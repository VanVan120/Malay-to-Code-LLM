{"text":"Check if the number is even or odd whose digits and base ( radix ) is given | Function that returns true if the number represented by arr [ ] is even in base r ; If the base is even , then the last digit is checked ; If base is odd , then the number of odd digits are checked ; To store the count of odd digits ; Number is odd ; Driver code","code":"< ? php function isEven ( $ arr , $ n , $ r ) { if ( $ r % 2 == 0 ) { if ( $ arr [ $ n - 1 ] % 2 == 0 ) return true ; } else { $ oddCount = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ arr [ $ i ] % 2 != 0 ) $ oddCount ++ ; } if ( $ oddCount % 2 == 0 ) return true ; } return false ; } $ arr = array ( 1 , 0 ) ; $ n = Count ( $ arr ) ; $ r = 2 ; if ( isEven ( $ arr , $ n , $ r ) ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text":"Rearrange the array to maximize the number of primes in prefix sum of the array | Function to print the re - arranged array ; Count the number of ones and twos in a [ ] ; If the array element is 1 ; Array element is 2 ; If it has at least one 2 Fill up first 2 ; Decrease the cnt of ones if even ; Fill up with odd count of ones ; Fill up with remaining twos ; If even ones , then fill last position ; Print the rearranged array ; Driver code","code":"< ? php function solve ( $ a , $ n ) { $ ones = 0 ; $ twos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ ones ++ ; else $ twos ++ ; } $ ind = 0 ; if ( $ twos ) $ a [ $ ind ++ ] = 2 ; $ evenOnes = ( $ ones % 2 == 0 ) ? true : false ; if ( $ evenOnes ) $ ones -= 1 ; for ( $ i = 0 ; $ i < $ ones ; $ i ++ ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ twos - 1 ; $ i ++ ) $ a [ $ ind ++ ] = 2 ; if ( $ evenOnes ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] , \" \u2581 \" ; } $ a = array ( 1 , 2 , 1 , 2 , 1 ) ; $ n = count ( $ a ) ; solve ( $ a , $ n ) ; ? >"}
{"text":"Generate an Array in which count of even and odd sum sub | Function to generate and print the required array ; Find the number of odd prefix sums ; If no odd prefix sum found ; Calculating the number of even prefix sums ; Stores the current prefix sum ; If current prefix sum is even ; Print 0 until e = EvenPreSums - 1 ; Print 1 when e = EvenPreSums ; Print 0 for rest of the values ; Driver code","code":"< ? php function CreateArray ( $ N , $ even , $ odd ) { $ temp = -1 ; $ OddPreSums = 0 ; for ( $ i = 0 ; $ i <= $ N + 1 ; $ i ++ ) { if ( $ i * ( ( $ N + 1 ) - $ i ) == $ odd ) { $ temp = 0 ; $ OddPreSums = $ i ; break ; } } if ( $ temp == -1 ) { echo temp ; } else { $ EvenPreSums = ( $ N + 1 ) - $ OddPreSums ; $ e = 1 ; $ o = 0 ; $ CurrSum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ CurrSum % 2 == 0 ) { if ( $ e < $ EvenPreSums ) { $ e ++ ; echo \"0 \u2581 \" ; } else { $ o ++ ; echo \"1 \u2581 \" ; $ CurrSum ++ ; } } else { if ( $ e < $ EvenPreSums ) { $ e ++ ; echo \"1 \u2581 \" ; $ CurrSum ++ ; } else { $ o ++ ; echo \"0 \u2581 \" ; } } } echo \" STRNEWLINE \" ; } } $ N = 15 ; $ even = 60 ; $ odd = 60 ; CreateArray ( $ N , $ even , $ odd ) ; ? >"}
{"text":"Choose X such that ( A xor X ) + ( B xor X ) is minimized | Function to return the integer X such that ( A xor X ) + ( B ^ X ) is minimized ; While either A or B is non - zero ; Position at which both A and B have a set bit ; Inserting a set bit in x ; Right shifting both numbers to traverse all the bits ; Driver code","code":"< ? php function findX ( $ A , $ B ) { $ j = 0 ; $ x = 0 ; while ( $ A $ B ) { if ( ( $ A & 1 ) && ( $ B & 1 ) ) { $ x += ( 1 << $ j ) ; } $ A >>= 1 ; $ B >>= 1 ; $ j += 1 ; } return $ x ; } $ A = 2 ; $ B = 3 ; $ X = findX ( $ A , $ B ) ; echo \" X = \" \u2581 , \u2581 $ X \u2581 , \u2581 \" , Sum = \" ( $ A ^ $ X ) + ( $ B ^ $ X ) ; ? >"}
{"text":"Compare sum of first N | Function that returns true if sum of first n - 1 elements of the array is equal to the last element ; Find the sum of first n - 1 elements of the array ; If sum equals to the last element ; Driver code","code":"< ? php function isSumEqual ( $ ar , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ sum += $ ar [ $ i ] ; if ( $ sum == $ ar [ $ n - 1 ] ) return true ; return false ; } $ arr = array ( 1 , 2 , 3 , 4 , 10 ) ; $ n = count ( $ arr ) ; if ( isSumEqual ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Count number of 1 s in the array after N moves | Function to count number of perfect squares ; Counting number of perfect squares between a and b ; Function to count number of 1 s in array after N moves ; Initialize array size ; Initialize all elements to 0","code":"< ? php function perfectSquares ( $ a , $ b ) { return ( floor ( sqrt ( $ b ) ) - ceil ( sqrt ( $ a ) ) + 1 ) ; } function countOnes ( $ arr , $ n ) { return perfectSquares ( 1 , $ n ) ; } $ N = 10 ; $ arr [ 10 ] = array ( 0 ) ; echo countOnes ( $ arr , $ N ) ; ? >"}
{"text":"Find the position of box which occupies the given ball | function to find the lower bound ; Function to print the position of each boxes where a ball has to be placed ; Find the cumulative sum of array A [ ] ; Find the position of box for each ball ; Row number ; Column ( position of box in particular row ) ; Row + 1 denotes row if indexing of array start from 1 ; Driver code","code":"< ? php function lower_bound ( $ A , $ valueTosearch ) { $ row = 0 ; foreach ( $ A as $ key = > $ value ) { if ( $ valueTosearch <= $ value ) return $ row ; $ row ++ ; } return $ row + 1 ; } function printPosition ( $ A , $ B , $ sizeOfA , $ sizeOfB ) { for ( $ i = 1 ; $ i < $ sizeOfA ; $ i ++ ) $ A [ $ i ] += $ A [ $ i - 1 ] ; for ( $ i = 0 ; $ i < $ sizeOfB ; $ i ++ ) { $ row = lower_bound ( $ A , $ B [ $ i ] ) ; $ boxNumber = ( $ row >= 1 ) ? $ B [ $ i ] - $ A [ $ row - 1 ] : $ B [ $ i ] ; print_r ( $ row +1 . \" , \u2581 \" . $ boxNumber ) ; echo \" STRNEWLINE \" ; } } $ A = array ( 2 , 2 , 2 , 2 ) ; $ B = array ( 1 , 2 , 3 , 4 ) ; $ sizeOfA = count ( $ A ) ; $ sizeOfB = count ( $ B ) ; printPosition ( $ A , $ B , $ sizeOfA , $ sizeOfB ) ; ? >"}
{"text":"Highest power of a number that divides other number | Function to get the prime factors and its count of times it divides ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , count i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to return the highest power ;  ; Get the prime factors of n and m ; Iterate and find the maximum power ; If i not a prime factor of n and m ; If i is a prime factor of n and m If count of i dividing m is more than i dividing n , then power will be 0 ; If i is a prime factor of M ; get the maximum power ; Drivers code","code":"< ? php function primeFactors ( $ n , $ freq ) { $ cnt = 0 ; while ( $ n % 2 == 0 ) { $ cnt ++ ; $ n = floor ( $ n \/ 2 ) ; } $ freq [ 2 ] = $ cnt ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { $ cnt = 0 ; while ( $ n % $ i == 0 ) { $ cnt ++ ; $ n = floor ( $ n \/ $ i ) ; } $ freq [ $ i ] = $ cnt ; } if ( $ n > 2 ) $ freq [ $ n ] = 1 ; return $ freq ; } function getMaximumPower ( $ n , $ m ) { ' ' ' Initialize two arrays ' ' ' $ freq1 = array_fill ( 0 , $ n + 1 , 0 ) ; $ freq2 = array_fill ( 0 , $ m + 1 , 0 ) ; $ freq1 = primeFactors ( $ n , $ freq1 ) ; $ freq2 = primeFactors ( $ m , $ freq2 ) ; $ maxi = 0 ; for ( $ i = 2 ; $ i <= $ m ; $ i ++ ) { if ( $ freq1 [ $ i ] == 0 && $ freq2 [ $ i ] == 0 ) continue ; if ( $ freq2 [ $ i ] > $ freq1 [ $ i ] ) return 0 ; if ( $ freq2 [ $ i ] ) { $ maxi = max ( $ maxi , floor ( $ freq1 [ $ i ] \/ $ freq2 [ $ i ] ) ) ; } } return $ maxi ; } $ n = 48 ; $ m = 4 ; echo getMaximumPower ( $ n , $ m ) ; ? >"}
{"text":"Find the number of divisors of all numbers in the range [ 1 , n ] | Function to find the number of divisors of all numbers in the range [ 1 , n ] ; Array to store the count of divisors ; For every number from 1 to n ; Increase divisors count for every number divisible by i ; Print the divisors ; Driver code","code":"< ? php function findDivisors ( $ n ) { $ div = array_fill ( 0 , $ n + 2 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j * $ i <= $ n ; $ j ++ ) $ div [ $ i * $ j ] ++ ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ div [ $ i ] , \" \u2581 \" ; } $ n = 10 ; findDivisors ( $ n ) ; ? >"}
{"text":"Predict the winner of the game on the basis of absolute difference of sum by selecting numbers | Function to decide the winner ; Iterate for all numbers in the array ; If mod gives 0 ; If mod gives 1 ; If mod gives 2 ; If mod gives 3 ; Check the winning condition for X ; Driver code","code":"< ? php function decideWinner ( $ a , $ n ) { $ count0 = 0 ; $ count1 = 0 ; $ count2 = 0 ; $ count3 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 4 == 0 ) $ count0 ++ ; else if ( $ a [ $ i ] % 4 == 1 ) $ count1 ++ ; else if ( $ a [ $ i ] % 4 == 2 ) $ count2 ++ ; else if ( $ a [ $ i ] % 4 == 3 ) $ count3 ++ ; } if ( $ count0 % 2 == 0 && $ count1 % 2 == 0 && $ count2 % 2 == 0 && $ count3 == 0 ) return 1 ; else return 2 ; } $ a = array ( 4 , 8 , 5 , 9 ) ; $ n = count ( $ a ) ; if ( decideWinner ( $ a , $ n ) == 1 ) echo \" X \u2581 wins \" ; else echo \" Y \u2581 wins \" ; ? >"}
{"text":"Count all prefixes of the given binary array which are divisible by x | Function to return the count of total binary prefix which are divisible by x ; Initialize with zero ; Instead of converting all prefixes to decimal , take reminder with x ; If number is divisible by x then reminder = 0 ; Driver code","code":"< ? php function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = ( $ number * 2 + $ arr [ $ i ] ) % $ x ; if ( $ number == 0 ) $ count1 += 1 ; } return $ count1 ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; $ x = 2 ; echo CntDivbyX ( $ arr , $ n , $ x ) ; ? >"}
{"text":"Length of the smallest number which is divisible by K and formed by using 1 's only | Function to return length of the resultant number ; If K is a multiple of 2 or 5 ; Instead of generating all possible numbers 1 , 11 , 111 , 111 , ... , K 1 's  Take remainder with K ; If number is divisible by k then remainder will be 0 ; Driver code","code":"< ? php function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = ( $ number * 10 + 1 ) % $ K ; if ( $ number == 0 ) return $ len ; } return -1 ; } $ K = 7 ; echo numLen ( $ K ) ; ? >"}
{"text":"Sum of multiplication of triplet of divisors of a number | PHP implementation of the approach ; Global array declaration ; Function to find the sum of multiplication of every triplet in the divisors of a number ; sum1 [ x ] represents the sum of all the divisors of x ; Adding i to sum1 [ j ] because i is a divisor of j ; sum2 [ x ] represents the sum of all the divisors of x ; Here i is divisor of j and sum1 [ j ] - i represents sum of all divisors of j which do not include i so we add i * ( sum1 [ j ] - i ) to sum2 [ j ] ; In the above implementation we have considered every pair two times so we have to divide every sum2 array element by 2 ; Here i is the divisor of j and we are trying to add the sum of multiplication of all triplets of divisors of j such that one of the divisors is i ; In the above implementation we have considered every triplet three times so we have to divide every sum3 array element by 3 ; Print the results ; Driver code ; Precomputing","code":"< ? php $ max_Element = 1005 ; $ sum1 = array_fill ( 0 , $ max_Element , 0 ) ; $ sum2 = array_fill ( 0 , $ max_Element , 0 ) ; $ sum3 = array_fill ( 0 , $ max_Element , 0 ) ; function precomputation ( $ arr , $ n ) { global $ max_Element , $ sum3 , $ sum2 , $ sum1 ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum1 [ $ j ] += $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum2 [ $ j ] += ( $ sum1 [ $ j ] - $ i ) * $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum2 [ $ i ] = ( int ) ( $ sum2 [ $ i ] \/ 2 ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum3 [ $ j ] += $ i * ( $ sum2 [ $ j ] - $ i * ( $ sum1 [ $ j ] - $ i ) ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum3 [ $ i ] = ( int ) ( $ sum3 [ $ i ] \/ 3 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ sum3 [ $ arr [ $ i ] ] . \" \u2581 \" ; } $ arr = array ( 9 , 5 , 6 ) ; $ n = count ( $ arr ) ; precomputation ( $ arr , $ n ) ; ? >"}
{"text":"Sum of Fibonacci Numbers in a range | Function to return the nth Fibonacci number ; Function to return the required sum ; Using our deduced result ; Driver code","code":"< ? php function fib ( $ n ) { $ phi = ( 1 + sqrt ( 5 ) ) \/ 2 ; return ( int ) round ( pow ( $ phi , $ n ) \/ sqrt ( 5 ) ) ; } function calculateSum ( $ l , $ r ) { $ sum = fib ( $ r + 2 ) - fib ( $ l + 1 ) ; return $ sum ; } $ l = 4 ; $ r = 8 ; echo ( calculateSum ( $ l , $ r ) ) ; ? >"}
{"text":"Print the balanced bracket expression using given brackets | Function to print balanced bracket expression if it is possible ; If the condition is met ; Print brackets of type - 1 ; Print brackets of type - 3 ; Print brackets of type - 4 ; Print brackets of type - 2 ; If the condition is not met ; Driver code","code":"< ? php function printBalancedExpression ( $ a , $ b , $ c , $ d ) { if ( ( $ a == $ d && $ a ) || ( $ a == 0 && $ c == 0 && $ d == 0 ) ) { for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) echo \" ( ( \" ; for ( $ i = 1 ; $ i <= $ c ; $ i ++ ) echo \" ) ( \" ; for ( $ i = 1 ; $ i <= $ d ; $ i ++ ) echo \" ) ) \" ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) echo \" ( ) \" ; } else echo - 1 ; } $ a = 3 ; $ b = 1 ; $ c = 4 ; $ d = 3 ; printBalancedExpression ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text":"Count numbers having N 0 ' s \u2581 and \u2581 and \u2581 M \u2581 1' s with no leading zeros | Function to return the factorial of a number ; Function to return the count of distinct ( N + M ) digit numbers having N 0 ' s \u2581 and \u2581 and \u2581 M \u2581 1' s with no leading zeros ; Driver code","code":"< ? php function factorial ( $ f ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ f ; $ i ++ ) $ fact *= $ i ; return $ fact ; } function findPermutation ( $ N , $ M ) { $ permutation = factorial ( $ N + $ M - 1 ) \/ ( factorial ( $ N ) * factorial ( $ M - 1 ) ) ; return $ permutation ; } $ N = 3 ; $ M = 3 ; echo findPermutation ( $ N , $ M ) ; ? >"}
{"text":"Maximum value of | arr [ 0 ] | Function to return the maximum required value ; Driver code","code":"< ? php function maxValue ( $ n ) { if ( $ n == 1 ) return 0 ; return ( ( $ n * $ n \/ 2 ) - 1 ) ; } $ n = 4 ; echo maxValue ( $ n ) ; ? >"}
{"text":"Count of a , b & c after n seconds for given reproduction rate | Function to print the count of a , b and c after n seconds ; Number of multiples of 60 below n ; Multiple of 60 nearest to n ; Change all a to b ; Change all b to c ; Change each c to two a ; Print the updated values of a , b and c ; Driver code","code":"< ? php function findCount ( $ n ) { $ a = 1 ; $ b = 0 ; $ c = 0 ; $ x = $ n \/ 60 ; $ a = pow ( 32 , $ x ) ; $ x = 60 * $ x ; for ( $ i = $ x + 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ b += $ a ; $ a = 0 ; } if ( $ i % 5 == 0 ) { $ c += $ b ; $ b = 0 ; } if ( $ i % 12 == 0 ) { $ a += ( 2 * $ c ) ; $ c = 0 ; } } echo ( \" a \u2581 = \u2581 \" . $ a . \" , b = \" \u2581 . \u2581 $ b \u2581 . \u2581 \" , c = \" } $ n = 72 ; findCount ( $ n ) ; ? >"}
{"text":"Find GCD of factorial of elements of given array | Implementation of factorial function ; Function to find GCD of factorial of elements from array ; find the minimum element of array ; return the factorial of minimum element ; Driver Code","code":"< ? php function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : factorial ( $ n - 1 ) * $ n ; } function gcdOfFactorial ( $ arr , $ n ) { $ minm = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ minm = $ minm > $ arr [ $ i ] ? $ arr [ $ i ] : $ minm ; return factorial ( $ minm ) ; } $ arr = array ( 9 , 12 , 122 , 34 , 15 ) ; $ n = count ( $ arr ) ; echo gcdOfFactorial ( $ arr , $ n ) ; ? >"}
{"text":"Sum of the series 1 ^ 1 + 2 ^ 2 + 3 ^ 3 + ... . . + n ^ n using recursion | Recursive function to return the sum of the given series ; 1 ^ 1 = 1 ; Recursive call ; Driver code","code":"< ? php function sum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( pow ( $ n , $ n ) + sum ( $ n - 1 ) ) ; } $ n = 2 ; echo ( sum ( $ n ) ) ; ? >"}
{"text":"Count permutations that are first decreasing then increasing . | PHP implementation of the above approach ; Function to compute a ^ n % mod ; Function to count permutations that are first decreasing and then increasing ; For n = 1 return 0 ; Calculate and return result ; Driver Code","code":"< ? php $ mod = 1000000007 ; function power ( $ a , $ n ) { global $ mod ; if ( $ n == 0 ) return 1 ; $ p = power ( $ a , $ n \/ 2 ) % $ mod ; $ p = ( $ p * $ p ) % $ mod ; if ( $ n & 1 ) $ p = ( $ p * $ a ) % $ mod ; return $ p ; } function countPermutations ( $ n ) { global $ mod ; if ( $ n == 1 ) { return 0 ; } return ( power ( 2 , $ n - 1 ) - 2 ) % $ mod ; } $ n = 5 ; echo countPermutations ( $ n ) ; ? >"}
{"text":"Find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . | Function to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Driver code","code":"< ? php function numbers ( $ n ) { return ( pow ( 2 , $ n + 1 ) ) - 2 ; } $ n = 2 ; echo numbers ( $ n ) ; ? >"}
{"text":"Ways to place 4 items in n ^ 2 positions such that no row \/ column contains more than one | Function to return the number of ways to place 4 items in n ^ 2 positions ; Driver code","code":"< ? php function NumberofWays ( $ n ) { $ x = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) \/ ( 4 * 3 * 2 * 1 ) ; $ y = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) ; return ( 1 * $ x * $ y ) ; } $ n = 4 ; echo NumberofWays ( $ n ) ; ? >"}
{"text":"Find Nth term of the series 1 , 6 , 18 , 40 , 75 , ... . | Function to generate a fixed number ; ( N ^ 2 * ( N + 1 ) ) \/ 2 ; Driver Code","code":"< ? php function nthTerm ( $ N ) { $ nth = 0 ; $ nth = ( $ N * $ N * ( $ N + 1 ) ) \/ 2 ; return $ nth ; } $ N = 5 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Print n numbers such that their sum is a perfect square | Function to prn numbers such that their sum is a perfect square ; Print ith odd number ; Driver code","code":"< ? php function findNumbers ( $ n ) { $ i = 1 ; while ( $ i <= $ n ) { echo ( ( 2 * $ i ) - 1 ) . \" \u2581 \" ; $ i ++ ; } } $ n = 3 ; findNumbers ( $ n ) ; ? >"}
{"text":"Missing even and odd elements from the given arrays | Function to find the missing numbers ; To store the minimum and the maximum odd and even elements from the arrays ; To store the sum of the array elements ; Get the minimum and the maximum even elements from the array ; Get the minimum and the maximum odd elements from the array ; To store the total terms in the series and the required sum of the array ; Total terms from 2 to minEven ; Sum of all even numbers from 2 to minEven ; Total terms from 2 to maxEven ; Sum of all even numbers from 2 to maxEven ; Required sum for the even array ; Missing even number ; Total terms from 1 to minOdd ; Sum of all odd numbers from 1 to minOdd ; Total terms from 1 to maxOdd ; Sum of all odd numbers from 1 to maxOdd ; Required sum for the odd array ; Missing odd number ; Driver code","code":"< ? php function findMissingNums ( $ even , $ sizeEven , $ odd , $ sizeOdd ) { $ minEven = PHP_INT_MAX ; $ maxEven = PHP_INT_MIN ; $ minOdd = PHP_INT_MAX ; $ maxOdd = PHP_INT_MIN ; $ sumEvenArr = $ sumOddArr = 0 ; for ( $ i = 0 ; $ i < $ sizeEven ; $ i ++ ) { $ minEven = min ( $ minEven , $ even [ $ i ] ) ; $ maxEven = max ( $ maxEven , $ even [ $ i ] ) ; $ sumEvenArr += $ even [ $ i ] ; } for ( $ i = 0 ; $ i < $ sizeOdd ; $ i ++ ) { $ minOdd = min ( $ minOdd , $ odd [ $ i ] ) ; $ maxOdd = max ( $ maxOdd , $ odd [ $ i ] ) ; $ sumOddArr += $ odd [ $ i ] ; } $ totalTerms = $ reqSum = 0 ; $ totalTerms = ( int ) ( $ minEven \/ 2 ) ; $ evenSumMin = $ totalTerms * ( $ totalTerms + 1 ) ; $ totalTerms = ( int ) ( $ maxEven \/ 2 ) ; $ evenSumMax = $ totalTerms * ( $ totalTerms + 1 ) ; $ reqSum = ( $ evenSumMax - $ evenSumMin + $ minEven ) ; echo \" Even = \" \u2581 . \u2581 ( $ reqSum \u2581 - \u2581 $ sumEvenArr ) \u2581 . \u2581 \" \" $ totalTerms = ( int ) ( ( $ minOdd \/ 2 ) + 1 ) ; $ oddSumMin = $ totalTerms * $ totalTerms ; $ totalTerms = ( int ) ( ( $ maxOdd \/ 2 ) + 1 ) ; $ oddSumMax = $ totalTerms * $ totalTerms ; $ reqSum = ( $ oddSumMax - $ oddSumMin + $ minOdd ) ; echo \" Odd = \" } $ even = array ( 6 , 4 , 8 , 14 , 10 ) ; $ sizeEven = count ( $ even ) ; $ odd = array ( 7 , 5 , 3 , 11 , 13 ) ; $ sizeOdd = count ( $ odd ) ; findMissingNums ( $ even , $ sizeEven , $ odd , $ sizeOdd ) ; ? >"}
{"text":"Minimum matches the team needs to win to qualify | Function to return the minimum number of matches to win to qualify for next round ; Do a binary search to find ; Find mid element ; Check for condition$ to qualify for next round ; Driver Code","code":"< ? php function findMinimum ( $ x , $ y ) { $ low = 0 ; $ high = $ y ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( ( $ mid * 2 + ( $ y - $ mid ) ) >= $ x ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return $ low ; } $ x = 6 ; $ y = 5 ; echo findMinimum ( $ x , $ y ) ; ? >"}
{"text":"Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | Function to return the sum of digits of x ; Function to return the count of required numbers ; If i is divisible by 2 and sum of digits of i is divisible by 3 ; Return the required count ; Driver code","code":"< ? php function sumOfDigits ( $ x ) { $ sum = 0 ; while ( $ x != 0 ) { $ sum += $ x % 10 ; $ x = $ x \/ 10 ; } return $ sum ; } function countNumbers ( $ l , $ r ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % 2 == 0 && sumOfDigits ( $ i ) % 3 == 0 ) $ count ++ ; } return $ count ; } $ l = 1000 ; $ r = 6000 ; echo countNumbers ( $ l , $ r ) ; ? >"}
{"text":"Sum of minimum element of all subarrays of a sorted array | Function to find the sum of minimum of all subarrays ; Driver code","code":"< ? php function findMinSum ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] * ( $ n - $ i ) ; return $ sum ; } $ arr = array ( 3 , 5 , 7 , 8 ) ; $ n = count ( $ arr ) ; echo findMinSum ( $ arr , $ n ) ; ? >"}
{"text":"Longest Sub | Function to return the max length of the sub - array that have the maximum average ( average value of the elements ) ; Finding the maximum value ; If consecutive maximum found ; Find the max length of consecutive max ; Driver code","code":"< ? php function maxLenSubArr ( $ a , $ n ) { $ cm = 1 ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max ) $ max = $ a [ $ i ] ; } for ( $ i = 0 ; $ i < $ n - 1 ; ) { $ count = 1 ; if ( $ a [ $ i ] == $ a [ $ i + 1 ] && $ a [ $ i ] == $ max ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] == $ max ) { $ count ++ ; $ i ++ ; } else break ; } if ( $ count > $ cm ) $ cm = $ count ; } else $ i ++ ; } return $ cm ; } $ arr = array ( 6 , 1 , 6 , 6 , 0 ) ; $ n = sizeof ( $ arr ) ; echo maxLenSubArr ( $ arr , $ n ) ; ? >"}
{"text":"Minimum possible sum of array elements after performing the given operation | Function to return the minimized sum ; To store the largest element from the array which is divisible by x ; Sum of array elements before performing any operation ; If current element is divisible by x and it is maximum so far ; Update the minimum element ; If no element can be reduced then there 's no point in performing the  operation as we will end up increasing  the sum when an element is multiplied by x ; Subtract the chosen elements from the sum and then add their updated values ; Return the minimized sum ; Driver code","code":"< ? php function minSum ( $ arr , $ n , $ x ) { $ sum = 0 ; $ largestDivisible = -1 ; $ minimum = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ arr [ $ i ] % $ x == 0 && $ largestDivisible < $ arr [ $ i ] ) $ largestDivisible = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minimum ) $ minimum = $ arr [ $ i ] ; } if ( $ largestDivisible == -1 ) return $ sum ; $ sumAfterOperation = $ sum - $ minimum - $ largestDivisible + ( $ x * $ minimum ) + ( $ largestDivisible \/ $ x ) ; return min ( $ sum , $ sumAfterOperation ) ; } $ arr = array ( 5 , 5 , 5 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; $ x = 3 ; print ( minSum ( $ arr , $ n , $ x ) ) ; ? >"}
{"text":"Maximum Bitwise AND pair from given range | Function to return the maximum bitwise AND possible among all the possible pairs ; If there is only a single value in the range [ L , R ] ; If there are only two values in the range [ L , R ] ; Driver code","code":"< ? php function maxAND ( $ L , $ R ) { if ( $ L == $ R ) return $ L ; else if ( ( $ R - $ L ) == 1 ) return ( $ R & $ L ) ; else { if ( ( ( $ R - 1 ) & $ R ) > ( ( $ R - 2 ) & ( $ R - 1 ) ) ) return ( ( $ R - 1 ) & $ R ) ; else return ( ( $ R - 2 ) & ( $ R - 1 ) ) ; } } $ L = 1 ; $ R = 632 ; echo maxAND ( $ L , $ R ) ; ? >"}
{"text":"Smallest Special Prime which is greater than or equal to a given number | Function to check whether the number is a special prime or not ; While number is not equal to zero ; If the number is not prime return false . ; Else remove the last digit by dividing the number by 10. ; If the number has become zero then the number is special prime , hence return true ; Function to find the Smallest Special Prime which is greater than or equal to a given number ; Initially all numbers are considered Primes . ; There is always an answer possible ; Checking if the number is a special prime or not ; If yes print the number and break the loop . ; Else increment the number . ; Driver code","code":"< ? php function checkSpecialPrime ( $ sieve , $ num ) { while ( $ num ) { if ( ! $ sieve [ $ num ] ) { return false ; } $ num = floor ( $ num \/ 10 ) ; } return true ; } function findSpecialPrime ( $ N ) { $ sieve = array_fill ( 0 , $ N * 10 , true ) ; $ sieve [ 0 ] = $ sieve [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ N * 10 ; $ i ++ ) { if ( $ sieve [ $ i ] ) { for ( $ j = $ i * $ i ; $ j <= $ N * 10 ; $ j += $ i ) { $ sieve [ $ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( $ sieve , $ N ) ) { echo $ N , \" STRNEWLINE \" ; break ; } else $ N ++ ; } } $ N = 379 ; findSpecialPrime ( $ N ) ; $ N = 100 ; findSpecialPrime ( $ N ) ; ? >"}
{"text":"Minimum number of given moves required to make N divisible by 25 | Function to return the minimum number of moves required to make n divisible by 25 ; Convert number into string ; To store required answer ; Length of the string ; To check all possible pairs ; Make a duplicate string ; Number of swaps required to place ith digit in last position ; Number of swaps required to place jth digit in 2 nd last position ; Find first non zero digit ; Place first non zero digit in the first position ; Convert string to number ; If this number is divisible by 25 then cur is one of the possible answer ; If not possible ; Driver code","code":"< ? php function minMoves ( $ n ) { $ s = strval ( $ n ) ; $ ans = PHP_INT_MAX ; $ len = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { for ( $ j = 0 ; $ j < $ len ; ++ $ j ) { if ( $ i == $ j ) continue ; $ t = $ s ; $ cur = 0 ; for ( $ k = $ i ; $ k < $ len - 1 ; ++ $ k ) { $ e = $ t [ $ k ] ; $ t [ $ k ] = $ t [ $ k + 1 ] ; $ t [ $ k + 1 ] = $ e ; ++ $ cur ; } for ( $ k = $ j - ( $ j > $ i ) ; $ k < $ len - 2 ; ++ $ k ) { $ e = $ t [ $ k ] ; $ t [ $ k ] = $ t [ $ k + 1 ] ; $ t [ $ k + 1 ] = $ e ; ++ $ cur ; } $ pos = -1 ; for ( $ k = 0 ; $ k < $ len ; ++ $ k ) { if ( $ t [ $ k ] != '0' ) { $ pos = $ k ; break ; } } for ( $ k = $ pos ; $ k > 0 ; -- $ k ) { $ e = $ t [ $ k ] ; $ t [ $ k ] = $ t [ $ k + 1 ] ; $ t [ $ k + 1 ] = $ e ; ++ $ cur ; } $ nn = intval ( $ t ) ; if ( $ nn % 25 == 0 ) $ ans = min ( $ ans , $ cur ) ; } } if ( $ ans == PHP_INT_MAX ) return -1 ; return $ ans ; } $ n = 509201 ; echo minMoves ( $ n ) ; ? >"}
{"text":"Maximum positive integer divisible by C and is in the range [ A , B ] | Function to return the required number ; If b % c = 0 then b is the required number ; Else get the maximum multiple of c smaller than b ; Driver code","code":"< ? php function getMaxNum ( $ a , $ b , $ c ) { if ( $ b % $ c == 0 ) return $ b ; $ x = ( ( int ) ( $ b \/ $ c ) * $ c ) ; if ( $ x >= $ a && $ x <= $ b ) return $ x ; else return -1 ; } $ a = 2 ; $ b = 10 ; $ c = 3 ; echo ( getMaxNum ( $ a , $ b , $ c ) ) ; ? >"}
{"text":"Count the total number of squares that can be visited by Bishop in one move | Function to return the count of total positions the Bishop can visit in a single move ; Count top left squares ; Count bottom right squares ; Count top right squares ; Count bottom left squares ; Return total count ; Bishop 's Position","code":"< ? php function countSquares ( $ row , $ column ) { $ topLeft = min ( $ row , $ column ) - 1 ; $ bottomRight = 8 - max ( $ row , $ column ) ; $ topRight = min ( $ row , 9 - $ column ) - 1 ; $ bottomLeft = 8 - max ( $ row , 9 - $ column ) ; return ( $ topLeft + $ topRight + $ bottomRight + $ bottomLeft ) ; } $ row = 4 ; $ column = 4 ; echo countSquares ( $ row , $ column ) ; ? >"}
{"text":"Check whether Bishop can take down Pawn or not | Function that return true if the Bishop can take down the pawn ; If pawn is at angle 45 or 225 degree from bishop 's Position ; If pawn is at angle 135 or 315 degree from bishop 's Position ; Bishop 's Position ; Pawn 's Position","code":"< ? php function canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) { if ( $ pawnX - $ bishopX == $ pawnY - $ bishopY ) return true ; else if ( - $ pawnX + $ bishopX == $ pawnY - $ bishopY ) return true ; else return false ; } $ bishopX = 5 ; $ bishopY = 5 ; $ pawnX = 1 ; $ pawnY = 1 ; if ( canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find maximum operations to reduce N to 1 | PHP program to find maximum number moves possible ; To store number of prime factors of each number ; Function to find number of prime factors of each number ; if i is a prime number ; increase value by one from it 's preveious multiple ; make prefix sum this will be helpful for multiple test cases ; Generate primeFactors array ; required answer","code":"< ? php $ N = 10005 ; $ primeFactors = array_fill ( 0 , $ N , 0 ) ; function findPrimeFactors ( ) { global $ N , $ primeFactors ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ primeFactors [ $ i ] == 0 ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) $ primeFactors [ $ j ] = $ primeFactors [ ( int ) ( $ j \/ $ i ) ] + 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ primeFactors [ $ i ] += $ primeFactors [ $ i - 1 ] ; } findPrimeFactors ( ) ; $ a = 6 ; $ b = 3 ; print ( ( $ primeFactors [ $ a ] - $ primeFactors [ $ b ] ) ) ; ? >"}
{"text":"Smallest integer with digit sum M and multiple of N | Function to return digit sum ; Function to find out the smallest integer ; Start of the iterator ( Smallest multiple of n ) ; Driver code","code":"< ? php function digitSum ( $ n ) { $ ans = 0 ; while ( $ n ) { $ ans += $ n % 10 ; $ n \/= 10 ; } return $ ans ; } function findInt ( $ n , $ m ) { $ minDigit = floor ( $ m \/ 9 ) ; $ start = pow ( 10 , $ minDigit ) - ( int ) pow ( 10 , $ minDigit ) % $ n ; while ( $ start < PHP_INT_MAX ) { if ( digitSum ( $ start ) == $ m ) return $ start ; else $ start += $ n ; } return -1 ; } $ n = 13 ; $ m = 32 ; echo findInt ( $ n , $ m ) ; # This  code is contributed by ajit. NEW_LINE ? >"}
{"text":"Maximum sum after repeatedly dividing N by a divisor | Function to find the smallest divisor ; Function to find the maximum sum ; Driver Code","code":"< ? php function smallestDivisor ( $ n ) { $ mx = sqrt ( $ n ) ; for ( $ i = 2 ; $ i <= $ mx ; $ i ++ ) if ( $ n % $ i == 0 ) return $ i ; return $ n ; } function maxSum ( $ n ) { $ res = $ n ; while ( $ n > 1 ) { $ divi = smallestDivisor ( $ n ) ; $ n \/= $ divi ; $ res += $ n ; } return $ res ; } $ n = 34 ; echo maxSum ( $ n ) ; #This  code is contributed by akt_mit. NEW_LINE ? >"}
{"text":"Make all elements of an array equal with the given operation | Function that returns true if all the elements of the array can be made equal with the given operation ; To store the sum of the array elements and the maximum element from the array ; Driver code","code":"< ? php function isPossible ( $ n , $ k , $ arr ) { $ sum = $ arr [ 0 ] ; $ maxVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ maxVal = max ( $ maxVal , $ arr [ $ i ] ) ; } if ( ( float ) $ maxVal > ( float ) ( $ sum + $ k ) \/ $ n ) return false ; return true ; } $ k = 8 ; $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; if ( isPossible ( $ n , $ k , $ arr ) ) echo \" Yes \" ; else echo \" No \" ; # This  code is contributed by akt_miit. NEW_LINE ? >"}
{"text":"Maximize the value of x + y + z such that ax + by + cz = n | Function to return the maximum value of ( x + y + z ) such that ( ax + by + cz = n ) ; i represents possible values of a * x ; j represents possible values of b * y ; If z is an integer ; Driver code ; Function Call","code":"< ? php function maxResult ( $ n , $ a , $ b , $ c ) { $ maxVal = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += $ a ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j += $ b ) { $ z = ( $ n - ( $ i + $ j ) ) \/ $ c ; if ( floor ( $ z ) == ceil ( $ z ) ) { $ x = ( int ) ( $ i \/ $ a ) ; $ y = ( int ) ( $ j \/ $ b ) ; $ maxVal = max ( $ maxVal , $ x + $ y + ( int ) $ z ) ; } } return $ maxVal ; } $ n = 10 ; $ a = 5 ; $ b = 3 ; $ c = 4 ; echo maxResult ( $ n , $ a , $ b , $ c ) ; ? >"}
{"text":"Make all numbers of an array equal | Function that returns true if all the array elements can be made equal with the given operation ; Divide number by 2 ; Divide number by 3 ; Driver code","code":"< ? php function EqualNumbers ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ a [ $ i ] % 2 == 0 ) $ a [ $ i ] \/= 2 ; while ( $ a [ $ i ] % 3 == 0 ) $ a [ $ i ] \/= 3 ; if ( $ a [ $ i ] != $ a [ 0 ] ) { return false ; } } return true ; } $ a = array ( 50 , 75 , 150 ) ; $ n = sizeof ( $ a ) \/ sizeof ( $ a [ 0 ] ) ; if ( EqualNumbers ( $ a , $ n ) ) echo \" Yes \" ; else echo \" No \" ; #This  code is contributed by ajit.. NEW_LINE ? >"}
{"text":"Maximum GCD from Given Product of Unknowns | Function to return the required gcd ; Count the number of times 2 divides p ; Equivalent to p = p \/ 2 ; ; If 2 divides p ; Check all the possible numbers that can divide p ; If n in the end is a prime number ; Return the required gcd ; Driver code","code":"< ? php function max_gcd ( $ n , $ p ) { $ count = 0 ; $ gcd = 1 ; while ( $ p % 2 == 0 ) { $ p >>= 1 ; $ count ++ ; } if ( $ count > 0 ) $ gcd *= pow ( 2 , ( int ) ( $ count \/ $ n ) ) ; for ( $ i = 3 ; $ i <= ( int ) sqrt ( $ p ) ; $ i += 2 ) { $ count = 0 ; while ( $ p % $ i == 0 ) { $ count ++ ; $ p = ( int ) ( $ p \/ $ i ) ; } if ( $ count > 0 ) { $ gcd *= pow ( $ i , ( int ) ( $ count \/ $ n ) ) ; } } if ( $ p > 2 ) $ gcd *= pow ( $ p , ( int ) ( 1 \/ $ n ) ) ; return $ gcd ; } $ n = 3 ; $ p = 80 ; echo ( max_gcd ( $ n , $ p ) ) ;"}
{"text":"Minimum positive integer divisible by C and is not in range [ A , B ] | Function to return the required number ; If doesn 't belong to the range  then c is the required number ; Else get the next multiple of c starting from b + 1 ; Driver code","code":"< ? php function getMinNum ( $ a , $ b , $ c ) { if ( $ c < $ a $ c > $ b ) return $ c ; $ x = ( floor ( ( $ b \/ $ c ) ) * $ c ) + $ c ; return $ x ; } $ a = 2 ; $ b = 4 ; $ c = 4 ; echo getMinNum ( $ a , $ b , $ c ) ; ? >"}
{"text":"Count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | Function to return the count of required pairs ; Special case ; Number which will give the max value . for ( ( n % i ) % j ) % n ; To store the maximum possible value of ( ( n % i ) % j ) % n ; Count of possible pairs ; Driver code","code":"< ? php function countPairs ( $ n ) { if ( $ n == 2 ) return 4 ; $ num = ( ( int ) ( $ n \/ 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = ( $ n - $ max ) ; return $ count ; } $ n = 5 ; echo ( countPairs ( $ n ) ) ; ? >"}
{"text":"Remove characters from a numeric string such that string becomes divisible by 8 | Function that return true if sub is a sub - sequence in s ; Function to return a multiple of 8 formed after removing 0 or more characters from the given string ; Iterate over all multiples of 8 ; If current multiple exists as a subsequence in the given string ; Driver Code","code":"< ? php function checkSub ( $ sub , $ s ) { $ j = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) if ( $ sub [ $ j ] == $ s [ $ i ] ) $ j ++ ; return $ j == strlen ( $ sub ) ; } function getMultiple ( $ s ) { for ( $ i = 0 ; $ i < 1e3 ; $ i += 8 ) { if ( checkSub ( ( string ) ( $ i ) , $ s ) ) return $ i ; } return -1 ; } $ s = \"3454\" ; echo getMultiple ( $ s ) ;"}
{"text":"Program to find sum of harmonic series | PHP program to find sum of harmonic series using recursion ; Base condition ; Driver Code","code":"< ? php function sum ( $ n ) { if ( $ n < 2 ) return 1 ; else return 1 \/ $ n + ( sum ( $ n - 1 ) ) ; } echo sum ( 8 ) . \" STRNEWLINE \" ; echo sum ( 10 ) ; ? >"}
{"text":"Sum of P terms of an AP if Mth and Nth terms are given | Function to calculate the value of the ; Calculate value of d using formula ; Calculate value of a using formula ; Return pair ; Function to calculate value sum of first p numbers of the series ; First calculate value of a and d ; Calculate the sum by using formula ; Return the sum ; Driver Code","code":"< ? php function findingValues ( $ m , $ n , $ mth , $ nth ) { $ d = ( abs ( $ mth - $ nth ) ) \/ abs ( ( $ m - 1 ) - ( $ n - 1 ) ) ; $ a = $ mth - ( ( $ m - 1 ) * $ d ) ; return array ( $ a , $ d ) ; } function findSum ( $ m , $ n , $ mth , $ nth , $ p ) { $ ad = findingValues ( $ m , $ n , $ mth , $ nth ) ; $ a = $ ad [ 0 ] ; $ d = $ ad [ 1 ] ; $ sum = ( $ p * ( 2 * $ a + ( $ p - 1 ) * $ d ) ) \/ 2 ; return $ sum ; } $ m = 6 ; $ n = 10 ; $ mTerm = 12 ; $ nTerm = 20 ; $ p = 5 ; echo findSum ( $ m , $ n , $ mTerm , $ nTerm , $ p ) ; ? >"}
{"text":"Print all integers that are sum of powers of two given numbers | Function to print powerful integers ; Set is used to store distinct numbers in sorted order ; Store all the powers of y < bound in a vector to avoid calculating them again and again ; x ^ i ; If num is within limits insert it into the set ; Break out of the inner loop ; Adding any number to it will be out of bounds ; Increment i ; Print the contents of the set ; Driver code ; Print powerful integers","code":"< ? php function powerfulIntegers ( $ x , $ y , $ bound ) { $ s = array ( ) ; $ powersOfY = array ( ) ; array_push ( $ powersOfY , 1 ) ; $ i = $ y ; while ( $ i < $ bound && $ y != 1 ) { array_push ( $ powersOfY , $ i ) ; $ i *= $ y ; } $ i = 0 ; while ( true ) { $ xPowI = pow ( $ x , $ i ) ; for ( $ j = 0 ; $ j < count ( $ powersOfY ) ; $ j ++ ) { $ num = $ xPowI + $ powersOfY [ $ j ] ; if ( $ num <= $ bound ) array_push ( $ s , $ num ) ; else break ; } if ( $ xPowI >= $ bound $ x == 1 ) break ; $ i += 1 ; } $ s = array_unique ( $ s ) ; sort ( $ s ) ; foreach ( $ s as & $ itr ) print ( $ itr . \" \" ) ; } $ x = 2 ; $ y = 3 ; $ bound = 10 ; powerfulIntegers ( $ x , $ y , $ bound ) ; ? >"}
{"text":"Distribute N candies among K people | Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Last term of last and current series ; Sum of current and last series ; Sum of current series only ; If sum of current is less than N ; else Individually distribute ; First term ; Distribute candies till there ; Candies available ; Not available ; Count the total candies ; Print the total candies ; Driver Code","code":"< ? php function candies ( $ n , $ k ) { $ count = 0 ; $ ind = 1 ; $ arr = array_fill ( 0 , $ k , 0 ) ; while ( $ n ) { $ f1 = ( $ ind - 1 ) * $ k ; $ f2 = $ ind * $ k ; $ sum1 = floor ( ( $ f1 * ( $ f1 + 1 ) ) \/ 2 ) ; $ sum2 = floor ( ( $ f2 * ( $ f2 + 1 ) ) \/ 2 ) ; $ res = $ sum2 - $ sum1 ; if ( $ res <= $ n ) { $ count ++ ; $ n -= $ res ; $ ind ++ ; } { $ i = 0 ; $ term = ( ( $ ind - 1 ) * $ k ) + 1 ; while ( $ n > 0 ) { if ( $ term <= $ n ) { $ arr [ $ i ++ ] = $ term ; $ n -= $ term ; $ term ++ ; } else { $ arr [ $ i ++ ] = $ n ; $ n = 0 ; } } } } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ arr [ $ i ] += floor ( ( $ count * ( $ i + 1 ) ) + ( $ k * ( $ count * ( $ count - 1 ) ) \/ 2 ) ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ n = 10 ; $ k = 3 ; candies ( $ n , $ k ) ; ? >"}
{"text":"Distribute N candies among K people | Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Do a binary search to find the number whose sum is less than N . ; Get mide ; If sum is below N ; Find number of complete turns ; Right halve ; Left halve ; Last term of last complete series ; Subtract the sum till ; First term of incomplete series ; Count the total candies ; Print the total candies ; Driver Code","code":"< ? php function candies ( $ n , $ k ) { $ count = 0 ; $ ind = 1 ; $ arr = array_fill ( 0 , $ k , 0 ) ; $ low = 0 ; $ high = $ n ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; $ sum = ( $ mid * ( $ mid + 1 ) ) >> 1 ; if ( $ sum <= $ n ) { $ count = ( int ) ( $ mid \/ $ k ) ; $ low = $ mid + 1 ; } else { $ high = $ mid - 1 ; } } $ last = ( $ count * $ k ) ; $ n -= ( int ) ( ( $ last * ( $ last + 1 ) ) \/ 2 ) ; $ i = 0 ; $ term = ( $ count * $ k ) + 1 ; while ( $ n ) { if ( $ term <= $ n ) { $ arr [ $ i ++ ] = $ term ; $ n -= $ term ; $ term ++ ; } else { $ arr [ $ i ] += $ n ; $ n = 0 ; } } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ arr [ $ i ] += ( $ count * ( $ i + 1 ) ) + ( int ) ( $ k * ( $ count * ( $ count - 1 ) ) \/ 2 ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ n = 7 ; $ k = 4 ; candies ( $ n , $ k ) ; ? >"}
{"text":"Smallest multiple of 3 which consists of three given non | Function to return the minimum number divisible by 3 formed by the given digits ; Sort the given array in ascending ; Check if any single digit is divisible by 3 ; Check if any two digit number formed by the given digits is divisible by 3 starting from the minimum ; Generate the two digit number ; If none of the above is true , we can form three digit number by taking a [ 0 ] three times . ; Driver code","code":"< ? php function printSmallest ( $ a ) { sort ( $ a ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { if ( $ a [ $ i ] % 3 == 0 ) return $ a [ $ i ] ; } for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { $ num = ( $ a [ $ i ] * 10 ) + $ a [ $ j ] ; if ( $ num % 3 == 0 ) return $ num ; } } return $ a [ 0 ] * 100 + $ a [ 0 ] * 10 + $ a [ 0 ] ; } $ arr = array ( 7 , 7 , 1 ) ; echo printSmallest ( $ arr ) ; ? >"}
{"text":"Print matrix after applying increment operations in M ranges | Function to update and print the matrix after performing queries ; Add 1 to the first element of the sub - matrix ; If there is an element after the last element of the sub - matrix then decrement it by 1 ; Calculate the running sum ; Print the updated element ; Next line ; Size of the matrix ; Queries","code":"< ? php function updateMatrix ( $ n , $ q , $ mat ) { for ( $ i = 0 ; $ i < sizeof ( $ q ) ; $ i ++ ) { $ X1 = $ q [ $ i ] [ 0 ] ; $ Y1 = $ q [ $ i ] [ 1 ] ; $ X2 = $ q [ $ i ] [ 2 ] ; $ Y2 = $ q [ $ i ] [ 3 ] ; $ mat [ $ X1 ] [ $ Y1 ] ++ ; if ( $ Y2 + 1 < $ n ) $ mat [ $ X2 ] [ $ Y2 + 1 ] -- ; else if ( $ X2 + 1 < $ n ) $ mat [ $ X2 + 1 ] [ 0 ] -- ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ sum += $ mat [ $ i ] [ $ j ] ; echo ( $ sum . \" \" ) ; } echo ( \" STRNEWLINE \" ) ; } } $ n = 5 ; $ mat = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; $ q = array ( array ( 0 , 0 , 1 , 2 ) , array ( 1 , 2 , 3 , 4 ) , array ( 1 , 4 , 3 , 4 ) ) ; updateMatrix ( $ n , $ q , $ mat ) ; ? >"}
{"text":"Replace the maximum element in the array by coefficient of range | Utility function to print the contents of the array ; Function to replace the maximum element from the array with the coefficient of range of the array ; Maximum element from the array ; Minimum element from the array ; Calculate the coefficient of range for the array ; Assuming all the array elements are distinct . Replace the maximum element with the coefficient of range of the array ; Print the updated array ; Driver code","code":"< ? php function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } function replaceMax ( $ arr , $ n ) { $ max = max ( $ arr ) ; $ min = min ( $ arr ) ; $ range = $ max - $ min ; $ coeffOfRange = round ( $ range \/ ( $ max + $ min ) , 6 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ max ) { $ arr [ $ i ] = $ coeffOfRange ; break ; } } printArr ( $ arr , $ n ) ; } $ arr = array ( 15 , 16 , 10 , 9 , 6 , 7 , 17 ) ; $ n = count ( $ arr ) ; replaceMax ( $ arr , $ n ) ; ? >"}
{"text":"Divide the two given numbers by their common divisors | print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; divide A and B by their common factors","code":"< ? php function divide ( $ a , $ b ) { for ( $ i = 2 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) { while ( $ a % $ i == 0 && $ b % $ i == 0 ) { $ a = $ a \/ $ i ; $ b = $ b \/ $ i ; } } echo \" A = \" , \u2581 $ a , \u2581 \" , B = \" , \u2581 $ b , \u2581 \" \" } $ A = 10 ; $ B = 15 ; divide ( $ A , $ B ) ; ? >"}
{"text":"Divide the two given numbers by their common divisors | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function commDiv ( $ a , $ b ) { $ n = gcd ( $ a , $ b ) ; $ a = ( int ) ( $ a \/ $ n ) ; $ b = ( int ) ( $ b \/ $ n ) ; echo \" A = \" \u2581 . \u2581 $ a \u2581 . STRNEWLINE TABSYMBOL TABSYMBOL \" , B = \" \u2581 . \u2581 $ b \u2581 . \u2581 \" \" } $ a = 10 ; $ b = 15 ; commDiv ( $ a , $ b ) ; ? >"}
{"text":"Minimum absolute difference between N and a power of 2 | Function to return the minimum difference between N and a power of 2 ; Power of 2 closest to n on its left ; Power of 2 closest to n on its right ; Return the minimum abs difference ; Driver code","code":"< ? php function minAbsDiff ( $ n ) { $ left = 1 << ( ( floor ( log ( $ n ) \/ log ( 2 ) ) ) ) ; $ right = $ left * 2 ; return min ( ( $ n - $ left ) , ( $ right - $ n ) ) ; } $ n = 15 ; echo minAbsDiff ( $ n ) ; ? >"}
{"text":"Find probability that a player wins when probabilities of hitting the target are given | Function to return the probability of the winner ; Driver Code ; Will print 9 digits after the decimal point","code":"< ? php function find_probability ( $ p , $ q , $ r , $ s ) { $ t = ( 1 - $ p \/ $ q ) * ( 1 - $ r \/ $ s ) ; $ ans = ( $ p \/ $ q ) \/ ( 1 - $ t ) ; return $ ans ; } $ p = 1 ; $ q = 2 ; $ r = 1 ; $ s = 2 ; $ res = find_probability ( $ p , $ q , $ r , $ s ) ; $ update = number_format ( $ res , 7 ) ; echo $ update ; ? >"}
{"text":"Represent n as the sum of exactly k powers of two | Set 2 | Function to print k numbers which are powers of two and whose sum is equal to n ; Initialising the sum with k ; Initialising an array A with k elements and filling all elements with 1 ; Iterating A [ ] from k - 1 to 0 ; Update sum and A [ i ] till sum + A [ i ] is less than equal to n ; Impossible to find the combination ; Possible solution is stored in A [ ] ; Driver code","code":"< ? php function FindAllElements ( $ n , $ k ) { $ sum = $ k ; $ A = array_fill ( 0 , $ k , 1 ) ; for ( $ i = $ k - 1 ; $ i >= 0 ; -- $ i ) { while ( $ sum + $ A [ $ i ] <= $ n ) { $ sum += $ A [ $ i ] ; $ A [ $ i ] *= 2 ; } } if ( $ sum != $ n ) { echo \" Impossible \" ; } else { for ( $ i = 0 ; $ i < $ k ; ++ $ i ) echo $ A [ $ i ] , ' \u2581 ' ; } } $ n = 12 ; $ k = 6 ; FindAllElements ( $ n , $ k ) ; ? >"}
{"text":"Check whether a + b = c or not after removing all zeroes from a , b and c | Function to remove zeroes ; Initialize result to zero holds the Result after removing zeroes from no ; Initialize variable d to 1 that holds digits of no ; Loop while n is greater then zero ; Check if n mod 10 is not equal to zero ; store the result by removing zeroes and increment d by 10 ; Go to the next digit ; Return the result ; Function to check if sum is true after Removing all zeroes . ; Call removeZero ( ) for both sides and check whether they are equal After removing zeroes . ; Driver code","code":"< ? php function removeZero ( $ n ) { $ res = 0 ; $ d = 1 ; while ( $ n > 0 ) { if ( $ n % 10 != 0 ) { $ res += ( $ n % 10 ) * $ d ; $ d *= 10 ; } $ n = floor ( $ n \/ 10 ) ; } return $ res ; } function isEqual ( $ a , $ b ) { if ( removeZero ( $ a ) + removeZero ( $ b ) == removeZero ( $ a + $ b ) ) return true ; return false ; } $ a = 105 ; $ b = 106 ; if ( isEqual ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"A Sum Array Puzzle | PHP implementation of above approach ; Allocate memory for temporary arrays leftSum [ ] , rightSum [ ] and Sum [ ] ; Left most element of left array is always 0 ; Rightmost most element of right array is always 0 ; Construct the left array ; Construct the right array ; Construct the sum array using left [ ] and right [ ] ; print the constructed prod array ; Driver Code","code":"< ? php function sumArray ( $ arr , $ n ) { $ leftSum = array_fill ( 0 , $ n , 0 ) ; $ rightSum = array_fill ( 0 , $ n , 0 ) ; $ Sum = array_fill ( 0 , $ n , 0 ) ; $ leftSum [ 0 ] = 0 ; $ rightSum [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ leftSum [ $ i ] = $ arr [ $ i - 1 ] + $ leftSum [ $ i - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ rightSum [ $ j ] = $ arr [ $ j + 1 ] + $ rightSum [ $ j + 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ Sum [ $ i ] = $ leftSum [ $ i ] + $ rightSum [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ Sum [ $ i ] . \" \u2581 \" ; } $ arr = array ( 3 , 6 , 4 , 8 , 9 ) ; $ n = count ( $ arr ) ; sumArray ( $ arr , $ n ) ; ? >"}
{"text":"Find minimum x such that ( x % k ) * ( x \/ k ) == n | Set | Function gives the required answer ; Iterate for all the factors ; Check if i is a factor ; Consider i to be A and n \/ i to be B ; Consider i to be B and n \/ i to be A ; Driver Code","code":"< ? php function minimumX ( $ n , $ k ) { $ mini = PHP_INT_MAX ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ fir = $ i ; $ sec = ( int ) $ n \/ $ i ; $ num1 = $ fir * $ k + $ sec ; $ res = ( int ) ( $ num1 \/ $ k ) * ( $ num1 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num1 , $ mini ) ; $ num2 = $ sec * $ k + $ fir ; $ res = ( int ) ( $ num2 \/ $ k ) * ( $ num2 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num2 , $ mini ) ; } } return $ mini ; } $ n = 4 ; $ k = 6 ; echo minimumX ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 5 ; $ k = 5 ; echo minimumX ( $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find minimum x such that ( x % k ) * ( x \/ k ) == n | This function gives the required answer ; Iterate over all possible remainders ; it must divide n ; Driver Code","code":"< ? php function minimumX ( $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ rem = $ k - 1 ; $ rem > 0 ; $ rem -- ) { if ( $ n % $ rem == 0 ) $ ans = min ( $ ans , $ rem + ( $ n \/ $ rem ) * $ k ) ; } return $ ans ; } $ n = 4 ; $ k = 6 ; echo minimumX ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 5 ; $ k = 5 ; echo minimumX ( $ n , $ k ) ; ? >"}
{"text":"Find nth Hermite number | Function to return nth Hermite number ; Base conditions ; Driver Code ; Print nth Hermite number","code":"< ? php function getHermiteNumber ( $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 0 ; else return -2 * ( $ n - 1 ) * getHermiteNumber ( $ n - 2 ) ; } $ n = 6 ; echo getHermiteNumber ( $ n ) ; ? >"}
{"text":"Find numbers a and b that satisfy the given conditions | Function to print the required numbers ; Suppose b = n and we want a % b = 0 and also ( a \/ b ) < n so a = b * ( n - 1 ) ; Special case if n = 1 we get a = 0 so ( a * b ) < n ; If no pair satisfies the conditions ; Driver code","code":"< ? php function find ( $ n ) { $ b = $ n ; $ a = $ b * ( $ n - 1 ) ; if ( $ a * $ b > $ n && $ a \/ $ b < $ n ) { echo \" a = \" \u2581 , \u2581 $ a \u2581 , \u2581 \" , b = \" } else echo - 1 ; } $ n = 10 ; find ( $ n ) ; ? >"}
{"text":"Closest perfect square and its distance | Function to check if a number is perfect square or not ; Function to find the closest perfect square taking minimum steps to reach from a number ; Variables to store first perfect square number above and below N ; Finding first perfect square number greater than N ; Finding first perfect square number less than N ; Variables to store the differences ; Driver code","code":"< ? php function isPerfect ( $ N ) { if ( ( sqrt ( $ N ) - floor ( sqrt ( $ N ) ) ) != 0 ) return false ; return true ; } function getClosestPerfectSquare ( $ N ) { if ( isPerfect ( $ N ) ) { echo $ N , \" \u2581 \" , \"0\" , \" STRNEWLINE \" ; return ; } $ aboveN = -1 ; $ belowN = -1 ; $ n1 ; $ n1 = $ N + 1 ; while ( true ) { if ( isPerfect ( $ n1 ) ) { $ aboveN = $ n1 ; break ; } else $ n1 ++ ; } $ n1 = $ N - 1 ; while ( true ) { if ( isPerfect ( $ n1 ) ) { $ belowN = $ n1 ; break ; } else $ n1 -- ; } $ diff1 = $ aboveN - $ N ; $ diff2 = $ N - $ belowN ; if ( $ diff1 > $ diff2 ) echo $ belowN , \" \u2581 \" , $ diff2 ; else echo $ aboveN , \" \u2581 \" , $ diff1 ; } $ N = 1500 ; getClosestPerfectSquare ( $ N ) ; ? >"}
{"text":"Fraction | Function to return gcd of a and b ; Function to convert the obtained fraction into it 's simplest form ; Finding gcd of both terms ; Converting both terms into simpler terms by dividing them by common factor ; Function to add two fractions ; Finding gcd of den1 and den2 ; Denominator of final fraction obtained finding LCM of den1 and den2 LCM * GCD = a * b ; Changing the fractions to have same denominator Numerator of the final fraction obtained ; Calling function to convert final fraction into it 's  simplest form ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function lowest ( & $ den3 , & $ num3 ) { $ common_factor = gcd ( $ num3 , $ den3 ) ; $ den3 = ( int ) $ den3 \/ $ common_factor ; $ num3 = ( int ) $ num3 \/ $ common_factor ; } function addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , & $ num3 , & $ den3 ) { $ den3 = gcd ( $ den1 , $ den2 ) ; $ den3 = ( $ den1 * $ den2 ) \/ $ den3 ; $ num3 = ( $ num1 ) * ( $ den3 \/ $ den1 ) + ( $ num2 ) * ( $ den3 \/ $ den2 ) ; lowest ( $ den3 , $ num3 ) ; } $ num1 = 1 ; $ den1 = 500 ; $ num2 = 2 ; $ den2 = 1500 ; $ den3 ; $ num3 ; addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , $ num3 , $ den3 ) ; echo $ num1 , \" \/ \" , $ den1 , \" \u2581 + \u2581 \" , $ num2 , \" \/ \" , $ den2 , \" \u2581 is \u2581 equal \u2581 to \u2581 \" , $ num3 , \" \/ \" , $ den3 , \" STRNEWLINE \" ; ? >"}
{"text":"Largest Divisor of a Number not divisible by a perfect square | Function to find the largest divisor not divisible by any perfect square greater than 1 ; If the number is divisible by i * i , then remove one i ; Now all squares are removed from n ; Driver Code","code":"< ? php function findLargestDivisor ( $ n ) { for ( $ i = 2 ; $ i < sqrt ( $ n ) + 1 ; $ i ++ ) { while ( $ n % ( $ i * $ i ) == 0 ) { $ n = $ n \/ $ i ; } } return $ n ; } $ n = 12 ; echo ( findLargestDivisor ( $ n ) ) ; echo ( \" STRNEWLINE \" ) ; $ n = 97 ; echo ( findLargestDivisor ( $ n ) ) ; ? >"}
{"text":"Arithmetic Progression | Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driver Code","code":"< ? php function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; } $ arr = array ( 20 , 15 , 5 , 0 , 10 ) ; $ n = count ( $ arr ) ; if ( checkIsAP ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if a number is Triperfect Number | Returns true if n is Triperfect ; To store sum of divisors . Adding 1 and n since they are divisors of n . ; Find all divisors and add them ; If sum of divisors is equal to 3 * n , then n is a Triperfect number ; Driver Code","code":"< ? php function isTriPerfect ( $ n ) { $ sum = 1 + $ n ; $ i = 2 ; while ( $ i * $ i <= $ n ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ sum = $ sum + $ i ; else $ sum = $ sum + $ i + $ n \/ $ i ; } $ i += 1 ; } if ( $ sum == 3 * $ n and $ n != 1 ) return true ; else false ; } $ n = 120 ; if ( isTriPerfect ( $ n ) ) echo $ n . \" \u2581 is \u2581 a \u2581 Triperfect \u2581 number \" ; else echo $ n . \" \u2581 is \u2581 not \u2581 a \u2581 Triperfect \u2581 number \" ; ? >"}
{"text":"Sum of first N natural numbers which are divisible by X or Y | Function to calculate the sum of numbers divisible by X or Y ; Driver code","code":"< ? php function sum ( $ N , $ X , $ Y ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = floor ( ( ( int ) $ N \/ $ X ) ) * ( 2 * $ X + ( int ) ( ( int ) $ N \/ $ X - 1 ) * $ X ) \/ 2 ; $ S2 = floor ( ( ( int ) $ N \/ $ Y ) ) * ( 2 * $ Y + ( int ) ( ( int ) $ N \/ $ Y - 1 ) * $ Y ) \/ 2 ; $ S3 = floor ( ( ( int ) $ N \/ ( $ X * $ Y ) ) ) * ( 2 * ( $ X * $ Y ) + ( ( int ) $ N \/ ( $ X * $ Y ) - 1 ) * ( int ) ( $ X * $ Y ) ) \/ 2 ; return ceil ( $ S1 + ( $ S2 - $ S3 ) ) ; } $ N = 14 ; $ X = 3 ; $ Y = 5 ; echo sum ( $ N , $ X , $ Y ) ; #This  code is contributed by ajit. NEW_LINE ? >"}
{"text":"Count numbers from range whose prime factors are only 2 and 3 | Function to count the number within a range whose prime factors are only 2 and 3 ; Start with 2 so that 1 doesn 't get counted ; While num is divisible by 2 , divide it by 2 ; While num is divisible by 3 , divide it by 3 ; If num got reduced to 1 then it has only 2 and 3 as prime factors ; Driver code","code":"< ? php function findTwoThreePrime ( $ l , $ r ) { if ( $ l == 1 ) $ l ++ ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; while ( $ num % 2 == 0 ) $ num \/= 2 ; while ( $ num % 3 == 0 ) $ num \/= 3 ; if ( $ num == 1 ) $ count ++ ; } return $ count ; } $ l = 1 ; $ r = 10 ; echo findTwoThreePrime ( $ l , $ r ) ; ? >"}
{"text":"Maximum number with same digit factorial product | Function to return the required number ; Count the frequency of each digit ; 4 ! can be expressed as 2 ! * 2 ! * 3 ! ; 6 ! can be expressed as 5 ! * 3 ! ; 8 ! can be expressed as 7 ! * 2 ! * 2 ! * 2 ! ; 9 ! can be expressed as 7 ! * 3 ! * 3 ! * 2 ! ; To store the required number ; If number has only either 1 and 0 as its digits ; Generate the greatest number possible ; Driver code","code":"< ? php function getNumber ( $ s ) { $ number_of_digits = strlen ( $ s ) ; $ freq = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 0 ; $ i < $ number_of_digits ; $ i ++ ) { if ( $ s [ $ i ] == '1' $ s [ $ i ] == '2' $ s [ $ i ] == '3' $ s [ $ i ] == '5' $ s [ $ i ] == '7' ) { $ freq [ ord ( $ s [ $ i ] ) - 48 ] += 1 ; } if ( $ s [ $ i ] == '4' ) { $ freq [ 2 ] += 2 ; $ freq [ 3 ] ++ ; } if ( $ s [ $ i ] == '6' ) { $ freq [ 5 ] ++ ; $ freq [ 3 ] ++ ; } if ( $ s [ $ i ] == '8' ) { $ freq [ 7 ] ++ ; $ freq [ 2 ] += 3 ; } if ( $ s [ $ i ] == '9' ) { $ freq [ 7 ] ++ ; $ freq [ 3 ] += 2 ; $ freq [ 2 ] ++ ; } } $ t = \" \" ; if ( $ freq [ 1 ] == $ number_of_digits || $ freq [ 0 ] == $ number_of_digits || ( $ freq [ 0 ] + $ freq [ 1 ] ) == $ number_of_digits ) { return $ s ; } else { for ( $ i = 9 ; $ i >= 2 ; $ i -- ) { $ ctr = $ freq [ $ i ] ; while ( $ ctr -- ) { $ t . = chr ( $ i + 48 ) ; } } return $ t ; } } $ s = \"1280\" ; echo getNumber ( $ s ) ; ? >"}
{"text":"Program to find first N Iccanobif Numbers | Iterative function to reverse digits of num ; Function to print first N Icanobif Numbers ; Initialize first , second numbers ; Print first two numbers ; Reversing digit of previous two terms and adding them ; Driver Code","code":"< ? php function reversDigits ( $ num ) { $ rev_num = 0 ; while ( $ num > 0 ) { $ rev_num = ( $ rev_num * 10 ) + ( $ num % 10 ) ; $ num = ( int ) ( $ num \/ 10 ) ; } return $ rev_num ; } function icanobifNumbers ( $ N ) { $ first = 0 ; $ second = 1 ; if ( $ N == 1 ) echo $ first ; else if ( $ N == 2 ) echo $ first , \" \u2581 \" , $ second ; else { echo $ first , \" \" \u2581 , \u2581 $ second , \u2581 \" \" for ( $ i = 3 ; $ i <= $ N ; $ i ++ ) { $ x = reversDigits ( $ first ) ; $ y = reversDigits ( $ second ) ; echo ( $ x + $ y ) , \" \u2581 \" ; $ temp = $ second ; $ second = $ x + $ y ; $ first = $ temp ; } } } $ N = 12 ; icanobifNumbers ( $ N ) ; ? >"}
{"text":"Add N digits to A such that it is divisible by B after each addition | PHP implementation of the approach ; Try all digits from ( 0 to 9 ) ; Fails in the first move itself ; Add ( n - 1 ) 0 's ; Driver Code","code":"< ? php function addNDigits ( $ a , $ b , $ n ) { $ num = $ a ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ tmp = $ a * 10 + $ i ; if ( $ tmp % $ b == 0 ) { $ a = $ tmp ; break ; } } if ( $ num == $ a ) return -1 ; for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) $ a *= 10 ; return $ a ; } $ a = 5 ; $ b = 3 ; $ n = 3 ; echo addNDigits ( $ a , $ b , $ n ) ;"}
{"text":"Count number of triplets ( a , b , c ) such that a ^ 2 + b ^ 2 = c ^ 2 and 1 <= a <= b <= c <= n | Function to ind number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; to store required answer ; run nested loops for first two numbers . ; third number ; check if third number is perfect square and less than n ; Driver code ; function call","code":"< ? php function Triplets ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = $ i ; $ j <= $ n ; ++ $ j ) { $ x = $ i * $ i + $ j * $ j ; $ y = ( int ) sqrt ( $ x ) ; if ( $ y * $ y == $ x && $ y <= $ n ) ++ $ ans ; } } return $ ans ; } $ n = 10 ; echo Triplets ( $ n ) ; ? >"}
{"text":"Sum of the digits of a number N written in all bases from 2 to N \/ 2 | Function to calculate the sum of the digits of n in the given base ; Sum of digits ; Digit of n in the given base ; Add the digit ; Function to calculate the sum of digits of n in bases from 2 to n \/ 2 ; to store digit sum in all bases ; function call for multiple bases ; Driver Code","code":"< ? php function solve ( $ n , $ base ) { $ sum = 0 ; while ( $ n > 0 ) { $ remainder = $ n % $ base ; $ sum += $ remainder ; $ n = $ n \/ $ base ; } return $ sum ; } function SumsOfDigits ( $ n ) { $ sum = 0 ; for ( $ base = 2 ; $ base <= $ n \/ 2 ; ++ $ base ) $ sum += solve ( $ n , $ base ) ; echo $ sum ; } $ n = 8 ; SumsOfDigits ( $ n ) ; ? >"}
{"text":"Largest number in an array that is not a perfect cube | Function to check if a number is perfect cube number or not ; takes the sqrt of the number ; checks if it is a perfect cube number ; Function to find the largest non perfect cube number in the array ; stores the maximum of all perfect cube numbers ; Traverse all elements in the array ; store the maximum if current element is a non perfect cube ; Driver Code","code":"< ? php function checkPerfectcube ( $ n ) { $ d = ( int ) round ( pow ( $ n , 1 \/ 3 ) ) ; if ( $ d * $ d * $ d == $ n ) return true ; return false ; } function largestNonPerfectcubeNumber ( $ a , $ n ) { $ maxi = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! checkPerfectcube ( $ a [ $ i ] ) ) $ maxi = max ( $ a [ $ i ] , $ maxi ) ; } return $ maxi ; } $ a = array ( 16 , 64 , 25 , 2 , 3 , 10 ) ; $ n = count ( $ a ) ; echo largestNonPerfectcubeNumber ( $ a , $ n ) ; ? >"}
{"text":"Check if N can be represented as sum of integers chosen from set { A , B } | Function to find if number N can be represented as sum of a ' s \u2581 and \u2581 b ' s ; base condition ; if x is already visited ; set x as possible ; recursive call ; Driver Code","code":"< ? php function checkIfPossibleRec ( $ x , $ a , $ b , $ isPossible , $ n ) { if ( $ x > $ n ) return ; if ( $ isPossible == true ) return ; $ isPossible [ $ x ] = true ; checkIfPossibleRec ( $ x + $ a , $ a , $ b , $ isPossible , $ n ) ; checkIfPossibleRec ( $ x + $ b , $ a , $ b , $ isPossible , $ n ) ; } function checkPossible ( $ n , $ a , $ b ) { $ isPossible [ $ n + 1 ] = array ( false ) ; checkIfPossibleRec ( 0 , $ a , $ b , $ isPossible , $ n ) ; return $ isPossible ; } $ a = 3 ; $ b = 7 ; $ n = 8 ; if ( checkPossible ( $ a , $ b , $ n ) ) echo \" No \" ; else echo \" Yes \" ; ? >"}
{"text":"Sum of all odd natural numbers in range L and R | Function to return the sum of all odd natural numbers ; Function to return the sum of all odd numbers in range L and R ; Driver Code","code":"< ? php function sumOdd ( $ n ) { $ terms = ( int ) ( $ n + 1 ) \/ 2 ; $ sum = $ terms * $ terms ; return $ sum ; } function suminRange ( $ l , $ r ) { return sumOdd ( $ r ) - sumOdd ( $ l - 1 ) ; } $ l = 2 ; $ r = 5 ; echo \" Sum \u2581 of \u2581 odd \u2581 natural \u2581 numbers \u2581 from \u2581 L \u2581 to \u2581 R \u2581 is \u2581 \" , suminRange ( $ l , $ r ) ; ? >"}
{"text":"Sum of common divisors of two numbers A and B | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Find the sum of divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver program to run the case","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function sumcommDiv ( $ a , $ b ) { $ n = gcd ( $ a , $ b ) ; $ sum = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ sum += $ i ; else $ sum += ( $ n \/ $ i ) + $ i ; } } return $ sum ; } $ a = 10 ; $ b = 15 ; echo \" Sum = \" ? >"}
{"text":"Check if a number is formed by Concatenation of 1 , 14 or 144 only | Function to check if a number is formed by Concatenation of 1 , 14 or 144 only ; check for each possible digit if given number consist other then 1 , 14 , 144 print NO else print YES ; Driver Code","code":"< ? php function checkNumber ( $ N ) { $ temp = $ N ; while ( $ temp > 0 ) { if ( $ temp % 1000 == 144 ) $ temp \/= 1000 ; else if ( $ temp % 100 == 14 ) $ temp \/= 100 ; else if ( $ temp % 10 == 1 ) $ temp \/= 10 ; else { return \" YES \" ; } } return \" NO \" ; } $ N = 1414 ; echo checkNumber ( $ N ) ; ? >"}
{"text":"Fibonacci problem ( Value of Fib ( N ) * Fib ( N ) | PHP implementation of the approach ; Driver code","code":"< ? php function getResult ( $ n ) { if ( $ n & 1 ) return 1 ; return -1 ; } $ n = 3 ; echo getResult ( $ n ) ; ? >"}
{"text":"Find two numbers with sum and product both same as N | Function to return the smallest string ; Not possible ; find a and b ; Driver Code","code":"< ? php function findAandB ( $ N ) { $ val = $ N * $ N - 4.0 * $ N ; if ( $ val < 0 ) { echo \" NO \" ; return ; } $ a = ( $ N + sqrt ( $ val ) ) \/ 2.0 ; $ b = ( $ N - sqrt ( $ val ) ) \/ 2.0 ; echo \" a = \" \u2581 , \u2581 $ a , \u2581 \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" b = \" \u2581 , \u2581 $ b , \u2581 \" \" } $ N = 69.0 ; findAandB ( $ N ) ; ? >"}
{"text":"Find minimum operations needed to make an Array beautiful | Function to find minimum operations required to make array beautiful ; counting consecutive zeros . ; check that start and end are same ; check is zero and one are equal ; Driver Code","code":"< ? php function minOperations ( $ A , $ n ) { if ( $ n & 1 ) return -1 ; $ zeros = 0 ; $ consZeros = 0 ; $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ A [ $ i ] == 0 ? $ zeros ++ : $ ones ++ ; if ( ( $ i + 1 ) < $ n ) { if ( $ A [ $ i ] == 0 && $ A [ $ i + 1 ] == 0 ) $ consZeros ++ ; } } if ( $ A [ 0 ] == $ A [ $ n - 1 ] && $ A [ 0 ] == 0 ) $ consZeros ++ ; if ( $ zeros == $ ones ) return $ consZeros ; else return -1 ; } $ A = array ( 1 , 1 , 0 , 0 ) ; $ n = sizeof ( $ A ) ; echo minOperations ( $ A , $ n ) ; ? >"}
{"text":"Steps to reduce N to zero by subtracting its most significant digit at every step | Function to count the number of digits in a number m ; Function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; Driver code","code":"< ? php function countdig ( $ m ) { if ( $ m == 0 ) return 0 ; else return 1 + countdig ( ( int ) ( $ m \/ 10 ) ) ; } function countSteps ( $ x ) { $ c = 0 ; $ last = $ x ; while ( $ last ) { $ digits = countdig ( $ last ) ; $ digits -= 1 ; $ divisor = pow ( 10 , $ digits ) ; $ first = ( int ) ( $ last \/ $ divisor ) ; $ lastnumber = $ first * $ divisor ; $ skipped = ( $ last - $ lastnumber ) \/ $ first ; $ skipped += 1 ; $ c += $ skipped ; $ last = $ last - ( $ first * $ skipped ) ; } return $ c ; } $ n = 14 ; echo countSteps ( $ n ) ;"}
{"text":"GCD of a number raised to some power and another number | Calculates modular exponentiation , i . e . , ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Returns GCD of a ^ n and b ; Driver code","code":"< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function powerGCD ( $ a , $ b , $ n ) { $ e = power ( $ a , $ n , $ b ) ; return gcd ( $ e , $ b ) ; } $ a = 5 ; $ b = 4 ; $ n = 2 ; echo powerGCD ( $ a , $ b , $ n ) ; ? >"}
{"text":"Largest number not greater than N all the digits of which are odd | Function to check if all digits of a number are odd ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the largest number with all digits odd ; iterate till we find a number with all digits odd ; Driver Code","code":"< ? php function allOddDigits ( $ n ) { while ( $ n > 1 ) { if ( ( $ n % 10 ) % 2 == 0 ) return false ; $ n = ( int ) $ n \/ 10 ; } return true ; } function largestNumber ( $ n ) { if ( $ n % 2 == 0 ) $ n -- ; for ( $ i = $ n ; ; $ i = ( $ i - 2 ) ) if ( allOddDigits ( $ i ) ) return $ i ; } $ N = 23 ; echo largestNumber ( $ N ) ; ? >"}
{"text":"Count number less than N which are product of perfect squares | Function to count number less than N which are product of any two perfect squares ; Driver Code","code":"< ? php function countNumbers ( $ N ) { return ( int ) ( sqrt ( $ N ) ) - 1 ; } $ N = 36 ; echo countNumbers ( $ N ) ; ? >"}
{"text":"Count ordered pairs with product less than N | Function to return count of Ordered pairs whose products are less than N ; Initialize count to 0 ; count total pairs ; multiply by 2 to get ordered_pairs ; subtract redundant pairs ( a , b ) where a == b . ; return answer ; Driver code ; function call to print required answer","code":"< ? php function countOrderedPairs ( $ N ) { $ count_pairs = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N - 1 ) ; ++ $ i ) { for ( $ j = $ i ; $ j * $ i < $ N ; ++ $ j ) ++ $ count_pairs ; } $ count_pairs *= 2 ; $ count_pairs -= ( sqrt ( $ N - 1 ) ) ; return $ count_pairs ; } $ N = 5 ; echo countOrderedPairs ( $ N ) ; ? >"}
{"text":"Absolute Difference of all pairwise consecutive elements in an array | Function to print pairwise absolute difference of consecutive elements ; absolute difference between consecutive numbers ; Driver Code","code":"< ? php function pairwiseDifference ( $ arr , $ n ) { $ diff = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; echo $ diff . \" \" ; } } $ arr = array ( 4 , 10 , 15 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; pairwiseDifference ( $ arr , $ n ) ; ? >"}
{"text":"Find the sum of all multiples of 2 and 5 below N | Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 2 and 5 below N ; Since , we need the sum of multiples less than N ; Driver code","code":"< ? php function sumAP ( $ n , $ d ) { $ n = ( int ) ( $ n \/ $ d ) ; return ( $ n ) * ( ( 1 + $ n ) * ( int ) $ d \/ 2 ) ; } function sumMultiples ( $ n ) { $ n -- ; return sumAP ( $ n , 2 ) + sumAP ( $ n , 5 ) - sumAP ( $ n , 10 ) ; } $ n = 20 ; echo sumMultiples ( $ n ) ; ? >"}
{"text":"Find the total marks obtained according to given marking scheme | Function that calculates marks . ; for not attempt score + 0 ; for each correct answer score + 3 ; for each wrong answer score - 1 ; calculate total marks ; Driver code","code":"< ? php function markingScheme ( $ N , $ answerKey , $ studentAnswer ) { $ positive = 0 ; $ negative = 0 ; $ notattempt = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ studentAnswer [ $ i ] == 0 ) $ notattempt ++ ; else if ( $ answerKey [ $ i ] == $ studentAnswer [ $ i ] ) $ positive ++ ; else if ( $ answerKey [ $ i ] != $ studentAnswer [ $ i ] ) $ negative ++ ; } return ( $ positive * 3 ) + ( $ negative * -1 ) ; } $ answerKey = array ( 1 , 2 , 3 , 4 , 1 ) ; $ studentAnswer = array ( 1 , 2 , 3 , 4 , 0 ) ; $ N = sizeof ( $ answerKey ) ; echo markingScheme ( $ N , $ answerKey , $ studentAnswer ) ; ? >"}
{"text":"Find the Product of first N Prime Numbers | PHP implementation of above solution ; Create a boolean array \" $ prime [ 0 . . $ n ] \" and initialize all entries it as true . A value in $prime [ i ] will finally be false if i is Not a $prime , else true . ; If $prime [ $p ] is not changed , then it is a $prime ; Set all multiples of $$p to non - $prime ; find the product of 1 st N $prime numbers ; $count of $prime numbers ; product of $prime numbers ; if the number is $prime add it ; increase the $count ; get to next number ; create the sieve ; find the value of 1 st $n $prime numbers","code":"< ? php $ MAX = 10000 ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; function SieveOfEratosthenes ( ) { global $ MAX ; global $ prime ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } } function solve ( $ n ) { global $ prime ; $ count = 0 ; $ num = 1 ; $ prod = 1 ; while ( $ count < $ n ) { if ( $ prime [ $ num ] == true ) { $ prod *= $ num ; $ count ++ ; } $ num ++ ; } return $ prod ; } SieveOfEratosthenes ( ) ; $ n = 5 ; echo solve ( $ n ) ; ? >"}
{"text":"Check if there is any pair in a given range with GCD is divisible by k | Returns count of numbers in [ l r ] that are divisible by k . ; Add 1 explicitly as l is divisible by k ; l is not divisible by k ; Driver Code","code":"< ? php function Check_is_possible ( $ l , $ r , $ k ) { $ div_count = ( int ) ( $ r \/ $ k ) - ( int ) ( $ l \/ $ k ) ; if ( $ l % $ k == 0 ) $ div_count ++ ; return ( $ div_count > 1 ) ; } $ l = 30 ; $ r = 70 ; $ k = 10 ; if ( Check_is_possible ( $ l , $ r , $ k ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text":"Find sum of N | calculate sum of Nth group ; Driver code","code":"< ? php function nth_group ( $ n ) { return $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; } $ N = 5 ; echo nth_group ( $ N ) ; ? >"}
{"text":"Find if a molecule can be formed from 3 atoms using their valence numbers | Function to check if it is possible ; Driver code","code":"< ? php function printPossible ( $ a , $ b , $ c ) { if ( ( $ a + $ b + $ c ) % 2 != 0 $ a + $ b < $ c ) echo ( \" NO \" ) ; else echo ( \" YES \" ) ; } $ a = 2 ; $ b = 4 ; $ c = 2 ; printPossible ( $ a , $ b , $ c ) ; ? >"}
{"text":"Find the sum of first N terms of the series 2 \u00c3 \u2014 3 + 4 \u00c3 \u2014 4 + 6 \u00c3 \u2014 5 + 8 \u00c3 \u2014 6 + ... | calculate sum upto N term of series ; Driver code","code":"< ? php function Sum_upto_nth_Term ( $ n ) { $ r = $ n * ( $ n + 1 ) * ( 2 * $ n + 7 ) \/ 3 ; echo $ r ; } $ N = 5 ; Sum_upto_nth_Term ( $ N ) ; ? >"}
{"text":"Absolute Difference between the Sum of Non | Function to find the difference between the sum of non - primes and the sum of primes of an array . ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store the sum of primes in S1 and the sum of non primes in S2 ; the number is prime ; the number is non - prime ; Return the absolute difference ; Get the array ; Find the absolute difference","code":"< ? php function CalculateDifference ( $ arr , $ n ) { $ max_val = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max_val ) $ max_val = $ arr [ $ i ] ; } $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ S1 = 0 ; $ S2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) { $ S1 += $ arr [ $ i ] ; } else if ( $ arr [ $ i ] != 1 ) { $ S2 += $ arr [ $ i ] ; } } return abs ( $ S2 - $ S1 ) ; } $ arr = array ( 1 , 3 , 5 , 10 , 15 , 7 ) ; $ n = sizeof ( $ arr ) ; echo CalculateDifference ( $ arr , $ n ) ; ? >"}
{"text":"Count number of integers less than or equal to N which has exactly 9 divisors | Function to count factors in O ( N ) ; iterate and check if factor or not ; Function to count numbers having exactly 9 divisors ; check for all numbers <= N ; check if exactly 9 factors or not ; Driver Code","code":"< ? php Function numberOfDivisors ( $ num ) { $ c = 0 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { if ( $ num % $ i == 0 ) { $ c += 1 ; } } return $ c ; } Function countNumbers ( $ n ) { $ c = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( numberOfDivisors ( $ i ) == 9 ) $ c += 1 ; } return $ c ; } $ n = 1000 ; echo countNumbers ( $ n ) ; ? >"}
{"text":"Number of distinct integers obtained by lcm ( X , N ) \/ X | Function to count the number of distinct integers ontained by lcm ( x , num ) \/ x ; iterate to count the number of factors ; Driver Code","code":"< ? php function numberOfDistinct ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ ans ++ ; if ( ( $ n \/ $ i ) != $ i ) $ ans ++ ; } } return $ ans ; } $ n = 3 ; echo numberOfDistinct ( $ n ) ; ? >"}
{"text":"Find the number of rectangles of size 2 * 1 which can be placed inside a rectangle of size n * m | function to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; if n is even ; if m is even ; if both are odd ; Driver code ; function call","code":"< ? php function NumberOfRectangles ( $ n , $ m ) { if ( $ n % 2 == 0 ) return ( $ n \/ 2 ) * $ m ; else if ( $ m % 2 == 0 ) return ( $ m \/ 2 ) * $ n ; return ( $ n * $ m - 1 ) \/ 2 ; } $ n = 3 ; $ m = 3 ; echo NumberOfRectangles ( $ n , $ m ) ; ? >"}
{"text":"Next greater Number than N with the same quantity of digits A and B | Recursive function to find the required number ; If the resulting number is >= n and count of a = count of b , return the number ; select minimum of two and call the function again ; Function to find the number next greater Number than N with the same quantity of digits A and B ; Driver code","code":"< ? php function findNumUtil ( $ res , $ a , $ aCount , $ b , $ bCount , $ n ) { if ( $ res > 100000000000 ) return 10000000000 ; if ( $ aCount == $ bCount && $ res >= $ n ) return $ res ; return min ( findNumUtil ( $ res * 10 + $ a , $ a , $ aCount + 1 , $ b , $ bCount , $ n ) , findNumUtil ( $ res * 10 + $ b , $ a , $ aCount , $ b , $ bCount + 1 , $ n ) ) ; } function findNum ( $ n , $ a , $ b ) { $ result = 0 ; $ aCount = 0 ; $ bCount = 0 ; return findNumUtil ( $ result , $ a , $ aCount , $ b , $ bCount , $ n ) ; } $ N = 4500 ; $ A = 4 ; $ B = 7 ; echo findNum ( $ N , $ A , $ B ) ; ? >"}
{"text":"Minimum and maximum number of N chocolates after distribution among K students | Driver code","code":"< ? php $ n = 7 ; $ k = 3 ; if ( $ n % $ k == 0 ) echo $ n \/ $ k . \" \u2581 \" . $ n \/ $ k ; else echo ( ( $ n - ( $ n % $ k ) ) \/ $ k ) . \" \u2581 \" . ( ( ( $ n - ( $ n % $ k ) ) \/ $ k ) + 1 ) ; ? >"}
{"text":"Total money to be paid after traveling the given number of hours | PHP implementation of the above approach ; calculating hours travelled","code":"< ? php $ m = 50 ; $ n = 5 ; $ x = 67 ; $ h = 2927 ; $ z = ( int ) ( ceil ( $ h \/ 60 ) ) ; if ( $ z <= $ n ) print ( $ z * $ m ) ; else print ( $ n * $ m + ( $ z - $ n ) * $ x ) ; ? >"}
{"text":"Absolute difference between sum and product of roots of a quartic equation | Function taking coefficient of each term of equation as input ; Finding sum of roots ; Finding product of roots ; Absolute difference ; Driver code","code":"< ? php function sumProductDifference ( $ a , $ b , $ c , $ d , $ e ) { $ rootSum = ( double ) ( -1 * $ b ) \/ $ a ; $ rootProduct = ( double ) $ e \/ $ a ; return abs ( $ rootSum - $ rootProduct ) ; } echo sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ; ? >"}
{"text":"Number of solutions of n = x + n \u00e2\u0160 \u2022 x | Function to find the number of solutions of n = n xor x ; Counter to store the number of solutions found ; Driver code","code":"< ? php function numberOfSolutions ( $ n ) { $ c = 0 ; for ( $ x = 0 ; $ x <= $ n ; ++ $ x ) if ( $ n == $ x + $ n ^ $ x ) ++ $ c ; return $ c ; } $ n = 3 ; echo numberOfSolutions ( $ n ) ;"}
{"text":"Program to find minimum number of lectures to attend to maintain 75 % | Function to compute minimum lecture ; Formula to compute ; Driver Code","code":"< ? php function minimumLectures ( $ m , $ n ) { $ ans = 0 ; if ( $ n < ceil ( 0.75 * $ m ) ) $ ans = ( int ) ceil ( ( ( 0.75 * $ m ) - $ n ) \/ 0.25 ) ; else $ ans = 0 ; return $ ans ; } $ M = 9 ; $ N = 1 ; echo minimumLectures ( $ M , $ N ) ; ? >"}
{"text":"Count Numbers with N digits which consists of odd number of 0 's | Function to count Numbers with N digits which consists of odd number of 0 's ; Driver code","code":"< ? php function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) \/ 2 ; } $ n = 5 ; echo countNumbers ( $ n ) ; ? >"}
{"text":"Sum of the first N terms of the series 5 , 12 , 23 , 38. ... | Function to calculate the sum ; number of terms to be included in sum ; find the Sn","code":"< ? php function calculateSum ( $ n ) { return 2 * ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) \/ 6 ) + $ n * ( $ n + 1 ) \/ 2 + 2 * ( $ n ) ; } $ n = 3 ; echo \" Sum = \" ? >"}
{"text":"Program to find number of solutions in Quadratic Equation | Method to check for solutions of equations ; If the expression is greater than 0 , then 2 solutions ; If the expression is equal 0 , then 2 solutions ; Else no solutions ; Driver Code","code":"< ? php function checkSolution ( $ a , $ b , $ c ) { if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) > 0 ) echo \"2 \u2581 solutions \" ; else if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) == 0 ) echo \"1 \u2581 solution \" ; else echo \" No \u2581 solutions \" ; } $ a = 2 ; $ b = 5 ; $ c = 2 ; checkSolution ( $ a , $ b , $ c ) ; ? >"}
{"text":"Program to convert KiloBytes to Bytes and Bits | Function to calculates the bits ; calculates Bits 1 kilobytes ( s ) = 8192 bits ; Function to calculates the bytes ; calculates Bytes 1 KB = 1024 bytes ; Driver code","code":"< ? php function Bits ( $ kilobytes ) { $ Bits = 0 ; $ Bits = $ kilobytes * 8192 ; return $ Bits ; } function Bytes ( $ kilobytes ) { $ Bytes = 0 ; $ Bytes = $ kilobytes * 1024 ; return $ Bytes ; } $ kilobytes = 1 ; echo $ kilobytes ; echo ( \" \u2581 Kilobytes \u2581 = \u2581 \" ) ; echo Bytes ( $ kilobytes ) ; echo ( \" \u2581 Bytes \u2581 and \u2581 \" ) ; echo Bits ( $ kilobytes ) ; echo ( \" \u2581 Bits . \" ) ; ? >"}
{"text":"Program to find the Hidden Number | Getting the size of array ; Getting the array of size n ; Solution ; Finding sum of the array elements ; Dividing sum by size n ; Print x , if found","code":"< ? php $ n = 3 ; $ a = array ( 1 , 2 , 3 ) ; $ i = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; } $ x = $ sum \/ $ n ; if ( $ x * $ n == $ sum ) echo ( $ x ) ; else echo ( \" - 1\" ) ; ? >"}
{"text":"Find sum of the series ? 3 + ? 12 + ... ... ... upto N terms | Function to find the sum ; Apply AP formula ; number of terms","code":"< ? php function findSum ( $ n ) { return sqrt ( 3 ) * ( $ n * ( $ n + 1 ) \/ 2 ) ; } $ n = 10 ; echo findSum ( $ n ) ; ? >"}
{"text":"Find the sum of the series x ( x + y ) + x ^ 2 ( x ^ 2 + y ^ 2 ) + x ^ 3 ( x ^ 3 + y ^ 3 ) + ... + x ^ n ( x ^ n + y ^ n ) | Function to return required sum ; sum of first series ; sum of second series ; Driver code ; function call to print sum","code":"< ? php function sum ( $ x , $ y , $ n ) { $ sum1 = ( pow ( $ x , 2 ) * ( pow ( $ x , 2 * $ n ) - 1 ) ) \/ ( pow ( $ x , 2 ) - 1 ) ; $ sum2 = ( $ x * $ y * ( pow ( $ x , $ n ) * pow ( $ y , $ n ) - 1 ) ) \/ ( $ x * $ y - 1 ) ; return $ sum1 + $ sum2 ; } $ x = 2 ; $ y = 2 ; $ n = 2 ; echo sum ( $ x , $ y , $ n ) ; ? >"}
{"text":"Find any pair with given GCD and LCM | Function to print the pairs ; Driver Code","code":"< ? php function printPair ( $ g , $ l ) { echo $ g ; echo ( \" \u2581 \" ) ; echo $ l ; } $ g = 3 ; $ l = 12 ; printPair ( $ g , $ l ) ; ? >"}
{"text":"Sum of first n terms of a given series 3 , 6 , 11 , ... . . | Function to calculate the sum ; starting number ; Common Ratio ; Common difference ; Nth term to be find ; find the Sn","code":"< ? php function calculateSum ( $ n ) { $ a1 = 1 ; $ a2 = 2 ; $ r = 2 ; $ d = 1 ; return ( $ n ) * ( 2 * $ a1 + ( $ n - 1 ) * $ d ) \/ 2 + $ a2 * ( pow ( $ r , $ n ) - 1 ) \/ ( $ r - 1 ) ; } $ n = 5 ; echo \" Sum = \" ? >"}
{"text":"Minimum number of sub | Function that returns true if n is a power of 5 ; Function to return the decimal value of binary equivalent ; Function to return the minimum cuts required ; Allocating memory for dp [ ] array ; From length 1 to n ; If previous character is '0' then ignore to avoid number with leading 0 s . ; Ignore s [ j ] = '0' starting numbers ; Number formed from s [ j ... . i ] ; Check for power of 5 ; Assigning min value to get min cut possible ; ( n + 1 ) to check if all the strings are traversed and no divisible by 5 is obtained like 000000 ; Driver code","code":"< ? php function ispower ( $ n ) { if ( $ n < 125 ) return ( $ n == 1 $ n == 5 $ n == 25 ) ; if ( $ n % 125 != 0 ) return false ; else return ispower ( $ n \/ 125 ) ; } function number ( $ s , $ i , $ j ) { $ ans = 0 ; for ( $ x = $ i ; $ x < $ j ; $ x ++ ) { $ ans = $ ans * 2 + ( ord ( $ s [ $ x ] ) - ord ( '0' ) ) ; } return $ ans ; } function minCuts ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n + 1 , $ n + 1 ) ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ s [ $ i - 1 ] == '0' ) continue ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ s [ $ j ] == '0' ) continue ; $ num = number ( $ s , $ j , $ i ) ; if ( ! ispower ( $ num ) ) continue ; $ dp [ $ i ] = min ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; } } return ( ( $ dp [ $ n ] < $ n + 1 ) ? $ dp [ $ n ] : -1 ) ; } $ s = \"101101101\" ; $ n = strlen ( $ s ) ; echo minCuts ( $ s , $ n ) ; ? >"}
{"text":"Minimum number of cubes whose sum equals to given number N | Function to return the minimum number of cubes whose sum is k ; If k is less than the 2 ^ 3 ; Initialize with the maximum number of cubes required ; Driver code","code":"< ? php function MinOfCubed ( $ k ) { if ( $ k < 8 ) return $ k ; $ res = $ k ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( $ i * $ i * $ i ) > $ k ) return $ res ; $ res = min ( $ res , MinOfCubed ( $ k - ( $ i * $ i * $ i ) ) + 1 ) ; } return $ res ; } $ num = 15 ; echo MinOfCubed ( $ num ) ; ? >"}
{"text":"Minimum number of cubes whose sum equals to given number N | Function to return the minimum number of cubes whose sum is k ; While current perfect cube is less than current element ; If i is a perfect cube ; i = ( i - 1 ) + 1 ^ 3 ; Next perfect cube ; Re - initialization for next element ; Driver code","code":"< ? php function MinOfCubedDP ( $ k ) { $ DP = array ( $ k + 1 ) ; $ j = 1 ; $ t = 1 ; $ DP [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ DP [ $ i ] = PHP_INT_MAX ; while ( $ j <= $ i ) { if ( $ j == $ i ) $ DP [ $ i ] = 1 ; else if ( $ DP [ $ i ] > $ DP [ $ i - $ j ] ) $ DP [ $ i ] = $ DP [ $ i - $ j ] + 1 ; $ t ++ ; $ j = $ t * $ t * $ t ; } $ t = $ j = 1 ; } return $ DP [ $ k ] ; } $ num = 15 ; echo ( MinOfCubedDP ( $ num ) ) ; ? >"}
{"text":"Maximum Subarray Sum after inverting at most two elements | Function to return the maximum required sub - array sum ; Creating one based indexing ; 2d array to contain solution for each step ; Case 1 : Choosing current or ( current + previous ) whichever is smaller ; Case 2 : ( a ) Altering sign and add to previous case 1 or value 0 ; Case 2 : ( b ) Adding current element with previous case 2 and updating the maximum ; Case 3 : ( a ) Altering sign and add to previous case 2 ; Case 3 : ( b ) Adding current element with previous case 3 ; Updating the maximum value of variable ans ; Return the final solution ; Driver code","code":"< ? php function maxSum ( $ a , $ n ) { $ ans = 0 ; $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ a [ $ i - 1 ] ; $ dp = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ dp [ $ i ] [ 0 ] = max ( $ arr [ $ i ] , $ dp [ $ i - 1 ] [ 0 ] + $ arr [ $ i ] ) ; $ dp [ $ i ] [ 1 ] = max ( 0 , $ dp [ $ i - 1 ] [ 0 ] ) - $ arr [ $ i ] ; if ( $ i >= 2 ) $ dp [ $ i ] [ 1 ] = max ( $ dp [ $ i ] [ 1 ] , $ dp [ $ i - 1 ] [ 1 ] + $ arr [ $ i ] ) ; if ( $ i >= 2 ) $ dp [ $ i ] [ 2 ] = $ dp [ $ i - 1 ] [ 1 ] - $ arr [ $ i ] ; if ( $ i >= 3 ) $ dp [ $ i ] [ 2 ] = max ( $ dp [ $ i ] [ 2 ] , $ dp [ $ i - 1 ] [ 2 ] + $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 0 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 1 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 2 ] ) ; } return $ ans ; } $ arr = array ( -5 , 3 , 2 , 7 , -8 , 3 , 7 , -9 , 10 , 12 , -6 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text":"Minimum cost to form a number X by adding up powers of 2 | Function to return the minimum cost ; Re - compute the array ; Add answers for set bits ; If bit is set ; Increase the counter ; Right shift the number ; Driver code","code":"< ? php function MinimumCost ( $ a , $ n , $ x ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = min ( $ a [ $ i ] , 2 * $ a [ $ i - 1 ] ) ; } $ ind = 0 ; $ sum = 0 ; while ( $ x ) { if ( $ x & 1 ) $ sum += $ a [ $ ind ] ; $ ind ++ ; $ x = $ x >> 1 ; } return $ sum ; } $ a = array ( 20 , 50 , 60 , 90 ) ; $ x = 7 ; $ n = sizeof ( $ a ) \/ sizeof ( $ a [ 0 ] ) ; echo MinimumCost ( $ a , $ n , $ x ) ; ? >"}
{"text":"Ways to form an array having integers in given range such that total sum is divisible by 2 | Function to return the number of ways to form an array of size n such that sum of all elements is divisible by 2 ; Represents first and last numbers of each type ( modulo 0 and 1 ) ; Count of numbers of each type between range ; Base Cases ; Ways to form array whose sum upto i numbers modulo 2 is 0 ; Ways to form array whose sum upto i numbers modulo 2 is 1 ; Return the required count of ways ; Driver Code","code":"< ? php function countWays ( $ n , $ l , $ r ) { $ tL = $ l ; $ tR = $ r ; $ L = array_fill ( 0 , 2 , 0 ) ; $ R = array_fill ( 0 , 2 , 0 ) ; $ L [ $ l % 2 ] = $ l ; $ R [ $ r % 2 ] = $ r ; $ l ++ ; $ r -- ; if ( $ l <= $ tR && $ r >= $ tL ) { $ L [ $ l % 2 ] = $ l ; $ R [ $ r % 2 ] = $ r ; } $ cnt0 = 0 ; $ cnt1 = 0 ; if ( $ R [ 0 ] && $ L [ 0 ] ) $ cnt0 = ( $ R [ 0 ] - $ L [ 0 ] ) \/ 2 + 1 ; if ( $ R [ 1 ] && $ L [ 1 ] ) $ cnt1 = ( $ R [ 1 ] - $ L [ 1 ] ) \/ 2 + 1 ; $ dp = array ( ) ; $ dp [ 1 ] [ 0 ] = $ cnt0 ; $ dp [ 1 ] [ 1 ] = $ cnt1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ 0 ] = ( $ cnt0 * $ dp [ $ i - 1 ] [ 0 ] + $ cnt1 * $ dp [ $ i - 1 ] [ 1 ] ) ; $ dp [ $ i ] [ 1 ] = ( $ cnt0 * $ dp [ $ i - 1 ] [ 1 ] + $ cnt1 * $ dp [ $ i - 1 ] [ 0 ] ) ; } return $ dp [ $ n ] [ 0 ] ; } $ n = 2 ; $ l = 1 ; $ r = 3 ; echo countWays ( $ n , $ l , $ r ) ; ? >"}
{"text":"Color N boxes using M colors such that K boxes have different color from the box on its left | PHP Program to Paint N boxes using M colors such that K boxes have color different from color of box on its left ; This function returns the required number of ways where idx is the current index and diff is number of boxes having different color from box on its left ; Base Case ; If already computed ; Either paint with same color as previous one ; Or paint with remaining ( M - 1 ) colors ; Driver code ; Multiply M since first box can be painted with any of the M colors and start solving from 2 nd box","code":"< ? php $ M = 1001 ; $ MOD = 998244353 ; $ dp = array_fill ( 0 , $ M , array_fill ( 0 , $ M , -1 ) ) ; function solve ( $ idx , $ diff , $ N , $ M , $ K ) { global $ dp , $ MOD ; if ( $ idx > $ N ) { if ( $ diff == $ K ) return 1 ; return 0 ; } if ( $ dp [ $ idx ] [ $ diff ] != -1 ) return $ dp [ $ idx ] [ $ diff ] ; $ ans = solve ( $ idx + 1 , $ diff , $ N , $ M , $ K ) ; $ ans += ( $ M - 1 ) * solve ( $ idx + 1 , $ diff + 1 , $ N , $ M , $ K ) ; return $ dp [ $ idx ] [ $ diff ] = $ ans % $ MOD ; } $ N = 3 ; $ M = 3 ; $ K = 0 ; echo ( $ M * solve ( 2 , 0 , $ N , $ M , $ K ) ) ; ? >"}
{"text":"Maximum path sum in an Inverted triangle | SET 2 | PHP program implementation of Max sum problem in a triangle ; Function for finding maximum sum ; Loop for bottom - up calculation ; For each element , check both elements just below the number and below left to the number add the maximum of them to it ; Return the maximum sum ; Driver Code","code":"< ? php $ N = 3 ; function maxPathSum ( $ tri ) { global $ N ; $ ans = 0 ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ N - $ i ; $ j ++ ) { if ( $ j - 1 >= 0 ) $ tri [ $ i ] [ $ j ] += max ( $ tri [ $ i + 1 ] [ $ j ] , $ tri [ $ i + 1 ] [ $ j - 1 ] ) ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; $ ans = max ( $ ans , $ tri [ $ i ] [ $ j ] ) ; } } return $ ans ; } $ tri = array ( array ( 1 , 5 , 3 ) , array ( 4 , 8 , 0 ) , array ( 1 , 0 , 0 ) ) ; echo maxPathSum ( $ tri ) ; ? >"}
{"text":"Count no . of ordered subsets having a particular XOR value | Returns count of ordered subsets of arr [ ] with XOR value = K ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] [ k ] is the number of subsets of length k having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] [ k ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subsets of all lengths from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver Code","code":"< ? php function subsetXOR ( $ arr , $ n , $ K ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( floor ( log ( $ max_ele , 2 ) ) + 1 ) ) - 1 ; $ dp = array ( array ( array ( ) ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) for ( $ k = 0 ; $ k <= $ n ; $ k ++ ) $ dp [ $ i ] [ $ j ] [ $ k ] = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ n ; $ k ++ ) { $ dp [ $ i ] [ $ j ] [ $ k ] = $ dp [ $ i - 1 ] [ $ j ] [ $ k ] ; if ( $ k != 0 ) { $ dp [ $ i ] [ $ j ] [ $ k ] += $ k * $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] [ $ k - 1 ] ; } } } } $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ ans += $ dp [ $ n ] [ $ K ] [ $ i ] ; } return $ ans ; } $ arr = [ 1 , 2 , 3 ] ; $ k = 1 ; $ n = sizeof ( $ arr ) ; echo subsetXOR ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Possible cuts of a number such that maximum parts are divisible by 3 | PHP program to find the maximum number of numbers divisible by 3 in a large number ; This will contain the count of the splits ; This will keep sum of all successive integers , when they are indivisible by 3 ; This is the condition of finding a split ; Driver Code","code":"< ? php function get_max_splits ( $ num_string ) { $ count = 0 ; $ running_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num_string ) ; $ i ++ ) { $ current_num = intval ( $ num_string [ $ i ] ) ; $ running_sum += $ current_num ; if ( $ current_num % 3 == 0 or ( $ running_sum != 0 and $ running_sum % 3 == 0 ) ) { $ count += 1 ; $ running_sum = 0 ; } } return $ count ; } print ( get_max_splits ( \"12345\" ) ) ; ? >"}
{"text":"Form N | Returns the minimum cost to form a n - copy string . Here , x -> Cost to add \/ remove a single character ' G ' and y -> cost to append the string to itself ; Base Case : to form a 1 - copy string we need to perform an operation of type 1 ( i . e Add ) ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 2 operation on ( ( i + 1 ) \/ 2 ) - copy string ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 3 operation on ( i \/ 2 ) - copy string ; Driver Code","code":"< ? php function findMinimumCost ( $ n , $ x , $ y ) { $ dp [ $ n + 1 ] = array ( ) ; $ dp [ 1 ] = $ x ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i & 1 ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ ( $ i + 1 ) \/ 2 ] + $ y + $ x ) ; } else { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ $ i \/ 2 ] + $ y ) ; } } return $ dp [ $ n ] ; } $ n = 4 ; $ x = 2 ; $ y = 1 ; echo findMinimumCost ( $ n , $ x , $ y ) ; ? >"}
{"text":"Count the number of special permutations | Function to return the number of ways to choose r objects out of n objects ; Function to return the number of derangements of n ; Function to return the required number of permutations ; Ways to choose i indices from n indices ; Dearangements of ( n - i ) indices ; Driver Code","code":"< ? php function nCr ( $ n , $ r ) { $ ans = 1 ; if ( $ r > $ n - $ r ) $ r = $ n - $ r ; for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { $ ans *= ( $ n - $ i ) ; $ ans \/= ( $ i + 1 ) ; } return $ ans ; } function countDerangements ( $ n ) { $ der = array ( $ n + 1 ) ; $ der [ 0 ] = 1 ; $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; } function countPermutations ( $ n , $ k ) { $ ans = 0 ; for ( $ i = $ n - $ k ; $ i <= $ n ; $ i ++ ) { $ ways = nCr ( $ n , $ i ) ; $ ans += $ ways * countDerangements ( $ n - $ i ) ; } return $ ans ; } $ n = 5 ; $ k = 3 ; echo ( countPermutations ( $ n , $ k ) ) ; ? >"}
{"text":"Ways to place K bishops on an N\u00c3 \u2014 N chessboard so that no two attack | returns the number of squares in diagonal i ; returns the number of ways to fill a n * n chessboard with k bishops so that no two bishops attack each other . ; return 0 if the number of valid places to be filled is less than the number of bishops ; dp table to store the values ; Setting the base conditions ; calculate the required number of ways ; stores the answer ; Driver code","code":"< ? php function squares ( $ i ) { if ( ( $ i & 1 ) == 1 ) return intval ( $ i \/ 4 ) * 2 + 1 ; else return intval ( ( $ i - 1 ) \/ 4 ) * 2 + 2 ; } function bishop_placements ( $ n , $ k ) { if ( $ k > 2 * $ n - 1 ) return 0 ; $ dp = array_fill ( 0 , $ n * 2 , array_fill ( 0 , $ k + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < $ n * 2 ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; $ dp [ 1 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n * 2 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 2 ] [ $ j ] + $ dp [ $ i - 2 ] [ $ j - 1 ] * ( squares ( $ i ) - $ j + 1 ) ; } $ ans = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) { $ ans += $ dp [ $ n * 2 - 1 ] [ $ i ] * $ dp [ $ n * 2 - 2 ] [ $ k - $ i ] ; } return $ ans ; } $ n = 2 ; $ k = 2 ; $ ans = bishop_placements ( $ n , $ k ) ; echo $ ans ; ? >"}
{"text":"Total number of different staircase that can made from N boxes | Function to find the total number of different staircase that can made from N boxes ; Initialize all the elements of the table to zero ; Base case ; When step is equal to 2 ; When step is greater than 2 ; Count the total staircase from all the steps ; Driver Code","code":"< ? php function countStaircases ( $ N ) { for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ N ; $ j ++ ) { $ memo [ $ i ] [ $ j ] = 0 ; } } $ memo [ 3 ] [ 2 ] = $ memo [ 4 ] [ 2 ] = 1 ; for ( $ i = 5 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 2 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 2 ) { $ memo [ $ i ] [ $ j ] = $ memo [ $ i - $ j ] [ $ j ] + 1 ; } else { $ memo [ $ i ] [ $ j ] = $ memo [ $ i - $ j ] [ $ j ] + $ memo [ $ i - $ j ] [ $ j - 1 ] ; } } } $ answer = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ answer = $ answer + $ memo [ $ N ] [ $ i ] ; return $ answer ; } $ N = 7 ; echo countStaircases ( $ N ) ; ? >"}
{"text":"Count the number of ways to traverse a Matrix | Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Return 1 if it is the first row or first column ; Recursively find the no of way to reach the last cell . ; Driver code","code":"< ? php function countPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return countPaths ( $ m - 1 , $ n ) + countPaths ( $ m , $ n - 1 ) ; } $ n = 5 ; $ m = 5 ; echo countPaths ( $ n , $ m ) ; ? >"}
{"text":"Count the number of ways to traverse a Matrix | Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Driver code","code":"< ? php function countPaths ( $ m , $ n ) { $ dp ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 1 $ j == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; } } return $ dp [ $ m ] [ $ n ] ; } $ n = 5 ; $ m = 5 ; echo countPaths ( $ n , $ m ) ; ? >"}
{"text":"Number of ways a convex polygon of n + 2 sides can split into triangles by connecting vertices | Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn \/ ( n + 1 ) ; Driver code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return $ c \/ ( $ n + 1 ) ; } $ n = 3 ; echo catalan ( $ n ) ; ? >"}
{"text":"Alternate Fibonacci Numbers | Alternate Fibonacci Series using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Driver Code","code":"< ? php function alternateFib ( $ n ) { if ( $ n < 0 ) return ; $ f1 = 0 ; $ f2 = 1 ; echo $ f1 . \" \" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ f3 = $ f2 + $ f1 ; if ( $ i % 2 == 0 ) echo $ f3 . \" \" ; $ f1 = $ f2 ; $ f2 = $ f3 ; } } $ N = 15 ; alternateFib ( $ N ) ; ? >"}
{"text":"Number of ways to form an array with distinct adjacent elements | Returns the total ways to form arrays such that every consecutive element is different and each element except the first and last can take values from 1 to M ; define the dp [ ] [ ] array ; if the first element is 1 ; there is only one way to place a 1 at the first index ; the value at first index needs to be 1 , thus there is no way to place a non - one integer ; if the first element was 1 then at index 1 , only non one integer can be placed thus there are M - 1 ways to place a non one integer at index 2 and 0 ways to place a 1 at the 2 nd index ; Else there is one way to place a one at index 2 and if a non one needs to be placed here , there are ( M - 2 ) options , i . e neither the element at this index should be 1 , neither should it be equal to the previous element ; Build the dp array in bottom up manner ; f ( i , one ) = f ( i - 1 , non - one ) ; f ( i , non - one ) = f ( i - 1 , one ) * ( M - 1 ) + f ( i - 1 , non - one ) * ( M - 2 ) ; last element needs to be one , so return dp [ n - 1 ] [ 0 ] ; Driver Code","code":"< ? php function totalWays ( $ N , $ M , $ X ) { $ dp = array ( array ( ) ) ; if ( $ X == 1 ) { $ dp [ 0 ] [ 0 ] = 1 ; } else { $ dp [ 0 ] [ 1 ] = 0 ; } if ( $ X == 1 ) { $ dp [ 1 ] [ 0 ] = 0 ; $ dp [ 1 ] [ 1 ] = $ M - 1 ; } else { $ dp [ 1 ] [ 0 ] = 1 ; $ dp [ 1 ] [ 1 ] = ( $ M - 2 ) ; } for ( $ i = 2 ; $ i < $ N ; $ i ++ ) { $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 1 ] ; $ dp [ $ i ] [ 1 ] = $ dp [ $ i - 1 ] [ 0 ] * ( $ M - 1 ) + $ dp [ $ i - 1 ] [ 1 ] * ( $ M - 2 ) ; } return $ dp [ $ N - 1 ] [ 0 ] ; } $ N = 4 ; $ M = 3 ; $ X = 2 ; echo totalWays ( $ N , $ M , $ X ) ; ? >"}
{"text":"Memoization ( 1D , 2D and 3D ) | Fibonacci Series using Recursion ; Base case ; recursive calls ; Driver Code","code":"< ? php function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; } $ n = 6 ; echo fib ( $ n ) ; ? >"}
{"text":"Sum of product of consecutive Binomial Coefficients | PHP Program to find sum of product of consecutive Binomial Coefficient . ; Find the binomial coefficient up to nth term ; $C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the sum of the product of consecutive binomial coefficient . ; Driver Code","code":"< ? php $ MAX = 100 ; function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , ( $ k + 1 ) , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } function sumOfproduct ( $ n ) { return binomialCoeff ( 2 * $ n , $ n - 1 ) ; } $ n = 3 ; echo sumOfproduct ( $ n ) ; ? >"}
{"text":"Print Fibonacci sequence using 2 variables | Simple php Program to print Fibonacci sequence ; Driver code","code":"< ? php function fib ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n >= 0 ) echo $ a , \" \u2581 \" ; if ( $ n >= 1 ) echo $ b , \" \u2581 \" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; echo $ c , \" \" ; $ a = $ b ; $ b = $ c ; } } fib ( 9 ) ; ? >"}
{"text":"Maximum sum increasing subsequence from a prefix and a given element after prefix is must | PHP program to find maximum sum increasing subsequence till i - th index and including k - th index . ; Initializing the first row of the dp [ ] [ ] . ; Creating the dp [ ] [ ] matrix . ; To calculate for i = 4 and k = 6. ; Driver Code","code":"< ? php function pre_compute ( & $ a , $ n , $ index , $ k ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ a [ 0 ] ) $ dp [ 0 ] [ $ i ] = $ a [ $ i ] + $ a [ 0 ] ; else $ dp [ 0 ] [ $ i ] = $ a [ $ i ] ; } for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] > $ a [ $ i ] && $ j > $ i ) { if ( ( $ dp [ $ i - 1 ] [ $ i ] + $ a [ $ j ] ) > $ dp [ $ i - 1 ] [ $ j ] ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ i ] + $ a [ $ j ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] ; } else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] ; } } return $ dp [ $ index ] [ $ k ] ; } $ a = array ( 1 , 101 , 2 , 3 , 100 , 4 , 5 ) ; $ n = sizeof ( $ a ) ; $ index = 4 ; $ k = 6 ; echo pre_compute ( $ a , $ n , $ index , $ k ) ; ? >"}
{"text":"Moser | Function to generate nth term of Moser - de Bruijn Sequence ; S ( 2 * n ) = 4 * S ( n ) ; S ( 2 * n + 1 ) = 4 * S ( n ) + 1 ; Generating the first ' n ' terms of Moser - de Bruijn Sequence ; Driver Code","code":"< ? php function gen ( $ n ) { $ S = array ( ) ; $ S [ 0 ] = 0 ; $ S [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ S [ $ i ] = 4 * $ S [ $ i \/ 2 ] ; else $ S [ $ i ] = 4 * $ S [ $ i \/ 2 ] + 1 ; } return $ S [ $ n ] ; } function moserDeBruijn ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo gen ( $ i ) , \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ n = 15 ; echo \" First \u2581 \" , $ n , \" \u2581 terms \u2581 of \u2581 \" , \" Moser - de \u2581 Bruijn \u2581 Sequence \u2581 : \u2581 STRNEWLINE \" ; moserDeBruijn ( $ n ) ; ? >"}
{"text":"Longest Common Substring ( Space optimized DP solution ) | Function to find longest common substring . ; Find length of both the strings . ; Variable to store length of longest common substring . ; Matrix to store result of two consecutive rows at a time . ; Variable to represent which row of matrix is current row . ; For a particular value of i and j , len [ currRow ] [ j ] stores length of longest common substring in string X [ 0. . i ] and Y [ 0. . j ] . ; Make current row as previous row and previous row as new current row . ; Driver Code","code":"< ? php function LCSubStr ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ result = 0 ; $ len = array ( array ( ) , array ( ) , ) ; $ currRow = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) { $ len [ $ currRow ] [ $ j ] = 0 ; } else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ len [ $ currRow ] [ $ j ] = $ len [ 1 - $ currRow ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ len [ $ currRow ] [ $ j ] ) ; } else { $ len [ $ currRow ] [ $ j ] = 0 ; } } $ currRow = 1 - $ currRow ; } return $ result ; } $ X = \" GeeksforGeeks \" ; $ Y = \" GeeksQuiz \" ; print ( LCSubStr ( $ X , $ Y ) ) ; ? >"}
{"text":"Minimal moves to form a string by adding characters or appending string itself | function to return the minimal number of moves ; initializing dp [ i ] to INT_MAX ; initialize both strings to null ; base case ; check if it can be appended ; addition of character takes one step ; appending takes 1 step , and we directly reach index i * 2 + 1 after appending so the number of steps is stord in i * 2 + 1 ; Driver Code ; function call to return minimal number of moves","code":"< ? php function minimalSteps ( $ s , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = PHP_INT_MAX ; $ s1 = \" \" ; $ s2 = \" \" ; $ dp [ 0 ] = 1 ; $ s1 = $ s1 . $ s [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ s1 = $ s1 . $ s [ $ i ] ; $ s2 = substr ( $ s , $ i + 1 , $ i + 1 ) ; $ dp [ $ i ] = min ( $ dp [ $ i ] , $ dp [ $ i - 1 ] + 1 ) ; if ( $ s1 == $ s2 ) $ dp [ $ i * 2 + 1 ] = min ( $ dp [ $ i ] + 1 , $ dp [ $ i * 2 + 1 ] ) ; } return $ dp [ $ n - 1 ] ; } $ s = \" aaaaaaaa \" ; $ n = strlen ( $ s ) ; echo minimalSteps ( $ s , $ n ) ; ? >"}
{"text":"Golomb sequence | Print the first n term of Golomb Sequence ; base cases ; Finding and printing first n terms of Golomb Sequence . ; Driver Code","code":"< ? php function printGolomb ( $ n ) { $ dp [ 1 ] = 1 ; echo $ dp [ 1 ] , \" \" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = 1 + $ dp [ $ i - $ dp [ $ dp [ $ i - 1 ] ] ] ; echo $ dp [ $ i ] , \" \" ; } } $ n = 9 ; printGolomb ( $ n ) ; ? >"}
{"text":"Maximum difference of zeros and ones in binary string | Set 2 ( O ( n ) time ) | Returns the length of substring with maximum difference of zeroes and ones in binary string ; traverse a binary string from left to right ; add current value to the current_sum according to the Character if it ' s \u2581 ' 0 ' add 1 else -1 ; update maximum sum ; return - 1 if string does not contain any zero that means all ones otherwise max_sum ; Driver Code","code":"< ? php function findLength ( $ str , $ n ) { $ current_sum = 0 ; $ max_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_sum += ( $ str [ $ i ] == '0' ? 1 : -1 ) ; if ( $ current_sum < 0 ) $ current_sum = 0 ; $ max_sum = max ( $ current_sum , $ max_sum ) ; } return $ max_sum == 0 ? -1 : $ max_sum ; } $ s = \"11000010001\" ; $ n = 11 ; echo findLength ( $ s , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Number of decimal numbers of length k , that are strict monotone | PHP program to count numbers of k digits that are strictly monotone . ; DP [ i ] [ j ] is going to store monotone numbers of length i + 1 considering j + 1 digits ( 1 , 2 , 3 , . .9 ) ; Unit length numbers ; Building dp [ ] in bottom up ; Driver code","code":"< ? php $ DP_s = 9 ; function getNumStrictMonotone ( $ len ) { global $ DP_s ; $ DP = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = 0 ; $ j < $ DP_s ; $ j ++ ) $ DP [ $ i ] [ $ j ] = 0 ; } for ( $ i = 0 ; $ i < $ DP_s ; ++ $ i ) $ DP [ 0 ] [ $ i ] = $ i + 1 ; for ( $ i = 1 ; $ i < $ len ; ++ $ i ) for ( $ j = 1 ; $ j < $ DP_s ; ++ $ j ) $ DP [ $ i ] [ $ j ] = $ DP [ $ i - 1 ] [ $ j - 1 ] + $ DP [ $ i ] [ $ j - 1 ] ; return $ DP [ $ len - 1 ] [ $ DP_s - 1 ] ; } echo ( getNumStrictMonotone ( 2 ) ) ; ? >"}
{"text":"Count ways to divide circle using N non | PHP code to count ways to divide circle using N non - intersecting chords . ; n = no of points required ; dp array containing the sum ; returning the required number ; Driver Code","code":"< ? php function chordCnt ( $ A ) { $ n = 2 * $ A ; $ dpArray = array_fill ( 0 , $ n + 1 , 0 ) ; $ dpArray [ 0 ] = 1 ; $ dpArray [ 2 ] = 1 ; for ( $ i = 4 ; $ i <= $ n ; $ i += 2 ) { for ( $ j = 0 ; $ j < $ i - 1 ; $ j += 2 ) { $ dpArray [ $ i ] += ( $ dpArray [ $ j ] * $ dpArray [ $ i - 2 - $ j ] ) ; } } return $ dpArray [ $ n ] ; } $ N = 2 ; echo chordCnt ( $ N ) , \" STRNEWLINE \" ; $ N = 1 ; echo chordCnt ( $ N ) , \" STRNEWLINE \" ; $ N = 4 ; echo chordCnt ( $ N ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check for possible path in 2D matrix | PHP program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; set arr [ 0 ] [ 0 ] = 1 ; Mark reachable ( from top left ) nodes in first row and first column . ; Mark reachable nodes in remaining matrix . ; return yes if right bottom index is 1 ; Given array ; path from arr [ 0 ] [ 0 ] to arr [ row ] [ col ]","code":"< ? php $ row = 5 ; $ col = 5 ; function isPath ( $ arr ) { global $ row , $ col ; $ arr [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) if ( $ arr [ $ i ] [ 0 ] != -1 ) $ arr [ $ i ] [ 0 ] = $ arr [ $ i - 1 ] [ 0 ] ; for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ 0 ] [ $ j ] != -1 ) $ arr [ 0 ] [ $ j ] = $ arr [ 0 ] [ $ j - 1 ] ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ $ i ] [ $ j ] != -1 ) $ arr [ $ i ] [ $ j ] = max ( $ arr [ $ i ] [ $ j - 1 ] , $ arr [ $ i - 1 ] [ $ j ] ) ; return ( $ arr [ $ row - 1 ] [ $ col - 1 ] == 1 ) ; } $ arr = array ( array ( 0 , 0 , 0 , 1 , 0 ) , array ( -1 , 0 , 0 , -1 , -1 ) , array ( 0 , 0 , 0 , -1 , 0 ) , array ( -1 , 0 , -1 , 0 , -1 ) , array ( 0 , 0 , -1 , 0 , 0 ) ) ; if ( isPath ( $ arr ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Newman\u00e2 \u20ac\u201c Shanks\u00e2 \u20ac\u201c Williams prime | return nth Newman a Shanks a Williams prime ; Base case ; Recursive step ; Driver Code","code":"< ? php function nswp ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return 2 * nswp ( $ n - 1 ) + nswp ( $ n - 2 ) ; } $ n = 3 ; echo ( nswp ( $ n ) ) ; ? >"}
{"text":"Newman Shanks Williams prime | return nth Newman Shanks Williams prime ; Base case ; Finding nth Newman Shanks Williams prime ; Driver Code","code":"< ? php function nswp ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = 2 * $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; } $ n = 3 ; echo ( nswp ( $ n ) ) ; ? >"}
{"text":"Minimum cost to make two strings identical by deleting the digits | Function to returns cost of removing the identical characters in LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains cost of removing identical characters in LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; If both characters are same , add both of them ; Otherwise find the maximum cost among them ; Returns cost of making X [ ] and Y [ ] identical ; Find LCS of X [ ] and Y [ ] ; Initialize the cost variable ; Find cost of all characters in both strings ; Driver code","code":"< ? php function lcs ( $ X , $ Y , $ m , $ n ) { $ L = array ( $ m + 1 , $ n + 1 ) ; for ( $ i = 0 ; $ i <= $ m ; ++ $ i ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 2 * ( $ X [ $ i - 1 ] - '0' ) ; else $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j ] > $ L [ $ i ] [ $ j - 1 ] ? $ L [ $ i - 1 ] [ $ j ] : $ L [ $ i ] [ $ j - 1 ] ; } } return $ L [ $ m ] [ $ n ] ; } function findMinCost ( $ X , $ Y ) { $ m = sizeof ( $ X ) ; $ n = sizeof ( $ Y ) ; $ cost = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) $ cost += $ X [ $ i ] - '0' ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += $ Y [ $ i ] - '0' ; return $ cost - lcs ( $ X , $ Y , $ m , $ n ) ; } $ X = str_split ( \"3759\" ) ; $ Y = str_split ( \"9350\" ) ; echo ( \" Minimum \u2581 Cost \u2581 to \u2581 make \u2581 two \u2581 strings \" . \" identical is = \""}
{"text":"Given a large number , check if a subsequence of digits is divisible by 8 | Function takes in an array of numbers , dynamically goes on the location and makes combination of numbers . ; Converting string to integer array for ease of computations ( Indexing in arr [ ] is considered to be starting from 1 ) ; If we consider the number in our combination , we add it to the previous combination ; If we exclude the number from our combination ; If at dp [ i ] [ 0 ] , we find value 1 \/ true , it shows that the number exists at the value of ' i ' ; Driver Code","code":"< ? php function isSubSeqDivisible ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , 10 , NULL ) ) ; $ arr = array_fill ( 0 , ( $ n + 1 ) , NULL ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ str [ $ i - 1 ] - '0' ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ arr [ $ i ] % 8 ] = 1 ; for ( $ j = 0 ; $ j < 8 ; $ j ++ ) { if ( $ dp [ $ i - 1 ] [ $ j ] > $ dp [ $ i ] [ ( $ j * 10 + $ arr [ $ i ] ) % 8 ] ) $ dp [ $ i ] [ ( $ j * 10 + $ arr [ $ i ] ) % 8 ] = $ dp [ $ i - 1 ] [ $ j ] ; if ( $ dp [ $ i - 1 ] [ $ j ] > $ dp [ $ i ] [ $ j ] ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] ; } } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ dp [ $ i ] [ 0 ] == 1 ) return true ; } return false ; } $ str = \"3144\" ; if ( isSubSeqDivisible ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Length of Longest Balanced Subsequence | PHP program to find length of the longest balanced subsequence ; Considering all balanced substrings of length 2 ; Considering all other substrings ; Driver Code","code":"< ? php function maxLength ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ s [ $ i ] == ' ( ' && $ s [ $ i + 1 ] == ' ) ' ) $ dp [ $ i ] [ $ i + 1 ] = 2 ; for ( $ l = 2 ; $ l < $ n ; $ l ++ ) { for ( $ i = 0 , $ j = $ l ; $ j < $ n ; $ i ++ , $ j ++ ) { if ( $ s [ $ i ] == ' ( ' && $ s [ $ j ] == ' ) ' ) $ dp [ $ i ] [ $ j ] = 2 + $ dp [ $ i + 1 ] [ $ j - 1 ] ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i ] [ $ k ] + $ dp [ $ k + 1 ] [ $ j ] ) ; } } return $ dp [ 0 ] [ $ n - 1 ] ; } $ s = \" ( ) ( ( ( ( ( ( ) \" ; $ n = strlen ( $ s ) ; echo maxLength ( $ s , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Smallest sum contiguous subarray | function to find the smallest sum contiguous subarray ; to store the minimum value that is ending up to the current index ; to store the minimum value encountered so far ; traverse the array elements ; if min_ending_here > 0 , then it could not possibly contribute to the minimum sum further ; else add the value arr [ i ] to min_ending_here ; update min_so_far ; required smallest sum contiguous subarray value ; Driver Code","code":"< ? php function smallestSumSubarr ( $ arr , $ n ) { $ min_ending_here = 999999 ; $ min_so_far = 999999 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min_ending_here > 0 ) $ min_ending_here = $ arr [ $ i ] ; else $ min_ending_here += $ arr [ $ i ] ; $ min_so_far = min ( $ min_so_far , $ min_ending_here ) ; } return $ min_so_far ; } $ arr = array ( 3 , -4 , 2 , -3 , -1 , 7 , -5 ) ; $ n = count ( $ arr ) ; echo \" Smallest \u2581 sum : \u2581 \" . smallestSumSubarr ( $ arr , $ n ) ; ? >"}
{"text":"Painting Fence Algorithm | Returns count of ways to color k posts using k colors ; There are k ways to color first post ; There are 0 ways for single post to violate ( same color_ and k ways to not violate ( different color ) ; Fill for 2 posts onwards ; Current same is same as previous diff ; We always have k - 1 choices for next post ; Total choices till i . ; Driver code","code":"< ? php function countWays ( $ n , $ k ) { $ total = $ k ; $ mod = 1000000007 ; $ same = 0 ; $ diff = $ k ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ same = $ diff ; $ diff = $ total * ( $ k - 1 ) ; $ diff = $ diff % $ mod ; $ total = ( $ same + $ diff ) % $ mod ; } return $ total ; } $ n = 3 ; $ k = 2 ; echo countWays ( $ n , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text":"Sum of all substrings of a string representing a number | Set 2 ( Constant Extra Space ) | Returns sum of all substring of num ; Initialize result ; Here traversing the array in reverse order . Initializing loop from last element . mf is multiplying factor . ; Each time sum is added to its previous sum . Multiplying the three factors as explained above . s [ i ] - '0' is done to convert char to int . ; Making new multiplying factor as explained above . ; Driver Code","code":"< ? php function sumOfSubstrings ( $ num ) { $ sum = 0 ; $ mf = 1 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ sum += ( $ num [ $ i ] - '0' ) * ( $ i + 1 ) * $ mf ; $ mf = $ mf * 10 + 1 ; } return $ sum ; } $ num = \"6759\" ; echo sumOfSubstrings ( $ num ) , \" STRNEWLINE \" ; ? >"}
{"text":"Largest sum subarray with at | Returns maximum sum of a subarray with at - least k elements . ; maxSum [ i ] is going to store maximum sum till index i such that a [ i ] is part of the sum . ; We use Kadane 's algorithm  to fill maxSum[] ; Sum of first k elements ; Use the concept of sliding window ; Compute sum of k elements ending with a [ i ] . ; Update result if required ; Include maximum sum till [ i - k ] also if it increases overall max . ; Driver code","code":"< ? php function maxSumWithK ( $ a , $ n , $ k ) { $ maxSum [ 0 ] = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ maxSum [ $ i ] = $ curr_max ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ sum += $ a [ $ i ] ; $ result = $ sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ a [ $ i ] - $ a [ $ i - $ k ] ; $ result = max ( $ result , $ sum ) ; $ result = max ( $ result , $ sum + $ maxSum [ $ i - $ k ] ) ; } return $ result ; } $ a = array ( 1 , 2 , 3 , -10 , -3 ) ; $ k = 4 ; $ n = sizeof ( $ a ) ; echo maxSumWithK ( $ a , $ n , $ k ) ; ? >"}
{"text":"Ways to sum to N using array elements with repetition allowed | function to count the total number of ways to sum up to ' N ' ; base case ; count ways for all values up to ' N ' and store the result ; if i >= arr [ j ] then accumulate count for value ' i ' as ways to form value ' i - arr [ j ] ' ; required number of ways ; Driver code","code":"< ? php function countWays ( $ arr , $ m , $ N ) { $ count = array_fill ( 0 , $ N + 1 , 0 ) ; $ count [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ i >= $ arr [ $ j ] ) $ count [ $ i ] += $ count [ $ i - $ arr [ $ j ] ] ; return $ count [ $ N ] ; } $ arr = array ( 1 , 5 , 6 ) ; $ m = count ( $ arr ) ; $ N = 7 ; echo \" Total \u2581 number \u2581 of \u2581 ways \u2581 = \u2581 \" , countWays ( $ arr , $ m , $ N ) ; ? >"}
{"text":"Sequences of given length where every element is more than or equal to twice of previous | Recursive function to find the number of special sequences ; A special sequence cannot exist if length n is more than the maximum value m . ; If n is 0 , found an empty special sequence ; There can be two possibilities : ( 1 ) Reduce last element value ( 2 ) Consider last element as m and reduce number of terms ; Driver Code","code":"< ? php function getTotalNumberOfSequences ( $ m , $ n ) { if ( $ m < $ n ) return 0 ; if ( $ n == 0 ) return 1 ; return getTotalNumberOfSequences ( $ m - 1 , $ n ) + getTotalNumberOfSequences ( $ m \/ 2 , $ n - 1 ) ; } $ m = 10 ; $ n = 4 ; echo ( \" Total \u2581 number \u2581 of \u2581 possible \u2581 sequences \u2581 \" ) ; echo ( getTotalNumberOfSequences ( $ m , $ n ) ) ; ? >"}
{"text":"Sequences of given length where every element is more than or equal to twice of previous | DP based function to find the number of special sequences ; define T and build in bottom manner to store number of special sequences of length n and maximum value m ; Base case : If length of sequence is 0 or maximum value is 0 , there cannot exist any special sequence ; if length of sequence is more than the maximum value , special sequence cannot exist ; If length of sequence is 1 then the number of special sequences is equal to the maximum value For example with maximum value 2 and length 1 , there can be 2 special sequences { 1 } , { 2 } ; otherwise calculate ; Driver Code","code":"< ? php function getTotalNumberOfSequences ( $ m , $ n ) { $ T = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) { if ( $ i == 0 or $ j == 0 ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ i < $ j ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ j == 1 ) $ T [ $ i ] [ $ j ] = $ i ; else $ T [ $ i ] [ $ j ] = $ T [ $ i - 1 ] [ $ j ] + $ T [ $ i \/ 2 ] [ $ j - 1 ] ; } } return $ T [ $ m ] [ $ n ] ; } $ m = 10 ; $ n = 4 ; echo \" Total \u2581 number \u2581 of \u2581 possible \u2581 sequences \u2581 \" , getTotalNumberOfSequences ( $ m , $ n ) ; ? >"}
{"text":"Minimum number of deletions to make a sorted sequence | lis ( ) returns the length of the longest increasing subsequence in arr [ ] of size n ; Initialize LIS values for all indexes ; Compute optimized LIS values in bottom up manner ; Pick resultimum of all LIS values ; function to calculate minimum number of deletions ; Find longest increasing subsequence ; After removing elements other than the lis , we get sorted sequence . ; Driver Code","code":"< ? php function lis ( $ arr , $ n ) { $ result = 0 ; $ lis [ $ n ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ lis [ $ i ] ) $ result = $ lis [ $ i ] ; return $ result ; } function minimumNumberOfDeletions ( $ arr , $ n ) { $ len = lis ( $ arr , $ n ) ; return ( $ n - $ len ) ; } $ arr = array ( 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo \" Minimum \u2581 number \u2581 of \u2581 deletions \u2581 = \u2581 \" , minimumNumberOfDeletions ( $ arr , $ n ) ; ? >"}
{"text":"Minimum number of deletions to make a string palindrome | Returns the length of the longest palindromic subsequence in ' str ' ; Create a table to store results of subproblems ; Strings of length 1 are palindrome of length 1 ; Build the table . Note that the lower diagonal values of table are useless and not filled in the process . c1 is length of substring ; length of longest palindromic subseq ; function to calculate minimum number of deletions ; Find longest palindromic subsequence ; After removing characters other than the lps , we get palindrome . ; Driver Code","code":"< ? php function lps ( $ str ) { $ n = strlen ( $ str ) ; $ L ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ L [ $ i ] [ $ i ] = 1 ; for ( $ cl = 2 ; $ cl <= $ n ; $ cl ++ ) { for ( $ i = 0 ; $ i < $ n - $ cl + 1 ; $ i ++ ) { $ j = $ i + $ cl - 1 ; if ( $ str [ $ i ] == $ str [ $ j ] && $ cl == 2 ) $ L [ $ i ] [ $ j ] = 2 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i + 1 ] [ $ j - 1 ] + 2 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i ] [ $ j - 1 ] , $ L [ $ i + 1 ] [ $ j ] ) ; } } return $ L [ 0 ] [ $ n - 1 ] ; } function minimumNumberOfDeletions ( $ str ) { $ n = strlen ( $ str ) ; $ len = lps ( $ str ) ; return ( $ n - $ len ) ; } { $ str = \" geeksforgeeks \" ; echo \" Minimum \u2581 number \u2581 of \u2581 deletions \u2581 = \u2581 \" , minimumNumberOfDeletions ( $ str ) ; return 0 ; } ? >"}
{"text":"Temple Offerings | Returns minimum offerings required ; Go through all templs one by one ; Go to left while height keeps increasing ; Go to right while height keeps increasing ; This temple should offer maximum of two values to follow the rule . ; Driver code","code":"< ? php function offeringNumber ( $ n , $ templeHeight ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ left = 0 ; $ right = 0 ; for ( $ j = $ i - 1 ; $ j >= 0 ; -- $ j ) { if ( $ templeHeight [ $ j ] < $ templeHeight [ $ j + 1 ] ) ++ $ left ; else break ; } for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { if ( $ templeHeight [ $ j ] < $ templeHeight [ $ j - 1 ] ) ++ $ right ; else break ; } $ sum += max ( $ right , $ left ) + 1 ; } return $ sum ; } $ arr1 = array ( 1 , 2 , 2 ) ; echo offeringNumber ( 3 , $ arr1 ) , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 4 , 3 , 6 , 2 , 1 ) ; echo offeringNumber ( 6 , $ arr2 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Subset with sum divisible by m | Returns true if there is a subset of arr [ ] with sum divisible by m ; This array will keep track of all the possible sum ( after modulo m ) which can be made using subsets of arr [ ] initialising boolean array with all false ; we 'll loop through all the elements of arr[] ; anytime we encounter a sum divisible by m , we are done ; To store all the new encountered sum ( after modulo ) . It is used to make sure that arr [ i ] is added only to those entries for which DP [ j ] was true before current iteration . ; For each element of arr [ ] , we loop through all elements of DP table from 1 to m and we add current element i . e . , arr [ i ] to all those elements which are true in DP table ; if an element is true in DP table ; We update it in temp and update to DP once loop of j is over ; Updating all the elements of temp to DP table since iteration over j is over ; Also since arr [ i ] is a single element subset , arr [ i ] % m is one of the possible sum ; Driver Code","code":"< ? php function modularSum ( $ arr , $ n , $ m ) { if ( $ n > $ m ) return true ; $ DP = Array_fill ( 0 , $ m , false ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ DP [ 0 ] ) return true ; $ temp = array_fill ( 0 , $ m , false ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ DP [ $ j ] == true ) { if ( $ DP [ ( $ j + $ arr [ $ i ] ) % $ m ] == false ) $ temp [ ( $ j + $ arr [ $ i ] ) % $ m ] = true ; } } for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ temp [ $ j ] ) $ DP [ $ j ] = true ; $ DP [ $ arr [ $ i ] % $ m ] = true ; } return $ DP [ 0 ] ; } $ arr = array ( 1 , 7 ) ; $ n = sizeof ( $ arr ) ; $ m = 5 ; if ( modularSum ( $ arr , $ n , $ m ) == true ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text":"Maximum sum of a path in a Right Number Triangle | function to find maximum sum path ; Adding the element of row 1 to both the elements of row 2 to reduce a step from the loop ; Traverse remaining rows ; Loop to traverse columns ; tri [ i ] would store the possible combinations of sum of the paths ; array at n - 1 index ( tri [ i ] ) stores all possible adding combination , finding the maximum one out of them ; Driver Code","code":"< ? php function maxSum ( $ tri , $ n ) { if ( $ n > 1 ) $ tri [ 1 ] [ 1 ] = $ tri [ 1 ] [ 1 ] + $ tri [ 0 ] [ 0 ] ; $ tri [ 1 ] [ 0 ] = $ tri [ 1 ] [ 0 ] + $ tri [ 0 ] [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ tri [ $ i ] [ 0 ] = $ tri [ $ i ] [ 0 ] + $ tri [ $ i - 1 ] [ 0 ] ; $ tri [ $ i ] [ $ i ] = $ tri [ $ i ] [ $ i ] + $ tri [ $ i - 1 ] [ $ i - 1 ] ; for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j - 1 ] >= $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j ] ) $ tri [ $ i ] [ $ j ] = $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j - 1 ] ; else $ tri [ $ i ] [ $ j ] = $ tri [ $ i ] [ $ j ] + $ tri [ $ i - 1 ] [ $ j ] ; } } $ max = $ tri [ $ n - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ max < $ tri [ $ n - 1 ] [ $ i ] ) $ max = $ tri [ $ n - 1 ] [ $ i ] ; } return $ max ; } $ tri = array ( array ( 1 ) , array ( 2 , 1 ) , array ( 3 , 3 , 2 ) ) ; echo maxSum ( $ tri , 3 ) ; ? >"}
{"text":"Modify array to maximize sum of adjacent differences | Returns maximum - difference - sum with array modifications allowed . ; Initialize dp [ ] [ ] with 0 values . ; for [ i + 1 ] [ 0 ] ( i . e . current modified value is 1 ) , choose maximum from dp [ $i ] [ 0 ] + abs ( 1 - 1 ) = dp [ i ] [ 0 ] and dp [ $i ] [ 1 ] + abs ( 1 - arr [ i ] ) ; for [ i + 1 ] [ 1 ] ( i . e . current modified value is arr [ i + 1 ] ) , choose maximum from dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) and dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ; Driver Code","code":"< ? php function maximumDifferenceSum ( $ arr , $ N ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ 1 ] = 0 ; for ( $ i = 0 ; $ i < ( $ N - 1 ) ; $ i ++ ) { $ dp [ $ i + 1 ] [ 0 ] = max ( $ dp [ $ i ] [ 0 ] , $ dp [ $ i ] [ 1 ] + abs ( 1 - $ arr [ $ i ] ) ) ; $ dp [ $ i + 1 ] [ 1 ] = max ( $ dp [ $ i ] [ 0 ] + abs ( $ arr [ $ i + 1 ] - 1 ) , $ dp [ $ i ] [ 1 ] + abs ( $ arr [ $ i + 1 ] - $ arr [ $ i ] ) ) ; } return max ( $ dp [ $ N - 1 ] [ 0 ] , $ dp [ $ N - 1 ] [ 1 ] ) ; } $ arr = array ( 3 , 2 , 1 , 4 , 5 ) ; $ N = count ( $ arr ) ; echo maximumDifferenceSum ( $ arr , $ N ) ; ? >"}
{"text":"Probability of Knight to remain in the chessboard | size of the chessboard ; direction vector for the Knight ; returns true if the knight is inside the chessboard ; Bottom up approach for finding the probability to go out of chessboard . ; dp array ; for 0 number of steps , each position will have probability 1 ; for every number of steps s ; for every position ( x , y ) after s number of steps ; for every position reachable from ( x , y ) ; if this position lie inside the board ; store the result ; return the result ; number of steps ; Function Call","code":"< ? php $ N = 8 ; $ dx = array ( 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 ) ; $ dy = array ( 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 ) ; function inside ( $ x , $ y ) { global $ N ; return ( $ x >= 0 and $ x < $ N and $ y >= 0 and $ y < $ N ) ; } function findProb ( $ start_x , $ start_y , $ steps ) { global $ N , $ dx , $ dy ; $ dp1 = array_fill ( 0 , $ N , array_fill ( 0 , $ N , array_fill ( 0 , $ steps + 1 , NULL ) ) ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) for ( $ j = 0 ; $ j < $ N ; ++ $ j ) $ dp1 [ $ i ] [ $ j ] [ 0 ] = 1 ; for ( $ s = 1 ; $ s <= $ steps ; ++ $ s ) { for ( $ x = 0 ; $ x < $ N ; ++ $ x ) { for ( $ y = 0 ; $ y < $ N ; ++ $ y ) { $ prob = 0.0 ; for ( $ i = 0 ; $ i < 8 ; ++ $ i ) { $ nx = $ x + $ dx [ $ i ] ; $ ny = $ y + $ dy [ $ i ] ; if ( inside ( $ nx , $ ny ) ) $ prob += $ dp1 [ $ nx ] [ $ ny ] [ $ s - 1 ] \/ 8.0 ; } $ dp1 [ $ x ] [ $ y ] [ $ s ] = $ prob ; } } } return $ dp1 [ $ start_x ] [ $ start_y ] [ $ steps ] ; } $ K = 3 ; echo findProb ( 0 , 0 , $ K ) . \" STRNEWLINE \" ; ? >"}
{"text":"Count of subarrays whose maximum element is greater than k | Return number of subarrays whose maximum element is less than or equal to K . ; To store count of subarrays with all elements less than or equal to k . ; Traversing the array . ; If element is greater than k , ignore . ; Counting the subarray length whose each element is less than equal to k . ; Suming number of subarray whose maximum element is less than equal to k . ; Driven Program","code":"< ? php function countSubarray ( $ arr , $ n , $ k ) { $ s = 0 ; $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] > $ k ) { $ i ++ ; continue ; } $ count = 0 ; while ( $ i < $ n and $ arr [ $ i ] <= $ k ) { $ i ++ ; $ count ++ ; } $ s += ( ( $ count * ( $ count + 1 ) ) \/ 2 ) ; } return ( $ n * ( $ n + 1 ) \/ 2 - $ s ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo countSubarray ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Sum of average of all subsets | Returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; method returns sum of average of all subsets ; Initialize result ; Find sum of elements ; looping once for all subset of same size ; each element occurs nCr ( N - 1 , n - 1 ) times while considering subset of size n ; Driver Code","code":"< ? php function nCr ( $ n , $ k ) { $ C [ $ n + 1 ] [ $ k + 1 ] = 0 ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function resultOfAllSubsets ( $ arr , $ N ) { $ result = 0.0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ n = 1 ; $ n <= $ N ; $ n ++ ) $ result += ( ( $ sum * ( nCr ( $ N - 1 , $ n - 1 ) ) ) \/ $ n ) ; return $ result ; } $ arr = array ( 2 , 3 , 5 , 7 ) ; $ N = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo resultOfAllSubsets ( $ arr , $ N ) ; ? >"}
{"text":"Maximum subsequence sum such that no three are consecutive | PHP program to find the maximum sum such that no three are consecutive using recursion . ; Returns maximum subsequence sum such that no three elements are consecutive ; Base cases ( process first three elements ) ; Process rest of the elements We have three cases ; Driver code","code":"< ? php $ arr = array ( 100 , 1000 , 100 , 1000 , 1 ) ; $ sum = array_fill ( 0 , count ( $ arr ) + 1 , -1 ) ; function maxSumWO3Consec ( $ n ) { global $ sum , $ arr ; if ( $ sum [ $ n ] != -1 ) return $ sum [ $ n ] ; if ( $ n == 0 ) return $ sum [ $ n ] = 0 ; if ( $ n == 1 ) return $ sum [ $ n ] = $ arr [ 0 ] ; if ( $ n == 2 ) return $ sum [ $ n ] = $ arr [ 1 ] + $ arr [ 0 ] ; return $ sum [ $ n ] = max ( max ( maxSumWO3Consec ( $ n - 1 ) , maxSumWO3Consec ( $ n - 2 ) + $ arr [ $ n ] ) , $ arr [ $ n ] + $ arr [ $ n - 1 ] + maxSumWO3Consec ( $ n - 3 ) ) ; } $ n = count ( $ arr ) ; echo maxSumWO3Consec ( $ n ) ; ? >"}
{"text":"Maximum sum of pairs with specific difference | Method to return maximum sum we can get by finding less than K difference pairs ; Sort elements to ensure every i and i - 1 is closest possible pair ; To get maximum possible sum , iterate from largest to smallest , giving larger numbers priority over smaller numbers . ; Case I : Diff of arr [ i ] and arr [ i - 1 ] is less then K , add to maxSum Case II : Diff between arr [ i ] and arr [ i - 1 ] is not less then K , move to next i since with sorting we know , arr [ i ] - arr [ i - 1 ] < arr [ i ] - arr [ i - 2 ] and so on . ; Assuming only positive numbers . ; When a match is found skip this pair ; Driver Code","code":"< ? php function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ k ) { $ maxSum = 0 ; sort ( $ arr ) ; for ( $ i = $ N - 1 ; $ i > 0 ; -- $ i ) { if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ k ) { $ maxSum += $ arr [ $ i ] ; $ maxSum += $ arr [ $ i - 1 ] ; -- $ i ; } } return $ maxSum ; } $ arr = array ( 3 , 5 , 10 , 15 , 17 , 12 , 9 ) ; $ N = sizeof ( $ arr ) ; $ K = 4 ; echo maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) ; ? >"}
{"text":"Count digit groupings of a number with given constraints | Function to find the subgroups ; Terminating Condition ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; Total number of subgroups till current position ; Driver Code","code":"< ? php function countGroups ( $ position , $ previous_sum , $ length , $ num ) { if ( $ position == $ length ) return 1 ; $ res = 0 ; $ sum = 0 ; for ( $ i = $ position ; $ i < $ length ; $ i ++ ) { $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum >= $ previous_sum ) $ res += countGroups ( $ i + 1 , $ sum , $ length , $ num ) ; } return $ res ; } $ num = \"1119\" ; $ len = strlen ( $ num ) ; echo countGroups ( 0 , 0 , $ len , $ num ) ; ? >"}
{"text":"Find number of times a string occurs as a subsequence in given string | Iterative DP function to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; Create a table to store results of sub - problems ; If second string is empty ; Fill lookup [ ] [ ] in bottom up manner ; If last characters are same , we have two options - 1. consider last characters of both strings in solution 2. ignore last character of first string ; If last character are different , ignore last character of first string ; Driver code","code":"< ? php function count1 ( $ a , $ b ) { $ m = strlen ( $ a ) ; $ n = strlen ( $ b ) ; $ lookup = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ m ; ++ $ i ) $ lookup [ $ i ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ a [ $ i - 1 ] == $ b [ $ j - 1 ] ) $ lookup [ $ i ] [ $ j ] = $ lookup [ $ i - 1 ] [ $ j - 1 ] + $ lookup [ $ i - 1 ] [ $ j ] ; else $ lookup [ $ i ] [ $ j ] = $ lookup [ $ i - 1 ] [ $ j ] ; } } return $ lookup [ $ m ] [ $ n ] ; } $ a = \" GeeksforGeeks \" ; $ b = \" Gks \" ; echo count1 ( $ a , $ b ) ; ? >"}
{"text":"A Space Optimized Solution of LCS | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Find lengths of two strings ; Binary index , used to index current row and previous row . ; Compute current binary index ; Last filled entry contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Driver code","code":"< ? php function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { $ bi = $ i & 1 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ bi ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ bi ] [ $ j ] = $ L [ 1 - $ bi ] [ $ j - 1 ] + 1 ; else $ L [ $ bi ] [ $ j ] = max ( $ L [ 1 - $ bi ] [ $ j ] , $ L [ $ bi ] [ $ j - 1 ] ) ; } } return $ L [ $ bi ] [ $ n ] ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length \u2581 of \u2581 LCS \u2581 is \u2581 : \u2581 \" , lcs ( $ X , $ Y ) ; ? >"}
{"text":"Count number of subsets having a particular XOR value | Returns count of subsets of arr [ ] with XOR value equals to k . ; Find maximum element in arr [ ] ; Maximum possible XOR value ; Initializing all the values of dp [ i ] [ j ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subset from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver Code","code":"< ? php function subsetXOR ( $ arr , $ n , $ k ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( int ) ( log ( $ max_ele , 2 ) + 1 ) ) - 1 ; if ( $ k > $ m ) { return 0 ; } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] ; return $ dp [ $ n ] [ $ k ] ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ k = 4 ; $ n = sizeof ( $ arr ) ; echo \" Count \u2581 of \u2581 subsets \u2581 is \u2581 \" , subsetXOR ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find number of solutions of a linear equation of n variables | Recursive function that returns count of solutions for given rhs value and coefficients coeff [ start . . end ] ; Base case ; Initialize count of solutions ; One by subtract all smaller or equal coefficiants and recur ; Driver Code","code":"< ? php function countSol ( $ coeff , $ start , $ end , $ rhs ) { if ( $ rhs == 0 ) return 1 ; $ result = 0 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) if ( $ coeff [ $ i ] <= $ rhs ) $ result += countSol ( $ coeff , $ i , $ end , $ rhs - $ coeff [ $ i ] ) ; return $ result ; } $ coeff = array ( 2 , 2 , 5 ) ; $ rhs = 4 ; $ n = sizeof ( $ coeff ) ; echo countSol ( $ coeff , 0 , $ n - 1 , $ rhs ) ; ? >"}
{"text":"Minimum steps to reach a destination | source -> source vertex step -> value of last step taken dest -> destination vertex ; base cases ; if we go on positive side ; if we go on negative side ; minimum of both cases ; Driver code","code":"< ? php function steps ( $ source , $ step , $ dest ) { if ( abs ( $ source ) > ( $ dest ) ) return PHP_INT_MAX ; if ( $ source == $ dest ) return $ step ; $ pos = steps ( $ source + $ step + 1 , $ step + 1 , $ dest ) ; $ neg = steps ( $ source - $ step - 1 , $ step + 1 , $ dest ) ; return min ( $ pos , $ neg ) ; } $ dest = 11 ; echo \" No . \u2581 of \u2581 steps \u2581 required \u2581 to \u2581 reach \u2581 \" , $ dest , \" \u2581 is \u2581 \" , steps ( 0 , 0 , $ dest ) ; ? >"}
{"text":"Longest Common Substring | DP | Returns length of function for longest common substring of X [ 0. . m - 1 ] and Y [ 0. . n - 1 ] ; Driver code","code":"< ? php function lcs ( $ i , $ j , $ count , & $ X , & $ Y ) { if ( $ i == 0 $ j == 0 ) return $ count ; if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ count = lcs ( $ i - 1 , $ j - 1 , $ count + 1 , $ X , $ Y ) ; } $ count = max ( $ count , lcs ( $ i , $ j - 1 , 0 , $ X , $ Y ) , lcs ( $ i - 1 , $ j , 0 , $ X , $ Y ) ) ; return $ count ; } $ X = \" abcdxyz \" ; $ Y = \" xyzabcd \" ; $ n = strlen ( $ X ) ; $ m = strlen ( $ Y ) ; echo lcs ( $ n , $ m , 0 , $ X , $ Y ) ; ? >"}
{"text":"Print a number as string of ' A ' and ' B ' in lexicographic order | Function to calculate number of characters in corresponding string of ' A ' and ' B ' ; Since the minimum number of characters will be 1 ; Calculating number of characters ; Since k length string can represent at most pow ( 2 , k + 1 ) - 2 that is if k = 4 , it can represent at most pow ( 2 , 4 + 1 ) - 2 = 30 so we have to calculate the length of the corresponding string ; return the length of the corresponding string ; Function to print corresponding string of ' A ' and ' B ' ; Find length of string ; Since the first number that can be represented by k length string will be ( pow ( 2 , k ) - 2 ) + 1 and it will be AAA ... A , k times , therefore , N will store that how much we have to print ; At a particular time , we have to decide whether we have to print ' A ' or ' B ' , this can be check by calculating the value of pow ( 2 , k - 1 ) ; Print new line ; Driver code","code":"< ? php function no_of_characters ( $ M ) { $ k = 1 ; while ( true ) { if ( pow ( 2 , $ k + 1 ) - 2 < $ M ) $ k ++ ; else break ; } return $ k ; } function print_string ( $ M ) { $ k ; $ num ; $ N ; $ k = no_of_characters ( $ M ) ; $ N = $ M - ( pow ( 2 , $ k ) - 2 ) ; while ( $ k > 0 ) { $ num = pow ( 2 , $ k - 1 ) ; if ( $ num >= $ N ) echo \" A \" ; else { echo \" B \" ; $ N -= $ num ; } $ k -- ; } echo \" STRNEWLINE \" ; } $ M ; $ M = 30 ; print_string ( $ M ) ; $ M = 55 ; print_string ( $ M ) ; $ M = 100 ; print_string ( $ M ) ; ? >"}
{"text":"Replace two substrings ( of a string ) with each other | Function to return the resultant string ; Iterate through all positions i ; Current sub - string of length = len ( A ) = len ( B ) ; If current sub - string gets equal to A or B ; Update S after replacing A ; Update S after replacing B ; Return the updated string ; Driver code","code":"< ? php function updateString ( $ S , $ A , $ B ) { $ l = strlen ( $ A ) ; for ( $ i = 0 ; $ i + $ l <= strlen ( $ S ) ; $ i ++ ) { $ curr = substr ( $ S , $ i , $ i + $ l ) ; if ( strcmp ( $ curr , $ A ) == 0 ) { $ new_string = substr ( $ S , 0 , $ i ) . $ B . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } else { $ new_string = substr ( $ S , 0 , $ i ) . $ A . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } } return $ S ; } $ S = \" aab \" ; $ A = \" aa \" ; $ B = \" bb \" ; echo ( updateString ( $ S , $ A , $ B ) ) ;"}
{"text":"Print n 0 s and m 1 s such that no two 0 s and no three 1 s are together | Function to print the required pattern ; When condition fails ; When m = n - 1 ; Driver code","code":"< ? php function printPattern ( $ n , $ m ) { if ( $ m > 2 * ( $ n + 1 ) $ m < $ n - 1 ) { echo ( \" - 1\" ) ; } else if ( abs ( $ n - $ m ) <= 1 ) { while ( $ n > 0 && $ m > 0 ) { System . out . print ( \"01\" ) ; $ n -- ; $ m -- ; } if ( $ n != 0 ) { echo ( \"0\" ) ; } if ( $ m != 0 ) { echo ( \"1\" ) ; } } else { while ( $ m - $ n > 1 && $ n > 0 ) { echo ( \"110\" ) ; $ m = $ m - 2 ; $ n = $ n - 1 ; } while ( $ n > 0 ) { echo ( \"10\" ) ; $ n -- ; $ m -- ; } while ( $ m > 0 ) { echo ( \"1\" ) ; $ m -- ; } } } $ n = 4 ; $ m = 8 ; printPattern ( $ n , $ m ) ; ? >"}
{"text":"Find the count of Strictly decreasing Subarrays | Function to count the number of strictly decreasing subarrays ; Initialize length of current decreasing subarray ; Traverse through the array ; If arr [ i + 1 ] is less than arr [ i ] , then increment length ; Else Update count and reset length ; If last length is more than 1 ; Driver Code","code":"< ? php function countDecreasing ( $ A , $ n ) { $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ A [ $ i + 1 ] < $ A [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) \/ 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) \/ 2 ) ; return $ cnt ; } $ A = array ( 100 , 3 , 1 , 13 ) ; $ n = sizeof ( $ A ) ; echo countDecreasing ( $ A , $ n ) ; ? >"}
{"text":"Minimum changes required to make first string substring of second string | Function to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Get the sizes of both strings ; Traverse the string S2 ; From every index in S2 , check the number of mis - matching characters in substring of length of S1 ; Take minimum of prev and current mis - match ; return answer ; Driver Code","code":"< ? php function minimumChar ( $ S1 , $ S2 ) { $ n = strlen ( $ S1 ) ; $ m = strlen ( $ S2 ) ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m - $ n + 1 ; $ i ++ ) { $ minRemovedChar = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ S1 [ $ j ] != $ S2 [ $ i + $ j ] ) { $ minRemovedChar ++ ; } } $ ans = min ( $ minRemovedChar , $ ans ) ; } return $ ans ; } $ S1 = \" abc \" ; $ S2 = \" paxzk \" ; echo minimumChar ( $ S1 , $ S2 ) ; ? >"}
{"text":"Frequency of a substring in a string | Simple PHP program to count occurrences of pat in txt . ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver Code","code":"< ? php function countFreq ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ res = 0 ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { $ res ++ ; $ j = 0 ; } } return $ res ; } $ txt = \" dhimanman \" ; $ pat = \" man \" ; echo countFreq ( $ pat , $ txt ) ;"}
{"text":"Optimized Naive Algorithm for Pattern Searching | A modified Naive Pettern Searching algorithn that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver Code","code":"< ? php function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( \" Pattern \u2581 found \u2581 at \u2581 index \u2581 $ i \" . \" STRNEWLINE \" ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } } $ txt = \" ABCEABCDABCEABCD \" ; $ pat = \" ABCD \" ; search ( $ pat , $ txt ) ; ? >"}
{"text":"Print an N x M matrix such that each row and column has all the vowels in it | Function to print the required matrix ; Impossible to generate the required matrix ; Store all the vowels ; Print the matrix ; Print vowels for every index ; Shift the vowels by one ; Driver code","code":"< ? php function printMatrix ( $ n , $ m ) { if ( $ n < 5 $ m < 5 ) { echo - 1 ; return ; } $ s = \" aeiou \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { echo $ s [ $ j % 5 ] . \" \" ; } echo \" STRNEWLINE \" ; $ c = $ s [ 0 ] ; for ( $ k = 0 ; $ k < 4 ; $ k ++ ) { $ s [ $ k ] = $ s [ $ k + 1 ] ; } $ s [ 4 ] = $ c ; } } $ n = 5 ; $ m = 5 ; printMatrix ( $ n , $ m ) ; return 0 ; ? >"}
{"text":"Number of character corrections in the given strings to make them equal | Function to return the count of operations required ; To store the count of operations ; No operation required ; One operation is required when any two characters are equal ; Two operations are required when none of the characters are equal ; Return the minimum count of operations required ; Driver code","code":"< ? php function minOperations ( $ n , $ a , $ b , $ c ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = $ a [ $ i ] ; $ y = $ b [ $ i ] ; $ z = $ c [ $ i ] ; if ( $ x == $ y && $ y == $ z ) ; else if ( $ x == $ y $ y == $ z $ x == $ z ) { $ ans ++ ; } else { $ ans += 2 ; } } return $ ans ; } $ a = \" place \" ; $ b = \" abcde \" ; $ c = \" plybe \" ; $ n = strlen ( $ a ) ; echo minOperations ( $ n , $ a , $ b , $ c ) ; ? >"}
{"text":"Check if string can be made lexicographically smaller by reversing any substring | Function that returns true if s can be made lexicographically smaller by reversing a sub - string in s ; Traverse in the string ; Check if $s [ $i + 1 ] < $s [ $i ] ; Not possible ; Driver code","code":"< ? php function check ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ s [ $ i ] > $ s [ $ i + 1 ] ) return true ; } return false ; } $ s = \" geeksforgeeks \" ; if ( check ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Count of sub | Function to return the count of required sub - strings ; Number of sub - strings from position of current x to the end of str ; To store the number of characters before x ; Driver code","code":"< ? php function countSubStr ( $ str , $ n , $ x ) { $ res = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) { $ res += ( ( $ count + 1 ) * ( $ n - $ i ) ) ; $ count = 0 ; } else $ count ++ ; } return $ res ; } $ str = \" abcabc \" ; $ n = strlen ( $ str ) ; $ x = ' c ' ; echo countSubStr ( $ str , $ n , $ x ) ; ? >"}
{"text":"Count of sub | Function to return the count of possible sub - strings of length n ; Driver code","code":"< ? php function countSubStr ( $ str , $ n ) { $ len = strlen ( $ str ) ; return ( $ len - $ n + 1 ) ; } $ str = \" geeksforgeeks \" ; $ n = 5 ; echo ( countSubStr ( $ str , $ n ) ) ; ? >"}
{"text":"Count of sub | Function to return the number of sub - strings that do not contain the given character c ; Length of the string ; Traverse in the string ; If current character is different from the given character ; Update the number of sub - strings ; Reset count to 0 ; For the characters appearing after the last occurrence of c ; Driver code","code":"< ? php function countSubstrings ( $ s , $ c ) { $ n = strlen ( $ s ) ; $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ c ) $ cnt ++ ; else { $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) \/ 2 ) ; $ cnt = 0 ; } } $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) \/ 2 ) ; return $ sum ; } $ s = \" baa \" ; $ c = ' b ' ; echo countSubstrings ( $ s , $ c ) ; ? >"}
{"text":"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | Function that returns true if s is palindrome ; Function to return the required index ; Copy the ith character in S ; Copy all the character of string s2 in Temp ; Check whether the string is palindrome ; Driver code","code":"< ? php function isPalindrome ( $ s ) { $ i = 0 ; $ j = strlen ( $ s ) - 1 ; while ( $ i < $ j ) { if ( $ s [ $ i ] != $ s [ $ j ] ) return false ; $ i ++ ; $ j -- ; } return true ; } function getIndex ( $ S1 , $ S2 , $ n ) { $ S = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ S = $ S . $ S1 [ $ i ] ; $ Temp = \" \" ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ Temp . = $ S2 [ $ j ] ; if ( isPalindrome ( $ S . $ Temp ) ) { return $ i ; } } return -1 ; } $ S1 = \" abcdf \" ; $ S2 = \" sfgba \" ; $ n = strlen ( $ S1 ) ; echo getIndex ( $ S1 , $ S2 , $ n ) ; ? >"}
{"text":"Sub | Function that returns true if every lowercase character appears atmost once ; every character frequency must be not greater than one ; Function that returns the modified good string if possible ; If the length of the string is less than n ; Sub - strings of length 26 ; To store frequency of each character ; Get the frequency of each character in the current sub - string ; Check if we can get sub - string containing all the 26 characters ; Find which character is missing ; Fill with missing characters ; Find the next missing character ; Return the modified good string ; Driver code","code":"< ? php function valid ( & $ cnt ) { for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ cnt [ $ i ] >= 2 ) return false ; } return true ; } function getGoodString ( $ s , $ n ) { if ( $ n < 26 ) return \" - 1\" ; for ( $ i = 25 ; $ i < $ n ; $ i ++ ) { $ cnt = array_fill ( 0 , 26 , NULL ) ; for ( $ j = $ i ; $ j >= $ i - 25 ; $ j -- ) { if ( $ s [ $ j ] != ' ? ' ) $ cnt [ ord ( $ s [ $ j ] ) - ord ( ' a ' ) ] ++ ; } if ( valid ( $ cnt ) ) { $ cur = 0 ; while ( $ cur < 26 && $ cnt [ $ cur ] > 0 ) $ cur ++ ; for ( $ j = $ i - 25 ; $ j <= $ i ; $ j ++ ) { if ( $ s [ $ j ] == ' ? ' ) { $ s [ $ j ] = chr ( $ cur + ord ( ' a ' ) ) ; $ cur ++ ; while ( $ cur < 26 && $ cnt [ $ cur ] > 0 ) $ cur ++ ; } } return $ s ; } } return \" - 1\" ; } $ s = \" abcdefghijkl ? nopqrstuvwxy ? \" ; $ n = strlen ( $ s ) ; echo getGoodString ( $ s , $ n ) ; ? >"}
{"text":"Modify the string by swapping continuous vowels or consonants | Function to check if a character is a vowel ; Function to swap two consecutively repeated vowels or consonants ; Traverse through the length of the string ; Check if the two consecutive characters are vowels or consonants ; swap the two characters ; Driver code","code":"< ? php function isVowel ( $ c ) { $ c = strtolower ( $ c ) ; if ( $ c == ' a ' $ c == ' e ' $ c == ' i ' $ c == ' o ' $ c == ' u ' ) return true ; return false ; } function swapRepeated ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) - 1 ; $ i ++ ) { if ( ( isVowel ( $ str [ $ i ] ) && isVowel ( $ str [ $ i + 1 ] ) ) || ( ! isVowel ( $ str [ $ i ] ) && ! isVowel ( $ str [ $ i + 1 ] ) ) ) { $ t = $ str [ $ i ] ; $ str [ $ i ] = $ str [ $ i + 1 ] ; $ str [ $ i + 1 ] = $ t ; } } return $ str ; } $ str = \" geeksforgeeks \" ; echo swapRepeated ( $ str ) ; return 0 ; ? >"}
{"text":"Find the lexicographically largest palindromic Subsequence of a String | Function to find the largest palindromic subsequence ; Find the largest character ; Append all occurrences of largest character to the resultant string ; Driver Code","code":"< ? php function largestPalinSub ( $ s ) { $ res = \" \" ; $ mx = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ mx = max ( $ mx , $ s [ $ i ] ) ; } for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ mx ) { $ res . = $ s [ $ i ] ; } } return $ res ; } $ s = \" geeksforgeeks \" ; echo ( largestPalinSub ( $ s ) ) ; ? >"}
{"text":"Generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | Function to print the required string ; count number of 1 s ; To check if the all the 1 s have been used or not ; Print all the 1 s if any 2 is encountered ; If str [ i ] = 0 or str [ i ] = 2 ; If 1 s are not printed yet ; Driver code","code":"< ? php function printString ( $ str , $ n ) { $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ ones ++ ; $ used = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '2' && ! $ used ) { $ used = 1 ; for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo \"1\" ; } if ( $ str [ $ i ] != '1' ) echo $ str [ $ i ] ; } if ( ! $ used ) for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo \"1\" ; } $ str = \"100210\" ; $ n = strlen ( $ str ) ; printString ( $ str , $ n ) ; ? >"}
{"text":"K length words that can be formed from given characters without repetition | Function to return the required count ; To store the count of distinct characters in $str ; Traverse $str character by character ; If current character is appearing for the first time in $str ; Increment the distinct character count ; Update the appearance of the current character ; Since P ( n , r ) = n ! \/ ( n - r ) ! ; Return the answer ; Driver code","code":"< ? php function findPermutation ( $ str , $ k ) { $ has = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { $ has [ $ i ] = false ; } $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ has [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] == false ) { $ cnt ++ ; $ has [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] = true ; } } $ ans = 1 ; for ( $ i = 2 ; $ i <= $ cnt ; $ i ++ ) $ ans *= $ i ; for ( $ i = $ cnt - $ k ; $ i > 1 ; $ i -- ) $ ans \/= $ i ; return $ ans ; } $ str = \" geeksforgeeks \" ; $ k = 4 ; echo findPermutation ( $ str , $ k ) ; ? >"}
{"text":"Find the number in a range having maximum product of the digits | Returns the product of digits of number x ; This function returns the number having maximum product of the digits ; Let the current answer be r ; Converting both integers to strings ; Stores the current number having current digit one less than current digit in b ; Replace all following digits with 9 to maximise the product ; Convert string to number ; Check if it lies in range and its product is greater than max product ; Driver Code","code":"< ? php function product ( $ x ) { $ prod = 1 ; while ( $ x ) { $ prod *= ( $ x % 10 ) ; $ x = ( int ) ( $ x \/ 10 ) ; } return $ prod ; } function findNumber ( $ l , $ r ) { $ ans = $ r ; $ a = strval ( $ l ) ; $ b = strval ( $ r ) ; for ( $ i = 0 ; $ i < strlen ( $ b ) ; $ i ++ ) { if ( $ b [ $ i ] == '0' ) continue ; $ curr = $ b ; $ curr [ $ i ] = chr ( ( ( ord ( $ curr [ $ i ] ) - ord ( '0' ) ) - 1 ) + ord ( '0' ) ) ; for ( $ j = $ i + 1 ; $ j < strlen ( $ curr ) ; $ j ++ ) $ curr [ $ j ] = '9' ; $ num = 0 ; for ( $ c = 0 ; $ c < strlen ( $ curr ) ; $ c ++ ) $ num = $ num * 10 + ( ord ( $ curr [ $ c ] ) - ord ( '0' ) ) ; if ( $ num >= $ l and product ( $ ans ) < product ( $ num ) ) $ ans = $ num ; } return $ ans ; } $ l = 1 ; $ r = 10 ; print ( findNumber ( $ l , $ r ) . \" \" ) ; $ l = 51 ; $ r = 62 ; print ( findNumber ( $ l , $ r ) ) ; ? >"}
{"text":"Construct a binary string following the given constraints | Function to print a binary string which has ' a ' number of 0 ' s , \u2581 ' b ' \u2581 number \u2581 of \u2581 1' s and there are at least ' x ' indices such that s [ i ] != s [ i + 1 ] ; Divide index value by 2 and store it into d ; If index value x is even and x \/ 2 is not equal to a ; Loop for d for each d print 10 ; subtract d from a and b ; Loop for b to print remaining 1 's ; Loop for a to print remaining 0 's ; Driver code","code":"< ? php function constructBinString ( $ a , $ b , $ x ) { $ d ; $ i ; $ d = $ x \/ 2 ; if ( $ x % 2 == 0 && $ x \/ 2 != $ a ) { $ d -- ; echo 0 ; $ a -- ; } for ( $ i = 0 ; $ i < $ d ; $ i ++ ) echo \"10\" ; $ a = $ a - $ d ; $ b = $ b - $ d ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) { echo \"1\" ; } for ( $ i = 0 ; $ i < $ a ; $ i ++ ) { echo \"0\" ; } } $ a = 4 ; $ b = 3 ; $ x = 2 ; constructBinString ( $ a , $ b , $ x ) ; ? >"}
{"text":"Check If every group of a ' s \u2581 is \u2581 followed \u2581 by \u2581 a \u2581 group \u2581 of \u2581 b ' s of same length | Function to match whether there are always n consecutive b ' s \u2581 followed \u2581 by \u2581 n \u2581 consecutive \u2581 a ' s throughout the string ; Traverse through the string ; Count a 's in current segment ; Count b 's in current segment ; If both counts are not same . ; Driver code","code":"< ? php function matchPattern ( $ s ) { $ count = 0 ; $ n = strlen ( $ s ) ; $ i = 0 ; while ( $ i < $ n ) { while ( $ i < $ n && $ s [ $ i ] == ' a ' ) { $ count ++ ; $ i ++ ; } while ( $ i < $ n && $ s [ $ i ] == ' b ' ) { $ count -- ; $ i ++ ; } if ( $ count != 0 ) return false ; } return true ; } $ s = \" bb \" ; if ( matchPattern ( $ s ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Length of longest consecutive ones by at most one swap in a Binary String | Function to calculate the length of the longest consecutive 1 's ; To count all 1 's in the string ; To store cumulative 1 's  $left[$n]; $right[$n]; ; Counting cumulative 1 's from left ; If 0 then start new cumulative one from that i ; perform step 3 of the approach ; step 3 ; string","code":"< ? php function maximum_one ( $ s , $ n ) { $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ cnt_one ++ ; } if ( $ s [ 0 ] == '1' ) $ left [ 0 ] = 1 ; else $ left [ 0 ] = 0 ; if ( $ s [ $ n - 1 ] == '1' ) $ right [ $ n - 1 ] = 1 ; else $ right [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ left [ $ i ] = $ left [ $ i - 1 ] + 1 ; else $ left [ $ i ] = 0 ; } for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '1' ) $ right [ $ i ] = $ right [ $ i + 1 ] + 1 ; else $ right [ $ i ] = 0 ; } $ cnt = 0 ; $ max_cnt = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) { $ sum = $ left [ $ i - 1 ] + $ right [ $ i + 1 ] ; if ( $ sum < $ cnt_one ) $ cnt = $ sum + 1 ; else $ cnt = $ sum ; $ max_cnt = max ( $ max_cnt , $ cnt ) ; $ cnt = 0 ; } } return $ max_cnt ; } $ s = \"111011101\" ; echo maximum_one ( $ s , strlen ( $ s ) ) ; ? >"}
{"text":"Lexicographically smallest substring with maximum occurrences containing a ' s \u2581 and \u2581 b ' s only | Function to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s \u2581 and \u2581 b ' s only . ; To store frequency of digits ; size of string ; Take lexicographically larger digit in b ; get frequency of each character ; If no such string exits ; Maximum frequency ; Driver Code","code":"< ? php function maxFreq ( $ s , $ a , $ b ) { $ fre = array_fill ( 0 , 10 , 0 ) ; $ n = strlen ( $ s ) ; if ( $ a > $ b ) { $ xx = $ a ; $ a = $ b ; $ b = $ xx ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = ord ( $ s [ $ i ] ) - ord ( '0' ) ; $ fre [ $ a ] += 1 ; } if ( $ fre [ $ a ] == 0 and $ fre [ $ b ] == 0 ) return -1 ; else if ( $ fre [ $ a ] >= $ fre [ $ b ] ) return $ a ; else return $ b ; } $ a = 4 ; $ b = 7 ; $ s = \"47744\" ; print ( maxFreq ( $ s , $ a , $ b ) ) ; ? >"}
{"text":"Minimum steps to convert one binary string to other only using negation | Function to find the minimum steps to convert string a to string b ; array to mark the positions needed to be negated ; If two character are not same then they need to be negated ; To count the blocks of 1 ; To count the number of 1 ' s \u2581 in \u2581 \u2581 each \u2581 block \u2581 of \u2581 1' s ; For the last block of 1 's ; Driver code","code":"< ? php function convert ( $ n , $ a , $ b ) { $ l = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ l [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] != $ b [ $ i ] ) $ l [ $ i ] = 1 ; } $ cc = 0 ; $ vl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ l [ $ i ] == 0 ) { if ( $ vl != 0 ) $ cc += 1 ; $ vl = 0 ; } else $ vl += 1 ; } if ( $ vl != 0 ) $ cc += 1 ; echo $ cc . \" STRNEWLINE \" ; } $ a = \"101010\" ; $ b = \"110011\" ; $ n = strlen ( $ a ) ; convert ( $ n , $ a , $ b ) ; ? >"}
{"text":"Number of ways to swap two bit of s1 so that bitwise OR of s1 and s2 changes | Function to find number of ways ; initialise result that store No . of swaps required ; Traverse both strings and check the bits as explained ; calculate result ; Driver code","code":"< ? php function countWays ( $ s1 , $ s2 , $ n ) { $ a = $ b = $ c = $ d = 0 ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s2 [ $ i ] == '0' ) { if ( $ s1 [ $ i ] == '0' ) { $ c ++ ; } else { $ d ++ ; } } else { if ( $ s1 [ $ i ] == '0' ) { $ a ++ ; } else { $ b ++ ; } } } $ result = $ a * $ d + $ b * $ c + $ c * $ d ; return $ result ; } $ n = 5 ; $ s1 = \"01011\" ; $ s2 = \"11001\" ; echo countWays ( $ s1 , $ s2 , $ n ) ; ? >"}
{"text":"Find the player who rearranges the characters to get a palindrome string first | Function that returns the winner of the game ; Initialize the freq array to 0 int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; $freg = array_fill ( ) ; Iterate and count the frequencies of each character in the string ; Count the odd occurring character ; If odd occurrence ; Check condition for Player - 1 winning the game ; Driver code ; Function call that returns the winner","code":"< ? php function returnWinner ( $ s , $ l ) { $ freq = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { $ freq [ $ s [ $ i ] - ' a ' ] ++ ; } $ cnt = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ freq [ $ i ] & 1 ) $ cnt ++ ; } if ( $ cnt == 0 $ cnt & 1 ) return 1 ; else return 2 ; } $ s = \" abaaab \" ; $ l = strlen ( $ s ) ; $ winner = returnWinner ( $ s , $ l ) ; echo \" Player - \" , $ winner ; ? >"}
{"text":"Maximum sum and product of the M consecutive digits in a number | Function to find the maximum product ; Driver code","code":"< ? php function maxProductSum ( $ str , $ m ) { $ n = strlen ( $ str ) ; $ maxProd = PHP_INT_MIN ; $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= ( $ n - $ m ) ; $ i ++ ) { $ product = 1 ; $ sum = 0 ; for ( $ j = $ i ; $ j < ( $ m + $ i ) ; $ j ++ ) { $ product = $ product * ( $ str [ $ j ] - '0' ) ; $ sum = $ sum + ( $ str [ $ j ] - '0' ) ; } $ maxProd = max ( $ maxProd , $ product ) ; $ maxSum = max ( $ maxSum , $ sum ) ; } echo \" Maximum \u2581 Product \u2581 = \u2581 \" , $ maxProd ; echo \" Maximum Sum = \" } $ str = \"3605356297\" ; $ m = 3 ; maxProductSum ( $ str , $ m ) ; ? >"}
{"text":"Find time taken for signal to reach all positions in a string | Returns time needed for signal to traverse through complete string . ; for the calculation of last index ; for strings like oxoooo , xoxxoooo . . ; if coun is greater than max_length ; if ' x ' is present at the right side of max_length ; if ' x ' is present at left side of max_length ; We use ceiling function to handle odd number ' o ' s ; Driver code","code":"< ? php function maxLength ( $ s , $ n ) { $ right = 0 ; $ left = 0 ; $ coun = 0 ; $ max_length = PHP_INT_MIN ; $ s = $ s . '1' ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' o ' ) $ coun ++ ; else { if ( $ coun > $ max_length ) { $ right = 0 ; $ left = 0 ; if ( $ s [ $ i ] == ' x ' ) $ right = 1 ; if ( ( ( $ i - $ coun ) > 0 ) && ( $ s [ $ i - $ coun - 1 ] == ' x ' ) ) $ left = 1 ; $ coun = ( int ) ceil ( ( double ) $ coun \/ ( $ right + $ left ) ) ; $ max_length = max ( $ max_length , $ coun ) ; } $ coun = 0 ; } } return $ max_length ; } $ s = \" oooxoooooooooxooo \" ; $ n = strlen ( $ s ) ; echo ( maxLength ( $ s , $ n ) ) ;"}
{"text":"Check whether the vowels in a string are in alphabetical order or not | Function that checks whether the vowel characters in a string are in alphabetical order or not ; ASCII Value 64 is less than all the alphabets so using it as a default value ; check if the vowels in the string are sorted or not ; if the vowel is smaller than the previous vowel ; store the vowel ; Driver code ; check whether the vowel characters in a string are in alphabetical order or not","code":"< ? php function areVowelsInOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = chr ( 64 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' $ s [ $ i ] == ' e ' $ s [ $ i ] == ' $ i ' $ s [ $ i ] == ' o ' $ s [ $ i ] == ' u ' ) { if ( $ s [ $ i ] < $ c ) return false ; else { $ c = $ s [ $ i ] ; } } } return true ; } $ s = \" aabbbddeecc \" ; if ( areVowelsInOrder ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program to find remainder when large number is divided by r | Function to Return Remainder ; len is variable to store the length of Number string . ; loop that find Remainder ; Return the remainder ; Get the large number as string ; Get the divisor R ; Find and print the remainder","code":"< ? php function Remainder ( $ str , $ R ) { $ len = strlen ( $ str ) ; $ Num = 0 ; $ Rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ Num = $ Rem * 10 + ( $ str [ $ i ] - '0' ) ; $ Rem = $ Num % $ R ; } return $ Rem ; } $ str = \"13589234356546756\" ; $ R = 13 ; echo Remainder ( $ str , $ R ) ;"}
{"text":"Count the number of carry operations required to add two numbers | Function to count the number of carry operations ; Initialize the value of carry to 0 ; Counts the number of carry operations ; Initialize len_a and len_b with the sizes of strings ; Assigning the ascii value of the character ; Add both numbers \/ digits ; If sum > 0 , increment count and set carry to 1 ; Else , set carry to 0 ; Driver code","code":"< ? php function count_carry ( $ a , $ b ) { $ carry = 0 ; $ count = 0 ; $ len_a = strlen ( $ a ) ; $ len_b = strlen ( $ b ) ; while ( $ len_a != 0 $ len_b != 0 ) { $ x = 0 ; $ y = 0 ; if ( $ len_a > 0 ) { $ x = $ a [ $ len_a - 1 ] - '0' ; $ len_a -- ; } if ( $ len_b > 0 ) { $ y = $ b [ $ len_b - 1 ] - '0' ; $ len_b -- ; } $ sum = $ x + $ y + $ carry ; if ( $ sum >= 10 ) { $ carry = 1 ; $ count ++ ; } else $ carry = 0 ; } return $ count ; } $ a = \"9555\" ; $ b = \"555\" ; $ count = count_carry ( $ a , $ b ) ; if ( $ count == 0 ) echo \"0 STRNEWLINE \" ; else if ( $ count == 1 ) echo \"1 STRNEWLINE \" ; else echo $ count , \" STRNEWLINE \" ; ? >"}
{"text":"Check if a number is in given base or not | PHP program to check if given number is in given base or not . ; Allowed bases are till 16 ( Hexadecimal ) ; If base is below or equal to 10 , then all digits should be from 0 to 9. ; If base is below or equal to 16 , then all digits should be from 0 to 9 or from ' A ' ; Driver code","code":"< ? php function isInGivenBase ( $ str , $ base ) { if ( $ base > 16 ) return false ; else if ( $ base <= 10 ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( $ str [ $ i ] >= '0' and $ str [ $ i ] < ( '0' + $ base ) ) ) return false ; } else { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( ( $ str [ $ i ] >= '0' && $ str [ $ i ] < ( '0' + $ base ) ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] < ( ' A ' + $ base - 10 ) ) ) ) return false ; } return true ; } $ str = \" AF87\" ; if ( isInGivenBase ( $ str , 16 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find indices of all occurrence of one string in other | PHP program to find indices of all occurrences of one string in other . ; Driver Code","code":"< ? php function printIndex ( $ str , $ s ) { $ flag = false ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( substr ( $ str , $ i , strlen ( $ s ) ) == $ s ) { echo $ i . \" \" ; $ flag = true ; } } if ( $ flag == false ) echo \" NONE \" ; } $ str1 = \" GeeksforGeeks \" ; $ str2 = \" Geeks \" ; printIndex ( $ str1 , $ str2 ) ; ? >"}
{"text":"Check for balanced parentheses in an expression | O ( 1 ) space | Function1 to match closing bracket ; Function1 to match opening bracket ; Function to check balanced parentheses ; helper variables ; Handling case of opening parentheses ; Handling case of closing parentheses ; If corresponding matching opening parentheses doesn 't lie in given interval return 0 ; else continue ; If corresponding closing parentheses doesn 't lie in given interval  return 0 ; if found , now check for each opening and closing parentheses in this interval ; Driver Code","code":"< ? php function matchClosing ( $ X , $ start , $ end , $ open , $ close ) { $ c = 1 ; $ i = $ start + 1 ; while ( $ i <= $ end ) { if ( $ X [ $ i ] == $ open ) { $ c ++ ; } else if ( $ X [ $ i ] == $ close ) { $ c -- ; } if ( $ c == 0 ) { return $ i ; } $ i ++ ; } return $ i ; } function matchingOpening ( $ X , $ start , $ end , $ open , $ close ) { $ c = -1 ; $ i = $ end - 1 ; while ( $ i >= $ start ) { if ( $ X [ $ i ] == $ open ) { $ c ++ ; } else if ( $ X [ $ i ] == $ close ) { $ c -- ; } if ( $ c == 0 ) { return $ i ; } $ i -- ; } return -1 ; } function isBalanced ( $ X , $ n ) { $ i ; $ j = 0 ; $ k ; $ x ; $ start ; $ end ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ X [ $ i ] == ' ( ' ) { $ j = matchClosing ( $ X , $ i , $ n - 1 , ' ( ' , ' ) ' ) ; } else if ( $ X [ $ i ] == ' { ' ) { $ j = matchClosing ( $ X , $ i , $ n - 1 , ' { ' , ' } ' ) ; } else if ( $ X [ $ i ] == ' [ ' ) { $ j = matchClosing ( $ X , $ i , $ n - 1 , ' [ ' , ' ] ' ) ; } else { if ( $ X [ $ i ] == ' ) ' ) { $ j = matchingOpening ( $ X , 0 , $ i , ' ( ' , ' ) ' ) ; } else if ( $ X [ $ i ] == ' } ' ) { $ j = matchingOpening ( $ X , 0 , $ i , ' { ' , ' } ' ) ; } else if ( $ X [ $ i ] == ' ] ' ) { $ j = matchingOpening ( $ X , 0 , $ i , ' [ ' , ' ] ' ) ; } if ( $ j < 0 $ j >= $ i ) { return false ; } continue ; } if ( $ j >= $ n $ j < 0 ) { return false ; } $ start = $ i ; $ end = $ j ; for ( $ k = $ start + 1 ; $ k < $ end ; $ k ++ ) { if ( $ X [ $ k ] == ' ( ' ) { $ x = matchClosing ( $ X , $ k , $ end , ' ( ' , ' ) ' ) ; if ( ! ( $ k < $ x && $ x < $ end ) ) { return false ; } } else if ( $ X [ $ k ] == ' ) ' ) { $ x = matchingOpening ( $ X , $ start , $ k , ' ( ' , ' ) ' ) ; if ( ! ( $ start < $ x && $ x < $ k ) ) { return false ; } } if ( $ X [ $ k ] == ' { ' ) { $ x = matchClosing ( $ X , $ k , $ end , ' { ' , ' } ' ) ; if ( ! ( $ k < $ x && $ x < $ end ) ) { return false ; } } else if ( $ X [ $ k ] == ' } ' ) { $ x = matchingOpening ( $ X , $ start , $ k , ' { ' , ' } ' ) ; if ( ! ( $ start < $ x && $ x < $ k ) ) { return false ; } } if ( $ X [ $ k ] == ' [ ' ) { $ x = matchClosing ( $ X , $ k , $ end , ' [ ' , ' ] ' ) ; if ( ! ( $ k < $ x && $ x < $ end ) ) { return false ; } } else if ( $ X [ $ k ] == ' ] ' ) { $ x = matchingOpening ( $ X , $ start , $ k , ' [ ' , ' ] ' ) ; if ( ! ( $ start < $ x && $ x < $ k ) ) { return false ; } } } } return true ; } $ X = str_split ( \" [ ( ) ] ( ) \" ) ; $ n = 6 ; if ( isBalanced ( $ X , $ n ) ) echo ( \" Yes STRNEWLINE \" ) ; else echo ( \" No STRNEWLINE \" ) ; $ Y = str_split ( \" [ [ ( ) ] ] ) \" ) ; $ n = 7 ; if ( isBalanced ( $ Y , $ n ) ) echo ( \" Yes STRNEWLINE \" ) ; else echo ( \" No STRNEWLINE \" ) ; ? >"}
{"text":"Sorting array with conditional swapping | Function to check if it is possible to sort the array ; Calculating max_element at each iteration . ; if we can not swap the i - th element . ; if it is impossible to swap the max_element then we can not sort the array . ; Otherwise , we can sort the array . ; Driver Code","code":"< ? php function possibleToSort ( $ arr , $ n , $ str ) { $ max_element = -1 ; for ( $ i = 0 ; $ i < sizeof ( $ str ) ; $ i ++ ) { $ max_element = max ( $ max_element , $ arr [ $ i ] ) ; if ( $ str [ $ i ] == '0' ) { if ( $ max_element > $ i + 1 ) return \" No \" ; } } return \" Yes \" ; } $ arr = array ( 1 , 2 , 5 , 3 , 4 , 6 ) ; $ n = sizeof ( $ arr ) ; $ str = \"01110\" ; echo possibleToSort ( $ arr , $ n , $ str ) ; ? >"}
{"text":"Prime String | Function that checks if sum is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver code","code":"< ? php function isPrimeString ( $ str ) { $ len = strlen ( $ str ) ; $ n = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ n += ( int ) $ str [ $ i ] ; if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } $ str = \" geekRam \" ; if ( isPrimeString ( $ str ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; ? >"}
{"text":"Number of palindromic permutations | Set 1 | PHP program to find number of palindromic permutations of a given string ; Returns factorial of n ; Returns count of palindromic permutations of str . ; Count frequencies of all characters ; Since half of the characters decide count of palindromic permutations , we take ( n \/ 2 ) ! ; To make sure that there is at most one odd occurring char ; Traverse through all counts ; To make sure that the string can permute to form a palindrome ; If there are more than one odd occurring chars ; Divide all permutations with repeated characters ; Driver code","code":"< ? php $ MAX = 256 ; function fact ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function countPalinPermutations ( & $ str ) { global $ MAX ; $ n = strlen ( $ str ) ; $ freq = ( 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = fact ( $ n \/ 2 ) ; $ oddFreq = false ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { $ half = $ freq [ $ i ] \/ 2 ; if ( $ freq [ $ i ] % 2 != 0 ) { if ( $ oddFreq == true ) return 0 ; $ oddFreq = true ; } $ res = $ res \/ fact ( $ half ) ; } return $ res ; } $ str = \" gffg \" ; echo countPalinPermutations ( $ str ) ; ? >"}
{"text":"Convert the string into palindrome string by changing only one character | Function to check if it is possible to convert the string into palindrome ; Counting number of characters that should be changed . ; If count of changes is less than or equal to 1 ; Driver Code","code":"< ? php function checkPalindrome ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n \/ 2 ; ++ $ i ) if ( $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) ++ $ count ; return ( $ count <= 1 ) ; } { $ str = \" abccaa \" ; if ( checkPalindrome ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; } ? >"}
{"text":"Counting even decimal value substrings in a binary string | function return count of even decimal value substring ; store the count of even decimal value substring ; substring started with '0' ; increment result by ( n - i ) because all substring which are generated by this character produce even decimal value . ; Driver Code","code":"< ? php function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) { $ result += ( $ n - $ i ) ; } } return $ result ; } $ str = \"10010\" ; $ n = 5 ; echo evenDecimalValue ( $ str , $ n ) ; return 0 ; ? >"}
{"text":"Number of substrings with odd decimal value in a binary string | function to count number of substrings with odd decimal representation ; auxiliary array to store count of 1 's  before ith index ; store count of 1 's  before i-th index ; variable to store answer ; traverse the string reversely to calculate number of odd substrings before i - th index ; Driver code","code":"< ? php function countSubstr ( $ s ) { $ n = strlen ( $ s ) ; $ auxArr = array ( ) ; if ( $ s [ 0 ] == '1' ) $ auxArr [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ auxArr [ $ i ] = $ auxArr [ $ i - 1 ] + 1 ; else $ auxArr [ $ i ] = $ auxArr [ $ i - 1 ] ; } $ count = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) if ( $ s [ $ i ] == '1' ) $ count += $ auxArr [ $ i ] ; return $ count ; } $ s = \"1101\" ; echo countSubstr ( $ s ) ; ? >"}
{"text":"Check whether second string can be formed from characters of first string | PHP program to check whether second string can be formed from first string ; Create a count array and count frequencies characters in str1 . ; Now traverse through str2 to check if every character has enough counts ; Driver Code","code":"< ? php $ MAX = 256 ; function canMakeStr2 ( $ str1 , $ str2 ) { $ count = ( 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) { if ( $ count [ $ str2 [ $ i ] ] == 0 ) return -1 ; } return true ; } $ str1 = \" geekforgeeks \" ; $ str2 = \" for \" ; if ( canMakeStr2 ( $ str1 , $ str2 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Position of robot after given movements | function to find final position of robot after the complete movement ; traverse the instruction string ' move ' ; for each movement increment its respective counter ; required final position of robot ; Driver Code","code":"< ? php function finalPosition ( $ move ) { $ l = strlen ( $ move ) ; $ countUp = 0 ; $ countDown = 0 ; $ countLeft = 0 ; $ countRight = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ move [ $ i ] == ' U ' ) $ countUp ++ ; else if ( $ move [ $ i ] == ' D ' ) $ countDown ++ ; else if ( $ move [ $ i ] == ' L ' ) $ countLeft ++ ; else if ( $ move [ $ i ] == ' R ' ) $ countRight ++ ; } echo \" Final \u2581 Position : \u2581 ( \" . ( $ countRight - $ countLeft ) . \" , \" \u2581 , \u2581 ( $ countUp \u2581 - \u2581 $ countDown ) \u2581 . \u2581 \" ) \" \u2581 . \" \" } $ move = \" UDDLLRUUUDUURUDDUULLDRRRR \" ; finalPosition ( $ move ) ; ? >"}
{"text":"Length of longest balanced parentheses prefix | Return the length of longest balanced parentheses prefix . ; Traversing the string . ; If open bracket add 1 to sum . ; If closed bracket subtract 1 from sum ; if first bracket is closing bracket then this condition would help ; If sum is 0 , store the index value . ; Driver Code","code":"< ? php function maxbalancedprefix ( $ str , $ n ) { $ sum = 0 ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) $ sum += 1 ; else $ sum -= 1 ; if ( $ sum < 0 ) break ; if ( $ sum == 0 ) $ maxi = $ i + 1 ; } return $ maxi ; } $ str = array ( ' ( ' , ' ( ' , ' ( ' , ' ) ' , ' ( ' , ' ) ' , ' ) ' , ' ( ' , ' ) ' , ' ) ' , ' ( ' , ' ( ' ) ; $ n = count ( $ str ) ; echo maxbalancedprefix ( $ str , $ n ) ; ? >"}
{"text":"Minimum cost to convert string into palindrome | Function to return cost ; length of string ; Iterate from both sides of string . If not equal , a cost will be there ; Driver code","code":"< ? php function cost ( $ str ) { $ len = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 , $ j = $ len - 1 ; $ i < $ j ; $ i ++ , $ j -- ) if ( $ str [ $ i ] != $ str [ $ j ] ) $ res += ( min ( ord ( $ str [ $ i ] ) , ord ( $ str [ $ j ] ) ) - ord ( ' a ' ) + 1 ) ; return $ res ; } $ str = \" abcdef \" ; echo cost ( $ str ) ; ? >"}
{"text":"Possibility of a word from a given set of characters | PHP program to check if a query string is present is given set . ; Count occurrences of all characters in s . ; Check if number of occurrences of every character in q is less than or equal to that in s . ; Driver Code","code":"< ? php function isPresent ( $ s , $ q ) { $ freq = array ( 256 ) ; for ( $ i = 0 ; $ i < 256 ; $ i ++ ) $ freq [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) $ freq [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ q ) ; $ i ++ ) { $ freq [ ord ( $ q [ $ i ] ) - ord ( ' a ' ) ] -- ; if ( $ freq [ ord ( $ q [ $ i ] ) - ord ( ' a ' ) ] < 0 ) return false ; } return true ; } $ s = \" abctd \" ; $ q = \" cat \" ; if ( isPresent ( $ s , $ q ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum reduce operations to convert a given string into a palindrome | Returns count of minimum character reduce operations to make palindrome . ; Compare every character of first half with the corresponding character of second half and add difference to result . ; Driver code","code":"< ? php function countReduce ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) $ res += abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ ( $ n - $ i - 1 ) ] ) ) ; return $ res ; } $ str = \" abcd \" ; echo countReduce ( $ str ) ; ? >"}
{"text":"Minimal operations to make a number magical | function to calculate the minimal changes ; maximum digits that can be changed ; nested loops to generate all 6 digit numbers ; counter to count the number of change required ; if first digit is equal ; if 2 nd digit is equal ; if 3 rd digit is equal ; if 4 th digit is equal ; if 5 th digit is equal ; if 6 th digit is equal ; checks if less then the previous calculate changes ; returns the answer ; number stored in string ; prints the minimum operations","code":"< ? php function calculate ( $ s ) { $ ans = 6 ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { for ( $ j = 0 ; $ j < 10 ; ++ $ j ) { for ( $ k = 0 ; $ k < 10 ; ++ $ k ) { for ( $ l = 0 ; $ l < 10 ; ++ $ l ) { for ( $ m = 0 ; $ m < 10 ; ++ $ m ) { for ( $ n = 0 ; $ n < 10 ; ++ $ n ) { if ( $ i + $ j + $ k == $ l + $ m + $ n ) { $ c = 0 ; if ( $ i != $ s [ 0 ] - '0' ) $ c ++ ; if ( $ j != $ s [ 1 ] - '0' ) $ c ++ ; if ( $ k != $ s [ 2 ] - '0' ) $ c ++ ; if ( $ l != $ s [ 3 ] - '0' ) $ c ++ ; if ( $ m != $ s [ 4 ] - '0' ) $ c ++ ; if ( $ n != $ s [ 5 ] - '0' ) $ c ++ ; if ( $ c < $ ans ) $ ans = $ c ; } } } } } } } return $ ans ; } $ s = \"123456\" ; echo calculate ( $ s ) ; ? >"}
{"text":"Check if a two character string can be made using given words | Function to check if str can be made using given words ; If str itself is present ; Match first character of str with second of word and vice versa ; If both characters found . ; Driver Code","code":"< ? php function makeAndCheckString ( $ words , $ str ) { $ n = sizeof ( $ words ) ; $ first = false ; $ second = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ words [ $ i ] == $ str ) return true ; if ( $ str [ 0 ] == $ words [ $ i ] [ 1 ] ) $ first = true ; if ( $ str [ 1 ] == $ words [ $ i ] [ 0 ] ) $ second = true ; if ( $ first && $ second ) return true ; } return false ; } $ str = \" ya \" ; $ words = array ( \" ah \" , \" oy \" , \" to \" , \" ha \" ) ; if ( makeAndCheckString ( $ words , $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sentence Palindrome ( Palindrome after removing spaces , dots , . . etc ) | To check sentence is palindrome or not ; Lowercase string ; Compares character until they are equal ; If there is another symbol in left of sentence ; If there is another symbol in right of sentence ; If characters are equal ; If characters are not equal then sentence is not palindrome ; Returns true if sentence is palindrome ; Driver program to test sentencePalindrome ( )","code":"< ? php function sentencePalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) - 1 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; while ( $ l <= $ h ) { if ( ! ( $ str [ $ l ] >= ' a ' && $ str [ $ l ] <= ' z ' ) ) $ l ++ ; else if ( ! ( $ str [ $ h ] >= ' a ' && $ str [ $ h ] <= ' z ' ) ) $ h -- ; else if ( $ str [ $ l ] == $ str [ $ h ] ) { $ l ++ ; $ h -- ; } else return false ; } return true ; } $ str = \" Too \u2581 hot \u2581 to \u2581 hoot . \" ; if ( sentencePalindrome ( $ str ) ) echo \" Sentence \u2581 is \u2581 palindrome . \" ; else echo \" Sentence \u2581 is \u2581 not \u2581 palindrome . \" ; return 0 ; ? >"}
{"text":"Ways to remove one element from a binary string so that XOR becomes zero | Return number of ways in which XOR become ZERO by remove 1 element ; Counting number of 0 and 1 ; If count of ones is even then return count of zero else count of one ; Driver Code","code":"< ? php function xorZero ( $ str ) { $ one_count = 0 ; $ zero_count = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ one_count ++ ; else $ zero_count ++ ; if ( $ one_count % 2 == 0 ) return $ zero_count ; return $ one_count ; } $ str = \"11111\" ; echo xorZero ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if both halves of the string have same set of characters | PHP program to check if it is possible to split string or not ; function to check if we can split string or not ; Counter array initialized with 0 ; Length of the string ; traverse till the middle element is reached ; First half ; Second half ; Checking if values are different set flag to 1 ; String to be checked","code":"< ? php $ MAX_CHAR = 26 ; function checkCorrectOrNot ( $ s ) { global $ MAX_CHAR ; $ count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ n = strlen ( $ s ) ; if ( $ n == 1 ) return true ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) { $ count [ $ s [ $ i ] - ' a ' ] ++ ; $ count [ $ s [ $ j ] - ' a ' ] -- ; } for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count [ $ i ] != 0 ) return false ; return true ; } $ s = \" abab \" ; if ( checkCorrectOrNot ( $ s ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Determine if a string has all Unique Characters | PHP program to illustrate string with unique characters using brute force technique ; Assuming string can have characters a - z , this has 32 bits set to 0 ; if that bit is already set in checker , return false ; otherwise update and continue by setting that bit in the checker ; no duplicates encountered , return true ; Driver Code","code":"< ? php function uniqueCharacters ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ bitAtIndex = $ str [ $ i ] - ' a ' ; if ( ( $ checker & ( 1 << $ bitAtIndex ) ) > 0 ) { return false ; } $ checker = $ checker | ( 1 << $ bitAtIndex ) ; } return true ; } $ str = \" geeksforgeeks \" ; if ( uniqueCharacters ( $ str ) ) { echo \" The \u2581 String \u2581 \" , $ str , \" \u2581 has \u2581 all \u2581 unique \u2581 characters STRNEWLINE \" ; } else { echo \" The \u2581 String \u2581 \" , $ str , \" \u2581 has \u2581 duplicate \u2581 characters STRNEWLINE \" ; } ? >"}
{"text":"Check whether K | PHP program to check if k - th bit of a given number is set or not ; Driver code","code":"< ? php function isKthBitSet ( $ n , $ k ) { if ( $ n & ( 1 << ( $ k - 1 ) ) ) echo \" SET \" ; else echo \" NOT \u2581 SET \" ; } $ n = 5 ; $ k = 1 ; isKthBitSet ( $ n , $ k ) ; ? >"}
{"text":"Recursive function to check if a string is palindrome | A recursive function that check a str [ s . . e ] is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code","code":"< ? php function isPalRec ( $ str , $ s , $ e ) { if ( $ s == $ e ) return true ; if ( $ str [ $ s ] != $ str [ $ e ] ) return false ; if ( $ s < $ e + 1 ) return isPalRec ( $ str , $ s + 1 , $ e - 1 ) ; return true ; } function isPalindrome ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 ) return true ; return isPalRec ( $ str , 0 , $ n - 1 ) ; } { $ str = \" geeg \" ; if ( isPalindrome ( $ str ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; return 0 ; } ? >"}
{"text":"Count substrings with same first and last characters | assuming lower case only ; Calculating frequency of each character in the string . ; Computing result using counts ; Driver Code","code":"< ? php $ MAX_CHAR = 26 ; function countSubstringWithEqualEnds ( $ s ) { global $ MAX_CHAR ; $ result = 0 ; $ n = strlen ( $ s ) ; $ count = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ result += ( $ count [ $ i ] * ( $ count [ $ i ] + 1 ) \/ 2 ) ; return $ result ; } $ s = \" abcab \" ; echo countSubstringWithEqualEnds ( $ s ) ; ? >"}
{"text":"Maximum consecutive repeating character in string | Returns the maximum repeating character in a given string ; Traverse string except last character ; If current character matches with next ; If doesn 't match, update result  (if required) and reset count ; Driver code","code":"< ? php function maxRepeating ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; $ cur_count = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) $ cur_count ++ ; else { if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } $ cur_count = 1 ; } } return $ res ; } $ str = \" aaaabbaaccde \" ; echo maxRepeating ( $ str ) ; ? >"}
{"text":"Queries for characters in a repeated string | Print whether index i and j have same element or not . ; Finding relative position of index i , j . ; Checking is element are same at index i , j . ; Driver Code","code":"< ? php function query ( $ s , $ i , $ j ) { $ n = strlen ( $ s ) ; $ i %= $ n ; $ j %= $ n ; if ( ( $ s [ $ i ] == $ s [ $ j ] ) ) echo \" Yes STRNEWLINE \" ; else echo \" No \" ; } $ X = \" geeksforgeeks \" ; query ( $ X , 0 , 8 ) ; query ( $ X , 8 , 13 ) ; query ( $ X , 6 , 15 ) ; ? >"}
{"text":"Count of character pairs at same distance as in English alphabets | Function to count pairs ; Increment count if characters are at same distance ; Driver code","code":"< ? php function countPairs ( $ str ) { $ result = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ $ j ] ) ) == abs ( $ i - $ j ) ) $ result ++ ; return $ result ; } $ str = \" geeksforgeeks \" ; echo countPairs ( $ str ) ; ? >"}
{"text":"Longest common subsequence with permutations allowed | Function to calculate longest string str1 -- > first string str2 -- > second string count1 [ ] -- > hash array to calculate frequency of characters in str1 count [ 2 ] -- > hash array to calculate frequency of characters in str2 result -- > resultant longest string whose permutations are sub - sequence of given two strings ; calculate frequency of characters ; Now traverse hash array ; append character ( ' a ' + i ) in resultant string ' result ' by min ( count1 [ $i ] , count2 [ $i ] ) times ; Driver Code","code":"< ? php function longestString ( $ str1 , $ str2 ) { $ count1 = array_fill ( 0 , 26 , NULL ) ; $ count2 = array_fill ( 0 , 26 , NULL ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) $ count1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) $ count2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ result = \" \" ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) for ( $ j = 1 ; $ j <= min ( $ count1 [ $ i ] , $ count2 [ $ i ] ) ; $ j ++ ) $ result = $ result . chr ( ord ( ' a ' ) + $ i ) ; echo $ result ; } $ str1 = \" geeks \" ; $ str2 = \" cake \" ; longestString ( $ str1 , $ str2 ) ; ? >"}
{"text":"Count number of substrings with exactly k distinct characters | Function to count number of substrings with exactly k unique characters ; Initialize result ; To store count of characters from ' a ' to ' z ' ; Consider all substrings beginning with str [ i ] ; Initializing count array with 0 ; Consider all substrings between str [ i . . j ] ; If this is a new character for this substring , increment dist_count . ; Increment count of current character ; If distinct character count becomes k , then increment result . ; Driver code","code":"< ? php function countkDist ( $ str , $ k ) { $ res = 0 ; $ n = strlen ( $ str ) ; $ cnt = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dist_count = 0 ; $ cnt = array_fill ( 0 , 0 , true ) ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] == 0 ) $ dist_count ++ ; $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] ++ ; if ( $ dist_count == $ k ) $ res ++ ; } } return $ res ; } { $ ch = \" abcbaa \" ; $ k = 3 ; echo ( \" Total \u2581 substrings \u2581 with \u2581 exactly \u2581 \" . $ k . \" \u2581 distinct \u2581 characters \u2581 : \u2581 \" . countkDist ( $ ch , $ k ) ) ; }"}
{"text":"Remove repeated digits in a given number | PHP program to remove repeated digits ; Store first digits as previous digit ; Initialize power ; Iterate through all digits of n , note that the digits are processed from least significant digit to most significant digit . ; Store current digit ; Add the current digit to the beginning of result ; Update previous result and power ; Remove last digit from n ; Driver Code","code":"< ? php function removeRecur ( $ n ) { $ prev_digit = $ n % 10 ; $ pow = 10 ; $ res = $ prev_digit ; while ( $ n ) { $ curr_digit = $ n % 10 ; if ( $ curr_digit != $ prev_digit ) { $ res += $ curr_digit * $ pow ; $ prev_digit = $ curr_digit ; $ pow *= 10 ; } $ n = $ n \/ 10 ; } return $ res ; } $ n = 12224 ; echo removeRecur ( $ n ) ; ? >"}
{"text":"Generate all the binary strings of N bits | Function to print the output ; Function to generate all binary strings ; First assign \"0\" at ith position and try for all other permutations for remaining positions ; And then assign \"1\" at ith position and try for all other permutations for remaining positions ; Driver Code ; Print all binary strings","code":"< ? php function printTheArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] , \" \" ; } echo \" STRNEWLINE \" ; } function generateAllBinaryStrings ( $ n , $ arr , $ i ) { if ( $ i == $ n ) { printTheArray ( $ arr , $ n ) ; return ; } $ arr [ $ i ] = 0 ; generateAllBinaryStrings ( $ n , $ arr , $ i + 1 ) ; $ arr [ $ i ] = 1 ; generateAllBinaryStrings ( $ n , $ arr , $ i + 1 ) ; } $ n = 4 ; $ arr = array_fill ( 0 , $ n , 0 ) ; generateAllBinaryStrings ( $ n , $ arr , 0 ) ; ? >"}
{"text":"Largest number N which can be reduced to 0 in K steps | Utility function to return the first digit of a number . ; Remove last digit from number till only one digit is left ; return the first digit ; Utility function that returns the count of numbers written down when starting from n ; Function to find the largest number N which can be reduced to 0 in K steps ; Get the sequence length of the mid point ; Until k sequence length is reached ; Update mid point ; Get count of the new mid point ; Update right to mid ; Update left to mid ; Increment mid point by one while count is equal to k to get the maximum value of mid point ; Driver Code","code":"< ? php function firstDigit ( $ n ) { while ( $ n >= 10 ) { $ n = ( int ) ( $ n \/ 10 ) ; } return $ n ; } function getCount ( $ n ) { $ count = 1 ; while ( $ n != 0 ) { $ leadDigit = firstDigit ( $ n ) ; $ n -= $ leadDigit ; $ count ++ ; } return $ count ; } function getLargestNumber ( $ k ) { $ left = $ k ; $ right = $ k * 10 ; $ mid = ( int ) ( ( $ left + $ right ) \/ 2 ) ; $ len = getCount ( $ mid ) ; while ( $ len != $ k ) { $ mid = ( int ) ( ( $ left + $ right ) \/ 2 ) ; $ len = getCount ( $ mid ) ; if ( $ len > $ k ) { $ right = $ mid ; } else { $ left = $ mid ; } } while ( $ len == $ k ) { if ( $ len != getCount ( $ mid + 1 ) ) { break ; } $ mid ++ ; } return ( $ mid ) ; } $ k = 3 ; echo ( getLargestNumber ( $ k ) ) ; ? >"}
{"text":"Find the Diameter or Longest chord of a Circle | Function to find the longest chord ; Get the radius ; Find the diameter","code":"< ? php function diameter ( $ r ) { echo \" The \u2581 length \u2581 of \u2581 the \u2581 longest \u2581 chord \" , \" \u2581 or \u2581 diameter \u2581 of \u2581 the \u2581 circle \u2581 is \u2581 \" , 2 * $ r << \" STRNEWLINE \" ; } $ r = 4 ; diameter ( $ r ) ; ? >"}
{"text":"Slope of the line parallel to the line with the given slope | Function to return the slope of the line which is parallel to the line with the given slope ; Driver code","code":"< ? php function getSlope ( $ m ) { return $ m ; } $ m = 2 ; echo getSlope ( $ m ) ; ? >"}
{"text":"Total number of triangles formed when there are H horizontal and V vertical lines | Function to return total triangles ; Only possible triangle is the given triangle ; If only vertical lines are present ; If only horizontal lines are present ; Return total triangles ; Driver code","code":"< ? php function totalTriangles ( $ h , $ v ) { if ( $ h == 0 && $ v == 0 ) return 1 ; if ( $ h == 0 ) return ( ( $ v + 1 ) * ( $ v + 2 ) \/ 2 ) ; if ( $ v == 0 ) return ( $ h + 1 ) ; $ Total = ( $ h + 1 ) * ( ( $ v + 1 ) * ( $ v + 2 ) \/ 2 ) ; return $ Total ; } $ h = 2 ; $ v = 2 ; echo totalTriangles ( $ h , $ v ) ; ? >"}
{"text":"Largest sphere that can be inscribed in a right circular cylinder inscribed in a frustum | Function to find the biggest sphere ; the radii and height cannot be negative ; radius of the sphere ; volume of the sphere ; Driver code","code":"< ? php function sph ( $ r , $ R , $ h ) { if ( $ r < 0 && $ R < 0 && $ h < 0 ) return -1 ; $ x = $ r ; $ V = ( 4 * 3.14 * pow ( $ r , 3 ) ) \/ 3 ; return $ V ; } $ r = 5 ; $ R = 8 ; $ h = 11 ; echo sph ( $ r , $ R , $ h ) ; #This  Code is contributed by ajit.. NEW_LINE ? >"}
{"text":"Check whether two straight lines are orthogonal or not | Function to check if two straight lines are orthogonal or not ; Both lines have infinite slope ; Only line 1 has infinite slope ; Only line 2 has infinite slope ; Find slopes of the lines ; Check if their product is - 1 ; Driver code","code":"< ? php function checkOrtho ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { if ( $ x2 - $ x1 == 0 && $ x4 - $ x3 == 0 ) return false ; else if ( $ x2 - $ x1 == 0 ) { $ m2 = ( int ) ( ( $ y4 - $ y3 ) \/ ( $ x4 - $ x3 ) ) ; if ( $ m2 == 0 ) return true ; else return false ; } else if ( $ x4 - $ x3 == 0 ) { $ m1 = ( int ) ( ( $ y2 - $ y1 ) \/ ( $ x2 - $ x1 ) ) ; if ( $ m1 == 0 ) return true ; else return false ; } else { $ m1 = ( int ) ( ( $ y2 - $ y1 ) \/ ( $ x2 - $ x1 ) ) ; $ m2 = ( int ) ( ( $ y4 - $ y3 ) \/ ( $ x4 - $ x3 ) ) ; if ( $ m1 * $ m2 == -1 ) return true ; else return false ; } } $ x1 = 0 ; $ y1 = 4 ; $ x2 = 0 ; $ y2 = -9 ; $ x3 = 2 ; $ y3 = 0 ; $ x4 = -1 ; $ y4 = 0 ; if ( checkOrtho ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text":"Diagonal of a Regular Pentagon | Function to find the diagonal of a regular pentagon ; Side cannot be negative ; Length of the diagonal ; Driver code","code":"< ? php function pentdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.22 * $ a ; return $ d ; } $ a = 6 ; echo pentdiagonal ( $ a ) ; ? >"}
{"text":"Area of hexagon with given diagonal length | Function to calculate area ; Formula to find area ; Driver Code","code":"< ? php function hexagonArea ( $ d ) { return ( 3 * sqrt ( 3 ) * pow ( $ d , 2 ) ) \/ 8 ; } $ d = 10 ; echo \" Area \u2581 of \u2581 hexagon : \u2581 \" , hexagonArea ( $ d ) ; ? >"}
{"text":"Number of squares of side length required to cover an N * M rectangle | function to find number of squares of a * a required to cover n * m rectangle ; Driver code ; function call","code":"< ? php function Squares ( $ n , $ m , $ a ) { return ( ( int ) ( ( $ m + $ a - 1 ) \/ $ a ) ) * ( ( int ) ( ( $ n + $ a - 1 ) \/ $ a ) ) ; } $ n = 6 ; $ m = 6 ; $ a = 4 ; echo Squares ( $ n , $ m , $ a ) ; ? >"}
{"text":"Length of the Diagonal of the Octagon | Function to find the diagonal of the octagon ; side cannot be negative ; diagonal of the octagon ; Driver code","code":"< ? php function octadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return $ a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; } $ a = 4 ; echo octadiagonal ( $ a ) ; ? >"}
{"text":"Program to Calculate the Perimeter of a Decagon | Function for finding the perimeter ; Driver Code","code":"< ? php function CalPeri ( $ s ) { $ Perimeter = 10 * $ s ; echo \" The \u2581 Perimeter \u2581 of \u2581 Decagon \u2581 is \u2581 : \u2581 $ Perimeter \" ; } $ s = 5 ; CalPeri ( $ s ) ; ? >"}
{"text":"Sum of lengths of all 12 edges of any rectangular parallelepiped | function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; initialize the area of three faces which has a common vertex","code":"< ? php function findEdges ( $ s1 , $ s2 , $ s3 ) { $ a = sqrt ( $ s1 * $ s2 \/ $ s3 ) ; $ b = sqrt ( $ s3 * $ s1 \/ $ s2 ) ; $ c = sqrt ( $ s3 * $ s2 \/ $ s1 ) ; $ sum = $ a + $ b + $ c ; return 4 * $ sum ; } $ s1 ; $ s2 ; $ s3 ; $ s1 = 65 ; $ s2 = 156 ; $ s3 = 60 ; echo findEdges ( $ s1 , $ s2 , $ s3 ) ; ? >"}
{"text":"Maximum number of pieces in N cuts | Function for finding maximum pieces with n cuts . ; to maximize number of pieces x is the horizontal cuts ; Now ( x ) is the horizontal cuts and ( n - x ) is vertical cuts , then maximum number of pieces = ( x + 1 ) * ( n - x + 1 ) ; Taking the maximum number of cuts allowed as 3 ; Finding and printing the max number of pieces","code":"< ? php function findMaximumPieces ( $ n ) { $ x = ( int ) ( $ n \/ 2 ) ; return ( ( $ x + 1 ) * ( $ n - $ x + 1 ) ) ; } $ n = 3 ; echo \" Max \u2581 number \u2581 of \u2581 pieces \u2581 for \u2581 n \u2581 = \u2581 \" . $ n . \" \u2581 is \u2581 \" . findMaximumPieces ( 3 ) ; ? >"}
{"text":"Program to check whether 4 points in a 3 | Function to find equation of plane . ; checking if the 4 th point satisfies the above equation ; Driver Code ; function calling","code":"< ? php function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x , $ y , $ z ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; if ( $ a * $ x + $ b * $ y + $ c * $ z + $ d == 0 ) echo ( \" Coplanar \" ) ; else echo ( \" Not \u2581 Coplanar \" ) ; } $ x1 = 3 ; $ y1 = 2 ; $ z1 = -5 ; $ x2 = -1 ; $ y2 = 4 ; $ z2 = -3 ; $ x3 = -3 ; $ y3 = 8 ; $ z3 = -5 ; $ x4 = -3 ; $ y4 = 2 ; $ z4 = 1 ; equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x4 , $ y4 , $ z4 ) ; ? >"}
{"text":"Angle between two Planes in 3D | Function to find Angle ; Driver Code","code":"< ? php function distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { $ d = ( $ a1 * $ a2 + $ b1 * $ b2 + $ c1 * $ c2 ) ; $ e1 = sqrt ( $ a1 * $ a1 + $ b1 * $ b1 + $ c1 * $ c1 ) ; $ e2 = sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ; $ d = $ d \/ ( $ e1 * $ e2 ) ; $ pi = 3.14159 ; $ A = ( 180 \/ $ pi ) * ( acos ( $ d ) ) ; echo sprintf ( \" Angle \u2581 is \u2581 % .2f \u2581 degree \" , $ A ) ; } $ a1 = 1 ; $ b1 = 1 ; $ c1 = 2 ; $ d1 = 1 ; $ a2 = 2 ; $ b2 = -1 ; $ c2 = 1 ; $ d2 = -4 ; distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) ; ? >"}
{"text":"Mirror of a point through a 3 D plane | Function to mirror image ; Driver Code ; function call","code":"< ? php function mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) \/ ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; $ x3 = 2 * $ x2 - $ x1 ; $ y3 = 2 * $ y2 - $ y1 ; $ z3 = 2 * $ z2 - $ z1 ; echo sprintf ( \" x3 \u2581 = \u2581 % .1f \u2581 \" , $ x3 ) ; echo sprintf ( \" y3 \u2581 = \u2581 % .1f \u2581 \" , $ y3 ) ; echo sprintf ( \" z3 \u2581 = \u2581 % .1f \u2581 \" , $ z3 ) ; } $ a = 1 ; $ b = -2 ; $ c = 0 ; $ d = 0 ; $ x1 = -1 ; $ y1 = 3 ; $ z1 = 4 ; mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) ; ? >"}
{"text":"Number of rectangles in a circle of radius R | Function to return the total possible rectangles that can be cut from the circle ; Diameter = 2 * $Radius ; Square of diameter which is the square of the maximum length diagonal ; generate all combinations of a and b in the range ( 1 , ( 2 * Radius - 1 ) ) ( Both inclusive ) ; Calculate the Diagonal length of this rectangle ; If this rectangle 's Diagonal  Length is less than the  Diameter, it is a valid  rectangle, thus increment counter ; Radius of the circle","code":"< ? php function countRectangles ( $ radius ) { $ rectangles = 0 ; $ diameter = 2 * $ radius ; $ diameterSquare = $ diameter * $ diameter ; for ( $ a = 1 ; $ a < 2 * $ radius ; $ a ++ ) { for ( $ b = 1 ; $ b < 2 * $ radius ; $ b ++ ) { $ diagonalLengthSquare = ( $ a * $ a + $ b * $ b ) ; if ( $ diagonalLengthSquare <= $ diameterSquare ) { $ rectangles ++ ; } } } return $ rectangles ; } $ radius = 2 ; $ totalRectangles ; $ totalRectangles = countRectangles ( $ radius ) ; echo $ totalRectangles , \" \u2581 rectangles \u2581 can \u2581 be \u2581 \" , \" cut \u2581 from \u2581 a \u2581 circle \u2581 of \u2581 Radius \u2581 \" , $ radius ; ? >"}
{"text":"Program to check similarity of given two triangles | Function for AAA similarity ; Check for AAA ; Function for SAS similarity ; angle b \/ w two smallest sides is largest . ; since we take angle b \/ w the sides . ; Function for SSS similarity ; Check for SSS ; Driver Code ; function call for AAA similarity ; function call for SSS similarity ; function call for SAS similarity ; Check if triangles are similar or not","code":"< ? php function simi_aaa ( $ a1 , $ a2 ) { sort ( $ a1 ) ; sort ( $ a2 ) ; if ( $ a1 [ 0 ] == $ a2 [ 0 ] && $ a1 [ 1 ] == $ a2 [ 1 ] && $ a1 [ 2 ] == $ a2 [ 2 ] ) return 1 ; else return 0 ; } function simi_sas ( $ s1 , $ s2 , $ a1 , $ a2 ) { sort ( $ a1 ) ; sort ( $ a2 ) ; sort ( $ s1 ) ; sort ( $ s2 ) ; if ( $ s1 [ 0 ] \/ $ s2 [ 0 ] == $ s1 [ 1 ] \/ $ s2 [ 1 ] ) { if ( $ a1 [ 2 ] == $ a2 [ 2 ] ) return 1 ; } if ( $ s1 [ 1 ] \/ $ s2 [ 1 ] == $ s1 [ 2 ] \/ $ s2 [ 2 ] ) { if ( $ a1 [ 0 ] == $ a2 [ 0 ] ) return 1 ; } if ( $ s1 [ 2 ] \/ $ s2 [ 2 ] == $ s1 [ 0 ] \/ $ s2 [ 0 ] ) { if ( $ a1 [ 1 ] == $ a2 [ 1 ] ) return 1 ; } return 0 ; } function simi_sss ( $ s1 , $ s2 ) { sort ( $ s1 ) ; sort ( $ s2 ) ; if ( $ s1 [ 0 ] \/ $ s2 [ 0 ] == $ s1 [ 1 ] \/ $ s2 [ 1 ] && $ s1 [ 1 ] \/ $ s2 [ 1 ] == $ s1 [ 2 ] \/ $ s2 [ 2 ] && $ s1 [ 2 ] \/ $ s2 [ 2 ] == $ s1 [ 0 ] \/ $ s2 [ 0 ] ) return 1 ; return 0 ; } $ s1 = array ( 2 , 3 , 3 ) ; $ s2 = array ( 4 , 6 , 6 ) ; $ a1 = array ( 80 , 60 , 40 ) ; $ a2 = array ( 40 , 60 , 80 ) ; $ aaa = simi_aaa ( $ a1 , $ a2 ) ; $ sss = simi_sss ( $ s1 , $ s2 ) ; $ sas = simi_sas ( $ s1 , $ s2 , $ a1 , $ a2 ) ; if ( $ aaa == 1 $ sss == 1 $ sas == 1 ) { echo \" Triangles \u2581 are \u2581 similar \u2581 by \u2581 \" ; if ( $ aaa == 1 ) echo \" AAA \u2581 \" ; if ( $ sss == 1 ) echo \" SSS \u2581 \" ; if ( $ sas == 1 ) echo \" SAS . \" ; } else echo \" Triangles \u2581 are \u2581 not \u2581 similar \" ; ? >"}
{"text":"Centered Pentadecagonal Number | centered pentadecagonal function ; Formula to calculate nth centered pentadecagonal number ; Driver Code","code":"< ? php function center_pentadecagonal_num ( $ n ) { return ( 15 * $ n * $ n - 15 * $ n + 2 ) \/ 2 ; } $ n = 3 ; echo $ n , \" th \u2581 number \u2581 : \u2581 \" , center_pentadecagonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo $ n , \" th \u2581 number \u2581 : \u2581 \" , center_pentadecagonal_num ( $ n ) ; ? >"}
{"text":"Centered nonadecagonal number | centered nonadecagonal function ; Formula to calculate nth centered nonadecagonal number ; Driver Code","code":"< ? php function center_nonadecagon_num ( $ n ) { return ( 19 * $ n * $ n - 19 * $ n + 2 ) \/ 2 ; } $ n = 2 ; echo $ n , \" th \u2581 centered \u2581 \" + \" nonadecagonal \u2581 number \u2581 : \u2581 \" , center_nonadecagon_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 7 ; echo $ n , \" th \u2581 centered \u2581 \" + \" nonadecagonal \u2581 number \u2581 : \u2581 \" , center_nonadecagon_num ( $ n ) ; ? >"}
{"text":"Hendecagonal number | Function to find Hendecagonal number ; Formula to calculate nth Hendecagonal number ; Driver Code","code":"< ? php function hendecagonal_num ( $ n ) { return ( 9 * $ n * $ n - 7 * $ n ) \/ 2 ; } $ n = 3 ; echo $ n , \" th \u2581 Hendecagonal \u2581 number : \u2581 \" ; echo hendecagonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo $ n , \" th \u2581 Hendecagonal \u2581 number : \u2581 \" ; echo hendecagonal_num ( $ n ) ; ? >"}
{"text":"Centered Octagonal Number | Centered octagonal number function ; Formula to calculate nth centered octagonal number & return it into main function . ; Driver Code","code":"< ? php function cen_octagonalnum ( $ n ) { return ( 4 * $ n * $ n - 4 * $ n + 1 ) ; } $ n = 6 ; echo $ n , \" th \u2581 centered \" , \" \u2581 octagonal \u2581 number \u2581 : \u2581 \" ; echo cen_octagonalnum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 11 ; echo $ n , \" th \u2581 centered \" , \" \u2581 octagonal \u2581 number \u2581 : \u2581 \" ; echo cen_octagonalnum ( $ n ) ; ? >"}
{"text":"Number of ordered points pair satisfying line equation | Checks if ( i , j ) is valid , a point ( i , j ) is valid if point ( arr [ i ] , arr [ j ] ) satisfies the equation y = mx + c And i is not equal to j ; check if i equals to j ; Equation LHS = y , and RHS = mx + c ; Returns the number of ordered pairs ( i , j ) for which point ( arr [ i ] , arr [ j ] ) satisfies the equation of the line y = mx + c ; for every possible ( i , j ) check if ( a [ i ] , a [ j ] ) satisfies the equation y = mx + c ; ( firstIndex , secondIndex ) is same as ( i , j ) ; check if ( firstIndex , secondIndex ) is a valid point ; Driver Code ; equation of line is y = mx + c","code":"< ? php function isValid ( $ arr , $ i , $ j , $ m , $ c ) { if ( $ i == $ j ) return false ; $ lhs = $ arr [ $ j ] ; $ rhs = $ m * $ arr [ $ i ] + $ c ; return ( $ lhs == $ rhs ) ; } function findOrderedPoints ( $ arr , $ n , $ m , $ c ) { $ counter = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ firstIndex = $ i ; $ secondIndex = $ j ; if ( isValid ( $ arr , $ firstIndex , $ secondIndex , $ m , $ c ) ) $ counter ++ ; } } return $ counter ; } $ arr = array ( 1 , 2 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ m = 1 ; $ c = 1 ; echo ( findOrderedPoints ( $ arr , $ n , $ m , $ c ) ) ; ? >"}
{"text":"Check if a given circle lies completely inside the ring formed by two concentric circles | Function to check if circle lies in the ring ; distance between center of circle center of concentric circles ( origin ) using Pythagoras theorem ; Condition to check if circle is strictly inside the ring ; Both circle with radius ' r ' and ' R ' have center ( 0 , 0 )","code":"< ? php function checkcircle ( $ r , $ R , $ r1 , $ x1 , $ y1 ) { $ dis = sqrt ( $ x1 * $ x1 + $ y1 * $ y1 ) ; return ( $ dis - $ r1 >= $ R && $ dis + $ r1 <= $ r ) ; } $ r = 8 ; $ R = 4 ; $ r1 = 2 ; $ x1 = 6 ; $ y1 = 0 ; if ( checkcircle ( $ r , $ R , $ r1 , $ x1 , $ y1 ) ) echo \" yes \" , \" STRNEWLINE \" ; else echo \" no \" , \" STRNEWLINE \" ; ? >"}
{"text":"Program for Surface Area of Octahedron | utility Function ; Driver Code","code":"< ? php function surface_area_octahedron ( $ side ) { return ( 2 * ( sqrt ( 3 ) ) * ( $ side * $ side ) ) ; } $ side = 7 ; echo ( \" Surface \u2581 area \u2581 of \u2581 octahedron \u2581 = \" ) ; echo ( surface_area_octahedron ( $ side ) ) ; ? >"}
{"text":"Count of different straight lines with total n points with m collinear | Returns value of binomial coefficient ; $C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; function to calculate number of straight lines can be formed ; Driver Code","code":"< ? php function nCk ( $ n , $ k ) { $ C = array_fill ( 0 , $ k + 1 , NULL ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } function count_Straightlines ( $ n , $ m ) { return ( nCk ( $ n , 2 ) - nCk ( $ m , 2 ) + 1 ) ; } $ n = 4 ; $ m = 3 ; echo ( count_Straightlines ( $ n , $ m ) ) ; ? >"}
{"text":"Calculate Volume of Dodecahedron | utility Function ; Driver Function","code":"< ? php function vol_of_dodecahedron ( $ side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) \/ 4 ) * ( pow ( $ side , 3 ) ) ) ; } $ side = 4 ; echo ( \" Volume \u2581 of \u2581 dodecahedron \u2581 = \u2581 \" ) ; echo ( vol_of_dodecahedron ( $ side ) ) ; ? >"}
{"text":"Program to check if water tank overflows when n solid balls are dipped in the water tank | function to find if tank will overflow or not ; cylinder capacity ; volume of water in tank ; volume of n balls ; total volume of water and n dipped balls ; condition to check if tank is in overflow state or not ; giving dimensions ; calling function","code":"< ? php function overflow ( $ H , $ r , $ h , $ N , $ R ) { $ tank_cap = 3.14 * $ r * $ r * $ H ; $ water_vol = 3.14 * $ r * $ r * $ h ; $ balls_vol = $ N * ( 4 \/ 3 ) * 3.14 * $ R * $ R * $ R ; $ vol = $ water_vol + $ balls_vol ; if ( $ vol > $ tank_cap ) { echo \" Overflow \" , \" STRNEWLINE \" ; } else { echo \" Not \u2581 in \u2581 overflow \u2581 state \" , \" STRNEWLINE \" ; } } $ H = 10 ; $ r = 5 ; $ h = 5 ; $ N = 2 ; $ R = 2 ; overflow ( $ H , $ r , $ h , $ N , $ R ) ; ? >"}
{"text":"Program to check if tank will overflow , underflow or filled in given time | function to calculate the volume of tank ; function to print overflow \/ filled \/ underflow accordingly ; radius of the tank ; height of the tank ; rate of flow of water ; time given ; calculate the required time ; printing the result","code":"< ? php function volume ( $ radius , $ height ) { return ( ( 22 \/ 7 ) * $ radius * $ radius * $ height ) ; } function check_and_print ( $ required_time , $ given_time ) { if ( $ required_time < $ given_time ) echo ( \" Overflow \" ) ; else if ( $ required_time > $ given_time ) echo ( \" Underflow \" ) ; else echo ( \" Filled \" ) ; } $ radius = 5 ; $ height = 10 ; $ rate_of_flow = 10 ; $ given_time = 70.0 ; $ required_time = volume ( $ radius , $ height ) \/ $ rate_of_flow ; check_and_print ( $ required_time , $ given_time ) ; ? >"}
{"text":"Program to find third side of triangle using law of cosines | Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to find third side ; Driver Code ; function call","code":"< ? php function cal_cos ( $ n ) { $ accuracy = 0.0001 ; $ x1 ; $ denominator ; $ cosx ; $ cosval ; $ n = $ n * ( 3.142 \/ 180.0 ) ; $ x1 = 1 ; $ cosx = $ x1 ; $ cosval = cos ( $ n ) ; $ i = 1 ; do { $ denominator = 2 * $ i * ( 2 * $ i - 1 ) ; $ x1 = - $ x1 * $ n * $ n \/ $ denominator ; $ cosx = $ cosx + $ x1 ; $ i = $ i + 1 ; } while ( $ accuracy <= ( $ cosval - $ cosx ) ) ; return $ cosx ; } function third_side ( $ a , $ b , $ c ) { $ angle = cal_cos ( $ c ) ; return sqrt ( ( $ a * $ a ) + ( $ b * $ b ) - 2 * $ a * $ b * $ angle ) ; } $ c = 49 ; $ a = 5 ; $ b = 8 ; echo third_side ( $ a , $ b , $ c ) ; ? >"}
{"text":"Check whether given circle resides in boundary maintained by two other circles | function to check if given circle fit in boundary or not ; Distance from the center ; Checking the corners of circle ; Radius of outer circle and inner circle respectively ; Co - ordinates and radius of the circle to be checked","code":"< ? php function fitOrNotFit ( $ R , $ r , $ x , $ y , $ rad ) { $ val = sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) ; if ( $ val + $ rad <= $ R && $ val - $ rad >= $ R - $ r ) echo \" Fits STRNEWLINE \" ; else echo \" Doesn ' t \u2581 Fit STRNEWLINE \" ; } $ R = 8 ; $ r = 4 ; $ x = 5 ; $ y = 3 ; $ rad = 3 ; fitOrNotFit ( $ R , $ r , $ x , $ y , $ rad ) ; ? >"}
{"text":"Regular polygon using only 1 s in a binary numbered circle | method returns true if polygon is possible with ' midpoints ' number of midpoints ; loop for getting first vertex of polygon ; loop over array values at ' midpoints ' distance ; and ( & ) all those values , if even one of them is 0 , val will be 0 ; if val is still 1 and ( N \/ midpoints ) or ( number of vertices ) are more than two ( for a polygon minimum ) print result and return true ; method prints sides in the polygon or print not possible in case of no possible polygon ; limit for iterating over divisors ; If i divides N then i and ( N \/ i ) will be divisors ; check polygon for both divisors ; Driver Code","code":"< ? php function checkPolygonWithMidpoints ( $ arr , $ N , $ midpoints ) { for ( $ j = 0 ; $ j < $ midpoints ; $ j ++ ) { $ val = 1 ; for ( $ k = $ j ; $ k < $ N ; $ k += $ midpoints ) { $ val &= $ arr [ $ k ] ; } if ( $ val && $ N \/ $ midpoints > 2 ) { echo \" Polygon \u2581 possible \u2581 with \u2581 side \u2581 length \u2581 \" , ( $ N \/ $ midpoints ) , \" STRNEWLINE \" ; return true ; } } return false ; } function isPolygonPossible ( $ arr , $ N ) { $ limit = sqrt ( $ N ) ; for ( $ i = 1 ; $ i <= $ limit ; $ i ++ ) { if ( $ N % $ i == 0 ) { if ( checkPolygonWithMidpoints ( $ arr , $ N , $ i ) || checkPolygonWithMidpoints ( $ arr , $ N , ( $ N \/ $ i ) ) ) return ; } } echo \" Not \u2581 possiblen \" ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ) ; $ N = sizeof ( $ arr ) ; isPolygonPossible ( $ arr , $ N ) ; ? >"}
{"text":"Maximum height when coins are arranged in a triangle | Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e decides the accuracy level ; Method to find maximum height of arrangement of coins ; calculating portion inside the square root ; Driver code to test above method","code":"< ? php function squareRoot ( $ n ) { $ x = $ n ; $ y = 1 ; $ e = 0.000001 ; while ( $ x - $ y > $ e ) { $ x = ( $ x + $ y ) \/ 2 ; $ y = $ n \/ $ x ; } return $ x ; } function findMaximumHeight ( $ N ) { $ n = 1 + 8 * $ N ; $ maxH = ( -1 + squareRoot ( $ n ) ) \/ 2 ; return floor ( $ maxH ) ; } $ N = 12 ; echo findMaximumHeight ( $ N ) ; ? >"}
{"text":"The Stock Span Problem | Fills array S [ ] with span values ; Span value of first day is always 1 ; Calculate span value of remaining days by linearly checking previous days ; Initialize span value ; Traverse left while the next element on left is smaller than price [ i ] ; print the calculated span values ; Driver Code ; Fill the span values in array S [ ]","code":"< ? php function calculateSpan ( $ price , $ n , $ S ) { $ S [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ S [ $ i ] = 1 ; for ( $ j = $ i - 1 ; ( $ j >= 0 ) && ( $ price [ $ i ] >= $ price [ $ j ] ) ; $ j -- ) $ S [ $ i ] ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ S [ $ i ] . \" \u2581 \" ; ; } $ price = array ( 10 , 4 , 5 , 90 , 120 , 80 ) ; $ n = count ( $ price ) ; $ S = array ( $ n ) ; calculateSpan ( $ price , $ n , $ S ) ; ? >"}
{"text":"Next Greater Element | prints element and NGE pair for all elements of arr [ ] of size n ; Driver Code","code":"< ? php function printNGE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . \" -- \" . \u2581 $ next . \" \" } } $ arr = array ( 11 , 13 , 21 , 3 ) ; $ n = count ( $ arr ) ; printNGE ( $ arr , $ n ) ; ? >"}
{"text":"Program for Tower of Hanoi | Tower of Hanoi ( n - disk ) algorithm in PHP with Display of Pole \/ rod Contents the 3 poles representation ; Number of disks ; A , B and C are names of rods","code":"< ? php $ poles = array ( array ( ) , array ( ) , array ( ) ) ; function TOH ( $ n , $ A = \" A \" , $ B = \" B \" , $ C = \" C \" ) { if ( $ n > 0 ) { TOH ( $ n - 1 , $ A , $ C , $ B ) ; echo \" Move \u2581 disk \u2581 from \u2581 rod \u2581 $ A \u2581 to \u2581 rod \u2581 $ C \u2581 STRNEWLINE \" ; move ( $ A , $ C ) ; dispPoles ( ) ; TOH ( $ n - 1 , $ B , $ A , $ C ) ; } else { return ; } } function initPoles ( $ n ) { global $ poles ; for ( $ i = $ n ; $ i >= 1 ; -- $ i ) { $ poles [ 0 ] [ ] = $ i ; } } function move ( $ source , $ destination ) { global $ poles ; if ( $ source == \" A \" ) $ ptr1 = 0 ; elseif ( $ source == \" B \" ) $ ptr1 = 1 ; else $ ptr1 = 2 ; if ( $ destination == \" A \" ) $ ptr2 = 0 ; elseif ( $ destination == \" B \" ) $ ptr2 = 1 ; else $ ptr2 = 2 ; $ top = array_pop ( $ poles [ $ ptr1 ] ) ; array_push ( $ poles [ $ ptr2 ] , $ top ) ; } function dispPoles ( ) { global $ poles ; echo \" A : \u2581 [ \" . implode ( \" , \u2581 \" , $ poles [ 0 ] ) . \" ] \u2581 \" ; echo \" B : \u2581 [ \" . implode ( \" , \u2581 \" , $ poles [ 1 ] ) . \" ] \u2581 \" ; echo \" C : \u2581 [ \" . implode ( \" , \u2581 \" , $ poles [ 2 ] ) . \" ] \u2581 \" ; echo \" STRNEWLINE STRNEWLINE \" ; } $ numdisks = 4 ; initPoles ( $ numdisks ) ; echo \" Tower \u2581 of \u2581 Hanoi \u2581 Solution \u2581 for \u2581 $ numdisks \u2581 disks : \u2581 STRNEWLINE STRNEWLINE \" ; dispPoles ( ) ; TOH ( $ numdisks ) ; ? >"}
{"text":"Find maximum of minimum for every window size in a given array | PHP program to find maximum of minimum of all windows of different sizes Method to find maximum of minimum of all windows of different sizes ; Consider all windows of different sizes starting from size 1 ; Initialize max of min for current window size k ; Traverse through all windows of current size k ; Find minimum of current window ; Update maxOfMin if required ; Print max of min for current window size ; Driver Code","code":"< ? php function printMaxOfMin ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) { $ maxOfMin = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) { $ min = $ arr [ $ i ] ; for ( $ j = 1 ; $ j < $ k ; $ j ++ ) { if ( $ arr [ $ i + $ j ] < $ min ) $ min = $ arr [ $ i + $ j ] ; } if ( $ min > $ maxOfMin ) $ maxOfMin = $ min ; } echo $ maxOfMin , \" \" ; } } $ arr = array ( 10 , 20 , 30 , 50 , 10 , 70 , 30 ) ; $ n = sizeof ( $ arr ) ; printMaxOfMin ( $ arr , $ n ) ; ? >"}
{"text":"Reverse a number using stack | Stack to maintain order of digits ; Function to push digits into stack ; Function to reverse the number ; Function call to push number 's   digits to stack ; Popping the digits and forming the reversed number ; Return the reversed number formed ; Driver Code ; Function call to reverse number","code":"< ? php $ st = array ( ) ; function push_digits ( $ number ) { global $ st ; while ( $ number != 0 ) { array_push ( $ st , $ number % 10 ) ; $ number = ( int ) ( $ number \/ 10 ) ; } } function reverse_number ( $ number ) { global $ st ; push_digits ( $ number ) ; $ reverse = 0 ; $ i = 1 ; while ( ! empty ( $ st ) ) { $ reverse = $ reverse + ( $ st [ count ( $ st ) - 1 ] * $ i ) ; array_pop ( $ st ) ; $ i = $ i * 10 ; } return $ reverse ; } $ number = 39997 ; echo reverse_number ( $ number ) ; ? >"}
{"text":"HeapSort | To heapify a subtree rooted with node i which is an index in arr [ ] . n is size of heap ; Initialize largest as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is larger than root ; If right child is larger than largest so far ; If largest is not root ; Recursively heapify the affected sub - tree ; main function to do heap sort ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver program","code":"< ? php function heapify ( & $ arr , $ n , $ i ) { $ largest = $ i ; $ l = 2 * $ i + 1 ; $ r = 2 * $ i + 2 ; if ( $ l < $ n && $ arr [ $ l ] > $ arr [ $ largest ] ) $ largest = $ l ; if ( $ r < $ n && $ arr [ $ r ] > $ arr [ $ largest ] ) $ largest = $ r ; if ( $ largest != $ i ) { $ swap = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ largest ] ; $ arr [ $ largest ] = $ swap ; heapify ( $ arr , $ n , $ largest ) ; } } function heapSort ( & $ arr , $ n ) { for ( $ i = $ n \/ 2 - 1 ; $ i >= 0 ; $ i -- ) heapify ( $ arr , $ n , $ i ) ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { $ temp = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ $ i ] ; $ arr [ $ i ] = $ temp ; heapify ( $ arr , $ i , 0 ) ; } } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; } $ arr = array ( 12 , 11 , 13 , 5 , 6 , 7 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; heapSort ( $ arr , $ n ) ; echo ' Sorted array is ' . \" STRNEWLINE \" ; printArray ( $ arr , $ n ) ; ? >"}
{"text":"How to check if a given array represents a Binary Heap ? | Returns true if arr [ i . . n - 1 ] represents a max - heap ; If a leaf node ; If an internal node and is greater than its children , and same is recursively true for the children ; Driver Code","code":"< ? php function isHeap ( $ arr , $ i , $ n ) { if ( $ i >= ( $ n - 2 ) \/ 2 ) return true ; if ( $ arr [ $ i ] >= $ arr [ 2 * $ i + 1 ] && $ arr [ $ i ] >= $ arr [ 2 * $ i + 2 ] && isHeap ( $ arr , 2 * $ i + 1 , $ n ) && isHeap ( $ arr , 2 * $ i + 2 , $ n ) ) return true ; return false ; } $ arr = array ( 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ) ; $ n = sizeof ( $ arr ) ; if ( isHeap ( $ arr , 0 , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"How to check if a given array represents a Binary Heap ? | Returns true if arr [ i . . n - 1 ] represents a max - heap ; Start from root and go till the last internal node ; If left child is greater , return false ; If right child is greater , return false ; Driver Code","code":"< ? php function isHeap ( $ arr , $ i , $ n ) { for ( $ i = 0 ; $ i < ( ( $ n - 2 ) \/ 2 ) + 1 ; $ i ++ ) { if ( $ arr [ 2 * $ i + 1 ] > $ arr [ $ i ] ) return False ; if ( 2 * $ i + 2 < $ n && $ arr [ 2 * $ i + 2 ] > $ arr [ $ i ] ) return False ; return True ; } } $ arr = array ( 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ) ; $ n = sizeof ( $ arr ) ; if ( isHeap ( $ arr , 0 , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Smallest Derangement of Sequence | Efficient PHP program to find smallest derangement . ; Generate Sequence S ; Generate Derangement ; Only if i is odd Swap S [ N - 1 ] and S [ N ] ; Print Derangement ; Driver Program","code":"< ? php function generate_derangement ( $ N ) { $ S = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ S [ $ i ] = $ i ; $ D = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i += 2 ) { if ( $ i == $ N ) { $ D [ $ N ] = $ S [ $ N - 1 ] ; $ D [ $ N - 1 ] = $ S [ $ N ] ; } else { $ D [ $ i ] = $ i + 1 ; $ D [ $ i + 1 ] = $ i ; } } for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ D [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } generate_derangement ( 10 ) ; ? >"}
{"text":"Program to calculate Profit Or Loss | Function to calculate Profit . ; Function to calculate Loss . ; Driver Code .","code":"< ? php function Profit ( $ costPrice , $ sellingPrice ) { $ profit = ( $ sellingPrice - $ costPrice ) ; return $ profit ; } function Loss ( $ costPrice , $ sellingPrice ) { $ Loss = ( $ costPrice - $ sellingPrice ) ; return $ Loss ; } $ costPrice = 1500 ; $ sellingPrice = 2000 ; if ( $ sellingPrice == $ costPrice ) echo \" No \u2581 profit \u2581 nor \u2581 Loss \" ; else if ( $ sellingPrice > $ costPrice ) echo Profit ( $ costPrice , $ sellingPrice ) . \" \u2581 Profit \u2581 \" ; else echo Loss ( $ costPrice , $ sellingPrice ) . \" \u2581 Loss \u2581 \" ; ? >"}
{"text":"Find the Next perfect square greater than a given number | Function to find the next perfect square ; Driver Code","code":"< ? php function nextPerfectSquare ( $ N ) { $ nextN = floor ( sqrt ( $ N ) ) + 1 ; return $ nextN * $ nextN ; } $ n = 35 ; echo nextPerfectSquare ( $ n ) ; ? >"}
{"text":"Print all substring of a number without any conversion | Function to print the substrings of a number ; Calculate the total number of digits ; 0.5 has been added because of it will return double value like 99.556 ; Print all the numbers from starting position ; Update the no . ; Update the no . of digits ; Driver code","code":"< ? php function printSubstrings ( $ n ) { $ s = ( int ) log10 ( $ n ) ; $ d = ( int ) ( pow ( 10 , $ s ) + 0.5 ) ; $ k = $ d ; while ( $ n ) { while ( $ d ) { echo ( int ) ( $ n \/ $ d ) . \" STRNEWLINE \" ; $ d = ( int ) ( $ d \/ 10 ) ; } $ n = $ n % $ k ; $ k = ( int ) ( $ k \/ 10 ) ; $ d = $ k ; } } $ n = 123 ; printSubstrings ( $ n ) ; ? >"}
{"text":"Modulo power for large numbers represented as strings | PHP program to find ( a ^ b ) % MOD where a and b may be very large and represented as strings . ; Returns modulo exponentiation for two numbers represented as long long int . It is used by powerStrings ( ) . Its complexity is log ( n ) ; Returns modulo exponentiation for two numbers represented as strings . It is used by powerStrings ( ) ; We convert strings to number ; calculating a % MOD ; calculating b % ( MOD - 1 ) ; Now a and b are long long int . We calculate a ^ b using modulo exponentiation ; As numbers are very large that is it may contains upto 10 ^ 6 digits . So , we use string .","code":"< ? php $ MOD = 1000000007 ; function powerLL ( $ x , $ n ) { global $ MOD ; $ result = 1 ; while ( $ n ) { if ( $ n & 1 ) $ result = $ result * $ x % $ MOD ; $ n = ( int ) $ n \/ 2 ; $ x = $ x * $ x % $ MOD ; } return $ result ; } function powerStrings ( $ sa , $ sb ) { global $ MOD ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < strlen ( $ sa ) ; $ i ++ ) $ a = ( $ a * 10 + ( $ sa [ $ i ] - '0' ) ) % $ MOD ; for ( $ i = 0 ; $ i < strlen ( $ sb ) ; $ i ++ ) $ b = ( $ b * 10 + ( $ sb [ $ i ] - '0' ) ) % ( $ MOD - 1 ) ; return powerLL ( $ a , $ b ) ; } $ sa = \"2\" ; $ sb = \"3\" ; echo powerStrings ( $ sa , $ sb ) ; ? >"}
{"text":"Check if a number can be expressed as 2 ^ x + 2 ^ y | Utility function to check if a number is power of 2 or not ; Utility function to determine the value of previous power of 2 ; function to check if n can be expressed as 2 ^ x + 2 ^ y or not ; if value of n is 0 or 1 it can not be expressed as 2 ^ x + 2 ^ y ; if a number is power of 2 then it can be expressed as 2 ^ x + 2 ^ y ; if the remainder after subtracting previous power of 2 is also a power of 2 then it can be expressed as 2 ^ x + 2 ^ y ; Driver code","code":"< ? php function isPowerOfTwo ( $ n ) { return ( $ n and ! ( $ n & ( $ n - 1 ) ) ) ; } function previousPowerOfTwo ( $ n ) { while ( $ n & $ n - 1 ) { $ n = $ n & $ n - 1 ; } return $ n ; } function checkSum ( $ n ) { if ( $ n == 0 or $ n == 1 ) return false ; else if ( isPowerOfTwo ( $ n ) ) { echo \" \" \u2581 , \u2581 $ n \u2581 \/ \u2581 2 \u2581 , \u2581 \" \" return true ; } else { $ x = previousPowerOfTwo ( $ n ) ; $ y = $ n - $ x ; if ( isPowerOfTwo ( $ y ) ) { echo $ x , \" \" , $ y ; return true ; } } return false ; } $ n1 = 20 ; if ( checkSum ( $ n1 ) == false ) echo \" No \" ; echo \" STRNEWLINE \" ; $ n2 = 11 ; if ( checkSum ( $ n2 ) == false ) echo \" No \" ; ? >"}
{"text":"10 's Complement of a decimal number | Function to find 10 's complement ; Calculating total digits in num ; restore num ; calculate 10 's complement ; Driver code","code":"< ? php function complement ( $ num ) { $ i ; $ len = 0 ; $ comp ; $ temp = $ num ; while ( 1 ) { $ len ++ ; $ num = ( int ) ( $ num \/ 10 ) ; if ( abs ( $ num ) == 0 ) break ; } $ num = $ temp ; $ comp = pow ( 10 , $ len ) - $ num ; return $ comp ; } echo complement ( 25 ) . \" STRNEWLINE \" ; echo complement ( 456 ) ; ? >"}
{"text":"Program to find HCF ( Highest Common Factor ) of 2 Numbers | Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 && $ b == 0 ) return 0 ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD \u2581 of \u2581 $ a \u2581 and \u2581 $ b \u2581 is \u2581 \" , gcd ( $ a , $ b ) ; ? >"}
{"text":"Sum of all elements up to Nth row in a Pascal triangle | Function to find sum of all elements upto nth row . ; Initialize sum with 0 ; Loop to calculate power of 2 upto n and add them ; Driver Code","code":"< ? php function calculateSum ( $ n ) { $ sum = 0 ; for ( $ row = 0 ; $ row < $ n ; $ row ++ ) { $ sum = $ sum + ( 1 << $ row ) ; } return $ sum ; } $ n = 10 ; echo \" \u2581 Sum \u2581 of \u2581 all \u2581 elements \u2581 : \u2581 \" . calculateSum ( $ n ) ; ? >"}
{"text":"Number of sequences which has HEAD at alternate positions to the right of the first HEAD | function to calculate total sequences possible ; Value of N is even ; Value of N is odd ; Driver code","code":"< ? php function findAllSequence ( $ N ) { if ( $ N % 2 == 0 ) { return pow ( 2 , $ N \/ 2 + 1 ) + pow ( 2 , $ N \/ 2 ) - 2 ; } else { return pow ( 2 , ( $ N + 1 ) \/ 2 ) + pow ( 2 , ( $ N + 1 ) \/ 2 ) - 2 ; } } $ N = 2 ; echo findAllSequence ( $ N ) ; ? >"}
{"text":"Number of ones in the smallest repunit | Function to find number of 1 s in smallest repunit multiple of the number ; to store number of 1 s in smallest repunit multiple of the number . ; initialize rem with 1 ; run loop until rem becomes zero ; rem * 10 + 1 here represents the repunit modulo n ; when remainder becomes 0 return count ; Driver Code ; Calling function","code":"< ? php function countOnes ( $ n ) { $ count = 1 ; $ rem = 1 ; while ( $ rem != 0 ) { $ rem = ( $ rem * 10 + 1 ) % $ n ; $ count ++ ; } return $ count ; } $ n = 13 ; echo countOnes ( $ n ) ; ? >"}
{"text":"Largest of two distinct numbers without using any conditional statements or operators | Function to find the largest number ; Drivers code","code":"< ? php function largestNum ( $ a , $ b ) { return ( $ a * ( boolean ) floor ( ( $ a \/ $ b ) ) ) + ( $ b * ( boolean ) floor ( ( $ b \/ $ a ) ) ) ; } $ a = 22 ; $ b = 1231 ; echo ( largestNum ( $ a , $ b ) ) ;"}
{"text":"Number of Distinct Meeting Points on a Circular Road | Returns the GCD of two number . ; Returns the number of distinct meeting points . ; Find the relative speed . ; convert the negative value to positive . ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { $ c = $ a % $ b ; while ( $ c != 0 ) { $ a = $ b ; $ b = $ c ; $ c = $ a % $ b ; } return $ b ; } function numberOfmeet ( $ a , $ b ) { $ ans ; if ( $ a > $ b ) $ ans = $ a - $ b ; else $ ans = $ b - $ a ; if ( $ a < 0 ) $ a = $ a * ( -1 ) ; if ( $ b < 0 ) $ b = $ b * ( -1 ) ; return $ ans \/ gcd ( $ a , $ b ) ; } $ a = 1 ; $ b = -1 ; echo numberOfmeet ( $ a , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find larger of x ^ y and y ^ x | PHP program to print greater of x ^ y and y ^ x ; Driver Code","code":"< ? php function printGreater ( $ x , $ y ) { $ X = $ y * log ( $ x ) ; $ Y = $ x * log ( $ y ) ; if ( abs ( $ X - $ Y ) < 1e-9 ) { echo \" Equal \" ; } else if ( $ X > $ Y ) { echo $ x . \" ^ \" . $ y ; } else { echo $ y . \" ^ \" . $ x ; } } $ x = 5 ; $ y = 8 ; printGreater ( $ x , $ y ) ; ? >"}
{"text":"n | Function to find nth term ; Driver code","code":"< ? php function sumOfSeries ( $ n ) { return $ n * ( $ n + 1 ) * ( 6 * $ n * $ n * $ n + 9 * $ n * $ n + $ n - 1 ) \/ 30 ; } $ n = 4 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text":"Product of first N factorials | To compute ( a * b ) % MOD ; $res = 0 ; Initialize result ; If b is odd , add ' a ' to result ; Multiply ' a ' with 2 ; Divide b by 2 ; Return result ; This function computes factorials and product by using above function i . e . modular multiplication ; Initialize product and fact with 1 ; ith factorial ; product of first i factorials ; If at any iteration , product becomes divisible by MOD , simply return 0 ; ; Driver Code","code":"< ? php function mulmod ( $ a , $ b , $ mod ) { $ a = $ a % $ mod ; while ( $ b > 0 ) { if ( $ b % 2 == 1 ) $ res = ( $ res + $ a ) % $ mod ; $ a = ( $ a * 2 ) % $ mod ; $ b \/= 2 ; } return $ res % $ mod ; } function findProduct ( $ N ) { $ product = 1 ; $ fact = 1 ; $ MOD = 1000000000 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fact = mulmod ( $ fact , $ i , $ MOD ) ; $ product = mulmod ( $ product , $ fact , $ MOD ) ; if ( $ product == 0 ) return 0 ; } return $ product ; } $ N = 3 ; echo findProduct ( $ N ) , \" STRNEWLINE \" ; $ N = 5 ; echo findProduct ( $ N ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if sum of divisors of two numbers are same | Function to calculate sum of all proper divisors num -- > given natural number ; To store sum of divisors ; Find all divisors and add them ; Function to check if both numbers are equivalent or not ; Driver code","code":"< ? php function divSum ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum = $ sum + $ i + floor ( $ n \/ $ i ) ; return $ sum ; } function areEquivalent ( $ num1 , $ num2 ) { return divSum ( $ num1 ) == divSum ( $ num2 ) ; } $ num1 = 559 ; $ num2 = 703 ; if ( areEquivalent ( $ num1 , $ num2 ) == true ) echo \" Equivalent \" ; else echo \" Not \u2581 Equivalent \" ; ? >"}
{"text":"Dodecahedral number | Function to find dodecahedral number ; Formula to calculate nth dodecahedral number and return it into main function . ; Drivers Code ; print result","code":"< ? php function dodecahedral_num ( $ n ) { return $ n * ( 3 * $ n - 1 ) * ( 3 * $ n - 2 ) \/ 2 ; } $ n = 5 ; echo $ n , \" th \u2581 Dodecahedral \u2581 number : \u2581 \" ; echo dodecahedral_num ( $ n ) ; ? >"}
{"text":"Count of divisors having more set bits than quotient on dividing N | Return the count of set bit . ; check if q and d have same number of set bit . ; Binary Search to find the point at which number of set in q is less than or equal to d . ; while left index is less than right index ; finding the middle . ; check if q and d have same number of set it or not . ; Driver Code","code":"< ? php function bit ( $ x ) { $ ans = 0 ; while ( $ x ) { $ x \/= 2 ; $ ans ++ ; } return $ ans ; } function check ( $ d , $ x ) { if ( bit ( $ x \/ $ d ) <= bit ( $ d ) ) return true ; return false ; } function bs ( int $ n ) { $ l = 1 ; $ r = sqrt ( $ n ) ; while ( $ l < $ r ) { $ m = ( $ l + $ r ) \/ 2 ; if ( check ( $ m , $ n ) ) $ r = $ m ; else $ l = $ m + 1 ; } if ( ! check ( $ l , $ n ) ) return floor ( $ l + 1 ) ; else return floor ( $ l ) ; } function countDivisor ( $ n ) { return $ n - bs ( $ n ) + 1 ; } $ n = 5 ; echo countDivisor ( $ n ) ; ? >"}
{"text":"Check if two people starting from different points ever meet | PHP program to find if two people starting from different positions ever meet or not . ; If speed of a person at a position before other person is smaller , then return false . ; Making sure that x1 is greater ; Until one person crosses other ; first person taking one jump in each iteration ; second person taking one jump in each iteration ; Driver code","code":"< ? php function everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) { if ( $ x1 < $ x2 && $ v1 <= $ v2 ) return false ; if ( $ x1 > $ x2 && $ v1 >= $ v2 ) return false ; if ( $ x1 < $ x2 ) { list ( $ x1 , $ x2 ) = array ( $ x2 , $ x1 ) ; list ( $ v1 , $ v2 ) = array ( $ v2 , $ v1 ) ; } while ( $ x1 >= $ x2 ) { if ( $ x1 == $ x2 ) return true ; $ x1 = $ x1 + $ v1 ; $ x2 = $ x2 + $ v2 ; } return false ; } $ x1 = 5 ; $ v1 = 8 ; $ x2 = 4 ; $ v2 = 7 ; if ( everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Divisibility by 3 where each digit is the sum of all prefix digits modulo 10 | Function to check the divisibility ; Cycle ; no of residual terms ; sum of residual terms ; if no of residue term = 0 ; if no of residue term = 1 ; if no of residue term = 2 ; if no of residue term = 3 ; sum of all digits ; divisibility check ; Driver code","code":"< ? php function check ( $ k , $ d0 , $ d1 ) { $ s = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 + ( 6 * ( $ d0 + $ d1 ) ) % 10 ; $ a = ( $ k - 3 ) % 4 ; $ x ; switch ( $ a ) { case 0 : $ x = 0 ; break ; case 1 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 2 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 3 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 ; break ; } $ sum = $ d0 + $ d1 + ( int ) ( ( $ k - 3 ) \/ 4 ) * $ s + $ x ; if ( $ sum % 3 == 0 ) return \" YES \" ; return \" NO \" ; } $ k ; $ d0 ; $ d1 ; $ k = 13 ; $ d0 = 8 ; $ d1 = 1 ; echo check ( $ k , $ d0 , $ d1 ) , \" STRNEWLINE \" ; $ k = 5 ; $ d0 = 3 ; $ d1 = 4 ; echo check ( $ k , $ d0 , $ d1 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find ceil of a \/ b without using ceil ( ) function | taking input 1 ; example of perfect division taking input 2","code":"< ? php $ a = 4 ; $ b = 3 ; $ val = ( $ a \/ $ b ) + ( ( $ a % $ b ) != 0 ) ; echo \" The \u2581 ceiling \u2581 value \u2581 of \u2581 4\/3 \u2581 is \u2581 \" , floor ( $ val ) , \" STRNEWLINE \" ; $ a = 6 ; $ b = 3 ; $ val = ( $ a \/ $ b ) + ( ( $ a % $ b ) != 0 ) ; echo \" The \u2581 ceiling \u2581 value \u2581 of \u2581 6\/3 \u2581 is \u2581 \" , $ val ; ? >"}
{"text":"Program to print Collatz Sequence | PHP program to print Collatz sequence ; We simply follow steps while we do not reach 1 ; If $n is odd ; If even ; Print 1 at the end ; Driver code","code":"< ? php function printCollatz ( $ n ) { while ( $ n != 1 ) { echo $ n . \" \" ; if ( $ n & 1 ) $ n = 3 * $ n + 1 ; else $ n = $ n \/ 2 ; } echo $ n ; } printCollatz ( 6 ) ; ? >"}
{"text":"Powers of 2 to required sum | PHP program to find the blocks for given number . ; Convert decimal number to its binary equivalent ; Displaying the output when the bit is '1' in binary equivalent of number . ; Driver Code","code":"< ? php function block ( $ x ) { $ v = array ( ) ; echo ' locks for ' . $ x . ' \u2581 : \u2581 ' ; while ( $ x > 0 ) { array_push ( $ v , intval ( $ x % 2 ) ) ; $ x = intval ( $ x \/ 2 ) ; } for ( $ i = 0 ; $ i < sizeof ( $ v ) ; $ i ++ ) { if ( $ v [ $ i ] == 1 ) { print $ i ; if ( $ i != sizeof ( $ v ) - 1 ) echo ' , \u2581 ' ; } } echo \" STRNEWLINE \" ; } block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ; ? >"}
{"text":"Given a number N in decimal base , find number of its digits in any base ( base b ) | function to print number of digits ; Calculating log using base changing property and then taking it floor and then adding 1. ; printing output ; taking inputs ; calling the method","code":"< ? php function findNumberOfDigits ( $ n , $ b ) { $ dig = ( int ) ( floor ( log ( $ n ) \/ log ( $ b ) ) + 1 ) ; echo ( \" The \u2581 Number \u2581 of \u2581 digits \" . \" \u2581 of \u2581 Number \u2581 \" . $ n . \" \u2581 in \u2581 base \u2581 \" . $ b . \" \u2581 is \u2581 \" . $ dig ) ; } $ n = 1446 ; $ b = 7 ; findNumberOfDigits ( $ n , $ b ) ; ? >"}
{"text":"Nesbitt 's Inequality | PHP code to verify Nesbitt 's Inequality ; 3 parts of the inequality sum ; Driver Code","code":"< ? php function isValidNesbitt ( $ a , $ b , $ c ) { $ A = $ a \/ ( $ b + $ c ) ; $ B = $ b \/ ( $ a + $ c ) ; $ C = $ c \/ ( $ a + $ b ) ; $ inequality = $ A + $ B + $ C ; return ( $ inequality >= 1.5 ) ; } $ a = 1.0 ; $ b = 2.0 ; $ c = 3.0 ; if ( isValidNesbitt ( $ a , $ b , $ c ) ) echo \" Nesbitt ' s \u2581 inequality \u2581 satisfied . \" , \" for \u2581 real \u2581 numbers \u2581 \" , $ a , \" , \u2581 \" , $ b , \" , \u2581 \" , $ c , \" STRNEWLINE \" ; else cout << \" Not \u2581 satisfied \" ; ? >"}
{"text":"Cube Free Numbers smaller than n | Efficient PHP Program to print all cube free numbers smaller than or equal to n . ; Initialize all numbers as not cube free ; Traverse through all possible cube roots ; If i itself is cube free ; Mark all multiples of i as not cube free ; Print all cube free numbers ; Driver Code","code":"< ? php function printCubeFree ( $ n ) { $ cubFree = array_fill ( 0 , ( $ n + 1 ) , 1 ) ; $ i = 2 ; while ( $ i * $ i * $ i <= $ n ) { if ( $ cubFree [ $ i ] == 1 ) { $ multiple = 1 ; while ( $ i * $ i * $ i * $ multiple <= $ n ) { $ cubFree [ $ i * $ i * $ i * $ multiple ] = 0 ; $ multiple += 1 ; } } $ i += 1 ; } for ( $ i = 2 ; $ i < $ n + 1 ; $ i ++ ) if ( $ cubFree [ $ i ] == 1 ) echo $ i . \" \" ; } printCubeFree ( 20 ) ; ? >"}
{"text":"Squared triangular number ( Sum of cubes ) | Returns root of n ( n + 1 ) \/ 2 = num if num is triangular ( or integerroot exists ) . Else returns - 1. ; Considering the equation n * ( n + 1 ) \/ 2 = num . The equation is : a ( n ^ 2 ) + bn + c = 0 \"; ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Returns square root of x if it is perfect square . Else returns - 1. ; Find floating point value of square root of x . ; If square root is an integer ; Function to find if the given number is sum of the cubes of first n natural numbers ; Driver code","code":"< ? php function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ c = ( -2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return -1 ; $ root1 = ( - $ b + sqrt ( $ d ) ) \/ ( 2 * $ a ) ; $ root2 = ( - $ b - sqrt ( $ d ) ) \/ ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return $ root1 ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return $ root2 ; return -1 ; } function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; if ( ( $ sr - floor ( $ sr ) ) == 0 ) return floor ( $ sr ) ; else return -1 ; } function findS ( $ s ) { $ sr = isPerfectSquare ( $ s ) ; if ( $ sr == -1 ) return -1 ; return isTriangular ( $ sr ) ; } $ s = 9 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo \" - 1\" ; else echo $ n ; ? >"}
{"text":"Smallest even digits number not less than N | function to return the answer when the first odd digit is 9 ; traverse towwars the left to find the non - 8 digit ; index digit ; if digit is not 8 , then break ; if on the left side of the '9' , no 8 is found then we return by adding a 2 and 0 's ; till non - 8 digit add all numbers ; if non - 8 is even or odd than add the next even . ; add 0 to right of 9 ; function to return the smallest number with all digits even ; convert the number to string to perform operations ; find out the first odd number ; if no odd numbers are there , than n is the answer ; if the odd number is 9 , than tricky case handles it ; add all digits till first odd ; increase the odd digit by 1 ; add 0 to the right of the odd number ; Driver Code","code":"< ? php function trickyCase ( $ s , $ index ) { $ index1 = -1 ; for ( $ i = $ index - 1 ; $ i >= 0 ; $ i -- ) { $ digit = $ s [ $ i ] - '0' ; if ( $ digit != 8 ) { $ index1 = $ i ; break ; } } if ( $ index1 == -1 ) return 2 * pow ( 10 , strlen ( $ s ) ) ; $ num = 0 ; for ( $ i = 0 ; $ i < $ index1 ; $ i ++ ) $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; if ( $ s [ $ index1 ] % 2 == 0 ) $ num = $ num * 10 + ( $ s [ $ index1 ] - '0' + 2 ) ; else $ num = $ num * 10 + ( $ s [ $ index1 ] - '0' + 1 ) ; for ( $ i = $ index1 + 1 ; $ i < strlen ( $ s ) ; $ i ++ ) $ num = $ num * 10 ; return $ num ; } function smallestNumber ( $ n ) { $ num = 0 ; $ s = \" \" ; $ duplicate = $ n ; while ( $ n ) { $ s = chr ( $ n % 10 + 48 ) . $ s ; $ n = ( int ) ( $ n \/ 10 ) ; } $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ digit = $ s [ $ i ] - '0' ; if ( $ digit & 1 ) { $ index = $ i ; break ; } } if ( $ index == -1 ) return $ duplicate ; if ( $ s [ $ index ] == '9' ) { $ num = trickyCase ( $ s , $ index ) ; return $ num ; } for ( $ i = 0 ; $ i < $ index ; $ i ++ ) $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; $ num = $ num * 10 + ( $ s [ $ index ] - '0' + 1 ) ; for ( $ i = $ index + 1 ; $ i < strlen ( $ s ) ; $ i ++ ) $ num = $ num * 10 ; return $ num ; } $ N = 2397 ; echo smallestNumber ( $ N ) ; ? >"}
{"text":"n | Simple PHP program to find n - th number with sum of digits as 10. ; Find sum of digits in current no . ; If sum is 10 , we increment count ; If count becomes n , we return current number . ; Driver Code","code":"< ? php function findNth ( $ n ) { $ count = 0 ; for ( $ curr = 19 ; ; $ curr += 9 ) { $ sum = 0 ; for ( $ x = $ curr ; $ x > 0 ; $ x = ( int ) $ x \/ 10 ) $ sum = $ sum + $ x % 10 ; if ( $ sum == 10 ) $ count ++ ; if ( $ count == $ n ) return $ curr ; } return -1 ; } echo findNth ( 5 ) ; ? >"}
{"text":"Sum of pairwise products | Simple PHP program to find sum of given series . ; Driver Code","code":"< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = $ i ; $ j <= $ n ; $ j ++ ) $ sum = $ sum + $ i * $ j ; return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text":"Sum of pairwise products | Efficient PHP program to find sum of given series . ; Sum of multiples of 1 is 1 * ( 1 + 2 + . . ) ; Adding sum of multiples of numbers other than 1 , starting from 2. ; Subtract previous number from current multiple . ; For example , for 2 , we get sum as ( 2 + 3 + 4 + ... . ) * 2 ; Driver code","code":"< ? php function findSum ( $ n ) { $ multiTerms = ( int ) ( $ n * ( $ n + 1 ) \/ 2 ) ; $ sum = $ multiTerms ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ multiTerms = $ multiTerms - ( $ i - 1 ) ; $ sum = $ sum + $ multiTerms * $ i ; } return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text":"Sum of n digit numbers divisible by a given number | find the Sum of having n digit and divisible by the number ; compute the first and last term ; first number which is divisible by given number ; last number which is divisible by given number ; total divisible number ; return the total sum ; Driver Code","code":"< ? php function totalSumDivisibleByNum ( $ digit , $ number ) { $ firstnum = pow ( 10 , $ digit - 1 ) ; $ lastnum = pow ( 10 , $ digit ) ; $ firstnum = ( $ firstnum - $ firstnum % $ number ) + $ number ; $ lastnum = ( $ lastnum - $ lastnum % $ number ) ; $ count = ( ( $ lastnum - $ firstnum ) \/ $ number + 1 ) ; return ( ( $ lastnum + $ firstnum ) * $ count ) \/ 2 ; } $ n = 3 ; $ number = 7 ; echo totalSumDivisibleByNum ( $ n , $ number ) ; ? >"}
{"text":"Program for N | PHP Program to find nth term of Arithmetic progression ; using formula to find the Nth term t ( n ) = a ( 1 ) + ( n - 1 ) * d ; starting number ; Common difference ; N th term to be find ; Display the output","code":"< ? php function Nth_of_AP ( $ a , $ d , $ N ) { return ( $ a + ( $ N - 1 ) * $ d ) ; } $ a = 2 ; $ d = 1 ; $ N = 5 ; echo ( \" The \u2581 \" . $ N . \" th \u2581 term \u2581 of \u2581 the \u2581 series \u2581 is \u2581 : \u2581 \" . Nth_of_AP ( $ a , $ d , $ N ) ) ; ? >"}
{"text":"Fibbinary Numbers ( No consecutive 1 s in binary ) | function to check if binary representation of an integer has consecutive 1 s ; stores the previous last bit initially as 0 ; if current last bit and previous last bit is 1 ; stores the last bit ; right shift the number ; Driver code","code":"< ? php function checkFibinnary ( $ n ) { $ prev_last = 0 ; while ( $ n ) { if ( ( $ n & 1 ) && $ prev_last ) return false ; $ prev_last = $ n & 1 ; $ n >>= 1 ; } return true ; } $ n = 10 ; if ( checkFibinnary ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Sum of the series 5 + 55 + 555 + . . up to n terms | function which return the the sum of series ; Driver code","code":"< ? php function sumOfSeries ( $ n ) { return ( int ) ( 0.6172 * ( pow ( 10 , $ n ) - 1 ) - 0.55 * $ n ) ; } $ n = 2 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Nonagonal number | Function to find nth nonagonal number . ; Formula to find nth nonagonal number . ; Driver Code","code":"< ? php function Nonagonal ( $ n ) { return $ n * ( 7 * $ n - 5 ) \/ 2 ; } $ n = 10 ; echo Nonagonal ( $ n ) ; ? >"}
{"text":"Check if a large number is divisible by 20 | PHP program to check if a large number is divisible by 20. ; Get number with last two digits ; Check if the number formed by last two digits is divisible by 5 and 4. ; Driver Code","code":"< ? php function divisibleBy20 ( $ num ) { $ lastTwoDigits = intval ( substr ( $ num , ( strlen ( $ num ) - 2 ) , 2 ) ) ; return ( ( $ lastTwoDigits % 5 == 0 ) && ( $ lastTwoDigits % 4 == 0 ) ) ; } $ num = \"63284689320\" ; if ( divisibleBy20 ( $ num ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Divisibility by 12 for a large number | PHP Program to check if number is divisible by 12 ; if number greater then 3 ; find last digit ; no is odd ; find second last digit ; find sum of all digits ; if number is less then or equal to 100 ; Driver Code","code":"< ? php function isDvisibleBy12 ( $ num ) { if ( strlen ( $ num ) >= 3 ) { $ d1 = ( int ) $ num [ strlen ( $ num ) - 1 ] ; if ( $ d1 % 2 != 0 ) return ( 0 ) ; $ d2 = ( int ) $ num [ strlen ( $ num ) - 2 ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ sum += $ num [ $ i ] ; return ( $ sum % 3 == 0 && ( $ d2 * 10 + $ d1 ) % 4 == 0 ) ; } else { $ number = stoi ( $ num ) ; return ( $ number % 12 == 0 ) ; } } $ num = \"12244824607284961224\" ; if ( isDvisibleBy12 ( $ num ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Largest number that is not a perfect square | PHP program to find the largest non perfect square number among n numbers ; takes the sqrt of the number ; checks if it is a perfect square number ; function to find the largest non perfect square number ; stores the maximum of all non perfect square numbers ; traverse for all elements in the array ; store the maximum if not a perfect square ; Driver Code ; function call","code":"< ? php function check ( $ n ) { $ d = sqrt ( $ n ) ; if ( $ d * $ d == $ n ) return true ; return false ; } function largestNonPerfectSquareNumber ( $ a , $ n ) { $ maxi = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! check ( $ a [ $ i ] ) ) $ maxi = max ( $ a [ $ i ] , $ maxi ) ; } return $ maxi ; } $ a = array ( 16 , 20 , 25 , 2 , 3 , 10 ) ; $ n = count ( $ a ) ; echo largestNonPerfectSquareNumber ( $ a , $ n ) ; ? >"}
{"text":"Program to print Arithmetic Progression series | PHP Program to print an arithmetic progression series ; Printing AP by simply adding d to previous term . ; starting number ; Common difference ; N th term to be find","code":"< ? php function printAP ( $ a , $ d , $ n ) { $ curr_term ; $ curr_term = a ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo ( $ curr_term . \" \" ) ; $ curr_term += $ d ; } } $ a = 2 ; $ d = 1 ; $ n = 5 ; printAP ( $ a , $ d , $ n ) ; ? >"}
{"text":"Program to print non square numbers | PHP program to print first n non - square numbers . ; Print curr_count numbers . curr_count is current gap between two square numbers . ; skip a square number . ; Count of next non - square numbers is next even number . ; Driver code","code":"< ? php function printNonSquare ( $ n ) { $ curr_count = 2 ; $ num = 2 ; $ count = 0 ; while ( $ count < $ n ) { for ( $ i = 0 ; $ i < $ curr_count && $ count < $ n ; $ i ++ ) { echo ( $ num . \" \" ) ; $ count ++ ; $ num ++ ; } $ num ++ ; $ curr_count += 2 ; } } $ n = 10 ; printNonSquare ( $ n ) ; ? >"}
{"text":"Count number of trailing zeros in product of array | Returns count of zeros in product of array ; count number of 2 s in each element ; count number of 5 s in each element ; return the minimum ; Driver Code","code":"< ? php function countZeros ( $ a , $ n ) { $ count2 = 0 ; $ count5 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ a [ $ i ] % 2 == 0 ) { $ a [ $ i ] = $ a [ $ i ] \/ 2 ; $ count2 ++ ; } while ( $ a [ $ i ] % 5 == 0 ) { $ a [ $ i ] = $ a [ $ i ] \/ 5 ; $ count5 ++ ; } } return ( $ count2 < $ count5 ) ? $ count2 : $ count5 ; } $ a = array ( 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 ) ; $ n = sizeof ( $ a ) ; echo ( countZeros ( $ a , $ n ) ) ; ? >"}
{"text":"Sum of square of first n even numbers | Efficient PHP method to find sum of square of first n even numbers . ; Driver code","code":"< ? php function squareSum ( $ n ) { return 2 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) \/ 3 ; } echo squareSum ( 8 ) ; ? >"}
{"text":"M\u00c3 \u00bc nchhausen Number | pwr [ i ] is going to store i raised to power i . ; Function to check out whether the number is MA14nchhausen Number or not ; Precompute i raised to power i for every i ; The input here is fixed i . e . it will check up to n ; check the integer for MA14nchhausen Number , if yes then print out the number ; Driver Code","code":"< ? php $ pwr = array_fill ( 0 , 10 , 0 ) ; function isMunchhausen ( $ n ) { global $ pwr ; $ sm = 0 ; $ temp = $ n ; while ( $ temp ) { $ sm = $ sm + $ pwr [ ( $ temp % 10 ) ] ; $ temp = ( int ) ( $ temp \/ 10 ) ; } return ( $ sm == $ n ) ; } function printMunchhausenNumbers ( $ n ) { global $ pwr ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ pwr [ $ i ] = pow ( ( float ) ( $ i ) , ( float ) ( $ i ) ) ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) if ( isMunchhausen ( $ i ) ) print ( $ i . \" STRNEWLINE \" ) ; } $ n = 10000 ; printMunchhausenNumbers ( $ n ) ; ? >"}
{"text":"K | To compute k - th digit in a ^ b ; computing a ^ b ; getting last digit ; increasing count by 1 ; if current number is required digit ; remove last digit ; Driver Code","code":"< ? php function kthdigit ( $ a , $ b , $ k ) { $ p = pow ( $ a , $ b ) ; $ count = 0 ; while ( $ p > 0 and $ count < $ k ) { $ rem = $ p % 10 ; $ count ++ ; if ( $ count == $ k ) return $ rem ; $ p = $ p \/ 10 ; } return 0 ; } $ a = 5 ; $ b = 2 ; $ k = 1 ; echo kthdigit ( $ a , $ b , $ k ) ; ? >"}
{"text":"Recursive sum of digit in n ^ x , where n and x are very large | function to get sum of digits of a number ; function to return sum ; Find sum of digits in n ; Find remainder of exponent ; Driver code","code":"< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } function PowDigSum ( $ n , $ x ) { $ sum = digSum ( $ n ) ; $ rem = $ x % 6 ; if ( ( $ sum == 3 $ sum == 6 ) && $ x > 1 ) return 9 ; else if ( $ x == 1 ) return $ sum ; else if ( $ x == 0 ) return 1 ; else if ( $ rem == 0 ) return digSum ( pow ( $ sum , 6 ) ) ; else return digSum ( pow ( $ sum , $ rem ) ) ; } $ n = 33333 ; $ x = 332654 ; echo PowDigSum ( $ n , $ x ) ; ? >"}
{"text":"Container with Most Water | PHP code for Max Water Container ; Calculating the max area ; Driver code","code":"< ? php function maxArea ( $ A , $ len ) { $ l = 0 ; $ r = $ len - 1 ; $ area = 0 ; while ( $ l < $ r ) { $ area = max ( $ area , min ( $ A [ $ l ] , $ A [ $ r ] ) * ( $ r - $ l ) ) ; if ( $ A [ $ l ] < $ A [ $ r ] ) $ l += 1 ; else $ r -= 1 ; } return $ area ; } $ a = array ( 1 , 5 , 4 , 3 ) ; $ b = array ( 3 , 1 , 2 , 4 , 5 ) ; $ len1 = sizeof ( $ a ) \/ sizeof ( $ a [ 0 ] ) ; echo maxArea ( $ a , $ len1 ) . \" STRNEWLINE \" ; $ len2 = sizeof ( $ b ) \/ sizeof ( $ b [ 0 ] ) ; echo maxArea ( $ b , $ len2 ) ; ? >"}
{"text":"Program for Mobius Function | Returns value of mobius ( ) ; Handling 2 separately ; If 2 ^ 2 also divides N ; Check for all other prime factors ; If i divides n ; If i ^ 2 also divides N ; Driver code","code":"< ? php function mobius ( $ n ) { $ p = 0 ; if ( $ n % 2 == 0 ) { $ n = $ n \/ 2 ; $ p ++ ; if ( $ n % 2 == 0 ) return 0 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ n = $ n \/ $ i ; $ p ++ ; if ( $ n % $ i == 0 ) return 0 ; } } return ( $ p % 2 == 0 ) ? -1 : 1 ; } $ N = 17 ; echo \" Mobius \u2581 Functions \u2581 M ( N ) \u2581 at \u2581 N \u2581 = \u2581 \" , $ N , \" \u2581 is : \u2581 \" , mobius ( $ N ) , \" STRNEWLINE \" ; echo \" Mobius \u2581 Functions \u2581 M ( N ) \u2581 at \u2581 N \u2581 = \u2581 \" , 25 , \" \u2581 is : \u2581 \" , mobius ( 25 ) , \" STRNEWLINE \" ; echo \" Mobius \u2581 Functions \u2581 M ( N ) \u2581 at \u2581 N \u2581 = \u2581 \" , 6 , \" \u2581 is : \u2581 \" , mobius ( 6 ) ; ? >"}
{"text":"Sum of squares of binomial coefficients | function to return product of number from start to end . ; Return the sum of square of binomial coefficient ; Driver Code","code":"< ? php function factorial ( $ start , $ end ) { $ res = 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) $ res *= $ i ; return $ res ; } function sumofsquare ( $ n ) { return factorial ( $ n + 1 , 2 * $ n ) \/ factorial ( 1 , $ n ) ; } $ n = 4 ; echo sumofsquare ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find nth Fibonacci number using Golden ratio | Approximate value of golden ratio ; Function to find nth Fibonacci number ; Fibonacci numbers for n < 6 ; Else start counting from 5 th term ; Driver Code","code":"< ? php $ PHI = 1.6180339 ; function fib ( $ n ) { global $ PHI ; $ f = array ( 0 , 1 , 1 , 2 , 3 , 5 ) ; if ( $ n < 6 ) return $ f [ $ n ] ; $ t = 5 ; $ fn = 5 ; while ( $ t < $ n ) { $ fn = round ( $ fn * $ PHI ) ; $ t ++ ; } return $ fn ; } $ n = 9 ; echo $ n , \" th \u2581 Fibonacci \u2581 Number \u2581 = \u2581 \" , fib ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Euler Method for solving differential equation | Consider a differential equation dy \/ dx = ( x + y + xy ) ; Function for Euler formula ; Iterating till the point at which we need approximation ; Printing approximation ; Initial Values ; Value of x at which we need approximation","code":"< ? php function func ( $ x , $ y ) { return ( $ x + $ y + $ x * $ y ) ; } function euler ( $ x0 , $ y , $ h , $ x ) { $ temp = -0 ; while ( $ x0 < $ x ) { $ temp = $ y ; $ y = $ y + $ h * func ( $ x0 , $ y ) ; $ x0 = $ x0 + $ h ; } echo \" Approximate \u2581 solution \u2581 at \u2581 x \u2581 = \u2581 \" , $ x , \" \u2581 is \u2581 \" , $ y , \" STRNEWLINE \" ; } $ x0 = 0 ; $ y0 = 1 ; $ h = 0.025 ; $ x = 0.1 ; euler ( $ x0 , $ y0 , $ h , $ x ) ; ? >"}
{"text":"Find x and y satisfying ax + by = n | function to find the solution ; traverse for all possible values ; check if it is satisfying the equation ; Driver Code","code":"< ? php function solution ( $ a , $ b , $ n ) { for ( $ i = 0 ; $ i * $ a <= $ n ; $ i ++ ) { if ( ( $ n - ( $ i * $ a ) ) % $ b == 0 ) { echo \" x = \" \u2581 , \u2581 $ i \u2581 , \u2581 \" , y = \" ( $ n - ( $ i * $ a ) ) \/ $ b ; return ; } } echo \" No \u2581 solution \" ; } $ a = 2 ; $ b = 3 ; $ n = 7 ; solution ( $ a , $ b , $ n ) ; ? >"}
{"text":"Sum of Binomial coefficients | Returns value of Binomial Coefficient Sum which is 2 raised to power n . ; Driver Code","code":"< ? php function binomialCoeffSum ( $ n ) { return ( 1 << $ n ) ; } $ n = 4 ; echo binomialCoeffSum ( $ n ) ; ? >"}
{"text":"Program to compute division upto n decimal places | PHP program to compute division upto n decimal places . ; Base cases ; Since n <= 0 , don 't   compute after the decimal ; Handling negative numbers ; Integral division ; Now one by print digits after dot using school division method . ; Driver Code","code":"< ? php function precisionCompute ( $ x , $ y , $ n ) { if ( $ y == 0 ) { echo \" Infinite \" , \" STRNEWLINE \" ; return ; } if ( $ x == 0 ) { echo 0 , \" STRNEWLINE \" ; return ; } if ( $ n <= 0 ) { echo $ x \/ $ y , \" STRNEWLINE \" ; return ; } if ( ( ( $ x > 0 ) && ( $ y < 0 ) ) || ( ( $ x < 0 ) && ( $ y > 0 ) ) ) { echo \" - \" $ x = $ x > 0 ? $ x : - $ x ; $ y = $ y > 0 ? $ y : - $ y ; } $ d = $ x \/ $ y ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { echo $ d ; $ x = $ x - ( $ y * $ d ) ; if ( $ x == 0 ) break ; $ x = $ x * 10 ; $ d = $ x \/ $ y ; if ( $ i == 0 ) echo \" . \" ; } } $ x = 22 ; $ y = 7 ; $ n = 15 ; precisionCompute ( $ x , $ y , $ n ) ; ? >"}
{"text":"Program to determine the quadrant of the cartesian plane | Function to check quadrant ; Driver code ; Function call","code":"< ? php function quadrant ( $ x , $ y ) { if ( $ x > 0 and $ y > 0 ) echo ( \" lies \u2581 in \u2581 First \u2581 quadrant \" ) ; else if ( $ x < 0 and $ y > 0 ) echo ( \" lies \u2581 in \u2581 Second \u2581 quadrant \" ) ; else if ( $ x < 0 and $ y < 0 ) echo ( \" lies \u2581 in \u2581 Third \u2581 quadrant \" ) ; else if ( $ x > 0 and $ y < 0 ) echo ( \" lies \u2581 in \u2581 Fourth \u2581 quadrant \" ) ; else if ( $ x == 0 and $ y > 0 ) echo ( \" lies \u2581 at \u2581 positive \u2581 y \u2581 axis \" ) ; else if ( $ x == 0 and $ y < 0 ) echo ( \" lies \u2581 at \u2581 negative \u2581 y \u2581 axis \" ) ; else if ( $ y == 0 and $ x < 0 ) echo ( \" lies \u2581 at \u2581 negative \u2581 x \u2581 axis \" ) ; else if ( $ y == 0 and $ x > 0 ) echo ( \" lies \u2581 at \u2581 positive \u2581 x \u2581 axis \" ) ; else echo ( \" lies \u2581 at \u2581 origin \" ) ; } $ x = 1 ; $ y = 1 ; quadrant ( $ x , $ y ) ; ? >"}
{"text":"Check if a number is Full Prime | function to check digits ; check all digits are prime or not ; check if digits are prime or not ; To check if n is prime or not ; check for all factors ; To check if n is Full Prime ; The order is important here for efficiency . ; Driver Code","code":"< ? php function checkDigits ( $ n ) { while ( $ n ) { $ dig = $ n % 10 ; if ( $ dig != 2 && $ dig != 3 && $ dig != 5 && $ dig != 7 ) return false ; $ n = ( int ) ( $ n \/ 10 ) ; } return true ; } function prime ( $ n ) { if ( $ n == 1 ) return false ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) return false ; } return true ; } function isFullPrime ( $ n ) { return ( checkDigits ( $ n ) && prime ( $ n ) ) ; } $ n = 53 ; if ( isFullPrime ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Schr\u00c3 \u00b6 der\u00e2 \u20ac\u201c Hipparchus number | A memoization based optimized PHP program to find n - th SchrAderaHipparchus number ; Driver Code","code":"< ? php $ MAX = 500 ; function nthSHN ( $ n , $ dp ) { if ( $ n == 1 $ n == 2 ) return $ dp [ $ n ] = 1 ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; return $ dp [ $ n ] = ( ( 6 * $ n - 9 ) * nthSHN ( $ n - 1 , $ dp ) - ( $ n - 3 ) * nthSHN ( $ n - 2 , $ dp ) ) \/ $ n ; } $ n = 6 ; $ dp = array_fill ( 0 , $ MAX , true ) ; echo nthSHN ( $ n , $ dp ) , \" STRNEWLINE \" ; ? >"}
{"text":"Sum of first n even numbers | function to find sum of first n even numbers ; sum of first n even numbers ; next even number ; required sum ; Driver program to test above","code":"< ? php function evenSum ( $ n ) { $ curr = 2 ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; } $ n = 20 ; echo \" Sum \u2581 of \u2581 first \u2581 \" . $ n . \" \u2581 Even \u2581 numbers \u2581 is : \u2581 \" . evenSum ( $ n ) ; ? >"}
{"text":"Sum of first n even numbers | function to find sum of first n even numbers ; required sum ; Driver Code","code":"< ? php function evenSum ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; } $ n = 20 ; echo \" Sum \u2581 of \u2581 first \u2581 \" , $ n , \" \u2581 Even \u2581 numbers \u2581 is : \u2581 \" , evenSum ( $ n ) ; ? >"}
{"text":"Program to Convert Km \/ hr to miles \/ hr and vice versa | Function to convert kmph to mph ; Function to convert mph to kmph ; Driver Code","code":"< ? php function kmphTOmph ( $ kmph ) { return 0.6214 * $ kmph ; } function mphTOkmph ( $ mph ) { return $ mph * 1.60934 ; } $ kmph = 150 ; $ mph = 100 ; echo \" speed \u2581 in \u2581 mph \u2581 is \u2581 \" , kmphTOmph ( $ kmph ) , \" STRNEWLINE \" ; echo \" speed \u2581 in \u2581 kmph \u2581 is \u2581 \" , mphTOkmph ( $ mph ) ; ? >"}
{"text":"Find element in array that divides all array elements | Returns gcd of two numbers ; Function to return the desired number if exists ; Find GCD of array ; Check if GCD is present in array ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findNumber ( $ arr , $ n ) { $ ans = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans = gcd ( $ ans , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ ans ) return $ ans ; return -1 ; } $ arr = array ( 2 , 2 , 4 ) ; $ n = sizeof ( $ arr ) ; echo findNumber ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Special prime numbers | PHP program to check whether there exist at least k or not in range [ 2. . n ] ; Generating all the prime numbers from 2 to n . ; If a prime number is Special prime number , then we increments the value of k . ; If at least k Special prime numbers are present , then we return 1. else we return 0 from outside of the outer loop . ; Driver Code","code":"< ? php $ primes = array ( ) ; function SieveofEratosthenes ( $ n ) { global $ primes ; $ visited = array_fill ( 0 , $ n , false ) ; for ( $ i = 2 ; $ i <= $ n + 1 ; $ i ++ ) if ( ! $ visited [ $ i ] ) { for ( $ j = $ i * $ i ; $ j <= $ n + 1 ; $ j += $ i ) $ visited [ $ j ] = true ; array_push ( $ primes , $ i ) ; } } function specialPrimeNumbers ( $ n , $ k ) { global $ primes ; SieveofEratosthenes ( $ n ) ; $ count = 0 ; for ( $ i = 0 ; $ i < count ( $ primes ) ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i - 1 ; $ j ++ ) { if ( $ primes [ $ j ] + $ primes [ $ j + 1 ] + 1 == $ primes [ $ i ] ) { $ count ++ ; break ; } } if ( $ count == $ k ) return true ; } return false ; } $ n = 27 ; $ k = 2 ; if ( specialPrimeNumbers ( $ n , $ k ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text":"Prime factors of a big number | function to calculate all the prime factors and count of every prime factor ; count the number of times 2 divides ; equivalent to n = n \/ 2 ; ; if 2 divides it ; check for all the possible numbers that can divide it ; if n at the end is a prime number . ; Driver Code","code":"< ? php function factorize ( $ n ) { $ count = 0 ; while ( ! ( $ n % 2 ) ) { $ n >>= 1 ; $ count ++ ; } if ( $ count ) echo ( 2 . \" \" \u2581 . \u2581 $ count \u2581 . \u2581 \" \" for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { $ count = 0 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n \/ $ i ; } if ( $ count ) echo ( $ i . \" \u2581 \" . $ count ) ; } if ( $ n > 2 ) echo ( $ n . \" \u2581 \" . 1 ) ; } $ n = 1000000000000000000 ; factorize ( $ n ) ; ? >"}
{"text":"Minimum gcd operations to make all array elements one | __gcd function ; Function to count number of moves . ; Counting Number of ones . ; If there is a one ; Find smallest subarray with GCD equals to one . ; to calculate GCD ; Not Possible ; Final answer ; Driver code","code":"< ? php function __gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return __gcd ( $ b % $ a , $ a ) ; } function minimumMoves ( $ A , $ N ) { $ one = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] == 1 ) $ one ++ ; if ( $ one != 0 ) return $ N - $ one ; $ minimum = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ g = $ A [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { $ g = __gcd ( $ A [ $ j ] , $ g ) ; if ( $ g == 1 ) { $ minimum = min ( $ minimum , $ j - $ i ) ; break ; } } } if ( $ minimum == PHP_INT_MAX ) return -1 ; else return $ N + $ minimum - 1 ; } $ A = array ( 2 , 4 , 3 , 9 ) ; $ N = sizeof ( $ A ) ; echo ( minimumMoves ( $ A , $ N ) ) ; ? >"}
{"text":"Given N and Standard Deviation , find N elements | function to print series of n elements ; if S . D . is 0 then print all elements as 0. ; print n 0 's ; if S . D . is even ; print - SD , + SD , - SD , + SD ; if odd ; convert n to a float integer ; print one element to be 0 ; print ( n - 1 ) elements as xi derived from the formula ; Driver Code","code":"< ? php function series ( $ n , $ d ) { if ( $ d == 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo \"0 \u2581 \" ; echo \" STRNEWLINE \" ; return ; } if ( $ n % 2 == 0 ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo pow ( -1 , $ i ) * $ d , \" \" ; } echo \" STRNEWLINE \" ; } else { $ m = $ n ; $ r = ( $ m \/ ( $ m - 1 ) ) ; $ g = ( $ d * sqrt ( $ r ) ) ; echo \"0 \u2581 \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { echo pow ( -1 , $ i ) * $ g , \" \" ; } echo \" STRNEWLINE \" ; } } $ n = 3 ; $ d = 3 ; series ( $ n , $ d ) ; ? >"}
{"text":"Total no of 1 's in numbers | PHP code to count the frequency of 1 in numbers less than or equal to the given number . ; Driver Code","code":"< ? php function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ str = strval ( $ i ) ; $ countr += substr_count ( $ str , '1' ) ; } return $ countr ; } $ n = 13 ; echo countDigitOne ( $ n ) . \" STRNEWLINE \" ; $ n = 131 ; echo countDigitOne ( $ n ) . \" STRNEWLINE \" ; $ n = 159 ; echo countDigitOne ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Exponential Squaring ( Fast Modulo Multiplication ) | prime modulo value ; for cases where exponent is not an even value ; Driver Code","code":"< ? php $ N = 1000000007 ; function exponentiation ( $ bas , $ exp ) { global $ N ; $ t = 1 ; while ( $ exp > 0 ) { if ( $ exp % 2 != 0 ) $ t = ( $ t * $ bas ) % $ N ; $ bas = ( $ bas * $ bas ) % $ N ; $ exp = ( int ) $ exp \/ 2 ; } return $ t % $ N ; } $ bas = 5 ; $ exp = 100000 ; $ modulo = exponentiation ( $ bas , $ exp ) ; echo ( $ modulo ) ; ? >"}
{"text":"GCD of factorials of two numbers | PHP program to find GCD of factorial of two numbers . ; Driver Code","code":"< ? php function factorial ( $ x ) { if ( $ x <= 1 ) return 1 ; $ res = 2 ; for ( $ i = 3 ; $ i <= $ x ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function gcdOfFactorial ( $ m , $ n ) { return factorial ( min ( $ m , $ n ) ) ; } $ m = 5 ; $ n = 9 ; echo gcdOfFactorial ( $ m , $ n ) ; ? >"}
{"text":"Recursive sum of digits of a number is prime or not | Function for recursive digit sum ; function to check if prime or not the single digit ; calls function which returns sum till single digit ; checking prime ; Driver code","code":"< ? php function recDigSum ( $ n ) { if ( $ n == 0 ) return 0 ; else { if ( $ n % 9 == 0 ) return 9 ; else return $ n % 9 ; } } function check ( $ n ) { $ n = recDigSum ( $ n ) ; if ( $ n == 2 or $ n == 3 or $ n == 5 or $ n == 7 ) echo \" Yes \" ; else echo \" No \" ; } $ n = 5602 ; check ( $ n ) ; ? >"}
{"text":"Find n | Definition of findNumber function ; Finding x from equation n = x ( x + 1 ) \/ 2 + 1 ; Base of current block ; Value of n - th element ; Driver code","code":"< ? php function findNumber ( $ n ) { $ x = floor ( ( -1 + sqrt ( 1 + 8 * $ n - 8 ) ) \/ 2 ) ; $ base = ( $ x * ( $ x + 1 ) ) \/ 2 + 1 ; return $ n - $ base + 1 ; } $ n = 55 ; echo findNumber ( $ n ) ; ? >"}
{"text":"Program for weighted mean of natural numbers . | Returns weighted mean assuming for numbers { 1 , 2 , . . n } and weights { 1 , 2 , . . n } ; Driver Code","code":"< ? php function weightedMean ( $ n ) { return ( 2 * $ n + 1 ) \/ 3 ; } $ n = 10 ; echo ( weightedMean ( $ n ) ) ; ? >"}
{"text":"Divide every element of one array by other array elements | Function to calculate the quotient of every element of the array ; Calculate the product of all elements ; To calculate the quotient of every array element ; Driver code","code":"< ? php function calculate ( $ a , $ b , $ n , $ m ) { $ mul = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] != 0 ) $ mul = $ mul * $ b [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = floor ( $ a [ $ i ] \/ $ mul ) ; echo $ x , \" \" ; } } $ a = array ( 5 , 100 , 8 ) ; $ b = array ( 2 , 3 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; calculate ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text":"Minimum number of bombs | function to print where to shoot ; no . of bombs required ; bomb all the even positions ; bomb all the odd positions ; bomb all the even positions again ; Driver Code","code":"< ? php function p_rint ( $ n ) { echo floor ( $ n + $ n \/ 2 ) , \" STRNEWLINE \" ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , \" \u2581 \" ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) echo $ i , \" \u2581 \" ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , \" \u2581 \" ; } $ n = 3 ; p_rint ( $ n ) ; ? >"}
{"text":"LCM of digits of a given number | define lcm function ; If at any point LCM become 0. return it ; Driver code","code":"< ? php function lcm_fun ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return lcm_fun ( $ b , $ a % $ b ) ; } function digitLCM ( $ n ) { $ lcm = 1 ; while ( $ n > 0 ) { $ lcm = ( int ) ( ( $ n % 10 * $ lcm ) \/ lcm_fun ( $ n % 10 , $ lcm ) ) ; if ( $ lcm == 0 ) return 0 ; $ n = ( int ) ( $ n \/ 10 ) ; } return $ lcm ; } $ n = 397 ; echo digitLCM ( $ n ) ; ? >"}
{"text":"Secretary Problem ( A Optimal Stopping Problem ) | PHP Program to test 1 \/ e law for Secretary Problem : ; To find closest integer of num . ; Finds best candidate using n \/ e rule . candidate [ ] represents talents of n candidates . ; Calculating sample size for benchmarking . ; Finding best candidate in sample size ; Finding the first best candidate that is better than benchmark set . ; Driver code ; n = 8 candidates and candidate array contains talents of n candidate where the largest number means highest talented candidate . ; generating random numbers between 1 to 8 for talent of candidate","code":"< ? php $ e = 2.71828 ; function roundNo ( $ num ) { return $ num < 0 ? $ num - 0.5 : $ num + 0.5 ; } function printBestCandidate ( $ candidate , $ n ) { global $ e ; $ sample_size = roundNo ( $ n \/ $ e ) ; echo \" Sample size is \" floor ( $ sample_size ) . \" STRNEWLINE \" ; $ best = 0 ; for ( $ i = 1 ; $ i < $ sample_size ; $ i ++ ) if ( $ candidate [ $ i ] > $ candidate [ $ best ] ) $ best = $ i ; for ( $ i = $ sample_size ; $ i < $ n ; $ i ++ ) if ( $ candidate [ $ i ] >= $ candidate [ $ best ] ) { $ best = $ i ; break ; } if ( $ best >= $ sample_size ) echo \" Best candidate found is \" . floor ( $ best + 1 ) . \" \u2581 with \u2581 talent \u2581 \" . floor ( $ candidate [ $ best ] ) . \" STRNEWLINE \" ; else echo \" Couldn ' t \u2581 find \u2581 a \u2581 best \u2581 candidate STRNEWLINE \" ; } $ n = 8 ; $ candidate = array_fill ( 0 , $ n , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ candidate [ $ i ] = 1 + rand ( 1 , 8 ) ; echo \" Candidate \u2581 : \u2581 \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ i + 1 ) . \" \u2581 \" ; echo \" Talents : \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ candidate [ $ i ] . \" \u2581 \" ; printBestCandidate ( $ candidate , $ n ) ; ? >"}
{"text":"Newton Forward And Backward Interpolation | Calculation of u mentioned in formula ; Calculating factorial of given n ; number of values given ; y [ ] [ ] is used for difference table and y [ ] [ 0 ] used for input ; Calculating the backward difference table ; Displaying the backward difference table ; Value to interpolate at ; Initializing u and sum","code":"< ? php function u_cal ( $ u , $ n ) { $ temp = $ u ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ temp = $ temp * ( $ u + $ i ) ; return $ temp ; } function fact ( $ n ) { $ f = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ f *= $ i ; return $ f ; } $ n = 5 ; $ x = array ( 1891 , 1901 , 1911 , 1921 , 1931 ) ; $ y = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; $ y [ 0 ] [ 0 ] = 46 ; $ y [ 1 ] [ 0 ] = 66 ; $ y [ 2 ] [ 0 ] = 81 ; $ y [ 3 ] [ 0 ] = 93 ; $ y [ 4 ] [ 0 ] = 101 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ n - 1 ; $ j >= $ i ; $ j -- ) $ y [ $ j ] [ $ i ] = $ y [ $ j ] [ $ i - 1 ] - $ y [ $ j - 1 ] [ $ i - 1 ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) print ( $ y [ $ i ] [ $ j ] . \" TABSYMBOL \" ) ; print ( \" STRNEWLINE \" ) ; } $ value = 1925 ; $ sum = $ y [ $ n - 1 ] [ 0 ] ; $ u = ( $ value - $ x [ $ n - 1 ] ) \/ ( $ x [ 1 ] - $ x [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( u_cal ( $ u , $ i ) * $ y [ $ n - 1 ] [ $ i ] ) \/ fact ( $ i ) ; } print ( \" Value at \" \u2581 . \u2581 $ value \u2581 . STRNEWLINE TABSYMBOL \" is \" ? >"}
{"text":"Happy Numbers | Returns sum of squares of digits of a number n . For example for n = 12 it returns 1 + 4 = 5 ; Returns true if n is Happy number else returns false . ; Keep replacing n with sum of squares of digits until we either reach 1 or we end up in a cycle ; Number is Happy if we reach 1 ; Replace n with sum of squares of digits ; Number is not Happy if we reach 4 ; Driver code","code":"< ? php function sumDigitSquare ( $ n ) { $ sq = 0 ; while ( $ n ) { $ digit = $ n % 10 ; $ sq += $ digit * $ digit ; $ n = $ n \/ 10 ; } return $ sq ; } function isHappy ( $ n ) { while ( 1 ) { if ( $ n == 1 ) return true ; $ n = sumDigitSquare ( $ n ) ; if ( $ n == 4 ) return false ; } return false ; } $ n = 23 ; if ( isHappy ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sum of all subsets of a set formed by first n natural numbers | PHP program to find sum of all subsets of a set ; sum of subsets is ( n * ( n + 1 ) \/ 2 ) * pow ( 2 , n - 1 ) ; Driver Code","code":"< ? php function findSumSubsets ( $ n ) { return ( $ n * ( $ n + 1 ) \/ 2 ) * ( 1 << ( $ n - 1 ) ) ; } $ n = 3 ; echo findSumSubsets ( $ n ) ; ? >"}
{"text":"Minimum element whose n | function to find the minimum element ; loop to traverse and store the sum of log ; computes sum ; calculates the elements according to formula . ; returns the minimal element ; initialised array ; computes the size of array ; prints out the minimal element","code":"< ? php function findMin ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += log ( $ a [ $ i ] ) ; $ x = exp ( $ sum \/ $ n ) ; return ( int ) ( $ x + 1 ) ; } $ a = array ( 3 , 2 , 1 , 4 ) ; $ n = sizeof ( $ a ) ; echo ( findMin ( $ a , $ n ) ) ; ? >"}
{"text":"Generate all cyclic permutations of a number | Function to count the total number of digits in a number . ; Function to generate all cyclic permutations of a number ; Following three lines generates a circular pirmutation of a number . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Code","code":"< ? php function countdigits ( $ N ) { $ count = 0 ; while ( $ N ) { $ count ++ ; $ N = floor ( $ N \/ 10 ) ; } return $ count ; } function cyclic ( $ N ) { $ num = $ N ; $ n = countdigits ( $ N ) ; while ( 1 ) { echo ( $ num ) ; echo \" STRNEWLINE \" ; $ rem = $ num % 10 ; $ div = floor ( $ num \/ 10 ) ; $ num = ( pow ( 10 , $ n - 1 ) ) * $ rem + $ div ; if ( $ num == $ N ) break ; } } $ N = 5674 ; cyclic ( $ N ) ; ? >"}
{"text":"Check whether a number is circular prime or not | Function to check if a number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is circular prime or not . ; Count digits . ; Following three lines generate the next circular permutation of a number . We move last digit to first position . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return -1 ; return true ; } function checkCircular ( $ N ) { $ count = 0 ; $ temp = $ N ; while ( $ temp ) { $ count ++ ; $ temp = ( int ) $ temp \/ 10 ; } $ num = $ N ; while ( isPrime ( $ num ) ) { $ rem = $ num % 10 ; $ div = ( int ) $ num \/ 10 ; $ num = ( pow ( 10 , $ count - 1 ) ) * $ rem + $ div ; if ( $ num == $ N ) return true ; } return -1 ; } $ N = 1193 ; if ( checkCircular ( $ N ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; ? >"}
{"text":"Find if two people ever meet after same number of jumps | function to find if any one of them can overtake the other ; Since starting points are always different , they will meet if following conditions are met . ( 1 ) Speeds are not same ( 2 ) Difference between speeds divide the total distance between initial points . ; Driver Code","code":"< ? php function sackRace ( $ p1 , $ s1 , $ p2 , $ s2 ) { return ( ( $ s1 > $ s2 && ( $ p2 - $ p1 ) % ( $ s1 - $ s2 ) == 0 ) || ( $ s2 > $ s1 && ( $ p1 - $ p2 ) % ( $ s2 - $ s1 ) == 0 ) ) ; } $ p1 = 4 ; $ s1 = 4 ; $ p2 = 8 ; $ s2 = 2 ; if ( sackRace ( $ p1 , $ s1 , $ p2 , $ s2 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Largest proper fraction with sum of numerator and denominator equal to a given number | PHP program to find the largest fraction a \/ b such that a + b is equal to given number and a < b . ; Calculate N \/ 2 ; ; Check if N is odd or even ; If N is odd answer will be ceil ( n \/ 2 ) - 1 and floor ( n \/ 2 ) + 1 ; If N is even check if N \/ 2 i . e a is even or odd ; If N \/ 2 is even apply the previous formula ; If N \/ 2 is odd answer will be ceil ( N \/ 2 ) - 2 and floor ( N \/ 2 ) + 2 ; driver function","code":"< ? php function solve ( $ n ) { $ a = ( float ) $ n \/ 2 ; if ( $ n % 2 != 0 ) echo ceil ( $ a ) - 1 , \" \u2581 \" , floor ( $ a ) + 1 , \" STRNEWLINE \" ; else { if ( $ a % 2 == 0 ) { echo ceil ( $ a ) - 1 , \" \u2581 \" , floor ( $ a ) + 1 , \" STRNEWLINE \" ; } else { echo ceil ( $ a ) - 2 , \" \u2581 \" , floor ( $ a ) + 2 , \" STRNEWLINE \" ; } } } $ n = 34 ; solve ( $ n ) ; ? >"}
{"text":"Program to find simple interest | We can change values here for different inputs ; Calculate simple interest ; Print the resultant value of SI","code":"< ? php $ P = 1 ; $ R = 1 ; $ T = 1 ; $ SI = ( $ P * $ T * $ R ) \/ 100 ; echo \" Simple \u2581 Interest \u2581 = \u2581 \" . $ SI ; ? >"}
{"text":"Number of digits in the product of two numbers | function to count number of digits in the product of two numbers ; absolute value of the product of two numbers ; if product is 0 ; count number of digits in the product ' p ' ; required count of digits ; Driver Code","code":"< ? php function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a * $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p \/ 10 ) ; } return $ count ; } $ a = 33 ; $ b = -24 ; echo \" Number \u2581 of \u2581 digits \u2581 = \u2581 \" . countDigits ( $ a , $ b ) ; ? >"}
{"text":"Find multiple of x closest to or a ^ b ( a raised to power b ) | function to find closest multiple of x to a ^ b ; calculate a ^ b \/ x ; Answer is either ( ans * x ) or ( ans + 1 ) * x ; Printing nearest answer ; Driver Code","code":"< ? php function multiple ( $ a , $ b , $ x ) { if ( $ b < 0 ) { if ( $ a == 1 && $ x == 1 ) echo \"1\" ; else echo \"0\" ; } $ mul = pow ( $ a , $ b ) ; $ ans = $ mul \/ $ x ; $ ans1 = $ x * $ ans ; $ ans2 = $ x * ( $ ans + 1 ) ; $ k = ( ( ( $ mul - $ ans1 ) <= ( $ ans2 - $ mul ) ) ? $ ans1 : $ ans2 ) ; echo ( $ k ) ; } $ a = 348 ; $ b = 1 ; $ x = 4 ; multiple ( $ a , $ b , $ x ) ; ? >"}
{"text":"Maximum sum of difference of adjacent elements | To find max sum of permutation ; Base case ; Otherwise max sum will be ( n * ( n - 1 ) \/ 2 ) - 1 + n \/ 2 ; Driver Code","code":"< ? php function maxSum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( $ n * ( $ n - 1 ) \/ 2 ) - 1 + $ n \/ 2 ; } $ n = 3 ; echo intval ( maxSum ( $ n ) ) ; ? >"}
{"text":"Add minimum number to an array so that the sum becomes even | Function to find out minimum number ; Count odd number of terms in array ; Driver code","code":"< ? php function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd = ! $ odd ; if ( $ odd ) return 1 ; return 2 ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; echo minNum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if a number is jumbled or not | Function to check if a number is jumbled or not ; Single digit number ; Checking every digit through a loop ; All digits were checked ; Digit at index i ; Digit at index i - 1 ; If difference is greater than 1 ; Number checked ; - 1234 to be checked ; 287 to be checked","code":"< ? php function checkJumbled ( $ num ) { if ( $ num \/ 10 == 0 ) return true ; while ( $ num != 0 ) { if ( $ num \/ 10 == 0 ) return true ; $ digit1 = $ num % 10 ; $ digit2 = ( $ num \/ 10 ) % 10 ; if ( abs ( $ digit2 - $ digit1 ) > 1 ) return false ; $ num = $ num \/ 10 ; } return true ; } $ num = -1234 ; if ( checkJumbled ( $ num ) ) echo \" True \u2581 STRNEWLINE \" ; else echo \" False \u2581 STRNEWLINE \" ; $ num = -1247 ; if ( checkJumbled ( $ num ) ) echo \" True \u2581 STRNEWLINE \" ; else echo \" False \u2581 STRNEWLINE \" ; ? >"}
{"text":"Josephus Problem Using Bit Magic | function to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; function to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' . We will do 1 << 6 - 1 to get '100000' ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; Driver Code","code":"< ? php function msbPos ( $ n ) { $ pos = 0 ; while ( $ n != 0 ) { $ pos ++ ; $ n = $ n >> 1 ; } return $ pos ; } function josephify ( $ n ) { $ position = msbPos ( $ n ) ; $ j = 1 << ( $ position - 1 ) ; $ n = $ n ^ $ j ; $ n = $ n << 1 ; $ n = $ n | 1 ; return $ n ; } $ n = 41 ; print ( josephify ( $ n ) ) ; ? >"}
{"text":"Count pairs with Odd XOR | A function will return number of pair whose XOR is odd ; To store count of XOR pair ; If XOR is odd increase count ; Return count ; Driver Code","code":"< ? php function countXorPair ( $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ) % 2 == 1 ) $ count ++ ; } return $ count ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = count ( $ arr ) ; echo countXorPair ( $ arr , $ n ) ; ? >"}
{"text":"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Function to calculate k for given a , b , m ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; If collision occurs i . e . , LHS = RHS ; Check whether ans lies below m or not ; Driver code","code":"< ? php function powmod ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function discreteLogarithm ( $ a , $ b , $ m ) { $ n = ( int ) sqrt ( $ m ) + 1 ; $ value = array_fill ( 0 , $ m , NULL ) ; for ( $ i = $ n ; $ i >= 1 ; -- $ i ) $ value [ powmod ( $ a , $ i * $ n , $ m ) ] = $ i ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { $ cur = ( powmod ( $ a , $ j , $ m ) * $ b ) % $ m ; if ( $ value [ $ cur ] ) { $ ans = $ value [ $ cur ] * $ n - $ j ; if ( $ ans < $ m ) return $ ans ; } } return -1 ; } $ a = 2 ; $ b = 3 ; $ m = 5 ; echo discreteLogarithm ( $ a , $ b , $ m ) , \" \" ; $ a = 3 ; $ b = 7 ; $ m = 11 ; echo discreteLogarithm ( $ a , $ b , $ m ) , \" \" ; ? >"}
{"text":"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | PHP program to calculate discrete logarithm ; Calculate a ^ n ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; Driver code","code":"< ? php function discreteLogarithm ( $ a , $ b , $ m ) { $ n = ( int ) sqrt ( $ m ) + 1 ; $ an = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ an = ( $ an * $ a ) % $ m ; $ value = array_fill ( 0 , $ m , NULL ) ; for ( $ i = 1 , $ cur = $ an ; $ i <= $ n ; ++ $ i ) { if ( ! $ value [ $ cur ] ) $ value [ $ cur ] = $ i ; $ cur = ( $ cur * $ an ) % $ m ; } for ( $ i = 0 , $ cur = $ b ; $ i <= $ n ; ++ $ i ) { if ( $ value [ $ cur ] ) { $ ans = $ value [ $ cur ] * $ n - $ i ; if ( $ ans < $ m ) return $ ans ; } $ cur = ( $ cur * $ a ) % $ m ; } return -1 ; } $ a = 2 ; $ b = 3 ; $ m = 5 ; echo discreteLogarithm ( $ a , $ b , $ m ) , \" \" ; $ a = 3 ; $ b = 7 ; $ m = 11 ; echo discreteLogarithm ( $ a , $ b , $ m ) ; ? >"}
{"text":"Finding n | PHP program to find n - th number with prime digits 2 , 3 and 7 ; remainder for check element position ; if number is 1 st position in tree ; if number is 2 nd position in tree ; if number is 3 rd position in tree ; if number is 4 th position in tree ; Driver code","code":"< ? php function nthprimedigitsnumber ( $ number ) { $ num = \" \" ; while ( $ number > 0 ) { $ rem = $ number % 4 ; switch ( $ rem ) { case 1 : $ num . = '2' ; break ; case 2 : $ num . = '3' ; break ; case 3 : $ num . = '5' ; break ; case 0 : $ num . = '7' ; break ; } if ( $ number % 4 == 0 ) $ number -- ; $ number = ( int ) ( $ number \/ 4 ) ; } return strrev ( $ num ) ; } $ number = 21 ; print ( nthprimedigitsnumber ( 10 ) . \" STRNEWLINE \" ) ; print ( nthprimedigitsnumber ( $ number ) ) ;"}
{"text":"Count pairs ( a , b ) whose sum of cubes is N ( a ^ 3 + b ^ 3 = N ) | Function to count the pairs satisfying a ^ 3 + b ^ 3 = N ; Check for each number 1 to cbrt ( N ) ; Store cube of a number ; Subtract the cube from given N ; Check if the difference is also a perfect cube ; If yes , then increment count ; Return count ; Loop to Count no . of pairs satisfying a ^ 3 + b ^ 3 = i for N = 1 to 10","code":"< ? php function countPairs ( $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= ( int ) pow ( $ N , 1 \/ 3 ) ; $ i ++ ) { $ cb = $ i * $ i * $ i ; $ diff = ( $ N - $ cb ) ; $ cbrtDiff = ( int ) pow ( $ diff , 1 \/ 3 ) ; if ( $ cbrtDiff * $ cbrtDiff * $ cbrtDiff == $ diff ) $ count ++ ; } return $ count ; } for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) echo \" For \u2581 n \u2581 = \u2581 \" , $ i , \" , \u2581 \" , countPairs ( $ i ) , \" \u2581 pair \u2581 exists STRNEWLINE \" ; ? >"}
{"text":"Finding ' k ' such that its modulus with each array element is same | Prints all k such that arr [ i ] % k is same for all i ; sort the numbers ; max difference will be the difference between first and last element of sorted array ; Case when all the array elements are same ; Find all divisors of d and store in a vector v [ ] ; check for each v [ i ] if its modulus with each array element is same or not ; checking for each array element if its modulus with k is equal to k or not ; if check is true print v [ i ] ; Driver method","code":"< ? php function printEqualModNumbers ( $ arr , $ n ) { sort ( $ arr ) ; $ d = $ arr [ $ n - 1 ] - $ arr [ 0 ] ; if ( d == 0 ) { print ( \" Infinite \u2581 solution \" ) ; return ; } $ v = array ( ) ; for ( $ i = 1 ; $ i * $ i <= $ d ; $ i ++ ) { if ( $ d % $ i == 0 ) { array_push ( $ v , $ i ) ; if ( $ i != $ d \/ $ i ) array_push ( $ v , $ d \/ $ i ) ; } } for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) { $ temp = $ arr [ 0 ] % $ v [ $ i ] ; $ j = 1 ; for ( ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] % $ v [ $ i ] != $ temp ) break ; if ( $ j == $ n ) print ( $ v [ $ i ] . \" \u2581 \" ) ; } } $ arr = array ( 38 , 6 , 34 ) ; printEqualModNumbers ( $ arr , count ( $ arr ) ) ; ? >"}
{"text":"First digit in product of an array of numbers | Returns the first digit of product of elements of arr [ ] ; stores the logarithm of product of elements of arr [ ] ; fractional ( s ) = s - floor ( s ) ; ans = 10 ^ fract_s ; Driver Code","code":"< ? php function FirstDigit ( $ arr , $ n ) { $ S = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ S = $ S + log10 ( $ arr [ $ i ] * 1.0 ) ; $ fract_S = $ S - floor ( $ S ) ; $ ans = pow ( 10 , $ fract_S ) ; return floor ( $ ans ) ; } $ arr = array ( 5 , 8 , 3 , 7 ) ; $ n = sizeof ( $ arr ) ; echo FirstDigit ( $ arr , $ n ) ; ? >"}
{"text":"Find count of digits in a number that divide the number | Return the number of digits that divides the number . ; Fetching each digit of the number ; Checking if digit is greater than 0 and can divides n . ; Driver Code","code":"< ? php function countDigit ( $ n ) { $ temp = $ n ; $ count = 0 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp \/= 10 ; if ( $ d > 0 && $ n % $ d == 0 ) $ count ++ ; } return $ count ; } $ n = 1012 ; echo countDigit ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Minimum positive integer to divide a number such that the result is an odd | Function to find the value ; Return 1 if already odd ; Check how many times it is divided by 2 ; Driver code","code":"< ? php function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; $ resul = 1 ; while ( $ n % 2 == 0 ) { $ n \/= 2 ; $ resul *= 2 ; } return $ resul ; } $ n = 36 ; echo makeOdd ( $ n ) ; ? >"}
{"text":"Multiple of x closest to n | Function to calculate the smallest multiple ; Driver Code","code":"< ? php function closestMultiple ( $ n , $ x ) { if ( $ x > $ n ) return $ x ; $ n = $ n + $ x \/ 2 ; $ n = $ n - ( $ n % $ x ) ; return $ n ; } $ n = 9 ; $ x = 4 ; echo closestMultiple ( $ n , $ x ) ; ? >"}
{"text":"Perfect cubes in a range | An efficient solution to print perfect cubes between a and b ; Find cube root of both a and b ; Print cubes between acrt and bcrt ; Driver code","code":"< ? php function printCubes ( $ a , $ b ) { $ acrt = ( int ) pow ( $ a , 1 \/ 3 ) ; $ bcrt = ( int ) pow ( $ b , 1 \/ 3 ) ; for ( $ i = $ acrt ; $ i <= $ bcrt ; $ i ++ ) if ( $ i * $ i * $ i >= $ a && $ i * $ i * $ i <= $ b ) echo $ i * $ i * $ i , \" \u2581 \" ; } $ a = 24 ; $ b = 576 ; echo \" Perfect \u2581 cubes \u2581 in \u2581 given \u2581 range : STRNEWLINE \" , printCubes ( $ a , $ b ) ; ? >"}
{"text":"Number of occurrences of 2 as a digit in numbers from 0 to n | Counts the number of '2' digits in a single number ; Counts the number of '2' digits between 0 and n ; Initialize result ; Count 2 's in every number  from 2 to n ; Driver Code","code":"< ? php function number0f2s ( $ n ) { $ count = 0 ; while ( $ n > 0 ) { if ( $ n % 10 == 2 ) $ count ++ ; $ n = $ n \/ 10 ; } return $ count ; } function numberOf2sinRange ( $ n ) { $ count = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ count += number0f2s ( $ i ) ; return $ count ; } echo ( numberOf2sinRange ( 22 ) ) ; echo \" STRNEWLINE \" ; echo numberOf2sinRange ( 100 ) ; ? >"}
{"text":"Minimum toggles to partition a binary array so that it has first 0 s then 1 s | Function to calculate minimum toggling required by using Dynamic programming ; Fill entries in zero [ ] such that zero [ i ] stores count of zeroes to the left of i ( exl ; If zero found update zero [ ] array ; Finding the minimum toggle required from every index ( 0 to n - 1 ) ; Driver Program","code":"< ? php function minToggle ( $ arr , $ n ) { $ zero [ 0 ] = 0 ; $ zero [ $ n + 1 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { if ( $ arr [ $ i - 1 ] == 0 ) $ zero [ $ i ] = $ zero [ $ i - 1 ] + 1 ; else $ zero [ $ i ] = $ zero [ $ i - 1 ] ; } $ ans = $ n ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ ans = min ( $ ans , $ i - $ zero [ $ i ] + $ zero [ $ n ] - $ zero [ $ i ] ) ; return $ ans ; } $ arr = array ( 1 , 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; echo minToggle ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if a large number is divisible by 6 or not | Function to find that number divisible by 6 or not ; Return false if number is not divisible by 2. ; Compute sum of digits ; Check if sum of digits is divisible by 3 ; Driver code","code":"< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; if ( ( $ str [ $ n - 1 ] - '0' ) % 2 != 0 ) return false ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; } $ str = \"1332\" ; if ( check ( $ str ) ) echo \" Yes \" ; else echo \" \u2581 No \u2581 \" ; return 0 ; ? >"}
{"text":"Find ways an Integer can be expressed as sum of n | PHP program to find number of ways to express a number as sum of n - th powers of numbers . ; Wrapper over checkRecursive ( ) ; Driver Code","code":"< ? php $ res = 0 ; function checkRecursive ( $ num , $ x , $ k , $ n ) { global $ res ; if ( $ x == 0 ) $ res ++ ; $ r = ( int ) floor ( pow ( $ num , 1.0 \/ $ n ) ) ; for ( $ i = $ k + 1 ; $ i <= $ r ; $ i ++ ) { $ a = $ x - ( int ) pow ( $ i , $ n ) ; if ( $ a >= 0 ) checkRecursive ( $ num , $ x - ( int ) pow ( $ i , $ n ) , $ i , $ n ) ; } return $ res ; } function check ( $ x , $ n ) { return checkRecursive ( $ x , $ x , 0 , $ n ) ; } echo ( check ( 10 , 2 ) ) ; ? >"}
{"text":"N 'th palindrome of K digits | Utility function to reverse the number n ; Boolean Function to check for palindromic number ; Function for finding nth palindrome of k digits ; Get the smallest k digit number ; check the number is palindrom or not ; if n 'th palindrome found  break the loop ; Increment number for checking next palindrome ; Driver code","code":"< ? php function reverseNum ( $ n ) { $ rem ; $ rev = 0 ; while ( $ n ) { $ rem = $ n % 10 ; $ rev = ( $ rev * 10 ) + $ rem ; $ n = ( int ) ( $ n \/ 10 ) ; } return $ rev ; } function isPalindrom ( $ num ) { return $ num == reverseNum ( $ num ) ; } function nthPalindrome ( $ n , $ k ) { $ num = pow ( 10 , $ k - 1 ) ; while ( true ) { if ( isPalindrom ( $ num ) ) -- $ n ; if ( ! $ n ) break ; ++ $ num ; } return $ num ; } $ n = 6 ; $ k = 5 ; echo $ n , \" th \u2581 palindrome \u2581 of \u2581 \" , $ k , \" \u2581 digit \u2581 = \u2581 \" , nthPalindrome ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 10 ; $ k = 6 ; echo $ n , \" th \u2581 palindrome \u2581 of \u2581 \" , $ k , \" \u2581 digit \u2581 = \u2581 \" , nthPalindrome ( $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"N 'th palindrome of K digits | PHP program of finding nth palindrome of k digit ; Determine the first half digits ; Print the first half digits of palindrome ; If k is odd , truncate the last digit ; print the last half digits of palindrome ; Driver code","code":"< ? php function nthPalindrome ( $ n , $ k ) { $ temp = ( $ k & 1 ) ? ( int ) ( $ k \/ 2 ) : ( int ) ( $ k \/ 2 - 1 ) ; $ palindrome = ( int ) pow ( 10 , $ temp ) ; $ palindrome += $ n - 1 ; print ( $ palindrome ) ; if ( $ k & 1 ) $ palindrome = ( int ) ( $ palindrome \/ 10 ) ; while ( $ palindrome > 0 ) { print ( $ palindrome % 10 ) ; $ palindrome = ( int ) ( $ palindrome \/ 10 ) ; } print ( \" STRNEWLINE \" ) ; } $ n = 6 ; $ k = 5 ; print ( $ n . \" th \u2581 palindrome \u2581 of \u2581 $ k \u2581 digit \u2581 = \u2581 \" ) ; nthPalindrome ( $ n , $ k ) ; $ n = 10 ; $ k = 6 ; print ( $ n . \" th \u2581 palindrome \u2581 of \u2581 $ k \u2581 digit \u2581 = \u2581 \" ) ; nthPalindrome ( $ n , $ k ) ; ? >"}
{"text":"Summation of GCD of all the pairs up to N | PHP approach of finding sum of GCD of all pairs ; phi [ i ] stores euler totient function for i result [ j ] stores result for value j ; Precomputation of phi [ ] numbers . Refer link for details : https : goo . gl \/ LUqdtY ; Refer https : goo . gl \/ LUqdtY ; Precomputes result for all numbers till MAX ; Precompute all phi value ; Iterate throght all the divisors of i . ; Add summation of previous calculated sum ; Function to calculate sum of all the GCD pairs","code":"< ? php $ MAX = 100001 ; $ phi = array_fill ( 0 , $ MAX , 0 ) ; $ result = array_fill ( 0 , $ MAX , 0 ) ; function computeTotient ( ) { global $ MAX , $ phi ; $ phi [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) { if ( ! $ phi [ $ i ] ) { $ phi [ $ i ] = $ i - 1 ; for ( $ j = ( $ i << 1 ) ; $ j < $ MAX ; $ j += $ i ) { if ( ! $ phi [ $ j ] ) $ phi [ $ j ] = $ j ; $ phi [ $ j ] = ( $ phi [ $ j ] \/ $ i ) * ( $ i - 1 ) ; } } } } function sumOfGcdPairs ( ) { global $ MAX , $ phi , $ result ; computeTotient ( ) ; for ( $ i = 1 ; $ i < $ MAX ; ++ $ i ) { for ( $ j = 2 ; $ i * $ j < $ MAX ; ++ $ j ) $ result [ $ i * $ j ] += $ i * $ phi [ $ j ] ; } for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ result [ $ i ] += $ result [ $ i - 1 ] ; } sumOfGcdPairs ( ) ; $ N = 4 ; echo \" Summation \u2581 of \u2581 \" . $ N . \" \u2581 = \u2581 \" . $ result [ $ N ] . \" STRNEWLINE \" ; $ N = 12 ; echo \" Summation \u2581 of \u2581 \" . $ N . \" \u2581 = \u2581 \" . $ result [ $ N ] . \" STRNEWLINE \" ; $ N = 5000 ; echo \" Summation \u2581 of \u2581 \" . $ N . \" \u2581 = \u2581 \" . $ result [ $ N ] . \" STRNEWLINE \" ; ? >"}
{"text":"Find coordinates of the triangle given midpoint of each side | PHP program to find coordinate of the triangle given midpoint of each side ; Return after solving the equations and finding the vertices coordinate . ; Finding sum of all three coordinate . ; Solving the equation . ; Finds vertices of a triangles from given middle vertices . ; Find X coordinates of vertices . ; Find Y coordinates of vertices . ; Output the solution . ; Driver code","code":"< ? php $ N = 3 ; function solve ( $ v ) { $ res = array ( ) ; $ all3 = $ v [ 0 ] + $ v [ 1 ] + $ v [ 2 ] ; array_push ( $ res , $ all3 - $ v [ 1 ] * 2 ) ; array_push ( $ res , $ all3 - $ v [ 2 ] * 2 ) ; array_push ( $ res , $ all3 - $ v [ 0 ] * 2 ) ; return $ res ; } function findVertex ( $ xmid , $ ymid ) { $ V1 = solve ( $ xmid ) ; $ V2 = solve ( $ ymid ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) print ( $ V1 [ $ i ] . \" \u2581 \" . $ V2 [ $ i ] . \" STRNEWLINE \" ) ; } $ xmid = array ( 5 , 4 , 5 ) ; $ ymid = array ( 3 , 4 , 5 ) ; findVertex ( $ xmid , $ ymid ) ? >"}
{"text":"N | Return the n - th number in the sorted list of multiples of two numbers . ; Generating first n multiple of a . ; Sorting the sequence . ; Generating and storing first n multiple of b and storing if not present in the sequence . ; If not present in the sequence ; Storing in the sequence . ; Driver Code","code":"< ? php function nthElement ( $ a , $ b , $ n ) { $ seq = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) array_push ( $ seq , $ a * $ i ) ; sort ( $ seq ) ; for ( $ i = 1 , $ k = $ n ; $ i <= $ n && $ k > 0 ; $ i ++ ) { if ( array_search ( $ b * $ i , $ seq ) == 0 ) { array_push ( $ seq , $ b * $ i ) ; sort ( $ seq ) ; $ k -- ; } } return $ seq [ $ n - 1 ] ; } $ a = 3 ; $ b = 5 ; $ n = 5 ; echo nthElement ( $ a , $ b , $ n ) ; ? >"}
{"text":"Count pairs of natural numbers with GCD equal to given number | Return the GCD of two numbers . ; Return the count of pairs having GCD equal to g . ; Setting the value of L , R . ; For each possible pair check if GCD is 1. ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { return $ b ? gcd ( $ b , $ a % $ b ) : $ a ; } function countGCD ( $ L , $ R , $ g ) { $ L = ( $ L + $ g - 1 ) \/ $ g ; $ R = $ R \/ $ g ; $ ans = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) for ( $ j = $ L ; $ j <= $ R ; $ j ++ ) if ( gcd ( $ i , $ j ) == 1 ) $ ans ++ ; return $ ans ; } $ L = 1 ; $ R = 11 ; $ g = 5 ; echo countGCD ( $ L , $ R , $ g ) ; ? >"}
{"text":"Last non | Initialize values of last non - zero digit of numbers from 0 to 9 ; Check whether tens ( or second last ) digit is odd or even If n = 375 , So n \/ 10 = 37 and ( n \/ 10 ) % 10 = 7 Applying formula for even and odd cases . ; Driver code","code":"< ? php $ dig = array ( 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ) ; function lastNon0Digit ( $ n ) { global $ dig ; if ( $ n < 10 ) return $ dig [ $ n ] ; if ( ( ( $ n \/ 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( $ n \/ 5 ) * $ dig [ $ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( $ n \/ 5 ) * $ dig [ $ n % 10 ] ) % 10 ; } $ n = 14 ; echo ( lastNon0Digit ( $ n ) ) ; ? >"}
{"text":"Find the first natural number whose factorial is divisible by x | GCD function to compute the greatest divisor among a and b ; Returns first number whose factorial divides x . ; Result ; Remove common factors ; We found first i . ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( ( $ a % $ b ) == 0 ) return $ b ; return gcd ( $ b , $ a % $ b ) ; } function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ new_x = $ x ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ new_x \/= gcd ( $ i , $ new_x ) ; if ( $ new_x == 1 ) break ; } return $ i ; } $ x = 16 ; echo ( firstFactorialDivisibleNumber ( $ x ) ) ; ? >"}
{"text":"Find the highest occurring digit in prime numbers in a range | Sieve of Eratosthenes ; Returns maximum occurring digits in primes from l to r . ; Finding the prime number up to R . ; Initialise frequency of all digit to 0. ; For all number between L to R , check if prime or not . If prime , incrementing the frequency of digits present in the prime number . ; $p = $i ; If i is prime ; Finding digit with highest frequency . ; Driver Code","code":"< ? php function sieve ( & $ prime , $ n ) { for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == false ) for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = true ; } } function maxDigitInPrimes ( $ L , $ R ) { $ prime = array_fill ( 0 , $ R + 1 , false ) ; sieve ( $ prime , $ R ) ; $ freq = array_fill ( 0 , 10 , 0 ) ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( ! $ prime [ $ i ] ) { while ( $ p ) { $ freq [ $ p % 10 ] ++ ; $ p = ( int ) ( $ p \/ 10 ) ; } } } $ max = $ freq [ 0 ] ; $ ans = 0 ; for ( $ j = 1 ; $ j < 10 ; $ j ++ ) { if ( $ max <= $ freq [ $ j ] ) { $ max = $ freq [ $ j ] ; $ ans = $ j ; } } return $ ans ; } $ L = 1 ; $ R = 20 ; echo maxDigitInPrimes ( $ L , $ R ) ; ? >"}
{"text":"Common Divisors of Two Numbers | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Count divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function commDiv ( $ a , $ b ) { $ n = gcd ( $ a , $ b ) ; $ result = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ result += 1 ; else $ result += 2 ; } } return $ result ; } $ a = 12 ; $ b = 24 ; echo ( commDiv ( $ a , $ b ) ) ; ? >"}
{"text":"Count ways to spell a number with repeated digits | Function to calculate all possible spells of a number with repeated digits num -- > string which is favourite number ; final count of total possible spells ; iterate through complete number ; count contiguous frequency of particular digit num [ i ] ; Compute 2 ^ ( count - 1 ) and multiply with result ; Driver Code","code":"< ? php function spellsCount ( $ num ) { $ n = strlen ( $ num ) ; $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; while ( $ i < $ n - 1 && $ num [ $ i + 1 ] == $ num [ $ i ] ) { $ count ++ ; $ i ++ ; } $ result = $ result * pow ( 2 , $ count - 1 ) ; } return $ result ; } $ num = \"11112\" ; echo spellsCount ( $ num ) ; ? >"}
{"text":"Happy Number | Utility method to return sum of square of digit of n ; method return true if n is Happy number ; initialize slow and fast by n ; move slow number by one iteration ; move fast number by two iteration ; if both number meet at 1 , then return true ; Driver Code","code":"< ? php function numSquareSum ( $ n ) { $ squareSum = 0 ; while ( $ n ) { $ squareSum += ( $ n % 10 ) * ( $ n % 10 ) ; $ n \/= 10 ; } return $ squareSum ; } function isHappynumber ( $ n ) { $ slow ; $ fast ; $ slow = $ n ; $ fast = $ n ; do { $ slow = numSquareSum ( $ slow ) ; $ fast = numSquareSum ( numSquareSum ( $ fast ) ) ; } while ( $ slow != $ fast ) ; return ( $ slow == 1 ) ; } $ n = 13 ; if ( isHappynumber ( $ n ) ) echo $ n , \" \u2581 is \u2581 a \u2581 Happy \u2581 number STRNEWLINE \" ; else echo n , \" \u2581 is \u2581 not \u2581 a \u2581 Happy \u2581 number STRNEWLINE \" ; ? >"}
{"text":"Count Divisors of Factorial | allPrimes [ ] stores all prime numbers less than or equal to n . ; Fills above vector allPrimes [ ] for a given n ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true . ; Loop to update prime [ ] ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store primes in the vector allPrimes ; Function to find all result of factorial number ; Initialize result ; find exponents of all primes which divides n and less than n ; Current divisor ; Find the highest power ( stored in exp ) of allPrimes [ i ] that divides n using Legendre 's formula. ; Multiply exponents of all primes less than n ; return total divisors ; Driver Code","code":"< ? php $ allPrimes = array ( ) ; function sieve ( $ n ) { global $ allPrimes ; $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) if ( $ prime [ $ p ] ) array_push ( $ allPrimes , $ p ) ; } function factorialDivisors ( $ n ) { global $ allPrimes ; $ result = 1 ; for ( $ i = 0 ; $ i < count ( $ allPrimes ) ; $ i ++ ) { $ p = $ allPrimes [ $ i ] ; $ exp = 0 ; while ( $ p <= $ n ) { $ exp = $ exp + ( int ) ( $ n \/ $ p ) ; $ p = $ p * $ allPrimes [ $ i ] ; } $ result = $ result * ( $ exp + 1 ) ; } return $ result ; } echo factorialDivisors ( 6 ) ; ? >"}
{"text":"Non Fibonacci Numbers | Returns n 'th Non- Fibonacci number ; curr is to keep track of current fibonacci number , prev is previous , prevPrev is previous of previous . ; While count of non - fibonacci numbers doesn 't become  negative or zero ; Simple Fibonacci number logic ; ( curr - prev - 1 ) is count of non - Fibonacci numbers between curr and prev . ; n might be negative now . Make sure it becomes positive by removing last added gap . ; Now add the positive n to previous Fibonacci number to find the n 'th non-fibonacci. ; Driver code","code":"< ? php function nonFibonacci ( $ n ) { $ prevPrev = 1 ; $ prev = 2 ; $ curr = 3 ; while ( $ n > 0 ) { $ prevPrev = $ prev ; $ prev = $ curr ; $ curr = $ prevPrev + $ prev ; $ n = $ n - ( $ curr - $ prev - 1 ) ; } $ n = $ n + ( $ curr - $ prev - 1 ) ; return $ prev + $ n ; } echo nonFibonacci ( 5 ) ; ? >"}
{"text":"Stein 's Algorithm for finding GCD | Function to implement Stein 's Algorithm ; GCD ( 0 , b ) == b ; GCD ( a , 0 ) == a , GCD ( 0 , 0 ) == 0 ; Finding K , where K is the greatest power of 2 that divides both a and b . ; Dividing a by 2 until a becomes odd ; From here on , ' a ' is always odd . ; If b is even , remove all factor of 2 in b ; Now a and b are both odd . Swap if necessary so a <= b , then set b = b - a ( which is even ) ; restore common factors of 2 ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; $ k ; for ( $ k = 0 ; ( ( $ a $ b ) & 1 ) == 0 ; ++ $ k ) { $ a >>= 1 ; $ b >>= 1 ; } while ( ( $ a & 1 ) == 0 ) $ a >>= 1 ; do { while ( ( $ b & 1 ) == 0 ) $ b >>= 1 ; if ( $ a > $ b ) swap ( $ a , $ b ) ; $ b = ( $ b - $ a ) ; } while ( $ b != 0 ) ; return $ a << $ k ; } $ a = 34 ; $ b = 17 ; echo \" Gcd \u2581 of \u2581 given \u2581 numbers \u2581 is \u2581 \" . gcd ( $ a , $ b ) ; ? >"}
{"text":"Print all n | n -- > value of input out -- > output array index -- > index of next digit to be filled in output array evenSum , oddSum -- > sum of even and odd digits so far ; Base case ; If number becomes n - digit ; if absolute difference between sum of even and odd digits is 1 , print the number ; If current index is odd , then add it to odd sum and recurse ; else else add to even sum and recurse ; This is mainly a wrapper over findNDigitNumsUtil . It explicitly handles leading digit and calls findNDigitNumsUtil ( ) for remaining indexes . ; output array to store n - digit numbers ; Initialize number index considered so far ; Initialize even and odd sums ; Explicitly handle first digit and call recursive function findNDigitNumsUtil for remaining indexes . Note that the first digit is considered to be present in even position . ; Driver program","code":"< ? php function findNDigitNumsUtil ( $ n , $ out , $ index , $ evenSum , $ oddSum ) { if ( $ index > $ n ) return ; if ( $ index == $ n ) { if ( abs ( $ evenSum - $ oddSum ) == 1 ) { echo implode ( \" \" , $ out ) . \" \" } return ; } if ( $ index & 1 ) { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = $ i + '0' ; findNDigitNumsUtil ( $ n , $ out , $ index + 1 , $ evenSum , $ oddSum + $ i ) ; } } { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = $ i + '0' ; findNDigitNumsUtil ( $ n , $ out , $ index + 1 , $ evenSum + $ i , $ oddSum ) ; } } } function findNDigitNums ( $ n ) { $ out = array_fill ( 0 , $ n + 1 , \" \" ) ; $ index = 0 ; $ evenSum = 0 ; $ oddSum = 0 ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = $ i + '0' ; findNDigitNumsUtil ( $ n , $ out , $ index + 1 , $ evenSum + $ i , $ oddSum ) ; } } $ n = 3 ; findNDigitNums ( $ n ) ; ? >"}
{"text":"Program to convert a given number to words | Set 2 | strings at index 0 is not used , it is to make array indexing simple ; strings at index 0 and 1 are not used , they is to make array indexing simple ; n is 1 - or 2 - digit number ; if n is more than 19 , divide it ; if n is non - zero ; Function to print a given number in words ; stores word representation of given number n ; handles digits at ten millions and hundred millions places ( if any ) ; handles digits at hundred thousands and one millions places ( if any ) ; handles digits at thousands and tens thousands places ( if any ) ; handles digit at hundreds places ( if any ) ; handles digits at ones and tens places ( if any ) ; long handles upto 9 digit no change to unsigned long long int to handle more digit number ; convert given number in words","code":"< ? php $ one = array ( \" \" , \" one \u2581 \" , \" two \u2581 \" , \" three \u2581 \" , \" four \u2581 \" , \" five \u2581 \" , \" six \u2581 \" , \" seven \u2581 \" , \" eight \u2581 \" , \" nine \u2581 \" , \" ten \u2581 \" , \" eleven \u2581 \" , \" twelve \u2581 \" , \" thirteen \u2581 \" , \" fourteen \u2581 \" , \" fifteen \u2581 \" , \" sixteen \u2581 \" , \" seventeen \u2581 \" , \" eighteen \u2581 \" , \" nineteen \u2581 \" ) ; $ ten = array ( \" \" , \" \" , \" twenty \u2581 \" , \" thirty \u2581 \" , \" forty \u2581 \" , \" fifty \u2581 \" , \" sixty \u2581 \" , \" seventy \u2581 \" , \" eighty \u2581 \" , \" ninety \u2581 \" ) ; function numToWords ( $ n , $ s ) { global $ one , $ ten ; $ str = \" \" ; if ( $ n > 19 ) { $ str . = $ ten [ ( int ) ( $ n \/ 10 ) ] ; $ str . = $ one [ $ n % 10 ] ; } else $ str . = $ one [ $ n ] ; if ( $ n != 0 ) $ str . = $ s ; return $ str ; } function convertToWords ( $ n ) { $ out = \" \" ; $ out . = numToWords ( ( int ) ( $ n \/ 10000000 ) , \" crore \u2581 \" ) ; $ out . = numToWords ( ( ( int ) ( $ n \/ 100000 ) % 100 ) , \" lakh \u2581 \" ) ; $ out . = numToWords ( ( ( int ) ( $ n \/ 1000 ) % 100 ) , \" thousand \u2581 \" ) ; $ out . = numToWords ( ( ( int ) ( $ n \/ 100 ) % 10 ) , \" hundred \u2581 \" ) ; if ( $ n > 100 && $ n % 100 ) $ out . = \" and \u2581 \" ; $ out . = numToWords ( ( $ n % 100 ) , \" \" ) ; return $ out ; } $ n = 438237764 ; echo convertToWords ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Linear Diophantine Equations | utility function to find the GCD of two numbers ; This function checks if integral solutions are possible ; First example ; Second example ; Third example","code":"< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b == 0 ) ? abs ( $ b ) : gcd ( $ b , $ a % $ b ) ; } function isPossible ( $ a , $ b , $ c ) { return ( $ c % gcd ( $ a , $ b ) == 0 ) ; } $ a = 3 ; $ b = 6 ; $ c = 9 ; if ( isPossible ( $ a , $ b , $ c ) == true ) echo \" Possible STRNEWLINE \" ; else echo \" Not \u2581 Possible STRNEWLINE \" ; $ a = 3 ; $ b = 6 ; $ c = 8 ; if ( isPossible ( $ a , $ b , $ c ) == true ) echo \" Possible STRNEWLINE \" ; else echo \" Not \u2581 Possible STRNEWLINE \" ; $ a = 2 ; $ b = 5 ; $ c = 1 ; if ( isPossible ( $ a , $ b , $ c ) == true ) echo \" Possible STRNEWLINE \" ; else echo \" Not \u2581 Possible STRNEWLINE \" ; ? >"}
{"text":"Farey Sequence | Optimized function to print Farey sequence of order n ; We know first two terms are 0 \/ 1 and 1 \/ n ; For next terms to be evaluated ; Using recurrence relation to find the next term ; Print next term ; Update x1 , y1 , x2 and y2 for next iteration ; Driver Code","code":"< ? php function farey ( $ n ) { $ x1 = 0 ; $ y1 = 1 ; $ x2 = 1 ; $ y2 = $ n ; echo $ x1 , \" \/ \" , $ y1 , \" \u2581 \" , $ x2 , \" \/ \" , $ y2 , \" \u2581 \" ; $ x ; $ y = 0 ; while ( $ y != 1.0 ) { $ x = floor ( ( $ y1 + $ n ) \/ $ y2 ) * $ x2 - $ x1 ; $ y = floor ( ( $ y1 + $ n ) \/ $ y2 ) * $ y2 - $ y1 ; echo $ x , \" \/ \" , $ y , \" \u2581 \" ; $ x1 = $ x2 ; $ x2 = $ x ; $ y1 = $ y2 ; $ y2 = $ y ; } } $ n = 7 ; echo \" Farey \u2581 Sequence \u2581 of \u2581 order \u2581 \" , $ n , \" \u2581 is STRNEWLINE \" ; farey ( $ n ) ; ? >"}
{"text":"Find smallest values of x and y such that ax | To find GCD using Eculcid 's algorithm ; Prints smallest values of x and y that satisfy \" ax \u2581 - \u2581 by \u2581 = \u2581 0\" ; Find LCM ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return ( gcd ( $ b , $ a % $ b ) ) ; } function findSmallest ( $ a , $ b ) { $ lcm = ( $ a * $ b ) \/ gcd ( $ a , $ b ) ; echo \" x \u2581 = \u2581 \" , $ lcm \/ $ a , \" y = \" } $ a = 25 ; $ b = 35 ; findSmallest ( $ a , $ b ) ; ? >"}
{"text":"Compute n ! under modulo p | Utility function to do modular exponentiation . It returns ( x ^ y ) % p ; $res = 1 ; Initialize result $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Function to find modular inverse of a under modulo p using Fermat 's method. Assumption: p is prime ; Returns n ! % p using Wilson 's Theorem ; n ! % p is 0 if n >= p ; Initialize result as ( p - 1 ) ! which is - 1 or ( p - 1 ) ; Multiply modulo inverse of all numbers from ( n + 1 ) to p ; Driver Code","code":"< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modInverse ( $ a , $ p ) { return power ( $ a , $ p - 2 , $ p ) ; } function modFact ( $ n , $ p ) { if ( $ p <= $ n ) return 0 ; $ res = ( $ p - 1 ) ; for ( $ i = $ n + 1 ; $ i < $ p ; $ i ++ ) $ res = ( $ res * modInverse ( $ i , $ p ) ) % $ p ; return $ res ; } $ n = 25 ; $ p = 29 ; echo modFact ( $ n , $ p ) ; ? >"}
{"text":"Count number of ways to divide a number in 4 parts | Returns count of ways ; Initialize result ; Generate all possible quadruplet and increment counter when sum of a quadruplet is equal to n ; Driver Code","code":"< ? php function countWays ( $ n ) { $ counter = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) for ( $ k = $ j ; $ k < $ n ; $ k ++ ) for ( $ l = $ k ; $ l < $ n ; $ l ++ ) if ( $ i + $ j + $ k + $ l == $ n ) $ counter ++ ; return $ counter ; } $ n = 8 ; echo countWays ( $ n ) ; ? >"}
{"text":"Sum of Bitwise And of all pairs in a given array | Returns value of \" arr [ 0 ] \u2581 & \u2581 arr [ 1 ] \u2581 + \u2581 arr [ 0 ] \u2581 & \u2581 arr [ 2 ] \u2581 + \u2581 . . . \u2581 arr [ i ] \u2581 & \u2581 arr [ j ] \u2581 + \u2581 . . . . . \u2581 arr [ n - 2 ] \u2581 & \u2581 arr [ n - 1 ] \" ; Initialize result ; Consider all pairs ( arr [ i ] , arr [ j ) such that i < j ; Driver Code","code":"< ? php function pairAndSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] & $ arr [ $ j ] ; return $ ans ; } $ arr = array ( 5 , 10 , 15 ) ; $ n = sizeof ( $ arr ) ; echo pairAndSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Sum of Bitwise And of all pairs in a given array | Returns value of \" arr [ 0 ] \u2581 & \u2581 arr [ 1 ] \u2581 + \u2581 arr [ 0 ] \u2581 & \u2581 arr [ 2 ] \u2581 + \u2581 . . . \u2581 arr [ i ] \u2581 & \u2581 arr [ j ] \u2581 + \u2581 . . . . . \u2581 arr [ n - 2 ] \u2581 & \u2581 arr [ n - 1 ] \" ; Initialize result ; Traverse over all bits ; Count number of elements with i 'th bit set  Initialize the count ; There are k set bits , means k ( k - 1 ) \/ 2 pairs . Every pair adds 2 ^ i to the answer . Therefore , we add \"2 ^ i \u2581 * \u2581 [ k * ( k - 1 ) \/ 2 ] \" to the answer . ; Driver Code","code":"< ? php function pairAndSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ k = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) ) $ k ++ ; $ ans += ( 1 << $ i ) * ( $ k * ( $ k - 1 ) \/ 2 ) ; } return $ ans ; } $ arr = array ( 5 , 10 , 15 ) ; $ n = sizeof ( $ arr ) ; echo pairAndSum ( $ arr , $ n ) ; ? >"}
{"text":"Primality Test | Set 1 ( Introduction and School Method ) | A school method based PHP program to check if a number is prime ; Corner case ; Check from 2 to n - 1 ; Driver Code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; } $ tet = isPrime ( 11 ) ? \" \u2581 true STRNEWLINE \" : \" \u2581 false STRNEWLINE \" ; echo $ tet ; $ tet = isPrime ( 15 ) ? \" \u2581 true STRNEWLINE \" : \" \u2581 false STRNEWLINE \" ; echo $ tet ; ? >"}
{"text":"Euler 's Totient function for all numbers smaller than or equal to n | Computes and prints totient of all numbers smaller than or equal to n . ; Create and initialize an array to store phi or totient values ; indicates not evaluated yet and initializes for product formula . ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 \/ $p ) ; Print precomputed phi values ; Driver Code","code":"< ? php function computeTotient ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ phi [ $ i ] = $ i ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ phi [ $ p ] == $ p ) { $ phi [ $ p ] = $ p - 1 ; for ( $ i = 2 * $ p ; $ i <= $ n ; $ i += $ p ) { $ phi [ $ i ] = ( $ phi [ $ i ] \/ $ p ) * ( $ p - 1 ) ; } } } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo \" Totient \u2581 of \u2581 \" , $ i , \" \u2581 is \u2581 \" , $ phi [ $ i ] , \" STRNEWLINE \" ; } $ n = 12 ; computeTotient ( $ n ) ; ? >"}
{"text":"Sum of all elements between k1 ' th \u2581 and \u2581 k2' th smallest elements | Returns sum between two kth smallest elements of the array ; Sort the given array ; Below code is equivalent to ; Driver program","code":"< ? php function sumBetweenTwoKth ( $ arr , $ n , $ k1 , $ k2 ) { sort ( $ arr ) ; $ result = 0 ; for ( $ i = $ k1 ; $ i < $ k2 - 1 ; $ i ++ ) $ result += $ arr [ $ i ] ; return $ result ; } $ arr = array ( 20 , 8 , 22 , 4 , 12 , 10 , 14 ) ; $ k1 = 3 ; $ k2 = 6 ; $ n = count ( $ arr ) ; ; echo sumBetweenTwoKth ( $ arr , $ n , $ k1 , $ k2 ) ; ? >"}
{"text":"Puzzle | Program to find number of squares in a chessboard | Function to return count of squares ; ; A better way to write n * ( n + 1 ) * ( 2 n + 1 ) \/ 6 ; Driver Code","code":"< ? php function countSquares ( $ n ) { return ( $ n * ( $ n + 1 ) \/ 2 ) * ( 2 * $ n + 1 ) \/ 3 ; } $ n = 4 ; echo \" Count \u2581 of \u2581 squares \u2581 is \u2581 \" , countSquares ( $ n ) ; ? >"}
{"text":"Find nth Magic Number | Function to find nth magic number ; Go through every bit of n ; If last bit of n is set ; proceed to next bit $n >>= 1 ; or $n = $n \/ 2 ; Driver Code","code":"< ? php function nthMagicNo ( $ n ) { $ pow = 1 ; $ answer = 0 ; while ( $ n ) { $ pow = $ pow * 5 ; if ( $ n & 1 ) $ answer += $ pow ; } return $ answer ; } $ n = 5 ; echo \" nth \u2581 magic \u2581 number \u2581 is \u2581 \" , nthMagicNo ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Given a number n , count all multiples of 3 and \/ or 5 in set { 1 , 2 , 3 , ... n } | PHP program to find count of multiples of 3 and 5 in { 1 , 2 , 3 , . . n } ; Add multiples of 3 and 5. Since common multiples are counted twice in n \/ 3 + n \/ 15 , subtract common multiples ; Driver Code","code":"< ? php function countOfMultiples ( $ n ) { return floor ( floor ( $ n \/ 3 ) + floor ( $ n \/ 5 ) - floor ( $ n \/ 15 ) ) ; } echo countOfMultiples ( 6 ) , \" STRNEWLINE \" ; echo countOfMultiples ( 16 ) ; ? >"}
{"text":"Program to find GCD or HCF of two numbers | Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD \u2581 of \u2581 $ a \u2581 and \u2581 $ b \u2581 is \u2581 \" , gcd ( $ a , $ b ) ; ? >"}
{"text":"Game Theory in Balanced Ternary Numeral System | ( Moving 3 k steps at a time ) | Function that returns true if the game cannot be won ; Driver code ; Common length","code":"< ? php function isDefeat ( $ s1 , $ s2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == '1' ) || ( $ s1 [ $ i ] == '1' && $ s2 [ $ i ] == '0' ) ) continue ; else if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == ' Z ' ) || ( $ s1 [ $ i ] == ' Z ' && $ s2 [ $ i ] == '0' ) ) continue ; else { return true ; } } return false ; } $ s1 = ( \"01001101ZZ \" ) ; $ s2 = ( \"10Z1001000\" ) ; $ n = 10 ; if ( isDefeat ( $ s1 , $ s2 , $ n ) ) echo ( \" Defeat \" ) ; else echo ( \" Victory \" ) ;"}
{"text":"Check if matrix A can be converted to B by changing parity of corner elements of any submatrix | PHP implementation of the above approach ; Boolean function that returns true or false ; Traverse for all elements ; If both are not equal ; Change the parity of all corner elements ; Check if A is equal to B ; Not equal ; First binary matrix ; Second binary matrix","code":"< ? php $ N = 3 ; $ M = 3 ; function check ( $ a , $ b ) { for ( $ i = 1 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 1 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] != $ b [ $ i ] [ $ j ] ) { $ a [ $ i ] [ $ j ] ^= 1 ; $ a [ 0 ] [ 0 ] ^= 1 ; $ a [ 0 ] [ $ j ] ^= 1 ; $ a [ $ i ] [ 0 ] ^= 1 ; } } } for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] != $ b [ $ i ] [ $ j ] ) return false ; } } return true ; } $ a = array ( array ( 0 , 1 , 0 ) , array ( 0 , 1 , 0 ) , array ( 1 , 0 , 0 ) ) ; $ b = array ( array ( 1 , 0 , 0 ) , array ( 1 , 0 , 0 ) , array ( 1 , 0 , 0 ) ) ; if ( check ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Position of the K | Function that returns the Kth set bit ; Traverse in the binary ; Check if the last bit is set or not ; Check if count is equal to k then return the index ; Increase the index as we move right ; Right shift the number by 1 ; Driver Code","code":"< ? php function FindIndexKthBit ( $ n , $ k ) { $ cnt = 0 ; $ ind = 0 ; while ( $ n ) { if ( $ n & 1 ) $ cnt ++ ; if ( $ cnt == $ k ) return $ ind ; $ ind ++ ; $ n = $ n >> 1 ; } return -1 ; } $ n = 15 ; $ k = 3 ; $ ans = FindIndexKthBit ( $ n , $ k ) ; if ( $ ans != -1 ) echo $ ans ; else echo \" No \u2581 k - th \u2581 set \u2581 bit \" ; ? >"}
{"text":"Distance between two nodes of binary tree with node values from 1 to N | Function to get minimum path distance ; count bit length of n1 and n2 ; find bit difference and maxBit ; calculate result by formula ; Driver Code","code":"< ? php function minDistance ( $ n1 , $ n2 ) { $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue ; $ result = $ bitCount1 + $ bitCount2 - 2 * $ disSimilarBitPosition ; return $ result ; } $ n1 = 12 ; $ n2 = 5 ; echo minDistance ( $ n1 , $ n2 ) ; ? >"}
{"text":"Remove one bit from a binary number to get maximum value | Function to find the maximum binary number ; Traverse the binary number ; Try finding a 0 and skip it ; Get the binary number ; Find the maximum binary number","code":"< ? php function printMaxAfterRemoval ( $ s ) { $ flag = false ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '0' && $ flag == false ) { $ flag = true ; continue ; } else echo $ s [ $ i ] ; } } $ s = \"1001\" ; printMaxAfterRemoval ( $ s ) ; ? >"}
{"text":"Find position of left most dis | Function to find first dis - similar bit ; return zero for equal number ; count bit length of n1 and n2 ; find bit difference and maxBit ; Driver Code","code":"< ? php function bitPos ( $ n1 , $ n2 ) { if ( $ n1 == $ n2 ) return 0 ; $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue + 1 ; return $ disSimilarBitPosition ; } $ n1 = 53 ; $ n2 = 55 ; echo bitPos ( $ n1 , $ n2 ) ; ? >"}
{"text":"Number of pairs with Bitwise OR as Odd number | Function to count pairs with odd OR ; Count total even numbers in array ; Even pair count ; Total pairs ; Return Odd pair count ; Driver main","code":"< ? php function countOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; $ evenPairCount = $ count * ( $ count - 1 ) \/ 2 ; $ totPairs = $ N * ( $ N - 1 ) \/ 2 ; return ( $ totPairs - $ evenPairCount ) ; } $ A = array ( 5 , 6 , 2 , 8 ) ; $ N = sizeof ( $ A ) ; echo countOddPair ( $ A , $ N ) , \" STRNEWLINE \" ; ? >"}
{"text":"Replace every array element by Bitwise Xor of previous and next element | PHP program to update every array element with sum of previous and next numbers in array ; Nothing to do when array size is 1 ; store current value of arr [ 0 ] and update it ; Update rest of the array elements ; Store current value of next interaction ; Update current value using previous value ; Update previous value ; Update last array element separately ; Driver Code ; Print the modified array","code":"< ? php function ReplaceElements ( & $ arr , $ n ) { if ( $ n <= 1 ) return ; $ prev = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 0 ] ^ $ arr [ 1 ] ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ curr = $ arr [ $ i ] ; $ arr [ $ i ] = $ prev ^ $ arr [ $ i + 1 ] ; $ prev = $ curr ; } $ arr [ $ n - 1 ] = $ prev ^ $ arr [ $ n - 1 ] ; } $ arr = array ( 2 , 3 , 4 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; ReplaceElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Find bitwise OR of all possible sub | function to return OR of sub - arrays ; Driver Code ; print OR of all subarrays","code":"< ? php function O_R ( $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ ans |= $ a [ $ i ] ; return $ ans ; } $ a = array ( 1 , 4 , 6 ) ; $ n = count ( $ a ) ; echo O_R ( $ a , $ n ) ; ? >"}
{"text":"Maximum set bit sum in array without considering adjacent elements | Function to count total number of set bits in an integer ; Maximum sum of set bits ; Calculate total number of set bits for every element of the array ; find total set bits for each number and store back into the array ; current max excluding i ; current max including i ; return max of incl and excl ; Driver code","code":"< ? php function bit ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n = $ n & ( $ n - 1 ) ; } return $ count ; } function maxSumOfBits ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = bit ( $ arr [ $ i ] ) ; } $ incl = $ arr [ 0 ] ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = ( $ incl > $ excl ) ? $ incl : $ excl ; $ incl = $ excl + $ arr [ $ i ] ; $ excl = $ excl_new ; } return ( ( $ incl > $ excl ) ? $ incl : $ excl ) ; } $ arr = array ( 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo maxSumOfBits ( $ arr , $ n ) ; #This  Code is Contributed by ajit  NEW_LINE ? >"}
{"text":"Increment a number without using ++ or + | function that increment the value . ; Invert bits and apply negative sign ; Driver code","code":"< ? php function increment ( $ i ) { $ i = - ( ~ ord ( $ i ) ) ; return chr ( $ i ) ; } $ n = ' a ' ; echo increment ( $ n ) ; ? >"}
{"text":"Count pairs with Bitwise XOR as ODD number | Function to count number of odd pairs ; find all pairs ; return number of odd pair ; Driver Code ; calling function findOddPair and print number of odd pair","code":"< ? php function findOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 == 0 ) $ count ++ ; } return $ count * ( $ N - $ count ) ; } $ a = array ( 5 , 4 , 7 , 2 , 1 ) ; $ n = count ( $ a ) ; echo ( findOddPair ( $ a , $ n ) ) ; ? >"}
{"text":"Bitwise OR ( or | ) of a range | Returns the Most Significant Bit Position ( MSB ) ; Returns the Bitwise OR of all integers between L and R ; Find the MSB position in L ; Find the MSB position in R ; Add this value until msb_p1 and msb_p2 are same ; ; Calculate msb_p1 and msb_p2 ; Find the max of msb_p1 and msb_p2 ; Set all the bits from msb_p1 upto 0 th bit in the result ; Driver Code","code":"< ? php function MSBPosition ( $ N ) { $ msb_p = -1 ; while ( $ N ) { $ N = $ N >> 1 ; $ msb_p ++ ; } return $ msb_p ; } function findBitwiseOR ( $ L , $ R ) { $ res = 0 ; $ msb_p1 = MSBPosition ( $ L ) ; $ msb_p2 = MSBPosition ( $ R ) ; while ( $ msb_p1 == $ msb_p2 ) { $ res_val = ( 1 << $ msb_p1 ) ; $ res += $ res_val ; $ L -= $ res_val ; $ R -= $ res_val ; $ msb_p1 = MSBPosition ( $ L ) ; $ msb_p2 = MSBPosition ( $ R ) ; } $ msb_p1 = max ( $ msb_p1 , $ msb_p2 ) ; for ( $ i = $ msb_p1 ; $ i >= 0 ; $ i -- ) { $ res_val = ( 1 << $ i ) ; $ res += $ res_val ; } return $ res ; } $ L = 12 ; $ R = 18 ; echo findBitwiseOR ( $ L , $ R ) ; ? >"}
{"text":"Maximize the bitwise OR of an array | Function to maximize the bitwise OR sum ; Compute x ^ k ; Find prefix bitwise OR ; Find suffix bitwise OR ; Find maximum OR value ; Driver Code","code":"< ? php function maxOR ( $ arr , $ n , $ k , $ x ) { $ res ; $ pow = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ pow *= $ x ; $ preSum [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i + 1 ] = $ preSum [ $ i ] | $ arr [ $ i ] ; $ suffSum [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] | $ arr [ $ i ] ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ preSum [ $ i ] | ( $ arr [ $ i ] * $ pow ) $ suffSum [ $ i + 1 ] ) ; return $ res ; } $ arr = array ( 1 , 2 , 4 , 8 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; $ x = 3 ; echo maxOR ( $ arr , $ n , $ k , $ x ) , \" STRNEWLINE \" ; ? >"}
{"text":"How to turn on a particular bit in a number ? | Returns a number that has all bits same as n except the k 'th bit which is made 1 ; k must be greater than 0 ; Do | of n with a number with all unset bits except the k 'th bit ; Driver Code","code":"< ? php function turnOnK ( $ n , $ k ) { if ( $ k <= 0 ) return $ n ; return ( $ n | ( 1 << ( $ k - 1 ) ) ) ; } $ n = 4 ; $ k = 2 ; echo turnOnK ( $ n , $ k ) ; ? >"}
{"text":"Minimum sum of two numbers formed from digits of an array | Returns sum of two numbers formed from all digits in a [ ] ; sort the elements ; Driver code","code":"< ? php function minSum ( $ a , $ n ) { sort ( $ a ) ; $ num1 = 0 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ num1 = $ num1 * 10 + $ a [ $ i ] ; else $ num2 = $ num2 * 10 + $ a [ $ i ] ; } return ( $ num2 + $ num1 ) ; } $ arr = array ( 5 , 3 , 0 , 7 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" The \u2581 required \u2581 sum \u2581 is \u2581 \" , minSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find value of k | PHP program to find k - th bit from right ; Driver Code ; Function Call","code":"< ? php function printKthBit ( $ n , $ k ) { echo ( $ n & ( 1 << ( $ k - 1 ) ) ) ; } $ n = 13 ; $ k = 2 ; printKthBit ( $ n , $ k ) ; ? >"}
{"text":"Odd numbers in N | Function to get no of set bits in binary representation of positive integer n ; Count number of 1 's in binary  representation of n. ; Number of odd numbers in n - th row is 2 raised to power the count . ; Driver code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; } function countOfOddsPascal ( $ n ) { $ c = countSetBits ( $ n ) ; return pow ( 2 , $ c ) ; } $ n = 20 ; echo countOfOddsPascal ( $ n ) ; ? >"}
{"text":"Queries on XOR of XORs of all subarrays | Output for each query ; If number of element is even . ; If number of element is odd . ; if l is even ; if l is odd ; Wrapper Function ; Evaluating prefixodd and prefixeven ; Driver code","code":"< ? php function ansQueries ( $ prefeven , $ prefodd , $ l , $ r ) { if ( ( $ r - $ l + 1 ) % 2 == 0 ) { echo \"0\" ; } else { if ( $ l % 2 == 0 ) echo ( $ prefeven [ $ r ] ^ $ prefeven [ $ l - 1 ] ) ; else echo ( $ prefodd [ $ r ] ^ $ prefodd [ $ l - 1 ] ) ; } echo \" STRNEWLINE \" ; } function wrapper ( array $ arr , $ n , array $ l , array $ r , $ q ) { $ prefodd = array_fill ( 0 , 100 , 0 ) ; $ prefeven = array_fill ( 0 , 100 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( ( $ i ) % 2 == 0 ) { $ prefeven [ $ i ] = $ arr [ $ i - 1 ] ^ $ prefeven [ $ i - 1 ] ; $ prefodd [ $ i ] = $ prefodd [ $ i - 1 ] ; } else { $ prefeven [ $ i ] = $ prefeven [ $ i - 1 ] ; $ prefodd [ $ i ] = $ prefodd [ $ i - 1 ] ^ $ arr [ $ i - 1 ] ; } } $ i = 0 ; while ( $ i != $ q ) { ansQueries ( $ prefeven , $ prefodd , $ l [ $ i ] , $ r [ $ i ] ) ; $ i ++ ; } } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ l = array ( 1 , 1 , 2 ) ; $ r = array ( 2 , 3 , 4 ) ; $ q = sizeof ( $ l ) \/ sizeof ( $ l [ 0 ] ) ; wrapper ( $ arr , $ n , $ l , $ r , $ q ) ; ? >"}
{"text":"Variation in Nim Game | Function to return final grundy Number ( G ) of game ; if pile size is odd ; We XOR pile size + 1 ; We XOR pile size - 1 ; Game with 3 piles ; pile with different sizes ; Function to return result of game ; if ( $res == 0 ) if G is zero ; else if G is non zero","code":"< ? php function solve ( $ p , $ n ) { $ G = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ p [ $ i ] & 1 ) $ G ^= ( $ p [ $ i ] + 1 ) ; $ G ^= ( $ p [ $ i ] - 1 ) ; } return $ G ; } $ n = 3 ; $ p = array ( 32 , 49 , 58 ) ; $ res = solve ( $ p , $ n ) ; echo \" Player \u2581 2 \u2581 wins \" ; echo \" Player \u2581 1 \u2581 wins \" ; ? >"}
{"text":"Maximum AND value of a pair in an array | Utility function to check number of elements having set msb as of pattern ; Function for finding maximum and value pair ; iterate over total of 30 bits from msb to lsb ; find the count of element having set msb ; if count >= 2 set particular bit in result ; Driver Code","code":"< ? php function checkBit ( $ pattern , $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ pattern & $ arr [ $ i ] ) == $ pattern ) $ count ++ ; return $ count ; } function maxAND ( $ arr , $ n ) { $ res = 0 ; $ count ; for ( $ bit = 31 ; $ bit >= 0 ; $ bit -- ) { $ count = checkBit ( $ res | ( 1 << $ bit ) , $ arr , $ n ) ; if ( $ count >= 2 ) $ res |= ( 1 << $ bit ) ; } return $ res ; } $ arr = array ( 4 , 8 , 6 , 2 ) ; $ n = count ( $ arr ) ; echo \" Maximum \u2581 AND \u2581 Value \u2581 = \u2581 \" , maxAND ( $ arr , $ n ) ; ? >"}
{"text":"Check if a number is power of 8 or not | function to check if power of 8 ; calculate log8 ( n ) ; check if i is an integer or not ; Driver Code","code":"< ? php function checkPowerof8 ( $ n ) { $ i = log ( $ n ) \/ log ( 8 ) ; return ( $ i - floor ( $ i ) < 0.000001 ) ; } $ n = 65 ; if ( checkPowerof8 ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if binary representation of a given number and its complement are anagram | Returns true if binary representations of a and b are anagram . ; _popcnt64 ( a ) gives number of 1 's present  in binary representation of a. If number  of 1s is half of total bits, return true. ; Driver code","code":"< ? php function bit_anagram_check ( $ a ) { $ longSize = 8 ; $ ULL_SIZE = 8 * $ longSize ; return ( BitCount ( $ a ) == ( $ ULL_SIZE >> 1 ) ) ; } function BitCount ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ count ++ ; $ n &= ( $ n - 1 ) ; } return $ count ; } $ a = 4294967295 ; echo ( bit_anagram_check ( $ a ) ) ; ? >"}
{"text":"Sum of numbers with exactly 2 bits set | To calculate sum of numbers ; Find numbers whose 2 bits are set ; If number is greater then n we don 't include this in sum ; Return sum of numbers ; Driver Code","code":"< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; ( 1 << $ i ) < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ num = ( 1 << $ i ) + ( 1 << $ j ) ; if ( $ num <= $ n ) $ sum += $ num ; } } return $ sum ; } $ n = 10 ; echo findSum ( $ n ) ; ? >"}
{"text":"Position of rightmost different bit | function to find rightmost different bit in two numbers . ; Driver code","code":"< ? php function posOfRightMostDiffBit ( $ m , $ n ) { $ t = floor ( log ( $ m ^ $ n , 2 ) ) ; return $ t ; } $ m = 52 ; $ n = 4 ; echo \" Position \u2581 = \u2581 \" , posOfRightMostDiffBit ( $ m , $ n ) ; ? >"}
{"text":"Set the K | function to set the kth bit ; kth bit of n is being set by this operation ; Driver Code","code":"< ? php function setKthBit ( $ n , $ k ) { return ( ( 1 << $ k ) $ n ) ; } $ n = 10 ; $ k = 2 ; echo \" Kth \u2581 bit \u2581 set \u2581 number \u2581 = \u2581 \" , setKthBit ( $ n , $ k ) ; ? >"}
{"text":"Reverse an array without using subtract sign \u00e2 \u20ac\u02dc | Function to reverse array ; Trick to assign - 1 to a variable ; Reverse array in simple manner ; Swap ith index value with ( n - i - 1 ) th index value ; Drivers code ; print the reversed array","code":"< ? php function reverseArray ( & $ arr , $ n ) { $ x = ( PHP_INT_MIN \/ PHP_INT_MAX ) ; for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) swap ( $ arr , $ i , $ n + ( $ x * $ i ) + $ x ) ; } function swap ( & $ arr , $ i , $ j ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; return $ arr ; } $ arr = array ( 5 , 3 , 7 , 2 , 1 , 6 ) ; $ n = sizeof ( $ arr ) ; reverseArray ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ;"}
{"text":"Reverse an array without using subtract sign \u00e2 \u20ac\u02dc | Function to reverse array ; Reverse array in simple manner ; Swap ith index value with ( n - i - 1 ) th index value Note : A - B = A + ~ B + 1 So n - i = n + ~ i + 1 then n - i - 1 = ( n + ~ i + 1 ) + 1 + 1 ; Driver code ; print the reversed array","code":"< ? php function reverseArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) { swap ( $ arr , $ i , ( $ n + ~ $ i + 1 ) + ~ 1 + 1 ) ; } } function swap ( & $ arr , $ i , $ j ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; return $ arr ; } { $ arr = array ( 5 , 3 , 7 , 2 , 1 , 6 ) ; $ n = sizeof ( $ arr ) ; reverseArray ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ arr [ $ i ] . \" \" ) ; } }"}
{"text":"Maximum XOR value of a pair from a range | method to get maximum xor value in range [ L , R ] ; get xor of limits ; loop to get msb position of L ^ R ; construct result by adding 1 , msbPos times ; Driver Code","code":"< ? php function maxXORInRange ( $ L , $ R ) { $ LXR = $ L ^ $ R ; $ msbPos = 0 ; while ( $ LXR ) { $ msbPos ++ ; $ LXR >>= 1 ; } $ maxXOR = 0 ; $ two = 1 ; while ( $ msbPos -- ) { $ maxXOR += $ two ; $ two <<= 1 ; } return $ maxXOR ; } $ L = 8 ; $ R = 20 ; echo maxXORInRange ( $ L , $ R ) , \" STRNEWLINE \" ; ? >"}
{"text":"Numbers whose bitwise OR and sum with N are equal | Function to find total 0 bit in a number ; Function to find Count of non - negative numbers less than or equal to N , whose bitwise OR and SUM with N are equal . ; count number of zero bit in N ; power of 2 to count ; Driver code","code":"< ? php function CountZeroBit ( $ n ) { $ count = 0 ; while ( $ n ) { if ( ! ( $ n & 1 ) ) $ count ++ ; $ n >>= 1 ; } return $ count ; } function CountORandSumEqual ( $ N ) { $ count = CountZeroBit ( $ N ) ; return ( 1 << $ count ) ; } $ N = 10 ; echo CountORandSumEqual ( $ N ) ; ? >"}
{"text":"Count smaller numbers whose XOR with n produces greater value | PHP program to count numbers whose XOR with n produces a value more than n . ; Position of current bit in n ; Initialize result ; If current bit is 0 , then there are 2 ^ k numbers with current bit 1 and whose XOR with n produces greater value ; Increase position for next bit ; Reduce n to find next bit ; Driver code","code":"< ? php function countNumbers ( $ n ) { $ k = 0 ; $ count = 0 ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) $ count += pow ( 2 , $ k ) ; $ k += 1 ; $ n >>= 1 ; } return $ count ; } $ n = 11 ; echo countNumbers ( $ n ) ; ? >"}
{"text":"Multiples of 4 ( An Interesting Method ) | Returns true if n is a multiple of 4. ; Find XOR of all numbers from 1 to n ; If XOR is equal n , then return true ; Printing multiples of 4 using above method","code":"< ? php function isMultipleOf4 ( $ n ) { if ( $ n == 1 ) return false ; $ XOR = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ XOR = $ XOR ^ $ i ; return ( $ XOR == $ n ) ; } for ( $ n = 0 ; $ n <= 42 ; $ n ++ ) if ( isMultipleOf4 ( $ n ) ) echo $ n , \" \u2581 \" ; ? >"}
{"text":"Multiples of 4 ( An Interesting Method ) | Returns true if n is a multiple of 4. ; Printing multiples of 4 using above method","code":"< ? php function isMultipleOf4 ( $ n ) { if ( $ n == 0 ) return true ; return ( ( ( $ n >> 2 ) << 2 ) == $ n ) ; } for ( $ n = 0 ; $ n <= 42 ; $ n ++ ) if ( isMultipleOf4 ( $ n ) ) echo $ n , \" \u2581 \" ; ? >"}
{"text":"Check if a number is Bleak | Function to get no of set bits in binary representation of passed binary no . ; A function to return ceiling of log x in base 2. For example , it returns 3 for 8 and 4 for 9. ; Returns true if n is Bleak ; Check for all numbers ' x ' smaller than n . If x + countSetBits ( x ) becomes n , then n can 't be Bleak ; Driver code","code":"< ? php function countSetBits ( $ x ) { $ count = 0 ; while ( $ x ) { $ x &= ( $ x - 1 ) ; $ count ++ ; } return $ count ; } function ceilLog2 ( $ x ) { $ count = 0 ; $ x -- ; while ( $ x > 0 ) { $ x = $ x >> 1 ; $ count ++ ; } return $ count ; } function isBleak ( $ n ) { for ( $ x = $ n - ceilLog2 ( $ n ) ; $ x < $ n ; $ x ++ ) if ( $ x + countSetBits ( $ x ) == $ n ) return false ; return true ; } if ( isBleak ( 3 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isBleak ( 4 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Count strings with consecutive 1 's | Returns count of n length binary strings with consecutive 1 's ; Count binary strings without consecutive 1 's.  See the approach discussed on be  ( http:goo.gl\/p8A3sW ) ; Subtract a [ n - 1 ] + b [ n - 1 ] from 2 ^ n ; Driver Code","code":"< ? php function countStrings ( $ n ) { $ a [ $ n ] = 0 ; $ b [ $ n ] = 0 ; $ a [ 0 ] = $ b [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ a [ $ i - 1 ] + $ b [ $ i - 1 ] ; $ b [ $ i ] = $ a [ $ i - 1 ] ; } return ( 1 << $ n ) - $ a [ $ n - 1 ] - $ b [ $ n - 1 ] ; } echo countStrings ( 5 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Distance of nearest cell having 1 in a binary matrix | PHP program to find distance of nearest cell having 1 in a binary matrix . ; Print the distance of nearest cell having 1 for each cell . ; Initialize the answer matrix with INT_MAX . ; For each cell ; Traversing the whole matrix to find the minimum distance . ; If cell contain 1 , check for minimum distance . ; Printing the answer . ; Driver Code","code":"< ? php $ N = 3 ; $ M = 4 ; function printDistance ( $ mat ) { global $ N , $ M ; $ ans = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ M ; $ j ++ ) $ ans [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { for ( $ k = 0 ; $ k < $ N ; $ k ++ ) for ( $ l = 0 ; $ l < $ M ; $ l ++ ) { if ( $ mat [ $ k ] [ $ l ] == 1 ) $ ans [ $ i ] [ $ j ] = min ( $ ans [ $ i ] [ $ j ] , abs ( $ i - $ k ) + abs ( $ j - $ l ) ) ; } } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) echo $ ans [ $ i ] [ $ j ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 1 , 1 ) , array ( 0 , 1 , 1 , 0 ) ) ; printDistance ( $ mat ) ; ? >"}
{"text":"Given level order traversal of a Binary Tree , check if the Tree is a Min | Returns true if given level order traversal is Min Heap . ; First non leaf node is at index ( n \/ 2 - 1 ) . Check whether each parent is greater than child ; Left child will be at index 2 * i + 1 Right child will be at index 2 * i + 2 ; If parent is greater than right child ; Driver code","code":"< ? php function isMinHeap ( $ level , $ n ) { for ( $ i = ( $ n \/ 2 - 1 ) ; $ i >= 0 ; $ i -- ) { if ( $ level [ $ i ] > $ level [ 2 * $ i + 1 ] ) return false ; if ( 2 * $ i + 2 < $ n ) { if ( $ level [ $ i ] > $ level [ 2 * $ i + 2 ] ) return false ; } } return true ; } $ level = array ( 10 , 15 , 14 , 25 , 30 ) ; $ n = sizeof ( $ level ) ; if ( isMinHeap ( $ level , $ n ) ) echo \" True \" ; else echo \" False \" ;"}
{"text":"Most frequent element in an array | PHP program to find the most frequent element in an array . ; Sort the array ; find the max frequency using linear traversal ; If last element is most frequent ; Driver Code","code":"< ? php function mostFrequent ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ max_count = 1 ; $ res = $ arr [ 0 ] ; $ curr_count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ curr_count ++ ; else { if ( $ curr_count > $ max_count ) { $ max_count = $ curr_count ; $ res = $ arr [ $ i - 1 ] ; } $ curr_count = 1 ; } } if ( $ curr_count > $ max_count ) { $ max_count = $ curr_count ; $ res = $ arr [ $ n - 1 ] ; } return $ res ; } { $ arr = array ( 1 , 5 , 2 , 1 , 3 , 2 , 1 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo mostFrequent ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text":"How to check if two given sets are disjoint ? | Returns true if set1 [ ] and set2 [ ] are disjoint , else false ; Take every element of set1 [ ] and search it in set2 ; If no element of set1 is present in set2 ; Driver Code","code":"< ? php function areDisjoint ( $ set1 , $ set2 , $ m , $ n ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ set1 [ $ i ] == $ set2 [ $ j ] ) return false ; return true ; } $ set1 = array ( 12 , 34 , 11 , 9 , 3 ) ; $ set2 = array ( 7 , 2 , 1 , 5 ) ; $ m = sizeof ( $ set1 ) ; $ n = sizeof ( $ set2 ) ; if ( areDisjoint ( $ set1 , $ set2 , $ m , $ n ) == true ) echo \" Yes \" ; else echo \" \u2581 No \" ; ? >"}
{"text":"Find elements which are present in first array and not in second | Function for finding elements which are there in a [ ] but not in b [ ] . ; Driver code","code":"< ? php function findMissing ( $ a , $ b , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ a [ $ i ] == $ b [ $ j ] ) break ; if ( $ j == $ m ) echo $ a [ $ i ] , \" \u2581 \" ; } } $ a = array ( 1 , 2 , 6 , 3 , 4 , 5 ) ; $ b = array ( 2 , 4 , 3 , 1 , 0 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; findMissing ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text":"Check if two arrays are equal or not | Returns true if arr1 [ 0. . n - 1 ] and arr2 [ 0. . m - 1 ] contain same elements . ; If lengths of array are not equal means array are not equal ; Sort both arrays ; Linearly compare elements ; If all elements were same . ; Driver Code","code":"< ? php function areEqual ( $ arr1 , $ arr2 , $ n , $ m ) { if ( $ n != $ m ) return false ; sort ( $ arr1 ) ; sort ( $ arr2 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return false ; return true ; } $ arr1 = array ( 3 , 5 , 2 , 5 , 2 ) ; $ arr2 = array ( 2 , 3 , 5 , 5 , 2 ) ; $ n = count ( $ arr1 ) ; $ m = count ( $ arr2 ) ; if ( areEqual ( $ arr1 , $ arr2 , $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Pair with given product | Set 1 ( Find if any pair exists ) | Returns true if there is a pair in arr [ 0. . n - 1 ] with product equal to x . ; Consider all possible pairs and check for every pair . ; Driver code","code":"< ? php function isProduct ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] * $ arr [ $ j ] == $ x ) return true ; return false ; } $ arr = array ( 10 , 20 , 9 , 40 ) ; $ x = 400 ; $ n = count ( $ arr ) ; if ( isProduct ( $ arr , $ n , $ x ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ x = 190 ; if ( isProduct ( $ arr , $ n , $ x ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Find pair with greatest product in array | Function to find greatest number ; Driver code","code":"< ? php function findGreatest ( $ arr , $ n ) { $ result = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ j ] * $ arr [ $ k ] == $ arr [ $ i ] ) $ result = max ( $ result , $ arr [ $ i ] ) ; return $ result ; } $ arr = array ( 30 , 10 , 9 , 3 , 35 ) ; $ n = count ( $ arr ) ; echo findGreatest ( $ arr , $ n ) ; ? >"}
{"text":"Count pairs with given sum | Returns number of pairs in arr [ 0. . n - 1 ] with sum equal to ' sum ' ; Initialize result ; Consider all possible pairs and check their sums ; Driver Code","code":"< ? php function getPairsCount ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 5 , 7 , -1 , 5 ) ; $ n = sizeof ( $ arr ) ; $ sum = 6 ; echo \" Count \u2581 of \u2581 pairs \u2581 is \u2581 \" , getPairsCount ( $ arr , $ n , $ sum ) ; ? >"}
{"text":"Count pairs from two sorted arrays whose sum is equal to a given value x | function to count all pairs from both the sorted arrays whose sum is equal to a given value ; generating pairs from both the arrays ; if sum of pair is equal to ' x ' increment count ; required count of pairs ; Driver Code","code":"< ? php function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr1 [ $ i ] + $ arr2 [ $ j ] ) == $ x ) $ count ++ ; return $ count ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ arr2 = array ( 2 , 3 , 5 , 8 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; $ x = 10 ; echo \" Count \u2581 = \u2581 \" , countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) ; ? >"}
{"text":"Count pairs from two sorted arrays whose sum is equal to a given value x | function to search ' value ' in the given array ' arr [ ] ' it uses binary search technique as ' arr [ ] ' is sorted ; value found ; value not found ; function to count all pairs from both the sorted arrays whose sum is equal to a given value ; for each arr1 [ i ] ; check if the ' value ' is present in ' arr2 [ ] ' ; required count of pairs ; Driver Code","code":"< ? php function isPresent ( $ arr , $ low , $ high , $ value ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) \/ 2 ; if ( $ arr [ $ mid ] == $ value ) return true ; else if ( $ arr [ $ mid ] > $ value ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return false ; } function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ value = $ x - $ arr1 [ $ i ] ; if ( isPresent ( $ arr2 , 0 , $ n - 1 , $ value ) ) $ count ++ ; } return $ count ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ arr2 = array ( 2 , 3 , 5 , 8 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; $ x = 10 ; echo \" Count \u2581 = \u2581 \" , countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) ; ? >"}
{"text":"Count pairs from two sorted arrays whose sum is equal to a given value x | function to count all pairs from both the sorted arrays whose sum is equal to a given value ; traverse ' arr1 [ ] ' from left to right traverse ' arr2 [ ] ' from right to left ; if this sum is equal to ' x ' , then increment ' l ' , decrement ' r ' and increment ' count ' ; if this sum is less than x , then increment l ; else decrement ' r ' ; required count of pairs ; Driver Code","code":"< ? php function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) == $ x ) { $ l ++ ; $ r -- ; $ count ++ ; } else if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) < $ x ) $ l ++ ; else $ r -- ; } return $ count ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ arr2 = array ( 2 , 3 , 5 , 8 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; $ x = 10 ; echo \" Count \u2581 = \u2581 \" , countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) ; ? >"}
{"text":"Count quadruples from four sorted arrays whose sum is equal to a given value x | find the ' value ' in the given array ' arr [ ] ' binary search technique is applied ; ' value ' found ; ' value ' not found ; function to count all quadruples from four sorted arrays whose sum is equal to a given value x ; generate all triplets from the 1 st three arrays ; calculate the sum of elements in the triplet so generated ; check if ' x - T ' is present in 4 th array or not ; increment count ; required count of quadruples ; four sorted arrays each of size ' n '","code":"< ? php function isPresent ( $ arr , $ low , $ high , $ value ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) \/ 2 ; if ( $ arr [ $ mid ] == $ value ) return true ; else if ( $ arr [ $ mid ] > $ value ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return false ; } function countQuadruples ( $ arr1 , $ arr2 , $ arr3 , $ arr4 , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { $ T = $ arr1 [ $ i ] + $ arr2 [ $ j ] + $ arr3 [ $ k ] ; if ( isPresent ( $ arr4 , 0 , $ n , $ x - $ T ) ) $ count ++ ; } return $ count ; } $ arr1 = array ( 1 , 4 , 5 , 6 ) ; $ arr2 = array ( 2 , 3 , 7 , 8 ) ; $ arr3 = array ( 1 , 4 , 6 , 10 ) ; $ arr4 = array ( 2 , 4 , 7 , 8 ) ; $ n = sizeof ( $ arr1 ) ; $ x = 30 ; echo \" Count = \" ? >"}
{"text":"Count pairs whose products exist in array | Returns count of pairs whose product exists in arr [ ] ; find product in an array ; if product found increment counter ; return Count of all pair whose product exist in array ; Driver Code","code":"< ? php function countPairs ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ product = $ arr [ $ i ] * $ arr [ $ j ] ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ k ] == $ product ) { $ result ++ ; break ; } } } } return $ result ; } $ arr = array ( 6 , 2 , 4 , 12 , 5 , 3 ) ; $ n = sizeof ( $ arr ) ; echo countPairs ( $ arr , $ n ) ;"}
{"text":"Master Theorem For Subtract and Conquer Recurrences | PHP code for the above approach ; Driver Code","code":"< ? php function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; } $ n = 9 ; echo fib ( $ n ) ; ? >"}
{"text":"Tail Recursion | A tail recursive function to calculate factorial ; A wrapper over factTR ; Driver program to test above function","code":"< ? php function factTR ( $ n , $ a ) { if ( $ n == 0 ) return $ a ; return factTR ( $ n - 1 , $ n * $ a ) ; } function fact ( $ n ) { return factTR ( $ n , 1 ) ; } echo fact ( 5 ) ; ? >"}
{"text":"Given two unsorted arrays , find all pairs whose sum is x | Function to print all pairs in both arrays whose sum is equal to given value x ; Driver code","code":"< ? php function findPairs ( $ arr1 , $ arr2 , $ n , $ m , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ arr1 [ $ i ] + $ arr2 [ $ j ] == $ x ) echo $ arr1 [ $ i ] . \" \u2581 \" . $ arr2 [ $ j ] . \" STRNEWLINE \" ; } $ arr1 = array ( 1 , 2 , 3 , 7 , 5 , 4 ) ; $ arr2 = array ( 0 , 7 , 4 , 3 , 2 , 1 ) ; $ n = count ( $ arr1 ) ; $ m = count ( $ arr2 ) ; $ x = 8 ; findPairs ( $ arr1 , $ arr2 , $ n , $ m , $ x ) ; ? >"}
{"text":"Find pairs in array whose sums already exist in array | Function to find pair whose sum exists in arr [ ] ; Driver code","code":"< ? php function findPair ( $ arr , $ n ) { $ found = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] == $ arr [ $ k ] ) { echo $ arr [ $ i ] , \" \u2581 \" , $ arr [ $ j ] ; $ found = true ; } } } } if ( $ found == false ) echo \" Not \u2581 exist \" ; } $ arr = array ( 10 , 4 , 8 , 13 , 5 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; findPair ( $ arr , $ n ) ; ? >"}
{"text":"Find all pairs ( a , b ) in an array such that a % b = k | Function to find pair such that ( a % b = k ) ; Consider each and every pair ; Print if their modulo equals to k ; Driver Code","code":"< ? php function printPairs ( $ arr , $ n , $ k ) { $ isPairFound = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i != $ j && $ arr [ $ i ] % $ arr [ $ j ] == $ k ) { echo \" ( \" , $ arr [ $ i ] , \" , \u2581 \" , $ arr [ $ j ] , \" ) \" , \" \u2581 \" ; $ isPairFound = true ; } } } return $ isPairFound ; } $ arr = array ( 2 , 3 , 5 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; if ( printPairs ( $ arr , $ n , $ k ) == false ) echo \" No \u2581 such \u2581 pair \u2581 exists \" ; ? >"}
{"text":"Return maximum occurring character in an input string | PHP program to output the maximum occurring character in a string ; Create array to keep the count of individual characters and initialize the array as 0 ; Construct character count array from the input string . ; Initialize max count ; Traversing through the string and maintaining the count of each character ; Driver Code","code":"< ? php $ ASCII_SIZE = 256 ; function getMaxOccuringChar ( $ str ) { global $ ASCII_SIZE ; $ count = array_fill ( 0 , $ ASCII_SIZE , NULL ) ; $ len = strlen ( $ str ) ; $ max = 0 ; for ( $ i = 0 ; $ i < ( $ len ) ; $ i ++ ) { $ count [ ord ( $ str [ $ i ] ) ] ++ ; if ( $ max < $ count [ ord ( $ str [ $ i ] ) ] ) { $ max = $ count [ ord ( $ str [ $ i ] ) ] ; $ result = $ str [ $ i ] ; } } return $ result ; } $ str = \" sample \u2581 string \" ; echo \" Max \u2581 occurring \u2581 character \u2581 is \u2581 \" . getMaxOccuringChar ( $ str ) ; ? >"}
{"text":"Non | Simple PHP program to find first non - repeating element . ; Driver code","code":"< ? php function firstNonRepeating ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && $ arr [ $ i ] == $ arr [ $ j ] ) break ; if ( $ j == $ n ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 9 , 4 , 9 , 6 , 7 , 4 ) ; $ n = sizeof ( $ arr ) ; echo firstNonRepeating ( $ arr , $ n ) ; ? >"}
{"text":"Subarray with no pair sum divisible by K | function to find the subarray with no pair sum divisible by k ; hash table to store the remainders obtained on dividing by K ; s : starting index of the current subarray , e : ending index of the current subarray , maxs : starting index of the maximum size subarray so far , maxe : ending index of the maximum size subarray so far ; insert the first element in the set ; Removing starting elements of current subarray while there is an element in set which makes a pair with mod [ i ] such that the pair sum is divisible . ; include the current element in the current subarray the ending index of the current subarray increments by one ; compare the size of the current subarray with the maximum size so far ; Driver Code","code":"< ? php function subarrayDivisibleByK ( $ arr , $ n , $ k ) { $ mp = array_fill ( 0 , 1000 , 0 ) ; $ s = 0 ; $ e = 0 ; $ maxs = 0 ; $ maxe = 0 ; $ mp [ $ arr [ 0 ] % $ k ] ++ ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ mod = $ arr [ $ i ] % $ k ; while ( $ mp [ $ k - $ mod ] != 0 || ( $ mod == 0 && $ mp [ $ mod ] != 0 ) ) { $ mp [ $ arr [ $ s ] % $ k ] -- ; $ s ++ ; } $ mp [ $ mod ] ++ ; $ e ++ ; if ( ( $ e - $ s ) > ( $ maxe - $ maxs ) ) { $ maxe = $ e ; $ maxs = $ s ; } } echo ( \" The \u2581 maximum \u2581 size \u2581 is \u2581 \" . ( $ maxe - $ maxs + 1 ) . \" \u2581 and \u2581 the \u2581 subarray \u2581 is \" . \" \u2581 as \u2581 follows STRNEWLINE \" ) ; for ( $ i = $ maxs ; $ i <= $ maxe ; $ i ++ ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; } $ k = 3 ; $ arr = array ( 5 , 10 , 15 , 20 , 25 ) ; $ n = count ( $ arr ) ; subarrayDivisibleByK ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find three element from different three arrays such that a + b + c = sum | Function to check if there is an element from each array such that sum of the three elements is equal to given sum . ; Driver Code","code":"< ? php function findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) { for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n2 ; $ j ++ ) for ( $ k = 0 ; $ k < $ n3 ; $ k ++ ) if ( $ a1 [ $ i ] + $ a2 [ $ j ] + $ a3 [ $ k ] == $ sum ) return true ; return false ; } $ a1 = array ( 1 , 2 , 3 , 4 , 5 ) ; $ a2 = array ( 2 , 3 , 6 , 1 , 2 ) ; $ a3 = array ( 3 , 2 , 4 , 5 , 6 ) ; $ sum = 9 ; $ n1 = count ( $ a1 ) ; $ n2 = count ( $ a2 ) ; $ n3 = count ( $ a3 ) ; if ( findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum insertions to form a palindrome with permutations allowed | Function will return number of characters to be added ; To store string length ; To store number of characters occurring odd number of times ; To store count of each character ; To store occurrence of each character ; To count characters with odd occurrence ; As one character can be odd return res - 1 but if string is already palindrome return 0 ; Driver program","code":"< ? php function minInsertion ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; $ count = array ( 26 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ count [ $ i ] % 2 == 1 ) $ res ++ ; } return ( $ res == 0 ) ? 0 : $ res - 1 ; } $ str = \" geeksforgeeks \" ; echo ( minInsertion ( $ str ) ) ; ? >"}
{"text":"Difference between highest and least frequencies in an array | PHP code to find the difference between highest and least frequencies function that returns difference ; sort the array ; checking consecutive elements ; Driver Code","code":"< ? php function findDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; $ max_count = 0 ; $ min_count = $ n ; for ( $ i = 0 ; $ i < ( $ n - 1 ) ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count += 1 ; continue ; } else { $ max_count = max ( $ max_count , $ count ) ; $ min_count = min ( $ min_count , $ count ) ; $ count = 0 ; } } return ( $ max_count - $ min_count ) ; } $ arr = array ( 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 ) ; $ n = sizeof ( $ arr ) ; echo ( findDiff ( $ arr , $ n ) . \" \" ) ; ? >"}
{"text":"Maximum possible difference of two subsets of an array | function for maximum subset diff ; if frequency of any element is two make both equal to zero ; Driver Code","code":"< ? php function maxDiff ( $ arr , $ n ) { $ SubsetSum_1 = 0 ; $ SubsetSum_2 = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ isSingleOccurance = true ; for ( $ j = $ i + 1 ; $ j <= $ n - 1 ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) { $ isSingleOccurance = false ; $ arr [ $ i ] = $ arr [ $ j ] = 0 ; break ; } } if ( $ isSingleOccurance ) { if ( $ arr [ $ i ] > 0 ) $ SubsetSum_1 += $ arr [ $ i ] ; else $ SubsetSum_2 += $ arr [ $ i ] ; } } return abs ( $ SubsetSum_1 - $ SubsetSum_2 ) ; } $ arr = array ( 4 , 2 , -3 , 3 , -2 , -2 , 8 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum \u2581 Difference \u2581 = \u2581 \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text":"Maximum possible difference of two subsets of an array | function for maximum subset diff ; sort the array ; calculate the result ; check for last element ; return result ; Driver Code","code":"< ? php function maxDiff ( $ arr , $ n ) { $ result = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] ) $ result += abs ( $ arr [ $ i ] ) ; else $ i ++ ; } if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) $ result += abs ( $ arr [ $ n - 1 ] ) ; return $ result ; } $ arr = array ( 4 , 2 , -3 , 3 , -2 , -2 , 8 ) ; $ n = count ( $ arr ) ; echo \" Maximum \u2581 Difference \u2581 = \u2581 \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text":"Print all triplets in sorted array that form AP | Function to print all triplets in given sorted array that forms AP ; Use hash to find if there is a previous element with difference equal to arr [ j ] - arr [ i ] ; Driver code","code":"< ? php function printAllAPTriplets ( $ arr , $ n ) { $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; if ( in_array ( $ arr [ $ i ] - $ diff , $ arr ) ) echo ( ( $ arr [ $ i ] - $ diff ) . \" \" \u2581 . \u2581 $ arr [ $ i ] \u2581 . \u2581 \" \" \u2581 . \u2581 $ arr [ $ j ] \u2581 . \u2581 \" \" } array_push ( $ s , $ arr [ $ i ] ) ; } } $ arr = array ( 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ) ; $ n = count ( $ arr ) ; printAllAPTriplets ( $ arr , $ n ) ; ? >"}
{"text":"Print all triplets in sorted array that form AP | Function to print all triplets in given sorted array that forms AP ; Search other two elements of AP with arr [ i ] as middle . ; if a triplet is found ; Since elements are distinct , arr [ k ] and arr [ j ] cannot form any more triplets with arr [ i ] ; If middle element is more move to higher side , else move lower side . ; Driver code","code":"< ? php function findAllTriplets ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i - 1 , $ k = $ i + 1 ; $ j >= 0 && $ k < $ n { if ( $ arr [ $ j ] + $ arr [ $ k ] == 2 * $ arr [ $ i ] ) { echo $ arr [ $ j ] . \" \u2581 \" . $ arr [ $ i ] . \" \u2581 \" . $ arr [ $ k ] . \" STRNEWLINE \" ; $ k ++ ; $ j -- ; } else if ( $ arr [ $ j ] + $ arr [ $ k ] < 2 * $ arr [ $ i ] ) $ k ++ ; else $ j -- ; } } } $ arr = array ( 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ) ; $ n = count ( $ arr ) ; findAllTriplets ( $ arr , $ n ) ; ? >"}
{"text":"Count number of triplets with product equal to given number | Function to count such triplets ; Consider all triplets and count if their product is equal to m ; Driver code","code":"< ? php function countTriplets ( $ arr , $ n , $ m ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] == $ m ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 4 , 6 , 2 , 3 , 8 ) ; $ n = sizeof ( $ arr ) ; $ m = 24 ; echo countTriplets ( $ arr , $ n , $ m ) ; ? >"}
{"text":"Count of index pairs with equal elements in an array | Return the number of pairs with equal values . ; for each index i and j ; finding the index with same value but different index . ; Driven Code","code":"< ? php function countPairs ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ ans ++ ; return $ ans ; } $ arr = array ( 1 , 1 , 2 ) ; $ n = count ( $ arr ) ; echo countPairs ( $ arr , $ n ) ; ? >"}
{"text":"Queries to answer the number of ones and zero to the left of given index | Function to pre - calculate the left [ ] array ; Iterate in the binary array ; Initialize the number of 1 and 0 ; Increase the count ; Driver code ; Queries ; Solve queries","code":"< ? php function preCalculate ( $ binary , $ n ) { $ left = array ( ) ; $ count1 = 0 ; $ count0 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ left [ $ i ] = array ( $ count1 , $ count0 ) ; if ( $ binary [ $ i ] ) $ count1 ++ ; else $ count0 ++ ; } return $ left ; } $ binary = array ( 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ) ; $ n = count ( $ binary ) ; $ left = preCalculate ( $ binary , $ n ) ; $ queries = array ( 0 , 1 , 2 , 4 ) ; $ q = count ( $ queries ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo $ left [ $ queries [ $ i ] ] [ 0 ] , \" \u2581 ones \u2581 \" , $ left [ $ queries [ $ i ] ] [ 1 ] , \" \u2581 zeros STRNEWLINE \" ; ? >"}
{"text":"Partition the array into three equal sum segments | First segment 's end index ; Third segment 's start index ; This function returns true if the array can be divided into three equal sum segments ; Prefix Sum Array ; Suffix Sum Array ; Stores the total sum of the array ; We can also take pre [ pos2 - 1 ] - pre [ pos1 ] == total_sum \/ 3 here . ; Driver Code","code":"< ? php $ pos1 = -1 ; $ pos2 = -1 ; function equiSumUtil ( $ arr ) { global $ pos2 , $ pos1 ; $ n = count ( $ arr ) ; $ pre = array_fill ( 0 , $ n , 0 ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ pre [ $ i ] = $ sum ; } $ suf = array_fill ( 0 , $ n , 0 ) ; $ sum = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ sum += $ arr [ $ i ] ; $ suf [ $ i ] = $ sum ; } $ total_sum = $ sum ; $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ j - 1 ) { if ( $ pre [ $ i ] == $ total_sum \/ 3 ) { $ pos1 = $ i ; } if ( $ suf [ $ j ] == $ total_sum \/ 3 ) { $ pos2 = $ j ; } if ( $ pos1 != -1 && $ pos2 != -1 ) { if ( $ suf [ $ pos1 + 1 ] - $ suf [ $ pos2 ] == $ total_sum \/ 3 ) { return true ; } else { return false ; } } if ( $ pre [ $ i ] < $ suf [ $ j ] ) { $ i ++ ; } else { $ j -- ; } } return false ; } function equiSum ( $ arr ) { global $ pos2 , $ pos1 ; $ ans = equiSumUtil ( $ arr ) ; if ( $ ans ) { print ( \" First \u2581 Segment \u2581 : \u2581 \" ) ; for ( $ i = 0 ; $ i <= $ pos1 ; $ i ++ ) { print ( $ arr [ $ i ] . \" \" ) ; } print ( \" STRNEWLINE \" ) ; print ( \" Second \u2581 Segment \u2581 : \u2581 \" ) ; for ( $ i = $ pos1 + 1 ; $ i < $ pos2 ; $ i ++ ) { print ( $ arr [ $ i ] . \" \" ) ; } print ( \" STRNEWLINE \" ) ; print ( \" Third \u2581 Segment \u2581 : \u2581 \" ) ; for ( $ i = $ pos2 ; $ i < count ( $ arr ) ; $ i ++ ) { print ( $ arr [ $ i ] . \" \" ) ; } print ( \" STRNEWLINE \" ) ; } else { println ( \" Array \u2581 cannot \u2581 be \u2581 divided \u2581 into \u2581 \" , \" three \u2581 equal \u2581 sum \u2581 segments \" ) ; } } $ arr = array ( 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 ) ; equiSum ( $ arr ) ; ? >"}
{"text":"Leftmost and rightmost indices of the maximum and the minimum element of an array | Function to return the index of the rightmost minimum element from the array ; First element is the minimum in a sorted array ; While the elements are equal to the minimum update rightMin ; Final check whether there are any elements which are equal to the minimum ; Function to return the index of the leftmost maximum element from the array ; Last element is the maximum in a sorted array ; While the elements are equal to the maximum update leftMax ; Final check whether there are any elements which are equal to the maximum ; Driver code ; First element is the leftmost minimum in a sorted array ; Last element is the rightmost maximum in a sorted array","code":"< ? php function getRightMin ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; $ rightMin = 0 ; $ i = 1 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ min ) $ rightMin = $ i ; $ i *= 2 ; } $ i = $ rightMin + 1 ; while ( $ i < $ n && $ arr [ $ i ] == $ min ) { $ rightMin = $ i ; $ i ++ ; } return $ rightMin ; } function getLeftMax ( $ arr , $ n ) { $ max = $ arr [ $ n - 1 ] ; $ leftMax = $ n - 1 ; $ i = $ n - 2 ; while ( $ i > 0 ) { if ( $ arr [ $ i ] == $ max ) $ leftMax = $ i ; $ i \/= 2 ; } $ i = $ leftMax - 1 ; while ( $ i >= 0 && $ arr [ $ i ] == $ max ) { $ leftMax = $ i ; $ i -- ; } return $ leftMax ; } $ arr = array ( 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum \u2581 left \u2581 : \u2581 \" , 0 , \" STRNEWLINE \" ; echo \" Minimum \u2581 right \u2581 : \u2581 \" , getRightMin ( $ arr , $ n ) , \" STRNEWLINE \" ; echo \" Maximum \u2581 left \u2581 : \u2581 \" , getLeftMax ( $ arr , $ n ) , \" STRNEWLINE \" ; echo \" Maximum \u2581 right \u2581 : \u2581 \" , ( $ n - 1 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Elements to be added so that all elements of a range are present in array | Function to count numbers to be added ; Sort the array ; Check if elements are consecutive or not . If not , update count ; Driver code","code":"< ? php function countNum ( $ arr , $ n ) { $ count = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i + 1 ] - 1 ) $ count += $ arr [ $ i + 1 ] - $ arr [ $ i ] - 1 ; return $ count ; } $ arr = array ( 3 , 5 , 8 , 6 ) ; $ n = count ( $ arr ) ; echo countNum ( $ arr , $ n ) ; ? >"}
{"text":"Count subarrays with same even and odd elements | function that returns the count of subarrays that contain equal number of odd as well as even numbers ; initialize difference and answer with 0 ; initialize these auxiliary arrays with 0 ; since the difference is initially 0 , we have to initialize hash_positive [ 0 ] with 1 ; for loop to iterate through whole array ( zero - based indexing is used ) ; incrementing or decrementing difference based on arr [ i ] being even or odd , check if arr [ i ] is odd ; adding hash value of ' difference ' to our answer as all the previous occurrences of the same difference value will make even - odd subarray ending at index ' i ' . After that , we will increment hash array for that ' difference ' value for its occurrence at index ' i ' . if difference is negative then use hash_negative ; else use hash_positive ; return total number of even - odd subarrays ; Driver code ; Printing total number of even - odd subarrays","code":"< ? php function countSubarrays ( & $ arr , $ n ) { $ difference = 0 ; $ ans = 0 ; $ hash_positive = array_fill ( 0 , $ n + 1 , NULL ) ; $ hash_negative = array_fill ( 0 , $ n + 1 , NULL ) ; $ hash_positive [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & 1 == 1 ) $ difference ++ ; else $ difference -- ; if ( $ difference < 0 ) { $ ans += $ hash_negative [ - $ difference ] ; $ hash_negative [ - $ difference ] ++ ; } else { $ ans += $ hash_positive [ $ difference ] ; $ hash_positive [ $ difference ] ++ ; } } return $ ans ; } $ arr = array ( 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ) ; $ n = sizeof ( $ arr ) ; echo \" Total \u2581 Number \u2581 of \u2581 Even - Odd \u2581 subarrays \" . \" \u2581 are \u2581 \" . countSubarrays ( $ arr , $ n ) ; ? >"}
{"text":"Saddleback Search Algorithm in a 2D array | PHP program to search an element in row - wise and column - wise sorted matrix ; Searches the element x in mat [ m ] [ n ] . If the element is found , then prints its position and returns true , otherwise prints \" not \u2581 found \" and returns false ; set indexes for bottom left element ; if mat [ i ] [ j ] < x ; Driver Code","code":"< ? php $ MAX = 100 ; function search ( $ mat , $ m , $ n , $ x ) { $ i = $ m - 1 ; $ j = 0 ; while ( $ i >= 0 && $ j < $ n ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) return true ; if ( $ mat [ $ i ] [ $ j ] > $ x ) $ i -- ; else $ j ++ ; } return false ; } $ mat = array ( array ( 10 , 20 , 30 , 40 ) , array ( 15 , 25 , 35 , 45 ) , array ( 27 , 29 , 37 , 48 ) , array ( 32 , 33 , 39 , 50 ) , array ( 50 , 60 , 70 , 80 ) ) ; if ( search ( $ mat , 5 , 4 , 29 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Number of Larger Elements on right side in a string | PHP program to find counts of right greater characters for every character . ; Driver code","code":"< ? php function printGreaterCount ( $ str ) { $ len = strlen ( $ str ) ; $ right = array_fill ( 0 , $ len , 0 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) if ( $ str [ $ i ] < $ str [ $ j ] ) $ right [ $ i ] ++ ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) echo $ right [ $ i ] . \" \u2581 \" ; } $ str = ' bcd ' printGreaterCount ( $ str ) ; ? >"}
{"text":"N \/ 3 repeated number in an array with O ( 1 ) space | PHP program to find if any element appears more than n \/ 3. ; take the integers as the maximum value of integer hoping the integer would not be present in the array ; if this element is previously seen , increment count1 . ; if this element is previously seen , increment count2 . ; if current element is different from both the previously seen variables , decrement both the counts . ; Again traverse the array and find the actual counts . ; Driver code","code":"< ? php function appearsNBy3 ( $ arr , $ n ) { $ count1 = 0 ; $ count2 = 0 ; $ first = PHP_INT_MAX ; $ second = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ first == $ arr [ $ i ] ) $ count1 ++ ; else if ( $ second == $ arr [ $ i ] ) $ count2 ++ ; else if ( $ count1 == 0 ) { $ count1 ++ ; $ first = $ arr [ $ i ] ; } else if ( $ count2 == 0 ) { $ count2 ++ ; $ second = $ arr [ $ i ] ; } else { $ count1 -- ; $ count2 -- ; } } $ count1 = 0 ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ first ) $ count1 ++ ; else if ( $ arr [ $ i ] == $ second ) $ count2 ++ ; } if ( $ count1 > $ n \/ 3 ) return $ first ; if ( $ count2 > $ n \/ 3 ) return $ second ; return -1 ; } $ arr = array ( 1 , 2 , 3 , 1 , 1 ) ; $ n = count ( $ arr ) ; echo appearsNBy3 ( $ arr , $ n ) ; ? >"}
{"text":"Count pairs in array whose sum is divisible by 4 | Program to count pairs whose sum divisible by '4' ; Create a frequency array to count occurrences of all remainders when divided by 4 ; Count occurrences of all remainders ; If both pairs are divisible by '4' ; If both pairs are 2 modulo 4 ; If one of them is equal to 1 modulo 4 and the other is equal to 3 modulo 4 ; Driver code","code":"< ? php function count4Divisibiles ( $ arr , $ n ) { $ freq = array ( 0 , 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) ++ $ freq [ $ arr [ $ i ] % 4 ] ; $ ans = $ freq [ 0 ] * ( $ freq [ 0 ] - 1 ) \/ 2 ; $ ans += $ freq [ 2 ] * ( $ freq [ 2 ] - 1 ) \/ 2 ; $ ans += $ freq [ 1 ] * $ freq [ 3 ] ; return $ ans ; } $ arr = array ( 2 , 2 , 1 , 7 , 5 ) ; $ n = sizeof ( $ arr ) ; echo count4Divisibiles ( $ arr , $ n ) ; ? >"}
{"text":"Smallest number whose set bits are maximum in a given range | Returns smallest number whose set bits are maximum in given range . ; Initialize the maximum count and final answer as ' num ' ; Traverse for every bit of ' i ' number ; If count is greater than previous calculated max_count , update it ; Driver code","code":"< ? php function countMaxSetBits ( $ left , $ right ) { $ max_count = -1 ; $ num ; for ( $ i = $ left ; $ i <= $ right ; ++ $ i ) { $ temp = $ i ; $ cnt = 0 ; while ( $ temp ) { if ( $ temp & 1 ) ++ $ cnt ; $ temp >>= 1 ; } if ( $ cnt > $ max_count ) { $ max_count = $ cnt ; $ num = $ i ; } } return $ num ; } $ l = 1 ; $ r = 5 ; echo countMaxSetBits ( $ l , $ r ) , \" STRNEWLINE \" ; $ l = 1 ; $ r = 10 ; echo countMaxSetBits ( $ l , $ r ) ; ? >"}
{"text":"Recaman 's sequence | Prints first n terms of Recaman sequence ; First term of the sequence is always 0 ; Fill remaining terms using recursive formula . ; If arr [ i - 1 ] - i is negative or already exists . ; Driver Code","code":"< ? php function recaman ( $ n ) { $ arr [ 0 ] = 0 ; echo $ arr [ 0 ] , \" , \u2581 \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr = $ arr [ $ i - 1 ] - $ i ; $ j ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ j ] == $ curr ) $ curr < 0 ) { $ curr = $ arr [ $ i - 1 ] + $ i ; break ; } } $ arr [ $ i ] = $ curr ; echo $ arr [ $ i ] , \" , \u2581 \" ; } } $ n = 17 ; recaman ( $ n ) ; ? >"}
{"text":"Recaman 's sequence | Prints first n terms of Recaman sequence ; Print first term and store it in a hash ; Print remaining terms using recursive formula . ; If arr [ i - 1 ] - i is negative or already exists . ; Driver code","code":"< ? php function recaman ( $ n ) { if ( $ n <= 0 ) return ; print ( \"0 , \u2581 \" ) ; $ s = array ( ) ; array_push ( $ s , 0 ) ; $ prev = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr = $ prev - $ i ; if ( $ curr < 0 or in_array ( $ curr , $ s ) ) $ curr = $ prev + $ i ; array_push ( $ s , $ curr ) ; print ( $ curr . \" , \" ) ; $ prev = $ curr ; } } $ n = 17 ; recaman ( $ n ) ; ? >"}
{"text":"Maximum area rectangle by picking four sides from array | function for finding max area ; sort array in non - increasing order ; Initialize two sides of rectangle ; traverse through array ; if any element occurs twice store that as dimension ; return the product of dimensions ; Driver Code","code":"< ? php function findArea ( $ arr , $ n ) { rsort ( $ arr ) ; $ dimension = array ( 0 , 0 ) ; for ( $ i = 0 , $ j = 0 ; $ i < $ n - 1 && $ j < 2 ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ dimension [ $ j ++ ] = $ arr [ $ i ++ ] ; return ( $ dimension [ 0 ] * $ dimension [ 1 ] ) ; } $ arr = array ( 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 ) ; $ n = count ( $ arr ) ; echo findArea ( $ arr , $ n ) ; ? >"}
{"text":"Given a sorted and rotated array , find if there is a pair with a given sum | This function returns true if arr [ 0. . n - 1 ] has a pair with sum equals to x . ; Find the pivot element ; l is now index of smallest element ; r is now index of largest element ; Keep moving either l or r till they meet ; If we find a pair with sum x , we return true ; If current pair sum is less , move to the higher sum ; Move to the lower sum side ; Driver Code","code":"< ? php function pairInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) return true ; if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return false ; } $ arr = array ( 11 , 15 , 6 , 8 , 9 , 10 ) ; $ sum = 16 ; $ n = sizeof ( $ arr ) ; if ( pairInSortedRotated ( $ arr , $ n , $ sum ) ) echo \" Array \u2581 has \u2581 two \u2581 elements \u2581 \" . \" with \u2581 sum \u2581 16\" ; else echo \" Array \u2581 doesn ' t \u2581 have \u2581 two \u2581 \" . \" elements \u2581 with \u2581 sum \u2581 16 \u2581 \" ; ? >"}
{"text":"Given a sorted and rotated array , find if there is a pair with a given sum | This function returns count of number of pairs with sum equals to x . ; Find the pivot element . Pivot element is largest element of array . ; l is index of smallest element . ; r is index of largest element . ; Variable to store count of number of pairs . ; Find sum of pair formed by arr [ l ] and arr [ r ] and update l , r and cnt accordingly . ; If we find a pair with sum x , then increment cnt , move l and r to next element . ; This condition is required to be checked , otherwise l and r will cross each other and loop will never terminate . ; If current pair sum is less , move to the higher sum side . ; If current pair sum is greater , move to the lower sum side . ; Driver Code","code":"< ? php function pairsInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; $ cnt = 0 ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) { $ cnt ++ ; if ( $ l == ( $ r - 1 + $ n ) % $ n ) { return $ cnt ; } $ l = ( $ l + 1 ) % $ n ; $ r = ( $ r - 1 + $ n ) % $ n ; } else if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return $ cnt ; } $ arr = array ( 11 , 15 , 6 , 7 , 9 , 10 ) ; $ sum = 16 ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo pairsInSortedRotated ( $ arr , $ n , $ sum ) ; ? >"}
{"text":"Find maximum value of Sum ( i * arr [ i ] ) with only rotations on given array allowed | Returns max possible value of i * arr [ i ] ; Find array sum and i * arr [ i ] with no rotation Stores sum of arr [ i ] ; Stores sum of i * arr [ i ] ; Initialize result as 0 rotation sum ; Try all rotations one by one and find the maximum rotation sum . ; Return result ; Driver Code","code":"< ? php function maxSum ( $ arr , $ n ) { $ arrSum = 0 ; $ currVal = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arrSum = $ arrSum + $ arr [ $ i ] ; $ currVal = $ currVal + ( $ i * $ arr [ $ i ] ) ; } $ maxVal = $ currVal ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ currVal = $ currVal + $ arrSum - $ n * $ arr [ $ n - $ j ] ; if ( $ currVal > $ maxVal ) $ maxVal = $ currVal ; } return $ maxVal ; } $ arr = array ( 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; echo \" Max \u2581 sum \u2581 is \u2581 \" , maxSum ( $ arr , $ n ) ; ? >"}
{"text":"Maximum sum of i * arr [ i ] among all rotations of a given array | Returns maximum value of i * arr [ i ] ; Initialize result ; Consider rotation beginning with i for all possible values of i . ; Initialize sum of current rotation ; Compute sum of all values . We don 't actually rotate  the array, but compute sum  by finding indexes when  arr[i] is first element ; Update result if required ; Driver code","code":"< ? php function maxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ index = ( $ i + $ j ) % $ n ; $ curr_sum += $ j * $ arr [ $ index ] ; } $ res = max ( $ res , $ curr_sum ) ; } return $ res ; } $ arr = array ( 8 , 3 , 1 , 2 ) ; $ n = sizeof ( $ arr ) ; echo maxSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Maximum sum of i * arr [ i ] among all rotations of a given array | An efficient PHP program to compute maximum sum of i * arr [ i ] ; Compute sum of all array elements ; Compute sum of i * arr [ i ] for initial configuration . ; Initialize result ; Compute values for other iterations ; Compute next value using previous value in O ( 1 ) time ; Update current value ; Update result if required ; Driver code","code":"< ? php function maxSum ( $ arr , $ n ) { $ cum_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cum_sum += $ arr [ $ i ] ; $ curr_val = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ curr_val += $ i * $ arr [ $ i ] ; $ res = $ curr_val ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ next_val = $ curr_val - ( $ cum_sum - $ arr [ $ i - 1 ] ) + $ arr [ $ i - 1 ] * ( $ n - 1 ) ; $ curr_val = $ next_val ; $ res = max ( $ res , $ next_val ) ; } return $ res ; } $ arr = array ( 8 , 3 , 1 , 2 ) ; $ n = sizeof ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text":"Find the Rotation Count in Rotated Sorted array | Returns count of rotations for an array which is first sorted in ascending order , then rotated ; We basically find index of minimum element ; Driver code","code":"< ? php function countRotations ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; $ min_index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min > $ arr [ $ i ] ) { $ min = $ arr [ $ i ] ; $ min_index = $ i ; } } return $ min_index ; } $ arr = array ( 15 , 18 , 2 , 3 , 6 , 12 ) ; $ n = sizeof ( $ arr ) ; echo countRotations ( $ arr , $ n ) ; ? >"}
{"text":"Find the Rotation Count in Rotated Sorted array | Returns count of rotations for an array which is first sorted in ascending order , then rotated ; This condition is needed to handle the case when array is not rotated at all ; If there is only one element left ; Find mid ; Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 } ; Check if mid itself is minimum element ; Decide whether we need to go to left half or right half ; Driver code","code":"< ? php function countRotations ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return 0 ; if ( $ high == $ low ) return $ low ; $ mid = $ low + ( $ high - $ low ) \/ 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return ( int ) ( $ mid + 1 ) ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return ( int ) ( $ mid ) ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return countRotations ( $ arr , $ low , $ mid - 1 ) ; return countRotations ( $ arr , $ mid + 1 , $ high ) ; } $ arr = array ( 15 , 18 , 2 , 3 , 6 , 12 ) ; $ n = sizeof ( $ arr ) ; echo countRotations ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text":"Quickly find multiple left rotations of an array | Set 1 | Fills $temp with two copies of $arr ; Store $arr elements at i and i + n ; Function to left rotate an array k times ; Starting position of array after k rotations in temp [ ] will be k % n ; Print array after k rotations ; Driver Code","code":"< ? php function preprocess ( & $ arr , $ n , & $ temp ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ temp [ $ i ] = $ temp [ $ i + $ n ] = $ arr [ $ i ] ; } function leftRotate ( & $ arr , $ n , $ k , & $ temp ) { $ start = $ k % $ n ; for ( $ i = $ start ; $ i < $ start + $ n ; $ i ++ ) echo $ temp [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 1 , 3 , 5 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ temp [ 2 * $ n ] = array ( ) ; preprocess ( $ arr , $ n , $ temp ) ; $ k = 2 ; leftRotate ( $ arr , $ n , $ k , $ temp ) ; $ k = 3 ; leftRotate ( $ arr , $ n , $ k , $ temp ) ; $ k = 4 ; leftRotate ( $ arr , $ n , $ k , $ temp ) ; ? >"}
{"text":"Quickly find multiple left rotations of an array | Set 1 | Function to left rotate an array k times ; Print array after k rotations ; Driver program","code":"< ? php function leftRotate ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ k + $ n ; $ i ++ ) echo $ arr [ $ i % $ n ] , \" \u2581 \" ; } $ arr = array ( 1 , 3 , 5 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; leftRotate ( $ arr , $ n , $ k ) ; echo \" STRNEWLINE \" ; $ k = 3 ; leftRotate ( $ arr , $ n , $ k ) ; echo \" STRNEWLINE \" ; $ k = 4 ; leftRotate ( $ arr , $ n , $ k ) ; echo \" STRNEWLINE \" ; ? >"}
{"text":"Reversal algorithm for right rotation of an array | Function to reverse arr [ ] from index start to end ; Function to right rotate arr [ ] of size n by d ; function to print an array ; Driver code","code":"< ? php function reverseArray ( & $ arr , $ start , $ end ) { while ( $ start < $ end ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ end ] ; $ arr [ $ end ] = $ temp ; $ start ++ ; $ end -- ; } } function rightRotate ( & $ arr , $ d , $ n ) { reverseArray ( $ arr , 0 , $ n - 1 ) ; reverseArray ( $ arr , 0 , $ d - 1 ) ; reverseArray ( $ arr , $ d , $ n - 1 ) ; } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; rightRotate ( $ arr , $ k , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text":"Find a rotation with maximum hamming distance | Return the maximum hamming distance of a rotation ; arr [ ] to brr [ ] two times so that we can traverse through all rotations . ; We know hamming distance with 0 rotation would be 0. ; We try other rotations one by one and compute Hamming distance of every rotation ; We can never get more than n . ; Driver Code","code":"< ? php function maxHamming ( $ arr , $ n ) { $ brr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ n + $ i ] = $ arr [ $ i ] ; $ maxHam = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ currHam = 0 ; for ( $ j = $ i , $ k = 0 ; $ j < ( $ i + $ n ) ; $ j ++ , $ k ++ ) if ( $ brr [ $ j ] != $ arr [ $ k ] ) $ currHam ++ ; if ( $ currHam == $ n ) return $ n ; $ maxHam = max ( $ maxHam , $ currHam ) ; } return $ maxHam ; } $ arr = array ( 2 , 4 , 6 , 80 ) ; $ n = count ( $ arr ) ; echo maxHamming ( $ arr , $ n ) ; ? >"}
{"text":"Print left rotation of array in O ( n ) time and O ( 1 ) space | Function to leftRotate array multiple times ; To get the starting point of rotated array ; Prints the rotated array from start position ; Driver Code ; Function Call ; Function Call ; Function Call","code":"< ? php function leftRotate ( $ arr , $ n , $ k ) { $ mod = $ k % $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ ( $ mod + $ i ) % $ n ] ) , \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 1 , 3 , 5 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; leftRotate ( $ arr , $ n , $ k ) ; $ k = 3 ; leftRotate ( $ arr , $ n , $ k ) ; $ k = 4 ; leftRotate ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find element at given index after a number of rotations | Function to compute the element at given index ; Range [ left ... right ] ; Rotation will not have any effect ; Returning new element ; Driver Code ; No . of rotations ; Ranges according to 0 - based indexing","code":"< ? php function findElement ( $ arr , $ ranges , $ rotations , $ index ) { for ( $ i = $ rotations - 1 ; $ i >= 0 ; $ i -- ) { $ left = $ ranges [ $ i ] [ 0 ] ; $ right = $ ranges [ $ i ] [ 1 ] ; if ( $ left <= $ index && $ right >= $ index ) { if ( $ index == $ left ) $ index = $ right ; else $ index -- ; } } return $ arr [ $ index ] ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ rotations = 2 ; $ ranges = array ( array ( 0 , 2 ) , array ( 0 , 3 ) ) ; $ index = 1 ; echo findElement ( $ arr , $ ranges , $ rotations , $ index ) ; ? >"}
{"text":"Split the array and add the first part to the end | PHP program to split array and move first part to end . ; Rotate array by 1. ; Driver code","code":"< ? php function splitArr ( & $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ arr [ 0 ] ; for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ arr [ $ n - 1 ] = $ x ; } } $ arr = array ( 12 , 10 , 5 , 6 , 52 , 36 ) ; $ n = sizeof ( $ arr ) ; $ position = 2 ; splitArr ( $ arr , 6 , $ position ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Shell | Function to sort arr [ ] using Shell Metzner sort ; Set initial step size to the size of the array ; Step size decreases by half each time ; k is the upper limit for j ; j is the starting point ; i equals to smaller value ; l equals to larger value ; Compare and swap arr [ i ] with arr [ l ] ; Decrease smaller value by step size ; Increment the lower limit of i ; Function to print the contents of an array ; Driver code ; Sort the array using Shell Metzner Sort ; Print the sorted array","code":"< ? php function sort_shell_metzner ( $ arr , $ n ) { $ m = $ n ; while ( $ m > 0 ) { $ m = $ m \/ 2 ; $ k = $ n - $ m ; $ j = 0 ; do { $ i = $ j ; do { $ l = $ i + $ m ; if ( $ arr [ $ i ] > $ arr [ $ l ] ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ l ] ; $ arr [ $ l ] = $ temp ; $ i -= $ m ; } else break ; } while ( $ i >= 0 ) ; $ j ++ ; } while ( $ j <= $ k ) ; } return $ arr ; } function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ arr = array ( 0 , -2 , 8 , 5 , 1 ) ; $ n = count ( $ arr ) ; $ result_array = sort_shell_metzner ( $ arr , $ n ) ; printArray ( $ result_array , $ n ) ; ? >"}
{"text":"Rearrange array such that arr [ i ] >= arr [ j ] if i is even and arr [ i ] <= arr [ j ] if i is odd and j < i | function to rearrange the array ; total even positions ; total odd positions ; copy original array in an auxiliary array ; sort the auxiliary array ; fill up odd position in original array ; fill up even positions in original array ; display array ; Driver code","code":"< ? php function rearrangeArr ( & $ arr , $ n ) { $ evenPos = intval ( $ n \/ 2 ) ; $ oddPos = $ n - $ evenPos ; $ tempArr = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ tempArr [ $ i ] = $ arr [ $ i ] ; sort ( $ tempArr ) ; $ j = $ oddPos - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) { $ arr [ $ i ] = $ tempArr [ $ j ] ; $ j -- ; } $ j = $ oddPos ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) { $ arr [ $ i ] = $ tempArr [ $ j ] ; $ j ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; $ size = sizeof ( $ arr ) ; rearrangeArr ( $ arr , $ size ) ; ? >"}
{"text":"Maximum sum of absolute difference of any permutation | PHP implementation of above algorithm ; final sequence stored in the vector ; sort the original array so that we can retrieve the large elements from the end of array elements ; In this loop first we will insert one smallest element not entered till that time in final sequence and then enter a highest element ( not entered till that time ) in final sequence so that we have large difference value . This process is repeated till all array has completely entered in sequence . Here , we have loop till n \/ 2 because we are inserting two elements at a time in loop . ; If there are odd elements , push the middle element at the end . ; variable to store the maximum sum of absolute difference ; In this loop absolute difference of elements for the final sequence is calculated . ; absolute difference of last element and 1 st element ; return the value ; Driver Code","code":"< ? php function MaxSumDifference ( & $ a , $ n ) { $ finalSequence = array ( ) ; sort ( $ a ) ; for ( $ i = 0 ; $ i < $ n \/ 2 ; ++ $ i ) { array_push ( $ finalSequence , $ a [ $ i ] ) ; array_push ( $ finalSequence , $ a [ $ n - $ i - 1 ] ) ; } if ( $ n % 2 != 0 ) array_push ( $ finalSequence , $ a [ $ n - 1 ] ) ; $ MaximumSum = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ MaximumSum = $ MaximumSum + abs ( $ finalSequence [ $ i ] - $ finalSequence [ $ i + 1 ] ) ; } $ MaximumSum = $ MaximumSum + abs ( $ finalSequence [ $ n - 1 ] - $ finalSequence [ 0 ] ) ; return $ MaximumSum ; } $ a = array ( 1 , 2 , 4 , 8 ) ; $ n = sizeof ( $ a ) ; echo MaxSumDifference ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Minimum swaps required to bring all elements less than or equal to k together | Utility function to find minimum swaps required to club all elements less than or equals to k together ; Find count of elements which are less than equals to k ; Find unwanted elements in current window of size ' count ' ; Initialize answer with ' bad ' value of current window ; Decrement count of previous window ; Increment count of current window ; Update ans if count of ' bad ' is less in current window ; Driver code","code":"< ? php function minSwap ( $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] <= $ k ) ++ $ count ; $ bad = 0 ; for ( $ i = 0 ; $ i < $ count ; ++ $ i ) if ( $ arr [ $ i ] > $ k ) ++ $ bad ; $ ans = $ bad ; for ( $ i = 0 , $ j = $ count ; $ j < $ n ; ++ $ i , ++ $ j ) { if ( $ arr [ $ i ] > $ k ) -- $ bad ; if ( $ arr [ $ j ] > $ k ) ++ $ bad ; $ ans = min ( $ ans , $ bad ) ; } return $ ans ; } $ arr = array ( 2 , 1 , 5 , 6 , 3 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo ( minSwap ( $ arr , $ n , $ k ) . \" \" ) ; $ arr1 = array ( 2 , 7 , 9 , 5 , 8 , 7 , 4 ) ; $ n = sizeof ( $ arr1 ) ; $ k = 5 ; echo ( minSwap ( $ arr1 , $ n , $ k ) ) ; ? >"}
{"text":"Maximum product of subsequence of size k | Required function ; sorting given input array ; variable to store final product of all element of sub - sequence of size k ; CASE I If max element is 0 and k is odd then max product will be 0 ; CASE II If all elements are negative and k is odd then max product will be product of rightmost - subarray of size k ; else i is current left pointer index ; j is current right pointer index ; CASE III if k is odd and rightmost element in sorted array is positive then it must come in subsequence Multiplying A [ j ] with product and correspondingly changing j ; CASE IV Now k is even Now we deal with pairs Each time a pair is multiplied to product ie . . two elements are added to subsequence each time Effectively k becomes half Hence , k >>= 1 means k \/= 2 ; Now finding k corresponding pairs to get maximum possible value of product ; product from left pointers ; product from right pointers ; Taking the max product from two choices Correspondingly changing the pointer 's position ; Finally return product ; Driver Code","code":"< ? php function maxProductSubarrayOfSizeK ( $ A , $ n , $ k ) { sort ( $ A ) ; $ product = 1 ; if ( $ A [ $ n - 1 ] == 0 && ( $ k & 1 ) ) return 0 ; if ( $ A [ $ n - 1 ] <= 0 && ( $ k & 1 ) ) { for ( $ i = $ n - 1 ; $ i >= $ n - $ k ; $ i -- ) $ product *= $ A [ $ i ] ; return $ product ; } $ i = 0 ; $ j = $ n - 1 ; if ( $ k & 1 ) { $ product *= $ A [ $ j ] ; $ j -- ; $ k -- ; } $ k >>= 1 ; for ( $ itr = 0 ; $ itr < $ k ; $ itr ++ ) { $ left_product = $ A [ $ i ] * $ A [ $ i + 1 ] ; $ right_product = $ A [ $ j ] * $ A [ $ j - 1 ] ; if ( $ left_product > $ right_product ) { $ product *= $ left_product ; $ i += 2 ; } else { $ product *= $ right_product ; $ j -= 2 ; } } return $ product ; } $ A = array ( 1 , 2 , -1 , -3 , -6 , 4 ) ; $ n = count ( $ A ) ; $ k = 4 ; echo maxProductSubarrayOfSizeK ( $ A , $ n , $ k ) ; ? >"}
{"text":"Reorder an array according to given indexes | Function to reorder elements of arr [ ] according to index [ ] ; $temp [ $n ] ; arr [ i ] should be present at index [ i ] index ; Copy temp [ ] to arr [ ] ; Driver Code","code":"< ? php function reorder ( $ arr , $ index , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp [ $ index [ $ i ] ] = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = $ temp [ $ i ] ; $ index [ $ i ] = $ i ; } echo \" Reordered \u2581 array \u2581 is : \u2581 STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . \" \" ; } echo \" Modified Index array is : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ index [ $ i ] . \" \" ; } } $ arr = array ( 50 , 40 , 70 , 60 , 90 ) ; $ index = array ( 3 , 0 , 4 , 1 , 2 ) ; $ n = sizeof ( $ arr ) ; reorder ( $ arr , $ index , $ n ) ; ? >"}
{"text":"Count minimum number of subsets ( or subsequences ) with consecutive numbers | Returns count of subsets with consecutive numbers ; Sort the array so that elements which are consecutive in nature became consecutive in the array . ; Initialize result ; Check if there is beginning of another subset of consecutive number ; Driver Code","code":"< ? php function numofsubset ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; } return $ count ; } $ arr = array ( 100 , 56 , 5 , 6 , 102 , 58 , 101 , 57 , 7 , 103 , 59 ) ; $ n = sizeof ( $ arr ) ; echo numofsubset ( $ arr , $ n ) ; ? >"}
{"text":"Gnome Sort | A function to sort the algorithm using gnome sort ; Driver Code","code":"< ? php function gnomeSort ( $ arr , $ n ) { $ index = 0 ; while ( $ index < $ n ) { if ( $ index == 0 ) $ index ++ ; if ( $ arr [ $ index ] >= $ arr [ $ index - 1 ] ) $ index ++ ; else { $ temp = 0 ; $ temp = $ arr [ $ index ] ; $ arr [ $ index ] = $ arr [ $ index - 1 ] ; $ arr [ $ index - 1 ] = $ temp ; $ index -- ; } } echo \" Sorted \u2581 sequence \u2581 \" , \" after \u2581 Gnome \u2581 sort : \u2581 \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 34 , 2 , 10 , -9 ) ; $ n = count ( $ arr ) ; gnomeSort ( $ arr , $ n ) ; ? >"}
{"text":"Find the point where maximum intervals overlap | PHP Program to find maximum guest at any time in a party ; Sort arrival and exit arrays ; guests_in indicates number of guests at a time ; Similar to merge in merge sort to process all events in sorted order ; If next event in sorted order is arrival , increment count of guests ; Update max_guests if needed ; increment index of arrival array ; If event is exit , decrement count of guests . ; of guests . ; Driver Code","code":"< ? php function findMaxGuests ( $ arrl , $ exit , $ n ) { sort ( $ arrl ) ; sort ( $ exit ) ; $ guests_in = 1 ; $ max_guests = 1 ; $ time = $ arrl [ 0 ] ; $ i = 1 ; $ j = 0 ; while ( $ i < $ n and $ j < $ n ) { if ( $ arrl [ $ i ] <= $ exit [ $ j ] ) { $ guests_in ++ ; if ( $ guests_in > $ max_guests ) { $ max_guests = $ guests_in ; $ time = $ arrl [ $ i ] ; } $ i ++ ; } else { $ guests_in -- ; $ j ++ ; } } echo \" Maximum \u2581 Number \u2581 of \u2581 Guests \u2581 = \u2581 \" , $ max_guests , \" \u2581 at \u2581 time \u2581 \" , $ time ; } $ arr1 = array ( 1 , 2 , 10 , 5 , 5 ) ; $ exit = array ( 4 , 5 , 12 , 9 , 120 ) ; $ n = count ( $ arr1 ) ; findMaxGuests ( $ arr1 , $ exit , $ n ) ; ? >"}
{"text":"Find the point where maximum intervals overlap |  ; Finding maximum starting time O ( n ) ; Finding maximum ending time O ( n ) ; Creating and auxiliary array O ( n ) ; Lazy addition ; Lazily Calculating value at index i O ( n ) ; Driver code","code":"< ? php function maxOverlap ( $ start , $ end ) { $ n = count ( $ start ) ; $ maxa = max ( $ start ) ; $ maxb = max ( $ end ) ; $ maxc = max ( $ maxa , $ maxb ) ; $ x = array_fill ( 0 , $ maxc + 2 , 0 ) ; $ cur = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { ++ $ x [ $ start [ $ i ] ] ; -- $ x [ $ end [ $ i ] + 1 ] ; } $ maxy = - PHP_INT_MAX ; for ( $ i = 0 ; $ i <= $ maxc ; $ i ++ ) { $ cur += $ x [ $ i ] ; if ( $ maxy < $ cur ) { $ maxy = $ cur ; $ idx = $ i ; } } echo \" Maximum \u2581 value \u2581 is \u2581 \" . $ maxy . \" \u2581 at \u2581 position \u2581 \" . $ idx . \" STRNEWLINE \" ; } $ start = array ( 13 , 28 , 29 , 14 , 40 , 17 , 3 ) ; $ end = array ( 107 , 95 , 111 , 105 , 70 , 127 , 74 ) ; maxOverlap ( $ start , $ end ) ; ? >"}
{"text":"Rearrange an array in maximum minimum form | Set 1 | Prints max at first position , min at second position second max at third position , second min at fourth position and so on . ; Auxiliary array to hold modified array ; Indexes of smallest and largest elements from remaining array . ; To indicate whether we need to copy remaining largest or remaining smallest at next position ; Store result in temp [ ] ; Copy temp [ ] to arr [ ] ; Driver Code","code":"< ? php function rearrange ( & $ arr , $ n ) { $ temp = array ( ) ; $ small = 0 ; $ large = $ n - 1 ; $ flag = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ flag ) $ temp [ $ i ] = $ arr [ $ large -- ] ; else $ temp [ $ i ] = $ arr [ $ small ++ ] ; $ flag = ! $ flag ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; $ n = count ( $ arr ) ; echo \" Original \u2581 Arrayn STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; rearrange ( $ arr , $ n ) ; echo \" Modified Arrayn \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Rearrange an array in maximum minimum form | Set 2 ( O ( 1 ) extra space ) | Prints max at first position , min at second position second max at third position , second min at fourth position and so on . ; initialize index of first minimum and first maximum element ; store maximum element of array ; traverse array elements ; at even index : we have to put maximum element ; at odd index : we have to put minimum element ; array elements back to it 's original form ; Driver Code","code":"< ? php function rearrange ( & $ arr , $ n ) { $ max_idx = $ n - 1 ; $ min_idx = 0 ; $ max_elem = $ arr [ $ n - 1 ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ arr [ $ i ] += ( $ arr [ $ max_idx ] % $ max_elem ) * $ max_elem ; $ max_idx -- ; } else { $ arr [ $ i ] += ( $ arr [ $ min_idx ] % $ max_elem ) * $ max_elem ; $ min_idx ++ ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = ( int ) ( $ arr [ $ i ] \/ $ max_elem ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; echo \" Original \u2581 Array \" . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; rearrange ( $ arr , $ n ) ; echo \" Modified Array \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ;"}
{"text":"Move all negative numbers to beginning and positive to end with constant extra space | A PHP program to put all negative numbers before positive numbers ; A utility function to print an array ; Driver code","code":"< ? php function rearrange ( & $ arr , $ n ) { $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < 0 ) { if ( $ i != $ j ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; } $ j ++ ; } } } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( -1 , 2 , -3 , 4 , 5 , 6 , -7 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; rearrange ( $ arr , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text":"Move all negative elements to end in order with extra space allowed | Moves all - ve element to end of array in same order . ; Create an empty array to store result ; Traversal array and store + ve element in temp array index of temp ; If array contains all positive or all negative . ; Store - ve element in temp array ; Copy contents of temp [ ] to arr [ ] ; Driver Code","code":"< ? php function segregateElements ( & $ arr , $ n ) { $ temp = array ( 0 , $ n , NULL ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] >= 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; if ( $ j == $ n $ j == 0 ) return ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; } $ arr = array ( 1 , -1 , -3 , -2 , 7 , 5 , 11 , 6 ) ; $ n = sizeof ( $ arr ) ; segregateElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Rearrange array such that even index elements are smaller and odd index elements are greater | Swap ; Rearrange ; Utility that prints out an array in a line ; Driver Code","code":"< ? php function swap ( & $ a , & $ b ) { $ temp = $ a ; $ a = $ b ; $ b = $ temp ; } function rearrange ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ i % 2 == 0 && $ arr [ $ i ] > $ arr [ $ i + 1 ] ) swap ( $ arr [ $ i ] , $ arr [ $ i + 1 ] ) ; if ( $ i % 2 != 0 && $ arr [ $ i ] < $ arr [ $ i + 1 ] ) swap ( $ arr [ $ i ] , $ arr [ $ i + 1 ] ) ; } } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 6 , 4 , 2 , 1 , 8 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Before \u2581 rearranging : \u2581 STRNEWLINE \" ; printArray ( $ arr , $ n ) ; rearrange ( $ arr , $ n ) ; echo \" After \u2581 rearranging : \u2581 STRNEWLINE \" ; printArray ( $ arr , $ n ) ; ? >"}
{"text":"Positive elements at even and negative at odd positions ( Relative order not maintained ) | PHP program to rearrange positive and negative numbers ; Move forward the positive pointer till negative number number not encountered ; Move forward the negative pointer till positive number number not encountered ; Swap array elements to fix their position . ; Break from the while loop when any index exceeds the size of the array ; Driver code","code":"< ? php function rearrange ( & $ a , $ size ) { $ positive = 0 ; $ negative = 1 ; while ( true ) { while ( $ positive < $ size && $ a [ $ positive ] >= 0 ) $ positive += 2 ; while ( $ negative < $ size && $ a [ $ negative ] <= 0 ) $ negative += 2 ; if ( $ positive < $ size && $ negative < $ size ) { $ temp = $ a [ $ positive ] ; $ a [ $ positive ] = $ a [ $ negative ] ; $ a [ $ negative ] = $ temp ; } else break ; } } $ arr = array ( 1 , -3 , 5 , 6 , -3 , 6 , 7 , -4 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; rearrange ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Segregate even and odd numbers | Set 3 | Function to segregate even odd numbers ; Swapping even and odd numbers ; Printing segregated array ; Driver code","code":"< ? php function arrayEvenAndOdd ( $ arr , $ n ) { $ i = -1 ; $ j = 0 ; $ t ; while ( $ j != $ n ) { if ( $ arr [ $ j ] % 2 == 0 ) { $ i ++ ; $ x = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ x ; } $ j ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; arrayEvenAndOdd ( $ arr , $ n ) ; ? >"}
{"text":"Program to find largest element in an array | PHP function to find maximum in arr [ ] of size n ; Initialize maximum element ; Traverse array elements from second and compare every element with current max ; Driver Code","code":"< ? php function largest ( $ arr , $ n ) { $ i ; $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; return $ max ; } $ arr = array ( 10 , 324 , 45 , 90 , 9808 ) ; $ n = sizeof ( $ arr ) ; echo \" Largest \u2581 in \u2581 given \u2581 array \u2581 is \u2581 \" , largest ( $ arr , $ n ) ; ? >"}
{"text":"Program to find largest element in an array | returns maximum in arr [ ] of size n ; Driver Code","code":"< ? php function largest ( $ arr , $ n ) { return max ( $ arr ) ; } $ arr = array ( 10 , 324 , 45 , 90 , 9808 ) ; $ n = count ( $ arr ) ; echo largest ( $ arr , $ n ) ; ? >"}
{"text":"Program for Mean and median of an unsorted array | Function for calculating mean ; Function for calculating median ; First we sort the array ; check for even case ; Driver Code ; Function call","code":"< ? php function findMean ( & $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; return ( double ) $ sum \/ ( double ) $ n ; } function findMedian ( & $ a , $ n ) { sort ( $ a ) ; if ( $ n % 2 != 0 ) return ( double ) $ a [ $ n \/ 2 ] ; return ( double ) ( $ a [ ( $ n - 1 ) \/ 2 ] + $ a [ $ n \/ 2 ] ) \/ 2.0 ; } $ a = array ( 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ) ; $ n = sizeof ( $ a ) ; echo \" Mean \u2581 = \u2581 \" . findMean ( $ a , $ n ) . \" STRNEWLINE \" ; echo \" Median \u2581 = \u2581 \" . findMedian ( $ a , $ n ) ; ? >"}
{"text":"k smallest elements in same order using O ( 1 ) extra space | Function to print smallest k numbers in arr [ 0. . n - 1 ] ; For each arr [ i ] find whether it is a part of n - smallest with insertion sort concept ; find largest from first k - elements ; if largest is greater than arr [ i ] shift all element one place left ; make arr [ k - 1 ] = arr [ i ] ; print result ; Driver Code","code":"< ? php function printSmall ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ n ; ++ $ i ) { $ max_var = $ arr [ $ k - 1 ] ; $ pos = $ k - 1 ; for ( $ j = $ k - 2 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ j ] > $ max_var ) { $ max_var = $ arr [ $ j ] ; $ pos = $ j ; } } if ( $ max_var > $ arr [ $ i ] ) { $ j = $ pos ; while ( $ j < $ k - 1 ) { $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ j ++ ; } $ arr [ $ k - 1 ] = $ arr [ $ i ] ; } } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ arr = array ( 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ) ; $ n = count ( $ arr ) ; $ k = 5 ; printSmall ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find Second largest element in an array | Function to print the second largest elements ; There should be atleast two elements ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver Code","code":"< ? php function print2largest ( $ arr , $ arr_size ) { if ( $ arr_size < 2 ) { echo ( \" \u2581 Invalid \u2581 Input \u2581 \" ) ; return ; } $ first = $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] != $ first ) $ second = $ arr [ $ i ] ; } if ( $ second == PHP_INT_MIN ) echo ( \" There \u2581 is \u2581 no \u2581 second \u2581 largest \u2581 element STRNEWLINE \" ) ; else echo ( \" The \u2581 second \u2581 largest \u2581 element \u2581 is \u2581 \" . $ second . \" STRNEWLINE \" ) ; } $ arr = array ( 12 , 35 , 1 , 10 , 34 , 1 ) ; $ n = sizeof ( $ arr ) ; print2largest ( $ arr , $ n ) ; ? >"}
{"text":"Find sum of all nodes of the given perfect binary tree | function to find sum of all of the nodes of given perfect binary tree ; no of leaf nodes ; sum of nodes at last level ; sum of all nodes ; Driver Code","code":"< ? php function sumNodes ( $ l ) { $ leafNodeCount = ( $ l - 1 ) * ( $ l - 1 ) ; $ sumLastLevel = 0 ; $ sumLastLevel = ( $ leafNodeCount * ( $ leafNodeCount + 1 ) ) \/ 2 ; $ sum = $ sumLastLevel * $ l ; return $ sum ; } $ l = 3 ; echo ( sumNodes ( $ l ) ) ; ? >"}
{"text":"Constant time range add operation on an array | Utility method to add value val , to range [ lo , hi ] ; Utility method to get actual array from operation array ; convert array into prefix sum array ; method to print final updated array ; Driver Code ; Range add Queries","code":"< ? php function add ( & $ arr , $ N , $ lo , $ hi , $ val ) { $ arr [ $ lo ] += $ val ; if ( $ hi != $ N - 1 ) $ arr [ $ hi + 1 ] -= $ val ; } function updateArray ( & $ arr , $ N ) { for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ arr [ $ i ] += $ arr [ $ i - 1 ] ; } function printArr ( & $ arr , $ N ) { updateArray ( $ arr , $ N ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ N = 6 ; $ arr = array_fill ( 0 , $ N , NULL ) ; add ( $ arr , $ N , 0 , 2 , 100 ) ; add ( $ arr , $ N , 1 , 5 , 100 ) ; add ( $ arr , $ N , 2 , 3 , 100 ) ; printArr ( $ arr , $ N ) ; ? >"}
{"text":"Queries for GCD of all numbers of an array except elements in a given range | Calculating GCD using euclid algorithm ; Filling the prefix and suffix array ; Filling the prefix array following relation prefix ( i ) = GCD ( prefix ( i - 1 ) , arr ( i ) ) ; Filling the suffix array following the relation suffix ( i ) = GCD ( suffix ( i + 1 ) , arr ( i ) ) ; To calculate gcd of the numbers outside range ; If l = 0 , we need to tell GCD of numbers from r + 1 to n ; If r = n - 1 we need to return the gcd of numbers from 1 to l ; Driver Code","code":"< ? php function GCD ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return GCD ( $ b , $ a % $ b ) ; } function FillPrefixSuffix ( & $ prefix , & $ arr , & $ suffix , $ n ) { $ prefix [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prefix [ $ i ] = GCD ( $ prefix [ $ i - 1 ] , $ arr [ $ i ] ) ; $ suffix [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ suffix [ $ i ] = GCD ( $ suffix [ $ i + 1 ] , $ arr [ $ i ] ) ; } function GCDoutsideRange ( $ l , $ r , & $ prefix , & $ suffix , $ n ) { if ( $ l == 0 ) return $ suffix [ $ r + 1 ] ; if ( $ r == $ n - 1 ) return $ prefix [ $ l - 1 ] ; return GCD ( $ prefix [ $ l - 1 ] , $ suffix [ $ r + 1 ] ) ; } $ arr = array ( 2 , 6 , 9 ) ; $ n = sizeof ( $ arr ) ; $ prefix = array_fill ( 0 , $ n , NULL ) ; $ suffix = array_fill ( 0 , $ n , NULL ) ; FillPrefixSuffix ( $ prefix , $ arr , $ suffix , $ n ) ; $ l = 0 ; $ r = 0 ; echo GCDoutsideRange ( $ l , $ r , $ prefix , $ suffix , $ n ) . \" \" ; $ l = 1 ; $ r = 1 ; echo GCDoutsideRange ( $ l , $ r , $ prefix , $ suffix , $ n ) . \" \" ; $ l = 1 ; $ r = 2 ; echo GCDoutsideRange ( $ l , $ r , $ prefix , $ suffix , $ n ) . \" \" ; ? >"}
{"text":"Queries for counts of array elements with values in given range | function to count elements within given range ; initialize result ; check if element is in range ; Driver Code ; Answer queries","code":"< ? php function countInRange ( $ arr , $ n , $ x , $ y ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] >= $ x && $ arr [ $ i ] <= $ y ) $ count ++ ; } return $ count ; } $ arr = array ( 1 , 3 , 4 , 9 , 10 , 3 ) ; $ n = count ( $ arr ) ; $ i = 1 ; $ j = 4 ; echo countInRange ( $ arr , $ n , $ i , $ j ) . \" \" ; $ i = 9 ; $ j = 12 ; echo countInRange ( $ arr , $ n , $ i , $ j ) . \" \" ; ? >"}
{"text":"Queries for counts of array elements with values in given range | function to find first index >= x ; function to find last index <= y ; function to count elements within given range ; initialize result ; Driver Code ; Preprocess array ; Answer queries","code":"< ? php function lowerIndex ( $ arr , $ n , $ x ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ l <= $ h ) { $ mid = ( $ l + $ h ) \/ 2 ; if ( $ arr [ $ mid ] >= $ x ) $ h = $ mid - 1 ; else $ l = $ mid + 1 ; } return $ l ; } function upperIndex ( $ arr , $ n , $ y ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ l <= $ h ) { $ mid = ( $ l + $ h ) \/ 2 ; if ( $ arr [ $ mid ] <= $ y ) $ l = $ mid + 1 ; else $ h = $ mid - 1 ; } return $ h ; } function countInRange ( $ arr , $ n , $ x , $ y ) { $ count = 0 ; $ count = ( upperIndex ( $ arr , $ n , $ y ) - lowerIndex ( $ arr , $ n , $ x ) + 1 ) ; $ t = floor ( $ count ) ; return $ t ; } $ arr = array ( 1 , 4 , 4 , 9 , 10 , 3 ) ; $ n = sizeof ( $ arr ) ; sort ( $ arr ) ; $ i = 1 ; $ j = 4 ; echo countInRange ( $ arr , $ n , $ i , $ j ) , \" \" ; $ i = 9 ; $ j = 12 ; echo countInRange ( $ arr , $ n , $ i , $ j ) , \" \" ; ? >"}
{"text":"Queries for decimal values of subarrays of a binary array | Fills pre [ ] ; returns the number represented by a binary subarray l to r ; if r is equal to n - 1 r + 1 does not exist ; Driver Code","code":"< ? php function precompute ( & $ arr , $ n , & $ pre ) { $ pre [ $ n - 1 ] = $ arr [ $ n - 1 ] * pow ( 2 , 0 ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ pre [ $ i ] = $ pre [ $ i + 1 ] + $ arr [ $ i ] * ( 1 << ( $ n - 1 - $ i ) ) ; } function decimalOfSubarr ( & $ arr , $ l , $ r , $ n , & $ pre ) { if ( $ r != $ n - 1 ) return ( $ pre [ $ l ] - $ pre [ $ r + 1 ] ) \/ ( 1 << ( $ n - 1 - $ r ) ) ; return $ pre [ $ l ] \/ ( 1 << ( $ n - 1 - $ r ) ) ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; $ pre = array_fill ( 0 , $ n , NULL ) ; precompute ( $ arr , $ n , $ pre ) ; echo decimalOfSubarr ( $ arr , 2 , 4 , $ n , $ pre ) . \" \" ; echo decimalOfSubarr ( $ arr , 4 , 5 , $ n , $ pre ) . \" \" ; ? >"}
{"text":"Count elements which divide all numbers in range L | function to count element Time complexity O ( n ^ 2 ) worst case ; answer for query ; 0 based index ; iterate for all elements ; check if the element divides all numbers in range ; no of elements ; if all elements are divisible by a [ i ] ; answer for every query ; Driver Code","code":"< ? php function answerQuery ( $ a , $ n , $ l , $ r ) { $ count = 0 ; $ l = $ l - 1 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) { $ element = $ a [ $ i ] ; $ divisors = 0 ; for ( $ j = $ l ; $ j < $ r ; $ j ++ ) { if ( $ a [ $ j ] % $ a [ $ i ] == 0 ) $ divisors ++ ; else break ; } if ( $ divisors == ( $ r - $ l ) ) $ count ++ ; } return $ count ; } $ a = array ( 1 , 2 , 3 , 5 ) ; $ n = sizeof ( $ a ) ; $ l = 1 ; $ r = 4 ; echo answerQuery ( $ a , $ n , $ l , $ r ) . \" STRNEWLINE \" ; $ l = 2 ; $ r = 4 ; echo answerQuery ( $ a , $ n , $ l , $ r ) . \" STRNEWLINE \" ;"}
{"text":"Number whose sum of XOR with given array range is maximum | PHP program to find smallest integer X such that sum of its XOR with range is maximum . ; Function to make prefix array which counts 1 's of each bit up to that number ; Making a prefix array which sums number of 1 's up to  that position ; If j - th bit of a number is set then add one to previously counted 1 's ; Function to find X ; Initially taking maximum value all bits 1 ; Iterating over each bit ; get 1 ' s \u2581 at \u2581 ith \u2581 bit \u2581 between \u2581 the \u2581 \u2581 range \u2581 L - R \u2581 by \u2581 subtracting \u2581 1' s till Rth number - 1 's till L-1th number ; If 1 ' s \u2581 are \u2581 more \u2581 than \u2581 or \u2581 equal \u2581 \u2581 to \u2581 0' s then unset the ith bit from answer ; Set ith bit to 0 by doing Xor with 1 ; Driver Code","code":"< ? php $ one = array ( ) ; $ MAX = 2147483647 ; function make_prefix ( $ A , $ n ) { global $ one , $ MAX ; for ( $ j = 0 ; $ j < 32 ; $ j ++ ) $ one [ 0 ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ a = $ A [ $ i - 1 ] ; for ( $ j = 0 ; $ j < 32 ; $ j ++ ) { $ x = pow ( 2 , $ j ) ; if ( $ a & $ x ) $ one [ $ i ] [ $ j ] = 1 + $ one [ $ i - 1 ] [ $ j ] ; else $ one [ $ i ] [ $ j ] = $ one [ $ i - 1 ] [ $ j ] ; } } } function Solve ( $ L , $ R ) { global $ one , $ MAX ; $ l = $ L ; $ r = $ R ; $ tot_bits = $ r - $ l + 1 ; $ X = $ MAX ; for ( $ i = 0 ; $ i < 31 ; $ i ++ ) { $ x = $ one [ $ r ] [ $ i ] - $ one [ $ l - 1 ] [ $ i ] ; if ( $ x >= ( $ tot_bits - $ x ) ) { $ ith_bit = pow ( 2 , $ i ) ; $ X = $ X ^ $ ith_bit ; } } return $ X ; } $ n = 5 ; $ q = 3 ; $ A = [ 210 , 11 , 48 , 22 , 133 ] ; $ L = [ 1 , 4 , 2 ] ; $ R = [ 3 , 14 , 4 ] ; make_prefix ( $ A , $ n ) ; for ( $ j = 0 ; $ j < $ q ; $ j ++ ) echo ( Solve ( $ L [ $ j ] , $ R [ $ j ] ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Count of pairs from 1 to a and 1 to b whose sum is divisible by N | Function to find the distinct pairs from 1 - a & 1 - b such that their sum is divisible by n . ; Iterate over 1 to a to find distinct pairs ; For each integer from 1 to a b \/ n integers exists such that pair sum is divisible by n ; If ( i % n + b % n ) >= n one more pair is possible ; Return answer ; Driver code","code":"< ? php function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) { $ ans += ( int ) ( $ b \/ $ n ) ; $ ans += ( ( $ i % $ n ) + ( $ b % $ n ) ) >= $ n ? 1 : 0 ; } return $ ans ; } $ a = 5 ; $ b = 13 ; $ n = 3 ; echo findCountOfPairs ( $ a , $ b , $ n ) ; ? >"}
{"text":"Buy minimum items without change and given coins | See if we can buy less than 10 items Using 10 Rs coins and one r Rs coin ; We can always buy 10 items ; Driver Code","code":"< ? php function minItems ( $ k , $ r ) { for ( $ i = 1 ; $ i < 10 ; $ i ++ ) if ( ( $ i * $ k - $ r ) % 10 == 0 || ( $ i * $ k ) % 10 == 0 ) return $ i ; return 10 ; } $ k = 15 ; $ r = 2 ; echo minItems ( $ k , $ r ) ; ? >"}
{"text":"Number of indexes with equal elements in given range | function that answers every query in O ( r - l ) ; traverse from l to r and count the required indexes ; Driver Code ; 1 - st query ; 2 nd query","code":"< ? php function answer_query ( $ a , $ n , $ l , $ r ) { $ count = 0 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) if ( $ a [ $ i ] == $ a [ $ i + 1 ] ) $ count += 1 ; return $ count ; } $ a = array ( 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ) ; $ n = count ( $ a ) ; $ L = 1 ; $ R = 8 ; echo ( answer_query ( $ a , $ n , $ L , $ R ) . \" \" ) ; $ L = 0 ; $ R = 4 ; echo ( answer_query ( $ a , $ n , $ L , $ R ) . \" \" ) ; ? >"}
{"text":"Number of indexes with equal elements in given range | PHP program to count the number of indexes in range L R such that Ai = Ai + 1 ; array to store count of index from 0 to i that obey condition ; precomputing prefixans [ ] array ; traverse to compute the prefixans [ ] array ; function that answers every query in O ( 1 ) ; Driver Code ; pre - computation ; 1 - st query ; 2 nd query","code":"< ? php $ N = 1000 ; $ prefixans = array_fill ( 0 , $ N , 0 ) ; function countIndex ( $ a , $ n ) { global $ N , $ prefixans ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i + 1 ] ) $ prefixans [ $ i ] = 1 ; if ( $ i != 0 ) $ prefixans [ $ i ] += $ prefixans [ $ i - 1 ] ; } } function answer_query ( $ l , $ r ) { global $ N , $ prefixans ; if ( $ l == 0 ) return $ prefixans [ $ r - 1 ] ; else return ( $ prefixans [ $ r - 1 ] - $ prefixans [ $ l - 1 ] ) ; } $ a = array ( 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ) ; $ n = count ( $ a ) ; countIndex ( $ a , $ n ) ; $ L = 1 ; $ R = 8 ; echo ( answer_query ( $ L , $ R ) . \" \" ) ; $ L = 0 ; $ R = 4 ; echo ( answer_query ( $ L , $ R ) . \" \" ) ; ? >"}
{"text":"Count subarrays with Prime sum | Function to count subarrays with Prime sum ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Initialize result ; Traverse through the array ; return answer ; Driver program","code":"< ? php function primeSubarrays ( $ A , $ n ) { $ max_val = pow ( 10 , 5 ) ; $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ val = $ A [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { $ val += $ A [ $ j ] ; if ( $ prime [ $ val ] ) ++ $ cnt ; } } return $ cnt ; } $ A = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = count ( $ A ) ; echo primeSubarrays ( $ A , $ n ) ; ? >"}
{"text":"Total numbers with no repeated digits in a range | Function to check if the given number has repeated digit or not ; Traversing through each digit ; if the digit is present more than once in the number ; return 0 if the number has repeated digit ; return 1 if the number has no repeated digit ; Function to find total number in the given range which has no repeated digit ; Traversing through the range ; Add 1 to the answer if i has no repeated digit else 0 ; Driver Code ; Calling the calculate","code":"< ? php function repeated_digit ( $ n ) { $ c = 10 ; $ a = array_fill ( 0 , $ c , 0 ) ; while ( $ n > 0 ) { $ d = $ n % 10 ; if ( $ a [ $ d ] > 0 ) { return 0 ; } $ a [ $ d ] ++ ; $ n = ( int ) ( $ n \/ 10 ) ; } return 1 ; } function calculate ( $ L , $ R ) { $ answer = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { $ answer += repeated_digit ( $ i ) ; } return $ answer ; } $ L = 1 ; $ R = 100 ; echo calculate ( $ L , $ R ) ; ? >"}
{"text":"Minimum swaps required to make a binary string alternating | returns the minimum number of swaps of a binary string passed as the argument to make it alternating ; counts number of zeroes at odd and even positions ; counts number of ones at odd and even positions ; alternating string starts with 0 ; alternating string starts with 1 ; calculates the minimum number of swaps ; Driver code","code":"< ? php function countMinSwaps ( $ st ) { $ min_swaps = 0 ; $ odd_0 = 0 ; $ even_0 = 0 ; $ odd_1 = 0 ; $ even_1 = 0 ; $ n = strlen ( $ st ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { if ( $ st [ $ i ] == '1' ) { $ even_1 ++ ; } else { $ even_0 ++ ; } } else { if ( $ st [ $ i ] == '1' ) { $ odd_1 ++ ; } else { $ odd_0 ++ ; } } } $ cnt_swaps_1 = min ( $ even_0 , $ odd_1 ) ; $ cnt_swaps_2 = min ( $ even_1 , $ odd_0 ) ; return min ( $ cnt_swaps_1 , $ cnt_swaps_2 ) ; } $ st = \"000111\" ; echo ( countMinSwaps ( $ st ) ) ; ? >"}
{"text":"Find the value of the function Y = ( X ^ 6 + X ^ 2 + 9894845 ) % 971 | computing ( a ^ b ) % c ; Driver code","code":"< ? php function modpow ( $ base , $ exp , $ modulus ) { $ base %= $ modulus ; $ result = 1 ; while ( $ exp > 0 ) { if ( $ exp & 1 ) $ result = ( $ result * $ base ) % $ modulus ; $ base = ( $ base * $ base ) % $ modulus ; $ exp >>= 1 ; } return $ result ; } $ n = 654654 ; $ mod = 971 ; echo ( ( ( modpow ( $ n , 6 , $ mod ) + modpow ( $ n , 2 , $ mod ) ) % $ mod + 355 ) % $ mod ) ; ? >"}
{"text":"Largest Sum Contiguous Subarray | PHP program to print largest contiguous array sum ; Driver code","code":"< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = count ( $ a ) ; $ max_sum = maxSubArraySum ( $ a , $ n ) ; echo \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" , $ max_sum ; ? >"}
{"text":"Largest Sum Contiguous Subarray |  ; Do not compare for all elements . Compare only when max_ending_here > 0","code":"< ? php < ? php function maxSubArraySum ( & $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; else if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; } return $ max_so_far ; ? >"}
{"text":"Minimum rooms for m events of n batches with given schedule | Returns minimum number of rooms required to perform classes of n groups in m slots with given schedule . ; Store count of classes happening in every slot . ; initialize all values to zero ; Number of rooms required is equal to maximum classes happening in a particular slot . ; Driver Code","code":"< ? php function findMinRooms ( $ slots , $ n , $ m ) { $ counts = array_fill ( 0 , $ m , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ slots [ $ i ] [ $ j ] == '1' ) $ counts [ $ j ] ++ ; return max ( $ counts ) ; } $ n = 3 ; $ m = 7 ; $ slots = array ( \"0101011\" , \"0011001\" , \"0110111\" ) ; echo findMinRooms ( $ slots , $ n , $ m ) ; ? >"}
{"text":"Largest Sum Contiguous Subarray |  ; Driver Code","code":"< ? php < ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = sizeof ( $ a ) ; $ max_sum = maxSubArraySum ( $ a , $ n ) ; echo \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" . $ max_sum ; ? >"}
{"text":"Largest Sum Contiguous Subarray | PHP program to print largest contiguous array sum ; Driver Code","code":"< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; $ start = 0 ; $ end = 0 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here += $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) { $ max_so_far = $ max_ending_here ; $ start = $ s ; $ end = $ i ; } if ( $ max_ending_here < 0 ) { $ max_ending_here = 0 ; $ s = $ i + 1 ; } } echo \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" . $ max_so_far . \" STRNEWLINE \" ; echo \" Starting \u2581 index \u2581 \" . $ start . \" \" . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Ending index \" \u2581 . \u2581 $ end \u2581 . \u2581 \" \" } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = sizeof ( $ a ) ; $ max_sum = maxSubArraySum ( $ a , $ n ) ; ? >"}
{"text":"Find minimum number of currency notes and values that sum to given amount | function to count and prcurrency notes ; count notes using Greedy approach ; Print notes ; Driver Code","code":"< ? php function countCurrency ( $ amount ) { $ notes = array ( 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ) ; $ noteCounter = array ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { if ( $ amount >= $ notes [ $ i ] ) { $ noteCounter [ $ i ] = intval ( $ amount \/ $ notes [ $ i ] ) ; $ amount = $ amount - $ noteCounter [ $ i ] * $ notes [ $ i ] ; } } echo ( \" Currency \u2581 Count \u2581 - > \" . \" STRNEWLINE \" ) ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { if ( $ noteCounter [ $ i ] != 0 ) { echo ( $ notes [ $ i ] . \" : \" \u2581 . \u2581 $ noteCounter [ $ i ] \u2581 . \u2581 \" \" } } } $ amount = 868 ; countCurrency ( $ amount ) ; ? >"}
{"text":"Minimum sum by choosing minimum of pairs from array | Returns minimum possible sum in array B [ ] ; Driver Code","code":"< ? php function minSum ( $ A , $ n ) { $ min_val = min ( $ A ) ; return ( $ min_val * ( $ n - 1 ) ) ; } $ A = array ( 3 , 6 , 2 , 8 , 7 , 5 ) ; $ n = count ( $ A ) ; echo minSum ( $ A , $ n ) ; ? >"}
{"text":"Program for Next Fit algorithm in Memory Management | Function to allocate memory to blocks as per Next fit algorithm ; Stores block id of the block allocated to a process ; pick each process and find suitable blocks according to its size ad assign to it ; Do not start from beginning ; allocate block j to p [ i ] process ; Reduce available memory in this block . ; mod m will help in traversing the blocks from starting block after we reach the end . ; Driver program","code":"< ? php function NextFit ( $ blockSize , $ m , $ processSize , $ n ) { $ allocation = array_fill ( 0 , $ n , -1 ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ blockSize [ $ j ] >= $ processSize [ $ i ] ) { $ allocation [ $ i ] = $ j ; $ blockSize [ $ j ] -= $ processSize [ $ i ] ; break ; } $ j = ( $ j + 1 ) % $ m ; } } echo \" Process No . Process Size Block no . \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo \" \" . ( $ i \u2581 + \u2581 1 ) . \" \" . $ processSize [ $ i ] . \" \" if ( $ allocation [ $ i ] != -1 ) echo ( $ allocation [ $ i ] + 1 ) ; else echo \" Not \u2581 Allocated \" ; echo \" STRNEWLINE \" ; } } $ blockSize = array ( 5 , 10 , 20 ) ; $ processSize = array ( 10 , 20 , 5 ) ; $ m = count ( $ blockSize ) ; $ n = count ( $ processSize ) ; NextFit ( $ blockSize , $ m , $ processSize , $ n ) ; ? >"}
{"text":"Find the subarray with least average | Prints beginning and ending indexes of subarray of size k with minimum average ; k must be smaller than or equal to n ; Initialize beginning index of result ; Compute sum of first subarray of size k ; Initialize minimum sum as current sum ; Traverse from ( k + 1 ) ' th \u2581 element \u2581 \u2581 to \u2581 n ' th element ; Add current item and remove first item of previous subarray ; Update result if needed ; Driver Code ; Subarray size","code":"< ? php function findMinAvgSubarray ( $ arr , $ n , $ k ) { if ( $ n < $ k ) return ; $ res_index = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ curr_sum += $ arr [ $ i ] ; $ min_sum = $ curr_sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ curr_sum < $ min_sum ) { $ min_sum = $ curr_sum ; $ res_index = ( $ i - $ k + 1 ) ; } } echo \" Subarray between [ \" \u2581 , $ res _ index \u2581 , \u2581 \" , \" \u2581 , $ res _ index \u2581 + \u2581 $ k \u2581 - \u2581 1 , \u2581 \" ] has minimum average \" ; } $ arr = array ( 3 , 7 , 90 , 20 , 10 , 50 , 40 ) ; $ k = 3 ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; findMinAvgSubarray ( $ arr , $ n , $ k ) ; return 0 ; ? >"}
{"text":"Find element using minimum segments in Seven Segment Display | Precomputed values of segment used by digit 0 to 9. ; Return the number of segments used by x . ; Finding sum of the segment used by each digit of a number . ; Initialising the minimum segment and minimum number index . ; Finding and comparing segment used by each number arr [ i ] . ; If arr [ i ] used less segment then update minimum segment and minimum number . ; Driver Code","code":"< ? php $ seg = array ( 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ) ; function computeSegment ( $ x ) { global $ seg ; if ( $ x == 0 ) return $ seg [ 0 ] ; $ count = 0 ; while ( $ x ) { $ count += $ seg [ $ x % 10 ] ; $ x = ( int ) $ x \/ 10 ; } return $ count ; } function elementMinSegment ( $ arr , $ n ) { $ minseg = computeSegment ( $ arr [ 0 ] ) ; $ minindex = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ temp = computeSegment ( $ arr [ $ i ] ) ; if ( $ temp < $ minseg ) { $ minseg = $ temp ; $ minindex = $ i ; } } return $ arr [ $ minindex ] ; } $ arr = array ( 489 , 206 , 745 , 123 , 756 ) ; $ n = sizeof ( $ arr ) ; echo elementMinSegment ( $ arr , $ n ) , \" \" ; ? >"}
{"text":"Find the Largest number with given number of digits and sum of digits | Prints the smalles possible number with digit sum ' s ' and ' m ' number of digits . ; If sum of digits is 0 , then a number is possible only if number of digits is 1. ; Sum greater than the maximum possible sum . ; Fill from most significant digit to least significant digit . ; Fill 9 first to make the number largest ; If remaining sum becomes less than 9 , then fill the remaining sum ; Driver code","code":"< ? php function findLargest ( $ m , $ s ) { if ( $ s == 0 ) { if ( ( $ m == 1 ) == true ) echo \" Largest \u2581 number \u2581 is \u2581 \" , 0 ; else echo \" Not \u2581 possible \" ; return ; } if ( $ s > 9 * $ m ) { echo \" Not \u2581 possible \" ; return ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ s >= 9 ) { $ res [ $ i ] = 9 ; $ s -= 9 ; } else { $ res [ $ i ] = $ s ; $ s = 0 ; } } echo \" Largest \u2581 number \u2581 is \u2581 \" ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ res [ $ i ] ; } $ s = 9 ; $ m = 2 ; findLargest ( $ m , $ s ) ; ? >"}
{"text":"Minimum number of jumps to reach end | Returns minimum number of jumps to reach arr [ h ] from arr [ l ] ; Base case : when source and destination are same ; When nothing is reachable from the given source ; Traverse through all the points reachable from arr [ l ] . Recursively get the minimum number of jumps needed to reach arr [ h ] from these reachable points . ; Driver program to test above function","code":"< ? php function minJumps ( $ arr , $ l , $ h ) { if ( $ h == $ l ) return 0 ; if ( $ arr [ $ l ] == 0 ) return INT_MAX ; $ min = 999999 ; for ( $ i = $ l + 1 ; $ i <= $ h && $ i <= $ l + $ arr [ $ l ] ; $ i ++ ) { $ jumps = minJumps ( $ arr , $ i , $ h ) ; if ( $ jumps != 999999 && $ jumps + 1 < $ min ) $ min = $ jumps + 1 ; } return $ min ; } $ arr = array ( 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ) ; $ n = count ( $ arr ) ; echo \" Minimum \u2581 number \u2581 of \u2581 jumps \u2581 to \u2581 reach \u2581 \" . \" end \u2581 is \u2581 \" . minJumps ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text":"Minimum number of jumps to reach end | Returns Minimum number of jumps to reach end ; jumps [ 0 ] will hold the result ; Minimum number of jumps needed to reach last element from last elements itself is always 0 ; Start from the second element , move from right to left and construct the jumps [ ] array where jumps [ i ] represents minimum number of jumps needed to reach arr [ m - 1 ] from arr [ i ] ; If arr [ i ] is 0 then arr [ n - 1 ] can 't be reached from here ; If we can direcly reach to the end point from here then jumps [ i ] is 1 ; Otherwise , to find out the minimum number of jumps needed to reach arr [ n - 1 ] , check all the points reachable from here and jumps [ ] value for those points ; initialize min value ; following loop checks with all reachable points and takes the minimum ; Handle overflow ; or INT_MAX ; Driver Code","code":"< ? php function minJumps ( $ arr , $ n ) { $ jumps [ $ n ] = array ( ) ; $ min ; $ jumps [ $ n - 1 ] = array ( 0 ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] == 0 ) $ jumps [ $ i ] = PHP_INT_MAX ; else if ( $ arr [ $ i ] >= ( $ n - $ i ) - 1 ) $ jumps [ $ i ] = 1 ; else { $ min = PHP_INT_MAX ; for ( $ j = $ i + 1 ; $ j < $ n && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) { if ( $ min > $ jumps [ $ j ] ) $ min = $ jumps [ $ j ] ; } if ( $ min != PHP_INT_MAX ) $ jumps [ $ i ] = $ min + 1 ; else $ jumps [ $ i ] = $ min ; } } return $ jumps [ 0 ] ; } $ arr = array ( 1 , 3 , 6 , 1 , 0 , 9 ) ; $ size = sizeof ( $ arr ) ; echo \" Minimum \u2581 number \u2581 of \u2581 jumps \u2581 to \u2581 reach \" , \" \u2581 end \u2581 is \u2581 \" , minJumps ( $ arr , $ size ) ; ? >"}
{"text":"Smallest subarray with sum greater than a given value | Returns length of smallest subarray with sum greater than x . If there is no subarray with given sum , then returns n + 1 ; Initialize length of smallest subarray as n + 1 ; Pick every element as starting point ; Initialize sum starting with current start ; If first element itself is greater ; Try different ending points for curremt start ; add last element to current sum ; If sum becomes more than x and length of this subarray is smaller than current smallest length , update the smallest length ( or result ) ; Driver Code","code":"< ? php function smallestSubWithSum ( $ arr , $ n , $ x ) { $ min_len = $ n + 1 ; for ( $ start = 0 ; $ start < $ n ; $ start ++ ) { $ curr_sum = $ arr [ $ start ] ; if ( $ curr_sum > $ x ) return 1 ; for ( $ end = $ start + 1 ; $ end < $ n ; $ end ++ ) { $ curr_sum += $ arr [ $ end ] ; if ( $ curr_sum > $ x && ( $ end - $ start + 1 ) < $ min_len ) $ min_len = ( $ end - $ start + 1 ) ; } } return $ min_len ; } $ arr1 = array ( 1 , 4 , 45 , 6 , 10 , 19 ) ; $ x = 51 ; $ n1 = sizeof ( $ arr1 ) ; $ res1 = smallestSubWithSum ( $ arr1 , $ n1 , $ x ) ; if ( ( $ res1 == $ n1 + 1 ) == true ) echo \" Not \u2581 possible STRNEWLINE \" ; else echo $ res1 , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 10 , 5 , 2 , 7 ) ; $ n2 = sizeof ( $ arr2 ) ; $ x = 9 ; $ res2 = smallestSubWithSum ( $ arr2 , $ n2 , $ x ) ; if ( ( $ res2 == $ n2 + 1 ) == true ) echo \" Not \u2581 possible STRNEWLINE \" ; else echo $ res2 , \" STRNEWLINE \" ; $ arr3 = array ( 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ) ; $ n3 = sizeof ( $ arr3 ) ; $ x = 280 ; $ res3 = smallestSubWithSum ( $ arr3 , $ n3 , $ x ) ; if ( ( $ res3 == $ n3 + 1 ) == true ) echo \" Not \u2581 possible STRNEWLINE \" ; else echo $ res3 , \" STRNEWLINE \" ; ? >"}
{"text":"Smallest subarray with sum greater than a given value | Returns length of smallest subarray with sum greater than x . If there is no subarray with given sum , then returns n + 1 ; Initialize current sum and minimum length ; Initialize starting and ending indexes ; Keep adding array elements while current sum is smaller than or equal to x ; If current sum becomes greater than x . ; Update minimum length if needed ; remove starting elements ; Driver Code","code":"< ? php function smallestSubWithSum ( $ arr , $ n , $ x ) { $ curr_sum = 0 ; $ min_len = $ n + 1 ; $ start = 0 ; $ end = 0 ; while ( $ end < $ n ) { while ( $ curr_sum <= $ x && $ end < $ n ) $ curr_sum += $ arr [ $ end ++ ] ; while ( $ curr_sum > $ x && $ start < $ n ) { if ( $ end - $ start < $ min_len ) $ min_len = $ end - $ start ; $ curr_sum -= $ arr [ $ start ++ ] ; } } return $ min_len ; } $ arr1 = array ( 1 , 4 , 45 , 6 , 10 , 19 ) ; $ x = 51 ; $ n1 = sizeof ( $ arr1 ) ; $ res1 = smallestSubWithSum ( $ arr1 , $ n1 , $ x ) ; if ( $ res1 == $ n1 + 1 ) echo \" Not \u2581 possible STRNEWLINE \" ; else echo $ res1 , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 10 , 5 , 2 , 7 ) ; $ n2 = sizeof ( $ arr2 ) ; $ x = 9 ; $ res2 = smallestSubWithSum ( $ arr2 , $ n2 , $ x ) ; if ( $ res2 == $ n2 + 1 ) echo \" Not \u2581 possible STRNEWLINE \" ; else echo $ res2 , \" STRNEWLINE \" ; $ arr3 = array ( 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ) ; $ n3 = sizeof ( $ arr3 ) ; $ x = 280 ; $ res3 = smallestSubWithSum ( $ arr3 , $ n3 , $ x ) ; if ( $ res3 == $ n3 + 1 ) echo \" Not \u2581 possible STRNEWLINE \" ; else echo $ res3 , \" STRNEWLINE \" ; ? >"}
{"text":"Count minimum steps to get the given desired array | Returns count of minimum operations to convert a zero array to target array with increment and doubling operations . This function computes count by doing reverse steps , i . e . , convert target to zero array . ; Initialize result ( Count of minimum moves ) ; Keep looping while all elements of target don 't become 0. ; To store count of zeroes in current target array ; To find first odd element ; If odd number found ; If 0 , then increment zero_count ; All numbers are 0 ; All numbers are even ; Divide the whole array by 2 and increment result ; Make all odd numbers even by subtracting one and increment result . ; Driver Code","code":"< ? php function countMinOperations ( $ target , $ n ) { $ result = 0 ; while ( 1 ) { $ zero_count = 0 ; $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ target [ $ i ] & 1 ) break ; else if ( $ target [ $ i ] == 0 ) $ zero_count ++ ; } if ( $ zero_count == $ n ) return $ result ; if ( $ i == $ n ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ target [ $ j ] = $ target [ $ j ] \/ 2 ; $ result ++ ; } for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ target [ $ j ] & 1 ) { $ target [ $ j ] -- ; $ result ++ ; } } } } $ arr = array ( 16 , 16 , 16 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum \u2581 number \u2581 of \u2581 steps \u2581 required \u2581 to \u2581 STRNEWLINE \" . \" get \u2581 the \u2581 given \u2581 target \u2581 array \u2581 is \u2581 \" . countMinOperations ( $ arr , $ n ) ; ? >"}
{"text":"Find minimum number of merge operations to make an array palindrome | Returns minimum number of count operations required to make arr [ ] palindrome ; Initialize result ; Start from two corners ; If corner elements are same , problem reduces arr [ i + 1. . j - 1 ] ; If left element is greater , then we merge right two elements ; need to merge from tail . ; Else we merge left two elements ; Driver Code","code":"< ? php function findMinOps ( $ arr , $ n ) { $ ans = 1 ; for ( $ i = 0 , $ j = $ n - 1 ; $ i <= $ j { if ( $ arr [ $ i ] == $ arr [ $ j ] ) { $ i ++ ; $ j -- ; } else if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ j -- ; $ arr [ $ j ] += $ arr [ $ j + 1 ] ; $ ans ++ ; } else { $ i ++ ; $ arr [ $ i ] += $ arr [ $ i - 1 ] ; $ ans ++ ; } } return $ ans ; } $ arr [ ] = array ( 1 , 4 , 5 , 9 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Count \u2581 of \u2581 minimum \u2581 operations \u2581 is \u2581 \" , findMinOps ( $ arr , $ n ) ; ? >"}
{"text":"Find the smallest positive integer value that cannot be represented as sum of any subset of a given array | Returns the smallest number that cannot be represented as sum of subset of elements from set represented by sorted array arr [ 0. . n - 1 ] ; Initialize result ; Traverse the array and increment ' res ' if arr [ i ] is smaller than or equal to ' res ' . ; Driver Code","code":"< ? php function findSmallest ( $ arr , $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n and $ arr [ $ i ] <= $ res ; $ i ++ ) $ res = $ res + $ arr [ $ i ] ; return $ res ; } $ arr1 = array ( 1 , 3 , 4 , 5 ) ; $ n1 = count ( $ arr1 ) ; echo findSmallest ( $ arr1 , $ n1 ) , \" STRNEWLINE \" ; $ arr2 = array ( 1 , 2 , 6 , 10 , 11 , 15 ) ; $ n2 = count ( $ arr2 ) ; echo findSmallest ( $ arr2 , $ n2 ) , \" STRNEWLINE \" ; $ arr3 = array ( 1 , 1 , 1 , 1 ) ; $ n3 = count ( $ arr3 ) ; echo findSmallest ( $ arr3 , $ n3 ) , \" STRNEWLINE \" ; $ arr4 = array ( 1 , 1 , 3 , 4 ) ; $ n4 = count ( $ arr4 ) ; echo findSmallest ( $ arr4 , $ n4 ) ; ? >"}
{"text":"Find minimum difference between any two elements | Returns minimum difference between any pair ; Initialize difference as infinite ; Find the min diff by comparing difference of all possible pairs in given array ; Return min diff ; Driver code","code":"< ? php function findMinDiff ( $ arr , $ n ) { $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) < $ diff ) $ diff = abs ( $ arr [ $ i ] - $ arr [ $ j ] ) ; return $ diff ; } $ arr = array ( 1 , 5 , 3 , 19 , 18 , 25 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum \u2581 difference \u2581 is \u2581 \" , findMinDiff ( $ arr , $ n ) ; ? >"}
{"text":"Find minimum difference between any two elements | Returns minimum difference between any pair ; Sort array in non - decreasing order ; Initialize difference as infinite ; Find the min diff by comparing adjacent pairs in sorted array ; Return min diff ; Driver code","code":"< ? php function findMinDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i + 1 ] - $ arr [ $ i ] < $ diff ) $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; return $ diff ; } $ arr = array ( 1 , 5 , 3 , 19 , 18 , 25 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum \u2581 difference \u2581 is \u2581 \" , findMinDiff ( $ arr , $ n ) ; ? >"}
{"text":"Space optimization using bit manipulations | Driver Code ; Iterate through a to b , If it is a multiple of 2 or 5 Mark index in array as 1","code":"< ? php $ a = 2 ; $ b = 10 ; $ size = abs ( $ b - $ a ) + 1 ; $ array = array_fill ( 0 , $ size , 0 ) ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ i % 2 == 0 $ i % 5 == 0 ) $ array [ $ i - $ a ] = 1 ; echo \" MULTIPLES \u2581 of \u2581 2 \u2581 and \u2581 5 : STRNEWLINE \" ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ array [ $ i - $ a ] == 1 ) echo $ i . \" \" ; ? >"}
{"text":"Longest Span with same Sum in two Binary arrays | Returns length of the longest common subarray with same sum ; Initialize result ; One by one pick all possible starting points of subarrays ; Initialize sums of current subarrays ; Conider all points for starting with arr [ i ] ; Update sums ; If sums are same and current length is more than maxLen , update maxLen ; Driver Code","code":"< ? php function longestCommonSum ( $ arr1 , $ arr2 , $ n ) { $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ sum1 += $ arr1 [ $ j ] ; $ sum2 += $ arr2 [ $ j ] ; if ( $ sum1 == $ sum2 ) { $ len = $ j - $ i + 1 ; if ( $ len > $ maxLen ) $ maxLen = $ len ; } } } return $ maxLen ; } $ arr1 = array ( 0 , 1 , 0 , 1 , 1 , 1 , 1 ) ; $ arr2 = array ( 1 , 1 , 1 , 1 , 1 , 0 , 1 ) ; $ n = sizeof ( $ arr1 ) ; echo \" Length \u2581 of \u2581 the \u2581 longest \u2581 common \u2581 span \u2581 \" . \" with \u2581 same \u2581 \" , \" sum \u2581 is \u2581 \" , longestCommonSum ( $ arr1 , $ arr2 , $ n ) ; ? >"}
{"text":"Merge an array of size n into another array of size m + n | Assuming - 1 is filled for the places where element is not available ; Function to move m elements at the end of array mPlusN [ ] ; Merges array N [ ] of size n into array mPlusN [ ] of size m + n ; Current index of i \/ p part of mPlusN [ ] ; Current index of N [ ] ; Current index of output mPlusN [ ] ; Take an element from mPlusN [ ] if a ) value of the picked element is smaller and we have not reached end of it b ) We have reached end of N [ ] ; Otherwise take element from N [ ] ; Utility that prints out an array on a line ; Initialize arrays ; Move the m elements at the end of mPlusN ; Merge N [ ] into mPlusN [ ] ; Print the resultant mPlusN","code":"< ? php $ NA = -1 ; function moveToEnd ( & $ mPlusN , $ size ) { global $ NA ; $ j = $ size - 1 ; for ( $ i = $ size - 1 ; $ i >= 0 ; $ i -- ) if ( $ mPlusN [ $ i ] != $ NA ) { $ mPlusN [ $ j ] = $ mPlusN [ $ i ] ; $ j -- ; } } function merge ( & $ mPlusN , & $ N , $ m , $ n ) { $ i = $ n ; $ j = 0 ; $ k = 0 ; while ( $ k < ( $ m + $ n ) ) { if ( ( $ j == $ n ) || ( $ i < ( $ m + $ n ) && $ mPlusN [ $ i ] <= $ N [ $ j ] ) ) { $ mPlusN [ $ k ] = $ mPlusN [ $ i ] ; $ k ++ ; $ i ++ ; } else { $ mPlusN [ $ k ] = $ N [ $ j ] ; $ k ++ ; $ j ++ ; } } } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ mPlusN = array ( 2 , 8 , $ NA , $ NA , $ NA , 13 , $ NA , 15 , 20 ) ; $ N = array ( 5 , 7 , 9 , 25 ) ; $ n = sizeof ( $ N ) ; $ m = sizeof ( $ mPlusN ) - $ n ; moveToEnd ( $ mPlusN , $ m + $ n ) ; merge ( $ mPlusN , $ N , $ m , $ n ) ; printArray ( $ mPlusN , $ m + $ n ) ; ? >"}
{"text":"Sort 1 to N by swapping adjacent elements | Return true if array can be sorted otherwise false ; Check bool array B and sorts elements for continuous sequence of 1 ; Sort array A from i to j ; Check if array is sorted or not ; Driver Code","code":"< ? php function sortedAfterSwap ( $ A , $ B , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ B [ $ i ] ) { $ j = $ i ; while ( $ B [ $ j ] ) $ j ++ ; sort ( $ A ) ; $ i = $ j ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] != $ i + 1 ) return false ; } return true ; } $ A = array ( 1 , 2 , 5 , 3 , 4 , 6 ) ; $ B = array ( 0 , 1 , 1 , 1 , 0 ) ; $ n = count ( $ A ) ; if ( sortedAfterSwap ( $ A , $ B , $ n ) ) echo \" A \u2581 can \u2581 be \u2581 sorted STRNEWLINE \" ; else echo \" A \u2581 can \u2581 not \u2581 be \u2581 sorted STRNEWLINE \" ; ? >"}
{"text":"Sort 1 to N by swapping adjacent elements | Return true if array can be sorted otherwise false ; Check if array is sorted or not ; Driver Code","code":"< ? php function sortedAfterSwap ( & $ A , & $ B , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ B [ $ i ] ) { if ( $ A [ $ i ] != $ i + 1 ) { $ t = $ A [ $ i ] ; $ A [ $ i ] = $ A [ $ i + 1 ] ; $ A [ $ i + 1 ] = $ t ; } } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] != $ i + 1 ) return false ; } return true ; } $ A = array ( 1 , 2 , 5 , 3 , 4 , 6 ) ; $ B = array ( 0 , 1 , 1 , 1 , 0 ) ; $ n = sizeof ( $ A ) ; if ( sortedAfterSwap ( $ A , $ B , $ n ) ) echo \" A \u2581 can \u2581 be \u2581 sorted STRNEWLINE \" ; else echo \" A \u2581 can \u2581 not \u2581 be \u2581 sorted STRNEWLINE \" ; ? >"}
{"text":"Sort an array containing two types of elements | Method for segregation 0 and 1 given input array ; Driver Code","code":"< ? php function segregate0and1 ( $ arr , $ n ) { $ type0 = 0 ; $ type1 = $ n - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else { $ type0 ++ ; } } return $ arr ; } $ arr = array ( 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 ) ; $ n = count ( $ arr ) ; $ arr1 = segregate0and1 ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr1 [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Count Inversions in an array | Set 1 ( Using Merge Sort ) | PHP program to Count Inversions in an array ; Driver Code","code":"< ? php function getInvCount ( & $ arr , $ n ) { $ inv_count = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ inv_count ++ ; return $ inv_count ; } $ arr = array ( 1 , 20 , 6 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; echo \" Number \u2581 of \u2581 inversions \u2581 are \u2581 \" , getInvCount ( $ arr , $ n ) ; ? >"}
{"text":"Two elements whose sum is closest to zero | PHP program to find the Two elements whose sum is closest to zero ; Array should have at least two elements ; Initialization of values ; Driver Code","code":"< ? php function minAbsSumPair ( $ arr , $ arr_size ) { $ inv_count = 0 ; if ( $ arr_size < 2 ) { echo \" Invalid \u2581 Input \" ; return ; } $ min_l = 0 ; $ min_r = 1 ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; for ( $ l = 0 ; $ l < $ arr_size - 1 ; $ l ++ ) { for ( $ r = $ l + 1 ; $ r < $ arr_size ; $ r ++ ) { $ sum = $ arr [ $ l ] + $ arr [ $ r ] ; if ( abs ( $ min_sum ) > abs ( $ sum ) ) { $ min_sum = $ sum ; $ min_l = $ l ; $ min_r = $ r ; } } } echo \" The \u2581 two \u2581 elements \u2581 whose \u2581 sum \u2581 is \u2581 minimum \u2581 are \u2581 \" . $ arr [ $ min_l ] . \" \u2581 and \u2581 \" . $ arr [ $ min_r ] ; } $ arr = array ( 1 , 60 , -10 , 70 , -80 , 85 ) ; minAbsSumPair ( $ arr , 6 ) ; ? >"}
{"text":"Shortest Un | bool function for checking an array elements are in increasing . ; bool function for checking an array elements are in decreasing . ; increasing and decreasing are two functions . if function return true value then print 0 otherwise 3. ; Driver code","code":"< ? php function increasing ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ a [ $ i ] >= $ a [ $ i + 1 ] ) return false ; return true ; } function decreasing ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ a [ $ i ] < $ a [ $ i + 1 ] ) return false ; return true ; } function shortestUnsorted ( $ a , $ n ) { if ( increasing ( $ a , $ n ) == true || decreasing ( $ a , $ n ) == true ) return 0 ; else return 3 ; } $ ar = array ( 7 , 9 , 10 , 8 , 11 ) ; $ n = sizeof ( $ ar ) ; echo shortestUnsorted ( $ ar , $ n ) ; ? >"}
{"text":"Union and Intersection of two sorted arrays | Function prints union of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ] ; Print remaining elements of the larger array ; Driver Code","code":"< ? php function printUnion ( $ arr1 , $ arr2 , $ m , $ n ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) echo ( $ arr1 [ $ i ++ ] . \" \u2581 \" ) ; else if ( $ arr2 [ $ j ] < $ arr1 [ $ i ] ) echo ( $ arr2 [ $ j ++ ] . \" \u2581 \" ) ; else { echo ( $ arr2 [ $ j ++ ] . \" \" ) ; $ i ++ ; } } while ( $ i < $ m ) echo ( $ arr1 [ $ i ++ ] . \" \u2581 \" ) ; while ( $ j < $ n ) echo ( $ arr2 [ $ j ++ ] . \" \u2581 \" ) ; } $ arr1 = array ( 1 , 2 , 4 , 5 , 6 ) ; $ arr2 = array ( 2 , 3 , 5 , 7 ) ; $ m = sizeof ( $ arr1 ) ; $ n = sizeof ( $ arr2 ) ; printUnion ( $ arr1 , $ arr2 , $ m , $ n ) ; ? >"}
{"text":"Union and Intersection of two sorted arrays | Function prints Intersection of arr1 [ ] and arr2 [ ] m is the number of elements in arr1 [ ] n is the number of elements in arr2 [ ] ; Driver Code ; Function calling","code":"< ? php function printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ i ++ ; else if ( $ arr2 [ $ j ] < $ arr1 [ $ i ] ) $ j ++ ; else { echo $ arr2 [ $ j ] , \" \" ; $ i ++ ; $ j ++ ; } } } $ arr1 = array ( 1 , 2 , 4 , 5 , 6 ) ; $ arr2 = array ( 2 , 3 , 5 , 7 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) ; ? >"}
{"text":"Find Union and Intersection of two unsorted arrays | Prints union of arr1 [ 0. . m - 1 ] and arr2 [ 0. . n - 1 ] ; Before finding union , make sure arr1 [ 0. . m - 1 ] is smaller ; Now arr1 [ ] is smaller Sort the first array and print its elements ( these two steps can be swapped as order in output is not important ) ; Search every element of bigger array in smaller array and print the element if not found ; Prints intersection of arr1 [ 0. . m - 1 ] and arr2 [ 0. . n - 1 ] ; Before finding intersection , make sure arr1 [ 0. . m - 1 ] is smaller ; Now arr1 [ ] is smaller Sort smaller array arr1 [ 0. . m - 1 ] ; Search every element of bigger array in smaller array and print the element if found ; A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be presen in left subarray ; Else the element can only be present in right subarray ; We reach here when element is not present in array ; Driver program to test above function ; Function call","code":"< ? php function printUnion ( $ arr1 , $ arr2 , $ m , $ n ) { if ( $ m > $ n ) { $ tempp = $ arr1 ; $ arr1 = $ arr2 ; $ arr2 = $ tempp ; $ temp = $ m ; $ m = $ n ; $ n = $ temp ; } sort ( $ arr1 ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ arr1 [ $ i ] . \" \u2581 \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( binarySearch ( $ arr1 , 0 , $ m - 1 , $ arr2 [ $ i ] ) == -1 ) echo $ arr2 [ $ i ] . \" \u2581 \" ; } function printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) { if ( $ m > $ n ) { $ tempp = $ arr1 ; $ arr1 = $ arr2 ; $ arr2 = $ tempp ; $ temp = $ m ; $ m = $ n ; $ n = $ temp ; } sort ( $ arr1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( binarySearch ( $ arr1 , 0 , $ m - 1 , $ arr2 [ $ i ] ) != -1 ) echo $ arr2 [ $ i ] . \" \u2581 \" ; } function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = ( int ) ( $ l + ( $ r - $ l ) \/ 2 ) ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } $ arr1 = array ( 7 , 1 , 5 , 2 , 3 , 6 ) ; $ arr2 = array ( 3 , 8 , 6 , 20 , 7 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; echo \" Union \u2581 of \u2581 two \u2581 arrays \u2581 is \u2581 STRNEWLINE \" ; printUnion ( $ arr1 , $ arr2 , $ m , $ n ) ; echo \" Intersection of two arrays is \" ; printIntersection ( $ arr1 , $ arr2 , $ m , $ n ) ; ? >"}
{"text":"Find Union and Intersection of two unsorted arrays | Function to find intersection ; when both are equal ; Driver Code ; sort ; Function call","code":"< ? php function intersection ( $ a , $ b , $ n , $ m ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ n && $ j < $ m ) { if ( $ a [ $ i ] > $ b [ $ j ] ) { $ j ++ ; } else if ( $ b [ $ j ] > $ a [ $ i ] ) { $ i ++ ; } else { echo ( $ a [ $ i ] . \" \" ) ; $ i ++ ; $ j ++ ; } } } $ a = array ( 1 , 3 , 2 , 3 , 4 , 5 , 5 , 6 ) ; $ b = array ( 3 , 3 , 5 ) ; $ n = sizeof ( $ a ) ; $ m = sizeof ( $ b ) ; sort ( $ a ) ; sort ( $ b ) ; intersection ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text":"Sort an array of 0 s , 1 s and 2 s | UTILITY FUNCTIONS ; Sort the input array , the array is assumed to have values in { 0 , 1 , 2 } ; Utility function to print array arr [ ] ; Driver Code","code":"< ? php function swap ( & $ a , & $ b ) { $ temp = $ a ; $ a = $ b ; $ b = $ temp ; } function sort012 ( & $ a , $ arr_size ) { $ lo = 0 ; $ hi = $ arr_size - 1 ; $ mid = 0 ; while ( $ mid <= $ hi ) { switch ( $ a [ $ mid ] ) { case 0 : swap ( $ a [ $ lo ++ ] , $ a [ $ mid ++ ] ) ; break ; case 1 : $ mid ++ ; break ; case 2 : swap ( $ a [ $ mid ] , $ a [ $ hi -- ] ) ; break ; } } } function printArray ( & $ arr , $ arr_size ) { for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; sort012 ( $ arr , $ arr_size ) ; echo \" array \u2581 after \u2581 segregation \u2581 \" ; printArray ( $ arr , $ arr_size ) ; ? >"}
{"text":"Find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted | PHP program to find the Minimum length Unsorted Subarray , sorting which makes the complete array sorted ; step 1 ( a ) of above algo ; step 1 ( b ) of above algo ; step 2 ( a ) of above algo ; step 2 ( b ) of above algo ; step 2 ( c ) of above algo ; step 3 of above algo","code":"< ? php function printUnsorted ( & $ arr , $ n ) { $ s = 0 ; $ e = $ n - 1 ; for ( $ s = 0 ; $ s < $ n - 1 ; $ s ++ ) { if ( $ arr [ $ s ] > $ arr [ $ s + 1 ] ) break ; } if ( $ s == $ n - 1 ) { echo \" The \u2581 complete \u2581 array \u2581 is \u2581 sorted \" ; return ; } for ( $ e = $ n - 1 ; $ e > 0 ; $ e -- ) { if ( $ arr [ $ e ] < $ arr [ $ e - 1 ] ) break ; } $ max = $ arr [ $ s ] ; $ min = $ arr [ $ s ] ; for ( $ i = $ s + 1 ; $ i <= $ e ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ min ) $ min = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ s ; $ i ++ ) { if ( $ arr [ $ i ] > $ min ) { $ s = $ i ; break ; } } for ( $ i = $ n - 1 ; $ i >= $ e + 1 ; $ i -- ) { if ( $ arr [ $ i ] < $ max ) { $ e = $ i ; break ; } } echo \" \u2581 The \u2581 unsorted \u2581 subarray \u2581 which \u2581 makes \u2581 \" . \" the \u2581 given \u2581 array \u2581 \" . \" STRNEWLINE \" . \" \u2581 sorted \u2581 lies \u2581 between \u2581 the \u2581 indees \u2581 \" . $ s . \" \u2581 and \u2581 \" . $ e ; return ; } $ arr = array ( 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ) ; $ arr_size = sizeof ( $ arr ) ; printUnsorted ( $ arr , $ arr_size ) ; ? >"}
{"text":"Count the number of possible triangles | Function to count all possible triangles with arr [ ] element ; Sort the array elements in non - decreasing order ; Initialize count of triangles ; Fix the first element . We need to run till n - 3 as the other two elements are selected from arr [ i + 1. . . n - 1 ] ; Initialize index of the rightmost third element ; Fix the second element ; Find the rightmost element which is smaller than the sum of two fixed elements . The important thing to note here is , we use the previous value of k . If value of arr [ i ] + arr [ j - 1 ] was greater than arr [ k ] , then arr [ i ] + arr [ j ] must be greater than k , because the array is sorted . ; Total number of possible triangles that can be formed with the two fixed elements is k - j - 1. The two fixed elements are arr [ i ] and arr [ j ] . All elements between arr [ j + 1 ] to arr [ k - 1 ] can form a triangle with arr [ i ] and arr [ j ] . One is subtracted from k because k is incremented one extra in above while loop . k will always be greater than j . If j becomes equal to k , then above loop will increment k , because arr [ k ] + arr [ i ] is always \/ greater than arr [ k ] ; Driver code","code":"< ? php function findNumberOfTriangles ( $ arr ) { $ n = count ( $ arr ) ; sort ( $ arr ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { $ k = $ i + 2 ; for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { while ( $ k < $ n && $ arr [ $ i ] + $ arr [ $ j ] > $ arr [ $ k ] ) ++ $ k ; if ( $ k > $ j ) $ count += $ k - $ j - 1 ; } } return $ count ; } $ arr = array ( 10 , 21 , 22 , 100 , 101 , 200 , 300 ) ; echo \" Total \u2581 number \u2581 of \u2581 triangles \u2581 is \u2581 \" , findNumberOfTriangles ( $ arr ) ; ? >"}
{"text":"Count all distinct pairs with difference equal to k | A simple PHP program to count pairs with difference k ; Pick all elements one by one ; See if there is a pair of this picked element ; Driver Code","code":"< ? php function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] - $ arr [ $ j ] == $ k or $ arr [ $ j ] - $ arr [ $ i ] == $ k ) $ count ++ ; } return $ count ; } $ arr = array ( 1 , 5 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Count \u2581 of \u2581 pairs \u2581 with \u2581 given \u2581 diff \u2581 is \u2581 \" , countPairsWithDiffK ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Count all distinct pairs with difference equal to k | Standard binary search function ; Returns count of pairs with difference k in arr [ ] of size n . ; Sort array elements ; Pick a first element point ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ low , $ high , $ x ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) \/ 2 ; if ( $ x == $ arr [ $ mid ] ) return $ mid ; if ( $ x > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high , $ x ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) , $ x ) ; } return -1 ; } function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; $ i ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( binarySearch ( $ arr , $ i + 1 , $ n - 1 , $ arr [ $ i ] + $ k ) != -1 ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 5 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Count \u2581 of \u2581 pairs \u2581 with \u2581 given \u2581 diff \u2581 is \u2581 \" , countPairsWithDiffK ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Count all distinct pairs with difference equal to k | Returns count of pairs with difference k in arr [ ] of size n . ; Sort array elements ; arr [ r ] - arr [ l ] < k ; Driver Code","code":"< ? php function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; sort ( $ arr ) ; $ l = 0 ; $ r = 0 ; while ( $ r < $ n ) { if ( $ arr [ $ r ] - $ arr [ $ l ] == $ k ) { $ count ++ ; $ l ++ ; $ r ++ ; } else if ( $ arr [ $ r ] - $ arr [ $ l ] > $ k ) $ l ++ ; else $ r ++ ; } return $ count ; } $ arr = array ( 1 , 5 , 3 , 4 , 2 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Count \u2581 of \u2581 pairs \u2581 with \u2581 given \u2581 diff \u2581 is \u2581 \" , countPairsWithDiffK ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Construct an array from its pair | Fills element in arr [ ] from its pair sum array pair [ ] . n is size of arr [ ] ; Driver Code","code":"< ? php function constructArr ( $ pair ) { $ arr = array ( ) ; $ n = 5 ; $ arr [ 0 ] = intval ( ( $ pair [ 0 ] + $ pair [ 1 ] - $ pair [ $ n - 1 ] ) \/ 2 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ pair [ $ i - 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ pair = array ( 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 ) ; constructArr ( $ pair ) ; ? >"}
{"text":"Merge two sorted arrays with O ( 1 ) extra space | Merge ar1 [ ] and ar2 [ ] with O ( 1 ) extra space ; Iterate through all elements of ar2 [ ] starting from the last element ; Find the smallest element greater than ar2 [ i ] . Move all elements one position ahead till the smallest greater element is not found ; If there was a greater element ; Driver program","code":"< ? php function merge ( & $ ar1 , & $ ar2 , $ m , $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ last = $ ar1 [ $ m - 1 ] ; for ( $ j = $ m - 2 ; $ j >= 0 && $ ar1 [ $ j ] > $ ar2 [ $ i ] ; $ j -- ) $ ar1 [ $ j + 1 ] = $ ar1 [ $ j ] ; if ( $ j != $ m - 2 $ last > $ ar2 [ $ i ] ) { $ ar1 [ $ j + 1 ] = $ ar2 [ $ i ] ; $ ar2 [ $ i ] = $ last ; } } } $ ar1 = array ( 1 , 5 , 9 , 10 , 15 , 20 ) ; $ ar2 = array ( 2 , 3 , 8 , 13 ) ; $ m = sizeof ( $ ar1 ) \/ sizeof ( $ ar1 [ 0 ] ) ; $ n = sizeof ( $ ar2 ) \/ sizeof ( $ ar2 [ 0 ] ) ; merge ( $ ar1 , $ ar2 , $ m , $ n ) ; echo \" First Array : \" for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ ar1 [ $ i ] . \" \u2581 \" ; echo \" Second Array : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ ar2 [ $ i ] . \" \u2581 \" ; return 0 ; ? >"}
{"text":"Gould 's Sequence | Function to generate gould 's Sequence ; loop to generate each row of pascal 's Triangle up to nth row ; Loop to generate each element of ith row ; if c is odd increment count ; print count of odd elements ; Get n ; Function call","code":"< ? php function gouldSequence ( $ n ) { for ( $ row_num = 1 ; $ row_num <= $ n ; $ row_num ++ ) { $ count = 1 ; $ c = 1 ; for ( $ i = 1 ; $ i <= $ row_num ; $ i ++ ) { $ c = $ c * ( $ row_num - $ i ) \/ $ i ; if ( $ c % 2 == 1 ) $ count ++ ; } echo $ count , \" \" ; } } $ n = 16 ; gouldSequence ( $ n ) ; ? >"}
{"text":"Product of maximum in first array and minimum in second | Function to calculate the product ; Sort the arrays to find the maximum and minimum elements in given arrays ; Return product of maximum and minimum . ; Driver code","code":"< ? php function minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { sort ( $ arr1 ) ; sort ( $ arr2 ) ; return $ arr1 [ $ n1 - 1 ] * $ arr2 [ 0 ] ; } $ arr1 = array ( 10 , 2 , 3 , 6 , 4 , 1 ) ; $ arr2 = array ( 5 , 1 , 4 , 2 , 6 , 9 ) ; $ n1 = count ( $ arr1 ) ; $ n2 = count ( $ arr2 ) ; echo minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) ; ? >"}
{"text":"Minimum odd cost path in a matrix | PHP program to find Minimum odd cost path in a matrix ; Function to find the minimum cost ; leftmost element ; rightmost element ; Any element except leftmost and rightmost element of a row is reachable from direct upper or left upper or right upper row 's block ; Counting the minimum cost ; Find the minimum cost ; Driver code","code":"< ? php $ M = 100 ; $ N = 100 ; function find_min_odd_cost ( $ given , $ m , $ n ) { global $ M , $ N ; $ floor1 [ $ M ] [ $ N ] = array ( array ( 0 ) , array ( 0 ) ) ; $ min_odd_cost = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ floor1 [ 0 ] [ $ j ] = $ given [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j == 0 ) { $ floor1 [ $ i ] [ $ j ] = $ given [ $ i ] [ $ j ] ; $ floor1 [ $ i ] [ $ j ] += min ( $ floor1 [ $ i - 1 ] [ $ j ] , $ floor1 [ $ i - 1 ] [ $ j + 1 ] ) ; } else if ( $ j == $ n - 1 ) { $ floor1 [ $ i ] [ $ j ] = $ given [ $ i ] [ $ j ] ; $ floor1 [ $ i ] [ $ j ] += min ( $ floor1 [ $ i - 1 ] [ $ j ] , $ floor1 [ $ i - 1 ] [ $ j - 1 ] ) ; } else { $ temp = min ( $ floor1 [ $ i - 1 ] [ $ j ] , $ floor1 [ $ i - 1 ] [ $ j - 1 ] ) ; $ temp = min ( $ temp , $ floor1 [ $ i - 1 ] [ $ j + 1 ] ) ; $ floor1 [ $ i ] [ $ j ] = $ given [ $ i ] [ $ j ] + $ temp ; } } $ min_odd_cost = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ floor1 [ $ n - 1 ] [ $ j ] % 2 == 1 ) { if ( $ min_odd_cost > $ floor1 [ $ n - 1 ] [ $ j ] ) $ min_odd_cost = $ floor1 [ $ n - 1 ] [ $ j ] ; } } if ( $ min_odd_cost == PHP_INT_MIN ) return -1 ; return $ min_odd_cost ; } $ m = 5 ; $ n = 5 ; $ given = array ( array ( 1 , 2 , 3 , 4 , 6 ) , array ( 1 , 2 , 3 , 4 , 5 ) , array ( 1 , 2 , 3 , 4 , 5 ) , array ( 1 , 2 , 3 , 4 , 5 ) , array ( 100 , 2 , 3 , 4 , 5 ) ) ; echo \" Minimum \u2581 odd \u2581 cost \u2581 is \u2581 \" . find_min_odd_cost ( $ given , $ m , $ n ) ; ? >"}
{"text":"Product of maximum in first array and minimum in second | Function to calculate the product ; Initialize max of first array ; initialize min of second array ; To find the maximum element in first array ; To find the minimum element in second array ; Process remaining elements ; Driven code","code":"< ? php function minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { $ max = $ arr1 [ 0 ] ; $ min = $ arr2 [ 0 ] ; $ i ; for ( $ i = 1 ; $ i < $ n1 && $ i < $ n2 ; ++ $ i ) { if ( $ arr1 [ $ i ] > $ max ) $ max = $ arr1 [ $ i ] ; if ( $ arr2 [ $ i ] < $ min ) $ min = $ arr2 [ $ i ] ; } while ( $ i < $ n1 ) { if ( $ arr1 [ $ i ] > $ max ) $ max = $ arr1 [ $ i ] ; $ i ++ ; } while ( $ i < $ n2 ) { if ( $ arr2 [ $ i ] < $ min ) $ min = $ arr2 [ $ i ] ; $ i ++ ; } return $ max * $ min ; } $ arr1 = array ( 10 , 2 , 3 , 6 , 4 , 1 ) ; $ arr2 = array ( 5 , 1 , 4 , 2 , 6 , 9 ) ; $ n1 = count ( $ arr1 ) ; $ n2 = count ( $ arr2 ) ; echo minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) ; ? >"}
{"text":"Search , insert and delete in an unsorted array | Function to implement search operation ; Driver Code ; Using a last element as search element","code":"< ? php function findElement ( $ arr , $ n , $ key ) { $ i ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ key ) return $ i ; return -1 ; } $ arr = array ( 12 , 34 , 10 , 6 , 40 ) ; $ n = sizeof ( $ arr ) ; $ key = 40 ; $ position = findElement ( $ arr , $ n , $ key ) ; if ( $ position == - 1 ) echo ( \" Element \u2581 not \u2581 found \" ) ; else echo ( \" Element \u2581 Found \u2581 at \u2581 Position : \u2581 \" . ( $ position + 1 ) ) ; ? >"}
{"text":"Search , insert and delete in an unsorted array | Inserts a key in arr [ ] of given capacity . n is current size of arr [ ] . This function returns n + 1 if insertion is successful , else n . ; Cannot insert more elements if n is already more than or equal to capcity ; Driver Code ; Inserting key","code":"< ? php function insertSorted ( & $ arr , $ n , $ key , $ capacity ) { if ( $ n >= $ capacity ) return $ n ; array_push ( $ arr , $ key ) ; return ( $ n + 1 ) ; } $ arr = array ( 12 , 16 , 20 , 40 , 50 , 70 ) ; $ capacity = 20 ; $ n = 6 ; $ key = 26 ; echo \" Before \u2581 Insertion : \u2581 \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; $ n = insertSorted ( $ arr , $ n , $ key , $ capacity ) ; echo \" After Insertion : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Search , insert and delete in an unsorted array | To search a key to be deleted ; Function to delete an element ; Find position of element to be deleted ; Deleting element ; Driver code","code":"< ? php function findElement ( & $ arr , $ n , $ key ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ key ) return $ i ; return -1 ; } function deleteElement ( & $ arr , $ n , $ key ) { $ pos = findElement ( $ arr , $ n , $ key ) ; if ( $ pos == -1 ) { echo \" Element \u2581 not \u2581 found \" ; return $ n ; } for ( $ i = $ pos ; $ i < $ n - 1 ; $ i ++ ) $ arr [ $ i ] = $ arr [ $ i + 1 ] ; return $ n - 1 ; } $ arr = array ( 10 , 50 , 30 , 40 , 20 ) ; $ n = count ( $ arr ) ; $ key = 30 ; echo \" Array \u2581 before \u2581 deletion STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; $ n = deleteElement ( $ arr , $ n , $ key ) ; echo \" Array after deletion \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Search , insert and delete in a sorted array | function to implement binary search ; low + ( high - low ) \/ 2 ; Driver Code Let us search 3 in below array","code":"< ? php function binarySearch ( $ arr , $ low , $ high , $ key ) { if ( $ high < $ low ) return -1 ; $ mid = ( $ low + $ high ) \/ 2 ; if ( $ key == $ arr [ ( int ) $ mid ] ) return $ mid ; if ( $ key > $ arr [ ( int ) $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high , $ key ) ; return ( binarySearch ( $ arr , $ low , ( $ mid -1 ) , $ key ) ) ; } $ arr = array ( 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = count ( $ arr ) ; $ key = 10 ; echo \" Index : \u2581 \" , ( int ) binarySearch ( $ arr , 0 , $ n -1 , $ key ) ; ? >"}
{"text":"Find n | function to find nth stern ' diatomic series ; SET the Base case ; Traversing the array from 2 nd Element to nth Element ; Case 1 : for even n ; Case 2 : for odd n ; Driver Code","code":"< ? php function findSDSFunc ( $ n ) { $ DP [ 0 ] = 0 ; $ DP [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ DP [ $ i ] = $ DP [ $ i \/ 2 ] ; else $ DP [ $ i ] = $ DP [ ( $ i - 1 ) \/ 2 ] + $ DP [ ( $ i + 1 ) \/ 2 ] ; } return $ DP [ $ n ] ; } $ n = 15 ; echo ( findSDSFunc ( $ n ) ) ; ? >"}
{"text":"Find common elements in three sorted arrays | This function prints common elements in ar1 ; Initialize starting indexes for ar1 [ ] , ar2 [ ] and ar3 [ ] ; Iterate through three arrays while all arrays have elements ; If x = y and y = z , print any of them and move ahead in all arrays ; x < y ; y < z ; We reach here when x > y and z < y , i . e . , z is smallest ; Driver program to test above function","code":"< ? php function findCommon ( $ ar1 , $ ar2 , $ ar3 , $ n1 , $ n2 , $ n3 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 && $ k < $ n3 ) { if ( $ ar1 [ $ i ] == $ ar2 [ $ j ] && $ ar2 [ $ j ] == $ ar3 [ $ k ] ) { echo $ ar1 [ $ i ] , \" \" ; $ i ++ ; $ j ++ ; $ k ++ ; } else if ( $ ar1 [ $ i ] < $ ar2 [ $ j ] ) $ i ++ ; else if ( $ ar2 [ $ j ] < $ ar3 [ $ k ] ) $ j ++ ; else $ k ++ ; } } $ ar1 = array ( 1 , 5 , 10 , 20 , 40 , 80 ) ; $ ar2 = array ( 6 , 7 , 20 , 80 , 100 ) ; $ ar3 = array ( 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 ) ; $ n1 = count ( $ ar1 ) ; $ n2 = count ( $ ar2 ) ; $ n3 = count ( $ ar3 ) ; echo \" Common \u2581 Elements \u2581 are \u2581 \" ; findCommon ( $ ar1 , $ ar2 , $ ar3 , $ n1 , $ n2 , $ n3 ) ; ? >"}
{"text":"Jacobsthal and Jacobsthal | Return nth Jacobsthal number . ; base case ; Return nth Jacobsthal - Lucas number . ; base case ; Driver Code","code":"< ? php function Jacobsthal ( $ n ) { $ dp [ $ n + 1 ] ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + 2 * $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; } function Jacobsthal_Lucas ( $ n ) { $ dp [ $ n + 1 ] ; $ dp [ 0 ] = 2 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + 2 * $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; } $ n = 5 ; echo \" Jacobsthal \u2581 number : \u2581 \" , Jacobsthal ( $ n ) , \" STRNEWLINE \" ; echo \" Jacobsthal - Lucas \u2581 number : \u2581 \" , Jacobsthal_Lucas ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find position of an element in a sorted array of infinite numbers | Simple binary search algorithm ; function takes an infinite size array and a key to be searched and returns its position if found else - 1. We don 't know size of arr[] and we can assume size to be infinite in this function. NOTE THAT THIS FUNCTION ASSUMES arr[] TO BE OF INFINITE SIZE THEREFORE, THERE IS NO INDEX OUT OF BOUND CHECKING ; Find h to do binary search ; store previous high ; double high index ; update new val ; at this point we have updated low and high indices , Thus use binary search between them ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = $ l + ( $ r - $ l ) \/ 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } function findPos ( $ arr , $ key ) { $ l = 0 ; $ h = 1 ; $ val = $ arr [ 0 ] ; while ( $ val < $ key ) { $ l = $ h ; $ h = 2 * $ h ; $ val = $ arr [ $ h ] ; } return binarySearch ( $ arr , $ l , $ h , $ key ) ; } $ arr = array ( 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 ) ; $ ans = findPos ( $ arr , 10 ) ; if ( $ ans == -1 ) echo \" Element \u2581 not \u2581 found \" ; else echo \" Element \u2581 found \u2581 at \u2581 index \u2581 \" , $ ans ; ? >"}
{"text":"Number of n digit stepping numbers | function that calculates the answer ; if n is 1 then answer will be 10. ; Compute values for count of digits more than 1. ; If ending digit is 0 ; If ending digit is 9 ; For other digits . ; stores the final answer ; Driver Code","code":"< ? php function answer ( $ n ) { if ( $ n == 1 ) return 10 ; for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) $ dp [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j + 1 ] ; else if ( $ j == 9 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j + 1 ] ; } } $ sum = 0 ; for ( $ j = 1 ; $ j <= 9 ; $ j ++ ) $ sum += $ dp [ $ n ] [ $ j ] ; return $ sum ; } $ n = 2 ; echo answer ( $ n ) ; ? >"}
{"text":"Find the element that appears once in an array where every other element appears twice | Return the maximum Sum of difference between consecutive elements . ; Do XOR of all elements and return ; Driver code","code":"< ? php function findSingle ( $ ar , $ ar_size ) { $ res = $ ar [ 0 ] ; for ( $ i = 1 ; $ i < $ ar_size ; $ i ++ ) $ res = $ res ^ $ ar [ $ i ] ; return $ res ; } $ ar = array ( 2 , 3 , 5 , 4 , 5 , 3 , 4 ) ; $ n = count ( $ ar ) ; echo \" Element \u2581 occurring \u2581 once \u2581 is \u2581 \" , findSingle ( $ ar , $ n ) ; ? >"}
{"text":"Count all triplets whose sum is equal to a perfect cube | PHP program to calculate all triplets whose sum is perfect cube . ; Function to calculate all occurrence of a number in a given range ; if i == 0 assign 1 to present state ; else add + 1 to current state with previous state ; Function to calculate triplets whose sum is equal to the perfect cube ; Initialize answer ; count all occurrence of third triplet in range from j + 1 to n ; Driver code","code":"< ? php $ dp = array_fill ( 0 , 1001 , array_fill ( 0 , 15001 , NULL ) ) ; function computeDpArray ( & $ arr , $ n ) { global $ dp ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = 1 ; $ j <= 15000 ; ++ $ j ) { if ( $ i == 0 ) $ dp [ $ i ] [ $ j ] = ( $ j == $ arr [ $ i ] ) ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + ( $ arr [ $ i ] == $ j ) ; } } } function countTripletSum ( & $ arr , $ n ) { global $ dp ; computeDpArray ( $ arr , $ n ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; ++ $ j ) { for ( $ k = 1 ; $ k <= 24 ; ++ $ k ) { $ cube = $ k * $ k * $ k ; $ rem = $ cube - ( $ arr [ $ i ] + $ arr [ $ j ] ) ; if ( $ rem > 0 ) $ ans += $ dp [ $ n - 1 ] [ $ rem ] - $ dp [ $ j ] [ $ rem ] ; } } } return $ ans ; } $ arr = array ( 2 , 5 , 1 , 20 , 6 ) ; $ n = sizeof ( $ arr ) ; echo countTripletSum ( $ arr , $ n ) ; ? >"}
{"text":"Maximum Subarray Sum Excluding Certain Elements | Function to check the element present in array B ; Utility function for findMaxSubarraySum ( ) with the following parameters A = > Array A , B = > Array B , n = > Number of elements in Array A , m = > Number of elements in Array B ; set max_so_far to INT_MIN ; if the element is present in B , set current max to 0 and move to the next element ; Proceed as in Kadane 's Algorithm ; Wrapper for findMaxSubarraySumUtil ( ) ; This case will occour when all elements of A are present in B , thus no subarray can be formed ; Driver Code ; Function call","code":"< ? php function isPresent ( $ B , $ m , $ x ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ B [ $ i ] == $ x ) return true ; return false ; } function findMaxSubarraySumUtil ( $ A , $ B , $ n , $ m ) { $ max_so_far = PHP_INT_MIN ; $ curr_max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPresent ( $ B , $ m , $ A [ $ i ] ) ) { $ curr_max = 0 ; continue ; } $ curr_max = max ( $ A [ $ i ] , $ curr_max + $ A [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; } function findMaxSubarraySum ( $ A , $ B , $ n , $ m ) { $ maxSubarraySum = findMaxSubarraySumUtil ( $ A , $ B , $ n , $ m ) ; if ( $ maxSubarraySum == PHP_INT_MIN ) { echo ( \" Maximum \u2581 Subarray \u2581 \" . \" Sum \u2581 cant \u2581 be \u2581 found STRNEWLINE \" ) ; } else { echo ( \" The \u2581 Maximum \u2581 Subarray \u2581 Sum \u2581 = \u2581 \" . $ maxSubarraySum . \" STRNEWLINE \" ) ; } } $ A = array ( 3 , 4 , 5 , -4 , 6 ) ; $ B = array ( 1 , 8 , 5 ) ; $ n = count ( $ A ) ; $ m = count ( $ B ) ; findMaxSubarraySum ( $ A , $ B , $ n , $ m ) ; ? >"}
{"text":"Number of n | Returns count of non - decreasing numbers with n digits . ; Initialization of all 0 - digit number ; Initialization of all i - digit non - decreasing number leading with 9 ; for all digits we should calculate number of ways depending upon leading digits ; Driver Code","code":"< ? php function nonDecNums ( $ n ) { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) $ a [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ a [ $ i ] [ 9 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 8 ; $ j >= 0 ; $ j -- ) $ a [ $ i ] [ $ j ] = $ a [ $ i - 1 ] [ $ j ] + $ a [ $ i ] [ $ j + 1 ] ; return $ a [ $ n ] [ 0 ] ; } $ n = 2 ; echo \" Non - decreasing \u2581 digits \u2581 = \u2581 \" , nonDecNums ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count Balanced Binary Trees of Height h | PHP program to count number of balanced ; base cases ; Driver Code","code":"< ? php $ mod = 1000000007 ; function countBT ( $ h ) { global $ mod ; $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ h ; $ i ++ ) { $ dp [ $ i ] = ( $ dp [ $ i - 1 ] * ( ( 2 * $ dp [ $ i - 2 ] ) % $ mod + $ dp [ $ i - 1 ] ) % $ mod ) % $ mod ; } return $ dp [ $ h ] ; } $ h = 3 ; echo \" No . \u2581 of \u2581 balanced \u2581 binary \u2581 trees \" , \" \u2581 of \u2581 height \u2581 h \u2581 is : \u2581 \" , countBT ( $ h ) , \" STRNEWLINE \" ; ? >"}
{"text":"Equilibrium index of an array | function to find the equilibrium index ; Check for indexes one by one until an equilibrium index is found ; get left sum ; get right sum ; if leftsum and rightsum are same , then we are done ; return - 1 if no equilibrium index is found ; Driver code","code":"< ? php function equilibrium ( $ arr , $ n ) { $ i ; $ j ; $ leftsum ; $ rightsum ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ leftsum = 0 ; $ rightsum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ leftsum += $ arr [ $ j ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ rightsum += $ arr [ $ j ] ; if ( $ leftsum == $ rightsum ) return $ i ; } return -1 ; } $ arr = array ( -7 , 1 , 5 , 2 , -4 , 3 , 0 ) ; $ arr_size = sizeof ( $ arr ) ; echo equilibrium ( $ arr , $ arr_size ) ; ? >"}
{"text":"Find number of endless points | Returns count of endless points ; Fills column matrix . For every column , start from every last row and fill every entry as blockage after a 0 is found . ; flag which will be zero once we get a '0' and it will be 1 otherwise ; encountered a '0' , set the isEndless variable to false ; Similarly , fill row matrix ; Calculate total count of endless points ; If there is NO blockage or column after this point , increment result . ; Driver code","code":"< ? php function countEndless ( $ input , $ n ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ isEndless = 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ input [ $ i ] [ $ j ] == 0 ) $ isEndless = 0 ; $ col [ $ i ] [ $ j ] = $ isEndless ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ isEndless = 1 ; for ( $ j = $ n - 1 ; $ j >= 0 ; $ j -- ) { if ( $ input [ $ i ] [ $ j ] == 0 ) $ isEndless = 0 ; $ row [ $ i ] [ $ j ] = $ isEndless ; } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 1 ; $ j < $ n ; $ j ++ ) if ( $ row [ $ i ] [ $ j ] && $ col [ $ i ] [ $ j ] ) $ ans ++ ; return $ ans ; } $ input = array ( array ( 1 , 0 , 1 , 1 ) , array ( 0 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 ) , array ( 0 , 1 , 1 , 0 ) ) ; $ n = 4 ; echo countEndless ( $ input , $ n ) ; ? >"}
{"text":"Equilibrium index of an array | function to find the equilibrium index ; initialize sum of whole array ; initialize leftsum ; Find sum of the whole array ; sum is now right sum for index i ; If no equilibrium index found , then return 0 ; Driver code","code":"< ? php function equilibrium ( $ arr , $ n ) { $ sum = 0 ; $ leftsum = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ sum -= $ arr [ $ i ] ; if ( $ leftsum == $ sum ) return $ i ; $ leftsum += $ arr [ $ i ] ; } return -1 ; } $ arr = array ( -7 , 1 , 5 , 2 , -4 , 3 , 0 ) ; $ arr_size = sizeof ( $ arr ) ; echo \" First \u2581 equilibrium \u2581 index \u2581 is \u2581 \" , equilibrium ( $ arr , $ arr_size ) ; ? >"}
{"text":"Sum of all substrings of a string representing a number | Set 1 | Method to convert character digit to integer digit ; Returns sum of all substring of num ; allocate memory equal to length of string ; initialize first value with first digit ; loop over all digits of string ; update each sumofdigit from previous value ; add current value to the result ; Driver Code","code":"< ? php function toDigit ( $ ch ) { return ( $ ch - '0' ) ; } function sumOfSubstrings ( $ num ) { $ n = strlen ( $ num ) ; $ sumofdigit [ $ n ] = 0 ; $ sumofdigit [ 0 ] = toDigit ( $ num [ 0 ] ) ; $ res = $ sumofdigit [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ numi = toDigit ( $ num [ $ i ] ) ; $ sumofdigit [ $ i ] = ( $ i + 1 ) * $ numi + 10 * $ sumofdigit [ $ i - 1 ] ; $ res += $ sumofdigit [ $ i ] ; } return $ res ; } $ num = \"1234\" ; echo sumOfSubstrings ( $ num ) ; ? >"}
{"text":"Leaders in an array | PHP Function to print leaders in an array ; the loop didn 't break ; Driver Code","code":"< ? php function printLeaders ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) { if ( $ arr [ $ i ] <= $ arr [ $ j ] ) break ; } if ( $ j == $ size ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; } } $ arr = array ( 16 , 17 , 4 , 3 , 5 , 2 ) ; $ n = sizeof ( $ arr ) ; printLeaders ( $ arr , $ n ) ; ? >"}
{"text":"Leaders in an array | PHP Function to print leaders in an array ; Rightmost element is always leader ; Driver Code","code":"< ? php function printLeaders ( & $ arr , $ size ) { $ max_from_right = $ arr [ $ size - 1 ] ; echo ( $ max_from_right ) ; echo ( \" \u2581 \" ) ; for ( $ i = $ size - 2 ; $ i >= 0 ; $ i -- ) { if ( $ max_from_right < $ arr [ $ i ] ) { $ max_from_right = $ arr [ $ i ] ; echo ( $ max_from_right ) ; echo ( \" \u2581 \" ) ; } } } $ arr = array ( 16 , 17 , 4 , 3 , 5 , 2 ) ; $ n = sizeof ( $ arr ) ; printLeaders ( $ arr , $ n ) ; ? >"}
{"text":"Unbounded Knapsack ( Repetition of items allowed ) | Returns the maximum value with knapsack of W capacity ; dp [ i ] is going to store maximum value with knapsack capacity i . ; Fill dp [ ] using above recursive formula ; Driver Code","code":"< ? php function unboundedKnapsack ( $ W , $ n , $ val , $ wt ) { for ( $ i = 0 ; $ i <= $ W ; $ i ++ ) $ dp [ $ i ] = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ W ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ wt [ $ j ] <= $ i ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - $ wt [ $ j ] ] + $ val [ $ j ] ) ; return $ dp [ $ W ] ; } $ W = 100 ; $ val = array ( 10 , 30 , 20 ) ; $ wt = array ( 5 , 10 , 15 ) ; $ n = count ( $ val ) ; sizeof ( $ val ) \/ sizeof ( $ val [ 0 ] ) ; echo unboundedKnapsack ( $ W , $ n , $ val , $ wt ) ; ? >"}
{"text":"Ceiling in a sorted array | Function to get index of ceiling of x in arr [ low . . high ] ; If x is smaller than or equal to first element , then return the first element ; Otherwise , linearly search for ceil value ; if x lies between arr [ i ] and arr [ i + 1 ] including arr [ i + 1 ] , then return arr [ i + 1 ] ; If we reach here then x is greater than the last element of the array , return - 1 in this case ; Driver Code","code":"< ? php function ceilSearch ( $ arr , $ low , $ high , $ x ) { if ( $ x <= $ arr [ $ low ] ) return $ low ; for ( $ i = $ low ; $ i < $ high ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; if ( $ arr [ $ i ] < $ x && $ arr [ $ i + 1 ] >= $ x ) return $ i + 1 ; } return -1 ; } $ arr = array ( 1 , 2 , 8 , 10 , 10 , 12 , 19 ) ; $ n = sizeof ( $ arr ) ; $ x = 3 ; $ index = ceilSearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ index == -1 ) echo ( \" Ceiling \u2581 of \u2581 \" . $ x . \" \u2581 doesn ' t \u2581 exist \u2581 in \u2581 array \u2581 \" ) ; else echo ( \" ceiling \u2581 of \u2581 \" . $ x . \" \u2581 is \u2581 \" . $ arr [ $ index ] ) ; ? >"}
{"text":"Maximum sum subarray removing at most one element | Method returns maximum sum of all subarray where removing one element is also allowed ; Maximum sum subarrays in forward and backward directions ; Initialize current max and max so far . ; calculating maximum sum subarrays in forward direction ; storing current maximum till ith , in forward array ; calculating maximum sum subarrays in backward direction ; storing current maximum from ith , in backward array ; Initializing final ans by max_so_far so that , case when no element is removed to get max sum subarray is also handled ; choosing maximum ignoring ith element ; Driver Code","code":"< ? php function maxSumSubarrayRemovingOneEle ( $ arr , $ n ) { $ fw = array ( ) ; $ bw = array ( ) ; $ cur_max = $ arr [ 0 ] ; $ max_so_far = $ arr [ 0 ] ; $ fw [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ cur_max = max ( $ arr [ $ i ] , $ cur_max + $ arr [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ cur_max ) ; $ fw [ $ i ] = $ cur_max ; } $ cur_max = $ max_so_far = $ bw [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ cur_max = max ( $ arr [ $ i ] , $ cur_max + $ arr [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ cur_max ) ; $ bw [ $ i ] = $ cur_max ; } $ fans = $ max_so_far ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ fans = max ( $ fans , $ fw [ $ i - 1 ] + $ bw [ $ i + 1 ] ) ; return $ fans ; } $ arr = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = count ( $ arr ) ; echo maxSumSubarrayRemovingOneEle ( $ arr , $ n ) ; ? >"}
{"text":"Ceiling in a sorted array | Function to get index of ceiling of x in arr [ low . . high ] ; If x is smaller than or equal to the first element , then return the first element ; If x is greater than the last element , then return - 1 ; get the index of middle element of arr [ low . . high ] ; If x is same as middle element , then return mid ; If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ] ; If x is smaller than arr [ mid ] , then either arr [ mid ] is ceiling of x or ceiling lies in arr [ low ... . mid - 1 ] ; Driver Code","code":"< ? php function ceilSearch ( $ arr , $ low , $ high , $ x ) { $ mid ; if ( $ x <= $ arr [ $ low ] ) return $ low ; if ( $ x > $ arr [ $ high ] ) return -1 ; $ mid = ( $ low + $ high ) \/ 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; else if ( $ arr [ $ mid ] < $ x ) { if ( $ mid + 1 <= $ high && $ x <= $ arr [ $ mid + 1 ] ) return $ mid + 1 ; else return ceilSearch ( $ arr , $ mid + 1 , $ high , $ x ) ; } else { if ( $ mid - 1 >= $ low && $ x > $ arr [ $ mid - 1 ] ) return $ mid ; else return ceilSearch ( $ arr , $ low , $ mid - 1 , $ x ) ; } } $ arr = array ( 1 , 2 , 8 , 10 , 10 , 12 , 19 ) ; $ n = sizeof ( $ arr ) ; $ x = 20 ; $ index = ceilSearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ index == -1 ) echo ( \" Ceiling \u2581 of \u2581 $ x \u2581 doesn ' t \u2581 exist \u2581 in \u2581 array \u2581 \" ) ; else echo ( \" ceiling \u2581 of \u2581 $ x \u2581 is \" ) ; echo ( isset ( $ arr [ $ index ] ) ) ; ? >"}
{"text":"Path with maximum average value | method returns maximum average of all path of cost matrix ; Initialize first column of total cost ( dp ) array ; Initialize first row of dp array ; Construct rest of the dp array ; divide maximum sum by constant path length : ( 2 N - 1 ) for getting average ; Driver code","code":"< ? php function maxAverageOfPath ( $ cost , $ N ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = $ cost [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 0 ] + $ cost [ $ i ] [ 0 ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) $ dp [ 0 ] [ $ j ] = $ dp [ 0 ] [ $ j - 1 ] + $ cost [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) + $ cost [ $ i ] [ $ j ] ; } return $ dp [ $ N - 1 ] [ $ N - 1 ] \/ ( 2 * $ N - 1 ) ; } $ cost = array ( array ( 1 , 2 , 3 ) , array ( 6 , 5 , 4 ) , array ( 7 , 3 , 9 ) ) ; echo maxAverageOfPath ( $ cost , 3 ) ; ? >"}
{"text":"Maximum weight path ending at any element of last row in a matrix | Function which return the maximum weight path sum ; creat 2D matrix to store the sum of the path ; Initialize first column of total weight array ( dp [ i to N ] [ 0 ] ) ; Calculate rest path sum of weight matrix ; find the max weight path sum to rech the last row ; return maximum weight path sum ; Driver program","code":"< ? php function maxCost ( $ mat , $ N ) { $ dp = array ( array ( ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; $ dp [ 0 ] [ 0 ] = $ mat [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ mat [ $ i ] [ 0 ] + $ dp [ $ i - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i + 1 && $ j < $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } $ result = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ result < $ dp [ $ N - 1 ] [ $ i ] ) $ result = $ dp [ $ N - 1 ] [ $ i ] ; return $ result ; } $ mat = array ( array ( 4 , 1 , 5 , 6 , 1 ) , array ( 2 , 9 , 2 , 11 , 10 ) , array ( 15 , 1 , 3 , 15 , 2 ) , array ( 16 , 92 , 41 , 4 , 3 ) , array ( 8 , 142 , 6 , 4 , 8 ) ) ; $ N = 5 ; echo \" Maximum \u2581 Path \u2581 Sum \u2581 : \u2581 \" , maxCost ( $ mat , $ N ) ; ? >"}
{"text":"Maximum profit by buying and selling a share at most k times | Function to find out maximum profit by buying & selling a share atmost k times given stock price of n days ; table to store results of subproblems profit [ t ] [ i ] stores maximum profit using atmost t transactions up to day i ( including day i ) ; For day 0 , you can 't  earn money irrespective  of how many times you trade ; profit is 0 if we don 't  do any transaction  (i.e. k =0) ; fill the table in bottom - up fashion ; Driver Code","code":"< ? php function maxProfit ( $ price , $ n , $ k ) { $ profit [ $ k + 1 ] [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ profit [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ profit [ 0 ] [ $ j ] = 0 ; $ prevDiff = NULL ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ prevDiff = max ( $ prevDiff , $ profit [ $ i - 1 ] [ $ j - 1 ] - $ price [ $ j - 1 ] ) ; $ profit [ $ i ] [ $ j ] = max ( $ profit [ $ i ] [ $ j - 1 ] , $ price [ $ j ] + $ prevDiff ) ; } } return $ profit [ $ k ] [ $ n - 1 ] ; } $ k = 3 ; $ price = array ( 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ) ; $ n = sizeof ( $ price ) ; echo \" Maximum \u2581 profit \u2581 is : \u2581 \" , maxProfit ( $ price , $ n , $ k ) ; ? >"}
{"text":"Count even length binary sequences with same sum of first and second half bits | diff is difference between sums first n bits and last n bits respectively ; We can 't cover difference of  more than n with 2n bits ; n == 1 , i . e . , 2 bit long sequences ; First bit is 0 & last bit is 1 ; First and last bits are same ; First bit is 1 & last bit is 0 ; Driver Code","code":"< ? php function countSeq ( $ n , $ diff ) { if ( abs ( $ diff ) > $ n ) return 0 ; if ( $ n == 1 && $ diff == 0 ) return 2 ; if ( $ n == 1 && abs ( $ diff ) == 1 ) return 1 ; $ res = countSeq ( $ n - 1 , $ diff + 1 ) + 2 * countSeq ( $ n - 1 , $ diff ) + countSeq ( $ n - 1 , $ diff - 1 ) ; return $ res ; } $ n = 2 ; echo \" Count \u2581 of \u2581 sequences \u2581 is \u2581 \" , countSeq ( $ n , 0 ) ; ? >"}
{"text":"Count even length binary sequences with same sum of first and second half bits | A memoization based PHP program to count even length binary sequences such that the sum of first and second half bits is same ; A lookup table to store the results of subproblems ; dif is difference between sums of first n bits and last n bits i . e . , dif = ( Sum of first n bits ) - ( Sum of last n bits ) ; We can 't cover difference of more  than n with 2n bits ; n == 1 , i . e . , 2 bit long sequences ; Check if this subproblem is already solved n is added to dif to make sure index becomes positive ; $res = First bit is 0 & last bit is 1 ; First and last bits are same ; First bit is 1 & last bit is 0 ; Store result in lookup table and return the result ; A Wrapper over countSeqUtil ( ) . It mainly initializes lookup table , then calls countSeqUtil ( ) ; call countSeqUtil ( ) ; Driver Code","code":"< ? php $ MAX = 1000 ; $ lookup = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , -1 ) ) ; function countSeqUtil ( $ n , $ dif ) { global $ lookup ; if ( abs ( $ dif ) > $ n ) return 0 ; if ( $ n == 1 && $ dif == 0 ) return 2 ; if ( $ n == 1 && abs ( $ dif ) == 1 ) return 1 ; if ( $ lookup [ $ n ] [ $ n + $ dif ] != -1 ) return $ lookup [ $ n ] [ $ n + $ dif ] ; countSeqUtil ( $ n - 1 , $ dif + 1 ) + 2 * countSeqUtil ( $ n - 1 , $ dif ) + countSeqUtil ( $ n - 1 , $ dif - 1 ) ; return $ lookup [ $ n ] [ $ n + $ dif ] = $ res ; } function countSeq ( $ n ) { return countSeqUtil ( $ n , 0 ) ; } $ n = 2 ; echo \" Count \u2581 of \u2581 sequences \u2581 is \u2581 \" . countSeq ( $ n ) ; ? >"}
{"text":"Remove minimum elements from either side such that 2 * min becomes more than max | A utility function to find minimum in arr [ l . . h ] ; A utility function to find maximum in arr [ l . . h ] ; Returns the minimum number of removals from either end in arr [ l . . h ] so that 2 * min becomes greater than max . ; If there is 1 or less elements , return 0. For a single element , 2 * min > max . ( Assumption : All elements are positive in arr [ ] ) ; 1 ) Find minimum and maximum in arr [ l . . h ] ; If the property is followed , no removals needed ; Otherwise remove a character from left end and recur , then remove a character from right end and recur , take the minimum of two is returned ; Driver Code","code":"< ? php function min_1 ( & $ arr , $ l , $ h ) { $ mn = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mn > $ arr [ $ i ] ) $ mn = $ arr [ $ i ] ; return $ mn ; } function max_1 ( & $ arr , $ l , $ h ) { $ mx = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mx < $ arr [ $ i ] ) $ mx = $ arr [ $ i ] ; return $ mx ; } function minRemovals ( & $ arr , $ l , $ h ) { if ( $ l >= $ h ) return 0 ; $ mn = min_1 ( $ arr , $ l , $ h ) ; $ mx = max_1 ( $ arr , $ l , $ h ) ; if ( 2 * $ mn > $ mx ) return 0 ; return min ( minRemovals ( $ arr , $ l + 1 , $ h ) , minRemovals ( $ arr , $ l , $ h - 1 ) ) + 1 ; } $ arr = array ( 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ) ; $ n = sizeof ( $ arr ) ; echo minRemovals ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text":"Count all possible paths from top left to bottom right of a mXn matrix | Returns count of possible paths to reach cell at row number m and column number n from the topmost leftmost cell ( cell at 1 , 1 ) ; Create a 2D table to store results of subproblems ; Count of paths to reach any cell in first column is 1 ; Count of paths to reach any cell in first column is 1 ; Calculate count of paths for other cells in bottom - up manner using the recursive solution ; By uncommenting the last part the code calculated the total possible paths if the diagonal Movements are allowed ; Driver Code","code":"< ? php function numberOfPaths ( $ m , $ n ) { $ count = array ( ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ count [ $ i ] [ 0 ] = 1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ count [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) $ count [ $ i ] [ $ j ] = $ count [ $ i - 1 ] [ $ j ] + $ count [ $ i ] [ $ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; } return $ count [ $ m - 1 ] [ $ n - 1 ] ; } echo numberOfPaths ( 3 , 3 ) ; ? >"}
{"text":"Maximum Product Cutting | DP | Utility function to get the maximum of two and three integers ; The main function that returns maximum product obtainable from a rope of length n ; Base cases ; Make a cut at different places and take the maximum of all ; Return the maximum of all values ; Driver Code","code":"< ? php function max_1 ( $ a , $ b , $ c ) { return max ( $ a , max ( $ b , $ c ) ) ; } function maxProd ( $ n ) { if ( $ n == 0 $ n == 1 ) return 0 ; $ max_val = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ max_val = max_1 ( $ max_val , $ i * ( $ n - $ i ) , maxProd ( $ n - $ i ) * $ i ) ; return $ max_val ; } echo \" Maximum \u2581 Product \u2581 is \u2581 \" . maxProd ( 10 ) ; ? >"}
{"text":"Assembly Line Scheduling | DP | A PHP program to find minimum possible time by the car chassis to complete ; Utility function to find minimum of two numbers ; time taken to leave first station in line 1 ; time taken to leave first station in line 2 ; Fill tables T1 [ ] and T2 [ ] using the above given recursive relations ; Consider exit times and return minimum ; Driver Code","code":"< ? php $ NUM_LINE = 2 ; $ NUM_STATION = 4 ; function carAssembly ( $ a , $ t , $ e , $ x ) { global $ NUM_LINE , $ NUM_STATION ; $ T1 = array ( ) ; $ T2 = array ( ) ; $ i ; $ T1 [ 0 ] = $ e [ 0 ] + $ a [ 0 ] [ 0 ] ; $ T2 [ 0 ] = $ e [ 1 ] + $ a [ 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ NUM_STATION ; ++ $ i ) { $ T1 [ $ i ] = min ( $ T1 [ $ i - 1 ] + $ a [ 0 ] [ $ i ] , $ T2 [ $ i - 1 ] + $ t [ 1 ] [ $ i ] + $ a [ 0 ] [ $ i ] ) ; $ T2 [ $ i ] = min ( $ T2 [ $ i - 1 ] + $ a [ 1 ] [ $ i ] , $ T1 [ $ i - 1 ] + $ t [ 0 ] [ $ i ] + $ a [ 1 ] [ $ i ] ) ; } return min ( $ T1 [ $ NUM_STATION - 1 ] + $ x [ 0 ] , $ T2 [ $ NUM_STATION - 1 ] + $ x [ 1 ] ) ; } $ a = array ( array ( 4 , 5 , 3 , 2 ) , array ( 2 , 10 , 1 , 4 ) ) ; $ t = array ( array ( 0 , 7 , 4 , 5 ) , array ( 0 , 9 , 2 , 8 ) ) ; $ e = array ( 10 , 12 ) ; $ x = array ( 18 , 7 ) ; echo carAssembly ( $ a , $ t , $ e , $ x ) ; ? >"}
{"text":"Longest Common Substring | DP | Returns length of longest common substring of X [ 0. . m - 1 ] and Y [ 0. . n - 1 ] ; Create a table to store lengths of longest common suffixes of substrings . Notethat LCSuff [ i ] [ j ] contains length of longest common suffix of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] . The first row and first column entries have no logical meaning , they are used only for simplicity of program ; To store length of the longest common substring ; Following steps build LCSuff [ m + 1 ] [ n + 1 ] in bottom up fashion . ; Driver Code","code":"< ? php function LCSubStr ( $ X , $ Y , $ m , $ n ) { $ LCSuff = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; $ result = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ LCSuff [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ LCSuff [ $ i ] [ $ j ] = $ LCSuff [ $ i - 1 ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ LCSuff [ $ i ] [ $ j ] ) ; } else $ LCSuff [ $ i ] [ $ j ] = 0 ; } } return $ result ; } $ X = \" OldSite : GeeksforGeeks . org \" ; $ Y = \" NewSite : GeeksQuiz . com \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; echo \" Length \u2581 of \u2581 Longest \u2581 Common \u2581 Substring \u2581 is \u2581 \" . LCSubStr ( $ X , $ Y , $ m , $ n ) ; ? >"}
{"text":"Maximum Subarray Sum using Divide and Conquer algorithm | Find the maximum possible sum in arr [ ] such that arr [ m ] is part of it ; Include elements on left of mid . ; Include elements on right of mid ; Return sum of elements on left and right of mid returning only left_sum + right_sum will fail for [ - 2 , 1 ] ; Returns sum of maximum sum subarray in aa [ l . . h ] ; Base Case : Only one element ; Find middle point ; Return maximum of following three possible cases a ) Maximum subarray sum in left half b ) Maximum subarray sum in right half c ) Maximum subarray sum such that the subarray crosses the midpoint ; Driver Code","code":"< ? php function maxCrossingSum ( & $ arr , $ l , $ m , $ h ) { $ sum = 0 ; $ left_sum = PHP_INT_MIN ; for ( $ i = $ m ; $ i >= $ l ; $ i -- ) { $ sum = $ sum + $ arr [ $ i ] ; if ( $ sum > $ left_sum ) $ left_sum = $ sum ; } $ sum = 0 ; $ right_sum = PHP_INT_MIN ; for ( $ i = $ m + 1 ; $ i <= $ h ; $ i ++ ) { $ sum = $ sum + $ arr [ $ i ] ; if ( $ sum > $ right_sum ) $ right_sum = $ sum ; } return max ( $ left_sum + $ right_sum , $ left_sum , $ right_sum ) ; } function maxSubArraySum ( & $ arr , $ l , $ h ) { if ( $ l == $ h ) return $ arr [ $ l ] ; $ m = intval ( ( $ l + $ h ) \/ 2 ) ; return max ( maxSubArraySum ( $ arr , $ l , $ m ) , maxSubArraySum ( $ arr , $ m + 1 , $ h ) , maxCrossingSum ( $ arr , $ l , $ m , $ h ) ) ; } $ arr = array ( 2 , 3 , 4 , 5 , 7 ) ; $ n = count ( $ arr ) ; $ max_sum = maxSubArraySum ( $ arr , 0 , $ n - 1 ) ; echo \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" . $ max_sum ; ? >"}
{"text":"Program to find amount of water in a given glass | Returns the amount of water in jth glass of ith row ; A row number i has maximum i columns . So input column number must be less than i ; There will be i * ( i + 1 ) \/ 2 glasses till ith row ( including ith row ) and Initialize all glasses as empty ; Put all water in first glass ; Now let the water flow to the downward glasses till the row number is less than or \/ equal to i ( given row ) correction : X can be zero for side glasses as they have lower rate to fill ; Fill glasses in a given row . Number of columns in a row is equal to row number ; Get the water from current glass ; Keep the amount less than or equal to capacity in current glass ; Get the remaining amount ; Distribute the remaining amount to the down two glasses ; The index of jth glass in ith row will be i * ( i - 1 ) \/ 2 + j - 1 ; Driver Code ; Total amount of water","code":"< ? php function findWater ( $ i , $ j , $ X ) { if ( $ j > $ i ) { echo \" Incorrect \u2581 Input STRNEWLINE \" ; return ; } $ glass = array_fill ( 0 , ( int ) ( $ i * ( $ i + 1 ) \/ 2 ) , 0 ) ; $ index = 0 ; $ glass [ $ index ] = $ X ; for ( $ row = 1 ; $ row < $ i ; ++ $ row ) { for ( $ col = 1 ; $ col <= $ row ; ++ $ col , ++ $ index ) { $ X = $ glass [ $ index ] ; $ glass [ $ index ] = ( $ X >= 1.0 ) ? 1.0 : $ X ; $ X = ( $ X >= 1.0 ) ? ( $ X - 1 ) : 0.0 ; $ glass [ $ index + $ row ] += ( double ) ( $ X \/ 2 ) ; $ glass [ $ index + $ row + 1 ] += ( double ) ( $ X \/ 2 ) ; } } return $ glass [ ( int ) ( $ i * ( $ i - 1 ) \/ 2 + $ j - 1 ) ] ; } $ i = 2 ; $ j = 2 ; $ X = 2.0 ; echo \" Amount \u2581 of \u2581 water \u2581 in \u2581 jth \u2581 \" , \" glass \u2581 of \u2581 ith \u2581 row \u2581 is : \u2581 \" . str_pad ( findWater ( $ i , $ j , $ X ) , 8 , '0' ) ; ? >"}
{"text":"Palindrome Partitioning | DP | Returns the minimum number of cuts needed to partition a string such that every part is a palindrome ; Get the length of the string ; Create two arrays to build the solution in bottom up manner C [ i ] [ j ] = Minimum number of cuts needed for palindrome partitioning of substring str [ i . . j ] P [ i ] [ j ] = true if substring str [ i . . j ] is palindrome , else false Note that C [ i ] [ j ] is 0 if P [ i ] [ j ] is true ; Every substring of length 1 is a palindrome ; L is substring length . Build the solution in a bottom - up manner by considering all substrings of length starting from 2 to n . The loop structure is same as Matrix Chain Multiplication problem ( See https : www . geeksforgeeks . org \/ matrix - chain - multiplication - dp - 8 \/ ) ; For substring of length L , set different possible starting indexes ; Set ending index ; If L is 2 , then we just need to compare two characters . Else need to check two corner characters and value of P [ i + 1 ] [ j - 1 ] ; IF str [ i . . j ] is palindrome , then C [ i ] [ j ] is 0 ; Make a cut at every possible location starting from i to j , and get the minimum cost cut . ; Return the min cut value for complete string . i . e . , str [ 0. . n - 1 ] ; Driver program to test the above function","code":"< ? php function minPalPartion ( $ str ) { $ n = strlen ( $ str ) ; $ C = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; $ P = array_fill ( false , $ n , array_fill ( false , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ P [ $ i ] [ $ i ] = true ; $ C [ $ i ] [ $ i ] = 0 ; } for ( $ L = 2 ; $ L <= $ n ; $ L ++ ) { for ( $ i = 0 ; $ i < $ n - $ L + 1 ; $ i ++ ) { $ j = $ i + $ L - 1 ; if ( $ L == 2 ) $ P [ $ i ] [ $ j ] = ( $ str [ $ i ] == $ str [ $ j ] ) ; else $ P [ $ i ] [ $ j ] = ( $ str [ $ i ] == $ str [ $ j ] ) && $ P [ $ i + 1 ] [ $ j - 1 ] ; if ( $ P [ $ i ] [ $ j ] == true ) $ C [ $ i ] [ $ j ] = 0 ; else { $ C [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = $ i ; $ k <= $ j - 1 ; $ k ++ ) $ C [ $ i ] [ $ j ] = min ( $ C [ $ i ] [ $ j ] , $ C [ $ i ] [ $ k ] + $ C [ $ k + 1 ] [ $ j ] + 1 ) ; } } } return $ C [ 0 ] [ $ n - 1 ] ; } $ str = \" ababbbabbababa \" ; echo \" Min \u2581 cuts \u2581 needed \u2581 for \u2581 Palindrome \u2581 Partitioning \u2581 is \u2581 \" . minPalPartion ( $ str ) ; return 0 ; ? >"}
{"text":"String matching with * ( that matches with any ) in any of the two strings | Function to check if the two strings can be matched or not ; if the string don 't have *  then character at that position  must be same. ; Driver Code","code":"< ? php function doMatch ( $ A , $ B ) { for ( $ i = 0 ; $ i < strlen ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] != ' * ' && $ B [ $ i ] != ' * ' ) if ( $ A [ $ i ] != $ B [ $ i ] ) return false ; return true ; } $ A = \" gee * sforgeeks \" ; $ B = \" geeksforgeeks \" ; echo doMatch ( $ A , $ B ) ; ? >"}
{"text":"Find Nth term of the series 0 , 2 , 4 , 8 , 12 , 18. . . | Calculate Nth term of series ; Driver Code","code":"< ? php function nthTerm ( $ N ) { return ( int ) ( ( $ N + $ N * ( $ N - 1 ) ) \/ 2 ) ; } $ N = 5 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Number of substrings of one string present in other | PHP program to count number of substrings of s1 present in s2 . ; s3 stores all substrings of s1 ; check the presence of s3 in s2 ; Driver code","code":"< ? php function countSubstrs ( $ s1 , $ s2 ) { $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s1 ) ; $ i ++ ) { $ s3 = \" \" ; for ( $ j = $ i ; $ j < strlen ( $ s1 ) ; $ j ++ ) { $ s3 += $ s1 [ $ j ] ; if ( stripos ( $ s2 , $ s3 , 0 ) != -1 ) $ ans ++ ; } } return $ ans ; } $ s1 = \" aab \" ; $ s2 = \" aaaab \" ; echo countSubstrs ( $ s1 , $ s2 ) ; ? >"}
{"text":"Find Nth term of series 1 , 4 , 15 , 72 , 420. . . | Function for finding factorial of N ; return factorial of N ; Function for calculating Nth term of series ; Driver code","code":"< ? php function factorial ( $ N ) { $ fact = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function nthTerm ( $ N ) { return ( factorial ( $ N ) * ( $ N + 2 ) \/ 2 ) ; } $ N = 6 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Match Expression where a single special character in pattern can match one or more characters | Returns true if pat matches with text ; i is used as an index in pattern and j as an index in text ; Traverse through pattern ; If current character of pattern is not ' # ' ; If does not match with text ; If matches , increment i and j ; Current character is ' # ' ; At least one character must match with # ; Match characters with # until a matching character is found . ; Matching with # is over , move ahead in pattern ; Driver code","code":"< ? php function regexMatch ( $ text , $ pat ) { $ lenText = strlen ( $ text ) ; $ letPat = strlen ( $ pat ) ; $ i = 0 ; $ j = 0 ; while ( $ i < $ letPat ) { if ( $ pat [ $ i ] != ' # ' ) { if ( $ pat [ $ i ] != $ text [ $ j ] ) return false ; $ i ++ ; $ j ++ ; } else { $ j ++ ; while ( $ text [ $ j ] != $ pat [ $ i + 1 ] ) $ j ++ ; $ i ++ ; } } return ( $ j == $ lenText ) ; } $ str = \" ABABABA \" ; $ pat = \" A # B # A \" ; if ( regexMatch ( $ str , $ pat ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text":"Binary Indexed Tree : Range Updates and Point Queries | Updates such that getElement ( ) gets an increased value when queried from l to r . ; Get the element indexed at i ; To get ith element sum of all the elements from 0 to i need to be computed ; Driver Code ; Find the element at Index 4 ; Find the element at Index 3","code":"< ? php function update ( & $ arr , $ l , $ r , $ val ) { $ arr [ $ l ] += $ val ; if ( $ r + 1 < sizeof ( $ arr ) ) $ arr [ $ r + 1 ] -= $ val ; } function getElement ( & $ arr , $ i ) { $ res = 0 ; for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) $ res += $ arr [ $ j ] ; return $ res ; } $ arr = array ( 0 , 0 , 0 , 0 , 0 ) ; $ n = sizeof ( $ arr ) ; $ l = 2 ; $ r = 4 ; $ val = 2 ; update ( $ arr , $ l , $ r , $ val ) ; $ index = 4 ; echo ( \" Element \u2581 at \u2581 index \u2581 \" . $ index . \" \u2581 is \u2581 \" . getElement ( $ arr , $ index ) . \" STRNEWLINE \" ) ; $ l = 0 ; $ r = 3 ; $ val = 4 ; update ( $ arr , $ l , $ r , $ val ) ; $ index = 3 ; echo ( \" Element \u2581 at \u2581 index \u2581 \" . $ index . \" \u2581 is \u2581 \" . getElement ( $ arr , $ index ) ) ; ? >"}
{"text":"Number of ways to arrange 2 * N persons on the two sides of a table with X and Y persons on opposite sides | Function to find factorial of a number ; Function to find nCr ; Function to find the number of ways to arrange 2 * N persons ; Driver code ; Function call","code":"< ? php function factorial ( $ n ) { if ( $ n <= 1 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } function nCr ( $ n , $ r ) { return factorial ( $ n ) \/ ( factorial ( $ n - $ r ) * factorial ( $ r ) ) ; } function NumberOfWays ( $ n , $ x , $ y ) { return nCr ( 2 * $ n - $ x - $ y , $ n - $ x ) * factorial ( $ n ) * factorial ( $ n ) ; } $ n = 5 ; $ x = 4 ; $ y = 2 ; echo ( NumberOfWays ( $ n , $ x , $ y ) ) ; ? >"}
{"text":"Count Pairs from two arrays with even sum | Function to return count of required pairs ; Count of odd and even numbers from both the arrays ; Find the count of odd and even elements in a [ ] ; Find the count of odd and even elements in b [ ] ; Count the number of pairs ; Return the number of pairs ; Driver code ; This code is contributes by AnkitRai01","code":"< ? php function count_pairs ( $ a , $ b , $ n , $ m ) { $ odd1 = 0 ; $ even1 = 0 ; $ odd2 = 0 ; $ even2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 1 ) $ odd1 ++ ; else $ even1 ++ ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ b [ $ i ] % 2 == 1 ) $ odd2 ++ ; else $ even2 ++ ; } $ pairs = min ( $ odd1 , $ odd2 ) + min ( $ even1 , $ even2 ) ; return $ pairs ; } $ a = array ( 9 , 14 , 6 , 2 , 11 ) ; $ b = array ( 8 , 4 , 7 , 20 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; echo count_pairs ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text":"Find the value of N when F ( N ) = f ( a ) + f ( b ) where a + b is the minimum possible and a * b = N | Function to return the value of F ( N ) ; Base cases ; Count the number of times a number if divisible by 2 ; Return the summation ; Driver code","code":"< ? php function getValueOfF ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; $ cnt = 0 ; while ( $ n % 2 == 0 ) { $ cnt += 1 ; $ n \/= 2 ; } return 2 * $ cnt ; } $ n = 20 ; echo getValueOfF ( $ n ) ; ? >"}
{"text":"Find ( 1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n ) mod 5 | Set 2 | Function to return A mod B ; length of the string ; to store required answer ; Function to return ( 1 ^ n + 2 ^ n + 3 ^ n + 4 ^ n ) % 5 ; Calculate and return ans ; Driver code","code":"< ? php function A_mod_B ( $ N , $ a ) { $ len = strlen ( $ N ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ ans = ( $ ans * 10 + ( int ) $ N [ $ i ] - '0' ) % $ a ; return $ ans % $ a ; } function findMod ( $ N ) { $ mod = A_mod_B ( $ N , 4 ) ; $ ans = ( 1 + pow ( 2 , $ mod ) + pow ( 3 , $ mod ) + pow ( 4 , $ mod ) ) ; return ( $ ans % 5 ) ; } $ N = \"4\" ; echo findMod ( $ N ) ; ? >"}
{"text":"Elements greater than the previous and next element in an Array | Function to print elements greater than the previous and next element in an Array ; Traverse array from index 1 to n - 2 and check for the given condition ; Driver Code","code":"< ? php function printElements ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] and $ arr [ $ i ] > $ arr [ $ i + 1 ] ) echo $ arr [ $ i ] . \" \u2581 \" ; } } $ arr = array ( 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ) ; $ n = sizeof ( $ arr ) ; printElements ( $ arr , $ n ) ;"}
{"text":"Sum of the series Kn + ( K ( n | Recursive C program to compute modular power ; Base cases ; If B is even ; If B is odd ; Function to return sum ; Driver code","code":"< ? php function exponent ( $ A , $ B ) { if ( $ A == 0 ) return 0 ; if ( $ B == 0 ) return 1 ; if ( $ B % 2 == 0 ) { $ y = exponent ( $ A , $ B \/ 2 ) ; $ y = ( $ y * $ y ) ; } else { $ y = $ A ; $ y = ( $ y * exponent ( $ A , $ B - 1 ) ) ; } return $ y ; } function sum ( $ k , $ n ) { $ sum = exponent ( $ k , $ n + 1 ) - exponent ( $ k - 1 , $ n + 1 ) ; return $ sum ; } $ n = 3 ; $ K = 3 ; echo sum ( $ K , $ n ) ; ? >"}
{"text":"Minimize the cost to split a number | check if a number is prime or not ; run a loop upto square root of x ; Function to return the minimized cost ; If n is prime ; If n is odd and can be split into ( prime + 2 ) then cost will be 1 + 1 = 2 ; Every non - prime even number can be expressed as the sum of two primes ; n is odd so n can be split into ( 3 + even ) further even part can be split into ( prime + prime ) ( 3 + prime + prime ) will cost 3 ; Driver code","code":"< ? php function isPrime ( $ x ) { for ( $ i = 2 ; $ i * $ i <= $ x ; $ i ++ ) { if ( $ x % $ i == 0 ) return 0 ; } return 1 ; } function minimumCost ( $ n ) { if ( isPrime ( $ n ) ) return 1 ; if ( $ n % 2 == 1 && isPrime ( $ n - 2 ) ) return 2 ; if ( $ n % 2 == 0 ) return 2 ; return 3 ; } $ n = 6 ; echo ( minimumCost ( $ n ) ) ;"}
{"text":"Find amount of water wasted after filling the tank | Function to calculate amount of wasted water ; filled amount of water in one minute ; total time taken to fill the tank because of leakage ; wasted amount of water ; Driver code","code":"< ? php function wastedWater ( $ V , $ M , $ N ) { $ amt_per_min = $ M - $ N ; $ time_to_fill = $ V \/ $ amt_per_min ; $ wasted_amt = $ N * $ time_to_fill ; return $ wasted_amt ; } $ V = 700 ; $ M = 10 ; $ N = 3 ; echo wastedWater ( $ V , $ M , $ N ) , \" STRNEWLINE \" ; $ V = 1000 ; $ M = 100 ; $ N = 50 ; echo wastedWater ( $ V , $ M , $ N ) ;"}
{"text":"Smallest and Largest N | Function to print the largest and the smallest n - digit perfect cube ; Smallest n - digit perfect cube ; Largest n - digit perfect cube ; Driver code","code":"< ? php function nDigitPerfectCubes ( $ n ) { print ( pow ( ceil ( pow ( pow ( 10 , ( $ n - 1 ) ) , 1 \/ 3 ) ) , 3 ) . \" \u2581 \" ) ; print ( ( int ) pow ( ceil ( pow ( pow ( 10 , ( $ n ) ) , 1 \/ 3 ) ) - 1 , 3 ) ) ; } $ n = 3 ; nDigitPerfectCubes ( $ n ) ; ? >"}
{"text":"Count numbers which are divisible by all the numbers from 2 to 10 | Function to return the count of numbers from 1 to n which are divisible by all the numbers from 2 to 10 ; Driver code","code":"< ? php function countNumbers ( $ n ) { return ( int ) ( $ n \/ 2520 ) ; } $ n = 3000 ; echo ( countNumbers ( $ n ) ) ; ? >"}
{"text":"Sum of all odd factors of numbers in the range [ l , r ] | PHP implementation of the approach ; Function to calculate the prefix sum of all the odd factors ; Add i to all the multiples of i ; Update the prefix sum ; Function to return the sum of all the odd factors of the numbers in the given range ; Driver code","code":"< ? php $ MAX = 10001 ; $ prefix = array_fill ( 0 , $ MAX , 0 ) ; function sieve_modified ( ) { global $ prefix , $ MAX ; for ( $ i = 1 ; $ i < $ MAX ; $ i += 2 ) { for ( $ j = $ i ; $ j < $ MAX ; $ j += $ i ) $ prefix [ $ j ] += $ i ; } for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) $ prefix [ $ i ] += $ prefix [ $ i - 1 ] ; } function sumOddFactors ( $ L , $ R ) { global $ prefix ; return ( $ prefix [ $ R ] - $ prefix [ $ L - 1 ] ) ; } sieve_modified ( ) ; $ l = 6 ; $ r = 10 ; echo sumOddFactors ( $ l , $ r ) ;"}
{"text":"XOR of a submatrix queries | PHP implementation of the approach ; Function to pre - compute the xor ; Left to right prefix xor for each row ; Top to bottom prefix xor for each column ; Function to process the queries x1 , x2 , y1 , y2 represent the positions of the top - left and bottom right corners ; To store the xor values ; Finding the values we need to xor with value at ( x2 , y2 ) in prefix - xor matrix ; Return the required prefix xor ; Driver code ; To store pre - computed xor ; Pre - computing xor ; Queries","code":"< ? php $ n = 3 ; function preComputeXor ( $ arr , & $ prefix_xor ) { global $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j == 0 ) $ prefix_xor [ $ i ] [ $ j ] = $ arr [ $ i ] [ $ j ] ; else $ prefix_xor [ $ i ] [ $ j ] = ( $ prefix_xor [ $ i ] [ $ j - 1 ] ^ $ arr [ $ i ] [ $ j ] ) ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 1 ; $ j < $ n ; $ j ++ ) $ prefix_xor [ $ j ] [ $ i ] = ( $ prefix_xor [ $ j - 1 ] [ $ i ] ^ $ prefix_xor [ $ j ] [ $ i ] ) ; } function ansQuerie ( $ prefix_xor , $ x1 , $ y1 , $ x2 , $ y2 ) { $ xor_1 = $ xor_2 = $ xor_3 = 0 ; if ( $ x1 != 0 ) $ xor_1 = $ prefix_xor [ $ x1 - 1 ] [ $ y2 ] ; if ( $ y1 != 0 ) $ xor_2 = $ prefix_xor [ $ x2 ] [ $ y1 - 1 ] ; if ( $ x1 != 0 and $ y1 != 0 ) $ xor_3 = $ prefix_xor [ $ x1 - 1 ] [ $ y1 - 1 ] ; return ( ( $ prefix_xor [ $ x2 ] [ $ y2 ] ^ $ xor_1 ) ^ ( $ xor_2 ^ $ xor_3 ) ) ; } $ arr = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ prefix_xor = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; preComputeXor ( $ arr , $ prefix_xor ) ; echo ansQuerie ( $ prefix_xor , 1 , 1 , 2 , 2 ) . \" \" ; echo ansQuerie ( $ prefix_xor , 1 , 2 , 2 , 2 ) ; ? >"}
{"text":"Numbers less than N that are perfect cubes and the sum of their digits reduced to a single digit is 1 | Function that returns true if the eventual digit sum of number nm is 1 ; if reminder will 1 then eventual sum is 1 ; Function to print the required numbers less than n ; If it is the required perfect cube ; Driver code","code":"< ? php function isDigitSumOne ( $ nm ) { if ( $ nm % 9 == 1 ) return true ; else return false ; } function printValidNums ( $ n ) { $ cbrt_n = ceil ( pow ( $ n , 1 \/ 3 ) ) ; for ( $ i = 1 ; $ i <= $ cbrt_n ; $ i ++ ) { $ cube = pow ( $ i , 3 ) ; if ( $ cube >= 1 && $ cube <= $ n && isDigitSumOne ( $ cube ) ) echo $ cube , \" \u2581 \" ; } } $ n = 1000 ; printValidNums ( $ n ) ; ? >"}
{"text":"Count the number of rhombi possible inside a rectangle of given size | Function to return the count of rhombi possible ; All possible diagonal lengths ; Update rhombi possible with the current diagonal lengths ; Return the total count of rhombi possible ; Driver code","code":"< ? php function countRhombi ( $ h , $ w ) { $ ct = 0 ; for ( $ i = 2 ; $ i <= $ h ; $ i += 2 ) for ( $ j = 2 ; $ j <= $ w ; $ j += 2 ) $ ct += ( $ h - $ i + 1 ) * ( $ w - $ j + 1 ) ; return $ ct ; } $ h = 2 ; $ w = 2 ; echo ( countRhombi ( $ h , $ w ) ) ; ? >"}
{"text":"Program to calculate the area between two Concentric Circles | Function to find area between the two given concentric circles ; Declare value of pi ; Calculate area of outer circle ; Calculate area of inner circle ; Difference in areas ; Driver Code","code":"< ? php function calculateArea ( $ x , $ y ) { $ pi = 3.1415926536 ; $ arx = $ pi * $ x * $ x ; $ ary = $ pi * $ y * $ y ; return ( $ arx - $ ary ) ; } $ x = 2 ; $ y = 1 ; echo calculateArea ( $ x , $ y ) ; ? >"}
{"text":"Find the winner by adding Pairwise difference of elements in the array until Possible | Function to calculate gcd ; Function to return the winner of the game ; To store the gcd of the original array ; To store the maximum element from the original array ; If number of moves are odd ; Driver Code","code":"< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function getWinner ( $ arr , $ n ) { $ gcd = $ arr [ 0 ] ; $ maxEle = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ gcd = __gcd ( $ gcd , $ arr [ $ i ] ) ; $ maxEle = max ( $ maxEle , $ arr [ $ i ] ) ; } $ totalMoves = ( $ maxEle \/ $ gcd ) - $ n ; if ( $ totalMoves % 2 == 1 ) return ' A ' ; return ' B ' ; } $ arr = array ( 5 , 6 , 7 ) ; $ n = sizeof ( $ arr ) ; echo getWinner ( $ arr , $ n ) ; ? >"}
{"text":"Count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | PHP implementation of the approach ; Number which will give the max value for ( ( n % i ) % j ) % n ; To store the maximum possible value of ( ( n % i ) % j ) % n ; To store the count of possible pairs ; Check all possible pairs ; Calculating the value of ( ( n % i ) % j ) % n ; If value is equal to maximum ; Return the number of possible pairs ; Driver code","code":"< ? php function countPairs ( $ n ) { $ num = ( ( $ n \/ 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ val = ( ( $ n % $ i ) % $ j ) % $ n ; if ( $ val == $ max ) $ count ++ ; } } return $ count ; } $ n = 5 ; echo ( countPairs ( $ n ) ) ; ? >"}
{"text":"Program to check if a number is divisible by any of its digits | Function to check if given number is divisible by any of its digits ; check if any of digit divides n ; check if K divides N ; Driver Code","code":"< ? php function isDivisible ( $ n ) { $ temp = $ n ; while ( $ n ) { $ k = $ n % 10 ; if ( $ temp % $ k == 0 ) return \" YES \" ; $ n = floor ( $ n \/ 10 ) ; } return \" NO \" ; } $ n = 9876543 ; echo isDivisible ( $ n ) ; ? >"}
{"text":"Program to find sum of harmonic series | Function to return sum of harmonic series ; Driver Code","code":"< ? php function sum ( $ n ) { $ i ; $ s = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s = $ s + 1 \/ $ i ; return $ s ; } $ n = 5 ; echo ( \" Sum \u2581 is \u2581 \" ) ; echo ( sum ( $ n ) ) ; ? >"}
{"text":"Check if a number can be expressed as sum two abundant numbers | Function to return all abundant numbers This function will be helpful for multiple queries ; To store abundant numbers ; to store sum of the divisors include 1 in the sum ; if j is proper divisor ; if i is not a perfect square ; if sum is greater than i then i is a abundant number ; Check if number n is expressed as sum of two abundant numbers ; if both i and n - i are abundant numbers ; can not be expressed ; Driver code","code":"< ? php function ABUNDANT ( ) { $ N = 100005 ; $ v = array ( ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ sum = 1 ; for ( $ j = 2 ; $ j * $ j <= $ i ; $ j ++ ) { if ( $ i % $ j == 0 ) { $ sum += $ j ; if ( $ i \/ $ j != $ j ) $ sum += $ i \/ $ j ; } } if ( $ sum > $ i ) array_push ( $ v , $ i ) ; } $ v = array_unique ( $ v ) ; return $ v ; } function SumOfAbundant ( $ n ) { $ v = ABUNDANT ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( in_array ( $ i , $ v ) && in_array ( $ n - $ i , $ v ) ) { echo $ i , \" \u2581 \" , $ n - $ i ; return ; } } echo - 1 ; } $ n = 24 ; SumOfAbundant ( $ n ) ; ? >"}
{"text":"Find nth term of the series 5 2 13 41 | function to calculate nth term of the series ; if n is even number ; if n is odd number ; return nth term ; Driver code","code":"< ? php function nthTermOfTheSeries ( $ n ) { if ( $ n % 2 == 0 ) $ nthTerm = pow ( $ n - 1 , 2 ) + $ n ; else $ nthTerm = pow ( $ n + 1 , 2 ) + $ n ; return $ nthTerm ; } $ n = 8 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 12 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 102 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 999 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; $ n = 9999 ; echo nthTermOfTheSeries ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find cost price from given selling price and profit or loss percentage | Function to calculate cost price with profit ; required formula to calculate CP with profit ; Function to calculate cost price with loss ; required formula to calculate CP with loss ; Driver code","code":"< ? php function CPwithProfit ( $ sellingPrice , $ profit ) { $ costPrice = ( $ sellingPrice * 100.0 ) \/ ( 100 + $ profit ) ; return $ costPrice ; } function CPwithLoss ( $ sellingPrice , $ loss ) { $ costPrice = ( $ sellingPrice * 100.0 ) \/ ( 100 - $ loss ) ; return $ costPrice ; } $ SP = 1020 ; $ profit = 20 ; echo ( \" Cost \u2581 Price \u2581 = \u2581 \" ) ; echo ( CPwithProfit ( $ SP , $ profit ) ) ; echo ( \" STRNEWLINE \" ) ; $ SP = 900 ; $ loss = 10 ; echo ( \" Cost \u2581 Price \u2581 = \u2581 \" ) ; echo ( CPwithLoss ( $ SP , $ loss ) ) ; echo ( \" STRNEWLINE \" ) ; $ SP = 42039 ; $ profit = 8 ; echo ( \" Cost \u2581 Price \u2581 = \u2581 \" ) ; echo ( CPwithProfit ( $ SP , $ profit ) ) ; echo ( \" STRNEWLINE \" ) ; ? >"}
{"text":"Check whether a number is Non | Function to find prime factor and check if it is of the form 4 k + 1 or not ; 2 is a prime number but not of the form 4 k + 1 so , keep Dividing n by 2 until n is divisible by 2 ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; if i divides n check if i is of the form 4 k + 1 or not ; while i divides n divide n by i and update n ; This condition is to handle the case when n is a prime number greater than 2 ; Test function ; Driver code","code":"< ? php function isNonHypotenuse ( $ n ) { while ( $ n % 2 == 0 ) { $ n = $ n \/ 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { if ( ( $ i - 1 ) % 4 == 0 ) return false ; while ( $ n % $ i == 0 ) { $ n = $ n \/ $ i ; } } } if ( $ n > 2 && ( $ n - 1 ) % 4 == 0 ) return false ; else return true ; } function test ( $ n ) { echo \" Testing \u2581 for \u2581 \" , $ n , \" \u2581 : \u2581 \" ; if ( isNonHypotenuse ( $ n ) ) echo \" YES \" . \" STRNEWLINE \" ; else echo \" NO \" . \" STRNEWLINE \" ; } $ n = 11 ; test ( $ n ) ; $ n = 10 ; test ( $ n ) ; ? >"}
{"text":"Find the n | Function to return the nth string in the required sequence ; Length of the resultant string ; Relative index ; Initial string of length len consists of all a 's since the  list is sorted ; Convert relative index to Binary form and set 0 = a and 1 = b ; Reverse and return the string ; Driver Code","code":"< ? php function obtain_str ( $ n ) { $ len = ( int ) ( log ( $ n + 1 ) \/ log ( 2 ) ) ; $ rel_ind = $ n + 1 - pow ( 2 , $ len ) ; $ i = 0 ; $ str = \" \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ str . = ' a ' ; } $ i = 0 ; while ( $ rel_ind > 0 ) { if ( $ rel_ind % 2 == 1 ) $ str [ $ i ] = ' b ' ; $ rel_ind = ( int ) ( $ rel_ind \/ 2 ) ; $ i ++ ; } return strrev ( $ str ) ; } $ n = 11 ; echo obtain_str ( $ n ) ; ? >"}
{"text":"Program to find the Nth term of the series 0 , 3 \/ 1 , 8 \/ 3 , 15 \/ 5. . ... ... | Function to return the nth term of the given series ; nth term ; Driver code","code":"< ? php function Nthterm ( $ n ) { $ numerator = ( pow ( $ n , 2 ) ) -1 ; $ denomenator = 2 * $ n - 3 ; echo $ numerator , \" \/ \" , $ denomenator ; return $ Tn ; } $ n = 3 ; Nthterm ( $ n ) ; ? >"}
{"text":"Sum of each element raised to ( prime | Function to return the required sum ; Driver code","code":"< ? php function getSum ( $ arr , $ p ) { return count ( $ arr ) ; } $ arr = array ( 5 , 6 , 8 ) ; $ p = 7 ; echo ( getSum ( $ arr , $ p ) ) ; ? >"}
{"text":"Count numbers upto N which are both perfect square and perfect cube | Function to return required count ; Driver Code ; function call to print required answer","code":"< ? php function SquareCube ( $ N ) { $ cnt = 0 ; $ i = 1 ; while ( ( pow ( $ i , 6 ) ) <= $ N ) { ++ $ cnt ; ++ $ i ; } return $ cnt ; } $ N = 100000 ; echo SquareCube ( $ N ) ; ? >"}
{"text":"Sum of integers upto N with given unit digit | Function to return the required sum ; Driver code","code":"< ? php function getSum ( $ n , $ d ) { $ sum = 0 ; while ( $ d <= $ n ) { $ sum += $ d ; $ d += 10 ; } return $ sum ; } $ n = 30 ; $ d = 3 ; echo ( getSum ( $ n , $ d ) ) ; ? >"}
{"text":"Summing the sum series | Function to calculate twice of sum of first N natural numbers ; Function to calculate the terms of summing of sum series ; Driver Code","code":"< ? php function sum ( $ N ) { $ MOD = 1000000007 ; $ val = $ N * ( $ N + 1 ) ; $ val = $ val % $ MOD ; return $ val ; } function sumX ( $ N , $ M , $ K ) { $ MOD = 1000000007 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { $ N = sum ( $ K + $ N ) ; } $ N = $ N % $ MOD ; return $ N ; } $ N = 1 ; $ M = 2 ; $ K = 3 ; echo ( sumX ( $ N , $ M , $ K ) ) ; ? >"}
{"text":"Logarithm | PHP program to find log ( n ) using Recursion ; Drive main","code":"< ? php function Log2n ( $ n ) { return ( $ n > 1 ) ? 1 + Log2n ( $ n \/ 2 ) : 0 ; } $ n = 32 ; echo Log2n ( $ n ) ; ? >"}
{"text":"Harmonic Progression | PHP program to check if a given array can form harmonic progression ; Find reciprocal of arr [ ] ; After finding reciprocal , check if the reciprocal is in A . P . To check for A . P . , first Sort the reciprocal array , then check difference between consecutive elements ; series to check whether it is in H . P ; Checking a series is in H . P or not","code":"< ? php function checkIsHP ( $ arr ) { $ n = count ( $ arr ) ; if ( $ n == 1 ) return true ; $ rec = array ( ) ; for ( $ i = 0 ; $ i < count ( $ arr ) ; $ i ++ ) { $ a = 1 \/ $ arr [ $ i ] ; array_push ( $ rec , $ a ) ; } return ( $ rec ) ; sort ( $ rec ) ; $ d = $ rec [ 1 ] - $ rec [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ rec [ $ i ] - $ rec [ $ i - 1 ] != $ d ) return false ; return true ; } $ arr = array ( 1 \/ 5 , 1 \/ 10 , 1 \/ 15 , 1 \/ 20 , 1 \/ 25 ) ; if ( checkIsHP ( $ arr ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text":"Arithmetic Mean | Prints N arithmetic means between A and B . ; calculate common difference ( d ) ; for finding N the arithmetic mean between A and B ; Driver Code","code":"< ? php function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) \/ ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , \" \u2581 \" ; } $ A = 20 ; $ B = 32 ; $ N = 5 ; printAMeans ( $ A , $ B , $ N ) ;"}
{"text":"Prime Factor | function to print all prime factors of a given number n ; Print the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Driver Code","code":"< ? php function primeFactors ( $ n ) { while ( $ n % 2 == 0 ) { echo 2 , \" \u2581 \" ; $ n = $ n \/ 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { echo $ i , \" \" ; $ n = $ n \/ $ i ; } } if ( $ n > 2 ) echo $ n , \" \u2581 \" ; } $ n = 315 ; primeFactors ( $ n ) ; ? >"}
{"text":"Time taken by two persons to meet on a circular track | PHP implementation of above approach ; Function to return the time when both the persons will meet at the starting point ; Time to cover 1 round by both ; Finding LCM to get the meeting point ; Function to return the time when both the persons will meet for the first time ; Driver Code ; Calling function","code":"< ? php function gcd ( $ a , $ b ) { return $ b ? gcd ( $ b , $ a % $ b ) : $ a ; } function startingPoint ( $ Length , $ Speed1 , $ Speed2 ) { $ result1 = 0 ; $ result2 = 0 ; $ time1 = $ Length \/ $ Speed1 ; $ time2 = $ Length \/ $ Speed2 ; $ result1 = gcd ( $ time1 , $ time2 ) ; $ result2 = $ time1 * $ time2 \/ ( $ result1 ) ; return $ result2 ; } function firstTime ( $ Length , $ Speed1 , $ Speed2 ) { $ result = 0 ; $ relativeSpeed = abs ( $ Speed1 - $ Speed2 ) ; $ result = ( ( float ) $ Length \/ $ relativeSpeed ) ; return $ result ; } $ L = 30 ; $ S1 = 5 ; $ S2 = 2 ; $ first_Time = firstTime ( $ L , $ S1 , $ S2 ) ; $ starting_Point = startingPoint ( $ L , $ S1 , $ S2 ) ; echo \" Met \u2581 first \u2581 time \u2581 after \u2581 \" . $ first_Time . \" \u2581 hrs \" . \" STRNEWLINE \" ; echo \" Met \u2581 at \u2581 starting \u2581 point \u2581 after \u2581 \" . $ starting_Point . \" \u2581 hrs \" . \" STRNEWLINE \" ; ? >"}
{"text":"Check if the array has an element which is equal to product of remaining elements | Function to Check if the array has an element which is equal to product of all the remaining elements ; Calculate the product of all the elements ; Return true if any such element is found ; If no element is found ; Driver Code","code":"< ? php function CheckArray ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ prod *= $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] == $ prod \/ $ arr [ $ i ] ) return true ; return false ; } $ arr = array ( 1 , 2 , 12 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; if ( CheckArray ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ;"}
{"text":"Sum of common divisors of two numbers A and B | print the sum of common factors ; sum of common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; print the sum of common factors","code":"< ? php function sum ( $ a , $ b ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) if ( $ a % $ i == 0 && $ b % $ i == 0 ) $ sum += $ i ; return $ sum ; } $ A = 10 ; $ B = 15 ; echo \" Sum = \" ? >"}
{"text":"Minimum number of cuts required to make circle segments equal sized | Recursive function to return gcd of two nos ; Function to find the minimum number of additional cuts required to make circle segments are equal sized ; Sort the array ; Initial gcd value ; Including the last segment ; Driver Code","code":"< ? php function findgcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return findgcd ( $ b , $ a % $ b ) ; } function minimumCuts ( $ a , $ n ) { sort ( $ a ) ; $ gcd = $ a [ 1 ] - $ a [ 0 ] ; $ s = $ gcd ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ gcd = findgcd ( $ gcd , $ a [ $ i ] - $ a [ $ i - 1 ] ) ; $ s += $ a [ $ i ] - $ a [ $ i - 1 ] ; } if ( 360 - $ s > 0 ) $ gcd = findgcd ( $ gcd , 360 - $ s ) ; return ( 360 \/ $ gcd ) - $ n ; } $ arr = array ( 30 , 60 , 180 ) ; $ n = sizeof ( $ arr ) ; echo ( minimumCuts ( $ arr , $ n ) ) ; ? >"}
{"text":"Find Selling Price from given Profit Percentage and Cost | Function to calculate the Selling Price ; Decimal Equivalent of Profit Percentage ; Find the Selling Price ; return the calculated Selling Price ; Get the CP and Profit % ; Printing the returned value","code":"< ? php function SellingPrice ( $ CP , $ PP ) { $ P_decimal = 1 + ( $ PP \/ 100 ) ; $ res = $ P_decimal * $ CP ; return $ res ; } $ C = 720 ; $ P = 13 ; echo SellingPrice ( $ C , $ P ) ; ? >"}
{"text":"Product of all the Composite Numbers in an array | Function that returns the the product of all composite numbers ; Find maximum value in the array ; Use sieve to find all prime numbers less than or equal to max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Set 0 and 1 as primes as they don 't need to be  counted as composite numbers ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Find the product of all composite numbers in the arr [ ] ; Driver code","code":"< ? php function compositeProduct ( $ arr , $ n ) { $ max_val = max ( $ arr ) ; $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = true ; $ prime [ 1 ] = true ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ! $ prime [ $ arr [ $ i ] ] ) { $ product *= $ arr [ $ i ] ; } return $ product ; } $ arr = array ( 2 , 3 , 4 , 5 , 6 , 7 ) ; $ n = count ( $ arr ) ; echo compositeProduct ( $ arr , $ n ) ; ? >"}
{"text":"Primality test for the sum of digits at odd places of a number | Function that return sum of the digits at odd places ; Function that returns true if the number is prime else false ; Corner cases ; This condition is checked so that we can skip middle five numbers in the below loop ; Driver code ; Get the sum of the digits at odd places","code":"< ? php function sum_odd ( $ n ) { $ sum = 0 ; $ pos = 1 ; while ( $ n ) { if ( $ pos % 2 == 1 ) $ sum += $ n % 10 ; $ n = ( int ) ( $ n \/ 10 ) ; $ pos ++ ; } return $ sum ; } function check_prime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = ( $ i + 6 ) ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } $ n = 223 ; $ sum = sum_odd ( $ n ) ; if ( check_prime ( $ sum ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find amount to be added to achieve target ratio in a given mixture | PHP program to find amount of water to be added to achieve given target ratio . ; Driver Code","code":"< ? php function findAmount ( $ X , $ W , $ Y ) { return ( $ X * ( $ Y - $ W ) ) \/ ( 100 - $ Y ) ; } $ X = 100 ; $ W = 50 ; $ Y = 60 ; echo \" Water \u2581 to \u2581 be \u2581 added \u2581 = \u2581 \" . findAmount ( $ X , $ W , $ Y ) ; ? >"}
{"text":"Check if a number is a Mystery Number | Finds reverse of given num x . ; if found print the pair , return","code":"< ? php function reverseNum ( $ x ) { $ s = ( string ) $ x ; $ s = strrev ( $ s ) ; $ rev = ( int ) $ s ; return $ rev ; } function isMysteryNumber ( $ n ) { for ( $ i = 1 ; $ i <= $ n \/ 2 ; $ i ++ ) { $ j = reverseNum ( $ i ) ; if ( $ i + $ j == $ n ) { echo $ i . \" \u2581 \" . $ j ; return true ; } } echo \" Not \u2581 a \u2581 Mystery \u2581 Number \" ; return false ; } $ n = 121 ; isMysteryNumber ( $ n ) ; return 0 ; ? >"}
{"text":"Replace every element of the array by product of all other elements | PHP program to Replace every element by the product of all other elements ; Calculate the product of all the elements ; Replace every element product of all other elements ; Driver Code ; Print the modified array .","code":"< ? php function ReplaceElements ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ prod *= $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ arr [ $ i ] = ( int ) ( $ prod \/ $ arr [ $ i ] ) ; } return $ arr ; } $ arr = array ( 2 , 3 , 3 , 5 , 7 ) ; $ n = sizeof ( $ arr ) ; $ arr1 = ReplaceElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { echo $ arr1 [ $ i ] . \" \" ; } ? >"}
{"text":"Check if there is any pair in a given range with GCD is divisible by k | function to count such possible numbers ; if i is divisible by k ; if count of such numbers is greater than one ; Driver code","code":"< ? php function Check_is_possible ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % $ k == 0 ) $ count ++ ; } return ( $ count > 1 ) ; } $ l = 4 ; $ r = 12 ; $ k = 5 ; if ( Check_is_possible ( $ l , $ r , $ k ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text":"Sum of first N natural numbers which are divisible by 2 and 7 | Function to calculate the sum of numbers divisible by 2 or 7 ; Driver code","code":"< ? php function sum ( $ N ) { $ S1 = ( int ) ( ( $ N \/ 2 ) ) * ( int ) ( 2 * 2 + ( int ) ( $ N \/ 2 - 1 ) * 2 ) \/ 2 ; $ S2 = ( int ) ( ( $ N \/ 7 ) ) * ( int ) ( 2 * 7 + ( int ) ( $ N \/ 7 - 1 ) * 7 ) \/ 2 ; $ S3 = ( int ) ( ( $ N \/ 14 ) ) * ( int ) ( 2 * 14 + ( int ) ( $ N \/ 14 - 1 ) * 14 ) \/ 2 ; return ( $ S1 + $ S2 ) - $ S3 ; } $ N = 20 ; echo sum ( $ N ) ;"}
{"text":"Ways to color a skewed tree such that parent and child have different colors | fast_way is recursive method to calculate power ; Driver Code","code":"< ? php function fastPow ( $ N , $ K ) { if ( $ K == 0 ) return 1 ; $ temp = fastPow ( $ N , $ K \/ 2 ) ; if ( $ K % 2 == 0 ) return $ temp * $ temp ; else return $ N * $ temp * $ temp ; } function countWays ( $ N , $ K ) { return $ K * fastPow ( $ K - 1 , $ N - 1 ) ; } $ N = 3 ; $ K = 3 ; echo countWays ( $ N , $ K ) ; ? >"}
{"text":"Sum of nth terms of Modified Fibonacci series made by every pair of two arrays | PHP program to find sum of n - th terms of a Fibonacci like series formed using first two terms of two arrays . ; if sum of first term is required ; if sum of second term is required ; fibonacci series used to find the nth term of every series ; as every b [ i ] term appears m times and every a [ i ] term also appears m times ; m is the size of the array","code":"< ? php function sumNth ( & $ A , & $ B , & $ m , & $ n ) { $ res = 0 ; if ( $ n == 1 ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = $ res + $ A [ $ i ] ; } else if ( $ n == 2 ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = $ res + $ B [ $ i ] * $ m ; } else { $ f = array ( ) ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ f [ $ i ] = $ f [ $ i - 1 ] + $ f [ $ i - 2 ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ res = $ res + ( $ m * ( $ B [ $ i ] * $ f [ $ n - 1 ] ) ) + ( $ m * ( $ A [ $ i ] * $ f [ $ n - 2 ] ) ) ; } } return $ res ; } $ A = array ( 1 , 2 , 3 ) ; $ B = array ( 4 , 5 , 6 ) ; $ n = 3 ; $ m = sizeof ( $ A ) ; echo ( sumNth ( $ A , $ B , $ m , $ n ) ) ; ? >"}
{"text":"Puzzle | Minimum distance for Lizard | side of cube ; understand from diagram ; understand from diagram ; minimum distance","code":"< ? php $ a = 5 ; $ AC = $ a ; $ CE = 2 * $ a ; $ shortestDistance = ( double ) ( sqrt ( $ AC * $ AC + $ CE * $ CE ) ) ; echo $ shortestDistance . \" STRNEWLINE \" ; ? >"}
{"text":"Find Sum of Series 1 ^ 2 | Function to find sum of series ; If n is even ; If n is odd ; return the result ; Get n ; Find the sum ; Get n ; Find the sum","code":"< ? php function sum_of_series ( $ n ) { $ result = 0 ; if ( $ n % 2 == 0 ) { $ result = - ( $ n * ( $ n + 1 ) ) \/ 2 ; } else { $ result = ( $ n * ( $ n + 1 ) ) \/ 2 ; } return $ result ; } $ n = 3 ; echo sum_of_series ( $ n ) ; echo ( \" STRNEWLINE \" ) ; $ n = 10 ; echo sum_of_series ( $ n ) ; echo ( \" STRNEWLINE \" ) ; ? >"}
{"text":"Check whether the given numbers are Cousin prime or not | Function to check if the given Number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Returns true if n1 and n2 are Cousin primes ; Check if the given number differ by 4 or not ; Check if both numbers are prime or not ; Get the 2 numbers ; Check the numbers for cousin prime","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isCousinPrime ( $ n1 , $ n2 ) { if ( abs ( $ n1 - $ n2 ) != 4 ) return false ; else return ( isPrime ( $ n1 ) && isPrime ( $ n2 ) ) ; } $ n1 = 7 ; $ n2 = 11 ; if ( isCousinPrime ( $ n1 , $ n2 ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Thabit number | Utility function to check power of two ; function to check if the given number is Thabit Number ; Add 1 to the number ; Divide the number by 3 ; Check if the given number is power of 2 ; Driver Code ; Check if number is thabit number","code":"< ? php function isPowerOfTwo ( $ n ) { return ( $ n && ! ( $ n & ( $ n - 1 ) ) ) ; } function isThabitNumber ( $ n ) { $ n = $ n + 1 ; if ( $ n % 3 == 0 ) $ n = $ n \/ 3 ; else return false ; if ( isPowerOfTwo ( $ n ) ) return true ; else return false ; } $ n = 47 ; if ( isThabitNumber ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Smallest Integer to be inserted to have equal sums | Function to find the minimum value to be added ; Variable to store entire array sum ; Variables to store sum of subarray1 and subarray 2 ; minimum value to be added ; Traverse through the array ; Sum of both halves ; Calculate minimum number to be added ; Driver code ; Length of array","code":"< ? php function findMinEqualSums ( $ a , $ N ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ sum += $ a [ $ i ] ; } $ sum1 = 0 ; $ sum2 = 0 ; $ min = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ sum1 += $ a [ $ i ] ; $ sum2 = $ sum - $ sum1 ; if ( abs ( $ sum1 - $ sum2 ) < $ min ) { $ min = abs ( $ sum1 - $ sum2 ) ; } if ( $ min == 0 ) { break ; } } return $ min ; } $ a = array ( 3 , 2 , 1 , 5 , 7 , 8 ) ; $ N = count ( $ a ) ; echo ( findMinEqualSums ( $ a , $ N ) ) ; ? >"}
{"text":"Find the total Number of Digits in ( N ! ) N | Function to find the total Number of Digits in ( N ! ) ^ N ; Finding X ; Calculating N * X ; Floor ( N * X ) + 1 return ceil ( $sum ) ; equivalent to floor ( sum ) + 1 ; Driver code","code":"< ? php function CountDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { $ sum += log ( $ i ) \/ log ( 10 ) ; } $ sum *= $ n ; } $ N = 5 ; echo CountDigits ( $ N ) ; ? >"}
{"text":"Find the value of max ( f ( x ) ) | PHP implementation of above approach ; Function to calculate the value ; forming the prefix sum arrays ; Taking the query ; finding the sum in the range l to r in array a ; finding the sum in the range l to r in array b ; Finding the max value of the function ; Finding the min value of the function ; Driver code","code":"< ? php $ MAX = 200006 ; $ CONS = 32766 ; function calc ( $ a , $ b , $ lr , $ q , $ n ) { global $ MAX ; global $ CONS ; $ M ; $ m ; $ i ; $ j ; $ k ; $ l ; $ r ; $ suma ; $ sumb ; $ cc ; $ cc = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ a [ $ i + 1 ] += $ a [ $ i ] ; $ b [ $ i + 1 ] += $ b [ $ i ] ; } while ( $ q -- ) { $ l = $ lr [ $ cc ++ ] ; $ r = $ lr [ $ cc ++ ] ; $ l -= 2 ; $ r -= 1 ; $ suma = $ a [ $ r ] ; $ sumb = $ b [ $ r ] ; if ( $ l >= 0 ) { $ suma -= $ a [ $ l ] ; $ sumb -= $ b [ $ l ] ; } $ M = max ( $ CONS * $ suma + $ CONS * $ sumb , - $ CONS * $ suma - $ CONS * $ sumb ) ; $ M = max ( $ M , max ( $ CONS * $ suma - $ CONS * $ sumb , - $ CONS * $ suma + $ CONS * $ sumb ) ) ; $ m = min ( $ CONS * $ suma + $ CONS * $ sumb , - $ CONS * $ suma - $ CONS * $ sumb ) ; $ m = min ( $ m , min ( $ CONS * $ suma - $ CONS * $ sumb , - $ CONS * $ suma + $ CONS * $ sumb ) ) ; echo ( $ M - $ m ) , \" STRNEWLINE \" ; } } $ n = 5 ; $ q = 2 ; $ a = array ( 0 , 7 , 3 , 4 , 5 ) ; $ b = array ( 0 , 3 , 1 , 2 , 3 ) ; $ lr [ 0 ] = 1 ; $ lr [ 1 ] = 1 ; $ lr [ 2 ] = 1 ; $ lr [ 3 ] = 3 ; calc ( $ a , $ b , $ lr , $ q , $ n ) ; ? >"}
{"text":"Program to find the Nth number of the series 2 , 10 , 24 , 44 , 70. ... . | function to return Nth term of the series ; Taking n as 4 ; Get Nth term","code":"< ? php function NthTerm ( $ n ) { $ mod = 1000000009 ; $ x = ( 3 * $ n * $ n ) % $ mod ; return ( $ x - $ n + $ mod ) % $ mod ; } let N = 4 ; echo NthTerm ( $ N ) ; ? >"}
{"text":"Sum of first N natural numbers by taking powers of 2 as negative number | to store power of 2 ; to store presum of the power of 2 's ; function to find power of 2 ; to store power of 2 ; to store pre sum ; Function to find the sum ; first store sum of first n natural numbers . ; find the first greater number than given number then minus double of this from answer ; function call ; function call","code":"< ? php $ power = array_fill ( 0 , 31 , 0 ) ; $ pre = array_fill ( 0 , 31 , 0 ) ; function PowerOfTwo ( ) { global $ power , $ pre ; $ x = 1 ; for ( $ i = 0 ; $ i < 31 ; $ i ++ ) { $ power [ $ i ] = $ x ; $ x *= 2 ; } $ pre [ 0 ] = 1 ; for ( $ i = 1 ; $ i < 31 ; $ i ++ ) $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ power [ $ i ] ; } function Sum ( $ n ) { global $ power , $ pre ; $ ans = $ n * ( $ n + 1 ) \/ 2 ; for ( $ i = 0 ; $ i < 31 ; $ i ++ ) if ( $ power [ $ i ] > $ n ) { $ ans -= 2 * $ pre [ $ i - 1 ] ; break ; } return $ ans ; } PowerOfTwo ( ) ; $ n = 4 ; print ( Sum ( $ n ) ) ; ? >"}
{"text":"Check if a number is Quartan Prime or not | Function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver Code ; Check if number is prime and of the form 16 * n + 1","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } $ n = 17 ; if ( isPrime ( $ n ) && ( $ n % 16 == 1 ) ) { echo \" YES \" ; } else { echo \" NO \" ; }"}
{"text":"Print a number strictly less than a given number such that all its digits are distinct . | Function to find a number less than n such that all its digits are distinct ; looping through numbers less than n ; initializing a hash array ; creating a copy of i ; initializing variables to compare lengths of digits ; counting frequency of the digits ; checking if each digit is present once ; Driver code","code":"< ? php function findNumber ( $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ count = array_fill ( 0 , 10 , 0 ) ; $ x = $ i ; $ count1 = 0 ; $ count2 = 0 ; while ( $ x ) { $ count [ $ x % 10 ] ++ ; $ x = ( int ) ( $ x \/ 10 ) ; $ count1 ++ ; } for ( $ j = 0 ; $ j < 10 ; $ j ++ ) { if ( $ count [ $ j ] == 1 ) $ count2 ++ ; } if ( $ count1 == $ count2 ) return $ i ; } } $ n = 8490 ; echo findNumber ( $ n ) ; ? >"}
{"text":"Find two distinct prime numbers with given product | Function to generate all prime numbers less than n ; Initialize all entries of boolean array as true . A value in isPrime [ i ] will finally be false if i is Not a prime , else true bool isPrime [ n + 1 ] ; ; If isPrime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to print a prime pair with given product ; Generating primes using Sieve ; Traversing all numbers to find first pair ; Driver Code","code":"< ? php function SieveOfEratosthenes ( $ n , & $ isPrime ) { $ isPrime [ 0 ] = false ; $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ isPrime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ isPrime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ isPrime [ $ i ] = false ; } } } function findPrimePair ( $ n ) { $ flag = 0 ; $ isPrime = array_fill ( 0 , ( $ n + 1 ) , false ) ; SieveOfEratosthenes ( $ n , $ isPrime ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ x = ( int ) ( $ n \/ $ i ) ; if ( $ isPrime [ $ i ] && $ isPrime [ $ x ] and $ x != $ i and $ x * $ i == $ n ) { echo $ i . \" \u2581 \" . $ x ; $ flag = 1 ; return ; } } if ( ! $ flag ) echo \" No \u2581 such \u2581 pair \u2581 found \" ; } $ n = 39 ; findPrimePair ( $ n ) ; ? >"}
{"text":"Program to find the common ratio of three numbers | Utility function ; Function to print a : b : c ; To print the given proportion in simplest form . ; Get the ratios Get ratio a : b1 ; Get ratio b2 : c ; Find the ratio a : b : c","code":"< ? php function __gcd ( $ a , $ b ) { return $ b == 0 ? $ a : __gcd ( $ b , $ a % $ b ) ; } function solveProportion ( $ a , $ b1 , $ b2 , $ c ) { $ A = $ a * $ b2 ; $ B = $ b1 * $ b2 ; $ C = $ b1 * $ c ; $ gcd = __gcd ( __gcd ( $ A , $ B ) , $ C ) ; echo ( $ A \/ $ gcd ) . \" : \" . ( $ B \/ $ gcd ) . \" : \" . ( $ C \/ $ gcd ) ; } $ a = 3 ; $ b1 = 4 ; $ b2 = 8 ; $ c = 9 ; solveProportion ( $ a , $ b1 , $ b2 , $ c ) ; ? >"}
{"text":"Number of divisors of a given number N which are divisible by K | Function to count number of divisors of N which are divisible by K ; Variable to store count of divisors ; Traverse from 1 to n ; increase the count if both the conditions are satisfied ; Driver code","code":"< ? php function countDivisors ( $ n , $ k ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 && $ i % $ k == 0 ) { $ count ++ ; } } return $ count ; } $ n = 12 ; $ k = 3 ; echo countDivisors ( $ n , $ k ) ;"}
{"text":"Calculate volume and surface area of a cone | Function to calculate Volume of cone ; Function to calculate Surface area of cone ; Driver Code ; Printing value of volume and surface area","code":"< ? php function volume ( $ r , $ h ) { $ pi = 3.14159 ; return ( 1 \/ 3 ) * $ pi * $ r * $ r * $ h ; } function surface_area ( $ r , $ s ) { $ pi = 3.14159 ; return $ pi * $ r * $ s + $ pi * $ r * $ r ; } $ radius = 5 ; $ slant_height = 13 ; $ height = 12 ; echo ( \" Volume \u2581 Of \u2581 Cone \u2581 : \u2581 \" ) ; echo ( volume ( $ radius , $ height ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Surface \u2581 Area \u2581 Of \u2581 Cone \u2581 : \u2581 \" ) ; echo ( surface_area ( $ radius , $ slant_height ) ) ; ? >"}
{"text":"Program to find the Nth term of the series 0 , 14 , 40 , 78 , 124 , ... | calculate sum upto Nth term of series ; return the final sum ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 6 * pow ( $ n , 2 ) - 4 * $ n - 2 ; } $ N = 4 ; echo nthTerm ( $ N ) ;"}
{"text":"Program to find the Nth term of series 5 , 10 , 17 , 26 , 37 , 50 , 65 , 82 , ... | calculate Nth term of series ; return the final sum ; Driver Code","code":"< ? php function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 2 * $ n + 2 ; } $ N = 4 ; echo nthTerm ( $ N ) ;"}
{"text":"Find nth term of a given recurrence relation | function to return required value ; Get the answer ; Return the answer ; Get the value of n ; function call to print result","code":"< ? php function sum ( $ n ) { $ ans = ( $ n * ( $ n - 1 ) ) \/ 2 ; return $ ans ; } $ n = 5 ; echo sum ( $ n ) ; ? >"}
{"text":"Program to find Nth term of the series 3 , 12 , 29 , 54 , 87 , ... | calculate Nth term of series ; Return Nth term ; declaration of number of terms ; Get the Nth term","code":"< ? php function getNthTerm ( $ N ) { return 4 * pow ( $ N , 2 ) - 3 * $ N + 2 ; } $ N = 10 ; echo getNthTerm ( $ N ) ; ? >"}
{"text":"Find sum of product of number in given series | function to calculate ( a ^ b ) % p ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; function to return required answer ; modulo inverse of denominator ; calculating commentator part ; calculating t ! ; accumulating the final answer ; Driver code ; function call to print required sum","code":"< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function sumProd ( $ n , $ t ) { $ MOD = 1000000007 ; $ dino = power ( $ t + 1 , $ MOD - 2 , $ MOD ) ; $ ans = 1 ; for ( $ i = $ n + $ t + 1 ; $ i > $ n ; -- $ i ) $ ans = ( $ ans % $ MOD * $ i % $ MOD ) % $ MOD ; $ tfact = 1 ; for ( $ i = 1 ; $ i <= $ t ; ++ $ i ) $ tfact = ( $ tfact * $ i ) % $ MOD ; $ ans = $ ans * $ dino - $ tfact + $ MOD ; return $ ans % $ MOD ; } $ n = 3 ; $ t = 2 ; echo sumProd ( $ n , $ t ) ; ? >"}
{"text":"Find the sum of series 3 , 7 , 13 , 21 , 31. ... | Function to calculate sum ; Return sum ; Driver code","code":"< ? php function findSum ( $ n ) { return ( $ n * ( pow ( $ n , 2 ) + 3 * $ n + 5 ) ) \/ 3 ; } $ n = 25 ; echo findSum ( $ n ) ; ? >"}
{"text":"Minimum Players required to win the game | function to calculate ( a ^ b ) % ( 10 ^ 9 + 7 ) . ; function to find the minimum required player ; computing the nenomenator ; computing modulo inverse of denominator ; final result ; Driver code","code":"< ? php function power ( $ a , $ b ) { $ mod = 1000000007 ; $ res = 1 ; while ( $ b ) { if ( $ b & 1 ) { $ res *= $ a ; $ res %= $ mod ; } $ b \/= 2 ; $ a *= $ a ; $ a %= $ mod ; } return $ res ; } function minPlayer ( $ n , $ k ) { $ mod = 1000000007 ; $ num = ( ( power ( $ k , $ n ) - 1 ) + $ mod ) % $ mod ; $ den = ( power ( $ k - 1 , $ mod - 2 ) + $ mod ) % $ mod ; $ ans = ( ( ( $ num * $ den ) % $ mod ) * $ k ) % $ mod ; return $ ans ; } $ n = 3 ; $ k = 3 ; echo minPlayer ( $ n , $ k ) ; ? >"}
{"text":"Sum of Factors of a Number using Prime Factorization | Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if N is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7 ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries in it as false . ; Initializing smallest factor equal to 2 for all the even numbers ; For odd numbers less then equal to n ; s ( i ) for a prime is the number itself ; For all multiples of current prime number ; i is the smallest prime factor for number \" i * j \" . ; Function to find sum of all prime factors ; Declaring array to store smallest prime factor of i at i - th index ; Filling values in s [ ] using sieve ; Current prime factor of N ; Power of current prime factor ; N is now N \/ s [ N ] . If new N als has smallest prime factor as currFactor , increment power ; Update current prime factor as s [ N ] and initializing power of factor as 1. ; Driver code","code":"< ? php function sieveOfEratosthenes ( $ N , & $ s ) { $ prime = array_fill ( 0 , $ N + 1 , false ) ; for ( $ i = 2 ; $ i <= $ N ; $ i += 2 ) $ s [ $ i ] = 2 ; for ( $ i = 3 ; $ i <= $ N ; $ i += 2 ) { if ( $ prime [ $ i ] == false ) { $ s [ $ i ] = $ i ; for ( $ j = $ i ; $ j * $ i <= $ N ; $ j += 2 ) { if ( $ prime [ $ i * $ j ] == false ) { $ prime [ $ i * $ j ] = true ; $ s [ $ i * $ j ] = $ i ; } } } } } function findSum ( $ N ) { $ s = array_fill ( 0 , $ N + 1 , 0 ) ; $ ans = 1 ; sieveOfEratosthenes ( $ N , $ s ) ; $ currFactor = $ s [ $ N ] ; $ power = 1 ; while ( $ N > 1 ) { $ N \/= $ s [ $ N ] ; if ( $ currFactor == $ s [ $ N ] ) { $ power ++ ; continue ; } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ power ; $ i ++ ) $ sum += ( int ) pow ( $ currFactor , $ i ) ; $ ans *= $ sum ; $ currFactor = $ s [ $ N ] ; $ power = 1 ; } return $ ans ; } $ n = 12 ; echo \" Sum \u2581 of \u2581 the \u2581 factors \u2581 is \u2581 : \u2581 \" ; echo findSum ( $ n ) ; ? >"}
{"text":"Find Multiples of 2 or 3 or 5 less than or equal to N | Bit count function ; Function to count number of multiples of 2 or 3 or 5 less than or equal to N ; As we have to check divisibility by three numbers , So we can implement bit masking ; we check whether jth bit is set or not , if jth bit is set , simply multiply to prod ; check for set bit ; check multiple of product ; Driver code","code":"< ? php function popcount ( $ value ) { $ count = 0 ; while ( $ value ) { $ count += ( $ value & 1 ) ; $ value = $ value >> 1 ; } return $ count ; } function countMultiples ( $ n ) { $ multiple = array ( 2 , 3 , 5 ) ; $ count = 0 ; $ mask = pow ( 2 , 3 ) ; for ( $ i = 1 ; $ i < $ mask ; $ i ++ ) { $ prod = 1 ; for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { if ( $ i & 1 << $ j ) $ prod = $ prod * $ multiple [ $ j ] ; } if ( popcount ( $ i ) % 2 == 1 ) $ count = $ count + ( int ) ( $ n \/ $ prod ) ; else $ count = $ count - ( int ) ( $ n \/ $ prod ) ; } return $ count ; } $ n = 10 ; echo countMultiples ( $ n ) ; ? >"}
{"text":"Minimum value of N such that xor from 1 to N is equal to K | Function to find the value of N ; variable to store the result ; handling case for '0' ; handling case for '1' ; when number is completely divided by 4 then minimum ' x ' will be ' k ' ; when number divided by 4 gives 3 as remainder then minimum ' x ' will be ' k - 1' ; else it is not possible to get k for any value of x ; let the given number be 7","code":"< ? php function findN ( $ k ) { $ ans ; if ( $ k == 0 ) $ ans = 3 ; if ( $ k == 1 ) $ ans = 1 ; else if ( $ k % 4 == 0 ) $ ans = $ k ; else if ( $ k % 4 == 3 ) $ ans = $ k - 1 ; else $ ans = -1 ; return $ ans ; } $ k = 7 ; $ res = findN ( $ k ) ; if ( $ res == -1 ) echo \" Not \u2581 possible \" ; else echo $ res ; ? >"}
{"text":"Permutations to arrange N persons around a circular table | Function to find no . of permutations ; Driver Code","code":"< ? php function Circular ( $ n ) { $ Result = 1 ; while ( $ n > 0 ) { $ Result = $ Result * $ n ; $ n -- ; } return $ Result ; } $ n = 4 ; echo Circular ( $ n - 1 ) ; ? >"}
{"text":"Minimum time required to complete a work by N persons together | Function to calculate the time ; Driver Code","code":"< ? php function calTime ( & $ arr , $ n ) { $ work = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ work += 1 \/ $ arr [ $ i ] ; return 1 \/ $ work ; } $ arr = array ( 6.0 , 3.0 , 4.0 ) ; $ n = sizeof ( $ arr ) ; echo calTime ( $ arr , $ n ) ; echo \" \u2581 Hours \" ;"}
{"text":"Find the largest twins in given range | Function to find twins ; Create a boolean array \" prime [ 0 . . high ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Look for the smallest twin ; If p is not marked , then it is a prime ; Update all multiples of p ; Now print the largest twin in range ; Driver program","code":"< ? php function printTwins ( $ low , $ high ) { $ prime [ $ high + 1 ] = array ( ) ; $ twin = false ; $ prime = array_fill ( 0 , ( $ high + 1 ) , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p <= floor ( sqrt ( $ high ) ) + 1 ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ high ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = $ high ; $ i >= $ low ; $ i -- ) { if ( $ prime [ $ i ] && ( $ i - 2 >= $ low && $ prime [ $ i - 2 ] == true ) ) { echo \" Largest \u2581 twins \u2581 in \u2581 given \u2581 range : \u2581 ( \" , $ i - 2 , \" , \u2581 \" , $ i , \" ) \" ; $ twin = true ; break ; } } if ( $ twin == false ) echo \" No \u2581 such \u2581 pair \u2581 exists \" ; } printTwins ( 10 , 100 ) ; ? >"}
{"text":"Complement of a number with any base b | Function to find ( b - 1 ) 's complement ; Calculate number of digits in the given number ; Largest digit in the number system with base b ; Largest number in the number system with base b ; return Complement ; Function to find b 's complement ; b ' s \u2581 complement \u2581 = \u2581 ( b - 1 ) ' s complement + 1 ; Driver code","code":"< ? php function prevComplement ( $ n , $ b ) { $ maxNum = 0 ; $ digits = 0 ; $ num = $ n ; while ( ( int ) $ n != 0 ) { $ digits ++ ; $ n = $ n \/ 10 ; } $ maxDigit = $ b - 1 ; while ( $ digits -- ) { $ maxNum = $ maxNum * 10 + $ maxDigit ; } return $ maxNum - $ num ; } function complement ( $ n , $ b ) { return prevComplement ( $ n , $ b ) + 1 ; } echo prevComplement ( 25 , 7 ) , \" STRNEWLINE \" ; echo ( complement ( 25 , 7 ) ) ; ? >"}
{"text":"Minimum positive integer value possible of X for given A and B in X = P * A + Q * B | Function to return gcd of a and b ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } $ a = 2 ; $ b = 4 ; echo gcd ( $ a , $ b ) ; ? >"}
{"text":"Count elements in the given range which have maximum number of divisors | Function to count the elements with maximum number of divisors ; to store number of divisors initialise with zero ; to store the maximum number of divisors ; to store required answer ; Find the first divisible number ; Count number of divisors ; Find number of elements with maximum number of divisors ; Driver code","code":"< ? php function MaximumDivisors ( $ X , $ Y ) { $ arr = array_fill ( 0 , ( $ Y - $ X + 1 ) , NULL ) ; $ mx = PHP_INT_MIN ; $ cnt = 0 ; for ( $ i = 1 ; $ i * $ i <= $ Y ; $ i ++ ) { $ sq = $ i * $ i ; if ( ( $ X \/ $ i ) * $ i >= $ X ) $ first_divisible = ( $ X \/ $ i ) * $ i ; else $ first_divisible = ( $ X \/ $ i + 1 ) * $ i ; for ( $ j = $ first_divisible ; $ j < $ Y ; $ j += $ i ) { if ( $ j < $ sq ) continue ; else if ( $ j == $ sq ) $ arr [ $ j - $ X ] ++ ; else $ arr [ $ j - $ X ] += 2 ; } } for ( $ i = $ X ; $ i <= $ Y ; $ i ++ ) { if ( $ arr [ $ i - $ X ] > $ mx ) { $ cnt = 1 ; $ mx = $ arr [ $ i - $ X ] ; } else if ( $ arr [ $ i - $ X ] == $ mx ) $ cnt ++ ; } return $ cnt ; } $ X = 1 ; $ Y = 10 ; echo MaximumDivisors ( $ X , $ Y ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find First element in AP which is multiple of given prime | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; function to find nearest element in common ; base conditions ; Driver code ; module both A and D ; function call","code":"< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function NearestElement ( $ A , $ D , $ P ) { if ( $ A == 0 ) return 0 ; else if ( $ D == 0 ) return -1 ; else { $ X = power ( $ D , $ P - 2 , $ P ) ; return ( $ X * ( $ P - $ A ) ) % $ P ; } } $ A = 4 ; $ D = 9 ; $ P = 11 ; $ A %= $ P ; $ D %= $ P ; echo NearestElement ( $ A , $ D , $ P ) ; ? >"}
{"text":"Cunningham chain | Function to print Cunningham chain of the first kind ; Iterate till all elements are printed ; check prime or not ; Driver Code","code":"< ? php function print_C ( $ p0 ) { $ p1 = 0 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 + ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . \" \" ; $ i ++ ; } } $ p0 = 2 ; print_C ( $ p0 ) ;"}
{"text":"Count pairs with Bitwise AND as ODD number | Function to count number of odd pairs ; variable for counting odd pairs ; find all pairs ; find AND operation check odd or even ; return number of odd pair ; Driver Code ; calling function findOddPair and print number of odd pair","code":"< ? php function findOddPair ( & $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 != 0 ) $ oddPair = $ oddPair + 1 ; } } return $ oddPair ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo ( findOddPair ( $ a , $ n ) ) ; ? >"}
{"text":"Sum of all elements up to Nth row in a Pascal triangle | Function to find sum of all elements upto nth row . ; Initialize sum with 0 ; Calculate 2 ^ n ; Driver Code","code":"< ? php function calculateSum ( $ n ) { $ sum = 0 ; $ sum = 1 << $ n ; return ( $ sum - 1 ) ; } $ n = 10 ; echo \" \u2581 Sum \u2581 of \u2581 all \u2581 elements : \" , calculateSum ( $ n ) ; ? >"}
{"text":"Divide two integers without using multiplication , division and mod operator | Set2 | Returns the quotient of dividend \/ divisor . ; Calculate sign of divisor i . e . , sign will be negative only if either one of them is negative otherwise it will be positive ; Remove signs of dividend and divisor ; Zero division Exception . ; Using Formula derived above . ; Driver code","code":"< ? php function Divide ( $ a , $ b ) { $ dividend = $ a ; $ divisor = $ b ; $ sign = ( $ dividend < 0 ) ^ ( $ divisor < 0 ) ? -1 : 1 ; $ dividend = abs ( $ dividend ) ; $ divisor = abs ( $ divisor ) ; if ( $ divisor == 0 ) { echo \" Cannot \u2581 Divide \u2581 by \u2581 0\" ; echo \" \" ; } if ( $ dividend == 0 ) { echo $ a , \" \u2581 \/ \u2581 \" , $ b , \" \u2581 is \u2581 equal \u2581 to \u2581 : \u2581 \" , 0 ; echo \" \" ; } if ( $ divisor == 1 ) { echo $ a , \" \u2581 \/ \u2581 \" , $ b , \" \u2581 is \u2581 equal \u2581 to \u2581 : \u2581 \" , $ sign * $ dividend . \" STRNEWLINE \" ; echo \" \" ; } echo $ a , \" \u2581 \/ \u2581 \" , $ b , \" \u2581 is \u2581 equal \u2581 to \u2581 : \u2581 \" , $ sign * exp ( log ( $ dividend ) - log ( $ divisor ) ) . \" STRNEWLINE \" ; echo \" \" ; } $ a = 10 ; $ b = 5 ; Divide ( $ a , $ b ) ; $ a = 49 ; $ b = -7 ; Divide ( $ a , $ b ) ; ? >"}
{"text":"Check if the n | Return if the nth term is even or odd . ; If a is even ; If b is even ; If b is odd ; If a is odd ; If b is odd ; If b is eve ; Driver Code","code":"< ? php function findNature ( $ a , $ b , $ n ) { if ( $ n == 0 ) return ( $ a & 1 ) ; if ( $ n == 1 ) return ( $ b & 1 ) ; if ( ! ( $ a & 1 ) ) { if ( ! ( $ b & 1 ) ) return false ; else return ( $ n % 3 != 0 ) ; } else { if ( ! ( $ b & 1 ) ) return ( ( $ n - 1 ) % 3 != 0 ) ; else return ( ( $ n + 1 ) % 3 != 0 ) ; } } $ a = 2 ; $ b = 4 ; $ n = 3 ; if ( findNature ( $ a , $ b , $ n ) == true ) echo \" Odd \" , \" \u2581 \" ; else echo \" Even \" , \" \u2581 \" ; ? >"}
{"text":"Check if mirror image of a number is same if displayed in seven segment display | Return \" Yes \" , if the mirror image of number is same as the given number Else return \" No \" ; Checking if the number contain only 0 , 1 , 8. ; Checking if the number is palindrome or not . ; If corresponding index is not equal . ; Driver Code","code":"< ? php function checkEqual ( $ S ) { for ( $ i = 0 ; $ i < strlen ( $ S ) ; $ i ++ ) { if ( $ S [ $ i ] != '1' && $ S [ $ i ] != '0' && $ S [ $ i ] != '8' ) { return \" No \" ; } } $ start = 0 ; $ end = strlen ( $ S ) - 1 ; while ( $ start < $ end ) { if ( $ S [ $ start ] != $ S [ $ end ] ) { return \" No \" ; } $ start ++ ; $ end -- ; } return \" Yes \" ; } $ S = \"101\" ; echo checkEqual ( $ S ) ; ? >"}
{"text":"Check if given number is a power of d where d is a power of 2 | PHP program to find if a number is power of d where d is power of 2. ; Function to count the number of ways to paint N * 3 grid based on given conditions ; Check if there is only one bit set in n ; count 0 bits before set bit ; If count is a multiple of log2 ( d ) then return true else false ; If there are more than 1 bit set then n is not a power of 4 ; Driver Code","code":"< ? php function Log2n ( $ n ) { return ( $ n > 1 ) ? 1 + Log2n ( $ n \/ 2 ) : 0 ; } function isPowerOfd ( $ n , $ d ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) { while ( $ n > 1 ) { $ n >>= 1 ; $ count += 1 ; } return ( $ count % ( Log2n ( $ d ) ) == 0 ) ; } return false ; } $ n = 64 ; $ d = 8 ; if ( isPowerOfd ( $ n , $ d ) ) echo $ n , \" \u2581 \" , \" is \u2581 a \u2581 power \u2581 of \u2581 \" , $ d ; else echo $ n , \" \u2581 \" , \" is \u2581 not \u2581 a \u2581 power \u2581 of \u2581 \" , $ d ; ? >"}
{"text":"Octahedral Number | Function to find octahedral number ; Formula to calculate nth octahedral number and return it into main function . ; Drivers Code ; print result","code":"< ? php function octahedral_num ( $ n ) { return $ n * ( 2 * $ n * $ n + 1 ) \/ 3 ; } $ n = 5 ; echo $ n , \" th \u2581 Octahedral \u2581 number : \u2581 \" ; echo octahedral_num ( $ n ) ; ? >"}
{"text":"Centered tetrahedral number | Function to find centered Centered tetrahedral number ; Formula to calculate nth Centered tetrahedral number and return it into main function . ; Driver Code","code":"< ? php function centeredTetrahedralNumber ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 3 ) \/ 3 ; } $ n = 6 ; echo centeredTetrahedralNumber ( $ n ) ; ? >"}
{"text":"Swapping four variables without temporary variable | PHP program to swap 4 variables without using temporary variable ; swapping a and b variables ; swapping b and c variables ; swapping c and d variables ; initialising variables ; Function call","code":"< ? php function swap ( $ a , $ b , $ c , $ d ) { $ a = $ a + $ b ; $ b = $ a - $ b ; $ a = $ a - $ b ; $ b = $ b + $ c ; $ c = $ b - $ c ; $ b = $ b - $ c ; $ c = $ c + $ d ; $ d = $ c - $ d ; $ c = $ c - $ d ; echo \" values \u2581 after \u2581 swapping \u2581 are \u2581 : \u2581 \" , \" STRNEWLINE \" ; echo \" a = \" \u2581 , \u2581 $ a \u2581 , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" b = \" \u2581 , \u2581 $ b \u2581 , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" c = \" \u2581 , $ c \u2581 , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" d = \" \u2581 , \u2581 $ d \u2581 , \" \" } $ a = 1 ; $ b = 2 ; $ c = 3 ; $ d = 4 ; echo \" Values \u2581 before \u2581 swapping \u2581 are \u2581 : \" , \" STRNEWLINE \" ; echo \" a = \" \u2581 , \u2581 $ a \u2581 , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" b = \" \u2581 , $ b , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" c = \" \u2581 , \u2581 $ c \u2581 , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" d = \" \u2581 , \u2581 $ d \u2581 , \" \" , \" \" swap ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text":"Sum of first n natural numbers | Function to find the sum of series ; Driver code","code":"< ? php function seriesSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += $ i * ( $ i + 1 ) \/ 2 ; return $ sum ; } $ n = 4 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text":"Centrosymmetric Matrix | PHP Program to check whether given matrix is centrosymmetric or not . ; Finding the middle row of the matrix ; for each row upto middle row . ; If each element and its corresponding element is not equal then return false . ; Driver Code","code":"< ? php function checkCentrosymmetricted ( $ n , $ m ) { $ mid_row ; if ( $ n & 1 ) $ mid_row = $ n \/ 2 + 1 ; else $ mid_row = $ n \/ 2 ; for ( $ i = 0 ; $ i < $ mid_row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ n - $ i - 1 ] [ $ n - $ j - 1 ] ) return false ; } } return true ; } $ n = 3 ; $ m = array ( array ( 1 , 3 , 5 ) , array ( 6 , 8 , 6 ) , array ( 5 , 3 , 1 ) ) ; if ( checkCentrosymmetricted ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Centered triangular number | function for Centered Triangular number ; formula for find Centered Triangular number nth term ; For 3 rd Centered Triangular number ; For 12 th Centered Triangular number","code":"< ? php function Centered_Triangular_num ( $ n ) { return ( 3 * $ n * $ n + 3 * $ n + 2 ) \/ 2 ; } $ n = 3 ; echo Centered_Triangular_num ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo Centered_Triangular_num ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Combinatorics on ordered trees | Function returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; Function to calculate the number of trees with exactly k leaves . ; Function to calculate total number of nodes of degree d in these trees . ; Function to calculate the number of trees in which the root has degree r . ; Driver program to test above functions Number of trees having 3 edges and exactly 2 leaves ; Number of nodes of degree 3 in a tree having 4 edges ; Number of trees having 3 edges where root has degree 2","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ C = array ( array ( ) ) ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 or $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function k_Leaves ( $ n , $ k ) { $ ans = ( binomialCoeff ( $ n , $ k ) * binomialCoeff ( $ n , $ k - 1 ) ) \/ $ n ; echo \" Number \u2581 of \u2581 trees \u2581 having \u2581 4 \u2581 edges \u2581 and \u2581 \" , \" exactly \u2581 2 \u2581 leaves \u2581 : \u2581 \" , $ ans , \" STRNEWLINE \" ; return 0 ; } function numberOfNodes ( $ n , $ d ) { $ ans = binomialCoeff ( 2 * $ n - 1 - $ d , $ n - 1 ) ; echo \" Number \u2581 of \u2581 nodes \u2581 of \u2581 degree \u2581 1 \u2581 in \" , \" \u2581 a \u2581 tree \u2581 having \u2581 4 \u2581 edges \u2581 : \u2581 \" , $ ans , \" STRNEWLINE \" ; return 0 ; } function rootDegreeR ( $ n , $ r ) { $ ans = $ r * binomialCoeff ( 2 * $ n - 1 - $ r , $ n - 1 ) ; $ ans = $ ans \/ $ n ; echo \" Number \u2581 of \u2581 trees \u2581 having \u2581 4 \u2581 edges \" , \" \u2581 where \u2581 root \u2581 has \u2581 degree \u2581 2 \u2581 : \u2581 \" , $ ans ; return 0 ; } k_Leaves ( 3 , 2 ) ; numberOfNodes ( 3 , 1 ) ; rootDegreeR ( 3 , 2 ) ; ? >"}
{"text":"Repeated Unit Divisibility | To find least value of k ; To check n is coprime or not ; to store R ( k ) mod n and 10 ^ k mod n value ; Driver Code","code":"< ? php function repUnitValue ( $ n ) { if ( $ n % 2 == 0 $ n % 5 == 0 ) return 0 ; $ rem = 1 ; $ power = 1 ; $ k = 1 ; while ( $ rem % $ n != 0 ) { $ k ++ ; $ power = $ power * 10 % $ n ; $ rem = ( $ rem + $ power ) % $ n ; } return $ k ; } $ n = 13 ; echo repUnitValue ( $ n ) ; ? >"}
{"text":"First N natural can be divided into two sets with given difference and co | PHP code to determine whether numbers 1 to N can be divided into two sets such that absolute difference between sum of these two sets is M and these two sum are co - prime ; function that returns boolean value on the basis of whether it is possible to divide 1 to N numbers into two sets that satisfy given conditions . ; initializing total sum of 1 to n numbers ; since ( 1 ) total_sum = sum_s1 + sum_s2 and ( 2 ) m = sum_s1 - sum_s2 assuming sum_s1 > sum_s2 . solving these 2 equations to get sum_s1 and sum_s2 ; total_sum = sum_s1 + sum_s2 and therefore ; if total sum is less than the absolute difference then there is no way we can split n numbers into two sets so return false ; check if these two sums are integers and they add up to total sum and also if their absolute difference is m . ; Now if two sum are co - prime then return true , else return false . ; if two sums don 't add up to total  sum or if their absolute difference  is not m, then there is no way to  split n numbers, hence return false ; Driver code ; function call to determine answer","code":"< ? php function __gcd ( $ a , $ b ) { return $ b == 0 ? $ a : __gcd ( $ b , $ a % $ b ) ; } function isSplittable ( $ n , $ m ) { $ total_sum = ( int ) ( ( $ n * ( $ n + 1 ) ) \/ 2 ) ; $ sum_s1 = ( int ) ( ( $ total_sum + $ m ) \/ 2 ) ; $ sum_s2 = $ total_sum - $ sum_s1 ; if ( $ total_sum < $ m ) return false ; if ( $ sum_s1 + $ sum_s2 == $ total_sum && $ sum_s1 - $ sum_s2 == $ m ) return ( __gcd ( $ sum_s1 , $ sum_s2 ) == 1 ) ; return false ; } $ n = 5 ; $ m = 7 ; if ( isSplittable ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text":"Making zero array by decrementing pairs of adjacent | PHP implementation of the above approach ; converting array element into number ; Check if divisible by 11 ; Driver Code","code":"< ? php function isPossibleToZero ( $ a , $ n ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ num = $ num * 10 + $ a [ $ i ] ; return ( $ num % 11 == 0 ) ; } $ arr = array ( 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; if ( isPossibleToZero ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ;"}
{"text":"Blum Integer | Function to cheek if number is Blum Integer ; to store prime numbers from 2 to n ; If prime [ i ] is not changed , then it is a prime ; Update all multiples of p ; to check if the given odd integer is Blum Integer or not ; checking the factors are of 4 t + 3 form or not ; give odd integer greater than 20","code":"< ? php function isBlumInteger ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] == true ) { for ( $ j = $ i * 2 ; $ j <= $ n ; $ j += $ i ) $ prime [ $ j ] = false ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] ) { if ( ( $ n % $ i == 0 ) && ( ( $ i - 3 ) % 4 ) == 0 ) { $ q = ( int ) $ n \/ $ i ; return ( $ q != $ i && $ prime [ $ q ] && ( $ q - 3 ) % 4 == 0 ) ; } } } return false ; } $ n = 249 ; if ( isBlumInteger ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program to calculate value of nCr | PHP program To calculate the Value Of nCr ; Returns factorial of n ; Driver code","code":"< ? php function nCr ( $ n , $ r ) { return fact ( $ n ) \/ ( fact ( $ r ) * fact ( $ n - $ r ) ) ; } function fact ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } $ n = 5 ; $ r = 3 ; echo nCr ( $ n , $ r ) ; ? >"}
{"text":"Program to print the sum of the given nth term | function to calculate sum of series ; Sum of n terms is n ^ 2 ; Driver Code","code":"< ? php function summingSeries ( $ n ) { return pow ( $ n , 2 ) ; } $ n = 100 ; echo \" The \u2581 sum \u2581 of \u2581 n \u2581 term \u2581 is : \u2581 \" , summingSeries ( $ n ) ; ? >"}
{"text":"Brahmagupta Fibonacci Identity | PHP code to verify Brahmagupta Fibonacci identity ; represent the product as sum of 2 squares ; check identity criteria ; 1 ^ 2 + 2 ^ 2 ; 3 ^ 2 + 4 ^ 2 ; express product of sum of 2 squares as sum of ( sumof 2 squares )","code":"< ? php function find_sum_of_two_squares ( $ a , $ b ) { $ ab = $ a * $ b ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { for ( $ j = $ i ; $ i * $ i + $ j * $ j <= $ ab ; $ j ++ ) { if ( $ i * $ i + $ j * $ j == $ ab ) echo $ i , \" ^ 2 \u2581 + \u2581 \" , $ j , \" ^ 2 \u2581 = \u2581 \" , $ ab , \" STRNEWLINE \" ; } } } $ a = 1 * 1 + 2 * 2 ; $ b = 3 * 3 + 4 * 4 ; echo \" Representation \u2581 of \u2581 a \u2581 * \u2581 b \u2581 \" . \" as \u2581 sum \u2581 of \u2581 2 \u2581 squares : STRNEWLINE \" ; find_sum_of_two_squares ( $ a , $ b ) ; ? >"}
{"text":"Tetrahedral Numbers | Function to find Tetrahedral Number ; Driver Code","code":"< ? php function tetrahedralNumber ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) \/ 6 ; } $ n = 5 ; echo tetrahedralNumber ( $ n ) ; ? >"}
{"text":"Euler 's Four Square Identity | function to check euler four square identity ; loops checking the sum of squares ; sum of 2 squares ; sum of 3 squares ; sum of 4 squares ; product of 2 numbers represented as sum of four squares i , j , k , l ; product of 2 numbers a and b represented as sum of four squares i , j , k , l ; given numbers can be represented as sum of 4 squares By euler 's four square identity product also can be represented as sum of 4 squares","code":"< ? php function check_euler_four_square_identity ( $ a , $ b , $ ab ) { $ s = 0 ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { $ s = $ i * $ i ; for ( $ j = $ i ; $ j * $ j <= $ ab ; $ j ++ ) { $ s = $ j * $ j + $ i * $ i ; for ( $ k = $ j ; $ k * $ k <= $ ab ; $ k ++ ) { $ s = $ k * $ k + $ j * $ j + $ i * $ i ; for ( $ l = $ k ; $ l * $ l <= $ ab ; $ l ++ ) { $ s = $ l * $ l + $ k * $ k + $ j * $ j + $ i * $ i ; if ( $ s == $ ab ) { echo ( \" i \u2581 = \u2581 \" . $ i . \" STRNEWLINE \" ) ; echo ( \" j \u2581 = \u2581 \" . $ j . \" STRNEWLINE \" ) ; echo ( \" k \u2581 = \u2581 \" . $ k . \" STRNEWLINE \" ) ; echo ( \" l \u2581 = \u2581 \" . $ l . \" STRNEWLINE \" ) ; echo \" \" . \" Product \u2581 of \u2581 \" . $ a . \" \u2581 and \u2581 \" . $ b ; echo \" \u2581 can \u2581 be \u2581 written \" . \" \u2581 as \u2581 sum \u2581 of \u2581 squares \u2581 of \u2581 i , \u2581 \" . \" j , \u2581 k , \u2581 l STRNEWLINE \" ; echo $ ab . \" \u2581 = \u2581 \" ; echo $ i . \" * \" \u2581 . \u2581 $ i . \u2581 \" + \" echo $ j . \" * \" . $ j . \" \u2581 + \u2581 \" ; echo $ k . \" * \" \u2581 . \u2581 $ k \u2581 . \u2581 \" + \" echo $ l . \" * \" . $ l . \" STRNEWLINE \" ; echo \" STRNEWLINE \" ; } } } } } } $ ab = $ a * $ b ; check_euler_four_square_identity ( $ a , $ b , $ ab ) ; ? >"}
{"text":"Number of solutions to Modular Equations | Returns the number of divisors of ( A - B ) greater than B ; if N is divisible by i ; count only the divisors greater than B ; checking if a divisor isnt counted twice ; Utility function to calculate number of all possible values of X for which the modular equation holds true ; if A = B there are infinitely many solutions to equation or we say X can take infinitely many values > A . We return - 1 in this case ; if A < B , there are no possible values of X satisfying the equation ; the last case is when A > B , here we calculate the number of divisors of ( A - B ) , which are greater than B ; Wrapper function for numberOfPossibleWaysUtil ( ) ; if infinitely many solutions available ; Driver code","code":"< ? php function calculateDivisors ( $ A , $ B ) { $ N = ( $ A - $ B ) ; $ noOfDivisors = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N ) ; $ i ++ ) { if ( ( $ N % $ i ) == 0 ) { if ( $ i > $ B ) $ noOfDivisors ++ ; if ( ( $ N \/ $ i ) != $ i && ( $ N \/ $ i ) > $ B ) $ noOfDivisors ++ ; } } return $ noOfDivisors ; } function numberOfPossibleWaysUtil ( $ A , $ B ) { if ( $ A == $ B ) return -1 ; if ( $ A < $ B ) return 0 ; $ noOfDivisors = 0 ; $ noOfDivisors = calculateDivisors ( $ A , $ B ) ; return $ noOfDivisors ; } function numberOfPossibleWays ( $ A , $ B ) { $ noOfSolutions = numberOfPossibleWaysUtil ( $ A , $ B ) ; if ( $ noOfSolutions == -1 ) { echo \" For A = \" \u2581 , \u2581 $ A , \u2581 \" and B = \" \u2581 , $ B , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" X can take Infinitely many values greater than \" \u2581 , \u2581 $ A \u2581 , \u2581 \" \" ; STRNEWLINE TABSYMBOL } STRNEWLINE TABSYMBOL else \u2581 { STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" For A = \" , \u2581 $ A \u2581 , \u2581 \" and B = \" \u2581 , $ B , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" X can take \" , $ noOfSolutions , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" values \" } } $ A = 26 ; $ B = 2 ; numberOfPossibleWays ( $ A , $ B ) ; $ A = 21 ; $ B = 5 ; numberOfPossibleWays ( $ A , $ B ) ;"}
{"text":"Perfect power ( 1 , 4 , 8 , 9 , 16 , 25 , 27 , ... ) | Function that keeps all the odd power numbers upto n ; We need exclude perfect squares . ; sort the vector ; Return sum of odd and even powers . ; Driver Code","code":"< ? php function powerNumbers ( $ n ) { $ v = array ( ) ; for ( $ i = 2 ; $ i * $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i * $ i ; while ( $ j * $ i <= $ n ) { $ j *= $ i ; $ s = sqrt ( $ j ) ; if ( $ s * $ s != $ j ) array_push ( $ v , $ j ) ; } } sort ( $ v ) ; $ uni = array_unique ( $ v ) ; for ( $ i = 0 ; $ i < count ( $ uni ) ; $ i ++ ) { $ key = array_search ( $ uni [ $ i ] , $ v ) ; unset ( $ v [ $ key ] ) ; } return count ( $ v ) + 3 + intval ( sqrt ( $ n ) ) ; } echo ( powerNumbers ( 50 ) ) ; ? >"}
{"text":"Variance and standard | variance function declaration Function for calculating mean ; Calculating sum ; Returning mean ; Function for calculating variance ; subtracting mean from elements ; a [ i ] [ j ] = fabs ( a [ i ] [ j ] ) ; squaring each terms ; taking sum ; declaring and initializing matrix ; for mean ; for variance ; for standard deviation ; displaying variance and deviation","code":"< ? php function mean ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ a [ $ i ] [ $ j ] ; return floor ( ( int ) $ sum \/ ( $ n * $ n ) ) ; } function variance ( $ a , $ n , $ m ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ a [ $ i ] [ $ j ] -= $ m ; $ a [ $ i ] [ $ j ] *= $ a [ $ i ] [ $ j ] ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ a [ $ i ] [ $ j ] ; return floor ( ( int ) $ sum \/ ( $ n * $ n ) ) ; } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ m = mean ( $ mat , 3 ) ; $ var = variance ( $ mat , 3 , $ m ) ; $ dev = sqrt ( $ var ) ; echo \" Mean : \" \u2581 , \u2581 $ m \u2581 , \u2581 \" \" , STRNEWLINE TABSYMBOL \" Variance : \" \u2581 , \u2581 $ var \u2581 , STRNEWLINE TABSYMBOL \" \" , \u2581 \" Deviation : \" floor ( $ dev ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find N Arithmetic Means between A and B | Prints N arithmetic means between A and B . ; calculate common difference ( d ) ; for finding N the arithmetic mean between A and B ; Driver Code","code":"< ? php function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) \/ ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , \" \u2581 \" ; } $ A = 20 ; $ B = 32 ; $ N = 5 ; printAMeans ( $ A , $ B , $ N ) ; ? >"}
{"text":"Sum of the series 1.2 . 3 + 2.3 . 4 + ... + n ( n + 1 ) ( n + 2 ) | function to calculate sum of series ; Driver Code","code":"< ? php function sumofseries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) \/ 4 ) ; } echo sumofseries ( 3 ) ; ? >"}
{"text":"Largest number in [ 2 , 3 , . . n ] which is co | Returns true if i is co - prime with numbers in set [ 2 , 3 , ... m ] ; Running the loop till square root of n to reduce the time complexity from n ; Find the minimum of square root of n and m to run the loop until the smaller one ; Check from 2 to min ( m , sqrt ( n ) ) ; Function to find the largest number less than n which is Co - prime with all numbers from 2 to m ; Iterating from n to m + 1 to find the number ; checking every number for the given conditions ; The first number which satisfy the conditions is the answer ; If there is no number which satisfy the conditions , then print number does not exist . ; Driver Code","code":"< ? php function isValid ( $ i , $ m ) { $ sq_i = sqrt ( $ i ) ; $ sq = min ( $ m , $ sq_i ) ; for ( $ j = 2 ; $ j <= $ sq ; $ j ++ ) if ( $ i % $ j == 0 ) return false ; return true ; } function findLargestNum ( $ n , $ m ) { for ( $ i = $ n ; $ i > $ m ; $ i -- ) { if ( isValid ( $ i , $ m ) ) { echo $ i , \" STRNEWLINE \" ; return ; } } echo \" Number \u2581 Doesn ' t \u2581 Exists STRNEWLINE \" ; } $ n = 16 ; $ m = 3 ; findLargestNum ( $ n , $ m ) ; ? >"}
{"text":"Check whether a given matrix is orthogonal or not | Function to check orthogonalilty ; Find transpose ; Find product of a [ ] [ ] and its transpose ; Since we are multiplying with transpose of itself . We use ; Check if product is identity matrix ; Driver Code","code":"< ? php function isOrthogonal ( $ a , $ m , $ n ) { if ( $ m != $ n ) return false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ trans [ $ i ] [ $ j ] = $ a [ $ j ] [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ sum = 0 ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { $ sum = $ sum + ( $ a [ $ i ] [ $ k ] * $ a [ $ j ] [ $ k ] ) ; } $ prod [ $ i ] [ $ j ] = $ sum ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i != $ j && $ prod [ $ i ] [ $ j ] != 0 ) return false ; if ( $ i == $ j && $ prod [ $ i ] [ $ j ] != 1 ) return false ; } } return true ; } $ a = array ( array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) , array ( 0 , 0 , 1 ) ) ; if ( isOrthogonal ( $ a , 3 , 3 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if given number is perfect square | PHP program to find if x is a perfect square . ; Find floating point value of square root of x . ; If square root is an integer ; Driver code","code":"< ? php function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; } $ x = 2502 ; if ( isPerfectSquare ( $ x ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Program to print GP ( Geometric Progression ) | function to print GP ; starting number ; Common ratio ; N th term to be find","code":"< ? php function printGP ( $ a , $ r , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_term = $ a * pow ( $ r , $ i ) ; echo $ curr_term , \" \" ; } } $ a = 2 ; $ r = 3 ; $ n = 5 ; printGP ( $ a , $ r , $ n ) ; ? >"}
{"text":"Space efficient iterative method to Fibonacci number | get second MSB ; consectutively set all the bits ; returns the second MSB ; Multiply function ; Function to calculate F [ ] [ ] raise to the power n ; Base case ; take 2D array to store number 's ; run loop till MSB > 0 ; To return fibonacci number ; Given n","code":"< ? php function getMSB ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( ( $ n + 1 ) >> 2 ) ; } function multiply ( & $ F , & $ M ) { $ x = $ F [ 0 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ F [ 0 ] [ 1 ] * $ M [ 1 ] [ 0 ] ; $ y = $ F [ 0 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ F [ 0 ] [ 1 ] * $ M [ 1 ] [ 1 ] ; $ z = $ F [ 1 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ F [ 1 ] [ 1 ] * $ M [ 1 ] [ 0 ] ; $ w = $ F [ 1 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ F [ 1 ] [ 1 ] * $ M [ 1 ] [ 1 ] ; $ F [ 0 ] [ 0 ] = $ x ; $ F [ 0 ] [ 1 ] = $ y ; $ F [ 1 ] [ 0 ] = $ z ; $ F [ 1 ] [ 1 ] = $ w ; } function power ( & $ F , $ n ) { if ( $ n == 0 $ n == 1 ) return ; $ M = array ( array ( 1 , 1 ) , array ( 1 , 0 ) ) ; for ( $ m = getMSB ( $ n ) ; $ m ; $ m = $ m >> 1 ) { multiply ( $ F , $ F ) ; if ( $ n & $ m ) { multiply ( $ F , $ M ) ; } } } function fib ( $ n ) { $ F = array ( array ( 1 , 1 ) , array ( 1 , 0 ) ) ; if ( $ n == 0 ) return 0 ; power ( $ F , $ n - 1 ) ; return $ F [ 0 ] [ 0 ] ; } $ n = 6 ; echo fib ( $ n ) . \" \" ; ? >"}
{"text":"Stern | PHP program to print Brocot Sequence ; loop to create sequence ; adding sum of considered element and it 's precedent ; adding next considered element ; printing sequence . . ; Driver code ; adding first two element in the sequence","code":"< ? php function SternSequenceFunc ( & $ BrocotSequence , $ n ) { for ( $ i = 1 ; count ( $ BrocotSequence ) < $ n ; $ i ++ ) { $ considered_element = $ BrocotSequence [ $ i ] ; $ precedent = $ BrocotSequence [ $ i - 1 ] ; array_push ( $ BrocotSequence , $ considered_element + $ precedent ) ; array_push ( $ BrocotSequence , $ considered_element ) ; } for ( $ i = 0 ; $ i < 15 ; ++ $ i ) echo ( $ BrocotSequence [ $ i ] . \" \u2581 \" ) ; } $ n = 15 ; $ BrocotSequence = array ( ) ; array_push ( $ BrocotSequence , 1 ) ; array_push ( $ BrocotSequence , 1 ) ; SternSequenceFunc ( $ BrocotSequence , $ n ) ; ? >"}
{"text":"Counting numbers whose difference from reverse is a product of k | PHP program to Count the numbers within a given range in which when you subtract a number from its reverse , the difference is a product of k ; function to check if the number and its reverse have their absolute difference divisible by k ; reverse the number ; Driver code","code":"< ? php function isRevDiffDivisible ( $ x , $ k ) { $ n = $ x ; $ m = 0 ; $ flag ; while ( $ x > 0 ) { $ m = $ m * 10 + $ x % 10 ; $ x = ( int ) $ x \/ 10 ; } return ( abs ( $ n - $ m ) % $ k == 0 ) ; } function countNumbers ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) if ( isRevDiffDivisible ( $ i , $ k ) ) ++ $ count ; return $ count ; } $ l = 20 ; $ r = 23 ; $ k = 6 ; echo countNumbers ( $ l , $ r , $ k ) ; ? >"}
{"text":"Check for Amicable Pair | Function to calculate sum of all proper divisors of a given number ; Sum of divisors ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' n ' ; if both divisors are same then add it once else add both ; Add 1 and n to result as above loop considers proper divisors greater than 1. ; Returns true if x and y are Amicable else false . ; Driver Code","code":"< ? php function divSum ( $ n ) { $ result = 0 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i == ( $ n \/ $ i ) ) $ result += $ i ; else $ result += ( $ i + $ n \/ $ i ) ; } } return ( $ result + 1 ) ; } function areAmicable ( $ x , $ y ) { if ( divSum ( $ x ) != $ y ) return false ; return ( divSum ( $ y ) == $ x ) ; } $ x = 220 ; $ y = 284 ; if ( areAmicable ( $ x , $ y ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program to print non square numbers | Function to check perfect square ; function to print all non square number ; variable which stores the count ; not perfect square ; Driver Code","code":"< ? php function isPerfectSquare ( $ n ) { if ( $ n < 0 ) return false ; $ root = round ( sqrt ( $ n ) ) ; return $ n == $ root * $ root ; } function printnonsquare ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ count < $ n ; ++ $ i ) { if ( ! isPerfectSquare ( $ i ) ) { echo $ i . \" \" ; $ count ++ ; } } } $ n = 10 ; printnonsquare ( $ n ) ; ? >"}
{"text":"Program to print non square numbers | Returns n - th non - square number . ; loop to print non squares below n ; Driver Code","code":"< ? php function nonsquare ( $ n ) { return $ n + ( int ) ( 0.5 + sqrt ( $ n ) ) ; } function printNonSquare ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) printf ( nonsquare ( $ i ) . \" \u2581 \" ) ; } $ n = 10 ; printNonSquare ( $ n ) ; ? >"}
{"text":"Program to compare two fractions | Get max of the two fractions ; Declare nume1 and nume2 for get the value of first numerator and second numerator ; Compute ad - bc ; Driver Code","code":"< ? php function maxFraction ( $ first , $ sec ) { $ a = $ first [ 0 ] ; $ b = $ first [ 1 ] ; $ c = $ sec [ 0 ] ; $ d = $ sec [ 1 ] ; $ Y = $ a * $ d - $ b * $ c ; return ( $ Y ) ? $ first : $ sec ; } $ first = array ( 3 , 2 ) ; $ sec = array ( 3 , 4 ) ; $ res = maxFraction ( $ first , $ sec ) ; echo $ res [ 0 ] . \" \/ \" . $ res [ 1 ] ; ? >"}
{"text":"Program to check if N is a Pentagonal Number | Function to determine if N is pentagonal or not . ; Substitute values of i in the formula . ; Driver Code","code":"< ? php function isPentagonal ( int $ N ) { $ i = 1 ; $ M ; do { $ M = ( 3 * $ i * $ i - $ i ) \/ 2 ; $ i += 1 ; } while ( $ M < $ N ) ; return ( $ M == $ N ) ; } $ N = 12 ; if ( isPentagonal ( $ N ) ) echo $ N , \" \u2581 is \u2581 pentagonal \u2581 \" ; else echo $ N , \" \u2581 is \u2581 not \u2581 pentagonal \" ; ? >"}
{"text":"Sum of fourth powers of the first n natural numbers | Return the sum of fourth power of first n natural numbers ; Driver Code","code":"< ? php function fourthPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( $ i * $ i * $ i * $ i ) ; return $ sum ; } $ n = 6 ; echo ( fourthPowerSum ( $ n ) ) ; ? >"}
{"text":"Sum of fourth powers of the first n natural numbers | Return the sum of fourth power of first n natural numbers ; Driver Code","code":"< ? php function fourthPowerSum ( $ n ) { return ( ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 15 * $ n * $ n * $ n * $ n ) + ( 10 * $ n * $ n * $ n ) - $ n ) \/ 30 ; } $ n = 6 ; echo ( fourthPowerSum ( $ n ) ) ; ? >"}
{"text":"Find unit digit of x raised to power y | find unit digit ; Get last digit of x ; Last cyclic modular value ; here we simply return the unit digit or the power of a number ; Driver code ; get unit digit number here we pass the unit digit of x and the last cyclicity number that is y % 4","code":"< ? php function unitnumber ( $ x , $ y ) { $ x = $ x % 10 ; if ( $ y != 0 ) $ y = $ y % 4 + 4 ; return ( ( ( int ) ( pow ( $ x , $ y ) ) ) % 10 ) ; } $ x = 133 ; $ y = 5 ; echo ( unitnumber ( $ x , $ y ) ) ; ? >"}
{"text":"Aliquot sum | Function to calculate sum of all proper divisors ; Driver Code","code":"< ? php function aliquotSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum += $ i ; return $ sum ; } $ n = 12 ; echo ( aliquotSum ( $ n ) ) ; ? >"}
{"text":"Multiplication of two complex numbers given as strings | PHP program to multiply two complex numbers given as strings . ; Spiting the real and imaginary parts of the given complex strings based on ' + ' and ' i ' symbols . ; Storing the real part of complex string a ; Storing the imaginary part of complex string a ; Storing the real part of complex string b ; Storing the imaginary part of complex string b ; Returns the product . ; Driver Code","code":"< ? php function complexNumberMultiply ( $ a , $ b ) { $ x = preg_split ( \" \/ [ \\s + ] + \u2581 i \/ \" , $ a ) ; $ y = preg_split ( \" \/ [ \\s + ] + \u2581 i \/ \" , $ b ) ; $ a_real = intval ( $ x [ 0 ] ) ; $ a_img = intval ( $ x [ 1 ] ) ; $ b_real = intval ( $ y [ 0 ] ) ; $ b_img = intval ( $ y [ 1 ] ) ; return ( $ a_real * $ b_real - $ a_img * $ b_img ) . \" + \" ( $ a_real * $ b_img + $ a_img * $ b_real ) . \" i \" ; } $ str1 = \"1 + 1i \" ; $ str2 = \"1 + 1i \" ; echo complexNumberMultiply ( $ str1 , $ str2 ) ; ? >"}
{"text":"Average of Squares of Natural Numbers | Function to get the average ; Driver Code","code":"< ? php function AvgofSquareN ( $ n ) { return ( ( $ n + 1 ) * ( 2 * $ n + 1 ) ) \/ 6 ; } $ n = 2 ; echo ( AvgofSquareN ( $ n ) ) ; ? >"}
{"text":"Program to implement Simpson 's 3\/8 rule | Given function to be integrated ; Function to perform calculations ; Calculates value till integral limit ; Driver Code","code":"< ? php function func ( $ x ) { return ( 1 \/ ( 1 + $ x * $ x ) ) ; } function calculate ( $ lower_limit , $ upper_limit , $ interval_limit ) { $ interval_size = ( $ upper_limit - $ lower_limit ) \/ $ interval_limit ; $ sum = func ( $ lower_limit ) + func ( $ upper_limit ) ; for ( $ i = 1 ; $ i < $ interval_limit ; $ i ++ ) { if ( $ i % 3 == 0 ) $ sum = $ sum + 2 * func ( $ lower_limit + $ i * $ interval_size ) ; else $ sum = $ sum + 3 * func ( $ lower_limit + $ i * $ interval_size ) ; } return ( 3 * $ interval_size \/ 8 ) * $ sum ; } $ interval_limit = 10 ; $ lower_limit = 1 ; $ upper_limit = 10 ; $ integral_res = calculate ( $ lower_limit , $ upper_limit , $ interval_limit ) ; echo $ integral_res ; ? >"}
{"text":"Program for focal length of a lens | Function to determine the focal length of a lens ; variable to store the distance between the lens and the image ; variable to store the distance between the lens and the object","code":"< ? php function focal_length ( $ image_distance , $ object_distance ) { return 1 \/ ( ( 1 \/ $ image_distance ) + ( 1 \/ $ object_distance ) ) ; } $ image_distance = 2 ; $ object_distance = 50 ; echo \" Focal \u2581 length \u2581 of \u2581 a \u2581 lens \u2581 is \u2581 \" , focal_length ( $ image_distance , $ object_distance ) , \" \u2581 units \u2581 . \" ; ? >"}
{"text":"Count numbers in range L | check if the number is divisible by the digits . ; function to calculate the number of numbers ; Driver function","code":"< ? php function check ( $ n ) { $ m = $ n ; while ( $ n ) { $ r = $ n % 10 ; if ( $ r > 0 ) if ( ( $ m % $ r ) != 0 ) return false ; $ n \/= 10 ; } return true ; } function countIn ( $ l , $ r ) { $ ans = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) if ( check ( $ i ) ) $ ans += 1 ; return $ ans ; } $ l = 10 ; $ r = 20 ; echo countIn ( $ l , $ r ) ;"}
{"text":"Sum of the Series 1 \/ ( 1 * 2 ) + 1 \/ ( 2 * 3 ) + 1 \/ ( 3 * 4 ) + 1 \/ ( 4 * 5 ) + . . . . . | function to find the sum of given series ; Computing sum term by term ; Driver Code","code":"< ? php function sumOfTheSeries ( $ n ) { $ sum = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 1.0 \/ ( $ i * ( $ i + 1 ) ) ; return $ sum ; } $ n = 10 ; echo sumOfTheSeries ( $ n ) ; ? >"}
{"text":"Sum of series ( n \/ 1 ) + ( n \/ 2 ) + ( n \/ 3 ) + ( n \/ 4 ) + ... ... . + ( n \/ n ) | function to find sum of series ; Driver code","code":"< ? php function sum ( $ n ) { $ root = intval ( sqrt ( $ n ) ) ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) $ ans += intval ( $ n \/ $ i ) ; $ ans = ( 2 * $ ans ) - ( $ root * $ root ) ; return $ ans ; } $ n = 35 ; echo ( sum ( $ n ) ) ; ? >"}
{"text":"Sum of the series 2 + ( 2 + 4 ) + ( 2 + 4 + 6 ) + ( 2 + 4 + 6 + 8 ) + \u00e2 \u20ac\u00a6 \u00e2 \u20ac\u00a6 + ( 2 + 4 + 6 + 8 + \u00e2 \u20ac\u00a6 . + 2 n ) | function to find the sum of the given series ; sum of 1 st n natural numbers ; sum of squares of 1 st n natural numbers ; required sum ; Driver Code","code":"< ? php function sumOfTheSeries ( $ n ) { $ sum_n = ( $ n * ( $ n + 1 ) \/ 2 ) ; $ sum_sq_n = ( $ n * ( $ n + 1 ) \/ 2 ) * ( 2 * $ n + 1 ) \/ 3 ; return ( $ sum_n + $ sum_sq_n ) ; } $ n = 5 ; echo ( \" Sum \u2581 = \u2581 \" . sumOfTheSeries ( $ n ) ) ; ? >"}
{"text":"Sum of squares of binomial coefficients | Return the sum of square of binomial coefficient ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; Finding the sum of square of binomial coefficient . ; Driven Program","code":"< ? php function sumofsquare ( $ n ) { $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ C [ $ n ] [ $ i ] * $ C [ $ n ] [ $ i ] ) ; return $ sum ; } $ n = 4 ; echo sumofsquare ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program to find sum of series 1 + 2 + 2 + 3 + 3 + 3 + . . . + n | Function that find sum of series . ; Driver Code ; Function call","code":"< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum = $ sum + $ i ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Find sum of even index binomial coefficients | Return the sum of even index term ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; finding sum of even index term . ; Driver Code","code":"< ? php function evenSum ( $ n ) { $ C = array ( array ( ) ) ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 or $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += 2 ) $ sum += $ C [ $ n ] [ $ i ] ; return $ sum ; } $ n = 4 ; echo evenSum ( $ n ) ; ? >"}
{"text":"Program to print triangular number series till n | Function to find triangular number ; Driver Code","code":"< ? php function triangular_series ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo ( \" \u2581 \" . $ i * ( $ i + 1 ) \/ 2 . \" \u2581 \" ) ; } $ n = 5 ; triangular_series ( $ n ) ; ? >"}
{"text":"Check if a number can be written as sum of three consecutive integers | function to check if a number can be written as sum of three consecutive integers . ; if n is multiple of 3 ; else print \" - 1\" . ; Driver Program","code":"< ? php function checksum ( $ n ) { if ( $ n % 3 == 0 ) echo $ n \/ 3 - 1 , \" \u2581 \" , $ n \/ 3 , \" \u2581 \" , $ n \/ 3 + 1 ; else echo \" - 1\" ; } $ n = 6 ; checksum ( $ n ) ; ? >"}
{"text":"Sum of all divisors from 1 to n | Utility function to find sum of all divisor of number up to ' n ' ; Driver code","code":"< ? php function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ sum += floor ( $ n \/ $ i ) * $ i ; return $ sum ; } $ n = 4 ; echo divisorSum ( $ n ) , \" STRNEWLINE \" ; $ n = 5 ; echo divisorSum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"N | function to evaluate Nth polite number ; Driver code","code":"< ? php function polite ( $ n ) { $ n += 1 ; $ base = 2 ; return $ n + ( log ( ( $ n + ( log ( $ n ) \/ log ( $ base ) ) ) ) ) \/ log ( $ base ) ; } $ n = 7 ; echo ( ( int ) polite ( $ n ) ) ; ? >"}
{"text":"Find the number of stair steps | Modified Binary search function to solve the equation ; if mid is solution to equation ; if our solution to equation lies between mid and mid - 1 ; if solution to equation is greater than mid ; if solution to equation is less than mid ; Driver Code ; call binary search method to solve for limits 1 to T ; Because our pattern starts from 2 , 3 , 4 , 5. . . so , we subtract 1 from ans","code":"< ? php function solve ( $ low , $ high , $ T ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) \/ 2 ; if ( ( $ mid * ( $ mid + 1 ) ) == $ T ) return $ mid ; if ( $ mid > 0 && ( $ mid * ( $ mid + 1 ) ) > $ T && ( $ mid * ( $ mid - 1 ) ) <= $ T ) return $ mid - 1 ; if ( ( $ mid * ( $ mid + 1 ) ) > $ T ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return -1 ; } $ T = 15 ; $ ans = solve ( 1 , $ T , 2 * $ T ) ; if ( $ ans != -1 ) $ ans -- ; echo \" Number \u2581 of \u2581 stair \u2581 steps \u2581 = \u2581 \" , $ ans , \" STRNEWLINE \" ; ? >"}
{"text":"Check for integer overflow on multiplication | Function to check whether there is overflow in a * b or not . It returns true if there is overflow . ; Check if either of them is zero ; Driver code","code":"< ? php function isOverflow ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return false ; $ result = $ a * $ b ; if ( $ a == ( int ) $ result \/ $ b ) return false ; else return true ; } $ a = 10000000000 ; $ b = -10000000000 ; if ( isOverflow ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sum of first n odd numbers in O ( 1 ) Complexity | Returns the sum of first n odd numbers ; Driver Code","code":"< ? php function oddSum ( $ n ) { $ sum = 0 ; $ curr = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; } $ n = 20 ; echo \" \u2581 Sum \u2581 of \u2581 first \u2581 \" , $ n , \" \u2581 Odd \u2581 Numbers \u2581 is : \u2581 \" , oddSum ( $ n ) ; ? >"}
{"text":"Sum of first n odd numbers in O ( 1 ) Complexity | Returns the sum of first n odd numbers ; Driver Code","code":"< ? php function oddSum ( $ n ) { return ( $ n * $ n ) ; } $ n = 20 ; echo \" \u2581 Sum \u2581 of \u2581 first \u2581 \" , $ n , \" \u2581 Odd \u2581 Numbers \u2581 is : \u2581 \" , oddSum ( $ n ) ; ? >"}
{"text":"K | Returns the sum of first n odd numbers ; Count prime factors of all numbers till B . ; Print all numbers with k prime factors ; Driver code","code":"< ? php function printKPFNums ( $ A , $ B , $ K ) { $ prime = array_fill ( true , $ B + 1 , NULL ) ; $ p_factors = array_fill ( 0 , $ B + 1 , NULL ) ; for ( $ p = 2 ; $ p <= $ B ; $ p ++ ) if ( $ p_factors [ $ p ] == 0 ) for ( $ i = $ p ; $ i <= $ B ; $ i += $ p ) $ p_factors [ $ i ] ++ ; for ( $ i = $ A ; $ i <= $ B ; $ i ++ ) if ( $ p_factors [ $ i ] == $ K ) echo $ i . \" \" ; } $ A = 14 ; $ B = 18 ; $ K = 2 ; printKPFNums ( $ A , $ B , $ K ) ; ? >"}
{"text":"Queries for maximum difference between prime numbers in given ranges | PHP program to find maximum differences between two prime numbers in given ranges ; Precompute Sieve , Prefix array , Suffix array ; Sieve of Eratosthenes ; Precomputing Prefix array . ; Precompute Suffix array . ; Function to solve each query ; Driver Code","code":"< ? php $ MAX = 100005 ; function precompute ( & $ prefix , & $ suffix ) { global $ MAX ; $ prime = array_fill ( 0 , $ MAX , true ) ; for ( $ i = 2 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ prime [ $ i ] ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) $ prime [ $ j ] = false ; } } $ prefix [ 1 ] = 1 ; $ suffix [ $ MAX - 1 ] = 1e9 + 7 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) { if ( $ prime [ $ i ] ) $ prefix [ $ i ] = $ i ; else $ prefix [ $ i ] = $ prefix [ $ i - 1 ] ; } for ( $ i = $ MAX - 1 ; $ i > 1 ; $ i -- ) { if ( $ prime [ $ i ] ) $ suffix [ $ i ] = $ i ; else $ suffix [ $ i ] = $ suffix [ $ i + 1 ] ; } } function query ( $ prefix , $ suffix , $ L , $ R ) { if ( $ prefix [ $ R ] < $ L $ suffix [ $ L ] > $ R ) return 0 ; else return $ prefix [ $ R ] - $ suffix [ $ L ] ; } $ q = 3 ; $ L = array ( 2 , 2 , 24 ) ; $ R = array ( 5 , 2 , 28 ) ; $ prefix = array_fill ( 0 , $ MAX + 1 , 0 ) ; $ suffix = array_fill ( 0 , $ MAX + 1 , 0 ) ; precompute ( $ prefix , $ suffix ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo query ( $ prefix , $ suffix , $ L [ $ i ] , $ R [ $ i ] ) . \" STRNEWLINE \" ; ? >"}
{"text":"Sum of the Series 1 + x \/ 1 + x ^ 2 \/ 2 + x ^ 3 \/ 3 + . . + x ^ n \/ n | Code to print the sum of the series ; Driver code","code":"< ? php function sum ( $ x , $ n ) { $ i ; $ total = 1.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ total = $ total + ( pow ( $ x , $ i ) \/ $ i ) ; return $ total ; } $ x = 2 ; $ n = 5 ; echo ( sum ( $ x , $ n ) ) ; ? >"}
{"text":"Find if a number is part of AP whose first element and difference are given | returns yes if exist else no . ; If difference is 0 , then x must be same as a ; Else difference between x and a must be divisible by d . ; Driver code .","code":"< ? php function isMember ( $ a , $ d , $ x ) { if ( $ d == 0 ) return ( $ x == $ a ) ; return ( ( $ x - $ a ) % $ d == 0 && ( $ x - $ a ) \/ $ d >= 0 ) ; } $ a = 1 ; $ x = 7 ; $ d = 3 ; if ( isMember ( $ a , $ d , $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check whether a number can be represented by sum of two squares | function to check if there exist two numbers sum of whose squares is n . ; Driver Code","code":"< ? php function sumSquare ( int $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j * $ j <= $ n ; $ j ++ ) if ( $ i * $ i + $ j * $ j == $ n ) { echo $ i , \" ^ 2 \u2581 + \u2581 \" , $ j , \" ^ 2\" ; return true ; } return false ; } $ n = 25 ; if ( sumSquare ( $ n ) ) echo \" \u2581 STRNEWLINE \" , \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Smallest root of the equation x ^ 2 + s ( x ) * x | function to check if the sum of digits is equal to the summation assumed ; calculate the sum of digit ; function to find the largest root possible . ; iterate for all possible sum of digits . ; check if discriminent is a perfect square . ; check if discriminent is a perfect square and if it as perefect root of the equation ; function returns answer ; Driver Code","code":"< ? php function check ( $ a , $ b ) { $ c = 0 ; while ( $ a != 0 ) { $ c = $ c + $ a % 10 ; $ a = ( int ) ( $ a \/ 10 ) ; } return ( $ c == $ b ) ? true : false ; } function root ( $ n ) { $ found = false ; $ mx = 1000000000000000001 ; for ( $ i = 0 ; $ i <= 90 ; $ i ++ ) { $ s = $ i * $ i + 4 * $ n ; $ sq = ( int ) ( sqrt ( $ s ) ) ; if ( $ sq * $ sq == $ s && check ( ( int ) ( ( $ sq - $ i ) \/ 2 ) , $ i ) ) { $ found = true ; $ mx = min ( $ mx , ( int ) ( ( $ sq - $ i ) \/ 2 ) ) ; } } if ( $ found ) return $ mx ; else return -1 ; } $ n = 110 ; echo root ( $ n ) ; ? >"}
{"text":"Sum of digits of a given number to a given power | Function to calculate sum ; Driver Code","code":"< ? php function calculate ( $ n , $ power ) { $ sum = 0 ; $ bp = ( int ) pow ( $ n , $ power ) ; while ( $ bp != 0 ) { $ d = $ bp % 10 ; $ sum += $ d ; $ bp \/= 10 ; } return $ sum ; } $ n = 5 ; $ power = 4 ; echo ( calculate ( $ n , $ power ) ) ; ? >"}
{"text":"Co | Utility function ; function to check if pair is co - prime or not ; function to find and print co - prime pair ; Driver code","code":"< ? php function gcd ( $ num1 , $ num2 ) { while ( $ num2 != 0 ) { $ t = $ num1 % $ num2 ; $ num1 = $ num2 ; $ num2 = $ t ; } return $ num1 ; } function coprime ( $ a , $ b ) { if ( gcd ( $ a , $ b ) == 1 ) return 1 ; else return 0 ; } function pairSum ( $ n ) { $ mid = ( int ) ( ( $ n \/ 2 ) ) ; for ( $ i = $ mid ; $ i >= 1 ; $ i -- ) { if ( coprime ( $ i , $ n - $ i ) == 1 ) { echo $ i . \" \u2581 \" . ( $ n - $ i ) ; break ; } } } $ n = 11 ; pairSum ( $ n ) ; ? >"}
{"text":"Program for quotient and remainder of big number | Function to calculate the modulus ; Store the modulus of big number ; Do step by step division ; Update modulo by concatenating current digit . ; Update quotient ; Update mod for next iteration . ; Flag used to remove starting zeros ; Driver Code","code":"< ? php function modBigNumber ( $ num , $ m ) { $ vec ; $ x = 0 ; $ mod = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) { $ digit = $ num [ $ i ] - '0' ; $ mod = $ mod * 10 + $ digit ; $ quo = ( int ) ( $ mod \/ $ m ) ; $ vec [ $ x ++ ] = $ quo ; $ mod = $ mod % $ m ; } echo \" Remainder \u2581 : \u2581 \" . $ mod . \" STRNEWLINE \" ; echo \" Quotient \u2581 : \u2581 \" ; $ zeroflag = 0 ; for ( $ i = 0 ; $ i < $ x ; $ i ++ ) { if ( $ vec [ $ i ] == 0 && $ zeroflag == 0 ) continue ; $ zeroflag = 1 ; echo $ vec [ $ i ] ; } return ; } $ num = \"14598499948265358486\" ; $ m = 487 ; modBigNumber ( $ num , $ m ) ; ? >"}
{"text":"Queries to find whether a number has exactly four distinct factors or not | Initialize global variable according to given condition so that it can be accessible to all function ; Function to calculate all number having four distinct factors ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Initialize prime [ ] array which will contains all the primes from 1 - N ; Iterate over all the prime numbers ; Mark cube root of prime numbers ; Mark product of prime numbers ; Driver Code","code":"< ? php $ N = 1000001 ; $ fourDiv = array_fill ( 0 , $ N + 1 , false ) ; function fourDistinctFactors ( ) { global $ N ; global $ fourDiv ; $ primeAll = array_fill ( 0 , $ N + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ primeAll [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ primeAll [ $ i ] = false ; } } $ prime ; $ x = 0 ; for ( $ p = 2 ; $ p <= $ N ; $ p ++ ) if ( $ primeAll [ $ p ] ) $ prime [ $ x ++ ] = $ p ; for ( $ i = 0 ; $ i < $ x ; ++ $ i ) { $ p = $ prime [ $ i ] ; if ( 1 * $ p * $ p * $ p <= $ N ) $ fourDiv [ $ p * $ p * $ p ] = true ; for ( $ j = $ i + 1 ; $ j < $ x ; ++ $ j ) { $ q = $ prime [ $ j ] ; if ( 1 * $ p * $ q > $ N ) break ; $ fourDiv [ $ p * $ q ] = true ; } } } fourDistinctFactors ( ) ; $ num = 10 ; if ( $ fourDiv [ $ num ] ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ num = 12 ; if ( $ fourDiv [ $ num ] ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Leonardo Number | A simple recursive program to find n - th leonardo number . ; Driver code","code":"< ? php function leonardo ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + 1 ; return $ dp [ $ n ] ; } echo leonardo ( 3 ) ; ? >"}
{"text":"Cholesky Decomposition : Matrix Decomposition | PHP program to decompose a matrix using Cholesky Decomposition ; Decomposing a matrix into Lower Triangular ; summation for diagonals ; Evaluating L ( i , j ) using L ( j , j ) ; Displaying Lower Triangular and its Transpose ; Lower Triangular ; Transpose of Lower Triangular ; Driver Code","code":"< ? php $ MAX = 100 ; function Cholesky_Decomposition ( $ matrix , $ n ) { $ lower ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ lower [ $ i ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { $ sum = 0 ; if ( $ j == $ i ) { for ( $ k = 0 ; $ k < $ j ; $ k ++ ) $ sum += pow ( $ lower [ $ j ] [ $ k ] , 2 ) ; $ lower [ $ j ] [ $ j ] = sqrt ( $ matrix [ $ j ] [ $ j ] - $ sum ) ; } else { for ( $ k = 0 ; $ k < $ j ; $ k ++ ) $ sum += ( $ lower [ $ i ] [ $ k ] * $ lower [ $ j ] [ $ k ] ) ; $ lower [ $ i ] [ $ j ] = ( $ matrix [ $ i ] [ $ j ] - $ sum ) \/ $ lower [ $ j ] [ $ j ] ; } } } echo \" TABSYMBOL Lower \u2581 Triangular \" . str_pad ( \" Transpose \" , 30 , \" \u2581 \" , STR_PAD_BOTH ) . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo str_pad ( $ lower [ $ i ] [ $ j ] , 6 , \" \u2581 \" , STR_PAD_BOTH ) . \" TABSYMBOL \" ; echo \" TABSYMBOL \" ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo str_pad ( $ lower [ $ j ] [ $ i ] , 6 , \" \u2581 \" , STR_PAD_BOTH ) . \" TABSYMBOL \" ; echo \" STRNEWLINE \" ; } } $ n = 3 ; $ matrix = array ( array ( 4 , 12 , -16 ) , array ( 12 , 37 , -43 ) , array ( -16 , -43 , 98 ) ) ; Cholesky_Decomposition ( $ matrix , $ n ) ; ? >"}
{"text":"Program for sum of arithmetic series | Efficient PHP code to find sum of arithmetic series . ; Driver code","code":"< ? php function sumOfAP ( $ a , $ d , $ n ) { $ sum = ( $ n \/ 2 ) * ( 2 * $ a + ( $ n - 1 ) * $ d ) ; return $ sum ; } $ n = 20 ; $ a = 2.5 ; $ d = 1.5 ; echo ( sumOfAP ( $ a , $ d , $ n ) ) ; ? >"}
{"text":"Program for cube sum of first n natural numbers | Returns sum of first n natural numbers ; Driver code","code":"< ? php function sumOfSeries ( $ n ) { $ x ; if ( $ n % 2 == 0 ) $ x = ( $ n \/ 2 ) * ( $ n + 1 ) ; else $ x = ( ( $ n + 1 ) \/ 2 ) * $ n ; return $ x * $ x ; } $ n = 5 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text":"Maximum value of | arr [ i ] | PHP program to find maximum value of | arr [ i ] - arr [ j ] | + | i - j | ; Return maximum value of | arr [ i ] - arr [ j ] | + | i - j | ; Iterating two for loop , one for i and another for j . ; Evaluating | arr [ i ] - arr [ j ] | + | i - j | and compare with previous maximum . ; Driver Code","code":"< ? php $ MAX = 10 ; function findValue ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ ans = max ( $ ans , abs ( $ arr [ $ i ] - $ arr [ $ j ] ) + abs ( $ i - $ j ) ) ; return $ ans ; } $ arr = array ( 1 , 2 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo findValue ( $ arr , $ n ) ; ? >"}
{"text":"Maximum value of | arr [ i ] | Return maximum | arr [ i ] - arr [ j ] | + | i - j | ; Calculating first_array and second_array ; Finding maximum and minimum value in first_array ; Storing the difference between maximum and minimum value in first_array ; Finding maximum and minimum value in second_array ; Storing the difference between maximum and minimum value in second_array ; Driver Code","code":"< ? php function findValue ( $ arr , $ n ) { $ a [ ] = array ( ) ; $ b = array ( ) ; $ tmp ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = ( $ arr [ $ i ] + $ i ) ; $ b [ $ i ] = ( $ arr [ $ i ] - $ i ) ; } $ x = $ a [ 0 ] ; $ y = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) $ x = $ a [ $ i ] ; if ( $ a [ $ i ] < $ y ) $ y = $ a [ $ i ] ; } $ ans1 = ( $ x - $ y ) ; $ x = $ b [ 0 ] ; $ y = $ b [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ b [ $ i ] > $ x ) $ x = $ b [ $ i ] ; if ( $ b [ $ i ] < $ y ) $ y = $ b [ $ i ] ; } $ ans2 = ( $ x - $ y ) ; return max ( $ ans1 , $ ans2 ) ; } $ arr = array ( 1 , 2 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo findValue ( $ arr , $ n ) ; ? >"}
{"text":"Number of subarrays having product less than K | PHP program to count subarrays having product less than k . ; Counter for single element ; Multiple subarray ; If this multiple is less than k , then increment ; Driver Code","code":"< ? php function countsubarray ( $ array , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ k ) $ count ++ ; $ mul = $ array [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mul = $ mul * $ array [ $ j ] ; if ( $ mul < $ k ) $ count ++ ; else break ; } } return $ count ; } $ array = array ( 1 , 2 , 3 , 4 ) ; $ k = 10 ; $ size = sizeof ( $ array ) ; $ count = countsubarray ( $ array , $ size , $ k ) ; echo ( $ count . \" \" ) ; ? >"}
{"text":"Efficient program to print the number of factors of n numbers | PHP program to count number of factors of an array of integers ; function to generate all prime factors of numbers from 1 to 10 ^ 6 ; Initializes all the positions with their value . ; Initializes all multiples of 2 with 2 ; A modified version of Sieve of Eratosthenes to store the smallest prime factor that divides every number . ; check if it has no prime factor . ; Initializes of j starting from i * i ; if it has no prime factor before , then stores the smallest prime divisor ; function to calculate number of factors ; stores the smallest prime number that divides n ; stores the count of number of times a prime number divides n . ; reduces to the next number after prime factorization of n ; false when prime factorization is done ; if the same prime number is dividing n , then we increase the count ; if its a new prime factor that is factorizing n , then we again set c = 1 and change dup to the new prime factor , and apply the formula explained above . ; prime factorizes a number ; for the last prime factor ; generate prime factors of number upto 10 ^ 6","code":"< ? php $ MAX = 1000001 ; $ factor = array_fill ( 0 , $ MAX + 1 , 0 ) ; function generatePrimeFactors ( ) { global $ factor ; global $ MAX ; $ factor [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ factor [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAX ; $ i += 2 ) $ factor [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ factor [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) { if ( $ factor [ $ j ] == $ j ) $ factor [ $ j ] = $ i ; } } } } function calculateNoOFactors ( $ n ) { global $ factor ; if ( $ n == 1 ) return 1 ; $ ans = 1 ; $ dup = $ factor [ $ n ] ; $ c = 1 ; $ j = ( int ) ( $ n \/ $ factor [ $ n ] ) ; while ( $ j != 1 ) { if ( $ factor [ $ j ] == $ dup ) $ c += 1 ; else { $ dup = $ factor [ $ j ] ; $ ans = $ ans * ( $ c + 1 ) ; $ c = 1 ; } $ j = ( int ) ( $ j \/ $ factor [ $ j ] ) ; } $ ans = $ ans * ( $ c + 1 ) ; return $ ans ; } generatePrimeFactors ( ) ; $ a = array ( 10 , 30 , 100 , 450 , 987 ) ; $ q = sizeof ( $ a ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo calculateNoOFactors ( $ a [ $ i ] ) . \" \u2581 \" ; ? >"}
{"text":"Digit | function to produce and print Digit Product Sequence ; Array which store sequence ; Temporary variable to store product ; Initialize first element of the array with 1 ; Run a loop from 1 to N . Check if previous number is single digit or not . If yes then product = 1 else take modulus . Then again check if previous number is single digit or not if yes then store previous number , else store its first value Then for every i store value in the array . ; Print sequence ; Value of N ; Calling function","code":"< ? php function digit_product_Sum ( $ N ) { $ a = array_fill ( 0 , $ N , 0 ) ; $ product = 1 ; $ a [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ product = ( int ) ( $ a [ $ i - 1 ] \/ 10 ) ; if ( $ product == 0 ) $ product = 1 ; else $ product = $ a [ $ i - 1 ] % 10 ; $ val = ( int ) ( $ a [ $ i - 1 ] \/ 10 ) ; if ( $ val == 0 ) $ val = $ a [ $ i - 1 ] ; $ a [ $ i ] = $ a [ $ i - 1 ] + ( $ val * $ product ) ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) echo $ a [ $ i ] . \" \u2581 \" ; } $ N = 10 ; digit_product_Sum ( $ N ) ; ? >"}
{"text":"Geometric mean ( Two Methods ) | function to calculate geometric mean and return float value . ; declare product variable and initialize it to 1. ; Compute the product of all the elements in the array . ; compute geometric mean through formula pow ( product , 1 \/ n ) and return the value to main function . ; Driver Code","code":"< ? php function geometricMean ( $ arr , $ n ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product * $ arr [ $ i ] ; $ gm = pow ( $ product , ( float ) ( 1 \/ $ n ) ) ; return $ gm ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) ; $ n = sizeof ( $ arr ) ; echo ( geometricMean ( $ arr , $ n ) ) ; ? >"}
{"text":"Check whether a number can be expressed as a product of single digit numbers | function to check whether a number can be expressed as a product of single digit numbers ; if ' n ' is a single digit number , then it can be expressed ; define single digit prime numbers array ; repeatedly divide ' n ' by the given prime numbers until all the numbers are used or ' n ' > 1 ; if true , then ' n ' can be expressed ; Driver Code","code":"< ? php function productOfSingelDgt ( $ n , $ SIZE ) { if ( $ n >= 0 && $ n <= 9 ) return true ; $ prime = array ( 2 , 3 , 5 , 7 ) ; for ( $ i = 0 ; $ i < $ SIZE && $ n > 1 ; $ i ++ ) while ( $ n % $ prime [ $ i ] == 0 ) $ n = $ n \/ $ prime [ $ i ] ; return ( $ n == 1 ) ; } $ SIZE = 4 ; $ n = 24 ; if ( productOfSingelDgt ( $ n , $ SIZE ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program to find sum of first n natural numbers | Returns sum of first n natural numbers ; If n is odd , ( n + 1 ) must be even ; Driver code","code":"< ? php function findSum ( $ n ) { if ( $ n % 2 == 0 ) return ( $ n \/ 2 ) * ( $ n + 1 ) ; else return ( ( $ n + 1 ) \/ 2 ) * $ n ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text":"Maximum number of unique prime factors | Return maximum number of prime factors for any number in [ 1 , N ] ; Based on Sieve of Eratosthenes ; If p is prime ; We simply multiply first set of prime numbers while the product is smaller than N . ; Driver Code","code":"< ? php function maxPrimefactorNum ( $ N ) { if ( $ N < 2 ) return 0 ; $ arr = array_fill ( 0 , ( $ N + 1 ) , true ) ; $ prod = 1 ; $ res = 0 ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ arr [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ arr [ $ i ] = false ; $ prod *= $ p ; if ( $ prod > $ N ) return $ res ; $ res ++ ; } } return $ res ; } $ N = 500 ; echo maxPrimefactorNum ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program to print multiplication table of a number | change input number Change here to ; change result .","code":"< ? php $ n = 8 ; $ range = 12 ; for ( $ i = 1 ; $ i <= $ range ; ++ $ i ) echo $ n , \" \u2581 * \u2581 \" , $ i , \" \u2581 = \u2581 \" , $ n * $ i , \" STRNEWLINE \" ; ? >"}
{"text":"To check a number is palindrome or not without using any extra space | Function to check if given number is palindrome or not without using the extra space ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Driver code","code":"< ? php function isPalindrome ( $ n ) { $ divisor = 1 ; while ( $ n \/ $ divisor >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = floor ( $ n \/ $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( $ n % $ divisor ) \/ 10 ; $ divisor = $ divisor \/ 100 ; } return true ; } if ( isPalindrome ( 1001 ) == true ) echo \" Yes , \u2581 it \u2581 is \u2581 Palindrome \" ; else echo \" No , \u2581 not \u2581 Palindrome \" ; ? >"}
{"text":"Find whether a given integer is a power of 3 or not | Returns true if n is power of 3 , else false ; The maximum power of 3 value that integer can hold is 1162261467 ( 3 ^ 19 ) . ; Driver code","code":"< ? php function check ( $ n ) { return 1162261467 % $ n == 0 ; } $ n = 9 ; if ( check ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Demlo number ( Square of 11. . .1 ) | To return demlo number . This function assumes that the length of str is smaller than 10. ; Add numbers to res upto size of str and then add number reverse to it ; Driver Code","code":"< ? php function printDemlo ( $ str ) { $ len = strlen ( $ str ) ; $ res = \" \" ; for ( $ i = 1 ; $ i <= $ len ; $ i ++ ) $ res . = chr ( $ i + 48 ) ; for ( $ i = $ len - 1 ; $ i >= 1 ; $ i -- ) $ res . = chr ( $ i + 48 ) ; return $ res ; } $ str = \"111111\" ; echo printDemlo ( $ str ) ; ? >"}
{"text":"Number of times a number can be replaced by the sum of its digits until it only contains one digit | PHP program to count number of times we need to add digits to get a single digit . ; Here the count variable store how many times we do sum of digits and temporary_sum always store the temporary sum we get at each iteration . ; In this loop we always compute the sum of digits in temporary_ sum variable and convert it into string str till its length become 1 and increase the count in each iteration . ; computing sum of its digits ; converting temporary_sum into string str again . ; increase the count ; Driver Code","code":"< ? php function NumberofTimes ( $ str ) { $ temporary_sum = 0 ; $ count = 0 ; while ( strlen ( $ str ) > 1 ) { $ temporary_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ temporary_sum += ( $ str [ $ i ] - '0' ) ; $ str = ( string ) ( $ temporary_sum ) ; $ count ++ ; } return $ count ; } $ s = \"991\" ; echo NumberofTimes ( $ s ) ; ? >"}
{"text":"Climb n | function return the number of ways ; Driver Code","code":"< ? php function calculateLeaps ( $ n ) { if ( $ n == 0 $ n == 1 ) { return 1 ; } else { $ leaps = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leaps += calculateLeaps ( $ i ) ; return $ leaps ; } } echo calculateLeaps ( 4 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Print last k digits of a ^ b ( a raised to power b ) | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; function to calculate number of digits in x ; function to print last k digits of a ^ b ; Generating 10 ^ k ; Calling modular exponentiation ; Printing leftmost zeros . Since ( a ^ b ) % k can have digits less then k . In that case we need to print zeros ; If temp is not zero then print temp If temp is zero then already printed ; Driver Code","code":"< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function numberOfDigits ( $ x ) { $ i = 0 ; while ( $ x ) { $ x = ( int ) $ x \/ 10 ; $ i ++ ; } return $ i ; } function printLastKDigits ( $ a , $ b , $ k ) { echo \" Last \u2581 \" , $ k ; echo \" \u2581 digits \u2581 of \u2581 \" , $ a ; echo \" ^ \" , $ b , \" \u2581 = \u2581 \" ; $ temp = 1 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) $ temp *= 10 ; $ temp = power ( $ a , $ b , $ temp ) ; for ( $ i = 0 ; $ i < $ k - numberOfDigits ( $ temp ) ; $ i ++ ) echo 0 ; if ( $ temp ) echo $ temp ; } $ a = 11 ; $ b = 3 ; $ k = 2 ; printLastKDigits ( $ a , $ b , $ k ) ; ? >"}
{"text":"Adam Number | To reverse Digits of numbers ; To square number ; To check Adam Number ; Square first number and square reverse digits of second number ; If reverse of b equals a then given number is Adam number ; Driver Code","code":"< ? php function reverseDigits ( $ num ) { $ rev = 0 ; while ( $ num > 0 ) { $ rev = $ rev * 10 + $ num % 10 ; $ num = ( int ) $ num \/ 10 ; } return $ rev ; } function square ( $ num ) { return ( $ num * $ num ) ; } function checkAdamNumber ( $ num ) { $ a = square ( $ num ) ; $ b = square ( reverseDigits ( $ num ) ) ; if ( $ a == reverseDigits ( $ b ) ) return 0 ; return -1 ; } $ num = 12 ; if ( checkAdamNumber ( $ num ) ) echo \" Adam \u2581 Number \" ; else echo \" Not \u2581 a \u2581 Adam \u2581 Number \" ; ? >"}
{"text":"Compute the parity of a number using XOR and table look | Generating the look - up table while pre - processing ; LOOK_UP is the macro expansion to generate the table ; Function to find the parity ; Number is considered to be of 32 bits ; Dividing the number into 8 - bit chunks while performing X - OR ; Masking the number with 0xff ( 11111111 ) to produce valid 8 - bit result ; Driver code ; Result is 1 for odd parity , 0 for even parity ; Printing the desired result","code":"< ? php #define P2 ( n )  n, n ^ 1, n ^ 1, n NEW_LINE #define P4 ( n )  P2(n), P2(n ^ 1),  NEW_LINE P2 ( n ^ 1 ) , P2 ( n ) #define P6 ( n )  P4(n), P4(n ^ 1),  NEW_LINE P4 ( n ^ 1 ) , P4 ( n ) #define LOOK_UP  P6(0), P6(1),  NEW_LINE P6 ( 1 ) , P6 ( 0 ) $ table = array ( LOOK_UP ) ; function Parity ( $ num ) { global $ table ; $ max = 16 ; while ( $ max >= 8 ) { $ num = $ num ^ ( $ num >> $ max ) ; $ max = ( int ) $ max \/ 2 ; } return $ table [ $ num & 0xff ] ; } $ num = 1742346774 ; $ result = Parity ( $ num ) ; if ( $ result == true ) echo \" Odd \u2581 Parity \" ; else echo \" Even \u2581 Parity \" ; ? >"}
{"text":"Count total number of digits from 1 to n | PHP program to count total number of digits we have to write from 1 to n ; number_of_digits store total digits we have to write ; In the loop we are decreasing 0 , 9 , 99 ... from n till ( n - i + 1 ) is greater than 0 and sum them to number_of_digits to get the required sum ; Driver Code","code":"< ? php function totalDigits ( $ n ) { $ number_of_digits = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) $ number_of_digits += ( $ n - $ i + 1 ) ; return $ number_of_digits ; } $ n = 13 ; echo totalDigits ( $ n ) ; ? >"}
{"text":"Numbers with exactly 3 divisors | Generates all primes upto n and prints their squares ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; print squares of primes upto n . ; Driver Code","code":"< ? php function numbersWith3Divisors ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } echo \" Numbers \u2581 with \u2581 3 \u2581 divisors \u2581 : STRNEWLINE \" ; for ( $ i = 0 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ prime [ $ i ] ) echo $ i * $ i . \" \u2581 \" ; } $ n = 96 ; numbersWith3Divisors ( $ n ) ; ? >"}
{"text":"Program for decimal to hexadecimal conversion | function to convert decimal to hexadecimal ; char array to store hexadecimal number ; counter for hexadecimal number array ; temporary variable to store remainder ; storing remainder in temp variable . ; check if temp < 10 ; printing hexadecimal number array in reverse order ; Driver Code","code":"< ? php function decToHexa ( $ n ) { $ hexaDeciNum ; $ i = 0 ; while ( $ n != 0 ) { $ temp = 0 ; $ temp = $ n % 16 ; if ( $ temp < 10 ) { $ hexaDeciNum [ $ i ] = chr ( $ temp + 48 ) ; $ i ++ ; } else { $ hexaDeciNum [ $ i ] = chr ( $ temp + 55 ) ; $ i ++ ; } $ n = ( int ) ( $ n \/ 16 ) ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ hexaDeciNum [ $ j ] ; } $ n = 2545 ; decToHexa ( $ n ) ; ? >"}
{"text":"Program for Decimal to Binary Conversion | function to convert decimal to binary ; array to store binary number ; counter for binary array ; storing remainder in binary array ; printing binary array in reverse order ; Driver Code","code":"< ? php function decToBinary ( $ n ) { $ binaryNum ; $ i = 0 ; while ( $ n > 0 ) { $ binaryNum [ $ i ] = $ n % 2 ; $ n = ( int ) ( $ n \/ 2 ) ; $ i ++ ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ binaryNum [ $ j ] ; } $ n = 17 ; decToBinary ( $ n ) ; ? >"}
{"text":"Break the number into three parts | Function to count number of ways to make the given number n ; Driver Code","code":"< ? php function count_of_ways ( $ n ) { $ count ; $ count = ( $ n + 1 ) * ( $ n + 2 ) \/ 2 ; return $ count ; } $ n = 3 ; echo count_of_ways ( $ n ) ; ? >"}
{"text":"Implement * , | Function to flip the sign using only \" + \" operator ( It is simple with ' * ' allowed . We need to do a = ( - 1 ) * a ; If sign is + ve turn it - ve and vice - versa ; Check if a and b are of different signs ; Function to subtract two numbers by negating b and adding them ; Negating b ; Function to multiply a by b by adding a to itself b times ; because algo is faster if b < a ; Adding a to itself b times ; Check if final sign must be - ve or + ve ; Function to divide a by b by counting how many times ' b ' can be subtracted from ' a ' before getting 0 ; Negating b to subtract from a ; Subtracting divisor from dividend ; Check if a and b are of similar symbols or not ; Driver code","code":"< ? php function flipSign ( $ a ) { $ neg = 0 ; $ tmp = $ a < 0 ? 1 : -1 ; while ( $ a != 0 ) { $ neg += $ tmp ; $ a += $ tmp ; } return $ neg ; } function areDifferentSign ( $ a , $ b ) { return ( ( $ a < 0 && $ b > 0 ) || ( $ a > 0 && $ b < 0 ) ) ; } function sub ( $ a , $ b ) { return $ a + flipSign ( $ b ) ; } function mul ( $ a , $ b ) { if ( $ a < $ b ) return mul ( $ b , $ a ) ; $ sum = 0 ; for ( $ i = abs ( $ b ) ; $ i > 0 ; $ i -- ) $ sum += $ a ; if ( $ b < 0 ) $ sum = flipSign ( $ sum ) ; return $ sum ; } function division ( $ a , $ b ) { $ quotient = 0 ; $ divisor = flipSign ( abs ( $ b ) ) ; for ( $ dividend = abs ( $ a ) ; $ dividend >= abs ( $ divisor ) ; $ dividend += $ divisor ) $ quotient ++ ; if ( areDifferentSign ( $ a , $ b ) ) $ quotient = flipSign ( $ quotient ) ; return $ quotient ; } print ( \" Subtraction \u2581 is \u2581 \" . sub ( 4 , -2 ) . \" STRNEWLINE \" ) ; print ( \" Product \u2581 is \u2581 \" . mul ( -9 , 6 ) . \" STRNEWLINE \" ) ; list ( $ a , $ b ) = array ( 8 , 2 ) ; if ( $ b ) print ( \" Division \u2581 is \u2581 \" . division ( $ a , $ b ) ) ; else print ( \" Exception \u2581 : - \u2581 Divide \u2581 by \u2581 0\" ) ; ? >"}
{"text":"Number of Groups of Sizes Two Or Three Divisible By 3 | PHP Program to find groups of 2 or 3 whose sum is divisible by 3 ; Initialize groups to 0 ; Increment group with specified remainder ; Return groups using the formula ; Driver Code","code":"< ? php function numOfCombinations ( $ arr , $ N ) { $ C = array ( 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) ++ $ C [ $ arr [ $ i ] % 3 ] ; return $ C [ 1 ] * $ C [ 2 ] + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) \/ 2 + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) * ( $ C [ 0 ] - 2 ) \/ 6 + $ C [ 1 ] * ( $ C [ 1 ] - 1 ) * ( $ C [ 1 ] - 2 ) \/ 6 + $ C [ 2 ] * ( $ C [ 2 ] - 1 ) * ( $ C [ 2 ] - 2 ) \/ 6 + $ C [ 0 ] * $ C [ 1 ] * $ C [ 2 ] ; } $ arr1 = array ( 1 , 5 , 7 , 2 , 9 , 14 ) ; echo numOfCombinations ( $ arr1 , 6 ) , \" STRNEWLINE \" ; $ arr2 = array ( 3 , 6 , 9 , 12 ) ; echo numOfCombinations ( $ arr2 , 4 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if a number can be written as a sum of ' k ' prime numbers | Checking if a number is prime or not ; check for numbers from 2 to sqrt ( x ) if it is divisible return false ; Returns true if N can be written as sum of K primes ; N < 2 K directly return false ; If K = 1 return value depends on primality of N ; if N is even directly return true ; ; If N is odd , then one prime must be 2. All other primes are odd and cannot have a pair sum as even . ; If K >= 3 return true ; ; Driver Code","code":"< ? php function isprime ( $ x ) { for ( $ i = 2 ; $ i * $ i <= $ x ; $ i ++ ) if ( $ x % $ i == 0 ) return false ; return true ; } function isSumOfKprimes ( $ N , $ K ) { if ( $ N < 2 * $ K ) return false ; if ( $ K == 1 ) return isprime ( $ N ) ; if ( $ K == 2 ) { if ( $ N % 2 == 0 ) return true ; return isprime ( $ N - 2 ) ; } return true ; } $ n = 10 ; $ k = 2 ; if ( isSumOfKprimes ( $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Count total divisors of A or B in a given range | Utility function to find GCD of two numbers ; Utility function to find LCM of two numbers ; Function to calculate all divisors in given range ; Find LCM of a and b ; Find common divisor by using LCM ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b ) ? gcd ( $ b , $ a % $ b ) : $ b ; } function FindLCM ( $ a , $ b ) { return ( $ a * $ b ) \/ gcd ( $ a , $ b ) ; } function rangeDivisor ( $ m , $ n , $ a , $ b ) { $ lcm = FindLCM ( $ a , $ b ) ; $ a_divisor = $ n \/ $ a - ( $ m - 1 ) \/ $ a ; $ b_divisor = $ n \/ $ b - ( $ m - 1 ) \/ $ b ; $ common_divisor = $ n \/ $ lcm - ( $ m - 1 ) \/ $ lcm ; $ ans = $ a_divisor + $ b_divisor - $ common_divisor ; return $ ans ; } $ m = 3 ; $ n = 11 ; $ a = 2 ; $ b = 3 ; print ( ceil ( rangeDivisor ( $ m , $ n , $ a , $ b ) ) ) ; echo \" STRNEWLINE \" ; $ m = 11 ; $ n = 1000000 ; $ a = 6 ; $ b = 35 ; print ( ceil ( rangeDivisor ( $ m , $ n , $ a , $ b ) ) ) ; ? >"}
{"text":"Numbers having Unique ( or Distinct ) digits | Function to print unique digit numbers in range from l to r . ; Start traversing the numbers ; Find digits and maintain its hash ; if a digit occurs more than 1 time then break ; num will be 0 only when above loop doesn 't get break that  means the number is unique  so print it. ; Driver code","code":"< ? php function printUnique ( $ l , $ r ) { for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; $ visited = ( false ) ; while ( $ num ) { if ( $ visited [ $ num % 10 ] ) $ visited [ $ num % 10 ] = true ; $ num = ( int ) $ num \/ 10 ; } if ( $ num == 0 ) echo $ i , \" \u2581 \" ; } } $ l = 1 ; $ r = 20 ; printUnique ( $ l , $ r ) ; ? >"}
{"text":"Fibonacci modulo p | Returns position of first Fibonacci number whose modulo p is 0. ; add previous two remainders and then take its modulo p . ; Driver code","code":"< ? php function findMinZero ( $ p ) { $ first = 1 ; $ second = 1 ; $ number = 2 ; $ next = 1 ; while ( $ next ) { $ next = ( $ first + $ second ) % $ p ; $ first = $ second ; $ second = $ next ; $ number ++ ; } return $ number ; } $ p = 7 ; echo \" Minimal \u2581 zero \u2581 is : \u2581 \" , findMinZero ( $ p ) , \" STRNEWLINE \" ; ? >"}
{"text":"Perfect cubes in a range | A Simple Method to count cubes between a and b ; Traverse through all numbers in given range and one by one check if number is prime ; Check if current number ' i ' is perfect cube ; Driver Code","code":"< ? php function printCubes ( $ a , $ b ) { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j * $ j <= $ i ; $ j ++ ) { if ( $ j * $ j * $ j == $ i ) { echo $ j * $ j * $ j , \" \" ; break ; } } } } $ a = 1 ; $ b = 100 ; echo \" Perfect \u2581 cubes \u2581 in \u2581 given \u2581 range : STRNEWLINE \u2581 \" ; printCubes ( $ a , $ b ) ; ? >"}
{"text":"Converting a Real Number ( between 0 and 1 ) to Binary String | Function to convert Binary real number to String ; Check if the number is Between 0 to 1 or Not ; Setting a limit on length : 32 characters . ; compare the number to .5 ; Now it become 0.25 ; Input value","code":"< ? php function toBinary ( $ n ) { if ( $ n >= 1 $ n <= 0 ) return \" ERROR \" ; $ frac = 0.5 ; $ answer = \" . \" ; while ( $ n > 0 ) { if ( strlen ( $ answer ) >= 32 ) return \" ERROR \" ; if ( $ n >= $ frac ) { $ answer . = \"1\" ; $ n = $ n - $ frac ; } else { $ answer . = \"0\" ; } $ frac = ( $ frac \/ 2 ) ; } return $ answer ; } $ n = 0.625 ; $ result = toBinary ( $ n ) ; print ( \" ( 0\" . $ result . \" ) \u2581 in \u2581 base \u2581 2 STRNEWLINE \" ) ; $ m = 0.72 ; $ result = toBinary ( $ m ) ; print ( \" ( \" . $ result . \" ) \" ) ; ? >"}
{"text":"Given a number n , find the first k digits of n ^ n | function that manually calculates n ^ n and then removes digits until k digits remain ; loop will terminate when there are only k digits left ; Driver Code","code":"< ? php function firstkdigits ( $ n , $ k ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product *= $ n ; while ( ( int ) ( $ product \/ pow ( 10 , $ k ) ) != 0 ) $ product = ( int ) $ product \/ 10 ; return floor ( $ product ) ; } $ n = 15 ; $ k = 4 ; echo firstkdigits ( $ n , $ k ) ; ? >"}
{"text":"Check if a large number is divisible by 9 or not | Function to find that number divisible by 9 or not ; Compute sum of digits ; Check if sum of digits is divisible by 9. ; Driver code","code":"< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 9 == 0 ) ; } $ str = \"99333\" ; $ x = check ( $ str ) ? \" Yes \" : \" No \u2581 \" ; echo ( $ x ) ; ? >"}
{"text":"XOR of all subarray XORs | Set 1 | Returns XOR of all subarray xors ; initialize result by 0 as ( a xor 0 = a ) ; select the starting element ; select the eNding element ; Do XOR of elements in current subarray ; Driver code","code":"< ? php function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j ++ ) for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) $ res = $ res ^ $ arr [ $ k ] ; return $ res ; } $ arr = array ( 3 , 5 , 2 , 4 , 6 ) ; $ N = sizeof ( $ arr ) ; echo getTotalXorOfSubarrayXors ( $ arr , $ N ) ; ? >"}
{"text":"XOR of all subarray XORs | Set 1 | Returns XOR of all subarray xors ; initialize result by 0 as ( a XOR 0 = a ) ; loop over all elements once ; get the frequency of current element ; if frequency is odd , then include it in the result ; return the result ; Driver Code","code":"< ? php function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ freq = ( $ i + 1 ) * ( $ N - $ i ) ; if ( $ freq % 2 == 1 ) $ res = $ res ^ $ arr [ $ i ] ; } return $ res ; } $ arr = array ( 3 , 5 , 2 , 4 , 6 ) ; $ N = count ( $ arr ) ; echo getTotalXorOfSubarrayXors ( $ arr , $ N ) ; ? >"}
{"text":"GCD of more than two ( or array ) numbers | Function to return gcd of a and b ; Function to find gcd of array of numbers ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findGCD ( $ arr , $ n ) { $ result = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ result = gcd ( $ arr [ $ i ] , $ result ) ; if ( $ result == 1 ) { return 1 ; } } return $ result ; } $ arr = array ( 2 , 4 , 6 , 8 , 16 ) ; $ n = sizeof ( $ arr ) ; echo ( findGCD ( $ arr , $ n ) ) ; ? >"}
{"text":"Superperfect Number | Function to calculate sum of all divisors ; Final result of summation of divisors ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Returns true if n is Super Perfect else false . ; Find the sum of all divisors of number n ; Again find the sum of all divisors of n1 and check if sum is equal to n1 ; Driver code","code":"< ? php function divSum ( $ num ) { $ result = 0 ; for ( $ i = 1 ; $ i * $ i <= $ num ; ++ $ i ) { if ( $ num % $ i == 0 ) { if ( $ i == ( $ num \/ $ i ) ) $ result += $ i ; else $ result += ( $ i + $ num \/ $ i ) ; } } return $ result ; } function isSuperPerfect ( $ n ) { $ n1 = divSum ( $ n ) ; return ( 2 * $ n == divSum ( $ n1 ) ) ; } $ n = 16 ; $ hh = ( isSuperPerfect ( $ n ) ? \" Yes STRNEWLINE \" : \" No STRNEWLINE \" ) ; echo ( $ hh ) ; $ n = 6 ; $ hh = ( isSuperPerfect ( $ n ) ? \" Yes STRNEWLINE \" : \" No STRNEWLINE \" ) ; echo ( $ hh ) ; ? >"}
{"text":"Refactorable number | Function to count all divisors ; Initialize result ; If divisors are equal , count only one . ; Otherwise count both ; Driver Code","code":"< ? php function isRefactorableNumber ( $ n ) { $ divCount = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) ++ $ divCount ; else $ divCount += 2 ; } } return $ n % $ divCount == 0 ; } $ n = 8 ; if ( isRefactorableNumber ( $ n ) ) echo \" yes \" ; else echo \" no \" ; echo \" STRNEWLINE \" ; $ n = 14 ; if ( isRefactorableNumber ( $ n ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text":"Count all perfect divisors of a number | function to check perfect square number ; Returns count all perfect divisors of n ; Initialize result ; Consider every number that can be a divisor of n ; If i is a divisor ; Driver Code","code":"< ? php function isPerfectSquare ( $ n ) { $ sq = sqrt ( $ n ) ; return ( $ n == $ sq * $ sq ) ; } function countPerfectDivisors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( isPerfectSquare ( $ i ) ) ++ $ count ; if ( $ n \/ $ i != $ i && isPerfectSquare ( $ n \/ $ i ) ) ++ $ count ; } } return $ count ; } $ n = 16 ; echo \" Total \u2581 perfect \u2581 divisors \u2581 of \u2581 \" , $ n , \" \u2581 = \u2581 \" , countPerfectDivisors ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo \" Total \u2581 perfect \u2581 divisors \u2581 of \u2581 \" , $ n , \" \u2581 = \u2581 \" , countPerfectDivisors ( $ n ) ; ? >"}
{"text":"Nearest element with at | PHP program to print nearest element with at least one common prime factor . ; Loop covers the every element of arr [ ] ; Loop that covers from 0 to i - 1 and i + 1 to n - 1 indexes simultaneously ; print position of closest element ; Recursive function to return gcd of a and b ; Driver Code","code":"< ? php function nearestGcd ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ closest = -1 ; for ( $ j = $ i - 1 , $ k = $ i + 1 ; $ j > 0 $ k <= $ n ; -- $ j , ++ $ k ) { if ( $ j >= 0 && __gcd ( $ arr [ $ i ] , $ arr [ $ j ] ) > 1 ) { $ closest = $ j + 1 ; break ; } if ( $ k < $ n && __gcd ( $ arr [ $ i ] , $ arr [ $ k ] ) > 1 ) { $ closest = $ k + 1 ; break ; } } echo $ closest . \" \" ; } } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ arr = array ( 2 , 9 , 4 , 3 , 13 ) ; $ n = sizeof ( $ arr ) ; nearestGcd ( $ arr , $ n ) ; ? >"}
{"text":"Largest subsequence having GCD greater than 1 | Efficient PHP program to find length of the largest subsequence with GCD greater than 1. ; prime [ ] for storing smallest prime divisor of element count [ ] for storing the number of times a particular divisor occurs in a subsequence ; Simple sieve to find smallest prime factors of numbers smaller than MAX ; Prime number will have same divisor ; Returns length of the largest subsequence with GCD more than 1. ; Fetch total unique prime divisor of element ; Increment count [ ] of Every unique divisor we get till now ; Find maximum frequency of divisor ; Pre - compute smallest divisor of all numbers","code":"< ? php $ MAX = 10001 ; $ prime = array_fill ( 0 , $ MAX , 0 ) ; $ countdiv = array_fill ( 0 , $ MAX , 0 ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ prime ; for ( $ i = 2 ; $ i * $ i <= $ MAX ; ++ $ i ) { if ( $ prime [ $ i ] == 0 ) for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) $ prime [ $ j ] = $ i ; } for ( $ i = 1 ; $ i < $ MAX ; ++ $ i ) if ( $ prime [ $ i ] == 0 ) $ prime [ $ i ] = $ i ; } function largestGCDSubsequence ( $ arr , $ n ) { global $ countdiv , $ prime ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ element = $ arr [ $ i ] ; while ( $ element > 1 ) { $ div = $ prime [ $ element ] ; ++ $ countdiv [ $ div ] ; $ ans = max ( $ ans , $ countdiv [ $ div ] ) ; while ( $ element % $ div == 0 ) $ element = ( int ) ( $ element \/ $ div ) ; } } return $ ans ; } SieveOfEratosthenes ( ) ; $ arr = array ( 10 , 15 , 7 , 25 , 9 , 35 ) ; $ size = count ( $ arr ) ; echo largestGCDSubsequence ( $ arr , $ size ) ; ? >"}
{"text":"Count of Binary Digit numbers smaller than N | method returns count of binary digit numbers smaller than N ; queue to store all intermediate binary digit numbers ; binary digits start with 1 ; loop until we have element in queue ; push next binary digit numbers only if current popped element is N ; uncomment below line to print actual number in sorted order cout << t << \" \u2581 \" ; ; Driver Code","code":"< ? php function countOfBinaryNumberLessThanN ( $ N ) { $ q = array ( ) ; array_push ( $ q , 1 ) ; $ cnt = 0 ; $ t = 0 ; while ( ! empty ( $ q ) ) { $ t = array_pop ( $ q ) ; if ( $ t <= $ N ) { $ cnt ++ ; array_push ( $ q , $ t * 10 ) ; array_push ( $ q , ( $ t * 10 + 1 ) ) ; } } return $ cnt ; } $ N = 200 ; echo countOfBinaryNumberLessThanN ( $ N ) ; ? >"}
{"text":"Sum of product of x and y such that floor ( n \/ x ) = y | Return the sum of product x * y . ; Iterating x from 1 to n ; Finding y = n \/ x . ; Adding product of x and y to answer . ; Driver Code","code":"< ? php function sumofproduct ( $ n ) { $ ans = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ y = ( int ) ( $ n \/ $ x ) ; $ ans += ( $ y * $ x ) ; } return $ ans ; } $ n = 10 ; echo sumofproduct ( $ n ) ; ? >"}
{"text":"Program for Perrin numbers | Optimized PHP program for n 'th perrin number ; Driver code","code":"< ? php function per ( $ n ) { $ a = 3 ; $ b = 0 ; $ c = 2 ; $ i ; $ m ; if ( $ n == 0 ) return $ a ; if ( $ n == 1 ) return $ b ; if ( $ n == 2 ) return $ c ; while ( $ n > 2 ) { $ m = $ a + $ b ; $ a = $ b ; $ b = $ c ; $ c = $ m ; $ n -- ; } return $ m ; } $ n = 9 ; echo per ( $ n ) ; ? >"}
{"text":"Find the first natural number whose factorial is divisible by x | function for calculating factorial ; function for check Special_Factorial_Number ; call fact function and the Modulo with k and check if condition is TRUE then return i ; taking input","code":"< ? php function fact ( $ n ) { $ num = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ num = $ num * $ i ; return $ num ; } function Special_Factorial_Number ( $ k ) { for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( fact ( $ i ) % $ k ) == 0 ) { return $ i ; } } } $ k = 16 ; echo Special_Factorial_Number ( $ k ) ; ? >"}
{"text":"Program for Chocolate and Wrapper Puzzle | Returns maximum number of chocolates we can eat with given money , price of chocolate and number of wrapprices required to get a chocolate . ; Corner case ; First find number of chocolates that can be purchased with the given amount ; Now just add number of chocolates with the chocolates gained by wrapprices ; total money ; cost of each candy ; no of wrappers needs to be ; exchanged for one chocolate .","code":"< ? php function countMaxChoco ( $ money , $ price , $ wrap ) { if ( $ money < $ price ) return 0 ; $ choc = $ money \/ $ price ; $ choc = $ choc + ( $ choc - 1 ) \/ ( $ wrap - 1 ) ; return $ choc ; } $ money = 15 ; $ price = 1 ; $ wrap = 3 ; echo countMaxChoco ( $ money , $ price , $ wrap ) ; ? >"}
{"text":"Check if possible to move from given coordinate to desired coordinate | Returns GCD of i and j ; Returns true if it is possible to go to ( a , b ) from ( x , y ) ; Find absolute values of all as sign doesn 't  matter. ; If gcd is equal then it is possible to reach . Else not possible . ; Driver Code ; Converting coordinate into positive integer","code":"< ? php function gcd ( $ i , $ j ) { if ( $ i == $ j ) return $ i ; if ( $ i > $ j ) return gcd ( $ i - $ j , $ j ) ; return gcd ( $ i , $ j - $ i ) ; } function ispossible ( $ x , $ y , $ a , $ b ) { $ x = abs ( $ x ) ; $ y = abs ( $ y ) ; $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; return ( gcd ( $ x , $ y ) == gcd ( $ a , $ b ) ) ; } { $ x = 35 ; $ y = 15 ; $ a = 20 ; $ b = 25 ; if ( ispossible ( $ x , $ y , $ a , $ b ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; return 0 ; } ? >"}
{"text":"Equidigital Numbers | PHP Program to find Equidigital Numbers till n ; Array to store all prime less than and equal to MAX . ; Utility function for sieve of sundaram ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j ; Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1 ; Since 2 is a prime number ; Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; Returns true if n is a Equidigital number , else false . ; Count digits in original number ; Count all digits in prime factors of n pDigit is going to hold this value . ; Count powers of p in n ; If primes [ i ] is a prime factor , ; Count the power of prime factors ; Add its digits to pDigit . ; Add digits of power of prime factors to pDigit . ; If n != 1 then one prime factor still to be summed up ; ; If digits in prime factors and digits in original number are same , then return true . Else return false . ; Finding all prime numbers before limit . These numbers are used to find prime factors .","code":"< ? php $ MAX = 10000 ; $ primes = array ( ) ; function sieveSundaram ( ) { global $ primes , $ MAX ; $ marked = array_fill ( 0 , ( $ MAX \/ 2 + 1 ) , false ) ; for ( $ i = 1 ; $ i <= ( ( int ) sqrt ( $ MAX ) - 1 ) \/ 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= ( int ) ( $ MAX \/ 2 ) ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = true ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= ( int ) ( $ MAX \/ 2 ) ; $ i ++ ) if ( $ marked [ $ i ] == false ) array_push ( $ primes , 2 * $ i + 1 ) ; } function isEquidigital ( $ n ) { global $ primes , $ MAX ; if ( $ n == 1 ) return true ; $ original_no = $ n ; $ sumDigits = 0 ; while ( $ original_no > 0 ) { $ sumDigits ++ ; $ original_no = ( int ) ( $ original_no \/ 10 ) ; } $ pDigit = 0 ; $ count_exp = 0 ; $ p = 0 ; for ( $ i = 0 ; $ primes [ $ i ] <= ( int ) ( $ n \/ 2 ) ; $ i ++ ) { while ( $ n % $ primes [ $ i ] == 0 ) { $ p = $ primes [ $ i ] ; $ n = ( int ) ( $ n \/ $ p ) ; $ count_exp ++ ; } while ( $ p > 0 ) { $ pDigit ++ ; $ p = ( int ) ( $ p \/ 10 ) ; } while ( $ count_exp > 1 ) { $ pDigit ++ ; $ count_exp = ( int ) ( $ count_exp \/ 10 ) ; } } if ( $ n != 1 ) { while ( $ n > 0 ) { $ pDigit ++ ; $ n = ( int ) ( $ n \/ 10 ) ; } } return ( $ pDigit == $ sumDigits ) ; } sieveSundaram ( ) ; echo \" Printing \u2581 first \u2581 few \u2581 Equidigital \u2581 Numbers \u2581 using \u2581 isEquidigital ( ) STRNEWLINE \" ; for ( $ i = 1 ; $ i < 20 ; $ i ++ ) if ( isEquidigital ( $ i ) ) echo $ i . \" \" ; ? >"}
{"text":"Maximum sum of distinct numbers with LCM as N | Returns maximum sum of numbers with LCM as N ; Finding a divisor of n and adding it to max_sum ; if ' i ' is divisor of ' N ' ; if both divisors are same then add it only once else add both ; Driver code","code":"< ? php function maxSumLCM ( $ n ) { $ max_sum = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ max_sum += $ i ; if ( $ n \/ $ i != $ i ) $ max_sum += ( $ n \/ $ i ) ; } } return $ max_sum ; } $ n = 2 ; echo MaxSumLCM ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Smallest number divisible by first n numbers | Function returns the lcm of first n numbers ; Driver Code","code":"< ? php function lcm ( $ n ) { $ ans = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans = ( $ ans * $ i ) \/ ( gmp_gcd ( strval ( ans ) , strval ( i ) ) ) ; return $ ans ; } $ n = 20 ; echo lcm ( $ n ) ; ? >"}
{"text":"Trapezoidal Rule for Approximate Value of Definite Integral | A sample function whose definite integral 's approximate value is computed using Trapezoidal rule ; Declaring the function f ( x ) = 1 \/ ( 1 + x * x ) ; Function to evaluate the value of integral ; Grid spacing ; Computing sum of first and last terms in above formula ; Adding middle terms in above formula ; h \/ 2 indicates ( b - a ) \/ 2 n . Multiplying h \/ 2 with s . ; Range of definite integral ; Number of grids . Higher value means more accuracy","code":"< ? php function y ( $ x ) { return 1 \/ ( 1 + $ x * $ x ) ; } function trapezoidal ( $ a , $ b , $ n ) { $ h = ( $ b - $ a ) \/ $ n ; $ s = y ( $ a ) + y ( $ b ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ s += 2 * Y ( $ a + $ i * $ h ) ; return ( $ h \/ 2 ) * $ s ; } $ x0 = 0 ; $ xn = 1 ; $ n = 6 ; echo ( \" Value \u2581 of \u2581 integral \u2581 is \u2581 \" ) ; echo ( trapezoidal ( $ x0 , $ xn , $ n ) ) ; ? >"}
{"text":"Finding number of digits in n 'th Fibonacci number | This function returns the number of digits in nth Fibonacci number after ceiling it Formula used ( n * log ( phi ) - ( log 5 ) \/ 2 ) ; using phi = 1.6180339887498948 ; Driver Code","code":"< ? php function numberOfDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ d = ( $ n * log10 ( 1.6180339887498948 ) ) - ( ( log10 ( 5 ) ) \/ 2 ) ; return ceil ( $ d ) ; } $ i ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) echo \" Number \u2581 of \u2581 Digits \u2581 in \u2581 F ( $ i ) \u2581 - \u2581 \" , numberOfDigits ( $ i ) , \" STRNEWLINE \" ; ? >"}
{"text":"Number of elements with odd factors in given range | Function to count odd squares ; Driver code","code":"< ? php function countOddSquares ( $ n , $ m ) { return pow ( $ m , 0.5 ) - pow ( $ n - 1 , 0.5 ) ; } $ n = 5 ; $ m = 100 ; echo \" Count \u2581 is \u2581 \" , countOddSquares ( $ n , $ m ) ; ? >"}
{"text":"Check if a number is a power of another number | Returns 1 if y is a power of x ; The only power of 1 is 1 itself ; Repeatedly comput power of x ; Check if power of x becomes y ; check the result for true \/ false and print .","code":"< ? php function isPower ( $ x , $ y ) { if ( $ x == 1 ) return ( $ y == 1 ? 1 : 0 ) ; $ pow = 1 ; while ( $ pow < $ y ) $ pow *= $ x ; return ( $ pow == $ y ? 1 : 0 ) ; } echo isPower ( 10 , 1 ) . \" STRNEWLINE \" ; echo isPower ( 1 , 20 ) . \" STRNEWLINE \" ; echo isPower ( 2 , 128 ) . \" STRNEWLINE \" ; echo isPower ( 2 , 30 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Number of perfect squares between two given numbers | Method to count square between a and b ; Driver code","code":"< ? php function countSquares ( $ a , $ b ) { return ( floor ( sqrt ( $ b ) ) - ceil ( sqrt ( $ a ) ) + 1 ) ; } { $ a = 9 ; $ b = 25 ; echo \" Count \u2581 of \u2581 squares \u2581 is \u2581 \" , countSquares ( $ a , $ b ) ; return 0 ; } ? >"}
{"text":"Count positive integers with 0 as a digit and maximum ' d ' digits | function to calculate the count of natural numbers upto a given number of digits that contain atleast one zero ; Sum of two GP series ; Driver Code","code":"< ? php function findCountUpto ( $ d ) { $ GP1_Sum = 9 * ( ( pow ( 10 , $ d ) - 1 ) \/ 9 ) ; $ GP2_Sum = 9 * ( ( pow ( 9 , $ d ) - 1 ) \/ 8 ) ; return $ GP1_Sum - $ GP2_Sum ; } $ d = 1 ; echo findCountUpto ( $ d ) , \" STRNEWLINE \" ; $ d = 2 ; echo findCountUpto ( $ d ) , \" STRNEWLINE \" ; $ d = 4 ; echo findCountUpto ( $ d ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if count of divisors is even or odd | Function to count the divisors ; Initialize count of divisors ; Note that this loop runs till square root ; If divisors are equal increment count by one Otherwise increment count by 2 ; Driver Code","code":"< ? php function countDivisors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) + 1 ; $ i ++ ) { if ( $ n % $ i == 0 ) $ count += ( $ n \/ $ i == $ i ) ? 1 : 2 ; } if ( $ count % 2 == 0 ) echo \" Even STRNEWLINE \" ; else echo \" Odd STRNEWLINE \" ; } echo \" The \u2581 count \u2581 of \u2581 divisor : \u2581 \" ; countDivisors ( 10 ) ; ? >"}
{"text":"Compute n ! under modulo p | Returns largest power of p that divides n ! ; Initialize result ; Calculate x = n \/ p + n \/ ( p ^ 2 ) + n \/ ( p ^ 3 ) + ... . ; Utility function to do modular exponentiation . It returns ( x ^ y ) % p ; $res = 1 ; Initialize result $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Returns n ! % p ; Use Sieve of Eratosthenes to find all primes smaller than n ; Consider all primes found by Sieve ; Find the largest power of prime ' i ' that divides n ; Multiply result with ( i ^ k ) % p ; Driver Code","code":"< ? php function largestPower ( $ n , $ p ) { $ x = 0 ; while ( $ n ) { $ n = ( int ) ( $ n \/ $ p ) ; $ x += $ n ; } return $ x ; } function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modFact ( $ n , $ p ) { if ( $ n >= $ p ) return 0 ; $ res = 1 ; $ isPrime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { for ( $ j = 2 * $ i ; $ j <= $ n ; $ j += $ i ) $ isPrime [ $ j ] = 0 ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { $ k = largestPower ( $ n , $ i ) ; $ res = ( $ res * power ( $ i , $ k , $ p ) ) % $ p ; } } return $ res ; } $ n = 25 ; $ p = 29 ; echo modFact ( $ n , $ p ) ; ? >"}
{"text":"Count number of squares in a rectangle | Returns count of all squares in a rectangle of size m x n ; If n is smaller , swap m and n ; Now n is greater dimension , apply formula ; Driver Code","code":"< ? php function countSquares ( $ m , $ n ) { if ( $ n < $ m ) list ( $ m , $ n ) = array ( $ n , $ m ) ; return $ m * ( $ m + 1 ) * ( 2 * $ m + 1 ) \/ 6 + ( $ n - $ m ) * $ m * ( $ m + 1 ) \/ 2 ; } $ m = 4 ; $ n = 3 ; echo ( \" Count \u2581 of \u2581 squares \u2581 is \u2581 \" . countSquares ( $ m , $ n ) ) ; ? >"}
{"text":"Add two numbers using ++ and \/ or | Returns value of x + y without using + ; If y is positive , y times add 1 to x ; If y is negative , y times subtract 1 from x ; Driver Code","code":"< ? php function add ( $ x , $ y ) { while ( $ y > 0 && $ y -- ) $ x ++ ; while ( $ y < 0 && $ y ++ ) $ x -- ; return $ x ; } echo add ( 43 , 23 ) , \" STRNEWLINE \" ; echo add ( 43 , -23 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count factorial numbers in a given range | Function to count factorial ; Find the first factorial number ' fact ' greater than or equal to ' low ' ; Count factorial numbers in range [ low , high ] ; Return the count ; Driver Code","code":"< ? php function countFact ( $ low , $ high ) { $ fact = 1 ; $ x = 1 ; while ( $ fact < $ low ) { $ fact = $ fact * $ x ; $ x ++ ; } $ res = 0 ; while ( $ fact <= $ high ) { $ res ++ ; $ fact = $ fact * $ x ; $ x ++ ; } return $ res ; } echo \" Count \u2581 is \u2581 \" , countFact ( 2 , 720 ) ; ? >"}
{"text":"Find length of period in decimal value of 1 \/ n | Function to find length of period in 1 \/ n ; Find the ( n + 1 ) th remainder after decimal point in value of 1 \/ n ; Store ( n + 1 ) th remainder ; Count the number of remainders before next occurrence of ( n + 1 ) ' th \u2581 \u2581 remainder \u2581 ' d ' ; Driver Code","code":"< ? php function getPeriod ( $ n ) { $ rem = 1 ; for ( $ i = 1 ; $ i <= $ n + 1 ; $ i ++ ) $ rem = ( 10 * $ rem ) % $ n ; $ d = $ rem ; $ count = 0 ; do { $ rem = ( 10 * $ rem ) % $ n ; $ count ++ ; } while ( $ rem != $ d ) ; return $ count ; } echo getPeriod ( 3 ) , \" STRNEWLINE \" ; echo getPeriod ( 7 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program to find remainder without using modulo or % operator | This function returns remainder of num \/ divisor without using % ( modulo ) operator ; Driver Code","code":"< ? php function getRemainder ( $ num , $ divisor ) { $ t = ( $ num - $ divisor * ( int ) ( $ num \/ $ divisor ) ) ; return $ t ; } echo getRemainder ( 100 , 7 ) ; ? >"}
{"text":"Efficient Program to Compute Sum of Series 1 \/ 1 ! + 1 \/ 2 ! + 1 \/ 3 ! + 1 \/ 4 ! + . . + 1 \/ n ! | An Efficient Function to return value of 1 \/ 1 ! + 1 \/ 2 ! + . . + 1 \/ n ! ; Update factorial ; Update series sum ; Driver Code","code":"< ? php function sum ( $ n ) { $ sum = 0 ; $ fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ fact *= $ i ; $ sum += 1.0 \/ $ fact ; } return $ sum ; } $ n = 5 ; echo sum ( $ n ) ; ? >"}
{"text":"Print first k digits of 1 \/ n where n is a positive integer | Function to print first k digits after dot in value of 1 \/ n . n is assumed to be a positive integer . ; Initialize remainder ; Run a loop k times to print k digits ; The next digit can always be obtained as doing ( 10 * rem ) \/ 10 ; Update remainder ; Driver Code","code":"< ? php function println ( $ n , $ k ) { $ rem = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { echo floor ( ( 10 * $ rem ) \/ $ n ) ; $ rem = ( 10 * $ rem ) % $ n ; } } $ n = 7 ; $ k = 3 ; println ( $ n , $ k ) ; echo \" STRNEWLINE \" ; $ n = 21 ; $ k = 4 ; println ( $ n , $ k ) ; ? >"}
{"text":"Program to find sum of series 1 + 1 \/ 2 + 1 \/ 3 + 1 \/ 4 + . . + 1 \/ n | Function to return sum of 1 \/ 1 + 1 \/ 2 + 1 \/ 3 + . . + 1 \/ n ; Driver Code","code":"< ? php function sum ( $ n ) { $ i ; $ s = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s = $ s + 1 \/ $ i ; return $ s ; } $ n = 5 ; echo ( \" Sum \u2581 is \u2581 \" ) ; echo ( sum ( $ n ) ) ; ? >"}
{"text":"Program to find GCD or HCF of two numbers | Recursive function to return gcd of a and b ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD \u2581 of \u2581 $ a \u2581 and \u2581 $ b \u2581 is \u2581 \" , gcd ( $ a , $ b ) ; ? >"}
{"text":"Rearrange an array so that arr [ i ] becomes arr [ arr [ i ] ] with O ( 1 ) extra space | The function to rearrange an array in - place so that arr [ i ] becomes arr [ arr [ i ] ] . ; First step : Increase all values by ( arr [ arr [ i ] ] % n ) * n ; Second Step : Divide all values by n ; A utility function to print an array of size n ; Driver Code","code":"< ? php function rearrange ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] += ( $ arr [ $ arr [ $ i ] ] % $ n ) * $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = intval ( $ arr [ $ i ] \/ $ n ) ; } function printArr ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 3 , 2 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Given \u2581 array \u2581 is \u2581 STRNEWLINE \" ; printArr ( $ arr , $ n ) ; rearrange ( $ arr , $ n ) ; echo \" Modified \u2581 array \u2581 is \u2581 STRNEWLINE \" ; printArr ( $ arr , $ n ) ; ? >"}
{"text":"Print all sequences of given length | A utility function that prints a given arr [ ] of length size ; The core function that recursively generates and prints all sequences of length k ; A function that uses printSequencesRecur ( ) to prints all sequences from 1 , 1 , . .1 to n , n , . . n ; Driver Code","code":"< ? php function printArray ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; return ; } function printSequencesRecur ( $ arr , $ n , $ k , $ index ) { if ( $ k == 0 ) { printArray ( $ arr , $ index ) ; } if ( $ k > 0 ) { for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ arr [ $ index ] = $ i ; printSequencesRecur ( $ arr , $ n , $ k - 1 , $ index + 1 ) ; } } } function printSequences ( $ n , $ k ) { $ arr = array ( ) ; printSequencesRecur ( $ arr , $ n , $ k , 0 ) ; return ; } $ n = 3 ; $ k = 2 ; printSequences ( $ n , $ k ) ; ? >"}
{"text":"Check if a number is multiple of 5 without using \/ and % operators | assumes that n is a positive integer ; Driver Code","code":"< ? php function isMultipleof5 ( $ n ) { while ( $ n > 0 ) $ n = $ n - 5 ; if ( $ n == 0 ) return true ; return false ; } $ n = 19 ; if ( isMultipleof5 ( $ n ) == true ) echo ( \" $ n \u2581 is \u2581 multiple \u2581 of \u2581 5\" ) ; else echo ( \" $ n \u2581 is \u2581 not \u2581 a \u2581 multiple \u2581 of \u2581 5\" ) ; ? >"}
{"text":"Total pairs in an array such that the bitwise AND , bitwise OR and bitwise XOR of LSB is 1 | Function to find the count of required pairs ; To store the count of elements which give remainder 0 i . e . even values ; To store the count of elements which give remainder 1 i . e . odd values ; Driver code","code":"< ? php function CalculatePairs ( $ a , $ n ) { $ cnt_zero = 0 ; $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ cnt_zero += 1 ; else $ cnt_one += 1 ; } $ total_XOR_pairs = $ cnt_zero * $ cnt_one ; $ total_AND_pairs = ( $ cnt_one ) * ( $ cnt_one - 1 ) \/ 2 ; $ total_OR_pairs = $ cnt_zero * $ cnt_one + ( $ cnt_one ) * ( $ cnt_one - 1 ) \/ 2 ; echo ( \" cntXOR \u2581 = \u2581 $ total _ XOR _ pairs STRNEWLINE \" ) ; echo ( \" cntAND \u2581 = \u2581 $ total _ AND _ pairs STRNEWLINE \" ) ; echo ( \" cntOR \u2581 = \u2581 $ total _ OR _ pairs STRNEWLINE \" ) ; } $ a = array ( 1 , 3 , 4 , 2 ) ; $ n = count ( $ a ) ; CalculatePairs ( $ a , $ n ) ; ? >"}
{"text":"Assign other value to a variable from two possible values | Function to alternate the values ; Driver Code","code":"< ? php function alternate ( & $ a , & $ b , & $ x ) { $ x = $ a + $ b - $ x ; } $ a = -10 ; $ b = 15 ; $ x = $ a ; echo \" x \u2581 is \u2581 : \u2581 \" , $ x ; alternate ( $ a , $ b , $ x ) ; echo \" After change \" ; echo \" x is : \" ? >"}
{"text":"Highest power of two that divides a given number | PHP program to find highest power of 2 that divides n . ; Driver Code","code":"< ? php function highestPowerOf2 ( $ n ) { return ( $ n & ( ~ ( $ n - 1 ) ) ) ; } $ n = 48 ; echo highestPowerOf2 ( $ n ) ; ? >"}
{"text":"Check whether bitwise AND of a number with any subset of an array is zero or not | Function to check whether bitwise AND of a number with any subset of an array is zero or not ; variable to store the AND of all the elements ; find the AND of all the elements of the array ; if the AND of all the array elements and N is equal to zero ; Driver Code","code":"< ? php function isSubsetAndZero ( $ array , $ length , $ N ) { $ arrAnd = $ array [ 0 ] ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ arrAnd = $ arrAnd & $ array [ $ i ] ; } if ( ( $ arrAnd & $ N ) == 0 ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; } $ array = array ( 1 , 2 , 4 ) ; $ length = count ( $ array ) ; $ N = 3 ; isSubsetAndZero ( $ array , $ length , $ N ) ; ? >"}
{"text":"Finding the Parity of a number Efficiently | Function to find the parity ; Rightmost bit of y holds the parity value if ( y & 1 ) is 1 then parity is odd else even ; Driver code","code":"< ? php function findParity ( $ x ) { $ y = $ x ^ ( $ x >> 1 ) ; $ y = $ y ^ ( $ y >> 2 ) ; $ y = $ y ^ ( $ y >> 4 ) ; $ y = $ y ^ ( $ y >> 8 ) ; $ y = $ y ^ ( $ y >> 16 ) ; if ( $ y & 1 ) return 1 ; return 0 ; } ( findParity ( 9 ) == 0 ) ? print ( \" Even \u2581 Parity STRNEWLINE \" ) : print ( \" Odd \u2581 Parity STRNEWLINE \" ) ; ( findParity ( 13 ) == 0 ) ? print ( \" Even \u2581 Parity STRNEWLINE \" ) : print ( \" Odd \u2581 Parity STRNEWLINE \" ) ; ? >"}
{"text":"Check if bits in range L to R of two numbers are complement of each other or not | function to check whether all the bits are set in the given range or not ; calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; new number which will only have one or more set bits in the range l to r and nowhere else ; if both are equal , then all bits are set in the given range ; else all bits are not set ; function to check whether all the bits in the given range of two numbers are complement of each other ; Driver Code","code":"< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = ( $ n & $ num ) ; if ( $ num == $ new_num ) return true ; return false ; } function bitsAreComplement ( $ a , $ b , $ l , $ r ) { $ xor_value = $ a ^ $ b ; return allBitsSetInTheGivenRange ( $ xor_value , $ l , $ r ) ; } $ a = 10 ; $ b = 5 ; $ l = 1 ; $ r = 3 ; if ( bitsAreComplement ( $ a , $ b , $ l , $ r ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sum of the series 2 ^ 0 + 2 ^ 1 + 2 ^ 2 + ... . . + 2 ^ n | function to calculate sum of series ; initialize sum as 0 ; loop to calculate sum of series ; calculate 2 ^ i and add it to sum ; Driver code","code":"< ? php function calculateSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( 1 << $ i ) ; } return $ sum ; } $ n = 10 ; echo \" Sum \u2581 of \u2581 the \u2581 series \u2581 of \u2581 \" . \" power \u2581 2 \u2581 is \u2581 : \u2581 \" , calculateSum ( $ n ) ; ? >"}
{"text":"Print all the combinations of N elements by changing sign such that their sum is divisible by M | Function to print all the combinations ; Iterate for all combinations ; Initially 100 in binary if n is 3 as 1 << ( 3 - 1 ) = 100 in binary ; Iterate in the array and assign signs to the array elements ; If the j - th bit from left is set take ' + ' sign ; Right shift to check if jth bit is set or not ; re - initialize ; Iterate in the array elements ; If the jth from left is set ; right shift ; Driver Code","code":"< ? php function printCombinations ( $ a , $ n , $ m ) { for ( $ i = 0 ; $ i < ( 1 << $ n ) ; $ i ++ ) { $ sum = 0 ; $ num = 1 << ( $ n - 1 ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i & $ num ) $ sum += $ a [ $ j ] ; else $ sum += ( -1 * $ a [ $ j ] ) ; $ num = $ num >> 1 ; } if ( $ sum % $ m == 0 ) { $ num = 1 << ( $ n - 1 ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ i & $ num ) ) echo \" + \" \u2581 , \u2581 $ a [ $ j ] \u2581 , \u2581 \" \" ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL else STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL echo \u2581 \" - \" \u2581 , \u2581 $ a [ $ j ] \u2581 , \u2581 \" \" $ num = $ num >> 1 ; } echo \" STRNEWLINE \" ; } } } $ a = array ( 3 , 5 , 6 , 8 ) ; $ n = sizeof ( $ a ) ; $ m = 5 ; printCombinations ( $ a , $ n , $ m ) ; ? >"}
{"text":"Same Number Of Set Bits As N | returns number of set bits in a number ; function ; __builtin_popcount function that count set bits in n ; Iterate from n - 1 to 1 ; check if the number of set bits equals to temp increment count ; Driver Code","code":"< ? php function __builtin_popcount ( $ n ) { $ t = 0 ; while ( $ n > 0 ) { $ d = $ n % 2 ; $ n = intval ( $ n \/ 2 ) ; if ( $ d == 1 ) $ t ++ ; } return $ t ; } function smallerNumsWithSameSetBits ( $ n ) { $ temp = __builtin_popcount ( $ n ) ; $ count = 0 ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ temp == __builtin_popcount ( $ i ) ) $ count ++ ; } return $ count ; } $ n = 4 ; echo ( smallerNumsWithSameSetBits ( $ n ) ) ; ? >"}
{"text":"Multiply any Number with 4 using Bitwise Operator | function the return multiply a number with 4 using bitwise operator ; returning a number with multiply with 4 using2 bit shifting right ; Driver Code","code":"< ? php function multiplyWith4 ( $ n ) { return ( $ n << 2 ) ; } $ n = 4 ; echo multiplyWith4 ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Set all even bits of a number | Sets even bits of n and returns modified number . ; Generate 101010. . .10 number and store in res . ; if bit is even then generate number and or with res ; return OR number ; Driver Code","code":"< ? php function evenbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; } $ n = 10 ; echo evenbitsetnumber ( $ n ) ; ? >"}
{"text":"Set all even bits of a number | return msb set number ; set all bits ; return msb increment n by 1 and shift by 1 ; return even seted number ; get msb here ; generate even bits like 101010. . ; if bits is odd then shift by 1 ; return even set bits number ; set all even bits here ; take or with even set bits number ; Driver code","code":"< ? php function getmsb ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( $ n + 1 ) >> 1 ; } function getevenbits ( $ n ) { $ n = getmsb ( $ n ) ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; if ( $ n & 1 ) $ n = $ n >> 1 ; return $ n ; } function setallevenbits ( $ n ) { return $ n | getevenbits ( $ n ) ; } $ n = 10 ; echo setallevenbits ( $ n ) ; ? >"}
{"text":"Set all odd bits of a number | set all odd bit ; res for store 010101. . number ; generate number form of 010101. . . till temp size ; if bit is odd , then generate number and or with res ; Driver code","code":"< ? php function oddbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; } $ n = 10 ; echo oddbitsetnumber ( $ n ) ; ? >"}
{"text":"Set all odd bits of a number | return MSB set number ; set all bits including MSB . ; return MSB ; Returns a number of same size ( MSB atsame position ) as n and all odd bits set ; generate odd bits like 010101. . ; if bits is even then shift by 1 ; return odd set bits number ; set all odd bits here ; take OR with odd set bits number ; Driver code","code":"< ? php function getmsb ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( $ n + 1 ) >> 1 ; } function getevenbits ( $ n ) { $ n = getmsb ( $ n ) ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; if ( ( $ n & 1 ) == 0 ) $ n = $ n >> 1 ; return $ n ; } function setalloddbits ( $ n ) { return $ n | getevenbits ( $ n ) ; } $ n = 10 ; echo setalloddbits ( $ n ) ; ? >"}
{"text":"Print numbers in the range 1 to n having bits in alternate pattern | function to print numbers in the range 1 to n having bits in alternate pattern ; first number having bits in alternate pattern ; display ; loop until n < curr_num ; generate next number having alternate bit pattern ; if true then break ; display ; generate next number having alternate bit pattern ; if true then break ; display ; Driver code","code":"< ? php function printNumHavingAltBitPatrn ( $ n ) { $ curr_num = 1 ; echo $ curr_num . \" \" ; while ( 1 ) { $ curr_num <<= 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . \" \" ; $ curr_num = ( ( $ curr_num ) << 1 ) ^ 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . \" \" ; } } $ n = 50 ; printNumHavingAltBitPatrn ( $ n ) ; ? >"}
{"text":"Smallest perfect power of 2 greater than n ( without using arithmetic operators ) | Function to find smallest perfect power of 2 greater than n ; To store perfect power of 2 ; bitwise left shift by 1 ; bitwise right shift by 1 ; Required perfect power of 2 ; Driver code","code":"< ? php function perfectPowerOf2 ( $ n ) { $ per_pow = 1 ; while ( $ n > 0 ) { $ per_pow = $ per_pow << 1 ; $ n = $ n >> 1 ; } return $ per_pow ; } $ n = 128 ; echo \" Perfect \u2581 power \u2581 of \u2581 2 \u2581 greater \u2581 than \u2581 \" . $ n . \" : \u2581 \" . perfectPowerOf2 ( $ n ) ; ? >"}
{"text":"Find Unique pair in an array with pairs of numbers | PHP program to find a unique pair in an array of pairs . ; XOR each element and get XOR of two unique elements ( ans ) ; Get a set bit of XOR ( We get the rightmost set bit ) ; Now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element . Initialize missing numbers ; XOR of first set in arr [ ] ; XOR of second set in arr [ ] ; Driver code","code":"< ? php function findUniquePair ( $ arr , $ n ) { $ XOR = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ XOR = $ XOR ^ $ arr [ $ i ] ; $ set_bit_no = $ XOR & ~ ( $ XOR - 1 ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo \" The \u2581 unique \u2581 pair \u2581 is \u2581 \" , \" ( \" , $ x , \" \u2581 \" , $ y , \" ) \" ; } $ a = array ( 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ) ; $ n = count ( $ a ) ; findUniquePair ( $ a , $ n ) ; ? >"}
{"text":"Count unset bits of a number | An optimized PHP program to count unset bits in an integer . ; This makes sure two bits ( From MSB and including MSB ) are set ; This makes sure 4 bits ( From MSB and including MSB ) are set ; Count set bits in toggled number ; Driver code","code":"< ? php function countUnsetBits ( $ n ) { $ x = $ n ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ t = log ( $ x ^ $ n , 2 ) ; return floor ( $ t ) ; } $ n = 17 ; echo countUnsetBits ( $ n ) ; ? >"}
{"text":"Count total bits in a number | Function to get no of bits in binary representation of positive integer ; Driver Code","code":"< ? php function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; } $ i = 65 ; echo ( countBits ( $ i ) ) ; ? >"}
{"text":"Toggle all bits after most significant bit | Function to toggle bits starting from MSB ; temporary variable to use XOR with one of a n ; Run loop until the only set bit in temp crosses MST of n . ; Toggle bit of n corresponding to current set bit in temp . ; Move set bit to next higher position . ; Driver code","code":"< ? php function toggle ( & $ n ) { $ temp = 1 ; while ( $ temp <= $ n ) { $ n = $ n ^ $ temp ; $ temp = $ temp << 1 ; } } $ n = 10 ; toggle ( $ n ) ; echo $ n ; ? >"}
{"text":"Find the n | Finds if the kth bit is set in the binary representation ; Returns the position of leftmost set bit in the binary representation ; Finds whether the integer in binary representation is palindrome or not ; One by one compare bits ; Compare left and right bits and converge ; Start from 1 , traverse through all the integers ; If we reach n , break the loop ; Driver code ; Function Call","code":"< ? php function isKthBitSet ( $ x , $ k ) { return ( $ x & ( 1 << ( $ k - 1 ) ) ) ? 1 : 0 ; } function leftmostSetBit ( $ x ) { $ count = 0 ; while ( $ x ) { $ count ++ ; $ x = $ x >> 1 ; } return $ count ; } function isBinPalindrome ( $ x ) { $ l = leftmostSetBit ( $ x ) ; $ r = 1 ; while ( $ l > $ r ) { if ( isKthBitSet ( $ x , $ l ) != isKthBitSet ( $ x , $ r ) ) return 0 ; $ l -- ; $ r ++ ; } return 1 ; } function findNthPalindrome ( $ n ) { $ pal_count = 0 ; $ i = 0 ; for ( $ i = 1 ; $ i <= PHP_INT_MAX ; $ i ++ ) { if ( isBinPalindrome ( $ i ) ) { $ pal_count ++ ; } if ( $ pal_count == $ n ) break ; } return $ i ; } $ n = 9 ; echo ( findNthPalindrome ( $ n ) ) ; ? >"}
{"text":"Print ' K ' th least significant bit of a number | Function returns 1 if set , 0 if not ; Driver code ; Function call","code":"< ? php function LSB ( $ num , $ K ) { return ( $ num & ( 1 << ( $ K - 1 ) ) ) ; } $ num = 10 ; $ K = 4 ; $ r = LSB ( $ num , $ K ) ; if ( $ r ) echo '1' ; else echo '0' ; ? >"}
{"text":"Check if two numbers are equal without using comparison operators | Finds if a and b are same ; Driver code","code":"< ? php function areSame ( $ a , $ b ) { if ( ! ( $ a - $ b ) ) echo \" Same \" ; else echo \" Not \u2581 Same \" ; } areSame ( 10 , 20 ) ; ? >"}
{"text":"Toggle bits in the given range | function to toggle bits in the given range ; calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; toggle bits in the range l to r in ' n ' Besides this , we can calculate num as : $num = ( 1 << $r ) - $l . and return the number ; Driver Code","code":"< ? php function toggleBitsFromLToR ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; return ( $ n ^ $ num ) ; } $ n = 50 ; $ l = 2 ; $ r = 5 ; echo toggleBitsFromLToR ( $ n , $ l , $ r ) ; ? >"}
{"text":"Position of rightmost different bit | Function to find the position of rightmost set bit in ' n ' ; to handle edge case when n = 0. ; Function to find the position of rightmost different bit in the binary representations of ' m ' and ' n ' ; position of rightmost different bit ; Driver Code","code":"< ? php function getRightMostSetBit ( $ n ) { if ( $ n == 0 ) return 0 ; return log ( $ n & - $ n , ( 2 ) ) + 1 ; } function posOfRightMostDiffBit ( $ m , $ n ) { return getRightMostSetBit ( $ m ^ $ n ) ; } $ m = 52 ; $ n = 4 ; echo posOfRightMostDiffBit ( $ m , $ n ) ; ? >"}
{"text":"Closest ( or Next ) smaller and greater numbers with same number of set bits | Main Function to find next smallest number bigger than n ; Compute c0 and c1 ; If there is no bigger number with the same no . of 1 's ; input 1 ; input 2","code":"< ? php function getNext ( $ n ) { $ c = $ n ; $ c0 = 0 ; $ c1 = 0 ; while ( ( ( $ c & 1 ) == 0 ) && ( $ c != 0 ) ) { $ c0 ++ ; $ c >>= 1 ; } while ( ( $ c & 1 ) == 1 ) { $ c1 ++ ; $ c >>= 1 ; } if ( $ c0 + $ c1 == 31 $ c0 + $ c1 == 0 ) return -1 ; return $ n + ( 1 << $ c0 ) + ( 1 << ( $ c1 - 1 ) ) - 1 ; } $ n = 5 ; echo getNext ( $ n ) ; $ n = 8 ; echo \" STRNEWLINE \" ; echo getNext ( $ n ) ; ? >"}
{"text":"Count minimum bits to flip such that XOR of A and B equal to C | PHP code to count the Minimum bits in A and B ; If both A [ i ] and B [ i ] are equal ; If Both A and B are unequal ; N represent total count of Bits","code":"< ? php function totalFlips ( $ A , $ B , $ C , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ A [ $ i ] == $ B [ $ i ] && $ C [ $ i ] == '1' ) ++ $ count ; else if ( $ A [ $ i ] != $ B [ $ i ] && $ C [ $ i ] == '0' ) ++ $ count ; } return $ count ; } $ N = 5 ; $ a = \"10100\" ; $ b = \"00010\" ; $ c = \"10011\" ; echo totalFlips ( $ a , $ b , $ c , $ N ) ; ? >"}
{"text":"Swap three variables without using temporary variable | Assign c ' s \u2581 value \u2581 to \u2581 a , \u2581 a ' s value to b and b 's value to c. ; Store XOR of all in a ; After this , b has value of a ; After this , c has value of b ; After this , a has value of c ; Driver code ; Calling Function","code":"< ? php function swapThree ( & $ a , & $ b , & $ c ) { $ a = $ a ^ $ b ^ $ c ; $ b = $ a ^ $ b ^ $ c ; $ c = $ a ^ $ b ^ $ c ; $ a = $ a ^ $ b ^ $ c ; } $ a = 10 ; $ b = 20 ; $ c = 30 ; echo \" Before \u2581 swapping \u2581 a \u2581 = \u2581 \" , $ a , \" , \u2581 b \u2581 = \u2581 \" , $ b , \" , \u2581 c \u2581 = \u2581 \" , $ c , \" STRNEWLINE \" ; swapThree ( $ a , $ b , $ c ) ; echo \" After \u2581 swapping \u2581 a \u2581 = \u2581 \" , $ a , \" , \u2581 b \u2581 = \u2581 \" , $ b , \" , \u2581 c \u2581 = \u2581 \" , $ c , \" STRNEWLINE \" ; ? >"}
{"text":"Find Two Missing Numbers | Set 2 ( XOR based solution ) | Function to find two missing numbers in range [ 1 , n ] . This function assumes that size of array is n - 2 and all array elements are distinct ; Get the XOR of all elements in arr [ ] and { 1 , 2 . . n } ; Get a set bit of XOR ( We get the rightmost set bit ) ; Now divide elements in two sets by comparing rightmost set bit of XOR with bit at same position in each element . ; XOR of first set in arr [ ] ; XOR of second set in arr [ ] ; XOR of first set in arr [ ] and { 1 , 2 , ... n } ; XOR of second set in arr [ ] and { 1 , 2 , ... n } ; Driver Code ; Range of numbers is 2 plus size of array","code":"< ? php function findTwoMissingNumbers ( $ arr , $ n ) { $ XOR = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n - 2 ; $ i ++ ) $ XOR ^= $ arr [ $ i ] ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ XOR ^= $ i ; $ set_bit_no = $ XOR & ~ ( $ XOR - 1 ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i & $ set_bit_no ) $ x = $ x ^ $ i ; else $ y = $ y ^ $ i ; } echo \" Two \u2581 Missing \u2581 Numbers \u2581 are STRNEWLINE \" , $ x ; echo \" STRNEWLINE \" , $ y ; } $ arr = array ( 1 , 3 , 5 , 6 ) ; $ n = 2 + count ( $ arr ) ; findTwoMissingNumbers ( $ arr , $ n ) ; ? >"}
{"text":"Find profession in a special family | Function to get no of set bits in binary representation of passed binary no . ; Returns ' e ' if profession of node at given level and position is engineer . Else doctor . The function assumes that given position and level have valid values . ; Count set bits in ' pos - 1' ; If set bit count is odd , then doctor , else engineer ; Driver Code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function findProffesion ( $ level , $ pos ) { $ c = countSetBits ( $ pos - 1 ) ; return ( $ c % 2 ) ? ' d ' : ' e ' ; } $ level = 3 ; $ pos = 4 ; if ( ( findProffesion ( $ level , $ pos ) == ' e ' ) == true ) echo \" Engineer \u2581 STRNEWLINE \" ; else echo \" Doctor \u2581 STRNEWLINE \" ; ? >"}
{"text":"Implement rand3 ( ) using rand2 ( ) | Random Function to that returns 0 or 1 with equal probability ; rand ( ) function will generate odd or even number with equal probability . If rand ( ) generates odd number , the function will return 1 else it will return 0. ; Random Function to that returns 0 , 1 or 2 with equal probability 1 with 75 % ; returns 0 , 1 , 2 or 3 with 25 % probability ; Driver Code","code":"< ? php function rand2 ( ) { return rand ( ) & 1 ; } function rand3 ( ) { $ r = 2 * rand2 ( ) + rand2 ( ) ; if ( $ r < 3 ) return $ r ; return rand3 ( ) ; } srand ( time ( NULL ) ) ; for ( $ i = 0 ; $ i < 100 ; $ i ++ ) echo rand3 ( ) ; ? >"}
{"text":"Find a distinct pair ( x , y ) in given range such that x divides y | Function to return the possible pair ; ans1 , ans2 store value of x and y respectively ; Driver Code","code":"< ? php function findpair ( $ l , $ r ) { $ ans1 = $ l ; $ ans2 = 2 * $ l ; echo ( $ ans1 . \" , \u2581 \" . $ ans2 ) ; } $ l = 1 ; $ r = 10 ; findpair ( $ l , $ r ) ;"}
{"text":"Maximum elements that can be made equal with k updates | Function to calculate the maximum number of equal elements possible with atmost K increment of values . Here we have done sliding window to determine that whether there are x number of elements present which on increment will become equal . The loop here will run in fashion like 0. . . x - 1 , 1. . . x , 2. . . x + 1 , ... . , n - x - 1. . . n - 1 ; It can be explained with the reasoning that if for some x number of elements we can update the values then the increment to the segment ( i to j having length -> x ) so that all will be equal is ( x * maxx [ j ] ) this is the total sum of segment and ( pre [ j ] - pre [ i ] ) is present sum So difference of them should be less than k if yes , then that segment length ( x ) can be possible return true ; sort the array in ascending order ; Initializing the prefix array and maximum array ; Calculating prefix sum of the array ; Calculating max value upto that position in the array ; Binary search applied for computation here ; printing result ; Driver code","code":"< ? php function ElementsCalculationFunc ( $ pre , $ maxx , $ x , $ k , $ n ) { for ( $ i = 0 , $ j = $ x ; $ j <= $ n ; $ j ++ , $ i ++ ) { if ( $ x * $ maxx [ $ j ] - ( $ pre [ $ j ] - $ pre [ $ i ] ) <= $ k ) return true ; } return false ; } function MaxNumberOfElements ( $ a , $ n , $ k ) { sort ( $ a ) ; for ( $ i = 0 ; $ i <= $ n ; ++ $ i ) { $ pre [ $ i ] = 0 ; $ maxx [ $ i ] = 0 ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ a [ $ i - 1 ] ; $ maxx [ $ i ] = max ( $ maxx [ $ i - 1 ] , $ a [ $ i - 1 ] ) ; } $ l = 1 ; $ r = $ n ; $ ans ; while ( $ l < $ r ) { $ mid = ( $ l + $ r ) \/ 2 ; if ( ElementsCalculationFunc ( $ pre , $ maxx , $ mid - 1 , $ k , $ n ) ) { $ ans = $ mid ; $ l = $ mid + 1 ; } else $ r = $ mid - 1 ; } echo $ ans , \" STRNEWLINE \" ; } $ arr = array ( 2 , 4 , 9 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ k = 3 ; MaxNumberOfElements ( $ arr , $ n , $ k ) ; #This  code is contributed by akt_mit. NEW_LINE ? >"}
{"text":"Count palindromic characteristics of a String | PHP program which counts different palindromic characteristics of a string . ; function which checks whether a substr [ i . . j ] of a given is a palindrome or not . ; P [ i , j ] = true if substr [ i . . j ] is palindrome , else false ; palindrome of single length ; palindrome of length 2 ; Palindromes of length more then 2. This loop is similar to Matrix Chain Multiplication . We start with a gap of length 2 and fill P table in a way that gap between starting and ending indexes increases one by one by outer loop . ; Pick starting point for current gap ; Set ending point ; If current string is palindrome ; function which recursively counts if a str [ i . . j ] is a k - palindromic or not . ; terminating condition for a which is a k - palindrome . ; terminating condition for a which is not a k - palindrome . ; increases the counter for the if it is a k - palindrome . ; mid is middle pointer of the str [ i ... j ] . ; if length of which is ( j - i + 1 ) is odd than we have to subtract one from mid else if even then no change . ; if the is k - palindrome then we check if it is a ( k + 1 ) - palindrome or not by just sending any of one half of the to the Count_k_Palindrome function . ; Finding all palindromic substrings of given string ; counting k - palindromes for each and every sub of given string . . ; Output the number of K - palindromic substrings of a given string . ; Driver code","code":"< ? php $ MAX_STR_LEN = 1000 ; $ P = array ( array ( ) ) ; $ Kpal = array_fill ( 0 , $ MAX_STR_LEN , 0 ) ; for ( $ i = 0 ; $ i < $ MAX_STR_LEN ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX_STR_LEN ; $ j ++ ) $ P [ $ i ] [ $ j ] = false ; } function checkSubStrPal ( $ str , $ n ) { global $ P , $ Kpal , $ MAX_STR_LEN ; for ( $ i = 0 ; $ i < $ MAX_STR_LEN ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX_STR_LEN ; $ j ++ ) $ P [ $ i ] [ $ j ] = false ; $ Kpal [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ P [ $ i ] [ $ i ] = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ P [ $ i ] [ $ i + 1 ] = true ; for ( $ gap = 2 ; $ gap < $ n ; $ gap ++ ) { for ( $ i = 0 ; $ i < $ n - $ gap ; $ i ++ ) { $ j = $ gap + $ i ; if ( $ str [ $ i ] == $ str [ $ j ] && $ P [ $ i + 1 ] [ $ j - 1 ] ) $ P [ $ i ] [ $ j ] = true ; } } } function countKPalindromes ( $ i , $ j , $ k ) { global $ Kpal , $ P ; if ( $ i == $ j ) { $ Kpal [ $ k ] ++ ; return ; } if ( $ P [ $ i ] [ $ j ] == false ) return ; $ Kpal [ $ k ] ++ ; $ mid = ( $ i + $ j ) \/ 2 ; if ( ( $ j - $ i + 1 ) % 2 == 1 ) $ mid -- ; countKPalindromes ( $ i , $ mid , $ k + 1 ) ; } function printKPalindromes ( $ s ) { global $ P , $ Kpal , $ MAX_STR_LEN ; $ n = strlen ( $ s ) ; checkSubStrPal ( $ s , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) countKPalindromes ( $ j , $ j + $ i , 1 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo ( $ Kpal [ $ i ] . \" \u2581 \" ) ; echo ( \" STRNEWLINE \" ) ; } $ s = \" abacaba \" ; printKPalindromes ( $ s ) ; ? >"}
{"text":"Grouping Countries | PHP program to count no of distinct countries from a given group of people ; Answer is valid if adjacent sitting num people give same answer ; someone gives different answer ; check next person ; one valid country group has been found ; Driver Code","code":"< ? php function countCountries ( $ ans , $ N ) { $ total_countries = 0 ; $ i = 0 ; $ invalid = false ; while ( $ i < $ N ) { $ curr_size = $ ans [ $ i ] ; $ num = $ ans [ $ i ] ; while ( $ num > 0 ) { if ( $ ans [ $ i ] != $ curr_size ) { echo \" Invalid \u2581 Answer STRNEWLINE \" ; return ; } else $ num -- ; $ i ++ ; } $ total_countries ++ ; } echo \" There \u2581 are \u2581 \" , $ total_countries , \" \u2581 distinct \u2581 companies \u2581 in \u2581 the \u2581 group . STRNEWLINE \" ; } $ ans = array ( 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 ) ; $ n = sizeof ( $ ans ) ; countCountries ( $ ans , $ n ) ; ? >"}
{"text":"Check if an array contains all elements of a given range | Function to check the array for elements in given range ; Range is the no . of elements that are to be checked ; Traversing the array ; If an element is in range ; Checking whether elements in range 0 - range are negative ; Element from range is missing from array ; All range elements are present ; Defining Array and size ; A is lower limit and B is the upper limit of range ; True denotes all elements were present ; False denotes any element was not present","code":"< ? php function check_elements ( $ arr , $ n , $ A , $ B ) { $ range = $ B - $ A ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( abs ( $ arr [ $ i ] ) >= $ z = abs ( $ arr [ $ i ] ) - $ A ; if ( $ arr [ $ z ] > 0 ) { $ arr [ $ z ] = $ arr [ $ z ] * -1 ; } } } $ A && abs ( $ arr [ $ i ] ) <= $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ range && $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) return -1 ; else $ count ++ ; } if ( $ count != ( $ range + 1 ) ) return -1 ; return true ; } $ arr = array ( 1 , 4 , 5 , 2 , 7 , 8 , 3 ) ; $ n = sizeof ( $ arr ) ; $ A = 2 ; $ B = 5 ; if ( ( check_elements ( $ arr , $ n , $ A , $ B ) ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Recursive Programs to find Minimum and Maximum elements of array | function to print Minimum element using recursion ; if size = 0 means whole array has been traversed ; Driver Code","code":"< ? php function findMinRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return min ( $ A [ $ n - 1 ] , findMinRec ( $ A , $ n - 1 ) ) ; } $ A = array ( 1 , 4 , 45 , 6 , -50 , 10 , 2 ) ; $ n = sizeof ( $ A ) ; echo findMinRec ( $ A , $ n ) ; ? >"}
{"text":"Allocate minimum number of pages | Utility function to check if current minimum value is feasible or not . ; iterate over all books ; check if current number of pages are greater than curr_min that means we will get the result after mid no . of pages ; count how many students are required to distribute curr_min pages ; increment student count ; update curr_sum ; if students required becomes greater than given no . of students , return false ; else update curr_sum ; function to find minimum pages ; return - 1 if no . of books is less than no . of students ; Count total number of pages ; initialize start as 0 pages and end as total pages ; traverse until start <= end ; check if it is possible to distribute books by using mid as current minimum ; update result to current distribution as it 's the best we have found till now ; as we are finding minimum and books are sorted so reduce end = mid - 1 that means ; if not possible means pages should be increased so update start = mid + 1 ; at - last return minimum no . of pages ; Number of pages in books ; $m = 2 ; No . of students","code":"< ? php function isPossible ( $ arr , $ n , $ m , $ curr_min ) { $ studentsRequired = 1 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ curr_min ) return false ; if ( $ curr_sum + $ arr [ $ i ] > $ curr_min ) { $ studentsRequired ++ ; $ curr_sum = $ arr [ $ i ] ; if ( $ studentsRequired > $ m ) return false ; } else $ curr_sum += $ arr [ $ i ] ; } return true ; } function findPages ( $ arr , $ n , $ m ) { $ sum = 0 ; if ( $ n < $ m ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ start = 0 ; $ end = $ sum ; $ result = PHP_INT_MAX ; while ( $ start <= $ end ) { $ mid = ( int ) ( $ start + $ end ) \/ 2 ; if ( isPossible ( $ arr , $ n , $ m , $ mid ) ) { $ result = $ mid ; $ end = $ mid - 1 ; } else $ start = $ mid + 1 ; } return $ result ; } $ arr = array ( 12 , 34 , 67 , 90 ) ; $ n = count ( $ arr ) ; echo \" Minimum \u2581 number \u2581 of \u2581 pages \u2581 = \u2581 \" , findPages ( $ arr , $ n , $ m ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count distinct elements in an array | This function prints all distinct elements ; Creates an empty hashset ; Traverse the input array ; If not present , then put it in hashtable and increment result ; Driver Code","code":"< ? php function countDistinct ( $ arr , $ n ) { $ s = array ( ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ arr [ $ i ] ) ; } $ s = array_unique ( $ s ) ; return count ( $ s ) ; } $ arr = array ( 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ) ; $ n = count ( $ arr ) ; echo countDistinct ( $ arr , $ n ) ; ? >"}
{"text":"Rearrange an array to maximize i * arr [ i ] | Function to calculate the maximum points earned by making an optimal selection on the given array ; Sorting the array ; Variable to store the total points earned ; Driver code","code":"< ? php function findOptimalSolution ( $ a , $ N ) { sort ( $ a ) ; $ points = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ points += $ a [ $ i ] * $ i ; } return $ points ; } $ a = array ( 1 , 4 , 2 , 3 , 9 ) ; $ N = sizeof ( $ a ) ; echo ( findOptimalSolution ( $ a , $ N ) ) ; ? >"}
{"text":"Minimum number of towers required such that every house is in the range of at least one tower | Function to count the number of tower ; first we sort the house numbers ; for count number of towers ; for iterate all houses ; count number of towers ; find find the middle location ; traverse till middle location ; this is point to middle house where we insert the tower ; now find the last location ; traverse till last house of the range ; return the number of tower ; given elements ; print number of towers","code":"< ? php function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; } $ house = array ( 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ) ; $ range = 2 ; $ n = sizeof ( $ house ) \/ sizeof ( $ house [ 0 ] ) ; echo number_of_tower ( $ house , $ range , $ n ) ; ? >"}
{"text":"Check if the characters of a given string are in alphabetical order | Function that checks whether the string is in alphabetical order or not ; length of the string ; create a character array of the length of the string ; assign the string to character array ; sort the character array ; check if the character array is equal to the string or not ; Driver code ; check whether the string is in alphabetical order or not","code":"< ? php Function isAlphabaticOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ c [ $ i ] = $ s [ $ i ] ; } sort ( $ c ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ c [ $ i ] != $ s [ $ i ] ) return false ; return true ; } $ s = \" aabbbcc \" ; if ( isAlphabaticOrder ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sort first k values in ascending order and remaining n | function to sort the array ; Sort first k elements in ascending order ; Sort remaining n - k elements in descending order ; Our arr contains 8 elements","code":"< ? php function printOrder ( $ arr , $ n , $ k ) { $ a = array_slice ( $ arr , 0 , $ k ) ; sort ( $ a ) ; $ b = array_slice ( $ arr , $ k , $ n ) ; sort ( $ b ) ; $ b = array_reverse ( $ b ) ; unset ( $ arr ) ; $ arr = $ a ; return array_merge ( $ arr , $ b ) ; } $ arr = array ( 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , -1 ) ; $ k = 4 ; $ n = count ( $ arr ) ; $ arr = printOrder ( $ arr , $ n , $ k ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Program to sort string in descending order | PHP program to sort a string in descending order using library function ; Driver Code ; descOrder ( $s ) ; function call","code":"< ? php function descOrder ( $ s ) { $ s = str_split ( $ s ) ; rsort ( $ s ) ; echo implode ( ' ' , $ s ) ; } $ s = \" geeksforgeeks \" ; ? >"}
{"text":"Smallest element in an array that is repeated exactly ' k ' times . | PHP program to find smallest number in array that is repeated exactly ' k ' times . ; finds the smallest number in arr that is repeated k times ; Computing frequencies of all elements ; Finding the smallest element with frequency as k ; If frequency of any of the number is equal to k starting from 0 then return the number ; Driver code","code":"< ? php $ MAX = 1000 ; function findDuplicate ( $ arr , $ n , $ k ) { global $ MAX ; $ freq = array_fill ( 0 , $ MAX , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < 1 && $ arr [ $ i ] > $ MAX ) { echo \" Out \u2581 of \u2581 range \" ; return -1 ; } $ freq [ $ arr [ $ i ] ] += 1 ; } for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { if ( $ freq [ $ i ] == $ k ) return $ i ; } return -1 ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findDuplicate ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Program to print an array in Pendulum Arrangement | Prints pendulam arrangement of arr [ ] ; sorting the elements ; Auxiliary array to store output ; calculating the middle index ; storing the minimum element in the middle i is index for output array and j is for input array . ; adjustment for when no . of elements is even ; Printing the pendulum arrangement ; input Array ; calling pendulum function","code":"< ? php function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) \/ 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo \" Pendulum \u2581 arrangement : \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 14 , 6 , 19 , 21 , 12 ) ; $ n = sizeof ( $ arr ) ; pendulumArrangement ( $ arr , $ n ) ; ? >"}
{"text":"Minimize the sum of product of two arrays with permutations allowed | Returns minimum sum of product of two arrays with permutations allowed ; Sort A and B so that minimum and maximum value can easily be fetched . ; Multiplying minimum value of A and maximum value of B ; Driver Code","code":"< ? php function minValue ( $ A , $ B , $ n ) { sort ( $ A ) ; sort ( $ A , $ n ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ A [ $ i ] * $ B [ $ n - $ i - 1 ] ) ; return $ result ; } $ A = array ( 3 , 1 , 1 ) ; $ B = array ( 6 , 5 , 4 ) ; $ n = sizeof ( $ A ) \/ sizeof ( $ A [ 0 ] ) ; echo minValue ( $ A , $ B , $ n ) ; ? >"}
{"text":"Maximum number that can be display on Seven Segment Display using N segments | Function to print maximum number that can be formed using N segments ; If n is odd ; use 3 three segment to print 7 ; remaining to print 1 ; If n is even ; print n \/ 2 1 s . ; Driver 's Code","code":"< ? php function printMaxNumber ( $ n ) { if ( $ n & 1 ) { echo \"7\" ; for ( $ i = 0 ; $ i < ( $ n - 3 ) \/ 2 ; $ i ++ ) echo \"1\" ; } else { for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) echo \"1\" ; } } $ n = 5 ; printMaxNumber ( $ n ) ; ? >"}
{"text":"Partition an array such into maximum increasing segments | Returns the maximum number of sorted subarrays in a valid partition ; Find minimum value from right for every index ; Finding the shortest prefix such that all the elements in the prefix are less than or equal to the elements in the rest of the array . ; if current max is less than the right prefix min , we increase number of partitions . ; Driver code ; Find minimum value from right for every index","code":"< ? php function sorted_partitions ( $ arr , $ n ) { $ right_min [ $ n + 1 ] = array ( ) ; $ right_min [ $ n ] = PHP_INT_MAX ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ right_min [ $ i ] = min ( $ right_min [ $ i + 1 ] , $ arr [ $ i ] ) ; } $ partitions = 0 ; for ( $ current_max = $ arr [ 0 ] , $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_max = max ( $ current_max , $ arr [ $ i ] ) ; if ( $ current_max <= $ right_min [ $ i + 1 ] ) $ partitions ++ ; } return $ partitions ; } $ arr = array ( 3 , 1 , 2 , 4 , 100 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ ans = sorted_partitions ( $ arr , $ n ) ; echo $ ans , \" STRNEWLINE \" ; ? >"}
{"text":"Minimize Cost with Replacement with other allowed | this function returns the minimum cost of the array ; Code driven","code":"< ? php function getMinCost ( $ arr , $ n ) { $ min_ele = min ( $ arr ) ; return $ min_ele * ( $ n - 1 ) ; } $ arr = array ( 4 , 2 , 5 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo getMinCost ( $ arr , $ n ) ; #This  code contributed by ajit NEW_LINE ? >"}
{"text":"Check if it is possible to return to the starting position after moving in the given directions | Main method ; $n = 0 ; Count of North $s = 0 ; Count of South $e = 0 ; Count of East $w = 0 ; Count of West","code":"< ? php $ st = \" NNNWEWESSS \" ; $ len = strlen ( $ st ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ st [ $ i ] == ' N ' ) $ n += 1 ; if ( $ st [ $ i ] == ' S ' ) $ s += 1 ; if ( $ st [ $ i ] == ' W ' ) $ w += 1 ; if ( $ st [ $ i ] == ' E ' ) $ e += 1 ; } if ( $ n == $ s && $ w == $ e ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text":"Minimum cost to make array size 1 by removing larger of pairs | function to calculate the minimum cost ; Minimum cost is n - 1 multiplied with minimum element . ; Driver Code","code":"< ? php function cost ( $ a , $ n ) { return ( $ n - 1 ) * ( min ( $ a ) ) ; } $ a = array ( 4 , 3 , 2 ) ; $ n = count ( $ a ) ; echo cost ( $ a , $ n ) ; ? >"}
{"text":"Minimum cost for acquiring all coins with k extra coins allowed with every coin | function to calculate min cost ; sort the coins value ; calculate no . of coins needed ; calculate sum of all selected coins ; Driver Code","code":"< ? php function minCost ( $ coin , $ n , $ k ) { sort ( $ coin ) ; sort ( $ coin , $ n ) ; $ coins_needed = ceil ( 1.0 * $ n \/ ( $ k + 1 ) ) ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ coins_needed - 1 ; $ i ++ ) $ ans += $ coin [ $ i ] ; return $ ans ; } { $ coin = array ( 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ) ; $ n = sizeof ( $ coin ) \/ sizeof ( $ coin [ 0 ] ) ; $ k = 3 ; echo minCost ( $ coin , $ n , $ k ) ; return 0 ; } ? >"}
{"text":"Gould 's Sequence | Utility function to count odd numbers in ith row of Pascals 's triangle ; Initialize count as zero ; Return 2 ^ count ; Function to generate gould 's Sequence ; loop to generate gould 's Sequence up to n ; Get n ; Function call","code":"< ? php function countOddNumber ( $ row_num ) { $ count = 0 ; while ( $ row_num ) { $ count += $ row_num & 1 ; $ row_num >>= 1 ; } return ( 1 << $ count ) ; } function gouldSequence ( $ n ) { for ( $ row_num = 0 ; $ row_num < $ n ; $ row_num ++ ) { echo countOddNumber ( $ row_num ) , \" \" ; } } $ n = 16 ; gouldSequence ( $ n ) ; ? >"}
{"text":"Tiling with Dominoes | PHP program to find no . of ways to fill a 3 xn board with 2 x1 dominoes . ; Driver Code","code":"< ? php function countWays ( $ n ) { $ A = array ( ) ; $ B = array ( ) ; $ A [ 0 ] = 1 ; $ A [ 1 ] = 0 ; $ B [ 0 ] = 0 ; $ B [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ A [ $ i ] = $ A [ $ i - 2 ] + 2 * $ B [ $ i - 1 ] ; $ B [ $ i ] = $ A [ $ i - 1 ] + $ B [ $ i - 2 ] ; } return $ A [ $ n ] ; } $ n = 8 ; echo countWays ( $ n ) ; ? >"}
{"text":"Newman | Recursive Function to find the n - th element ; Driver Code","code":"< ? php function sequence ( $ n ) { if ( $ n == 1 $ n == 2 ) return 1 ; else return sequence ( sequence ( $ n - 1 ) ) + sequence ( $ n - sequence ( $ n - 1 ) ) ; } $ n = 10 ; echo ( sequence ( $ n ) ) ; ? >"}
{"text":"Counting pairs when a person can form pair with at most one | Number of ways in which participant can take part . ; Base condition ; A participant can choose to consider ( 1 ) Remains single . Number of people reduce to ( x - 1 ) ( 2 ) Pairs with one of the ( x - 1 ) others . For every pairing , number of peopl reduce to ( x - 2 ) . ; Driver code","code":"< ? php function numberOfWays ( $ x ) { if ( $ x == 0 $ x == 1 ) return 1 ; else return numberOfWays ( $ x - 1 ) + ( $ x - 1 ) * numberOfWays ( $ x - 2 ) ; } $ x = 3 ; echo numberOfWays ( $ x ) ; ? >"}
{"text":"Counting pairs when a person can form pair with at most one | PHP program for Number of ways in which participant can take part . ; Driver code","code":"< ? php function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; } $ x = 3 ; echo numberOfWays ( $ x ) ; ? >"}
{"text":"Longest Repeated Subsequence | Refer https : www . geeksforgeeks . org \/ longest - repeating - subsequence \/ for complete code . This function mainly returns LCS ( str , str ) with a condition that same characters at same index are not considered . ; Create and initialize DP table ; Fill dp table ( similar to LCS loops ) ; If characters match and indexes are not same ; If characters do not match","code":"< ? php function findLongestRepeatingSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } } return $ dp [ $ n ] [ $ n ] ; } ? >"}
{"text":"Number of ways to arrange N items under given constraints | method returns number of ways with which items can be arranged ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; declare dp array to store result up to ith colored item ; variable to keep track of count of items considered till now ; loop over all different colors ; populate next value using current value and stated relation ; return value stored at last index ; Driver code","code":"< ? php function waysToArrange ( $ N , $ K , $ k ) { $ C [ $ N + 1 ] [ $ N + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = ( $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ) ; } } $ dp [ $ K ] = array ( ) ; $ count = 0 ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ K ; $ i ++ ) { $ dp [ $ i + 1 ] = ( $ dp [ $ i ] * $ C [ $ count + $ k [ $ i ] - 1 ] [ $ k [ $ i ] - 1 ] ) ; $ count += $ k [ $ i ] ; } return $ dp [ $ K ] ; } $ N = 4 ; $ k = array ( 2 , 2 ) ; $ K = sizeof ( $ k ) ; echo waysToArrange ( $ N , $ K , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"Minimum cells required to reach destination with jumps equal to cell values | function to count minimum cells required to be covered to reach destination ; to store min cells required to be covered to reach a particular cell ; initially no cells can be reached ; base case ; building up the dp [ ] [ ] matrix ; dp [ i ] [ j ] != INT_MAX denotes that cell ( i , j ) can be reached from cell ( 0 , 0 ) and the other half of the condition finds the cell on the right that can be reached from ( i , j ) ; the other half of the condition finds the cell right below that can be reached from ( i , j ) ; it true then cell ( m - 1 , n - 1 ) can be reached from cell ( 0 , 0 ) and returns the minimum number of cells covered ; cell ( m - 1 , n - 1 ) cannot be reached from cell ( 0 , 0 ) ; Driver Code","code":"< ? php function minCells ( $ mat , $ m , $ n ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ j + $ mat [ $ i ] [ $ j ] ) < $ n and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] ) $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] = $ dp [ $ i ] [ $ j ] + 1 ; if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ i + $ mat [ $ i ] [ $ j ] ) < $ m and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] ) $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] = $ dp [ $ i ] [ $ j ] + 1 ; } } if ( $ dp [ $ m - 1 ] [ $ n - 1 ] != PHP_INT_MAX ) return $ dp [ $ m - 1 ] [ $ n - 1 ] ; return -1 ; } $ mat = array ( array ( 2 , 3 , 2 , 1 , 4 ) , array ( 3 , 2 , 5 , 8 , 2 ) , array ( 1 , 1 , 2 , 2 , 1 ) ) ; $ m = 3 ; $ n = 5 ; echo \" Minimum \u2581 number \u2581 of \u2581 cells \u2581 = \u2581 \" , minCells ( $ mat , $ m , $ n ) ; ? >"}
{"text":"Maximize the binary matrix by filpping submatrix once | PHP program to find maximum number of ones after one flipping in Binary Matrix ; Return number of ones in square submatrix of size k x k starting from ( x , y ) ; Return maximum number of 1 s after flipping a submatrix ; Precomputing the number of 1 s ; Finding the maximum number of 1 s after flipping ; Driver code","code":"< ? php $ R = 3 ; $ C = 3 ; function cal ( $ ones , $ x , $ y , $ k ) { return $ ones [ $ x + $ k - 1 ] [ $ y + $ k - 1 ] - $ ones [ $ x - 1 ] [ $ y + $ k - 1 ] - $ ones [ $ x + $ k - 1 ] [ $ y - 1 ] + $ ones [ $ x - 1 ] [ $ y - 1 ] ; } function sol ( $ mat ) { global $ C , $ R ; $ ans = 0 ; $ ones = array_fill ( 0 , $ R + 1 , array_fill ( 0 , $ C + 1 , 0 ) ) ; for ( $ i = 1 ; $ i <= $ R ; $ i ++ ) for ( $ j = 1 ; $ j <= $ C ; $ j ++ ) $ ones [ $ i ] [ $ j ] = $ ones [ $ i - 1 ] [ $ j ] + $ ones [ $ i ] [ $ j - 1 ] - $ ones [ $ i - 1 ] [ $ j - 1 ] + ( int ) ( $ mat [ $ i - 1 ] [ $ j - 1 ] == 1 ) ; for ( $ k = 1 ; $ k <= min ( $ R , $ C ) ; $ k ++ ) for ( $ i = 1 ; $ i + $ k - 1 <= $ R ; $ i ++ ) for ( $ j = 1 ; $ j + $ k - 1 <= $ C ; $ j ++ ) $ ans = max ( $ ans , ( $ ones [ $ R ] [ $ C ] + $ k * $ k - 2 * cal ( $ ones , $ i , $ j , $ k ) ) ) ; return $ ans ; } $ mat = array ( array ( 0 , 0 , 1 ) , array ( 0 , 0 , 1 ) , array ( 1 , 0 , 1 ) ) ; echo sol ( $ mat ) ; ? >"}
{"text":"Minimum steps to minimize n as per given condition | A tabulation based solution in PHP ; Driver Code","code":"< ? php function getMinSteps ( $ n ) { $ table = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] = $ n - $ i ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ! ( $ i % 2 ) ) $ table [ $ i \/ 2 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i \/ 2 ] ) ; if ( ! ( $ i % 3 ) ) $ table [ $ i \/ 3 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i \/ 3 ] ) ; } return $ table [ 1 ] ; } $ n = 10 ; echo getMinSteps ( $ n ) ; ? >"}
{"text":"Longest subsequence such that difference between adjacents is one | Function to find the length of longest subsequence ; Initialize the dp [ ] array with 1 as a single element will be of 1 length ; Start traversing the given array ; Compare with all the previous elements ; If the element is consecutive then consider this subsequence and update dp [ i ] if required . ; Longest length will be the maximum value of dp array . ; Longest subsequence with one difference is { 1 , 2 , 3 , 4 , 3 , 2 }","code":"< ? php function longestSubseqWithDiffOne ( $ arr , $ n ) { $ dp [ $ n ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ i ] == $ arr [ $ j ] + 1 ) || ( $ arr [ $ i ] == $ arr [ $ j ] - 1 ) ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; } } $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ dp [ $ i ] ) $ result = $ dp [ $ i ] ; return $ result ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo longestSubseqWithDiffOne ( $ arr , $ n ) ; ? >"}
{"text":"Non | A dynamic programming based function to find nth Catalan number ; Initialize first two values in table ; Fill entries in catalan [ ] using recursive formula ; Return last entry ; Returns count of ways to connect n points on a circle such that no two connecting lines cross each other and every point is connected with one other point . ; Throw error if n is odd ; Else return n \/ 2 'th Catalan number ; Driver Code","code":"< ? php function catalanDP ( $ n ) { $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } return $ catalan [ $ n ] ; } function countWays ( $ n ) { if ( $ n & 1 ) { echo \" Invalid \" ; return 0 ; } return catalanDP ( $ n \/ 2 ) ; } echo countWays ( 6 ) , \" \" ; ? >"}
{"text":"Ways to arrange Balls such that adjacent balls are of different types | PHP program to count number of ways to arrange three types of balls such that no two balls of same color are adjacent to each other ; table to store to store results of subproblems ; Returns count of arrangements where last placed ball is ' last ' . ' last ' is 0 for ' p ' , 1 for ' q ' and 2 for ' r ' ; if number of balls of any color becomes less than 0 the number of ways arrangements is 0. ; If last ball required is of type P and the number of balls of P type is 1 while number of balls of other color is 0 the number of ways is 1. ; Same case as above for ' q ' and ' r ' ; If this subproblem is already evaluated ; if last ball required is P and the number of ways is the sum of number of ways to form sequence with ' p - 1' P balls , q Q Balls and r R balls ending with Q and R . ; Same as above case for ' q ' and ' r ' ; else ( last == 2 ) ; Returns count of required arrangements ; Three cases arise : return countWays ( $p , $q , $r , 0 ) + Last required balls is type P countWays ( $p , $q , $r , 1 ) + Last required balls is type Q countWays ( $p , $q , $r , 2 ) ; Last required balls is type R ; Driver code","code":"< ? php $ MAX = 100 ; $ dp = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , array_fill ( 0 , 3 , -1 ) ) ) ) ; function countWays ( $ p , $ q , $ r , $ last ) { global $ dp ; if ( $ p < 0 $ q < 0 $ r < 0 ) return 0 ; if ( $ p == 1 && $ q == 0 && $ r == 0 && $ last == 0 ) return 1 ; if ( $ p == 0 && $ q == 1 && $ r == 0 && $ last == 1 ) return 1 ; if ( $ p == 0 && $ q == 0 && $ r == 1 && $ last == 2 ) return 1 ; if ( $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] != -1 ) return $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] ; if ( $ last == 0 ) $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] = countWays ( $ p - 1 , $ q , $ r , 1 ) + countWays ( $ p - 1 , $ q , $ r , 2 ) ; else if ( $ last == 1 ) $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] = countWays ( $ p , $ q - 1 , $ r , 0 ) + countWays ( $ p , $ q - 1 , $ r , 2 ) ; $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] = countWays ( $ p , $ q , $ r - 1 , 0 ) + countWays ( $ p , $ q , $ r - 1 , 1 ) ; return $ dp [ $ p ] [ $ q ] [ $ r ] [ $ last ] ; } function countUtil ( $ p , $ q , $ r ) { } $ p = 1 ; $ q = 1 ; $ r = 1 ; print ( countUtil ( $ p , $ q , $ r ) ) ; ? >"}
{"text":"Count Derangements ( Permutation such that no element appears in its original position ) | Function to count derangements ; Base cases ; countDer ( n ) = ( n - 1 ) [ countDer ( n - 1 ) + der ( n - 2 ) ] ; Driver Code","code":"< ? php function countDer ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; return ( $ n - 1 ) * ( countDer ( $ n - 1 ) + countDer ( $ n - 2 ) ) ; } $ n = 4 ; echo \" Count \u2581 of \u2581 Derangements \u2581 is \u2581 \" , countDer ( $ n ) ; ? >"}
{"text":"Count Derangements ( Permutation such that no element appears in its original position ) | Function to count derangements ; Base cases ; Fill der [ 0. . n ] in bottom up manner using above recursive formula ; Return result for n ; Driver code","code":"< ? php function countDer ( $ n ) { $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; ++ $ i ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; } $ n = 4 ; echo \" Count \u2581 of \u2581 Derangements \u2581 is \u2581 \" , countDer ( $ n ) ; ? >"}
{"text":"Find number of solutions of a linear equation of n variables | Returns count of solutions for given rhs and coefficients coeff [ 0. . n - 1 ] ; Create and initialize a table to store results of subproblems ; Fill table in bottom up manner ; Driver Code","code":"< ? php function countSol ( $ coeff , $ n , $ rhs ) { $ dp = str_repeat ( \" \\0\" , 256 ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ coeff [ $ i ] ; $ j <= $ rhs ; $ j ++ ) $ dp [ $ j ] = $ dp [ $ j ] + ( $ dp [ $ j - $ coeff [ $ i ] ] ) ; return $ dp [ $ rhs ] ; } $ coeff = array ( 2 , 2 , 5 ) ; $ rhs = 4 ; $ n = sizeof ( $ coeff ) \/ sizeof ( $ coeff [ 0 ] ) ; echo countSol ( $ coeff , $ n , $ rhs ) ; ? >"}
{"text":"Maximum Product Cutting | DP | The main function that returns the max possible product ; n equals to 2 or 3 must be handled explicitly ; Keep removing parts of size 3 while n is greater than 4 ; Keep multiplying 3 to res ; The last part multiplied by previous parts ; Driver code","code":"< ? php function maxProd ( $ n ) { if ( $ n == 2 $ n == 3 ) return ( $ n - 1 ) ; $ res = 1 ; while ( $ n > 4 ) { $ n = $ n - 3 ; $ res = $ res * 3 ; } return ( $ n * $ res ) ; } echo ( \" Maximum \u2581 Product \u2581 is \u2581 \" ) ; echo ( maxProd ( 10 ) ) ; ? >"}
{"text":"Dice Throw | DP | The main function that returns number of ways to get sum ' x ' with ' n ' dice and ' m ' with m faces . ; Create a table to store results of subproblems . One extra row and column are used for simpilicity ( Number of dice is directly used as row index and sum is directly used as column index ) . The entries in 0 th row and 0 th column are never used . ; Table entries for only one dice ; Fill rest of the entries in table using recursive relation i : number of dice , j : sum ; Return value ; Driver Code","code":"< ? php function findWays ( $ m , $ n , $ x ) { $ table ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 1 ; $ j < $ x + 1 ; $ j ++ ) $ table [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ m && $ j <= $ x ; $ j ++ ) $ table [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ x ; $ j ++ ) for ( $ k = 1 ; $ k <= $ m && $ k < $ j ; $ k ++ ) $ table [ $ i ] [ $ j ] += $ table [ $ i - 1 ] [ $ j - $ k ] ; return $ table [ $ n ] [ $ x ] ; } echo findWays ( 4 , 2 , 1 ) . \" STRNEWLINE \" ; echo findWays ( 2 , 2 , 3 ) . \" STRNEWLINE \" ; echo findWays ( 6 , 3 , 8 ) . \" STRNEWLINE \" ; echo findWays ( 4 , 2 , 5 ) . \" STRNEWLINE \" ; echo findWays ( 4 , 3 , 5 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Longest Palindromic Subsequence | DP | Returns the length of the longest palindromic subsequence in seq ; Base Case 1 : If there is only 1 character ; Base Case 2 : If there are only 2 characters and both are same ; If the first and last characters match ; If the first and last characters do not match ; Driver Code","code":"< ? php function lps ( $ seq , $ i , $ j ) { if ( $ i == $ j ) return 1 ; if ( $ seq [ $ i ] == $ seq [ $ j ] && $ i + 1 == $ j ) return 2 ; if ( $ seq [ $ i ] == $ seq [ $ j ] ) return lps ( $ seq , $ i + 1 , $ j - 1 ) + 2 ; return max ( lps ( $ seq , $ i , $ j - 1 ) , lps ( $ seq , $ i + 1 , $ j ) ) ; } $ seq = \" GEEKSFORGEEKS \" ; $ n = strlen ( $ seq ) ; echo \" The \u2581 length \u2581 of \u2581 the \u2581 LPS \u2581 is \u2581 \" . lps ( $ seq , 0 , $ n - 1 ) ; ? >"}
{"text":"Count occurrences of a string that can be constructed from another given string | Function to find the count ; Initialize hash for both strings ; hash the frequency of letters of str1 ; hash the frequency of letters of str2 ; Find the count of str2 constructed from str1 ; Return answer ; Driver code","code":"< ? php function findCount ( $ str1 , $ str2 ) { $ len = strlen ( $ str1 ) ; $ len2 = strlen ( $ str1 ) ; $ ans = PHP_INT_MAX ; $ hash1 = array_fill ( 0 , 26 , 0 ) ; $ hash2 = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ hash1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ len2 ; $ i ++ ) $ hash2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash2 [ $ i ] ) $ ans = min ( $ ans , $ hash1 [ $ i ] \/ $ hash2 [ $ i ] ) ; return $ ans ; } $ str1 = \" geeksclassesatnoida \" ; $ str2 = \" sea \" ; echo findCount ( $ str1 , $ str2 ) ; ? >"}
{"text":"Check if a string is the typed name of the given name | Check if the character is vowel or not ; Returns true if ' typed ' is a typed name given str ; Traverse through all characters of str . ; If current characters do not match ; If not vowel , simply move ahead in both ; Count occurrences of current vowel in str ; Count occurrences of current vowel in typed . ; Driver code","code":"< ? php function isVowel ( $ c ) { $ vowel = \" aeiou \" ; for ( $ i = 0 ; $ i < strlen ( $ vowel ) ; ++ $ i ) if ( $ vowel [ $ i ] == $ c ) return true ; return false ; } function printRLE ( $ str , $ typed ) { $ n = strlen ( $ str ) ; $ m = strlen ( $ typed ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] != $ typed [ $ j ] ) return false ; if ( isVowel ( $ str [ $ i ] ) == false ) { $ j ++ ; continue ; } $ count1 = 1 ; while ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) { $ count1 ++ ; $ i ++ ; } $ count2 = 1 ; while ( $ j < $ m - 1 && $ typed [ $ j ] == $ str [ $ i ] ) { $ count2 ++ ; $ j ++ ; } if ( $ count1 > $ count2 ) return false ; } return true ; } $ name = \" alex \" ; $ typed = \" aaalaeex \" ; if ( printRLE ( $ name , $ typed ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program to replace a word with asterisks in a sentence | Function takes two parameter ; Break down sentence by ' \u2581 ' spaces and store each individual word in a different list ; A new string to store the result ; Creating the censor which is an asterisks \" * \" text of the length of censor word ; count variable to access our word_list ; Iterating through our list of extracted words ; changing the censored word to created asterisks censor ; join the words ; Driver code","code":"< ? php function censor ( $ text , $ word ) { $ word_list = explode ( \" \u2581 \" , $ text ) ; $ result = ' ' $ stars = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ word ) ; $ i ++ ) $ stars . = \" * \" ; $ count = 0 ; $ index = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ word_list ) ; $ i ++ ) { if ( $ word_list [ $ i ] == $ word ) $ word_list [ $ index ] = $ stars ; $ index += 1 ; } return implode ( ' \u2581 ' , $ word_list ) ; } $ extract = \" GeeksforGeeks \u2581 is \u2581 a \u2581 computer \u2581 science \u2581 \" . \" portal for geeks . I am pursuing my \" . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" major in computer science . \" $ cen = \" computer \" ; echo censor ( $ extract , $ cen ) ; ? >"}
{"text":"Find the time which is palindromic and comes after the given time | Function to return the required time ; To store the resultant time ; Hours are stored in h as integer ; Minutes are stored in m as integer ; Reverse of h ; Reverse of h as a string ; If MM < reverse of ( HH ) ; 0 is added if HH < 10 ; 0 is added if rev_h < 10 ; Increment hours ; Reverse of the hour after incrementing 1 ; 0 is added if HH < 10 ; 0 is added if rev_h < 10 ; Driver code","code":"< ? php function getTime ( $ s , $ n ) { $ res = \" \" ; $ h = intval ( $ s . substr ( 0 , 2 ) ) ; $ m = intval ( $ s . substr ( 3 , 2 ) ) ; $ rev_h = ( $ h % 10 ) * 10 + ( ( $ h % 100 ) - ( $ h % 10 ) ) \/ 10 ; $ rev_hs = strval ( $ rev_h ) ; if ( $ h == 23 && $ m >= 32 ) { $ res = \" - 1\" ; } else if ( $ m < $ rev_h ) { $ temp = \" \" ; if ( $ h < 10 ) $ temp = \"0\" ; $ temp = $ temp . strval ( $ h ) ; if ( $ rev_h < 10 ) $ res = $ res . $ temp . \" : 0\" . $ rev_hs ; else $ res = $ res . $ temp . \" : \" . $ rev_hs ; } else { $ h ++ ; $ rev_h = ( $ h % 10 ) * 10 + ( ( $ h % 100 ) - ( $ h % 10 ) ) \/ 10 ; $ rev_hs = strval ( $ rev_h ) ; $ temp = \" \" ; if ( $ h < 10 ) $ temp = \"0\" ; $ temp = $ temp . strval ( $ h ) ; if ( $ rev_h < 10 ) $ res = $ res . $ temp . \" : 0\" . $ rev_hs ; else $ res = $ res . $ temp . \" : \" . $ rev_hs ; } return $ res ; } $ s = \"21:12\" ; $ n = strlen ( $ s ) ; echo getTime ( $ s , $ n ) ; return 0 ; ? >"}
{"text":"Count of sub | Function to return the count of valid sub - strings ; Variable ans to store all the possible substrings Initialize its value as total number of substrings that can be formed from the given string ; Stores recent index of the characters ; If character is a update a 's index  and the variable ans ; If character is b update b 's index  and the variable ans ; If character is c update c 's index  and the variable ans ; Driver code","code":"< ? php function CountSubstring ( $ str , $ n ) { $ ans = ( $ n * ( $ n + 1 ) ) \/ 2 ; $ a_index = 0 ; $ b_index = 0 ; $ c_index = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' a ' ) { $ a_index = $ i + 1 ; $ ans -= min ( $ b_index , $ c_index ) ; } else if ( $ str [ $ i ] == ' b ' ) { $ b_index = $ i + 1 ; $ ans -= min ( $ a_index , $ c_index ) ; } else { $ c_index = $ i + 1 ; $ ans -= min ( $ a_index , $ b_index ) ; } } return $ ans ; } { $ str = str_split ( \" babac \" ) ; $ n = sizeof ( $ str ) ; echo ( CountSubstring ( $ str , $ n ) ) ; }"}
{"text":"Check if a binary string contains consecutive same or not | Function that returns true is str is valid ; Assuming the string is binary If any two consecutive characters are equal then the string is invalid ; If the string is alternating ; Driver code","code":"< ? php function isValid ( $ str , $ len ) { for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i - 1 ] ) return false ; } return true ; } $ str = \"0110\" ; $ len = strlen ( $ str ) ; if ( isValid ( $ str , $ len ) ) echo \" Valid \" ; else echo \" Invalid \" ; ? >"}
{"text":"Minimum K such that every substring of length atleast K contains a character c | This function checks if there exists some character which appears in all K length substrings ; Iterate over all possible characters ; stores the last occurrence ; set answer as true ; ; No occurrence found of current character in first substring of length K ; Check for every last substring of length K where last occurr - ence exists in substring ; If last occ is not present in substring ; current character is K amazing ; This function performs binary search over the answer to minimise it ; Check if answer is found try to minimise it ; Driver Code","code":"< ? php function check ( $ s , $ K ) { for ( $ ch = 0 ; $ ch < 26 ; $ ch ++ ) { $ c = chr ( ord ( ' a ' ) + $ ch ) ; $ last = -1 ; $ found = true ; for ( $ i = 0 ; $ i < $ K ; $ i ++ ) if ( $ s [ $ i ] == $ c ) $ last = $ i ; if ( $ last == -1 ) continue ; for ( $ i = $ K ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ c ) $ last = $ i ; if ( $ last <= ( $ i - $ K ) ) { $ found = false ; break ; } } if ( $ found ) return 1 ; } return 0 ; } function binarySearch ( $ s ) { $ low = 1 ; $ high = strlen ( $ s ) ; while ( $ low <= $ high ) { $ mid = ( $ high + $ low ) >> 1 ; if ( check ( $ s , $ mid ) ) { $ ans = $ mid ; $ high = $ mid - 1 ; } else $ low = $ mid + 1 ; } return $ ans ; } $ s = \" abcde \" ; echo binarySearch ( $ s ) . \" STRNEWLINE \" ; $ s = \" aaaa \" ; echo binarySearch ( $ s ) . \" STRNEWLINE \" ; ? >"}
{"text":"Check if number can be displayed using seven segment led | Pre - computed values of segment used by digit 0 to 9. ; Check if it is possible to display the number ; Finding sum of the segments used by each digit of the number ; Driver Code ; Function call to print required answer","code":"< ? php $ seg = array ( 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ) ; function LedRequired ( $ s , $ led ) { $ count = 0 ; global $ seg ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; ++ $ i ) { $ count += $ seg [ ord ( $ s [ $ i ] ) - 48 ] ; } if ( $ count <= $ led ) return \" YES \" ; else return \" NO \" ; } $ S = \"123456789\" ; $ led = 20 ; echo LedRequired ( $ S , $ led ) ; ? >"}
{"text":"Count the number of vowels occurring in all the substrings of given string | Returns the total sum of occurrences of all vowels ; No . of occurrences of 0 th character in all the substrings ; No . of occurrences of ith character in all the substrings ; Check if ith character is a vowel ; Return the total sum of occurrences of vowels ; Driver Code","code":"< ? php function vowel_calc ( $ s ) { $ n = strlen ( $ s ) ; $ arr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i == 0 ) $ arr [ $ i ] = $ n ; else $ arr [ $ i ] = ( $ n - $ i ) + $ arr [ $ i - 1 ] - $ i ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' $ s [ $ i ] == ' e ' $ s [ $ i ] == ' i ' $ s [ $ i ] == ' o ' $ s [ $ i ] == ' u ' ) $ sum += $ arr [ $ i ] ; } return $ sum ; } $ s = \" daceh \" ; echo ( vowel_calc ( $ s ) ) ; ? >"}
{"text":"Count all palindrome which is square of a palindrome | check if a number is a palindrome ; Function to return required count of palindromes ; Range [ L , R ] ; Upper limit ; count odd length palindromes ; if s = '1234' ; then , t = '1234321' ; count even length palindromes ; if s = '1234' ; then , t = '12344321' ; Return count of super - palindromes ; Driver Code ; function call to get required answer","code":"< ? php function ispalindrome ( $ x ) { $ ans = 0 ; $ temp = $ x ; while ( $ temp > 0 ) { $ ans = ( 10 * $ ans ) + ( $ temp % 10 ) ; $ temp = ( int ) ( $ temp \/ 10 ) ; } return $ ans == $ x ; } function SuperPalindromes ( $ L , $ R ) { $ L = ( int ) $ L ; $ R = ( int ) $ R ; $ LIMIT = 100000 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ LIMIT ; $ i ++ ) { $ s = ( string ) $ i ; $ rs = substr ( $ s , 0 , strlen ( $ s ) - 1 ) ; $ p = $ s . strrev ( $ rs ) ; $ p_sq = ( int ) $ p * * 2 ; if ( $ p_sq > $ R ) { break ; } if ( $ p_sq >= $ L and ispalindrome ( $ p_sq ) ) { $ ans = $ ans + 1 ; } } for ( $ i = 0 ; $ i < $ LIMIT ; $ i ++ ) { $ s = ( string ) $ i ; $ p = $ s . strrev ( $ s ) ; $ p_sq = ( int ) $ p * * 2 ; if ( $ p_sq > $ R ) { break ; } if ( $ p_sq >= $ L and ispalindrome ( $ p_sq ) ) { $ ans = $ ans + 1 ; } } return $ ans ; } $ L = \"4\" ; $ R = \"1000\" ; echo SuperPalindromes ( $ L , $ R ) ; ? >"}
{"text":"Sub | Function that counts all the sub - strings of length ' k ' which have all identical characters ; count of sub - strings , length , initial position of sliding window ; map to store the frequency of the characters of sub - string ; increase the frequency of the character and length of the sub - string ; if the length of the sub - string is greater than K ; remove the character from the beginning of sub - string ; if the length of the sub string is equal to k and frequency of one of its characters is equal to the length of the sub - string i . e . all the characters are same increase the count ; display the number of valid sub - strings ; Driver code","code":"< ? php function solve ( $ s , $ k ) { $ count = 0 ; $ length = 0 ; $ pos = 0 ; $ m = array ( ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ m [ $ s [ $ i ] ] ++ ; $ length ++ ; if ( $ length > $ k ) { $ m [ $ s [ $ pos ++ ] ] -- ; $ length -- ; } if ( $ length == $ k && $ m [ $ s [ $ i ] ] == $ length ) $ count ++ ; } echo $ count . \" STRNEWLINE \" ; } $ s = \" aaaabbbccdddd \" ; $ k = 4 ; solve ( $ s , $ k ) ; ? >"}
{"text":"Program to replace every space in a string with hyphen | Get the String ; Traverse the string character by character . ; Changing the ith character to ' - ' if it 's a space. ; Print the modified string .","code":"< ? php $ str = \" A \u2581 computer \u2581 science \u2581 portal \u2581 for \u2581 geeks \" ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { if ( $ str [ $ i ] == ' \u2581 ' ) { $ str [ $ i ] = ' - ' ; } } echo $ str . \" STRNEWLINE \" ;"}
{"text":"Check if any permutation of a large number is divisible by 8 | PHP program to check if any permutation of a large number is divisible by 8 or not ; Function to check if any permutation of a large number is divisible by 8 ; Less than three digit number can be checked directly . ; check for the reverse of a number ; Stores the Frequency of characters in the n . ; Iterates for all three digit numbers divisible by 8 ; stores the frequency of all single digit in three - digit number ; check if the original number has the digit ; when all are checked its not possible ; Driver Code","code":"< ? php error_reporting ( 0 ) ; function solve ( $ n , $ l ) { if ( $ l < 3 ) { if ( intval ( $ n ) % 8 == 0 ) return true ; strrev ( $ n ) ; if ( intval ( $ n ) % 8 == 0 ) return true ; return false ; } $ hash [ 10 ] = array ( 0 ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ hash [ $ n [ $ i ] - '0' ] ++ ; for ( $ i = 104 ; $ i < 1000 ; $ i += 8 ) { $ dup = $ i ; $ freq [ 10 ] = array ( 0 ) ; $ freq [ $ dup % 10 ] ++ ; $ dup = $ dup \/ 10 ; $ freq [ $ dup % 10 ] ++ ; $ dup = $ dup \/ 10 ; $ freq [ $ dup % 10 ] ++ ; $ dup = $ i ; if ( $ freq [ $ dup % 10 ] > $ hash [ $ dup % 10 ] ) continue ; $ dup = $ dup \/ 10 ; if ( $ freq [ $ dup % 10 ] > $ hash [ $ dup % 10 ] ) continue ; $ dup = $ dup \/ 10 ; if ( $ freq [ $ dup % 10 ] > $ hash [ $ dup % 10 ] ) continue ; return true ; } return false ; } $ number = \"31462708\" ; $ l = strlen ( $ number ) ; if ( solve ( $ number , $ l ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text":"Lexicographically smallest string formed by appending a character from the first K characters of a given string | Function to find the new string thus formed by removing characters ; new string ; Remove characters until the string is empty ; Traverse to find the smallest character in the first k characters ; append the smallest character ; removing the lexicographically smallest character from the string ; Driver code","code":"< ? php function newString ( $ s , $ k ) { $ X = \" \" ; while ( strlen ( $ s ) > 0 ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < $ k && $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] < $ temp ) { $ temp = $ s [ $ i ] ; } } $ X = $ X . $ temp ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { if ( $ s [ $ i ] == $ temp ) { $ s = substr ( $ s , 0 , $ i ) . substr ( $ s , $ i + 1 , strlen ( $ s ) ) ; break ; } } } return $ X ; } $ s = \" gaurang \" ; $ k = 3 ; echo ( newString ( $ s , $ k ) ) ; ? >"}
{"text":"Convert String into Binary Sequence | utility function ; convert each char to ASCII value ; Convert ASCII value to binary ; Driver code","code":"< ? php function strToBinary ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ val = ord ( $ s [ $ i ] ) ; $ bin = \" \" ; while ( $ val > 0 ) { ( $ val % 2 ) ? $ bin = $ bin . '1' : $ bin = $ bin . '0' ; $ val = floor ( $ val \/ 2 ) ; } for ( $ x = strlen ( $ bin ) - 1 ; $ x >= 0 ; $ x -- ) echo $ bin [ $ x ] ; echo \" \u2581 \" ; } } $ s = \" geeks \" ; strToBinary ( $ s ) ; ? >"}
{"text":"Convert a sentence into its equivalent mobile numeric keypad sequence | Function which computes the sequence ; length of input string ; Checking for space ; Calculating index for each character ; Output sequence ; storing the sequence in array","code":"< ? php function printSequence ( & $ arr , $ input ) { $ output = \" \" ; $ n = strlen ( $ input ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ input [ $ i ] == ' \u2581 ' ) $ output = $ output + \"0\" ; else { $ position = ord ( $ input [ $ i ] ) - ord ( ' A ' ) ; $ output = $ output . $ arr [ $ position ] ; } } return $ output ; } $ str = array ( \"2\" , \"22\" , \"222\" , \"3\" , \"33\" , \"333\" , \"4\" , \"44\" , \"444\" , \"5\" , \"55\" , \"555\" , \"6\" , \"66\" , \"666\" , \"7\" , \"77\" , \"777\" , \"7777\" , \"8\" , \"88\" , \"888\" , \"9\" , \"99\" , \"999\" , \"9999\" ) ; $ input = \" GEEKSFORGEEKS \" ; echo printSequence ( $ str , $ input ) ; ? >"}
{"text":"Check whether given floating point number is even or odd | Function to check even or odd . ; Loop to traverse number from LSB ; We ignore trailing 0 s after dot ; If it is ' . ' we will check next digit and it means decimal part is traversed . ; If digit is divisible by 2 means even number . ; Driver Code","code":"< ? php function isEven ( $ s ) { $ l = strlen ( $ s ) ; $ dotSeen = false ; for ( $ i = $ l - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' && $ dotSeen == false ) continue ; if ( $ s [ $ i ] == ' . ' ) { $ dotSeen = true ; continue ; } if ( ( $ s [ $ i ] - '0' ) % 2 == 0 ) return true ; return false ; } } $ s = \"100.70\" ; if ( isEven ( $ s ) ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text":"Length of the smallest sub | PHP program to find the length of the smallest substring consisting of maximum distinct characters ; Find maximum distinct characters in any string ; Initialize all character 's count with 0 ; Increase the count in array if a character is found ; size of given string ; Find maximum distinct characters in any string ; result ; Brute force approach to find all substrings ; We have to check here both conditions together 1. substring ' s \u2581 distinct \u2581 characters \u2581 is \u2581 equal \u2581 \u2581 to \u2581 maximum \u2581 distinct \u2581 characters \u2581 \u2581 2 . \u2581 substring ' s length should be minimum ; Input String","code":"< ? php $ NO_OF_CHARS = 256 ; function max_distinct_char ( $ str , $ n ) { global $ NO_OF_CHARS ; $ count = array_fill ( 0 , $ NO_OF_CHARS , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) ] ++ ; $ max_distinct = 0 ; for ( $ i = 0 ; $ i < $ NO_OF_CHARS ; $ i ++ ) if ( $ count [ $ i ] != 0 ) $ max_distinct ++ ; return $ max_distinct ; } function smallesteSubstr_maxDistictChar ( $ str ) { $ n = strlen ( $ str ) ; $ max_distinct = max_distinct_char ( $ str , $ n ) ; $ minl = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ subs = substr ( $ str , $ i , $ j ) ; $ subs_lenght = strlen ( $ subs ) ; $ sub_distinct_char = max_distinct_char ( $ subs , $ subs_lenght ) ; if ( $ subs_lenght < $ minl && $ max_distinct == $ sub_distinct_char ) { $ minl = $ subs_lenght ; } } } return $ minl ; } $ str = \" AABBBCBB \" ; $ len = smallesteSubstr_maxDistictChar ( $ str ) ; echo \" \u2581 The \u2581 length \u2581 of \u2581 the \u2581 smallest \u2581 substring \" . \" \u2581 consisting \u2581 of \u2581 maximum \u2581 distinct \u2581 characters \u2581 : \u2581 \" . $ len ; ? >"}
{"text":"Evaluate a boolean expression represented as string | Evaluates boolean expression and returns the result ; Traverse all operands by jumping a character after every iteration . ; If operator next to current operand is AND . ; If operator next to current operand is OR . ; If operator next to current operand is XOR ( Assuming a valid input ) ; Driver code","code":"< ? php function evaluateBoolExpr ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) { if ( ( $ i + 1 ) < $ n && $ s [ $ i + 1 ] == ' A ' ) { if ( $ s [ $ i + 2 ] == '0' $ s [ $ i ] == '0' ) $ s [ $ i + 2 ] = '0' ; else $ s [ $ i + 2 ] = '1' ; } else if ( ( $ i + 1 ) < $ n && $ s [ $ i + 1 ] == ' B ' ) { if ( $ s [ $ i + 2 ] == '1' $ s [ $ i ] == '1' ) $ s [ $ i + 2 ] = '1' ; else $ s [ $ i + 2 ] = '0' ; } else { if ( ( $ i + 2 ) < $ n && $ s [ $ i + 2 ] == $ s [ $ i ] ) $ s [ $ i + 2 ] = '0' ; else $ s [ $ i + 2 ] = '1' ; } } return $ s [ $ n - 1 ] - '0' ; } $ s = \"1C1B1B0A0\" ; echo evaluateBoolExpr ( $ s ) ;"}
{"text":"Efficiently find first repeated character in a string without using any additional data structure in one traversal | Returns - 1 if all characters of str are unique . Assumptions : ( 1 ) str contains only characters from ' a ' to ' z ' ( 2 ) integers are stored using 32 bits ; An integer to store presence \/ absence of 26 characters using its 32 bits . ; If bit corresponding to current character is already set ; set bit in checker ; Driver code","code":"< ? php function FirstRepeated ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return $ i ; $ checker |= ( 1 << $ val ) ; } return -1 ; } $ s = \" abcfdeacf \" ; $ i = FirstRepeated ( $ s ) ; if ( $ i != -1 ) echo \" Char \u2581 = \u2581 \" . $ s [ $ i ] . \" \u2581 and \u2581 Index \u2581 = \u2581 \" . $ i ; else echo \" No \u2581 repeated \u2581 Char \" ; ? >"}
{"text":"Number of even substrings in a string of digits | Return the even number substrings . ; If current digit is even , add count of substrings ending with it . The count is ( i + 1 ) ; Driver Code","code":"< ? php function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; } $ str = \"1234\" ; echo evenNumSubstring ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find largest word in dictionary by deleting some characters of given string | Returns true if str1 [ ] is a subsequence of str2 [ ] . m is length of str1 and n is length of str2 ; Traverse str2 and str1 , and compare current character of str2 with first unmatched char of str1 , if matched then move ahead in str1 ; If all characters of str1 were found in str2 ; Returns the longest string in dictionary which is a subsequence of str . ; Traverse through all words of dictionary ; If current word is subsequence of str and is largest such word so far . ; Return longest string ; Driver code","code":"< ? php function isSubSequence ( $ str1 , $ str2 ) { $ m = strlen ( $ str1 ) ; $ n = strlen ( $ str2 ) ; for ( $ i = 0 ; $ i < $ n && $ j < $ m ; $ i ++ ) if ( $ str1 [ $ j ] == $ str2 [ $ i ] ) $ j ++ ; return ( $ j == $ m ) ; } function findLongestString ( $ dict , $ str ) { $ result = \" \" ; $ length = 0 ; foreach ( $ dict as $ word ) { if ( $ length < strlen ( $ word ) && isSubSequence ( $ word , $ str ) ) { $ result = $ word ; $ length = strlen ( $ word ) ; } } return $ result ; } $ dict = array ( \" ale \" , \" apple \" , \" monkey \" , \" plea \" ) ; $ str = \" abpcplea \" ; echo findLongestString ( $ dict , $ str ) ; ? >"}
{"text":"Check if edit distance between two strings is one | Returns true if edit distance between s1 and s2 is one , else false ; Find lengths of given strings ; If difference between lengths is more than 1 , then strings can 't  be at one distance ; Count of edits ; If current characters don 't match ; If length of one string is more , then only possible edit is to remove a character ; If lengths of both strings is same ; Increment count of edits ; If current characters match ; If last character is extra in any string ; Driver Code","code":"< ? php function isEditDistanceOne ( $ s1 , $ s2 ) { $ m = strlen ( $ s1 ) ; $ n = strlen ( $ s2 ) ; if ( abs ( $ m - $ n ) > 1 ) return false ; $ count = 0 ; $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ s1 [ $ i ] != $ s2 [ $ j ] ) { if ( $ count == 1 ) return false ; if ( $ m > $ n ) $ i ++ ; else if ( $ m < $ n ) $ j ++ ; else { $ i ++ ; $ j ++ ; } $ count ++ ; } else { $ i ++ ; $ j ++ ; } } if ( $ i < $ m $ j < $ n ) $ count ++ ; return $ count == 1 ; } $ s1 = \" gfg \" ; $ s2 = \" gf \" ; if ( isEditDistanceOne ( $ s1 , $ s2 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Given a binary string , count number of substrings that start and end with 1. | A simple PHP program to count number of substrings starting and ending with 1 ; Initialize result ; Pick a starting point ; Search for all possible ending point ; Driver Code","code":"< ? php function countSubStr ( $ str ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) if ( $ str [ $ j ] == '1' ) $ res ++ ; } } return $ res ; } $ str = \"00100101\" ; echo countSubStr ( $ str ) ; ? >"}
{"text":"Modular exponentiation ( Recursive ) | Recursive PHP program to compute modular power ; Base cases ; If B is even ; If B is odd ; Driver Code","code":"< ? php function exponentMod ( $ A , $ B , $ C ) { if ( $ A == 0 ) return 0 ; if ( $ B == 0 ) return 1 ; if ( $ B % 2 == 0 ) { $ y = exponentMod ( $ A , $ B \/ 2 , $ C ) ; $ y = ( $ y * $ y ) % $ C ; } else { $ y = $ A % $ C ; $ y = ( $ y * exponentMod ( $ A , $ B - 1 , $ C ) % $ C ) % $ C ; } return ( ( $ y + $ C ) % $ C ) ; } $ A = 2 ; $ B = 5 ; $ C = 13 ; echo \" Power \u2581 is \u2581 \" . exponentMod ( $ A , $ B , $ C ) ; ? >"}
{"text":"Modular Exponentiation ( Power in Modular Arithmetic ) | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now ; Driver Code","code":"< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; if ( $ x == 0 ) return 0 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; y = $ y \/ 2 $ y = $ y >> 1 ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } $ x = 2 ; $ y = 5 ; $ p = 13 ; echo \" Power \u2581 is \u2581 \" , power ( $ x , $ y , $ p ) ; ? >"}
{"text":"Area of the Largest Triangle inscribed in a Hexagon | Function to find the area of the triangle ; side cannot be negative ; area of the triangle ; Driver code","code":"< ? php function trianglearea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) \/ 4 ; return $ area ; } $ a = 6 ; echo trianglearea ( $ a ) ; ? >"}
{"text":"Equation of ellipse from its focus , directrix , and eccentricity | Function to find equation of ellipse . ; Driver Code","code":"< ? php function equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) { $ t = ( $ a * $ a ) + ( $ b * $ b ) ; $ a1 = $ t - $ e * ( $ a * $ a ) ; $ b1 = $ t - $ e * ( $ b * $ b ) ; $ c1 = ( -2 * $ t * $ x1 ) - ( 2 * $ e * $ c * $ a ) ; $ d1 = ( -2 * $ t * $ y1 ) - ( 2 * $ e * $ c * $ b ) ; $ e1 = -2 * $ e * $ a * $ b ; $ f1 = ( - $ e * $ c * $ c ) + ( $ t * $ x1 * $ x1 ) + ( $ t * $ y1 * $ y1 ) ; $ fixed ; echo \" Equation \u2581 of \u2581 ellipse \u2581 is \u2581 STRNEWLINE \" , $ a1 , \" \u2581 x ^ 2 \u2581 + \u2581 \" , $ b1 , \" \u2581 y ^ 2 \u2581 + \u2581 \" , $ c1 , \" \u2581 x \u2581 + \u2581 \" , $ d1 , \" \u2581 y \u2581 + \u2581 \" , $ e1 , \" \u2581 xy \u2581 + \u2581 \" , $ f1 , \" \u2581 = \u2581 0\" ; } $ x1 = 1 ; $ y1 = 1 ; $ a = 1 ; $ b = -1 ; $ c = 3 ; $ e = 0.5 * 0.5 ; equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) ; ? >"}
{"text":"Area of circle which is inscribed in equilateral triangle | Function return the area of circle inscribed in equilateral triangle ; Driver code","code":"< ? php function circle_inscribed ( $ a ) { return 3.14 * ( $ a * $ a ) \/ 12 ; } $ a = 4 ; echo circle_inscribed ( $ a ) ;"}
{"text":"Program to find the Volume of an irregular tetrahedron | Function to find the volume ; Steps to calculate volume of a Tetrahedron using formula ; edge lengths","code":"< ? php function findVolume ( $ u , $ v , $ w , $ U , $ V , $ W , $ b ) { $ uPow = pow ( $ u , 2 ) ; $ vPow = pow ( $ v , 2 ) ; $ wPow = pow ( $ w , 2 ) ; $ UPow = pow ( $ U , 2 ) ; $ VPow = pow ( $ V , 2 ) ; $ WPow = pow ( $ W , 2 ) ; $ a = 4 * ( $ uPow * $ vPow * $ wPow ) - $ uPow * pow ( ( $ vPow + $ wPow - $ UPow ) , 2 ) - $ vPow * pow ( ( $ wPow + $ uPow - $ VPow ) , 2 ) - $ wPow * pow ( ( $ uPow + $ vPow - $ WPow ) , 2 ) + ( $ vPow + $ wPow - $ UPow ) * ( $ wPow + $ uPow - $ VPow ) * ( $ uPow + $ vPow - $ WPow ) ; $ vol = sqrt ( $ a ) ; $ vol \/= $ b ; echo $ vol ; } $ u = 1000 ; $ v = 1000 ; $ w = 1000 ; $ U = 3 ; $ V = 4 ; $ W = 5 ; $ b = 12 ; findVolume ( $ u , $ v , $ w , $ U , $ V , $ W , $ b ) ; ? >"}
{"text":"Check if it is possible to create a polygon with a given angle | Function to check whether it is possible to make a regular polygon with a given angle . ; N denotes the number of sides of polygons possible ; Driver code ; function to print the required answer","code":"< ? php function makePolygon ( $ a ) { $ n = 360 \/ ( 180 - $ a ) ; if ( $ n == ( int ) $ n ) echo \" YES \" ; else echo \" NO \" ; } $ a = 90 ; makePolygon ( $ a ) ; ? >"}
{"text":"Finding Quadrant of a Coordinate with respect to a Circle | Thus function returns the quadrant number ; Coincides with center ; Outside circle ; 1 st quadrant ; 2 nd quadrant ; 3 rd quadrant ; 4 th quadrant ; Coordinates of centre ; Radius of circle ; Coordinates of the given po$","code":"< ? php function getQuadrant ( $ X , $ Y , $ R , $ PX , $ PY ) { if ( $ PX == $ X and $ PY == $ Y ) return 0 ; $ val = pow ( ( $ PX - $ X ) , 2 ) + pow ( ( $ PY - $ Y ) , 2 ) ; if ( $ val > pow ( $ R , 2 ) ) return -1 ; if ( $ PX > $ X and $ PY >= $ Y ) return 1 ; if ( $ PX <= $ X and $ PY > $ Y ) return 2 ; if ( $ PX < $ X and $ PY <= $ Y ) return 3 ; if ( $ PX >= $ X and $ PY < $ Y ) return 4 ; } $ X = 0 ; $ Y = 3 ; $ R = 2 ; $ PX = 1 ; $ PY = 4 ; $ ans = getQuadrant ( $ X , $ Y , $ R , $ PX , $ PY ) ; if ( $ ans == -1 ) echo \" Lies \u2581 Outside \u2581 the \u2581 circle \" ; else if ( $ ans == 0 ) echo \" Coincides \u2581 with \u2581 centre \" ; else echo $ ans , \" \u2581 Quadrant \" ; ? >"}
{"text":"Hexadecagonal number | Function to calculate hexadecagonal number ; Driver Code","code":"< ? php function hexadecagonalNum ( $ n ) { return ( ( 14 * $ n * $ n ) - 12 * $ n ) \/ 2 ; } $ n = 5 ; echo $ n , \" th \u2581 Hexadecagonal \u2581 number \u2581 : \u2581 \" ; echo hexadecagonalNum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 9 ; echo $ n , \" th \u2581 Hexadecagonal \u2581 number \u2581 : \u2581 \" ; echo hexadecagonalNum ( $ n ) ;"}
{"text":"Find the perimeter of a cylinder | Function to calculate perimeter ; Driver Code","code":"< ? php function perimeter ( $ diameter , $ height ) { return 2 * ( $ diameter + $ height ) ; } $ diameter = 5 ; $ height = 10 ; echo ( \" Perimeter \u2581 = \u2581 \" ) ; echo ( perimeter ( $ diameter , $ height ) ) ; echo ( \" \u2581 units \" ) ; ? >"}
{"text":"Find all possible coordinates of parallelogram | coordinates of A ; coordinates of B ; coordinates of C","code":"< ? php $ ax = 5 ; $ ay = 0 ; $ bx = 1 ; $ by = 1 ; $ cx = 2 ; $ cy = 5 ; echo $ ax + $ bx - $ cx , \" , \u2581 \" , $ ay + $ by - $ cy , \" STRNEWLINE \" ; echo $ ax + $ cx - $ bx , \" , \u2581 \" , $ ay + $ cy - $ by , \" STRNEWLINE \" ; echo $ cx + $ bx - $ ax , \" , \u2581 \" , $ cy + $ by - $ ax ; ? >"}
{"text":"Check whether a given point lies inside a rectangle or not | A utility function to calculate area of triangle formed by ( x1 , y1 ) , ( x2 , y2 ) and ( x3 , y3 ) ; A function to check whether point P ( x , y ) lies inside the rectangle formed by A ( x1 , y1 ) , B ( x2 , y2 ) , C ( x3 , y3 ) and D ( x4 , y4 ) ; Calculate area of rectangle ABCD ; Calculate area of triangle PAB ; Calculate area of triangle PBC ; Calculate area of triangle PCD ; Calculate area of triangle PAD ; Check if sum of A1 , A2 , A3 and A4 is same as A ; Let us check whether the point P ( 10 , 15 ) lies inside the rectangle formed by A ( 0 , 10 ) , B ( 10 , 0 ) C ( 0 , - 10 ) D ( - 10 , 0 )","code":"< ? php function area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) { return abs ( ( $ x1 * ( $ y2 - $ y3 ) + $ x2 * ( $ y3 - $ y1 ) + $ x3 * ( $ y1 - $ y2 ) ) \/ 2.0 ) ; } function check ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 , $ x , $ y ) { $ A = area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) + area ( $ x1 , $ y1 , $ x4 , $ y4 , $ x3 , $ y3 ) ; $ A1 = area ( $ x , $ y , $ x1 , $ y1 , $ x2 , $ y2 ) ; $ A2 = area ( $ x , $ y , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ A3 = area ( $ x , $ y , $ x3 , $ y3 , $ x4 , $ y4 ) ; $ A4 = area ( $ x , $ y , $ x1 , $ y1 , $ x4 , $ y4 ) ; return ( $ A == $ A1 + $ A2 + $ A3 + $ A4 ) ; } if ( check ( 0 , 10 , 10 , 0 , 0 , -10 , -10 , 0 , 10 , 15 ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text":"Pizza cut problem ( Or Circle Division by Lines ) | Function for finding maximum pieces with n cuts . ; Driver code","code":"< ? php function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) \/ 2 ; } echo findMaximumPieces ( 3 ) ; ? >"}
{"text":"A Space Optimized DP solution for 0 | val [ ] is for storing maximum profit for each weight wt [ ] is for storing weights n number of item W maximum capacity of bag mat [ 2 ] [ W + 1 ] to store final result ; matrix to store final result ; iterate through all items ; one by one traverse each element ; traverse all weights j <= W ; if i is odd that mean till now we have odd number of elements so we store result in 1 th indexed row ; check for each value ; include element ; exclude element ; if i is even that mean till now we have even number of elements so we store result in 0 th indexed row ; Return mat [ 0 ] [ W ] if n is odd , else mat [ 1 ] [ W ] ; Driver Code","code":"< ? php function KnapSack ( & $ val , & $ wt , $ n , $ W ) { $ mat = array_fill ( 0 , 2 , array_fill ( 0 , $ W + 1 , NULL ) ) ; $ i = 0 ; while ( $ i < $ n ) { $ j = 0 ; if ( $ i % 2 != 0 ) { { while ( ++ $ j <= $ W ) if ( $ wt [ $ i ] <= $ j ) $ mat [ 1 ] [ $ j ] = max ( $ val [ $ i ] + $ mat [ 0 ] [ $ j - $ wt [ $ i ] ] , $ mat [ 0 ] [ $ j ] ) ; else $ mat [ 1 ] [ $ j ] = $ mat [ 0 ] [ $ j ] ; } } else { while ( ++ $ j <= $ W ) { if ( $ wt [ $ i ] <= $ j ) $ mat [ 0 ] [ $ j ] = max ( $ val [ $ i ] + $ mat [ 1 ] [ $ j - $ wt [ $ i ] ] , $ mat [ 1 ] [ $ j ] ) ; else $ mat [ 0 ] [ $ j ] = $ mat [ 1 ] [ $ j ] ; } } $ i ++ ; } if ( $ n % 2 != 0 ) return $ mat [ 0 ] [ $ W ] ; else return $ mat [ 1 ] [ $ W ] ; } $ val = array ( 7 , 8 , 4 ) ; $ wt = array ( 3 , 8 , 6 ) ; $ W = 10 ; $ n = 3 ; echo KnapSack ( $ val , $ wt , $ n , $ W ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find original numbers from gcd ( ) every pair | PHP implementation of the approach ; Utility function to print the contents of an array ; Function to find the required numbers ; Sort array in decreasing order ; Count frequency of each element ; Size of the resultant array ; Store the highest element in the resultant array ; Decrement the frequency of that element ; Compute GCD ; Decrement GCD value by 2 ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b ) ? gcd ( $ b , $ a % $ b ) : $ b ; } function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; } function findNumbers ( $ arr , $ n ) { rsort ( $ arr ) ; $ freq = array_fill ( 0 , $ arr [ 0 ] + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ $ arr [ $ i ] ] ++ ; $ size = floor ( sqrt ( $ n ) ) ; $ brr = array_fill ( 0 , $ size , 0 ) ; $ l = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ $ arr [ $ i ] ] > 0 ) { $ brr [ $ l ] = $ arr [ $ i ] ; $ freq [ $ brr [ $ l ] ] -- ; $ l ++ ; for ( $ j = 0 ; $ j < $ l ; $ j ++ ) { if ( $ i != $ j ) { $ x = gcd ( $ arr [ $ i ] , $ brr [ $ j ] ) ; $ freq [ $ x ] -= 2 ; } } } } printArr ( $ brr , $ size ) ; } $ arr = array ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 ) ; $ n = count ( $ arr ) ; findNumbers ( $ arr , $ n ) ; ? >"}
{"text":"Rearrange Odd and Even values in Alternate Fashion in Ascending Order | PHP implementation of the above approach ; Sort the array ; $v1 = array ( ) ; to insert even values $v2 = array ( ) ; to insert odd values ; Set flag to true if first element is even ; Start rearranging array ; If first element is even ; Else , first element is Odd ; Print the rearranged array ; Driver code","code":"< ? php function AlternateRearrange ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 0 ) array_push ( $ v1 , $ arr [ $ i ] ) ; else array_push ( $ v2 , $ arr [ $ i ] ) ; $ index = 0 ; $ i = 0 ; $ j = 0 ; $ flag = false ; if ( $ arr [ 0 ] % 2 == 0 ) $ flag = true ; while ( $ index < $ n ) { if ( $ flag == true ) { $ arr [ $ index ++ ] = $ v1 [ $ i ++ ] ; $ flag = ! $ flag ; } else { $ arr [ $ index ++ ] = $ v2 [ $ j ++ ] ; $ flag = ! $ flag ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ arr = array ( 9 , 8 , 13 , 2 , 19 , 14 ) ; $ n = sizeof ( $ arr ) ; AlternateRearrange ( $ arr , $ n ) ; ? >"}
{"text":"Convert given array to Arithmetic Progression by adding an element | Function to return the number to be added ; If difference of the current consecutive elements is different from the common difference ; If number has already been chosen then it 's not possible  to add another number ; If the current different is twice the common difference then a number can be added midway from current and previous element ; Number has been chosen ; It 's not possible to maintain  the common difference ; Return last element + common difference if no element is chosen and the array is already in AP ; Else return the chosen number ; Driver code","code":"< ? php function getNumToAdd ( $ arr , $ n ) { sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; $ numToAdd = -1 ; $ numAdded = false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ diff = $ arr [ $ i ] - $ arr [ $ i - 1 ] ; if ( $ diff != $ d ) { if ( $ numAdded ) return -1 ; if ( $ diff == 2 * $ d ) { $ numToAdd = $ arr [ $ i ] - $ d ; $ numAdded = true ; } else return -1 ; } } if ( $ numToAdd == -1 ) return ( $ arr [ $ n - 1 ] + $ d ) ; return $ numToAdd ; } $ arr = array ( 1 , 3 , 5 , 7 , 11 , 13 , 15 ) ; $ n = sizeof ( $ arr ) ; echo getNumToAdd ( $ arr , $ n ) ; ? >"}
{"text":"Get maximum items when other items of total cost of an item are free | Function to count the total number of items ; Sort the prices ; Choose the last element ; Initial count of item ; Sum to keep track of the total price of free items ; If total is less than or equal to z then we will add 1 to the answer ; Driver code","code":"< ? php function items ( $ n , $ a ) { sort ( $ a ) ; $ z = $ a [ $ n - 1 ] ; $ x = 1 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ s += $ a [ $ i ] ; if ( $ s <= $ z ) $ x += 1 ; else break ; } return $ x ; } $ n = 5 ; $ a = array ( 5 , 3 , 1 , 5 , 6 ) ; echo items ( $ n , $ a ) ; ? >"}
{"text":"Minimum boxes required to carry all gifts | Function to return number of boxes ; Sort the boxes in ascending order ; Try to fit smallest box with current heaviest box ( from right side ) ; Driver program","code":"< ? php function numBoxes ( $ A , $ n , $ K ) { sort ( $ A ) ; $ i = 0 ; $ j = $ n - 1 ; $ ans = 0 ; while ( $ i <= $ j ) { $ ans ++ ; if ( $ A [ $ i ] + $ A [ $ j ] <= $ K ) $ i ++ ; $ j -- ; } return $ ans ; } $ A = array ( 3 , 2 , 2 , 1 ) ; $ K = 3 ; $ n = sizeof ( $ A ) \/ sizeof ( $ A [ 0 ] ) ; echo numBoxes ( $ A , $ n , $ K ) ; ? >"}
{"text":"Maximize the profit by selling at | Function to find profit ; Calculating profit for each gadget ; sort the profit array in descending order ; variable to calculate total profit ; check for best M profits ; Driver Code","code":"< ? php function solve ( $ N , $ M , & $ cp , & $ sp ) { $ profit = array_fill ( 0 , $ N , NULL ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ profit [ $ i ] = $ sp [ $ i ] - $ cp [ $ i ] ; rsort ( $ profit ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { if ( $ profit [ $ i ] > 0 ) $ sum += $ profit [ $ i ] ; else break ; } return $ sum ; } $ N = 5 ; $ M = 3 ; $ CP = array ( 5 , 10 , 35 , 7 , 23 ) ; $ SP = array ( 11 , 10 , 0 , 9 , 19 ) ; echo solve ( $ N , $ M , $ CP , $ SP ) ; ? >"}
{"text":"Find the largest number that can be formed with the given digits | Function to generate largest possible number with given digits ; sort the given array in descending order ; generate the number ; Driver code","code":"< ? php function findMaxNum ( & $ arr , $ n ) { rsort ( $ arr ) ; $ num = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ num = $ num * 10 + $ arr [ $ i ] ; } return $ num ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 0 ) ; $ n = sizeof ( $ arr ) ; echo findMaxNum ( $ arr , $ n ) ; ? >"}
{"text":"Minimum partitions of maximum size 2 and sum limited by given value | PHP program to count minimum number of partitions of size 2 and sum smaller than or equal to given key . ; sort the array ; if sum of ith smaller and jth larger element is less than key , then pack both numbers in a set otherwise pack the jth larger number alone in the set ; After ending of loop i will contain minimum number of sets ; Driver Code","code":"< ? php function minimumSets ( $ arr , $ n , $ key ) { $ i ; $ j ; sort ( $ arr ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i <= $ j ; ++ $ i ) if ( $ arr [ $ i ] + $ arr [ $ j ] <= $ key ) $ j -- ; return $ i ; } $ arr = array ( 3 , 5 , 3 , 4 ) ; $ n = count ( $ arr ) ; $ key = 5 ; echo minimumSets ( $ arr , $ n , $ key ) ; ? >"}
{"text":"Number of visible boxes after putting one inside another | return the minimum number of visible boxes ; New Queue of integers . ; sorting the array ; traversing the array ; checking if current element is greater than or equal to twice of front element ; Pushing each element of array ; Driver Code","code":"< ? php function minimumBox ( $ arr , $ n ) { $ q = array ( ) ; sort ( $ arr ) ; array_push ( $ q , $ arr [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ now = $ q [ 0 ] ; if ( $ arr [ $ i ] >= 2 * $ now ) array_pop ( $ q ) ; array_push ( $ q , $ arr [ $ i ] ) ; } return count ( $ q ) ; } $ arr = array ( 4 , 1 , 2 , 8 ) ; $ n = count ( $ arr ) ; echo minimumBox ( $ arr , $ n ) ; ? >"}
{"text":"Sort a binary array using one traversal | PHP Code for Sort a binary array using one traversal ; if number is smaller than 1 then swap it with j - th number ; Driver Code","code":"< ? php function sortBinaryArray ( $ a , $ n ) { $ j = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] < 1 ) { $ j ++ ; $ temp = $ a [ $ j ] ; $ a [ $ j ] = $ a [ $ i ] ; $ a [ $ i ] = $ temp ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] . \" \u2581 \" ; } $ a = array ( 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 ) ; $ n = count ( $ a ) ; sortBinaryArray ( $ a , $ n ) ; ? >"}
{"text":"Smallest element in an array that is repeated exactly ' k ' times . | finds the smallest number in arr [ ] that is repeated k times ; Since arr [ ] has numbers in range from 1 to MAX ; set count to 1 as number is present once ; If frequency of number is equal to ' k ' ; Driver code","code":"< ? php function findDuplicate ( $ arr , $ n , $ k ) { $ MAX = 1000 ; $ res = $ MAX + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) { $ count = 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count += 1 ; if ( $ count == $ k ) $ res = min ( $ res , $ arr [ $ i ] ) ; } } return $ res ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findDuplicate ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Smallest element in an array that is repeated exactly ' k ' times . | finds the smallest number in arr [ ] that is repeated k times ; Sort the array ; Find the first element with exactly k occurrences . ; Driver code","code":"< ? php function findDuplicate ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n ) { $ j ; $ count = 1 ; for ( $ j = $ i + 1 ; $ j < $ n && $ arr [ $ j ] == $ arr [ $ i ] ; $ j ++ ) $ count ++ ; if ( $ count == $ k ) return $ arr [ $ i ] ; $ i = $ j ; } return -1 ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = sizeof ( $ arr ) ; echo ( findDuplicate ( $ arr , $ n , $ k ) ) ; ? >"}
{"text":"Check if it is possible to sort an array with conditional swapping of adjacent allowed | Returns true if it is possible to sort else false ; We need to do something only if previousl element is greater ; If difference is more than one , then not possible ; Driver Code","code":"< ? php function checkForSorting ( $ arr , $ n ) { $ temp = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) { if ( $ arr [ $ i ] - $ arr [ $ i + 1 ] == 1 ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ i + 1 ] ; $ arr [ $ i + 1 ] = $ temp ; } else return false ; } } return true ; } $ arr = array ( 1 , 0 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; if ( checkForSorting ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"K | Return the K - th smallest element . ; sort ( arr , arr + n ) ; ; Checking if k lies before 1 st element ; If k is the first element of array arr [ ] . ; If k is more than last element ; If first element of array is 1. ; Reducing k by numbers before arr [ 0 ] . ; Finding k 'th smallest element  after removing array elements. ; Finding count of element between i - th and ( i - 1 ) - th element . ; Driver Code","code":"< ? php function ksmallest ( $ arr , $ n , $ k ) { sort ( $ arr ) ; if ( $ k < $ arr [ 0 ] ) return $ k ; if ( $ k == $ arr [ 0 ] ) return $ arr [ 0 ] + 1 ; if ( $ k > $ arr [ $ n - 1 ] ) return $ k + $ n ; if ( $ arr [ 0 ] == 1 ) $ k -- ; else $ k -= ( $ arr [ 0 ] - 1 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ c = $ arr [ $ i ] - $ arr [ $ i - 1 ] - 1 ; if ( $ k <= $ c ) return $ arr [ $ i - 1 ] + $ k ; else $ k -= $ c ; } return $ arr [ $ n - 1 ] + $ k ; } $ k = 1 ; $ arr = array ( 1 ) ; $ n = sizeof ( $ arr ) ; echo ksmallest ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Check whether a given number is even or odd | Returns true if n is even , else odd ; n & 1 is 1 , then odd , else even ; Driver code","code":"< ? php function isEven ( $ n ) { return ( ! ( n & 1 ) ) ; } $ n = 101 ; if ( isEven ( $ n ) == true ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text":"Count distinct occurrences as a subsequence | PHP program to count number of times S appears as a subsequence in T ; T can 't appear as a subsequence in S ; mat [ i ] [ j ] stores the count of occurrences of T ( 1. . i ) in S ( 1. . j ) . ; Initializing first column with all 0 s . An empty string can 't have another  string as suhsequence ; Initializing first row with all 1 s . An empty string is subsequence of all . ; Fill mat [ ] [ ] in bottom up manner ; If last characters don 't match,  then value is same as the value  without last character in S. ; Else value is obtained considering two cases . a ) All substrings without last character in S b ) All substrings without last characters in both . ; uncomment this to print matrix mat for ( int i = 1 ; i <= m ; i ++ , cout << endl ) for ( int j = 1 ; j <= n ; j ++ ) cout << mat [ i ] [ j ] << \" \u2581 \" ; ; Driver Code","code":"< ? php function findSubsequenceCount ( $ S , $ T ) { $ m = strlen ( $ T ) ; $ n = strlen ( $ S ) ; if ( $ m > $ n ) return 0 ; $ mat = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ mat [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ mat [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ T [ $ i - 1 ] != $ S [ $ j - 1 ] ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] ; else $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] + $ mat [ $ i - 1 ] [ $ j - 1 ] ; } } return $ mat [ $ m ] [ $ n ] ; } $ T = \" ge \" ; $ S = \" geeksforgeeks \" ; echo findSubsequenceCount ( $ S , $ T ) . \" \" ;"}
{"text":"Check if it is possible to make two matrices strictly increasing by swapping corresponding values only | Function to check whether the matrices can be made strictly increasing with the given operation ; Swap only when a [ i ] [ j ] > b [ i ] [ j ] ; Check if rows are strictly increasing ; Check if columns are strictly increasing ; Driver code","code":"< ? php function Check ( $ a , $ b , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] > $ b [ $ i ] [ $ j ] ) { $ temp = $ a [ $ i ] [ $ j ] ; $ a [ $ i ] [ $ j ] = $ b [ $ i ] [ $ j ] ; $ b [ $ i ] [ $ j ] = $ temp ; } } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m - 1 ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] >= $ a [ $ i ] [ $ j + 1 ] or $ b [ $ i ] [ $ j ] >= $ b [ $ i ] [ $ j + 1 ] ) return \" No \" ; } } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] >= $ a [ $ i + 1 ] [ $ j ] or $ b [ $ i ] [ $ j ] >= $ b [ $ i + 1 ] [ $ j ] ) return \" No \" ; } } return \" Yes \" ; } $ n = 2 ; $ m = 2 ; $ a = array ( array ( 2 , 10 ) , array ( 11 , 5 ) ) ; $ b = array ( array ( 9 , 4 ) , array ( 3 , 12 ) ) ; print ( Check ( $ a , $ b , $ n , $ m ) ) ; ? >"}
{"text":"Find the lexicographically smallest string which satisfies the given condition | Function to return the required string ; First character will always be ' a ' ; To store the resultant string ; Since length of the string should be greater than 0 and first element of array should be 1 ; Check one by one all element of given prefix array ; If the difference between any two consecutive elements of the prefix array is greater than 1 then there will be no such string possible that satisfies the given array Also , string cannot have more than 26 distinct characters ; If difference is 0 then the ( i + 1 ) th character will be same as the ith character ; If difference is 1 then the ( i + 1 ) th character will be different from the ith character ; Return the resultant string ; Driver code","code":"< ? php function smallestString ( $ N , $ A ) { $ ch = ' a ' ; $ S = \" \" ; if ( $ N < 1 $ A [ 0 ] != 1 ) { $ S = \" - 1\" ; return $ S ; } $ S . = $ ch ; $ ch ++ ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ diff = $ A [ $ i ] - $ A [ $ i - 1 ] ; if ( $ diff > 1 $ diff < 0 $ A [ $ i ] > 26 ) { $ S = \" - 1\" ; return $ S ; } else if ( $ diff == 0 ) $ S . = ' a ' ; else { $ S . = $ ch ; $ ch ++ ; } } return $ S ; } $ arr = array ( 1 , 1 , 2 , 3 , 3 ) ; $ n = sizeof ( $ arr ) ; echo ( smallestString ( $ n , $ arr ) ) ; ? >"}
{"text":"Count of alphabets whose ASCII values can be formed with the digits of N | Function that returns true if num can be formed with the digits in digits [ ] array ; Copy of the digits array ; Get last digit ; If digit array doesn 't contain  current digit ; One occurrence is used ; Remove the last digit ; Function to return the count of required alphabets ; To store the occurrences of digits ( 0 - 9 ) ; Get last digit ; Update the occurrence of the digit ; Remove the last digit ; If any lowercase character can be picked from the current digits ; If any uppercase character can be picked from the current digits ; Return the required count of alphabets ; Driver code","code":"< ? php function canBePicked ( $ digits , $ num ) { $ copyDigits = array ( ) ; for ( $ i = 0 ; $ i < sizeof ( $ digits ) ; $ i ++ ) $ copyDigits [ $ i ] = $ digits [ $ i ] ; while ( $ num > 0 ) { $ digit = $ num % 10 ; if ( $ copyDigits [ $ digit ] == 0 ) return false ; else $ copyDigits [ $ digit ] -- ; $ num = floor ( $ num \/ 10 ) ; } return true ; } function countAlphabets ( $ n ) { $ count = 0 ; $ digits = array_fill ( 0 , 10 , 0 ) ; while ( $ n > 0 ) { $ digit = $ n % 10 ; $ digits [ $ digit ] ++ ; $ n = floor ( $ n \/ 10 ) ; } for ( $ i = ord ( ' a ' ) ; $ i <= ord ( ' z ' ) ; $ i ++ ) if ( canBePicked ( $ digits , $ i ) ) $ count ++ ; for ( $ i = ord ( ' A ' ) ; $ i <= ord ( ' Z ' ) ; $ i ++ ) if ( canBePicked ( $ digits , $ i ) ) $ count ++ ; return $ count ; } $ n = 1623455078 ; echo countAlphabets ( $ n ) ; ? >"}
{"text":"Find two numbers whose sum and GCD are given | Function to find gcd of two numbers ; Function to find two numbers whose sum and gcd is given ; sum != gcd checks that both the numbers are positive or not ; Driver code","code":"< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function findTwoNumbers ( $ sum , $ gcd ) { if ( __gcd ( $ gcd , $ sum - $ gcd ) == $ gcd && $ sum != $ gcd ) echo \" a = \" \u2581 , \u2581 min ( $ gcd , \u2581 $ sum \u2581 - \u2581 $ gcd ) , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" b = \" else echo ( -1 ) ; } $ sum = 8 ; $ gcd = 2 ; findTwoNumbers ( $ sum , $ gcd ) ; ? >"}
{"text":"Find maximum distance between any city and station | Function to calculate the maximum distance between any city and its nearest station ; Initialize boolean list ; Assign True to cities containing station ; Driver code","code":"< ? php function findMaxDistance ( $ numOfCities , $ station , $ n ) { $ hasStation = array_fill ( 0 , $ numOfCities + 1 , false ) ; for ( $ city = 0 ; $ city < $ n ; $ city ++ ) { $ hasStation [ $ station [ $ city ] ] = true ; } $ dist = 0 ; $ maxDist = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ maxDist = min ( $ station [ $ i ] , $ maxDist ) ; } for ( $ city = 0 ; $ city < $ numOfCities ; $ city ++ ) { if ( $ hasStation [ $ city ] == true ) { $ maxDist = max ( ( int ) ( ( $ dist + 1 ) \/ 2 ) , $ maxDist ) ; $ dist = 0 ; } else $ dist += 1 ; } return max ( $ maxDist , $ dist ) ; } $ numOfCities = 6 ; $ station = array ( 3 , 1 ) ; $ n = count ( $ station ) ; echo \" Max \u2581 Distance : \u2581 \" . findMaxDistance ( $ numOfCities , $ station , $ n ) ; ? >"}
{"text":"Split the number into N parts such that difference between the smallest and the largest part is minimum | Function that prints the required sequence ; If we cannot split the number into exactly ' N ' parts ; If x % n == 0 then the minimum difference is 0 and all numbers are x \/ n ; upto n - ( x % n ) the values will be x \/ n after that the values will be x \/ n + 1 ; Driver code","code":"< ? php function split ( $ x , $ n ) { if ( $ x < $ n ) echo ( -1 ) ; else if ( $ x % $ n == 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ x \/ $ n ) ; echo ( \" \u2581 \" ) ; } } else { $ zp = $ n - ( $ x % $ n ) ; $ pp = $ x \/ $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i >= $ zp ) { echo ( int ) $ pp + 1 ; echo ( \" \u2581 \" ) ; } else { echo ( int ) $ pp ; echo ( \" \u2581 \" ) ; } } } } $ x = 5 ; $ n = 3 ; split ( $ x , $ n ) ; ? >"}
{"text":"Minimum time to reach a point with + t and | returns the minimum time required to reach ' X ' ; Stores the minimum time ; increment ' t ' by 1 ; update the sum ; Driver code","code":"< ? php function cal_minimum_time ( $ X ) { $ t = 0 ; $ sum = 0 ; while ( $ sum < $ X ) { $ t ++ ; $ sum = $ sum + $ t ; } return $ t ; } $ n = 6 ; $ ans = cal_minimum_time ( $ n ) ; echo \" The \u2581 minimum \u2581 time \u2581 required \u2581 is \u2581 : \u2581 \" . $ ans ; ? >"}
{"text":"Sum of minimum difference between consecutive elements of an array | function to find minimum sum of difference of consecutive element ; ul to store upper limit ll to store lower limit ; storethe lower range in ll and upper range in ul ; initialize the answer with 0 ; iterate for all ranges ; case 1 , in this case the difference will be 0 ; change upper limit and lower limit ; case 2 ; store the difference ; case 3 ; store the difference ; array of range","code":"< ? php function solve ( $ v , $ n ) { $ ans ; $ ul ; $ ll ; $ first = 0 ; $ second = 1 ; $ ll = $ v [ 0 ] [ $ first ] ; $ ul = $ v [ 0 ] [ $ second ] ; $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( ( $ v [ $ i ] [ $ first ] <= $ ul and $ v [ $ i ] [ $ first ] >= $ ll ) or ( $ v [ $ i ] [ $ second ] >= $ ll and $ v [ $ i ] [ $ second ] <= $ ul ) ) { if ( $ v [ $ i ] [ $ first ] > $ ll ) { $ ll = $ v [ $ i ] [ $ first ] ; } if ( $ v [ $ i ] [ $ second ] < $ ul ) { $ ul = $ v [ $ i ] [ $ second ] ; } } else if ( $ v [ $ i ] [ $ first ] > $ ul ) { $ ans += abs ( $ ul - $ v [ $ i ] [ $ first ] ) ; $ ul = $ v [ $ i ] [ $ first ] ; $ ll = $ v [ $ i ] [ $ first ] ; } else if ( $ v [ $ i ] [ $ second ] < $ ll ) { $ ans += abs ( $ ll - $ v [ $ i ] [ $ second ] ) ; $ ul = $ v [ $ i ] [ $ second ] ; $ ll = $ v [ $ i ] [ $ second ] ; } } return $ ans ; } $ v = array ( array ( 1 , 3 ) , array ( 2 , 5 ) , array ( 6 , 8 ) , array ( 1 , 2 ) , array ( 2 , 3 ) ) ; $ n = 5 ; echo ( solve ( $ v , $ n ) ) ; ? >"}
{"text":"Find the Largest Cube formed by Deleting minimum Digits from a number | Returns vector of Pre Processed perfect cubes ; convert the cube to string and push into preProcessedCubes vector ; Utility function for findLargestCube ( ) . Returns the Largest cube number that can be formed ; reverse the preProcessed cubes so that we have the largest cube in the beginning of the vector ; iterate over all cubes ; check if the current digit of the cube matches with that of the number num ; if control reaches here , the its not possible to form a perfect cube ; wrapper for findLargestCubeUtil ( ) ; pre process perfect cubes ; convert number n to String ; Driver Code","code":"< ? php function preProcess ( $ n ) { $ preProcessedCubes = array ( ) ; for ( $ i = 1 ; $ i * $ i * $ i < $ n ; $ i ++ ) { $ iThCube = $ i * $ i * $ i ; $ cubeString = strval ( $ iThCube ) ; array_push ( $ preProcessedCubes , $ cubeString ) ; } return $ preProcessedCubes ; } function findLargestCubeUtil ( $ num , $ preProcessedCubes ) { $ preProcessedCubes = array_reverse ( $ preProcessedCubes ) ; $ totalCubes = count ( $ preProcessedCubes ) ; for ( $ i = 0 ; $ i < $ totalCubes ; $ i ++ ) { $ currCube = $ preProcessedCubes [ $ i ] ; $ digitsInCube = strlen ( $ currCube ) ; $ index = 0 ; $ digitsInNumber = strlen ( $ num ) ; for ( $ j = 0 ; $ j < $ digitsInNumber ; $ j ++ ) { if ( $ num [ $ j ] == $ currCube [ $ index ] ) $ index += 1 ; if ( $ digitsInCube == $ index ) return $ currCube ; } } return \" Not \u2581 Possible \" ; } function findLargestCube ( $ n ) { $ preProcessedCubes = preProcess ( $ n ) ; $ num = strval ( $ n ) ; $ ans = findLargestCubeUtil ( $ num , $ preProcessedCubes ) ; print ( \" Largest \u2581 Cube \u2581 that \u2581 can \u2581 be \u2581 formed \u2581 from \u2581 \" . $ n . \" \u2581 is \u2581 \" . $ ans . \" STRNEWLINE \" ) ; } $ n = 4125 ; findLargestCube ( $ n ) ; $ n = 876 ; findLargestCube ( $ n ) ? >"}
{"text":"Print a closest string that does not contain adjacent duplicates | Function to print simple string ; If any two adjacent characters are equal ; Initialize it to ' a ' ; Traverse the loop until it is different from the left and right letter . ; Driver Code","code":"< ? php function noAdjacentDup ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ s [ $ i ] = ' a ' ; while ( $ s [ $ i ] == $ s [ $ i - 1 ] || ( $ i + 1 < $ n && $ s [ $ i ] == $ s [ $ i + 1 ] ) ) $ s [ $ i ] ++ ; $ i ++ ; } } return $ s ; } $ s = \" geeksforgeeks \" ; echo ( noAdjacentDup ( $ s ) ) ; ? >"}
{"text":"Array element moved by k using single moves | PHP program to find winner of game ; if the number of steps is more then n - 1 , ; initially the best is 0 and no . of wins is 0. ; traverse through all the numbers ; if the value of array is more then that of previous best ; best is replaced by a [ i ] ; if not the first index ; no of wins is 1 now ; if it wins ; if any position has more then k wins then return ; Maximum element will be winner because we move smaller element at end and repeat the process . ; Driver Code","code":"< ? php function winner ( $ a , $ n , $ k ) { if ( $ k >= $ n - 1 ) return $ n ; $ best = 0 ; $ times = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ best ) { $ best = $ a [ $ i ] ; if ( $ i ) $ times = 1 ; } else $ times += 1 ; if ( $ times >= $ k ) return $ best ; } return $ best ; } $ a = array ( 2 , 1 , 3 , 4 , 5 ) ; $ n = sizeof ( $ a ) ; $ k = 2 ; echo ( winner ( $ a , $ n , $ k ) ) ; ? >"}
{"text":"Queries for bitwise OR in the index range [ L , R ] of the given array | PHP implementation of the approach ; Array to store bit - wise prefix count ; Function to find the prefix sum ; Loop for each bit ; Loop to find prefix count ; Function to answer query ; To store the answer ; Loop for each bit ; To store the number of variables with ith bit set ; Condition for ith bit of answer to be set ; Driver code","code":"< ? php $ MAX = 100000 ; $ bitscount = 32 ; $ prefix_count = array_fill ( 0 , $ bitscount , array_fill ( 0 , $ MAX , NULL ) ) ; function findPrefixCount ( & $ arr , $ n ) { global $ MAX , $ bitscount , $ prefix_count ; for ( $ i = 0 ; $ i < $ bitscount ; $ i ++ ) { $ prefix_count [ $ i ] [ 0 ] = ( ( $ arr [ 0 ] >> $ i ) & 1 ) ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ prefix_count [ $ i ] [ $ j ] = ( ( $ arr [ $ j ] >> $ i ) & 1 ) ; $ prefix_count [ $ i ] [ $ j ] += $ prefix_count [ $ i ] [ $ j - 1 ] ; } } } function rangeOr ( $ l , $ r ) { global $ MAX , $ bitscount , $ prefix_count ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ bitscount ; $ i ++ ) { if ( $ l == 0 ) $ x = $ prefix_count [ $ i ] [ $ r ] ; else $ x = $ prefix_count [ $ i ] [ $ r ] - $ prefix_count [ $ i ] [ l - 1 ] ; if ( $ x != 0 ) $ ans = ( $ ans | ( 1 << $ i ) ) ; } return $ ans ; } $ arr = array ( 7 , 5 , 3 , 5 , 2 , 3 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; findPrefixCount ( $ arr , $ n ) ; $ queries = array ( array ( 1 , 3 ) , array ( 4 , 5 ) ) ; $ q = sizeof ( $ queries ) \/ sizeof ( $ queries [ 0 ] ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo rangeOr ( $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text":"Bellman Ford Algorithm ( Simple Implementation ) | The main function that finds shortest distances from src to all other vertices using Bellman - Ford algorithm . The function also detects negative weight cycle The row graph [ i ] represents i - th edge with three values u , v and w . ; Initialize distance of all vertices as infinite . ; initialize distance of source as 0 ; Relax all edges | V | - 1 times . A simple shortest path from src to any other vertex can have at - most | V | - 1 edges ; check for negative - weight cycles . The above step guarantees shortest distances if graph doesn 't contain  negative weight cycle. If we get a  shorter path, then there is a cycle. ; Every edge has three values ( u , v , w ) where the edge is from vertex u to v . And weight of the edge is w .","code":"< ? php function BellmanFord ( $ graph , $ V , $ E , $ src ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ V ; $ i ++ ) $ dis [ $ i ] = PHP_INT_MAX ; $ dis [ $ src ] = 0 ; for ( $ i = 0 ; $ i < $ V - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ E ; $ j ++ ) { if ( $ dis [ $ graph [ $ j ] [ 0 ] ] != PHP_INT_MAX && $ dis [ $ graph [ $ j ] [ 0 ] ] + $ graph [ $ j ] [ 2 ] < $ dis [ $ graph [ $ j ] [ 1 ] ] ) $ dis [ $ graph [ $ j ] [ 1 ] ] = $ dis [ $ graph [ $ j ] [ 0 ] ] + $ graph [ $ j ] [ 2 ] ; } } for ( $ i = 0 ; $ i < $ E ; $ i ++ ) { $ x = $ graph [ $ i ] [ 0 ] ; $ y = $ graph [ $ i ] [ 1 ] ; $ weight = $ graph [ $ i ] [ 2 ] ; if ( $ dis [ $ x ] != PHP_INT_MAX && $ dis [ $ x ] + $ weight < $ dis [ $ y ] ) echo \" Graph \u2581 contains \u2581 negative \u2581 weight \u2581 cycle \u2581 STRNEWLINE \" ; } echo \" Vertex \u2581 Distance \u2581 from \u2581 Source \u2581 STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ V ; $ i ++ ) echo $ i , \" TABSYMBOL TABSYMBOL \" , $ dis [ $ i ] , \" STRNEWLINE \" ; } $ graph = array ( array ( 0 , 1 , -1 ) , array ( 0 , 2 , 4 ) , array ( 1 , 2 , 3 ) , array ( 1 , 3 , 2 ) , array ( 1 , 4 , 2 ) , array ( 3 , 2 , 5 ) , array ( 3 , 1 , 1 ) , array ( 4 , 3 , -3 ) ) ; BellmanFord ( $ graph , $ V , $ E , 0 ) ; ? >"}
{"text":"Find the maximum number of composite summands of a number | PHP implementation of the above approach ; Function to generate the dp array ; combination of three integers ; take the maximum number of summands ; Function to find the maximum number of summands ; If n is a smaller number , less than 16 return dp [ n ] ; Else , find a minimal number t as explained in solution ; Driver code ; Generate dp array","code":"< ? php $ maxn = 16 ; function precompute ( ) { $ dp = array_fill ( 0 , $ GLOBALS [ ' axn ' , -1 ) ; $ dp [ 0 ] = 0 ; $ v = array ( 4 , 6 , 9 ) ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' axn ' ; ++ $ i ) { for ( $ k = 0 ; $ k < 3 ; $ k ++ ) { $ j = $ v [ $ k ] ; if ( $ i >= $ j && $ dp [ $ i - $ j ] != -1 ) { $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - $ j ] + 1 ) ; } } } return $ dp ; } function Maximum_Summands ( $ dp , $ n ) { if ( $ n < $ GLOBALS [ ' axn ' ) return $ dp [ $ n ] ; else { $ t = ( $ n - $ GLOBALS [ ' axn ' ) \/ 4 + 1 ; return $ t + $ dp [ $ n - 4 * $ t ] ; } } $ n = 12 ; $ dp = precompute ( ) ; echo Maximum_Summands ( $ dp , $ n ) ; ? >"}
{"text":"Find sub | PHP implementation of the approach ; Function to return the sum of the sub - matrix ; Function that returns true if it is possible to find the sub - matrix with required sum ; 2 - D array to store the sum of all the sub - matrices ; Filling of dp [ ] [ ] array ; Checking for each possible sub - matrix of size k X k ; Sub - matrix with the given sum not found ; Driver code ; Function call","code":"< ? php $ GLOBALS [ ' N ' ] = 4 ; function getSum ( $ r1 , $ r2 , $ c1 , $ c2 , $ dp ) { return $ dp [ $ r2 ] [ $ c2 ] - $ dp [ $ r2 ] [ $ c1 ] - $ dp [ $ r1 ] [ $ c2 ] + $ dp [ $ r1 ] [ $ c1 ] ; } function sumFound ( $ K , $ S , $ grid ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) $ dp [ $ i + 1 ] [ $ j + 1 ] = $ dp [ $ i + 1 ] [ $ j ] + $ dp [ $ i ] [ $ j + 1 ] - $ dp [ $ i ] [ $ j ] + $ grid [ $ i ] [ $ j ] ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) { $ sum = getSum ( $ i , $ i + $ K , $ j , $ j + $ K , $ dp ) ; if ( $ sum == $ S ) return true ; } return false ; } $ grid = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 9 , 10 , 11 , 12 ) , array ( 13 , 14 , 15 , 16 ) ) ; $ K = 2 ; $ S = 14 ; if ( sumFound ( $ K , $ S , $ grid ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum number of operations required to sum to binary string S | Function to return the minimum operations required to sum to a number reprented by the binary string S ; Reverse the string to consider it from LSB to MSB ; initialise the dp table ; If S [ 0 ] = '0' , there is no need to perform any operation ; If S [ 0 ] = '1' , just perform a single operation ( i . e Add 2 ^ 0 ) ; Irrespective of the LSB , dp [ 0 ] [ 1 ] is always 1 as there is always the need of making the suffix of the binary string of the form \"11 . . . . 1\" as suggested by the definition of dp [ i ] [ 1 ] ; Transition from dp [ i - 1 ] [ 0 ] ; 1. Transition from dp [ i - 1 ] [ 1 ] by just doing 1 extra operation of subtracting 2 ^ i 2. Transition from dp [ i - 1 ] [ 0 ] by just doing 1 extra operation of subtracting 2 ^ ( i + 1 ) ; Transition from dp [ i - 1 ] [ 1 ] ; 1. Transition from dp [ i - 1 ] [ 1 ] by just doing 1 extra operation of adding 2 ^ ( i + 1 ) 2. Transition from dp [ i - 1 ] [ 0 ] by just doing 1 extra operation of adding 2 ^ i ; Driver Code","code":"< ? php function findMinOperations ( $ S ) { $ p = strrev ( $ S ) ; $ n = strlen ( $ p ) ; $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , 2 , NULL ) ) ; if ( $ p [ 0 ] == '0' ) { $ dp [ 0 ] [ 0 ] = 0 ; } else { $ dp [ 0 ] [ 0 ] = 1 ; } $ dp [ 0 ] [ 1 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ p [ $ i ] == '0' ) { $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 0 ] ; $ dp [ $ i ] [ 1 ] = 1 + min ( $ dp [ $ i - 1 ] [ 1 ] , $ dp [ $ i - 1 ] [ 0 ] ) ; } else { $ dp [ $ i ] [ 1 ] = $ dp [ $ i - 1 ] [ 1 ] ; $ dp [ $ i ] [ 0 ] = 1 + min ( $ dp [ $ i - 1 ] [ 0 ] , $ dp [ $ i - 1 ] [ 1 ] ) ; } } return $ dp [ $ n - 1 ] [ 0 ] ; } $ S = \"100\" ; echo findMinOperations ( $ S ) . \" STRNEWLINE \" ; $ S = \"111\" ; echo findMinOperations ( $ S ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text":"K | Function that finds the Nth element of K - Fibonacci series ; If N is less than K then the element is '1' ; first k elements are 1 ; ( K + 1 ) th element is K ; find the elements of the K - Fibonacci series ; subtract the element at index i - k - 1 and add the element at index i - i from the sum ( sum contains the sum of previous ' K ' elements ) ; set the new sum ; Driver code ; get the Nth value of K - Fibonacci series","code":"< ? php function solve ( $ N , $ K ) { $ Array = array_fill ( 0 , $ N + 1 , NULL ) ; if ( $ N <= $ K ) { echo \"1\" . \" STRNEWLINE \" ; return ; } $ i = 0 ; $ sum = $ K ; for ( $ i = 1 ; $ i <= $ K ; ++ $ i ) { $ Array [ $ i ] = 1 ; } $ Array [ $ i ] = $ sum ; for ( $ i = $ K + 2 ; $ i <= $ N ; ++ $ i ) { $ Array [ $ i ] = $ sum - $ Array [ $ i - $ K - 1 ] + $ Array [ $ i - 1 ] ; $ sum = $ Array [ $ i ] ; } echo $ Array [ $ N ] . \" STRNEWLINE \" ; } $ N = 4 ; $ K = 2 ; solve ( $ N , $ K ) ; ? >"}
{"text":"Minimum sum possible of any bracket sequence of length N | PHP program to find the Minimum sum possible of any bracket sequence of length N using the given values for brackets ; DP array ; Recursive function to check for correct bracket expression ; \/ Not a proper bracket expression ; If reaches at end ; \/ If proper bracket expression ; else if not , return max ; If already visited ; To find out minimum sum ; Driver Code","code":"< ? php $ MAX_VAL = 10000000 ; $ dp = array_fill ( 0 , 100 , array_fill ( 0 , 100 , -1 ) ) ; function find ( $ index , $ openbrk , $ n , $ adj ) { global $ MAX_VAL ; global $ dp ; if ( $ openbrk < 0 ) return $ MAX_VAL ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) { return 0 ; } return $ MAX_VAL ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; $ dp [ $ index ] [ $ openbrk ] = min ( $ adj [ $ index ] [ 1 ] + find ( $ index + 1 , $ openbrk + 1 , $ n , $ adj ) , $ adj [ $ index ] [ 0 ] + find ( $ index + 1 , $ openbrk - 1 , $ n , $ adj ) ) ; return $ dp [ $ index ] [ $ openbrk ] ; } $ n = 4 ; $ adj = array ( array ( 5000 , 3000 ) , array ( 6000 , 2000 ) , array ( 8000 , 1000 ) , array ( 9000 , 6000 ) ) ; echo find ( 1 , 1 , $ n , $ adj ) + $ adj [ 0 ] [ 1 ] ; ? >"}
{"text":"Maximum length of segments of 0 ' s \u2581 and \u2581 1' s | Recursive Function to find total length of the array where 1 is greater than zero ; If reaches till end ; If $dp is saved ; Finding for each length ; If the character scanned is 1 ; If one is greater than zero , add total length scanned till now ; Continue with next length ; Return the value for $start index ; Driver Code ; Size of string ; Calling the function to find the value of function","code":"< ? php function find ( $ start , $ adj , $ n , $ dp ) { if ( $ start == $ n ) return 0 ; if ( $ dp [ $ start ] != -1 ) return $ dp [ $ start ] ; $ dp [ $ start ] = 0 ; $ one = 0 ; $ zero = 0 ; for ( $ k = $ start ; $ k < $ n ; $ k ++ ) { if ( $ adj [ $ k ] == '1' ) $ one ++ ; else $ zero ++ ; if ( $ one > $ zero ) $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) + $ k - $ start + 1 ) ; else $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) ) ; } return $ dp [ $ start ] ; } $ adj = \"100110001010001\" ; $ n = strlen ( $ adj ) ; $ dp = array_fill ( 0 , $ n + 1 , -1 ) ; echo find ( 0 , $ adj , $ n , $ dp ) ; ? >"}
{"text":"Length of longest common subsequence containing vowels | function to check whether ' ch ' is a vowel or not ; function to find the length of longest common subsequence which contains all vowel characters ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] which contains all vowel characters ; Driver Code","code":"< ? php function isVowel ( $ ch ) { if ( $ ch == ' a ' $ ch == ' e ' $ ch == ' i ' $ ch == ' o ' $ ch == ' u ' ) return true ; return false ; } function lcs ( $ X , $ Y , $ m , $ n ) { $ L = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) && isVowel ( $ X [ $ i - 1 ] ) ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } return $ L [ $ m ] [ $ n ] ; } $ X = \" aieef \" ; $ Y = \" klaief \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; echo \" Length \u2581 of \u2581 LCS \u2581 = \u2581 \" . lcs ( $ X , $ Y , $ m , $ n ) ; ? >"}
{"text":"Minimum number of single digit primes required whose sum is equal to N | function to check if i - th index is valid or not ; function to find the minimum number of single digit prime numbers required which when summed up equals to a given number N . ; Not possible ; Driver Code","code":"< ? php function check ( $ i , $ val ) { if ( $ i - $ val < 0 ) return false ; return true ; } function MinimumPrimes ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = 1e9 ; $ dp [ 0 ] = $ dp [ 2 ] = $ dp [ 3 ] = $ dp [ 5 ] = $ dp [ 7 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( check ( $ i , 2 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 2 ] ) ; if ( check ( $ i , 3 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 3 ] ) ; if ( check ( $ i , 5 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 5 ] ) ; if ( check ( $ i , 7 ) ) $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - 7 ] ) ; } if ( $ dp [ $ n ] == ( 1e9 ) ) return -1 ; else return $ dp [ $ n ] ; } $ n = 12 ; $ minimal = MinimumPrimes ( $ n ) ; if ( $ minimal != -1 ) { echo ( \" Minimum \u2581 number \u2581 of \u2581 single \u2581 \" . \" digit \u2581 primes \u2581 required \u2581 : \" ) ; echo ( $ minimal ) ; } else { echo ( \" Not \u2581 possible \" ) ; } ? >"}
{"text":"Number of Unique BST with a given key | Dynamic Programming | Function to find number of unique BST ; DP to store the number of unique BST with key i ; Base case ; fill the dp table in top - down approach . ; n - i in right * i - 1 in left ; Driver Code","code":"< ? php function numberOfBST ( $ n ) { $ dp = array ( $ n + 1 ) ; for ( $ i = 0 ; $ i <= $ n + 1 ; $ i ++ ) $ dp [ $ i ] = 0 ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ dp [ $ i ] += ( ( $ dp [ $ i - $ j ] ) * ( $ dp [ $ j - 1 ] ) ) ; } } return $ dp [ $ n ] ; } $ n = 3 ; echo \" Number \u2581 of \u2581 structurally \u2581 \" . \" Unique \u2581 BST \u2581 with \u2581 \" , $ n , \" \u2581 keys \u2581 are \u2581 : \u2581 \" , numberOfBST ( $ n ) ; ? >"}
{"text":"Sum of product of r and rth Binomial Coefficient ( r * nCr ) | Return summation of r * nCr ; Driver Code","code":"< ? php function summation ( $ n ) { return $ n << ( $ n - 1 ) ; } $ n = 2 ; echo summation ( $ n ) ; ? >"}
{"text":"Maximum Product Subarray | Added negative product case | Function to find maximum subarray product . ; As maximum product can be negative , so initialize ans with minimum integer value . ; Variable to store maximum product until current value . ; Variable to store minimum product until current value . ; Variable used during updation of maximum product and minimum product . is prevMax ; If current element is positive , update maxval . Update minval if it is negative . ; If current element is zero , maximum product cannot end at current element . Update minval with 1 and maxval with 0. maxval is updated to 0 as in case all other elements are negative , then maxval is 0. ; If current element is negative , then new value of maxval is previous minval * arr [ i ] and new value of minval is previous maxval * arr [ i ] . Before updating maxval , store its previous value in prevMax to be used to update minval . ; Update ans if necessary . ; If maxval is zero , then to calculate product for next iteration , it should be set to 1 as maximum product subarray does not include 0. The minimum possible value to be considered in maximum product subarray is already stored in minval , so when maxval is negative it is set to 1. ; Driver Code","code":"< ? php function findMaxProduct ( & $ arr , $ n ) { $ ans = 0 ; $ maxval = 1 ; $ minval = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) { $ maxval = $ maxval * $ arr [ i ] ; $ minval = min ( 1 , $ minval * $ arr [ $ i ] ) ; } else if ( $ arr [ $ i ] == 0 ) { $ minval = 1 ; $ maxval = 0 ; } else if ( $ arr [ $ i ] < 0 ) { $ prevMax = $ maxval ; $ maxval = $ minval * $ arr [ $ i ] ; $ minval = $ prevMax * $ arr [ $ i ] ; } $ ans = max ( $ ans , $ maxval ) ; if ( $ maxval <= 0 ) { $ maxval = 1 ; } } return $ ans ; } $ arr = array ( 0 , -4 , 0 , -2 ) ; $ n = sizeof ( $ arr ) ; echo findMaxProduct ( $ arr , $ n ) ; ? >"}
{"text":"Maximum and Minimum Values of an Algebraic Expression | PHP program to find the maximum and minimum values of an Algebraic expression of given form ; Finding sum of array elements ; shifting the integers by 50 so that they become positive ; dp [ i ] [ j ] represents true if sum j can be reachable by choosing i numbers ; if dp [ i ] [ j ] is true , that means it is possible to select i numbers from ( n + m ) numbers to sum upto j ; k can be at max n because the left expression has n numbers ; checking if a particular sum can be reachable by choosing n numbers ; getting the actual sum as we shifted the numbers by 50 to avoid negative indexing in array ; Driver Code","code":"< ? php function minMaxValues ( $ arr , $ n , $ m ) { $ sum = 0 ; $ INF = 1000000000 ; $ MAX = 50 ; for ( $ i = 0 ; $ i < ( $ n + $ m ) ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ arr [ $ i ] += 50 ; } $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ MAX + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX * $ MAX + 1 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; } $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i < ( $ n + $ m ) ; $ i ++ ) { for ( $ k = min ( $ n , $ i + 1 ) ; $ k >= 1 ; $ k -- ) { for ( $ j = 0 ; $ j < $ MAX * $ MAX + 1 ; $ j ++ ) { if ( $ dp [ $ k - 1 ] [ $ j ] ) $ dp [ $ k ] [ $ j + $ arr [ $ i ] ] = 1 ; } } } $ max_value = -1 * $ INF ; $ min_value = $ INF ; for ( $ i = 0 ; $ i < $ MAX * $ MAX + 1 ; $ i ++ ) { if ( $ dp [ $ n ] [ $ i ] ) { $ temp = $ i - 50 * $ n ; $ max_value = max ( $ max_value , $ temp * ( $ sum - $ temp ) ) ; $ min_value = min ( $ min_value , $ temp * ( $ sum - $ temp ) ) ; } } echo ( \" Maximum \u2581 Value : \u2581 \" . $ max_value . \" \" . \u2581 \" Minimum Value : \" . \u2581 $ min _ value . \u2581 \" \" } $ n = 2 ; $ m = 2 ; $ arr = [ 1 , 2 , 3 , 4 ] ; minMaxValues ( $ arr , $ n , $ m ) ; ? >"}
{"text":"Golomb sequence | Return the nth element of Golomb sequence ; base case ; Recursive Step ; Print the first n term of Golomb Sequence ; Finding first n terms of Golomb Sequence . ; Driver Code","code":"< ? php function findGolomb ( $ n ) { if ( $ n == 1 ) return 1 ; return 1 + findGolomb ( $ n - findGolomb ( findGolomb ( $ n - 1 ) ) ) ; } function printGolomb ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo findGolomb ( $ i ) , \" \u2581 \" ; } $ n = 9 ; printGolomb ( $ n ) ; ? >"}
{"text":"Printing Items in 0 \/ 1 Knapsack | Prints the items which are kept in a knapsack of capacity W ; Build table K [ ] [ ] in bottom up manner ; stores the result of Knapsack ; either the result comes from the top ( K [ i - 1 ] [ w ] ) or from ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] ) as in Knapsack table . If it comes from the latter one \/ it means the item is included . ; This item is included . ; Since this weight is included its value is deducted ; Driver code","code":"< ? php function printknapSack ( $ W , & $ wt , & $ val , $ n ) { $ K = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ W + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ w = 0 ; $ w <= $ W ; $ w ++ ) { if ( $ i == 0 $ w == 0 ) $ K [ $ i ] [ $ w ] = 0 ; else if ( $ wt [ $ i - 1 ] <= $ w ) $ K [ $ i ] [ $ w ] = max ( $ val [ $ i - 1 ] + $ K [ $ i - 1 ] [ $ w - $ wt [ $ i - 1 ] ] , $ K [ $ i - 1 ] [ $ w ] ) ; else $ K [ $ i ] [ $ w ] = $ K [ $ i - 1 ] [ $ w ] ; } } $ res = $ K [ $ n ] [ $ W ] ; echo $ res . \" STRNEWLINE \" ; $ w = $ W ; for ( $ i = $ n ; $ i > 0 && $ res > 0 ; $ i -- ) { if ( $ res == $ K [ $ i - 1 ] [ $ w ] ) continue ; else { echo $ wt [ $ i - 1 ] . \" \" ; $ res = $ res - $ val [ $ i - 1 ] ; $ w = $ w - $ wt [ $ i - 1 ] ; } } } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = sizeof ( $ val ) ; printknapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text":"Maximum number of segments of lengths a , b and c | function to find the maximum number of segments ; stores the maximum number of segments each index can have ; initialize with - 1 ; 0 th index will have 0 segments base case ; traverse for all possible segments till n ; conditions if ( $i + $a <= $n ) avoid buffer overflow ; if ( $i + $b <= $n ) avoid buffer overflow ; if ( $i + $c <= $n ) avoid buffer overflow ; Driver code","code":"< ? php function maximumSegments ( $ n , $ a , $ b , $ c ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n + 10 ; $ i ++ ) $ dp [ $ i ] = -1 ; $ dp [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ dp [ $ i ] != -1 ) { $ dp [ $ i + $ a ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ a ] ) ; $ dp [ $ i + $ b ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ b ] ) ; $ dp [ $ i + $ c ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ c ] ) ; } } return $ dp [ $ n ] ; } $ n = 7 ; $ a = 5 ; $ b = 2 ; $ c = 5 ; echo ( maximumSegments ( $ n , $ a , $ b , $ c ) ) ; ? >"}
{"text":"Print n terms of Newman | Function to find the n - th element ; Declare array to store sequence ; Driver Code","code":"< ? php function sequence ( $ n ) { $ f = array ( 0 ) ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; echo $ f [ 1 ] , \" \" \u2581 , \u2581 $ f [ 2 ] \u2581 , \u2581 \" \" for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ f [ $ i ] = $ f [ $ f [ $ i - 1 ] ] + $ f [ $ i - $ f [ $ i - 1 ] ] ; echo $ f [ $ i ] , \" \" ; } } { $ n = 13 ; sequence ( $ n ) ; return 0 ; } ? >"}
{"text":"Entringer Number | Return Entringer Number E ( n , k ) ; Base cases ; Finding dp [ i ] [ j ] ; Driven Code","code":"< ? php function zigzag ( $ n , $ k ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ i - $ j ] ; } return $ dp [ $ n ] [ $ k ] ; } $ n = 4 ; $ k = 3 ; echo zigzag ( $ n , $ k ) ; ? >"}
{"text":"Lobb Number | PHP Program to find Ln , m Lobb Number . ; Returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using p reviously stored values ; Return the Lm , n Lobb Number . ; Driven Code","code":"< ? php $ MAXN = 109 ; function binomialCoeff ( $ n , $ k ) { $ C = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function lobb ( $ n , int $ m ) { return ( ( 2 * $ m + 1 ) * binomialCoeff ( 2 * $ n , $ m + $ n ) ) \/ ( $ m + $ n + 1 ) ; } $ n = 5 ; $ m = 3 ; echo lobb ( $ n , $ m ) ; ? >"}
{"text":"Count of arrays having consecutive element with different values | PHP Program to find count of arrays . ; Return the number of arrays with given constartints . ; Initialising dp [ 0 ] and dp [ 1 ] . ; Computing f ( i ) for each 2 <= i <= n . ; Driven Code","code":"< ? php $ MAXN = 109 ; function countarray ( $ n , $ k , $ x ) { $ dp = array ( 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = ( $ k - 2 ) * $ dp [ $ i - 1 ] + ( $ k - 1 ) * $ dp [ $ i - 2 ] ; return ( $ x == 1 ? ( $ k - 1 ) * $ dp [ $ n - 2 ] : $ dp [ $ n - 1 ] ) ; } $ n = 4 ; $ k = 3 ; $ x = 2 ; echo countarray ( $ n , $ k , $ x ) ; ? >"}
{"text":"Number of palindromic subsequences of length k where k <= 3 | PHP program to count number of subsequences of given length . ; Precompute the prefix and suffix array . ; Precompute the prefix 2D array ; Precompute the Suffix 2D array . ; Find the number of palindromic subsequence of length k ; If k is 1. ; If k is 2 ; Adding all the products of prefix array ; For k greater than 2. Adding all the products of value of prefix and suffix array . ; Driver Code","code":"< ? php $ MAX = 100 ; $ MAX_CHAR = 26 ; function precompute ( $ s , $ n , & $ l , & $ r ) { global $ MAX , $ MAX_CHAR ; $ l [ ord ( $ s [ 0 ] ) - ord ( ' a ' ) ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) $ l [ $ j ] [ $ i ] += $ l [ $ j ] [ $ i - 1 ] ; $ l [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] [ $ i ] ++ ; } $ r [ ord ( $ s [ $ n - 1 ] ) - ord ( ' a ' ) ] [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) $ r [ $ j ] [ $ i ] += $ r [ $ j ] [ $ i + 1 ] ; $ r [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] [ $ i ] ++ ; } } function countPalindromes ( $ k , $ n , & $ l , & $ r ) { global $ MAX , $ MAX_CHAR ; $ ans = 0 ; if ( $ k == 1 ) { for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ ans += $ l [ $ i ] [ $ n - 1 ] ; return $ ans ; } if ( $ k == 2 ) { for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ ans += ( ( $ l [ $ i ] [ $ n - 1 ] * ( $ l [ $ i ] [ $ n - 1 ] - 1 ) ) \/ 2 ) ; return $ ans ; } for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) $ ans += $ l [ $ j ] [ $ i - 1 ] * $ r [ $ j ] [ $ i + 1 ] ; return $ ans ; } $ s = \" aabab \" ; $ k = 2 ; $ n = strlen ( $ s ) ; $ l = array_fill ( 0 , $ MAX_CHAR , array_fill ( 0 , $ MAX , NULL ) ) ; $ r = array_fill ( 0 , $ MAX_CHAR , array_fill ( 0 , $ MAX , NULL ) ) ; precompute ( $ s , $ n , $ l , $ r ) ; echo countPalindromes ( $ k , $ n , $ l , $ r ) . \" \" ; ? >"}
{"text":"Maximum sum path in a matrix from top to bottom | PHP implementation to find the maximum sum path in a matrix ; function to find the maximum sum path in a matric ; if there is a single element only ; dp [ ] [ ] matrix to store the results of each iteration ; base case , copying elements of last row ; building up the dp [ ] [ ] matrix from bottom to the top row ; finding the maximum diagonal element in the ( i + 1 ) th row if that cell exists ; adding that ' max ' element to the mat [ i ] [ j ] element ; finding the maximum value from the first row of dp [ ] [ ] ; required maximum sum ; Driver Code","code":"< ? php $ SIZE = 10 ; function maxSum ( $ mat , $ n ) { if ( $ n == 1 ) return $ mat [ 0 ] [ 0 ] ; $ dp = array ( array ( ) ) ; $ maxSum = PHP_INT_MIN ; $ max ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ n - 1 ] [ $ j ] = $ mat [ $ n - 1 ] [ $ j ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ max = PHP_INT_MIN ; if ( ( ( $ j - 1 ) >= 0 ) and ( $ max < $ dp [ $ i + 1 ] [ $ j - 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j - 1 ] ; if ( ( ( $ j + 1 ) < $ n ) and ( $ max < $ dp [ $ i + 1 ] [ $ j + 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j + 1 ] ; $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ max ; } } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ maxSum < $ dp [ 0 ] [ $ j ] ) $ maxSum = $ dp [ 0 ] [ $ j ] ; return $ maxSum ; } $ mat = array ( array ( 5 , 6 , 1 , 7 ) , array ( -2 , 10 , 8 , -1 ) , array ( 3 , -7 , -9 , 11 ) , array ( 12 , -4 , 2 , 6 ) ) ; $ n = 4 ; echo \" Maximum \u2581 Sum \u2581 = \u2581 \" , maxSum ( $ mat , $ n ) ; ? >"}
{"text":"Longest Repeated Subsequence | This function mainly returns LCS ( str , str ) with a condition that same characters at same index are not considered . ; THIS PART OF CODE IS SAME AS BELOW POST . IT FILLS dp [ ] [ ] https : www . geeksforgeeks . org \/ longest - repeating - subsequence \/ OR the code mentioned above . ; THIS PART OF CODE FINDS THE RESULT STRING USING DP [ ] [ ] , Initialize result ; Traverse dp [ ] [ ] from bottom right ; If this cell is same as diagonally adjacent cell just above it , then same characters are present at str [ i - 1 ] and str [ j - 1 ] . Append any of them to result . ; Otherwise we move to the side that that gave us maximum result ; Since we traverse dp [ ] [ ] from bottom , we get result in reverse order . ; Driver Code","code":"< ? php function longestRepeatedSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; $ res = \" \" ; $ i = $ n ; $ j = $ n ; while ( $ i > 0 && $ j > 0 ) { if ( $ dp [ $ i ] [ $ j ] == $ dp [ $ i - 1 ] [ $ j - 1 ] + 1 ) { $ res = $ res . $ str [ $ i - 1 ] ; $ i -- ; $ j -- ; } else if ( $ dp [ $ i ] [ $ j ] == $ dp [ $ i - 1 ] [ $ j ] ) $ i -- ; else $ j -- ; } return strrev ( $ res ) ; } $ str = \" AABEBCDD \" ; echo longestRepeatedSubSeq ( $ str ) ; ? >"}
{"text":"Maximum elements that can be made equal with k updates | PHP program to find maximum elements that can be made equal with k ; Function to calculate the maximum number of equal elements possible with atmost K increment of values . Here we have done sliding window to determine that whether there are x number of elements present which on increment will become equal . The loop here will run in fashion like 0. . . x - 1 , 1. . . x , 2. . . x + 1 , ... . , n - x - 1. . . n - 1 ; It can be explained with the reasoning that if for some x number of elements we can update the values then the increment to the segment ( i to j having length -> x ) so that all will be equal is ( x * maxx [ j ] ) this is the total sum of segment and ( pre [ j ] - pre [ i ] ) is present sum So difference of them should be less than k if yes , then that segment length ( x ) can be possible return true ; sort the array in ascending order ; Initializing the prefix array and maximum array ; Calculating prefix sum of the array ; Calculating max value upto that position in the array ; Binary search applied for computation here ; printing result ; Driver code","code":"< ? php function ElementsCalculationFunc ( $ pre , $ maxx , $ x , $ k , $ n ) { for ( $ i = 0 , $ j = $ x ; $ j <= $ n ; $ j ++ , $ i ++ ) { function ElementsCalculationFunc ( $ pre , $ maxx , $ x , $ k , $ n ) { for ( $ i = 0 , $ j = $ x ; $ j <= $ n ; $ j ++ , $ i ++ ) { if ( $ x * $ maxx [ $ j ] - ( $ pre [ $ j ] - $ pre [ $ i ] ) <= $ k ) return true ; } return false ; } function MaxNumberOfElements ( $ a , $ n , $ k ) { sort ( $ a ) ; for ( $ i = 0 ; $ i <= $ n ; ++ $ i ) { $ pre [ $ i ] = 0 ; $ maxx [ $ i ] = 0 ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ a [ $ i - 1 ] ; $ maxx [ $ i ] = max ( $ maxx [ $ i - 1 ] , $ a [ $ i - 1 ] ) ; } $ l = 1 ; $ r = $ n ; $ ans ; while ( $ l < $ r ) { $ mid = ( $ l + $ r ) \/ 2 ; if ( ElementsCalculationFunc ( $ pre , $ maxx , $ mid - 1 , $ k , $ n ) ) { $ ans = $ mid ; $ l = $ mid + 1 ; } else $ r = $ mid - 1 ; } echo $ ans , \" STRNEWLINE \" ; } $ arr = array ( 2 , 4 , 9 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ k = 3 ; MaxNumberOfElements ( $ arr , $ n , $ k ) ; #This  code is contributed by akt_mit. NEW_LINE ? >"}
{"text":"Remove array end element to maximize the sum of product | PHP program to find maximum score we can get by removing elements from either end . ; If only one element left . ; If already calculated , return the value . ; Computing Maximum value when element at index i and index j is to be choosed . ; Driver Code","code":"< ? php $ MAX = 50 ; function solve ( $ dp , $ a , $ low , $ high , $ turn ) { if ( $ low == $ high ) return $ a [ $ low ] * $ turn ; if ( $ dp [ $ low ] [ $ high ] != 0 ) return $ dp [ $ low ] [ $ high ] ; $ dp [ $ low ] [ $ high ] = max ( $ a [ $ low ] * $ turn + solve ( $ dp , $ a , $ low + 1 , $ high , $ turn + 1 ) , $ a [ $ high ] * $ turn + solve ( $ dp , $ a , $ low , $ high - 1 , $ turn + 1 ) ) ; return $ dp [ $ low ] [ $ high ] ; } $ arr = array ( 1 , 3 , 1 , 5 , 2 ) ; $ n = count ( $ arr ) ; $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { $ dp [ $ i ] = array_fill ( $ i , $ MAX , 0 ) ; } echo solve ( $ dp , $ arr , 0 , $ n - 1 , 1 ) ; ? >"}
{"text":"Maximum sum bitonic subarray | function to find the maximum sum bitonic subarray ; ' msis [ ] ' to store the maximum sum increasing subarray up to each index of ' arr ' from the beginning ' msds [ ] ' to store the maximum sum decreasing subarray from each index of ' arr ' up to the end ; to store the maximum sum bitonic subarray ; building up the maximum sum increasing subarray for each array index ; building up the maximum sum decreasing subarray for each array index ; for each array index , calculating the maximum sum of bitonic subarray of which it is a part of ; if true , then update ' max ' bitonic subarray sum ; required maximum sum ; Driver Code","code":"< ? php function maxSumBitonicSubArr ( $ arr , $ n ) { $ msis = array ( ) ; $ msds = array ( ) ; $ max_sum = PHP_INT_MIN ; $ msis [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ msis [ $ i ] = $ msis [ $ i - 1 ] + $ arr [ $ i ] ; else $ msis [ $ i ] = $ arr [ $ i ] ; $ msds [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) $ msds [ $ i ] = $ msds [ $ i + 1 ] + $ arr [ $ i ] ; else $ msds [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max_sum < ( $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ) ) $ max_sum = $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ; return $ max_sum ; } $ arr = array ( 5 , 3 , 9 , 2 , 7 , 6 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum \u2581 Sum \u2581 = \u2581 \" , maxSumBitonicSubArr ( $ arr , $ n ) ; ? >"}
{"text":"Count the number of ways to tile the floor of size n x m using 1 x m size tiles | function to count the total number of ways ; table to store values of subproblems ; Fill the table upto value n ; recurrence relation ; base cases ; i = = m ; required number of ways ; Driver Code","code":"< ? php function countWays ( $ n , $ m ) { $ count [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i > $ m ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - $ m ] ; else if ( $ i < $ m or $ i == 1 ) $ count [ $ i ] = 1 ; else $ count [ $ i ] = 2 ; } return $ count [ $ n ] ; } $ n = 7 ; $ m = 4 ; echo \" Number \u2581 of \u2581 ways \u2581 = \u2581 \" , countWays ( $ n , $ m ) ; ? >"}
{"text":"Largest sum Zigzag sequence in a matrix | PHP program to find the largest sum zigzag sequence ; Returns largest sum of a Zigzag sequence starting from ( i , j ) and ending at a bottom cell . ; If we have reached bottom ; Find the largest sum by considering all possible next elements in sequence . ; Returns largest possible sum of a Zizag sequence starting from top and ending at bottom . ; Consider all cells of top row as starting point ; Driver Code","code":"< ? php $ MAX = 100 ; function largestZigZagSumRec ( $ mat , $ i , $ j , $ n ) { if ( $ i == $ n - 1 ) return $ mat [ $ i ] [ $ j ] ; $ zzs = 0 ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) if ( $ k != $ j ) $ zzs = max ( $ zzs , largestZigZagSumRec ( $ mat , $ i + 1 , $ k , $ n ) ) ; return $ zzs + $ mat [ $ i ] [ $ j ] ; } function largestZigZag ( $ mat , $ n ) { $ res = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ res = max ( $ res , largestZigZagSumRec ( $ mat , 0 , $ j , $ n ) ) ; return $ res ; } $ n = 3 ; $ mat = array ( array ( 4 , 2 , 1 ) , array ( 3 , 9 , 6 ) , array ( 11 , 3 , 15 ) ) ; echo \" Largest \u2581 zigzag \u2581 sum : \u2581 \" , largestZigZag ( $ mat , $ n ) ; ? >"}
{"text":"Count of strings that can be formed using a , b and c under given constraints | n is total number of characters . bCount and cCount are counts of ' b ' and ' c ' respectively . ; Base cases ; Three cases , we choose , a or b or c . In all three cases n decreases by 1. ; Total number of characters","code":"< ? php function countStr ( $ n , $ bCount , $ cCount ) { if ( $ bCount < 0 $ cCount < 0 ) return 0 ; if ( $ n == 0 ) return 1 ; if ( $ bCount == 0 && $ cCount == 0 ) return 1 ; $ res = countStr ( $ n - 1 , $ bCount , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount - 1 , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount , $ cCount - 1 ) ; return $ res ; } $ n = 3 ; echo countStr ( $ n , 1 , 2 ) ; ? >"}
{"text":"Maximum path sum that starting with any cell of 0 | PHP program to find Maximum path sum start any column in row '0' and ends up to any column in row ' n - 1' ; function find maximum sum path ; create 2D matrix to store the sum of the path ; copy all element of first column into ' dp ' first column ; Find maximum path sum that end ups at any column of last row ' N - 1' ; return maximum sum path ; Driver Code","code":"< ? php $ N = 4 ; function MaximumPath ( & $ Mat ) { global $ N ; $ result = 0 ; $ dp = array_fill ( 0 , $ N , array_fill ( 0 , $ N + 2 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ 0 ] [ $ i + 1 ] = $ Mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ j + 1 ] ) ) + $ Mat [ $ i ] [ $ j - 1 ] ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ result = max ( $ result , $ dp [ $ N - 1 ] [ $ i ] ) ; return $ result ; } $ Mat = array ( array ( 4 , 2 , 3 , 4 ) , array ( 2 , 9 , 1 , 10 ) , array ( 15 , 1 , 3 , 0 ) , array ( 16 , 92 , 41 , 44 ) ) ; echo MaximumPath ( $ Mat ) . \" STRNEWLINE \" ; ? >"}
{"text":"Probability of getting at least K heads in N tosses of Coins | Dynamic and Logarithm approach find probability of at least k heads ; dp [ i ] is going to store Log ( i ! ) in base 2 ; Initialize result ; Iterate from k heads to n heads ; Preprocess all the logarithm value on base 2 ; Driver code ; Probability of getting 2 head out of 3 coins ; Probability of getting 3 head out of 6 coins ; Probability of getting 500 head out of 10000 coins","code":"< ? php $ MAX = 100001 ; $ dp = array_fill ( 0 , $ MAX , 0 ) ; function probability ( $ k , $ n ) { global $ MAX , $ dp ; $ ans = 0 ; for ( $ i = $ k ; $ i <= $ n ; ++ $ i ) { $ res = $ dp [ $ n ] - $ dp [ $ i ] - $ dp [ $ n - $ i ] - $ n ; $ ans += pow ( 2.0 , $ res ) ; } return $ ans ; } function precompute ( ) { global $ MAX , $ dp ; for ( $ i = 2 ; $ i < $ MAX ; ++ $ i ) precompute ( ) ; echo probability ( 2 , 3 ) . \" STRNEWLINE \" ; echo probability ( 3 , 6 ) . \" STRNEWLINE \" ; echo probability ( 500 , 1000 ) ; ? >"}
{"text":"Maximum path sum for each position with jumps under divisibility condition | PHP program to print maximum path sum ending with each position x such that all path step positions divide x . ; Create an array such that dp [ i ] stores maximum path sum ending with i . ; Calculating maximum sum path for each element . ; Finding previous step for arr [ i ] Moving from 1 to sqrt ( i + 1 ) since all the divisors are present from sqrt ( i + 1 ) . ; Checking if j is divisor of i + 1. ; Checking which divisor will provide greater value . ; Printing the answer ( Maximum path sum ending with every position i + 1. ; Driven Program ; Function calling","code":"< ? php function printMaxSum ( $ arr , $ n ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; $ maxi = 0 ; for ( $ j = 1 ; $ j <= sqrt ( $ i + 1 ) ; $ j ++ ) { if ( ( ( $ i + 1 ) % $ j == 0 ) && ( $ i + 1 ) != $ j ) { if ( $ dp [ $ j - 1 ] > $ maxi ) $ maxi = $ dp [ $ j - 1 ] ; if ( $ dp [ ( $ i + 1 ) \/ $ j - 1 ] > $ maxi && $ j != 1 ) $ maxi = $ dp [ ( $ i + 1 ) \/ $ j - 1 ] ; } } $ dp [ $ i ] += $ maxi ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , \" \u2581 \" ; } $ arr = array ( 2 , 3 , 1 , 4 , 6 , 5 ) ; $ n = sizeof ( $ arr ) ; printMaxSum ( $ arr , $ n ) ; ? >"}
{"text":"Maximum sum alternating subsequence | Return sum of maximum sum alternating sequence starting with arr [ 0 ] and is first decreasing . ; handling the edge case ; stores sum of decreasing and increasing sub - sequence ; store sum of increasing and decreasing sun - sequence ; As per question , first element must be part of solution . ; Traverse remaining elements of array ; IF current sub - sequence is decreasing the update dec [ j ] if needed . dec [ i ] by current inc [ j ] + arr [ i ] ; Revert the flag , if first decreasing is found ; If next element is greater but flag should be 1 i . e . this element should be counted after the first decreasing element gets counted ; If current sub - sequence is increasing then update inc [ i ] ; find maximum sum in b \/ w inc [ ] and dec [ ] ; return maximum sum alternate sun - sequence ; Driver Code","code":"< ? php function maxAlternateSum ( $ arr , $ n ) { if ( $ n == 1 ) return $ arr [ 0 ] ; $ min = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ min = max ( $ min , $ arr [ $ i ] ) ; } if ( $ arr [ 0 ] == $ min ) return $ arr [ 0 ] ; $ dec = array_fill ( 0 , $ n , 0 ) ; $ inc = array_fill ( 0 , $ n , 0 ) ; $ dec [ 0 ] = $ inc [ 0 ] = $ arr [ 0 ] ; $ flag = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ arr [ $ j ] > $ arr [ $ i ] ) { $ dec [ $ i ] = max ( $ dec [ $ i ] , $ inc [ $ j ] + $ arr [ $ i ] ) ; $ flag = 1 ; } else if ( $ arr [ $ j ] < $ arr [ $ i ] && $ flag == 1 ) $ inc [ $ i ] = max ( $ inc [ $ i ] , $ dec [ $ j ] + $ arr [ $ i ] ) ; } } $ result = - ( PHP_INT_MAX - 1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ result < $ inc [ $ i ] ) $ result = $ inc [ $ i ] ; if ( $ result < $ dec [ $ i ] ) $ result = $ dec [ $ i ] ; } return $ result ; } $ arr = array ( 8 , 2 , 3 , 5 , 7 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum \u2581 sum \u2581 = \u2581 \" , maxAlternateSum ( $ arr , $ n ) ; ? >"}
{"text":"Padovan Sequence | Function to calculate padovan number P ( n ) ; 0 th , 1 st and 2 nd number of the series are 1 ; Driver Code","code":"< ? php function pad ( $ n ) { $ pPrevPrev = 1 ; $ pPrev = 1 ; $ pCurr = 1 ; $ pNext = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ pNext = $ pPrevPrev + $ pPrev ; $ pPrevPrev = $ pPrev ; $ pPrev = $ pCurr ; $ pCurr = $ pNext ; } return $ pNext ; } $ n = 12 ; echo ( pad ( $ n ) ) ; ? >"}
{"text":"Lucas Numbers | Iterative function ; declaring base values for positions 0 and 1 ; generating number ; Driver Code","code":"< ? php function lucas ( $ n ) { $ a = 2 ; $ b = 1 ; $ c ; $ i ; if ( $ n == 0 ) return $ a ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ b ; } $ n = 9 ; echo lucas ( $ n ) ; ? >"}
{"text":"Recursively break a number in 3 parts to get maximum sum | Function to find the maximum sum ; base conditions ; Fill in bottom - up manner using recursive formula . ; Driver Code","code":"< ? php function breakSum ( $ n ) { $ dp = array_fill ( 0 , $ n + 1 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = max ( $ dp [ ( int ) ( $ i \/ 2 ) ] + $ dp [ ( int ) ( $ i \/ 3 ) ] + $ dp [ ( int ) ( $ i \/ 4 ) ] , $ i ) ; return $ dp [ $ n ] ; } $ n = 24 ; echo breakSum ( $ n ) ; ? >"}
{"text":"Minimum time to finish tasks without skipping two consecutive | arr [ ] represents time taken by n given tasks ; Corner Cases ; First task is exluded ; Process remaining n - 1 tasks ; Time taken if current task is included There are two possibilities ( a ) Previous task is also included ( b ) Previous task is not included ; Time taken when current task is not included . There is only one possibility that previous task is also included . ; Update incl and excl for next iteration ; Return maximum of two values for last task ; Driver code","code":"< ? php function minTime ( $ arr , $ n ) { if ( $ n <= 0 ) return 0 ; $ excl = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ incl_new = $ arr [ $ i ] + min ( $ excl , $ incl ) ; $ excl_new = $ incl ; $ incl = $ incl_new ; $ excl = $ excl_new ; } return min ( $ incl , $ excl ) ; } $ arr1 = array ( 10 , 5 , 2 , 7 , 10 ) ; $ n1 = sizeof ( $ arr1 ) ; echo minTime ( $ arr1 , $ n1 ) , \" STRNEWLINE \" ; $ arr2 = array ( 10 , 5 , 7 , 10 ) ; $ n2 = sizeof ( $ arr2 ) ; echo minTime ( $ arr2 , $ n2 ) , \" STRNEWLINE \" ; $ arr3 = array ( 10 , 5 , 2 , 4 , 8 , 6 , 7 , 10 ) ; $ n3 = sizeof ( $ arr3 ) ; echo minTime ( $ arr3 , $ n3 ) ; ? >"}
{"text":"Matrix Exponentiation | A utility function to multiply two matrices a [ ] [ ] and b [ ] [ ] . Multiplication result is stored back in b [ ] [ ] ; Creating an auxiliary matrix to store elements of the multiplication matrix ; storing the multiplication result in a [ ] [ ] ; Updating our matrix ; Function to compute F raise to power n - 2. ; Multiply it with initial values i . e with F ( 0 ) = 0 , F ( 1 ) = 1 , F ( 2 ) = 1 ; Multiply it with initial values i . e with F ( 0 ) = 0 , F ( 1 ) = 1 , F ( 2 ) = 1 ; Return n 'th term of a series defined using below recurrence relation. f(n) is defined as f(n) = f(n-1) + f(n-2) + f(n-3), n>=3 Base Cases : f(0) = 0, f(1) = 1, f(2) = 1 ; Driver code","code":"< ? php function multiply ( & $ a , & $ b ) { $ mul = array_fill ( 0 , 3 , array_fill ( 0 , 3 , 0 ) ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { $ mul [ $ i ] [ $ j ] = 0 ; for ( $ k = 0 ; $ k < 3 ; $ k ++ ) $ mul [ $ i ] [ $ j ] += $ a [ $ i ] [ $ k ] * $ b [ $ k ] [ $ j ] ; } } for ( $ i = 0 ; $ i < 3 ; $ i ++ ) for ( $ j = 0 ; $ j < 3 ; $ j ++ ) $ a [ $ i ] [ $ j ] = $ mul [ $ i ] [ $ j ] ; } function power ( $ F , $ n ) { $ M = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; if ( $ n == 1 ) return $ F [ 0 ] [ 0 ] + $ F [ 0 ] [ 1 ] ; power ( $ F , ( int ) ( $ n \/ 2 ) ) ; multiply ( $ F , $ F ) ; if ( $ n % 2 != 0 ) multiply ( $ F , $ M ) ; return $ F [ 0 ] [ 0 ] + $ F [ 0 ] [ 1 ] ; } function findNthTerm ( $ n ) { $ F = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; return power ( $ F , $ n - 2 ) ; } $ n = 5 ; echo \" F ( 5 ) \u2581 is \u2581 \" . findNthTerm ( $ n ) ; ? >"}
{"text":"Count number of ways to fill a \" n \u2581 x \u2581 4\" grid using \"1 \u2581 x \u2581 4\" tiles | Returns count of count of ways to place 1 x 4 tiles on n x 4 grid . ; Create a table to store results of subproblems dp [ i ] stores count of ways for i x 4 grid . ; Fill the table from d [ 1 ] to dp [ n ] ; Base cases ; dp ( i - 1 ) : Place first tile horizontally dp ( n - 4 ) : Place first tile vertically which means 3 more tiles have to be placed vertically . ; Driver Code","code":"< ? php function countt ( $ n ) { $ dp [ $ n + 1 ] = 0 ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i >= 1 && $ i <= 3 ) $ dp [ $ i ] = 1 ; else if ( $ i == 4 ) $ dp [ $ i ] = 2 ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 4 ] ; } return $ dp [ $ n ] ; } $ n = 5 ; echo \" Count \u2581 of \u2581 ways \u2581 is \u2581 \" , countt ( $ n ) ; ? >"}
{"text":"Compute nCr % p | Set 1 ( Introduction and Dynamic Programming Solution ) | Returns nCr % p ; Optimization for the cases when r is large ; The array C is going to store last row of pascal triangle at the end . And last entry of last row is nCr ; Top row of Pascal Triangle ; One by constructs remaining rows of Pascal Triangle from top to bottom ; Fill entries of current row using previous row values ; nCj = ( n - 1 ) Cj + ( n - 1 ) C ( j - 1 ) ; ; Driver Code","code":"< ? php function nCrModp ( $ n , $ r , $ p ) { if ( $ r > $ n - $ r ) $ r = $ n - $ r ; $ C = array ( ) ; for ( $ i = 0 ; $ i < $ r + 1 ; $ i ++ ) $ C [ $ i ] = 0 ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = Min ( $ i , $ r ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = ( $ C [ $ j ] + $ C [ $ j - 1 ] ) % $ p ; } return $ C [ $ r ] ; } $ n = 10 ; $ r = 2 ; $ p = 13 ; echo \" Value \u2581 of \u2581 nCr \u2581 % \u2581 p \u2581 is \u2581 \" , nCrModp ( $ n , $ r , $ p ) ; ? >"}
{"text":"Bell Numbers ( Number of ways to Partition a Set ) | function that returns n 'th bell number ; Explicitly fill for j = 0 ; Fill for remaining values of j ; Driver Code","code":"< ? php function bellNumber ( $ n ) { $ bell [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ bell [ $ i ] [ 0 ] = $ bell [ $ i - 1 ] [ $ i - 1 ] ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ bell [ $ i ] [ $ j ] = $ bell [ $ i - 1 ] [ $ j - 1 ] + $ bell [ $ i ] [ $ j - 1 ] ; } return $ bell [ $ n ] [ 0 ] ; } for ( $ n = 0 ; $ n <= 5 ; $ n ++ ) echo ( \" Bell \u2581 Number \u2581 \" . $ n . \" \u2581 is \u2581 \" . bellNumber ( $ n ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Count number of ways to cover a distance | Function returns count of ways to cover ' dist ' ; Initialize base values . There is one way to cover 0 and 1 distances and two ways to cover 2 distance ; Fill the count array in bottom up manner ; Driver Code","code":"< ? php function printCountDP ( $ dist ) { $ count = array ( ) ; $ count [ 0 ] = 1 ; $ count [ 1 ] = 1 ; $ count [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ dist ; $ i ++ ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - 2 ] + $ count [ $ i - 3 ] ; return $ count [ $ dist ] ; } $ dist = 4 ; echo printCountDP ( $ dist ) ; ? >"}
{"text":"Count even length binary sequences with same sum of first and second half bits | Returns the count of even length sequences ; Calculate SUM ( ( nCr ) ^ 2 ) ; Compute nCr using nC ( r - 1 ) nCr \/ nC ( r - 1 ) = ( n + 1 - r ) \/ r ; ; Driver Code","code":"< ? php function countSeq ( $ n ) { $ nCr = 1 ; $ res = 1 ; for ( $ r = 1 ; $ r <= $ n ; $ r ++ ) { $ nCr = ( $ nCr * ( $ n + 1 - $ r ) ) \/ $ r ; $ res = $ res + ( $ nCr * $ nCr ) ; } return $ res ; } $ n = 2 ; echo ( \" Count \u2581 of \u2581 sequences \u2581 is \u2581 \" ) ; echo countSeq ( $ n ) ; ? >"}
{"text":"Remove minimum elements from either side such that 2 * min becomes more than max | A utility function to find minimum in arr [ l . . h ] ; A utility function to find maximum in arr [ l . . h ] ; Returns the minimum number of removals from either end in arr [ l . . h ] so that 2 * min becomes greater than max . ; Create a table to store solutions of subproblems ; Fill table using above recursive formula . Note that the table is filled in diagonal fashion ( similar to http : goo . gl \/ PQqoS ) , from diagonal elements to table [ 0 ] [ n - 1 ] which is the result . ; Driver Code","code":"< ? php function min1 ( $ arr , $ l , $ h ) { $ mn = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mn > $ arr [ $ i ] ) $ mn = $ arr [ $ i ] ; return $ mn ; } function max1 ( $ arr , $ l , $ h ) { $ mx = $ arr [ $ l ] ; for ( $ i = $ l + 1 ; $ i <= $ h ; $ i ++ ) if ( $ mx < $ arr [ $ i ] ) $ mx = $ arr [ $ i ] ; return $ mx ; } function minRemovalsDP ( $ arr , $ n ) { $ table = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ mn = min1 ( $ arr , $ i , $ j ) ; $ mx = max1 ( $ arr , $ i , $ j ) ; $ table [ $ i ] [ $ j ] = ( 2 * $ mn > $ mx ) ? 0 : min ( $ table [ $ i ] [ $ j - 1 ] + 1 , $ table [ $ i + 1 ] [ $ j ] + 1 ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; } $ arr = array ( 20 , 4 , 1 , 3 ) ; $ n = count ( $ arr ) ; echo minRemovalsDP ( $ arr , $ n ) ; ? >"}
{"text":"Count all possible paths from top left to bottom right of a mXn matrix | Returns count of possible paths to reach cell at row number m and column number n from the topmost leftmost cell ( cell at 1 , 1 ) ; If either given row number is first or given column number is first ; If diagonal movements are allowed then the last addition is required . ; Driver Code","code":"< ? php function numberOfPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return numberOfPaths ( $ m - 1 , $ n ) + numberOfPaths ( $ m , $ n - 1 ) ; } echo numberOfPaths ( 3 , 3 ) ; ? >"}
{"text":"Count all possible paths from top left to bottom right of a mXn matrix | PHP program to count all possible paths from top left to top bottom using combinatorics ; We have to calculate m + n - 2 C n - 1 here which will be ( m + n - 2 ) ! \/ ( n - 1 ) ! ( m - 1 ) ! ; Driver code","code":"< ? php function numberOfPaths ( $ m , $ n ) { $ path = 1 ; for ( $ i = $ n ; $ i < ( $ m + $ n - 1 ) ; $ i ++ ) { $ path *= $ i ; $ path \/= ( $ i - $ n + 1 ) ; } return $ path ; } { echo ( numberOfPaths ( 3 , 3 ) ) ; }"}
{"text":"Longest Arithmetic Progression | DP | Returns length of the longest AP subset in a given set ; Create a table and initialize all values as 2. The value of L [ i ] [ j ] stores LLAP with set [ i ] and set [ j ] as first two elements of AP . Only valid entries are the entries where j > i ; Fill entries in last column as 2. There will always be two elements in AP with last number of set as second element in AP ; Consider every element as second element of AP ; Search for i and k for j ; Before changing i , set L [ i ] [ j ] as 2 ; Found i and k for j , LLAP with i and j as first two elements is equal to LLAP with j and k as first two elements plus 1. L [ j ] [ k ] must have been filled before as we run the loop from right side ; Update overall LLAP , if needed ; Change i and k to fill more L [ i ] [ j ] values for current j ; If the loop was stopped due to k becoming more than n - 1 , set the remaining entities in column j as 2 ; Driver Code","code":"< ? php function lenghtOfLongestAP ( $ set , $ n ) { if ( $ n <= 2 ) return $ n ; $ L [ $ n ] [ $ n ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ L [ $ i ] [ $ n - 1 ] = 2 ; for ( $ j = $ n - 2 ; $ j >= 1 ; $ j -- ) { $ i = $ j - 1 ; $ k = $ j + 1 ; while ( $ i >= 0 && $ k <= $ n - 1 ) { if ( $ set [ $ i ] + $ set [ $ k ] < 2 * $ set [ $ j ] ) $ k ++ ; else if ( $ set [ $ i ] + $ set [ $ k ] > 2 * $ set [ $ j ] ) { $ L [ $ i ] [ $ j ] = 2 ; $ i -- ; } else { $ L [ $ i ] [ $ j ] = $ L [ $ j ] [ $ k ] + 1 ; $ llap = max ( $ llap , $ L [ $ i ] [ $ j ] ) ; $ i -- ; $ k ++ ; } } while ( $ i >= 0 ) { $ L [ $ i ] [ $ j ] = 2 ; $ i -- ; } } return $ llap ; } $ set1 = array ( 1 , 7 , 10 , 13 , 14 , 19 ) ; $ n1 = sizeof ( $ set1 ) ; echo lenghtOfLongestAP ( $ set1 , $ n1 ) , \" \" ; $ set2 = array ( 1 , 7 , 10 , 15 , 27 , 29 ) ; $ n2 = sizeof ( $ set2 ) ; echo lenghtOfLongestAP ( $ set2 , $ n2 ) , \" \" ; $ set3 = array ( 2 , 4 , 6 , 8 , 10 ) ; $ n3 = sizeof ( $ set3 ) ; echo lenghtOfLongestAP ( $ set3 , $ n3 ) , \" \" ; ? >"}
{"text":"Longest Bitonic Subsequence | DP | lbs ( ) returns the length of the Longest Bitonic Subsequence in arr [ ] of size n . The function mainly creates two temporary arrays lis [ ] and lds [ ] and returns the maximum lis [ i ] + lds [ i ] - 1. lis [ i ] == > Longest Increasing subsequence ending with arr [ i ] lds [ i ] == > Longest decreasing subsequence starting with arr [ i ] ; Allocate memory for LIS [ ] and initialize LIS values as 1 for all indexes ; Compute LIS values from left to right ; Allocate memory for lds and initialize LDS values for all indexes ; Compute LDS values from right to left ; Return the maximum value of lis [ i ] + lds [ i ] - 1 ; Driver Code","code":"< ? php function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; } $ arr = array ( 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ) ; $ n = sizeof ( $ arr ) ; echo \" Length \u2581 of \u2581 LBS \u2581 is \u2581 \" . lbs ( $ arr , $ n ) ; ? >"}
{"text":"Egg Dropping Puzzle | DP | Function to get minimum number of trials needed in worst case with n eggs and k floors ; A 2D table where entry eggFloor [ i ] [ j ] will represent minimum number of trials needed for i eggs and j floors . ; We need one trial for one floor and0 trials for 0 floors ; We always need j trials for one egg and j floors . ; Fill rest of the entries in table using optimal substructure property ; eggFloor [ n ] [ k ] holds the result ; Driver Code","code":"< ? php function eggDrop ( $ n , $ k ) { $ eggFloor = array ( array ( ) ) ; ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ eggFloor [ $ i ] [ 1 ] = 1 ; $ eggFloor [ $ i ] [ 0 ] = 0 ; } for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ eggFloor [ 1 ] [ $ j ] = $ j ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 2 ; $ j <= $ k ; $ j ++ ) { $ eggFloor [ $ i ] [ $ j ] = 999999 ; for ( $ x = 1 ; $ x <= $ j ; $ x ++ ) { $ res = 1 + max ( $ eggFloor [ $ i - 1 ] [ $ x - 1 ] , $ eggFloor [ $ i ] [ $ j - $ x ] ) ; if ( $ res < $ eggFloor [ $ i ] [ $ j ] ) $ eggFloor [ $ i ] [ $ j ] = $ res ; } } } return $ eggFloor [ $ n ] [ $ k ] ; } $ n = 2 ; $ k = 36 ; echo \" Minimum \u2581 number \u2581 of \u2581 trials \u2581 in \u2581 worst \u2581 case \u2581 with \u2581 \" . $ n . \" \u2581 eggs \u2581 and \u2581 \" . $ k . \" \u2581 floors \u2581 is \u2581 \" . eggDrop ( $ n , $ k ) ; ? >"}
{"text":"0 | Returns the maximum value that can be put in a knapsack of capacity W ; Base Case ; If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution ; Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included ; Driver Code","code":"< ? php function knapSack ( $ W , $ wt , $ val , $ n ) { if ( $ n == 0 $ W == 0 ) return 0 ; if ( $ wt [ $ n - 1 ] > $ W ) return knapSack ( $ W , $ wt , $ val , $ n - 1 ) ; else return max ( $ val [ $ n - 1 ] + knapSack ( $ W - $ wt [ $ n - 1 ] , $ wt , $ val , $ n - 1 ) , knapSack ( $ W , $ wt , $ val , $ n - 1 ) ) ; } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = count ( $ val ) ; echo knapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text":"Total number of possible Binary Search Trees and Binary Trees with n keys | A function to find factorial of a given number ; Calculate value of [ 1 * ( 2 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ] ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn \/ ( n + 1 ) ; A function to count number of BST with n nodes using catalan ; find nth catalan number ; return nth catalan number ; A function to count number of binary trees with n nodes ; find count of BST with n numbers ; return count * n ! ; Driver Code ; find count of BST and binary trees with n nodes ; print count of BST and binary trees with n nodes","code":"< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ res *= $ i ; } return $ res ; } function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res = ( int ) $ res \/ ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return ( int ) $ c \/ ( $ n + 1 ) ; } function countBST ( $ n ) { $ count = catalan ( $ n ) ; return $ count ; } function countBT ( $ n ) { $ count = catalan ( $ n ) ; return $ count * factorial ( $ n ) ; } $ count1 ; $ count2 ; $ n = 5 ; $ count1 = countBST ( $ n ) ; $ count2 = countBT ( $ n ) ; echo \" Count \u2581 of \u2581 BST \u2581 with \u2581 \" , $ n , \" \u2581 nodes \u2581 is \u2581 \" , $ count1 , \" STRNEWLINE \" ; echo \" Count \u2581 of \u2581 binary \u2581 trees \u2581 with \u2581 \" , $ n , \" \u2581 nodes \u2581 is \u2581 \" , $ count2 ; ? >"}
{"text":"Generate permutation of 1 to N such that absolute difference of consecutive numbers give K distinct integers | Function to generate a permutation of integers from 1 to N such that the absolute difference of all the two consecutive integers give K distinct integers ; To store the permutation ; For sequence 1 2 3. . . ; For sequence N , N - 1 , N - 2. . . ; Flag is used to alternate between the above if else statements ; If last element added was r + 1 ; If last element added was l - 1 ; Print the permutation ; Driver code","code":"< ? php function printPermutation ( $ N , $ K ) { $ res = array ( ) ; $ l = 1 ; $ r = $ N ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ K ; $ i ++ ) { if ( ! $ flag ) { array_push ( $ res , $ l ) ; $ l ++ ; } else { array_push ( $ res , $ r ) ; $ r -- ; } $ flag ^= 1 ; } if ( ! $ flag ) { for ( $ i = $ r ; $ i >= $ l ; $ i -- ) array_push ( $ res , $ i ) ; } else { for ( $ i = l ; $ i <= $ r ; $ i ++ ) array_push ( $ res , $ i ) ; } for ( $ i = 0 ; $ i < sizeof ( $ res ) ; $ i ++ ) echo $ res [ $ i ] , \" \u2581 \" ; } $ N = 10 ; $ K = 4 ; printPermutation ( $ N , $ K ) ; ? >"}
{"text":"Find Nth term of the series 1 , 8 , 54 , 384. . . | calculate factorial of N ; calculate Nth term of series ; Driver Code","code":"< ? php function fact ( $ N ) { $ product = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ product = $ product * $ i ; return $ product ; } function nthTerm ( $ N ) { return ( $ N * $ N ) * fact ( $ N ) ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Rabin | d is the number of characters in the input alphabet ; pat -> pattern txt -> text q -> A prime number ; $p = 0 ; hash value for pattern $t = 0 ; hash value for txt ; The value of h would be \" pow ( d , \u2581 M - 1 ) % q \" ; Calculate the hash value of pattern and first window of text ; Slide the pattern over text one by one ; Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one ; Check for characters one by one ; if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Calculate hash value for next window of text : Remove leading digit , add trailing digit ; We might get negative value of t , converting it to positive ; Driver Code ; A prime number ; Function Call","code":"< ? php $ d = 256 ; function search ( $ pat , $ txt , $ q ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i ; $ j ; $ h = 1 ; $ d = 1 ; for ( $ i = 0 ; $ i < $ M - 1 ; $ i ++ ) $ h = ( $ h * $ d ) % $ q ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { $ p = ( $ d * $ p + $ pat [ $ i ] ) % $ q ; $ t = ( $ d * $ t + $ txt [ $ i ] ) % $ q ; } for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { if ( $ p == $ t ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; } if ( $ j == $ M ) echo \" Pattern \u2581 found \u2581 at \u2581 index \u2581 \" , $ i , \" STRNEWLINE \" ; } if ( $ i < $ N - $ M ) { $ t = ( $ d * ( $ t - $ txt [ $ i ] * $ h ) + $ txt [ $ i + $ M ] ) % $ q ; if ( $ t < 0 ) $ t = ( $ t + $ q ) ; } } } $ txt = \" GEEKS \u2581 FOR \u2581 GEEKS \" ; $ pat = \" GEEK \" ; $ q = 101 ; search ( $ pat , $ txt , $ q ) ; ? >"}
{"text":"Minimum number of towers required such that every house is in the range of at least one tower | Function to count the number of tower ; first we sort the house numbers ; for count number of towers ; for iterate all houses ; count number of towers ; find find the middle location ; traverse till middle location ; this is point to middle house where we insert the tower ; now find the last location ; traverse till last house of the range ; return the number of tower ; given elements ; print number of towers","code":"< ? php function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; } $ house = array ( 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ) ; $ range = 2 ; $ n = sizeof ( $ house ) \/ sizeof ( $ house [ 0 ] ) ; echo number_of_tower ( $ house , $ range , $ n ) ; ? >"}
{"text":"Smallest element in an array that is repeated exactly ' k ' times . | PHP program to find smallest number in array that is repeated exactly ' k ' times . ; Computing frequencies of all elements ; Finding the smallest element with frequency as k ; If frequency of any of the number is equal to k starting from 0 then return the number ; Driver code","code":"< ? php $ MAX = 1000 ; function findDuplicate ( $ arr , $ n , $ k ) { global $ MAX ; $ freq = array_fill ( 0 , $ MAX , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < 1 && $ arr [ $ i ] > $ MAX ) { echo \" Out \u2581 of \u2581 range \" ; return -1 ; } $ freq [ $ arr [ $ i ] ] += 1 ; } for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { if ( $ freq [ $ i ] == $ k ) return $ i ; } return -1 ; } $ arr = array ( 2 , 2 , 1 , 3 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findDuplicate ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Program to print an array in Pendulum Arrangement | Prints pendulam arrangement of arr [ ] ; sorting the elements ; Auxiliary array to store output ; calculating the middle index ; storing the minimum element in the middle i is index for output array and j is for input array . ; adjustment for when no . of elements is even ; Printing the pendulum arrangement ; input Array ; calculating the length of array A ; calling pendulum function","code":"< ? php function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) \/ 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo \" Pendulum \u2581 arrangement : \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } arr = array ( 14 , 6 , 19 , 21 , 12 ) ; $ n = sizeof ( $ arr ) ; pendulumArrangement ( $ arr , $ n ) ; ? >"}
{"text":"Queries to find the last non | Maximum distinct characters possible ; To store the frequency of the characters ; Function to pre - calculate the frequency array ; Only the first character has frequency 1 till index 0 ; Starting from the second character of the string ; For every possible character ; Current character under consideration ; If it is equal to the character at the current index ; Function to return the frequency of the given character in the sub - string $str [ $l ... $r ] ; Function to return the last non - repeating character ; Starting from the last character ; Current character ; If frequency of the current character is 1 then return the character ; All the characters of the sub - string are repeating ; Driver code ; Pre - calculate the frequency array","code":"< ? php $ MAX = 256 ; $ freq = array_fill ( 0 , 256 , array_fill ( 0 , 1000 , 0 ) ) ; function preCalculate ( $ str , $ n ) { global $ freq ; global $ MAX ; $ freq [ ord ( $ str [ 0 ] ) ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ ch = $ str [ $ i ] ; for ( $ j = 0 ; $ j < $ MAX ; $ j ++ ) { $ charToUpdate = chr ( $ j ) ; if ( $ charToUpdate == $ ch ) $ freq [ $ j ] [ $ i ] = $ freq [ $ j ] [ $ i - 1 ] + 1 ; else $ freq [ $ j ] [ $ i ] = $ freq [ $ j ] [ $ i - 1 ] ; } } } function getFrequency ( $ ch , $ l , $ r ) { global $ freq ; if ( $ l == 0 ) return $ freq [ ord ( $ ch ) ] [ $ r ] ; else return ( $ freq [ ord ( $ ch ) ] [ $ r ] - $ freq [ ord ( $ ch ) ] [ $ l - 1 ] ) ; } function lastNonRepeating ( $ str , $ n , $ l , $ r ) { for ( $ i = $ r ; $ i >= $ l ; $ i -- ) { $ ch = $ str [ $ i ] ; if ( getFrequency ( $ ch , $ l , $ r ) == 1 ) return $ ch ; } return \" - 1\" ; } $ str = \" GeeksForGeeks \" ; $ n = strlen ( $ str ) ; $ queries = array ( array ( 2 , 9 ) , array ( 2 , 3 ) , array ( 0 , 12 ) ) ; $ q = 3 ; preCalculate ( $ str , $ n ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) { echo ( lastNonRepeating ( $ str , $ n , $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] ) ) , \" STRNEWLINE \" ; } ? >"}
{"text":"Minimum cost to modify a string | Function to return the minimum cost ; Initialize result ; To store the frequency of characters of the string Initialize array with 0 ; Update the frequencies of the characters of the string ; Loop to check all windows from a - z where window size is K ; Starting index of window ; Ending index of window ; Check if the string contains character ; Check if the character is on left side of window find the cost of modification for character add value to count calculate nearest distance of modification ; Check if the character is on right side of window find the cost of modification for character add value to count calculate nearest distance of modification ; Find the minimum of all costs for modifying the string ; Loop to check all windows Here window contains characters before z and after z of window size K ; Starting index of window ; Ending index of window ; Check if the string contains character ; If characters are outside window find the cost for modifying character add value to count ; Find the minimum of all costs for modifying the string ; Driver code","code":"< ? php function minCost ( $ str , $ K ) { $ n = strlen ( $ str ) ; $ res = 999999999 ; $ count = 0 ; $ cnt = array_fill ( 0 , 27 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cnt [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) + 1 ] ++ ; for ( $ i = 1 ; $ i < ( 26 - $ K + 1 ) ; $ i ++ ) { $ a = $ i ; $ b = $ i + $ K ; $ count = 0 ; for ( $ j = 1 ; $ j <= 26 ; $ j ++ ) { if ( $ cnt [ $ j ] > 0 ) { if ( $ j >= $ a && $ j >= $ b ) $ count = $ count + ( min ( $ j - $ b , 25 - $ j + $ a + 1 ) ) * $ cnt [ $ j ] ; else if ( $ j <= $ a && $ j <= $ b ) $ count = $ count + ( min ( $ a - $ j , 25 + $ j - $ b + 1 ) ) * $ cnt [ $ j ] ; } } $ res = min ( $ res , $ count ) ; } for ( $ i = 26 - $ K + 1 ; $ i <= 26 ; $ i ++ ) { $ a = $ i ; $ b = ( $ i + $ K ) % 26 ; $ count = 0 ; for ( $ j = 1 ; $ j <= 26 ; $ j ++ ) { if ( $ cnt [ $ j ] > 0 ) { if ( $ j >= $ b and $ j <= $ a ) $ count = $ count + ( min ( $ j - $ b , $ a - $ j ) ) * $ cnt [ $ j ] ; } } $ res = min ( $ res , $ count ) ; } return $ res ; } $ str = \" abcdefghi \" ; $ K = 2 ; echo minCost ( $ str , $ K ) ; ? >"}
{"text":"Print last character of each word in a string | Function to print the last character of each word in the given string ; Now , last word is also followed by a space ; If current character is a space ; Then previous character must be the last character of some word ; Driver code","code":"< ? php function printLastChar ( $ str ) { $ str = $ str . \" \u2581 \" ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! strcmp ( $ str [ $ i ] , ' \u2581 ' ) ) echo ( $ str [ $ i - 1 ] . \" \u2581 \" ) ; } } $ str = \" Geeks \u2581 for \u2581 Geeks \" ; printLastChar ( $ str ) ; ? >"}
{"text":"Maximum length of balanced string after swapping and removal of characters | PHP implementation of the approach Function to return the length of the longest balanced sub - string ; To store the count of parentheses ; Traversing the string ; Check type of parentheses and incrementing count for it ; Sum all pair of balanced parentheses ; Driven code","code":"< ? php function maxBalancedStr ( $ s ) { $ open1 = 0 ; $ close1 = 0 ; $ open2 = 0 ; $ close2 = 0 ; $ open3 = 0 ; $ close3 = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { switch ( $ s [ $ i ] ) { case ' ( ' : $ open1 ++ ; break ; case ' ) ' : $ close1 ++ ; break ; case ' { ' : $ open2 ++ ; break ; case ' } ' : $ close2 ++ ; break ; case ' [ ' : $ open3 ++ ; break ; case ' ] ' : $ close3 ++ ; break ; } } $ maxLen = 2 * min ( $ open1 , $ close1 ) + 2 * min ( $ open2 , $ close2 ) + 2 * min ( $ open3 , $ close3 ) ; return $ maxLen ; } { $ s = \" ) ) [ ] ] ( ( \" ; echo ( maxBalancedStr ( $ s ) ) ; }"}
{"text":"Replace all occurrences of a string with space | Function to extract the secret message ; Replacing all occurrences of Sub in Str by empty spaces ; Removing unwanted spaces in the start and end of the string ; Driver code","code":"< ? php function extractSecretMessage ( $ Str , $ Sub ) { $ Str = str_replace ( $ Sub , \" \u2581 \" , $ Str ) ; return trim ( $ Str ) ; } $ Str = \" LIELIEILIEAMLIECOOL \" ; $ Sub = \" LIE \" ; echo extractSecretMessage ( $ Str , $ Sub ) ; ? >"}
{"text":"Binary Search a String | Returns index of x if it is present in arr [ ] , else return - 1 ; Check if x is present at mid ; If x greater , ignore left half ; If x is smaller , ignore right half ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ x ) { $ l = 0 ; $ r = count ( $ arr ) ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) \/ 2 ) ; $ res = strcmp ( $ x , $ arr [ $ m ] ) ; if ( $ res == 0 ) return $ m - 1 ; if ( $ res > 0 ) $ l = $ m + 1 ; else $ r = $ m - 1 ; } return -1 ; } $ arr = array ( \" contribute \" , \" geeks \" , \" ide \" , \" practice \" ) ; $ x = \" ide \" ; $ result = binarySearch ( $ arr , $ x ) ; if ( $ result == -1 ) print ( \" Element \u2581 not \u2581 present \" ) ; else print ( \" Element \u2581 found \u2581 at \u2581 index \u2581 \" . $ result ) ; ? >"}
{"text":"Students with maximum average score of three subjects | Function to find the list of students having maximum average score ; Variables to store average score of a student and maximum average score ; List to store names of students having maximum average score ; Traversing the file data ; finding average score of a student ; Clear the list and add name of student having current maximum average score in the list ; Printing the maximum average score and names of students having this maximum average score as per the order in the file . ; Driver code ; Number of elements in string array","code":"< ? php function getStudentsList ( $ file , $ n ) { $ maxAvgScore = PHP_INT_MIN ; $ names = array ( ) ; $ avgScore = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 4 ) { $ avgScore = ( int ) ( ( intval ( $ file [ $ i + 1 ] ) + intval ( $ file [ $ i + 2 ] ) + intval ( $ file [ $ i + 3 ] ) ) \/ 3 ) ; if ( $ avgScore > $ maxAvgScore ) { $ maxAvgScore = $ avgScore ; unset ( $ names ) ; $ names = array ( ) ; array_push ( $ names , $ file [ $ i ] ) ; } else if ( $ avgScore == $ maxAvgScore ) array_push ( $ names , $ file [ $ i ] ) ; } for ( $ i = 0 ; $ i < count ( $ names ) ; $ i ++ ) { echo $ names [ $ i ] . \" \" ; } echo $ maxAvgScore ; } $ file = array ( \" Shrikanth \" , \"20\" , \"30\" , \"10\" , \" Ram \" , \"100\" , \"50\" , \"10\" ) ; $ n = count ( $ file ) ; getStudentsList ( $ file , $ n ) ; ? >"}
{"text":"Sum of the alphabetical values of the characters of a string | Function to find string score ; Driver code","code":"< ? php function strScore ( $ str , $ s , $ n ) { $ score = 0 ; $ index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ s ) { for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) $ score += ( ord ( $ s [ $ j ] ) - ord ( ' a ' ) ) + 1 ; $ index = ( $ i + 1 ) ; break ; } } $ score = $ score * $ index ; return $ score ; } $ str = array ( \" sahil \" , \" shashanak \" , \" sanjit \" , \" abhinav \" , \" mohit \" ) ; $ s = \" abhinav \" ; $ n = sizeof ( $ str ) ; $ score = strScore ( $ str , $ s , $ n ) ; echo $ score , \" STRNEWLINE \" ; ? >"}
{"text":"Minimum number of Parentheses to be added to make it valid | Function to return required minimum number ; maintain balance of string ; It is guaranteed bal >= - 1 ; Driver code ; Function to print required answer","code":"< ? php function minParentheses ( $ p ) { $ bal = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ p ) ; ++ $ i ) { if ( $ p [ $ i ] == ' ( ' ) $ bal += 1 ; else $ bal += -1 ; if ( $ bal == -1 ) { $ ans += 1 ; $ bal += 1 ; } } return $ bal + $ ans ; } $ p = \" ( ) ) \" ; echo minParentheses ( $ p ) ; ? >"}
{"text":"Check if suffix and prefix of a string are palindromes | Function to check whether the string is a palindrome ; reverse the string to compare with the original string ; check if both are same ; Function to check whether the string has prefix and suffix substrings of length greater than 1 which are palindromes . ; check all prefix substrings ; check if the prefix substring is a palindrome ; If we did not find any palindrome prefix of length greater than 1. ; check all suffix substrings , as the string is reversed now ; check if the suffix substring is a palindrome ; If we did not find a suffix ; Driver code","code":"< ? php function isPalindrome ( $ r ) { $ p = $ r ; strrev ( $ p ) ; return ( $ r == $ p ) ; } function CheckStr ( $ s ) { $ l = strlen ( $ s ) ; for ( $ i = 2 ; $ i <= $ l ; $ i ++ ) { if ( isPalindrome ( substr ( $ s , 0 , $ i ) ) ) break ; } if ( $ i == ( $ l + 1 ) ) return false ; $ i = 2 ; for ( $ i = 2 ; $ i <= $ l ; $ i ++ ) { if ( isPalindrome ( substr ( $ s , $ l - $ i , $ i ) ) ) return true ; } return false ; } $ s = \" abccbarfgdbd \" ; if ( CheckStr ( $ s ) ) echo ( \" YES STRNEWLINE \" ) ; else echo ( \" NO STRNEWLINE \" ) ; ? >"}
{"text":"Rotations of a Binary String with Odd Value | function to calculate total odd decimal equivalent ; Driver code","code":"< ? php function oddEquivalent ( $ s , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ count ++ ; } return $ count ; } $ s = \"1011011\" ; $ n = strlen ( $ s ) ; echo ( oddEquivalent ( $ s , $ n ) ) ; ? >"}
{"text":"Count of strings that can be formed from another string using each character at | Function to find the number of str2 that can be formed using characters of str1 ; iterate and mark the frequencies of all characters in str1 ; find the minimum frequency of every character in str1 ; Driver Code","code":"< ? php function findNumberOfTimes ( $ str1 , $ str2 ) { $ freq = array_fill ( 0 , 26 , NULL ) ; $ l1 = strlen ( $ str1 ) ; $ freq2 = array_fill ( 0 , 26 , NULL ) ; $ l2 = strlen ( $ str2 ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ freq [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] += 1 ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] += 1 ; $ count = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ count = min ( $ count , $ freq [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] \/ $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ) ; return $ count ; } $ str1 = \" foreeksgekseg \" ; $ str2 = \" geeks \" ; echo findNumberOfTimes ( $ str1 , $ str2 ) . \" \" ; ? >"}
{"text":"String transformation using XOR and OR | function to check if conversion is possible or not ; if lengths are different ; iterate to check if both strings have 1 ; to check if there is even one 1 in string s1 ; to check if there is even one 1 in string s2 ; if both string do not have a '1' . ; Driver code","code":"< ? php function solve ( $ s1 , $ s2 ) { if ( strlen ( $ s1 ) != strlen ( $ s2 ) ) return false ; $ l = strlen ( $ s1 ) ; for ( $ i = 0 ; $ i < 1 ; $ i ++ ) { if ( $ s1 [ $ i ] == '1' ) $ flag1 = 1 ; if ( $ s2 [ $ i ] == '1' ) $ flag2 = 1 ; if ( ! $ flag1 && ! $ flag2 ) return true ; } return false ; } $ s1 = \"100101\" ; $ s2 = \"100000\" ; if ( solve ( $ s1 , $ s2 ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Longest substring of 0 s in a string formed by k concatenations | Function to calculate maximum length of substring containing only zero ; loop to first calculate longest substring in string ; if all elements in string are '0' ; Else , find size of prefix and suffix containing only zeroes ; Calculate prefix containing only zeroes ; Calculate suffix containing only zeroes ; if k <= 1 then there is no need to take prefix + suffix into account ; Driver code","code":"< ? php function subzero ( $ str , $ k ) { $ ans = 0 ; $ curr = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { if ( $ str [ $ i ] == '0' ) $ curr ++ ; else $ curr = 0 ; $ ans = max ( $ ans , $ curr ) ; } if ( $ ans == $ len ) return $ len * $ k ; else { $ pre = 0 ; $ suff = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) $ pre ++ ; else break ; } for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == '0' ) $ suff ++ ; else break ; } if ( $ k > 1 ) $ ans = max ( $ ans , $ pre + $ suff ) ; return $ ans ; } } $ str = \"00100110\" ; $ k = 5 ; echo subzero ( $ str , $ k ) ; ? >"}
{"text":"Find nth term of the Dragon Curve Sequence | function to generate the nth term ; first term ; generating each term of the sequence ; loop to generate the ith term ; add character from the original string ; add alternate 0 and 1 in between ; if previous added term was '0' then add '1' ; now current term becomes previous term ; if previous added term was '1' , then add '0' ; now current term becomes previous term ; s becomes the ith term of the sequence ; Taking inputs ; generate nth term of dragon curve sequence ; Printing output","code":"< ? php function Dragon_Curve_Sequence ( $ n ) { $ s = \"1\" ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ temp = \"1\" ; $ prev = '1' ; $ zero = '0' ; $ one = '1' ; for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) { $ temp . = $ s [ $ j ] ; if ( $ prev == '0' ) { $ temp . = $ one ; $ prev = $ one ; } else { $ temp . = $ zero ; $ prev = $ zero ; } } $ s = $ temp ; } return $ s ; } $ n = 4 ; $ s = Dragon_Curve_Sequence ( $ n ) ; echo $ s . \" STRNEWLINE \" ; ? >"}
{"text":"Number of substrings of a string | PHP program to count number of substrings of a string ; Driver Code","code":"< ? php function countNonEmptySubstr ( $ str ) { $ n = strlen ( $ str ) ; return $ n * ( $ n + 1 ) \/ 2 ; } $ s = \" abcde \" ; echo countNonEmptySubstr ( $ s ) ; ? >"}
{"text":"Check if characters of one string can be swapped to form other | PHP program to check if characters of one string can be swapped to form other ; if length is not same print no ; Count frequencies of character in first string . ; iterate through the second string decrement counts of characters in second string ; Since lengths are same , some value would definitely become negative if result is false . ; Driver Code","code":"< ? php $ MAX = 26 ; function targetstring ( $ str1 , $ str2 ) { global $ MAX ; $ l1 = strlen ( $ str1 ) ; $ l2 = strlen ( $ str2 ) ; if ( $ l1 != $ l2 ) return false ; $ map [ $ MAX ] = array ( 0 ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ map [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) { $ map [ $ str2 [ $ i ] - ' a ' ] -- ; if ( $ map [ $ str2 [ $ i ] - ' a ' ] < 0 ) return false ; } return true ; } $ str1 = \" geeksforgeeks \" ; $ str2 = \" geegeeksksfor \" ; if ( targetstring ( $ str1 , $ str2 ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find the Number which contain the digit d | Returns true if d is present as digit in number x . ; Breal loop if d is present as digit ; If loop broke ; function to display the values ; Check all numbers one by one ; checking for digit ; Driver Code","code":"< ? php function isDigitPresent ( $ x , $ d ) { while ( $ x > 0 ) { if ( $ x % 10 == $ d ) break ; $ x = $ x \/ 10 ; } return ( $ x > 0 ) ; } function printNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( $ i == $ d || isDigitPresent ( $ i , $ d ) ) echo $ i , \" \u2581 \" ; } $ n = 47 ; $ d = 7 ; printNumbers ( $ n , $ d ) ; ? >"}
{"text":"Find one extra character in a string | PHP program to find extra character in one string ; result store the result ; traverse string A till end and xor with res ; xor with res ; traverse string B till end and xor with res ; xor with res ; print result at the end ; given string","code":"< ? php function findExtraCharcter ( $ strA , $ strB ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ strA ) ; $ i ++ ) { $ res ^= ord ( $ strA [ $ i ] ) ; } for ( $ i = 0 ; $ i < strlen ( $ strB ) ; $ i ++ ) { $ res ^= ord ( $ strB [ $ i ] ) ; } return $ res ; } $ strA = \" abcd \" ; $ strB = \" cbdad \" ; echo chr ( findExtraCharcter ( $ strA , $ strB ) ) ; ? >"}
{"text":"Evaluate an array expression with numbers , + and | Function to find the sum of given array ; if string is empty ; stoi function to convert string into integer ; cast to convert string into integer ; Find operator ; If operator is equal to ' + ' , add value in sum variable else subtract ; Driver code","code":"< ? php function calculateSum ( $ arr , $ n ) { if ( $ n == 0 ) return 0 ; $ s = $ arr [ 0 ] ; $ value = ( int ) $ s ; $ sum = $ value ; for ( $ i = 2 ; $ i < $ n ; $ i = $ i + 2 ) { $ s = $ arr [ $ i ] ; $ value = ( int ) $ s ; $ operation = $ arr [ $ i - 1 ] ; if ( $ operation == ' + ' ) $ sum += $ value ; else if ( $ operation == ' - ' ) $ sum -= $ value ; } return $ sum ; } $ arr = array ( \"3\" , \" + \" , \"4\" , \" - \" , \"7\" , \" + \" , \"13\" ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo calculateSum ( $ arr , $ n ) ; ? >"}
{"text":"String with maximum number of unique characters | Function to find string with maximum number of unique characters ; Index of string with maximum unique characters ; iterate through all strings ; array indicating any alphabet included or not included ; count number of unique alphabets in each string ; keep track of maximum number of alphabets ; print result ; Driver code","code":"< ? php function LargestString ( $ na ) { $ N = sizeof ( $ na ) ; $ c = array_fill ( 0 , $ N , 0 ) ; $ m = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ character = array_fill ( 0 , 26 , false ) ; for ( $ k = 0 ; $ k < strlen ( $ na [ $ j ] ) ; $ k ++ ) { $ x = ord ( $ na [ $ j ] [ $ k ] ) - 65 ; if ( ( $ na [ $ j ] [ $ k ] != ' \u2581 ' ) && ( $ character [ $ x ] == false ) ) { $ c [ $ j ] ++ ; $ character [ $ x ] = true ; } } if ( $ c [ $ j ] > $ c [ $ m ] ) $ m = $ j ; } echo $ na [ $ m ] . \" STRNEWLINE \" ; } $ na = array ( \" BOB \" , \" A \u2581 AB \u2581 C \u2581 JOHNSON \" , \" ASKRIT \" , \" ARMAN \u2581 MALLIK \" , \" ANJALI \" ) ; LargestString ( $ na ) ; ? >"}
{"text":"Morse Code Implementation | function to encode a alphabet as Morse code ; refer to the Morse table image attached in the article ; for space ; Character by character print Morse code ; Driver code","code":"< ? php function morseEncode ( $ x ) { switch ( $ x ) { case ' a ' : return \" . - \" ; case ' b ' : return \" - . . . \" ; case ' c ' : return \" - . - . \" ; case ' d ' : return \" - . . \" ; case ' e ' : return \" . \" ; case ' f ' : return \" . . - . \" ; case ' g ' : return \" - - . \" ; case ' h ' : return \" . . . . \" ; case ' i ' : return \" . . \" ; case ' j ' : return \" . - - - \" ; case ' k ' : return \" - . - \" ; case ' l ' : return \" . - . . \" ; case ' m ' : return \" - - \" ; case ' n ' : return \" - . \" ; case ' o ' : return \" - - - \" ; case ' p ' : return \" . - - . \" ; case ' q ' : return \" - - . - \" ; case ' r ' : return \" . - . \" ; case ' s ' : return \" . . . \" ; case ' t ' : return \" - \" ; case ' u ' : return \" . . - \" ; case ' v ' : return \" . . . - \" ; case ' w ' : return \" . - - \" ; case ' x ' : return \" - . . - \" ; case ' y ' : return \" - . - - \" ; case ' z ' : return \" - - . . \" ; case '1' : return \" . - - - - \" ; case '2' : return \" . . - - - \" ; case '3' : return \" . . . - - \" ; case '4' : return \" . . . . - \" ; case '5' : return \" . . . . . \" ; case '6' : return \" - . . . . \" ; case '7' : return \" - - . . . \" ; case '8' : return \" - - - . . \" ; case '9' : return \" - - - - . \" ; case '0' : return \" - - - - - \" ; } } function morseCode ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) echo morseEncode ( $ s [ $ i ] ) ; echo \" STRNEWLINE \" ; } $ s = \" geeksforgeeks \" ; morseCode ( $ s ) ; ? >"}
{"text":"Polybius Square Cipher | function to display polybius cipher text ; convert each character to its encrypted code ; finding row of the table ; finding column of the table ; if character is ' k ' ; if character is greater than ' j ' ; Driver Code ; print the cipher of \"geeksforgeeks","code":"< ? php function polybiusCipher ( $ s ) { $ row = 0 ; $ col = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ row = floor ( ( ord ( $ s [ $ i ] ) - ord ( ' a ' ) ) \/ 5 ) + 1 ; $ col = ( ( ord ( $ s [ $ i ] ) - ord ( ' a ' ) ) % 5 ) + 1 ; if ( $ s [ $ i ] == ' k ' ) { $ row = $ row - 1 ; $ col = 5 - $ col + 1 ; } else if ( $ s [ $ i ] >= ' j ' ) { if ( $ col == 1 ) { $ col = 6 ; $ row = $ row - 1 ; } $ col = $ col - 1 ; } echo ( $ row . $ col ) ; } echo ( \" STRNEWLINE \" ) ; } $ s = \" geeksforgeeks \" ; polybiusCipher ( $ s ) ; ? >"}
{"text":"Minimum removal to make palindrome permutation | function to find minimum removal of characters ; hash to store frequency of each character and to set hash array to zeros ; count frequency of each character ; count the odd frequency characters ; if count is - 1 return 0 otherwise return count ; Driver Code","code":"< ? php function minRemoval ( $ str ) { $ hash = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ hash [ ord ( $ str [ $ i ] ) - 97 ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash [ $ i ] % 2 ) $ count ++ ; return ( $ count == 0 ) ? 0 : $ count - 1 ; } $ str = \" geeksforgeeks \" ; echo minRemoval ( $ str ) . \" STRNEWLINE \" ; ? >"}
{"text":"Longest Uncommon Subsequence | function to calculate length of longest uncommon subsequence ; Case 1 : If strings are equal ; for case 2 and case 3 ; input strings","code":"< ? php function findLUSlength ( $ a , $ b ) { if ( ! strcmp ( $ a , $ b ) ) return 0 ; return max ( strlen ( $ a ) , strlen ( $ b ) ) ; } $ a = \" abcdabcd \" ; $ b = \" abcabc \" ; echo ( findLUSlength ( $ a , $ b ) ) ; ? >"}
{"text":"Interchanging first and second halves of strings | Function to concatenate two different halves of given strings ; Creating new strings by exchanging the first half of a and b . ; Driver Code ; Calling function","code":"< ? php function swapTwoHalves ( $ a , $ b ) { $ la = strlen ( $ a ) ; $ lb = strlen ( $ b ) ; $ c = substr ( $ a , 0 , intval ( $ la \/ 2 ) ) . substr ( $ b , intval ( $ lb \/ 2 ) , $ lb ) ; $ d = substr ( $ b , 0 , intval ( $ lb \/ 2 ) ) . substr ( $ a , intval ( $ la \/ 2 ) , $ la ) ; echo ( $ c . \" \" \u2581 . \u2581 $ d \u2581 . \u2581 \" \" } $ a = \" remuneration \" ; $ b = \" day \" ; swapTwoHalves ( $ a , $ b ) ; ? >"}
{"text":"Longest sub | PHP implementation to find the length of the longest sub$having frequency of each character less than equal to k ; function to find the length of the longest sub$ having frequency of each character less than equal to k ; hash table to store frequency of each table ; ' start ' index of the current substring ; to store the maximum length ; traverse the $ ' str ' ; get the current character as ' ch ' ; increase frequency of ' ch ' in ' freq [ ] ' ; if frequency of ' ch ' becomes more than ' k ' ; update ' maxLen ' ; decrease frequency of each character as they are encountered from the ' start ' index until frequency of ' ch ' is greater than ' k ' ; decrement frequency by '1' ; increment ' start ' ; update maxLen ; required length ; Driver Code","code":"< ? php $ SIZE = 26 ; function longSubstring ( $ str , $ k ) { global $ SIZE ; $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) $ freq [ $ i ] = 0 ; $ start = 0 ; $ maxLen = 0 ; $ ch = ' ' $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ ch = $ str [ $ i ] ; $ freq [ ord ( $ ch ) - ord ( ' a ' ) ] ++ ; if ( $ freq [ ord ( $ ch ) - ord ( ' a ' ) ] > $ k ) { if ( $ maxLen < ( $ i - $ start ) ) $ maxLen = $ i - $ start ; while ( $ freq [ ord ( $ ch ) - ord ( ' a ' ) ] > $ k ) { $ freq [ ord ( $ str [ $ start ] ) - ord ( ' a ' ) ] -- ; $ start ++ ; } } } if ( $ maxLen < ( $ n - $ start ) ) $ maxLen = $ n - $ start ; return $ maxLen ; } $ str = \" babcaag \" ; $ k = 1 ; echo ( \" Length \u2581 = \u2581 \" . longSubstring ( $ str , $ k ) ) ; ? >"}
{"text":"Magical Indices in an array | Function to count number of magical indices . ; Array to store parent node of traversal . ; Array to determine whether current node is already counted in the cycle . ; Initialize the arrays . ; Check if current node is already traversed or not . If node is not traversed yet then parent value will be - 1. ; Traverse the graph until an already visited node is not found . ; Check parent value to ensure a cycle is present . ; Count number of nodes in the cycle . ; Driver code","code":"< ? php function solve ( $ A , $ n ) { $ i = 0 ; $ cnt = 0 ; $ j = 0 ; $ parent = array ( ) ; $ vis = array ( ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) { $ parent [ $ i ] = -1 ; $ vis [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j = $ i ; if ( $ parent [ $ j ] == -1 ) { while ( $ parent [ $ j ] == -1 ) { $ parent [ $ j ] = $ i ; $ j = ( $ j + $ A [ $ j ] + 1 ) % $ n ; } if ( $ parent [ $ j ] == $ i ) { while ( $ vis [ $ j ] == 0 ) { $ vis [ $ j ] = 1 ; $ cnt ++ ; $ j = ( $ j + $ A [ $ j ] + 1 ) % $ n ; } } } } return $ cnt ; } $ A = array ( 0 , 0 , 0 , 2 ) ; $ n = count ( $ A ) ; echo ( solve ( $ A , $ n ) ) ; ? >"}
{"text":"Tug of War | solution by calling itself recursively ; checks whether the it is going out of bound ; checks that the numbers of elements left are not less than the number of elements required to form the solution ; consider the cases when current element is not included in the solution ; add the current element to the solution ; checks if a solution is formed ; checks if the solution formed is better than the best solution so far ; consider the cases where current element is included in the solution ; removes current element before returning to the caller of this function ; main function that generate an arr ; the boolean array that contains the inclusion and exclusion of an element in current set . The number excluded automatically form the other set ; The inclusion \/ exclusion array for final solution ; Find the solution using recursive function TOWUtil ( ) ; Print the solution ; Driver Code","code":"< ? php function TOWUtil ( & $ arr , $ n , & $ curr_elements , $ no_of_selected_elements , & $ soln , & $ min_diff , $ sum , $ curr_sum , $ curr_position ) { if ( $ curr_position == $ n ) return ; if ( ( intval ( $ n \/ 2 ) - $ no_of_selected_elements ) > ( $ n - $ curr_position ) ) return ; TOWUtil ( $ arr , $ n , $ curr_elements , $ no_of_selected_elements , $ soln , $ min_diff , $ sum , $ curr_sum , $ curr_position + 1 ) ; $ no_of_selected_elements ++ ; $ curr_sum = ( $ curr_sum + $ arr [ $ curr_position ] ) ; $ curr_elements [ $ curr_position ] = true ; if ( $ no_of_selected_elements == intval ( $ n \/ 2 ) ) { if ( abs ( intval ( $ sum \/ 2 ) - $ curr_sum ) < $ min_diff ) { $ min_diff = abs ( intval ( $ sum \/ 2 ) - $ curr_sum ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ soln [ $ i ] = $ curr_elements [ $ i ] ; } } else { TOWUtil ( $ arr , $ n , $ curr_elements , $ no_of_selected_elements , $ soln , $ min_diff , $ sum , $ curr_sum , $ curr_position + 1 ) ; } $ curr_elements [ $ curr_position ] = false ; } function tugOfWar ( & $ arr , $ n ) { $ curr_elements = array_fill ( 0 , $ n , 0 ) ; $ soln = array_fill ( 0 , $ n , 0 ) ; $ min_diff = PHP_INT_MAX ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ curr_elements [ $ i ] = $ soln [ $ i ] = false ; } TOWUtil ( $ arr , $ n , $ curr_elements , 0 , $ soln , $ min_diff , $ sum , 0 , 0 ) ; echo \" The \u2581 first \u2581 subset \u2581 is : \u2581 \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ soln [ $ i ] == true ) echo $ arr [ $ i ] . \" \u2581 \" ; } echo \" The second subset is : \" for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ soln [ $ i ] == false ) echo $ arr [ $ i ] . \" \u2581 \" ; } } $ arr = array ( 23 , 45 , -34 , 12 , 0 , 98 , -99 , 4 , 189 , -1 , 4 ) ; $ n = count ( $ arr ) ; tugOfWar ( $ arr , $ n ) ; ? >"}
{"text":"Length of the smallest sub | PHP program to find the length of the smallest substring consisting of maximum distinct characters ; Find maximum distinct characters in any string ; Initialize all character 's count with 0 ; Increase the count in array if a character is found ; size of given string ; Find maximum distinct characters in any string ; result ; Brute force approach to find all substrings ; We have to check here both conditions together 1. substring ' s \u2581 distinct \u2581 characters \u2581 is \u2581 equal \u2581 \u2581 to \u2581 maximum \u2581 distinct \u2581 characters \u2581 \u2581 2 . \u2581 substring ' s length should be minimum ; Input String","code":"< ? php $ NO_OF_CHARS = 256 ; function max_distinct_char ( $ str , $ n ) { global $ NO_OF_CHARS ; $ count = array_fill ( 0 , $ NO_OF_CHARS , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) ] ++ ; $ max_distinct = 0 ; for ( $ i = 0 ; $ i < $ NO_OF_CHARS ; $ i ++ ) if ( $ count [ $ i ] != 0 ) $ max_distinct ++ ; return $ max_distinct ; } function smallesteSubstr_maxDistictChar ( $ str ) { $ n = strlen ( $ str ) ; $ max_distinct = max_distinct_char ( $ str , $ n ) ; $ minl = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ subs = substr ( $ str , $ i , $ j ) ; $ subs_lenght = strlen ( $ subs ) ; $ sub_distinct_char = max_distinct_char ( $ subs , $ subs_lenght ) ; if ( $ subs_lenght < $ minl && $ max_distinct == $ sub_distinct_char ) { $ minl = $ subs_lenght ; } } } return $ minl ; } $ str = \" AABBBCBB \" ; $ len = smallesteSubstr_maxDistictChar ( $ str ) ; echo \" \u2581 The \u2581 length \u2581 of \u2581 the \u2581 smallest \u2581 substring \" . \" \u2581 consisting \u2581 of \u2581 maximum \u2581 distinct \u2581 characters \u2581 : \u2581 \" . $ len ; ? >"}
{"text":"Number of even substrings in a string of digits | Return the even number substrings . ; If current digit is even , add count of substrings ending with it . The count is ( i + 1 ) ; Driver Code","code":"< ? php function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; } $ str = \"1234\" ; echo evenNumSubstring ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find an index such that difference between product of elements before and after it is minimum | Function to return the index i such that the absolute difference between product of elements up to that index and the product of rest of the elements of the array is minimum ; To store the required index ; Prefix product array ; Compute the product array ; Iterate the product array to find the index ; Driver code","code":"< ? php function findIndex ( $ a , $ n ) { $ min_diff = PHP_INT_MAX ; $ prod = array ( ) ; $ prod [ 0 ] = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prod [ $ i ] = $ prod [ $ i - 1 ] * $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ curr_diff = abs ( ( $ prod [ $ n - 1 ] \/ $ prod [ $ i ] ) - $ prod [ $ i ] ) ; if ( $ curr_diff < $ min_diff ) { $ min_diff = $ curr_diff ; $ res = $ i ; } } return $ res ; } $ arr = array ( 3 , 2 , 5 , 7 , 2 , 9 ) ; $ N = count ( $ arr ) ; echo findIndex ( $ arr , $ N ) ; ? >"}
{"text":"Print all numbers whose set of prime factors is a subset of the set of the prime factors of X | Function to print all the numbers ; Iterate for every element in the array ; Find the gcd ; Iterate till gcd is 1 of number and x ; Divide the number by gcd ; Find the new gcdg ; If the number is 1 at the end then print the number ; If no numbers have been there ; Driver code","code":"< ? php function printNumbers ( $ a , $ n , $ x ) { $ flag = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num = $ a [ $ i ] ; $ g = __gcd ( $ num , $ x ) ; while ( $ g != 1 ) { $ num \/= $ g ; $ g = __gcd ( $ num , $ x ) ; } if ( $ num == 1 ) { $ flag = true ; echo $ a [ $ i ] , \" \" ; } } if ( ! $ flag ) echo ( \" There \u2581 are \u2581 no \u2581 such \u2581 numbers \" ) ; } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ x = 60 ; $ a = array ( 2 , 5 , 10 , 7 , 17 ) ; $ n = count ( $ a ) ; printNumbers ( $ a , $ n , $ x ) ; ? >"}
{"text":"Find the final radiations of each Radiated Stations | Function to print the final radiations ; Function to create the array of the resultant radiations ; Resultant radiations ; Declaring index counter for left and right radiation ; Effective radiation for left and right case ; Radiation for i - th station ; Radiation increment for left stations ; Radiation increment for right stations ; Print the resultant radiation for each of the stations ; 1 - based indexing","code":"< ? php function print_radiation ( $ rStation , $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ rStation [ $ i ] . \" \" ; } echo \" STRNEWLINE \" ; } function radiated_Station ( $ station , $ n ) { $ rStation = array ( ) ; $ rStation = array_fill ( 0 , $ n + 1 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ li = $ i - 1 ; $ ri = $ i + 1 ; $ lRad = $ station [ $ i ] - 1 ; $ rRad = $ station [ $ i ] - 1 ; $ rStation [ $ i ] += $ station [ $ i ] ; while ( $ li >= 1 && $ lRad >= 1 ) { $ rStation [ $ li -- ] += $ lRad -- ; } while ( $ ri <= $ n && $ rRad >= 1 ) { $ rStation [ $ ri ++ ] += $ rRad -- ; } } print_radiation ( $ rStation , $ n ) ; } $ station = array ( 0 , 7 , 9 , 12 , 2 , 5 ) ; $ n = ( sizeof ( $ station ) \/ sizeof ( $ station [ 0 ] ) ) - 1 ; radiated_Station ( $ station , $ n ) ; ? >"}
{"text":"Program to find the maximum difference between the index of any two different numbers | Function to return the maximum difference ; Iteratively check from back ; Different numbers ; Iteratively check from the beginning ; Different numbers ; Driver code","code":"< ? php function findMaximumDiff ( $ a , $ n ) { $ ind1 = 0 ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ a [ 0 ] != $ a [ $ i ] ) { $ ind1 = $ i ; break ; } } $ ind2 = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ n - 1 ] != $ a [ $ i ] ) { $ ind2 = ( $ n - 1 - $ i ) ; break ; } } return max ( $ ind1 , $ ind2 ) ; } $ a = array ( 1 , 2 , 3 , 2 , 3 ) ; $ n = count ( $ a ) ; echo findMaximumDiff ( $ a , $ n ) ; ? >"}
{"text":"Sum of the series Kn + ( K ( n | Function to return sum ; Driver code","code":"< ? php function sum ( $ k , $ n ) { $ sum = pow ( $ k , $ n + 1 ) - pow ( $ k - 1 , $ n + 1 ) ; return $ sum ; } $ n = 3 ; $ K = 3 ; echo sum ( $ K , $ n ) ;"}
{"text":"Check whether factorial of N is divisible by sum of first N natural numbers | Function to check whether a number is prime or not . ; Count variable to store the number of factors of ' num ' ; Counting the number of factors ; If number is prime return true ; Function to check for divisibility ; if ' n ' equals 1 then divisibility is possible ; Else check whether ' n + 1' is prime or not ; If ' n + 1' is prime then ' n ! ' is not divisible by ' n * ( n + 1 ) \/ 2' ; else divisibility occurs ; Test for n = 3 ; Test for n = 4","code":"< ? php function is_prime ( $ num ) { $ count1 = 0 ; for ( $ i = 1 ; $ i * $ i <= ( $ num ) ; $ i ++ ) { if ( ( $ num ) % $ i == 0 ) { if ( $ i * $ i != ( $ num ) ) $ count1 += 2 ; else $ count1 ++ ; } } if ( $ count1 == 2 ) return true ; else return false ; } function is_divisible ( $ n ) { if ( $ n == 1 ) { return \" YES \" ; } else { if ( is_prime ( $ n + 1 ) ) return \" NO \" ; else return \" YES \" ; } } $ n = 3 ; echo is_divisible ( $ n ) . \" STRNEWLINE \" ; $ n = 4 ; echo is_divisible ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Given two binary strings perform operation until B > 0 and print the result | PHP implementation of the approach ; Function to return the required result ; Reverse the strings ; Count the number of set bits in b ; To store the powers of 2 ; power [ i ] = pow ( 2 , i ) % mod ; To store the final answer ; Add power [ i ] to the ans after multiplying it with the number of set bits in b ; Divide by 2 means right shift b >> 1 if b has 1 at right most side than number of set bits will get decreased ; If no more set bits in b i . e . b = 0 ; Return the required answer ; Driver code","code":"< ? php $ GLOBALS [ ' mod ' ] = ( 1e9 + 7 ) ; function BitOperations ( $ a , $ n , $ b , $ m ) { $ a = strrev ( $ a ) ; $ b = strrev ( $ b ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] == '1' ) $ c ++ ; $ power = array ( ) ; $ power [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ power [ $ i ] = ( $ power [ $ i - 1 ] * 2 ) % $ GLOBALS [ ' mod ' ] ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == '1' ) { $ ans += $ c * $ power [ $ i ] ; if ( $ ans >= $ GLOBALS [ ' mod ' ] ) $ ans %= $ GLOBALS [ ' mod ' ] ; } if ( $ b [ $ i ] == '1' ) $ c -- ; if ( $ c == 0 ) break ; } return $ ans ; } $ a = \"1001\" ; $ b = \"10101\" ; $ n = strlen ( $ a ) ; $ m = strlen ( $ b ) ; echo BitOperations ( $ a , $ n , $ b , $ m ) ; ? >"}
{"text":"Print prime numbers with prime sum of digits in an array | Function to store the primes ; Function to return the sum of digits ; Function to print additive primes ; If the number is prime ; Check if it 's digit sum is prime ; Driver code","code":"< ? php function sieve ( $ maxEle , & $ prime ) { $ prime [ 0 ] = $ prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i * $ i <= $ maxEle ; $ i ++ ) { if ( ! $ prime [ $ i ] ) { for ( $ j = 2 * $ i ; $ j <= $ maxEle ; $ j += $ i ) $ prime [ $ j ] = 1 ; } } } function digitSum ( $ n ) { $ sum = 0 ; while ( $ n ) { $ sum += $ n % 10 ; $ n = $ n \/ 10 ; } return $ sum ; } function printAdditivePrime ( $ arr , $ n ) { $ maxEle = max ( $ arr ) ; $ prime = array_fill ( 0 , $ maxEle + 1 , 0 ) ; sieve ( $ maxEle , $ prime ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] == 0 ) { $ sum = digitSum ( $ arr [ $ i ] ) ; if ( $ prime [ $ sum ] == 0 ) print ( $ arr [ $ i ] . \" \u2581 \" ) ; } } } $ a = array ( 2 , 4 , 6 , 11 , 12 , 18 , 7 ) ; $ n = count ( $ a ) ; printAdditivePrime ( $ a , $ n ) ; ? >"}
{"text":"Program to find nth term of the series 1 4 15 24 45 60 92 | function to calculate nth term of the series ; variable nth will store the nth term of series ; if n is even ; if n is odd ; return nth term ; Driver code","code":"< ? php function nthTerm ( $ n ) { $ nth ; if ( $ n % 2 == 0 ) $ nth = 2 * ( ( $ n * $ n ) - $ n ) ; else $ nth = ( 2 * $ n * $ n ) - $ n ; return $ nth ; } $ n = 5 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; $ n = 25 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; $ n = 25000000 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; $ n = 250000007 ; echo nthTerm ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find the Nth term of the series 9 , 45 , 243 , 1377 | Function to return the nth term of the given series ; nth term of the given series ; Driver code","code":"< ? php function nthterm ( $ n ) { $ An = ( pow ( 1 , $ n ) + pow ( 2 , $ n ) ) * pow ( 3 , $ n ) ; return $ An ; } $ n = 3 ; echo nthterm ( $ n ) ; ? >"}
{"text":"Count the numbers < N which have equal number of divisors as K | Function to return the count of the divisors of a number ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ; While i divides n ; This condition is to handle the case when n is a prime number > 2 ; Count the total elements that have divisors exactly equal to as that of k 's ; Exclude k from the result if it is smaller than n . ; Driver code","code":"< ? php function countDivisors ( $ n ) { $ x = 0 ; $ ans = 1 ; while ( $ n % 2 == 0 ) { $ x ++ ; $ n = $ n \/ 2 ; } $ ans = $ ans * ( $ x + 1 ) ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { $ x = 0 ; while ( $ n % $ i == 0 ) { $ x ++ ; $ n = $ n \/ $ i ; } $ ans = $ ans * ( $ x + 1 ) ; } if ( $ n > 2 ) $ ans = $ ans * 2 ; return $ ans ; } function getTotalCount ( $ n , $ k ) { $ k_count = countDivisors ( $ k ) ; $ count = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ k_count == countDivisors ( $ i ) ) $ count ++ ; if ( $ k < $ n ) $ count = $ count - 1 ; return $ count ; } $ n = 500 ; $ k = 6 ; echo getTotalCount ( $ n , $ k ) ; #This  code is contributed by Sachin.. NEW_LINE ? >"}
{"text":"Find the nth term of the series 0 , 8 , 64 , 216 , 512 , . . . | Function to return the nth term of the given series ; Common difference ; First term ; nth term ; nth term of the given series ; Driver code","code":"< ? php function term ( $ n ) { $ d = 2 ; $ a1 = 0 ; $ An = $ a1 + ( $ n - 1 ) * $ d ; return pow ( $ An , 3 ) ; } $ n = 5 ; echo term ( $ n ) ; ? >"}
{"text":"Count the number of intervals in which a given value lies | PHP program to count the number of intervals in which a given value lies ; Function to count the number of intervals in which a given value lies ; Variables to store overall minimum and maximum of the intervals ; Variables to store start and end of an interval ; Frequency array to keep track of how many of the given intervals an element lies in ; Constructing the frequency array ; Driver code ; length of the array","code":"< ? php $ MAX_VAL = 200000 ; function countIntervals ( $ arr , $ V , $ N ) { global $ MAX_VAL ; $ min = PHP_INT_MAX ; $ max = 0 ; $ li = 0 ; $ ri = 0 ; $ freq = array_fill ( 0 , $ MAX_VAL , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ li = $ arr [ $ i ] [ 0 ] ; $ freq [ $ li ] = $ freq [ $ li ] + 1 ; $ ri = $ arr [ $ i ] [ 1 ] ; $ freq [ $ ri + 1 ] = $ freq [ $ ri + 1 ] - 1 ; if ( $ li < $ min ) $ min = $ li ; if ( $ ri > $ max ) $ max = $ ri ; } for ( $ i = $ min ; $ i <= $ max ; $ i ++ ) $ freq [ $ i ] = $ freq [ $ i ] + $ freq [ $ i - 1 ] ; return $ freq [ $ V ] ; } $ arr = array ( array ( 1 , 10 ) , array ( 5 , 10 ) , array ( 15 , 25 ) , array ( 7 , 12 ) , array ( 20 , 25 ) ) ; $ V = 7 ; $ N = count ( $ arr ) ; echo ( countIntervals ( $ arr , $ V , $ N ) ) ; ? >"}
{"text":"Split N ^ 2 numbers into N groups of equal sum | Function to print N groups of equal sum ; No . of Groups ; n \/ 2 pairs ; Driver code","code":"< ? php function printGroups ( $ n ) { $ x = 1 ; $ y = $ n * $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n \/ 2 ; $ j ++ ) { echo \" { \" \u2581 , \u2581 $ x \u2581 , \u2581 \" , \" \u2581 , \u2581 $ y \u2581 , \u2581 \" } \" $ x ++ ; $ y -- ; } echo \" STRNEWLINE \" ; } } $ n = 4 ; printGroups ( $ n ) ; ? >"}
{"text":"Program to find the Break Even Point | Function to calculate Break Even Point ; Calculating number of articles to be sold ; Driver Code","code":"< ? php function breakEvenPoint ( $ exp , $ S , $ M ) { $ earn = $ S - $ M ; $ res = ceil ( $ exp \/ $ earn ) ; return $ res ; } $ exp = 3550 ; $ S = 90 ; $ M = 65 ; echo breakEvenPoint ( $ exp , $ S , $ M ) ; ? >"}
{"text":"Minimize the value of N by applying the given operations | function to return the product of distinct prime factors of a number ; find distinct prime ; Driver code","code":"< ? php function minimum ( $ n ) { $ product = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) $ n = $ n \/ $ i ; $ product = $ product * $ i ; } } if ( $ n >= 2 ) $ product = $ product * $ n ; return $ product ; } $ n = 20 ; echo minimum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"N digit numbers divisible by 5 formed from the M digits | Function to find the count of all possible N digit numbers which are divisible by 5 formed from M digits ; If it is not possible to form n digit number from the given m digits without repetition ; If both zero and five exists ; Remaining N - 1 iterations ; Remaining N - 1 iterations ; Driver code","code":"< ? php function numbers ( $ n , $ arr , $ m ) { $ isZero = 0 ; $ isFive = 0 ; $ result = 0 ; if ( $ m < $ n ) { return -1 ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) $ isZero = 1 ; if ( $ arr [ $ i ] == 5 ) $ isFive = 1 ; } if ( $ isZero && $ isFive ) { $ result = 2 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ result = $ result * ( -- $ m ) ; } } else if ( $ isZero $ isFive ) { $ result = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ result = $ result * ( -- $ m ) ; } } else $ result = -1 ; return $ result ; } $ n = 3 ; $ m = 6 ; $ arr = array ( 2 , 3 , 5 , 6 , 7 , 9 ) ; echo numbers ( $ n , $ arr , $ m ) ; ? >"}
{"text":"Program to find the smallest element among three elements | PHP implementation to find the smallest of three elements","code":"< ? php $ a = 5 ; $ b = 7 ; $ c = 10 ; if ( $ a <= $ b && $ a <= $ c ) echo $ a . \" \u2581 is \u2581 the \u2581 smallest \" ; else if ( $ b <= $ a && $ b <= $ c ) echo $ b . \" \u2581 is \u2581 the \u2581 smallest \" ; else echo $ c . \" \u2581 is \u2581 the \u2581 smallest \" ;"}
{"text":"Find subsequences with maximum Bitwise AND and Bitwise OR | Function to find the maximum sum ; Maximum AND is maximum element ; Maximum OR is bitwise OR of all . ; Driver code","code":"< ? php function maxSum ( $ a , $ n ) { $ maxAnd = max ( $ a ) ; $ maxOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ maxOR |= $ a [ $ i ] ; print ( $ maxAnd + $ maxOR ) ; } $ n = 4 ; $ a = array ( 3 , 5 , 6 , 1 ) ; maxSum ( $ a , $ n ) ; ? >"}
{"text":"Minimum and Maximum element of an array which is divisible by a given number k | Function to find the minimum element ; Function to find the maximum element ; Driver code","code":"< ? php function getMin ( $ arr , $ n , $ k ) { $ res = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ res = min ( $ res , $ arr [ $ i ] ) ; } return $ res ; } function getMax ( $ arr , $ n , $ k ) { $ res = PHP_INT_MIN ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ res = max ( $ res , $ arr [ $ i ] ) ; } return $ res ; } $ arr = array ( 10 , 1230 , 45 , 67 , 1 ) ; $ k = 10 ; $ n = sizeof ( $ arr ) ; echo \" Minimum \u2581 element \u2581 of \u2581 array \u2581 which \u2581 is \u2581 \" . \" divisible \u2581 by \u2581 k : \u2581 \" , getMin ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; echo \" Maximum \u2581 element \u2581 of \u2581 array \u2581 which \u2581 is \u2581 \" . \" divisible \u2581 by \u2581 k : \u2581 \" , getMax ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Print a number containing K digits with digital root D | Function to find a number ; If d is 0 k has to be 1 ; Print k - 1 zeroes ; Driver code","code":"< ? php function printNumberWithDR ( $ k , $ d ) { if ( $ d == 0 && $ k != 1 ) echo \" - 1\" ; else { echo $ d ; $ k -- ; while ( $ k -- ) echo \"0\" ; } } $ k = 4 ; $ d = 4 ; printNumberWithDR ( $ k , $ d ) ; ? >"}
{"text":"Count number of integers less than or equal to N which has exactly 9 divisors | PHP implementation of above approach Function to count numbers having exactly 9 divisors ; Sieve array ; initially prime [ i ] = i ; use sieve concept to store the first prime factor of every number ; mark all factors of i ; check for all numbers if they can be expressed in form p * q ; p prime factor ; q prime factor ; if both prime factors are different if p * q <= n and q != ; Check if it can be expressed as p ^ 8 ; Driver Code","code":"< ? php function countNumbers ( $ n ) { $ c = 0 ; $ limit = sqrt ( $ n ) ; $ prime [ $ limit + 1 ] = array ( 0 ) ; for ( $ i = 1 ; $ i <= $ limit ; $ i ++ ) $ prime [ $ i ] = $ i ; for ( $ i = 2 ; $ i * $ i <= $ limit ; $ i ++ ) { if ( $ prime [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j <= $ limit ; $ j += $ i ) if ( $ prime [ $ j ] == $ j ) $ prime [ $ j ] = $ i ; } } for ( $ i = 2 ; $ i <= $ limit ; $ i ++ ) { $ p = $ prime [ $ i ] ; $ q = $ prime [ $ i \/ $ prime [ $ i ] ] ; if ( $ p * $ q == $ i && $ q != 1 && $ p != $ q ) { $ c += 1 ; } else if ( $ prime [ $ i ] == $ i ) { if ( pow ( $ i , 8 ) <= $ n ) { $ c += 1 ; } } } return $ c ; } $ n = 1000 ; echo countNumbers ( $ n ) ; ? >"}
{"text":"Interprime | Function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the given number is interprime or not ; Smallest Interprime is 4 So the number less than 4 can not be a Interprime ; Calculate first prime number < n ; Calculate first prime number > n ; Check if prev_prime and next_prime have the same average ; Driver Code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 or $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 or $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } function isInterprime ( $ n ) { if ( $ n < 4 ) return false ; $ prev_prime = $ n ; $ next_prime = $ n ; while ( ! isPrime ( $ prev_prime ) ) { $ prev_prime -- ; } while ( ! isPrime ( $ next_prime ) ) { $ next_prime ++ ; } if ( ( $ prev_prime + $ next_prime ) == 2 * $ n ) return true ; else return false ; } $ n = 9 ; if ( isInterprime ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find the unit place digit of sum of N factorials | Function to find the unit 's place digit ; Let us write for cases when N is smaller than or equal to 4. ; We know following ( 1 ! + 2 ! + 3 ! + 4 ! ) % 10 = 3 else ( N >= 4 ) ; Driver code","code":"< ? php function get_unit_digit ( $ N ) { if ( $ N == 0 $ N == 1 ) return 1 ; else if ( $ N == 2 ) return 3 ; else if ( $ N == 3 ) return 9 ; return 3 ; } $ N = 1 ; for ( $ N = 0 ; $ N <= 10 ; $ N ++ ) echo \" For \u2581 N \u2581 = \u2581 \" . $ N . \" \u2581 : \u2581 \" . get_unit_digit ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Sum of squares of Fibonacci numbers | PHP Program to find sum of squares of Fibonacci numbers in O ( Log n ) time . ; Create an array for memoization ; Returns n 'th Fibonacci number using table f[] ; Base cases ; If fib ( n ) is already computed ; Applying above formula [ Note value n & 1 is 1 if n is odd , else 0 ] . ; Function to calculate sum of squares of Fibonacci numbers ; Driver Code","code":"< ? php $ MAX = 1000 ; global $ f ; $ f = array_fill ( 0 , $ MAX , 0 ) ; function fib ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return ( $ f [ $ n ] = 1 ) ; $ k = ( $ n & 1 ) ? ( $ n + 1 ) \/ 2 : $ n \/ 2 ; $ f [ $ n ] = ( $ n & 1 ) ? ( fib ( $ k ) * fib ( $ k ) + fib ( $ k - 1 ) * fib ( $ k - 1 ) ) : ( 2 * fib ( $ k - 1 ) + fib ( $ k ) ) * fib ( $ k ) ; return $ f [ $ n ] ; } function calculateSumOfSquares ( $ n ) { return fib ( $ n ) * fib ( $ n + 1 ) ; } $ n = 6 ; echo \" Sum \u2581 of \u2581 Squares \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \u2581 \" ; echo calculateSumOfSquares ( $ n ) ; ? >"}
{"text":"Number of solutions for the equation x + y + z <= n | function to find the number of solutions for the equation x + y + z <= n , such that 0 <= x <= X , 0 <= y <= Y , 0 <= z <= Z . ; to store answer ; for values of x ; for values of y ; maximum possible value of z ; if z value greater than equals to 0 then only it is valid ; find minimum of temp and z ; return required answer ; Driver code","code":"< ? php function NumberOfSolutions ( $ x , $ y , $ z , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i <= $ x ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ y ; $ j ++ ) { $ temp = $ n - $ i - $ j ; if ( $ temp >= 0 ) { $ temp = min ( $ temp , $ z ) ; $ ans += $ temp + 1 ; } } } return $ ans ; } $ x = 1 ; $ y = 2 ; $ z = 3 ; $ n = 4 ; echo NumberOfSolutions ( $ x , $ y , $ z , $ n ) ; ? >"}
{"text":"Program to find the Nth term of series 5 , 12 , 21 , 32 , 45. ... . . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 4 * $ n ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Numbers less than N which are product of exactly two distinct prime numbers | Function to check whether a number is a PerfectSquare or not ; Function to check if a number is a product of exactly two distinct primes ; Function to find numbers that are product of exactly two distinct prime numbers . ; Vector to store such numbers ; insert in the vector ; Print all numbers till n from the vector ; Driver Code","code":"< ? php function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; } function isProduct ( $ num ) { $ cnt = 0 ; for ( $ i = 2 ; $ cnt < 2 && $ i * $ i <= $ num ; ++ $ i ) { while ( $ num % $ i == 0 ) { $ num \/= $ i ; ++ $ cnt ; } } if ( $ num > 1 ) ++ $ cnt ; return $ cnt == 2 ; } function findNumbers ( $ N ) { $ vec = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( isProduct ( $ i ) && ! isPerfectSquare ( $ i ) ) { array_push ( $ vec , $ i ) ; } } for ( $ i = 0 ; $ i < sizeof ( $ vec ) ; $ i ++ ) { echo $ vec [ $ i ] . \" \" ; } } $ N = 30 ; findNumbers ( $ N ) ;"}
{"text":"Program to find the Nth term of the series 3 , 20 , 63 , 144 , 230 , \u00e2 \u20ac\u00a6 \u00e2 \u20ac\u00a6 | calculate Nth term of series ; return final sum ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 3 ) + pow ( $ n , 2 ) ; } $ N = 3 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Find Nth number of the series 1 , 6 , 15 , 28 , 45 , ... . . | PHP program to find Nth term of the series ; function to return nth term of the series ; Taking n as 4 ; function call","code":"< ? php $ mod = 1000000009 ; function NthTerm ( $ n ) { global $ mod ; $ x = ( 2 * $ n * $ n ) % $ mod ; return ( $ x - $ n + $ mod ) % $ mod ; } $ N = 4 ; echo NthTerm ( $ N ) ; ? >"}
{"text":"Program to print the Sum of series | calculate Nth term of series ; Get the value of N ; Get the sum of the series","code":"< ? php function findSum ( $ N ) { return ( $ N * ( $ N + 1 ) * ( 2 * $ N - 5 ) + 4 * $ N ) \/ 2 ; } $ N = 3 ; echo findSum ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program to find the Nth term of series | calculate Nth term of series ; Get the value of N ; Find the Nth term and print it","code":"< ? php function nthTerm ( $ N ) { return ( ( 3 * $ N * $ N ) - ( 6 * $ N ) + 2 ) ; } $ N = 3 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Program to find the value of tan ( n\u00ce \u02dc ) | PHP program to find the value of cos ( n - theta ) ; This function use to calculate the binomial coefficient upto 15 ; use simple DP to find coefficient ; Function to find the value of ; store required answer ; use to toggle sign in sequence . ; calculate numerator ; calculate denominator ; Driver code .","code":"< ? php $ MAX = 16 ; $ nCr = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , 0 ) ) ; function binomial ( ) { global $ MAX , $ nCr ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ nCr [ $ i ] [ $ j ] = 1 ; else $ nCr [ $ i ] [ $ j ] = $ nCr [ $ i - 1 ] [ $ j ] + $ nCr [ $ i - 1 ] [ $ j - 1 ] ; } } } function findTanNTheta ( $ tanTheta , $ n ) { global $ MAX , $ nCr ; $ ans = 0 ; $ numerator = 0 ; $ denominator = 0 ; $ toggle = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) { $ numerator = $ numerator + $ nCr [ $ n ] [ $ i ] * pow ( $ tanTheta , $ i ) * $ toggle ; $ toggle = $ toggle * -1 ; } $ denominator = 1 ; $ toggle = -1 ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) { $ numerator = $ numerator + $ nCr [ $ n ] [ $ i ] * pow ( $ tanTheta , $ i ) * $ toggle ; $ toggle = $ toggle * -1 ; } $ ans = $ numerator \/ $ denominator ; return $ ans ; } binomial ( ) ; $ tanTheta = 0.3 ; $ n = 10 ; echo findTanNTheta ( $ tanTheta , $ n ) ; ? >"}
{"text":"Pizza cut problem ( Or Circle Division by Lines ) | Function for finding maximum pieces with n cuts . ; Driver code","code":"< ? php function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) \/ 2 ; } echo findMaximumPieces ( 3 ) ; ? >"}
{"text":"Check if any large number is divisible by 19 or not | Function to check if the number is divisible by 19 or not ; Extracting the last digit ; Truncating the number ; Adding twice the last digit to the remaining number ; return true if number is divisible by 19 ; Driver code","code":"< ? php function isDivisible ( $ n ) { while ( 1 ) { $ d = $ n % 10 ; $ n = $ n \/ 10 ; $ n = $ n + $ d * 2 ; if ( $ n < 100 ) break ; } return ( $ n % 19 == 0 ) ; } $ n = 38 ; if ( isDivisible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program to find Sum of the series 1 * 3 + 3 * 5 + ... . | PHP program to find sum of first n terms ; Sn = n * ( 4 * n * n + 6 * n - 1 ) \/ 3 ; number of terms to be included in the sum ; find the Sn","code":"< ? php function calculateSum ( $ n ) { return ( $ n * ( 4 * $ n * $ n + 6 * $ n - 1 ) \/ 3 ) ; } $ n = 4 ; echo \" Sum = \" ? >"}
{"text":"Triplet with no element divisible by 3 and sum N | Function to print a , b and c ; first loop ; check for 1 st number ; second loop ; check for 2 nd number ; third loop ; Check for 3 rd number ; Driver Code","code":"< ? php function printCombination ( $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 3 != 0 ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ j % 3 != 0 ) { for ( $ k = 1 ; $ k < $ n ; $ k ++ ) { if ( $ k % 3 != 0 && ( $ i + $ j + $ k ) == $ n ) { echo $ i , \" \" \u2581 , \u2581 $ j \u2581 , \u2581 \" \" return ; } } } } } } } $ n = 233 ; printCombination ( $ n ) ;"}
{"text":"Program to find the percentage of difference between two numbers | Function to calculate the percentage ; Driver Code ; Function calling","code":"< ? php function percent ( $ a , $ b ) { $ result = 0 ; $ result = ( ( $ b - $ a ) * 100 ) \/ $ a ; return $ result ; } $ a = 20 ; $ b = 25 ; echo percent ( $ a , $ b ) . \" % \" ; ? >"}
{"text":"Count numbers which can be represented as sum of same parity primes | Function to calculate count ; Driver Code","code":"< ? php function calculate ( & $ array , $ size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) if ( $ array [ $ i ] % 2 == 0 && $ array [ $ i ] != 0 && $ array [ $ i ] != 2 ) $ count ++ ; return $ count ; } $ a = array ( 1 , 3 , 4 , 6 ) ; $ size = sizeof ( $ a ) ; echo calculate ( $ a , $ size ) ; ? >"}
{"text":"Program to find HCF ( Highest Common Factor ) of 2 Numbers | Recursive function to return gcd of a and b ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } $ a = 98 ; $ b = 56 ; echo \" GCD \u2581 of \u2581 $ a \u2581 and \u2581 $ b \u2581 is \u2581 \" , gcd ( $ a , $ b ) ; ? >"}
{"text":"Largest number with maximum trailing nines which is less than N and greater than N | function to count no of digits ; function to implement above approach ; if difference between power and n doesn 't exceed d ; loop to build a number from the appropriate no of digits containing only 9 ; if the build number is same as original number ( n ) ; observation ; Driver Code ; variable that stores no of digits in n","code":"< ? php function dig ( $ a ) { $ count = 0 ; while ( $ a > 0 ) { $ a = ( int ) ( $ a \/ 10 ) ; $ count ++ ; } return $ count ; } function required_number ( $ num , $ n , $ d ) { $ flag = 0 ; for ( $ i = $ num ; $ i >= 1 ; $ i -- ) { $ power = pow ( 10 , $ i ) ; $ a = $ n % $ power ; if ( $ d > $ a ) { $ flag = 1 ; break ; } } if ( $ flag ) { $ t = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ t += 9 * pow ( 10 , $ j ) ; } if ( $ n % $ power == $ t ) echo $ n ; else { echo ( $ n - ( $ n % $ power ) - 1 ) ; } } else echo $ n ; } $ n = 1029 ; $ d = 102 ; $ num = dig ( $ n ) ; required_number ( $ num , $ n , $ d ) ; ? >"}
{"text":"Egg Dropping Puzzle with 2 Eggs and K Floors | PHP program to find optimal number of trials for k floors and 2 eggs . ; Driver Code","code":"< ? php function twoEggDrop ( $ k ) { return ceil ( ( -1.0 + sqrt ( 1 + 8 * $ k ) ) \/ 2.0 ) ; } $ k = 100 ; echo twoEggDrop ( $ k ) ;"}
{"text":"Program to find the Area and Volume of Icosahedron | Function to find area of Icosahedron ; Formula to calculating area ; Function to find volume of Icosahedron ; Formula to calculating volume ; Driver Code ; Function call to find area of Icosahedron . ; Function call to find volume of Icosahedron .","code":"< ? php function findArea ( $ a ) { $ area ; $ area = 5 * sqrt ( 3 ) * $ a * $ a ; return $ area ; } function findVolume ( $ a ) { $ volume ; $ volume = ( ( float ) 5 \/ 12 ) * ( 3 + sqrt ( 5 ) ) * $ a * $ a * $ a ; return $ volume ; } $ a = 5 ; echo \" Area : \" \u2581 , \u2581 findArea ( $ a ) , \u2581 \" \" ; STRNEWLINE echo \u2581 \" Volume : \" ? >"}
{"text":"Total number of ways to place X and Y at n places such that no two X are together | Function to return number of ways ; for n = 1 ; for n = 2 ; iterate to find Fibonacci term ; total number of places","code":"< ? php function ways ( $ n ) { $ first = 2 ; $ second = 3 ; $ res = 0 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ res = $ first + $ second ; $ first = $ second ; $ second = $ res ; } return $ res ; } $ n = 7 ; echo \" Total \u2581 ways \u2581 are : \u2581 \" , ways ( $ n ) ; ? >"}
{"text":"Number of digits in N factorial to the power N | PHP program to find count of digits in N factorial raised to N ; we take sum of logarithms as explained in the approach ; multiply the result with n ; Driver Code","code":"< ? php function countDigits ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += log10 ( $ i ) ; $ ans = $ ans * $ n ; return 1 + floor ( $ ans ) ; } $ n = 4 ; echo countDigits ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program to convert centimeter into meter and kilometer | Driver Code ; Converting centimeter into meter and kilometer","code":"< ? php $ cm ; $ meter ; $ kilometer ; $ cm = 1000 ; $ meter = $ cm \/ 100.0 ; $ kilometer = $ cm \/ 100000.0 ; echo \" Length \u2581 in \u2581 meter \u2581 = \u2581 \" , $ meter , \" m \" , \" STRNEWLINE \" ; echo \" Length \u2581 in \u2581 Kilometer \u2581 = \u2581 \" , $ kilometer , \" km \" , \" STRNEWLINE \" ; ? >"}
{"text":"Check if two people starting from different points ever meet | PHP program to find if two people starting from different positions ever meet or not . ; If speed of a person at a position before other person is smaller , then return false . ; Making sure that x1 is greater ; checking if relative speed is a factor of relative distance or not ; Driver code","code":"< ? php function everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) { if ( $ x1 < $ x2 && $ v1 <= $ v2 ) return false ; if ( $ x1 > $ x2 && $ v1 >= $ v2 ) return false ; if ( $ x1 < $ x2 ) { list ( $ x1 , $ x2 ) = array ( $ x2 , $ x1 ) ; list ( $ v2 , $ v1 ) = array ( $ v1 , $ v2 ) ; } return ( ( $ x1 - $ x2 ) % ( $ v1 - $ v2 ) == 0 ) ; } $ x1 = 5 ; $ v1 = 8 ; $ x2 = 4 ; $ v2 = 7 ; if ( everMeet ( $ x1 , $ x2 , $ v1 , $ v2 ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text":"Find ceil of a \/ b without using ceil ( ) function | taking input 1 ; example of perfect division taking input 2","code":"< ? php $ a = 4 ; $ b = 3 ; $ val = ( $ a + $ b - 1 ) \/ $ b ; echo \" The \u2581 ceiling \u2581 value \u2581 of \u2581 4\/3 \u2581 is \u2581 \" , floor ( $ val ) , \" STRNEWLINE \" ; $ a = 6 ; $ b = 3 ; $ val = ( $ a + $ b - 1 ) \/ $ b ; echo \" The \u2581 ceiling \u2581 value \u2581 of \u2581 6\/3 \u2581 is \u2581 \" , floor ( $ val ) ; ? >"}
{"text":"Sum of range in a series of first odd then even natural numbers | Function that returns sum in the range 1 to x in the sequence 1 3 5 7. ... . N 2 4 6. . . N - 1 ; number of odd numbers ; number of extra even numbers required ; Driver code","code":"< ? php function sumTillX ( $ x , $ n ) { $ odd = ceil ( $ n \/ 2.0 ) ; if ( $ x <= $ odd ) return $ x * $ x ; $ even = $ x - $ odd ; return ( ( $ odd * $ odd ) + ( $ even * $ even ) + $ even ) ; } function rangeSum ( $ N , $ L , $ R ) { return sumTillX ( $ R , $ N ) - sumTillX ( $ L - 1 , $ N ) ; } $ N = 10 ; $ L = 1 ; $ R = 6 ; echo ( rangeSum ( $ N , $ L , $ R ) ) ; ? >"}
{"text":"Twin Prime Numbers between 1 and n | PHP program to print all twin primes using Sieve of Eratosthenes . ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; to check for twin prime numbers display the twin primes ; Driver Code ; Calling the function","code":"< ? php function printTwinPrime ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ n - 2 ; $ p ++ ) if ( $ prime [ $ p ] && $ prime [ $ p + 2 ] ) echo \" ( \" . $ p . \" , \u2581 \" . ( $ p + 2 ) . \" ) \" ; } $ n = 25 ; printTwinPrime ( $ n ) ; ? >"}
{"text":"Cube Free Numbers smaller than n | Returns true if n is a cube free number , else returns false . ; check for all possible divisible cubes ; Print all cube free numbers smaller than n . ; Driver code","code":"< ? php function isCubeFree ( $ n ) { if ( $ n == 1 ) return false ; for ( $ i = 2 ; $ i * $ i * $ i <= $ n ; $ i ++ ) if ( $ n % ( $ i * $ i * $ i ) == 0 ) return false ; return true ; } function printCubeFree ( $ n ) { for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( isCubeFree ( $ i ) ) echo $ i . \" \" ; } $ n = 20 ; printCubeFree ( $ n ) ; ? >"}
{"text":"Decimal Equivalent of Gray Code and its Inverse | Function to convert given decimal number of gray code into its inverse in decimal form ; Taking xor until n becomes zero ; Driver Code","code":"< ? php function inversegrayCode ( $ n ) { $ inv = 0 ; for ( ; $ n ; $ n = $ n >> 1 ) $ inv ^= $ n ; return $ inv ; } $ n = 15 ; echo inversegrayCode ( $ n ) ; ? >"}
{"text":"Product of unique prime factors of a number | A function to print all prime factors of a given number n ; Handle prime factor 2 explicitly so that can optimally handle other prime factors . ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Driver Code","code":"< ? php function productPrimeFactors ( $ n ) { $ product = 1 ; if ( $ n % 2 == 0 ) { $ product *= 2 ; while ( $ n % 2 == 0 ) $ n = $ n \/ 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ product = $ product * $ i ; while ( $ n % $ i == 0 ) $ n = $ n \/ $ i ; } } if ( $ n > 2 ) $ product = $ product * $ n ; return $ product ; } $ n = 44 ; echo productPrimeFactors ( $ n ) ; ? >"}
{"text":"Maximizing Probability of one type from N containers | Returns the Maximum probability for Drawing 1 copy of number A from N containers with N copies each of numbers A and B ; Pmax = N \/ ( N + 1 ) ; 1. N = 1 ; 2. N = 2 ; 3. N = 10","code":"< ? php function calculateProbability ( $ N ) { $ probability = $ N \/ ( $ N + 1 ) ; return $ probability ; } $ N = 1 ; $ probabilityMax = calculateProbability ( $ N ) ; echo ( \" Maximum \u2581 Probability \u2581 for \u2581 N \u2581 = \u2581 \" . $ N . \" is , \" round ( $ probabilityMax , 4 ) . \" STRNEWLINE \" ) ; $ N = 2 ; $ probabilityMax = calculateProbability ( $ N ) ; echo ( \" Maximum \u2581 Probability \u2581 for \u2581 N \u2581 = \u2581 \" . $ N . \" is , \" round ( $ probabilityMax , 4 ) . \" STRNEWLINE \" ) ; $ N = 10 ; $ probabilityMax = calculateProbability ( $ N ) ; echo ( \" Maximum \u2581 Probability \u2581 for \u2581 N \u2581 = \u2581 \" . $ N . \" is , \" round ( $ probabilityMax , 4 ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Program to implement standard deviation of grouped data | Function to find mean of grouped data . ; Function to find standard deviation of grouped data . ; Formula to find standard deviation of grouped data . ; Declare and initialize the upper limit of interval . ; Declare and initialize the upper limit of interval . ; Calculating the size of array .","code":"< ? php function mean ( $ mid , $ freq , $ n ) { $ sum = 0 ; $ freqSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ mid [ $ i ] * $ freq [ $ i ] ; $ freqSum = $ freqSum + $ freq [ $ i ] ; } return $ sum \/ $ freqSum ; } function groupedSD ( $ lower_limit , $ upper_limit , $ freq , $ n ) { $ mid = array ( ) ; $ sum = 0 ; $ freqSum = 0 ; $ sd ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ mid [ $ i ] = ( $ lower_limit [ $ i ] + $ upper_limit [ $ i ] ) \/ 2 ; $ sum = $ sum + $ freq [ $ i ] * $ mid [ $ i ] * $ mid [ $ i ] ; $ freqSum = $ freqSum + $ freq [ $ i ] ; } $ sd = sqrt ( ( $ sum - $ freqSum * mean ( $ mid , $ freq , $ n ) * mean ( $ mid , $ freq , $ n ) ) \/ ( $ freqSum - 1 ) ) ; return $ sd ; } $ lower_limit = array ( 50 , 61 , 71 , 86 , 96 ) ; $ upper_limit = array ( 60 , 70 , 85 , 95 , 100 ) ; $ freq = array ( 9 , 7 , 9 , 12 , 8 ) ; $ n = count ( $ lower_limit ) ; echo groupedSD ( $ lower_limit , $ upper_limit , $ freq , $ n ) ; ? >"}
{"text":"Average of first n even natural numbers | function to find average of sum of first n even numbers ; sum of first n even numbers ; calculating Average ; Driver Code","code":"< ? php function avg_of_even_num ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 2 * $ i ; return $ sum \/ $ n ; } $ n = 9 ; echo ( avg_of_even_num ( $ n ) ) ; ? >"}
{"text":"Average of first n even natural numbers | Return the average of sum of first n even numbers ; Driver Code","code":"< ? php function avg_of_even_num ( $ n ) { return $ n + 1 ; } $ n = 8 ; echo ( avg_of_even_num ( $ n ) ) ; ? >"}
{"text":"Sum of square of first n odd numbers | Efficient PHP method to find sum of square of first n odd numbers . ; driver code","code":"< ? php < ? php function squareSum ( $ n ) { return $ n * ( 4 * $ n * $ n - 1 ) \/ 3 ; } echo squareSum ( 8 ) ; ? >"}
{"text":"Check whether given three numbers are adjacent primes | checks weather given number is prime or not . ; check if n is a multiple of 2 ; if not , then just check the odds ; return next prime number ; start with next number . ; breaks after finding next prime number ; check given three numbers are adjacent primes are not . ; check given three numbers are primes are not . ; find next prime of a ; If next is not same as ' a ' ; If next next is not same as ' c ' ; Driver code","code":"< ? php function isPrime ( $ n ) { if ( $ n % 2 == 0 ) return false ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) if ( $ n % $ i == 0 ) return false ; return true ; } function nextPrime ( $ start ) { $ next = $ start + 1 ; while ( ! isPrime ( $ next ) ) $ next ++ ; return $ next ; } function areAdjacentPrimes ( $ a , $ b , $ c ) { if ( ! isPrime ( $ a ) || ! isPrime ( $ b ) || ! isPrime ( $ c ) ) return false ; $ next = nextPrime ( $ a ) ; if ( $ next != $ b ) return false ; if ( nextPrime ( $ b ) != $ c ) return false ; return true ; } if ( areAdjacentPrimes ( 11 , 13 , 19 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check whether a number is semiprime or not | Utility function to check whether number is semiprime or not ; If number is greater than 1 , add it to the count variable as it indicates the number remain is prime number ; Return '1' if count is equal to '2' else return '0' ; Function to print ' True ' or ' False ' according to condition of semiprime ; Driver code","code":"< ? php function checkSemiprime ( $ num ) { $ cnt = 0 ; for ( $ i = 2 ; $ cnt < 2 && $ i * $ i <= $ num ; ++ $ i ) while ( $ num % $ i == 0 ) $ num \/= $ i ; ++ $ cnt ; if ( $ num > 1 ) ++ $ cnt ; return $ cnt == 2 ; } function semiprime ( $ n ) { if ( checkSemiprime ( $ n ) ) echo \" True STRNEWLINE \" ; else echo \" False STRNEWLINE \" ; } $ n = 6 ; semiprime ( $ n ) ; $ n = 8 ; semiprime ( $ n ) ; ? >"}
{"text":"Program to find sum of series 1 + 2 + 2 + 3 + 3 + 3 + . . . + n | Function to find sum of series . ; Driver Code ; Function call","code":"< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * $ i ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Program to find sum of series 1 + 2 + 2 + 3 + 3 + 3 + . . . + n | Function to find sum of series . ; Driver Code","code":"< ? php function sumOfSeries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) \/ 6 ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Maximum binomial coefficient term value | Returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; Return maximum binomial coefficient term value . ; if n is even ; if n is odd ; Driver Code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ C [ $ n + 1 ] [ $ k + 1 ] = array ( 0 ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } return $ C [ $ n ] [ $ k ] ; } function maxcoefficientvalue ( $ n ) { if ( $ n % 2 == 0 ) return binomialCoeff ( $ n , $ n \/ 2 ) ; else return binomialCoeff ( $ n , ( $ n + 1 ) \/ 2 ) ; } $ n = 4 ; echo maxcoefficientvalue ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Smallest n digit number divisible by given three numbers |  ; LCM for x , y , z ; returns smallest n digit number divisible by x , y and z ; find the LCM ; find power of 10 for least number ; reminder after ; If smallest number itself divides lcm . ; add lcm - reminder number for next n digit number ; this condition check the n digit number is possible or not if it is possible it return the number else return 0 ; driver code ; if number is possible then it print the number","code":"< ? php function gcd ( $ a , $ b ) { return ( $ a % $ b ) ? gcd ( $ b , $ a % $ b ) : $ b ; } function LCM ( $ x , $ y , $ z ) { $ ans = floor ( ( $ x * $ y ) \/ ( gcd ( $ x , $ y ) ) ) ; return floor ( ( $ z * $ ans ) \/ ( gcd ( $ ans , $ z ) ) ) ; } function findDivisible ( $ n , $ x , $ y , $ z ) { $ lcm = LCM ( $ x , $ y , $ z ) ; $ ndigitnumber = pow ( 10 , $ n - 1 ) ; $ reminder = $ ndigitnumber % $ lcm ; if ( $ reminder == 0 ) return $ ndigitnumber ; $ ndigitnumber += $ lcm - $ reminder ; if ( $ ndigitnumber < pow ( 10 , $ n ) ) return $ ndigitnumber ; else return 0 ; } $ n = 4 ; $ x = 2 ; $ y = 3 ; $ z = 5 ; $ res = findDivisible ( $ n , $ x , $ y , $ z ) ; if ( $ res != 0 ) echo $ res ; else echo \" Not \u2581 possible \" ; ? >"}
{"text":"Sum of squares of first n natural numbers | Return the sum of square of first n natural numbers ; Driver Code","code":"< ? php function squaresum ( $ n ) { return ( $ n * ( $ n + 1 ) \/ 2 ) * ( 2 * $ n + 1 ) \/ 3 ; } $ n = 4 ; echo squaresum ( $ n ) ; ? >"}
{"text":"Program to calculate distance between two points | Function to calculate distance ; Calculating distance ; Driver Code","code":"< ? php function distance ( $ x1 , $ y1 , $ x2 , $ y2 ) { return sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) * 1.0 ) ; } echo ( distance ( 3 , 4 , 4 , 3 ) ) ; ? >"}
{"text":"Check if a large number is divisibility by 15 | to find sum ; function to check if a large number is divisible by 15 ; length of string ; check divisibility by 5 ; Sum of digits ; if divisible by 3 ; Driver Code","code":"< ? php function accumulate ( $ s ) { $ acc = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ acc += $ s [ $ i ] - '0' ; } return $ acc ; } function isDivisible ( $ s ) { $ n = strlen ( $ s ) ; if ( $ s [ $ n - 1 ] != '5' && $ s [ $ n - 1 ] != '0' ) return false ; $ sum = accumulate ( $ s ) ; return ( $ sum % 3 == 0 ) ; } $ s = \"15645746327462384723984023940239\" ; isDivisible ( $ s ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; $ s = \"15645746327462384723984023940235\" ; isDivisible ( $ s ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; ? >"}
{"text":"Largest perfect square number in an Array | Function to check if a number is perfect square number or not ; takes the sqrt of the number ; checks if it is a perfect square number ; Function to find the largest perfect square number in the array ; stores the maximum of all perfect square numbers ; Traverse all elements in the array ; store the maximum if current element is a perfect square ; Driver Code","code":"< ? php function checkPerfectSquare ( $ n ) { $ d = sqrt ( $ n ) ; if ( $ d * $ d == $ n ) return true ; return false ; } function largestPerfectSquareNumber ( $ a , $ n ) { $ maxi = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( checkPerfectSquare ( $ a [ $ i ] ) ) $ maxi = max ( $ a [ $ i ] , $ maxi ) ; } return $ maxi ; } $ a = array ( 16 , 20 , 25 , 2 , 3 , 10 ) ; $ n = count ( $ a ) ; echo largestPerfectSquareNumber ( $ a , $ n ) ; ? >"}
{"text":"Count pairs ( i , j ) such that ( i + j ) is divisible by A and B both | PHP implementation of above approach ; Function to find the LCM ; Function to count the pairs ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { return $ b == 0 ? $ a : gcd ( $ b , $ a % $ b ) ; } function find_LCM ( $ x , $ y ) { return ( int ) ( ( $ x * $ y ) \/ gcd ( $ x , $ y ) ) ; } function CountPairs ( $ n , $ m , $ A , $ B ) { $ cnt = 0 ; $ lcm = find_LCM ( $ A , $ B ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ cnt += ( int ) ( ( $ m + ( $ i % $ lcm ) ) \/ $ lcm ) ; return $ cnt ; } $ n = 60 ; $ m = 90 ; $ A = 5 ; $ B = 10 ; echo CountPairs ( $ n , $ m , $ A , $ B ) ; ? >"}
{"text":"Given an array and two integers l and r , find the kth largest element in the range [ l , r ] | PHP implementation of the approach ; Function to calculate the prefix ; Creating one based indexing ; Initializing and creating prefix array ; Creating a prefix array for every possible value in a given range ; Function to return the kth largest element in the index range [ l , r ] ; Binary searching through the 2d array and only checking the range in which the sub array is a part ; Driver code ; Creating the prefix array for the given array ; Queries ; Perform queries","code":"< ? php $ MAX = 101 ; $ prefix = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , 0 ) ) ; $ ar = array_fill ( 0 , $ MAX , 0 ) ; function cal_prefix ( $ n , $ arr ) { global $ prefix , $ ar , $ MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ar [ $ i + 1 ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ prefix [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ prefix [ $ i ] [ $ j ] = $ prefix [ $ i ] [ $ j - 1 ] + ( int ) ( $ ar [ $ j ] <= $ i ? 1 : 0 ) ; } } } function ksub ( $ l , $ r , $ n , $ k ) { global $ prefix , $ ar , $ MAX ; $ lo = 1 ; $ hi = $ MAX - 1 ; while ( $ lo + 1 < $ hi ) { $ mid = ( int ) ( ( $ lo + $ hi ) \/ 2 ) ; if ( $ prefix [ $ mid ] [ $ r ] - $ prefix [ $ mid ] [ $ l - 1 ] >= $ k ) $ hi = $ mid ; else $ lo = $ mid + 1 ; } if ( $ prefix [ $ lo ] [ $ r ] - $ prefix [ $ lo ] [ $ l - 1 ] >= $ k ) $ hi = $ lo ; return $ hi ; } $ arr = array ( 1 , 4 , 2 , 3 , 5 , 7 , 6 ) ; $ n = count ( $ arr ) ; $ k = 4 ; cal_prefix ( $ n , $ arr ) ; $ queries = array ( array ( 1 , $ n , 1 ) , array ( 2 , $ n - 2 , 2 ) , array ( 3 , $ n - 1 , 3 ) ) ; $ q = count ( $ queries ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo ksub ( $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] , $ n , $ queries [ $ i ] [ 2 ] ) . \" STRNEWLINE \" ; ? >"}
{"text":"Remove exactly one element from the array such that max | function to calculate max - min ; There should be at - least two elements ; To store first and second minimums ; To store first and second maximums ; Driver code","code":"< ? php function max_min ( $ a , $ n ) { if ( $ n <= 1 ) return PHP_INT_MAX ; $ f_min = $ a [ 0 ] ; $ s_min = PHP_INT_MAX ; $ f_max = $ a [ 0 ] ; $ s_max = ~ PHP_INT_MAX ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ f_min ) { $ s_min = $ f_min ; $ f_min = $ a [ $ i ] ; } else if ( $ a [ $ i ] < $ s_min ) { $ s_min = $ a [ $ i ] ; } if ( $ a [ $ i ] >= $ f_max ) { $ s_max = $ f_max ; $ f_max = $ a [ $ i ] ; } else if ( $ a [ $ i ] > $ s_max ) { $ s_max = $ a [ $ i ] ; } } return min ( ( $ f_max - $ s_min ) , ( $ s_max - $ f_min ) ) ; } $ a = array ( 1 , 3 , 3 , 7 ) ; $ n = sizeof ( $ a ) ; echo ( max_min ( $ a , $ n ) ) ; ? >"}
{"text":"Minimum in an array which is first decreasing then increasing | Function to find the smallest number 's index ; Do a binary search ; Find the mid element ; Check for break point ; Return the index ; Driver Code ; Print the smallest number","code":"< ? php function minimal ( $ a , $ n ) { $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) >> 1 ; if ( $ a [ $ mid ] < $ a [ $ mid + 1 ] ) { $ hi = $ mid ; } else { $ lo = $ mid + 1 ; } } return $ lo ; } $ a = array ( 8 , 5 , 4 , 3 , 4 , 10 ) ; $ n = sizeof ( $ a ) ; $ ind = minimal ( $ a , $ n ) ; echo $ a [ $ ind ] ; ? >"}
{"text":"Leftmost and rightmost indices of the maximum and the minimum element of an array | PHP implementation of the approach ; If found new minimum ; If arr [ i ] = min then rightmost index for min will change ; If found new maximum ; If arr [ i ] = max then rightmost index for max will change ; Driver code","code":"< ? php function findIndices ( $ arr , $ n ) { $ leftMin = 0 ; $ rightMin = 0 ; $ leftMax = 0 ; $ rightMax = 0 ; $ min = $ arr [ 0 ] ; $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ min ) { $ leftMin = $ rightMin = $ i ; $ min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] == $ min ) $ rightMin = $ i ; if ( $ arr [ $ i ] > $ max ) { $ leftMax = $ rightMax = $ i ; $ max = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] == $ max ) $ rightMax = $ i ; } echo \" Minimum \u2581 left \u2581 : \u2581 \" , $ leftMin , \" STRNEWLINE \" ; echo \" Minimum \u2581 right \u2581 : \u2581 \" , $ rightMin , \" STRNEWLINE \" ; echo \" Maximum \u2581 left \u2581 : \u2581 \" , $ leftMax , \" STRNEWLINE \" ; echo \" Maximum \u2581 right \u2581 : \u2581 \" , $ rightMax , \" STRNEWLINE \" ; } $ arr = array ( 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 ) ; $ n = sizeof ( $ arr ) ; findIndices ( $ arr , $ n ) ; ? >"}
{"text":"Find smallest and largest element from square matrix diagonals | Function to find smallest and largest element from principal and secondary diagonal ; take length of $matrix ; declare and initialize variables with appropriate value ; Condition for principal diagonal ; take new smallest value ; take new largest value ; Condition for secondary diagonal ; take new smallest value ; take new largest value ; Declare and initialize 5 X5 matrix","code":"< ? php function diagonalsMinMax ( $ mat ) { $ n = count ( $ mat ) ; if ( $ n == 0 ) return ; $ principalMin = $ mat [ 0 ] [ 0 ] ; $ principalMax = $ mat [ 0 ] [ 0 ] ; $ secondaryMin = $ mat [ $ n - 1 ] [ 0 ] ; $ secondaryMax = $ mat [ $ n - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) { if ( $ mat [ $ i ] [ $ j ] < $ principalMin ) { $ principalMin = $ mat [ $ i ] [ $ j ] ; } if ( $ mat [ $ i ] [ $ j ] > $ principalMax ) { $ principalMax = $ mat [ $ i ] [ $ j ] ; } } if ( ( $ i + $ j ) == ( $ n - 1 ) ) { if ( $ mat [ $ i ] [ $ j ] < $ secondaryMin ) { $ secondaryMin = $ mat [ $ i ] [ $ j ] ; } if ( $ mat [ $ i ] [ $ j ] > $ secondaryMax ) { $ secondaryMax = $ mat [ $ i ] [ $ j ] ; } } } } echo \" Principal \u2581 Diagonal \u2581 Smallest \u2581 Element : \u2581 \" , $ principalMin , \" STRNEWLINE \" ; echo \" Principal \u2581 Diagonal \u2581 Greatest \u2581 Element \u2581 : \u2581 \" , $ principalMax , \" STRNEWLINE \" ; echo \" Secondary \u2581 Diagonal \u2581 Smallest \u2581 Element : \u2581 \" , $ secondaryMin , \" STRNEWLINE \" ; echo \" Secondary \u2581 Diagonal \u2581 Greatest \u2581 Element : \u2581 \" , $ secondaryMax , \" STRNEWLINE \" ; } $ matrix = array ( array ( 1 , 2 , 3 , 4 , -10 ) , array ( 5 , 6 , 7 , 8 , 6 ) , array ( 1 , 2 , 11 , 3 , 4 ) , array ( 5 , 6 , 70 , 5 , 8 ) , array ( 4 , 9 , 7 , 1 , -5 ) ) ; diagonalsMinMax ( $ matrix ) ; ? >"}
{"text":"Indexed Sequential Search | PHP program for Indexed Sequential Search ; Storing element ; Storing the index ; Driver code ; Element to search ; Function call","code":"< ? php function indexedSequentialSearch ( $ arr , $ n , $ k ) { $ elements = array ( ) ; $ indices = array ( ) ; $ temp = array ( ) ; $ j = 0 ; $ ind = 0 ; $ start = 0 ; $ end = 0 ; $ set = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 3 ) { $ elements [ $ ind ] = $ arr [ $ i ] ; $ indices [ $ ind ] = $ i ; $ ind ++ ; } if ( $ k < $ elements [ 0 ] ) { echo \" Not \u2581 found \" ; } else { for ( $ i = 1 ; $ i <= $ ind ; $ i ++ ) if ( $ k < $ elements [ $ i ] ) { $ start = $ indices [ $ i - 1 ] ; $ set = 1 ; $ end = $ indices [ $ i ] ; break ; } } if ( $ set == 1 ) { $ start = $ indices [ $ i - 1 ] ; $ end = $ n ; } for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { if ( $ k == $ arr [ $ i ] ) { $ j = 1 ; break ; } } if ( $ j == 1 ) echo \" Found \u2581 at \u2581 index \u2581 \" , $ i ; else echo \" Not \u2581 found \" ; } $ arr = array ( 6 , 7 , 8 , 9 , 10 ) ; $ n = count ( $ arr ) ; $ k = 8 ; indexedSequentialSearch ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Number of segments where all elements are greater than X | Function to count number of segments ; Iterate in the array ; check if array element greater then X or not ; if flag is true ; After iteration complete check for the last segment ; Driver Code","code":"< ? php function countSegments ( $ a , $ n , $ x ) { $ flag = false ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) { $ flag = true ; } else { if ( $ flag ) $ count += 1 ; $ flag = false ; } } if ( $ flag ) $ count += 1 ; return $ count ; } $ a = array ( 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ) ; $ n = sizeof ( $ a ) ; $ x = 13 ; echo countSegments ( $ a , $ n , $ x ) ; ? >"}
{"text":"Count triplets ( a , b , c ) such that a + b , b + c and a + c are all divisible by K | Function to find the quadratic equation whose roots are a and b ; iterate for all triples pairs ( i , j , l ) ; if the condition is satisfied ; Driver code","code":"< ? php function count_triples ( $ n , $ k ) { $ i = 0 ; $ j = 0 ; $ l = 0 ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ l = 1 ; $ l <= $ n ; $ l ++ ) { if ( ( $ i + $ j ) % $ k == 0 && ( $ i + $ l ) % $ k == 0 && ( $ j + $ l ) % $ k == 0 ) $ count ++ ; } } } return $ count ; } $ n = 3 ; $ k = 2 ; $ ans = count_triples ( $ n , $ k ) ; echo ( $ ans ) ; ? >"}
{"text":"kth smallest \/ largest in a small range unsorted array | PHP program of kth smallest \/ largest in a small range unsorted array ; Storing counts of elements ; Traverse hash array build above until we reach k - th smallest element . ; Driver code","code":"< ? php $ maxs = 1000001 ; function kthSmallestLargest ( & $ arr , $ n , $ k ) { global $ maxs ; $ max_val = max ( $ arr ) ; $ hash = array_fill ( 0 , $ max_val + 1 , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash [ $ arr [ $ i ] ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i <= $ max_val ; $ i ++ ) { while ( $ hash [ $ i ] > 0 ) { $ count ++ ; if ( $ count == $ k ) return $ i ; $ hash [ $ i ] -- ; } } return -1 ; } $ arr = array ( 11 , 6 , 2 , 9 , 4 , 3 , 16 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ k = 3 ; echo \" kth \u2581 smallest \u2581 number \u2581 is : \u2581 \" . kthSmallestLargest ( $ arr , $ n , $ k ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text":"Meta Binary Search | One | Function to show the working of Meta binary search ; Set number of bits to represent ; largest array index This is redundant and will cause error for some case while ( ( 1 << $lg ) < $n - 1 ) $lg += 1 ; ; Incrementally construct the index of the target value ; find the element in one direction and update $position ; if element found return $pos otherwise - 1 ; Driver code","code":"< ? php function bsearch ( $ A , $ key_to_search , $ n ) { $ lg = log ( $ n - 1 , 2 ) + 1 ; $ pos = 0 ; for ( $ i = $ lg - 1 ; $ i >= 0 ; $ i -- ) { if ( $ A [ $ pos ] == $ key_to_search ) return $ pos ; $ new_pos = $ pos | ( 1 << $ i ) ; if ( ( $ new_pos < $ n ) && ( $ A [ $ new_pos ] <= $ key_to_search ) ) $ pos = $ new_pos ; } return ( ( $ A [ $ pos ] == $ key_to_search ) ? $ pos : -1 ) ; } $ A = [ -2 , 10 , 100 , 250 , 32315 ] ; $ ans = bsearch ( $ A , 10 , 5 ) ; echo $ ans ; ? >"}
{"text":"Median of two sorted arrays of different sizes | Set 1 ( Linear ) | This function returns median of a [ ] and b [ ] . Assumptions in this function : Both a [ ] and b [ ] are sorted arrays ; Current index of i \/ p array a [ ] ; Current index of i \/ p array b [ ] ; Below is to handle the case where all elements of a [ ] are smaller than smallest ( or first ) element of b [ ] or a [ ] is empty ; Below is to handle case where all elements of b [ ] are smaller than smallest ( or first ) element of a [ ] or b [ ] is empty ; Below is to handle the case where sum of number of elements of the arrays is even ; Below is to handle the case where sum of number of elements of the arrays is odd ; Driver Code","code":"< ? php function findmedian ( $ a , $ n1 , $ b , $ n2 ) { $ i = 0 ; $ j = 0 ; $ k ; $ m1 = -1 ; $ m2 = -1 ; for ( $ k = 0 ; $ k <= ( $ n1 + $ n2 ) \/ 2 ; $ k ++ ) { if ( $ i < $ n1 and $ j < $ n2 ) { if ( $ a [ $ i ] < $ b [ $ j ] ) { $ m2 = $ m1 ; $ m1 = $ a [ $ i ] ; $ i ++ ; } else { $ m2 = $ m1 ; $ m1 = $ b [ $ j ] ; $ j ++ ; } } else if ( i == n1 ) { $ m2 = $ m1 ; $ m1 = $ b [ j ] ; $ j ++ ; } else if ( $ j == $ n2 ) { $ m2 = $ m1 ; $ m1 = $ a [ $ i ] ; $ i ++ ; } } if ( ( $ n1 + $ n2 ) % 2 == 0 ) return ( $ m1 + $ m2 ) * 1.0 \/ 2 ; return m1 ; } $ a = array ( 1 , 12 , 15 , 26 , 38 ) ; $ b = array ( 2 , 13 , 24 ) ; $ n1 = count ( $ a ) ; $ n2 = count ( $ b ) ; echo ( findmedian ( $ a , $ n1 , $ b , $ n2 ) ) ; ? >"}
{"text":"Next Smaller Element | prints element and NSE pair for all elements of arr [ ] of size n ; Driver Code","code":"< ? php function printNSE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . \" -- \" . \u2581 $ next . \" \" } } $ arr = array ( 11 , 13 , 21 , 3 ) ; $ n = count ( $ arr ) ; printNSE ( $ arr , $ n ) ; ? >"}
{"text":"Longest subarray such that the difference of max and min is at | PHP code to find longest subarray with difference between max and min as at - most 1. ; longest constant range length ; first number ; If we see same number ; If we see different number , but same as previous . ; If number is neither same as previous nor as current . ; Driver Code","code":"< ? php function longestSubarray ( $ input , $ length ) { $ prev = -1 ; $ prevCount = 0 ; $ currentCount = 1 ; $ longest = 1 ; $ current = $ input [ 0 ] ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ next = $ input [ $ i ] ; if ( $ next == $ current ) { $ currentCount ++ ; } else if ( $ next == $ prev ) { $ prevCount += $ currentCount ; $ prev = $ current ; $ current = $ next ; $ currentCount = 1 ; } else { $ longest = max ( $ longest , $ currentCount + $ prevCount ) ; $ prev = $ current ; $ prevCount = $ currentCount ; $ current = $ next ; $ currentCount = 1 ; } } return max ( $ longest , $ currentCount + $ prevCount ) ; } $ input = array ( 5 , 5 , 6 , 7 , 6 ) ; echo ( longestSubarray ( $ input , count ( $ input ) ) ) ; ? >"}
{"text":"Longest Subarray with first element greater than or equal to Last element | Search function for searching the first element of the subarray which is greater or equal to the last element ( num ) ; Returns length of the longest array with first element smaller than the last element . ; Initially the search space is empty . ; We will add an ith element in the search space if the search space is empty or if the ith element is greater than the last element of the search space . ; we will search for the index first element in the search space and we will use it find the index of it in the original array . ; Update the answer if the length of the subarray is greater than the previously calculated lengths . ; Driver code","code":"< ? php function binarySearch ( $ searchSpace , $ s , $ e , $ num ) { $ ans = 0 ; while ( $ s <= $ e ) { $ mid = ( $ s + $ e ) \/ 2 ; if ( $ searchSpace [ $ mid ] >= $ num ) { $ ans = $ mid ; $ e = $ mid - 1 ; } else { $ s = $ mid + 1 ; } } return $ ans ; } function longestSubArr ( & $ arr , $ n ) { $ j = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ j == 0 or $ searchSpace [ $ j - 1 ] < $ arr [ $ i ] ) { $ searchSpace [ $ j ] = $ arr [ $ i ] ; $ index [ $ j ] = $ i ; $ j ++ ; } $ idx = binarySearch ( $ searchSpace , 0 , $ j - 1 , $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ i - $ index [ $ idx ] + 1 ) ; } return $ ans ; } $ arr = array ( -5 , -1 , 7 , 5 , 1 , -2 ) ; $ n = sizeof ( $ arr ) ; echo ( longestSubArr ( $ arr , $ n ) ) ; ? >"}
{"text":"Check if a string is suffix of another | PHP program to find if a string is suffix of another ; Driver Code ; Test case - sensitive implementation of endsWith function","code":"< ? php function isSuffix ( $ s1 , $ s2 ) { $ n1 = ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; if ( $ n1 > $ n2 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) if ( $ s1 [ $ n1 - $ i - 1 ] != $ s2 [ $ n2 - $ i - 1 ] ) return false ; return true ; } $ s1 = \" geeks \" ; $ s2 = \" geeksforgeeks \" ; $ result = isSuffix ( $ s1 , $ s2 ) ; if ( $ result ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if all occurrences of a character appear together | To indicate if one or more occurrences of ' c ' are seen or not . ; Traverse given string ; If current character is same as c , we first check if c is already seen . ; If this is very first appearance of c , we traverse all consecutive occurrences . ; To indicate that character is seen once . ; Driver Code","code":"< ? php $ oneSeen = false ; $ i = 0 ; $ n = strlen ( $ s ) ; while ( $ i < $ n ) { if ( $ s [ $ i ] == $ c ) { if ( $ oneSeen == true ) return false ; while ( $ i < $ n && $ s [ $ i ] == $ c ) $ i ++ ; $ oneSeen = true ; } else $ i ++ ; } return true ; } $ s = \"110029\" ; if ( checkIfAllTogether ( $ s , '1' ) ) echo ( \" Yes STRNEWLINE \" ) ; else echo ( \" No STRNEWLINE \" ) ; ? >"}
{"text":"Front and Back Search in unsorted array | PHP program to implement front and back search ; Start searching from both ends ; Keep searching while two indexes do not cross . ; Driver Code","code":"< ? php function search ( $ arr , $ n , $ x ) { $ front = 0 ; $ back = $ n - 1 ; while ( $ front <= $ back ) { if ( $ arr [ $ front ] == $ x $ arr [ $ back ] == $ x ) return true ; $ front ++ ; $ back -- ; } return false ; } $ arr = array ( 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ) ; $ x = 130 ; $ n = sizeof ( $ arr ) ; if ( search ( $ arr , $ n , $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Even | PHP program to find max ( X , Y ) \/ min ( X , Y ) after P turns ; 1 st test case ; 2 nd test case","code":"< ? php function findValue ( $ X , $ Y , $ P ) { if ( $ P % 2 == 0 ) return ( int ) ( max ( $ X , $ Y ) \/ min ( $ X , $ Y ) ) ; else return ( int ) ( max ( 2 * $ X , $ Y ) \/ min ( 2 * $ X , $ Y ) ) ; } $ X = 1 ; $ Y = 2 ; $ P = 1 ; echo findValue ( $ X , $ Y , $ P ) , \" STRNEWLINE \" ; $ X = 3 ; $ Y = 7 ; $ P = 2 ; echo findValue ( $ X , $ Y , $ P ) , \" STRNEWLINE \" ; ? >"}
{"text":"The painter 's partition problem | function to calculate sum between two indices in array ; bottom up tabular dp ; initialize table ; base cases k = 1 ; n = 1 ; 2 to k partitions ; track minimum ; i - 1 th separator before position arr [ p = 1. . j ] ; required ; Driver Code ; Calculate size of array .","code":"< ? php function sum ( $ arr , $ from , $ to ) { $ total = 0 ; for ( $ i = $ from ; $ i <= $ to ; $ i ++ ) $ total += $ arr [ $ i ] ; return $ total ; } function findMax ( $ arr , $ n , $ k ) { $ dp [ $ k + 1 ] [ $ n + 1 ] = array ( 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ 1 ] [ $ i ] = sum ( $ arr , 0 , $ i - 1 ) ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) $ dp [ $ i ] [ 1 ] = $ arr [ 0 ] ; for ( $ i = 2 ; $ i <= $ k ; $ i ++ ) { $ best = PHP_INT_MAX ; for ( $ p = 1 ; $ p <= $ j ; $ p ++ ) $ best = min ( $ best , max ( $ dp [ $ i - 1 ] [ $ p ] , sum ( $ arr , $ p , $ j - 1 ) ) ) ; $ dp [ $ i ] [ $ j ] = $ best ; } } return $ dp [ $ k ] [ $ n ] ; } $ arr = array ( 10 , 20 , 60 , 50 , 30 , 40 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo findMax ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"Counting cross lines in an array | Function return count of cross line in an array ; Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position ; increment cross line by one ; Driver Code","code":"< ? php function countCrossLine ( $ arr , $ n ) { $ count_crossline = 0 ; $ i ; $ key ; $ j ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ key = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 and $ arr [ $ j ] > $ key ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j = $ j - 1 ; $ count_crossline ++ ; } $ arr [ $ j + 1 ] = $ key ; } return $ count_crossline ; } $ arr = array ( 4 , 3 , 1 , 2 ) ; $ n = count ( $ arr ) ; echo countCrossLine ( $ arr , $ n ) ; ? >"}
{"text":"Recursive Programs to find Minimum and Maximum elements of array | function to return maximum element using recursion ; if n = 0 means whole array has been traversed ; Driver Code ; Function calling","code":"< ? php function findMaxRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return max ( $ A [ $ n - 1 ] , findMaxRec ( $ A , $ n - 1 ) ) ; } $ A = array ( 1 , 4 , 45 , 6 , -50 , 10 , 2 ) ; $ n = sizeof ( $ A ) ; echo findMaxRec ( $ A , $ n ) ; ? >"}
{"text":"Minimum length of square to contain at least half of the given Coordinates | Function to Calculate Absolute Value ; Function to Calculate the Minimum value of M ; To store the minimum M for each point in array ; Sort the array ; Index at which atleast required point are inside square of length 2 * M ; Driver Code","code":"< ? php function mod ( $ x ) { if ( $ x >= 0 ) return $ x ; return - $ x ; } function findSquare ( $ n ) { $ points = array ( array ( 1 , 2 ) , array ( -3 , 4 ) , array ( 1 , 78 ) , array ( -3 , -7 ) ) ; $ a [ $ n ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x ; $ y ; $ x = $ points [ $ i ] [ 0 ] ; $ y = $ points [ $ i ] [ 1 ] ; $ a [ $ i ] = max ( mod ( $ x ) , mod ( $ y ) ) ; } sort ( $ a ) ; $ index = floor ( $ n \/ 2 ) - 1 ; echo \" Minimum \u2581 M \u2581 required \u2581 is : \u2581 \" , $ a [ $ index ] , \" STRNEWLINE \" ; } $ N = 4 ; findSquare ( $ N ) ; ? >"}
{"text":"Sort even and odd placed elements in increasing order | function to prin the odd and even indexed digits ; lists to store the odd and even positioned digits ; traverse through all the indexes in the integer ; if the digit is in odd_index position append it to odd_position list ; else append it to the even_position list ; print the elements in the list in sorted order ; Driver Code","code":"< ? php function odd_even ( $ n ) { $ odd_indexes = array ( ) ; $ even_indexes = array ( ) ; for ( $ i = 0 ; $ i < sizeof ( $ n ) ; $ i ++ ) { if ( $ i % 2 == 0 ) array_push ( $ odd_indexes , $ n [ $ i ] ) ; else array_push ( $ even_indexes , $ n [ $ i ] ) ; } sort ( $ odd_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ odd_indexes ) ; $ i ++ ) echo $ odd_indexes [ $ i ] , \" \u2581 \" ; sort ( $ even_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ even_indexes ) ; $ i ++ ) echo $ even_indexes [ $ i ] , \" \u2581 \" ; } $ n = array ( 3 , 2 , 7 , 6 , 8 ) ; odd_even ( $ n ) ; ? >"}
{"text":"Minimum increment in the sides required to get non | Function to return the minimum increase in side lengths of the triangle ; push the three sides to a array ; sort the array ; check if sum is greater than third side ; Driver Code","code":"< ? php function minimumIncrease ( $ a , $ b , $ c ) { $ arr = array ( $ a , $ b , $ c ) ; sort ( $ arr ) ; if ( $ arr [ 0 ] + $ arr [ 1 ] >= $ arr [ 2 ] ) return 0 ; else return $ arr [ 2 ] - ( $ arr [ 0 ] + $ arr [ 1 ] ) ; } $ a = 3 ; $ b = 5 ; $ c = 10 ; echo minimumIncrease ( $ a , $ b , $ c ) ; ? >"}
{"text":"Minimum sum of differences with an element in an array | function to find min sum after operation ; Sort the array ; Pick middle value ; Sum of absolute differences . ; Driver Code","code":"< ? php function absSumDidd ( $ a , $ n ) { sort ( $ a ) ; $ midValue = $ a [ ( $ n \/ 2 ) ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + abs ( $ a [ $ i ] - $ midValue ) ; } return $ sum ; } $ arr = array ( 5 , 11 , 14 , 10 , 17 , 15 ) ; $ n = count ( $ arr ) ; echo absSumDidd ( $ arr , $ n ) ; ? >"}
{"text":"Count subsequences in first string which are anagrams of the second string | PHP implementation to count subsequences in first $which are anagrams of the second string ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ] ; function to count subsequences in first string which are anagrams of the second string ; hash tables to store frequencies of each character ; store frequency of each character of ' str1' ; store frequency of each character of ' str2' ; to store the total count of subsequences ; if character ( i + ' a ' ) exists in ' str2' ; if this character ' s \u2581 frequency \u2581 \u2581 in \u2581 ' str2 ' \u2581 in \u2581 less \u2581 than \u2581 or \u2581 \u2581 equal \u2581 to \u2581 its \u2581 frequency \u2581 in \u2581 \u2581 ' str1 ' \u2581 then \u2581 accumulate \u2581 its \u2581 \u2581 contribution \u2581 to \u2581 the \u2581 count \u2581 \u2581 of \u2581 subsequences . \u2581 If \u2581 its \u2581 \u2581 frequency \u2581 in \u2581 ' str1 ' \u2581 is \u2581 ' n ' \u2581 \u2581 and \u2581 in \u2581 ' str2 ' \u2581 is \u2581 ' r ', then  its contribution will be nCr,  where C is the binomial  coefficient. ; else return 0 as there could be no subsequence which is an anagram of ' str2' ; required count of subsequences ; Driver Code","code":"< ? php $ SIZE = 26 ; function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res ; } function countSubsequences ( $ str1 , $ str2 ) { global $ SIZE ; $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ count = 1 ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) if ( $ freq2 [ $ i ] != 0 ) { if ( $ freq2 [ $ i ] <= $ freq1 [ $ i ] ) $ count = $ count * binomialCoeff ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; else return 0 ; } return $ count ; } $ str1 = \" abacd \" ; $ str2 = \" abc \" ; echo ( \" Count \u2581 = \u2581 \" . countSubsequences ( $ str1 , $ str2 ) ) ; ? >"}
{"text":"Count subsequence of length three in a given string | Function to find number of occurrences of a subsequence of length three in a string ; variable to store no of occurrences ; loop to find first character ; loop to find 2 nd character ; loop to find 3 rd character ; increment count if subsequence is found ; Driver Code","code":"< ? php function findOccurrences ( $ str , $ substr ) { $ counter = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ substr [ 0 ] ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ j ] == $ substr [ 1 ] ) { for ( $ k = $ j + 1 ; $ k < strlen ( $ str ) ; $ k ++ ) { if ( $ str [ $ k ] == $ substr [ 2 ] ) $ counter ++ ; } } } } } return $ counter ; } $ str = \" GFGFGYSYIOIWIN \" ; $ substr = \" GFG \" ; echo findOccurrences ( $ str , $ substr ) ; ? >"}
{"text":"Count subsequence of length three in a given string | Function to find number of occurrences of a subsequence of length three in a string ; calculate length of string ; auxiliary array to store occurrences of first character ; auxiliary array to store occurrences of third character ; calculate occurrences of first character upto ith index from left ; calculate occurrences of third character upto ith index from right ; variable to store total number of occurrences ; loop to find the occurrences of middle element ; if middle character of subsequence is found in the string ; multiply the total occurrences of first character before middle character with the total occurrences of third character after middle character ; Driver Code","code":"< ? php function findOccurrences ( $ str , $ substr ) { $ n = strlen ( $ str ) ; $ preLeft = array ( 0 ) ; $ preRight = array ( 0 ) ; if ( $ str [ 0 ] == $ substr [ 0 ] ) $ preLeft [ 0 ] ++ ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ substr [ 0 ] ) $ preLeft [ $ i ] = $ preLeft [ $ i - 1 ] + 1 ; else $ preLeft [ $ i ] = $ preLeft [ $ i - 1 ] ; } if ( $ str [ $ n - 1 ] == $ substr [ 2 ] ) $ preRight [ $ n - 1 ] ++ ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == $ substr [ 2 ] ) $ preRight [ $ i ] = ( $ preRight [ $ i + 1 ] + 1 ) ; else $ preRight [ $ i ] = $ preRight [ $ i + 1 ] ; } $ counter = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ 1 ] ) { $ total = $ preLeft [ $ i - 1 ] * $ preRight [ $ i + 1 ] ; $ counter += $ total ; } } return $ counter ; } $ str = \" GFGFGYSYIOIWIN \" ; $ substr = \" GFG \" ; echo findOccurrences ( $ str , $ substr ) ; ? >"}
{"text":"Lexicographically smallest string whose hamming distance from given string is exactly K | function to find Lexicographically smallest string with hamming distance k ; If k is 0 , output input string ; Copying input string into output string ; Traverse all the character of the string ; If current character is not ' a ' ; copy character ' a ' to output string ; str2 [ i ] = ' a ' ; ; If hamming distance became k , break ; ; If k is less than p ; Traversing string in reverse order ; Driver Code","code":"< ? php function findString ( $ str , $ n , $ k ) { if ( $ k == 0 ) { echo $ str . \" STRNEWLINE \" ; return ; } $ str2 = $ str ; $ p = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str2 [ $ i ] != ' a ' ) { $ str2 [ $ i ] = ' a ' ; $ p ++ ; p ++ ; if ( $ p == $ k ) break ; } } if ( $ p < $ k ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == ' a ' ) { $ str2 [ $ i ] = ' b ' ; $ p ++ ; if ( $ p == $ k ) break ; } } echo $ str2 . \" STRNEWLINE \" ; } $ str = \" pqrs \" ; $ n = strlen ( $ str ) ; $ k = 2 ; findString ( $ str , $ n , $ k ) ; ? >"}
{"text":"Print all possible strings that can be made by placing spaces | Function to print all subsequences ; Driver code","code":"< ? php function printSubsequences ( $ str ) { $ n = strlen ( $ str ) ; $ opsize = pow ( 2 , $ n - 1 ) ; for ( $ counter = 0 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo $ str [ $ j ] ; if ( $ counter & ( 1 << $ j ) ) echo \" \u2581 \" ; } echo \" STRNEWLINE \" ; } } $ str = \" ABC \" ; printSubsequences ( $ str ) ; ? >"}
{"text":"Minimum number of deletions so that no two consecutive are same | Function for counting deletions ; If two consecutive characters are the same , delete one of them . ; Driver Code ; Function call to print answer","code":"< ? php function countDeletions ( $ str ) { $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) - 1 ; $ i ++ ) if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ ans ++ ; return $ ans ; } $ str = \" AAABBB \" ; echo countDeletions ( $ str ) ; ? >"}
{"text":"Nth Even length Palindrome | Function to find nth even length Palindrome ; string r to store resultant palindrome . Initialize same as s ; In this loop string r stores reverse of string s after the string s in consecutive manner . ; Driver code ; Function call","code":"< ? php function evenlength ( $ n ) { $ res = $ n ; for ( $ j = strlen ( $ n ) - 1 ; $ j >= 0 ; -- $ j ) $ res = $ res . $ n [ $ j ] ; return $ res ; } $ n = \"10\" ; echo evenlength ( $ n ) ; ? >"}
{"text":"Determine if a string has all Unique Characters | PHP program to illustrate string with unique characters using brute force technique ; If at any time we encounter 2 same characters , return false ; If no duplicate characters encountered , return true ; Driver Code","code":"< ? php function uniqueCharacters ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ i ] == $ str [ $ j ] ) { return false ; } } } return true ; } $ str = \" GeeksforGeeks \" ; if ( uniqueCharacters ( $ str ) ) { echo \" The \u2581 String \u2581 \" , $ str , \" \u2581 has \u2581 all \u2581 unique \u2581 characters STRNEWLINE \" ; } else { echo \" The \u2581 String \u2581 \" , $ str , \" \u2581 has \u2581 duplicate \u2581 characters STRNEWLINE \" ; } ? >"}
{"text":"Find an equal point in a string of brackets | Method to find an equal index ; Store the number of opening brackets at each index ; Store the number of closing brackets at each index ; check if there is no opening or closing brackets ; check if there is any index at which both brackets are equal ; Driver Code","code":"< ? php function findIndex ( $ str ) { $ len = strlen ( $ str ) ; $ open = array ( 0 , $ len + 1 , NULL ) ; $ close = array ( 0 , $ len + 1 , NULL ) ; $ index = -1 ; $ open [ 0 ] = 0 ; $ close [ $ len ] = 0 ; if ( $ str [ 0 ] == ' ( ' ) $ open [ 1 ] = 1 ; if ( $ str [ $ len - 1 ] == ' ) ' ) $ close [ $ len - 1 ] = 1 ; for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) $ open [ $ i + 1 ] = $ open [ $ i ] + 1 ; else $ open [ $ i + 1 ] = $ open [ $ i ] ; } for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == ' ) ' ) $ close [ $ i ] = $ close [ $ i + 1 ] + 1 ; else $ close [ $ i ] = $ close [ $ i + 1 ] ; } if ( $ open [ $ len ] == 0 ) return $ len ; if ( $ close [ 0 ] == 0 ) return 0 ; for ( $ i = 0 ; $ i <= $ len ; $ i ++ ) if ( $ open [ $ i ] == $ close [ $ i ] ) $ index = $ i ; return $ index ; } $ str = \" ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) \" ; echo ( findIndex ( $ str ) ) ; ? >"}
{"text":"Convert decimal fraction to binary number | Function to convert decimal to binary upto k - precision after decimal point ; Fetch the integral part of decimal number ; Fetch the fractional part decimal number ; Conversion of integral part to binary equivalent ; Append 0 in binary ; Reverse string to get original binary equivalent ; Append point before conversion of fractional part ; Conversion of fractional part to binary equivalent ; Find next bit in fraction ; Driver code","code":"< ? php function decimalToBinary ( $ num , $ k_prec ) { $ binary = \" \" ; $ Integral = ( int ) ( $ num ) ; $ fractional = $ num - $ Integral ; while ( $ Integral ) { $ rem = $ Integral % 2 ; $ binary . = chr ( $ rem + 48 ) ; $ Integral = ( int ) ( $ Integral \/ 2 ) ; } $ binary = strrev ( $ binary ) ; $ binary . = ' . ' ; while ( $ k_prec -- ) { $ fractional *= 2 ; $ fract_bit = ( int ) $ fractional ; if ( $ fract_bit == 1 ) { $ fractional -= $ fract_bit ; $ binary . = chr ( 1 + 48 ) ; } else $ binary . = chr ( 0 + 48 ) ; } return $ binary ; } $ n = 4.47 ; $ k = 3 ; echo decimalToBinary ( $ n , $ k ) . \" STRNEWLINE \" ; $ n = 6.986 ; $ k = 5 ; echo decimalToBinary ( $ n , $ k ) ; ? >"}
{"text":"Difference of two large numbers | Returns true if str1 is smaller than str2 , else false . ; Calculate lengths of both string ; Function for finding difference of larger numbers ; Before proceeding further , make sure str1 is not smaller ; Take an empty string for storing result ; Calculate lengths of both string ; Initially take carry zero ; Traverse from end of both strings ; Do school mathematics , compute difference of current digits and carry ; subtract remaining digits of str1 [ ] ; if ( $i > 0 $sub > 0 ) remove preceding 0 's ; reverse resultant string ; Driver code ; Function call","code":"< ? php function isSmaller ( $ str1 , $ str2 ) { $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; if ( $ n1 < $ n2 ) return true ; if ( $ n2 < $ n1 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) { if ( $ str1 [ $ i ] < $ str2 [ $ i ] ) return true ; else if ( $ str1 [ $ i ] > $ str2 [ $ i ] ) return false ; } return false ; } function findDiff ( $ str1 , $ str2 ) { if ( isSmaller ( $ str1 , $ str2 ) ) { $ t = $ str1 ; $ str1 = $ str2 ; $ str2 = $ t ; } $ str = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; $ diff = $ n1 - $ n2 ; $ carry = 0 ; for ( $ i = $ n2 - 1 ; $ i >= 0 ; $ i -- ) { $ sub = ( ( ord ( $ str1 [ $ i + $ diff ] ) - ord ( '0' ) ) - ( ord ( $ str2 [ $ i ] ) - ord ( '0' ) ) - $ carry ) ; if ( $ sub < 0 ) { $ sub = $ sub + 10 ; $ carry = 1 ; } else $ carry = 0 ; $ str . = chr ( $ sub + ord ( \"0\" ) ) ; } for ( $ i = $ n1 - $ n2 - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str1 [ $ i ] == '0' && $ carry > 0 ) { $ str . = \"9\" ; continue ; } $ sub = ( ord ( $ str1 [ $ i ] ) - ord ( '0' ) - $ carry ) ; $ str . = chr ( $ sub + ord ( \"0\" ) ) ; $ carry = 0 ; } return strrev ( $ str ) ; } $ str1 = \"88\" ; $ str2 = \"1079\" ; print ( findDiff ( $ str1 , $ str2 ) ) ; ? >"}
{"text":"Check if two strings are k | Optimized PHP program to check if two strings are k anagram or not . ; Function to check if str1 and str2 are k - anagram or not ; If both strings are not of equal length then return false ; Store the occurrence of all characters in a hash_array ; Store the occurrence of all characters in a hash_array ; Return true if count is less than or equal to k ; Driver code","code":"< ? php $ MAX_CHAR = 26 ; function areKAnagrams ( $ str1 , $ str2 , $ k ) { global $ MAX_CHAR ; $ n = strlen ( $ str1 ) ; if ( strlen ( $ str2 ) != $ n ) return false ; $ hash_str1 = array ( 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash_str1 [ $ str1 [ $ i ] - ' a ' ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ hash_str1 [ $ str2 [ $ i ] - ' a ' ] > 0 ) $ hash_str1 [ $ str2 [ $ i ] - ' a ' ] -- ; else $ count ++ ; if ( $ count > $ k ) return false ; } return true ; } $ str1 = \" fodr \" ; $ str2 = \" gork \" ; $ k = 2 ; if ( areKAnagrams ( $ str1 , $ str2 , $ k ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Nth character in Concatenated Decimal String | Method to get dth digit of number N ; Method to return Nth character in concatenated decimal string ; sum will store character escaped till now ; dist will store numbers escaped till now ; loop for number lengths ; nine * len will be incremented characters and nine will be incremented numbers ; restore variables to previous correct state ; get distance from last one digit less maximum number ; d will store dth digit of current number ; method will return dth numbered digit of ( dist + diff ) number ; Driver code","code":"< ? php function getDigit ( $ N , $ d ) { $ string = strval ( $ N ) ; return $ string [ $ d - 1 ] ; } function getNthChar ( $ N ) { $ sum = 0 ; $ nine = 9 ; $ dist = 0 ; for ( $ len = 1 ; $ len < $ N ; $ len ++ ) { $ sum += $ nine * $ len ; $ dist += $ nine ; if ( $ sum >= $ N ) { $ sum -= $ nine * $ len ; $ dist -= $ nine ; $ N -= $ sum ; break ; } $ nine *= 10 ; } $ diff = ( $ N \/ $ len ) + 1 ; $ d = $ N % $ len ; if ( $ d == 0 ) $ d = $ len ; return getDigit ( $ dist + $ diff , $ d ) ; } $ N = 251 ; echo getNthChar ( $ N ) ; ? >"}
{"text":"Count characters at same position as in English alphabet | Function to count the number of characters at same position as in English alphabets ; Traverse the input string ; Check that index of characters of string is same as of English alphabets by using ASCII values and the fact that all lower case alphabetic characters come together in same order in ASCII table . And same is true for upper case . ; Driver Code","code":"< ? php function findCount ( $ str ) { $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ( $ i == ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) or ( $ i == ord ( $ str [ $ i ] ) - ord ( ' A ' ) ) ) $ result += 1 ; } return $ result ; } $ str = \" AbgdeF \" ; print ( findCount ( $ str ) ) ? >"}
{"text":"Generate all binary strings from given pattern | Recursive function to generate all binary strings formed by replacing each wildcard character by 0 or 1 ; replace ' ? ' by '0' and recurse ; replace ' ? ' by '1' and recurse ; No need to backtrack as string is passed by value to the function ; Driver code","code":"< ? php function print1 ( $ str , $ index ) { if ( $ index == strlen ( $ str ) ) { echo $ str . \" STRNEWLINE \" ; return ; } if ( $ str [ $ index ] == ' ? ' ) { $ str [ $ index ] = '0' ; print1 ( $ str , $ index + 1 ) ; $ str [ $ index ] = '1' ; print1 ( $ str , $ index + 1 ) ; } else print1 ( $ str , $ index + 1 ) ; } $ str = \"1 ? ? 0?101\" ; print1 ( $ str , 0 ) ; ? >"}
{"text":"Find the most frequent digit without using array \/ string | Simple function to count occurrences of digit d in x ; Initialize count of digit d ; Increment count if current digit is same as d ; Returns the max occurring digit in x ; Handle negative number ; Traverse through all digits ; Count occurrences of current digit ; Update max_count and result if needed ; Driver Code","code":"< ? php function countOccurrences ( $ x , $ d ) { $ count = 0 ; while ( $ x ) { if ( $ x % 10 == $ d ) $ count ++ ; $ x = ( int ) ( $ x \/ 10 ) ; } return $ count ; } function maxOccurring ( $ x ) { if ( $ x < 0 ) $ x = - $ x ; for ( $ d = 0 ; $ d <= 9 ; $ d ++ ) { $ count = countOccurrences ( $ x , $ d ) ; if ( $ count >= $ max_count ) { $ max_count = $ count ; $ result = $ d ; } } return $ result ; } $ x = 1223355 ; echo \" Max \u2581 occurring \u2581 digit \u2581 is \u2581 \" . maxOccurring ( $ x ) ; ? >"}
{"text":"Find the maximum subarray XOR in a given array | A simple PHP program to find max subarray XOR ; Initialize result ; Pick starting points of subarrays ; to store xor of current subarray ; Pick ending points of subarrays starting with i ; Driver Code","code":"< ? php function maxSubarrayXOR ( $ arr , $ n ) { $ ans = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_xor = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ curr_xor = $ curr_xor ^ $ arr [ $ j ] ; $ ans = max ( $ ans , $ curr_xor ) ; } } return $ ans ; } $ arr = array ( 8 , 1 , 2 , 12 ) ; $ n = count ( $ arr ) ; echo \" Max \u2581 subarray \u2581 XOR \u2581 is \u2581 \" , maxSubarrayXOR ( $ arr , $ n ) ; ? >"}
{"text":"Given a string , find its first non | PHP program to find first non - repeating character ; calculate count of characters in the passed string ; The method returns index of first non - repeating character in a string . If all characters are repeating then returns - 1 ; Driver code","code":"< ? php $ NO_OF_CHARS = 256 ; $ count = array_fill ( 0 , 200 , 0 ) ; function getCharCountArray ( $ str ) { global $ count ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) ] ++ ; } function firstNonRepeating ( $ str ) { global $ count ; getCharCountArray ( $ str ) ; $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ count [ ord ( $ str [ $ i ] ) ] == 1 ) { $ index = $ i ; break ; } } return $ index ; } $ str = \" geeksforgeeks \" ; $ index = firstNonRepeating ( $ str ) ; if ( $ index == -1 ) echo \" Either \u2581 all \u2581 characters \u2581 are \" . \" \u2581 repeating \u2581 or \u2581 string \u2581 is \u2581 empty \" ; else echo \" First \u2581 non - repeating \u2581 \" . \" character \u2581 is \u2581 \" . $ str [ $ index ] ; ? >"}
{"text":"Divide a string in N equal parts | Function to print n equal parts of str ; Check if string can be divided in n equal parts ; Calculate the size of parts to find the division point ; Driver Code length od string is 28 ; Print 4 equal parts of the string","code":"< ? php function divideString ( $ str , $ n ) { $ str_size = strlen ( $ str ) ; $ i ; $ part_size ; if ( $ str_size % $ n != 0 ) { echo \" Invalid \u2581 Input : \u2581 String \u2581 size \" ; echo \" \u2581 is \u2581 not \u2581 divisible \u2581 by \u2581 n \" ; return ; } $ part_size = $ str_size \/ $ n ; for ( $ i = 0 ; $ i < $ str_size ; $ i ++ ) { if ( $ i % $ part_size == 0 ) echo \" STRNEWLINE \" ; echo $ str [ $ i ] ; } } $ str = \" a _ simple _ divide _ string _ quest \" ; divideString ( $ str , 4 ) ; ? >"}
{"text":"Find Nth term ( A matrix exponentiation example ) | PHP program to find n - th term of a recursive function using matrix exponentiation . ; This power function returns first row of { Transformation Matrix } ^ n - 1 * Initial Vector ; This is an identity matrix . ; this is Transformation matrix . ; Matrix exponentiation to calculate power of { tMat } ^ n - 1 store res in \" res \" matrix . ; res store { Transformation matrix } ^ n - 1 hence will be first row of res * Initial Vector . ; Driver code","code":"< ? php $ MOD = 1000000009 ; function power ( $ n ) { global $ MOD ; if ( $ n <= 1 ) return 1 ; $ n -- ; $ res = array ( array ( 1 , 0 ) , array ( 0 , 1 ) ) ; $ tMat = array ( array ( 2 , 3 ) , array ( 1 , 0 ) ) ; while ( $ n ) { if ( $ n & 1 ) { $ tmp = array_fill ( 0 , 2 , array_fill ( 0 , 2 , 0 ) ) ; $ tmp [ 0 ] [ 0 ] = ( $ res [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ res [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 0 ] [ 1 ] = ( $ res [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ res [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ tmp [ 1 ] [ 0 ] = ( $ res [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ res [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 1 ] [ 1 ] = ( $ res [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ res [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ res [ 0 ] [ 0 ] = $ tmp [ 0 ] [ 0 ] ; $ res [ 0 ] [ 1 ] = $ tmp [ 0 ] [ 1 ] ; $ res [ 1 ] [ 0 ] = $ tmp [ 1 ] [ 0 ] ; $ res [ 1 ] [ 1 ] = $ tmp [ 1 ] [ 1 ] ; } $ n = ( int ) ( $ n \/ 2 ) ; $ tmp = array_fill ( 0 , 2 , array_fill ( 0 , 2 , 0 ) ) ; $ tmp [ 0 ] [ 0 ] = ( $ tMat [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ tMat [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 0 ] [ 1 ] = ( $ tMat [ 0 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ tMat [ 0 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ tmp [ 1 ] [ 0 ] = ( $ tMat [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 0 ] + $ tMat [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 0 ] ) % $ MOD ; $ tmp [ 1 ] [ 1 ] = ( $ tMat [ 1 ] [ 0 ] * $ tMat [ 0 ] [ 1 ] + $ tMat [ 1 ] [ 1 ] * $ tMat [ 1 ] [ 1 ] ) % $ MOD ; $ tMat [ 0 ] [ 0 ] = $ tmp [ 0 ] [ 0 ] ; $ tMat [ 0 ] [ 1 ] = $ tmp [ 0 ] [ 1 ] ; $ tMat [ 1 ] [ 0 ] = $ tmp [ 1 ] [ 0 ] ; $ tMat [ 1 ] [ 1 ] = $ tmp [ 1 ] [ 1 ] ; } return ( $ res [ 0 ] [ 0 ] * 1 + $ res [ 0 ] [ 1 ] * 1 ) % $ MOD ; } $ n = 3 ; echo power ( $ n ) ; ? >"}
{"text":"Place k elements such that minimum distance is maximized | Returns true if it is possible to arrange k elements of arr [ 0. . n - 1 ] with minimum distance given as mid . ; Place first element at arr [ 0 ] position ; Initialize count of elements placed . ; Try placing k elements with minimum distance mid . ; Place next element if its distance from the previously placed element is greater than current mid ; Return if all elements are placed successfully ; Returns largest minimum distance for k elements in arr [ 0. . n - 1 ] . If elements can 't be placed, returns -1. ; Sort the positions ; Initialize result . ; Consider the maximum possible distance ; Do binary search for largest minimum distance ; If it is possible to place k elements with minimum distance mid , search for higher distance . ; Change value of variable max to mid iff all elements can be successfully placed ; If not possible to place k elements , search for lower distance ; Driver Code","code":"< ? php function isFeasible ( $ mid , $ arr , $ n , $ k ) { $ pos = $ arr [ 0 ] ; $ elements = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] - $ pos >= $ mid ) { $ pos = $ arr [ $ i ] ; $ elements ++ ; if ( $ elements == $ k ) return true ; } } return 0 ; } function largestMinDist ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ res = -1 ; $ left = 1 ; $ right = $ arr [ $ n - 1 ] ; while ( $ left < $ right ) { $ mid = ( $ left + $ right ) \/ 2 ; if ( isFeasible ( $ mid , $ arr , $ n , $ k ) ) { $ res = max ( $ res , $ mid ) ; $ left = $ mid + 1 ; } else $ right = $ mid ; } return $ res ; } $ arr = array ( 1 , 2 , 8 , 4 , 9 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo largestMinDist ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Square root of an integer | Returns floor of square root of x ; Base cases ; Do Binary Search for floor ( sqrt ( x ) ) ; If x is a perfect square ; Since we need floor , we update answer when mid * mid is smaller than x , and move closer to sqrt ( x ) ; If mid * mid is greater than x ; Driver Code","code":"< ? php function floorSqrt ( $ x ) { if ( $ x == 0 $ x == 1 ) return $ x ; $ start = 1 ; $ end = $ x ; $ ans ; while ( $ start <= $ end ) { $ mid = ( $ start + $ end ) \/ 2 ; if ( $ mid * $ mid == $ x ) return $ mid ; if ( $ mid * $ mid < $ x ) { $ start = $ mid + 1 ; $ ans = $ mid ; } else $ end = $ mid - 1 ; } return $ ans ; } $ x = 11 ; echo floorSqrt ( $ x ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count of distinct rectangles inscribed in an equilateral triangle | Function to return the count of rectangles when n is odd ; Calculating number of dots in vertical level ; Calculating number of ways to select two points in the horizontal level i ; Multiply both to obtain the number of rectangles formed at that level ; Calculating number of dots in vertical level ; Calculating number of ways to select two points in the horizontal level i ; Multiply both to obtain the number of rectangles formed at that level ; Function to return the count of rectangles when n is even ; Driver code ; If n is odd","code":"< ? php function countOdd ( $ n ) { $ coun = 0 ; for ( $ i = $ n - 2 ; $ i >= 1 ; $ i -- ) { if ( $ i & 1 ) { $ m = ( $ n - $ i ) \/ 2 ; $ j = ( $ i * ( $ i + 1 ) ) \/ 2 ; $ coun += $ j * $ m ; } else { $ m = ( ( $ n - 1 ) - $ i ) \/ 2 ; $ j = ( $ i * ( $ i + 1 ) ) \/ 2 ; $ coun += $ j * $ m ; } } return $ coun ; } function countEven ( $ n ) { $ coun = 0 ; for ( $ i = $ n - 2 ; $ i >= 1 ; $ i -- ) { if ( $ i & 1 ) { $ m = ( ( $ n - 1 ) - i ) \/ 2 ; $ j = ( $ i * ( $ i + 1 ) ) \/ 2 ; $ coun += $ j * $ m ; } else { $ m = ( $ n - $ i ) \/ 2 ; $ j = ( $ i * ( $ i + 1 ) ) \/ 2 ; $ coun += $ j * $ m ; } } return $ coun ; } $ n = 5 ; if ( $ n & 1 ) echo countOdd ( $ n ) ; else echo countEven ( $ n ) ; ? >"}
{"text":"Area of the biggest ellipse inscribed within a rectangle | Function to find the area of the ellipse ; The sides cannot be negative ; Area of the ellipse ; Driver code","code":"< ? php function ellipse ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ x = ( 3.14 * $ l * $ b ) \/ 4 ; return $ x ; } $ l = 5 ; $ b = 3 ; echo ellipse ( $ l , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text":"Determine the number of squares of unit area that a given line will pass through . | Function to return the required position ;  ; Driver Code","code":"< ? php function noOfSquares ( $ x1 , $ y1 , $ x2 , $ y2 ) { $ dx = abs ( $ x2 - $ x1 ) ; $ dy = abs ( $ y2 - $ y1 ) ; $ ans = $ dx + $ dy - gcd ( $ dx , $ dy ) ; echo ( $ ans ) ; } function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } $ x1 = 1 ; $ y1 = 1 ; $ x2 = 4 ; $ y2 = 3 ; noOfSquares ( $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text":"Count paths with distance equal to Manhattan distance | Function to return the value of nCk ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ] ; Function to return the number of paths ; Difference between the ' x ' coordinates of the given points ; Difference between the ' y ' coordinates of the given points ; Driver code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res ; } function countPaths ( $ x1 , $ y1 , $ x2 , $ y2 ) { $ m = abs ( $ x1 - $ x2 ) ; $ n = abs ( $ y1 - $ y2 ) ; return ( binomialCoeff ( $ m + $ n , $ n ) ) ; } { $ x1 = 2 ; $ y1 = 3 ; $ x2 = 4 ; $ y2 = 5 ; echo ( countPaths ( $ x1 , $ y1 , $ x2 , $ y2 ) ) ; }"}
{"text":"Find the area of largest circle inscribed in ellipse | PHP program to find the area of the circle ; Area of the Reuleaux triangle ; Driver Code","code":"< ? php $ GLOBALS [ ' pi ' ] = 3.1415926 ; function areaCircle ( $ b ) { $ area = $ GLOBALS [ ' pi ' ] * $ b * $ b ; return $ area ; } $ a = 10 ; $ b = 8 ; echo round ( areaCircle ( $ b ) , 3 ) ; ? >"}
{"text":"Section formula for 3 D | Function to find the section of the line ; Applying section formula ; Printing result ; Driver code","code":"< ? php function section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) { $ x = ( ( $ m * $ x2 ) + ( $ n * $ x1 ) ) \/ ( $ m + $ n ) ; $ y = ( ( $ m * $ y2 ) + ( $ n * $ y1 ) ) \/ ( $ m + $ n ) ; $ z = ( ( $ m * $ z2 ) + ( $ n * $ z1 ) ) \/ ( $ m + $ n ) ; echo \" ( \" . $ x . \" , \" ; \u2581 echo \u2581 $ y \u2581 . \u2581 \" , \" ; \u2581 echo \u2581 $ z \u2581 . \u2581 \" ) \" \u2581 . \" \" } $ x1 = 2 ; $ x2 = 4 ; $ y1 = -1 ; $ y2 = 3 ; $ z1 = 4 ; $ z2 = 2 ; $ m = 2 ; $ n = 3 ; section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) ;"}
{"text":"Program to find the Circumcircle of any regular polygon | Function to find the radius of the circumcircle ; these cannot be negative ; Radius of the circumcircle ; Return the radius ; Driver code ; Find the radius of the circumcircle","code":"< ? php function findRadiusOfcircumcircle ( $ n , $ a ) { if ( $ n < 0 $ a < 0 ) return -1 ; $ radius = $ a \/ sqrt ( 2 - ( 2 * cos ( 360 \/ $ n ) ) ) ; return $ radius ; } $ n = 5 ; $ a = 6 ; echo findRadiusOfcircumcircle ( $ n , $ a ) ; ? >"}
{"text":"Program to find the Radius of the incircle of the triangle | Function to find the radius of the incircle ; the sides cannot be negative ; semi - perimeter of the circle ; area of the triangle ; Radius of the incircle ; Return the radius ; Get the sides of the triangle ; Find the radius of the incircle","code":"< ? php function findRadiusOfIncircle ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) \/ 2 ; $ area = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ radius = $ area \/ $ p ; return $ radius ; } $ a = 2 ; $ b = 2 ; $ c = 3 ; echo findRadiusOfIncircle ( $ a , $ b , $ c ) . \" \" ;"}
{"text":"Find area of triangle if two vectors of two adjacent sides are given | function to calculate area of triangle ; Driver Code","code":"< ? php function area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ area = sqrt ( pow ( ( $ y1 * $ z2 - $ y2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ z2 - $ x2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ y2 - $ x2 * $ y1 ) , 2 ) ) ; $ area = $ area \/ 2 ; return $ area ; } $ x1 = -2 ; $ y1 = 0 ; $ z1 = -5 ; $ x2 = 1 ; $ y2 = -2 ; $ z2 = -1 ; $ a = area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) ; echo \" Area = \" . $ a \u2581 . \" \" ? >"}
{"text":"Largest trapezoid that can be inscribed in a semicircle | Function to find the area of the biggest trapezoid ; the radius cannot be negative ; area of the trapezoid ; Driver code","code":"< ? php function trapezoidarea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3 * sqrt ( 3 ) * pow ( $ r , 2 ) ) \/ 4 ; return $ a ; } $ r = 5 ; echo trapezoidarea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text":"Largest rectangle that can be inscribed in a semicircle | Function to find the area of the biggest rectangle ; the radius cannot be negative ; area of the rectangle ; Driver code","code":"< ? php function rectanglearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = $ r * $ r ; return $ a ; } $ r = 5 ; echo rectanglearea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text":"Maximum distinct lines passing through a single point | function to find maximum lines which passes through a single point ; Driver Code","code":"< ? php function maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) { $ s = array ( ) ; $ slope ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ x1 [ $ i ] == $ x2 [ $ i ] ) $ slope = PHP_INT_MAX ; else $ slope = ( $ y2 [ $ i ] - $ y1 [ $ i ] ) * 1.0 \/ ( $ x2 [ $ i ] - $ x1 [ $ i ] ) * 1.0 ; array_push ( $ s , $ slope ) ; } return count ( $ s ) ; } $ n = 2 ; $ x1 = array ( 1 , 2 ) ; $ y1 = array ( 1 , 2 ) ; $ x2 = array ( 2 , 4 ) ; $ y2 = array ( 2 , 10 ) ; echo maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text":"Find area of parallelogram if vectors of two adjacent sides are given | Function to calculate area of parallelogram ; Driver Code","code":"< ? php function area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ area = sqrt ( pow ( ( $ y1 * $ z2 - $ y2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ z2 - $ x2 * $ z1 ) , 2 ) + pow ( ( $ x1 * $ y2 - $ x2 * $ y1 ) , 2 ) ) ; return $ area ; } $ x1 = 3 ; $ y1 = 1 ; $ z1 = -2 ; $ x2 = 1 ; $ y2 = -3 ; $ z2 = 4 ; $ a = area ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) ; echo ( \" Area \u2581 = \u2581 \" ) ; echo ( $ a ) ; ? >"}
{"text":"Maximum possible intersection by moving centers of line segments | Function to print the maximum intersection ; Case 1 ; Case 2 ; Case 3 ; Driver Code","code":"< ? php function max_intersection ( $ center , $ length , $ k ) { sort ( $ center ) ; if ( $ center [ 2 ] - $ center [ 0 ] >= 2 * $ k + $ length ) { return 0 ; } else if ( $ center [ 2 ] - $ center [ 0 ] >= 2 * $ k ) { return ( 2 * $ k - ( $ center [ 2 ] - $ center [ 0 ] - $ length ) ) ; } else return $ length ; } $ center = array ( 1 , 2 , 3 ) ; $ L = 1 ; $ K = 1 ; echo max_intersection ( $ center , $ L , $ K ) ; ? >"}
{"text":"Haversine formula to find distance between two points on a sphere | PHP program for the haversine formula ; distance between latitudes and longitudes ; convert to radians ; apply formulae ; Driver code","code":"< ? php function haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ dLat = ( $ lat2 - $ lat1 ) * M_PI \/ 180.0 ; $ dLon = ( $ lon2 - $ lon1 ) * M_PI \/ 180.0 ; $ lat1 = ( $ lat1 ) * M_PI \/ 180.0 ; $ lat2 = ( $ lat2 ) * M_PI \/ 180.0 ; $ a = pow ( sin ( $ dLat \/ 2 ) , 2 ) + pow ( sin ( $ dLon \/ 2 ) , 2 ) * cos ( $ lat1 ) * cos ( $ lat2 ) ; $ rad = 6371 ; $ c = 2 * asin ( sqrt ( $ a ) ) ; return $ rad * $ c ; } $ lat1 = 51.5007 ; $ lon1 = 0.1246 ; $ lat2 = 40.6892 ; $ lon2 = 74.0445 ; echo haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) . \" \u2581 K . M . \" ; ? >"}
{"text":"Pentatope number | Function that returns nth pentatope number ; For 5 th PentaTope Number ; For 11 th PentaTope Number","code":"< ? php function pentatopeNum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) ) \/ 24 ; } $ n = 5 ; echo pentatopeNum ( $ n ) , \" STRNEWLINE \" ; $ n = 11 ; echo pentatopeNum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Heptagonal number | Function to return Nth Heptagonal number ; Driver Code","code":"< ? php function heptagonalNumber ( $ n ) { return ( ( 5 * $ n * $ n ) - ( 3 * $ n ) ) \/ 2 ; } $ n = 2 ; echo heptagonalNumber ( $ n ) , \" STRNEWLINE \" ; $ n = 15 ; echo heptagonalNumber ( $ n ) ; ? >"}
{"text":"Icosidigonal number | Function to calculate Icosidigonal number ; Formula for finding nth Icosidigonal number ; Driver Code","code":"< ? php function icosidigonal_num ( $ n ) { return ( 20 * $ n * $ n - 18 * $ n ) \/ 2 ; } $ n = 4 ; echo $ n , \" th \u2581 Icosidigonal \u2581 number \u2581 : \u2581 \" , icosidigonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 8 ; echo $ n , \" th \u2581 Icosidigonal \u2581 number \u2581 : \u2581 \" , icosidigonal_num ( $ n ) ; ? >"}
{"text":"Hypercube Graph | PHP program to find vertices in a hypercube graph of order n ; Function to find power of 2 ; Driver Code","code":"< ? php { function power ( $ n ) { if ( $ n == 1 ) return 2 ; return 2 * power ( $ n - 1 ) ; } { $ n = 4 ; echo ( power ( $ n ) ) ; } } ? >"}
{"text":"Reflection of a point at 180 degree rotation of another point | PHP Program for find the 180 degree reflection of one point around another point . ; Driver Code","code":"< ? php function findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) { echo \" ( \" , 2 * $ x2 - $ x1 , \" , \u2581 \" , 2 * $ y2 - $ y1 , \" ) \" ; } $ x1 = 0 ; $ y1 = 0 ; $ x2 = 1 ; $ y2 = 1 ; findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text":"Program to check if the points are parallel to X axis or Y axis | To check for parallel line ; checking for parallel to X and Y axis condition ; To display the output ; Driver 's Code","code":"< ? php function parallel ( $ n , $ a ) { $ x = true ; $ y = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] [ 0 ] != $ a [ $ i + 1 ] [ 0 ] ) $ x = false ; if ( $ a [ $ i ] [ 1 ] != $ a [ $ i + 1 ] [ 1 ] ) $ y = false ; } if ( $ x ) echo \" parallel \u2581 to \u2581 Y \u2581 Axis \" ; else if ( y ) echo \" parallel \u2581 to \u2581 X \u2581 Axis \" ; else echo \" Not \u2581 parallel \u2581 to \u2581 X \" , \" \u2581 and \u2581 Y \u2581 Axis \" ; } $ a = array ( array ( 1 , 2 ) , array ( 1 , 4 ) , array ( 1 , 6 ) , array ( 1 , 0 ) ) ; $ n = count ( $ a ) ; parallel ( $ n , $ a ) ; ? >"}
{"text":"Triangular Matchstick Number | PHP program to find X - th triangular matchstick number ; Driver code","code":"< ? php function numberOfSticks ( $ x ) { return ( 3 * $ x * ( $ x + 1 ) ) \/ 2 ; } echo ( numberOfSticks ( 7 ) ) ; ? >"}
{"text":"Area of square Circumscribed by Circle | Function to find area of square ; Radius of a circle ; Call Function to find an area of square","code":"< ? php function find_Area ( $ r ) { return ( 2 * $ r * $ r ) ; } $ r = 3 ; echo ( \" Area \u2581 of \u2581 square \u2581 = \u2581 \" ) ; echo ( find_Area ( $ r ) ) ; ? >"}
{"text":"Check whether triangle is valid or not if sides are given | function to check if three sider form a triangle or not ; check condition ; Driver Code ; function calling and print output","code":"< ? php function checkValidity ( $ a , $ b , $ c ) { if ( $ a + $ b <= $ c $ a + $ c <= $ b $ b + $ c <= $ a ) return false ; else return true ; } $ a = 7 ; $ b = 10 ; $ c = 5 ; if ( checkValidity ( $ a , $ b , $ c ) ) echo \" Valid \" ; else echo \" Invalid \" ; ? >"}
{"text":"Find the Surface area of a 3D figure | Declaring the size of the matrix ; Absolute Difference between the height of two consecutive blocks ; Function To calculate the Total surfaceArea . ; Traversing the matrix . ; If we are traveling the topmost row in the matrix , we declare the wall above it as 0 as there is no wall above it . ; If we are traveling the leftmost column in the matrix , we declare the wall left to it as 0 as there is no wall left it . ; If its not the topmost row ; If its not the leftmost column ; Summing up the contribution of by the current block ; If its the rightmost block of the matrix it will contribute area equal to its height as a wall on the right of the figure ; If its the lowest block of the matrix it will contribute area equal to its height as a wall on the bottom of the figure ; Adding the contribution by the base and top of the figure ; Driver Code","code":"< ? php $ M = 3 ; $ N = 3 ; function contribution_height ( $ current , $ previous ) { return abs ( $ current - $ previous ) ; } function surfaceArea ( $ A ) { global $ M ; global $ N ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { $ up = 0 ; $ left = 0 ; if ( $ i > 0 ) $ up = $ A [ $ i - 1 ] [ $ j ] ; if ( $ j > 0 ) $ left = $ A [ $ i ] [ $ j - 1 ] ; $ ans += contribution_height ( $ A [ $ i ] [ $ j ] , $ up ) + contribution_height ( $ A [ $ i ] [ $ j ] , $ left ) ; if ( $ i == $ N - 1 ) $ ans += $ A [ $ i ] [ $ j ] ; if ( $ j == $ M - 1 ) $ ans += $ A [ $ i ] [ $ j ] ; } } $ ans += $ N * $ M * 2 ; return $ ans ; } $ A = array ( array ( 1 , 3 , 4 ) , array ( 2 , 2 , 3 ) , array ( 1 , 2 , 4 ) ) ; echo surfaceArea ( $ A ) ;"}
{"text":"Program to calculate area and volume of a Tetrahedron | Utility Function ; Driver Code","code":"< ? php function area_of_tetrahedron ( $ side ) { return ( sqrt ( 3 ) * ( $ side * $ side ) ) ; } $ side = 3 ; echo \" Area \u2581 of \u2581 Tetrahedron \u2581 = \u2581 \" , area_of_tetrahedron ( $ side ) ; ? >"}
{"text":"Program to calculate area and volume of a Tetrahedron | Function to calculate volume ; Driver Code","code":"< ? php function vol_tetra ( $ side ) { $ volume = ( pow ( $ side , 3 ) \/ ( 6 * sqrt ( 2 ) ) ) ; return $ volume ; } $ side = 3 ; $ vol = vol_tetra ( $ side ) ; echo $ vol ; ? >"}
{"text":"Counting pairs when a person can form pair with at most one | PHP program for Number of ways in which participant can take part . ; Driver code","code":"< ? php function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; } $ x = 3 ; echo numberOfWays ( $ x ) ; ? >"}
{"text":"Program to calculate area and perimeter of equilateral triangle | Function to calculate Area of equilateral triangle ; Function to calculate Perimeter of equilateral triangle ; Driver Code","code":"< ? php function area_equi_triangle ( $ side ) { return sqrt ( 3 ) \/ 4 * $ side * $ side ; } function peri_equi_triangle ( $ side ) { return 3 * $ side ; } $ side = 4 ; echo ( \" Area \u2581 of \u2581 Equilateral \u2581 Triangle : \u2581 \" ) ; echo ( area_equi_triangle ( $ side ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Perimeter \u2581 of \u2581 Equilateral \u2581 Triangle : \u2581 \" ) ; echo ( peri_equi_triangle ( $ side ) ) ; ? >"}
{"text":"Program for Volume and Surface Area of Cuboid | utility function ; Driver Code","code":"< ? php function areaCuboid ( $ l , $ h , $ w ) { return ( $ l * $ h * $ w ) ; } function surfaceAreaCuboid ( $ l , $ h , $ w ) { return ( 2 * $ l * $ w + 2 * $ w * $ h + 2 * $ l * $ h ) ; } $ l = 1 ; $ h = 5 ; $ w = 7 ; echo \" Area \u2581 = \u2581 \" , areaCuboid ( $ l , $ h , $ w ) , \" STRNEWLINE \" ; echo \" Total \u2581 Surface \u2581 Area \u2581 = \u2581 \" , surfaceAreaCuboid ( $ l , $ h , $ w ) ; ? >"}
{"text":"Program to find Circumference of a Circle | PHP program to find circumference of circle ; utility function ; Driver Code","code":"< ? php $ PI = 3.1415 ; function circumference ( $ r ) { global $ PI ; $ cir = 2 * $ PI * $ r ; return $ cir ; } $ r = 5 ; echo \" Circumference \u2581 = \u2581 \" , circumference ( $ r ) ;"}
{"text":"Program to check if three points are collinear | function to check if point collinear or not ; Driver Code","code":"< ? php function collinear ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) { if ( ( $ y3 - $ y2 ) * ( $ x2 - $ x1 ) == ( $ y2 - $ y1 ) * ( $ x3 - $ x2 ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; } $ x1 = 1 ; $ x2 = 1 ; $ x3 = 0 ; $ y1 = 1 ; $ y2 = 6 ; $ y3 = 9 ; collinear ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) ; ? >"}
{"text":"Number of rectangles in N * M grid | PHP program to count number of rectangles in a n x m grid ; Driver Code","code":"< ? php function rectCount ( $ n , $ m ) { return ( $ m * $ n * ( $ n + 1 ) * ( $ m + 1 ) ) \/ 4 ; } $ n = 5 ; $ m = 4 ; echo rectCount ( $ n , $ m ) ; ? >"}
{"text":"Number of unique rectangles formed using N unit squares | height >= length is maintained ; Driver code","code":"< ? php function countRect ( $ n ) { $ ans = 0 ; for ( $ length = 1 ; $ length <= sqrt ( $ n ) ; $ length ++ ) for ( $ height = $ length ; $ height * $ length <= $ n ; $ height ++ ) $ ans ++ ; return $ ans ; } $ n = 5 ; echo countRect ( $ n ) ; ? >"}
{"text":"Find the Missing Point of Parallelogram | Driver Code ; coordinates of A ; coordinates of B ; coordinates of C","code":"< ? php $ ax = 5 ; $ ay = 0 ; $ bx = 1 ; $ by = 1 ; $ cx = 2 ; $ cy = 5 ; echo $ ax + $ cx - $ bx , \" , \u2581 \" , $ ay + $ cy - $ by ; ? >"}
{"text":"Represent a given set of points by the best possible straight line | function to calculate m and c that best fit points represented by x [ ] and y [ ] ; Driver Code","code":"< ? php function bestApproximate ( $ x , $ y , $ n ) { $ i ; $ j ; $ m ; $ c ; $ sum_x = 0 ; $ sum_y = 0 ; $ sum_xy = 0 ; $ sum_x2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_x += $ x [ $ i ] ; $ sum_y += $ y [ $ i ] ; $ sum_xy += $ x [ $ i ] * $ y [ $ i ] ; $ sum_x2 += ( $ x [ $ i ] * $ x [ $ i ] ) ; } $ m = ( $ n * $ sum_xy - $ sum_x * $ sum_y ) \/ ( $ n * $ sum_x2 - ( $ sum_x * $ sum_x ) ) ; $ c = ( $ sum_y - $ m * $ sum_x ) \/ $ n ; echo \" m = \" , \u2581 $ m ; STRNEWLINE TABSYMBOL echo \u2581 \" c = \" } $ x = array ( 1 , 2 , 3 , 4 , 5 ) ; $ y = array ( 14 , 27 , 40 , 55 , 68 ) ; $ n = sizeof ( $ x ) ; bestApproximate ( $ x , $ y , $ n ) ; ? >"}
{"text":"Check for star graph | define the size of incidence matrix ; function to find star graph ; initialize number of vertex with deg 1 and n - 1 ; check for S1 ; check for S2 ; check for Sn ( n > 2 ) ; Driver code","code":"< ? php $ size = 4 ; function checkStar ( $ mat ) { global $ size ; $ vertexD1 = 0 ; $ vertexDn_1 = 0 ; if ( $ size == 1 ) return ( $ mat [ 0 ] [ 0 ] == 0 ) ; if ( $ size == 2 ) return ( $ mat [ 0 ] [ 0 ] == 0 && $ mat [ 0 ] [ 1 ] == 1 && $ mat [ 1 ] [ 0 ] == 1 && $ mat [ 1 ] [ 1 ] == 0 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ degreeI = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ degreeI ++ ; if ( $ degreeI == 1 ) $ vertexD1 ++ ; else if ( $ degreeI == $ size - 1 ) $ vertexDn_1 ++ ; } return ( $ vertexD1 == ( $ size - 1 ) && $ vertexDn_1 == 1 ) ; } $ mat = array ( array ( 0 , 1 , 1 , 1 ) , array ( 1 , 0 , 0 , 0 ) , array ( 1 , 0 , 0 , 0 ) , array ( 1 , 0 , 0 , 0 ) ) ; if ( checkStar ( $ mat ) ) echo ( \" Star \u2581 Graph \" ) ; else echo ( \" Not \u2581 a \u2581 Star \u2581 Graph \" ) ; ? >"}
{"text":"Minimum steps to minimize n as per given condition | A tabulation based solution in PHP ; Driver Code","code":"< ? php function getMinSteps ( $ n ) { $ table = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] = $ n - $ i ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ! ( $ i % 2 ) ) $ table [ $ i \/ 2 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i \/ 2 ] ) ; if ( ! ( $ i % 3 ) ) $ table [ $ i \/ 3 ] = min ( $ table [ $ i ] + 1 , $ table [ $ i \/ 3 ] ) ; } return $ table [ 1 ] ; } $ n = 10 ; echo getMinSteps ( $ n ) ; ? >"}
{"text":"Check if a string is the typed name of the given name | Check if the character is vowel or not ; Returns true if ' typed ' is a typed name given str ; Traverse through all characters of str . ; If current characters do not match ; If not vowel , simply move ahead in both ; Count occurrences of current vowel in str ; Count occurrences of current vowel in typed . ; Driver code","code":"< ? php function isVowel ( $ c ) { $ vowel = \" aeiou \" ; for ( $ i = 0 ; $ i < strlen ( $ vowel ) ; ++ $ i ) if ( $ vowel [ $ i ] == $ c ) return true ; return false ; } function printRLE ( $ str , $ typed ) { $ n = strlen ( $ str ) ; $ m = strlen ( $ typed ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] != $ typed [ $ j ] ) return false ; if ( isVowel ( $ str [ $ i ] ) == false ) { $ j ++ ; continue ; } $ count1 = 1 ; while ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) { $ count1 ++ ; $ i ++ ; } $ count2 = 1 ; while ( $ j < $ m - 1 && $ typed [ $ j ] == $ str [ $ i ] ) { $ count2 ++ ; $ j ++ ; } if ( $ count1 > $ count2 ) return false ; } return true ; } $ name = \" alex \" ; $ typed = \" aaalaeex \" ; if ( printRLE ( $ name , $ typed ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check whether given degrees of vertices represent a Graph or Tree | Function returns true for tree false for graph ; Find sum of all degrees ; Graph is tree if sum is equal to 2 ( n - 1 ) ; Driver Code","code":"< ? php function check ( & $ degree , $ n ) { $ deg_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ deg_sum += $ degree [ $ i ] ; return ( 2 * ( $ n - 1 ) == $ deg_sum ) ; } $ n = 5 ; $ degree = array ( 2 , 3 , 1 , 1 , 1 ) ; if ( check ( $ degree , $ n ) ) echo \" Tree \" ; else echo \" Graph \" ; ? >"}
{"text":"Check if an array represents Inorder of Binary Search tree or not | Function that returns true if array is Inorder traversal of any Binary Search Tree or not . ; Array has one or no element ; Unsorted pair found ; No unsorted pair found ; Driver code","code":"< ? php function isInorder ( $ arr , $ n ) { if ( $ n == 0 $ n == 1 ) return true ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i - 1 ] > $ arr [ $ i ] ) return false ; return true ; } $ arr = array ( 19 , 23 , 25 , 30 , 45 ) ; $ n = sizeof ( $ arr ) ; if ( isInorder ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sorted order printing of a given array that represents a BST | PHP Code for Sorted order printing of a given array that represents a BST ; print left subtree ; print root ; print right subtree ; Driver Code","code":"< ? php function printSorted ( $ arr , $ start , $ end ) { if ( $ start > $ end ) return ; printSorted ( $ arr , $ start * 2 + 1 , $ end ) ; echo ( $ arr [ $ start ] . \" \" ) ; printSorted ( $ arr , $ start * 2 + 2 , $ end ) ; } $ arr = array ( 4 , 2 , 5 , 1 , 3 ) ; printSorted ( $ arr , 0 , sizeof ( $ arr ) - 1 ) ;"}
{"text":"Leaf nodes from Preorder of a Binary Search Tree ( Using Recursion ) | Print the leaf node from the given preorder of BST . ; Driver code","code":"< ? php function isLeaf ( $ pre , & $ i , $ n , $ min , $ max ) { if ( $ i >= $ n ) return false ; if ( $ pre [ $ i ] > $ min && $ pre [ $ i ] < $ max ) { $ i ++ ; $ left = isLeaf ( $ pre , $ i , $ n , $ min , $ pre [ $ i - 1 ] ) ; $ right = isLeaf ( $ pre , $ i , $ n , $ pre [ $ i - 1 ] , $ max ) ; if ( ! $ left && ! $ right ) echo $ pre [ $ i - 1 ] , \" \u2581 \" ; return true ; } return false ; } function printLeaves ( $ preorder , $ n ) { $ i = 0 ; isLeaf ( $ preorder , $ i , $ n , PHP_INT_MIN , PHP_INT_MAX ) ; } $ preorder = array ( 890 , 325 , 290 , 530 , 965 ) ; $ n = sizeof ( $ preorder ) ; printLeaves ( $ preorder , $ n ) ; ? >"}
{"text":"Minimum Possible value of | ai + aj | function for finding pairs and min value ; initialize smallest and count ; iterate over all pairs ; is abs value is smaller than smallest update smallest and reset count to 1 ; if abs value is equal to smallest increment count value ; print result ; Driver Code","code":"< ? php function pairs ( $ arr , $ n , $ k ) { $ smallest = PHP_INT_MAX ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) < $ smallest ) { $ smallest = abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) ; $ count = 1 ; } else if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) == $ smallest ) $ count ++ ; } echo \" Minimal Value = \" \u2581 , \u2581 $ smallest \u2581 , \u2581 \" \" ; STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" Total Pairs = \" , \u2581 $ count \u2581 , \u2581 \" \" } $ arr = array ( 3 , 5 , 7 , 5 , 1 , 9 , 9 ) ; $ k = 12 ; $ n = sizeof ( $ arr ) ; pairs ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Rank of an element in a stream | Driver code","code":"< ? php $ a = array ( 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 ) ; $ key = 20 ; $ arraySize = sizeof ( $ a ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ arraySize ; $ i ++ ) { if ( $ a [ $ i ] <= $ key ) { $ count += 1 ; } } echo \" Rank \u2581 of \u2581 \" . $ key . \" \u2581 in \u2581 stream \u2581 is : \u2581 \" . ( $ count - 1 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Sum of middle row and column in Matrix | PHP program to find sum of middle row and column in matrix ; loop for sum of row ; loop for sum of column ; Driver function","code":"< ? php function middlesum ( $ mat , $ n ) { $ row_sum = 0 ; $ col_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ row_sum += $ mat [ $ n \/ 2 ] [ $ i ] ; echo \" Sum \u2581 of \u2581 middle \u2581 row \u2581 = \u2581 \" , $ row_sum , \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ col_sum += $ mat [ $ i ] [ $ n \/ 2 ] ; echo \" Sum \u2581 of \u2581 middle \u2581 column \u2581 = \u2581 \" , $ col_sum ; } $ mat = array ( array ( 2 , 5 , 7 ) , array ( 3 , 7 , 2 ) , array ( 5 , 6 , 9 ) ) ; middlesum ( $ mat , 3 ) ; ? >"}
{"text":"Rotate the matrix right by K times | size of matrix ; function to rotate matrix by k times ; temporary array of size M ; within the size of matrix ; copy first M - k elements to temporary array ; copy the elements from k to end to starting ; copy elements from temporary array to end ; function to display the matrix ; Driver code ; rotate matrix by k ; display rotated matrix","code":"< ? php $ M = 3 ; $ N = 3 ; function rotateMatrix ( & $ matrix , $ k ) { global $ M , $ N ; $ temp = array ( ) ; $ k = $ k % $ M ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ t = 0 ; $ t < $ M - $ k ; $ t ++ ) $ temp [ $ t ] = $ matrix [ $ i ] [ $ t ] ; for ( $ j = $ M - $ k ; $ j < $ M ; $ j ++ ) $ matrix [ $ i ] [ $ j - $ M + $ k ] = $ matrix [ $ i ] [ $ j ] ; for ( $ j = $ k ; $ j < $ M ; $ j ++ ) $ matrix [ $ i ] [ $ j ] = $ temp [ $ j - $ k ] ; } } function displayMatrix ( & $ matrix ) { global $ M , $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) echo ( $ matrix [ $ i ] [ $ j ] . \" \u2581 \" ) ; echo ( \" STRNEWLINE \" ) ; } } $ matrix = array ( array ( 12 , 23 , 34 ) , array ( 45 , 56 , 67 ) , array ( 78 , 89 , 91 ) ) ; $ k = 2 ; rotateMatrix ( $ matrix , $ k ) ; displayMatrix ( $ matrix ) ; ? >"}
{"text":"Program to check Involutory Matrix | Program to implement involutory matrix . ; Function for matrix multiplication . ; Function to check involutory matrix . ; multiply function call . ; Driver Code ; Function call . If function return true then if part will execute otherwise else part will execute .","code":"< ? php $ N = 3 ; function multiply ( $ mat , $ res ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ res [ $ i ] [ $ j ] = 0 ; for ( $ k = 0 ; $ k < $ N ; $ k ++ ) $ res [ $ i ] [ $ j ] += $ mat [ $ i ] [ $ k ] * $ mat [ $ k ] [ $ j ] ; } } return $ res ; } function InvolutoryMatrix ( $ mat ) { global $ N ; $ res ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ res [ $ i ] [ $ j ] = 0 ; $ res = multiply ( $ mat , $ res ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ i == $ j && $ res [ $ i ] [ $ j ] != 1 ) return false ; if ( $ i != $ j && $ res [ $ i ] [ $ j ] != 0 ) return false ; } } return true ; } $ mat = array ( array ( 1 , 0 , 0 ) , array ( 0 , -1 , 0 ) , array ( 0 , 0 , -1 ) ) ; if ( InvolutoryMatrix ( $ mat ) ) echo \" Involutory \u2581 Matrix \" ; else echo \" Not \u2581 Involutory \u2581 Matrix \" ; ? >"}
{"text":"Interchange elements of first and last rows in matrix | PHP code to swap the element of first and last row and display the result ; swapping of element between first and last rows ; input in the array ; printing the interchanged matrix","code":"< ? php $ n = 4 ; function interchangeFirstLast ( & $ m ) { global $ n ; $ rows = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ t = $ m [ 0 ] [ $ i ] ; $ m [ 0 ] [ $ i ] = $ m [ $ rows - 1 ] [ $ i ] ; $ m [ $ rows - 1 ] [ $ i ] = $ t ; } } $ m = array ( array ( 8 , 9 , 7 , 6 ) , array ( 4 , 7 , 6 , 5 ) , array ( 3 , 2 , 1 , 8 ) , array ( 9 , 9 , 7 , 7 ) ) ; interchangeFirstLast ( $ m ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ m [ $ i ] [ $ j ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } ? >"}
{"text":"Program for Markov matrix | PHP code to check Markov Matrix ; outer loop to access rows and inner to access columns ; Find sum of current row ; Matrix to check ; calls the function check ( )","code":"< ? php function checkMarkov ( $ m ) { $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum = $ sum + $ m [ $ i ] [ $ j ] ; if ( $ sum != 1 ) return false ; } return true ; } $ m = array ( array ( 0 , 0 , 1 ) , array ( 0.5 , 0 , 0.5 ) , array ( 1 , 0 , 0 ) ) ; if ( checkMarkov ( $ m ) ) echo \" \u2581 yes \u2581 \" ; else echo \" \u2581 no \u2581 \" ; ? >"}
{"text":"Program to check diagonal matrix and scalar matrix | Program to check matrix is diagonal matrix or not . ; Function to check matrix is diagonal matrix or not . ; condition to check other elements except main diagonal are zero or not . ; Driver Code","code":"< ? php $ N = 4 ; function isDiagonalMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; return true ; } $ mat = array ( array ( 4 , 0 , 0 , 0 ) , array ( 0 , 7 , 0 , 0 ) , array ( 0 , 0 , 5 , 0 ) , array ( 0 , 0 , 0 , 1 ) ) ; if ( isDiagonalMatrix ( $ mat ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; ? >"}
{"text":"Program to check diagonal matrix and scalar matrix | Program to check matrix is scalar matrix or not . ; Function to check matrix is scalar matrix or not . ; Check all elements except main diagonal are zero or not . ; Check all diagonal elements are same or not . ; Driver Code ; Function call","code":"< ? php $ N = 4 ; function isScalarMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] != $ mat [ $ i + 1 ] [ $ i + 1 ] ) return false ; return true ; } $ mat = array ( array ( 2 , 0 , 0 , 0 ) , array ( 0 , 2 , 0 , 0 ) , array ( 0 , 0 , 2 , 0 ) , array ( 0 , 0 , 0 , 2 ) ) ; if ( isScalarMatrix ( $ mat ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check given matrix is magic square or not | Returns true if mat [ ] [ ] is magic square , else returns false . ; calculate the sum of the prime diagonal ; the secondary diagonal ; For sums of Rows ; check if every row sum is equal to prime diagonal sum ; For sums of Columns ; check if every column sum is equal to prime diagonal sum ; Driver Code","code":"< ? php function isMagicSquare ( $ mat ) { $ sum = 0 ; $ N = 3 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ sum = $ sum + $ mat [ $ i ] [ $ i ] ; $ sum2 = 0 ; $ N = 3 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ sum2 = $ sum2 + $ mat [ $ i ] [ $ N - $ i - 1 ] ; if ( $ sum != $ sum2 ) return false ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ rowSum = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ rowSum += $ mat [ $ i ] [ $ j ] ; if ( $ rowSum != $ sum ) return false ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ colSum = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ colSum += $ mat [ $ j ] [ $ i ] ; if ( $ sum != $ colSum ) return false ; } return true ; } { $ mat = array ( array ( 2 , 7 , 6 ) , array ( 9 , 5 , 1 ) , array ( 4 , 3 , 8 ) ) ; if ( isMagicSquare ( $ mat ) ) echo \" Magic \u2581 Square \" ; else echo \" Not \u2581 a \u2581 magic \u2581 Square \" ; return 0 ; } ? >"}
{"text":"Count sub | function to count all sub - arrays divisible by k ; create auxiliary hash array to count frequency of remainders ; Traverse original array and compute cumulative sum take remainder of this current cumulative sum and increase count by 1 for this remainder in mod array ; as the sum can be negative , taking modulo twice ; Initialize result ; Traverse mod ; If there are more than one prefix subarrays with a particular mod value . ; add the subarrays starting from the arr [ i ] which are divisible by k itself ; function to count all sub - matrices having sum divisible by the value ' k ' ; Variable to store the final output ; Set the left column ; Initialize all elements of temp as 0 ; Set the right column for the left column set by outer loop ; Calculate sum between current left and right for every row ' i ' ; Count number of subarrays in temp having sum divisible by ' k ' and then add it to ' tot _ count ' ; required count of sub - matrices having sum divisible by ' k ' ; Driver Code","code":"< ? php function subCount ( $ arr , $ n , $ k ) { $ mod = array ( ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ mod [ $ i ] = 0 ; $ cumSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ cumSum += $ arr [ $ i ] ; $ mod [ ( ( $ cumSum % $ k ) + $ k ) % $ k ] ++ ; } $ result = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( $ mod [ $ i ] > 1 ) $ result += ( $ mod [ $ i ] * ( $ mod [ $ i ] - 1 ) ) \/ 2 ; $ result += $ mod [ 0 ] ; return $ result ; } function countSubmatrix ( $ mat , $ n , $ k ) { $ tot_count = 0 ; $ temp = array ( ) ; for ( $ left = 0 ; $ left < $ n ; $ left ++ ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ temp [ $ i ] = 0 ; for ( $ right = $ left ; $ right < $ n ; $ right ++ ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ temp [ $ i ] += $ mat [ $ i ] [ $ right ] ; $ tot_count += subCount ( $ temp , $ n , $ k ) ; } } return $ tot_count ; } $ mat = array ( array ( 5 , -1 , 6 ) , array ( -2 , 3 , 8 ) , array ( 7 , 4 , -9 ) ) ; $ n = 3 ; $ k = 4 ; echo ( \" Count \u2581 = \u2581 \" . countSubmatrix ( $ mat , $ n , $ k ) ) ; ? >"}
{"text":"Count frequency of k in a matrix of size n where matrix ( i , j ) = i + j | PHP program to find the frequency of k in matrix where m ( i , j ) = i + j ; Driver Code","code":"< ? php function find ( $ n , $ k ) { if ( $ n + 1 >= $ k ) return ( $ k - 1 ) ; else return ( 2 * $ n + 1 - $ k ) ; } $ n = 4 ; $ k = 7 ; $ freq = find ( $ n , $ k ) ; if ( $ freq < 0 ) echo \" \u2581 element \u2581 not \u2581 exist \u2581 STRNEWLINE \u2581 \" ; else echo \" \u2581 Frequency \u2581 of \u2581 \" , $ k , \" \u2581 is \u2581 \" , $ freq , \" STRNEWLINE \" ; ? >"}
{"text":"Given 1 ' s , \u2581 2' s , 3 ' s \u2581 . . . . . . k ' s print them in zig zag way . | function that prints given number of 1 ' s , \u2581 2' s , 3 ' s \u2581 . . . . k ' s in zig - zag way . ; two - dimensional array to store numbers . ; for even row . ; for each column . ; storing element . ; decrement element at kth index . ; if array contains zero then increment index to make this next index ; for odd row . ; for each column . ; storing element . ; decrement element at kth index . ; if array contains zero then increment index to make this next index . ; printing the stored elements . ; Driver Code","code":"< ? php function ZigZag ( $ rows , $ columns , $ numbers ) { $ k = 0 ; $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { if ( $ i % 2 == 0 ) { for ( $ j = 0 ; $ j < $ columns and $ numbers [ $ k ] > 0 ; $ j ++ ) { $ arr [ $ i ] [ $ j ] = $ k + 1 ; $ numbers [ $ k ] -- ; if ( $ numbers [ $ k ] == 0 ) $ k ++ ; } } else { for ( $ j = $ columns - 1 ; $ j >= 0 and $ numbers [ $ k ] > 0 ; $ j -- ) { $ arr [ $ i ] [ $ j ] = $ k + 1 ; $ numbers [ $ k ] -- ; if ( $ numbers [ $ k ] == 0 ) $ k ++ ; } } } for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { for ( $ j = 0 ; $ j < $ columns ; $ j ++ ) echo $ arr [ $ i ] [ $ j ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } } $ rows = 4 ; $ columns = 5 ; $ Numbers = array ( 3 , 4 , 2 , 2 , 3 , 1 , 5 ) ; ZigZag ( $ rows , $ columns , $ Numbers ) ; ? >"}
{"text":"Number of cells a queen can move with obstacles on the chessborad | Return the number of position a Queen can move . ; d11 , d12 , d21 , d22 are for diagnoal distances . r1 , r2 are for vertical distance . c1 , c2 are for horizontal distance . ; Initialise the distance to end of the board . ; For each obstacle find the minimum distance . If obstacle is present in any direction , distance will be updated . ; Chessboard size ; number of obstacles ; Queen x position ; Queen y position ; x position of obstacles ; y position of obstacles","code":"< ? php function numberofPosition ( $ n , $ k , $ x , $ y , $ obstPosx , $ obstPosy ) { $ d11 ; $ d12 ; $ d21 ; $ d22 ; $ r1 ; $ r2 ; $ c1 ; $ c2 ; $ d11 = min ( $ x - 1 , $ y - 1 ) ; $ d12 = min ( $ n - $ x , $ n - $ y ) ; $ d21 = min ( $ n - $ x , $ y - 1 ) ; $ d22 = min ( $ x - 1 , $ n - $ y ) ; $ r1 = $ y - 1 ; $ r2 = $ n - $ y ; $ c1 = $ x - 1 ; $ c2 = $ n - $ x ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { if ( $ x > $ obstPosx [ $ i ] && $ y > $ obstPosy [ $ i ] && $ x - $ obstPosx [ $ i ] == $ y - $ obstPosy [ $ i ] ) $ d11 = min ( $ d11 , $ x - $ obstPosx [ $ i ] - 1 ) ; if ( $ obstPosx [ $ i ] > $ x && $ obstPosy [ $ i ] > $ y && $ obstPosx [ $ i ] - $ x == $ obstPosy [ $ i ] - $ y ) $ d12 = min ( $ d12 , $ obstPosx [ $ i ] - $ x - 1 ) ; if ( $ obstPosx [ $ i ] > $ x && $ y > $ obstPosy [ $ i ] && $ obstPosx [ $ i ] - $ x == $ y - $ obstPosy [ $ i ] ) $ d21 = min ( $ d21 , $ obstPosx [ $ i ] - $ x - 1 ) ; if ( $ x > $ obstPosx [ $ i ] && $ obstPosy [ $ i ] > $ y && $ x - $ obstPosx [ $ i ] == $ obstPosy [ $ i ] - $ y ) $ d22 = min ( $ d22 , $ x - $ obstPosx [ $ i ] - 1 ) ; if ( $ x == $ obstPosx [ $ i ] && $ obstPosy [ $ i ] < $ y ) $ r1 = min ( $ r1 , $ y - $ obstPosy [ $ i ] - 1 ) ; if ( $ x == $ obstPosx [ $ i ] && $ obstPosy [ $ i ] > $ y ) $ r2 = min ( $ r2 , $ obstPosy [ $ i ] - $ y - 1 ) ; if ( $ y == $ obstPosy [ $ i ] && $ obstPosx [ $ i ] < $ x ) $ c1 = min ( $ c1 , $ x - $ obstPosx [ $ i ] - 1 ) ; if ( $ y == $ obstPosy [ $ i ] && $ obstPosx [ $ i ] > $ x ) $ c2 = min ( $ c2 , $ obstPosx [ $ i ] - $ x - 1 ) ; } return $ d11 + $ d12 + $ d21 + $ d22 + $ r1 + $ r2 + $ c1 + $ c2 ; } $ n = 8 ; $ k = 1 ; $ Qposx = 4 ; $ Qposy = 4 ; $ obstPosx = array ( 3 ) ; $ obstPosy = array ( 5 ) ; echo numberofPosition ( $ n , $ k , $ Qposx , $ Qposy , $ obstPosx , $ obstPosy ) ; ? >"}
{"text":"Maximum product of 4 adjacent elements in matrix | PHP program to find out the maximum product in the matrix which four elements are adjacent to each other in one direction ; function to find max product ; iterate the rows . ; iterate the columns . ; check the maximum product in horizontal row . ; check the maximum product in vertical row . ; check the maximum product in diagonal going through down - right ; check the maximum product in diagonal going through up - right ; Driver Code","code":"< ? php $ n = 5 ; function FindMaxProduct ( $ arr , $ n ) { $ max = 0 ; $ result ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ j - 3 ) >= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i ] [ $ j - 1 ] * $ arr [ $ i ] [ $ j - 2 ] * $ arr [ $ i ] [ $ j - 3 ] ; if ( $ max < $ result ) $ max = $ result ; } if ( ( $ i - 3 ) >= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i - 1 ] [ $ j ] * $ arr [ $ i - 2 ] [ $ j ] * $ arr [ $ i - 3 ] [ $ j ] ; if ( $ max < $ result ) $ max = $ result ; } if ( ( $ i - 3 ) >= 0 and ( $ j - 3 ) >= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i - 1 ] [ $ j - 1 ] * $ arr [ $ i - 2 ] [ $ j - 2 ] * $ arr [ $ i - 3 ] [ $ j - 3 ] ; if ( $ max < $ result ) $ max = $ result ; } if ( ( $ i - 3 ) >= 0 and ( $ j - 1 ) <= 0 ) { $ result = $ arr [ $ i ] [ $ j ] * $ arr [ $ i - 1 ] [ $ j + 1 ] * $ arr [ $ i - 2 ] [ $ j + 2 ] * $ arr [ $ i - 3 ] [ $ j + 3 ] ; if ( $ max < $ result ) $ max = $ result ; } } } return $ max ; } $ arr = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 6 , 7 , 8 , 9 , 1 ) , array ( 2 , 3 , 4 , 5 , 6 ) , array ( 7 , 8 , 9 , 1 , 0 ) , array ( 9 , 6 , 4 , 2 , 3 ) ) ; echo FindMaxProduct ( $ arr , $ n ) ; ? >"}
{"text":"Minimum flip required to make Binary Matrix symmetric | PHP Program to find minimum flip required to make ; Return the minimum flip required to make Binary Matrix symmetric along main diagonal . ; finding the transpose of the matrix ; Finding the number of position where element are not same . ; Driver Code","code":"< ? php $ N = 3 ; function minimumflip ( $ mat , $ n ) { global $ N ; $ transpose ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ transpose [ $ i ] [ $ j ] = $ mat [ $ j ] [ $ i ] ; $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ transpose [ $ i ] [ $ j ] != $ mat [ $ i ] [ $ j ] ) $ flip ++ ; return $ flip \/ 2 ; } $ n = 3 ; $ mat = array ( array ( 0 , 0 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) ) ; echo minimumflip ( $ mat , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Minimum flip required to make Binary Matrix symmetric | PHP Program to find minimum flip required to make Binary Matrix symmetric along main diagonal ; Return the minimum flip required to make Binary Matrix symmetric along main diagonal . ; Comparing elements across diagonal ; Driver Code","code":"< ? php $ N = 3 ; function minimumflip ( $ mat , $ n ) { $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) $ flip ++ ; return $ flip ; } $ n = 3 ; $ mat = array ( array ( 0 , 0 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) ) ; echo minimumflip ( $ mat , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Frequencies of even and odd numbers in a matrix | PHP Program to Find the frequency of even and odd numbers in a matrix ; function for calculating frequency ; modulo by 2 to check even and odd ; print Frequency of numbers ; Driver code","code":"< ? php $ MAX = 100 ; function freq ( $ ar , $ m , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) { for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( ( $ ar [ $ i ] [ $ j ] % 2 ) == 0 ) ++ $ even ; else ++ $ odd ; } } echo \" \u2581 Frequency \u2581 of \u2581 odd \u2581 number \u2581 = \u2581 \" , $ odd , \" STRNEWLINE \" ; echo \" \u2581 Frequency \u2581 of \u2581 even \u2581 number \u2581 = \u2581 \" , $ even ; } $ m = 3 ; $ n = 3 ; $ array = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; freq ( $ array , $ m , $ n ) ; ? >"}
{"text":"Center element of matrix equals sums of half diagonals | PHP Program to check if the center element is equal to the individual sum of all the half diagonals ; Function to Check center element is equal to the individual sum of all the half diagonals ; Find sums of half diagonals ; Driver code","code":"< ? php $ MAX = 100 ; function HalfDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ diag1_left = 1 ; $ diag1_right = 1 ; $ diag2_left = 1 ; $ diag2_right = 1 ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ n ; $ i ++ , $ j -- ) { if ( $ i < $ n \/ 2 ) { $ diag1_left += $ mat [ $ i ] [ $ i ] ; $ diag2_left += $ mat [ $ j ] [ $ i ] ; } else if ( $ i > $ n \/ 2 ) { $ diag1_right += $ mat [ $ i ] [ $ i ] ; $ diag2_right += $ mat [ $ j ] [ $ i ] ; } } return ( $ diag1_left == $ diag2_right && $ diag2_right == $ diag2_left && $ diag1_right == $ diag2_left && $ diag2_right == $ mat [ $ n \/ 2 ] [ $ n \/ 2 ] ) ; } $ a = array ( array ( 2 , 9 , 1 , 4 , -2 ) , array ( 6 , 7 , 2 , 11 , 4 ) , array ( 4 , 2 , 9 , 2 , 4 ) , array ( 1 , 9 , 2 , 4 , 4 ) , array ( 0 , 2 , 4 , 2 , 5 ) ) ; if ( HalfDiagonalSums ( $ a , 5 ) == 0 ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program for Identity Matrix | PHP program to print Identity Matrix ; Checking if row is equal to column ; Driver Code","code":"< ? php function Identity ( $ num ) { $ row ; $ col ; for ( $ row = 0 ; $ row < $ num ; $ row ++ ) { for ( $ col = 0 ; $ col < $ num ; $ col ++ ) { if ( $ row == $ col ) echo 1 , \" \u2581 \" ; else echo 0 , \" \u2581 \" ; } echo \" STRNEWLINE \" ; } return 0 ; } $ size = 5 ; identity ( $ size ) ; ? >"}
{"text":"Program for Identity Matrix | PHP program to check if a given matrix is identity $MAX = 100 ; ; Driver Code","code":"< ? php function isIdentity ( $ mat , $ N ) { for ( $ row = 0 ; $ row < $ N ; $ row ++ ) { for ( $ col = 0 ; $ col < $ N ; $ col ++ ) { if ( $ row == $ col and $ mat [ $ row ] [ $ col ] != 1 ) return false ; else if ( $ row != $ col && $ mat [ $ row ] [ $ col ] != 0 ) return false ; } } return true ; } $ N = 4 ; $ mat = array ( array ( 1 , 0 , 0 , 0 ) , array ( 0 , 1 , 0 , 0 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 0 , 0 , 1 ) ) ; if ( isIdentity ( $ mat , $ N ) ) echo \" Yes \u2581 \" ; else echo \" No \u2581 \" ; ? >"}
{"text":"Ways of filling matrix such that product of all rows and all columns are equal to unity | PHP program to find number of ways to fill a matrix under given constraints ; Returns a raised power t under modulo mod ; Counting number of ways of filling the matrix ; Function calculating the answer ; if sum of numbers of rows and columns is odd i . e ( n + m ) % 2 == 1 and k = - 1 then there are 0 ways of filiing the matrix . ; If there is one row or one column then there is only one way of filling the matrix ; If the above cases are not followed then we find ways to fill the n - 1 rows and m - 1 columns which is 2 ^ ( ( m - 1 ) * ( n - 1 ) ) . ; Driver Code","code":"< ? php $ mod = 100000007 ; function modPower ( $ a , $ t ) { global $ mod ; $ now = $ a ; $ ret = 1 ; while ( $ t ) { if ( $ t & 1 ) $ ret = $ now * ( $ ret % $ mod ) ; $ now = $ now * ( $ now % $ mod ) ; $ t >>= 1 ; } return $ ret ; } function countWays ( $ n , $ m , $ k ) { global $ mod ; if ( $ k == -1 and ( $ n + $ m ) % 2 == 1 ) return 0 ; if ( $ n == 1 or $ m == 1 ) return 1 ; return ( modPower ( modPower ( 2 , $ n - 1 ) , $ m - 1 ) % $ mod ) ; } $ n = 2 ; $ m = 7 ; $ k = 1 ; echo countWays ( $ n , $ m , $ k ) ; ? >"}
{"text":"Mirror of matrix across diagonal | Efficient PHP program to find mirror of matrix across diagonal . ; traverse a matrix and swap mat [ i ] [ j ] with mat [ j ] [ i ] ; Utility function to print a matrix ; Driver Code","code":"< ? php function imageSwap ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ mat [ $ j ] [ $ i ] - ( $ mat [ $ j ] [ $ i ] = $ mat [ $ i ] [ $ j ] ) ; } function printMatrix ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo ( $ mat [ $ i ] [ $ j ] ) ; echo ( \" \u2581 \" ) ; } echo ( \" STRNEWLINE \" ) ; } } $ mat = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 9 , 10 , 11 , 12 ) , array ( 13 , 14 , 15 , 16 ) ) ; $ n = 4 ; imageSwap ( $ mat , $ n ) ; printMatrix ( $ mat , $ n ) ; ? >"}
{"text":"Search in a row wise and column wise sorted matrix | Searches the element $x in mat [ ] [ ] . If the element is found , then prints its position and returns true , otherwise prints \" not \u2581 found \" and returns false ; set indexes for top right element ; if $mat [ $i ] [ $j ] < $x ; if ( $i == $n $j == - 1 ) ; Driver Code","code":"< ? php function search ( & $ mat , $ n , $ x ) { $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) { echo \" n \u2581 found \u2581 at \u2581 \" . $ i . \" , \u2581 \" . $ j ; return 1 ; } if ( $ mat [ $ i ] [ $ j ] > $ x ) $ j -- ; else $ i ++ ; } echo \" n \u2581 Element \u2581 not \u2581 found \" ; return 0 ; } $ mat = array ( array ( 10 , 20 , 30 , 40 ) , array ( 15 , 25 , 35 , 45 ) , array ( 27 , 29 , 37 , 48 ) , array ( 32 , 33 , 39 , 50 ) ) ; search ( $ mat , 4 , 29 ) ; ? >"}
{"text":"Create a matrix with alternating rectangles of O and X | Function to print alternating rectangles of 0 and X ; k - starting row index m - ending row index l - starting column index n - ending column index i - iterator ; Store given number of rows and columns for later use ; Iniitialize the character to be stoed in a [ ] [ ] ; Fill characters in a [ ] [ ] in spiral form . Every iteration fills one rectangle of either Xs or Os ; Fill the first row from the remaining rows ; Fill the last column from the remaining columns ; Fill the last row from the remaining rows ; Print the first column from the remaining columns ; Flip character for next iteration ; Print the filled matrix ; Driver Code","code":"< ? php function fill0X ( $ m , $ n ) { $ k = 0 ; $ l = 0 ; $ r = $ m ; $ c = $ n ; $ x = ' X ' ; while ( $ k < $ m && $ l < $ n ) { for ( $ i = $ l ; $ i < $ n ; ++ $ i ) $ a [ $ k ] [ $ i ] = $ x ; $ k ++ ; for ( $ i = $ k ; $ i < $ m ; ++ $ i ) $ a [ $ i ] [ $ n - 1 ] = $ x ; $ n -- ; if ( $ k < $ m ) { for ( $ i = $ n - 1 ; $ i >= $ l ; -- $ i ) $ a [ $ m - 1 ] [ $ i ] = $ x ; $ m -- ; } if ( $ l < $ n ) { for ( $ i = $ m - 1 ; $ i >= $ k ; -- $ i ) $ a [ $ i ] [ $ l ] = $ x ; $ l ++ ; } $ x = ( $ x == '0' ) ? ' X ' : '0' ; } for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { for ( $ j = 0 ; $ j < $ c ; $ j ++ ) echo ( $ a [ $ i ] [ $ j ] . \" \u2581 \" ) ; echo \" STRNEWLINE \" ; } } echo \" Output \u2581 for \u2581 m \u2581 = \u2581 5 , \u2581 n \u2581 = \u2581 6 STRNEWLINE \" ; fill0X ( 5 , 6 ) ; echo \" Output for m = 4 , n = 4 \" ; fill0X ( 4 , 4 ) ; echo \" Output for m = 3 , n = 4 \" ; fill0X ( 3 , 4 ) ; ? >"}
{"text":"Minimum cost to sort a matrix of numbers from 0 to n ^ 2 | function to find the total energy required to rearrange the numbers ; nested loops to access the elements of the given matrix ; store quotient ; final destination location ( i_des , j_des ) of the element mat [ i ] [ j ] is being calculated ; energy required for the movement of the element mat [ i ] [ j ] is calculated and then accumulated in the ' tot _ energy ' ; required total energy ; Driver Code","code":"< ? php function calculateEnergy ( $ mat , $ n ) { $ i_des ; $ j_des ; $ q ; $ tot_energy = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ q = ( int ) ( $ mat [ $ i ] [ $ j ] \/ $ n ) ; $ i_des = $ q ; $ j_des = $ mat [ $ i ] [ $ j ] - ( $ n * $ q ) ; $ tot_energy += abs ( $ i_des - $ i ) + abs ( $ j_des - $ j ) ; } } return $ tot_energy ; } $ mat = array ( array ( 4 , 7 , 0 , 3 ) , array ( 8 , 5 , 6 , 1 ) , array ( 9 , 11 , 10 , 2 ) , array ( 15 , 13 , 14 , 12 ) ) ; $ n = 4 ; echo \" Total \u2581 energy \u2581 required \u2581 = \u2581 \" , calculateEnergy ( $ mat , $ n ) , \" \u2581 units \" ; ? >"}
{"text":"Unique cells in a binary matrix | PHP program to count unique cells in a matrix ; Returns true if mat [ i ] [ j ] is unique ; checking in row calculating sumrow will be moving column wise ; checking in column calculating sumcol will be moving row wise ; Driver code","code":"< ? php $ MAX = 100 ; function isUnique ( $ mat , $ i , $ j , $ n , $ m ) { global $ MAX ; $ sumrow = 0 ; for ( $ k = 0 ; $ k < $ m ; $ k ++ ) { $ sumrow += $ mat [ $ i ] [ $ k ] ; if ( $ sumrow > 1 ) return false ; } $ sumcol = 0 ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { $ sumcol += $ mat [ $ k ] [ $ j ] ; if ( $ sumcol > 1 ) return false ; } return true ; } function countUnique ( $ mat , $ n , $ m ) { $ uniquecount = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] && isUnique ( $ mat , $ i , $ j , $ n , $ m ) ) $ uniquecount ++ ; return $ uniquecount ; } $ mat = array ( array ( 0 , 1 , 0 , 0 ) , array ( 0 , 0 , 1 , 0 ) , array ( 1 , 0 , 0 , 1 ) ) ; echo countUnique ( $ mat , 3 , 4 ) ; ? >"}
{"text":"Check if a given matrix is sparse or not | PHP code to check if a matrix is sparse . ; Count number of zeros in the matrix ; Driver Code","code":"< ? php $ MAX = 100 ; function isSparse ( $ array , $ m , $ n ) { $ counter = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) for ( $ j = 0 ; $ j < $ n ; ++ $ j ) if ( $ array [ $ i ] [ $ j ] == 0 ) ++ $ counter ; return ( $ counter > ( ( $ m * $ n ) \/ 2 ) ) ; } $ array = array ( array ( 1 , 0 , 3 ) , array ( 0 , 0 , 4 ) , array ( 6 , 0 , 0 ) ) ; $ m = 3 ; $ n = 3 ; if ( isSparse ( $ array , $ m , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Row | PHP program to find common elements in two diagonals . ; Returns count of row wise same elements in two diagonals of mat [ n ] [ n ] ; Driver Code","code":"< ? php $ MAX = 100 ; function countCommon ( $ mat , $ n ) { global $ MAX ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] == $ mat [ $ i ] [ $ n - $ i - 1 ] ) $ res ++ ; return $ res ; } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; echo countCommon ( $ mat , 3 ) ; ? >"}
{"text":"Check if sums of i | Function to check the if sum of a row is same as corresponding column ; number of rows ; number of columns","code":"< ? php function areSumSame ( $ a , $ n , $ m ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ sum1 += $ a [ $ i ] [ $ j ] ; $ sum2 += $ a [ $ j ] [ $ i ] ; } if ( $ sum1 == $ sum2 ) return true ; } return false ; } $ n = 4 ; $ m = 4 ; $ M = array ( array ( 1 , 2 , 3 , 4 ) , array ( 9 , 5 , 3 , 1 ) , array ( 0 , 3 , 5 , 6 ) , array ( 0 , 4 , 5 , 6 ) ) ; echo areSumSame ( $ M , $ n , $ m ) ; ? >"}
{"text":"Find row number of a binary matrix having maximum number of 1 s | PHP program to find row with maximum 1 in row sorted binary matrix ; function for finding row with maximum 1 ; find left most position of 1 in a row find 1 st zero in a row ; Driver Code","code":"< ? php $ N = 4 ; function findMax ( $ arr ) { global $ N ; $ row = 0 ; $ i ; $ j = $ N - 1 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { while ( $ arr [ $ i ] [ $ j ] == 1 && $ j >= 0 ) { $ row = $ i ; $ j -- ; } } echo \" Row \u2581 number \u2581 = \u2581 \" , $ row + 1 ; echo \" , MaxCount = \" } $ arr = array ( array ( 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 0 , 0 ) , array ( 0 , 1 , 1 , 1 ) ) ; findMax ( $ arr ) ; ? >"}
{"text":"Possible moves of knight | PHP program to find number of possible moves of knight ; To calculate possible moves ; All possible moves of a knight ; Check if each possible move is valid or not ; Position of knight after move ; count valid moves ; Return number of possible moves ; Driver Code","code":"< ? php $ n = 4 ; $ m = 4 ; function findPossibleMoves ( $ mat , $ p , $ q ) { global $ n ; global $ m ; $ X = array ( 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 ) ; $ Y = array ( 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { $ x = $ p + $ X [ $ i ] ; $ y = $ q + $ Y [ $ i ] ; if ( $ x >= 0 && $ y >= 0 && $ x < $ n && $ y < $ m && $ mat [ $ x ] [ $ y ] == 0 ) $ count ++ ; } return $ count ; } $ mat = array ( array ( 1 , 0 , 1 , 0 ) , array ( 0 , 1 , 1 , 1 ) , array ( 1 , 1 , 0 , 1 ) , array ( 0 , 1 , 1 , 1 ) ) ; $ p = 2 ; $ q = 2 ; echo findPossibleMoves ( $ mat , $ p , $ q ) ; ? >"}
{"text":"Efficiently compute sums of diagonals of a matrix | A simple PHP program to find sum of diagonals ; Condition for principal diagonal ; Condition for secondary diagonal ; Driver code","code":"< ? php $ MAX = 100 ; function printDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ principal = 0 ; $ secondary = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) $ principal += $ mat [ $ i ] [ $ j ] ; if ( ( $ i + $ j ) == ( $ n - 1 ) ) $ secondary += $ mat [ $ i ] [ $ j ] ; } } echo \" Principal \u2581 Diagonal : \" , $ principal , \" STRNEWLINE \" ; echo \" Secondary \u2581 Diagonal : \" , $ secondary , \" STRNEWLINE \" ; } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; printDiagonalSums ( $ a , 4 ) ; ? >"}
{"text":"Efficiently compute sums of diagonals of a matrix | An efficient PHP program to find sum of diagonals ; Driver Code","code":"< ? php $ MAX = 100 ; function printDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ principal = 0 ; $ secondary = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ principal += $ mat [ $ i ] [ $ i ] ; $ secondary += $ mat [ $ i ] [ $ n - $ i - 1 ] ; } echo \" Principal \u2581 Diagonal : \" , $ principal , \" STRNEWLINE \" ; echo \" Secondary \u2581 Diagonal : \" , $ secondary , \" STRNEWLINE \" ; } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; printDiagonalSums ( $ a , 4 ) ; ? >"}
{"text":"Boundary elements of a Matrix | PHP program to print boundary element of matrix . ; Driver code","code":"< ? php $ MAX = 100 ; function printBoundary ( $ a , $ m , $ n ) { global $ MAX ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) echo $ a [ $ i ] [ $ j ] , \" \u2581 \" ; else if ( $ i == $ m - 1 ) echo $ a [ $ i ] [ $ j ] , \" \u2581 \" ; else if ( $ j == 0 ) echo $ a [ $ i ] [ $ j ] , \" \u2581 \" ; else if ( $ j == $ n - 1 ) echo $ a [ $ i ] [ $ j ] , \" \u2581 \" ; else echo \" \u2581 \" , \" \u2581 \" ; } echo \" STRNEWLINE \" ; } } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; printBoundary ( $ a , 4 , 4 ) ; ? >"}
{"text":"Boundary elements of a Matrix | PHP program to find sum of boundary elements of matrix . ; Driver code","code":"< ? php function getBoundarySum ( $ a , $ m , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ i == $ m - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == $ n - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; } } return $ sum ; } $ a = array ( array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) , array ( 1 , 2 , 3 , 4 ) , array ( 5 , 6 , 7 , 8 ) ) ; $ sum = getBoundarySum ( $ a , 4 , 4 ) ; echo \" Sum \u2581 of \u2581 boundary \u2581 elements \u2581 is \u2581 \" , $ sum ; ? >"}
{"text":"Print a matrix in a spiral form starting from a point | PHP program to print a matrix in spiral form . ; Driver code ; Function calling","code":"< ? php $ MAX = 100 ; function printSpiral ( $ mat , $ r , $ c ) { global $ MAX ; $ i ; $ a = 0 ; $ b = 2 ; $ low_row = ( 0 > $ a ) ? 0 : $ a ; $ low_column = ( 0 > $ b ) ? 0 : $ b - 1 ; $ high_row = ( ( $ a + 1 ) >= $ r ) ? $ r - 1 : $ a + 1 ; $ high_column = ( ( $ b + 1 ) >= $ c ) ? $ c - 1 : $ b + 1 ; while ( ( $ low_row > 0 - $ r && $ low_column > 0 - $ c ) ) { for ( $ i = $ low_column + 1 ; $ i <= $ high_column && $ i < $ c && $ low_row >= 0 ; ++ $ i ) echo $ mat [ $ low_row ] [ $ i ] , \" \u2581 \" ; $ low_row -= 1 ; for ( $ i = $ low_row + 2 ; $ i <= $ high_row && $ i < $ r && $ high_column < $ c ; ++ $ i ) echo $ mat [ $ i ] [ $ high_column ] , \" \u2581 \" ; $ high_column += 1 ; for ( $ i = $ high_column - 2 ; $ i >= $ low_column && $ i >= 0 && $ high_row < $ r ; -- $ i ) echo $ mat [ $ high_row ] [ $ i ] , \" \u2581 \" ; $ high_row += 1 ; for ( $ i = $ high_row - 2 ; $ i > $ low_row && $ i >= 0 && $ low_column >= 0 ; -- $ i ) echo $ mat [ $ i ] [ $ low_column ] , \" \u2581 \" ; $ low_column -= 1 ; } echo \" STRNEWLINE \" ; } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ r = 3 ; $ c = 3 ; printSpiral ( $ mat , $ r , $ c ) ; ? >"}
{"text":"Find difference between sums of two diagonals | PHP program to find the difference between the sum of diagonal . ; Initialize sums of diagonals ; finding sum of primary diagonal ; finding sum of secondary diagonal ; Absolute difference of the sums across the diagonals ; Driver Code","code":"< ? php function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) $ d1 += $ arr [ $ i ] [ $ j ] ; if ( $ i == $ n - $ j - 1 ) $ d2 += $ arr [ $ i ] [ $ j ] ; } } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text":"Find difference between sums of two diagonals | PHP program to find the difference between the sum of diagonal . ; Initialize sums of diagonals ; Absolute difference of the sums across the diagonals ; Driver Code","code":"< ? php function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ d1 += $ arr [ $ i ] [ $ i ] ; $ d2 += $ arr [ $ i ] [ $ n - $ i - 1 ] ; } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text":"Circular Matrix ( Construct a matrix with numbers 1 to m * n in spiral way ) | Fills a [ m ] [ n ] with values from 1 to m * n in spiral fashion . ; Initialize value to be filled in matrix ; k - starting row index m - ending row index l - starting column index n - ending column index ; Print the first row from the remaining rows ; Print the last column from the remaining columns ; Print the last row from the remaining rows ; Print the first column from the remaining columns ; Driver Code","code":"< ? php function spiralFill ( $ m , $ n , & $ a ) { $ val = 1 ; $ k = 0 ; $ l = 0 ; while ( $ k < $ m && $ l < $ n ) { for ( $ i = $ l ; $ i < $ n ; ++ $ i ) $ a [ $ k ] [ $ i ] = $ val ++ ; $ k ++ ; for ( $ i = $ k ; $ i < $ m ; ++ $ i ) $ a [ $ i ] [ $ n - 1 ] = $ val ++ ; $ n -- ; if ( $ k < $ m ) { for ( $ i = $ n - 1 ; $ i >= $ l ; -- $ i ) $ a [ $ m - 1 ] [ $ i ] = $ val ++ ; $ m -- ; } if ( $ l < $ n ) { for ( $ i = $ m - 1 ; $ i >= $ k ; -- $ i ) $ a [ $ i ] [ $ l ] = $ val ++ ; $ l ++ ; } } } $ m = 4 ; $ n = 4 ; spiralFill ( $ m , $ n , $ a ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo ( $ a [ $ i ] [ $ j ] ) ; echo ( \" \u2581 \" ) ; } echo ( \" STRNEWLINE \" ) ; } ? >"}
{"text":"Maximum and Minimum in a square matrix . | PHP program for finding maximum and minimum in a matrix . ; Finds maximum and minimum in arr [ 0. . n - 1 ] [ 0. . n - 1 ] using pair wise comparisons ; Traverses rows one by one ; Compare elements from beginning and end of current row ; Driver Code","code":"< ? php $ MAX = 100 ; function maxMin ( $ arr , $ n ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n \/ 2 ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] > $ arr [ $ i ] [ $ n - $ j - 1 ] ) { if ( $ min > $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ min = $ arr [ $ i ] [ $ n - $ j - 1 ] ; if ( $ max < $ arr [ $ i ] [ $ j ] ) $ max = $ arr [ $ i ] [ $ j ] ; } else { if ( $ min > $ arr [ $ i ] [ $ j ] ) $ min = $ arr [ $ i ] [ $ j ] ; if ( $ max < $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ max = $ arr [ $ i ] [ $ n - $ j - 1 ] ; } } } echo \" Maximum = \" \u2581 , \u2581 $ max STRNEWLINE TABSYMBOL TABSYMBOL , \" , Minimum = \" } $ arr = array ( array ( 5 , 9 , 11 ) , array ( 25 , 0 , 14 ) , array ( 21 , 6 , 4 ) ) ; maxMin ( $ arr , 3 ) ; ? >"}
{"text":"Minimum operations required to set all elements of binary matrix | PHP program to find minimum operations required to set all the element of binary matrix ; Return minimum operation required to make all 1 s . ; check if this cell equals 0 ; increase the number of moves ; flip from this cell to the start point ; flip the cell ; Driver Code","code":"< ? php $ N = 5 ; $ M = 5 ; function minOperation ( & $ arr ) { global $ N , $ M ; $ ans = 0 ; for ( $ i = $ N - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ M - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] [ $ j ] == 0 ) { $ ans ++ ; for ( $ k = 0 ; $ k <= $ i ; $ k ++ ) { for ( $ h = 0 ; $ h <= $ j ; $ h ++ ) { if ( $ arr [ $ k ] [ $ h ] == 1 ) $ arr [ $ k ] [ $ h ] = 0 ; else $ arr [ $ k ] [ $ h ] = 1 ; } } } } } return $ ans ; } $ mat = array ( array ( 0 , 0 , 1 , 1 , 1 ) , array ( 0 , 0 , 0 , 1 , 1 ) , array ( 0 , 0 , 0 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) ) ; echo minOperation ( $ mat ) ; ? >"}
{"text":"Sum of matrix element where each elements is integer division of row and column | Return sum of matrix element where each element is division of its corresponding row and column . ; For each column . ; count the number of elements of each column . Initialize to i - 1 because number of zeroes are i - 1. ; For multiply ; Driver Code","code":"< ? php function findSum ( $ n ) { $ ans = 0 ; $ temp = 0 ; $ num ; for ( $ i = 1 ; $ i <= $ n and $ temp < $ n ; $ i ++ ) { $ temp = $ i - 1 ; $ num = 1 ; while ( $ temp < $ n ) { if ( $ temp + $ i <= $ n ) $ ans += ( $ i * $ num ) ; else $ ans += ( ( $ n - $ temp ) * $ num ) ; $ temp += $ i ; $ num ++ ; } } return $ ans ; } $ N = 2 ; echo findSum ( $ N ) ; ? >"}
{"text":"Find number of transformation to make two Matrix Equal | PHP program to find number of countOpsation to make two matrix equals ; Update matrix A [ ] [ ] so that only A [ ] [ ] has to be countOpsed ; Check necessary condition for condition for existence of full countOpsation ; If countOpsation is possible calculate total countOpsation ; Driver code","code":"< ? php function countOps ( $ A , $ B , $ m , $ n ) { $ MAX = 1000 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ A [ $ i ] [ $ j ] -= $ B [ $ i ] [ $ j ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 1 ; $ j < $ m ; $ j ++ ) if ( $ A [ $ i ] [ $ j ] - $ A [ $ i ] [ 0 ] - $ A [ 0 ] [ $ j ] + $ A [ 0 ] [ 0 ] != 0 ) return -1 ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += abs ( $ A [ $ i ] [ 0 ] ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ result += abs ( $ A [ 0 ] [ $ j ] - $ A [ 0 ] [ 0 ] ) ; return ( $ result ) ; } $ A = array ( array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) ) ; $ B = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; echo countOps ( $ A , $ B , 3 , 3 ) ; ? >"}
{"text":"Form coils in a matrix | Print coils in a matrix of size 4 n x 4 n ; Number of elements in each coil ; Let us fill elements in coil 1. ; First element of coil1 4 * n * 2 * n + 2 * n ; ; Fill remaining m - 1 elements in coil1 [ ] ; Fill elements of current step from down to up ; Next element from current element ; Fill elements of current step from up to down . ; get coil2 from coil1 ; Print both coils ; Driver code","code":"< ? php function printCoils ( $ n ) { $ m = 8 * $ n * $ n ; $ coil1 = array ( ) ; $ coil1 [ 0 ] = 8 * $ n * $ n + 2 * $ n ; $ curr = $ coil1 [ 0 ] ; $ nflg = 1 ; $ step = 2 ; $ index = 1 ; while ( $ index < $ m ) { for ( $ i = 0 ; $ i < $ step ; $ i ++ ) { $ curr = $ coil1 [ $ index ++ ] = ( $ curr - 4 * $ n * $ nflg ) ; if ( $ index >= $ m ) break ; } if ( $ index >= $ m ) break ; for ( $ i = 0 ; $ i < $ step ; $ i ++ ) { $ curr = $ coil1 [ $ index ++ ] = $ curr + $ nflg ; if ( $ index >= $ m ) break ; } $ nflg = $ nflg * ( -1 ) ; $ step += 2 ; } $ coil2 = array ( ) ; for ( $ i = 0 ; $ i < 8 * $ n * $ n ; $ i ++ ) $ coil2 [ $ i ] = 16 * $ n * $ n + 1 - $ coil1 [ $ i ] ; echo \" Coil \u2581 1 \u2581 : \u2581 \" ; for ( $ i = 0 ; $ i < 8 * $ n * $ n ; $ i ++ ) echo $ coil1 [ $ i ] , \" \u2581 \" ; echo \" Coil 2 : \" ; for ( $ i = 0 ; $ i < 8 * $ n * $ n ; $ i ++ ) echo $ coil2 [ $ i ] , \" \u2581 \" ; } $ n = 1 ; printCoils ( $ n ) ; ? >"}
{"text":"Sum of matrix in which each element is absolute difference of its row and column numbers | Retuen the sum of matrix in which each element is absolute difference of its corresponding row and column number row ; Generate matrix ; Compute sum ; Driver Code","code":"< ? php function findSum ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = abs ( $ i - $ j ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ arr [ $ i ] [ $ j ] ; return $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text":"Sum of matrix in which each element is absolute difference of its row and column numbers | Return the sum of matrix in which each element is absolute difference of its corresponding row and column number row ; Driver Code","code":"< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ i * ( $ n - $ i ) ; return 2 * $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text":"Sum of matrix in which each element is absolute difference of its row and column numbers | Retuen the sum of matrix in which each element is absolute difference of its corresponding row and column number row ; Driver Code","code":"< ? php function findSum ( $ n ) { $ n -- ; $ sum = 0 ; $ sum += ( $ n * ( $ n + 1 ) ) \/ 2 ; $ sum += ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) \/ 6 ; return $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text":"Sum of both diagonals of a spiral odd | function returns sum of diagonals ; as order should be only odd we should pass only odd - integers ; Driver Code","code":"< ? php function spiralDiaSum ( $ n ) { if ( $ n == 1 ) return 1 ; return ( 4 * $ n * $ n - 6 * $ n + 6 + spiralDiaSum ( $ n - 2 ) ) ; } $ n = 7 ; echo spiralDiaSum ( $ n ) ; ? >"}
{"text":"Find perimeter of shapes formed with 1 s in binary matrix | PHP program to find perimeter of area covered by 1 in 2D matrix consisits of 0 ' s \u2581 and \u2581 1' s . ; Find the number of covered side for mat [ i ] [ j ] . ; UP ; LEFT ; DOWN ; RIGHT ; Returns sum of perimeter of shapes formed with 1 s ; Traversing the matrix and finding ones to calculate their contribution . ; Driver Code","code":"< ? php $ R = 3 ; $ C = 5 ; function numofneighbour ( $ mat , $ i , $ j ) { global $ R ; global $ C ; $ count = 0 ; if ( $ i > 0 && ( $ mat [ $ i - 1 ] [ $ j ] ) ) $ count ++ ; if ( $ j > 0 && ( $ mat [ $ i ] [ $ j - 1 ] ) ) $ count ++ ; if ( ( $ i < $ R - 1 ) && ( $ mat [ $ i + 1 ] [ $ j ] ) ) $ count ++ ; if ( ( $ j < $ C - 1 ) && ( $ mat [ $ i ] [ $ j + 1 ] ) ) $ count ++ ; return $ count ; } function findperimeter ( $ mat ) { global $ R ; global $ C ; $ perimeter = 0 ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) for ( $ j = 0 ; $ j < $ C ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ perimeter += ( 4 - numofneighbour ( $ mat , $ i , $ j ) ) ; return $ perimeter ; } $ mat = array ( array ( 0 , 1 , 0 , 0 , 0 ) , array ( 1 , 1 , 1 , 0 , 0 ) , array ( 1 , 0 , 0 , 0 , 0 ) ) ; echo findperimeter ( $ mat ) , \" STRNEWLINE \" ; ? >"}
{"text":"Print matrix in diagonal pattern | php program to print matrix in diagonal order ; Initialize indexes of element to be printed next ; Direction is initially from down to up ; Traverse the matrix till all elements get traversed ; If isUp = true then traverse from downward to upward ; Set i and j according to direction ; If isUp = 0 then traverse up to down ; Set i and j according to direction ; Revert the isUp to change the direction ; Driver code","code":"< ? php $ MAX = 100 ; function printMatrixDiagonal ( $ mat , $ n ) { $ i = 0 ; $ j = 0 ; $ isUp = true ; for ( $ k = 0 ; $ k < $ n * $ n { if ( $ isUp ) { for ( ; $ i >= 0 && $ j < $ n ; $ j ++ , $ i -- ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; $ k ++ ; } if ( $ i < 0 && $ j <= $ n - 1 ) $ i = 0 ; if ( $ j == $ n ) { $ i = $ i + 2 ; $ j -- ; } } else { for ( ; $ j >= 0 && $ i < $ n ; $ i ++ , $ j -- ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; $ k ++ ; } if ( $ j < 0 && $ i <= $ n - 1 ) $ j = 0 ; if ( $ i == $ n ) { $ j = $ j + 2 ; $ i -- ; } } $ isUp = ! $ isUp ; } } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ n = 3 ; printMatrixDiagonal ( $ mat , $ n ) ; ? >"}
{"text":"Maximum difference of sum of elements in two rows in a matrix | PHP program to find maximum difference of sum of elements of two rows ; Function to find maximum difference of sum of elements of two rows such that second row appears before first row . ; auxiliary array to store sum of all elements of each row ; calculate sum of each row and store it in rowSum array ; calculating maximum difference of two elements such that rowSum [ i ] < rowsum [ j ] ; if current difference is greater than previous then update it ; if new element is less than previous minimum element then update it so that we may get maximum difference in remaining array ; Driver Code","code":"< ? php $ MAX = 100 ; function maxRowDiff ( $ mat , $ m , $ n ) { global $ MAX ; $ rowSum = array ( ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ mat [ $ i ] [ $ j ] ; $ rowSum [ $ i ] = $ sum ; } $ max_diff = $ rowSum [ 1 ] - $ rowSum [ 0 ] ; $ min_element = $ rowSum [ 0 ] ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { if ( $ rowSum [ $ i ] - $ min_element > $ max_diff ) $ max_diff = $ rowSum [ $ i ] - $ min_element ; if ( $ rowSum [ $ i ] < $ min_element ) $ min_element = $ rowSum [ $ i ] ; } return $ max_diff ; } $ m = 5 ; $ n = 4 ; $ mat = array ( array ( -1 , 2 , 3 , 4 ) , array ( 5 , 3 , -2 , 1 ) , array ( 6 , 7 , 2 , -3 ) , array ( 2 , 9 , 1 , 4 ) , array ( 2 , 1 , -2 , 0 ) ) ; echo maxRowDiff ( $ mat , $ m , $ n ) ; ? >"}
{"text":"Count all sorted rows in a matrix | PHP program to find number of sorted rows ; Function to count all sorted rows in a matrix ; Initialize result ; Start from left side of matrix to count increasing order rows ; Check if there is any pair ofs element that are not in increasing order . ; If the loop didn 't break  (All elements of current row were in increasing order) ; Start from right side of matrix to count increasing order rows ( reference to left these are in decreasing order ) ; Check if there is any pair ofs element that are not in decreasing order . ; Note c > 1 condition is required to make sure that a single column row is not counted twice ( Note that a single column row is sorted both in increasing and decreasing order ) ; Driver Code","code":"< ? php $ MAX = 100 ; function sortedCount ( $ mat , $ r , $ c ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ c - 1 ; $ j ++ ) if ( $ mat [ $ i ] [ $ j + 1 ] <= $ mat [ $ i ] [ $ j ] ) break ; if ( $ j == $ c - 1 ) $ result ++ ; } for ( $ i = 0 ; $ i < $ r ; $ i ++ ) { $ j ; for ( $ j = $ c - 1 ; $ j > 0 ; $ j -- ) if ( $ mat [ $ i ] [ $ j - 1 ] <= $ mat [ $ i ] [ $ j ] ) break ; if ( $ c > 1 && $ j == 0 ) $ result ++ ; } return $ result ; } $ m = 4 ; $ n = 5 ; $ mat = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 4 , 3 , 1 , 2 , 6 ) , array ( 8 , 7 , 6 , 5 , 4 ) , array ( 5 , 7 , 8 , 9 , 10 ) ) ; echo sortedCount ( $ mat , $ m , $ n ) ; ? >"}
{"text":"Maximum XOR value in matrix | PHP program to Find maximum XOR value in matrix either row or column wise maximum number of row and column ; function return the maximum xor value that is either row or column wise ; for row xor and column xor ; traverse matrix ; xor row element ; for each column : j is act as row & i act as column xor column element ; update maximum between r_xor , c_xor ; return maximum xor value ; Driver Code","code":"< ? php $ MAX = 1000 ; function maxXOR ( $ mat , $ N ) { $ r_xor ; $ c_xor ; $ max_xor = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r_xor = 0 ; $ c_xor = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r_xor = $ r_xor ^ $ mat [ $ i ] [ $ j ] ; $ c_xor = $ c_xor ^ $ mat [ $ j ] [ $ i ] ; } if ( $ max_xor < max ( $ r_xor , $ c_xor ) ) $ max_xor = max ( $ r_xor , $ c_xor ) ; } return $ max_xor ; } $ N = 3 ; $ mat = array ( array ( 1 , 5 , 4 ) , array ( 3 , 7 , 2 ) , array ( 5 , 9 , 10 ) ) ; echo \" maximum \u2581 XOR \u2581 value \u2581 : \u2581 \" , maxXOR ( $ mat , $ N ) ; ? >"}
{"text":"Direction at last square block | Function which tells the Current direction ; Driver Code","code":"< ? php function direction ( $ R , $ C ) { if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 != 0 && $ R < $ C ) { echo \" Left \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 == 0 && $ R > $ C ) { echo \" Up \" , \" STRNEWLINE \" ; return ; } if ( $ R == $ C && $ R % 2 != 0 && $ C % 2 != 0 ) { echo \" Right \" , \" STRNEWLINE \" ; return ; } if ( $ R == $ C && $ R % 2 == 0 && $ C % 2 == 0 ) { echo \" Left \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 != 0 && $ R < $ C ) { echo \" Right \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 != 0 && $ R > $ C ) { echo \" Down \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 == 0 && $ R < $ C ) { echo \" Left \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 == 0 && $ R > $ C ) { echo \" Up \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 == 0 && $ C % 2 != 0 && $ R > $ C ) { echo \" Down \" , \" STRNEWLINE \" ; return ; } if ( $ R != $ C && $ R % 2 != 0 && $ C % 2 == 0 && $ R < $ C ) { echo \" Right \" , \" STRNEWLINE \" ; return ; } } $ R = 3 ; $ C = 1 ; direction ( $ R , $ C ) ; ? >"}
{"text":"Find if given matrix is Toeplitz or not | Function to check if all elements present in descending diagonal starting from position ( i , j ) in the matrix are all same or not ; mismatch found ; we only reach here when all elements in given diagonal are same ; Function to check whether given matrix is a Toeplitz matrix or not ; do for each element in first row ; check descending diagonal starting from position ( 0 , j ) in the matrix ; do for each element in first column ; check descending diagonal starting from position ( i , 0 ) in the matrix ; we only reach here when each descending diagonal from left to right is same ; Driver code ; Function call","code":"< ? php function checkDiagonal ( $ mat , $ i , $ j ) { $ N = 5 ; $ M = 4 ; $ res = $ mat [ $ i ] [ $ j ] ; while ( ++ $ i < $ N && ++ $ j < $ M ) { if ( $ mat [ $ i ] [ $ j ] != $ res ) return false ; } return true ; } function isToepliz ( $ mat ) { $ N = 5 ; $ M = 4 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { if ( ! checkDiagonal ( $ mat , 0 , $ i ) ) return false ; } for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { if ( ! checkDiagonal ( $ mat , $ i , 0 ) ) return false ; } return true ; } $ mat = array ( array ( 6 , 7 , 8 , 9 ) , array ( 4 , 6 , 7 , 8 ) , array ( 1 , 4 , 6 , 7 ) , array ( 0 , 1 , 4 , 6 ) , array ( 2 , 0 , 1 , 4 ) ) ; if ( isToepliz ( $ mat ) ) echo \" Matrix \u2581 is \u2581 a \u2581 Toepliz \u2581 \" ; else echo \" Matrix \u2581 is \u2581 not \u2581 a \u2581 Toepliz \u2581 \" ; ? >"}
{"text":"Count zeros in a row wise and column wise sorted matrix | PHP program to count number of 0 s in the given row - wise and column - wise sorted binary matrix . ; Function to count number of 0 s in the given row - wise and column - wise sorted binary matrix . ; start from bottom - left corner of the matrix ; stores number of zeroes in the matrix ; move up until you find a 0 ; if zero is not found in current column , we are done ; add 0 s present in current column to result ; move right to next column ; Driver Code","code":"< ? php $ N = 5 ; function countZeroes ( $ mat ) { $ row = $ N - 1 ; $ col = 0 ; $ count = 0 ; while ( $ col < $ N ) { while ( $ mat [ $ row ] [ $ col ] ) if ( -- $ row < 0 ) return $ count ; $ count += ( $ row + 1 ) ; $ col ++ ; } return $ count ; } $ mat = array ( array ( 0 , 0 , 0 , 0 , 1 ) , array ( 0 , 0 , 0 , 1 , 1 ) , array ( 0 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 ) ) ; echo countZeroes ( $ mat ) ; ? >"}
{"text":"Find size of the largest ' + ' formed by all ones in a binary matrix | size of binary square matrix ; Function to find the size of the largest ' + ' formed by all 1 's in given binary matrix ; left [ j ] [ j ] , right [ i ] [ j ] , top [ i ] [ j ] and bottom [ i ] [ j ] store maximum number of consecutive 1 's present to the left,  right, top and bottom of mat[i][j]  including cell(i, j) respectively ; initialize above four matrix ; initialize first row of top ; initialize last row of bottom ; initialize first column of left ; initialize last column of right ; fill all cells of above four matrix ; calculate left matrix ( filled left to right ) ; calculate top matrix ; calculate new value of j to calculate value of bottom ( i , j ) and right ( i , j ) ; calculate bottom matrix ; calculate right matrix ; revert back to old j ; n stores length of longest + found so far ; compute longest + ; find minimum of left ( i , j ) , right ( i , j ) , top ( i , j ) , bottom ( i , j ) ; largest + would be formed by a cell that has maximum value ; 4 directions of length n - 1 and 1 for middle cell ; matrix contains all 0 's ; Driver Code","code":"< ? php $ N = 10 ; function findLargestPlus ( $ mat ) { global $ N ; $ left [ $ N ] [ $ N ] = array ( ) ; $ right [ $ N ] [ $ N ] = array ( ) ; $ top [ $ N ] [ $ N ] = array ( ) ; $ bottom [ $ N ] [ $ N ] = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ top [ 0 ] [ $ i ] = $ mat [ 0 ] [ $ i ] ; $ bottom [ $ N - 1 ] [ $ i ] = $ mat [ $ N - 1 ] [ $ i ] ; $ left [ $ i ] [ 0 ] = $ mat [ $ i ] [ 0 ] ; $ right [ $ i ] [ $ N - 1 ] = $ mat [ $ i ] [ $ N - 1 ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ N ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) $ left [ $ i ] [ $ j ] = $ left [ $ i ] [ $ j - 1 ] + 1 ; else $ left [ $ i ] [ $ j ] = 0 ; if ( $ mat [ $ j ] [ $ i ] == 1 ) $ top [ $ j ] [ $ i ] = $ top [ $ j - 1 ] [ $ i ] + 1 ; else $ top [ $ j ] [ $ i ] = 0 ; $ j = $ N - 1 - $ j ; if ( $ mat [ $ j ] [ $ i ] == 1 ) $ bottom [ $ j ] [ $ i ] = $ bottom [ $ j + 1 ] [ $ i ] + 1 ; else $ bottom [ $ j ] [ $ i ] = 0 ; if ( $ mat [ $ i ] [ $ j ] == 1 ) $ right [ $ i ] [ $ j ] = $ right [ $ i ] [ $ j + 1 ] + 1 ; else $ right [ $ i ] [ $ j ] = 0 ; $ j = $ N - 1 - $ j ; } } $ n = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ len = min ( min ( $ top [ $ i ] [ $ j ] , $ bottom [ $ i ] [ $ j ] ) , min ( $ left [ $ i ] [ $ j ] , $ right [ $ i ] [ $ j ] ) ) ; if ( $ len > $ n ) $ n = $ len ; } } if ( $ n ) return 4 * ( $ n - 1 ) + 1 ; return 0 ; } $ mat = array ( array ( 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ) , array ( 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 ) , array ( 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 ) , array ( 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ) , array ( 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ) , array ( 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ) , array ( 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 ) , array ( 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 ) , array ( 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ) , array ( 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ) ) ; echo findLargestPlus ( $ mat ) ; ? >"}
{"text":"Return previous element in an expanding matrix | Returns left of str in an expanding matrix of a , b , c and d . ; Start from rightmost position ; If the current character is b or d , change to a or c respectively and break the loop ; If the current character is a or c , change it to b or d respectively ; Driver Code","code":"< ? php function findLeft ( $ str ) { $ n = strlen ( $ str ) ; while ( $ n -- ) { if ( $ str [ $ n ] == ' d ' ) { $ str [ $ n ] = ' c ' ; break ; } if ( $ str [ $ n ] == ' b ' ) { $ str [ $ n ] = ' a ' ; break ; } if ( $ str [ $ n ] == ' a ' ) $ str [ $ n ] = ' b ' ; else if ( $ str [ $ n ] == ' c ' ) $ str [ $ n ] = ' d ' ; } return $ str ; } $ str = \" aacbddc \" ; echo \" Left \u2581 of \u2581 \" . $ str . \" \u2581 is \u2581 \" . findLeft ( $ str ) ; return 0 ; ? >"}
{"text":"Print n x n spiral matrix using O ( 1 ) extra space | Prints spiral matrix of size n x n containing numbers from 1 to n x n ; x stores the layer in which ( i , j ) th element lies ; Finds minimum of four inputs ; For upper right half ; for lower left half ; Driver code ; print a n x n spiral matrix in O ( 1 ) space","code":"< ? php function printSpiral ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ x ; $ x = min ( min ( $ i , $ j ) , min ( $ n - 1 - $ i , $ n - 1 - $ j ) ) ; if ( $ i <= $ j ) echo \" TABSYMBOL \u2581 \" , ( $ n - 2 * $ x ) * ( $ n - 2 * $ x ) - ( $ i - $ x ) - ( $ j - $ x ) ; else echo \" TABSYMBOL \u2581 \" , ( $ n - 2 * $ x - 2 ) * ( $ n - 2 * $ x - 2 ) + ( $ i - $ x ) + ( $ j - $ x ) ; } echo \" STRNEWLINE \" ; } } $ n = 5 ; printSpiral ( $ n ) ; ? >"}
{"text":"A Boolean Matrix Question | PHP Code For A Boolean Matrix Question ; Initialize all values of row [ ] as 0 ; Initialize all values of col [ ] as 0 ; Store the rows and columns to be marked as 1 in row [ ] and col [ ] arrays respectively ; Modify the input matrix mat [ ] using the above constructed row [ ] and col [ ] arrays ; A utility function to print a 2D matrix ; Driver code","code":"< ? php $ R = 3 ; $ C = 4 ; function modifyMatrix ( & $ mat ) { global $ R , $ C ; $ row = array ( ) ; $ col = array ( ) ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { $ row [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ C ; $ i ++ ) { $ col [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) { $ row [ $ i ] = 1 ; $ col [ $ j ] = 1 ; } } } for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ row [ $ i ] == 1 $ col [ $ j ] == 1 ) { $ mat [ $ i ] [ $ j ] = 1 ; } } } } function printMatrix ( & $ mat ) { global $ R , $ C ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; } echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 1 , 0 , 0 , 1 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 0 , 0 , 0 ) ) ; echo \" Input \u2581 Matrix \u2581 STRNEWLINE \" ; printMatrix ( $ mat ) ; modifyMatrix ( $ mat ) ; echo \" Matrix \u2581 after \u2581 modification \u2581 STRNEWLINE \" ; printMatrix ( $ mat ) ; ? >"}
{"text":"A Boolean Matrix Question | PHP Code For A Boolean Matrix Question ; variables to check if there are any 1 in first row and column ; updating the first row and col if 1 is encountered ; Modify the input matrix mat [ ] using the first row and first column of Matrix mat ; modify first row if there was any 1 ; modify first col if there was any 1 ; A utility function to print a 2D matrix ; Driver Code","code":"< ? php $ R = 3 ; $ C = 4 ; function modifyMatrix ( & $ mat ) { global $ R , $ C ; $ row_flag = false ; $ col_flag = false ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ i == 0 && $ mat [ $ i ] [ $ j ] == 1 ) $ row_flag = true ; if ( $ j == 0 && $ mat [ $ i ] [ $ j ] == 1 ) $ col_flag = true ; if ( $ mat [ $ i ] [ $ j ] == 1 ) { $ mat [ 0 ] [ $ j ] = 1 ; $ mat [ $ i ] [ 0 ] = 1 ; } } } for ( $ i = 1 ; $ i < $ R ; $ i ++ ) { for ( $ j = 1 ; $ j < $ C ; $ j ++ ) { if ( $ mat [ 0 ] [ $ j ] == 1 $ mat [ $ i ] [ 0 ] == 1 ) { $ mat [ $ i ] [ $ j ] = 1 ; } } } if ( $ row_flag == true ) { for ( $ i = 0 ; $ i < $ C ; $ i ++ ) { $ mat [ 0 ] [ $ i ] = 1 ; } } if ( $ col_flag == true ) { for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { $ mat [ $ i ] [ 0 ] = 1 ; } } } function printMatrix ( & $ mat ) { global $ R , $ C ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { echo $ mat [ $ i ] [ $ j ] . \" \" ; } echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 1 , 0 , 0 , 1 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 0 , 0 , 0 ) ) ; echo \" Input \u2581 Matrix \u2581 : STRNEWLINE \" ; printMatrix ( $ mat ) ; modifyMatrix ( $ mat ) ; echo \" Matrix \u2581 After \u2581 Modification \u2581 : STRNEWLINE \" ; printMatrix ( $ mat ) ; ? >"}
{"text":"Given a Boolean Matrix , find k such that all elements in k ' th \u2581 row \u2581 are \u2581 0 \u2581 and \u2581 k ' th column are 1. | PHP program to find i such that all entries in i ' th \u2581 row \u2581 are \u2581 0 \u2581 and \u2581 all \u2581 entries \u2581 in \u2581 i ' th column are 1 ; Start from top - most rightmost corner ( We could start from other corners also ) ; Initialize result ; Find the index ( This loop runs at most 2 n times , we either increment row number or decrement column number ) ; If current element is 0 , then this row may be a solution ; Check for all elements in this row ; If all values are 0 , then store this row as result ; We reach here if we found a 1 in current row , so this row cannot be a solution , increment row number ; If current element is 1 ; Check for all elements in this column ; If all elements are 1 ; We reach here if we found a 0 in current column , so this column cannot be a solution , increment column number ; If we could not find result in above loop , then result doesn 't exist ; Check if above computed res is valid ; Driver Code","code":"< ? php function find ( & $ arr ) { $ n = 5 ; $ i = 0 ; $ j = $ n - 1 ; $ res = -1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ arr [ $ i ] [ $ j ] == 0 ) { while ( $ j >= 0 && ( $ arr [ $ i ] [ $ j ] == 0 $ i == $ j ) ) $ j -- ; if ( $ j == -1 ) { $ res = $ i ; break ; } else $ i ++ ; } else { while ( $ i < $ n && ( $ arr [ $ i ] [ $ j ] == 1 $ i == $ j ) ) $ i ++ ; if ( $ i == $ n ) { $ res = $ j ; break ; } else $ j -- ; } } if ( $ res == -1 ) return $ res ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ res != $ i && $ arr [ $ i ] [ $ res ] != 1 ) return -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ res != $ j && $ arr [ $ res ] [ $ j ] != 0 ) return -1 ; return $ res ; } $ mat = array ( array ( 0 , 0 , 1 , 1 , 0 ) , array ( 0 , 0 , 0 , 1 , 0 ) , array ( 1 , 1 , 1 , 1 , 0 ) , array ( 0 , 0 , 0 , 0 , 0 ) , array ( 1 , 1 , 1 , 1 , 1 ) ) ; echo ( find ( $ mat ) ) ; ? >"}
{"text":"Submatrix Sum Queries | Function to preprcess input mat [ M ] [ N ] . This function mainly fills aux [ M ] [ N ] such that aux [ i ] [ j ] stores sum of elements from ( 0 , 0 ) to ( i , j ) ; Copy first row of mat [ ] [ ] to aux [ ] [ ] ; Do column wise sum ; Do row wise sum ; A O ( 1 ) time function to compute sum of submatrix between ( tli , tlj ) and ( rbi , rbj ) using aux [ ] [ ] which is built by the preprocess function ; result is now sum of elements between ( 0 , 0 ) and ( rbi , rbj ) ; Remove elements between ( 0 , 0 ) and ( tli - 1 , rbj ) ; Remove elements between ( 0 , 0 ) and ( rbi , tlj - 1 ) ; Add aux [ tli - 1 ] [ tlj - 1 ] as elements between ( 0 , 0 ) and ( tli - 1 , tlj - 1 ) are subtracted twice ; Driver Code","code":"< ? php function preProcess ( & $ mat , & $ aux ) { $ M = 4 ; $ N = 5 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ aux [ 0 ] [ $ i ] = $ mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ M ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ aux [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ aux [ $ i - 1 ] [ $ j ] ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) for ( $ j = 1 ; $ j < $ N ; $ j ++ ) $ aux [ $ i ] [ $ j ] += $ aux [ $ i ] [ $ j - 1 ] ; } function sumQuery ( & $ aux , $ tli , $ tlj , $ rbi , $ rbj ) { $ res = $ aux [ $ rbi ] [ $ rbj ] ; if ( $ tli > 0 ) $ res = $ res - $ aux [ $ tli - 1 ] [ $ rbj ] ; if ( $ tlj > 0 ) $ res = $ res - $ aux [ $ rbi ] [ $ tlj - 1 ] ; if ( $ tli > 0 && $ tlj > 0 ) $ res = $ res + $ aux [ $ tli - 1 ] [ $ tlj - 1 ] ; return $ res ; } $ mat = array ( array ( 1 , 2 , 3 , 4 , 6 ) , array ( 5 , 3 , 8 , 1 , 2 ) , array ( 4 , 6 , 7 , 5 , 5 ) , array ( 2 , 4 , 8 , 9 , 4 ) ) ; preProcess ( $ mat , $ aux ) ; $ tli = 2 ; $ tlj = 2 ; $ rbi = 3 ; $ rbj = 4 ; echo ( \" Query1 : \u2581 \" ) ; echo ( sumQuery ( $ aux , $ tli , $ tlj , $ rbi , $ rbj ) ) ; $ tli = 0 ; $ tlj = 0 ; $ rbi = 1 ; $ rbj = 1 ; echo ( \" Query2 : \" echo ( sumQuery ( $ aux , $ tli , $ tlj , $ rbi , $ rbj ) ) ; $ tli = 1 ; $ tlj = 2 ; $ rbi = 3 ; $ rbj = 3 ; echo ( \" Query3 : \" echo ( sumQuery ( $ aux , $ tli , $ tlj , $ rbi , $ rbj ) ) ; ? >"}
{"text":"Program for Rank of Matrix | PHP program to find rank of a matrix ; function for exchanging two rows of a matrix ; function for finding rank of matrix ; Before we visit current row ' row ' , we make sure that mat [ row ] [ 0 ] , ... . mat [ row ] [ row - 1 ] are 0. Diagonal element is not zero ; This makes all entries of current column as 0 except entry ' mat [ row ] [ row ] ' ; Diagonal element is already zero . Two cases arise : 1 ) If there is a row below it with non - zero entry , then swap this row with that row and process that row 2 ) If all elements in current column below mat [ r ] [ row ] are 0 , then remvoe this column by swapping it with last column and reducing number of columns by 1. ; Find the non - zero element in current column ; Swap the row with non - zero element with this row . ; If we did not find any row with non - zero element in current columnm , then all values in this column are 0. ; Reduce number of columns ; Copy the last column here ; Process this row again ; Uncomment these lines to see intermediate results display ( mat , R , C ) ; printf ( \" \\n \" ) ; ; function for displaying the matrix ; Driver code","code":"< ? php $ R = 3 ; $ C = 3 ; function swap ( & $ mat , $ row1 , $ row2 , $ col ) { for ( $ i = 0 ; $ i < $ col ; $ i ++ ) { $ temp = $ mat [ $ row1 ] [ $ i ] ; $ mat [ $ row1 ] [ $ i ] = $ mat [ $ row2 ] [ $ i ] ; $ mat [ $ row2 ] [ $ i ] = $ temp ; } } function rankOfMatrix ( $ mat ) { global $ R , $ C ; $ rank = $ C ; for ( $ row = 0 ; $ row < $ rank ; $ row ++ ) { if ( $ mat [ $ row ] [ $ row ] ) { for ( $ col = 0 ; $ col < $ R ; $ col ++ ) { if ( $ col != $ row ) { $ mult = $ mat [ $ col ] [ $ row ] \/ $ mat [ $ row ] [ $ row ] ; for ( $ i = 0 ; $ i < $ rank ; $ i ++ ) $ mat [ $ col ] [ $ i ] -= $ mult * $ mat [ $ row ] [ $ i ] ; } } } else { $ reduce = true ; for ( $ i = $ row + 1 ; $ i < $ R ; $ i ++ ) { if ( $ mat [ $ i ] [ $ row ] ) { swap ( $ mat , $ row , $ i , $ rank ) ; $ reduce = false ; break ; } } if ( $ reduce ) { $ rank -- ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) $ mat [ $ i ] [ $ row ] = $ mat [ $ i ] [ $ rank ] ; } $ row -- ; } } return $ rank ; } function display ( $ mat , $ row , $ col ) { for ( $ i = 0 ; $ i < $ row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ col ; $ j ++ ) print ( \" \u2581 $ mat [ $ i ] [ $ j ] \" ) ; print ( \" STRNEWLINE \" ) ; } } $ mat = array ( array ( 10 , 20 , 10 ) , array ( -20 , -30 , 10 ) , array ( 30 , 50 , 0 ) ) ; print ( \" Rank \u2581 of \u2581 the \u2581 matrix \u2581 is \u2581 : \u2581 \" . rankOfMatrix ( $ mat ) ) ; ? >"}
{"text":"Count number of islands where every island is row | This function takes a matrix of ' X ' and ' O ' and returns the number of rectangular islands of ' X ' where no two islands are row - wise or column - wise adjacent , the islands may be diagonaly adjacent ; Initialize result ; Traverse the input matrix ; If current cell is ' X ' , then check whether this is top - leftmost of a rectangle . If yes , then increment count ; Driver Code","code":"< ? php function countIslands ( $ mat ) { $ M = 6 ; $ N = 3 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == ' X ' ) { if ( ( $ i == 0 $ mat [ $ i - 1 ] [ $ j ] == ' O ' ) && ( $ j == 0 $ mat [ $ i ] [ $ j - 1 ] == ' O ' ) ) $ count ++ ; } } } return $ count ; } $ mat = array ( array ( ' O ' , ' O ' , ' O ' ) , array ( ' X ' , ' X ' , ' O ' ) , array ( ' X ' , ' X ' , ' O ' ) , array ( ' O ' , ' O ' , ' X ' ) , array ( ' O ' , ' O ' , ' X ' ) , array ( ' X ' , ' X ' , ' O ' ) ) ; echo \" Number \u2581 of \u2581 rectangular \u2581 islands \u2581 is \u2581 \" , countIslands ( $ mat ) ; ? >"}
{"text":"Given a matrix of \u2018 O \u2019 and \u2018 X \u2019 , replace ' O ' with ' X ' if surrounded by ' X ' | Size of given matrix is M X N ; A recursive function to replace previous value ' prevV ' at ' ( x , \u2581 y ) ' and all surrounding values of ( x , y ) with new value ' newV ' . ; Base cases ; Replace the color at ( x , y ) ; Recur for north , east , south and west ; Returns size of maximum size subsquare matrix surrounded by ' X ' ; Step 1 : Replace all ' O ' with ' - ' ; Call floodFill for all ' - ' lying on edges ; Right side ; Top side ; Bottom side ; Step 3 : Replace all ' - ' with ' X ' ; Driver Code","code":"< ? php $ M = 6 ; $ N = 6 ; function floodFillUtil ( & $ mat , $ x , $ y , $ prevV , $ newV ) { if ( $ x < 0 $ x >= $ GLOBALS [ ' M ' ] $ y < 0 $ y >= $ GLOBALS [ ' N ' ] ) return ; if ( $ mat [ $ x ] [ $ y ] != $ prevV ) return ; $ mat [ $ x ] [ $ y ] = $ newV ; floodFillUtil ( $ mat , $ x + 1 , $ y , $ prevV , $ newV ) ; floodFillUtil ( $ mat , $ x - 1 , $ y , $ prevV , $ newV ) ; floodFillUtil ( $ mat , $ x , $ y + 1 , $ prevV , $ newV ) ; floodFillUtil ( $ mat , $ x , $ y - 1 , $ prevV , $ newV ) ; } function replaceSurrounded ( & $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] == ' O ' ) $ mat [ $ i ] [ $ j ] = ' - ' ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) if ( $ mat [ $ i ] [ 0 ] == ' - ' ) floodFillUtil ( $ mat , $ i , 0 , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) if ( $ mat [ $ i ] [ $ GLOBALS [ ' N ' ] - 1 ] == ' - ' ) floodFillUtil ( $ mat , $ i , $ GLOBALS [ ' N ' ] - 1 , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) if ( $ mat [ 0 ] [ $ i ] == ' - ' ) floodFillUtil ( $ mat , 0 , $ i , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) if ( $ mat [ $ GLOBALS [ ' M ' ] - 1 ] [ $ i ] == ' - ' ) floodFillUtil ( $ mat , $ GLOBALS [ ' M ' ] - 1 , $ i , ' - ' , ' O ' ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] == ' - ' ) $ mat [ $ i ] [ $ j ] = ' X ' ; } $ mat = array ( array ( ' X ' , ' O ' , ' X ' , ' O ' , ' X ' , ' X ' ) , array ( ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' ) , array ( ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' X ' ) , array ( ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' ) , array ( ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' ) , array ( ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' ) ) ; replaceSurrounded ( $ mat ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' M ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) echo $ mat [ $ i ] [ $ j ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } ? >"}
{"text":"Find length of the longest consecutive path from a given starting character | PHP program to find the longest consecutive path ; tool matrices to recur for adjacent cells . ; dp [ i ] [ j ] Stores length of longest consecutive path starting at arr [ i ] [ j ] . ; check whether mat [ i ] [ j ] is a valid cell or not . ; Check whether current character is adjacent to previous character ( character processed in parent call ) or not . ; i , j are the indices of the current cell and prev is the character processed in the parent call . . also mat [ i ] [ j ] is our current character . ; If this cell is not valid or current character is not adjacent to previous one ( e . g . d is not adjacent to b ) or if this cell is already included in the path than return 0. ; If this subproblem is already solved , return the answer ; Initialize answer ; recur for paths with different adjacent cells and store the length of longest path . ; save the answer and return ; Returns length of the longest path with all characters consecutive to each other . This function first initializes dp array that is used to store results of subproblems , then it calls recursive DFS based function getLenUtil ( ) to find max length path ; check for each possible starting point ; recur for all eight adjacent cells ; Driver code","code":"< ? php $ R = 3 ; $ C = 3 ; $ x = array ( 0 , 1 , 1 , -1 , 1 , 0 , -1 , -1 ) ; $ y = array ( 1 , 0 , 1 , 1 , -1 , -1 , 0 , -1 ) ; $ dp = array_fill ( 0 , $ R , array_fill ( 0 , $ C , -1 ) ) ; function isvalid ( $ i , $ j ) { global $ R , $ C ; if ( $ i < 0 $ j < 0 $ i >= $ R $ j >= $ C ) return false ; return true ; } function isadjacent ( $ prev , $ curr ) { return ( ( ord ( $ curr ) - ord ( $ prev ) ) == 1 ) ; } function getLenUtil ( $ mat , $ i , $ j , $ prev ) { global $ x , $ y , $ dp ; if ( ! isvalid ( $ i , $ j ) || ! isadjacent ( $ prev , $ mat [ $ i ] [ $ j ] ) ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; $ ans = 0 ; for ( $ k = 0 ; $ k < 8 ; $ k ++ ) $ ans = max ( $ ans , 1 + getLenUtil ( $ mat , $ i + $ x [ $ k ] , $ j + $ y [ $ k ] , $ mat [ $ i ] [ $ j ] ) ) ; $ dp [ $ i ] [ $ j ] = $ ans ; return $ ans ; } function getLen ( $ mat , $ s ) { global $ R , $ C , $ x , $ y ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == $ s ) { for ( $ k = 0 ; $ k < 8 ; $ k ++ ) $ ans = max ( $ ans , 1 + getLenUtil ( $ mat , $ i + $ x [ $ k ] , $ j + $ y [ $ k ] , $ s ) ) ; } } } return $ ans ; } $ mat = array ( array ( ' a ' , ' c ' , ' d ' ) , array ( ' h ' , ' b ' , ' a ' ) , array ( ' i ' , ' g ' , ' f ' ) ) ; print ( getLen ( $ mat , ' a ' ) . \" \" ) ; print ( getLen ( $ mat , ' e ' ) . \" \" ) ; print ( getLen ( $ mat , ' b ' ) . \" \" ) ; print ( getLen ( $ mat , ' f ' ) . \" \" ) ; ? >"}
{"text":"Minimum Initial Points to Reach Destination | PHP program to find minimum initial points to reach destination ; dp [ i ] [ j ] represents the minimum initial points player should have so that when starts with cell ( i , j ) successfully reaches the destination cell ( m - 1 , n - 1 ) ; Base case ; Fill last row and last column as base to fill entire table ; fill the table in bottom - up fashion ; Driver Code","code":"< ? php $ R = 3 ; $ C = 3 ; function minInitialPoints ( $ points ) { global $ R ; global $ C ; $ dp [ $ R ] [ $ C ] = array ( ) ; $ m = $ R ; $ n = $ C ; $ dp [ $ m - 1 ] [ $ n - 1 ] = $ points [ $ m - 1 ] [ $ n - 1 ] > 0 ? 1 : abs ( $ points [ $ m - 1 ] [ $ n - 1 ] ) + 1 ; for ( $ i = $ m - 2 ; $ i >= 0 ; $ i -- ) $ dp [ $ i ] [ $ n - 1 ] = max ( $ dp [ $ i + 1 ] [ $ n - 1 ] - $ points [ $ i ] [ $ n - 1 ] , 1 ) ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ dp [ $ m - 1 ] [ $ j ] = max ( $ dp [ $ m - 1 ] [ $ j + 1 ] - $ points [ $ m - 1 ] [ $ j ] , 1 ) ; for ( $ i = $ m - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) { $ min_points_on_exit = min ( $ dp [ $ i + 1 ] [ $ j ] , $ dp [ $ i ] [ $ j + 1 ] ) ; $ dp [ $ i ] [ $ j ] = max ( $ min_points_on_exit - $ points [ $ i ] [ $ j ] , 1 ) ; } } return $ dp [ 0 ] [ 0 ] ; } $ points = array ( array ( -2 , -3 , 3 ) , array ( -5 , -10 , 1 ) , array ( 10 , 30 , -5 ) ) ; echo \" Minimum \u2581 Initial \u2581 Points \u2581 Required : \u2581 \" , minInitialPoints ( $ points ) ; ? >"}
{"text":"Find a peak element | A binary search based function that returns index of a peak element ; Find index of middle element ( low + high ) \/ 2 ; Compare middle element with its neighbours ( if neighbours exist ) ; If middle element is not peak and its left neighbour is greater than it , then left half must have a peak element ; If middle element is not peak and its right neighbour is greater than it , then right half must have a peak element ; A wrapper over recursive function findPeakUtil ( ) ; Driver Code","code":"< ? php function findPeakUtil ( $ arr , $ low , $ high , $ n ) { $ mid = $ low + ( $ high - $ low ) \/ 2 ; if ( ( $ mid == 0 $ arr [ $ mid - 1 ] <= $ arr [ $ mid ] ) && ( $ mid == $ n - 1 $ arr [ $ mid + 1 ] <= $ arr [ $ mid ] ) ) return $ mid ; else if ( $ mid > 0 && $ arr [ $ mid - 1 ] > $ arr [ $ mid ] ) return findPeakUtil ( $ arr , $ low , ( $ mid - 1 ) , $ n ) ; else return ( findPeakUtil ( $ arr , ( $ mid + 1 ) , $ high , $ n ) ) ; } function findPeak ( $ arr , $ n ) { return floor ( findPeakUtil ( $ arr , 0 , $ n - 1 , $ n ) ) ; } $ arr = array ( 1 , 3 , 20 , 4 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; echo \" Index \u2581 of \u2581 a \u2581 peak \u2581 point \u2581 is \u2581 \" , findPeak ( $ arr , $ n ) ; ? >"}
{"text":"Find the two repeating elements in a given array | Print Repeating function ; Driver Code","code":"< ? php function printRepeating ( $ arr , $ size ) { $ i ; $ j ; echo \" \u2581 Repeating \u2581 elements \u2581 are \u2581 \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = sizeof ( $ arr , 0 ) ; printRepeating ( $ arr , $ arr_size ) ; ? >"}
{"text":"Find the two repeating elements in a given array | Function ; Driver code","code":"< ? php function printRepeating ( $ arr , $ size ) { $ count = array_fill ( 0 , $ size , 0 ) ; echo \" Repeated \u2581 elements \u2581 are \u2581 \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ count [ $ arr [ $ i ] ] == 1 ) echo $ arr [ $ i ] . \" \u2581 \" ; else $ count [ $ arr [ $ i ] ] ++ ; } } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = count ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ; ? >"}
{"text":"Find the two repeating elements in a given array | printRepeating function ; S is for sum of elements in arr [ ] ; P is for product of elements in arr [ ] ; x and y are two repeating elements ; D is for difference of x and y , i . e . , x - y ; Calculate Sum and Product of all elements in arr [ ] ; S is x + y now ; P is x * y now ; D is x - y now ; factorial of n ; driver code","code":"< ? php function printRepeating ( $ arr , $ size ) { $ S = 0 ; $ P = 1 ; $ x ; $ y ; $ D ; $ n = $ size - 2 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ S = $ S + $ arr [ $ i ] ; $ P = $ P * $ arr [ $ i ] ; } $ S = $ S - $ n * ( $ n + 1 ) \/ 2 ; $ P = $ P \/ fact ( $ n ) ; $ D = sqrt ( $ S * $ S - 4 * $ P ) ; $ x = ( $ D + $ S ) \/ 2 ; $ y = ( $ S - $ D ) \/ 2 ; echo \" The \u2581 two \u2581 Repeating \u2581 elements \u2581 are \u2581 \" . $ x . \" & \" } function fact ( $ n ) { return ( $ n == 0 ) ? 1 : $ n * fact ( $ n - 1 ) ; } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = count ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ; ? >"}
{"text":"Find the two repeating elements in a given array | PHP code to Find the two repeating elements in a given array ; Will hold xor of all elements ; Will have only single set bit of xor ; Get the xor of all elements in arr [ ] and { 1 , 2 . . n } ; Get the rightmost set bit in set_bit_no ; Now divide elements in two sets by comparing rightmost set bit of xor with bit at same position in each element . ; XOR of first set in arr [ ] ; XOR of second set in arr [ ] ; XOR of first set in arr [ ] and { 1 , 2 , ... n } ; XOR of second set in arr [ ] and { 1 , 2 , ... n } ; driver code","code":"< ? php function printRepeating ( $ arr , $ size ) { $ xor = $ arr [ 0 ] ; $ set_bit_no ; $ i ; $ n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor ^= $ arr [ $ i ] ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ xor ^= $ i ; $ set_bit_no = $ xor & ~ ( $ xor - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i & $ set_bit_no ) $ x = $ x ^ $ i ; else $ y = $ y ^ $ i ; } echo \" n \u2581 The \u2581 two \u2581 repeating \u2581 elements \u2581 are \u2581 \" ; echo $ y . \" \u2581 \" . $ x ; } ? > $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = count ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ;"}
{"text":"Find the two repeating elements in a given array | Function to print repeating ; Driver code","code":"< ? php function printRepeating ( $ arr , $ size ) { $ i ; echo \" The \u2581 repeating \u2581 elements \u2581 are \" , \" \u2581 \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) ] = - $ arr [ abs ( $ arr [ $ i ] ) ] ; else echo abs ( $ arr [ $ i ] ) , \" \u2581 \" ; } } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; printRepeating ( $ arr , $ arr_size ) ; #This  code is contributed by aj_36 NEW_LINE ? >"}
{"text":"Find subarray with given sum | Set 1 ( Nonnegative Numbers ) | Returns true if the there is a subarray of arr [ ] with sum equal to ' sum ' otherwise returns false . Also , prints the result ; Pick a starting point ; try all subarrays starting with ' i ' ; Driver Code","code":"< ? php function subArraySum ( $ arr , $ n , $ sum ) { $ curr_sum ; $ i ; $ j ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = $ arr [ $ i ] ; for ( $ j = $ i + 1 ; $ j <= $ n ; $ j ++ ) { if ( $ curr_sum == $ sum ) { echo \" Sum \u2581 found \u2581 between \u2581 indexes \u2581 \" , $ i , \" \u2581 and \u2581 \" , $ j - 1 ; return 1 ; } if ( $ curr_sum > $ sum $ j == $ n ) break ; $ curr_sum = $ curr_sum + $ arr [ $ j ] ; } } echo \" No \u2581 subarray \u2581 found \" ; return 0 ; } $ arr = array ( 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ) ; $ n = sizeof ( $ arr ) ; $ sum = 23 ; subArraySum ( $ arr , $ n , $ sum ) ; return 0 ; ? >"}
{"text":"Find subarray with given sum | Set 1 ( Nonnegative Numbers ) | Returns true if the there is a subarray of arr [ ] with sum equal to ' sum ' otherwise returns false . Also , prints the result ; Initialize curr_sum as value of first element and starting point as 0 ; Add elements one by one to curr_sum and if the curr_sum exceeds the sum , then remove starting element ; If curr_sum exceeds the sum , then remove the starting elements ; If curr_sum becomes equal to sum , then return true ; Add this element to curr_sum ; If we reach here , then no subarray ; Driver Code","code":"< ? php function subArraySum ( $ arr , $ n , $ sum ) { $ curr_sum = $ arr [ 0 ] ; $ start = 0 ; $ i ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { while ( $ curr_sum > $ sum and $ start < $ i - 1 ) { $ curr_sum = $ curr_sum - $ arr [ $ start ] ; $ start ++ ; } if ( $ curr_sum == $ sum ) { echo \" Sum \u2581 found \u2581 between \u2581 indexes \" , \" \u2581 \" , $ start , \" \u2581 \" , \" and \u2581 \" , \" \u2581 \" , $ i - 1 ; return 1 ; } if ( $ i < $ n ) $ curr_sum = $ curr_sum + $ arr [ $ i ] ; } echo \" No \u2581 subarray \u2581 found \" ; return 0 ; } $ arr = array ( 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ) ; $ n = count ( $ arr ) ; $ sum = 23 ; subArraySum ( $ arr , $ n , $ sum ) ;"}
{"text":"Smallest Difference Triplet from Three arrays | function to find maximum number ; function to find minimum number ; Finds and prints the smallest Difference Triplet ; sorting all the three arrays ; To store resultant three numbers ; pointers to arr1 , arr2 , arr3 respectively ; Loop until one array reaches to its end Find the smallest difference . ; maximum number ; Find minimum and increment its index . ; comparing new difference with the previous one and updating accordingly ; Print result ; Driver Code","code":"< ? php function maximum ( $ a , $ b , $ c ) { return max ( max ( $ a , $ b ) , $ c ) ; } function minimum ( $ a , $ b , $ c ) { return min ( min ( $ a , $ b ) , $ c ) ; } function smallestDifferenceTriplet ( $ arr1 , $ arr2 , $ arr3 , $ n ) { sort ( $ arr1 ) ; sort ( $ arr2 ) ; sort ( $ arr3 ) ; $ res_min ; $ res_max ; $ res_mid ; $ i = 0 ; $ j = 0 ; $ k = 0 ; $ diff = PHP_INT_MAX ; while ( $ i < $ n && $ j < $ n && $ k < $ n ) { $ sum = $ arr1 [ $ i ] + $ arr2 [ $ j ] + $ arr3 [ $ k ] ; $ max = maximum ( $ arr1 [ $ i ] , $ arr2 [ $ j ] , $ arr3 [ $ k ] ) ; $ min = minimum ( $ arr1 [ $ i ] , $ arr2 [ $ j ] , $ arr3 [ $ k ] ) ; if ( $ min == $ arr1 [ $ i ] ) $ i ++ ; else if ( $ min == $ arr2 [ $ j ] ) $ j ++ ; else $ k ++ ; if ( $ diff > ( $ max - $ min ) ) { $ diff = $ max - $ min ; $ res_max = $ max ; $ res_mid = $ sum - ( $ max + $ min ) ; $ res_min = $ min ; } } echo $ res_max , \" , \u2581 \" , $ res_mid , \" , \u2581 \" , $ res_min ; } $ arr1 = array ( 5 , 2 , 8 ) ; $ arr2 = array ( 10 , 7 , 12 ) ; $ arr3 = array ( 9 , 14 , 6 ) ; $ n = sizeof ( $ arr1 ) ; smallestDifferenceTriplet ( $ arr1 , $ arr2 , $ arr3 , $ n ) ; ? >"}
{"text":"Find a triplet that sum to a given value | returns true if there is triplet with sum equal to ' sum ' present in A [ ] . Also , prints the triplet ; Fix the first element as A [ i ] ; Fix the second element as A [ j ] ; Now look for the third number ; If we reach here , then no triplet was found ; Driver Code","code":"< ? php function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ arr_size ; $ k ++ ) { if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] == $ sum ) { echo \" Triplet \u2581 is \" , \" \u2581 \" , $ A [ $ i ] , \" , \u2581 \" , $ A [ $ j ] , \" , \u2581 \" , $ A [ $ k ] ; return true ; } } } } return false ; } $ A = array ( 1 , 4 , 45 , 6 , 10 , 8 ) ; $ sum = 22 ; $ arr_size = sizeof ( $ A ) ; find3Numbers ( $ A , $ arr_size , $ sum ) ; ? >"}
{"text":"Find a triplet that sum to a given value | returns true if there is triplet with sum equal to ' sum ' present in A [ ] . Also , prints the triplet ; Sort the elements ; Now fix the first element one by one and find the other two elements ; To find the other two elements , start two index variables from two corners of the array and move them toward each other index of the first element ; in the remaining elements index of the last element ; A [ i ] + A [ l ] + A [ r ] > sum ; If we reach here , then no triplet was found ; Driver Code","code":"< ? php function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; sort ( $ A ) ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { $ l = $ i + 1 ; $ r = $ arr_size - 1 ; while ( $ l < $ r ) { if ( $ A [ $ i ] + $ A [ $ l ] + $ A [ $ r ] == $ sum ) { echo \" Triplet \u2581 is \u2581 \" , $ A [ $ i ] , \" \u2581 \" , $ A [ $ l ] , \" \u2581 \" , $ A [ $ r ] , \" STRNEWLINE \" ; return true ; } else if ( $ A [ $ i ] + $ A [ $ l ] + $ A [ $ r ] < $ sum ) $ l ++ ; else $ r -- ; } } return false ; } $ A = array ( 1 , 4 , 45 , 6 , 10 , 8 ) ; $ sum = 22 ; $ arr_size = sizeof ( $ A ) ; find3Numbers ( $ A , $ arr_size , $ sum ) ; ? >"}
{"text":"Subarray \/ Substring vs Subsequence and Programs to Generate them | Prints all subarrays in arr [ 0. . n - 1 ] ; Pick starting point ; Pick ending point ; Print subarray between current starting and ending points ; Driver Code","code":"< ? php function subArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ arr [ $ k ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } } } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" All \u2581 Non - empty \u2581 Subarrays STRNEWLINE \" ; subArray ( $ arr , $ n ) ; ? >"}
{"text":"Subarray \/ Substring vs Subsequence and Programs to Generate them | PHP code to generate all possible subsequences . Time Complexity O ( n * 2 ^ n ) ; Number of subsequences is ( 2 * * n - 1 ) ; Run from counter 000. . 1 to 111. . 1 ; Check if jth bit in the counter is set If set then print jth element from arr [ ] ; Driver Code","code":"< ? php function printSubsequences ( $ arr , $ n ) { $ opsize = pow ( 2 , $ n ) ; for ( $ counter = 1 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ counter & ( 1 << $ j ) ) echo $ arr [ $ j ] , \" \u2581 \" ; } echo \" STRNEWLINE \" ; } } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo \" All \u2581 Non - empty \u2581 Subsequences STRNEWLINE \" ; printSubsequences ( $ arr , $ n ) ; ? >"}
{"text":"A Product Array Puzzle | Function to print product array for a given array arr [ ] of size n ; Base case ; Allocate memory for the productarray ; Initialize the product array as 1 ; In this loop , temp variable contains product of elements on left side excluding arr [ i ] ; Initialize temp to 1 for product on right side ; In this loop , temp variable contains product of elements on right side excluding arr [ i ] ; print the constructed prod array ; Driver Code","code":"< ? php function productArray ( $ arr , $ n ) { if ( $ n == 1 ) { echo \"0\" ; return ; } $ i ; $ temp = 1 ; $ prod = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ prod [ $ j ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ prod [ $ i ] = $ temp ; $ temp *= $ arr [ $ i ] ; } $ temp = 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ prod [ $ i ] *= $ temp ; $ temp *= $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ prod [ $ i ] , \" \u2581 \" ; return ; } $ arr = array ( 10 , 3 , 5 , 6 , 2 ) ; $ n = count ( $ arr ) ; echo \" The \u2581 product \u2581 array \u2581 is \u2581 : \u2581 STRNEWLINE \" ; productArray ( $ arr , $ n ) ; ? >"}
{"text":"Check if array elements are consecutive | Added Method 3 | The function checks if the array elements are consecutive . If elements are consecutive , then returns true , else returns false ; 1 ) Get the minimum element in array ; 2 ) Get the maximum element in array ; 3 ) $max - $min + 1 is equal to $n , then only check all elements ; Create a temp array to hold visited flag of all elements . ; If we see an element again , then return false ; If visited first time , then mark the element as visited ; If all elements occur once , then return true ; if ( $max - $min + 1 != $n ) ; UTILITY FUNCTIONS ; Driver Code","code":"< ? php function areConsecutive ( $ arr , $ n ) { if ( $ n < 1 ) return false ; $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; if ( $ max - $ min + 1 == $ n ) { $ visited = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ visited [ $ i ] = false ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ visited [ $ arr [ $ i ] - $ min ] != false ) return false ; $ visited [ $ arr [ $ i ] - $ min ] = true ; } return true ; } return false ; } function getMin ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ min ) $ min = $ arr [ $ i ] ; return $ min ; } function getMax ( $ arr , $ n ) { $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; return $ max ; } $ arr = array ( 5 , 4 , 2 , 3 , 1 , 6 ) ; $ n = count ( $ arr ) ; if ( areConsecutive ( $ arr , $ n ) == true ) echo \" Array \u2581 elements \u2581 are \u2581 consecutive \u2581 \" ; else echo \" Array \u2581 elements \u2581 are \u2581 not \u2581 consecutive \u2581 \" ; ? >"}
{"text":"Check if array elements are consecutive | Added Method 3 | The function checks if the array elements are consecutive If elements are consecutive , then returns true , else returns false ; 1 ) Get the minimum element in array ; 2 ) Get the maximum element in array ; 3 ) max - min + 1 is equal to n then only check all elements ; if the value at index j is negative then there is repetition ; If we do not see a negative value then all elements are distinct ; if ( max - min + 1 != n ) ; UTILITY FUNCTIONS ; Driver program to test above functions","code":"< ? php function areConsecutive ( $ arr , $ n ) { if ( $ n < 1 ) return false ; $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; if ( $ max - $ min + 1 == $ n ) { $ i ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; if ( $ arr [ $ i ] < 0 ) $ j = - $ arr [ $ i ] - $ min ; else $ j = $ arr [ $ i ] - $ min ; if ( $ arr [ $ j ] > 0 ) $ arr [ $ j ] = - $ arr [ $ j ] ; else return false ; } return true ; } return false ; } function getMin ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ min ) $ min = $ arr [ $ i ] ; return $ min ; } function getMax ( $ arr , $ n ) { $ max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; return $ max ; } $ arr = array ( 1 , 4 , 5 , 3 , 2 , 6 ) ; $ n = count ( $ arr ) ; if ( areConsecutive ( $ arr , $ n ) == true ) echo \" \u2581 Array \u2581 elements \u2581 are \u2581 consecutive \u2581 \" ; else echo \" \u2581 Array \u2581 elements \u2581 are \u2581 not \u2581 consecutive \u2581 \" ; ? >"}
{"text":"Find relative complement of two sorted arrays | PHP program to find all those elements of arr1 [ ] that are not present in arr2 [ ] ; If current element in arr2 [ ] is greater , then arr1 [ i ] can 't be  present in arr2[j..m-1] ; Skipping smaller elements of arr2 [ ] ; Equal elements found ( skipping in both arrays ) ; Printing remaining elements of arr1 [ ] ; Driver code","code":"< ? php function relativeComplement ( $ arr1 , $ arr2 , $ n , $ m ) { $ i = 0 ; $ j = 0 ; while ( $ i < $ n && $ j < $ m ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) { echo $ arr1 [ $ i ] , \" \" ; $ i ++ ; } else if ( $ arr1 [ $ i ] > $ arr2 [ $ j ] ) { $ j ++ ; } else if ( $ arr1 [ $ i ] == $ arr2 [ $ j ] ) { $ i ++ ; $ j ++ ; } } while ( $ i < $ n ) echo $ arr1 [ $ i ] , \" \u2581 \" ; } { $ arr1 = array ( 3 , 6 , 10 , 12 , 15 ) ; $ arr2 = array ( 1 , 3 , 5 , 10 , 16 ) ; $ n = sizeof ( $ arr1 ) \/ sizeof ( $ arr1 [ 0 ] ) ; $ m = sizeof ( $ arr2 ) \/ sizeof ( $ arr2 [ 0 ] ) ; relativeComplement ( $ arr1 , $ arr2 , $ n , $ m ) ; return 0 ; } ? >"}
{"text":"Minimum increment by k operations to make all elements equal | function for calculating min operations ; max elements of array ; iterate for all elements ; check if element can make equal to max or not if not then return - 1 ; else update res for required operations ; return result ; Driver Code","code":"< ? php function minOps ( $ arr , $ n , $ k ) { $ max = max ( $ arr ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ max - $ arr [ $ i ] ) % $ k != 0 ) return -1 ; else $ res += ( $ max - $ arr [ $ i ] ) \/ $ k ; } return $ res ; } $ arr = array ( 21 , 33 , 9 , 45 , 63 ) ; $ n = count ( $ arr ) ; $ k = 6 ; print ( minOps ( $ arr , $ n , $ k ) ) ; ? >"}
{"text":"Minimize ( max ( A [ i ] , B [ j ] , C [ k ] ) | PHP code for above approach ; calculating min difference from last index of lists ; checking condition ; calculating max term from list ; Moving to smaller value in the array with maximum out of three . ; Driver code","code":"< ? php function solve ( $ A , $ B , $ C , $ i , $ j , $ k ) { $ min_diff ; $ current_diff ; $ max_term ; $ min_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; while ( $ i != -1 && $ j != -1 && $ k != -1 ) { $ current_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; if ( $ current_diff < $ min_diff ) $ min_diff = $ current_diff ; $ max_term = max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) ; if ( $ A [ $ i ] == $ max_term ) $ i -= 1 ; else if ( $ B [ $ j ] == $ max_term ) $ j -= 1 ; else $ k -= 1 ; } return $ min_diff ; } $ D = array ( 5 , 8 , 10 , 15 ) ; $ E = array ( 6 , 9 , 15 , 78 , 89 ) ; $ F = array ( 2 , 3 , 6 , 6 , 8 , 8 , 10 ) ; $ nD = sizeof ( $ D ) ; $ nE = sizeof ( $ E ) ; $ nF = sizeof ( $ F ) ; echo solve ( $ D , $ E , $ F , $ nD - 1 , $ nE - 1 , $ nF - 1 ) ; ? >"}
{"text":"Analysis of Algorithms | Set 2 ( Worst , Average and Best Cases ) | Linearly search x in arr [ ] . If x is present then return the index , otherwise return - 1 ; Driver Code","code":"< ? php function search ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; } return -1 ; } $ arr = array ( 1 , 10 , 30 , 15 ) ; $ x = 30 ; $ n = sizeof ( $ arr ) ; echo $ x . \" \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" . search ( $ arr , $ n , $ x ) ;"}
{"text":"Binary Search | A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be present in left subarray ; Else the element can only be present in right subarray ; We reach here when element is not present in array ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = ceil ( $ l + ( $ r - $ l ) \/ 2 ) ; if ( $ arr [ $ mid ] == $ x ) return floor ( $ mid ) ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ n = count ( $ arr ) ; $ x = 10 ; $ result = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( ( $ result == -1 ) ) echo \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ; else echo \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" , $ result ; ? >"}
{"text":"Binary Search | A iterative binary search function . It returns location of x in given array arr [ l . . r ] if present , otherwise - 1 ; Check if x is present at mid ; If x greater , ignore left half ; If x is smaller , ignore right half ; if we reach here , then element was not present ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { while ( $ l <= $ r ) { $ m = $ l + ( $ r - $ l ) \/ 2 ; if ( $ arr [ $ m ] == $ x ) return floor ( $ m ) ; if ( $ arr [ $ m ] < $ x ) $ l = $ m + 1 ; else $ r = $ m - 1 ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ n = count ( $ arr ) ; $ x = 10 ; $ result = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( ( $ result == -1 ) ) echo \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ; else echo \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" , $ result ; ? >"}
{"text":"Jump Search | PHP program to implement Jump Search ; Finding block size to be jumped ; Finding the block where element is present ( if it is present ) ; Doing a linear search for x in block beginning with prev . ; If we reached next block or end of array , element is not present . ; If element is found ; Driver program to test function ; Find the index of ' $ x ' using Jump Search ; Print the index where ' $ x ' is located","code":"< ? php function jumpSearch ( $ arr , $ x , $ n ) { $ step = sqrt ( $ n ) ; $ prev = 0 ; while ( $ arr [ min ( $ step , $ n ) - 1 ] < $ x ) { $ prev = $ step ; $ step += sqrt ( $ n ) ; if ( $ prev >= $ n ) return -1 ; } while ( $ arr [ $ prev ] < $ x ) { $ prev ++ ; if ( $ prev == min ( $ step , $ n ) ) return -1 ; } if ( $ arr [ $ prev ] == $ x ) return $ prev ; return -1 ; } $ arr = array ( 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 ) ; $ x = 55 ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ index = jumpSearch ( $ arr , $ x , $ n ) ; echo \" Number \u2581 \" . $ x . \" \u2581 is \u2581 at \u2581 index \u2581 \" . $ index ; return 0 ; ? >"}
{"text":"Exponential Search | Returns position of first occurrence of x in array ; If x is present at first location itself ; Find range for binary search by repeated doubling ; Call binary search for the found range . ; A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be present n left subarray ; Else the element can only be present in right subarray ; We reach here when element is not present in array ; Driver code","code":"< ? php function exponentialSearch ( $ arr , $ n , $ x ) { if ( $ arr [ 0 ] == $ x ) return 0 ; $ i = 1 ; while ( $ i < $ n and $ arr [ $ i ] <= $ x ) $ i = $ i * 2 ; return binarySearch ( $ arr , $ i \/ 2 , min ( $ i , $ n - 1 ) , $ x ) ; } function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = $ l + ( $ r - $ l ) \/ 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ n = count ( $ arr ) ; $ x = 10 ; $ result = exponentialSearch ( $ arr , $ n , $ x ) ; if ( $ result == -1 ) echo \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ; else echo \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" , $ result ; ? >"}
{"text":"Radix Sort | A function to do counting sort of arr [ ] according to the digit represented by exp . ; output array ; Store count of occurrences in count [ ] ; Change count [ i ] so that count [ i ] now contains actual position of this digit in output [ ] ; Build the output array ; Copy the output array to arr [ ] , so that arr [ ] now contains sorted numbers according to current digit ; The main function to that sorts arr [ ] of size n using Radix Sort ; Find the maximum number to know number of digits ; Do counting sort for every digit . Note that instead of passing digit number , exp is passed . exp is 10 ^ i where i is current digit number ; A utility function to print an array ; Driver Code ; Function Call","code":"< ? php function countSort ( & $ arr , $ n , $ exp ) { $ output = array_fill ( 0 , $ n , 0 ) ; $ count = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ( $ arr [ $ i ] \/ $ exp ) % 10 ] ++ ; for ( $ i = 1 ; $ i < 10 ; $ i ++ ) $ count [ $ i ] += $ count [ $ i - 1 ] ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ output [ $ count [ ( $ arr [ $ i ] \/ $ exp ) % 10 ] - 1 ] = $ arr [ $ i ] ; $ count [ ( $ arr [ $ i ] \/ $ exp ) % 10 ] -- ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ output [ $ i ] ; } function radixsort ( & $ arr , $ n ) { $ m = max ( $ arr ) ; for ( $ exp = 1 ; $ m \/ $ exp > 0 ; $ exp *= 10 ) countSort ( $ arr , $ n , $ exp ) ; } function PrintArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 ) ; $ n = count ( $ arr ) ; radixsort ( $ arr , $ n ) ; PrintArray ( $ arr , $ n ) ; ? >"}
{"text":"Iterative Quick Sort | Function to swap numbers ; This function takes last element as pivot , places the pivot element at its correct position in sorted array , and places all smaller ( smaller than pivot ) to left of pivot and all greater elements to right of pivot ; A [ ] -- > Array to be sorted , l -- > Starting index , h -- > Ending index ; Partitioning index ; Driver code","code":"< ? php function swap ( & $ a , & $ b ) { $ temp = $ a ; $ a = $ b ; $ b = $ temp ; } function partition ( & $ arr , $ l , $ h ) { $ x = $ arr [ $ h ] ; $ i = ( $ l - 1 ) ; for ( $ j = $ l ; $ j <= $ h - 1 ; $ j ++ ) { if ( $ arr [ $ j ] <= $ x ) { $ i ++ ; swap ( $ arr [ $ i ] , $ arr [ $ j ] ) ; } } swap ( $ arr [ $ i + 1 ] , $ arr [ $ h ] ) ; return ( $ i + 1 ) ; } function quickSort ( & $ A , $ l , $ h ) { if ( $ l < $ h ) { $ p = partition ( $ A , $ l , $ h ) ; quickSort ( $ A , $ l , $ p - 1 ) ; quickSort ( $ A , $ p + 1 , $ h ) ; } } $ n = 5 ; $ arr = array ( 4 , 2 , 6 , 9 , 2 ) ; quickSort ( $ arr , 0 , $ n - 1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . \" \u2581 \" ; } ? >"}
{"text":"Iterative Quick Sort | A utility function to swap two elements ; This function is same in both iterative and recursive ; A [ ] -- > Array to be sorted , l -- > Starting index , h -- > Ending index ; Create an auxiliary stack ; initialize top of stack ; push initial values of l and h to stack ; Keep popping from stack while is not empty ; Pop h and l ; Set pivot element at its correct position in sorted array ; If there are elements on left side of pivot , then push left side to stack ; If there are elements on right side of pivot , then push right side to stack ; A utility function to print contents of arr ; Driver code ; Function calling","code":"< ? php function swap ( & $ a , & $ b ) { $ t = $ a ; $ a = $ b ; $ b = $ t ; } function partition ( & $ arr , $ l , $ h ) { $ x = $ arr [ $ h ] ; $ i = ( $ l - 1 ) ; for ( $ j = $ l ; $ j <= $ h - 1 ; $ j ++ ) { if ( $ arr [ $ j ] <= $ x ) { $ i ++ ; swap ( $ arr [ $ i ] , $ arr [ $ j ] ) ; } } swap ( $ arr [ $ i + 1 ] , $ arr [ $ h ] ) ; return ( $ i + 1 ) ; } function quickSortIterative ( & $ arr , $ l , $ h ) { $ stack = array_fill ( 0 , $ h - $ l + 1 , 0 ) ; $ top = -1 ; $ stack [ ++ $ top ] = $ l ; $ stack [ ++ $ top ] = $ h ; while ( $ top >= 0 ) { $ h = $ stack [ $ top -- ] ; $ l = $ stack [ $ top -- ] ; $ p = partition ( $ arr , $ l , $ h ) ; if ( $ p - 1 > $ l ) { $ stack [ ++ $ top ] = $ l ; $ stack [ ++ $ top ] = $ p - 1 ; } if ( $ p + 1 < $ h ) { $ stack [ ++ $ top ] = $ p + 1 ; $ stack [ ++ $ top ] = $ h ; } } } function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 ) ; $ n = count ( $ arr ) ; quickSortIterative ( $ arr , 0 , $ n - 1 ) ; printArr ( $ arr , $ n ) ; ? >"}
{"text":"Search in an almost sorted array | A recursive binary search based function . It returns index of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at one of the middle 3 positions ; If element is smaller than mid , then it can only be present in left subarray ; Else the element can only be present in right subarray ; We reach here when element is not present in array ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = $ l + ( $ r - $ l ) \/ 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ mid > $ l && $ arr [ $ mid - 1 ] == $ x ) return ( $ mid - 1 ) ; if ( $ mid < $ r && $ arr [ $ mid + 1 ] == $ x ) return ( $ mid + 1 ) ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 2 , $ x ) ; return binarySearch ( $ arr , $ mid + 2 , $ r , $ x ) ; } return -1 ; } $ arr = array ( 3 , 2 , 10 , 4 , 40 ) ; $ n = sizeof ( $ arr ) ; $ x = 4 ; $ result = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ result == -1 ) echo ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) ; else echo ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 $ result \" ) ; ? >"}
{"text":"Find the closest pair from two sorted arrays | ar1 [ 0. . m - 1 ] and ar2 [ 0. . n - 1 ] are two given sorted arrays and x is given number . This function prints the pair from both arrays such that the sum of the pair is closest to x . ; Initialize the diff between pair sum and x . ; res_l and res_r are result indexes from ar1 [ ] and ar2 [ ] respectively ; Start from left side of ar1 [ ] and right side of ar2 [ ] ; If this pair is closer to x than the previously found closest , then update res_l , res_r and diff ; If sum of this pair is more than x , move to smaller side ; move to the greater side ; Print the result ; Driver Code","code":"< ? php function printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) { $ diff = PHP_INT_MAX ; $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) ; } if ( $ ar1 [ $ l ] + $ ar2 [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo \" The \u2581 closest \u2581 pair \u2581 is \u2581 [ \" , $ ar1 [ $ res_l ] , \" , \u2581 \" , $ ar2 [ $ res_r ] , \" ] \u2581 STRNEWLINE \" ; } $ ar1 = array ( 1 , 4 , 5 , 7 ) ; $ ar2 = array ( 10 , 20 , 30 , 40 ) ; $ m = count ( $ ar1 ) ; $ n = count ( $ ar2 ) ; $ x = 38 ; printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) ; ? >"}
{"text":"Given a sorted array and a number x , find the pair in array whose sum is closest to x | Prints the pair with sum closest to x ; To store indexes of result pair ; Initialize left and right indexes and difference between pair sum and x ; While there are elements between l and r ; Check if this pair is closer than the closest pair so far ; If this pair has more sum , move to smaller values . ; Move to larger values ; Driver Code","code":"< ? php function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo \" \u2581 The \u2581 closest \u2581 pair \u2581 is \u2581 \" , $ arr [ $ res_l ] , \" \u2581 and \u2581 \" , $ arr [ $ res_r ] ; } $ arr = array ( 10 , 22 , 28 , 29 , 30 , 40 ) ; $ x = 54 ; $ n = count ( $ arr ) ; printClosest ( $ arr , $ n , $ x ) ; ? >"}
{"text":"Count 1 's in a sorted binary array | Returns counts of 1 's in arr[low..high]. The array is assumed to be sorted in non-increasing order  ; get the middle index ; check if the element at middle index is last 1 ; If element is not last 1 , recur for right side ; else recur for left side ; Driver code","code":"< ? php function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) \/ 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; } $ arr = array ( 1 , 1 , 1 , 1 , 0 , 0 , 0 ) ; $ n = count ( $ arr ) ; echo \" Count \u2581 of \u2581 1 ' s \u2581 in \u2581 given \u2581 array \u2581 is \u2581 \" , countOnes ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text":"Minimum adjacent swaps to move maximum and minimum to corners | Function that returns the minimum swaps ; Index of leftmost largest element ; Index of rightmost smallest element ; Driver Code","code":"< ? php function solve ( $ a , $ n ) { $ maxx = -1 ; $ minn = $ a [ 0 ] ; $ l = 0 ; $ r = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ maxx ) { $ maxx = $ a [ $ i ] ; $ l = $ i ; } if ( $ a [ $ i ] <= $ minn ) { $ minn = $ a [ $ i ] ; $ r = $ i ; } } if ( $ r < $ l ) echo $ l + ( $ n - $ r - 2 ) ; else echo $ l + ( $ n - $ r - 1 ) ; } $ a = array ( 5 , 6 , 1 , 3 ) ; $ n = count ( $ a ) ; solve ( $ a , $ n ) ; ? >"}
{"text":"Activity Selection Problem | Greedy Algo | Prints a maximum set of activities that can be done by a single person , one at a time . n -- > Total number of activities s [ ] -- > An array that contains start time of all activities f [ ] -- > An array that contains finish time of all activities ; The first activity always gets selected ; Consider rest of the activities ; If this activity has start time greater than or equal to the finish time of previously selected activity , then select it ; Driver Code","code":"< ? php function printMaxActivities ( $ s , $ f , $ n ) { echo \" Following \u2581 activities \u2581 are \u2581 selected \u2581 \" . \" STRNEWLINE \" ; $ i = 0 ; echo $ i . \" \" ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ s [ $ j ] >= $ f [ $ i ] ) { echo $ j . \" \" ; $ i = $ j ; } } } $ s = array ( 1 , 3 , 0 , 5 , 8 , 5 ) ; $ f = array ( 2 , 4 , 6 , 7 , 9 , 9 ) ; $ n = sizeof ( $ s ) ; printMaxActivities ( $ s , $ f , $ n ) ; ? >"}
{"text":"Longest Common Subsequence | DP | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Driver Code","code":"< ? php function lcs ( $ X , $ Y , $ m , $ n ) { if ( $ m == 0 $ n == 0 ) return 0 ; else if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + lcs ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; else return max ( lcs ( $ X , $ Y , $ m , $ n - 1 ) , lcs ( $ X , $ Y , $ m - 1 , $ n ) ) ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length \u2581 of \u2581 LCS \u2581 is \u2581 \" ; echo lcs ( $ X , $ Y , strlen ( $ X ) , strlen ( $ Y ) ) ; ? >"}
{"text":"Longest Common Subsequence | DP | Dynamic Programming C # implementation of LCS problem ; find the length of the strings ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note : L [ i ] [ j ] contains length of LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; L [ m ] [ n ] contains the length of LCS of X [ 0. . n - 1 ] & Y [ 0. . m - 1 ] ; Driver Code","code":"< ? php function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } return $ L [ $ m ] [ $ n ] ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length \u2581 of \u2581 LCS \u2581 is \u2581 \" ; echo lcs ( $ X , $ Y ) ; ? >"}
{"text":"Min Cost Path | DP | A Naive recursive implementation of MCP ( Minimum Cost Path ) problem ; A utility function that returns minimum of 3 integers ; Returns cost of minimum cost path from ( 0 , 0 ) to ( m , n ) in mat [ R ] [ C ] ; Driver Code","code":"< ? php $ R = 3 ; $ C = 3 ; function min1 ( $ x , $ y , $ z ) { if ( $ x < $ y ) return ( $ x < $ z ) ? $ x : $ z ; else return ( $ y < $ z ) ? $ y : $ z ; } function minCost ( $ cost , $ m , $ n ) { global $ R ; global $ C ; if ( $ n < 0 $ m < 0 ) return PHP_INT_MAX ; else if ( $ m == 0 && $ n == 0 ) return $ cost [ $ m ] [ $ n ] ; else return $ cost [ $ m ] [ $ n ] + min1 ( minCost ( $ cost , $ m - 1 , $ n - 1 ) , minCost ( $ cost , $ m - 1 , $ n ) , minCost ( $ cost , $ m , $ n - 1 ) ) ; } $ cost = array ( array ( 1 , 2 , 3 ) , array ( 4 , 8 , 2 ) , array ( 1 , 5 , 3 ) ) ; echo minCost ( $ cost , 2 , 2 ) ; ? >"}
{"text":"Min Cost Path | DP | DP implementation of MCP problem ; Instead of following line , we can use int tc [ m + 1 ] [ n + 1 ] or dynamically allocate memory to save space . The following line is used to keep the program simple and make it working on all compilers . ; Initialize first column of total cost ( tc ) array ; Initialize first row of tc array ; Construct rest of the tc array ; returns minimum of 3 integers ; Driver Code","code":"< ? php $ R = 3 ; $ C = 3 ; function minCost ( $ cost , $ m , $ n ) { global $ R ; global $ C ; $ tc ; for ( $ i = 0 ; $ i <= $ R ; $ i ++ ) for ( $ j = 0 ; $ j <= $ C ; $ j ++ ) $ tc [ $ i ] [ $ j ] = 0 ; $ tc [ 0 ] [ 0 ] = $ cost [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ tc [ $ i ] [ 0 ] = $ tc [ $ i - 1 ] [ 0 ] + $ cost [ $ i ] [ 0 ] ; for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ tc [ 0 ] [ $ j ] = $ tc [ 0 ] [ $ j - 1 ] + $ cost [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ tc [ $ i ] [ $ j ] = min ( $ tc [ $ i - 1 ] [ $ j - 1 ] , $ tc [ $ i - 1 ] [ $ j ] , $ tc [ $ i ] [ $ j - 1 ] ) + $ cost [ $ i ] [ $ j ] ; return $ tc [ $ m ] [ $ n ] ; } $ cost = array ( array ( 1 , 2 , 3 ) , array ( 4 , 8 , 2 ) , array ( 1 , 5 , 3 ) ) ; echo minCost ( $ cost , 2 , 2 ) ; ? >"}
{"text":"0 | Returns the maximum value that can be put in a knapsack of capacity W ; Base Case ; If weight of the nth item is more than Knapsack capacity W , then this item cannot be included in the optimal solution ; Return the maximum of two cases : ( 1 ) nth item included ( 2 ) not included ; Driver Code","code":"< ? php function knapSack ( $ W , $ wt , $ val , $ n ) { if ( $ n == 0 $ W == 0 ) return 0 ; if ( $ wt [ $ n - 1 ] > $ W ) return knapSack ( $ W , $ wt , $ val , $ n - 1 ) ; else return max ( $ val [ $ n - 1 ] + knapSack ( $ W - $ wt [ $ n - 1 ] , $ wt , $ val , $ n - 1 ) , knapSack ( $ W , $ wt , $ val , $ n - 1 ) ) ; } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = count ( $ val ) ; echo knapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text":"0 | Returns the maximum value that can be put in a knapsack of capacity W ; Build table K [ ] [ ] in bottom up manner ; Driver Code","code":"< ? php function knapSack ( $ W , $ wt , $ val , $ n ) { $ K = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ w = 0 ; $ w <= $ W ; $ w ++ ) { if ( $ i == 0 $ w == 0 ) $ K [ $ i ] [ $ w ] = 0 ; else if ( $ wt [ $ i - 1 ] <= $ w ) $ K [ $ i ] [ $ w ] = max ( $ val [ $ i - 1 ] + $ K [ $ i - 1 ] [ $ w - $ wt [ $ i - 1 ] ] , $ K [ $ i - 1 ] [ $ w ] ) ; else $ K [ $ i ] [ $ w ] = $ K [ $ i - 1 ] [ $ w ] ; } } return $ K [ $ n ] [ $ W ] ; } $ val = array ( 60 , 100 , 120 ) ; $ wt = array ( 10 , 20 , 30 ) ; $ W = 50 ; $ n = count ( $ val ) ; echo knapSack ( $ W , $ wt , $ val , $ n ) ; ? >"}
{"text":"Egg Dropping Puzzle | DP | Function to get minimum number of trials needed in worst case with n eggs and k floors ; A 2D table where entry eggFloor [ i ] [ j ] will represent minimum number of trials needed for i eggs and j floors . ; We need one trial for one floor and0 trials for 0 floors ; We always need j trials for one egg and j floors . ; Fill rest of the entries in table using optimal substructure property ; eggFloor [ n ] [ k ] holds the result ; Driver Code","code":"< ? php function eggDrop ( $ n , $ k ) { $ eggFloor = array ( array ( ) ) ; ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ eggFloor [ $ i ] [ 1 ] = 1 ; $ eggFloor [ $ i ] [ 0 ] = 0 ; } for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ eggFloor [ 1 ] [ $ j ] = $ j ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 2 ; $ j <= $ k ; $ j ++ ) { $ eggFloor [ $ i ] [ $ j ] = 999999 ; for ( $ x = 1 ; $ x <= $ j ; $ x ++ ) { $ res = 1 + max ( $ eggFloor [ $ i - 1 ] [ $ x - 1 ] , $ eggFloor [ $ i ] [ $ j - $ x ] ) ; if ( $ res < $ eggFloor [ $ i ] [ $ j ] ) $ eggFloor [ $ i ] [ $ j ] = $ res ; } } } return $ eggFloor [ $ n ] [ $ k ] ; } $ n = 2 ; $ k = 36 ; echo \" Minimum \u2581 number \u2581 of \u2581 trials \u2581 in \u2581 worst \u2581 case \u2581 with \u2581 \" . $ n . \" \u2581 eggs \u2581 and \u2581 \" . $ k . \" \u2581 floors \u2581 is \u2581 \" . eggDrop ( $ n , $ k ) ; ? >"}
{"text":"Longest Palindromic Subsequence | DP | Returns the length of the longest palindromic subsequence in seq ; Base Case 1 : If there is only 1 character ; Base Case 2 : If there are only 2 characters and both are same ; If the first and last characters match ; If the first and last characters do not match ; Driver Code","code":"< ? php function lps ( $ seq , $ i , $ j ) { if ( $ i == $ j ) return 1 ; if ( $ seq [ $ i ] == $ seq [ $ j ] && $ i + 1 == $ j ) return 2 ; if ( $ seq [ $ i ] == $ seq [ $ j ] ) return lps ( $ seq , $ i + 1 , $ j - 1 ) + 2 ; return max ( lps ( $ seq , $ i , $ j - 1 ) , lps ( $ seq , $ i + 1 , $ j ) ) ; } $ seq = \" GEEKSFORGEEKS \" ; $ n = strlen ( $ seq ) ; echo \" The \u2581 length \u2581 of \u2581 the \u2581 LPS \u2581 is \u2581 \" . lps ( $ seq , 0 , $ n - 1 ) ; ? >"}
{"text":"Longest Palindromic Subsequence | DP | A utility function to get max of two integers ; Returns the length of the longest palindromic subsequence in seq ; Create a table to store results of subproblems ; Strings of length 1 are palindrome of lentgh 1 ; Build the table . Note that the lower diagonal values of table are useless and not filled in the process . The values are filled in a manner similar to Matrix Chain Multiplication DP solution ( Seewww . geeksforgeeks . org \/ matrix - chain - multiplication - dp - 8 \/ ) . https : cl is length of substring ; Driver Code","code":"< ? php function max ( $ x , $ y ) { return ( $ x > $ y ) ? $ x : $ y ; } function lps ( $ str ) { $ n = strlen ( $ str ) ; $ i ; $ j ; $ cl ; $ L [ ] [ ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ L [ $ i ] [ $ i ] = 1 ; for ( $ cl = 2 ; $ cl <= $ n ; $ cl ++ ) { for ( $ i = 0 ; $ i < $ n - $ cl + 1 ; $ i ++ ) { $ j = $ i + $ cl - 1 ; if ( $ str [ $ i ] == $ str [ $ j ] && $ cl == 2 ) $ L [ $ i ] [ $ j ] = 2 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i + 1 ] [ $ j - 1 ] + 2 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i ] [ $ j - 1 ] , $ L [ $ i + 1 ] [ $ j ] ) ; } } return $ L [ 0 ] [ $ n - 1 ] ; } $ seq = ' EEKS FOR GEEKS ' ; $ n = strlen ( $ seq ) ; echo \" The \u2581 length \u2581 of \u2581 the \u2581 \" . \" LPS \u2581 is \u2581 \" , lps ( $ seq ) ; ? >"}
{"text":"Longest Bitonic Subsequence | DP | lbs ( ) returns the length of the Longest Bitonic Subsequence in arr [ ] of size n . The function mainly creates two temporary arrays lis [ ] and lds [ ] and returns the maximum lis [ i ] + lds [ i ] - 1. lis [ i ] == > Longest Increasing subsequence ending with arr [ i ] lds [ i ] == > Longest decreasing subsequence starting with arr [ i ] ; Allocate memory for LIS [ ] and initialize LIS values as 1 for all indexes ; Compute LIS values from left to right ; Allocate memory for lds and initialize LDS values for all indexes ; Compute LDS values from right to left ; Return the maximum value of lis [ i ] + lds [ i ] - 1 ; Driver Code","code":"< ? php function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; } $ arr = array ( 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ) ; $ n = sizeof ( $ arr ) ; echo \" Length \u2581 of \u2581 LBS \u2581 is \u2581 \" . lbs ( $ arr , $ n ) ; ? >"}
{"text":"Ugly Numbers | This function divides a by greatest divisible power of b ; Function to check if a number is ugly or not ; Function to get the nth ugly number ; ugly number count ; Check for all integers untill ugly count becomes n ; Driver Code","code":"< ? php function maxDivide ( $ a , $ b ) { while ( $ a % $ b == 0 ) $ a = $ a \/ $ b ; return $ a ; } function isUgly ( $ no ) { $ no = maxDivide ( $ no , 2 ) ; $ no = maxDivide ( $ no , 3 ) ; $ no = maxDivide ( $ no , 5 ) ; return ( $ no == 1 ) ? 1 : 0 ; } function getNthUglyNo ( $ n ) { $ i = 1 ; $ count = 1 ; while ( $ n > $ count ) { $ i ++ ; if ( isUgly ( $ i ) ) $ count ++ ; } return $ i ; } $ no = getNthUglyNo ( 150 ) ; echo \"150th \u2581 ugly \u2581 no . \u2581 is \u2581 \" . $ no ; ? >"}
{"text":"Count of n digit numbers whose sum of digits equals to given sum | Recursive function to count ' n ' digit numbers with sum of digits as ' sum ' . This function considers leading 0 's also as digits, that is why not directly called ; Base case ; Initialize answer ; Traverse through every digit and count numbers beginning with it using recursion ; This is mainly a wrapper over countRec . It explicitly handles leading digit and calls countRec ( ) for remaining digits . ; Initialize final answer ; Traverse through every digit from 1 to 9 and count numbers beginning with it ; Driver Code","code":"< ? php function countRec ( $ n , $ sum ) { if ( $ n == 0 ) return $ sum == 0 ; if ( $ sum == 0 ) return 1 ; $ ans = 0 ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ ans ; } function finalCount ( $ n , $ sum ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ ans ; } $ n = 2 ; $ sum = 5 ; echo finalCount ( $ n , $ sum ) ; ? >"}
{"text":"Count of n digit numbers whose sum of digits equals to given sum | A lookup table used for memoization ; Memoization based implementation of recursive function ; Base case ; If this subproblem is already evaluated , return the evaluated value ; Initialize answer ; Traverse through every digit and recursively count numbers beginning with it ; This is mainly a wrapper over countRec . It explicitly handles leading digit and calls countRec ( ) for remaining n . ; Initialize final answer ; Traverse through every digit from 1 to 9 and count numbers beginning with it ; Driver Code","code":"< ? php $ lookup = array_fill ( 0 , 101 , array_fill ( 0 , 501 , -1 ) ) ; function countRec ( $ n , $ sum ) { global $ lookup ; if ( $ n == 0 ) return $ sum == 0 ; if ( $ lookup [ $ n ] [ $ sum ] != -1 ) return $ lookup [ $ n ] [ $ sum ] ; $ ans = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ lookup [ $ n ] [ $ sum ] = $ ans ; } function finalCount ( $ n , $ sum ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) if ( $ sum - $ i >= 0 ) $ ans += countRec ( $ n - 1 , $ sum - $ i ) ; return $ ans ; } $ n = 3 ; $ sum = 5 ; echo finalCount ( $ n , $ sum ) ; ? >"}
{"text":"Count of n digit numbers whose sum of digits equals to given sum | PHP program to Count of n digit numbers whose sum of digits equals to given sum ; In case n = 2 start is 10 and end is ( 100 - 1 ) = 99 ; Driver Code","code":"< ? php function findCount ( $ n , $ sum ) { $ start = ( int ) pow ( 10 , $ n - 1 ) ; $ end = ( int ) pow ( 10 , $ n ) - 1 ; $ count = 0 ; $ i = $ start ; while ( $ i < $ end ) { $ cur = 0 ; $ temp = $ i ; while ( $ temp != 0 ) { $ cur += $ temp % 10 ; $ temp = ( int ) $ temp \/ 10 ; } if ( $ cur == $ sum ) { $ count ++ ; $ i += 9 ; } else $ i ++ ; } echo ( $ count ) ; } $ n = 3 ; $ sum = 5 ; findCount ( $ n , $ sum ) ; ? >"}
{"text":"Total number of non | PHP program to count non - decreasing number with n digits ; dp [ i ] [ j ] contains total count of non decreasing numbers ending with digit i and of length j ; Fill table for non decreasing numbers of length 1 Base cases 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ; Fill the table in bottom - up manner ; Compute total numbers of non decreasing numbers of length ' len ' ; sum of all numbers of length of len - 1 in which last digit x is <= ' digit ' ; There total nondecreasing numbers of length n wiint be dp [ 0 ] [ n ] + dp [ 1 ] [ n ] . . + dp [ 9 ] [ n ] ; Driver program","code":"< ? php function countNonDecreasing ( $ n ) { $ dp = array_fill ( 0 , 10 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ dp [ $ i ] [ 1 ] = 1 ; for ( $ digit = 0 ; $ digit <= 9 ; $ digit ++ ) { for ( $ len = 2 ; $ len <= $ n ; $ len ++ ) { for ( $ x = 0 ; $ x <= $ digit ; $ x ++ ) $ dp [ $ digit ] [ $ len ] += $ dp [ $ x ] [ $ len - 1 ] ; } } $ count = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ count += $ dp [ $ i ] [ $ n ] ; return $ count ; } $ n = 3 ; echo countNonDecreasing ( $ n ) ; return 0 ; ? >"}
{"text":"Total number of non | PHP program to count non - decreasing numner with n digits ; Compute value of N * ( N + 1 ) \/ 2 * ( N + 2 ) \/ 3 * ... ... . * ( N + n - 1 ) \/ n ; Driver Code","code":"< ? php function countNonDecreasing ( $ n ) { $ N = 10 ; $ count = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ count *= ( $ N + $ i - 1 ) ; $ count \/= $ i ; } return $ count ; } $ n = 3 ; echo countNonDecreasing ( $ n ) ; ? >"}
{"text":"Minimum number of squares whose sum equals to given number n | Returns count of minimum squares that sum to n ; base cases ; getMinSquares rest of the table using recursive formula Maximum squares required is n ( 1 * 1 + 1 * 1 + . . ) ; Go through all smaller numbers to recursively find minimum ; Driver Code","code":"< ? php function getMinSquares ( $ n ) { if ( $ n <= 3 ) return $ n ; $ res = $ n ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ n ) break ; else $ res = min ( $ res , 1 + getMinSquares ( $ n - $ temp ) ) ; } return $ res ; } echo getMinSquares ( 6 ) ; ? >"}
{"text":"Minimum number of squares whose sum equals to given number n | Returns count of minimum squares that sum to n ; Create a dynamic programming table to store sq ; getMinSquares table for base case entries ; getMinSquares rest of the table using recursive formula ; max value is i as i can always be represented as 1 * 1 + 1 * 1 + ... ; Go through all smaller numbers to recursively find minimum ; Store result and free dp [ ] ; Driver Code","code":"< ? php function getMinSquares ( $ n ) { $ dp ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; $ dp [ 3 ] = 3 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = $ i ; for ( $ x = 1 ; $ x <= ceil ( sqrt ( $ i ) ) ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ i ) break ; else $ dp [ $ i ] = min ( $ dp [ $ i ] , ( 1 + $ dp [ $ i - $ temp ] ) ) ; } } $ res = $ dp [ $ n ] ; return $ res ; } echo getMinSquares ( 6 ) ; ? >"}
{"text":"Find minimum number of coins that make a given value | m is size of coins array ( number of different coins ) ; base case ; Initialize result ; Try every coin that has smaller value than V ; Check for INT_MAX to avoid overflow and see if result can minimized ; Driver Code","code":"< ? php function minCoins ( $ coins , $ m , $ V ) { if ( $ V == 0 ) return 0 ; $ res = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ coins [ $ i ] <= $ V ) { $ sub_res = minCoins ( $ coins , $ m , $ V - $ coins [ $ i ] ) ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ res ) $ res = $ sub_res + 1 ; } } return $ res ; } $ coins = array ( 9 , 6 , 5 , 1 ) ; $ m = sizeof ( $ coins ) ; $ V = 11 ; echo \" Minimum \u2581 coins \u2581 required \u2581 is \u2581 \" , minCoins ( $ coins , $ m , $ V ) ; ? >"}
{"text":"Find minimum number of coins that make a given value | m is size of coins array ( number of different coins ) ; table [ i ] will be storing the minimum number of coins required for i value . So table [ V ] will have result ; Base case ( If given value V is 0 ) ; Initialize all table values as Infinite ; Compute minimum coins required for all values from 1 to V ; Go through all coins smaller than i ; Driver Code","code":"< ? php function minCoins ( $ coins , $ m , $ V ) { $ table [ $ V + 1 ] = array ( ) ; $ table [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) $ table [ $ i ] = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ coins [ $ j ] <= $ i ) { $ sub_res = $ table [ $ i - $ coins [ $ j ] ] ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ table [ $ i ] ) $ table [ $ i ] = $ sub_res + 1 ; } } if ( $ table [ $ V ] == PHP_INT_MAX ) return -1 ; return $ table [ $ V ] ; } $ coins = array ( 9 , 6 , 5 , 1 ) ; $ m = sizeof ( $ coins ) ; $ V = 11 ; echo \" Minimum \u2581 coins \u2581 required \u2581 is \u2581 \" , minCoins ( $ coins , $ m , $ V ) ; ? >"}
{"text":"Shortest Common Supersequence | A Naive recursive PHP program to find length of the shortest supersequence ; Driver Code","code":"< ? php function superSeq ( $ X , $ Y , $ m , $ n ) { if ( ! $ m ) return $ n ; if ( ! $ n ) return $ m ; if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + superSeq ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; return 1 + min ( superSeq ( $ X , $ Y , $ m - 1 , $ n ) , superSeq ( $ X , $ Y , $ m , $ n - 1 ) ) ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length \u2581 of \u2581 the \u2581 shortest \u2581 supersequence \u2581 is \u2581 \" , superSeq ( $ X , $ Y , strlen ( $ X ) , strlen ( $ Y ) ) ; ? >"}
{"text":"Shortest Common Supersequence | Returns length of the shortest supersequence of X and Y ; Fill table in bottom up manner ; Below steps follow above recurrence ; Driver Code","code":"< ? php function superSeq ( $ X , $ Y , $ m , $ n ) { $ dp = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( ! $ i ) $ dp [ $ i ] [ $ j ] = $ j ; else if ( ! $ j ) $ dp [ $ i ] [ $ j ] = $ i ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = 1 + min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) ; } } return $ dp [ $ m ] [ $ n ] ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; echo \" Length \u2581 of \u2581 the \u2581 shortest \u2581 supersequence \u2581 is \u2581 \" . superSeq ( $ X , $ Y , strlen ( $ X ) , strlen ( $ Y ) ) ; ? >"}
{"text":"Compute sum of digits in all numbers from 1 to n | Returns sum of all digits in numbers from 1 to n ; initialize result ; One by one compute sum of digits in every number from 1 to n ; A utility function to compute sum of digits in a given number x ; Driver Program","code":"< ? php function sumOfDigitsFrom1ToN ( $ n ) { $ result = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ result += sumOfDigits ( $ x ) ; return $ result ; } function sumOfDigits ( $ x ) { $ sum = 0 ; while ( $ x != 0 ) { $ sum += $ x % 10 ; $ x = $ x \/ 10 ; } return $ sum ; } $ n = 328 ; echo \" Sum \u2581 of \u2581 digits \u2581 in \u2581 numbers \u2581 from \" . \" \u2581 1 \u2581 to \u2581 \" . $ n . \" \u2581 is \u2581 \" . sumOfDigitsFrom1ToN ( $ n ) ; ? >"}
{"text":"Compute sum of digits in all numbers from 1 to n | Function to computer sum of digits in numbers from 1 to n . Comments use example of 328 to explain the code ; base case : if n < 10 return sum of first n natural numbers ; d = number of digits minus one in n . For 328 , d is 2 ; computing sum of digits from 1 to 10 ^ d - 1 , d = 1 a [ 0 ] = 0 ; d = 2 a [ 1 ] = sum of digit from 1 to 9 = 45 d = 3 a [ 2 ] = sum of digit from 1 to 99 = a [ 1 ] * 10 + 45 * 10 ^ 1 = 900 d = 4 a [ 3 ] = sum of digit from 1 to 999 = a [ 2 ] * 10 + 45 * 10 ^ 2 = 13500 ; computing 10 ^ d ; Most significant digit ( msd ) of n , For 328 , msd is 3 which can be obtained using 328 \/ 100 ; EXPLANATION FOR FIRST and SECOND TERMS IN BELOW LINE OF CODE First two terms compute sum of digits from 1 to 299 ( sum of digits in range 1 - 99 stored in a [ d ] ) + ( sum of digits in range 100 - 199 , can be calculated as 1 * 100 + a [ d ] ( sum of digits in range 200 - 299 , can be calculated as 2 * 100 + a [ d ] The above sum can be written as 3 * a [ d ] + ( 1 + 2 ) * 100 EXPLANATION FOR THIRD AND FOURTH TERMS IN BELOW LINE OF CODE The last two terms compute sum of digits in number from 300 to 328. The third term adds 3 * 29 to sum as digit 3 occurs in all numbers from 300 to 328. The fourth term recursively calls for 28 ; Driver Code","code":"< ? php function sumOfDigitsFrom1ToN ( $ n ) { if ( $ n < 10 ) return ( $ n * ( $ n + 1 ) \/ 2 ) ; $ d = ( int ) ( log10 ( $ n ) ) ; $ a [ $ d + 1 ] = array ( ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 45 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , $ i - 1 ) ) ) ; $ p = ( int ) ( ceil ( pow ( 10 , $ d ) ) ) ; $ msd = ( int ) ( $ n \/ $ p ) ; return ( $ msd * $ a [ $ d ] + ( $ msd * ( int ) ( $ msd - 1 ) \/ 2 ) * $ p + $ msd * ( 1 + $ n % $ p ) + sumOfDigitsFrom1ToN ( $ n % $ p ) ) ; } $ n = 328 ; echo ( \" Sum \u2581 of \u2581 digits \u2581 in \u2581 numbers \u2581 \" ) , \" from \u2581 1 \u2581 to \u2581 \" , $ n , \" \u2581 is \u2581 \" , sumOfDigitsFrom1ToN ( $ n ) ; ? >"}
{"text":"Count possible ways to construct buildings | Returns count of possible ways for N sections ; Base case ; 2 for one side and 4 for two sides ; countB is count of ways with a building at the end countS is count of ways with a space at the end prev_countB and prev_countS are previous values of countB and countS respectively . Initialize countB and countS for one side ; Use the above recursive formula for calculating countB and countS using previous values ; Result for one side is sum of ways ending with building and ending with space ; Result for 2 sides is square of result for one side ; Driver Code","code":"< ? php function countWays ( $ N ) { if ( $ N == 1 ) return 4 ; $ countB = 1 ; $ countS = 1 ; $ prev_countB ; $ prev_countS ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ prev_countB = $ countB ; $ prev_countS = $ countS ; $ countS = $ prev_countB + $ prev_countS ; $ countB = $ prev_countS ; } $ result = $ countS + $ countB ; return ( $ result * $ result ) ; } $ N = 3 ; echo \" Count \u2581 of \u2581 ways \u2581 for \u2581 \" , $ N , \" \u2581 sections \u2581 is \u2581 \" , countWays ( $ N ) ; ? >"}
{"text":"Count number of ways to reach a given score in a game | Returns number of ways to reach score n ; table [ i ] will store count of solutions for value i . Initialize all table values as 0 ; Base case ( If given value is 0 ) ; One by one consider given 3 moves and update the table [ ] values after the index greater than or equal to the value of the picked move ; Driver Code","code":"< ? php function counts ( $ n ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) $ table [ $ j ] = 0 ; $ table [ 0 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 3 ] ; for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 5 ] ; for ( $ i = 10 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 10 ] ; return $ table [ $ n ] ; } $ n = 20 ; echo \" Count \u2581 for \u2581 \" ; echo ( $ n ) ; echo ( \" \u2581 is \u2581 \" ) ; echo counts ( $ n ) ; $ n = 13 ; echo ( \" STRNEWLINE \" ) ; echo \" Count \u2581 for \u2581 \" ; echo ( $ n ) ; echo ( \" \u2581 is \u2581 \" ) ; echo counts ( $ n ) ; ? >"}
{"text":"Naive algorithm for Pattern Searching | PHP program for Naive Pattern Searching algorithm ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver Code","code":"< ? php function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) echo \" Pattern \u2581 found \u2581 at \u2581 index \u2581 \" , $ i . \" STRNEWLINE \" ; } } $ txt = \" AABAACAADAABAAABAA \" ; $ pat = \" AABA \" ; search ( $ pat , $ txt ) ; ? >"}
{"text":"Rabin | d is the number of characters in the input alphabet ; pat -> pattern txt -> text q -> A prime number ; hash value ; for pattern hash value ; The value of h would be \" pow ( d , \u2581 M - 1 ) % q \" ; Calculate the hash value of pattern and first window of text ; Slide the pattern over text one by one ; Check the hash values of current window of text and pattern . If the hash values match then only check for characters on by one ; Check for characters one by one ; if p == t and pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Calculate hash value for next window of text : Remove leading digit , add trailing digit ; We might get negative value of t , converting it to positive ; Driver Code ; A prime number ; Function Call","code":"< ? php $ d = 256 ; function search ( $ pat , $ txt , $ q ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i ; $ j ; $ p = 0 ; $ t = 0 ; $ h = 1 ; $ d = 1 ; for ( $ i = 0 ; $ i < $ M - 1 ; $ i ++ ) $ h = ( $ h * $ d ) % $ q ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { $ p = ( $ d * $ p + $ pat [ $ i ] ) % $ q ; $ t = ( $ d * $ t + $ txt [ $ i ] ) % $ q ; } for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { if ( $ p == $ t ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; } if ( $ j == $ M ) echo \" Pattern \u2581 found \u2581 at \u2581 index \u2581 \" , $ i , \" STRNEWLINE \" ; } if ( $ i < $ N - $ M ) { $ t = ( $ d * ( $ t - $ txt [ $ i ] * $ h ) + $ txt [ $ i + $ M ] ) % $ q ; if ( $ t < 0 ) $ t = ( $ t + $ q ) ; } } } $ txt = \" GEEKS \u2581 FOR \u2581 GEEKS \" ; $ pat = \" GEEK \" ; $ q = 101 ; search ( $ pat , $ txt , $ q ) ; ? >"}
{"text":"Optimized Naive Algorithm for Pattern Searching | A modified Naive Pettern Searching algorithn that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver Code","code":"< ? php function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( \" Pattern \u2581 found \u2581 at \u2581 index \u2581 $ i \" . \" STRNEWLINE \" ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } } $ txt = \" ABCEABCDABCEABCD \" ; $ pat = \" ABCD \" ; search ( $ pat , $ txt ) ; ? >"}
{"text":"Print all possible strings that can be made by placing spaces | Function recursively prints the strings having space pattern . i and j are indices in ' str [ ] ' and ' buff [ ] ' respectively ; Either put the character ; Or put a space followed by next character ; This function creates buf [ ] to store individual output string and uses printPatternUtil ( ) to print all permutations . ; Buffer to hold the string containing spaces 2 n - 1 characters and 1 string terminator ; Copy the first character as it is , since it will be always at first position ; Driver code","code":"< ? php function printPatternUtil ( $ str , $ buff , $ i , $ j , $ n ) { if ( $ i == $ n ) { $ buff [ $ j ] = ' ' ; echo str_replace ( ' , \u2581 ' , ' ' , implode ( ' , \u2581 ' , $ buff ) ) . \" STRNEWLINE \" ; return ; } $ buff [ $ j ] = $ str [ $ i ] ; printPatternUtil ( $ str , $ buff , $ i + 1 , $ j + 1 , $ n ) ; $ buff [ $ j ] = ' \u2581 ' ; $ buff [ $ j + 1 ] = $ str [ $ i ] ; printPatternUtil ( $ str , $ buff , $ i +1 , $ j + 2 , $ n ) ; } function printPattern ( $ str ) { $ n = strlen ( $ str ) ; $ buf = array_fill ( 0 , 2 * $ n , null ) ; $ buf [ 0 ] = $ str [ 0 ] ; printPatternUtil ( $ str , $ buf , 1 , 1 , $ n ) ; } $ str = \" ABCD \" ; printPattern ( $ str ) ; ? >"}
{"text":"Median of two sorted arrays of same size | This function returns median of ar1 [ ] and ar2 [ ] . Assumptions in this function : Both ar1 [ ] and ar2 [ ] are sorted arrays Both have n elements ; Since there are 2 n elements , median will be average of elements at index n - 1 and n in the array obtained after merging ar1 and ar2 ; Below is to handle case where all elements of ar1 [ ] are smaller than smallest ( or first ) element of ar2 [ ] ; Below is to handle case where all elements of ar2 [ ] are smaller than smallest ( or first ) element of ar1 [ ] ; equals sign because if two arrays have some common elements ; Store the prev median ; Store the prev median ; Driver Code","code":"< ? php function getMedian ( $ ar1 , $ ar2 , $ n ) { $ i = 0 ; $ j = 0 ; $ count ; $ m1 = -1 ; $ m2 = -1 ; for ( $ count = 0 ; $ count <= $ n ; $ count ++ ) { if ( $ i == $ n ) { $ m1 = $ m2 ; $ m2 = $ ar2 [ 0 ] ; break ; } else if ( $ j == $ n ) { $ m1 = $ m2 ; $ m2 = $ ar1 [ 0 ] ; break ; } if ( $ ar1 [ $ i ] <= $ ar2 [ $ j ] ) { $ m1 = $ m2 ; $ m2 = $ ar1 [ $ i ] ; $ i ++ ; } else { $ m1 = $ m2 ; $ m2 = $ ar2 [ $ j ] ; $ j ++ ; } } return ( $ m1 + $ m2 ) \/ 2 ; } $ ar1 = array ( 1 , 12 , 15 , 26 , 38 ) ; $ ar2 = array ( 2 , 13 , 17 , 30 , 45 ) ; $ n1 = sizeof ( $ ar1 ) ; $ n2 = sizeof ( $ ar2 ) ; if ( $ n1 == $ n2 ) echo ( \" Median \u2581 is \u2581 \" . getMedian ( $ ar1 , $ ar2 , $ n1 ) ) ; else echo ( \" Doesn ' t \u2581 work \u2581 for \u2581 arrays \" . \" of \u2581 unequal \u2581 size \" ) ; ? >"}
{"text":"Check whether a given point lies inside a triangle or not | A utility function to calculate area of triangle formed by ( x1 , y1 ) , ( x2 , y2 ) and ( x3 , y3 ) ; A function to check whether P ( x , y ) lies inside the triangle formed by A ( x1 , y1 ) , B ( x2 , y2 ) and C ( x3 , y3 ) ; Calculate area of triangle ABC ; Calculate area of triangle PBC ; Calculate area of triangle PAC ; Calculate area of triangle PAB ; Check if sum of A1 , A2 and A3 is same as A ; Let us check whether the P ( 10 , 15 ) lies inside the triangle formed by A ( 0 , 0 ) , B ( 20 , 0 ) and C ( 10 , 30 )","code":"< ? php function area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) { return abs ( ( $ x1 * ( $ y2 - $ y3 ) + $ x2 * ( $ y3 - $ y1 ) + $ x3 * ( $ y1 - $ y2 ) ) \/ 2.0 ) ; } function isInside ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x , $ y ) { $ A = area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ A1 = area ( $ x , $ y , $ x2 , $ y2 , $ x3 , $ y3 ) ; $ A2 = area ( $ x1 , $ y1 , $ x , $ y , $ x3 , $ y3 ) ; $ A3 = area ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) ; return ( $ A == $ A1 + $ A2 + $ A3 ) ; } if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) echo \" Inside \" ; else echo \" Not \u2581 Inside \" ; ? >"}
{"text":"Lucky Numbers | Returns 1 if n is a lucky no . ohterwise returns 0 ; variable next_position is just for readability of the program we can remove it and use n only ; calculate next position of input no ; Driver Code","code":"< ? php function isLucky ( $ n ) { $ counter = 2 ; $ next_position = $ n ; if ( $ counter > $ n ) return 1 ; if ( $ n % $ counter == 0 ) return 0 ; $ next_position -= $ next_position \/ $ counter ; $ counter ++ ; return isLucky ( $ next_position ) ; } $ x = 5 ; if ( isLucky ( $ x ) ) echo $ x , \" \u2581 is \u2581 a \u2581 lucky \u2581 no . \" ; else echo $ x , \" \u2581 is \u2581 not \u2581 a \u2581 lucky \u2581 no . \" ; ? >"}
{"text":"Write you own Power without using multiplication ( * ) and division ( \/ ) operators | Works only if a >= 0 and b >= 0 ; Driver Code","code":"< ? php function poww ( $ a , $ b ) { if ( $ b == 0 ) return 1 ; $ answer = $ a ; $ increment = $ a ; $ i ; $ j ; for ( $ i = 1 ; $ i < $ b ; $ i ++ ) { for ( $ j = 1 ; $ j < $ a ; $ j ++ ) { $ answer += $ increment ; } $ increment = $ answer ; } return $ answer ; } echo ( poww ( 5 , 3 ) ) ; ? >"}
{"text":"Write you own Power without using multiplication ( * ) and division ( \/ ) operators | A recursive function to get x * y ; A recursive function to get a ^ b Works only if a >= 0 and b >= 0 ; Driver Code","code":"< ? php function multiply ( $ x , $ y ) { if ( $ y ) return ( $ x + multiply ( $ x , $ y - 1 ) ) ; else return 0 ; } function p_ow ( $ a , $ b ) { if ( $ b ) return multiply ( $ a , p_ow ( $ a , $ b - 1 ) ) ; else return 1 ; } echo pow ( 5 , 3 ) ; ? >"}
{"text":"Count numbers that don 't contain 3 | returns count of numbers which are in range from 1 to n and don 't contain 3 as a digit  ; Base cases ( Assuming n is not negative ) ; Calculate 10 ^ ( d - 1 ) ( 10 raise to the power d - 1 ) where d is number of digits in n . po will be 100 for n = 578 ; find the most significant digit ( msd is 5 for 578 ) ; For 578 , total will be 4 * count ( 10 ^ 2 - 1 ) + 4 + count ( 78 ) ; For 35 , total will be equal to count ( 29 ) ; Driver program to test above function","code":"< ? php function count1 ( $ n ) { if ( $ n < 3 ) return $ n ; if ( $ n >= 3 && $ n < 10 ) return $ n - 1 ; $ po = 1 ; for ( $ x = intval ( $ n \/ $ po ) ; $ x > 9 ; $ x = intval ( $ n \/ $ po ) ) $ po = $ po * 10 ; $ msd = intval ( $ n \/ $ po ) ; if ( $ msd != 3 ) return count1 ( $ msd ) * count1 ( $ po - 1 ) + count1 ( $ msd ) + count1 ( $ n % $ po ) ; else return count1 ( $ msd * $ po - 1 ) ; } echo count1 ( 578 ) ; ? >"}
{"text":"Number which has the maximum number of distinct prime factors in the range M to N | Function to return the maximum number ; array to store the number of distinct primes ; true if index ' i ' is a prime ; initializing the number of factors to 0 and ; Used in Sieve ; condition works only when ' i ' is prime , hence for factors of all prime number , the prime status is changed to false ; Number is prime ; number of factor of a prime number is 1 ; incrementing factorCount all the factors of i ; and changing prime status to false ; Initialize the max and num ; Gets the maximum number ; Gets the maximum number ; Driver code ; Calling function","code":"< ? php function maximumNumberDistinctPrimeRange ( $ m , $ n ) { $ factorCount = array ( ) ; $ prime = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ factorCount [ $ i ] = 0 ; $ prime [ $ i ] = true ; } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] == true ) { $ factorCount [ $ i ] = 1 ; for ( $ j = $ i * 2 ; $ j <= $ n ; $ j += $ i ) { $ factorCount [ $ j ] ++ ; $ prime [ $ j ] = false ; } } } $ max = $ factorCount [ $ m ] ; $ num = $ m ; for ( $ i = $ m ; $ i <= $ n ; $ i ++ ) { if ( $ factorCount [ $ i ] > $ max ) { $ max = $ factorCount [ $ i ] ; $ num = $ i ; } } return $ num ; } $ m = 4 ; $ n = 6 ; echo maximumNumberDistinctPrimeRange ( $ m , $ n ) ; ? >"}
{"text":"Lexicographic rank of a string | A utility function to find factorial of n ; A utility function to count smaller characters on right of arr [ low ] ; A function to find rank of a string in all permutations of characters ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Driver Code","code":"< ? php function fact ( $ n ) { return ( $ n <= 1 ) ? 1 : $ n * fact ( $ n - 1 ) ; } function findSmallerInRight ( $ str , $ low , $ high ) { $ countRight = 0 ; for ( $ i = $ low + 1 ; $ i <= $ high ; ++ $ i ) if ( $ str [ $ i ] < $ str [ $ low ] ) ++ $ countRight ; return $ countRight ; } function findRank ( $ str ) { $ len = strlen ( $ str ) ; $ mul = fact ( $ len ) ; $ rank = 1 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { $ mul \/= $ len - $ i ; $ countRight = findSmallerInRight ( $ str , $ i , $ len - 1 ) ; $ rank += $ countRight * $ mul ; } return $ rank ; } $ str = \" string \" ; echo findRank ( $ str ) ; ? >"}
{"text":"Lexicographic rank of a string | A O ( n ) solution for finding rank of string ; all elements of count [ ] are initialized with 0 ; A utility function to find factorial of n ; Construct a count array where value at every index contains count of smaller characters in whole string ; Removes a character ch from count [ ] array constructed by populateAndIncreaseCount ( ) ; A function to find rank of a string in all permutations of characters ; Populate the count array such that count [ i ] contains count of characters which are present in str and are smaller than i ; count number of chars smaller than str [ i ] fron str [ i + 1 ] to str [ len - 1 ] ; Reduce count of characters greater than str [ i ] ; Driver code","code":"< ? php $ MAX_CHAR = 256 ; $ count = array_fill ( 0 , $ MAX_CHAR + 1 , 0 ) ; function fact ( $ n ) { return ( $ n <= 1 ) ? 1 : $ n * fact ( $ n - 1 ) ; } function populateAndIncreaseCount ( & $ count , $ str ) { global $ MAX_CHAR ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) ++ $ count [ ord ( $ str [ $ i ] ) ] ; for ( $ i = 1 ; $ i < $ MAX_CHAR ; ++ $ i ) $ count [ $ i ] += $ count [ $ i - 1 ] ; } function updatecount ( & $ count , $ ch ) { global $ MAX_CHAR ; for ( $ i = ord ( $ ch ) ; $ i < $ MAX_CHAR ; ++ $ i ) -- $ count [ $ i ] ; } function findRank ( $ str ) { global $ MAX_CHAR ; $ len = strlen ( $ str ) ; $ mul = fact ( $ len ) ; $ rank = 1 ; populateAndIncreaseCount ( $ count , $ str ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { $ mul = ( int ) ( $ mul \/ ( $ len - $ i ) ) ; $ rank += $ count [ ord ( $ str [ $ i ] ) - 1 ] * $ mul ; updatecount ( $ count , $ str [ $ i ] ) ; } return $ rank ; } $ str = \" string \" ; echo findRank ( $ str ) ; ? >"}
{"text":"Efficient program to calculate e ^ x | Returns approximate value of e ^ x using sum of first n terms of Taylor Series ; initialize sum of series ; Driver Code","code":"< ? php function exponential ( $ n , $ x ) { $ sum = 1.0 ; for ( $ i = $ n - 1 ; $ i > 0 ; -- $ i ) $ sum = 1 + $ x * $ sum \/ $ i ; return $ sum ; } $ n = 10 ; $ x = 1.0 ; echo ( \" e ^ x \u2581 = \u2581 \" . exponential ( $ n , $ x ) ) ; ? >"}
{"text":"How to check if a given number is Fibonacci number ? | A utility function that returns true if x is perfect square ; Returns true if n is a Fibinacci Number , else false ; n is Fibinacci if one of 5 * n * n + 4 or 5 * n * n - 4 or both is a perferct square ; Driver Code","code":"< ? php function isPerfectSquare ( $ x ) { $ s = ( int ) ( sqrt ( $ x ) ) ; return ( $ s * $ s == $ x ) ; } function isFibonacci ( $ n ) { return isPerfectSquare ( 5 * $ n * $ n + 4 ) || isPerfectSquare ( 5 * $ n * $ n - 4 ) ; } for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) if ( isFibonacci ( $ i ) ) echo \" $ i \u2581 is \u2581 a \u2581 Fibonacci \u2581 Number \u2581 STRNEWLINE \" ; else echo \" $ i \u2581 is \u2581 a \u2581 not \u2581 Fibonacci \u2581 Number \u2581 STRNEWLINE \" ; ? >"}
{"text":"Count trailing zeroes in factorial of a number | Function to return trailing 0 s in factorial of n ; Initialize result ; Keep dividing n by powers of 5 and update count ; Driver Code","code":"< ? php function findTrailingZeros ( $ n ) { $ count = 0 ; for ( $ i = 5 ; $ n \/ $ i >= 1 ; $ i *= 5 ) $ count += $ n \/ $ i ; return $ count ; } $ n = 100 ; echo \" Count \u2581 of \u2581 trailing \u2581 0s \u2581 in \u2581 \" , 100 , \" ! \u2581 is \u2581 \" , findTrailingZeros ( $ n ) ; ? >"}
{"text":"Program for nth Catalan Number | A recursive function to find nth catalan number ; Base case ; catalan ( n ) is sum of catalan ( i ) * catalan ( n - i - 1 ) ; Driver Code","code":"< ? php function catalan ( $ n ) { if ( $ n <= 1 ) return 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += catalan ( $ i ) * catalan ( $ n - $ i - 1 ) ; return $ res ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) echo catalan ( $ i ) , \" \u2581 \" ; ? >"}
{"text":"Program for nth Catalan Number | PHP program for nth Catalan Number A dynamic programming based function to find nth Catalan number ; Table to store results of subproblems ; Initialize first two values in table ; Fill entries in catalan [ ] using recursive formula ; Return last entry ; Driver Code","code":"< ? php function catalanDP ( $ n ) { $ catalan = array ( ) ; $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } return $ catalan [ $ n ] ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) echo catalanDP ( $ i ) , \" \u2581 \" ;"}
{"text":"Program for nth Catalan Number | Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn \/ ( n + 1 ) ; Driver code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res = floor ( $ res \/ ( $ i + 1 ) ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * ( $ n ) , $ n ) ; return floor ( $ c \/ ( $ n + 1 ) ) ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) echo catalan ( $ i ) , \" \u2581 \" ; ? >"}
{"text":"Calculate the angle between hour hand and minute hand | Utility function to find minimum of two integers ; Function to calculate the angle ; validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Driver Code","code":"< ? php function mintwo ( $ x , $ y ) { return ( $ x < $ y ) ? $ x : $ y ; } function calcAngle ( $ h , $ m ) { if ( $ h < 0 $ m < 0 $ h > 12 $ m > 60 ) echo \" Wrong \u2581 input \" ; if ( $ h == 12 ) $ h = 0 ; if ( $ m == 60 ) { $ m = 0 ; $ h += 1 ; if ( $ h > 12 ) $ h = $ h - 12 ; } $ hour_angle = 0.5 * ( $ h * 60 + $ m ) ; $ minute_angle = 6 * $ m ; $ angle = abs ( $ hour_angle - $ minute_angle ) ; $ angle = min ( 360 - $ angle , $ angle ) ; return $ angle ; } echo calcAngle ( 9 , 60 ) , \" STRNEWLINE \" ; echo calcAngle ( 3 , 30 ) , \" STRNEWLINE \" ; ? >"}
{"text":"How to check if an instance of 8 puzzle is solvable ? | A utility function to count inversions in given array ' arr [ ] ' ; Value 0 is used for empty space ; This function returns true if given 8 puzzle is solvable . ; Count inversions in given 8 puzzle ; return true if inversion count is even . ; Driver Code","code":"< ? php function getInvCount ( $ arr ) { $ inv_count = 0 ; for ( $ i = 0 ; $ i < 9 - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < 9 ; $ j ++ ) $ inv_count ++ ; return $ inv_count ; } function isSolvable ( $ puzzle ) { $ invCount = getInvCount ( $ puzzle ) ; return ( $ invCount % 2 == 0 ) ; } $ puzzle = array ( array ( 1 , 8 , 2 ) , array ( 0 , 4 , 3 ) , array ( 7 , 6 , 5 ) ) ; if ( isSolvable ( $ puzzle ) == true ) echo \" Solvable \" ; else echo \" Not \u2581 Solvable \" ; ? >"}
{"text":"Birthday Paradox | Returns approximate number of people for a given probability ; Driver Code","code":"< ? php function find ( $ p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 \/ ( 1 - $ p ) ) ) ) ; } echo find ( 0.70 ) ; ? >"}
{"text":"Count Distinct Non | function counts number of pairs ( x , y ) that satisfy the inequality x * x + y * y < n . ; Driver Code","code":"< ? php function countSolutions ( $ n ) { $ res = 0 ; for ( $ x = 0 ; $ x * $ x < $ n ; $ x ++ ) for ( $ y = 0 ; $ x * $ x + $ y * $ y < $ n ; $ y ++ ) $ res ++ ; return $ res ; } { echo \" Total \u2581 Number \u2581 of \u2581 distinct \u2581 Non - Negative \u2581 pairs \u2581 is \u2581 \" ; echo countSolutions ( 6 ) ; return 0 ; } ? >"}
{"text":"Count Distinct Non | This function counts number of pairs ( x , y ) that satisfy the inequality x * x + y * y < n . ; Find the count of different y values for x = 0. ; One by one increase value of x , and find yCount for current x . If yCount becomes 0 , then we have reached maximum possible value of x . ; Add yCount ( count of different possible values of y for current x ) to result ; Increment x ; Update yCount for current x . Keep reducing yCount while the inequality is not satisfied . ; Driver program to test above function","code":"< ? php function countSolutions ( $ n ) { $ x = 0 ; $ yCount ; $ res = 0 ; for ( $ yCount = 0 ; $ yCount * $ yCount < $ n ; $ yCount ++ ) ; while ( $ yCount != 0 ) { $ res += $ yCount ; $ x ++ ; while ( $ yCount != 0 and ( $ x * $ x + ( $ yCount - 1 ) * ( $ yCount - 1 ) >= $ n ) ) $ yCount -- ; } return $ res ; } echo \" Total \u2581 Number \u2581 of \u2581 distinct \u2581 Non - Negative \" , \" pairs \u2581 is \u2581 \" , countSolutions ( 6 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program for Newton Raphson Method | PHP program for implementation of Newton Raphson Method for solving equations ; An example function whose solution is determined using Bisection Method . The function is x ^ 3 - x ^ 2 + 2 ; Derivative of the above function which is 3 * x ^ x - 2 * x ; Function to find the root ; x ( i + 1 ) = x ( i ) - f ( x ) \/ f '(x) ; Initial values assumed","code":"< ? php $ EPSILON = 0.001 ; function func ( $ x ) { return $ x * $ x * $ x - $ x * $ x + 2 ; } function derivFunc ( $ x ) { return 3 * $ x * $ x - 2 * $ x ; } function newtonRaphson ( $ x ) { global $ EPSILON ; $ h = func ( $ x ) \/ derivFunc ( $ x ) ; while ( abs ( $ h ) >= $ EPSILON ) { $ h = func ( $ x ) \/ derivFunc ( $ x ) ; $ x = $ x - $ h ; } echo \" The \u2581 value \u2581 of \u2581 the \u2581 \" . \" root \u2581 is \u2581 : \u2581 \" , $ x ; } $ x0 = -20 ; newtonRaphson ( $ x0 ) ; ? >"}
{"text":"Find the element that appears once | Method to find the element that occur only once ; The expression \" one \u2581 & \u2581 arr [ i ] \" gives the bits that are there in both ' ones ' and new element from arr [ ] . We add these bits to ' twos ' using bitwise OR Value of ' twos ' will be set as 0 , 3 , 3 and 1 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; XOR the new bits with previous ' ones ' to get all bits appearing odd number of times Value of ' ones ' will be set as 3 , 0 , 2 and 3 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; The common bits are those bits which appear third time . So these bits should not be there in both ' ones ' and ' twos ' . common_bit_mask contains all these bits as 0 , so that the bits can be removed from ' ones ' and ' twos ' Value of ' common _ bit _ mask ' will be set as 00 , 00 , 01 and 10 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; Remove common bits ( the bits that appear third time ) from ' ones ' Value of ' ones ' will be set as 3 , 0 , 0 and 2 after 1 st , 2 nd , 3 rd and 4 th iterations respectively ; Remove common bits ( the bits that appear third time ) from ' twos ' Value of ' twos ' will be set as 0 , 3 , 1 and 0 after 1 st , 2 nd , 3 rd and 4 th itearations respectively ; Driver Code","code":"< ? php function getSingle ( $ arr , $ n ) { $ ones = 0 ; $ twos = 0 ; $ common_bit_mask ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ twos = $ twos | ( $ ones & $ arr [ $ i ] ) ; $ ones = $ ones ^ $ arr [ $ i ] ; $ common_bit_mask = ~ ( $ ones & $ twos ) ; $ ones &= $ common_bit_mask ; $ twos &= $ common_bit_mask ; } return $ ones ; } $ arr = array ( 3 , 3 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" The \u2581 element \u2581 with \u2581 single \u2581 \" . \" occurrence \u2581 is \u2581 \" , getSingle ( $ arr , $ n ) ; ? >"}
{"text":"Find the element that appears once | PHP code to find the element that occur only once ; Initialize result ; Iterate through every bit ; Find sum of set bits at ith position in all array elements ; The bits with sum not multiple of 3 , are the bits of element with single occurrence . ; Driver Code","code":"< ? php $ INT_SIZE = 32 ; function getSingle ( $ arr , $ n ) { global $ INT_SIZE ; $ result = 0 ; $ x ; $ sum ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) { $ sum = 0 ; $ x = ( 1 << $ i ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & $ x ) $ sum ++ ; } if ( ( $ sum % 3 ) != 0 ) $ result |= $ x ; } return $ result ; } $ arr = array ( 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ) ; $ n = sizeof ( $ arr ) ; echo \" The \u2581 element \u2581 with \u2581 single \u2581 occurrence \u2581 is \u2581 \" , getSingle ( $ arr , $ n ) ; ? >"}
{"text":"Detect if two integers have opposite signs | Function to detect signs ; Driver Code","code":"< ? php function oppositeSigns ( $ x , $ y ) { return ( ( $ x ^ $ y ) < 0 ) ; } $ x = 100 ; $ y = -100 ; if ( oppositeSigns ( $ x , $ y ) == true ) echo ( \" Signs \u2581 are \u2581 opposite \" ) ; else echo ( \" Signs \u2581 are \u2581 not \u2581 opposite \" ) ; ? >"}
{"text":"Count total set bits in all numbers from 1 to n | Returns count of set bits present in all numbers from 1 to n ; initialize the result ; A utility function to count set bits in a number x ; Driver Code","code":"< ? php function countSetBits ( $ n ) { $ bitCount = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ bitCount += countSetBitsUtil ( $ i ) ; return $ bitCount ; } function countSetBitsUtil ( $ x ) { if ( $ x <= 0 ) return 0 ; return ( $ x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( $ x \/ 2 ) ; } $ n = 4 ; echo \" Total \u2581 set \u2581 bit \u2581 count \u2581 is \u2581 \" . countSetBits ( $ n ) ; ? >"}
{"text":"Count total set bits in all numbers from 1 to n | Function which counts set bits from 0 to n ; ans store sum of set bits from 0 to n ; while n greater than equal to 2 ^ i ; This k will get flipped after 2 ^ i iterations ; change is iterator from 2 ^ i to 1 ; This will loop from 0 to n for every bit position ; When change = 1 flip the bit ; again set change to 2 ^ i ; increment the position ; Driver code","code":"< ? php function countSetBits ( $ n ) { $ i = 0 ; $ ans = 0 ; while ( ( 1 << $ i ) <= $ n ) { $ k = 0 ; $ change = 1 << $ i ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { $ ans += $ k ; if ( $ change == 1 ) { $ k = ! $ k ; $ change = 1 << $ i ; } else { $ change -- ; } } $ i ++ ; } return $ ans ; } $ n = 17 ; echo ( countSetBits ( $ n ) ) ; ? >"}
{"text":"Swap bits in a given number | PHP Program to swap bits in a given number function returns the swapped bits ; Move all bits of first set to rightmost side ; Move all bits of second set to rightmost side ; XOR the two sets ; Put the xor bits back to their original positions ; XOR the ' xor ' with the original number so that the two sets are swapped ; Driver Code","code":"< ? php function swapBits ( $ x , $ p1 , $ p2 , $ n ) { $ set1 = ( $ x >> $ p1 ) & ( ( 1 << $ n ) - 1 ) ; $ set2 = ( $ x >> $ p2 ) & ( ( 1 << $ n ) - 1 ) ; $ xor = ( $ set1 ^ $ set2 ) ; $ xor = ( $ xor << $ p1 ) | ( $ xor << $ p2 ) ; $ result = $ x ^ $ xor ; return $ result ; } $ res = swapBits ( 28 , 0 , 3 , 2 ) ; echo \" Result = \" ? >"}
{"text":"Smallest of three integers without comparison operators | php program to find Smallest of three integers without comparison operators ; Driver code","code":"< ? php function smallest ( $ x , $ y , $ z ) { $ c = 0 ; while ( $ x && $ y && $ z ) { $ x -- ; $ y -- ; $ z -- ; $ c ++ ; } return $ c ; } $ x = 12 ; $ y = 15 ; $ z = 5 ; echo \" Minimum \u2581 of \u2581 3 \u2581 numbers \u2581 is \u2581 \" . smallest ( $ x , $ y , $ z ) ; ? >"}
{"text":"Next higher number with same number of set bits | This function returns next higher number with same number of set bits as x . ; right most set bit ; reset the pattern and set next higher bit left part of x will be here ; nextHigherOneBit is now part [ D ] of the above explanation . isolate the pattern ; right adjust pattern ; correction factor ; rightOnesPattern is now part [ A ] of the above explanation . integrate new pattern ( Add [ D ] and [ A ] ) ; Driver Code","code":"< ? php function snoob ( $ x ) { $ next = 0 ; if ( $ x ) { $ rightOne = $ x & - $ x ; $ nextHigherOneBit = $ x + $ rightOne ; $ rightOnesPattern = $ x ^ $ nextHigherOneBit ; $ rightOnesPattern = intval ( ( $ rightOnesPattern ) \/ $ rightOne ) ; $ rightOnesPattern >>= 2 ; $ next = $ nextHigherOneBit | $ rightOnesPattern ; } return $ next ; } $ x = 156 ; echo \" Next \u2581 higher \u2581 number \u2581 with \u2581 same \u2581 \" . \" number \u2581 of \u2581 set \u2581 bits \u2581 is \u2581 \" . snoob ( $ x ) ; ? >"}
{"text":"Add 1 to a given number | PHP code to add add one to a given number ; Flip all the set bits until we find a 0 ; flip the rightmost 0 bit ; Driver Code","code":"< ? php function addOne ( $ x ) { $ m = 1 ; while ( $ x & $ m ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; } echo addOne ( 13 ) ; ? >"}
{"text":"Add 1 to a given number | PHP Code to Add 1 to a given number ; Driver Code","code":"< ? php function addOne ( $ x ) { return ( - ( ~ $ x ) ) ; } echo addOne ( 13 ) ; ? >"}
{"text":"Multiply a given Integer with 3.5 | PHP program to multiply a number with 3.5 ; Driver Code","code":"< ? php function multiplyWith3Point5 ( $ x ) { return ( $ x << 1 ) + $ x + ( $ x >> 1 ) ; } $ x = 4 ; echo multiplyWith3Point5 ( $ x ) ; ? >"}
{"text":"Turn off the rightmost set bit | unsets the rightmost set bit of n and returns the result ; Driver Code","code":"< ? php function fun ( $ n ) { return $ n & ( $ n - 1 ) ; } $ n = 7 ; echo \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \" . \" \u2581 rightmost \u2581 set \u2581 bit \u2581 \" , fun ( $ n ) ; ? >"}
{"text":"Find whether a given number is a power of 4 or not | Function to check if x is power of 4 ; Driver Code","code":"< ? php function isPowerOfFour ( $ n ) { if ( $ n == 0 ) return 0 ; while ( $ n != 1 ) { if ( $ n % 4 != 0 ) return 0 ; $ n = $ n \/ 4 ; } return 1 ; } $ test_no = 64 ; if ( isPowerOfFour ( $ test_no ) ) echo $ test_no , \" \u2581 is \u2581 a \u2581 power \u2581 of \u2581 4\" ; else echo $ test_no , \" \u2581 is \u2581 not \u2581 a \u2581 power \u2581 of \u2581 4\" ; ? >"}
{"text":"Find whether a given number is a power of 4 or not | Function to check if x is power of 4 ; Check if there is only one bit set in n ; count 0 bits before set bit ; If count is even then return true else false ; If there are more than 1 bit set then n is not a power of 4 ; Driver program to test above function","code":"< ? php function isPowerOfFour ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) { while ( $ n > 1 ) { $ n >>= 1 ; $ count += 1 ; } return ( $ count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } $ test_no = 64 ; if ( isPowerOfFour ( $ test_no ) ) echo $ test_no , \" \u2581 is \u2581 a \u2581 power \u2581 of \u2581 4\" ; else echo $ test_no , \" \u2581 not \u2581 is \u2581 a \u2581 power \u2581 of \u2581 4\" ; ? >"}
{"text":"Compute the minimum or maximum of two integers without branching | Function to find minimum of x and y ; Function to find maximum of x and y ; Driver Code","code":"< ? php function m_in ( $ x , $ y ) { return $ y ^ ( ( $ x ^ $ y ) & - ( $ x < $ y ) ) ; } function m_ax ( $ x , $ y ) { return $ x ^ ( ( $ x ^ $ y ) & - ( $ x < $ y ) ) ; } $ x = 15 ; $ y = 6 ; echo \" Minimum \u2581 of \" , \" \u2581 \" , $ x , \" \u2581 \" , \" and \" , \" \u2581 \" , $ y , \" \u2581 \" , \" \u2581 is \u2581 \" , \" \u2581 \" ; echo m_in ( $ x , $ y ) ; echo \" Maximum of \" , \" \" , $ x , \" \" , STRNEWLINE TABSYMBOL \" and \" , \" \" , $ y , \" \" , \u2581 \" is \" echo m_ax ( $ x , $ y ) ; ? >"}
{"text":"Find the Number Occurring Odd Number of Times | Function to find the element occurring odd number of times ; Driver code ; Function calling","code":"< ? php function getOddOccurrence ( & $ arr , $ arr_size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = 0 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count % 2 != 0 ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ) ; $ n = sizeof ( $ arr ) ; echo ( getOddOccurrence ( $ arr , $ n ) ) ; ? >"}
{"text":"Count number of bits to be flipped to convert A to B | Function that count set bits ; Function that return count of flipped number ; Return count of set bits in a XOR b ; Driver code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += 1 ; $ n &= ( n - 1 ) ; } return $ count ; } function FlippedCount ( $ a , $ b ) { return countSetBits ( $ a ^ $ b ) ; } $ a = 10 ; $ b = 20 ; echo FlippedCount ( $ a , $ b ) ; ? >"}
{"text":"Position of rightmost set bit | PHP Code for Position of rightmost set bit ; Driver Code","code":"< ? php function getFirstSetBitPos ( $ n ) { return ceil ( log ( ( $ n & - $ n ) + 1 , 2 ) ) ; } $ n = 12 ; echo getFirstSetBitPos ( $ n ) ; ? >"}
{"text":"Position of rightmost set bit | function to find the rightmost set bit ; Position variable initialize with 1 m variable is used to check the set bit ; left shift ; Driver Code ; function call","code":"< ? php function PositionRightmostSetbit ( $ n ) { $ position = 1 ; $ m = 1 ; while ( ! ( $ n & $ m ) ) { $ m = $ m << 1 ; $ position ++ ; } return $ position ; } $ n = 16 ; echo PositionRightmostSetbit ( $ n ) ; ? >"}
{"text":"Position of rightmost set bit | PHP implementation of above approach ; counting the position of first set bit ; Driver code","code":"< ? php function Right_most_setbit ( $ num ) { $ pos = 1 ; $ INT_SIZE = 32 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) { if ( ! ( $ num & ( 1 << $ i ) ) ) $ pos ++ ; else break ; } return $ pos ; } $ num = 18 ; $ pos = Right_most_setbit ( $ num ) ; echo $ pos ; echo ( \" STRNEWLINE \" ) ? >"}
{"text":"Binary representation of a given number | Function to convert decimal to binary number ; Driver code","code":"< ? php function bin ( $ n ) { if ( $ n > 1 ) bin ( $ n >> 1 ) ; echo ( $ n & 1 ) ; } bin ( 131 ) ; echo \" STRNEWLINE \" ; bin ( 3 ) ;"}
{"text":"Swap all odd and even bits | Function to swap even and odd bits ; Get all even bits of x ; Get all odd bits of x ; Right shift even bits ; Left shift odd bits ; Combine even and odd bits ; 00010111 ; Output is 43 ( 00101011 )","code":"< ? php function swapBits ( $ x ) { $ even_bits = $ x & 0xAAAAAAAA ; $ odd_bits = $ x & 0x55555555 ; $ even_bits >>= 1 ; $ odd_bits <<= 1 ; return ( $ even_bits $ odd_bits ) ; } $ x = 23 ; echo swapBits ( $ x ) ; ? >"}
{"text":"Find position of the only set bit | A utility function to check whether n is power of 2 or goo . gl \/ 17 Arj not . See http : ; Returns position of the only set bit in ' n ' ; Iterate through bits of n till we find a set bit i & n will be non - zero only when ' i ' and ' n ' have a set bit at same position ; Unset current bit and set the next bit in ' i ' ; increment position ; Driver Code","code":"< ? php function isPowerOfTwo ( $ n ) { return $ n && ( ! ( $ n & ( $ n - 1 ) ) ) ; } function findPosition ( $ n ) { if ( ! isPowerOfTwo ( $ n ) ) return -1 ; $ i = 1 ; $ pos = 1 ; while ( ! ( $ i & $ n ) ) { $ i = $ i << 1 ; ++ $ pos ; } return $ pos ; } $ n = 16 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , \u2581 \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , \u2581 $ pos , \u2581 \" \" $ n = 12 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , \u2581 \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , \u2581 $ pos , \u2581 \" \" $ n = 128 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , \u2581 \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , \u2581 $ pos , \u2581 \" \" ? >"}
{"text":"Find position of the only set bit | A utility function to check whether n is power of 2 or not ; Returns position of the only set bit in ' n ' ; One by one move the only set bit to right till it reaches end ; increment count of shifts ; Driver Code","code":"< ? php function isPowerOfTwo ( $ n ) { return $ n && ( ! ( $ n & ( $ n - 1 ) ) ) ; } function findPosition ( $ n ) { if ( ! isPowerOfTwo ( $ n ) ) return -1 ; $ count = 0 ; while ( $ n ) { $ n = $ n >> 1 ; ++ $ count ; } return $ count ; } $ n = 0 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL \" Invalid number \" , \u2581 \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL echo \u2581 \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL \" Position \" , \u2581 $ pos , \u2581 \" \" $ n = 12 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , \u2581 \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" n = \" , \u2581 $ n , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , \u2581 $ pos , \u2581 \" \" $ n = 128 ; $ pos = findPosition ( $ n ) ; if ( ( $ pos == -1 ) == true ) echo \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Invalid number \" , \u2581 \" \" ; STRNEWLINE else STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" n = \" , \u2581 $ n , \u2581 \" , \" , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" Position \" , \u2581 $ pos , \u2581 \" \" ? >"}
{"text":"How to swap two numbers without using a temporary variable ? | Driver code ; Code to swap ' x ' and ' y ' x now becomes 50 ; y becomes 10 ; x becomes 5","code":"< ? php $ x = 10 ; $ y = 5 ; $ x = $ x * $ y ; $ y = $ x \/ $ y ; $ x = $ x \/ $ y ; echo \" After \u2581 Swapping : \u2581 x \u2581 = \u2581 \" , $ x , \" \u2581 \" , \" y \u2581 = \u2581 \" , $ y ; ? >"}
{"text":"How to swap two numbers without using a temporary variable ? | PHP code to swap using XOR ; Code to swap ' x ' ( 1010 ) and ' y ' ( 0101 ) x now becomes 15 ( 1111 ) ; y becomes 10 ( 1010 ) ; x becomes 5 ( 0101 )","code":"< ? php $ x = 10 ; $ y = 5 ; $ x = $ x ^ $ y ; $ y = $ x ^ $ y ; $ x = $ x ^ $ y ; echo \" After \u2581 Swapping : \u2581 x \u2581 = \u2581 \" , $ x , \" , \u2581 \" , \" y \u2581 = \u2581 \" , $ y ; ? >"}
{"text":"How to swap two numbers without using a temporary variable ? | Swap function ; Driver Code","code":"< ? php function swap ( & $ xp , & $ yp ) { $ xp = $ xp ^ $ yp ; $ yp = $ xp ^ $ yp ; $ xp = $ xp ^ $ yp ; } $ x = 10 ; swap ( $ x , $ x ) ; print ( \" After \u2581 swap ( & x , \u2581 & x ) : \u2581 x \u2581 = \u2581 \" . $ x ) ; ? >"}
{"text":"Find Index of 0 to be replaced with 1 to get longest continuous sequence of 1 s in a binary array | Returns index of 0 to be replaced with 1 to get longest continuous sequence of 1 s . If there is no 0 in array , then it returns - 1. ; for maximum number of ; 1 around a zero for storing result ; index of previous zero ; index of previous to ; previous zero Traverse the input array ; If current element is 0 , then calculate the difference between curr and prev_prev_zero ; Update result if count of 1 s around prev_zero is more ; Update for next iteration ; Check for the last encountered zero ; Driver Code","code":"< ? php function maxOnesIndex ( $ arr , $ n ) { $ max_count = 0 ; $ max_index ; $ prev_zero = -1 ; $ prev_prev_zero = -1 ; for ( $ curr = 0 ; $ curr < $ n ; ++ $ curr ) { if ( $ arr [ $ curr ] == 0 ) { if ( $ curr - $ prev_prev_zero > $ max_count ) { $ max_count = $ curr - $ prev_prev_zero ; $ max_index = $ prev_zero ; } $ prev_prev_zero = $ prev_zero ; $ prev_zero = $ curr ; } } if ( $ n - $ prev_prev_zero > $ max_count ) $ max_index = $ prev_zero ; return $ max_index ; } $ arr = array ( 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Index \u2581 of \u2581 0 \u2581 to \u2581 be \u2581 replaced \u2581 is \u2581 \" , maxOnesIndex ( $ arr , $ n ) ; ? >"}
{"text":"Length of the largest subarray with contiguous elements | Set 1 | Utility functions to find minimum and maximum of two elements ; Returns length of the longest contiguous subarray ; Initialize result ; Initialize min and max for all subarrays starting with i ; Consider all subarrays starting with i and ending with j ; Update min and max in this subarray if needed ; If current subarray has all contiguous elements ; Return result ; Driver Code","code":"< ? php function mins ( $ x , $ y ) { if ( $ x < $ y ) return $ x ; else return $ y ; } function maxi ( $ a , $ b ) { if ( $ a > $ b ) return $ a ; else return $ b ; } function findLength ( & $ arr , $ n ) { $ max_len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ mn = $ arr [ $ i ] ; $ mx = $ arr [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mn = mins ( $ mn , $ arr [ $ j ] ) ; $ mx = maxi ( $ mx , $ arr [ $ j ] ) ; if ( ( $ mx - $ mn ) == $ j - $ i ) $ max_len = maxi ( $ max_len , $ mx - $ mn + 1 ) ; } } return $ max_len ; } $ arr = array ( 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ) ; $ n = sizeof ( $ arr ) ; echo ( \" Length \u2581 of \u2581 the \u2581 longest \u2581 contiguous \" . \" \u2581 subarray \u2581 is \u2581 \" ) ; echo ( findLength ( $ arr , $ n ) ) ; ? >"}
{"text":"Print all increasing sequences of length k from first n natural numbers | A utility function to print contents of arr [ 0. . k - 1 ] ; A recursive function to print all increasing sequences of first n natural numbers . Every sequence should be length k . The array arr [ ] is used to store current sequence . ; If length of current increasing sequence becomes k , print it ; Decide the starting number to put at current position : If length is 0 , then there are no previous elements in arr [ ] . So start putting new numbers with 1. If length is not 0 , then start from value of previous element plus 1. ; Increase length ; Put all numbers ( which are greater than the previous element ) at new position . ; This is important . The variable ' len ' is shared among all function calls in recursion tree . Its value must be brought back before next iteration of while loop ; This function prints all increasing sequences of first n natural numbers . The length of every sequence must be k . This function mainly uses printSeqUtil ( ) ; An array to store individual sequences Initial length of ; current sequence ; Driver Code","code":"< ? php function printArr ( $ arr , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } function printSeqUtil ( $ n , $ k , $ len , $ arr ) { if ( $ len == $ k ) { printArr ( $ arr , $ k ) ; return ; } $ i = ( $ len == 0 ) ? 1 : $ arr [ $ len - 1 ] + 1 ; $ len ++ ; while ( $ i <= $ n ) { $ arr [ $ len - 1 ] = $ i ; printSeqUtil ( $ n , $ k , $ len , $ arr ) ; $ i ++ ; } $ len -- ; } function printSeq ( $ n , $ k ) { $ arr = array ( ) ; $ len = 0 ; printSeqUtil ( $ n , $ k , $ len , $ arr ) ; } $ k = 3 ; $ n = 7 ; printSeq ( $ n , $ k ) ; ? >"}
{"text":"Given two strings , find if first string is a subsequence of second | Returns true if str1 [ ] is a subsequence of str2 [ ] . m is length of str1 and n is length of str2 ; Base Cases ; If last characters of two strings are matching ; If last characters are not matching ; Driver Code","code":"< ? php function isSubSequence ( $ str1 , $ str2 , $ m , $ n ) { if ( $ m == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ str1 [ $ m - 1 ] == $ str2 [ $ n - 1 ] ) return isSubSequence ( $ str1 , $ str2 , $ m - 1 , $ n - 1 ) ; return isSubSequence ( $ str1 , $ str2 , $ m , $ n - 1 ) ; } $ str1 = \" gksrek \" ; $ str2 = \" geeksforgeeks \" ; $ m = strlen ( $ str1 ) ; $ n = strlen ( $ str2 ) ; $ t = isSubSequence ( $ str1 , $ str2 , $ m , $ n ) ? \" Yes \u2581 \" : \" No \" ; if ( $ t = true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Replace every element with the greatest element on right side | Function to replace every element with the next greatest element ; Initialize the next greatest element ; The next greatest element for the rightmost element is always - 1 ; Replace all other elements with the next greatest ; Store the current element ( needed later for updating the next greatest element ) ; Replace current element with the next greatest ; Update the greatest element , if needed ; A utility Function that prints an array ; Driver Code","code":"< ? php function nextGreatest ( & $ arr , $ size ) { $ max_from_right = $ arr [ $ size - 1 ] ; $ arr [ $ size - 1 ] = -1 ; for ( $ i = $ size - 2 ; $ i >= 0 ; $ i -- ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ max_from_right ; if ( $ max_from_right < $ temp ) $ max_from_right = $ temp ; } } function printArray ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 16 , 17 , 4 , 3 , 5 , 2 ) ; $ size = count ( $ arr ) ; nextGreatest ( $ arr , $ size ) ; echo \" The \u2581 modified \u2581 array \u2581 is : \u2581 STRNEWLINE \" ; printArray ( $ arr , $ size ) ; ? >"}
{"text":"Construction of Longest Increasing Subsequence ( N log N ) | Binary search ; Add boundary case , when array n is zero Depend on smart pointers ; initialized with - 1 ; it will always point to empty location ; new smallest value ; arr [ i ] wants to extend largest subsequence ; arr [ i ] wants to be a potential condidate of future subsequence It will replace ceil value in tailIndices ; Driver code","code":"< ? php function GetCeilIndex ( $ arr , $ T , $ l , $ r , $ key ) { while ( $ r - $ l > 1 ) { $ m = ( int ) ( $ l + ( $ r - $ l ) \/ 2 ) ; if ( $ arr [ $ T [ $ m ] ] >= $ key ) $ r = $ m ; else $ l = $ m ; } return $ r ; } function LongestIncreasingSubsequence ( $ arr , $ n ) { $ tailIndices = array_fill ( 0 , $ n + 1 , 0 ) ; $ prevIndices = array_fill ( 0 , $ n + 1 , -1 ) ; $ len = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ tailIndices [ 0 ] ] ) { $ tailIndices [ 0 ] = $ i ; } else if ( $ arr [ $ i ] > $ arr [ $ tailIndices [ $ len - 1 ] ] ) { $ prevIndices [ $ i ] = $ tailIndices [ $ len - 1 ] ; $ tailIndices [ $ len ++ ] = $ i ; } else { $ pos = GetCeilIndex ( $ arr , $ tailIndices , -1 , $ len - 1 , $ arr [ $ i ] ) ; $ prevIndices [ $ i ] = $ tailIndices [ $ pos - 1 ] ; $ tailIndices [ $ pos ] = $ i ; } } echo \" LIS \u2581 of \u2581 given \u2581 input STRNEWLINE \" ; for ( $ i = $ tailIndices [ $ len - 1 ] ; $ i >= 0 ; $ i = $ prevIndices [ $ i ] ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; return $ len ; } $ arr = array ( 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ) ; $ n = count ( $ arr ) ; print ( \" LIS \u2581 size \u2581 \" . LongestIncreasingSubsequence ( $ arr , $ n ) ) ; ? >"}
{"text":"Generate all possible sorted arrays from alternate elements of two given sorted arrays | Function to generates and prints all sorted arrays from alternate elements of ' A [ i . . m - 1 ] ' and ' B [ j . . n - 1 ] ' If ' flag ' is true , then current element is to be included from A otherwise from B . ' len ' is the index in output array C [ ] . We print output array each time before including a character from A only if length of output array is greater than 0. We try than all possible combinations ; Include valid element from A ; Print output if there is at least one ' B ' in output array ' C ' ; Recur for all elements of A after current index ; this block works for the very first call to include the first element in the output array ; don 't increment lem as B  is included yet ; include valid element from A and recur ; Include valid element from B and recur ; Wrapper function ; output array ; A utility function to print an array ; Driver Code","code":"< ? php function generateUtil ( & $ A , & $ B , & $ C , $ i , $ j , $ m , $ n , $ len , $ flag ) { if ( $ flag ) { if ( $ len ) printArr ( $ C , $ len + 1 ) ; for ( $ k = $ i ; $ k < $ m ; $ k ++ ) { if ( ! $ len ) { $ C [ $ len ] = $ A [ $ k ] ; generateUtil ( $ A , $ B , $ C , $ k + 1 , $ j , $ m , $ n , $ len , ! $ flag ) ; } else { if ( $ A [ $ k ] > $ C [ $ len ] ) { $ C [ $ len + 1 ] = $ A [ $ k ] ; generateUtil ( $ A , $ B , $ C , $ k + 1 , $ j , $ m , $ n , $ len + 1 , ! $ flag ) ; } } } } else { for ( $ l = $ j ; $ l < $ n ; $ l ++ ) { if ( $ B [ $ l ] > $ C [ $ len ] ) { $ C [ $ len + 1 ] = $ B [ $ l ] ; generateUtil ( $ A , $ B , $ C , $ i , $ l + 1 , $ m , $ n , $ len + 1 , ! $ flag ) ; } } } } function generate ( & $ A , & $ B , $ m , $ n ) { $ C = array_fill ( 0 , ( $ m + $ n ) , NULL ) ; generateUtil ( $ A , $ B , $ C , 0 , 0 , $ m , $ n , 0 , true ) ; } function printArr ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ A = array ( 10 , 15 , 25 ) ; $ B = array ( 5 , 20 , 30 ) ; $ n = sizeof ( $ A ) ; $ m = sizeof ( $ B ) ; generate ( $ A , $ B , $ n , $ m ) ; ? >"}
{"text":"Replace two consecutive equal values with one greater | Function to replace consecutive equal elements ; Index in result ; to print new array ; Driver Code","code":"< ? php function replace_elements ( $ arr , $ n ) { $ pos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ pos ++ ] = $ arr [ $ i ] ; while ( $ pos > 1 && $ arr [ $ pos - 2 ] == $ arr [ $ pos - 1 ] ) { $ pos -- ; $ arr [ $ pos - 1 ] ++ ; } } for ( $ i = 0 ; $ i < $ pos ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( 6 , 4 , 3 , 4 , 3 , 3 , 5 ) ; $ n = count ( $ arr ) ; replace_elements ( $ arr , $ n ) ; ? >"}
{"text":"Rearrange a binary string as alternate x and y occurrences | Function which arrange the given string ; Counting number of 0 ' s \u2581 and \u2581 \u2581 1' s in the given string . ; Printing first all 0 ' s \u2581 x - times \u2581 \u2581 and \u2581 decrement \u2581 count \u2581 of \u2581 0' s x - times and do the similar task with '1' ; Driver Code","code":"< ? php function arrangeString ( $ str , $ x , $ y ) { $ count_0 = 0 ; $ count_1 = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) $ count_0 ++ ; else $ count_1 ++ ; } while ( $ count_0 > 0 $ count_1 > 0 ) { for ( $ j = 0 ; $ j < $ x && $ count_0 > 0 ; $ j ++ ) { if ( $ count_0 > 0 ) { echo \"0\" ; $ count_0 -- ; } } for ( $ j = 0 ; $ j < $ y && $ count_1 > 0 ; $ j ++ ) { if ( $ count_1 > 0 ) { echo \"1\" ; $ count_1 -- ; } } } } $ str = \"01101101101101101000000\" ; $ x = 1 ; $ y = 2 ; arrangeString ( $ str , $ x , $ y ) ; ? >"}
{"text":"Shuffle 2 n integers as a1 | function to rearrange the array ; if size is null or odd return because it is not possible to rearrange ; start from the middle index ; each time we will set two elements from the start to the valid position by swapping ; Driver Code","code":"< ? php function rearrange ( & $ arr , $ n ) { if ( $ arr == NULL $ n % 2 == 1 ) return ; $ currIdx = intval ( ( $ n - 1 ) \/ 2 ) ; while ( $ currIdx > 0 ) { $ count = $ currIdx ; $ swapIdx = $ currIdx ; while ( $ count -- > 0 ) { $ temp = $ arr [ $ swapIdx + 1 ] ; $ arr [ $ swapIdx + 1 ] = $ arr [ $ swapIdx ] ; $ arr [ $ swapIdx ] = $ temp ; $ swapIdx ++ ; } $ currIdx -- ; } } $ arr = array ( 1 , 3 , 5 , 2 , 4 , 6 ) ; $ n = count ( $ arr ) ; rearrange ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; ? >"}
{"text":"Maximum difference between two elements such that larger element appears after the smaller number | The function assumes that there are at least two elements in array . The function returns a negative value if the array is sorted in decreasing order and returns 0 if elements are equal ; Driver Code ; Function calling","code":"< ? php function maxDiff ( $ arr , $ arr_size ) { $ max_diff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ j ] - $ arr [ $ i ] > $ max_diff ) $ max_diff = $ arr [ $ j ] - $ arr [ $ i ] ; } } return $ max_diff ; } $ arr = array ( 1 , 2 , 90 , 10 , 110 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum \u2581 difference \u2581 is \u2581 \" . maxDiff ( $ arr , $ n ) ;"}
{"text":"Maximum difference between two elements such that larger element appears after the smaller number | The function assumes that there are at least two elements in array . The function returns a negative value if the array is sorted in decreasing order and returns 0 if elements are equal ; Initialize Result ; Initialize max element from right side ; Driver Code ; Function calling","code":"< ? php function maxDiff ( $ arr , $ n ) { $ maxDiff = -1 ; $ maxRight = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ maxRight ) $ maxRight = $ arr [ $ i ] ; else { $ diff = $ maxRight - $ arr [ $ i ] ; if ( $ diff > $ maxDiff ) { $ maxDiff = $ diff ; } } } return $ maxDiff ; } $ arr = array ( 1 , 2 , 90 , 10 , 110 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum \u2581 difference \u2581 is \u2581 \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text":"Maximum difference between two elements such that larger element appears after the smaller number | The function assumes that there are at least two elements in array . The function returns a negative value if the array is sorted in decreasing order and returns 0 if elements are equal ; Initialize diff , current sum and max sum ; Calculate current diff ; Calculate current sum ; Update max sum , if needed ; Driver Code ; Function calling","code":"< ? php function maxDiff ( $ arr , $ n ) { $ diff = $ arr [ 1 ] - $ arr [ 0 ] ; $ curr_sum = $ diff ; $ max_sum = $ curr_sum ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; if ( $ curr_sum > 0 ) $ curr_sum += $ diff ; else $ curr_sum = $ diff ; if ( $ curr_sum > $ max_sum ) $ max_sum = $ curr_sum ; } return $ max_sum ; } $ arr = array ( 80 , 2 , 6 , 3 , 100 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum \u2581 difference \u2581 is \u2581 \" , maxDiff ( $ arr , $ n ) ; ? >"}
{"text":"Find the maximum element in an array which is first increasing and then decreasing | PHP program to Find the maximum element in an array which is first increasing and then decreasing ; Driver Code","code":"< ? php function findMaximum ( $ arr , $ low , $ high ) { $ max = $ arr [ $ low ] ; $ i ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; } return $ max ; } $ arr = array ( 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 ) ; $ n = count ( $ arr ) ; echo \" The \u2581 maximum \u2581 element \u2581 is \u2581 \" , findMaximum ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text":"Find the maximum element in an array which is first increasing and then decreasing | PHP program to Find the maximum element in an array which is first increasing and then decreasing ; Base Case : Only one element is present in arr [ low . . high ] ; If there are two elements and first is greater then the first element is maximum ; If there are two elements and second is greater then the second element is maximum ; If we reach a point where arr [ mid ] is greater than both of its adjacent elements arr [ mid - 1 ] and arr [ mid + 1 ] , then arr [ mid ] is the maximum element ; If arr [ mid ] is greater than the next element and smaller than the previous element then maximum lies on left side of mid ; when arr [ mid ] is greater than arr [ mid - 1 ] and smaller than arr [ mid + 1 ] ; Driver Code","code":"< ? php function findMaximum ( $ arr , $ low , $ high ) { if ( $ low == $ high ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] >= $ arr [ $ high ] ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] < $ arr [ $ high ] ) return $ arr [ $ high ] ; $ mid = ( $ low + $ high ) \/ 2 ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return findMaximum ( $ arr , $ low , $ mid - 1 ) ; else return findMaximum ( $ arr , $ mid + 1 , $ high ) ; } $ arr = array ( 1 , 3 , 50 , 10 , 9 , 7 , 6 ) ; $ n = sizeof ( $ arr ) ; echo ( \" The \u2581 maximum \u2581 element \u2581 is \u2581 \" ) ; echo ( findMaximum ( $ arr , 0 , $ n -1 ) ) ; ? >"}
{"text":"Maximum Sum Path in Two Arrays | This function returns the sum of elements on maximum path from beginning to end ; initialize indexes for ar1 [ ] and ar2 [ ] ; Initialize result and current sum through ar1 [ ] and ar2 [ ] . ; Below 3 loops are similar to merge in merge sort ; Add elements of ar1 [ ] to sum1 ; Add elements of ar2 [ ] to sum2 ; we reached a common point ; Take the maximum of two sums and add to result Also add the common element of array , once ; Update sum1 and sum2 for elements after this intersection point ; update i and j to move to next element of each array ; Add remaining elements of ar1 [ ] ; Add remaining elements of ar2 [ ] ; Add maximum of two sums of remaining elements ; Driver Code ; Function call","code":"< ? php function maxPathSum ( $ ar1 , $ ar2 , $ m , $ n ) { $ i = 0 ; $ j = 0 ; $ result = 0 ; $ sum1 = 0 ; $ sum2 = 0 ; while ( $ i < $ m and $ j < $ n ) { if ( $ ar1 [ $ i ] < $ ar2 [ $ j ] ) $ sum1 += $ ar1 [ $ i ++ ] ; else if ( $ ar1 [ $ i ] > $ ar2 [ $ j ] ) $ sum2 += $ ar2 [ $ j ++ ] ; else { $ result += max ( $ sum1 , $ sum2 ) + $ ar1 [ $ i ] ; $ sum1 = 0 ; $ sum2 = 0 ; $ i ++ ; $ j ++ ; } } while ( $ i < $ m ) $ sum1 += $ ar1 [ $ i ++ ] ; while ( $ j < $ n ) $ sum2 += $ ar2 [ $ j ++ ] ; $ result += max ( $ sum1 , $ sum2 ) ; return $ result ; } $ ar1 = array ( 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 ) ; $ ar2 = array ( 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 ) ; $ m = count ( $ ar1 ) ; $ n = count ( $ ar2 ) ; echo \" Maximum \u2581 sum \u2581 path \u2581 is \u2581 \" , maxPathSum ( $ ar1 , $ ar2 , $ m , $ n ) ; ? >"}
{"text":"Smallest greater elements in whole array | Simple PHP program to find smallest greater element in whole array for every element . ; Find the closest greater element for arr [ j ] in the entire array . ; Check if arr [ i ] is largest ; Driver code","code":"< ? php function smallestGreater ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ diff = PHP_INT_MAX ; $ closest = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] && $ arr [ $ j ] - $ arr [ $ i ] < $ diff ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; $ closest = $ j ; } } if ( $ closest == -1 ) echo \" _ \u2581 \" ; else echo $ arr [ $ closest ] , \" \u2581 \" ; } } $ ar = array ( 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 ) ; $ n = sizeof ( $ ar ) ; smallestGreater ( $ ar , $ n ) ; ? >"}
{"text":"Find zeroes to be flipped so that number of consecutive 1 's is maximized | m is maximum of number zeroes allowed to flip n is size of array ; Left and right indexes of current window ; Left index and size of the widest window ; Count of zeroes in current window ; While right boundary of current window doesn 't cross  right end ; If zero count of current window is less than m , widen the window toward right ; If zero count of current window is more than m , reduce the window from left ; Updqate widest window if this window size is more ; Print positions of zeroes in the widest window ; Driver Code","code":"< ? php function findZeroes ( $ arr , $ n , $ m ) { $ wL = 0 ; $ wR = 0 ; $ bestL = 0 ; $ bestWindow = 0 ; $ zeroCount = 0 ; while ( $ wR < $ n ) { if ( $ zeroCount <= $ m ) { if ( $ arr [ $ wR ] == 0 ) $ zeroCount ++ ; $ wR ++ ; } if ( $ zeroCount > $ m ) { if ( $ arr [ $ wL ] == 0 ) $ zeroCount -- ; $ wL ++ ; } if ( ( $ wR - $ wL > $ bestWindow ) && ( $ zeroCount <= $ m ) ) { $ bestWindow = $ wR - $ wL ; $ bestL = $ wL ; } } for ( $ i = 0 ; $ i < $ bestWindow ; $ i ++ ) { if ( $ arr [ $ bestL + $ i ] == 0 ) echo $ bestL + $ i . \" \u2581 \" ; } } $ arr = array ( 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 ) ; $ m = 2 ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo \" Indexes \u2581 of \u2581 zeroes \u2581 to \u2581 be \u2581 flipped \u2581 are \u2581 \" ; findZeroes ( $ arr , $ n , $ m ) ; return 0 ; ? >"}
{"text":"Count Strictly Increasing Subarrays | PHP program to count number of strictly increasing subarrays ; Initialize count of subarrays as 0 ; Pick starting point ; Pick ending point ; If subarray arr [ i . . j ] is not strictly increasing , then subarrays after it , i . e . , arr [ i . . j + 1 ] , arr [ i . . j + 2 ] , ... . cannot be strictly increasing ; Driver program","code":"< ? php function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] > $ arr [ $ j - 1 ] ) $ cnt ++ ; else break ; } } return $ cnt ; } $ arr = array ( 1 , 2 , 2 , 4 ) ; $ n = count ( $ arr ) ; echo \" Count \u2581 of \u2581 strictly \u2581 increasing \u2581 \" , \" subarrays \u2581 is \u2581 \" , countIncreasing ( $ arr , $ n ) ; ? >"}
{"text":"Count Strictly Increasing Subarrays | PHP program to count number of strictly increasing subarrays in O ( n ) time . ; Initialize result ; Initialize length of current increasing subarray ; Traverse through the array ; If arr [ i + 1 ] is greater than arr [ i ] , then increment length ; Else Update count and reset length ; If last length is more than 1 ; Driver Code","code":"< ? php function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] > $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) \/ 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) \/ 2 ) ; return $ cnt ; } $ arr = array ( 1 , 2 , 2 , 4 ) ; $ n = count ( $ arr ) ; echo \" Count \u2581 of \u2581 strictly \u2581 increasing \u2581 subarrays \u2581 is \u2581 \" , countIncreasing ( $ arr , $ n ) ; ? >"}
{"text":"Maximum difference between group of k | utility function for array sum ; function for finding maximum group difference of array ; sort the array ; find array sum ; difference for k - smallest diff1 = ( arraysum - k_smallest ) - k_smallest ; reverse array for finding sum 0f 1 st k - largest ; difference for k - largest diff2 = ( arraysum - k_largest ) - k_largest ; return maximum difference value ; Driver Code","code":"< ? php function arraySum ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; return $ sum ; } function maxDiff ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ arraysum = arraySum ( $ arr , $ n ) ; $ diff1 = abs ( $ arraysum - 2 * arraySum ( $ arr , $ k ) ) ; array_reverse ( $ arr ) ; $ diff2 = abs ( $ arraysum - 2 * arraySum ( $ arr , $ k ) ) ; return ( max ( $ diff1 , $ diff2 ) ) ; } $ arr = array ( 1 , 7 , 4 , 8 , -1 , 5 , 2 , 1 ) ; $ n = count ( $ arr ) ; $ k = 3 ; echo \" Maximum \u2581 Difference \u2581 = \u2581 \" , maxDiff ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Minimum number of elements to add to make median equals x | Returns count of elements to be added to make median x . This function assumes that a [ ] has enough extra space . ; to sort the array in increasing order . ; Driver code","code":"< ? php function minNumber ( $ a , $ n , $ x ) { sort ( $ a ) ; $ k ; for ( $ k = 0 ; $ a [ ( $ n - 1 ) \/ 2 ] != $ x ; $ k ++ ) { $ a [ $ n ++ ] = $ x ; sort ( $ a ) ; } return $ k ; } $ x = 10 ; $ a = array ( 10 , 20 , 30 ) ; $ n = 3 ; echo minNumber ( $ a , $ n , $ x ) , \" STRNEWLINE \" ; ? >"}
{"text":"Minimum number of elements to add to make median equals x | PHP program to find minimum number of elements to add so that its median equals x . ; no . of elements equals to x , that is , e . ; no . of elements greater than x , that is , h . ; no . of elements smaller than x , that is , l . ; subtract the no . of elements that are equal to x . ; Driver code","code":"< ? php function minNumber ( $ a , $ n , $ x ) { $ l = 0 ; $ h = 0 ; $ e = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ x ) $ e ++ ; else if ( $ a [ $ i ] > $ x ) $ h ++ ; else if ( $ a [ $ i ] < $ x ) $ l ++ ; } $ ans = 0 ; if ( $ l > $ h ) $ ans = $ l - $ h ; else if ( $ l < $ h ) $ ans = $ h - $ l - 1 ; return $ ans + 1 - $ e ; } $ x = 10 ; $ a = array ( 10 , 20 , 30 ) ; $ n = sizeof ( $ a ) ; echo minNumber ( $ a , $ n , $ x ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check in binary array the number represented by a subarray is odd or even | prints if subarray is even or odd ; if arr [ r ] = 1 print odd ; if arr [ r ] = 0 print even ; Driver code","code":"< ? php function checkEVENodd ( $ arr , $ n , $ l , $ r ) { if ( $ arr [ $ r ] == 1 ) echo \" odd \" , \" STRNEWLINE \" ; else echo \" even \" , \" STRNEWLINE \" ; } $ arr = array ( 1 , 1 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; checkEVENodd ( $ arr , $ n , 1 , 3 ) ; ? >"}
{"text":"Mean of range in array | To find mean of range in l to r ; Both sum and count are initialize to 0 ; To calculate sum and number of elements in range l to r ; Calculate floor value of mean ; Returns mean of array in range l to r ; Driver Code","code":"< ? php function findMean ( $ arr , $ l , $ r ) { $ sum = 0 ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ count ++ ; } $ mean = floor ( $ sum \/ $ count ) ; return $ mean ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; echo findMean ( $ arr , 0 , 2 ) , \" STRNEWLINE \" ; echo findMean ( $ arr , 1 , 3 ) , \" STRNEWLINE \" ; echo findMean ( $ arr , 0 , 4 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Products of ranges in an array | Function to calculate Product in the given range . ; As our array is 0 based as and L and R are given as 1 based index . ; Driver code","code":"< ? php function calculateProduct ( $ A , $ L , $ R , $ P ) { $ L = $ L - 1 ; $ R = $ R - 1 ; $ ans = 1 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { $ ans = $ ans * $ A [ $ i ] ; $ ans = $ ans % $ P ; } return $ ans ; } $ A = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; $ P = 229 ; $ L = 2 ; $ R = 5 ; echo calculateProduct ( $ A , $ L , $ R , $ P ) , \" \" ; $ L = 1 ; $ R = 3 ; echo calculateProduct ( $ A , $ L , $ R , $ P ) , \" \" ; ? >"}
{"text":"Count Primes in Ranges | PHP program to answer queries for count of primes in given range . ; prefix [ i ] is going to store count of primes till i ( including i ) . ; Create a boolean array value in prime [ i ] will \" prime [ 0 . . n ] \" . A finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Build prefix array $prefix [ 0 ] = $prefix [ 1 ] = 0 ; ; Returns count of primes in range from L to R ( both inclusive ) . ; Driver code","code":"< ? php $ MAX = 10000 ; $ prefix = array_fill ( 0 , ( $ MAX + 1 ) , 0 ) ; function buildPrefix ( ) { global $ MAX , $ prefix ; $ prime = array_fill ( 0 , ( $ MAX + 1 ) , true ) ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ MAX ; $ p ++ ) { $ prefix [ $ p ] = $ prefix [ $ p - 1 ] ; if ( $ prime [ $ p ] ) $ prefix [ $ p ] ++ ; } } function query ( $ L , $ R ) { global $ prefix ; return $ prefix [ $ R ] - $ prefix [ $ L - 1 ] ; } buildPrefix ( ) ; $ L = 5 ; $ R = 10 ; echo query ( $ L , $ R ) . \" STRNEWLINE \" ; $ L = 1 ; $ R = 10 ; echo query ( $ L , $ R ) . \" STRNEWLINE \" ; ? >"}
{"text":"Binary array after M range toggle operations | function for toggle ; function for final processing of array ; function for printing result ; Driver Code ; function call for toggle ; process array ; print result","code":"< ? php function command ( $ arr , $ a , $ b ) { $ arr [ $ a ] = $ arr [ $ a ] ^ 1 ; $ arr [ $ b + 1 ] ^= 1 ; } function process ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) { $ arr [ $ k ] = $ arr [ $ k ] ^ $ arr [ $ k - 1 ] ; } } function result ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) echo $ arr [ $ k ] . \" \u2581 \" ; } $ n = 5 ; $ m = 3 ; $ arr = new SplFixedArray ( 7 ) ; $ arr [ 6 ] = array ( 0 ) ; command ( $ arr , 1 , 5 ) ; command ( $ arr , 2 , 5 ) ; command ( $ arr , 3 , 5 ) ; process ( $ arr , $ n ) ; result ( $ arr , $ n ) ; ? >"}
{"text":"Probability of a random pair being the maximum weighted pair | Function to return probability ; Count occurrences of maximum element in A [ ] ; Count occurrences of maximum element in B [ ] ; Returning probability ; Driver code","code":"< ? php function probability ( $ a , $ b , $ size1 , $ size2 ) { $ max1 = PHP_INT_MIN ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ size1 ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) { $ max1 = $ a [ $ i ] ; $ count1 = 1 ; } else if ( $ a [ $ i ] == $ max1 ) { $ count1 ++ ; } } $ max2 = PHP_INT_MIN ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ size2 ; $ i ++ ) { if ( $ b [ $ i ] > $ max2 ) { $ max2 = $ b [ $ i ] ; $ count2 = 1 ; } else if ( $ b [ $ i ] == $ max2 ) { $ count2 ++ ; } } return ( double ) ( $ count1 * $ count2 ) \/ ( $ size1 * $ size2 ) ; } $ a = array ( 1 , 2 , 3 ) ; $ b = array ( 1 , 3 , 3 ) ; $ size1 = sizeof ( $ a ) ; $ size2 = sizeof ( $ b ) ; echo probability ( $ a , $ b , $ size1 , $ size2 ) ; ? >"}
{"text":"Minimum De | function to count Dearrangement ; create a copy of original array ; sort the array ; traverse sorted array for counting mismatches ; reverse the sorted array ; traverse reverse sorted array for counting mismatches ; return minimum mismatch count ; Driver Code","code":"< ? php function countDe ( $ arr , $ n ) { $ v = $ arr ; sort ( $ arr ) ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count1 ++ ; rsort ( $ arr ) ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count2 ++ ; return ( min ( $ count1 , $ count2 ) ) ; } $ arr = array ( 5 , 9 , 21 , 17 , 13 ) ; $ n = count ( $ arr ) ; echo \" Minimum \u2581 Dearrangement \u2581 = \u2581 \" . countDe ( $ arr , $ n ) ; ? >"}
{"text":"Divide an array into k segments to maximize maximum of segment minimums | function to calculate the max of all the minimum segments ; if we have to divide it into 1 segment then the min will be the answer ; If k >= 3 , return maximum of all elements . ; Driver Code","code":"< ? php function maxOfSegmentMins ( $ a , $ n , $ k ) { if ( $ k == 1 ) return min ( $ a ) ; if ( $ k == 2 ) return max ( $ a [ 0 ] , $ a [ $ n - 1 ] ) ; return max ( $ a ) ; } $ a = array ( -10 , -9 , -8 , 2 , 7 , -6 , -5 ) ; $ n = count ( $ a ) ; $ k = 2 ; echo maxOfSegmentMins ( $ a , $ n , $ k ) ; ? >"}
{"text":"Minimum product pair an array of positive Integers | Function to calculate minimum product of pair ; Initialize first and second minimums . It is assumed that the array has at least two elements . ; Traverse remaining array and keep track of two minimum elements ( Note that the two minimum elements may be same if minimum element appears more than once ) more than once ) ; Driver Code","code":"< ? php function printMinimumProduct ( $ arr , $ n ) { $ first_min = min ( $ arr [ 0 ] , $ arr [ 1 ] ) ; $ second_min = max ( $ arr [ 0 ] , $ arr [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ first_min ) { $ second_min = $ first_min ; $ first_min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second_min ) $ second_min = $ arr [ $ i ] ; } return $ first_min * $ second_min ; } $ a = array ( 11 , 8 , 5 , 7 , 5 , 100 ) ; $ n = sizeof ( $ a ) ; echo ( printMinimumProduct ( $ a , $ n ) ) ; ? >"}
{"text":"Count ways to form minimum product triplets | function to calculate number of triples ; Sort the array ; Count occurrences of third element ; If all three elements are same ( minimum element appears at least 3 times ) . Answer is nC3 . ; If minimum element appears once . Answer is nC2 . ; Minimum two elements are distinct . Answer is nC1 . ; Driver code","code":"< ? php function noOfTriples ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ 2 ] ) $ count ++ ; if ( $ arr [ 0 ] == $ arr [ 2 ] ) return ( $ count - 2 ) * ( $ count - 1 ) * ( $ count ) \/ 6 ; else if ( $ arr [ 1 ] == $ arr [ 2 ] ) return ( $ count - 1 ) * ( $ count ) \/ 2 ; return $ count ; } $ arr = array ( 1 , 3 , 3 , 4 ) ; $ n = count ( $ arr ) ; echo noOfTriples ( $ arr , $ n ) ; ? >"}
{"text":"Check if reversing a sub array make the array sorted | Return true , if reversing the subarray will sort the array , else return false . ; Copying the array . ; Sort the copied array . ; Finding the first mismatch . ; Finding the last mismatch . ; If whole array is sorted ; Checking subarray is decreasing or not . ; Driver Code","code":"< ? php function checkReverse ( $ arr , $ n ) { $ temp [ $ n ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ temp [ $ i ] = $ arr [ $ i ] ; sort ( $ temp , 0 ) ; $ front ; for ( $ front = 0 ; $ front < $ n ; $ front ++ ) if ( $ temp [ $ front ] != $ arr [ $ front ] ) break ; $ back ; for ( $ back = $ n - 1 ; $ back >= 0 ; $ back -- ) if ( $ temp [ $ back ] != $ arr [ $ back ] ) break ; if ( $ front >= $ back ) return true ; do { $ front ++ ; if ( $ arr [ $ front - 1 ] < $ arr [ $ front ] ) return false ; } while ( $ front != $ back ) ; return true ; } $ arr = array ( 1 , 2 , 5 , 4 , 3 ) ; $ n = sizeof ( $ arr ) ; if ( checkReverse ( $ arr , $ n ) ) echo \" Yes \" . \" STRNEWLINE \" ; else echo \" No \" . \" STRNEWLINE \" ; ? >"}
{"text":"Check if reversing a sub array make the array sorted | Return true , if reversing the subarray will sort the array , else return false . ; Find first increasing part ; Find reversed part ; Find last increasing part ; To handle cases like { 1 , 2 , 3 , 4 , 20 , 9 , 16 , 17 } ; Driver Code","code":"< ? php function checkReverse ( $ arr , $ n ) { if ( $ n == 1 ) return true ; for ( $ i = 1 ; $ i < $ n && $ arr [ $ i - 1 ] < $ arr [ $ i ] ; $ i ++ ) ; if ( $ i == $ n ) return true ; $ j = $ i ; while ( $ arr [ $ j ] < $ arr [ $ j - 1 ] ) { if ( $ i > 1 && $ arr [ $ j ] < $ arr [ $ i - 2 ] ) return false ; $ j ++ ; } if ( $ j == $ n ) return true ; $ k = $ j ; if ( $ arr [ $ k ] < $ arr [ $ i - 1 ] ) return false ; while ( $ k > 1 && $ k < $ n ) { if ( $ arr [ $ k ] < $ arr [ $ k - 1 ] ) return false ; $ k ++ ; } return true ; } $ arr = array ( 1 , 3 , 4 , 10 , 9 , 8 ) ; $ n = sizeof ( $ arr ) ; if ( checkReverse ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Making elements of two arrays same with minimum increment \/ decrement | PHP program to find minimum increment \/ decrement operations to make array elements same . ; sorting both arrays in ascending order ; variable to store the final result ; After sorting both arrays Now each array is in non - decreasing order . Thus , we will now compare each element of the array and do the increment or decrement operation depending upon the value of array b [ ] . ; Driver code","code":"< ? php function MinOperation ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ b ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] > $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; else if ( $ a [ $ i ] < $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; } return $ result ; } $ a = array ( 3 , 1 , 1 ) ; $ b = array ( 1 , 2 , 2 ) ; $ n = sizeof ( $ a ) ; echo MinOperation ( $ a , $ b , $ n ) ; ? >"}
{"text":"Sorting array except elements in a subarray | Sort whole array a [ ] except elements in range a [ l . . r ] ; Copy all those element that need to be sorted to an auxiliary array b [ ] ; sort the array b ; Copy sorted elements back to a [ ] ; Driver code","code":"< ? php function sortExceptUandL ( $ a , $ l , $ u , $ n ) { $ b = array ( ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] = $ a [ $ i ] ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ a [ $ i ] = $ b [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ a [ $ i ] = $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] ; } $ a = array ( 4 , 5 , 3 , 12 , 14 , 9 ) ; $ n = count ( $ a ) ; $ l = 2 ; $ u = 4 ; sortExceptUandL ( $ a , $ l , $ u , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ a [ $ i ] . \" \u2581 \" ) ; ? >"}
{"text":"Sorting all array elements except one | PHP program to sort all elements except element at index k . ; Move k - th element to end ; Sort all elements except last ; Store last element ( originally k - th ) ; Move all elements from k - th to one position ahead . ; Restore k - th element ; Driver code","code":"< ? php function sortExceptK ( & $ arr , $ k , $ n ) { $ t = $ arr [ $ k ] ; $ arr [ $ k ] = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ t ; $ t = $ arr [ count ( $ arr ) - 1 ] ; $ arr = array_slice ( $ arr , 0 , -1 ) ; sort ( $ arr ) ; array_push ( $ arr , $ t ) ; $ last = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 1 ; $ i > $ k ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ $ k ] = $ last ; } $ a = array ( 10 , 4 , 11 , 7 , 6 , 20 ) ; $ k = 2 ; $ n = count ( $ a ) ; sortExceptK ( $ a , $ k , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ a [ $ i ] . \" \u2581 \" ) ; ? >"}
{"text":"Maximum number of partitions that can be sorted individually to make sorted | Function to find maximum partitions . ; Find maximum in prefix arr [ 0. . i ] ; If maximum so far is equal to index , we can make a new partition ending at index i . ; Driver code","code":"< ? php function maxPartitions ( $ arr , $ n ) { $ ans = 0 ; $ max_so_far = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ max_so_far = max ( $ max_so_far , $ arr [ $ i ] ) ; if ( $ max_so_far == $ i ) $ ans ++ ; } return $ ans ; } { $ arr = array ( 1 , 0 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo maxPartitions ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text":"Ropes left after every removal of smallest | Function print how many Ropes are Left AfterEvery Cutting operation ; sort all Ropes in increase of there length ; min length rope ; now traverse through the given Ropes in increase order of length ; After cutting if current rope length is greater than '0' that mean all ropes to it 's right side are also  greater than 0 ; now current rope become min length rope ; After first operation all ropes length become zero ; Driver Code","code":"< ? php function cuttringRopes ( $ Ropes , $ n ) { sort ( $ Ropes ) ; $ singleOperation = 0 ; $ cuttingLenght = $ Ropes [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ Ropes [ $ i ] - $ cuttingLenght > 0 ) { echo ( $ n - $ i ) . \" \u2581 \" ; $ cuttingLenght = $ Ropes [ $ i ] ; $ singleOperation ++ ; } } if ( $ singleOperation == 0 ) echo \"0 \u2581 \" ; } $ Ropes = array ( 5 , 1 , 1 , 2 , 3 , 5 ) ; $ n = count ( $ Ropes ) ; cuttringRopes ( $ Ropes , $ n ) ; ? >"}
{"text":"Rank of all elements in an array | Function to find rank ; Rank Vector ; Sweep through all elements in A for each element count the number of less than and equal elements separately in r and s . ; Use formula to obtain rank ; Driver Code","code":"< ? php function rankify ( $ A , $ n ) { $ R = array ( 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ r = 1 ; $ s = 1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j != $ i && $ A [ $ j ] < $ A [ $ i ] ) $ r += 1 ; if ( $ j != $ i && $ A [ $ j ] == $ A [ $ i ] ) $ s += 1 ; } $ R [ $ i ] = $ r + ( float ) ( $ s - 1 ) \/ ( float ) 2 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) print number_format ( $ R [ $ i ] , 1 ) . ' \u2581 ' ; } $ A = array ( 1 , 2 , 5 , 2 , 1 , 25 , 2 ) ; $ n = count ( $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ A [ $ i ] . ' \u2581 ' ; echo \" STRNEWLINE \" ; rankify ( $ A , $ n ) ; ? >"}
{"text":"Minimum number of subtract operation to make an array decreasing | Function to count minimum no of operation ; Count how many times we have to subtract . ; Check an additional subtraction is required or not . ; Modify the value of arr [ i ] . ; Count total no of operation \/ subtraction . ; Driver Code","code":"< ? php function min_noOf_operation ( $ arr , $ n , $ k ) { $ noOfSubtraction ; $ res = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ noOfSubtraction = 0 ; if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) { $ noOfSubtraction = ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) \/ $ k ; if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) % $ k != 0 ) $ noOfSubtraction ++ ; $ arr [ $ i ] = $ arr [ $ i ] - $ k * $ noOfSubtraction ; } $ res = $ res + $ noOfSubtraction ; } return floor ( $ res ) ; } $ arr = array ( 1 , 1 , 2 , 3 ) ; $ N = count ( $ arr ) ; $ k = 5 ; echo min_noOf_operation ( $ arr , $ N , $ k ) ; ? >"}
{"text":"Maximize the sum of arr [ i ] * i | PHP program to find the maximum value of i * arr [ i ] ; Sort the array ; Finding the sum of arr [ i ] * i ; Driver Code","code":"< ? php function maxSum ( $ arr , $ n ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( $ arr [ $ i ] * $ i ) ; return $ sum ; } $ arr = array ( 3 , 5 , 6 , 1 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text":"Pairs with Difference less than K | Function to count pairs ; Driver code","code":"< ? php function countPairs ( $ a , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ a [ $ j ] - $ a [ $ i ] ) < $ k ) $ res ++ ; return $ res ; } $ a = array ( 1 , 10 , 4 , 2 ) ; $ k = 3 ; $ n = count ( $ a ) ; echo countPairs ( $ a , $ n , $ k ) ; ? >"}
{"text":"Pairs with Difference less than K | PHP code to find count of Pairs with difference less than K . ; to sort the array . ; Keep incrementing result while subsequent elements are within limits . ; Driver code","code":"< ? php function countPairs ( $ a , $ n , $ k ) { sort ( $ a ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j = $ i + 1 ; while ( $ j < $ n and $ a [ $ j ] - $ a [ $ i ] < $ k ) { $ res ++ ; $ j ++ ; } } return $ res ; } $ a = array ( 1 , 10 , 4 , 2 ) ; $ k = 3 ; $ n = count ( $ a ) ; echo countPairs ( $ a , $ n , $ k ) ; ? >"}
{"text":"Sum of minimum absolute difference of each array element | function to find the sum of minimum absolute difference ; sort the given array ; initialize sum ; min absolute difference for the 1 st array element ; min absolute difference for the last array element ; find min absolute difference for rest of the array elements and add them to sum ; required sum ; Driver Code","code":"< ? php function sumOfMinAbsDifferences ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ sum = 0 ; $ sum += abs ( $ arr [ 0 ] - $ arr [ 1 ] ) ; $ sum += abs ( $ arr [ $ n - 1 ] - $ arr [ $ n - 2 ] ) ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ sum += min ( abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) , abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ) ; return $ sum ; } $ arr = array ( 5 , 10 , 1 , 4 , 8 , 7 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum = \" ? >"}
{"text":"Smallest Difference pair of values between two unsorted Arrays | function to calculate Small result between two arrays ; Sort both arrays using sort function ; Initialize result as max value ; Scan Both Arrays upto sizeof of the Arrays ; Move Smaller Value ; return final sma result ; Driver Code ; Input given array A ; Input given array B ; Calculate size of Both arrays ; Call function to print smallest result","code":"< ? php function findSmallestDifference ( $ A , $ B , $ m , $ n ) { sort ( $ A ) ; sort ( $ A , $ m ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ a = 0 ; $ b = 0 ; $ INT_MAX = 1 ; $ result = $ INT_MAX ; while ( $ a < $ m && $ b < $ n ) { if ( abs ( $ A [ $ a ] - $ B [ $ b ] ) < $ result ) $ result = abs ( $ A [ $ a ] - $ B [ $ b ] ) ; if ( $ A [ $ a ] < $ B [ $ b ] ) $ a ++ ; else $ b ++ ; } return $ result ; } { $ A = array ( 1 , 2 , 11 , 5 ) ; $ B = array ( 4 , 12 , 19 , 23 , 127 , 235 ) ; $ m = sizeof ( $ A ) \/ sizeof ( $ A [ 0 ] ) ; $ n = sizeof ( $ B ) \/ sizeof ( $ B [ 0 ] ) ; echo findSmallestDifference ( $ A , $ B , $ m , $ n ) ; return 0 ; } ? >"}
{"text":"Find elements larger than half of the elements in an array | Prints elements larger than n \/ 2 element ; Sort the array in ascending order ; Print last ceil ( n \/ 2 ) elements ; Driver Code","code":"< ? php function findLarger ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = $ n - 1 ; $ i >= $ n \/ 2 ; $ i -- ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ arr = array ( 1 , 3 , 6 , 1 , 0 , 9 ) ; $ n = count ( $ arr ) ; findLarger ( $ arr , $ n ) ; ? >"}
{"text":"Find the Missing Number | getMissingNo takes array and size of array as arguments ; Driver Code","code":"< ? php function getMissingNo ( $ a , $ n ) { $ total = ( $ n + 1 ) * ( $ n + 2 ) \/ 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ total -= $ a [ $ i ] ; return $ total ; } $ a = array ( 1 , 2 , 4 , 5 , 6 ) ; $ miss = getMissingNo ( $ a , 5 ) ; echo ( $ miss ) ; ? >"}
{"text":"Count number of occurrences ( or frequency ) in a sorted array | Returns number of times x occurs in arr [ 0. . n - 1 ] ; Driver code","code":"< ? php function countOccurrences ( $ arr , $ n , $ x ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res ++ ; return $ res ; } $ arr = array ( 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ) ; $ n = count ( $ arr ) ; $ x = 2 ; echo countOccurrences ( $ arr , $ n , $ x ) ; ? >"}
{"text":"Count number of occurrences ( or frequency ) in a sorted array | A recursive binary search function . It returns location of x in given array arr [ l . . r ] is present , otherwise - 1 ; If the element is present at the middle itself ; If element is smaller than mid , then it can only be present in left subarray ; Else the element can only be present in right subarray ; Returns number of times x occurs in arr [ 0. . n - 1 ] ; If element is not present ; Count elements on left side . ; Count elements on right side . ; Driver code","code":"< ? php function binarySearch ( & $ arr , $ l , $ r , $ x ) { if ( $ r < $ l ) return -1 ; $ mid = $ l + ( $ r - $ l ) \/ 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } function countOccurrences ( $ arr , $ n , $ x ) { $ ind = binarySearch ( $ arr , 0 , $ n - 1 , $ x ) ; if ( $ ind == -1 ) return 0 ; $ count = 1 ; $ left = $ ind - 1 ; while ( $ left >= 0 && $ arr [ $ left ] == $ x ) { $ count ++ ; $ left -- ; } $ right = $ ind + 1 ; while ( $ right < $ n && $ arr [ $ right ] == $ x ) { $ count ++ ; $ right ++ ; } return $ count ; } $ arr = array ( 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ) ; $ n = sizeof ( $ arr ) ; $ x = 2 ; echo countOccurrences ( $ arr , $ n , $ x ) ; ? >"}
{"text":"Given a sorted array and a number x , find the pair in array whose sum is closest to x | Prints the pair with sum closest to x ; To store indexes of result pair ; Initialize left and right indexes and difference between pair sum and x ; While there are elements between l and r ; Check if this pair is closer than the closest pair so far ; If this pair has more sum , move to smaller values . ; Move to larger values ; Driver Code","code":"< ? php function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo \" \u2581 The \u2581 closest \u2581 pair \u2581 is \u2581 \" , $ arr [ $ res_l ] , \" \u2581 and \u2581 \" , $ arr [ $ res_r ] ; } $ arr = array ( 10 , 22 , 28 , 29 , 30 , 40 ) ; $ x = 54 ; $ n = count ( $ arr ) ; printClosest ( $ arr , $ n , $ x ) ; ? >"}
{"text":"Count 1 's in a sorted binary array | Returns counts of 1 's in arr[low..high]. The array is assumed to be sorted in non-increasing order  ; get the middle index ; check if the element at middle index is last 1 ; If element is not last 1 , recur for right side ; else recur for left side ; Driver code","code":"< ? php function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) \/ 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; } $ arr = array ( 1 , 1 , 1 , 1 , 0 , 0 , 0 ) ; $ n = count ( $ arr ) ; echo \" Count \u2581 of \u2581 1 ' s \u2581 in \u2581 given \u2581 array \u2581 is \u2581 \" , countOnes ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text":"Find lost element from a duplicated array | Function to find missing element based on binary search approach . arr1 [ ] is of larger size and N is size of it . arr1 [ ] and arr2 [ ] are assumed to be in same order . ; special case , for only element which is missing in second array ; special case , for first element missing ; Initialize current corner points ; loop until lo < hi ; If element at mid indices are equal then go to right subarray ; if lo , hi becomes contiguous , break ; missing element will be at hi index of bigger array ; This function mainly does basic error checking and calls findMissingUtil ; Driver Code","code":"< ? php function findMissingUtil ( $ arr1 , $ arr2 , $ N ) { if ( $ N == 1 ) return $ arr1 [ 0 ] ; if ( $ arr1 [ 0 ] != $ arr2 [ 0 ] ) return $ arr1 [ 0 ] ; $ lo = 0 ; $ hi = $ N - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) \/ 2 ; if ( $ arr1 [ $ mid ] == $ arr2 [ $ mid ] ) $ lo = $ mid ; else $ hi = $ mid ; if ( $ lo == $ hi - 1 ) break ; } return $ arr1 [ $ hi ] ; } function findMissing ( $ arr1 , $ arr2 , $ M , $ N ) { if ( $ N == $ M - 1 ) echo \" Missing \u2581 Element \u2581 is \u2581 \" , findMissingUtil ( $ arr1 , $ arr2 , $ M ) ; else if ( $ M == $ N - 1 ) echo \" Missing \u2581 Element \u2581 is \u2581 \" , findMissingUtil ( $ arr2 , $ arr1 , $ N ) ; else echo \" Invalid \u2581 Input \" ; } $ arr1 = array ( 1 , 4 , 5 , 7 , 9 ) ; $ arr2 = array ( 4 , 5 , 7 , 9 ) ; $ M = count ( $ arr1 ) ; $ N = count ( $ arr2 ) ; findMissing ( $ arr1 , $ arr2 , $ M , $ N ) ; ? >"}
{"text":"Find lost element from a duplicated array | This function mainly does XOR of all elements of arr1 [ ] and arr2 [ ] ; Do XOR of all element ; Driver Code","code":"< ? php function findMissing ( $ arr1 , $ arr2 , $ M , $ N ) { if ( $ M != $ N - 1 && $ N != $ M - 1 ) { echo \" Invalid \u2581 Input \" ; return ; } $ res = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ res = $ res ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ res = $ res ^ $ arr2 [ $ i ] ; echo \" Missing \u2581 element \u2581 is \u2581 \" , $ res ; } $ arr1 = array ( 4 , 1 , 5 , 9 , 7 ) ; $ arr2 = array ( 7 , 5 , 9 , 4 ) ; $ M = sizeof ( $ arr1 ) ; $ N = sizeof ( $ arr2 ) ; findMissing ( $ arr1 , $ arr2 , $ M , $ N ) ; ? >"}
{"text":"Find the repeating and the missing | Added 3 new methods | PHP program to Find the repeating and missing elements ; Driver Code","code":"< ? php function printTwoElements ( $ arr , $ size ) { $ i ; echo \" The \u2581 repeating \u2581 element \u2581 is \" , \" \u2581 \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) - 1 ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) - 1 ] = - $ arr [ abs ( $ arr [ $ i ] ) - 1 ] ; else echo ( abs ( $ arr [ $ i ] ) ) ; } echo \" and the missing element is \" ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] > 0 ) echo ( $ i + 1 ) ; } } $ arr = array ( 7 , 3 , 4 , 5 , 5 , 6 , 2 ) ; $ n = count ( $ arr ) ; printTwoElements ( $ arr , $ n ) ; ? >"}
{"text":"Find the repeating and the missing | Added 3 new methods | PHP program to Find the repeating and missing elements ; Will hold xor of all elements and numbers from 1 to n ; Will have only single set bit of xor1 ; Get the xor of all array elements ; XOR the previous result with numbers from 1 to n ; Get the rightmost set bit in set_bit_no ; Now divide elements in two sets by comparing rightmost set bit of xor1 with bit at same position in each element . Also , get XORs of two sets . The two XORs are the output elements . The following two for loops serve the purpose ; arr [ i ] belongs to first set ; arr [ i ] belongs to second set ; i belongs to first set ; i belongs to second set ; * x and * y hold the desired output elements ; Driver Code","code":"< ? php function getTwoElements ( & $ arr , $ n ) { $ xor1 ; $ set_bit_no ; $ i ; $ x = 0 ; $ y = 0 ; $ xor1 = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ xor1 = $ xor1 ^ $ arr [ $ i ] ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ xor1 = $ xor1 ^ $ i ; $ set_bit_no = $ xor1 & ~ ( $ xor1 - 1 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ arr [ $ i ] & $ set_bit_no ) != 0 ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( ( $ i & $ set_bit_no ) != 0 ) $ x = $ x ^ $ i ; else $ y = $ y ^ $ i ; } } $ arr = array ( 1 , 3 , 4 , 5 , 1 , 6 , 2 ) ; $ n = sizeof ( $ arr ) ; getTwoElements ( $ arr , $ n ) ;"}
{"text":"Find four elements that sum to a given value | Set 1 ( n ^ 3 solution ) | A naive solution to print all combination of 4 elements in A [ ] with sum equal to X ; Fix the first element and find other three ; Fix the second element and find other two ; Fix the third element and find the fourth ; find the fourth ; Driver program to test above function","code":"< ? php function findFourElements ( $ A , $ n , $ X ) { for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) { for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] + $ A [ $ l ] == $ X ) echo $ A [ $ i ] , \" , \u2581 \" , $ A [ $ j ] , \" , \u2581 \" , $ A [ $ k ] , \" , \u2581 \" , $ A [ $ l ] ; } } } } $ A = array ( 10 , 20 , 30 , 40 , 1 , 2 ) ; $ n = sizeof ( $ A ) ; $ X = 91 ; findFourElements ( $ A , $ n , $ X ) ; ? >"}
{"text":"Search an element in an array where difference between adjacent elements is 1 | x is the element to be searched in arr [ 0. . n - 1 ] ; Traverse the given array starting from leftmost element ; If x is found at index i ; Jump the difference between current array element and x ; Driver Code","code":"< ? php function search ( $ arr , $ n , $ x ) { $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ x ) return $ i ; $ i = $ i + abs ( $ arr [ $ i ] - $ x ) ; } echo \" number \u2581 is \u2581 not \u2581 present ! \" ; return -1 ; } $ arr = array ( 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ) ; $ n = sizeof ( $ arr ) ; $ x = 3 ; echo \" Element \u2581 \" , $ x , \" \u2581 is \u2581 present \u2581 \" , \" at \u2581 index \u2581 \" , search ( $ arr , $ n , 3 ) ; ? >"}
{"text":"Third largest element in an array of distinct elements | PHP program to find third Largest element in an array of distinct elements ; There should be atleast three elements ; Find first largest element ; Find second largest element ; Find third largest element ; Driver Code","code":"< ? php function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo \" \u2581 Invalid \u2581 Input \u2581 \" ; return ; } $ first = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ first ) $ first = $ arr [ $ i ] ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] < $ first ) $ second = $ arr [ $ i ] ; $ third = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ third && $ arr [ $ i ] < $ second ) $ third = $ arr [ $ i ] ; echo \" The \u2581 third \u2581 Largest \u2581 element \u2581 is \u2581 \" , $ third , \" STRNEWLINE \" ; } $ arr = array ( 12 , 13 , 1 , 10 , 34 , 16 ) ; $ n = sizeof ( $ arr ) ; thirdLargest ( $ arr , $ n ) ; ? >"}
{"text":"Third largest element in an array of distinct elements | PHP program to find third Largest element in an array ; There should be atleast three elements ; Initialize first , second and third Largest element ; Traverse array elements to find the third Largest ; If current element is greater than first , then update first , second and third ; If arr [ i ] is in between first and second ; If arr [ i ] is in between second and third ; Driver Code","code":"< ? php function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo \" \u2581 Invalid \u2581 Input \u2581 \" ; return ; } $ first = $ arr [ 0 ] ; $ second = PHP_INT_MIN ; $ third = PHP_INT_MIN ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ third = $ second ; $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second ) { $ third = $ second ; $ second = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ third ) $ third = $ arr [ $ i ] ; } echo \" The \u2581 third \u2581 Largest \u2581 element \u2581 is \u2581 \" , $ third ; } $ arr = array ( 12 , 13 , 1 , 10 , 34 , 16 ) ; $ n = sizeof ( $ arr ) ; thirdLargest ( $ arr , $ n ) ; ? >"}
{"text":"Check if there exist two elements in an array whose sum is equal to the sum of rest of the array | Function to check whether two elements exist whose sum is equal to sum of rest of the elements . ; Find sum of whole array ; If sum of array is not even than we can not divide it into two part ; For each element arr [ i ] , see if there is another element with vaalue sum - arr [ i ] ; If element exist than return the pair ; Driver Code","code":"< ? php function checkPair ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( $ sum % 2 != 0 ) return false ; $ sum = $ sum \/ 2 ; $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ val = $ sum - $ arr [ $ i ] ; if ( array_search ( $ val , $ s ) ) { echo \" Pair \u2581 elements \u2581 are \u2581 \" . $ arr [ $ i ] . \" \u2581 and \u2581 \" . $ val . \" STRNEWLINE \" ; return true ; } array_push ( $ s , $ arr [ $ i ] ) ; } return false ; } $ arr = array ( 2 , 11 , 5 , 1 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; if ( checkPair ( $ arr , $ n ) == false ) echo \" No \u2581 pair \u2581 found \" ; ? >"}
{"text":"Search an element in an unsorted array using minimum number of comparisons | function to search an element in minimum number of comparisons ; 1 st comparison ; no termination condition and thus no comparison ; this would be executed at - most n times and therefore at - most n comparisons ; replace arr [ n - 1 ] with its actual element as in original ' arr [ ] ' ; if ' x ' is found before the ' ( n - 1 ) th ' index , then it is present in the array final comparison ; else not present in the array ; Driver Code","code":"< ? php function search ( $ arr , $ n , $ x ) { if ( $ arr [ $ n - 1 ] == $ x ) return \" Found \" ; $ backup = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ x ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) { $ arr [ $ n - 1 ] = $ backup ; if ( $ i < $ n - 1 ) return \" Found \" ; return \" Not \u2581 Found \" ; } } } $ arr = array ( 4 , 6 , 1 , 5 , 8 ) ; $ n = sizeof ( $ arr ) ; $ x = 1 ; echo ( search ( $ arr , $ n , $ x ) ) ; ? >"}
{"text":"Find element in a sorted array whose frequency is greater than or equal to n \/ 2. | PHP code to find majority element in a sorted array ; Driver Code","code":"< ? php function findMajority ( $ arr , $ n ) { return $ arr [ intval ( $ n \/ 2 ) ] ; } $ arr = array ( 1 , 2 , 2 , 3 ) ; $ n = count ( $ arr ) ; echo findMajority ( $ arr , $ n ) ; ? >"}
{"text":"Minimum absolute difference of adjacent elements in a circular array | PHP program to find maximum difference between adjacent elements in a circular array . ; Checking normal adjacent elements ; Checking circular link ; Driver Code","code":"< ? php function minAdjDifference ( $ arr , $ n ) { if ( $ n < 2 ) return ; $ res = abs ( $ arr [ 1 ] - $ arr [ 0 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ) ; $ res = min ( $ res , abs ( $ arr [ $ n - 1 ] - $ arr [ 0 ] ) ) ; echo \" Min \u2581 Difference \u2581 = \u2581 \" , $ res ; } $ a = array ( 10 , 12 , 13 , 15 , 10 ) ; $ n = count ( $ a ) ; minAdjDifference ( $ a , $ n ) ; ? >"}
{"text":"Find the first , second and third minimum elements in an array | php program to find the first , second and third minimum element in an array ; Check if current element is less than firstmin , then update first , second and third ; Check if current element is less than secmin then update second and third ; Check if current element is less than then update third ; Driver code","code":"< ? php function Print3Smallest ( $ array , $ n ) { $ MAX = 100000 ; $ firstmin = $ MAX ; $ secmin = $ MAX ; $ thirdmin = $ MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ firstmin ) { $ thirdmin = $ secmin ; $ secmin = $ firstmin ; $ firstmin = $ array [ $ i ] ; } else if ( $ array [ $ i ] < $ secmin ) { $ thirdmin = $ secmin ; $ secmin = $ array [ $ i ] ; } else if ( $ array [ $ i ] < $ thirdmin ) $ thirdmin = $ array [ $ i ] ; } echo \" First min = \" . $ firstmin . \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" Second min = \" . $ secmin . \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" Third min = \" . $ thirdmin . \" \" } $ array = array ( 4 , 9 , 1 , 32 , 12 ) ; $ n = sizeof ( $ array ) \/ sizeof ( $ array [ 0 ] ) ; Print3Smallest ( $ array , $ n ) ; ? >"}
{"text":"Program to find the minimum ( or maximum ) element of an array | PHP program to find minimum ( or maximum ) element in an array . ; Driver Code","code":"< ? php function getMin ( & $ arr , $ n ) { return min ( $ arr ) ; } function getMax ( & $ arr , $ n ) { return max ( $ arr ) ; } $ arr = array ( 12 , 1234 , 45 , 67 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum \u2581 element \u2581 of \u2581 array : \u2581 \" . getMin ( $ arr , $ n ) . \" STRNEWLINE \" ; echo \" Maximum \u2581 element \u2581 of \u2581 array : \u2581 \" . getMax ( $ arr , $ n ) ; ? >"}
{"text":"Count frequencies of all elements in array in O ( 1 ) extra space and O ( n ) time | Function to find counts of all elements present in arr [ 0. . n - 1 ] . The array elements must be range from 1 to n ; Subtract 1 from every element so that the elements become in range from 0 to n - 1 ; Use every element arr [ i ] as index and add ' n ' to element present at arr [ i ] % n to keep track of count of occurrences of arr [ i ] ; To print counts , simply print the number of times n was added at index corresponding to every element ; Driver Code","code":"< ? php function printfrequency ( $ arr , $ n ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ j ] = $ arr [ $ j ] - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ arr [ $ i ] % $ n ] = $ arr [ $ arr [ $ i ] % $ n ] + $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ i + 1 , \" \u2581 - > \u2581 \" , ( int ) ( $ arr [ $ i ] \/ $ n ) , \" STRNEWLINE \" ; } $ arr = array ( 2 , 3 , 3 , 2 , 5 ) ; $ n = sizeof ( $ arr ) ; printfrequency ( $ arr , $ n ) ; ? >"}
{"text":"Count Inversions of size three in a given array | Returns count of inversions of size 3 ; Initialize result ; Count all smaller elements on right of arr [ i ] ; Count all greater elements on left of arr [ i ] ; Update inversion count by adding all inversions that have arr [ i ] as middle of three elements ; Driver Code","code":"< ? php function getInvCount ( $ arr , $ n ) { $ invcount = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ small = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ small ++ ; $ great = 0 ; for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ great ++ ; $ invcount += $ great * $ small ; } return $ invcount ; } $ arr = array ( 8 , 4 , 2 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Inversion \u2581 Count \u2581 : \u2581 \" , getInvCount ( $ arr , $ n ) ; ? >"}
{"text":"Trapping Rain Water | PHP program to find maximum amount of water that can be trapped within given set of bars . ; Initialize result ; Fill left array ; Fill right array ; Calculate the accumulated water element by element consider the amount of water on i 'th bar, the  amount of water accumulated  on this particular  bar will be equal to min(left[i], right[i]) - arr[i] . ; Driver program","code":"< ? php function findWater ( $ arr , $ n ) { $ water = 0 ; $ left [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ left [ $ i ] = max ( $ left [ $ i - 1 ] , $ arr [ $ i ] ) ; $ right [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ right [ $ i ] = max ( $ right [ $ i + 1 ] , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ water += min ( $ left [ $ i ] , $ right [ $ i ] ) - $ arr [ $ i ] ; return $ water ; } $ arr = array ( 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Maximum \u2581 water \u2581 that \u2581 can \u2581 be \u2581 accumulated \u2581 is \u2581 \" , findWater ( $ arr , $ n ) ; ? >"}
{"text":"Trapping Rain Water | Method to find maximum amount of water that can be trapped within given set of bars . ; initialize output ; maximum element on left and right ; indices to traverse the array ; update max in left ; water on curr element = max - curr ; update right maximum ; Driver Code","code":"< ? php function findWater ( $ arr , $ n ) { $ result = 0 ; $ left_max = 0 ; $ right_max = 0 ; $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo <= $ hi ) { if ( $ arr [ $ lo ] < $ arr [ $ hi ] ) { if ( $ arr [ $ lo ] > $ left_max ) $ left_max = $ arr [ $ lo ] ; else $ result += $ left_max - $ arr [ $ lo ] ; $ lo ++ ; } else { if ( $ arr [ $ hi ] > $ right_max ) $ right_max = $ arr [ $ hi ] ; else $ result += $ right_max - $ arr [ $ hi ] ; $ hi -- ; } } return $ result ; } $ arr = array ( 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ) ; $ n = count ( $ arr ) ; echo \" Maximum \u2581 water \u2581 that \u2581 can \u2581 be \u2581 accumulated \u2581 is \u2581 \" , findWater ( $ arr , $ n ) ; ? >"}
{"text":"Median of two sorted arrays with different sizes in O ( log ( min ( n , m ) ) ) | PHP code for median with case of returning double value when even number of elements are present in both array combinely ; Function to find max ; Function to find minimum ; Function to find median of two sorted arrays ; if i = n , it means that Elements from a [ ] in the second half is an empty set . and if j = 0 , it means that Elements from b [ ] in the first half is an empty set . so it is necessary to check that , because we compare elements from these two groups . Searching on right ; if i = 0 , it means that Elements from a [ ] in the first half is an empty set and if j = m , it means that Elements from b [ ] in the second half is an empty set . so it is necessary to check that , because we compare elements from these two groups . searching on left ; we have found the desired halves . ; this condition happens when we don 't have any elements  in the first half from a[]  so we returning the last  element in b[] from the  first half. ; and this condition happens when we don 't have any  elements in the first half  from b[] so we returning the  last element in a[] from the  first half. ; calculating the median . If number of elements is odd there is one middle element . ; Elements from a [ ] in the second half is an empty set . ; Elements from b [ ] in the second half is an empty set . ; Driver code ; we need to define the smaller array as the first parameter to make sure that the time complexity will be O ( log ( min ( n , m ) ) )","code":"< ? php $ median = 0 ; $ i = 0 ; $ j = 0 ; function maximum ( $ a , $ b ) { return $ a > $ b ? $ a : $ b ; } function minimum ( $ a , $ b ) { return $ a < $ b ? $ a : $ b ; } function findMedianSortedArrays ( & $ a , $ n , & $ b , $ m ) { global $ median , $ i , $ j ; $ min_index = 0 ; $ max_index = $ n ; while ( $ min_index <= $ max_index ) { $ i = intval ( ( $ min_index + $ max_index ) \/ 2 ) ; $ j = intval ( ( ( $ n + $ m + 1 ) \/ 2 ) - $ i ) ; if ( $ i < $ n && $ j > 0 && $ b [ $ j - 1 ] > $ a [ $ i ] ) $ min_index = $ i + 1 ; else if ( $ i > 0 && $ j < $ m && $ b [ $ j ] < $ a [ $ i - 1 ] ) $ max_index = $ i - 1 ; else { if ( $ i == 0 ) $ median = $ b [ $ j - 1 ] ; else if ( $ j == 0 ) $ median = $ a [ $ i - 1 ] ; else $ median = maximum ( $ a [ $ i - 1 ] , $ b [ $ j - 1 ] ) ; break ; } } if ( ( $ n + $ m ) % 2 == 1 ) return $ median ; if ( $ i == $ n ) return ( ( $ median + $ b [ $ j ] ) \/ 2.0 ) ; if ( $ j == $ m ) return ( ( $ median + $ a [ $ i ] ) \/ 2.0 ) ; return ( ( $ median + minimum ( $ a [ $ i ] , $ b [ $ j ] ) ) \/ 2.0 ) ; } $ a = array ( 900 ) ; $ b = array ( 10 , 13 , 14 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; if ( $ n < $ m ) echo ( \" The \u2581 median \u2581 is \u2581 : \u2581 \" . findMedianSortedArrays ( $ a , $ n , $ b , $ m ) ) ; else echo ( \" The \u2581 median \u2581 is \u2581 : \u2581 \" . findMedianSortedArrays ( $ b , $ m , $ a , $ n ) ) ; ? >"}
{"text":"Print uncommon elements from two sorted arrays | PHP program to find uncommon elements of two sorted arrays ; If not common , prsmaller ; Skip common element ; printing remaining elements ; Driver code","code":"< ? php function printUncommon ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) { echo $ arr1 [ $ i ] . \" \" ; $ i ++ ; $ k ++ ; } else if ( $ arr2 [ $ j ] < $ arr1 [ $ i ] ) { echo $ arr2 [ $ j ] . \" \" ; $ k ++ ; $ j ++ ; } else { $ i ++ ; $ j ++ ; } } while ( $ i < $ n1 ) { echo $ arr1 [ $ i ] . \" \" ; $ i ++ ; $ k ++ ; } while ( $ j < $ n2 ) { echo $ arr2 [ $ j ] . \" \" ; $ j ++ ; $ k ++ ; } } $ arr1 = array ( 10 , 20 , 30 ) ; $ arr2 = array ( 20 , 25 , 30 , 40 , 50 ) ; $ n1 = sizeof ( $ arr1 ) ; $ n2 = sizeof ( $ arr2 ) ; printUncommon ( $ arr1 , $ arr2 , $ n1 , $ n2 ) ; ? >"}
{"text":"Least frequent element in an array | PHP program to find the least frequent element in an array . ; Sort the array ; find the min frequency using linear traversal ; If last element is least frequent ; Driver Code","code":"< ? php function leastFrequent ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ min_count = $ n + 1 ; $ res = -1 ; $ curr_count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ curr_count ++ ; else { if ( $ curr_count < $ min_count ) { $ min_count = $ curr_count ; $ res = $ arr [ $ i - 1 ] ; } $ curr_count = 1 ; } } if ( $ curr_count < $ min_count ) { $ min_count = $ curr_count ; $ res = $ arr [ $ n - 1 ] ; } return $ res ; } { $ arr = array ( 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo leastFrequent ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text":"Maximum sum of increasing order elements from n arrays | PHP program to find maximum sum by selecting a element from n arrays ; To calculate maximum sum by selecting element from each array ; Sort each array ; Store maximum element of last array ; Selecting maximum element from previoulsy selected element ; j = - 1 means no element is found in a [ i ] so return 0 ; Driver Code","code":"< ? php $ M = 4 ; function maximumSum ( $ a , $ n ) { global $ M ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) sort ( $ a [ $ i ] ) ; $ sum = $ a [ $ n - 1 ] [ $ M - 1 ] ; $ prev = $ a [ $ n - 1 ] [ $ M - 1 ] ; $ i ; $ j ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ M - 1 ; $ j >= 0 ; $ j -- ) { if ( $ a [ $ i ] [ $ j ] < $ prev ) { $ prev = $ a [ $ i ] [ $ j ] ; $ sum += $ prev ; break ; } } if ( $ j == -1 ) return 0 ; } return $ sum ; } $ arr = array ( array ( 1 , 7 , 3 , 4 ) , array ( 4 , 2 , 5 , 1 ) , array ( 9 , 5 , 1 , 8 ) ) ; $ n = sizeof ( $ arr ) ; echo maximumSum ( $ arr , $ n ) ; ? >"}
{"text":"Pairs such that one is a power multiple of other | function to count the required pairs ; sort the given array ; for each A [ i ] traverse rest array ; count Aj such that Ai * k ^ x = Aj ; increase x till Ai * k ^ x <= largest element ; Driver Code","code":"< ? php function countPairs ( $ A , $ n , $ k ) { $ ans = 0 ; sort ( $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ x = 0 ; while ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) <= $ A [ $ j ] ) { if ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) == $ A [ $ j ] ) { $ ans ++ ; break ; } $ x ++ ; } } } return $ ans ; } $ A = array ( 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 ) ; $ n = count ( $ A ) ; $ k = 3 ; echo countPairs ( $ A , $ n , $ k ) ; ? >"}
{"text":"Minimum distance between two occurrences of maximum | function to return min distance ; case a ; case b ; case c ; Driver Code","code":"< ? php function minDistance ( $ arr , $ n ) { $ maximum_element = $ arr [ 0 ] ; $ min_dis = $ n ; $ index = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ maximum_element == $ arr [ $ i ] ) { $ min_dis = min ( $ min_dis , ( $ i - $ index ) ) ; $ index = $ i ; } else if ( $ maximum_element < $ arr [ $ i ] ) { $ maximum_element = $ arr [ $ i ] ; $ min_dis = $ n ; $ index = $ i ; } else continue ; } return $ min_dis ; } $ arr = array ( 6 , 3 , 1 , 3 , 6 , 4 , 6 ) ; $ n = count ( $ arr ) ; echo \" Minimum \u2581 distance \u2581 = \u2581 \" . minDistance ( $ arr , $ n ) ; ? >"}
{"text":"Find final value if we double after every successful search in array | Function to Find the value of k ; Search for k . After every successful search , double k . ; Driver Code","code":"< ? php function findValue ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ k ) $ k *= 2 ; return $ k ; } $ arr = array ( 2 , 3 , 4 , 10 , 8 , 1 ) ; $ k = 2 ; $ n = count ( $ arr ) ; echo findValue ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Last duplicate element in a sorted array | PHP program to print last duplicate element and its index in a sorted array ; if array is null or size is less than equal to 0 return ; compare elements and return last duplicate and its index ; If we reach here , then no duplicate found . ; Driver Code","code":"< ? php function dupLastIndex ( $ arr , $ n ) { if ( $ arr == null or $ n <= 0 ) return ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { echo \" Last \u2581 index : \" , $ i , \" STRNEWLINE \" ; echo \" Last \u2581 duplicate \u2581 item : \" , $ arr [ $ i ] ; return ; } } echo \" no \u2581 duplicate \u2581 found \" ; } $ arr = array ( 1 , 5 , 5 , 6 , 6 , 7 , 9 ) ; $ n = count ( $ arr ) ; dupLastIndex ( $ arr , $ n ) ; ? >"}
{"text":"Find an array element such that all elements are divisible by it | function to find smallest num ; traverse for all elements ; stores the minimum if it divides all ; Driver Code","code":"< ? php function findSmallest ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] ) break ; if ( $ j == $ n ) return $ a [ $ i ] ; } return -1 ; } $ a = array ( 25 , 20 , 5 , 10 , 100 ) ; $ n = sizeof ( $ a ) ; echo findSmallest ( $ a , $ n ) ; ? >"}
{"text":"Find an array element such that all elements are divisible by it | function to find smallest num ; Find the smallest element ; Check if all array elements are divisible by smallest . ; Driver Code","code":"< ? php function findSmallest ( $ a , $ n ) { $ smallest = min ( $ a ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] % $ smallest ) return -1 ; return $ smallest ; } $ a = array ( 25 , 20 , 5 , 10 , 100 ) ; $ n = count ( $ a ) ; echo findSmallest ( $ a , $ n ) ; ? >"}
{"text":"Maximum in array which is at | Function to find the index of Max element that satisfies the condition ; Finding index of max of the array ; Returns - 1 if the max element is not twice of the i - th element . ; Driver Code","code":"< ? php function findIndex ( $ arr , $ len ) { $ maxIndex = 0 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ maxIndex ] ) $ maxIndex = $ i ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ maxIndex != $ i and $ arr [ $ maxIndex ] < 2 * $ arr [ $ i ] ) return -1 ; return $ maxIndex ; } $ arr = array ( 3 , 6 , 1 , 0 ) ; $ len = count ( $ arr ) ; echo findIndex ( $ arr , $ len ) ; ? >"}
{"text":"Consecutive steps to roof top | Function to count consecutive steps ; count the number of consecutive increasing height building ; Driver code","code":"< ? php function find_consecutive_steps ( $ arr , $ len ) { $ count = 0 ; $ maximum = 0 ; for ( $ index = 1 ; $ index < $ len ; $ index ++ ) { if ( $ arr [ $ index ] > $ arr [ $ index - 1 ] ) $ count ++ ; else { $ maximum = max ( $ maximum , $ count ) ; $ count = 0 ; } } return max ( $ maximum , $ count ) ; } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ len = count ( $ arr ) ; echo find_consecutive_steps ( $ arr , $ len ) ; ? >"}
{"text":"Maximum difference between groups of size two | PHP program to find minimum difference between groups of highest and lowest sums . ; Sorting the whole array . ; Driver code","code":"< ? php function CalculateMax ( $ arr , $ n ) { sort ( $ arr ) ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; $ max_sum = $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] ; return abs ( $ max_sum - $ min_sum ) ; } $ arr = array ( 6 , 7 , 1 , 11 ) ; $ n = sizeof ( $ arr ) ; echo CalculateMax ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Minimum difference between groups of size two | PHP program to find minimum difference between groups of highest and lowest sums . ; Sorting the whole array . ; Generating sum groups . ; Driver Code","code":"< ? php function calculate ( $ a , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) array_push ( $ s , ( $ a [ $ i ] + $ a [ $ j ] ) ) ; $ mini = min ( $ s ) ; $ maxi = max ( $ s ) ; return abs ( $ maxi - $ mini ) ; } $ a = array ( 2 , 6 , 4 , 3 ) ; $ n = sizeof ( $ a ) ; echo calculate ( $ a , $ n ) ; ? >"}
{"text":"Closest numbers from a list of unsorted integers | Returns minimum difference between any two pair in arr [ 0. . n - 1 ] ; Sort array elements ; Compare differences of adjacent pairs to find the minimum difference . ; Traverse array again and print all pairs with difference as minDiff . ; Driver code","code":"< ? php function printMinDiffPairs ( $ arr , $ n ) { if ( $ n <= 1 ) return ; sort ( $ arr ) ; $ minDiff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ minDiff = min ( $ minDiff , $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) == $ minDiff ) echo \" ( \" , $ arr [ $ i - 1 ] , \" , \u2581 \" , $ arr [ $ i ] , \" ) , \u2581 \" ; } $ arr = array ( 5 , 3 , 2 , 4 , 1 ) ; $ n = sizeof ( $ arr ) ; printMinDiffPairs ( $ arr , $ n ) ; ? >"}
{"text":"Maximum absolute difference of value and index sums | Brute force PHP program to calculate the maximum absolute difference of an array . ; Utility function to calculate the value of absolute difference for the pair ( i , j ) . ; Function to return maximum absolute difference in brute force . ; Variable for storing the maximum absolute distance throughout the traversal of loops . ; Iterate through all pairs . ; If the absolute difference of current pair ( i , j ) is greater than the maximum difference calculated till now , update the value of result . ; Driver Code","code":"< ? php function calculateDiff ( $ i , $ j , $ arr ) { return abs ( $ arr [ $ i ] - $ arr [ $ j ] ) + abs ( $ i - $ j ) ; } function maxDistance ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( calculateDiff ( $ i , $ j , $ arr ) > $ result ) $ result = calculateDiff ( $ i , $ j , $ arr ) ; } } return $ result ; } $ arr = array ( -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 ) ; $ n = sizeof ( $ arr ) ; echo maxDistance ( $ arr , $ n ) ; ? >"}
{"text":"Maximum absolute difference of value and index sums | Function to return maximum absolute difference in linear time . ; max and min variables as described in algorithm . ; Updating max and min variables as described in algorithm . ; Calculating maximum absolute difference . ; Driver Code","code":"< ? php function maxDistance ( $ arr , $ n ) { $ max1 = PHP_INT_MIN ; $ min1 = PHP_INT_MAX ; $ max2 = PHP_INT_MIN ; $ min2 = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ max1 = max ( $ max1 , $ arr [ $ i ] + $ i ) ; $ min1 = min ( $ min1 , $ arr [ $ i ] + $ i ) ; $ max2 = max ( $ max2 , $ arr [ $ i ] - $ i ) ; $ min2 = min ( $ min2 , $ arr [ $ i ] - $ i ) ; } return max ( $ max1 - $ min1 , $ max2 - $ min2 ) ; } $ arr = array ( -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 ) ; $ n = count ( $ arr ) ; echo maxDistance ( $ arr , $ n ) ; ? >"}
{"text":"Number of local extrema in an array | function to find local extremum ; start loop from position 1 till n - 1 ; check if a [ i ] is greater than both its neighbours then add 1 to x ; check if a [ i ] is less than both its neighbours , then add 1 to x ; Driver Code","code":"< ? php function extrema ( $ a , $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ count += ( $ a [ $ i ] > $ a [ $ i - 1 ] and $ a [ $ i ] > $ a [ $ i + 1 ] ) ; $ count += ( $ a [ $ i ] < $ a [ $ i - 1 ] and $ a [ $ i ] < $ a [ $ i + 1 ] ) ; } return $ count ; } $ a = array ( 1 , 0 , 2 , 1 ) ; $ n = count ( $ a ) ; echo extrema ( $ a , $ n ) ; ? >"}
{"text":"Find closest number in array | Returns element closest to target in arr [ ] ; Corner cases ; Doing binary search ; If target is less than array element , then search in left ; If target is greater than previous to mid , return closest of two ; Repeat for left half ; If target is greater than mid ; update i ; Only single element left after search ; Method to compare which one is the more close . We find the closest by taking the difference between the target and both values . It assumes that val2 is greater than val1 and target lies between these two . ; Driver code","code":"< ? php function findClosest ( $ arr , $ n , $ target ) { if ( $ target <= $ arr [ 0 ] ) return $ arr [ 0 ] ; if ( $ target >= $ arr [ $ n - 1 ] ) return $ arr [ $ n - 1 ] ; $ i = 0 ; $ j = $ n ; $ mid = 0 ; while ( $ i < $ j ) { $ mid = ( $ i + $ j ) \/ 2 ; if ( $ arr [ $ mid ] == $ target ) return $ arr [ $ mid ] ; if ( $ target < $ arr [ $ mid ] ) { if ( $ mid > 0 && $ target > $ arr [ $ mid - 1 ] ) return getClosest ( $ arr [ $ mid - 1 ] , $ arr [ $ mid ] , $ target ) ; $ j = $ mid ; } else { if ( $ mid < $ n - 1 && $ target < $ arr [ $ mid + 1 ] ) return getClosest ( $ arr [ $ mid ] , $ arr [ $ mid + 1 ] , $ target ) ; $ i = $ mid + 1 ; } } return $ arr [ $ mid ] ; } function getClosest ( $ val1 , $ val2 , $ target ) { if ( $ target - $ val1 >= $ val2 - $ target ) return $ val2 ; else return $ val1 ; } $ arr = array ( 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 ) ; $ n = sizeof ( $ arr ) ; $ target = 11 ; echo ( findClosest ( $ arr , $ n , $ target ) ) ; ? >"}
{"text":"Number of pairs with maximum sum | function to find the number of maximum pair sum ; traverse through all the pairs ; traverse through all pairs and keep a count of the number of maximum pairs ; Driver Code","code":"< ? php function sum ( $ a , $ n ) { $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ maxSum = max ( $ maxSum , $ a [ $ i ] + $ a [ $ j ] ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ i ] + $ a [ $ j ] == $ maxSum ) $ c ++ ; return $ c ; } $ array = array ( 1 , 1 , 1 , 2 , 2 , 2 ) ; $ n = count ( $ array ) ; echo sum ( $ array , $ n ) ; ? >"}
{"text":"Number of pairs with maximum sum | function to find the number of maximum pair sums ; Find maximum and second maximum elements . Also find their counts . ; If maximum element appears more than once . ; If maximum element appears only once . ; Driver Code","code":"< ? php function sum ( $ a , $ n ) { $ maxVal = $ a [ 0 ] ; $ maxCount = 1 ; $ secondMax = PHP_INT_MIN ; $ secondMaxCount ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ maxVal ) $ maxCount ++ ; else if ( $ a [ $ i ] > $ maxVal ) { $ secondMax = $ maxVal ; $ secondMaxCount = $ maxCount ; $ maxVal = $ a [ $ i ] ; $ maxCount = 1 ; } else if ( $ a [ $ i ] == $ secondMax ) { $ secondMax = $ a [ $ i ] ; $ secondMaxCount ++ ; } else if ( $ a [ $ i ] > $ secondMax ) { $ secondMax = $ a [ $ i ] ; $ secondMaxCount = 1 ; } } if ( $ maxCount > 1 ) return $ maxCount * ( $ maxCount - 1 ) \/ 2 ; return $ secondMaxCount ; } $ array = array ( 1 , 1 , 1 , 2 , 2 , 2 , 3 ) ; $ n = count ( $ array ) ; echo sum ( $ array , $ n ) ; ? >"}
{"text":"Find first k natural numbers missing in given array | Prints first k natural numbers in arr [ 0. . n - 1 ] ; Find first positive number ; Now find missing numbers between array elements ; Find missing numbers after maximum . ; Driver code","code":"< ? php function printKMissing ( $ arr , $ n , $ k ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ i = 0 ; while ( $ i < $ n && $ arr [ $ i ] <= 0 ) $ i ++ ; $ count = 0 ; $ curr = 1 ; while ( $ count < $ k && $ i < $ n ) { if ( $ arr [ $ i ] != $ curr ) { echo $ curr , \" \" ; $ count ++ ; } else $ i ++ ; $ curr ++ ; } while ( $ count < $ k ) { echo $ curr , \" \" ; $ curr ++ ; $ count ++ ; } } $ arr = array ( 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; printKMissing ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Noble integers in an array ( count of greater elements is equal to value ) | Returns a Noble integer if present , else returns - 1. ; If count of greater elements is equal to arr [ i ] ; Driver code","code":"< ? php function nobleInteger ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ count ++ ; if ( $ count == $ arr [ $ i ] ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 10 , 3 , 20 , 40 , 2 ) ; $ size = count ( $ arr ) ; $ res = nobleInteger ( $ arr , $ size ) ; if ( $ res != -1 ) echo \" The \u2581 noble \u2581 integer \u2581 is \u2581 \" , $ res ; else echo \" No \u2581 Noble \u2581 Integer \u2581 Found \" ; ? >"}
{"text":"Noble integers in an array ( count of greater elements is equal to value ) | Returns a Noble integer if present , else returns - 1. ; Return a Noble element if present before last . ; In case of duplicates , we reach last occurrence here . ; Driver code","code":"< ? php function nobleInteger ( $ arr ) { sort ( $ arr ) ; $ n = count ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) continue ; if ( $ arr [ $ i ] == $ n - $ i - 1 ) return $ arr [ $ i ] ; } if ( $ arr [ $ n - 1 ] == 0 ) return $ arr [ $ n - 1 ] ; return -1 ; } $ arr = array ( 10 , 3 , 20 , 40 , 2 ) ; $ res = nobleInteger ( $ arr ) ; if ( $ res != -1 ) echo \" The \u2581 noble \u2581 integer \u2581 is \u2581 \" , $ res ; else echo \" No \u2581 Noble \u2581 Integer \u2581 Found \" ; ? >"}
{"text":"Minimum sum of absolute difference of pairs of two arrays | Returns minimum possible pairwise absolute difference of two arrays . ; Sort both arrays ; Find sum of absolute differences ; Both a [ ] and b [ ] must be of same size .","code":"< ? php function findMinSum ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ a , $ n ) ; sort ( $ b ) ; sort ( $ b , $ n ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; return $ sum ; } $ a = array ( 4 , 1 , 8 , 7 ) ; $ b = array ( 2 , 3 , 6 , 5 ) ; $ n = sizeof ( $ a ) ; echo ( findMinSum ( $ a , $ b , $ n ) ) ; ? >"}
{"text":"Minimum product subset of an array | Function to find maximum product of a subset ; Find count of negative numbers , count of zeros , maximum valued negative number , minimum valued positive number and product of non - zero numbers ; If number is 0 , we don 't  multiply it with product. ; Count negatives and keep track of maximum valued negative . ; Track minimum positive number of array ; If there are all zeros or no negative number present ; If there are all positive ; If there are even number of negative numbers and count_neg not 0 ; Otherwise result is product of all non - zeros divided by maximum valued negative . ; Driver code","code":"< ? php function minProductSubset ( $ a , $ n ) { if ( $ n == 1 ) return $ a [ 0 ] ; $ max_neg = PHP_INT_MIN ; $ min_pos = PHP_INT_MAX ; $ count_neg = 0 ; $ count_zero = 0 ; $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 0 ) { $ count_zero ++ ; continue ; } if ( $ a [ $ i ] < 0 ) { $ count_neg ++ ; $ max_neg = max ( $ max_neg , $ a [ $ i ] ) ; } if ( $ a [ $ i ] > 0 ) $ min_pos = min ( $ min_pos , $ a [ $ i ] ) ; $ prod = $ prod * $ a [ $ i ] ; } if ( $ count_zero == $ n || ( $ count_neg == 0 && $ count_zero > 0 ) ) return 0 ; if ( $ count_neg == 0 ) return $ min_pos ; if ( ! ( $ count_neg & 1 ) && $ count_neg != 0 ) { $ prod = $ prod \/ $ max_neg ; } return $ prod ; } $ a = array ( -1 , -1 , -2 , 4 , 3 ) ; $ n = sizeof ( $ a ) ; echo ( minProductSubset ( $ a , $ n ) ) ; ? >"}
{"text":"Repeatedly search an element by doubling it after every successful search | Php program to repeatedly search an element by doubling it after every successful search ; Sort the given array so that binary search can be applied on it ; Maximum array element ; search for the element b present or not in array ; Driver code","code":"< ? php function binary_search ( $ a , $ x , $ lo = 0 , $ hi = NULL ) { if ( $ hi == NULL ) $ hi = count ( $ a ) ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) \/ 2 ; $ midval = $ a [ $ mid ] ; if ( $ midval < $ x ) $ lo = $ mid + 1 ; else if ( $ midval > $ x ) $ hi = $ mid ; else return $ mid ; } return -1 ; } function findElement ( $ a , $ n , $ b ) { sort ( $ a ) ; $ mx = $ a [ $ n - 1 ] ; while ( $ b < max ( $ a ) ) { if ( binary_search ( $ a , $ b , 0 , $ n ) != -1 ) $ b *= 2 ; else return $ b ; } return $ b ; } $ a = array ( 1 , 2 , 3 ) ; $ n = count ( $ a ) ; $ b = 1 ; echo findElement ( $ a , $ n , $ b ) ; ? >"}
{"text":"Maximum sum of pairwise product in an array with negative allowed | PHP program for above implementation ; Function to find the maximum sum ; Sort the array first ; First multiply negative numbers pairwise and sum up from starting as to get maximum sum . ; Second multiply positive numbers pairwise and summed up from the last as to get maximum sum . ; To handle case if positive and negative numbers both are odd in counts . ; If one of them occurs odd times ; Driver code","code":"< ? php $ Mod = 1000000007 ; function findSum ( & $ arr , $ n ) { global $ Mod ; $ sum = 0 ; sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n && $ arr [ $ i ] < 0 ) { if ( $ i != $ n - 1 && $ arr [ $ i + 1 ] <= 0 ) { $ sum = ( $ sum + ( $ arr [ $ i ] * $ arr [ $ i + 1 ] ) % $ Mod ) % $ Mod ; $ i += 2 ; } else break ; } $ j = $ n - 1 ; while ( $ j >= 0 && $ arr [ $ j ] > 0 ) { if ( $ j != 0 && $ arr [ $ j - 1 ] > 0 ) { $ sum = ( $ sum + ( $ arr [ $ j ] * $ arr [ $ j - 1 ] ) % $ Mod ) % $ Mod ; $ j -= 2 ; } else break ; } if ( $ j > $ i ) $ sum = ( $ sum + ( $ arr [ $ i ] * $ arr [ $ j ] ) % $ Mod ) % $ Mod ; else if ( $ i == $ j ) $ sum = ( $ sum + $ arr [ $ i ] ) % Mod ; return $ sum ; } $ arr = array ( -1 , 9 , 4 , 5 , -4 , 7 ) ; $ n = sizeof ( $ arr ) ; echo findSum ( $ arr , $ n ) ; ? >"}
{"text":"Count rotations of N which are Odd and Even | Function to count of all rotations which are odd and even ; Driver Code","code":"< ? php function countOddRotations ( $ n ) { $ odd_count = 0 ; $ even_count = 0 ; do { $ digit = $ n % 10 ; if ( $ digit % 2 == 1 ) $ odd_count ++ ; else $ even_count ++ ; $ n = ( int ) ( $ n \/ 10 ) ; } while ( $ n != 0 ) ; echo \" Odd = \" , \u2581 $ odd _ count , \u2581 \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" Even = \" , \u2581 $ even _ count , \u2581 \" \" } $ n = 1234 ; countOddRotations ( $ n ) ; ? >"}
{"text":"Generate all rotations of a number | Function to return the count of digits of n ; Function to print the left shift numbers ; Formula to calculate left shift from previous number ; Update the original number ; Driver Code","code":"< ? php function numberOfDigits ( $ n ) { $ cnt = 0 ; while ( $ n > 0 ) { $ cnt ++ ; $ n = floor ( $ n \/ 10 ) ; } return $ cnt ; } function cal ( $ num ) { $ digits = numberOfDigits ( $ num ) ; $ powTen = pow ( 10 , $ digits - 1 ) ; for ( $ i = 0 ; $ i < $ digits - 1 ; $ i ++ ) { $ firstDigit = floor ( $ num \/ $ powTen ) ; $ left = ( ( $ num * 10 ) + $ firstDigit ) - ( $ firstDigit * $ powTen * 10 ) ; echo $ left , \" \" ; $ num = $ left ; } } $ num = 1445 ; cal ( $ num ) ; ? >"}
{"text":"Check whether all the rotations of a given number is greater than or equal to the given number or not | PHP implementation of the approach ; Splitting the number at index i and adding to the front ; Checking if the value is greater than or equal to the given value ; Driver code","code":"< ? php function CheckKCycles ( $ n , $ s ) { $ ff = true ; $ x = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ x = strlen ( substr ( $ s , $ i ) . substr ( $ s , 0 , $ i ) ) ; if ( $ x >= strlen ( $ s ) ) { continue ; } $ ff = false ; break ; } if ( $ ff ) { print ( \" Yes \" ) ; } else { print ( \" No \" ) ; } } $ n = 3 ; $ s = \"123\" ; CheckKCycles ( $ n , $ s ) ; ? >"}
{"text":"Generating numbers that are divisor of their right | Function to check if N is a divisor of its right - rotation ; Function to generate m - digit numbers which are divisor of their right - rotation ; Driver code","code":"< ? php function rightRotationDivisor ( $ N ) { $ lastDigit = $ N % 10 ; $ rightRotation = ( $ lastDigit * pow ( 10 , ( int ) ( log10 ( $ N ) ) ) ) + floor ( $ N \/ 10 ) ; return ( $ rightRotation % $ N == 0 ) ; } function generateNumbers ( $ m ) { for ( $ i = pow ( 10 , ( $ m - 1 ) ) ; $ i < pow ( 10 , $ m ) ; $ i ++ ) if ( rightRotationDivisor ( $ i ) ) echo $ i . \" STRNEWLINE \" ; } $ m = 3 ; generateNumbers ( $ m ) ; ? >"}
{"text":"Check if an array is sorted and rotated | Function to check if an array is sorted and rotated clockwise ; Find the minimum element and it 's index ; Check if all elements before minIndex are in increasing order ; Check if all elements after minIndex are in increasing order ; Check if last element of the array is smaller than the element just starting element of the array for arrays like [ 3 , 4 , 6 , 1 , 2 , 5 ] - not sorted circular array ; Driver code ; Function Call","code":"< ? php function checkIfSortRotated ( $ arr , $ n ) { $ minEle = PHP_INT_MAX ; $ maxEle = PHP_INT_MIN ; $ minIndex = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ minEle ) { $ minEle = $ arr [ $ i ] ; $ minIndex = $ i ; } } $ flag1 = 1 ; for ( $ i = 1 ; $ i < $ minIndex ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ i - 1 ] ) { $ flag1 = 0 ; break ; } } $ flag2 = 1 ; for ( $ i = $ minIndex + 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ i - 1 ] ) { $ flag2 = 0 ; break ; } } if ( $ flag1 && $ flag2 && ( $ arr [ $ n - 1 ] < $ arr [ $ 0 ] ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; } $ arr = array ( 3 , 4 , 5 , 1 , 2 ) ; $ n = count ( $ arr ) ; checkIfSortRotated ( $ arr , $ n ) ; ? >"}
{"text":"Elements that occurred only once in the array | Function to find the elements that appeared only once in the array ; Sort the array ; Check for first element ; Check for all the elements if it is different its adjacent elements ; Check for the last element ; Driver code","code":"< ? php function occurredOnce ( & $ arr , $ n ) { sort ( $ arr ) ; if ( $ arr [ 0 ] != $ arr [ 1 ] ) echo $ arr [ 0 ] . \" \u2581 \" ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i - 1 ] ) echo $ arr [ $ i ] . \" \u2581 \" ; if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) echo $ arr [ $ n - 1 ] . \" \u2581 \" ; } $ arr = array ( 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ) ; $ n = sizeof ( $ arr ) ; occurredOnce ( $ arr , $ n ) ; ? >"}
{"text":"Elements that occurred only once in the array | Function to find the elements that appeared only once in the array ; Check if the first and last element is equal . If yes , remove those elements ; Start traversing the remaining elements ; Check if current element is equal to the element at immediate previous index If yes , check the same for next element ; Else print the current element ; Check for the last element ; Driver code","code":"< ? php function occurredOnce ( & $ arr , $ n ) { $ i = 1 ; $ len = $ n ; if ( $ arr [ 0 ] == $ arr [ $ len - 1 ] ) { $ i = 2 ; $ len -- ; } for ( ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ i ++ ; else echo $ arr [ $ i - 1 ] . \" \u2581 \" ; if ( $ arr [ $ n - 1 ] != $ arr [ 0 ] && $ arr [ $ n - 1 ] != $ arr [ $ n - 2 ] ) echo $ arr [ $ n - 1 ] ; } $ arr = array ( 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ) ; $ n = sizeof ( $ arr ) ; occurredOnce ( $ arr , $ n ) ; ? >"}
{"text":"Split the array and add the first part to the end | Set 2 | Function to reverse arr [ ] from index start to end ; Function to print an array ; Function to left rotate arr [ ] of size n by k ; Driver program to test above functions ; Function calling","code":"< ? php function rvereseArray ( & $ arr , $ start , $ end ) { while ( $ start < $ end ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ end ] ; $ arr [ $ end ] = $ temp ; $ start ++ ; $ end -- ; } } function printArray ( & $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } function splitArr ( & $ arr , $ k , $ n ) { rvereseArray ( $ arr , 0 , $ n - 1 ) ; rvereseArray ( $ arr , 0 , $ n - $ k - 1 ) ; rvereseArray ( $ arr , $ n - $ k , $ n - 1 ) ; } $ arr = array ( 12 , 10 , 5 , 6 , 52 , 36 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; splitArr ( $ arr , $ k , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text":"Count rotations divisible by 8 | function to count of all rotations divisible by 8 ; For single digit number ; For two - digit numbers ( considering all pairs ) ; first pair ; second pair ; considering all three - digit sequences ; Considering the number formed by the last digit and the first two digits ; Considering the number formed by the last two digits and the first digit ; required count of rotations ; Driver Code","code":"< ? php function countRotationsDivBy8 ( $ n ) { $ len = strlen ( $ n ) ; $ count = 0 ; if ( $ len == 1 ) { $ oneDigit = $ n [ 0 ] - '0' ; if ( $ oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( $ len == 2 ) { $ first = ( $ n [ 0 ] - '0' ) * 10 + ( $ n [ 1 ] - '0' ) ; $ second = ( $ n [ 1 ] - '0' ) * 10 + ( $ n [ 0 ] - '0' ) ; if ( $ first % 8 == 0 ) $ count ++ ; if ( $ second % 8 == 0 ) $ count ++ ; return $ count ; } $ threeDigit ; for ( $ i = 0 ; $ i < ( $ len - 2 ) ; $ i ++ ) { $ threeDigit = ( $ n [ $ i ] - '0' ) * 100 + ( $ n [ $ i + 1 ] - '0' ) * 10 + ( $ n [ $ i + 2 ] - '0' ) ; if ( $ threeDigit % 8 == 0 ) $ count ++ ; } $ threeDigit = ( $ n [ $ len - 1 ] - '0' ) * 100 + ( $ n [ 0 ] - '0' ) * 10 + ( $ n [ 1 ] - '0' ) ; if ( $ threeDigit % 8 == 0 ) $ count ++ ; $ threeDigit = ( $ n [ $ len - 2 ] - '0' ) * 100 + ( $ n [ $ len - 1 ] - '0' ) * 10 + ( $ n [ 0 ] - '0' ) ; if ( $ threeDigit % 8 == 0 ) $ count ++ ; return $ count ; } $ n = \"43262488612\" ; echo \" Rotations : \u2581 \" . countRotationsDivBy8 ( $ n ) ; ? >"}
{"text":"Check if two numbers are bit rotations of each other or not | function to check if two numbers are equal after bit rotation ; x64 has concatenation of x with itself . ; comapring only last 32 bits ; right shift by 1 unit ; Driver Code","code":"< ? php function isRotation ( $ x , $ y ) { $ x64 = $ x | ( $ x << 32 ) ; while ( $ x64 >= $ y ) { if ( ( $ x64 ) == $ y ) return 1 ; $ x64 >>= 1 ; } return -1 ; } $ x = 122 ; $ y = 2147483678 ; if ( isRotation ( $ x , $ y ) ) echo \" yes \" , \" STRNEWLINE \" ; else echo \" no \" , \" STRNEWLINE \" ; ? >"}
{"text":"Count rotations divisible by 4 | Returns count of all rotations divisible by 4 ; For single digit number ; At - least 2 digit number ( considering all pairs ) ; Considering the number formed by the pair of last digit and 1 st digit ; Driver Code","code":"< ? php function countRotations ( $ n ) { $ len = strlen ( $ n ) ; if ( $ len == 1 ) { $ oneDigit = $ n [ 0 ] - '0' ; if ( $ oneDigit % 4 == 0 ) return 1 ; return 0 ; } $ twoDigit ; $ count = 0 ; for ( $ i = 0 ; $ i < ( $ len - 1 ) ; $ i ++ ) { $ twoDigit = ( $ n [ $ i ] - '0' ) * 10 + ( $ n [ $ i + 1 ] - '0' ) ; if ( $ twoDigit % 4 == 0 ) $ count ++ ; } $ twoDigit = ( $ n [ $ len - 1 ] - '0' ) * 10 + ( $ n [ 0 ] - '0' ) ; if ( $ twoDigit % 4 == 0 ) $ count ++ ; return $ count ; } $ n = \"4834\" ; echo \" Rotations : \u2581 \" , countRotations ( $ n ) ; ? >"}
{"text":"Maximum length of subarray such that sum of the subarray is even | Function to find length of the longest subarray such that sum of the subarray is even ; Check if sum of complete array is even ; if ( $sum % 2 == 0 ) total sum is already even ; Find an index i such the a [ i ] is odd and compare length of both halfs excluding a [ i ] to find max length subarray ; Driver Code","code":"< ? php function maxLength ( $ a , $ n ) { $ sum = 0 ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; return $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 1 ) $ len = max ( $ len , $ max ( $ n - $ i - 1 , $ i ) ) ; } return $ len ; } $ a = array ( 1 , 2 , 3 , 2 ) ; $ n = count ( $ a ) ; echo maxLength ( $ a , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find a Symmetric matrix of order N that contain integers from 0 to N | Function to generate the required matrix ; Form cyclic array of elements 1 to n - 1 ; Store initial array into final array ; Fill the last row and column with 0 's ; Swap 0 and the number present at the current indexed row ; Also make changes in the last row with the number we swapped ; Print the final array ; Driver code","code":"< ? php function solve ( $ n ) { $ initial_array = array ( array ( ) ) ; $ final_array = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) $ initial_array [ 0 ] [ $ i ] = $ i + 1 ; for ( $ i = 1 ; $ i < $ n - 1 ; ++ $ i ) for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ initial_array [ $ i ] [ $ j ] = $ initial_array [ $ i - 1 ] [ ( $ j + 1 ) % ( $ n - 1 ) ] ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ final_array [ $ i ] [ $ j ] = $ initial_array [ $ i ] [ $ j ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ final_array [ $ i ] [ $ n - 1 ] = $ final_array [ $ n - 1 ] [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ t0 = $ final_array [ $ i ] [ $ i ] ; $ t1 = $ final_array [ $ i ] [ $ n - 1 ] ; $ temp = $ final_array [ $ i ] [ $ i ] ; $ final_array [ $ i ] [ $ i ] = $ final_array [ $ i ] [ $ n - 1 ] ; $ final_array [ $ i ] [ $ n - 1 ] = $ temp ; $ final_array [ $ n - 1 ] [ $ i ] = $ t0 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = 0 ; $ j < $ n ; ++ $ j ) echo $ final_array [ $ i ] [ $ j ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } } $ n = 5 ; solve ( $ n ) ; ? >"}
{"text":"Find smallest number K such that K % p = 0 and q % K = 0 | Function to return the minimum value K such that K % p = 0 and q % k = 0 ; If K is possible ; No such K is possible ; Driver code","code":"< ? php function getMinVal ( $ p , $ q ) { if ( $ q % $ p == 0 ) return $ p ; return -1 ; } $ p = 24 ; $ q = 48 ; echo getMinVal ( $ p , $ q ) ; ? >"}
{"text":"Count all Prime Length Palindromic Substrings | Function that returns true if sub - string starting at i and ending at j in str is a palindrome ; Function to count all palindromic substring whose lwngth is a prime number ; 0 and 1 are non - primes ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked . ; To store the required number of sub - strings ; Starting from the smallest prime till the largest length of the sub - string possible ; If j is prime ; Check all the sub - strings of length j ; If current sub - string is a palindrome ; Driver Code","code":"< ? php function isPalindrome ( $ str , $ i , $ j ) { while ( $ i < $ j ) { if ( $ str [ $ i ] != $ str [ $ j ] ) return false ; $ i ++ ; $ j -- ; } return true ; } function countPrimePalindrome ( $ str , $ len ) { $ prime = array_fill ( 0 , $ len + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ len ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * $ p ; $ i <= $ len ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ count = 0 ; for ( $ j = 2 ; $ j <= $ len ; $ j ++ ) { if ( $ prime [ $ j ] ) { for ( $ i = 0 ; $ i + $ j - 1 < $ len ; $ i ++ ) { if ( isPalindrome ( $ str , $ i , $ i + $ j - 1 ) ) $ count ++ ; } } } return $ count ; } $ s = \" geeksforgeeks \" ; $ len = strlen ( $ s ) ; echo countPrimePalindrome ( $ s , $ len ) ; ? >"}
{"text":"Minimum operations of the given type required to make a complete graph | Function to return the minimum number of steps required ; Driver Code","code":"< ? php function minOperations ( $ N ) { $ x = log ( $ N , 2 ) ; $ ans = ceil ( $ x ) ; return $ ans ; } $ N = 10 ; echo minOperations ( $ N ) ; ? >"}
{"text":"Greatest divisor which divides all natural number in range [ L , R ] | Function to return the greatest divisor that divides all the natural numbers in the range [ l , r ] ; Driver Code","code":"< ? php function find_greatest_divisor ( $ l , $ r ) { if ( $ l == $ r ) return $ l ; return 1 ; } $ l = 2 ; $ r = 12 ; echo find_greatest_divisor ( $ l , $ r ) ; ? >"}
{"text":"Probability of getting two consecutive heads after choosing a random coin among two different types of coins | Function to return the probability of getting two consecutive heads ; Formula derived from Bayes 's theorem ; given the probability of getting a head for both the coins","code":"< ? php function getProbability ( $ p , $ q ) { $ p \/= 100 ; $ q \/= 100 ; $ probability = ( $ p * $ p + $ q * $ q ) \/ ( $ p + $ q ) ; return $ probability ; } $ p = 80 ; $ q = 40 ; echo getProbability ( $ p , $ q ) ; ? >"}
{"text":"Check whether bitwise OR of N numbers is Even or Odd | Function to check if bitwise OR of n numbers is even or odd ; if at least one odd number is found , then the bitwise OR of all numbers will be odd ; Bitwise OR is an odd number ; Driver Code","code":"< ? php function check ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & 1 ) return true ; } return false ; } $ arr = array ( 3 , 9 , 12 , 13 , 15 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; if ( check ( $ arr , $ n ) ) echo \" Odd \u2581 Bit - wise \u2581 OR \" ; else echo \" Even \u2581 Bit - wise \u2581 OR \" ; ? >"}
{"text":"Iterated Logarithm log * ( n ) | Recursive PhP program to find value of Iterated Logarithm ; Driver code","code":"< ? php function _log ( $ x , $ base ) { return ( int ) ( log ( $ x ) \/ log ( $ base ) ) ; } function recursiveLogStar ( $ n , $ b ) { if ( $ n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( $ n , $ b ) , $ b ) ; else return 0 ; } $ n = 100 ; $ base = 5 ; echo \" Log * ( \" \u2581 , \u2581 $ n \u2581 , \u2581 \" ) \" , \" \u2581 = \u2581 \" , recursiveLogStar ( $ n , $ base ) , \" STRNEWLINE \" ; ? >"}
{"text":"Minimum time required to transport all the boxes from source to the destination under the given constraints | Function that returns true if it is possible to transport all the boxes in the given amount of time ; If all the boxes can be transported in the given time ; If all the boxes can 't be  transported in the given time ; Function to return the minimum time required ; Sort the two arrays ; Stores minimum time in which all the boxes can be transported ; Check for the minimum time in which all the boxes can be transported ; If it is possible to transport all the boxes in mid amount of time ; Driver code","code":"< ? php function isPossible ( $ box , $ truck , $ n , $ m , $ min_time ) { $ temp = 0 ; $ count = 0 ; while ( $ count < $ m ) { for ( $ j = 0 ; $ j < $ min_time && $ temp < $ n && $ truck [ $ count ] >= $ box [ $ temp ] ; $ j += 2 ) $ temp ++ ; $ count ++ ; } if ( $ temp == $ n ) return true ; return false ; } function minTime ( $ box , $ truck , $ n , $ m ) { sort ( $ box ) ; sort ( $ truck ) ; $ l = 0 ; $ h = 2 * $ n ; $ min_time = 0 ; while ( $ l <= $ h ) { $ mid = intdiv ( ( $ l + $ h ) , 2 ) ; if ( isPossible ( $ box , $ truck , $ n , $ m , $ mid ) ) { $ min_time = $ mid ; $ h = $ mid - 1 ; } else $ l = $ mid + 1 ; } return $ min_time ; } $ box = array ( 10 , 2 , 16 , 19 ) ; $ truck = array ( 29 , 25 ) ; $ n = sizeof ( $ box ) ; $ m = sizeof ( $ truck ) ; echo minTime ( $ box , $ truck , $ n , $ m ) ; ? >"}
{"text":"Find the minimum of maximum length of a jump required to reach the last island in exactly k jumps | Function that returns true if it is possible to reach end of the array in exactly k jumps ; Variable to store the number of steps required to reach the end ; If it is possible to reach the end in exactly k jumps ; Returns the minimum maximum distance required to reach the end of the array in exactly k jumps ; Stores the answer ; Binary search to calculate the result ; Driver code","code":"< ? php function isPossible ( $ arr , $ n , $ dist , $ k ) { $ req = 0 ; $ curr = 0 ; $ prev = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ curr != $ n && $ arr [ $ curr ] - $ arr [ $ prev ] <= $ dist ) $ curr ++ ; $ req ++ ; if ( $ curr == $ n ) break ; $ prev = $ curr - 1 ; } if ( $ curr != $ n ) return false ; if ( $ req <= $ k ) return true ; return false ; } function minDistance ( $ arr , $ n , $ k ) { $ l = 0 ; $ h = $ arr [ $ n - 1 ] ; $ ans = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) \/ 2 ) ; if ( isPossible ( $ arr , $ n , $ m , $ k ) ) { $ ans = $ m ; $ h = $ m - 1 ; } else $ l = $ m + 1 ; } return $ ans ; } $ arr = array ( 2 , 15 , 36 , 43 ) ; $ n = count ( $ arr ) ; $ k = 2 ; echo minDistance ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find the kth element in the series generated by the given N ranges | Function to return the kth element of the required series ; To store the number of integers that lie upto the ith index ; Compute the number of integers ; Stores the index , lying from 1 to n , ; Using binary search , find the index in which the kth element will lie ; Find the position of the kth element in the interval in which it lies ; Driver code","code":"< ? php function getKthElement ( $ n , $ k , $ L , $ R ) { $ l = 1 ; $ h = $ n ; $ total = array ( ) ; $ total [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ total [ $ i + 1 ] = $ total [ $ i ] + ( $ R [ $ i ] - $ L [ $ i ] ) + 1 ; } $ index = -1 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) \/ 2 ) ; if ( $ total [ $ m ] > $ k ) { $ index = $ m ; $ h = $ m - 1 ; } else if ( $ total [ $ m ] < $ k ) $ l = $ m + 1 ; else { $ index = $ m ; break ; } } $ l = $ L [ $ index - 1 ] ; $ h = $ R [ $ index - 1 ] ; $ x = $ k - $ total [ $ index - 1 ] ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) \/ 2 ) ; if ( ( $ m - $ L [ $ index - 1 ] ) + 1 == $ x ) { return $ m ; } else if ( ( $ m - $ L [ $ index - 1 ] ) + 1 > $ x ) $ h = $ m - 1 ; else $ l = $ m + 1 ; } } $ L = array ( 1 , 8 , 21 ) ; $ R = array ( 4 , 10 , 23 ) ; $ n = count ( $ L ) ; $ k = 6 ; echo getKthElement ( $ n , $ k , $ L , $ R ) ; ? >"}
{"text":"Find minimum positive integer x such that a ( x ^ 2 ) + b ( x ) + c >= k | Function to return the minimum positive integer satisfying the given equation ; Binary search to find the value of x ; Return the answer ; Driver code","code":"< ? php function MinimumX ( $ a , $ b , $ c , $ k ) { $ x = PHP_INT_MAX ; if ( $ k <= $ c ) return 0 ; $ h = $ k - $ c ; $ l = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) \/ 2 ) ; if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) > ( $ k - $ c ) ) { $ x = min ( $ x , $ m ) ; $ h = $ m - 1 ; } else if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) < ( $ k - $ c ) ) $ l = $ m + 1 ; else return $ m ; } return $ x ; } $ a = 3 ; $ b = 2 ; $ c = 4 ; $ k = 15 ; echo MinimumX ( $ a , $ b , $ c , $ k ) ; ? >"}
{"text":"Divide array into two parts with equal sum according to the given constraints | Function that checks if the given conditions are satisfied ; To store the prefix $sum of the array elements ; Sort the array ; Compute the prefix sum array ; Maximum element in the array ; Variable to check if there exists any number ; Stores the index of the largest number present in the array smaller than i ; Stores the index of the smallest number present in the array greater than i ; Find index of smallest number greater than i ; Find index of smallest number greater than i ; If there exists a number ; If no such number exists print no ; Driver code","code":"< ? php function IfExists ( $ arr , $ n ) { $ sum = array_fill ( 0 , $ n , 0 ) ; sort ( $ arr ) ; $ sum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = $ sum [ $ i - 1 ] + $ arr [ $ i ] ; $ max = $ arr [ $ n - 1 ] ; $ flag = false ; for ( $ i = 1 ; $ i <= $ max ; $ i ++ ) { $ findex = 0 ; $ lindex = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l <= $ r ) { $ m = ( $ l + $ r ) \/ 2 ; if ( $ arr [ $ m ] < $ i ) { $ findex = $ m ; $ l = $ m + 1 ; } else $ r = $ m - 1 ; } $ l = 1 ; $ r = $ n ; $ flag = false ; while ( $ l <= $ r ) { $ m = ( $ r + $ l ) \/ 2 ; if ( $ arr [ $ m ] > $ i ) { $ lindex = $ m ; $ r = $ m - 1 ; } else $ l = $ m + 1 ; } if ( $ sum [ $ findex ] == $ sum [ $ n - 1 ] - $ sum [ $ lindex - 1 ] ) { $ flag = true ; break ; } } if ( $ flag == true ) echo \" Yes \" ; else echo \" No \" ; } $ arr = array ( 1 , 2 , 2 , 5 ) ; $ n = sizeof ( $ arr ) ; IfExists ( $ arr , $ n ) ; ? >"}
{"text":"Find missing element in a sorted array of consecutive numbers | Function to return the missing element ; Check if middle element is consistent ; No inconsistency till middle elements When missing element is just after the middle element ; Move right ; Inconsistency found When missing element is just before the middle element ; Move left ; No missing element found ; Driver code","code":"< ? php function findMissing ( $ arr , $ n ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ h > $ l ) { $ mid = floor ( $ l + ( $ h - $ l ) \/ 2 ) ; if ( $ arr [ $ mid ] - $ mid == $ arr [ 0 ] ) { if ( $ arr [ $ mid + 1 ] - $ arr [ $ mid ] > 1 ) return $ arr [ $ mid ] + 1 ; else { $ l = $ mid + 1 ; } } else { if ( $ arr [ $ mid ] - $ arr [ $ mid - 1 ] > 1 ) return $ arr [ $ mid ] - 1 ; else { $ h = $ mid - 1 ; } } } return -1 ; } $ arr = array ( -9 , -8 , -7 , -5 , - 4 , -3 , -2 , -1 , 0 ) ; $ n = count ( $ arr ) ; echo findMissing ( $ arr , $ n ) ; ? >"}
{"text":"Find maximum sum taking every Kth element in the array | Function to return the maximum sum for every possible sequence such that a [ i ] + a [ i + k ] + a [ i + 2 k ] + ... + a [ i + qk ] is maximized ; Initialize the maximum with the smallest value ; Find maximum from all sequences ; Sum of the sequence starting from index i ; Update maximum ; Driver code","code":"< ? php function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sumk = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j += $ K ) $ sumk = $ sumk + $ arr [ $ j ] ; $ maximum = max ( $ maximum , $ sumk ) ; } return $ maximum ; } $ arr = array ( 3 , 6 , 4 , 7 , 2 ) ; $ n = sizeof ( $ arr ) ; $ K = 2 ; echo maxSum ( $ arr , $ n , $ K ) ; ? >"}
{"text":"Find the number of elements greater than k in a sorted array | Function to return the count of elements from the array which are greater than k ; Stores the index of the left most element from the array which is greater than k ; Finds number of elements greater than k ; If mid element is greater than k update leftGreater and r ; If mid element is less than or equal to k update l ; Return the count of elements greater than k ; Driver code","code":"< ? php function countGreater ( $ arr , $ n , $ k ) { $ l = 0 ; $ r = $ n - 1 ; $ leftGreater = $ n ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) \/ 2 ) ; if ( $ arr [ $ m ] > $ k ) { $ leftGreater = $ m ; $ r = $ m - 1 ; } else $ l = $ m + 1 ; } return ( $ n - $ leftGreater ) ; } $ arr = array ( 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ) ; $ n = sizeof ( $ arr ) ; $ k = 7 ; echo countGreater ( $ arr , $ n , $ k ) ;"}
{"text":"Count the number of operations required to reduce the given number | PHP implementation of the approach ; To store the normalized value of all the operations ; Minimum possible value for a series of operations ; If k can be reduced with first ( i + 1 ) operations ; Impossible to reduce k ; Number of times all the operations can be performed on k without reducing it to <= 0 ; Perform operations ; Final check ; Driver code","code":"< ? php function operations ( $ op , $ n , $ k ) { $ count = 0 ; $ nVal = 0 ; $ minimum = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ nVal += $ op [ $ i ] ; $ minimum = min ( $ minimum , $ nVal ) ; if ( ( $ k + $ nVal ) <= 0 ) return ( $ i + 1 ) ; } if ( $ nVal >= 0 ) return -1 ; $ times = round ( ( $ k - abs ( $ minimum ) ) \/ abs ( $ nVal ) ) ; $ k = ( $ k - ( $ times * abs ( $ nVal ) ) ) ; $ count = ( $ times * $ n ) ; while ( $ k > 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ k = $ k + $ op [ $ i ] ; $ count ++ ; if ( $ k <= 0 ) break ; } } return $ count ; } $ op = array ( -60 , 65 , -1 , 14 , -25 ) ; $ n = sizeof ( $ op ) ; $ k = 100000 ; echo operations ( $ op , $ n , $ k ) ; ? >"}
{"text":"Find the smallest number X such that X ! contains at least Y trailing zeros . | Function to count the number of factors P in X ! ; Function to find the smallest X such that X ! contains Y trailing zeros ; Driver code","code":"< ? php function countFactor ( $ P , $ X ) { if ( $ X < $ P ) return 0 ; return ( ( int ) ( $ X \/ $ P ) + countFactor ( $ P , ( $ X \/ $ P ) ) ) ; } function findSmallestX ( $ Y ) { $ low = 0 ; $ high = 5 * $ Y ; $ N = 0 ; while ( $ low <= $ high ) { $ mid = ( int ) ( ( $ high + $ low ) \/ 2 ) ; if ( countFactor ( 5 , $ mid ) < $ Y ) { $ low = $ mid + 1 ; } else { $ N = $ mid ; $ high = $ mid - 1 ; } } return $ N ; } $ Y = 10 ; echo ( findSmallestX ( $ Y ) ) ; ? >"}
{"text":"Find maximum N such that the sum of square of first N natural numbers is not more than X | Function to return the sum of the squares of first N natural numbers ; Function to return the maximum N such that the sum of the squares of first N natural numbers is not more than X ; Driver code","code":"< ? php function squareSum ( $ N ) { $ sum = ( $ N * ( int ) ( $ N + 1 ) * ( 2 * $ N + 1 ) ) \/ 6 ; return $ sum ; } function findMaxN ( $ X ) { $ low = 1 ; $ high = 100000 ; $ N = 0 ; while ( $ low <= $ high ) { $ mid = ( int ) ( $ high + $ low ) \/ 2 ; if ( squareSum ( $ mid ) <= $ X ) { $ N = $ mid ; $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ N ; } $ X = 25 ; echo findMaxN ( $ X ) ; ? >"}
{"text":"Search element in a Spirally sorted Matrix | PHP implementation of the above approach ; Function to return the ring , the number x belongs to . ; Returns - 1 if number x is smaller than least element of arr ; l and r represent the diagonal elements to search in ; Returns - 1 if number x is greater than the largest element of arr ; Function to perform binary search on an array sorted in increasing order l and r represent the left and right index of the row to be searched ; Function to perform binary search on a particular column of the 2D array t and b represent top and bottom rows ; Function to perform binary search on an array sorted in decreasing order ; Function to perform binary search on a particular column of the 2D array ; Function to find the position of the number x ; Finding the ring ; To store row and column ; Edge case if n is odd ; Check which of the 4 sides , the number x lies in ; Printing the position ; Driver code","code":"< ? php $ n = 4 ; function findRing ( $ arr , $ x ) { global $ n ; if ( $ arr [ 0 ] [ 0 ] > $ x ) return -1 ; $ l = 0 ; $ r = ( int ) ( ( $ n + 1 ) \/ 2 - 1 ) ; if ( $ n % 2 == 1 && $ arr [ $ r ] [ $ r ] < $ x ) return -1 ; if ( $ n % 2 == 0 && $ arr [ $ r + 1 ] [ $ r ] < $ x ) return -1 ; while ( $ l < $ r ) { $ mid = ( int ) ( ( $ l + $ r ) \/ 2 ) ; if ( $ arr [ $ mid ] [ $ mid ] <= $ x ) if ( $ mid == ( int ) ( ( $ n + 1 ) \/ 2 - 1 ) $ arr [ $ mid + 1 ] [ $ mid + 1 ] > $ x ) return $ mid ; else $ l = $ mid + 1 ; else $ r = $ mid - 1 ; } return $ r ; } function binarySearchRowInc ( $ arr , $ row , $ l , $ r , $ x ) { while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) \/ 2 ) ; if ( $ arr [ $ row ] [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ row ] [ $ mid ] < $ x ) $ l = $ mid + 1 ; else $ r = $ mid - 1 ; } return -1 ; } function binarySearchColumnInc ( $ arr , $ col , $ t , $ b , $ x ) { while ( $ t <= $ b ) { $ mid = ( int ) ( ( $ t + b ) \/ 2 ) ; if ( $ arr [ $ mid ] [ $ col ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] [ $ col ] < $ x ) $ t = $ mid + 1 ; else $ b = $ mid - 1 ; } return -1 ; } function binarySearchRowDec ( $ arr , $ row , $ l , $ r , $ x ) { while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) \/ 2 ) ; if ( $ arr [ $ row ] [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ row ] [ $ mid ] < $ x ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; } function binarySearchColumnDec ( $ arr , $ col , $ t , $ b , $ x ) { while ( $ t <= $ b ) { $ mid = ( int ) ( ( $ t + $ b ) \/ 2 ) ; if ( $ arr [ $ mid ] [ $ col ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] [ $ col ] < $ x ) $ b = $ mid - 1 ; else $ t = $ mid + 1 ; } return -1 ; } function spiralBinary ( $ arr , $ x ) { global $ n ; $ f1 = findRing ( $ arr , $ x ) ; $ r = -1 ; $ c = -1 ; if ( $ f1 == -1 ) { echo \" - 1\" ; return ; } if ( $ n % 2 == 1 && $ f1 == ( int ) ( ( $ n + 1 ) \/ 2 - 1 ) ) { echo $ f1 . \" \" \u2581 . \u2581 $ f1 \u2581 . \u2581 \" \" return ; } if ( $ x < $ arr [ $ f1 ] [ $ n - $ f1 - 1 ] ) { $ c = binarySearchRowInc ( $ arr , $ f1 , $ f1 , $ n - $ f1 - 2 , $ x ) ; $ r = $ f1 ; } else if ( $ x < $ arr [ $ n - $ f1 - 1 ] [ $ n - $ f1 - 1 ] ) { $ c = $ n - $ f1 - 1 ; $ r = binarySearchColumnInc ( $ arr , $ n - $ f1 - 1 , $ f1 , $ n - $ f1 - 2 , $ x ) ; } else if ( $ x < $ arr [ $ n - $ f1 - 1 ] [ $ f1 ] ) { $ c = binarySearchRowDec ( $ arr , $ n - $ f1 - 1 , $ f1 + 1 , $ n - $ f1 - 1 , $ x ) ; $ r = $ n - $ f1 - 1 ; } else { $ r = binarySearchColumnDec ( $ arr , $ f1 , $ f1 + 1 , $ n - $ f1 - 1 , $ x ) ; $ c = $ f1 ; } if ( $ c == -1 $ r == -1 ) echo \" - 1\" ; else echo $ r . \" \u2581 \" . $ c ; return ; } $ arr = array ( array ( 1 , 2 , 3 , 4 ) , array ( 12 , 13 , 14 , 5 ) , array ( 11 , 16 , 15 , 6 ) , array ( 10 , 9 , 8 , 7 ) ) ; spiralBinary ( $ arr , 7 ) ; ? >"}
{"text":"Number of subarrays have bitwise OR >= K | Function to return the count of required sub - arrays ; Traverse sub - array [ i . . j ] ; Driver code","code":"< ? php function countSubArrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ bitwise_or = 0 ; for ( $ k = $ i ; $ k < $ j + 1 ; $ k ++ ) $ bitwise_or = $ bitwise_or | $ arr [ $ k ] ; if ( $ bitwise_or >= $ K ) $ count += 1 ; } } return $ count ; } $ arr = array ( 3 , 4 , 5 ) ; $ n = count ( $ arr ) ; $ k = 6 ; print ( countSubArrays ( $ arr , $ n , $ k ) ) ; ? >"}
{"text":"Occurrences of a pattern in binary representation of a number | Function to return the count of occurrence of pat in binary representation of n ; To store decimal value of the pattern ; To store a number that has all ones in its binary representation and length of ones equal to length of the pattern ; Find values of $pattern_int and $all_ones ; If the pattern occurs in the last digits of $n ; Right shift $n by 1 bit ; Driver code","code":"< ? php function countPattern ( $ n , $ pat ) { $ pattern_int = 0 ; $ power_two = 1 ; $ all_ones = 0 ; for ( $ i = strlen ( $ pat ) - 1 ; $ i >= 0 ; $ i -- ) { $ current_bit = $ pat [ $ i ] - '0' ; $ pattern_int += ( $ power_two * $ current_bit ) ; $ all_ones = $ all_ones + $ power_two ; $ power_two = $ power_two * 2 ; } $ count = 0 ; while ( $ n && $ n >= $ pattern_int ) { if ( ( $ n & $ all_ones ) == $ pattern_int ) { $ count ++ ; } $ n = $ n >> 1 ; } return $ count ; } $ n = 500 ; $ pat = \"10\" ; echo countPattern ( $ n , $ pat ) ; ? >"}
{"text":"Remove exactly one element from the array such that max | function to calculate max - min ; Driver code","code":"< ? php function max_min ( & $ a , $ n ) { sort ( $ a ) ; return min ( $ a [ $ n - 2 ] - $ a [ 0 ] , $ a [ $ n - 1 ] - $ a [ 1 ] ) ; } $ a = array ( 1 , 3 , 3 , 7 ) ; $ n = sizeof ( $ a ) ; echo ( max_min ( $ a , $ n ) ) ; ? >"}
{"text":"Count numbers < = N whose difference with the count of primes upto them is > = K | PHP implementation of the above approach ; primeUpto [ i ] denotes count of prime numbers upto i ; Function to compute all prime numbers and update primeUpto array ; 0 and 1 are not primes ; If i is prime ; Set all multiples of i as non - prime ; Compute primeUpto array ; Function to return the count of valid numbers ; Compute primeUpto array ; Check if the number is valid , try to reduce it ; ans is the minimum valid number ; Driver Code","code":"< ? php $ MAX = 100001 ; $ primeUpto = array_fill ( 0 , $ MAX , 0 ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ primeUpto ; $ isPrime = array_fill ( 0 , $ MAX , true ) ; $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { for ( $ j = $ i * 2 ; $ j < $ MAX ; $ j += $ i ) $ isPrime [ $ j ] = false ; } } for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) { $ primeUpto [ $ i ] = $ primeUpto [ $ i - 1 ] ; if ( $ isPrime [ $ i ] ) $ primeUpto [ $ i ] ++ ; } } function countOfNumbers ( $ N , $ K ) { SieveOfEratosthenes ( ) ; global $ primeUpto ; $ low = 1 ; $ high = $ N ; $ ans = 0 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( $ mid - $ primeUpto [ $ mid ] >= $ K ) { $ ans = $ mid ; $ high = $ mid - 1 ; } else $ low = $ mid + 1 ; } return ( $ ans ? $ N - $ ans + 1 : 0 ) ; } $ N = 10 ; $ K = 3 ; echo countOfNumbers ( $ N , $ K ) ; ? >"}
{"text":"Find the element whose multiplication with | Function to find minimum index such that sum becomes 0 when the element is multiplied by - 1 ; Find array sum ; Find element with value equal to sum \/ 2 ; when sum is equal to 2 * element then this is our required element ; Driver code","code":"< ? php function minIndex ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( 2 * $ arr [ $ i ] == $ sum ) return ( $ i + 1 ) ; } return -1 ; } $ arr = array ( 1 , 3 , -5 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo ( minIndex ( $ arr , $ n ) ) ; ? >"}
{"text":"Find the intersection of two Matrices | Function to print the resultant matrix ; print element value for equal elements else * ; Driver Code","code":"< ? php function printIntersection ( $ A , $ B ) { $ N = 4 ; $ M = 4 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ A [ $ i ] [ $ j ] == $ B [ $ i ] [ $ j ] ) echo $ A [ $ i ] [ $ j ] . \" \u2581 \" ; else echo \" * \u2581 \" ; } echo \" STRNEWLINE \" ; } } $ A = array ( array ( 2 , 4 , 6 , 8 ) , array ( 1 , 3 , 5 , 7 ) , array ( 8 , 6 , 4 , 2 ) , array ( 7 , 5 , 3 , 1 ) ) ; $ B = array ( array ( 2 , 3 , 6 , 8 ) , array ( 1 , 3 , 5 , 2 ) , array ( 8 , 1 , 4 , 2 ) , array ( 3 , 5 , 4 , 1 ) ) ; printIntersection ( $ A , $ B ) ; ? >"}
{"text":"Count Triplets such that one of the numbers can be written as sum of the other two | Function to count the number of ways to choose the triples ; compute the max value in the array and create frequency array of size max_val + 1. We can also use HashMap to store frequencies . We have used an array to keep remaining code simple . ; Case 1 : 0 , 0 , 0 ; Case 2 : 0 , x , x ; Case 3 : x , x , 2 * x ; Case 4 : x , y , x + y iterate through all pairs ( x , y ) ; Driver code","code":"< ? php function countWays ( $ arr , $ n ) { $ max_val = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ max_val = max ( $ max_val , $ arr [ $ i ] ) ; $ freq = array_fill ( 0 , $ max_val + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ $ arr [ $ i ] ] ++ ; $ ans += ( int ) ( $ freq [ 0 ] * ( $ freq [ 0 ] - 1 ) * ( $ freq [ 0 ] - 2 ) \/ 6 ) ; for ( $ i = 1 ; $ i <= $ max_val ; $ i ++ ) $ ans += ( int ) ( $ freq [ 0 ] * $ freq [ $ i ] * ( $ freq [ $ i ] - 1 ) \/ 2 ) ; for ( $ i = 1 ; 2 * $ i <= $ max_val ; $ i ++ ) $ ans += ( int ) ( $ freq [ $ i ] * ( $ freq [ $ i ] - 1 ) \/ 2 * $ freq [ 2 * $ i ] ) ; for ( $ i = 1 ; $ i <= $ max_val ; $ i ++ ) { for ( $ j = $ i + 1 ; $ i + $ j <= $ max_val ; $ j ++ ) $ ans += $ freq [ $ i ] * $ freq [ $ j ] * $ freq [ $ i + $ j ] ; } return $ ans ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = count ( $ arr ) ; echo countWays ( $ arr , $ n ) ; ? >"}
{"text":"Longest subarray with elements having equal modulo K | function to find longest sub - array whose elements gives same remainder when divided with K ; Iterate in the array ; check if array element greater then X or not ; Driver code","code":"< ? php function LongestSubarray ( $ arr , $ n , $ k ) { $ cnt = 1 ; $ max_length = 1 ; $ prev_mod = $ arr [ 0 ] % $ k ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_mod = $ arr [ $ i ] % $ k ; if ( $ curr_mod == $ prev_mod ) { $ cnt ++ ; } else { $ max_length = max ( $ max_length , $ cnt ) ; $ cnt = 1 ; $ prev_mod = $ curr_mod ; } } return max ( $ max_length , $ cnt ) ; } $ arr = array ( 4 , 9 , 7 , 18 , 29 , 11 ) ; $ n = count ( $ arr ) ; $ k = 11 ; echo LongestSubarray ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Search in a sorted 2D matrix ( Stored in row major order ) | Php program to find whether a given element is present in the given 2 - D matrix ; Basic binary search to find an element in a 1 - D array ; if element found return true ; if middle less than K then skip the left part of the array else skip the right part ; if not found return false ; Function to search an element in a matrix based on Divide and conquer approach ; if the element lies in the range of this row then call 1 - D binary search on this row ; if the element is less then the starting element of that row then search in upper rows else search in the lower rows ; if not found ; Driver code","code":"< ? php $ M = 3 ; $ N = 4 ; function binarySearch1D ( $ arr , $ K ) { $ low = 0 ; $ high = $ GLOBALS [ ' N ' ] - 1 ; while ( $ low <= $ high ) { $ mid = $ low + ( int ) ( $ high - $ low ) \/ 2 ; if ( $ arr [ $ mid ] == $ K ) return True ; if ( $ arr [ $ mid ] < $ K ) $ low = $ mid + 1 ; else $ high = $ mid - 1 ; } return False ; } function searchMatrix ( $ matrix , $ K ) { $ low = 0 ; $ high = $ GLOBALS [ ' M ' ] - 1 ; while ( $ low <= $ high ) { $ mid = $ low + ( int ) ( $ high - $ low ) \/ 2 ; if ( $ K >= $ matrix [ $ mid ] [ 0 ] && $ K <= $ matrix [ $ mid ] [ $ GLOBALS [ ' N ' ] - 1 ] ) return binarySearch1D ( $ matrix [ $ mid ] , $ K ) ; if ( $ K < $ matrix [ $ mid ] [ 0 ] ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return False ; } $ matrix = array ( [ 1 , 3 , 5 , 7 ] , [ 10 , 11 , 16 , 20 ] , [ 23 , 30 , 34 , 50 ] ) ; $ K = 3 ; $ M = 3 ; $ N = 4 ; if ( searchMatrix ( $ matrix , $ K ) ) echo \" Found \" ; else echo \" Not \u2581 found \" ; ? >"}
{"text":"Number of elements that can be seen from right side | PHP program to find number of elements that can be seen from right side . ; Driver code","code":"< ? php function numberOfElements ( $ height , $ n ) { $ max_so_far = 0 ; $ coun = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ height [ $ i ] > $ max_so_far ) { $ max_so_far = $ height [ $ i ] ; $ coun ++ ; } } return $ coun ; } $ n = 6 ; $ height = array ( 4 , 8 , 2 , 0 , 0 , 5 ) ; echo numberOfElements ( $ height , $ n ) ;"}
{"text":"Largest element in the array that is repeated exactly k times | Function that finds the largest element which is repeated ' k ' times ; sort the array ; if the value of ' k ' is 1 and the largest appears only once in the array ; counter to count the repeated elements ; check if the element at index ' i ' is equal to the element at index ' i + 1' then increase the count ; else set the count to 1 to start counting the frequency of the new number ; if the count is equal to k and the previous element is not equal to this element ; if there is no such element ; Driver code ; find the largest element that is repeated K times","code":"< ? php function solve ( & $ arr , $ n , $ k ) { sort ( $ arr ) ; if ( $ k == 1 && $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) { echo $ arr [ $ n - 1 ] ; echo ( \" STRNEWLINE \" ) ; return ; } $ count = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ count ++ ; else $ count = 1 ; if ( $ count == $ k && ( $ i == 0 || ( $ arr [ $ i - 1 ] != $ arr [ $ i ] ) ) ) { echo ( $ arr [ $ i ] ) ; echo ( \" STRNEWLINE \" ) ; return ; } } echo ( \" No \u2581 such \u2581 element \" ) ; echo ( \" STRNEWLINE \" ) ; } $ arr = array ( 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 ) ; $ k = 2 ; $ n = sizeof ( $ arr ) ; solve ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Sum and Product of minimum and maximum element of an Array | Function to find minimum element ; Function to find maximum element ; Function to get Sum ; Function to get product ; Driver Code ; Sum of min and max element ; Product of min and max element","code":"< ? php function getMin ( $ arr , $ n ) { $ res = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , $ arr [ $ i ] ) ; return $ res ; } function getMax ( $ arr , $ n ) { $ res = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ arr [ $ i ] ) ; return $ res ; } function findSum ( $ arr , $ n ) { $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; return $ min + $ max ; } function findProduct ( $ arr , $ n ) { $ min = getMin ( $ arr , $ n ) ; $ max = getMax ( $ arr , $ n ) ; return $ min * $ max ; } $ arr = array ( 12 , 1234 , 45 , 67 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum = \" \u2581 . \u2581 findSum ( $ arr , \u2581 $ n ) \u2581 . \u2581 \" \" ; STRNEWLINE echo \u2581 \" Product = \""}
{"text":"Count characters with same neighbors | Function to count the characters with same adjacent characters ; if length is less than 3 then return length as there will be only two characters ; Traverse the string ; Increment the count if the previous and next character is same ; Return count ; Driver code","code":"< ? php function countChar ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n <= 2 ) return $ n ; $ count = 2 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ i + 1 ] ) $ count ++ ; return $ count ; } $ str = \" egeeksk \" ; echo countChar ( $ str ) ; ? >"}
{"text":"First strictly smaller element in a sorted array in Java | PHP program to find first element that is strictly smaller than given target . ; Minimum size of the array should be 1 ; If target lies beyond the max element , than the index of strictly smaller value than target should be ( end - 1 ) ; Move to the left side if the target is smaller ; Move right side ; Driver code","code":"< ? php function next0 ( $ arr , $ target ) { $ start = 0 ; $ end = sizeof ( $ arr ) - 1 ; if ( $ end == 0 ) return -1 ; if ( $ target > $ arr [ $ end ] ) return $ end ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) \/ 2 ) ; if ( $ arr [ $ mid ] >= $ target ) { $ end = $ mid - 1 ; } else { $ ans = $ mid ; $ start = $ mid + 1 ; } } return $ ans ; } { $ arr = array ( 1 , 2 , 3 , 5 , 8 , 12 ) ; echo ( next0 ( $ arr , 5 ) ) ; }"}
{"text":"First strictly greater element in a sorted array in Java | PHP program to find first element that is strictly greater than given target . ; Move to right side if target is greater . ; Move left side . ; Driver code","code":"< ? php function next0 ( $ arr , $ target ) { $ start = 0 ; $ end = sizeof ( $ arr ) - 1 ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) \/ 2 ) ; if ( $ arr [ $ mid ] <= $ target ) { $ start = $ mid + 1 ; } else { $ ans = $ mid ; $ end = $ mid - 1 ; } } return $ ans ; } { $ arr = array ( 1 , 2 , 3 , 5 , 8 , 12 ) ; echo ( next0 ( $ arr , 8 ) ) ; } ? >"}
{"text":"Reallocation of elements based on Locality of Reference | A function to perform sequential search . ; Linearly search the element ; If not found ; Shift elements before one position ; Driver Code","code":"< ? php function search ( $ arr , $ n , $ x ) { $ res = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res = $ i ; if ( $ res == -1 ) return false ; $ temp = $ arr [ $ res ] ; for ( $ i = $ res ; $ i > 0 ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ 0 ] = $ temp ; return true ; } $ arr = array ( 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 ) ; $ q = array ( 63 , 63 , 86 , 63 , 78 ) ; $ n = sizeof ( $ arr ) ; $ m = sizeof ( $ q ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( search ( $ arr , $ n , $ q [ $ i ] ) ) echo \" Yes \u2581 \" ; else echo \" No \u2581 \" ;"}
{"text":"Probability of a key K present in array | Function to find the probability ; find probability ; Driver Code","code":"< ? php function kPresentProbability ( & $ a , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] == $ k ) $ count ++ ; return $ count \/ $ n ; } $ A = array ( 4 , 7 , 2 , 0 , 8 , 7 , 5 ) ; $ K = 2 ; $ N = sizeof ( $ A ) ; echo round ( kPresentProbability ( $ A , $ N , $ K ) , 2 ) ; ? >"}
{"text":"Find the slope of the given number | function to find slope of a number ; to store slope of the given number ' num ' ; loop from the 2 nd digit up to the 2 nd last digit of the given number ' num ' ; if the digit is a maxima ; if the digit is a minima ; required slope ; Driver Code","code":"< ? php function slopeOfNum ( $ num , $ n ) { $ slope = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ num [ $ i ] > $ num [ $ i - 1 ] && $ num [ $ i ] > $ num [ $ i + 1 ] ) $ slope ++ ; else if ( $ num [ $ i ] < $ num [ $ i - 1 ] && $ num [ $ i ] < $ num [ $ i + 1 ] ) $ slope ++ ; } return $ slope ; } $ num = \"1213321\" ; $ n = strlen ( $ num ) ; echo \" Slope = \" ? >"}
{"text":"Previous greater element | php program previous greater element A naive solution to print previous greater element for every element in an array . ; Previous greater for first element never exists , so we print - 1. ; Let us process remaining elements . ; Find first element on left side that is greater than arr [ i ] . ; If all elements on left are smaller . ; Driver code","code":"< ? php function prevGreater ( & $ arr , $ n ) { echo ( \" - 1 , \u2581 \" ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { echo ( $ arr [ $ j ] ) ; echo ( \" , \u2581 \" ) ; break ; } } if ( $ j == -1 ) echo ( \" - 1 , \u2581 \" ) ; } } $ arr = array ( 10 , 4 , 2 , 20 , 40 , 12 , 30 ) ; $ n = sizeof ( $ arr ) ; prevGreater ( $ arr , $ n ) ; ? >"}
{"text":"Duplicates in an array in O ( n ) time and by using O ( 1 ) extra space | Set | Function to find repeating elements ; Flag variable used to represent whether repeating element is found or not . ; Check if current element is repeating or not . If it is repeating then value will be greater than or equal to n . ; Check if it is first repetition or not . If it is first repetition then value at index arr [ i ] is less than 2 * n . Print arr [ i ] if it is first repetition . ; Add n to index arr [ i ] to mark presence of arr [ i ] or to mark repetition of arr [ i ] . ; If flag variable is not set then no repeating element is found . So print - 1. ; Driver Function","code":"< ? php function printDuplicates ( $ arr , $ n ) { $ i ; $ fl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ arr [ $ i ] % $ n ] >= $ n ) { if ( $ arr [ $ arr [ $ i ] % $ n ] < 2 * $ n ) { echo $ arr [ $ i ] % $ n . \" \" ; $ fl = 1 ; } } $ arr [ $ arr [ $ i ] % $ n ] += $ n ; } if ( ! $ fl ) echo \" - 1\" ; } $ arr = array ( 1 , 6 , 3 , 1 , 3 , 6 , 6 ) ; $ arr_size = sizeof ( $ arr ) ; printDuplicates ( $ arr , $ arr_size ) ;"}
{"text":"Find the smallest positive number missing from an unsorted array | Set 2 | Function to find smallest positive missing number . ; to store current array element ; to store next array element in current traversal ; if value is negative or greater than array size , then it cannot be marked in array . So move to next element . ; traverse the array until we reach at an element which is already marked or which could not be marked . ; find first array index which is not marked which is also the smallest positive missing number . ; if all indices are marked , then smallest missing positive number is array_size + 1. ; Driver code","code":"< ? php function findMissingNo ( $ arr , $ n ) { $ val ; $ nextval ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= 0 $ arr [ $ i ] > $ n ) continue ; $ val = $ arr [ $ i ] ; while ( $ arr [ $ val - 1 ] != $ val ) { $ nextval = $ arr [ $ val - 1 ] ; $ arr [ $ val - 1 ] = $ val ; $ val = $ nextval ; if ( $ val <= 0 $ val > $ n ) break ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] != $ i + 1 ) { return $ i + 1 ; } } return $ n + 1 ; } $ arr = array ( 2 , 3 , 7 , 6 , 8 , -1 , -10 , 15 ) ; $ arr_size = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ missing = findMissingNo ( $ arr , $ arr_size ) ; echo \" The \u2581 smallest \u2581 positive \u2581 \" . \" missing \u2581 number \u2581 is \u2581 \" , $ missing ; ? >"}
{"text":"Print all triplets with given sum | Prints all triplets in arr [ ] with given sum ; Driver code","code":"< ? php function findTriplets ( $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] == $ sum ) { echo $ arr [ $ i ] , \" \" , $ arr [ $ j ] , \" \" , $ arr [ $ k ] , \" \" ; } } } } } $ arr = array ( 0 , -1 , 2 , -3 , 1 ) ; $ n = sizeof ( $ arr ) ; findTriplets ( $ arr , $ n , -2 ) ; ? >"}
{"text":"Maximum product quadruple ( sub | Function to find a maximum product of a quadruple in array of integers of size n ; if size is less than 4 , no quadruple exists ; will contain max product ; Driver Code","code":"< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ max_product = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] * $ arr [ $ l ] ) ; return $ max_product ; } $ arr = array ( 10 , 3 , 5 , 6 , 20 ) ; $ n = count ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No \u2581 Quadruple \u2581 Exists \" ; else echo \" Maximum \u2581 product \u2581 is \u2581 \" , $ max ; ? >"}
{"text":"Maximum product quadruple ( sub | Function to find a maximum product of a quadruple in array of integers of size n ; if size is less than 4 , no quadruple exists ; Sort the array in ascending order ; Return the maximum of x , y and z ; Driver Code","code":"< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; sort ( $ arr ) ; $ x = $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] * $ arr [ $ n - 4 ] ; $ y = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] * $ arr [ 3 ] ; $ z = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] ; return max ( $ x , max ( $ y , $ z ) ) ; } $ arr = array ( -10 , -3 , 5 , 6 , -20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No \u2581 Quadruple \u2581 Exists \" ; else echo \" Maximum \u2581 product \u2581 is \u2581 \" . $ max ;"}
{"text":"Minimum value of \" max \u2581 + \u2581 min \" in a subarray | PHP program to find sum of maximum and minimum in any subarray of an array of positive numbers . ; Driver code","code":"< ? php function maxSum ( $ arr , $ n ) { if ( $ n < 2 ) return -1 ; $ ans = $ arr [ 0 ] + $ arr [ 1 ] ; for ( $ i = 1 ; $ i + 1 < $ n ; $ i ++ ) $ ans = min ( $ ans , ( $ arr [ $ i ] + $ arr [ $ i + 1 ] ) ) ; return $ ans ; } $ arr = array ( 1 , 12 , 2 , 2 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , $ n ) ; ? >"}
{"text":"Maximum sum of elements from each row in the matrix | PHP Program to find row - wise maximum element sum considering elements in increasing order . ; Function to perform given task ; Getting the maximum element from last row ; Comparing it with the elements of above rows ; Maximum of current row . ; If we could not an element smaller than prev_max . ; Driver code","code":"< ? php $ N = 3 ; function getGreatestSum ( $ a ) { global $ N ; $ prev_max = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max < $ a [ $ N - 1 ] [ $ j ] ) $ prev_max = $ a [ $ N - 1 ] [ $ j ] ; $ sum = $ prev_max ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ curr_max = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max > $ a [ $ i ] [ $ j ] and $ a [ $ i ] [ $ j ] > $ curr_max ) $ curr_max = $ a [ $ i ] [ $ j ] ; if ( $ curr_max == PHP_INT_MIN ) return -1 ; $ prev_max = $ curr_max ; $ sum += $ prev_max ; } return $ sum ; } $ a = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; echo getGreatestSum ( $ a ) , \" STRNEWLINE \" ; $ b = array ( array ( 4 , 5 , 6 ) , array ( 4 , 5 , 6 ) , array ( 4 , 5 , 6 ) ) ; echo getGreatestSum ( $ b ) , \" STRNEWLINE \" ; ? >"}
{"text":"Value of k | PHP program to fin k - th element after append and insert middle operations ; Middle element of the sequence ; length of the resulting sequence . ; Updating the middle element of next sequence ; Moving to the left side of the middle element . ; Moving to the right side of the middle element . ; Driver code","code":"< ? php function findElement ( $ n , $ k ) { $ ans = $ n ; $ left = 1 ; $ right = pow ( 2 , $ n ) - 1 ; while ( 1 ) { $ mid = ( $ left + $ right ) \/ 2 ; if ( $ k == $ mid ) { echo $ ans , \" STRNEWLINE \" ; break ; } $ ans -- ; if ( $ k < $ id ) $ right = $ mid - 1 ; else $ left = $ mid + 1 ; } } $ n = 4 ; $ k = 8 ; findElement ( $ n , $ k ) ; ? >"}
{"text":"Print pair with maximum AND value in an array | Utility function to check number of elements having set msb as of pattern ; Function for finding maximum and value pair ; iterate over total of 30 bits from msb to lsb ; find the count of element having set msb ; if count >= 2 set particular bit in result ; Find the elements ; print the pair of elements ; inc count value after printing element ; return the result value ; Driver code","code":"< ? php function checkBit ( $ pattern , $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ pattern & $ arr [ $ i ] ) == $ pattern ) $ count ++ ; return $ count ; } function maxAND ( $ arr , $ n ) { $ res = 0 ; for ( $ bit = 31 ; $ bit >= 0 ; $ bit -- ) { $ count = checkBit ( $ res | ( 1 << $ bit ) , $ arr , $ n ) ; if ( $ count >= 2 ) $ res |= ( 1 << $ bit ) ; } if ( $ res == 0 ) echo \" Not \u2581 Possible STRNEWLINE \" ; else { echo \" Pair = \" $ count = 0 ; for ( $ i = 0 ; $ i < $ n && $ count < 2 ; $ i ++ ) { if ( ( $ arr [ $ i ] & $ res ) == $ res ) { $ count ++ ; echo $ arr [ $ i ] . \" \" ; } } } return $ res ; } $ arr = array ( 4 , 8 , 6 , 2 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo \" Maximum AND Value = \" ? >"}
{"text":"Probability of choosing a random pair with maximum sum in an array | Function to get max first and second ; If current element is smaller than first , then update both first and second ; If arr [ i ] is in between first and second then update second ; frequency of first maximum ; frequency of second maximum ; Returns probability of choosing a pair with maximum sum . ; Driver Code","code":"< ? php function countMaxSumPairs ( $ a , $ n ) { $ first = PHP_INT_MIN ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ first ) { $ second = $ first ; $ first = $ a [ $ i ] ; } else if ( $ a [ $ i ] > $ second && $ a [ $ i ] != $ first ) $ second = $ a [ $ i ] ; } $ cnt1 = 0 ; $ cnt2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ first ) $ cnt1 ++ ; if ( $ a [ $ i ] == $ second ) $ cnt2 ++ ; } if ( $ cnt1 == 1 ) return $ cnt2 ; if ( $ cnt1 > 1 ) return $ cnt1 * ( $ cnt1 - 1 ) \/ 2 ; } function findMaxSumProbability ( $ a , $ n ) { $ total = $ n * ( $ n - 1 ) \/ 2 ; $ max_sum_pairs = countMaxSumPairs ( $ a , $ n ) ; return ( float ) $ max_sum_pairs \/ ( float ) $ total ; } $ a = array ( 1 , 2 , 2 , 3 ) ; $ n = sizeof ( $ a ) ; echo findMaxSumProbability ( $ a , $ n ) ; ? >"}
{"text":"Find if given number is sum of first n natural numbers | Function to find no . of elements to be added from 1 to get n ; Start adding numbers from 1 ; If sum becomes equal to s return n ; Drivers code","code":"< ? php function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; } $ s = 15 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo \" - 1\" ; else echo $ n ; ? >"}
{"text":"Save from Bishop in chessboard | function to calculate total safe position ; i , j denotes row and column of position of bishop ; calc distance in four direction ; calc total sum of distance + 1 for unsafe positions ; return total safe positions ; Driver Code","code":"< ? php function calcSafe ( $ pos ) { $ j = $ pos % 10 ; $ i = $ pos \/ 10 ; $ dis_11 = min ( abs ( 1 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_18 = min ( abs ( 1 - $ i ) , abs ( 8 - $ j ) ) ; $ dis_81 = min ( abs ( 8 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_88 = min ( abs ( 8 - $ i ) , abs ( 8 - $ j ) ) ; $ sum = $ dis_11 + $ dis_18 + $ dis_81 + $ dis_88 + 1 ; return ceil ( 64 - $ sum ) ; } $ pos = 34 ; echo \" Safe \u2581 Positions \u2581 = \u2581 \" , calcSafe ( $ pos ) ; ? >"}
{"text":"Count number of elements between two given elements in array | Function to count number of elements occurs between the elements . ; Find num1 ; If num1 is not present or present at end ; Find num2 ; If num2 is not present ; return number of elements betweenthe two elements . ; Driver Code","code":"< ? php function getCount ( $ arr , $ n , $ num1 , $ num2 ) { $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ num1 ) break ; if ( $ i >= $ n - 1 ) return 0 ; $ j ; for ( $ j = $ n - 1 ; $ j >= $ i + 1 ; $ j -- ) if ( $ arr [ $ j ] == $ num2 ) break ; if ( $ j == $ i ) return 0 ; return ( $ j - $ i - 1 ) ; } $ arr = array ( 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ) ; $ n = sizeof ( $ arr ) ; $ num1 = 5 ; $ num2 = 4 ; echo ( getCount ( $ arr , $ n , $ num1 , $ num2 ) ) ; ? >"}
{"text":"Count numbers with difference between number and its digit sum greater than specific value | method to get sum of digits of K ; loop until K is not zero ; method returns count of numbers smaller than N , satisfying difference condition ; binary search while loop ; if difference between number and its sum of digit is smaller than given difference then smallest number will be on left side ; if difference between number and its sum of digit is greater than or equal to given difference then smallest number will be on right side ; return the difference between ' smallest \u2581 number \u2581 \u2581 found ' and ' N ' as result ; Driver Code","code":"< ? php function sumOfDigit ( $ K ) { $ sod = 0 ; while ( $ K ) { $ sod += $ K % 10 ; $ K \/= 10 ; } return $ sod ; } function totalNumbersWithSpecificDifference ( $ N , $ diff ) { $ low = 1 ; $ high = $ N ; while ( $ low <= $ high ) { $ mid = floor ( ( $ low + $ high ) \/ 2 ) ; if ( $ mid - sumOfDigit ( $ mid ) < $ diff ) $ low = $ mid + 1 ; else $ high = $ mid - 1 ; } return ( $ N - $ high ) ; } $ N = 13 ; $ diff = 2 ; echo totalNumbersWithSpecificDifference ( $ N , $ diff ) ; ? >"}
{"text":"Number of buildings facing the sun | Returns count buildings that can see sunlight ; Initialuze result ( Note that first building always sees sunlight ) ; Start traversing element ; If curr_element is maximum or current element is equal , update maximum and increment count ; Driver code","code":"< ? php function countBuildings ( $ arr , $ n ) { $ count = 1 ; $ curr_max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ curr_max $ arr [ $ i ] == $ curr_max ) { $ count ++ ; $ curr_max = $ arr [ $ i ] ; } } return $ count ; } $ arr = array ( 7 , 4 , 8 , 2 , 9 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo countBuildings ( $ arr , $ n ) ; ? >"}
{"text":"Find index of an extra element present in one sorted array | Returns index of extra element in arr1 [ ] . n is size of arr2 [ ] . Size of arr1 [ ] is n - 1. ; Driver code ; Solve is passed both arrays","code":"< ? php function findExtra ( $ arr1 , $ arr2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return $ i ; return $ n ; } $ arr1 = array ( 2 , 4 , 6 , 8 , 10 , 12 , 13 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 , 10 , 12 ) ; $ n = sizeof ( $ arr2 ) ; echo findExtra ( $ arr1 , $ arr2 , $ n ) ; ? >"}
{"text":"Find index of an extra element present in one sorted array | Returns index of extra element in arr1 [ ] . n is size of arr2 [ ] . Size of arr1 [ ] is n - 1. ; Initialize result ; left and right are end points denoting the current range . ; If middle element is same of both arrays , it means that extra element is after mid so we update left to mid + 1 ; If middle element is different of the arrays , it means that the index we are searching for is either mid , or before mid . Hence we update right to mid - 1. ; when right is greater than left , our search is complete . ; Driver code ; Solve is passed both arrays","code":"< ? php function findExtra ( $ arr1 , $ arr2 , $ n ) { $ index = $ n ; $ left = 0 ; $ right = $ n - 1 ; while ( $ left <= $ right ) { $ mid = ( $ left + $ right ) \/ 2 ; if ( $ arr2 [ $ mid ] == $ arr1 [ $ mid ] ) $ left = $ mid + 1 ; else { $ index = $ mid ; $ right = $ mid - 1 ; } } return $ index ; } { $ arr1 = array ( 2 , 4 , 6 , 8 , 10 , 12 , 13 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 , 10 , 12 ) ; $ n = sizeof ( $ arr2 ) \/ sizeof ( $ arr2 [ 0 ] ) ; echo findExtra ( $ arr1 , $ arr2 , $ n ) ; return 0 ; } ? >"}
{"text":"Make all array elements equal with minimum cost | Utility method to compute cost , when all values of array are made equal to X ; Method to find minimum cost to make all elements equal ; setting limits for ternary search by smallest and largest element ; loop until difference between low and high become less than 3 , because after that mid1 and mid2 will start repeating ; mid1 and mid2 are representative array equal values of search space ; if mid2 point gives more total cost , skip third part ; if mid1 point gives more total cost , skip first part ; computeCost gets optimum cost by sending average of low and high as X ; Driver Code","code":"< ? php function computeCost ( $ arr , $ N , $ X ) { $ cost = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cost += abs ( $ arr [ $ i ] - $ X ) ; return $ cost ; } function minCostToMakeElementEqual ( $ arr , $ N ) { $ low ; $ high ; $ low = $ high = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ low > $ arr [ $ i ] ) $ low = $ arr [ $ i ] ; if ( $ high < $ arr [ $ i ] ) $ high = $ arr [ $ i ] ; } while ( ( $ high - $ low ) > 2 ) { $ mid1 = $ low + ( floor ( $ high - $ low ) \/ 3 ) ; $ mid2 = $ high - ( $ high - $ low ) \/ 3 ; $ cost1 = computeCost ( $ arr , $ N , $ mid1 ) ; $ cost2 = computeCost ( $ arr , $ N , $ mid2 ) ; if ( $ cost1 < $ cost2 ) $ high = $ mid2 ; else $ low = $ mid1 ; } return computeCost ( $ arr , $ N , ( $ low + $ high ) \/ 2 ) ; } $ arr = array ( 1 , 100 , 101 ) ; $ N = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo minCostToMakeElementEqual ( $ arr , $ N ) ; ? >"}
{"text":"Smallest element greater than X not present in the array | Function to return the smallest element greater than x which is not present in a [ ] ; Sort the array ; Continue until low is less than or equals to high ; Find mid ; If element at mid is less than or equals to searching element ; If mid is equals to searching element ; Increment searching element ; Make high as N - 1 ; Make low as mid + 1 ; Make high as mid - 1 ; Return the next greater element ; Driver code","code":"< ? php function Next_greater ( $ a , $ n , $ x ) { sort ( $ a ) ; $ low = 0 ; $ high = $ n - 1 ; $ ans = $ x + 1 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) \/ 2 ; if ( $ a [ $ mid ] <= $ ans ) { if ( $ a [ $ mid ] == $ ans ) { $ ans ++ ; $ high = $ n - 1 ; } $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; } $ a = array ( 1 , 5 , 10 , 4 , 7 ) ; $ x = 4 ; $ n = count ( $ a ) ; echo Next_greater ( $ a , $ n , $ x ) ; ? >"}
{"text":"Count number of subsets whose median is also present in the same subset | PHP implementation of the approach ; Function to return the factorial of a number ; Function to return the value of nCr ; Function to return a raised to the power n with complexity O ( log ( n ) ) ; Function to return the number of sub - sets whose median is also present in the set ; Number of odd length sub - sets ; Sort the array ; Checking each element for leftmost middle element while they are equal ; Calculate the number of elements in right of rightmost middle element ; Calculate the number of elements in left of leftmost middle element ; Add selected even length subsets to the answer ; Driver code","code":"< ? php $ mod = 1000000007 ; function fact ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function nCr ( $ n , $ r ) { return fact ( $ n ) \/ ( fact ( $ r ) * fact ( $ n - $ r ) ) ; } function powmod ( $ a , $ n ) { global $ mod ; if ( $ n == 0 ) return 1 ; $ pt = powmod ( $ a , $ n \/ 2 ) ; $ pt = ( $ pt * $ pt ) % $ mod ; if ( $ n % 2 == 1 ) return ( $ pt * $ a ) % $ mod ; else return $ pt ; } function CountSubset ( $ arr , $ n ) { global $ mod ; $ ans = powmod ( 2 , $ n - 1 ) ; sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ j = $ i + 1 ; while ( $ j < $ n && $ arr [ $ j ] == $ arr [ $ i ] ) { $ r = $ n - 1 - $ j ; $ l = $ i ; $ ans = ( $ ans + nCr ( $ l + $ r , $ l ) ) % $ mod ; $ j ++ ; } } return $ ans ; } { $ arr = array ( 2 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo ( CountSubset ( $ arr , $ n ) ) ; }"}
{"text":"Reorder the position of the words in alphabetical order | Function to print the ordering of words ; Creating list of words and assigning them index numbers ; Sort the list of words lexicographically ; Print the ordering ; Driver Code","code":"< ? php function reArrange ( $ words , $ n ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ words [ $ i ] ] = ( $ i + 1 ) ; } sort ( $ words ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ freq [ $ words [ $ i ] ] , \" \u2581 \" ; } $ words = array ( \" live \" , \" place \" , \" travel \" , \" word \" , \" sky \" ) ; $ n = count ( $ words ) ; reArrange ( $ words , $ n ) ; ? >"}
{"text":"Sum of elements in 1 st array such that number of elements less than or equal to them in 2 nd array is maximum | PHP implementation of the approach ; Function to return the required sum ; Creating hash array initially filled with zero ; Calculate the frequency of elements of arr2 [ ] ; Running sum of hash array such that hash [ i ] will give count of elements less than or equal to i in arr2 [ ] ; To store the maximum value of the number of elements in arr2 [ ] which are smaller than or equal to some element of arr1 [ ] ; Calculate the sum of elements from arr1 [ ] corresponding to maximum frequency ; Return the required sum ; Driver code","code":"< ? php $ MAX = 10000 ; function findSumofEle ( $ arr1 , $ m , $ arr2 , $ n ) { $ hash = array_fill ( 0 , $ GLOBALS [ ' MAX ' ] , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash [ $ arr2 [ $ i ] ] ++ ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' MAX ' ] ; $ i ++ ) $ hash [ $ i ] = $ hash [ $ i ] + $ hash [ $ i - 1 ] ; $ maximumFreq = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ maximumFreq = max ( $ maximumFreq , $ hash [ $ arr1 [ $ i ] ] ) ; $ sumOfElements = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ sumOfElements += ( $ maximumFreq == $ hash [ $ arr1 [ $ i ] ] ) ? $ arr1 [ $ i ] : 0 ; return $ sumOfElements ; } $ arr1 = array ( 2 , 5 , 6 , 8 ) ; $ arr2 = array ( 4 , 10 ) ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; echo findSumofEle ( $ arr1 , $ m , $ arr2 , $ n ) ; ? >"}
{"text":"Find A and B from list of divisors | Function to print A and B all of whose divisors are present in the given array ; Sort the array ; A is the largest element from the array ; Iterate from the second largest element ; If current element is not a divisor of A then it must be B ; If current element occurs more than once ; Print A and B ; Driver code","code":"< ? php function printNumbers ( $ arr , $ n ) { sort ( $ arr ) ; $ A = $ arr [ $ n - 1 ] ; $ B = -1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ A % $ arr [ $ i ] != 0 ) { $ B = $ arr [ $ i ] ; break ; } if ( $ i - 1 >= 0 && $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { $ B = $ arr [ $ i ] ; break ; } } echo ( \" A \u2581 = \u2581 \" . $ A . \" , B = \" } $ arr = array ( 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 ) ; $ n = sizeof ( $ arr ) ; printNumbers ( $ arr , $ n ) ;"}
{"text":"Find the modified array after performing k operations of given type | Utility function to print the contents of an array ; Function to remove the minimum value of the array from every element of the array ; Get the minimum value from the array ; Remove the minimum value from every element of the array ; Function to remove every element of the array from the maximum value of the array ; Get the maximum value from the array ; Remove every element of the array from the maximum value of the array ; Function to print the modified array after k operations ; If k is odd then remove the minimum element of the array from every element of the array ; Else remove every element of the array from the maximum value from the array ; Print the modified array ; Driver code","code":"< ? php function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } function removeMin ( & $ arr , $ n ) { $ minVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ minVal = min ( $ minVal , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ arr [ $ i ] - $ minVal ; } function removeFromMax ( & $ arr , $ n ) { $ maxVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ maxVal = max ( $ maxVal , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ maxVal - $ arr [ $ i ] ; } function modifyArray ( $ arr , $ n , $ k ) { if ( $ k % 2 == 0 ) removeMin ( $ arr , $ n ) ; else removeFromMax ( $ arr , $ n ) ; printArray ( $ arr , $ n ) ; } $ arr = array ( 4 , 8 , 12 , 16 ) ; $ n = count ( $ arr ) ; $ k = 2 ; modifyArray ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Minimize the sum of the squares of the sum of elements of each group the array is divided into | Function to return the minimized sum ; Sort the array to pair the elements ; Variable to hold the answer ; Pair smallest with largest , second smallest with second largest , and so on ; Driver code","code":"< ? php function findAnswer ( $ n , $ arr ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n \/ 2 ; ++ $ i ) { $ sum += ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) * ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) ; } return $ sum ; } $ arr = array ( 53 , 28 , 143 , 5 ) ; $ n = count ( $ arr ) ; echo findAnswer ( $ n , $ arr ) ; ? >"}
{"text":"Merge K sorted arrays | Set 3 ( Using Divide and Conquer Approach ) | PHP program to merge K sorted arrays ; Function to perform merge operation ; to store the starting point of left and right array ; to store the size of left and right array ; array to temporarily store left and right array ; storing data in left array ; storing data in right array ; to store the current index of temporary left and right array ; to store the current index for output array ; two pointer merge for two sorted arrays ; Code to drive merge - sort and create recursion tree ; base step to initialize the output array before performing merge operation ; to sort left half ; to sort right half ; merge the left and right half ; input 2D - array ; Number of arrays ; Output array ; Print merged array","code":"< ? php $ n = 4 ; function merge ( $ l , $ r , & $ output ) { global $ n ; $ l_in = $ l * $ n ; $ r_in = ( ( int ) ( ( $ l + $ r ) \/ 2 ) + 1 ) * $ n ; $ l_c = ( int ) ( ( ( ( $ l + $ r ) \/ 2 ) - $ l + 1 ) * $ n ) ; $ r_c = ( $ r - ( int ) ( ( $ l + $ r ) \/ 2 ) ) * $ n ; $ l_arr = array_fill ( 0 , $ l_c , 0 ) ; $ r_arr = array_fill ( 0 , $ r_c , 0 ) ; for ( $ i = 0 ; $ i < $ l_c ; $ i ++ ) $ l_arr [ $ i ] = $ output [ $ l_in + $ i ] ; for ( $ i = 0 ; $ i < $ r_c ; $ i ++ ) $ r_arr [ $ i ] = $ output [ $ r_in + $ i ] ; $ l_curr = 0 ; $ r_curr = 0 ; $ in = $ l_in ; while ( $ l_curr + $ r_curr < $ l_c + $ r_c ) { if ( $ r_curr == $ r_c || ( $ l_curr != $ l_c && $ l_arr [ $ l_curr ] < $ r_arr [ $ r_curr ] ) ) { $ output [ $ in ] = $ l_arr [ $ l_curr ] ; $ l_curr ++ ; $ in ++ ; } else { $ output [ $ in ] = $ r_arr [ $ r_curr ] ; $ r_curr ++ ; $ in ++ ; } } } function divide ( $ l , $ r , & $ output , $ arr ) { global $ n ; if ( $ l == $ r ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ output [ $ l * $ n + $ i ] = $ arr [ $ l ] [ $ i ] ; return ; } divide ( $ l , ( int ) ( ( $ l + $ r ) \/ 2 ) , $ output , $ arr ) ; divide ( ( int ) ( ( $ l + $ r ) \/ 2 ) + 1 , $ r , $ output , $ arr ) ; merge ( $ l , $ r , $ output ) ; } $ arr = array ( array ( 5 , 7 , 15 , 18 ) , array ( 1 , 8 , 9 , 17 ) , array ( 1 , 4 , 7 , 7 ) ) ; $ k = count ( $ arr ) ; $ output = array_fill ( 0 , $ n * $ k , 0 ) ; divide ( 0 , $ k - 1 , $ output , $ arr ) ; for ( $ i = 0 ; $ i < $ n * $ k ; $ i ++ ) print ( $ output [ $ i ] . \" \u2581 \" ) ; ? >"}
{"text":"Count distinct elements in an array | PHP program to count distinct elements in a given array ; Pick all elements one by one ; If not printed earlier , then print it ; Driver Code","code":"< ? php function countDistinct ( & $ arr , $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) break ; if ( $ i == $ j ) $ res ++ ; } return $ res ; } $ arr = array ( 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 ) ; $ n = count ( $ arr ) ; echo countDistinct ( $ arr , $ n ) ; ? >"}
{"text":"Count distinct elements in an array | PHP program to count all distinct elements in a given array ; First sort the array so that all occurrences become consecutive ; Traverse the sorted array ; Move the index ahead while there are duplicates ; Driver Code","code":"< ? php function countDistinct ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n - 1 && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ i ++ ; $ res ++ ; } return $ res ; } $ arr = array ( 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ) ; $ n = sizeof ( $ arr ) ; echo countDistinct ( $ arr , $ n ) ; ? >"}
{"text":"Choose n elements such that their mean is maximum | Utility function to print the contents of an array ; Function to print the array with maximum mean ; Sort the original array ; Construct new array ; Print the resultant array ; Driver code","code":"< ? php function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } function printMaxMean ( $ arr , $ n ) { $ newArr [ $ n ] = array ( ) ; sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ newArr [ $ i ] = $ arr [ $ i + $ n ] ; printArray ( $ newArr , $ n ) ; } $ arr = array ( 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 ) ; $ n = sizeof ( $ arr ) ; printMaxMean ( $ arr , $ n \/ 2 ) ;"}
{"text":"Average of remaining elements after removing K largest and K smallest elements from array | Function to find average ; base case if 2 * k >= n means all element get removed ; first sort all elements ; sum of req number ; find average ; Driver code","code":"< ? php function average ( $ arr , $ n , $ k ) { $ total = 0 ; if ( 2 * $ k >= $ n ) return 0 ; sort ( $ arr ) ; $ start = $ k ; $ end = $ n - $ k - 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) $ total += $ arr [ $ i ] ; return ( $ total \/ ( $ n - 2 * $ k ) ) ; } $ arr = array ( 1 , 2 , 4 , 4 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; echo average ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Minimum sum after subtracting multiples of k from the elements of the array | function to calculate minimum sum after transformation ; no element can be reduced further ; if all the elements of the array are identical ; check if a [ i ] can be reduced to a [ 0 ] ; one of the elements cannot be reduced to be equal to the other elements ; if k = 1 then all elements can be reduced to 1 ; Driver code","code":"< ? php function min_sum ( $ n , $ k , $ a ) { sort ( $ a ) ; if ( $ a [ 0 ] < 0 ) return -1 ; if ( $ k == 0 ) { if ( $ a [ 0 ] == $ a [ $ n - 1 ] ) return ( $ n * $ a [ 0 ] ) ; else return -1 ; } else { $ f = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ p = $ a [ $ i ] - $ a [ 0 ] ; if ( $ p % $ k == 0 ) continue ; else { $ f = 1 ; break ; } } if ( $ f ) return -1 ; else { if ( $ k == 1 ) return $ n ; else return ( $ n * ( $ a [ 0 ] % $ k ) ) ; } } } $ arr = array ( 2 , 3 , 4 , 5 ) ; $ K = 1 ; $ N = count ( $ arr ) ; echo min_sum ( $ N , $ K , $ arr ) ; ? >"}
{"text":"Minimum Increment \/ decrement to make array elements equal | Function to return minimum operations need to be make each element of array equal ; Initialize cost to 0 ; Sort the array ; Middle element ; Find Cost ; If n , is even . Take minimum of the Cost obtained by considering both middle elements ; Find cost again ; Take minimum of two cost ; Return total cost ; Driver Code","code":"< ? php function minCost ( $ A , $ n ) { $ cost = 0 ; sort ( $ A ) ; $ K = $ A [ $ n \/ 2 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += abs ( $ A [ $ i ] - $ K ) ; if ( $ n % 2 == 0 ) { $ tempCost = 0 ; $ K = $ A [ ( $ n \/ 2 ) - 1 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ tempCost += abs ( $ A [ $ i ] - $ K ) ; $ cost = min ( $ cost , $ tempCost ) ; } return $ cost ; } $ A = array ( 1 , 6 , 7 , 10 ) ; $ n = sizeof ( $ A ) ; echo minCost ( $ A , $ n ) ; ? >"}
{"text":"Print array elements in alternatively increasing and decreasing order | Function to print array elements in alternative increasing and decreasing order ; First sort the array in increasing order ; start with 2 elements in increasing order ; till all the elements are not printed ; printing the elements in increasing order ; else printing the elements in decreasing order ; increasing the number of elements to printed in next iteration ; Driver Code","code":"< ? php function printArray ( $ arr , $ n ) { sort ( $ arr ) ; $ l = 0 ; $ r = $ n - 1 ; $ flag = 0 ; $ k = 2 ; while ( $ l <= $ r ) { if ( $ flag == 0 ) { for ( $ i = $ l ; $ i < $ l + $ k && $ i <= $ r ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; $ flag = 1 ; $ l = $ i ; } { for ( $ i = $ r ; $ i > $ r - $ k && $ i >= $ l ; $ i -- ) echo $ arr [ $ i ] , \" \u2581 \" ; $ flag = 0 ; $ r = $ i ; } $ k ++ ; } } $ n = 6 ; $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text":"Check if the characters of a given string are in alphabetical order | Function that checks whether the string is in alphabetical order or not ; if element at index ' i ' is less than the element at index ' i - 1' then the string is not sorted ; Driver code ; check whether the string is in alphabetical order or not","code":"< ? php function isAlphabaticOrder ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] < $ s [ $ i - 1 ] ) return false ; } return true ; } $ s = \" aabbbcc \" ; if ( isAlphabaticOrder ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if it is possible to rearrange rectangles in a non | Function to check if it possible to form rectangles with heights as non - ascending ; set maximum ; replace the maximum with previous maximum ; replace the minimum with previous minimum ; print NO if the above two conditions fail at least once ; initialize the number of rectangles ; initialize n rectangles with length and breadth","code":"< ? php function rotateRec ( $ n , $ L , $ B ) { $ m = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( max ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = max ( $ L [ $ i ] , $ B [ $ i ] ) ; else if ( min ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = min ( $ L [ $ i ] , $ B [ $ i ] ) ; else { return 0 ; } } return 1 ; } $ n = 3 ; $ L = array ( 5 , 5 , 6 ) ; $ B = array ( 6 , 7 , 8 ) ; if ( rotateRec ( $ n , $ L , $ B ) == 1 ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find a point such that sum of the Manhattan distances is minimized | Function to print the required points which minimizes the sum of Manhattan distances ; Sorting points in all k dimension ; Output the required k points ; Driver code ; function call to print required points","code":"< ? php function minDistance ( $ n , $ k , & $ point ) { for ( $ i = 0 ; $ i < $ k ; ++ $ i ) sort ( $ point [ $ i ] ) ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) echo $ point [ $ i ] [ ( ceil ( ( double ) $ n \/ 2 ) - 1 ) ] . \" \u2581 \" ; } $ n = 4 ; $ k = 4 ; $ point = array ( array ( 1 , 5 , 2 , 4 ) , array ( 6 , 2 , 0 , 6 ) , array ( 9 , 5 , 1 , 3 ) , array ( 6 , 7 , 5 , 9 ) ) ; minDistance ( $ n , $ k , $ point ) ; ? >"}
{"text":"Sort first k values in ascending order and remaining n | Function to sort the array ; Store the k elements in an array ; Store the remaining n - k elements in an array ; sorting the array from 0 to k - 1 places ; sorting the array from k to n places ; storing the values in the final array arr ; printing the array ; Driver code","code":"< ? php function printOrder ( $ arr , $ n , $ k ) { $ len1 = $ k ; $ len2 = $ n - $ k ; $ arr1 = array_fill ( 0 , $ k , 0 ) ; $ arr2 = array_fill ( 0 , ( $ n - $ k ) , 0 ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ arr1 [ $ i ] = $ arr [ $ i ] ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) $ arr2 [ $ i - $ k ] = $ arr [ $ i ] ; sort ( $ arr1 ) ; sort ( $ arr2 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ i < $ k ) $ arr [ $ i ] = $ arr1 [ $ i ] ; else { $ arr [ $ i ] = $ arr2 [ $ len2 - 1 ] ; $ len2 -= 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) print ( $ arr [ $ i ] . \" \u2581 \" ) ; } $ arr = array ( 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , -1 ) ; $ k = 4 ; $ n = count ( $ arr ) ; printOrder ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find the largest number that can be formed with the given digits | Function to generate largest possible number with given digits ; Declare a hash array of size 10 and initialize all the elements to zero ; store the number of occurrences of the digits in the given array into the hash table ; Traverse the hash in descending order to print the required number ; Print the number of times a digits occurs ; Driver code","code":"< ? php function findMaxNum ( $ arr , $ n ) { $ hash = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hash [ $ arr [ $ i ] ] += 1 ; for ( $ i = 9 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < $ hash [ $ i ] ; $ j ++ ) echo $ i ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 0 ) ; $ n = sizeof ( $ arr ) ; findMaxNum ( $ arr , $ n ) ; ? >"}
{"text":"Equally divide into two sets such that one set has maximum distinct elements | PHP program to equally divide n elements into two sets such that second set has maximum distinct elements . ; Driver code","code":"< ? php function distribution ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ count ++ ; return min ( $ count , $ n \/ 2 ) ; } $ arr = array ( 1 , 1 , 2 , 1 , 3 , 4 ) ; $ n = count ( $ arr ) ; echo ( distribution ( $ arr , $ n ) ) ; ? >"}
{"text":"Sort 3 numbers | PHP program to sort an array of size 3","code":"< ? php $ a = array ( 10 , 12 , 5 ) ; sort ( $ a ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) echo $ a [ $ i ] , \" \u2581 \" ; ? >"}
{"text":"Print triplets with sum less than k | A Simple PHP program to count triplets with sum smaller than a given value ; Fix the first element as A [ i ] ; Fix the second element as A [ j ] ; Now look for the third number ; Driver Code","code":"< ? php function printTriplets ( & $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] < $ sum ) { echo ( $ arr [ $ i ] ) ; echo ( \" , \u2581 \" ) ; echo ( $ arr [ $ j ] ) ; echo ( \" , \u2581 \" ) ; echo ( $ arr [ $ k ] ) ; echo ( \" STRNEWLINE \" ) ; } } } } $ arr = array ( 5 , 1 , 3 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; $ sum = 12 ; printTriplets ( $ arr , $ n , $ sum ) ; ? >"}
{"text":"Count number of triplets in an array having sum in the range [ a , b ] | Function to count triplets ; Initialize result ; Fix the first element as A [ i ] ; Fix the second element as A [ j ] ; Now look for the third number ; Driver Code","code":"< ? php function countTriplets ( $ arr , $ n , $ a , $ b ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ a && $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] <= $ b ) $ ans ++ ; } } return $ ans ; } $ arr = array ( 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ) ; $ n = sizeof ( $ arr ) ; $ a = 8 ; $ b = 16 ; echo countTriplets ( $ arr , $ n , $ a , $ b ) . \" \" ; ? >"}
{"text":"Count number of triplets in an array having sum in the range [ a , b ] | Function to find count of triplets having sum less than or equal to val . ; sort the input array . ; Initialize result ; to store sum ; Fix the first element ; Initialize other two elements as corner elements of subarray arr [ j + 1. . k ] ; Use Meet in the Middle concept . ; If sum of current triplet is greater , then to reduce it decrease k . ; If sum is less than or equal to given value , then add possible triplets ( k - j ) to result . ; Function to return count of triplets having sum in range [ a , b ] . ; to store count of triplets . ; Find count of triplets having sum less than or equal to b and subtract count of triplets having sum less than or equal to a - 1. ; Driver Code","code":"< ? php function countTripletsLessThan ( $ arr , $ n , $ val ) { sort ( $ arr ) ; $ ans = 0 ; $ sum ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { $ j = $ i + 1 ; $ k = $ n - 1 ; while ( $ j != $ k ) { $ sum = $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ; if ( $ sum > $ val ) $ k -- ; else { $ ans += ( $ k - $ j ) ; $ j ++ ; } } } return $ ans ; } function countTriplets ( $ arr , $ n , $ a , $ b ) { $ res ; $ res = countTripletsLessThan ( $ arr , $ n , $ b ) - countTripletsLessThan ( $ arr , $ n , $ a - 1 ) ; return $ res ; } $ arr = array ( 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ) ; $ n = sizeof ( $ arr ) ; $ a = 8 ; $ b = 16 ; echo countTriplets ( $ arr , $ n , $ a , $ b ) , \" \" ; ? >"}
{"text":"Sum of Areas of Rectangles possible for an array | Function to find area of rectangles ; sorting the array in descending order ; store the final sum of all the rectangles area possible ; temporary variable to store the length of rectangle ; Selecting the length of rectangle so that difference between any two number is 1 only . Here length is selected so flag is set ; flag is set means we have got length of rectangle ; length is set to a [ i + 1 ] so that if a [ i + 1 ] is less than a [ i ] by 1 then also we have the correct chice for length ; incrementing the counter one time more as we have considered a [ i + 1 ] element also so . ; Selecting the width of rectangle so that difference between any two number is 1 only . Here width is selected so now flag is again unset for next rectangle ; area is calculated for rectangle ; flag is set false for another rectangle which we can get from elements in array ; incrementing the counter one time more as we have considered a [ i + 1 ] element also so . ; Driver code","code":"< ? php function MaxTotalRectangleArea ( $ a , $ n ) { rsort ( $ a ) ; $ sum = 0 ; $ flag = false ; $ len ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ a [ $ i ] == $ a [ $ i + 1 ] or $ a [ $ i ] - $ a [ $ i + 1 ] == 1 ) and ( ! $ flag ) ) { $ flag = true ; $ len = $ a [ $ i + 1 ] ; $ i ++ ; } else if ( ( $ a [ $ i ] == $ a [ $ i + 1 ] or $ a [ $ i ] - $ a [ $ i + 1 ] == 1 ) and ( $ flag ) ) { $ sum = $ sum + $ a [ $ i + 1 ] * $ len ; $ flag = false ; $ i ++ ; } } return $ sum ; } $ a = array ( 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ) ; $ n = count ( $ a ) ; echo MaxTotalRectangleArea ( $ a , $ n ) ; ? >"}
{"text":"Stable sort for descending order | Bubble sort implementation to sort elements in descending order . ; Sorts a [ ] in descending order using bubble sort . ; Driver code","code":"< ? php function swap ( & $ x , & $ y ) { $ x ^= $ y ^= $ x ^= $ y ; } function print1 ( $ a , $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) echo ( $ a [ $ i ] . \" \u2581 \" ) ; echo ( \" STRNEWLINE \" ) ; } function sort1 ( $ a , $ n ) { for ( $ i = $ n ; $ i >= 0 ; $ i -- ) { for ( $ j = $ n ; $ j > $ n - $ i ; $ j -- ) { if ( $ a [ $ j ] > $ a [ $ j - 1 ] ) swap ( $ a [ $ j ] , $ a [ $ j - 1 ] ) ; } } print1 ( $ a , $ n ) ; } $ n = 6 ; $ a = array ( ) ; array_push ( $ a , 2 ) ; array_push ( $ a , 4 ) ; array_push ( $ a , 3 ) ; array_push ( $ a , 2 ) ; array_push ( $ a , 4 ) ; array_push ( $ a , 5 ) ; array_push ( $ a , 3 ) ; sort1 ( $ a , $ n ) ; ? >"}
{"text":"Sum of Manhattan distances between all pairs of points | Return the sum of distance between all the pair of points . ; for each point , finding distance to rest of the point ; Driver Code","code":"< ? php function distancesum ( $ x , $ y , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ sum += ( abs ( $ x [ $ i ] - $ x [ $ j ] ) + abs ( $ y [ $ i ] - $ y [ $ j ] ) ) ; return $ sum ; } $ x = array ( -1 , 1 , 3 , 2 ) ; $ y = array ( 5 , 6 , 5 , 3 ) ; $ n = count ( $ x ) ; echo distancesum ( $ x , $ y , $ n ) ; ? >"}
{"text":"Sum of Manhattan distances between all pairs of points | Return the sum of distance of one axis . ; sorting the array . ; for each point , finding the distance . ; Driver Code","code":"< ? php function distancesum ( $ arr , $ n ) { sort ( $ arr ) ; $ res = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res += ( $ arr [ $ i ] * $ i - $ sum ) ; $ sum += $ arr [ $ i ] ; } return $ res ; } function totaldistancesum ( $ x , $ y , $ n ) { return distancesum ( $ x , $ n ) + distancesum ( $ y , $ n ) ; } $ x = array ( -1 , 1 , 3 , 2 ) ; $ y = array ( 5 , 6 , 5 , 3 ) ; $ n = sizeof ( $ x ) ; echo totaldistancesum ( $ x , $ y , $ n ) , \" \" ; ? >"}
{"text":"Median after K additional integers | Find median of array after adding k elements ; sorting the array in increasing order . ; printing the median of array . Since n + K is always odd and K < n , so median of array always lies in the range of n . ; Driver Code","code":"< ? php function printMedian ( $ arr , $ n , $ K ) { sort ( $ arr ) ; echo $ arr [ ( $ n + $ K ) \/ 2 ] ; } $ arr = array ( 5 , 3 , 2 , 8 ) ; $ k = 3 ; $ n = count ( $ arr ) ; printMedian ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Sort an array according to absolute difference with a given value \" using \u2581 constant \u2581 extra \u2581 space \" | PHP program to sort an array based on absolute difference with a given value x . ; Below lines are similar to insertion sort ; Insert arr [ i ] at correct place ; Function to print the array ; Driver Code","code":"< ? php function arrange ( $ arr , $ n , $ x ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ x ) ; $ j = $ i - 1 ; if ( abs ( $ arr [ $ j ] - $ x ) > $ diff ) { $ temp = $ arr [ $ i ] ; while ( abs ( $ arr [ $ j ] - $ x ) > $ diff && $ j >= 0 ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j -- ; } $ arr [ $ j + 1 ] = $ temp ; } } return $ arr ; } function print_arr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr = array ( 10 , 5 , 3 , 9 , 2 ) ; $ n = sizeof ( $ arr ) ; $ x = 7 ; $ arr1 = arrange ( $ arr , $ n , $ x ) ; print_arr ( $ arr1 , $ n ) ; ? >"}
{"text":"Sort first half in ascending and second half in descending order | 1 | function to print half of the array in ascending order and the other half in descending order ; sorting the array ; printing first half in ascending order ; printing second half in descending order ; Driver code","code":"< ? php function printOrder ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; for ( $ j = $ n - 1 ; $ j >= $ n \/ 2 ; $ j -- ) echo $ arr [ $ j ] . \" \u2581 \" ; } $ arr = array ( 5 , 4 , 6 , 2 , 1 , 3 , 8 , -1 ) ; $ n = sizeof ( $ arr ) ; printOrder ( $ arr , $ n ) ; ? >"}
{"text":"Find the minimum and maximum amount to buy all N candies | Function to find the minimum amount to buy all candies ; Buy current candy ; And take k candies for free from the last ; Function to find the maximum amount to buy all candies ; Buy candy with maximum amount ; And get k candies for free from the starting ; Driver Code ; Function call","code":"< ? php function findMinimum ( $ arr , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res += $ arr [ $ i ] ; $ n = $ n - $ k ; } return $ res ; } function findMaximum ( $ arr , $ n , $ k ) { $ res = 0 ; $ index = 0 ; for ( $ i = $ n - 1 ; $ i >= $ index ; $ i -- ) { $ res += $ arr [ $ i ] ; $ index += $ k ; } return $ res ; } $ arr = array ( 3 , 2 , 1 , 4 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; sort ( $ arr ) ; sort ( $ arr , $ n ) ; echo findMinimum ( $ arr , $ n , $ k ) , \" \" , findMaximum ( $ arr , $ n , $ k ) ; return 0 ; ? >"}
{"text":"Find maximum height pyramid from the given array of objects | Returns maximum number of pyramidcal levels n boxes of given widths . ; Sort objects in increasing order of widths ; Initialize result ; Total width of previous level and total number of objects in previous level ; Number of object in current level . ; Width of current level . ; Picking the object . So increase current width and number of object . ; If current width and number of object are greater than previous . ; Update previous width , number of object on previous level . ; Reset width of current level , number of object on current level . ; Increment number of level . ; Driver Code","code":"< ? php function maxLevel ( $ boxes , $ n ) { sort ( $ boxes ) ; $ ans = 1 ; $ prev_width = $ boxes [ 0 ] ; $ prev_count = 1 ; $ curr_count = 0 ; $ curr_width = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_width += $ boxes [ $ i ] ; $ curr_count += 1 ; if ( $ curr_width > $ prev_width and $ curr_count > $ prev_count ) { $ prev_width = $ curr_width ; $ prev_count = $ curr_count ; $ curr_count = 0 ; $ curr_width = 0 ; $ ans ++ ; } } return $ ans ; } $ boxes = array ( 10 , 20 , 30 , 50 , 60 , 70 ) ; $ n = count ( $ boxes ) ; echo maxLevel ( $ boxes , $ n ) ; ? >"}
{"text":"Sort all even numbers in ascending order and then sort all odd numbers in descending order | To do two way sort . First sort even numbers in ascending order , then odd numbers in descending order . ; Make all odd numbers negative ; if ( $arr [ $i ] & 1 ) Check for odd ; Sort all numbers ; Retaining original array ; Driver code","code":"< ? php function twoWaySort ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] *= -1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] & 1 ) $ arr [ $ i ] *= -1 ; } $ arr = array ( 1 , 3 , 2 , 7 , 5 , 4 ) ; $ n = sizeof ( $ arr ) ; twoWaySort ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Possible to form a triangle from array values | Method prints possible triangle when array values are taken as sides ; If number of elements are less than 3 , then no triangle is possible ; first sort the array ; loop for all 3 consecutive triplets ; If triplet satisfies triangle condition , break ; Driver Code","code":"< ? php function isPossibleTriangle ( $ arr , $ N ) { if ( $ N < 3 ) return false ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ N - 2 ; $ i ++ ) if ( $ arr [ $ i ] + $ arr [ $ i + 1 ] > $ arr [ $ i + 2 ] ) return true ; } $ arr = array ( 5 , 4 , 3 , 1 , 2 ) ; $ N = count ( $ arr ) ; if ( isPossibleTriangle ( $ arr , $ N ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"K | PHP program to find the K - th smallest element after removing some integers from natural number . ; Return the K - th smallest element . ; Making an array , and mark all number as unmarked . ; Marking the number present in the given array . ; If j is unmarked , reduce k by 1. ; If k is 0 return j . ; Driver code","code":"< ? php $ MAX = 10000 ; function ksmallest ( $ arr , $ n , $ k ) { global $ MAX ; $ b = array_fill ( 0 , $ MAX , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ b [ $ arr [ $ i ] ] = 1 ; for ( $ j = 1 ; $ j < $ MAX ; $ j ++ ) { if ( $ b [ $ j ] != 1 ) $ k -- ; if ( $ k == 0 ) return $ j ; } } $ k = 1 ; $ arr = array ( 1 ) ; $ n = count ( $ arr ) ; echo ksmallest ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Sort an array when two halves are sorted | PHP program to Merge two sorted halves of array Into Single Sorted Array ; Sort the given array using sort STL ; Driver Code ; Print sorted Array","code":"< ? php function mergeTwoHalf ( & $ A , $ n ) { sort ( $ A , 0 ) ; } $ A = array ( 2 , 3 , 8 , -1 , 7 , 10 ) ; $ n = sizeof ( $ A ) ; mergeTwoHalf ( $ A , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ A [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Choose k array elements such that difference of maximum and minimum is minimized | Return minimum difference of maximum and minimum of k elements of arr [ 0. . n - 1 ] . ; Sorting the array . ; Find minimum value among all K size subarray . ; Driver Code","code":"< ? php function minDiff ( $ arr , $ n , $ k ) { $ INT_MAX = 2147483647 ; $ result = $ INT_MAX ; sort ( $ arr , $ n ) ; sort ( $ arr ) ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) $ result = min ( $ result , $ arr [ $ i + $ k - 1 ] - $ arr [ $ i ] ) ; return $ result ; } $ arr = array ( 10 , 100 , 300 , 200 , 1000 , 20 , 30 ) ; $ n = sizeof ( $ arr ) ; $ k = 3 ; echo minDiff ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Number of swaps to sort when only adjacent swapping allowed | This function merges two sorted arrays and returns inversion count in the arrays . ; i is index for left subarray ; j is index for right subarray ; k is index for resultant merged subarray ; this is tricky -- see above explanation \/ diagram for merge ( ) ; Copy the remaining elements of left subarray ( if there are any ) to temp ; Copy the remaining elements of right subarray ( if there are any ) to temp ; Copy back the merged elements to original array ; An auxiliary recursive function that sorts the input array and returns the number of inversions in the array . ; Divide the array into two parts and call _mergeSortAndCountInv ( ) for each of the parts ; Inversion count will be sum of inversions in left - part , right - part and number of inversions in merging ; Merge the two parts ; This function sorts the input array and returns the number of inversions in the array ; Driver progra to test above functions","code":"< ? php function merge ( & $ arr , & $ temp , $ left , $ mid , $ right ) { $ inv_count = 0 ; $ i = $ left ; $ j = $ mid ; $ k = $ left ; while ( ( $ i <= $ mid - 1 ) && ( $ j <= $ right ) ) { if ( $ arr [ $ i ] <= $ arr [ $ j ] ) $ temp [ $ k ++ ] = $ arr [ $ i ++ ] ; else { $ temp [ $ k ++ ] = $ arr [ $ j ++ ] ; $ inv_count = $ inv_count + ( $ mid - $ i ) ; } } while ( $ i <= $ mid - 1 ) $ temp [ $ k ++ ] = $ arr [ $ i ++ ] ; while ( $ j <= $ right ) $ temp [ $ k ++ ] = $ arr [ $ j ++ ] ; for ( $ i = $ left ; $ i <= $ right ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; return $ inv_count ; } function _mergeSort ( & $ arr , & $ temp , $ left , $ right ) { $ inv_count = 0 ; if ( $ right > $ left ) { $ mid = intval ( ( $ right + $ left ) \/ 2 ) ; $ inv_count = _mergeSort ( $ arr , $ temp , $ left , $ mid ) ; $ inv_count += _mergeSort ( $ arr , $ temp , $ mid + 1 , $ right ) ; $ inv_count += merge ( $ arr , $ temp , $ left , $ mid + 1 , $ right ) ; } return $ inv_count ; } function countSwaps ( & $ arr , $ n ) { $ temp = array_fill ( 0 , $ n , NULL ) ; return _mergeSort ( $ arr , $ temp , 0 , $ n - 1 ) ; } $ arr = array ( 1 , 20 , 6 , 4 , 5 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo \" Number \u2581 of \u2581 swaps \u2581 is \u2581 \" . countSwaps ( $ arr , $ n ) ; return 0 ; ? >"}
{"text":"Check whether a given number is even or odd | Returns true if n is even , else odd ; Driver code","code":"< ? php function isEven ( $ n ) { return ( $ n % 2 == 0 ) ; } $ n = 101 ; if ( isEven != true ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text":"Find Surpasser Count of each element in array | Function to find surpasser count of each element in array ; stores surpasser count for element arr [ i ] ; Function to print an array ; Driver Code","code":"< ? php function findSurpasser ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] > $ arr [ $ i ] ) $ count ++ ; echo $ count , \" \" ; } } function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 2 , 7 , 5 , 3 , 0 , 8 , 1 ) ; $ n = count ( $ arr ) ; echo \" Given \u2581 array \u2581 is \u2581 STRNEWLINE \" ; printArray ( $ arr , $ n ) ; echo \" Surpasser \u2581 Count \u2581 of \u2581 array \u2581 is \u2581 STRNEWLINE \" ; findSurpasser ( $ arr , $ n ) ; ? >"}
{"text":"Minimum sum of two numbers formed from digits of an array | Function to find and return minimum sum of two numbers formed from digits of the array . ; sort the array ; let two numbers be a and b ; fill a and b with every alternate digit of input array ; return the sum ; Driver code","code":"< ? php function solve ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ a = $ a * 10 + $ arr [ $ i ] ; else $ b = $ b * 10 + $ arr [ $ i ] ; } return $ a + $ b ; } $ arr = array ( 6 , 8 , 4 , 5 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum \u2581 is \u2581 \" , solve ( $ arr , $ n ) ; ? >"}
{"text":"Maximum product of a triplet ( subsequence of size 3 ) in array | Function to find a maximum product of a triplet in array of integers of size n ; if size is less than 3 , no triplet exists ; will contain max product ; Driver Code","code":"< ? php function maxProduct ( $ arr , $ n ) { $ INT_MIN = 0 ; if ( $ n < 3 ) return -1 ; $ max_product = $ INT_MIN ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] ) ; return $ max_product ; } $ arr = array ( 10 , 3 , 5 , 6 , 20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No \u2581 Triplet \u2581 Exists \" ; else echo \" Maximum \u2581 product \u2581 is \u2581 \" , $ max ; ? >"}
{"text":"Maximum product of a triplet ( subsequence of size 3 ) in array | Function to find a maximum product of a triplet in array of integers of size n ; if size is less than 3 , no triplet exists ; Construct four auxiliary vectors of size n and initialize them by - 1 ; will contain max product ; to store maximum element on left of array ; to store minimum element on left of array ; leftMax [ i ] will contain max element on left of arr [ i ] excluding arr [ i ] . leftMin [ i ] will contain min element on left of arr [ i ] excluding arr [ i ] . ; reset max_sum to store maximum element on right of array ; reset min_sum to store minimum element on right of array ; rightMax [ i ] will contain max element on right of arr [ i ] excluding arr [ i ] . rightMin [ i ] will contain min element on right of arr [ i ] excluding arr [ i ] . ; For all array indexes i except first and last , compute maximum of arr [ i ] * x * y where x can be leftMax [ i ] or leftMin [ i ] and y can be rightMax [ i ] or rightMin [ i ] . ; Driver program to test above functions","code":"< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 3 ) return -1 ; $ leftMin = array_fill ( 0 , $ n , -1 ) ; $ rightMin = array_fill ( 0 , $ n , -1 ) ; $ leftMax = array_fill ( 0 , $ n , -1 ) ; $ rightMax = array_fill ( 0 , $ n , -1 ) ; $ max_product = PHP_INT_MIN ; $ max_sum = $ arr [ 0 ] ; $ min_sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ leftMax [ $ i ] = $ max_sum ; if ( $ arr [ $ i ] > $ max_sum ) $ max_sum = $ arr [ $ i ] ; $ leftMin [ $ i ] = $ min_sum ; if ( $ arr [ $ i ] < $ min_sum ) $ min_sum = $ arr [ $ i ] ; } $ max_sum = $ arr [ $ n - 1 ] ; $ min_sum = $ arr [ $ n - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) { $ rightMax [ $ j ] = $ max_sum ; if ( $ arr [ $ j ] > $ max_sum ) $ max_sum = $ arr [ $ j ] ; $ rightMin [ $ j ] = $ min_sum ; if ( $ arr [ $ j ] < $ min_sum ) $ min_sum = $ arr [ $ j ] ; } for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ max1 = max ( $ arr [ $ i ] * $ leftMax [ $ i ] * $ rightMax [ $ i ] , $ arr [ $ i ] * $ leftMin [ $ i ] * $ rightMin [ $ i ] ) ; $ max2 = max ( $ arr [ $ i ] * $ leftMax [ $ i ] * $ rightMin [ $ i ] , $ arr [ $ i ] * $ leftMin [ $ i ] * $ rightMax [ $ i ] ) ; $ max_product = max ( $ max_product , max ( $ max1 , $ max2 ) ) ; } return $ max_product ; } $ arr = array ( 1 , 4 , 3 , -6 , -7 , 0 ) ; $ n = count ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No \u2581 Triplet \u2581 Exists \" ; else echo \" Maximum \u2581 product \u2581 is \u2581 \" . $ max ; ? >"}
{"text":"Maximum product of a triplet ( subsequence of size 3 ) in array | Function to find a maximum product of a triplet in array of integers of size n ; if size is less than 3 , no triplet exists ; Sort the array in ascending order ; Return the maximum of product of last three elements and product of first two elements and last element ; Driver code","code":"< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 3 ) { return -1 ; } sort ( $ arr ) ; return max ( $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] , $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] ) ; } $ arr = array ( -10 , -3 , 5 , 6 , -20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) { echo ( \" No \u2581 Triplet \u2581 Exists \" ) ; } else { echo ( \" Maximum \u2581 product \u2581 is \u2581 \" . $ max ) ; }"}
{"text":"Largest substring with same Characters | Function to find largest sub string with same characters ; Traverse the string ; If character is same as previous increment temp value ; Return the required answer ; Driver code ; Function call","code":"< ? php function Substring ( $ s ) { $ ans = 1 ; $ temp = 1 ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { ++ $ temp ; } else { $ ans = max ( $ ans , $ temp ) ; $ temp = 1 ; } } $ ans = max ( $ ans , $ temp ) ; return $ ans ; } $ s = \" abcdddddeff \" ; echo Substring ( $ s ) ; ? >"}
{"text":"Generate an array of K elements such that sum of elements is N and the condition a [ i ] < a [ i + 1 ] <= 2 * a [ i ] is met | Set 2 | Function that print the desired array which satisfies the given conditions ; If the lowest filling condition is void , then it is not possible to generate the required array ; Increase all the elements by cnt ; Start filling from the back till the number is a [ i + 1 ] <= 2 * a [ i ] ; Get the number to be filled ; If it is less than the remaining numbers to be filled ; less than remaining numbers to be filled ; Get the sum of the array ; If this condition is void at any stage during filling up , then print - 1 ; Else add it to the sum ; If the sum condition is not satisified , then print - 1 ; Print the generated array ; Driver code","code":"< ? php function solve ( $ n , $ k ) { $ mini = 0 ; $ x1 = 1 ; $ a = array ( ) ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ mini += $ x1 ; $ a [ $ i - 1 ] = $ x1 ; $ x1 += 1 ; } if ( $ n < $ mini ) { echo \" - 1\" ; return ; } $ rem = $ n - $ mini ; $ cnt = floor ( $ rem \/ $ k ) ; $ rem = $ rem % $ k ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ a [ $ i ] += $ cnt ; for ( $ i = $ k - 1 ; $ i > 0 && $ rem > 0 ; $ i -- ) { $ xx = $ a [ $ i - 1 ] * 2 ; $ left = $ xx - $ a [ $ i ] ; if ( $ rem >= $ left ) { $ a [ $ i ] = $ xx ; $ rem -= $ left ; } else { $ a [ $ i ] += $ rem ; $ rem = 0 ; } } $ sum = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ k ; $ i ++ ) { if ( $ a [ $ i ] > 2 * $ a [ $ i - 1 ] ) { echo \" - 1\" ; return ; } $ sum += $ a [ $ i ] ; } if ( $ sum != $ n ) { echo \" - 1\" ; return ; } for ( $ i = 0 ; $ i < $ k ; $ i ++ ) echo $ a [ $ i ] , \" \u2581 \" ; } $ n = 26 ; $ k = 6 ; solve ( $ n , $ k ) ; ? >"}
{"text":"Maximum money that can be withdrawn in two steps | Function to return the maximum coins we can get ; Update elements such that X > Y ; Take from the maximum ; Refill ; Again , take the maximum ; Driver code","code":"< ? php function maxCoins ( $ X , $ Y ) { if ( $ X < $ Y ) swap ( $ X , $ Y ) ; $ coins = $ X ; $ X -- ; $ coins += max ( $ X , $ Y ) ; return $ coins ; } $ X = 7 ; $ Y = 5 ; echo maxCoins ( $ X , $ Y ) ; ? >"}
{"text":"Maximum elements which can be crossed using given units of a and b | Function to find the number of elements crossed ; Keep a copy of a ; Iterate in the binary array ; If no a and b left to use ; If there is no a ; use b and increase a by 1 if arr [ i ] is 1 ; simply use b ; Use a if theres no b ; Increase a and use b if arr [ i ] == 1 ; Use a ; Driver code","code":"< ? php function findElementsCrossed ( $ arr , $ a , $ b , $ n ) { $ aa = $ a ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a == 0 && $ b == 0 ) break ; else if ( $ a == 0 ) { if ( $ arr [ $ i ] == 1 ) { $ b -= 1 ; $ a = min ( $ aa , $ a + 1 ) ; } else $ b -= 1 ; } else if ( $ b == 0 ) $ a -- ; else if ( $ arr [ $ i ] == 1 && $ a < $ aa ) { $ b -= 1 ; $ a = min ( $ aa , $ a + 1 ) ; } else $ a -- ; $ ans ++ ; } return $ ans ; } $ arr = array ( 1 , 0 , 0 , 1 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; $ a = 1 ; $ b = 2 ; echo findElementsCrossed ( $ arr , $ a , $ b , $ n ) ; ? >"}
{"text":"Count the pairs of vowels in the given string | Function that return true if character ch is a vowel ; Function to return the count of adjacent vowel pairs in the given string ; If current character and the character after it are both vowels ; Driver code","code":"< ? php function isVowel ( $ ch ) { if ( $ ch == ' a ' $ ch == ' e ' $ ch == ' i ' $ ch == ' o ' $ ch == ' u ' ) return true ; return false ; } function vowelPairs ( $ s , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( isVowel ( $ s [ $ i ] ) && isVowel ( $ s [ $ i + 1 ] ) ) $ cnt ++ ; } return $ cnt ; } $ s = \" abaebio \" ; $ n = strlen ( $ s ) ; echo vowelPairs ( $ s , $ n ) ; ? >"}
{"text":"Minimum possible final health of the last monster in a game | Function to return the gcd of two numbers ; Function to return the minimum possible health for the monster ; gcd of first and second element ; gcd for all subsequent elements ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function solve ( $ health , $ n ) { $ currentgcd = gcd ( $ health [ 0 ] , $ health [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; ++ $ i ) { $ currentgcd = gcd ( $ currentgcd , $ health [ $ i ] ) ; } return $ currentgcd ; } $ health = array ( 4 , 6 , 8 , 12 ) ; $ n = sizeof ( $ health ) ; echo solve ( $ health , $ n ) ; ? >"}
{"text":"Divide array into increasing and decreasing subsequence without changing the order | Function to print strictly increasing and strictly decreasing sequence if possible ; Arrays to store strictly increasing and decreasing sequence ; Initializing last element of both sequence ; Iterating through the array ; If current element can be appended to both the sequences ; If next element is greater than the current element Then append it to the strictly increasing array ; Otherwise append it to the strictly decreasing array ; If current element can be appended to the increasing sequence only ; If current element can be appended to the decreasing sequence only ; Else we can not make such sequences from the given array ; Print the required sequences ; Driver code","code":"< ? php function Find_Sequence ( $ arr , $ n ) { $ inc_arr = array ( ) ; $ dec_arr = array ( ) ; $ inc = -1 ; $ dec = 1e7 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ inc < $ arr [ $ i ] && $ arr [ $ i ] < $ dec ) { if ( $ arr [ $ i ] < $ arr [ $ i + 1 ] ) { $ inc = $ arr [ $ i ] ; array_push ( $ inc_arr , $ arr [ $ i ] ) ; } else { $ dec = $ arr [ $ i ] ; array_push ( $ dec_arr , $ arr [ $ i ] ) ; } } else if ( $ inc < $ arr [ $ i ] ) { $ inc = $ arr [ $ i ] ; array_push ( $ inc_arr , $ arr [ $ i ] ) ; } else if ( $ dec > $ arr [ $ i ] ) { $ dec = $ arr [ $ i ] ; array_push ( $ dec_arr , $ arr [ $ i ] ) ; } else { echo ' - 1' ; break ; } } print_r ( $ inc_arr ) ; print_r ( $ dec_arr ) ; } $ arr = array ( 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 ) ; $ n = count ( $ arr ) ; Find_Sequence ( $ arr , $ n ) ; ? >"}
{"text":"Find the sum of digits of a number at even and odd places | Function to return the reverse of a number ; Function to find the sum of the odd and even positioned digits in a number ; If c is even number then it means digit extracted is at even place ; Driver code","code":"< ? php function reverse ( $ n ) { $ rev = 0 ; while ( $ n != 0 ) { $ rev = ( $ rev * 10 ) + ( $ n % 10 ) ; $ n = floor ( $ n \/ 10 ) ; } return $ rev ; } function getSum ( $ n ) { $ n = reverse ( $ n ) ; $ sumOdd = 0 ; $ sumEven = 0 ; $ c = 1 ; while ( $ n != 0 ) { if ( $ c % 2 == 0 ) $ sumEven += $ n % 10 ; else $ sumOdd += $ n % 10 ; $ n = floor ( $ n \/ 10 ) ; $ c ++ ; } echo \" Sum odd = \" , \u2581 $ sumOdd , \u2581 \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" Sum even = \" } $ n = 457892 ; getSum ( $ n ) ; ? >"}
{"text":"Count the number of currency notes needed | Function to return the amount of notes with value A required ; If possible ; Driver code","code":"< ? php function bankNotes ( $ A , $ B , $ S , $ N ) { $ numerator = $ S - ( $ B * $ N ) ; $ denominator = $ A - $ B ; if ( $ numerator % $ denominator == 0 ) return ( $ numerator \/ $ denominator ) ; return -1 ; } $ A = 1 ; $ B = 2 ; $ S = 7 ; $ N = 5 ; echo ( bankNotes ( $ A , $ B , $ S , $ N ) ) ; ? >"}
{"text":"Divide a number into two parts | Function to print the two parts ; Find the position of 4 ; If current character is not '4' but appears after the first occurrence of '4' ; Print both the parts ; Driver code","code":"< ? php function twoParts ( $ str ) { $ flag = 0 ; $ a = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '4' ) { $ str [ $ i ] = '3' ; $ a . = '1' ; $ flag = 1 ; } else if ( $ flag ) $ a . = '0' ; } echo $ str . \" \u2581 \" . $ a ; } $ str = \"9441\" ; twoParts ( $ str ) ; ? >"}
{"text":"Length of the longest substring with no consecutive same letters | Function to return the length of the required sub - string ; Get the length of the string ; Iterate in the string ; Check for not consecutive ; If cnt greater than maxi ; Re - initialize ; Check after iteration is complete ; Driver code","code":"< ? php function longestSubstring ( $ s ) { $ cnt = 1 ; $ maxi = 1 ; $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ i - 1 ] ) $ cnt ++ ; else { $ maxi = max ( $ cnt , $ maxi ) ; $ cnt = 1 ; } } $ maxi = max ( $ cnt , $ maxi ) ; return $ maxi ; } $ s = \" ccccdeededff \" ; echo longestSubstring ( $ s ) ; ? >"}
{"text":"Minimum number of changes such that elements are first Negative and then Positive | Function to return the count of minimum operations required ; To store the count of negative integers on the right of the current index ( inclusive ) ; Find the count of negative integers on the right ; If current element is negative ; To store the count of positive elements ; Find the positive integers on the left ; If current element is positive ; Update the answer ; Return the required answer ; Driver code","code":"< ? php function Minimum_Operations ( $ a , $ n ) { $ np = array ( ) ; $ np [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ np [ $ i ] = $ np [ $ i + 1 ] ; if ( $ a [ $ i ] <= 0 ) $ np [ $ i ] ++ ; } $ pos = 0 ; $ ans = $ n ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] >= 0 ) $ pos ++ ; $ ans = min ( $ ans , $ pos + $ np [ $ i + 1 ] ) ; } return $ ans ; } $ a = array ( -1 , 0 , 1 , 2 ) ; $ n = count ( $ a ) ; echo Minimum_Operations ( $ a , $ n ) ; ? >"}
{"text":"Sum of elements in an array whose difference with the mean of another array is less than k | Function for finding sum of elements whose diff with mean is not more than k ; Find the mean of second array ; Find sum of elements from array1 whose difference with mean is not more than k ; Return result ; Driver code","code":"< ? php function findSumofEle ( $ arr1 , $ m , $ arr2 , $ n , $ k ) { $ arraySum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arraySum += $ arr2 [ $ i ] ; $ mean = $ arraySum \/ $ n ; $ sumOfElements = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ difference = $ arr1 [ $ i ] - $ mean ; if ( ( $ difference < 0 ) && ( $ k > ( -1 ) * $ difference ) ) { $ sumOfElements += $ arr1 [ $ i ] ; } if ( ( $ difference >= 0 ) && ( $ k > $ difference ) ) { $ sumOfElements += $ arr1 [ $ i ] ; } } return $ sumOfElements ; } $ arr1 = array ( 1 , 2 , 3 , 4 , 7 , 9 ) ; $ arr2 = array ( 0 , 1 , 2 , 1 , 1 , 4 ) ; $ k = 2 ; $ m = count ( $ arr1 ) ; $ n = count ( $ arr2 ) ; print ( findSumofEle ( $ arr1 , $ m , $ arr2 , $ n , $ k ) ) ; ? >"}
{"text":"Find n positive integers that satisfy the given equations | Function to find n positive integers that satisfy the given conditions ; To store n positive integers ; Place N - 1 one 's ; If can not place ( y - ( n - 1 ) ) as the Nth integer ; Place Nth integer ; To store the sum of squares of N integers ; If it is less than x ; Print the required integers ; Driver code","code":"< ? php function findIntegers ( $ n , $ x , $ y ) { $ ans = array ( ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) array_push ( $ ans , 1 ) ; if ( $ y - ( $ n - 1 ) <= 0 ) { echo \" - 1\" ; return ; } array_push ( $ ans , $ y - ( $ n - 1 ) ) ; $ store = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ store += $ ans [ $ i ] * $ ans [ $ i ] ; if ( $ store < $ x ) { echo \" - 1\" ; return ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ ans [ $ i ] , \" \u2581 \" ; } $ n = 3 ; $ x = 254 ; $ y = 18 ; findIntegers ( $ n , $ x , $ y ) ; ? >"}
{"text":"Find the minimum number of steps to reach M from N | Function to find a minimum number of steps to reach M from N ; Continue till m is greater than n ; If m is odd ; add one ; divide m by 2 ; Return the required answer ; Driver code","code":"< ? php function Minsteps ( $ n , $ m ) { $ ans = 0 ; while ( $ m > $ n ) { if ( $ m % 2 != 0 ) { $ m ++ ; $ ans ++ ; } $ m \/= 2 ; $ ans ++ ; } return $ ans + $ n - $ m ; } $ n = 4 ; $ m = 6 ; echo ( Minsteps ( $ n , $ m ) ) ; ? >"}
{"text":"Find the number of jumps to reach X in the number line from zero | Utility function to calculate sum of numbers from 1 to x ; Function to find the number of jumps to reach X in the number line from zero ; First make number positive Answer will be same either it is Positive or negative ; To store required answer ; Continue till number is lesser or not in same parity ; Return the required answer ; Driver code","code":"< ? php function getsum ( $ x ) { return ( $ x * ( $ x + 1 ) ) \/ 2 ; } function countJumps ( $ n ) { $ n = abs ( $ n ) ; $ ans = 0 ; while ( getsum ( $ ans ) < $ n or ( getsum ( $ ans ) - $ n ) & 1 ) $ ans ++ ; return $ ans ; } $ n = 9 ; echo countJumps ( $ n ) ; ? >"}
{"text":"Maximum number of candies that can be bought | Function to return the maximum candies that can be bought ; Buy all the candies of the last type ; Starting from second last ; Amount of candies of the current type that can be bought ; Add candies of current type that can be bought ; Update the previous bought amount ; Driver code","code":"< ? php function maxCandies ( $ arr , $ n ) { $ prevBought = $ arr [ $ n - 1 ] ; $ candies = $ prevBought ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ x = min ( $ prevBought - 1 , $ arr [ $ i ] ) ; if ( $ x >= 0 ) { $ candies += $ x ; $ prevBought = $ x ; } } return $ candies ; } $ arr = array ( 1 , 2 , 1 , 3 , 6 ) ; $ n = sizeof ( $ arr ) ; echo ( maxCandies ( $ arr , $ n ) ) ; ? >"}
{"text":"Minimum changes required such that the string satisfies the given condition | Function to return the minimum changes required ; To store the count of minimum changes , number of ones and the number of zeroes ; First character has to be '1' ; If condition fails changes need to be made ; Return the required count ; Driver code","code":"< ? php function minChanges ( $ str , $ n ) { $ count = $ zeros = $ ones = 0 ; if ( $ str [ 0 ] != '1' ) { $ count ++ ; $ ones ++ ; } for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) $ zeros ++ ; else $ ones ++ ; if ( $ zeros > $ ones ) { $ zeros -- ; $ ones ++ ; $ count ++ ; } } return $ count ; } $ str = \"0000\" ; $ n = strlen ( $ str ) ; echo minChanges ( $ str , $ n ) ; ? >"}
{"text":"Count possible moves in the given direction in a grid | Function to return the count of possible steps in a single direction ; It can cover infinite steps ; We are approaching towards X = N ; We are approaching towards X = 1 ; Function to return the count of steps ; Take the minimum of both moves independently ; Update count and current positions ; Driver code","code":"< ? php function steps ( $ cur , $ x , $ n ) { if ( $ x == 0 ) return PHP_INT_MAX ; if ( $ x > 0 ) return floor ( abs ( ( $ n - $ cur ) \/ $ x ) ) ; else return floor ( abs ( ( $ cur - 1 ) \/ $ x ) ) ; } function countSteps ( $ curx , $ cury , $ n , $ m , $ moves ) { $ count = 0 ; $ k = sizeof ( $ moves ) ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ moves [ $ i ] [ 0 ] ; $ y = $ moves [ $ i ] [ 1 ] ; $ stepct = min ( steps ( $ curx , $ x , $ n ) , steps ( $ cury , $ y , $ m ) ) ; $ count += $ stepct ; $ curx += $ stepct * $ x ; $ cury += $ stepct * $ y ; } return $ count ; } $ n = 4 ; $ m = 5 ; $ x = 1 ; $ y = 1 ; $ moves = array ( array ( 1 , 1 ) , array ( 1 , 1 ) , array ( 0 , -2 ) ) ; $ k = sizeof ( $ moves ) ; echo countSteps ( $ x , $ y , $ n , $ m , $ moves ) ; ? >"}
{"text":"Minimum elements to be removed such that sum of adjacent elements is always odd | Returns the minimum number of eliminations ; Stores the previous element ; Stores the new value ; Check if the previous and current values are of same parity ; Previous value is now the current value ; Return the counter variable ; Driver code","code":"< ? php function min_elimination ( $ n , $ arr ) { $ count = 0 ; $ prev_val = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_val = $ arr [ $ i ] ; if ( $ curr_val % 2 == $ prev_val % 2 ) $ count ++ ; $ prev_val = $ curr_val ; } return $ count ; } $ arr = array ( 1 , 2 , 3 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; echo min_elimination ( $ n , $ arr ) ; ? >"}
{"text":"Count all possible N digit numbers that satisfy the given condition | Function to return the count of required numbers ; If N is odd then return 0 ; Driver Code","code":"< ? php function getCount ( $ N ) { if ( $ N % 2 == 1 ) return 0 ; $ result = \"9\" ; for ( $ i = 1 ; $ i <= $ N \/ 2 - 1 ; $ i ++ ) $ result . = \"0\" ; return $ result ; } $ N = 4 ; echo getCount ( $ N ) ; ? >"}
{"text":"Maximum number of teams that can be formed with given persons | Function that returns true if it possible to form a team with the given n and m ; 1 person of Type1 and 2 persons of Type2 can be chosen ; 1 person of Type2 and 2 persons of Type1 can be chosen ; Cannot from a team ; Function to return the maximum number of teams that can be formed ; To store the required count of teams formed ; Choose 2 persons of Type1 ; And 1 person of Type2 ; Choose 2 persons of Type2 ; And 1 person of Type1 ; Another team has been formed ; Driver code","code":"< ? php function canFormTeam ( $ n , $ m ) { if ( $ n >= 1 && $ m >= 2 ) return true ; if ( $ m >= 1 && $ n >= 2 ) return true ; return false ; } function maxTeams ( $ n , $ m ) { $ count = 0 ; while ( canFormTeam ( $ n , $ m ) ) { if ( $ n > $ m ) { $ n -= 2 ; $ m -= 1 ; } else { $ m -= 2 ; $ n -= 1 ; } $ count ++ ; } return $ count ; } $ n = 4 ; $ m = 5 ; echo maxTeams ( $ n , $ m ) ; ? >"}
{"text":"Find the Side of the smallest Square that can contain given 4 Big Squares | Function to find the maximum of two values ; Function to find the smallest side of the suitable suitcase ; sort array to find the smallest and largest side of suitcases ; side of the suitcase will be smallest if they arranged in 2 x 2 way so find all possible sides of that arrangement ; since suitcase should be square so find maximum of all four side ; now find greatest side and that will be the smallest square ; return the result ; Driver program ; Get the side of the 4 small squares ; Find the smallest side ; Get the side of the 4 small squares ; Find the smallest side","code":"< ? php function max1 ( $ a , $ b ) { if ( $ a > $ b ) return $ a ; else return $ b ; } function smallestSide ( $ a ) { sort ( $ a , 0 ) ; $ side1 = $ a [ 0 ] + $ a [ 3 ] ; $ side2 = $ a [ 1 ] + $ a [ 2 ] ; $ side3 = $ a [ 0 ] + $ a [ 1 ] ; $ side4 = $ a [ 2 ] + $ a [ 3 ] ; $ side11 = max1 ( $ side1 , $ side2 ) ; $ side12 = max1 ( $ side3 , $ side4 ) ; $ sideOfSquare = max1 ( $ side11 , $ side12 ) ; return $ sideOfSquare ; } $ side = array ( ) ; echo \" Test \u2581 Case \u2581 1 STRNEWLINE \" ; $ side [ 0 ] = 2 ; $ side [ 1 ] = 2 ; $ side [ 2 ] = 2 ; $ side [ 3 ] = 2 ; echo smallestSide ( $ side ) . \" STRNEWLINE \" ; echo \" Test Case 2 \" ; $ side [ 0 ] = 100000000000000 ; $ side [ 1 ] = 123450000000000 ; $ side [ 2 ] = 987650000000000 ; $ side [ 3 ] = 987654321000000 ; echo smallestSide ( $ side ) . \" STRNEWLINE \" ; ? >"}
{"text":"Rectangle with minimum possible difference between the length and the width | Function to print the length ( l ) and breadth ( b ) of the rectangle having area = N and | l - b | as minimum as possible ; i is a factor ; l >= sqrt ( area ) >= i ; so here l is + ve always ; Here l and b are length and breadth of the rectangle ; Driver code","code":"< ? php function find_rectangle ( $ area ) { $ M = floor ( sqrt ( $ area ) ) ; for ( $ i = $ M ; $ i >= 1 ; $ i -- ) { if ( $ area % $ i == 0 ) { $ l = floor ( $ area \/ $ i ) ; $ b = $ i ; break ; } } echo \" l = \" , \u2581 $ l , \u2581 \" , b = \" , \u2581 $ b , \u2581 \" \" } $ area = 99 ; find_rectangle ( $ area ) ; ? >"}
{"text":"Largest sub | Function to return the size of the required sub - set ; Sort the array ; Set to store the contents of the required sub - set ; Insert the elements satisfying the conditions ; Return the size of the set ; Driver code","code":"< ? php function sizeSubSet ( $ a , $ k , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % $ k != 0 or ! in_array ( floor ( $ a [ $ i ] \/ $ k ) , $ s ) ) array_push ( $ s , $ a [ $ i ] ) ; } return sizeof ( $ s ) ; } $ a = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = sizeof ( $ a ) ; $ k = 2 ; echo sizeSubSet ( $ a , $ k , $ n ) ; ? >"}
{"text":"Minimum number of sets with numbers less than Y | Function to find the minimum number of shets ; Variable to count the number of sets ; Iterate in the string ; Add the number to string ; Mark that we got a number ; else Every time it exceeds ; Check if previous was anytime less than Y ; Current number ; Check for current number ; Check for last added number ; Driver Code","code":"< ? php function minimumSets ( $ s , $ y ) { $ cnt = 0 ; $ num = 0 ; $ l = strlen ( $ s ) ; $ f = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; if ( $ num <= $ y ) $ f = 1 ; { if ( $ f ) $ cnt += 1 ; $ num = $ s [ $ i ] - '0' ; $ f = 0 ; if ( $ num <= $ y ) $ f = 1 ; else $ num = 0 ; } } if ( $ f ) $ cnt += 1 ; return $ cnt ; } $ s = \"1234\" ; $ y = 30 ; echo ( minimumSets ( $ s , $ y ) ) ; ? >"}
{"text":"Find the non decreasing order array from given array | Utility function to print the contents of the array ; Function to build array B [ ] ; Lower and upper limits ; To store the required array ; Apply greedy approach ; Print the built array b [ ] ; Driver code","code":"< ? php function printArr ( $ b , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ b [ $ i ] . \" \u2581 \" ; } function ModifiedArray ( $ a , $ n ) { $ l = 0 ; $ r = PHP_INT_MAX ; $ b = array ( 0 ) ; for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) { $ b [ $ i ] = max ( $ l , $ a [ $ i ] - $ r ) ; $ b [ $ n - $ i - 1 ] = $ a [ $ i ] - $ b [ $ i ] ; $ l = $ b [ $ i ] ; $ r = $ b [ $ n - $ i - 1 ] ; } printArr ( $ b , $ n ) ; } $ a = array ( 5 , 6 ) ; $ n = sizeof ( $ a ) ; ModifiedArray ( $ a , 2 * $ n ) ; ? >"}
{"text":"Maximum sum of all elements of array after performing given operations | Function to calculate Maximum Subarray Sum or Kadane 's Algorithm ; Function to find the maximum sum after given operations ; To store sum of all elements ; Maximum sum of a subarray ; Calculate the sum of all elements ; Driver Code ; size of an array","code":"< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; } function maxSum ( $ a , $ n ) { $ S = 0 ; $ S1 = maxSubArraySum ( $ a , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ S += $ a [ $ i ] ; return ( 2 * $ S1 - $ S ) ; } $ a = array ( -35 , 32 , -24 , 0 , 27 , -10 , 0 , -19 ) ; $ n = sizeof ( $ a ) ; echo ( maxSum ( $ a , $ n ) ) ;"}
{"text":"Minimize the difference between minimum and maximum elements | Function to minimize the difference between minimum and maximum elements ; Find max and min elements of the array ; Check whether the difference between the max and min element is less than or equal to k or not ; Calculate average of max and min ; If the array element is greater than the average then decrease it by k ; If the array element is smaller than the average then increase it by k ; Find max and min of the modified array ; return the new difference ; Driver code","code":"< ? php function minimizeDiff ( & $ arr , $ n , $ k ) { $ max = max ( $ arr ) ; $ min = min ( $ arr ) ; if ( ( $ max - $ min ) <= $ k ) { return ( $ max - $ min ) ; } $ avg = ( $ max + $ min ) \/ 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ avg ) $ arr [ $ i ] -= $ k ; else $ arr [ $ i ] += $ k ; } $ max = max ( $ arr ) ; $ min = min ( $ arr ) ; return ( $ max - $ min ) ; } $ arr = array ( 3 , 16 , 12 , 9 , 20 ) ; $ n = 5 ; $ k = 3 ; echo \" Max \u2581 height \u2581 difference \u2581 = \u2581 \" . minimizeDiff ( $ arr , $ n , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text":"Maximum litres of water that can be bought with N Rupees | PHP implementation of the above approach ; if buying glass bottles is profitable ; Glass bottles that can be bought ; Change budget according the bought bottles ; Plastic bottles that can be bought ; if only plastic bottles need to be bought ; Driver Code","code":"< ? php function maxLitres ( $ budget , $ plastic , $ glass , $ refund ) { if ( $ glass - $ refund < $ plastic ) { $ ans = max ( ( int ) ( $ budget - $ refund ) \/ ( $ glass - $ refund ) , 0 ) ; $ budget -= $ ans * ( $ glass - $ refund ) ; $ ans += ( int ) ( $ budget \/ $ plastic ) ; echo $ ans . \" STRNEWLINE \" ; } else echo ( int ) ( $ budget \/ $ plastic ) . \" STRNEWLINE \" ; } $ budget = 10 ; $ plastic = 11 ; $ glass = 9 ; $ refund = 8 ; maxLitres ( $ budget , $ plastic , $ glass , $ refund ) ; ? >"}
{"text":"Find number from given list for which value of the function is closest to A | Function to find number from given list for which value of the function is closest to A ; Stores the final index ; Declaring a variable to store the minimum absolute difference ; Finding F ( n ) ; Updating the index of the answer if new absolute difference is less than tmp ; Driver Code","code":"< ? php function leastValue ( $ P , $ A , $ N , $ a ) { $ ans = -1 ; $ tmp = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ t = $ P - $ a [ $ i ] * 0.006 ; if ( abs ( $ t - $ A ) < $ tmp ) { $ tmp = abs ( $ t - $ A ) ; $ ans = $ i ; } } return $ a [ $ ans ] ; } $ N = 2 ; $ P = 12 ; $ A = 5 ; $ a = array ( 1000 , 2000 ) ; print ( leastValue ( $ P , $ A , $ N , $ a ) ) ; ? >"}
{"text":"Find permutation of n which is divisible by 3 but not divisible by 6 | Function to find the permutation ; length of integer ; if integer is even ; return odd integer ; rotate integer ; return - 1 in case no required permutation exists ; Driver Code","code":"< ? php function findPermutation ( $ n ) { $ len = ceil ( log10 ( $ n ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ n % 2 != 0 ) { return ( int ) $ n ; } else { $ n = ( $ n \/ 10 ) + ( $ n % 10 ) * pow ( 10 , $ len - $ i - 1 ) ; continue ; } } return -1 ; } $ n = 132 ; echo findPermutation ( $ n ) ; ? >"}
{"text":"Check if it is possible to serve customer queue with different notes | Function that returns true is selling of the tickets is possible ; Nothing to return to the customer ; Check if 25 can be returned to customer . ; Try returning one 50 and one 25 ; Try returning three 25 ; If the loop did not break , all the tickets were sold ; Driver Code","code":"< ? php function isSellingPossible ( $ n , $ a ) { $ c25 = 0 ; $ c50 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 25 ) $ c25 ++ ; else if ( $ a [ $ i ] == 50 ) { $ c50 ++ ; if ( $ c25 == 0 ) break ; $ c25 -- ; } else { if ( $ c50 > 0 && $ c25 > 0 ) { $ c50 -- ; $ c25 -- ; } else if ( $ c25 >= 3 ) $ c25 -= 3 ; else break ; } } if ( $ i == $ n ) return true ; else return false ; } $ a = array ( 25 , 25 , 50 , 100 ) ; $ n = sizeof ( $ a ) ; if ( isSellingPossible ( $ n , $ a ) ) { echo \" YES \" ; } else { echo \" NO \" ; } ? >"}
{"text":"Check if a cell can be visited more than once in a String | Function to check if any cell can be visited more than once ; Array to mark cells ; Traverse the string ; Increase the visit count of the left and right cells within the array which can be visited ; If any cell can be visited more than once , Return True ; Driver code","code":"< ? php function checkIfOverlap ( $ str ) { $ len = strlen ( $ str ) ; $ visited = array_fill ( 0 , $ len + 1 , NULL ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == ' . ' ) continue ; for ( $ j = max ( 0 , $ i - $ str [ $ i ] ) ; $ j <= min ( $ len , $ i + $ str [ $ i ] ) ; $ j ++ ) $ visited [ $ j ] ++ ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ visited [ $ i ] > 1 ) { return true ; } } return false ; } $ str = \" . 2 . . 2 . \" ; if ( checkIfOverlap ( $ str ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Check if a number has digits in the given Order | Check if the digits follow the correct order ; to store the previous digit ; pointer to tell what type of sequence are we dealing with ; check if we have same digit as the previous digit ; checking the peak point of the number ; check if we have same digit as the previous digit ; check if the digit is greater than the previous one If true , then break from the loop as we are in descending order part ; Driver code","code":"< ? php function isCorrectOrder ( $ n ) { $ flag = true ; $ prev = -1 ; $ type = -1 ; while ( $ n != 0 ) { if ( $ type == -1 ) { if ( $ prev == -1 ) { $ prev = $ n % 10 ; $ n = ( int ) $ n \/ 10 ; continue ; } if ( $ prev == $ n % 10 ) { $ flag = false ; break ; } if ( $ prev > $ n % 10 ) { $ type = 1 ; $ prev = $ n % 10 ; $ n = ( int ) $ n \/ 10 ; continue ; } $ prev = $ n % 10 ; $ n = ( int ) $ n \/ 10 ; } else { if ( $ prev == $ n % 10 ) { $ flag = false ; break ; } if ( $ prev < $ n % 10 ) { $ flag = false ; break ; } $ prev = $ n % 10 ; $ n = ( int ) $ n \/ 10 ; } } return $ flag ; } $ n = 123454321 ; if ( isCorrectOrder ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Coin game of two corners ( Greedy Approach ) | Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Find sum of odd positioned coins ; Find sum of even positioned coins ; Print even or odd coins depending upon which sum is greater . ; Driver Code","code":"< ? php function printCoins ( & $ arr , $ n ) { $ oddSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) $ oddSum += $ arr [ $ i ] ; $ evenSum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) $ evenSum += $ arr [ $ i ] ; $ start = ( ( $ oddSum > $ evenSum ) ? 0 : 1 ) ; for ( $ i = $ start ; $ i < $ n ; $ i += 2 ) echo $ arr [ $ i ] . \" \u2581 \" ; } $ arr1 = array ( 8 , 15 , 3 , 7 ) ; $ n = sizeof ( $ arr1 ) ; printCoins ( $ arr1 , $ n ) ; echo \" STRNEWLINE \" ; $ arr2 = array ( 2 , 2 , 2 , 2 ) ; $ n = sizeof ( $ arr2 ) ; printCoins ( $ arr2 , $ n ) ; echo \" STRNEWLINE \" ; $ arr3 = array ( 20 , 30 , 2 , 2 , 2 , 10 ) ; $ n = sizeof ( $ arr3 ) ; printCoins ( $ arr3 , $ n ) ; ? >"}
{"text":"Final cell position in the matrix | function to find the final cell position in the given matrix ; to count up , down , left and cright movements ; to store the final coordinate position ; traverse the command array ; calculate final values ; Driver Code","code":"< ? php function finalPos ( $ command , $ n , $ x , $ y ) { $ cup ; $ cdown ; $ cleft ; $ cright ; $ final_x ; $ final_y ; $ cup = $ cdown = $ cleft = $ cright = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ command [ $ i ] == ' U ' ) $ cup ++ ; else if ( $ command [ $ i ] == ' D ' ) $ cdown ++ ; else if ( $ command [ $ i ] == ' L ' ) $ cleft ++ ; else if ( $ command [ $ i ] == ' R ' ) $ cright ++ ; } $ final_x = $ x + ( $ cright - $ cleft ) ; $ final_y = $ y + ( $ cdown - $ cup ) ; echo \" Final \u2581 Position : \u2581 \" . \" ( \" . $ final_x . \" , \u2581 \" . $ final_y . \" ) \" ; } $ command = \" DDLRULL \" ; $ n = strlen ( $ command ) ; $ x = 3 ; $ y = 4 ; finalPos ( $ command , $ n , $ x , $ y ) ;"}
{"text":"Smallest sum contiguous subarray | Set | Function to find the smallest sum contiguous subarray ; First invert the sign of the elements ; Apply the normal Kadane algorithm but on the elements of the array having inverted sign ; Invert the answer to get minimum val ; Driver Code","code":"< ? php function smallestSumSubarr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = - $ arr [ $ i ] ; $ sum_here = $ arr [ 0 ] ; $ max_sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum_here = max ( $ sum_here + $ arr [ $ i ] , $ arr [ $ i ] ) ; $ max_sum = max ( $ max_sum , $ sum_here ) ; } return ( -1 ) * $ max_sum ; } $ arr = array ( 3 , -4 , 2 , -3 , -1 , 7 , -5 ) ; $ n = sizeof ( $ arr ) ; echo \" Smallest \u2581 sum : \u2581 \" , smallestSumSubarr ( $ arr , $ n ) ; ? >"}
{"text":"Maximum number by concatenating every element in a rotation of an array | Function to print the largest number ; store the index of largest left most digit of elements ; Iterate for all numbers ; check for the the last digit ; check for the largest left most digit ; print the rotation of array ; print the rotation of array ; Driver Code","code":"< ? php function printLargest ( $ a , $ n ) { $ max = -1 ; $ ind = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num = $ a [ $ i ] ; while ( $ num ) { $ r = $ num % 10 ; $ num = ( int ) $ num \/ 10 ; if ( $ num == 0 ) { if ( $ max < $ r ) { $ max = $ r ; $ ind = $ i ; } } } } for ( $ i = $ ind ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ ind ; $ i ++ ) echo $ a [ $ i ] ; } $ a = array ( 54 , 546 , 548 , 60 ) ; $ n = sizeof ( $ a ) ; printLargest ( $ a , $ n ) ; ? >"}
{"text":"Minimum operations to make GCD of array a multiple of k | PHP program to make GCD of array a multiple of k . ; If array value is not 1 and it is greater than k then we can increase the or decrease the remainder obtained by dividing k from the ith value of array so that we get the number which is either closer to k or its multiple ; Else we only have one choice which is to increment the value to make equal to k ; Driver code","code":"< ? php function MinOperation ( $ a , $ n , $ k ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] != 1 && $ a [ $ i ] > $ k ) { $ result = $ result + min ( $ a [ $ i ] % $ k , $ k - $ a [ $ i ] % $ k ) ; } else { $ result = $ result + $ k - $ a [ $ i ] ; } } return $ result ; } $ arr = array ( 4 , 5 , 6 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ k = 5 ; echo MinOperation ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Maximum product subset of an array | PHP program to find maximum product of a subset . ; Find count of negative numbers , count of zeros , negative number with least absolute value and product of non - zero numbers ; If number is 0 , we don 't  multiply it with product. ; Count negatives and keep track of negative number with least absolute value . ; If there are all zeros ; If there are odd number of negative numbers ; Exceptional case : There is only negative and all other are zeros ; Otherwise result is product of all non - zeros divided by negative number with least absolute value . ; Driver Code","code":"< ? php function maxProductSubset ( $ a , $ n ) { if ( $ n == 1 ) return $ a [ 0 ] ; $ max_neg = PHP_INT_MIN ; $ count_neg = 0 ; $ count_zero = 0 ; $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 0 ) { $ count_zero ++ ; continue ; } if ( $ a [ $ i ] < 0 ) { $ count_neg ++ ; $ max_neg = max ( $ max_neg , $ a [ $ i ] ) ; } $ prod = $ prod * $ a [ $ i ] ; } if ( $ count_zero == $ n ) return 0 ; if ( $ count_neg & 1 ) { if ( $ count_neg == 1 && $ count_zero > 0 && $ count_zero + $ count_neg == $ n ) return 0 ; $ prod = $ prod \/ $ max_neg ; } return $ prod ; } $ a = array ( -1 , -1 , -2 , 4 , 3 ) ; $ n = sizeof ( $ a ) ; echo maxProductSubset ( $ a , $ n ) ; ? >"}
{"text":"Smallest number with sum of digits as N and divisible by 10 ^ N | PHP program to find smallest number to find smallest number with N as sum of digits and divisible by 10 ^ N . ; If N = 0 the string will be 0 ; If n is not perfectly divisible by 9 output the remainder ; Print 9 N \/ 9 times ; Append N zero 's to the number so  as to make it divisible by 10^N ; Driver Code","code":"< ? php function digitsNum ( $ N ) { if ( $ N == 0 ) echo \"0 STRNEWLINE \" ; if ( $ N % 9 != 0 ) echo ( $ N % 9 ) ; for ( $ i = 1 ; $ i <= ( $ N \/ 9 ) ; ++ $ i ) echo \"9\" ; for ( $ i = 1 ; $ i <= $ N ; ++ $ i ) echo \"0\" ; echo \" STRNEWLINE \" ; } $ N = 5 ; echo \" The \u2581 number \u2581 is \u2581 : \u2581 \" ; digitsNum ( $ N ) ; ? >"}
{"text":"Divide 1 to n into two groups with minimum sum difference | To print vector along size ; Print vector size ; Print vector elements ; To divide n in two groups such that absolute difference of their sum is minimum ; Find sum of all elements upto n ; Sum of elements of group1 ; If sum is greater then or equal to 0 include i in group 1 otherwise include in group2 ; Decrease sum of group1 ; Print both the groups ; Driver Code","code":"< ? php function printVector ( $ v ) { echo count ( $ v ) . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) echo $ v [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } function findTwoGroup ( $ n ) { $ sum = $ n * ( $ n + 1 ) \/ 2 ; $ group1Sum = ( int ) ( $ sum \/ 2 ) ; $ group1 ; $ group2 ; $ x = 0 ; $ y = 0 ; for ( $ i = $ n ; $ i > 0 ; $ i -- ) { if ( $ group1Sum - $ i >= 0 ) { $ group1 [ $ x ++ ] = $ i ; $ group1Sum -= $ i ; } else { $ group2 [ $ y ++ ] = $ i ; } } printVector ( $ group1 ) ; printVector ( $ group2 ) ; } $ n = 5 ; findTwoGroup ( $ n ) ; ? >"}
{"text":"Partition into two subarrays of lengths k and ( N | Function to calculate max_difference ; Sum of the array ; Sort the array in descending order ; Calculating max_difference ; Driver Code","code":"< ? php function maxDifference ( $ arr , $ N , $ k ) { $ M ; $ S = 0 ; $ S1 = 0 ; $ max_difference = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ S += $ arr [ $ i ] ; rsort ( $ arr ) ; $ M = max ( $ k , $ N - $ k ) ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ S1 += $ arr [ $ i ] ; $ max_difference = $ S1 - ( $ S - $ S1 ) ; return $ max_difference ; } $ arr = array ( 8 , 4 , 5 , 2 , 10 ) ; $ N = count ( $ arr ) ; $ k = 2 ; echo maxDifference ( $ arr , $ N , $ k ) ; ? >"}
{"text":"Minimum sum of product of two arrays | Function to find the minimum product ; Find product of current elements and update result . ; If both product and b [ i ] are negative , we must increase value of a [ i ] to minimize result . ; If both product and a [ i ] are negative , we must decrease value of a [ i ] to minimize result . ; Similar to above two cases for positive product . ; Check if current difference becomes higher than the maximum difference so far . ; Driver Code","code":"< ? php function minproduct ( $ a , $ b , $ n , $ k ) { $ diff = 0 ; $ res = 0 ; $ temp ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ pro = $ a [ $ i ] * $ b [ $ i ] ; $ res = $ res + $ pro ; if ( $ pro < 0 and $ b [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro < 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] > 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; $ d = abs ( $ pro - $ temp ) ; if ( $ d > $ diff ) $ diff = $ d ; } return $ res - $ diff ; } $ a = array ( 2 , 3 , 4 , 5 , 4 , 0 ) ; $ b = array ( 3 , 4 , 2 , 3 , 2 ) ; $ n = 5 ; $ k = 3 ; echo minproduct ( $ a , $ b , $ n , $ k ) ; ? >"}
{"text":"Split n into maximum composite numbers | function to calculate the maximum number of composite numbers adding upto n ; 4 is the smallest composite number ; stores the remainder when n is divided by 4 ; if remainder is 0 , then it is perfectly divisible by 4. ; if the remainder is 1 ; If the number is less then 9 , that is 5 , then it cannot be expressed as 4 is the only composite number less than 5 ; If the number is greater then 8 , and has a remainder of 1 , then express n as n - 9 a and it is perfectly divisible by 4 and for 9 , count 1. ; When remainder is 2 , just subtract 6 from n , so that n is perfectly divisible by 4 and count 1 for 6 which is subtracted . ; if the number is 7 , 11 which cannot be expressed as sum of any composite numbers ; when the remainder is 3 , then subtract 15 from it and n becomes perfectly divisible by 4 and we add 2 for 9 and 6 , which is getting subtracted to make n perfectly divisible by 4. ; driver program to test the above function","code":"< ? php function c_ount ( $ n ) { if ( $ n < 4 ) return -1 ; $ rem = $ n % 4 ; if ( $ rem == 0 ) return $ n \/ 4 ; if ( $ rem == 1 ) { if ( $ n < 9 ) return -1 ; return ( $ n - 9 ) \/ 4 + 1 ; } if ( $ rem == 2 ) return ( $ n - 6 ) \/ 4 + 1 ; if ( $ rem == 3 ) { if ( $ n < 15 ) return -1 ; return ( $ n - 15 ) \/ 4 + 2 ; } } $ n = 90 ; echo c_ount ( $ n ) , \" STRNEWLINE \" ; $ n = 143 ; echo c_ount ( $ n ) ; ? >"}
{"text":"Minimum rotations to unlock a circular lock | function for min rotation ; iterate till input and unlock code become 0 ; input and unlock last digit as reminder ; find min rotation ; update code and input ; Driver Code","code":"< ? php function minRotation ( $ input , $ unlock_code ) { $ rotation = 0 ; $ input_digit ; $ code_digit ; while ( $ input $ unlock_code ) { $ input_digit = $ input % 10 ; $ code_digit = $ unlock_code % 10 ; $ rotation += min ( abs ( $ input_digit - $ code_digit ) , 10 - abs ( $ input_digit - $ code_digit ) ) ; $ input \/= 10 ; $ unlock_code \/= 10 ; } return $ rotation ; } $ input = 28756 ; $ unlock_code = 98234 ; echo \" Minimum \u2581 Rotation \u2581 = \u2581 \" , minRotation ( $ input , $ unlock_code ) ; ? >"}
{"text":"Minimum cost for acquiring all coins with k extra coins allowed with every coin | Converts coin [ ] to prefix sum array ; sort the coins value ; Maintain prefix sum array ; Function to calculate min cost when we can get k extra coins after paying cost of one . ; calculate no . of coins needed ; return sum of from prefix array ; Driver Code","code":"< ? php function preprocess ( & $ coin , $ n ) { sort ( $ coin ) ; for ( $ i = 1 ; $ i <= $ n - 1 ; $ i ++ ) $ coin [ $ i ] += $ coin [ $ i - 1 ] ; } function minCost ( & $ coin , $ n , $ k ) { $ coins_needed = ceil ( 1.0 * $ n \/ ( $ k + 1 ) ) ; return $ coin [ $ coins_needed - 1 ] ; } $ coin = array ( 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ) ; $ n = sizeof ( $ coin ) ; preprocess ( $ coin , $ n ) ; $ k = 3 ; echo minCost ( $ coin , $ n , $ k ) . \" STRNEWLINE \" ; $ k = 7 ; echo minCost ( $ coin , $ n , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text":"Maximize array sum after K negations | Set 1 | This function does k operations on array in a way that maximize the array sum . index -- > stores the index of current minimum element for j 'th operation ; Modify array K number of times ; Find minimum element in array for current operation and modify it i . e ; arr [ j ] -- > - arr [ j ] ; this the condition if we find 0 as minimum element , so it will useless to replace 0 by - ( 0 ) for remaining operations ; Modify element of array ; Calculate sum of array ; Driver Code","code":"< ? php function maximumSum ( $ arr , $ n , $ k ) { $ INT_MAX = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ min = $ INT_MAX ; $ index = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] < $ min ) { $ min = $ arr [ $ j ] ; $ index = $ j ; } } if ( $ min == 0 ) break ; $ arr [ $ index ] = - $ arr [ $ index ] ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; return $ sum ; } $ arr = array ( -2 , 0 , 5 , -1 , 2 ) ; $ k = 4 ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo maximumSum ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Maximum sum such that no two elements are adjacent | Set 2 | PHP program to implement above approach ; variable to store states of dp ; variable to check if a given state has been solved ; Function to find the maximum sum subsequence such that no two elements are adjacent ; Base case ; To check if a state has been solved ; Required recurrence relation ; Returning the value ; Driver code","code":"< ? php $ maxLen = 10 ; $ dp = array_fill ( 0 , $ GLOBALS [ ' axLen ' , 0 ) ; $ v = array_fill ( 0 , $ GLOBALS [ ' axLen ' , 0 ) ; function maxSum ( $ arr , $ i , $ n ) { if ( $ i >= $ n ) return 0 ; if ( $ GLOBALS [ ' v ' ] [ $ i ] ) return $ GLOBALS [ ' dp ' ] [ $ i ] ; $ GLOBALS [ ' v ' ] [ $ i ] = 1 ; $ GLOBALS [ ' dp ' ] [ $ i ] = max ( maxSum ( $ arr , $ i + 1 , $ n ) , $ arr [ $ i ] + maxSum ( $ arr , $ i + 2 , $ n ) ) ; return $ GLOBALS [ ' dp ' ] [ $ i ] ; } $ arr = array ( 12 , 9 , 7 , 33 ) ; $ n = count ( $ arr ) ; echo maxSum ( $ arr , 0 , $ n ) ; ? >"}
{"text":"Maximize the subarray sum after multiplying all elements of any subarray with X | PHP implementation of the approach ; Function to return the maximum sum ; Base case ; If already calculated ; If no elements have been chosen ; Do not choose any element and use Kadane 's algorithm by taking max ; Choose the sub - array and multiply x ; Choose the sub - array and multiply x ; End the sub - array multiplication ; No more multiplication ; Memoize and return the answer ; Function to get the maximum sum ; Initialize dp with - 1 ; Iterate from every position and find the maximum sum which is possible ; Driver code","code":"< ? php $ N = 5 ; function func ( $ idx , $ cur , $ a , $ dp , $ n , $ x ) { if ( $ idx == $ n ) return 0 ; if ( $ dp [ $ idx ] [ $ cur ] != -1 ) return $ dp [ $ idx ] [ $ cur ] ; $ ans = 0 ; if ( $ cur == 0 ) { $ ans = max ( $ ans , $ a [ $ idx ] + func ( $ idx + 1 , 0 , $ a , $ dp , $ n , $ x ) ) ; $ ans = max ( $ ans , $ x * $ a [ $ idx ] + func ( $ idx + 1 , 1 , $ a , $ dp , $ n , $ x ) ) ; } else if ( $ cur == 1 ) { $ ans = max ( $ ans , $ x * $ a [ $ idx ] + func ( $ idx + 1 , 1 , $ a , $ dp , $ n , $ x ) ) ; $ ans = max ( $ ans , $ a [ $ idx ] + func ( $ idx + 1 , 2 , $ a , $ dp , $ n , $ x ) ) ; } else $ ans = max ( $ ans , $ a [ $ idx ] + func ( $ idx + 1 , 2 , $ a , $ dp , $ n , $ x ) ) ; return $ dp [ $ idx ] [ $ cur ] = $ ans ; } function getMaximumSum ( $ a , $ n , $ x ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = -1 ; } } $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ maxi = max ( $ maxi , func ( $ i , 0 , $ a , $ dp , $ n , $ x ) ) ; return $ maxi ; } $ a = array ( -3 , 8 , -2 , 1 , -6 ) ; $ n = count ( $ a ) ; $ x = -1 ; echo getMaximumSum ( $ a , $ n , $ x ) ; ? >"}
{"text":"Count pairs of non | PHP implementation of the approach ; Pre - processing function ; Get the size of the string ; Initially mark every position as false ; For the length ; Iterate for every index with length j ; If the length is less than 2 ; If characters are equal ; Check for equal ; Function to return the number of pairs ; Create the dp table initially ; Declare the left array ; Declare the right array ; Initially left [ 0 ] is 1 ; Count the number of palindrome pairs to the left ; Initially right most as 1 ; Count the number of palindrome pairs to the right ; Count the number of pairs ; Driver code","code":"< ? php $ N = 100 ; function pre_process ( $ dp , $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = false ; } for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ i = 0 ; $ i <= $ n - $ j ; $ i ++ ) { if ( $ j <= 2 ) { if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = true ; } else if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = $ dp [ $ i + 1 ] [ $ i + $ j - 2 ] ; } } return $ dp ; } function countPairs ( $ s ) { $ dp = array ( array ( ) ) ; $ dp = pre_process ( $ dp , $ s ) ; $ n = strlen ( $ s ) ; $ left = array_fill ( 0 , $ n , 0 ) ; $ right = array_fill ( 0 , $ n , 0 ) ; $ left [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ dp [ $ j ] [ $ i ] == 1 ) $ left [ $ i ] ++ ; } } $ right [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ right [ $ i ] = $ right [ $ i + 1 ] ; for ( $ j = $ n - 1 ; $ j >= $ i ; $ j -- ) { if ( $ dp [ $ i ] [ $ j ] == 1 ) $ right [ $ i ] ++ ; } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ ans += $ left [ $ i ] * $ right [ $ i + 1 ] ; return $ ans ; } $ s = \" abacaba \" ; echo countPairs ( $ s ) ; ? >"}
{"text":"Queries to check if substring [ L ... R ] is palindrome or not | PHP implementation of the approach ; Pre - processing function ; Get the size of the string ; Initially mark every position as false ; For the length ; Iterate for every index with length j ; If the length is less than 2 ; If characters are equal ; Check for equal ; Function to answer every query in O ( 1 ) ; Driver code","code":"< ? php $ N = 100 ; function pre_process ( $ dp , $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = false ; } for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ i = 0 ; $ i <= $ n - $ j ; $ i ++ ) { if ( $ j <= 2 ) { if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = true ; } else if ( $ s [ $ i ] == $ s [ $ i + $ j - 1 ] ) $ dp [ $ i ] [ $ i + $ j - 1 ] = $ dp [ $ i + 1 ] [ $ i + $ j - 2 ] ; } } return $ dp ; } function answerQuery ( $ l , $ r , $ dp ) { if ( $ dp [ $ l ] [ $ r ] ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; } $ s = \" abaaab \" ; $ dp = array ( array ( ) ) ; $ dp = pre_process ( $ dp , $ s ) ; $ queries = array ( array ( 0 , 1 ) , array ( 1 , 5 ) ) ; $ q = count ( $ queries ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) answerQuery ( $ queries [ $ i ] [ 0 ] , $ queries [ $ i ] [ 1 ] , $ dp ) ; ? >"}
{"text":"Length of the longest increasing subsequence such that no two adjacent elements are coprime | PHP program to find the length of the longest increasing sub sequence from the given array such that no two adjacent elements are co prime ; Function to find the length of the longest increasing sub sequence from the given array such that no two adjacent elements are co prime ; To store dp and d value ; To store required answer ; For all elements in the array ; Initially answer is one ; For all it 's divisors ; Update the dp value ; Update the divisor value ; Check for required answer ; Update divisor of a [ i ] ; Return required answer ; Driver code","code":"< ? php $ N = 100005 ; function LIS ( $ a , $ n ) { $ dp = array ( ) ; $ d = array ( ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ a [ $ i ] ] = 1 ; for ( $ j = 2 ; $ j * $ j <= $ a [ $ i ] ; $ j ++ ) { if ( $ a [ $ i ] % $ j == 0 ) { $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ j ] ] + 1 ) ; $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ a [ $ i ] \/ $ j ] ] + 1 ) ; $ d [ $ j ] = $ a [ $ i ] ; $ d [ $ a [ $ i ] \/ $ j ] = $ a [ $ i ] ; } } $ ans = max ( $ ans , $ dp [ $ a [ $ i ] ] ) ; $ d [ $ a [ $ i ] ] = $ a [ $ i ] ; } return $ ans ; } $ a = array ( 1 , 2 , 3 , 4 , 5 , 6 ) ; $ n = sizeof ( $ a ) ; echo LIS ( $ a , $ n ) ; ? >"}
{"text":"Find the sum of the diagonal elements of the given N X N spiral matrix | Function to return the sum of both the diagonal elements of the required matrix ; Array to store sum of diagonal elements ; Base cases ; Computing the value of dp ; Driver code","code":"< ? php function findSum ( $ n ) { $ dp = array ( ) ; $ dp [ 1 ] = 1 ; $ dp [ 0 ] = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = ( 4 * ( $ i * $ i ) ) - 6 * ( $ i - 1 ) + $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; } $ n = 4 ; echo findSum ( $ n ) ; ? >"}
{"text":"Count number of ways to reach a given score in a Matrix | PHP implementation of the approach ; To store the states of dp ; To check whether a particular state of dp has been solved ; Function to find the ways using memoization ; Base cases ; If required score becomes negative ; If current state has been reached before ; Set current state to visited ; Driver code","code":"< ? php $ n = 3 ; $ MAX = 30 ; $ dp = array ( $ n , $ n , $ MAX ) ; $ v = array ( $ n , $ n , $ MAX ) ; function findCount ( $ mat , $ i , $ j , $ m ) { if ( $ i == 0 && $ j == 0 ) { if ( $ m == $ mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( $ m < 0 ) return 0 ; if ( $ i < 0 $ j < 0 ) return 0 ; if ( $ v [ $ i ] [ $ j ] [ $ m ] ) return $ dp [ $ i ] [ $ j ] [ $ m ] ; $ v [ $ i ] [ $ j ] [ $ m ] = true ; $ dp [ $ i ] [ $ j ] [ $ m ] = findCount ( $ mat , $ i - 1 , $ j , $ m - $ mat [ $ i ] [ $ j ] ) + findCount ( $ mat , $ i , $ j - 1 , $ m - $ mat [ $ i ] [ $ j ] ) ; return $ dp [ $ i ] [ $ j ] [ $ m ] ; } $ mat = array ( array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) ) ; $ m = 5 ; echo ( findCount ( $ mat , $ n - 1 , $ n - 1 , $ m ) ) ;"}
{"text":"Minimum steps to delete a string by deleting substring comprising of same characters | PHP implementation of the approach ; Function to return the minimum number of delete operations ; When a single character is deleted ; When a group of consecutive characters are deleted if any of them matches ; When both the characters are same then delete the letters in between them ; Memoize ; Driver code","code":"< ? php $ GLOBALS [ ' N ' ] = 10 ; function findMinimumDeletion ( $ l , $ r , $ dp , $ s ) { if ( $ l > $ r ) return 0 ; if ( $ l == $ r ) return 1 ; if ( $ dp [ $ l ] [ $ r ] != -1 ) return $ dp [ $ l ] [ $ r ] ; $ res = 1 + findMinimumDeletion ( $ l + 1 , $ r , $ dp , $ s ) ; for ( $ i = $ l + 1 ; $ i <= $ r ; ++ $ i ) { if ( $ s [ $ l ] == $ s [ $ i ] ) $ res = min ( $ res , findMinimumDeletion ( $ l + 1 , $ i - 1 , $ dp , $ s ) + findMinimumDeletion ( $ i , $ r , $ dp , $ s ) ) ; } return $ dp [ $ l ] [ $ r ] = $ res ; } $ s = \" abcddcba \" ; $ n = strlen ( $ s ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; echo findMinimumDeletion ( 0 , $ n - 1 , $ dp , $ s ) ; ? >"}
{"text":"Find the number of distinct pairs of vertices which have a distance of exactly k in a tree | PHP implementation of the approach ; To store vertices and value of k ; To store number vertices at a level i ; To store the final answer ; Function to add an edge between two nodes ; Function to find the number of distinct pairs of the vertices which have a distance of exactly k in a tree ; At level zero vertex itself is counted ; Count the pair of vertices at distance k ; For all levels count vertices ; Driver code ; Add edges ; Function call ; Required answer","code":"< ? php $ N = 5005 ; $ gr = array_fill ( 0 , $ N , array ( ) ) ; $ d = array_fill ( 0 , $ N , array_fill ( 0 , 505 , 0 ) ) ; $ ans = 0 ; function Add_edge ( $ x , $ y ) { global $ gr ; array_push ( $ gr [ $ x ] , $ y ) ; array_push ( $ gr [ $ y ] , $ x ) ; } function dfs ( $ v , $ par ) { global $ d , $ ans , $ k , $ gr ; $ d [ $ v ] [ 0 ] = 1 ; foreach ( $ gr [ $ v ] as & $ i ) { if ( $ i != $ par ) { dfs ( $ i , $ v ) ; for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ ans += $ d [ $ i ] [ $ j - 1 ] * $ d [ $ v ] [ $ k - $ j ] ; for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) $ d [ $ v ] [ $ j ] += $ d [ $ i ] [ $ j - 1 ] ; } } } $ n = 5 ; $ k = 2 ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; echo $ ans ; ? >"}
{"text":"Sum of XOR of all subarrays | Function to calculate the sum of XOR of all subarrays ; variable to store the final sum ; multiplier ; variable to store number of sub - arrays with odd number of elements with ith bits starting from the first element to the end of the array ; variable to check the status of the odd - even count while calculating c_odd ; loop to calculate initial value of c_odd ; loop to iterate through all the elements of the array and update sum ; updating the multiplier ; returning the sum ; Driver Code","code":"< ? php function findXorSum ( $ arr , $ n ) { $ sum = 0 ; $ mul = 1 ; for ( $ i = 0 ; $ i < 30 ; $ i ++ ) { $ c_odd = 0 ; $ odd = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) > 0 ) $ odd = ( ! $ odd ) ; if ( $ odd ) $ c_odd ++ ; } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ sum += ( $ mul * $ c_odd ) ; if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) > 0 ) $ c_odd = ( $ n - $ j - $ c_odd ) ; } $ mul *= 2 ; } return $ sum ; } $ arr = array ( 3 , 8 , 13 ) ; $ n = sizeof ( $ arr ) ; echo findXorSum ( $ arr , $ n ) ; ? >"}
{"text":"Check if it is possible to get back to 12 '0 clock only by adding or subtracting given seconds | Function to check all combinations ; Generate all power sets ; Check for every combination ; Store sum for all combinations ; Check if jth bit in the counter is set If set then print jth element from set ; $sum += $a [ $j ] ; if set then consider as ' + ' ; $sum -= $a [ $j ] ; else consider as ' - ' ; If we can get back to 0 ; Driver Code","code":"< ? php function checkCombinations ( $ a , $ n ) { $ pow_set_size = pow ( 2 , $ n ) ; for ( $ counter = 0 ; $ counter < $ pow_set_size ; $ counter ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ counter & ( 1 << $ j ) ) else } if ( $ sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } $ a = array ( 60 , 60 , 120 ) ; $ n = sizeof ( $ a ) ; if ( checkCombinations ( $ a , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find probability of selecting element from kth column after N iterations | Function to calculate probability ; declare dp [ ] [ ] and sum [ ] ; precalculate the first row ; calculate the probability for each element and update dp table ; return result ; Driver code","code":"< ? php function calcProbability ( $ M , $ k ) { $ m = 4 ; $ n = 4 ; $ dp = array ( ) ; $ sum = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ dp [ 0 ] [ $ j ] = $ M [ 0 ] [ $ j ] ; $ sum [ 0 ] += $ dp [ 0 ] [ $ j ] ; } for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ dp [ $ i ] [ $ j ] += $ dp [ $ i - 1 ] [ $ j ] \/ $ sum [ $ i - 1 ] + $ M [ $ i ] [ $ j ] ; $ sum [ $ i ] += $ dp [ $ i ] [ $ j ] ; } } return $ dp [ $ n - 1 ] [ $ k - 1 ] \/ $ sum [ $ n - 1 ] ; } $ M = array ( array ( 1 , 1 , 0 , 3 ) , array ( 2 , 3 , 2 , 3 ) , array ( 9 , 3 , 0 , 2 ) , array ( 2 , 3 , 2 , 2 ) ) ; $ k = 3 ; echo calcProbability ( $ M , $ k ) ; ? >"}
{"text":"Possible cuts of a number such that maximum parts are divisible by 3 | Function to find the maximum number of numbers divisible by 3 in a large number ; store size of the string ; Stores last index of a remainder ; last visited place of remainder zero is at 0. ; To store result from 0 to i ; get the remainder ; Get maximum res [ i ] value ; Driver Code","code":"< ? php function MaximumNumbers ( $ s ) { $ n = strlen ( $ s ) ; $ remIndex = array_fill ( 0 , 3 , -1 ) ; $ remIndex [ 0 ] = 0 ; $ res = array ( ) ; $ r = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ r = ( $ r + $ s [ $ i - 1 ] - '0' ) % 3 ; $ res [ $ i ] = $ res [ $ i - 1 ] ; if ( $ remIndex [ $ r ] != -1 ) $ res [ $ i ] = max ( $ res [ $ i ] , $ res [ $ remIndex [ $ r ] ] + 1 ) ; $ remIndex [ $ r ] = $ i + 1 ; } return $ res [ $ n ] ; } $ s = \"12345\" ; print ( MaximumNumbers ( $ s ) ) # This  code is contributed by Ryuga NEW_LINE ? >"}
{"text":"Count number of paths whose weight is exactly X and has at | PHP program to count the number of paths ; Function to find the number of paths ; If the summation is more than X ; If exactly X weights have reached ; Already visited ; Count paths ; Traverse in all paths ; If the edge weight is M ; else Edge 's weight is not M ; Driver Code ; Initialized the DP array with - 1 ; Function to count paths","code":"< ? php $ max = 4 ; $ c = 2 ; function countPaths ( $ sum , $ get , $ m , $ n , & $ dp ) { global $ max , $ c ; if ( $ sum < 0 ) return 0 ; if ( $ sum == 0 ) return $ get ; if ( $ dp [ $ sum ] [ $ get ] != -1 ) return $ dp [ $ sum ] [ $ get ] ; $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i == $ m ) $ res += countPaths ( $ sum - $ i , 1 , $ m , $ n , $ dp ) ; $ res += countPaths ( $ sum - $ i , $ get , $ m , $ n , $ dp ) ; } $ dp [ $ sum ] [ $ get ] = $ res ; return $ dp [ $ sum ] [ $ get ] ; } $ n = 3 ; $ m = 2 ; $ x = 3 ; $ dp = array_fill ( 0 , $ max + 1 , NULL ) ; for ( $ i = 0 ; $ i <= $ max ; $ i ++ ) for ( $ j = 0 ; $ j < 2 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; echo countPaths ( $ x , 0 , $ m , $ n , $ dp ) ; ? >"}
{"text":"Sum of kth powers of first n natural numbers | A global array to store factorial ; Function to calculate the factorials of all the numbers upto k ; Function to return the binomial coefficient ; nCr = ( n ! * ( n - r ) ! ) \/ r ! ; Function to return the sum of kth powers of n natural numbers ; When j is unity ; Calculating sum ( n ^ 1 ) of unity powers of n ; storing sum ( n ^ 1 ) for sum ( n ^ 2 ) ; If k = 1 then temp is the result ; For finding sum ( n ^ k ) removing 1 and n * kCk from ( n + 1 ) ^ k ; Removing all kC2 * sum ( n ^ ( k - 2 ) ) + ... + kCk - 1 * ( sum ( n ^ ( k - ( k - 1 ) ) ; Storing the result for next sum of next powers of k ; Driver code","code":"< ? php $ MAX_K = 15 ; $ fac [ $ MAX_K ] = array ( ) ; function factorial ( $ k ) { global $ fac ; $ fac [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ k + 1 ; $ i ++ ) { $ fac [ $ i ] = ( $ i * $ fac [ $ i - 1 ] ) ; } } function bin ( $ a , $ b ) { global $ MAX_K ; global $ fac ; $ ans = ( ( $ fac [ $ a ] ) \/ ( $ fac [ $ a - $ b ] * $ fac [ $ b ] ) ) ; return $ ans ; } function sumofn ( $ n , $ k ) { $ p = 0 ; $ num1 ; $ temp ; $ arr [ 1000 ] = array ( ) ; for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) { if ( $ j == 1 ) { $ num1 = ( $ n * ( $ n + 1 ) ) \/ 2 ; $ arr [ $ p ++ ] = $ num1 ; $ temp = $ num1 ; } else { $ temp = ( pow ( $ n + 1 , $ j + 1 ) - 1 - $ n ) ; for ( $ s = 1 ; $ s < $ j ; $ s ++ ) { $ temp = $ temp - ( $ arr [ $ j - $ s - 1 ] * bin ( $ j + 1 , $ s + 1 ) ) ; } $ temp = $ temp \/ ( $ j + 1 ) ; $ arr [ $ p ++ ] = $ temp ; } } $ temp = $ arr [ $ p - 1 ] ; return $ temp ; } $ n = 5 ; $ k = 2 ; factorial ( $ k ) ; echo sumofn ( $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"Ways to fill N positions using M colors such that there are exactly K pairs of adjacent different colors | PHP implementation of the approach ; Recursive function to find the required number of ways ; When all positions are filled ; If adjacent pairs are exactly K ; If already calculated ; Next position filled with same color ; Next position filled with different color So there can be m - 1 different colors ; Driver Code","code":"< ? php $ GLOBALS [ ' max ' ] = 4 ; function countWays ( $ index , $ cnt , $ dp , $ n , $ m , $ k ) { if ( $ index == $ n ) { if ( $ cnt == $ k ) return 1 ; else return 0 ; } if ( $ dp [ $ index ] [ $ cnt ] != -1 ) return $ dp [ $ index ] [ $ cnt ] ; $ ans = 0 ; $ ans += countWays ( $ index + 1 , $ cnt , $ dp , $ n , $ m , $ k ) ; $ ans += ( $ m - 1 ) * countWays ( $ index + 1 , $ cnt + 1 , $ dp , $ n , $ m , $ k ) ; $ dp [ $ index ] [ $ cnt ] = $ ans ; return $ dp [ $ index ] [ $ cnt ] ; } $ n = 3 ; $ m = 3 ; $ k = 2 ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ GLOBALS [ ' max ' ] ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; echo $ m * countWays ( 1 , 0 , $ dp , $ n , $ m , $ k ) ; ? >"}
{"text":"Sum of Fibonacci numbers at even indexes upto N terms | Computes value of first fibonacci numbers and stores the even - indexed sum ; Initialize result ; Add remaining terms ; For even indices ; Return the alternting sum ; Get n ; Find the even - indiced sum","code":"< ? php function calculateEvenSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 2 * $ n + 1 ] = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= 2 * $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum += $ fibo [ $ i ] ; } return $ sum ; } $ n = 8 ; echo \" Even \u2581 indexed \u2581 Fibonacci \u2581 Sum \u2581 upto \u2581 \" . $ n . \" \u2581 terms : \u2581 \" . calculateEvenSum ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Gould 's Sequence | 32768 = 2 ^ 15 ; Array to store Sequence up to 2 ^ 16 = 65536 ; Utility function to pre - compute odd numbers in ith row of Pascals 's triangle ; First term of the Sequence is 1 ; Initialize i to 1 ; Initialize p to 1 ( i . e 2 ^ i ) in each iteration i will be pth power of 2 ; loop to generate gould 's Sequence ; i is pth power of 2 traverse the array from j = 0 to i i . e ( 2 ^ p ) ; double the value of arr [ j ] and store to arr [ i + j ] ; update i to next power of 2 ; increment p ; Function to print gould 's Sequence ; loop to generate gould 's  Sequence up to n ; Driver code ; Get n ; Function call","code":"< ? php $ MAX = 32768 ; $ arr = array_fill ( 0 , 2 * $ MAX , 0 ) ; function gouldSequence ( ) { global $ MAX , $ arr ; $ arr [ 0 ] = 1 ; $ i = 1 ; $ p = 1 ; while ( $ i <= $ MAX ) { $ j = 0 ; while ( $ j < $ i ) { $ arr [ $ i + $ j ] = 2 * $ arr [ $ j ] ; $ j ++ ; } $ i = ( 1 << $ p ) ; $ p ++ ; } } function printSequence ( $ n ) { global $ MAX , $ arr ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . \" \" ; } } gouldSequence ( ) ; $ n = 16 ; printSequence ( $ n ) ; ? >"}
{"text":"Matrix Chain Multiplication ( A O ( N ^ 2 ) Solution ) | Matrix Mi has dimension p [ i - 1 ] x p [ i ] for i = 1. . n ; For simplicity of the program , one extra row and one extra column are allocated in dp [ ] [ ] . 0 th row and 0 th column of dp [ ] [ ] are not used ; cost is zero when multiplying one matrix . ; Simply following above recursive formula . ; Driver code","code":"< ? php function MatrixChainOrder ( $ p , $ n ) { $ dp = array ( ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] [ $ i ] = 0 ; for ( $ L = 1 ; $ L < $ n - 1 ; $ L ++ ) for ( $ i = 1 ; $ i < $ n - $ L ; $ i ++ ) $ dp [ $ i ] [ $ i + $ L ] = min ( $ dp [ $ i + 1 ] [ $ i + $ L ] + $ p [ $ i - 1 ] * $ p [ $ i ] * $ p [ $ i + $ L ] , $ dp [ $ i ] [ $ i + $ L - 1 ] + $ p [ $ i - 1 ] * $ p [ $ i + $ L - 1 ] * $ p [ $ i + $ L ] ) ; return $ dp [ 1 ] [ $ n - 1 ] ; } $ arr = array ( 10 , 20 , 30 , 40 , 30 ) ; $ size = sizeof ( $ arr ) ; echo \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" . MatrixChainOrder ( $ arr , $ size ) ; ? >"}
{"text":"Count common subsequence in two strings | return the number of common subsequence in two strings ; for each character of S ; for each character in T ; if character are same in both the string ; Driver Code","code":"< ? php function CommomSubsequencesCount ( $ s , $ t ) { $ n1 = strlen ( $ s ) ; $ n2 = strlen ( $ t ) ; $ dp = array ( ) ; for ( $ i = 0 ; $ i <= $ n1 ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n2 ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = 0 ; } } for ( $ i = 1 ; $ i <= $ n1 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n2 ; $ j ++ ) { if ( $ s [ $ i - 1 ] == $ t [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j ] - $ dp [ $ i - 1 ] [ $ j - 1 ] ; } } return $ dp [ $ n1 ] [ $ n2 ] ; } $ s = \" ajblqcpdz \" ; $ t = \" aefcnbtdi \" ; echo CommomSubsequencesCount ( $ s , $ t ) . \" \" ; ? >"}
{"text":"Number of ways to represent a number as sum of k fibonacci numbers | To store fibonacci numbers 42 second number in fibonacci series largest possible integer ; Function to generate fibonacci series ; Recursive function to return the number of ways ; base condition ; for recursive function call ; Driver code","code":"< ? php $ fib = array_fill ( 0 , 43 , 0 ) ; function fibonacci ( ) { global $ fib ; $ fib [ 0 ] = 1 ; $ fib [ 1 ] = 2 ; for ( $ i = 2 ; $ i < 43 ; $ i ++ ) $ fib [ $ i ] = $ fib [ $ i - 1 ] + $ fib [ $ i - 2 ] ; } function rec ( $ x , $ y , $ last ) { global $ fib ; if ( $ y == 0 ) { if ( $ x == 0 ) return 1 ; return 0 ; } $ sum = 0 ; for ( $ i = $ last ; $ i >= 0 and $ fib [ $ i ] * $ y >= $ x ; $ i -- ) { if ( $ fib [ $ i ] > $ x ) continue ; $ sum += rec ( $ x - $ fib [ $ i ] , $ y - 1 , $ i ) ; } return $ sum ; } fibonacci ( ) ; $ n = 13 ; $ k = 3 ; echo \" Possible \u2581 ways \u2581 are : \u2581 \" . rec ( $ n , $ k , 42 ) ; ? >"}
{"text":"Minimum cost to reach the top of the floor by climbing stairs | function to find the minimum cost to reach N - th floor ; base case ; initially to climb till 0 - th or 1 th stair ; iterate for finding the cost ; return the minimum ; Driver Code","code":"< ? php function minimumCost ( & $ cost , $ n ) { if ( $ n == 1 ) return $ cost [ 0 ] ; $ dp [ 0 ] = $ cost [ 0 ] ; $ dp [ 1 ] = $ cost [ 1 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] , $ dp [ $ i - 2 ] ) + $ cost [ $ i ] ; } return min ( $ dp [ $ n - 2 ] , $ dp [ $ n - 1 ] ) ; } $ a = array ( 16 , 19 , 10 , 12 , 18 ) ; $ n = sizeof ( $ a ) ; echo ( minimumCost ( $ a , $ n ) ) ; ? >"}
{"text":"Minimum cost to reach the top of the floor by climbing stairs | function to find the minimum cost to reach N - th floor ; traverse till N - th stair ; update the last two stairs value ; Driver Code","code":"< ? php function minimumCost ( & $ cost , $ n ) { $ dp1 = 0 ; $ dp2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp0 = $ cost [ $ i ] + min ( $ dp1 , $ dp2 ) ; $ dp2 = $ dp1 ; $ dp1 = $ dp0 ; } return min ( $ dp1 , $ dp2 ) ; } $ a = array ( 2 , 5 , 3 , 1 , 7 , 3 , 4 ) ; $ n = sizeof ( $ a ) ; echo ( minimumCost ( $ a , $ n ) ) ; ? >"}
{"text":"Edit distance and LCS ( Longest Common Subsequence ) | PHP program to find Edit Distance ( when only two operations are allowed , insert and delete ) using LCS . ; Find LCS ; Edit distance is delete operations + insert operations . ; Driver Code","code":"< ? php function editDistanceWith2Ops ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L [ $ m + 1 ] [ $ n + 1 ] ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } $ lcs = $ L [ $ m ] [ $ n ] ; return ( $ m - $ lcs ) + ( $ n - $ lcs ) ; } $ X = \" abc \" ; $ Y = \" acd \" ; echo editDistanceWith2Ops ( $ X , $ Y ) ; ? >"}
{"text":"Longest Common Subsequence | DP using Memoization | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Driver Code ; Find the length of string","code":"< ? php function lcs ( $ X , $ Y , $ m , $ n ) { if ( $ m == 0 $ n == 0 ) return 0 ; if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + lcs ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; else return max ( lcs ( $ X , $ Y , $ m , $ n - 1 ) , lcs ( $ X , $ Y , $ m - 1 , $ n ) ) ; } $ X = \" AGGTAB \" ; $ Y = \" GXTXAYB \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; echo \" Length \u2581 of \u2581 LCS : \u2581 \" . lcs ( $ X , $ Y , $ m , $ n ) ; ? >"}
{"text":"Number of different cyclic paths of length N in a tetrahedron | Function to count the number of steps in a tetrahedron ; initially coming to B is B -> B ; cannot reach A , D or C ; iterate for all steps ; recurrence relation ; memoize previous values ; returns steps ; Driver Code","code":"< ? php function countPaths ( $ n ) { $ zB = 1 ; $ zADC = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ nzB = $ zADC * 3 ; $ nzADC = ( $ zADC * 2 + $ zB ) ; $ zB = $ nzB ; $ zADC = $ nzADC ; } return $ zB ; } $ n = 3 ; echo countPaths ( $ n ) ; ? >"}
{"text":"Sequence Alignment problem | function to find out the minimum penalty ; table for storing optimal substructure answers ; initialising the table ; calculating the minimum penalty ; Reconstructing the solution $l = $n + $m ; maximum possible length ; Final answers for the respective strings $xans [ $l + 1 ] ; $yans [ $l + 1 ] ; ; Since we have assumed the answer to be n + m long , we need to remove the extra gaps in the starting id represents the index from which the arrays xans , yans are useful ; Printing the final answer ; input strings ; initialising penalties of different types ; calling the function to calculate the result","code":"< ? php function getMinimumPenalty ( $ x , $ y , $ pxy , $ pgap ) { $ dp [ $ n + $ m + 1 ] [ $ n + $ m + 1 ] = array ( 0 ) ; for ( $ i = 0 ; $ i <= ( $ n + $ m ) ; $ i ++ ) { $ dp [ $ i ] [ 0 ] = $ i * $ pgap ; $ dp [ 0 ] [ $ i ] = $ i * $ pgap ; } for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ x [ $ i - 1 ] == $ y [ $ j - 1 ] ) { $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] ; } else { $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i - 1 ] [ $ j - 1 ] + $ pxy , $ dp [ $ i - 1 ] [ $ j ] + $ pgap , $ dp [ $ i ] [ $ j - 1 ] + $ pgap ) ; } } } $ i = $ m ; $ j = $ n ; $ xpos = $ l ; $ ypos = $ l ; while ( ! ( $ i == 0 $ j == 0 ) ) { if ( $ x [ $ i - 1 ] == $ y [ $ j - 1 ] ) { $ xans [ $ xpos -- ] = $ x [ $ i - 1 ] ; $ yans [ $ ypos -- ] = $ y [ $ j - 1 ] ; $ i -- ; $ j -- ; } else if ( $ dp [ $ i - 1 ] [ $ j - 1 ] + $ pxy == $ dp [ $ i ] [ $ j ] ) { $ xans [ $ xpos -- ] = $ x [ $ i - 1 ] ; $ yans [ $ ypos -- ] = $ y [ $ j - 1 ] ; $ i -- ; $ j -- ; } else if ( $ dp [ $ i - 1 ] [ $ j ] + $ pgap == $ dp [ $ i ] [ $ j ] ) { $ xans [ $ xpos -- ] = $ x [ $ i - 1 ] ; $ yans [ $ ypos -- ] = ' _ ' ; $ i -- ; } else if ( $ dp [ $ i ] [ $ j - 1 ] + $ pgap == $ dp [ $ i ] [ $ j ] ) { $ xans [ $ xpos -- ] = ' _ ' ; $ yans [ $ ypos -- ] = $ y [ $ j - 1 ] ; $ j -- ; } } while ( $ xpos > 0 ) { if ( $ i > 0 ) $ xans [ $ xpos -- ] = $ x [ -- $ i ] ; else $ xans [ $ xpos -- ] = ' _ ' ; } while ( $ ypos > 0 ) { if ( $ j > 0 ) $ yans [ $ ypos -- ] = $ y [ -- $ j ] ; else $ yans [ $ ypos -- ] = ' _ ' ; } $ id = 1 ; for ( $ i = $ l ; $ i >= 1 ; $ i -- ) { if ( $ yans [ $ i ] == ' _ ' && $ xans [ $ i ] == ' _ ' ) { $ id = $ i + 1 ; break ; } } echo \" Minimum \u2581 Penalty \u2581 in \u2581 \" . \" aligning \u2581 the \u2581 genes \u2581 = \u2581 \" ; echo $ dp [ $ m ] [ $ n ] . \" STRNEWLINE \" ; echo \" The \u2581 aligned \u2581 genes \u2581 are \u2581 : STRNEWLINE \" ; for ( $ i = $ id ; $ i <= $ l ; $ i ++ ) { echo $ xans [ $ i ] ; } echo \" STRNEWLINE \" ; for ( $ i = $ id ; $ i <= $ l ; $ i ++ ) { echo $ yans [ $ i ] ; } return ; } $ gene1 = \" AGGGCT \" ; $ gene2 = \" AGGCA \" ; $ misMatchPenalty = 3 ; $ gapPenalty = 2 ; getMinimumPenalty ( $ gene1 , $ gene2 , $ misMatchPenalty , $ gapPenalty ) ; ? >"}
{"text":"Longest Decreasing Subsequence | Function that returns the length of the longest decreasing subsequence ; Initialize LDS with 1 for all index The minimum LDS starting with any element is always 1 ; Compute LDS from every index in bottom up manner ; Select the maximum of all the LDS values ; returns the length of the LDS ; Driver Code","code":"< ? php function lds ( $ arr , $ n ) { $ lds = array ( ) ; $ i ; $ j ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] and $ lds [ $ i ] < $ lds [ $ j ] + 1 ) { $ lds [ $ i ] = $ lds [ $ j ] + 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ lds [ $ i ] ) $ max = $ lds [ $ i ] ; return $ max ; } $ arr = array ( 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ) ; $ n = count ( $ arr ) ; echo \" Length \u2581 of \u2581 LDS \u2581 is \u2581 \" , lds ( $ arr , $ n ) ; ? >"}
{"text":"Sum of product of consecutive Binomial Coefficients | PHP Program to find sum of product of consecutive Binomial Coefficient . ; Find the binomial coefficient upto nth term ; $C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the sum of the product of consecutive binomial coefficient . ; finding the sum of product of consecutive coefficient . ; Driver Code","code":"< ? php $ MAX = 100 ; function binomialCoeff ( $ C , $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ n ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C ; } function sumOfproduct ( $ n ) { global $ MAX ; $ sum = 0 ; $ C = array_fill ( 0 , $ MAX , 0 ) ; $ C = binomialCoeff ( $ C , $ n ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += $ C [ $ i ] * $ C [ $ i + 1 ] ; return $ sum ; } $ n = 3 ; echo sumOfproduct ( $ n ) ; ? >"}
{"text":"Sum of product of r and rth Binomial Coefficient ( r * nCr ) | PHP Program to find sum of product of r and rth Binomial Coefficient i . e summation r * nCr ; Return the first n term of binomial coefficient . ; $C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return summation of r * nCr ; finding the first n term of binomial coefficient ; Iterate a loop to find the sum . ; Driver Code","code":"< ? php $ MAX = 100 ; function binomialCoeff ( $ n , & $ C ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ n ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } } function summation ( $ n ) { global $ MAX ; $ C = array_fill ( 0 , $ MAX , 0 ) ; binomialCoeff ( $ n , $ C ) ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ C [ $ i ] ) ; return $ sum ; } $ n = 2 ; echo summation ( $ n ) ; ? >"}
{"text":"Number of arrays of size N whose elements are positive integers and sum is K | Return nCr ; $C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the number of array that can be formed of size n and sum equals to k . ; Driver Code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , ( $ k + 1 ) , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } function countArray ( $ N , $ K ) { return binomialCoeff ( $ K - 1 , $ N - 1 ) ; } $ N = 2 ; $ K = 3 ; echo countArray ( $ N , $ K ) ; ? >"}
{"text":"Maximize array elements upto given number | Function to find maximum possible value of number that can be obtained using array elements . ; Variable to represent current index . ; Variable to show value between 0 and maxLimit . ; Table to store whether a value can be obtained or not upto a certain index . 1. dp [ i ] [ j ] = 1 if value j can be obtained upto index i . 2. dp [ i ] [ j ] = 0 if value j cannot be obtained upto index i . ; Check for index 0 if given value val can be obtained by either adding to or subtracting arr [ 0 ] from num . ; 1. If arr [ ind ] is added to obtain given val then val - arr [ ind ] should be obtainable from index ind - 1. 2. If arr [ ind ] is subtracted to obtain given val then val + arr [ ind ] should be obtainable from index ind - 1. Check for both the conditions . ; If either of one condition is true , then val is obtainable at index ind . ; Find maximum value that is obtained at index n - 1. ; If no solution exists return - 1. ; Driver Code","code":"< ? php function findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) { $ ind ; $ val ; $ dp [ $ n ] [ $ maxLimit + 1 ] = array ( ) ; for ( $ ind = 0 ; $ ind < $ n ; $ ind ++ ) { for ( $ val = 0 ; $ val <= $ maxLimit ; $ val ++ ) { if ( $ ind == 0 ) { if ( $ num - $ arr [ $ ind ] == $ val $ num + $ arr [ $ ind ] == $ val ) { $ dp [ $ ind ] [ $ val ] = 1 ; } else { $ dp [ $ ind ] [ $ val ] = 0 ; } } else { if ( $ val - $ arr [ $ ind ] >= 0 && $ val + $ arr [ $ ind ] <= $ maxLimit ) { $ dp [ $ ind ] [ $ val ] = $ dp [ $ ind - 1 ] [ $ val - $ arr [ $ ind ] ] || $ dp [ $ ind - 1 ] [ $ val + $ arr [ $ ind ] ] ; } else if ( $ val - $ arr [ $ ind ] >= 0 ) { $ dp [ $ ind ] [ $ val ] = $ dp [ $ ind - 1 ] [ $ val - $ arr [ $ ind ] ] ; } else if ( $ val + $ arr [ $ ind ] <= $ maxLimit ) { $ dp [ $ ind ] [ $ val ] = $ dp [ $ ind - 1 ] [ $ val + $ arr [ $ ind ] ] ; } else { $ dp [ $ ind ] [ $ val ] = 0 ; } } } } for ( $ val = $ maxLimit ; $ val >= 0 ; $ val -- ) { if ( $ dp [ $ n - 1 ] [ $ val ] ) { return $ val ; } } return -1 ; } $ num = 1 ; $ arr = array ( 3 , 10 , 6 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; $ maxLimit = 15 ; echo findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) ; ? >"}
{"text":"Moser | Function to generate nth term of Moser - de Bruijn Sequence ; S ( 0 ) = 0 ; S ( 1 ) = 1 ; S ( 2 * n ) = 4 * S ( n ) ; S ( 2 * n + 1 ) = 4 * S ( n ) + 1 ; Generating the first ' n ' terms of Moser - de Bruijn Sequence ; Driver Code","code":"< ? php function gen ( $ n ) { if ( $ n == 0 ) return 0 ; else if ( $ n == 1 ) return 1 ; else if ( $ n % 2 == 0 ) return 4 * gen ( $ n \/ 2 ) ; else if ( $ n % 2 == 1 ) return 4 * gen ( $ n \/ 2 ) + 1 ; } function moserDeBruijn ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( gen ( $ i ) . \" \u2581 \" ) ; echo ( \" STRNEWLINE \" ) ; } $ n = 15 ; echo ( \" First \u2581 \" . $ n . \" \u2581 terms \u2581 of \u2581 \" . \" Moser - de \u2581 Bruijn \u2581 Sequence \u2581 : \u2581 STRNEWLINE \" ) ; echo ( moserDeBruijn ( $ n ) ) ; ? >"}
{"text":"Minimum Sum Path in a Triangle | Util function to find minimum sum for a path ; For storing the result in a 1 - D array , and simultaneously updating the result . ; For the bottom row ; Calculation of the remaining rows , in bottom up manner . ; return the top element ; Driver Code","code":"< ? php function minSumPath ( & $ A ) { $ memo = array ( ) ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) $ memo [ $ i ] = 0 ; $ n = count ( $ A ) - 1 ; for ( $ i = 0 ; $ i < count ( $ A [ $ n ] ) ; $ i ++ ) $ memo [ $ i ] = $ A [ $ n ] [ $ i ] ; for ( $ i = count ( $ A ) - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < count ( $ A [ $ i + 1 ] ) - 1 ; $ j ++ ) $ memo [ $ j ] = $ A [ $ i ] [ $ j ] + min ( $ memo [ $ j ] , $ memo [ $ j + 1 ] ) ; return $ memo [ 0 ] ; } $ A = array ( array ( 2 ) , array ( 3 , 9 ) , array ( 1 , 6 , 7 ) ) ; echo ( minSumPath ( $ A ) ) ; ? >"}
{"text":"Minimum removals from array to make max | PHP program to find minimum removals to make max - min <= K ; function to check all possible combinations of removal and return the minimum one ; base case when all elements are removed ; if condition is satisfied , no more removals are required ; if the state has already been visited ; when Amax - Amin > d ; minimum is taken of the removal of minimum element or removal of the maximum element ; To sort the array and return the answer ; sort the array ; fill all stated with - 1 when only one element ; Driver Code","code":"< ? php $ MAX = 100 ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j < $ MAX ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; } function countRemovals ( $ a , $ i , $ j , $ k ) { global $ dp ; if ( $ i >= $ j ) return 0 ; else if ( ( $ a [ $ j ] - $ a [ $ i ] ) <= $ k ) return 0 ; else if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; else if ( ( $ a [ $ j ] - $ a [ $ i ] ) > $ k ) { $ dp [ $ i ] [ $ j ] = 1 + min ( countRemovals ( $ a , $ i + 1 , $ j , $ k ) , countRemovals ( $ a , $ i , $ j - 1 , $ k ) ) ; } return $ dp [ $ i ] [ $ j ] ; } function removals ( $ a , $ n , $ k ) { sort ( $ a ) ; if ( $ n == 1 ) return 0 ; else return countRemovals ( $ a , 0 , $ n - 1 , $ k ) ; } $ a = array ( 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 ) ; $ n = count ( $ a ) ; $ k = 4 ; echo ( removals ( $ a , $ n , $ k ) ) ; ? >"}
{"text":"Number of ordered pairs such that ( Ai & Aj ) = 0 | Naive function to count the number of ordered pairs such that their bitwise and is 0 ; check for all possible pairs ; add 2 as ( i , j ) and ( j , i ) are considered different ; Driver Code","code":"< ? php function countPairs ( $ a , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ i ] & $ a [ $ j ] ) == 0 ) $ count += 2 ; } return $ count ; } { $ a = array ( 3 , 4 , 2 ) ; $ n = sizeof ( $ a ) \/ sizeof ( $ a [ 0 ] ) ; echo countPairs ( $ a , $ n ) ; return 0 ; }"}
{"text":"Minimum sum of multiplications of n numbers | Used in recursive memoized solution ; function to calculate the cumulative sum from a [ i ] to a [ j ] ; base case ; memoization , if the partition has been called before then return the stored value ; store a max value ; we break them into k partitions ; store the min of the formula thus obtained ; return the minimum ; Driver code","code":"< ? php $ dp = array ( array ( ) ) ; function sum ( $ a , $ i , $ j ) { $ ans = 0 ; for ( $ m = $ i ; $ m <= $ j ; $ m ++ ) $ ans = ( $ ans + $ a [ $ m ] ) % 100 ; return $ ans ; } function solve ( $ a , $ i , $ j ) { global $ dp ; if ( $ i == $ j ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) { $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i ] [ $ j ] , ( solve ( $ a , $ i , $ k ) + solve ( $ a , $ k + 1 , $ j ) + ( sum ( $ a , $ i , $ k ) * sum ( $ a , $ k + 1 , $ j ) ) ) ) ; } return $ dp [ $ i ] [ $ j ] ; } function initialize ( $ n ) { global $ dp ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = -1 ; } $ a = array ( 40 , 60 , 20 ) ; $ n = count ( $ a ) ; initialize ( $ n ) ; echo solve ( $ a , 0 , $ n - 1 ) ; ? >"}
{"text":"Print Fibonacci Series in reverse order | PHP Program to print Fibonacci series in reverse order ; assigning first and second elements ; storing sum in the preceding location ; printing array in reverse order ; Driver COde","code":"< ? php function reverseFibonacci ( $ n ) { $ a [ 0 ] = 0 ; $ a [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ a [ $ i - 2 ] + $ a [ $ i - 1 ] ; } for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { echo ( $ a [ $ i ] . \" \" ) ; } } $ n = 5 ; reverseFibonacci ( $ n ) ; ? >"}
{"text":"Probability of reaching a point with 2 or 3 steps at a time | Returns probability to reach N ; Driver code","code":"< ? php function find_prob ( $ N , $ P ) { $ dp ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 0 ; $ dp [ 2 ] = $ P ; $ dp [ 3 ] = 1 - $ P ; for ( $ i = 4 ; $ i <= $ N ; ++ $ i ) $ dp [ $ i ] = ( $ P ) * $ dp [ $ i - 2 ] + ( 1 - $ P ) * $ dp [ $ i - 3 ] ; return $ dp [ $ N ] ; } $ n = 5 ; $ p = 0.2 ; echo find_prob ( $ n , $ p ) ; ? >"}
{"text":"Hosoya 's Triangle | PHP Program to print Hosoya 's triangle of height n. ; Print the Hosoya triangle of height n . ; base case . ; For each row . ; for each column ; ; recursive steps . ; printing the solution ; Driven Program","code":"< ? php $ N = 5 ; function printHosoya ( $ n ) { global $ N ; $ dp = array_fill ( 0 , $ N , array_fill ( 0 , $ N , 0 ) ) ; $ dp [ 0 ] [ 0 ] = $ dp [ 1 ] [ 0 ] = $ dp [ 1 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i > $ j ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 2 ] [ $ j ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i - 2 ] [ $ j - 2 ] ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo $ dp [ $ i ] [ $ j ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } } $ n = 5 ; printHosoya ( $ n ) ; ? >"}
{"text":"Different ways to sum n using numbers greater than or equal to m | PHP Program to find number of ways to which numbers that are greater than given number can be added to get sum . ; Return number of ways to which numbers that are greater than given number can be added to get sum . ; Filling the table . k is for numbers greater than or equal that are allowed . ; i is for sum ; initializing dp [ i ] [ k ] to number ways to get sum using numbers greater than or equal k + 1 ; if i > k ; Driver Program","code":"< ? php $ MAX = 100 ; function numberofways ( $ n , $ m ) { global $ MAX ; $ dp = array_fill ( 0 , $ n + 2 , array_fill ( 0 , $ n + 2 , NULL ) ) ; $ dp [ 0 ] [ $ n + 1 ] = 1 ; for ( $ k = $ n ; $ k >= $ m ; $ k -- ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ k ] = $ dp [ $ i ] [ $ k + 1 ] ; if ( $ i - $ k >= 0 ) $ dp [ $ i ] [ $ k ] = ( $ dp [ $ i ] [ $ k ] + $ dp [ $ i - $ k ] [ $ k ] ) ; } } return $ dp [ $ n ] [ $ m ] ; } $ n = 3 ; $ m = 1 ; echo numberofways ( $ n , $ m ) ; return 0 ; ? >"}
{"text":"Entringer Number | Return Entringer Number E ( n , k ) ; Base Case ; Base Case ; Recursive step ; Driven Code","code":"< ? php function zigzag ( $ n , $ k ) { if ( $ n == 0 and $ k == 0 ) return 1 ; if ( $ k == 0 ) return 0 ; return zigzag ( $ n , $ k - 1 ) + zigzag ( $ n - 1 , $ n - $ k ) ; } $ n = 4 ; $ k = 3 ; echo zigzag ( $ n , $ k ) ; ? >"}
{"text":"Eulerian Number | Return euleriannumber A ( n , m ) ; For each row from 1 to n ; For each column from 0 to m ; If i is greater than j ; If j is 0 , then make that state as 1. ; basic recurrence relation . ; Driver Code","code":"< ? php function eulerian ( $ n , $ m ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ m + 1 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { if ( $ i > $ j ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = ( ( $ i - $ j ) * $ dp [ $ i - 1 ] [ $ j - 1 ] ) + ( ( $ j + 1 ) * $ dp [ $ i - 1 ] [ $ j ] ) ; } } } return $ dp [ $ n ] [ $ m ] ; } $ n = 3 ; $ m = 1 ; echo eulerian ( $ n , $ m ) ; ? >"}
{"text":"Delannoy Number | Return the nth Delannoy Number . ; Base case ; Recursive step . ; Driver Code","code":"< ? php function dealnnoy ( $ n , $ m ) { if ( $ m == 0 or $ n == 0 ) return 1 ; return dealnnoy ( $ m - 1 , $ n ) + dealnnoy ( $ m - 1 , $ n - 1 ) + dealnnoy ( $ m , $ n - 1 ) ; } $ n = 3 ; $ m = 4 ; echo dealnnoy ( $ n , $ m ) ; ? >"}
{"text":"Delannoy Number | Return the nth Delannoy Number . ; Base cases ; Driven Code","code":"< ? php function dealnnoy ( $ n , $ m ) { $ dp [ $ m + 1 ] [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ m ] [ $ n ] ; } $ n = 3 ; $ m = 4 ; echo dealnnoy ( $ n , $ m ) ; ? >"}
{"text":"Longest alternating ( positive and negative ) subarray starting at every index | PHP program to find longest alternating subarray starting from every index . ; Fill count [ ] from end . ; Print result ; Driver code","code":"< ? php function longestAlternating ( $ arr , $ n ) { $ count = array ( ) ; $ count [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] * $ arr [ $ i + 1 ] < 0 ) $ count [ $ i ] = $ count [ $ i + 1 ] + 1 ; else $ count [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count [ $ i ] , \" \u2581 \" ; } $ a = array ( -5 , -1 , -1 , 2 , -2 , -3 ) ; $ n = count ( $ a ) ; longestAlternating ( $ a , $ n ) ; ? >"}
{"text":"Maximum value with the choice of either dividing or considering as it is | function for calculating max possible result ; Compute remaining values in bottom up manner . ; Driver Code","code":"< ? php function maxDP ( $ n ) { $ res [ 0 ] = 0 ; $ res [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = max ( $ i , ( $ res [ $ i \/ 2 ] + $ res [ $ i \/ 3 ] + $ res [ $ i \/ 4 ] + $ res [ $ i \/ 5 ] ) ) ; return $ res [ $ n ] ; } $ n = 60 ; echo \" MaxSum = \" ? >"}
{"text":"Minimum jumps to reach last building in a matrix | Recursive PHP program to find minimum jumps to reach last building from first . ; Returns minimum jump path from ( 0 , 0 ) to ( m , n ) in height [ R ] [ C ] ; base case ; Find minimum jumps if we go through diagonal ; Find minimum jumps if we go through down ; Find minimum jumps if we go through right ; return minimum jumps ; Driver Code","code":"< ? php $ R = 4 ; $ C = 3 ; function isSafe ( $ x , $ y ) { global $ R , $ C ; return ( $ x < $ R and $ y < $ C ) ; } function minJump ( $ height , $ x , $ y ) { global $ R , $ C ; if ( $ x == $ R - 1 and $ y == $ C - 1 ) return 0 ; $ diag = PHP_INT_MAX ; if ( isSafe ( $ x + 1 , $ y + 1 ) ) $ diag = minJump ( $ height , $ x + 1 , $ y + 1 ) + abs ( $ height [ $ x ] [ $ y ] - $ height [ $ x + 1 ] [ $ y + 1 ] ) ; $ down = PHP_INT_MAX ; if ( isSafe ( $ x + 1 , $ y ) ) $ down = minJump ( $ height , $ x + 1 , $ y ) + abs ( $ height [ $ x ] [ $ y ] - $ height [ $ x + 1 ] [ $ y ] ) ; $ right = PHP_INT_MAX ; if ( isSafe ( $ x , $ y + 1 ) ) $ right = minJump ( $ height , $ x , $ y + 1 ) + abs ( $ height [ $ x ] [ $ y ] - $ height [ $ x ] [ $ y + 1 ] ) ; return min ( $ down , min ( $ right , $ diag ) ) ; } $ height = array ( array ( 5 , 4 , 2 ) , array ( 9 , 2 , 1 ) , array ( 2 , 5 , 9 ) , array ( 1 , 3 , 11 ) ) ; echo minJump ( $ height , 0 , 0 ) ; ? >"}
{"text":"Maximum sum subsequence with at | PHP program to find maximum sum subsequence such that elements are at least k distance away . ; We fill MS from right to left . ; Driver code","code":"< ? php function maxSum ( $ arr , $ N , $ k ) { $ MS [ $ N - 1 ] = $ arr [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { if ( $ i + $ k + 1 >= $ N ) $ MS [ $ i ] = max ( $ arr [ $ i ] , $ MS [ $ i + 1 ] ) ; else $ MS [ $ i ] = max ( $ arr [ $ i ] + $ MS [ $ i + $ k + 1 ] , $ MS [ $ i + 1 ] ) ; } return $ MS [ 0 ] ; } $ N = 10 ; $ k = 2 ; $ arr = array ( 50 , 70 , 40 , 50 , 90 , 70 , 60 , 40 , 70 , 50 ) ; echo ( maxSum ( $ arr , $ N , $ k ) ) ; ? >"}
{"text":"Longest alternating sub | Function to calculate alternating sub - array for each index of array elements ; Initialize the base state of len [ ] ; Calculating value for each element ; If both elements are different then add 1 to next len [ i + 1 ] ; else initialize to 1 ; Print lengths of binary subarrays . ; Driver Code","code":"< ? php function alternateSubarray ( & $ arr , $ n ) { $ len = array_fill ( 0 , $ n , NULL ) ; $ len [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; -- $ i ) { if ( $ arr [ $ i ] ^ $ arr [ $ i + 1 ] == 1 ) $ len [ $ i ] = $ len [ $ i + 1 ] + 1 ; else $ len [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ len [ $ i ] . \" \u2581 \" ; } $ arr = array ( 1 , 0 , 1 , 0 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; alternateSubarray ( $ arr , $ n ) ; ? >"}
{"text":"Longest alternating sub | Function to calculate alternating sub - array for each index of array elements ; Initialize count variable for storing length of sub - array ; Initialize ' prev ' variable which indicates the previous element while traversing for index ' i ' ; If both elements are same print elements because alternate element is not found for current index ; print count and decrement it . ; Increment count for next element ; Re - initialize previous variable ; If elements are still available after traversing whole array , print it ; Driver Code","code":"< ? php function alternateSubarray ( $ arr , $ n ) { $ count = 1 ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) { if ( ( $ arr [ $ i ] ^ $ prev ) == 0 ) { while ( $ count ) echo $ count -- , \" \u2581 \" ; } ++ $ count ; $ prev = $ arr [ $ i ] ; } while ( $ count ) echo $ count -- , \" \u2581 \" ; } $ arr = array ( 1 , 0 , 1 , 0 , 0 , 1 ) ; $ n = sizeof ( $ arr ) ; alternateSubarray ( $ arr , $ n ) ; ? >"}
{"text":"Count ways to build street under given constraints | function to count ways of building a street of n rows ; base case ; ways of building houses in both the spots of ith row ; ways of building an office in one of the two spots of ith row ; total ways for n rows ; Driver Code","code":"< ? php function countWays ( $ n ) { $ dp [ 0 ] [ 1 ] = 1 ; $ dp [ 1 ] [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ 0 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] + $ dp [ 1 ] [ $ i - 1 ] ; $ dp [ 1 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] * 2 + $ dp [ 1 ] [ $ i - 1 ] ; } return $ dp [ 0 ] [ $ n ] + $ dp [ 1 ] [ $ n ] ; } $ n = 5 ; echo \" Total \u2581 no \u2581 of \u2581 ways \u2581 with \u2581 n \u2581 = \u2581 \" , $ n , \" \u2581 are : \u2581 \" , countWays ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Maximum length subsequence with difference between adjacent elements as either 0 or 1 | function to find maximum length subsequence with difference between adjacent elements as either 0 or 1 ; Initialize mls [ ] values for all indexes ; Compute optimized maximum length subsequence values in bottom up manner ; Store maximum of all ' mls ' values in ' max ' ; required maximum length subsequence ; Driver Code","code":"< ? php function maxLenSub ( $ arr , $ n ) { $ mls = array ( ) ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mls [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= 1 and $ mls [ $ i ] < $ mls [ $ j ] + 1 ) $ mls [ $ i ] = $ mls [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ mls [ $ i ] ) $ max = $ mls [ $ i ] ; return $ max ; } $ arr = array ( 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ) ; $ n = count ( $ arr ) ; echo \" Maximum \u2581 length \u2581 subsequence \u2581 = \u2581 \" , maxLenSub ( $ arr , $ n ) ; ? >"}
{"text":"Coin game winner where every player has three choices | To find winner of game ; To store results ; Initial values ; Computing other values . ; If A losses any of i - 1 or i - x or i - y game then he will definitely win game i ; Else A loses game . ; If dp [ n ] is true then A will game otherwise he losses ; Driver program to test findWinner ( ) ;","code":"< ? php function findWinner ( $ x , $ y , $ n ) { $ dp = array ( ) ; $ dp [ 0 ] = false ; $ dp [ 1 ] = true ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i - 1 >= 0 and ! $ dp [ $ i - 1 ] ) $ dp [ $ i ] = true ; else if ( $ i - $ x >= 0 and ! $ dp [ $ i - $ x ] ) $ dp [ $ i ] = true ; else if ( $ i - $ y >= 0 and ! $ dp [ $ i - $ y ] ) $ dp [ $ i ] = true ; else $ dp [ $ i ] = false ; } return $ dp [ $ n ] ; } $ x = 3 ; $ y = 4 ; $ n = 5 ; if ( findWinner ( $ x , $ y , $ n ) ) echo ' A ' ; else echo ' B ' ; ? >"}
{"text":"Maximum games played by winner | Method returns maximum games a winner needs to play in N - player tournament ; for 0 games , 1 player is needed for 1 game , 2 players are required ; loop until i - th Fibonacci number is less than or equal to N ; result is ( i - 2 ) because i will be incremented one extra in while loop and we want the last value which is smaller than N , so one more decrement ; Driver Code","code":"< ? php function maxGameByWinner ( $ N ) { $ dp [ $ N ] = 0 ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 2 ; $ i = 2 ; do { $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; } while ( $ dp [ $ i ++ ] <= $ N ) ; return ( $ i - 2 ) ; } $ N = 10 ; echo maxGameByWinner ( $ N ) ; ? >"}
{"text":"Convert to Strictly increasing integer array with minimum changes | To find min elements to remove from array to make it strictly increasing ; Mark all elements of LIS as 1 ; Find LIS of array ; Return min changes for array to strictly increasing ; Driver Code","code":"< ? php function minRemove ( $ arr , $ n ) { $ LIS = array ( ) ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ LIS [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ LIS [ $ i ] = max ( $ LIS [ $ i ] , $ LIS [ $ j ] + 1 ) ; } $ len = max ( $ len , $ LIS [ $ i ] ) ; } return $ n - $ len ; } $ arr = array ( 1 , 2 , 6 , 5 , 4 ) ; $ n = count ( $ arr ) ; echo minRemove ( $ arr , $ n ) ; ? >"}
{"text":"Find length of longest subsequence of one string which is substring of another string | Return the maximum size of substring of X which is substring in Y . ; Initialize the dp [ ] [ ] to 0. ; Calculating value for each element . ; If alphabet of string X and Y are equal make dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; Else copy the previous value in the row i . e dp [ i - 1 ] [ j - 1 ] ; Finding the maximum length . ; Driver Code","code":"< ? php function maxSubsequenceSubstring ( $ x , $ y , $ n , $ m ) { $ dp ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ x [ $ j - 1 ] == $ y [ $ i - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] ; } } $ ans = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ ans = max ( $ ans , $ dp [ $ i ] [ $ n ] ) ; return $ ans ; } { $ x = \" ABCD \" ; $ y = \" BACDBDCD \" ; $ n = strlen ( $ x ) ; $ m = strlen ( $ y ) ; echo maxSubsequenceSubstring ( $ x , $ y , $ n , $ m ) ; return 0 ; } ? >"}
{"text":"Maximum sum in a 2 x n grid such that no two elements are adjacent | Function to find max sum without adjacent ; Sum including maximum element of first column ; Not including first column 's element ; Traverse for further elements ; Update max_sum on including or excluding of previous column ; Include current column . Add maximum element from both row of current column ; If current column doesn 't  to be included ; Return maximum of excl and incl As that will be the maximum sum ; Driver code","code":"< ? php function maxSum ( $ grid , $ n ) { $ incl = max ( $ grid [ 0 ] [ 0 ] , $ grid [ 1 ] [ 0 ] ) ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = max ( $ excl , $ incl ) ; $ incl = $ excl + max ( $ grid [ 0 ] [ $ i ] , $ grid [ 1 ] [ $ i ] ) ; $ excl = $ excl_new ; } return max ( $ excl , $ incl ) ; } $ grid = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 6 , 7 , 8 , 9 , 10 ) ) ; $ n = 5 ; echo maxSum ( $ grid , $ n ) ; ? >"}
{"text":"Minimum insertions to sort an array | method returns min steps of insertion we need to perform to sort array ' arr ' ; lis [ i ] is going to store length of lis that ends with i . ; Initialize lis values for all indexes ; Compute optimized lis values in bottom up manner ; The overall LIS must end with of the array elements . Pick maximum of all lis values ; return size of array minus length of LIS as final result ; Driver code","code":"< ? php function minInsertionStepToSortArray ( $ arr , $ N ) { $ lis [ $ N ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] >= $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ max = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ max < $ lis [ $ i ] ) $ max = $ lis [ $ i ] ; return ( $ N - $ max ) ; } $ arr = array ( 2 , 3 , 5 , 1 , 4 , 7 , 6 ) ; $ N = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo minInsertionStepToSortArray ( $ arr , $ N ) ; ? >"}
{"text":"Shortest Uncommon Subsequence | A dynamic programming based PHP program to find shortest uncommon subsequence . ; Returns length of shortest common subsequence ; declaring 2D array of m + 1 rows and n + 1 columns dynamically ; T string is empty ; S string is empty ; char not present in T ; Driver Code","code":"< ? php $ GLOBALS [ ' MAX ' ] = 1005 ; function shortestSeq ( $ S , $ T ) { $ m = strlen ( $ S ) ; $ n = strlen ( $ T ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ 0 ] [ $ i ] = $ GLOBALS [ ' MAX ' ] ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ ch = $ S [ $ i - 1 ] ; for ( $ k = $ j - 1 ; $ k >= 0 ; $ k -- ) if ( $ T [ $ k ] == $ ch ) break ; if ( $ k == -1 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ k ] + 1 ) ; } } $ ans = $ dp [ $ m ] [ $ n ] ; if ( $ ans >= $ GLOBALS [ ' MAX ' ] ) $ ans = -1 ; return $ ans ; } $ S = \" babab \" ; $ T = \" babba \" ; $ m = strlen ( $ S ) ; $ n = strlen ( $ T ) ; echo \" Length \u2581 of \u2581 shortest \u2581 subsequence \u2581 is \u2581 : \u2581 \" , shortestSeq ( $ S , $ T ) ; ? >"}
{"text":"Count number of ways to jump to reach end | function to count ways to jump to reach end for each array element ; count_jump [ i ] store number of ways arr [ i ] can reach to the end ; Last element does not require to jump . Count ways to jump for remaining elements ; if the element can directly jump to the end ; add the count of all the elements that can reach to end and arr [ i ] can reach to them ; if element can reach to end then add its count to count_jump [ i ] ; if arr [ i ] cannot reach to the end ; print count_jump for each array element ; Driver Code","code":"< ? php function countWaysToJump ( $ arr , $ n ) { $ count_jump ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count_jump [ $ i ] = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] >= $ n - $ i - 1 ) $ count_jump [ $ i ] ++ ; for ( $ j = $ i + 1 ; $ j < $ n - 1 && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) if ( $ count_jump [ $ j ] != -1 ) $ count_jump [ $ i ] += $ count_jump [ $ j ] ; if ( $ count_jump [ $ i ] == 0 ) $ count_jump [ $ i ] = -1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count_jump [ $ i ] . \" \u2581 \" ; } $ arr = array ( 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ) ; $ n = count ( $ arr ) ; countWaysToJump ( $ arr , $ n ) ; ? >"}
{"text":"Minimum steps to delete a string after repeated deletion of palindrome substrings | method returns minimum step for deleting the string , where in one step a palindrome is removed ; declare dp array and initialize it with 0 s ; loop for substring length we are considering ; loop with two variables i and j , denoting starting and ending of substrings ; If substring length is 1 , then 1 step will be needed ; delete the ith char individually and assign result for subproblem ( i + 1 , j ) ; if current and next char are same , choose min from current and subproblem ( i + 2 , j ) ; loop over all right characters and suppose Kth char is same as ith character then choose minimum from current and two substring after ignoring ith and Kth char ; Uncomment below snippet to print actual dp tablex for ( int i = 0 ; i < N ; i ++ , cout << endl ) for ( int j = 0 ; j < N ; j ++ ) cout << dp [ i ] [ j ] << \" \u2581 \" ; ; Driver code","code":"< ? php function minStepToDeleteString ( $ str ) { $ N = strlen ( $ str ) ; $ dp [ $ N + 1 ] [ $ N + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) for ( $ j = 0 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ len = 1 ; $ len <= $ N ; $ len ++ ) { for ( $ i = 0 , $ j = $ len - 1 ; $ j < $ N ; $ i ++ , $ j ++ ) { if ( $ len == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else { $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i + 1 ] [ $ j ] ; if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ dp [ $ i ] [ $ j ] = min ( 1 + $ dp [ $ i + 2 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; for ( $ K = $ i + 2 ; $ K <= $ j ; $ K ++ ) if ( $ str [ $ i ] == $ str [ $ K ] ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i + 1 ] [ $ K - 1 ] + $ dp [ $ K + 1 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; } } } return $ dp [ 0 ] [ $ N - 1 ] ; } $ str = \"2553432\" ; echo minStepToDeleteString ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text":"Clustering \/ Partitioning an array such that sum of square differences is minimum | Initialize answer as infinite . ; function to generate all possible answers . and compute minimum of all costs . i -- > is index of previous partition par -- > is current number of partitions a [ ] and n -- > Input array and its size current_ans -- > Cost of partitions made so far . ; If number of partitions is more than k ; If we have mad k partitions and have reached last element ; 1 ) Partition array at different points 2 ) For every point , increase count of partitions , \" par \" by 1. 3 ) Before recursive call , add cost of the partition to current_ans ; Driver code","code":"< ? php $ inf = 1000000000 ; $ ans = $ inf ; function solve ( $ i , $ par , & $ a , $ n , $ k , $ current_ans ) { global $ inf , $ ans ; if ( $ par > $ k ) return ; if ( $ par == $ k && $ i == $ n - 1 ) { $ ans = min ( $ ans , $ current_ans ) ; return ; } for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) solve ( $ j , $ par + 1 , $ a , $ n , $ k , $ current_ans + ( $ a [ $ j ] - $ a [ $ i + 1 ] ) * ( $ a [ $ j ] - $ a [ $ i + 1 ] ) ) ; } $ k = 2 ; $ a = array ( 1 , 5 , 8 , 10 ) ; $ n = sizeof ( $ a ) ; solve ( -1 , 0 , $ a , $ n , $ k , 0 ) ; echo $ ans . \" STRNEWLINE \" ; ? >"}
{"text":"Minimum steps to minimize n as per given condition | function to calculate min steps ; base case ; store temp value for n as min ( f ( n - 1 ) , f ( n \/ 2 ) , f ( n \/ 3 ) ) + 1 ; store memo [ n ] and return ; This function mainly initializes memo [ ] and calls getMinSteps ( n , memo ) ; initialize memoized array ; Driver Code","code":"< ? php function getMinSteps ( $ n , $ memo ) { if ( $ n == 1 ) return 0 ; if ( $ memo [ $ n ] != -1 ) return $ memo [ $ n ] ; $ res = getMinSteps ( $ n - 1 , $ memo ) ; if ( $ n % 2 == 0 ) $ res = min ( $ res , getMinSteps ( $ n \/ 2 , $ memo ) ) ; if ( $ n % 3 == 0 ) $ res = min ( $ res , getMinSteps ( $ n \/ 3 , $ memo ) ) ; $ memo [ $ n ] = 1 + $ res ; return $ memo [ $ n ] ; } function g_etMinSteps ( $ n ) { $ memo = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ memo [ $ i ] = -1 ; return getMinSteps ( $ n , $ memo ) ; } $ n = 10 ; echo g_etMinSteps ( $ n ) ; ? >"}
{"text":"Smallest length string with repeated replacement of two distinct adjacent | Returns smallest possible length with given operation allowed . ; Counint occurrences of three different characters ' a ' , ' b ' and ' c ' in str ; If all characters are same . ; If all characters are present even number of times or all are present odd number of times . ; Answer is 1 for all other cases . ; Driver code","code":"< ? php function stringReduction ( $ str ) { $ n = strlen ( $ str ) ; $ count = array_fill ( 0 , 3 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; if ( $ count [ 0 ] == $ n $ count [ 1 ] == $ n $ count [ 2 ] == $ n ) return $ n ; if ( ( $ count [ 0 ] % 2 ) == ( $ count [ 1 ] % 2 ) && ( $ count [ 1 ] % 2 ) == ( $ count [ 2 ] % 2 ) ) return 2 ; return 1 ; } $ str = \" abcbbaacb \" ; print ( stringReduction ( $ str ) ) ; ? >"}
{"text":"Number of subsequences of the form a ^ i b ^ j c ^ k | Returns count of subsequences of the form a ^ i b ^ j c ^ k ; Initialize counts of different subsequences caused by different combination of ' a ' ; Initialize counts of different subsequences caused by different combination of ' a ' and different combination of ' b ' ; Initialize counts of different subsequences caused by different combination of ' a ' , ' b ' and ' c ' . ; Traverse all characters of given string ; If current character is ' a ' , then there are following possibilities : a ) Current character begins a new subsequence . b ) Current character is part of aCount subsequences . c ) Current character is not part of aCount subsequences . ; If current character is ' b ' , then there are following possibilities : a ) Current character begins a new subsequence of b 's with aCount subsequences. b) Current character is part of bCount subsequences. c) Current character is not part of  bCount subsequences.  ; If current character is ' c ' , then there are following possibilities : a ) Current character begins a new subsequence of c 's with bCount subsequences. b) Current character is part of cCount subsequences. c) Current character is not part of  cCount subsequences.  ; Driver Code","code":"< ? php function countSubsequences ( $ s ) { $ aCount = 0 ; $ bCount = 0 ; $ cCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ aCount = ( 1 + 2 * $ aCount ) ; else if ( $ s [ $ i ] == ' b ' ) $ bCount = ( $ aCount + 2 * $ bCount ) ; else if ( $ s [ $ i ] == ' c ' ) $ cCount = ( $ bCount + 2 * $ cCount ) ; } return $ cCount ; } $ s = \" abbc \" ; echo countSubsequences ( $ s ) ; ? >"}
{"text":"Highway Billboard Problem | PHP program to find maximum revenue by placing billboard on the highway with given constraints . ; Array to store maximum revenue at each miles . ; actual minimum distance between 2 billboards . ; check if all billboards are already placed . ; check if we have billboard for that particular mile . If not , copy the previous maximum revenue . ; we do have billboard for this mile . ; If current position is less than or equal to t , then we can have only one billboard . ; Else we may have to remove previously placed billboard ; Driver Code","code":"< ? php function maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) { $ maxRev = array_fill ( 0 , $ m + 1 , false ) ; $ nxtbb = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { if ( $ nxtbb < $ n ) { if ( $ x [ $ nxtbb ] != $ i ) $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; else { if ( $ i <= $ t ) $ maxRev [ $ i ] = max ( $ maxRev [ $ i - 1 ] , $ revenue [ $ nxtbb ] ) ; else $ maxRev [ $ i ] = max ( $ maxRev [ $ i - $ t - 1 ] + $ revenue [ $ nxtbb ] , $ maxRev [ $ i - 1 ] ) ; $ nxtbb ++ ; } } else $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; } return $ maxRev [ $ m ] ; } $ m = 20 ; $ x = array ( 6 , 7 , 12 , 13 , 14 ) ; $ revenue = array ( 5 , 6 , 5 , 3 , 1 ) ; $ n = sizeof ( $ x ) ; $ t = 5 ; echo maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) ; ? >"}
{"text":"Finding the maximum square sub | Java program to find maximum K such that K x K is a submatrix with equal elements . ; Returns size of the largest square sub - matrix with all same elements . ; If elements is at top row or first column , it wont form a square matrix 's   bottom-right ; Check if adjacent elements are equal ; If not equal , then it will form a 1 x1 submatrix ; Update result at each ( i , j ) ; Driver Code","code":"< ? php $ Row = 6 ; $ Col = 6 ; function largestKSubmatrix ( & $ a ) { global $ Row , $ Col ; $ result = 0 ; for ( $ i = 0 ; $ i < $ Row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ Col ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else { if ( $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j ] && $ a [ $ i ] [ $ j ] == $ a [ $ i ] [ $ j - 1 ] && $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = min ( min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) , $ dp [ $ i - 1 ] [ $ j - 1 ] ) + 1 ; else $ dp [ $ i ] [ $ j ] = 1 ; } $ result = max ( $ result , $ dp [ $ i ] [ $ j ] ) ; } } return $ result ; } $ a = array ( array ( 2 , 2 , 3 , 3 , 4 , 4 ) , array ( 5 , 5 , 7 , 7 , 7 , 4 ) , array ( 1 , 2 , 7 , 7 , 7 , 4 ) , array ( 4 , 4 , 7 , 7 , 7 , 4 ) , array ( 5 , 5 , 5 , 1 , 2 , 7 ) , array ( 8 , 7 , 9 , 4 , 4 , 4 ) ) ; echo largestKSubmatrix ( $ a ) ; ? >"}
{"text":"Probability of getting at least K heads in N tosses of Coins | Naive approach in PHP to find probability of at least k heads ; Returns probability of getting at least k heads in n tosses . ; Probability of getting exactly i heads out of n heads ; Note : 1 << n = pow ( 2 , n ) ; Preprocess all factorial only upto 19 , as after that it will overflow ; Driver code ; Probability of getting 2 head out of 3 coins ; Probability of getting 3 head out of 6 coins ; Probability of getting 12 head out of 18 coins","code":"< ? php $ MAX = 21 ; $ fact = array_fill ( 0 , $ MAX , 0 ) ; function probability ( $ k , $ n ) { global $ fact ; $ ans = 0 ; for ( $ i = $ k ; $ i <= $ n ; ++ $ i ) $ ans += $ fact [ $ n ] \/ ( $ fact [ $ i ] * $ fact [ $ n - $ i ] ) ; $ ans = $ ans \/ ( 1 << $ n ) ; return $ ans ; } function precompute ( ) { global $ fact ; $ fact [ 0 ] = $ fact [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 20 ; ++ $ i ) $ fact [ $ i ] = $ fact [ $ i - 1 ] * $ i ; } precompute ( ) ; echo number_format ( probability ( 2 , 3 ) , 6 ) . \" STRNEWLINE \" ; echo number_format ( probability ( 3 , 6 ) , 6 ) . \" STRNEWLINE \" ; echo number_format ( probability ( 12 , 18 ) , 6 ) ; ? >"}
{"text":"Count binary strings with k times appearing adjacent two set bits | PHP program to count number of binary strings with k times appearing consecutive 1 's. ; dp [ i ] [ j ] [ 0 ] stores count of binary strings of length i with j consecutive 1 ' s \u2581 and \u2581 ending \u2581 at \u2581 0 . \u2581 \u2581 dp [ i ] [ j ] [1 ] \u2581 stores \u2581 count \u2581 of \u2581 binary \u2581 \u2581 strings \u2581 of \u2581 length \u2581 i \u2581 with \u2581 j \u2581 consecutive \u2581 \u2581 1' s and ending at 1. ; If n = 1 and k = 0. ; number of adjacent 1 's can not exceed i-1 ; Driver code","code":"< ? php function countStrings ( $ n , $ k ) { $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ k + 1 , array_fill ( 0 , 2 , 0 ) ) ) ; $ dp [ 1 ] [ 0 ] [ 0 ] = 1 ; $ dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( isset ( $ dp [ $ i ] [ $ j ] [ 0 ] ) || isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) { $ dp [ $ i ] [ $ j ] [ 0 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] + $ dp [ $ i - 1 ] [ $ j ] [ 1 ] ; $ dp [ $ i ] [ $ j ] [ 1 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] ; } if ( $ j - 1 >= 0 && isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) $ dp [ $ i ] [ $ j ] [ 1 ] += $ dp [ $ i - 1 ] [ $ j - 1 ] [ 1 ] ; } } return $ dp [ $ n ] [ $ k ] [ 0 ] + $ dp [ $ n ] [ $ k ] [ 1 ] ; } $ n = 5 ; $ k = 2 ; echo countStrings ( $ n , $ k ) ; ? >"}
{"text":"Friends Pairing Problem | Returns count of ways n people can remain single or paired up . ; Driver Code","code":"< ? php function countFriendsPairings ( $ n ) { $ dp = array_fill ( 0 , 1000 , -1 ) ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; if ( $ n > 2 ) { $ dp [ $ n ] = countFriendsPairings ( $ n - 1 ) + ( $ n - 1 ) * countFriendsPairings ( $ n - 2 ) ; return $ dp [ $ n ] ; } else { $ dp [ $ n ] = $ n ; return $ dp [ $ n ] ; } } $ n = 4 ; echo countFriendsPairings ( $ n ) ? >"}
{"text":"Maximum path sum in a triangle . | Function for finding maximum sum ; loop for bottom - up calculation ; for each element , check both elements just below the number and below right to the number add the maximum of them to it ; return the top element which stores the maximum sum ; Driver Code","code":"< ? php function maxPathSum ( $ tri , $ m , $ n ) { for ( $ i = $ m - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ tri [ $ i + 1 ] [ $ j ] > $ tri [ $ i + 1 ] [ $ j + 1 ] ) $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j + 1 ] ; } } return $ tri [ 0 ] [ 0 ] ; } $ tri = array ( array ( 1 , 0 , 0 ) , array ( 4 , 8 , 0 ) , array ( 1 , 5 , 3 ) ) ; echo maxPathSum ( $ tri , 2 , 2 ) ; ? >"}
{"text":"LCS ( Longest Common Subsequence ) of three strings | PHP program to find LCS of three strings ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] and Z [ 0. . o - 1 ] ; Driver code","code":"< ? php $ X = \" AGGT12\" ; $ Y = \"12TXAYB \" ; $ Z = \"12XBA \" ; $ dp = array_fill ( 0 , 100 , array_fill ( 0 , 100 , array_fill ( 0 , 100 , -1 ) ) ) ; function lcsOf3 ( $ i , $ j , $ k ) { global $ dp , $ X , $ Y , $ Z ; if ( $ i == -1 $ j == -1 $ k == -1 ) return 0 ; if ( $ dp [ $ i ] [ $ j ] [ $ k ] != -1 ) return $ dp [ $ i ] [ $ j ] [ $ k ] ; if ( $ X [ $ i ] == $ Y [ $ j ] && $ Y [ $ j ] == $ Z [ $ k ] ) return $ dp [ $ i ] [ $ j ] [ $ k ] = 1 + lcsOf3 ( $ i - 1 , $ j - 1 , $ k - 1 ) ; else return $ dp [ $ i ] [ $ j ] [ $ k ] = max ( max ( lcsOf3 ( $ i - 1 , $ j , $ k ) , lcsOf3 ( $ i , $ j - 1 , $ k ) ) , lcsOf3 ( $ i , $ j , $ k - 1 ) ) ; } $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ o = strlen ( $ Z ) ; echo \" Length \u2581 of \u2581 LCS \u2581 is \u2581 \" . lcsOf3 ( $ m - 1 , $ n - 1 , $ o - 1 ) ; ? >"}
{"text":"Count number of ways to reach destination in a Maze | PHP program to count number of paths in a maze with obstacles . ; Returns count of possible paths in a maze [ R ] [ C ] from ( 0 , 0 ) to ( R - 1 , C - 1 ) ; If the initial cell is blocked , there is no way of moving anywhere ; Initializing the leftmost column ; If we encounter a blocked cell in leftmost row , there is no way of visiting any cell directly below it . ; Similarly initialize the topmost row ; If we encounter a blocked cell in bottommost row , there is no way of visiting any cell directly below it . ; The only difference is that if a cell is - 1 , simply ignore it else recursively compute count value maze [ i ] [ j ] ; If blockage is found , ignore this cell ; If we can reach maze [ i ] [ j ] from maze [ i - 1 ] [ j ] then increment count . ; If we can reach maze [ i ] [ j ] from maze [ i ] [ j - 1 ] then increment count . ; If the final cell is blocked , output 0 , otherwise the answer ; Driver Code","code":"< ? php $ R = 4 ; $ C = 4 ; function countPaths ( $ maze ) { global $ R , $ C ; if ( $ maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( $ i = 0 ; $ i < $ R ; $ i ++ ) { if ( $ maze [ $ i ] [ 0 ] == 0 ) $ maze [ $ i ] [ 0 ] = 1 ; else break ; } for ( $ i = 1 ; $ i < $ C ; $ i ++ ) { if ( $ maze [ 0 ] [ $ i ] == 0 ) $ maze [ 0 ] [ $ i ] = 1 ; else break ; } for ( $ i = 1 ; $ i < $ R ; $ i ++ ) { for ( $ j = 1 ; $ j < $ C ; $ j ++ ) { if ( $ maze [ $ i ] [ $ j ] == -1 ) continue ; if ( $ maze [ $ i - 1 ] [ $ j ] > 0 ) $ maze [ $ i ] [ $ j ] = ( $ maze [ $ i ] [ $ j ] + $ maze [ $ i - 1 ] [ $ j ] ) ; if ( $ maze [ $ i ] [ $ j - 1 ] > 0 ) $ maze [ $ i ] [ $ j ] = ( $ maze [ $ i ] [ $ j ] + $ maze [ $ i ] [ $ j - 1 ] ) ; } } return ( $ maze [ $ R - 1 ] [ $ C - 1 ] > 0 ) ? $ maze [ $ R - 1 ] [ $ C - 1 ] : 0 ; } $ maze = array ( array ( 0 , 0 , 0 , 0 ) , array ( 0 , -1 , 0 , 0 ) , array ( -1 , 0 , 0 , 0 ) , array ( 0 , 0 , 0 , 0 ) ) ; echo countPaths ( $ maze ) ; ? >"}
{"text":"Maximum decimal value path in a binary matrix | Returns maximum decimal value in binary matrix . Here p indicate power of 2 ; Out of matrix boundary ; If current matrix value is 1 then return result + power ( 2 , p ) else result ; Driver Code","code":"< ? php function maxDecimalValue ( $ mat , $ i , $ j , $ p ) { $ N = 4 ; if ( $ i >= $ N $ j >= $ N ) return 0 ; $ result = max ( maxDecimalValue ( $ mat , $ i , $ j + 1 , $ p + 1 ) , maxDecimalValue ( $ mat , $ i + 1 , $ j , $ p + 1 ) ) ; if ( $ mat [ $ i ] [ $ j ] == 1 ) return pow ( 2 , $ p ) + $ result ; else return $ result ; } $ mat = array ( array ( 1 , 1 , 0 , 1 ) , array ( 0 , 1 , 1 , 0 ) , array ( 1 , 0 , 0 , 1 ) , array ( 1 , 0 , 1 , 1 ) ) ; echo maxDecimalValue ( $ mat , 0 , 0 , 0 ) ; ? >"}
{"text":"Count All Palindrome Sub | Returns total number of palindrome substring of length greater then equal to 2 ; create empty 2 - D matrix that counts all palindrome substring . dp [ i ] [ j ] stores counts of palindromic substrings in st [ i . . j ] ; P [ i ] [ j ] = true if substring str [ i . . j ] is palindrome , else false ; palindrome of single length ; palindrome of length 2 ; Palindromes of length more then 2. This loop is similar to Matrix Chain Multiplication . We start with a gap of length 2 and fill DP table in a way that gap between starting and ending indexes increases one by one by outer loop . ; Pick starting point for current gap ; Set ending point ; If current string is palindrome ; Add current palindrome substring ( + 1 ) and rest palindrome substring ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] ) remove common palindrome substrings ( - dp [ i + 1 ] [ j - 1 ] ) ; return total palindromic substrings ; Driver Code","code":"< ? php function CountPS ( $ str , $ n ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ P = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ P [ $ i ] [ $ j ] = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ P [ $ i ] [ $ i ] = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) { $ P [ $ i ] [ $ i + 1 ] = true ; $ dp [ $ i ] [ $ i + 1 ] = 1 ; } } for ( $ gap = 2 ; $ gap < $ n ; $ gap ++ ) { for ( $ i = 0 ; $ i < $ n - $ gap ; $ i ++ ) { $ j = $ gap + $ i ; if ( $ str [ $ i ] == $ str [ $ j ] && $ P [ $ i + 1 ] [ $ j - 1 ] ) $ P [ $ i ] [ $ j ] = true ; if ( $ P [ $ i ] [ $ j ] == true ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i + 1 ] [ $ j ] + 1 - $ dp [ $ i + 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i + 1 ] [ $ j ] - $ dp [ $ i + 1 ] [ $ j - 1 ] ; } } return $ dp [ 0 ] [ $ n - 1 ] ; } $ str = \" abaab \" ; $ n = strlen ( $ str ) ; echo CountPS ( $ str , $ n ) ; ? >"}
{"text":"Maximum subsequence sum such that no three are consecutive | Returns maximum subsequence sum such that no three elements are consecutive ; Stores result for subarray arr [ 0. . i ] , i . e . , maximum possible sum in subarray arr [ 0. . i ] such that no three elements are consecutive$ . ; Base cases ( process first three elements ) ; Process rest of the elements We have three cases 1 ) Exclude arr [ i ] , i . e . , sum [ i ] = sum [ i - 1 ] 2 ) Exclude arr [ i - 1 ] , i . e . , sum [ i ] = sum [ i - 2 ] + arr [ i ] 3 ) Exclude arr [ i - 2 ] , i . e . , sum [ i - 3 ] + arr [ i ] + arr [ i - 1 ] ; Driver code","code":"< ? php function maxSumWO3Consec ( $ arr , $ n ) { $ sum = array ( ) ; if ( $ n >= 1 ) $ sum [ 0 ] = $ arr [ 0 ] ; if ( $ n >= 2 ) $ sum [ 1 ] = $ arr [ 0 ] + $ arr [ 1 ] ; if ( $ n > 2 ) $ sum [ 2 ] = max ( $ sum [ 1 ] , max ( $ arr [ 1 ] + $ arr [ 2 ] , $ arr [ 0 ] + $ arr [ 2 ] ) ) ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = max ( max ( $ sum [ $ i - 1 ] , $ sum [ $ i - 2 ] + $ arr [ $ i ] ) , $ arr [ $ i ] + $ arr [ $ i - 1 ] + $ sum [ $ i - 3 ] ) ; return $ sum [ $ n - 1 ] ; } $ arr = array ( 100 , 1000 , 100 , 1000 , 1 ) ; $ n = count ( $ arr ) ; echo maxSumWO3Consec ( $ arr , $ n ) ; ? >"}
{"text":"Maximum sum of pairs with specific difference | method to return maximum sum we can get by finding less than K difference pair ; Sort input array in ascending order . ; dp [ i ] denotes the maximum disjoint pair sum we can achieve using first i elements ; if no element then dp value will be 0 ; first give previous value to dp [ i ] i . e . no pairing with ( i - 1 ) th element ; if current and previous element can form a pair ; update dp [ i ] by choosing maximum between pairing and not pairing ; last index will have the result ; Driver code","code":"< ? php function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) { sort ( $ arr ) ; $ dp = array ( ) ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] ; if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ K ) { if ( $ i >= 2 ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - 2 ] + $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; else $ dp [ $ i ] = max ( $ dp [ $ i ] , $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; } } return $ dp [ $ N - 1 ] ; } $ arr = array ( 3 , 5 , 10 , 15 , 17 , 12 , 9 ) ; $ N = sizeof ( $ arr ) ; $ K = 4 ; echo maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) ; ? >"}
{"text":"Lucas Numbers | recursive function ; Base cases ; recurrence relation ; Driver Code","code":"< ? php function lucas ( $ n ) { if ( $ n == 0 ) return 2 ; if ( $ n == 1 ) return 1 ; return lucas ( $ n - 1 ) + lucas ( $ n - 2 ) ; } $ n = 9 ; echo lucas ( $ n ) ; ? >"}
{"text":"Recursively break a number in 3 parts to get maximum sum | Function to find the maximum sum ; base conditions ; recursively break the number and return what maximum you can get ; Driver program to run the case","code":"< ? php function breakSum ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; return max ( ( breakSum ( intval ( $ n \/ 2 ) ) + breakSum ( intval ( $ n \/ 3 ) ) + breakSum ( intval ( $ n \/ 4 ) ) ) , $ n ) ; } $ n = 12 ; echo breakSum ( $ n ) ; ? >"}
{"text":"Count All Palindromic Subsequence in a given String | Function return the total palindromic subsequence ; create a 2D array to store the count of palindromic subsequence ; palindromic subsequence of length 1 ; check subsequence of length L is palindrome or not ; return total palindromic subsequence ; Driver Code","code":"< ? php function countPS ( $ str ) { $ N = strlen ( $ str ) ; $ cps = array_fill ( 0 , $ N + 1 , array_fill ( 0 , $ N + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cps [ $ i ] [ $ i ] = 1 ; for ( $ L = 2 ; $ L <= $ N ; $ L ++ ) { for ( $ i = 0 ; $ i <= $ N - $ L ; $ i ++ ) { $ k = $ L + $ i - 1 ; if ( $ str [ $ i ] == $ str [ $ k ] ) $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] + 1 ; else $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] - $ cps [ $ i + 1 ] [ $ k - 1 ] ; } } return $ cps [ 0 ] [ $ N - 1 ] ; } $ str = \" abcb \" ; echo \" Total \u2581 palindromic \u2581 subsequence \u2581 are \u2581 : \u2581 \" . countPS ( $ str ) . \" STRNEWLINE \" ; ? >"}
{"text":"Count All Palindromic Subsequence in a given String | PHP program to counts Palindromic Subsequence in a given String using recursion ; Function return the total palindromic subsequence ; Driver code","code":"< ? php $ dp = array_fill ( 0 , 100 , array_fill ( 0 , 1000 , -1 ) ) ; $ str = \" abcb \" ; $ n = strlen ( $ str ) ; function countPS ( $ i , $ j ) { global $ str , $ dp , $ n ; if ( $ i > $ j ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; if ( $ i == $ j ) return $ dp [ $ i ] [ $ j ] = 1 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) + 1 ; else return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) - countPS ( $ i + 1 , $ j - 1 ) ; } echo \" Total \u2581 palindromic \u2581 subsequence \u2581 are \u2581 : \u2581 \" . countPS ( 0 , $ n - 1 ) ; ? >"}
{"text":"Find minimum sum such that one of every three consecutive elements is taken | function to find minimum of 3 elements ; Returns minimum possible sum of elements such that an element out of every three consecutive elements is picked . ; Create a DP table to store results of subproblems . sum [ i ] is going to store minimum possible sum when arr [ i ] is part of the solution . ; When there are less than or equal to 3 elements ; Iterate through all other elements ; Driver code","code":"< ? php function minimum ( $ a , $ b , $ c ) { return min ( min ( $ a , $ b ) , $ c ) ; } function findMinSum ( $ arr , $ n ) { $ sum [ $ n ] = 0 ; $ sum [ 0 ] = $ arr [ 0 ] ; $ sum [ 1 ] = $ arr [ 1 ] ; $ sum [ 2 ] = $ arr [ 2 ] ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = $ arr [ $ i ] + minimum ( $ sum [ $ i - 3 ] , $ sum [ $ i - 2 ] , $ sum [ $ i - 1 ] ) ; return minimum ( $ sum [ $ n - 1 ] , $ sum [ $ n - 2 ] , $ sum [ $ n - 3 ] ) ; } $ arr = array ( 1 , 2 , 3 , 20 , 2 , 10 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Min \u2581 Sum \u2581 is \u2581 \" , findMinSum ( $ arr , $ n ) ; ? >"}
{"text":"Minimum cost to fill given weight in a bag | PHP program to find minimum cost to get exactly W Kg with given packets ; cost [ ] initial cost array including unavailable packet W capacity of bag ; val [ ] and wt [ ] arrays val [ ] array to store cost of ' i ' kg packet of orange wt [ ] array weight of packet of orange ; traverse the original cost [ ] array and skip unavailable packets and make val [ ] and wt [ ] array . size variable tells the available number of distinct weighted packets ; fill 0 th row with infinity ; fill 0 'th column with 0 ; now check for each weight one by one and fill the matrix according to the condition ; wt [ i - 1 ] > j means capacity of bag is less then weight of item ; here we check we get minimum cost either by including it or excluding it ; exactly weight W can not be made by given weights ; Driver Code","code":"< ? php $ INF = 1000000 ; function MinimumCost ( & $ cost , $ n , $ W ) { global $ INF ; $ val = array ( ) ; $ wt = array ( ) ; $ size = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ cost [ $ i ] != -1 ) { array_push ( $ val , $ cost [ $ i ] ) ; array_push ( $ wt , $ i + 1 ) ; $ size ++ ; } } $ n = $ size ; $ min_cost = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ W + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ W ; $ i ++ ) $ min_cost [ 0 ] [ $ i ] = $ INF ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ min_cost [ $ i ] [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ W ; $ j ++ ) { if ( $ wt [ $ i - 1 ] > $ j ) $ min_cost [ $ i ] [ $ j ] = $ min_cost [ $ i - 1 ] [ $ j ] ; else $ min_cost [ $ i ] [ $ j ] = min ( $ min_cost [ $ i - 1 ] [ $ j ] , $ min_cost [ $ i ] [ $ j - $ wt [ $ i - 1 ] ] + $ val [ $ i - 1 ] ) ; } } if ( $ min_cost [ $ n ] [ $ W ] == $ INF ) return -1 ; else return $ min_cost [ $ n ] [ $ W ] ; } $ cost = array ( 1 , 2 , 3 , 4 , 5 ) ; $ W = 5 ; $ n = sizeof ( $ cost ) ; echo MinimumCost ( $ cost , $ n , $ W ) ; ? >"}
{"text":"Find number of times a string occurs as a subsequence in given string | Recursive function to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; If both first and second string is empty , or if second string is empty , return 1 ; If only first string is empty and second string is not empty , return 0 ; If last characters are same Recur for remaining strings by 1. considering last characters of both strings 2. ignoring last character of first string ; If last characters are different , ignore last char of first string and recur for remaining string ; Driver code","code":"< ? php function count_1 ( $ a , $ b , $ m , $ n ) { if ( ( $ m == 0 && $ n == 0 ) $ n == 0 ) return 1 ; if ( $ m == 0 ) return 0 ; if ( $ a [ $ m - 1 ] == $ b [ $ n - 1 ] ) return count_1 ( $ a , $ b , $ m - 1 , $ n - 1 ) + count_1 ( $ a , $ b , $ m - 1 , $ n ) ; else return count_1 ( $ a , $ b , $ m - 1 , $ n ) ; } $ a = \" GeeksforGeeks \" ; $ b = \" Gks \" ; echo count_1 ( $ a , $ b , strlen ( $ a ) , strlen ( $ b ) ) . \" \" ; return 0 ; ? >"}
{"text":"Minimum Cost To Make Two Strings Identical | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Returns cost of making X [ ] and Y [ ] identical . costX is cost of removing a character from X [ ] and costY is cost of removing a character from Y [ ] \/ ; Find LCS of X [ ] and Y [ ] ; Cost of making two strings identical is SUM of following two 1 ) Cost of removing extra characters from first string 2 ) Cost of removing extra characters from second string ; Driver program to test above function","code":"< ? php function lcs ( $ X , $ Y , $ m , $ n ) { $ L = array_fill ( 0 , ( $ m + 1 ) , array_fill ( 0 , ( $ n + 1 ) , NULL ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ i ] [ $ j ] = $ L [ $ i - 1 ] [ $ j - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] = max ( $ L [ $ i - 1 ] [ $ j ] , $ L [ $ i ] [ $ j - 1 ] ) ; } } return $ L [ $ m ] [ $ n ] ; } function findMinCost ( & $ X , & $ Y , $ costX , $ costY ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ len_LCS = lcs ( $ X , $ Y , $ m , $ n ) ; return $ costX * ( $ m - $ len_LCS ) + $ costY * ( $ n - $ len_LCS ) ; } $ X = \" ef \" ; $ Y = \" gh \" ; echo \" Minimum \u2581 Cost \u2581 to \u2581 make \u2581 two \u2581 strings \u2581 \" . \" identical is = \" return 0 ; ? >"}
{"text":"Number of non | Returns count of solutions of a + b + c = n ; Initialize result ; Consider all triplets and increment result whenever sum of a triplet is n . ; Driver Code","code":"< ? php function countIntegralSolutions ( $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j ++ ) for ( $ k = 0 ; $ k <= ( $ n - $ i - $ j ) ; $ k ++ ) if ( $ i + $ j + $ k == $ n ) $ result ++ ; return $ result ; } $ n = 3 ; echo countIntegralSolutions ( $ n ) ; ? >"}
{"text":"Number of non | Returns count of solutions of a + b + c = n ; Driver Code","code":"< ? php function countIntegralSolutions ( $ n ) { return ( ( $ n + 1 ) * ( $ n + 2 ) ) \/ 2 ; } $ n = 3 ; echo countIntegralSolutions ( $ n ) ; ? >"}
{"text":"Maximum absolute difference between sum of two contiguous sub | Find maximum subarray sum for subarray [ 0. . i ] using standard Kadane ' s \u2581 algorithm . \u2581 \u2581 This \u2581 version \u2581 of \u2581 Kadane ' s Algorithm will work if all numbers are negative ; Find maximum subarray sum for subarray [ i . . n ] using Kadane ' s \u2581 algorithm . \u2581 This \u2581 \u2581 version \u2581 of \u2581 Kadane ' s Algorithm will work if all numbers are negative ; The function finds two non - overlapping contiguous sub - arrays such that the absolute difference between the sum of two sub - array is maximum . ; create and build an array that stores maximum sums of subarrays that lie in arr [ 0. . . i ] ; create and build an array that stores maximum sums of subarrays that lie in arr [ i + 1. . . n - 1 ] ; Invert array ( change sign ) to find minumum sum subarrays ; create and build an array that stores minimum sums of subarrays that lie in arr [ 0. . . i ] ; create and build an array that stores minimum sums of subarrays that lie in arr [ i + 1. . . n - 1 ] ; For each index i , take maximum of 1. abs ( max sum subarray that lies in arr [ 0. . . i ] - min sum subarray that lies in arr [ i + 1. . . n - 1 ] ) 2. abs ( min sum subarray that lies in arr [ 0. . . i ] - max sum subarray that lies in arr [ i + 1. . . n - 1 ] ) ; Driver Code","code":"< ? php function maxLeftSubArraySum ( & $ a , $ size , & $ sum ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; $ sum [ 0 ] = $ max_so_far ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; $ sum [ $ i ] = $ max_so_far ; } return $ max_so_far ; } function maxRightSubArraySum ( & $ a , $ n , & $ sum ) { $ max_so_far = $ a [ $ n ] ; $ curr_max = $ a [ $ n ] ; $ sum [ $ n ] = $ max_so_far ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; $ sum [ $ i ] = $ max_so_far ; } return $ max_so_far ; } function findMaxAbsDiff ( & $ arr , $ n ) { $ leftMax = array_fill ( 0 , $ n , NULL ) ; maxLeftSubArraySum ( $ arr , $ n , $ leftMax ) ; $ rightMax = array_fill ( 0 , $ n , NULL ) ; maxRightSubArraySum ( $ arr , $ n - 1 , $ rightMax ) ; $ invertArr = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ invertArr [ $ i ] = - $ arr [ $ i ] ; $ leftMin = array_fill ( 0 , $ n , NULL ) ; maxLeftSubArraySum ( $ invertArr , $ n , $ leftMin ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leftMin [ $ i ] = - $ leftMin [ $ i ] ; $ rightMin = array_fill ( 0 , $ n , NULL ) ; maxRightSubArraySum ( $ invertArr , $ n - 1 , $ rightMin ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ rightMin [ $ i ] = - $ rightMin [ $ i ] ; $ result = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ absValue = max ( abs ( $ leftMax [ $ i ] - $ rightMin [ $ i + 1 ] ) , abs ( $ leftMin [ $ i ] - $ rightMax [ $ i + 1 ] ) ) ; if ( $ absValue > $ result ) $ result = $ absValue ; } return $ result ; } $ a = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n = sizeof ( $ a ) ; echo findMaxAbsDiff ( $ a , $ n ) ; ? >"}
{"text":"Ways to arrange Balls such that adjacent balls are of different types | Returns count of arrangements where last placed ball is ' last ' . ' last ' is 0 for ' p ' , 1 for ' q ' and 2 for ' r ' ; if number of balls of any color becomes less than 0 the number of ways arrangements is 0. ; If last ball required is of type P and the number of balls of P type is 1 while number of balls of other color is 0 the number of ways is 1. ; Same case as above for ' q ' and ' r ' ; if last ball required is P and the number of ways is the sum of number of ways to form sequence with ' p - 1' P balls , q Q Balls and r R balls ending with Q and R . ; Same as above case for ' q ' and ' r ' ; Returns count of required arrangements ; Three cases arise : Last required balls is type P Last required balls is type Q Last required balls is type R ; Driver Code","code":"< ? php function countWays ( $ p , $ q , $ r , $ last ) { if ( $ p < 0 $ q < 0 $ r < 0 ) return 0 ; if ( $ p == 1 && $ q == 0 && $ r == 0 && $ last == 0 ) return 1 ; if ( $ p == 0 && $ q == 1 && $ r == 0 && $ last == 1 ) return 1 ; if ( $ p == 0 && $ q == 0 && $ r == 1 && $ last == 2 ) return 1 ; if ( $ last == 0 ) return countWays ( $ p - 1 , $ q , $ r , 1 ) + countWays ( $ p - 1 , $ q , $ r , 2 ) ; if ( $ last == 1 ) return countWays ( $ p , $ q - 1 , $ r , 0 ) + countWays ( $ p , $ q - 1 , $ r , 2 ) ; if ( $ last == 2 ) return countWays ( $ p , $ q , $ r - 1 , 0 ) + countWays ( $ p , $ q , $ r - 1 , 1 ) ; } function countUtil ( $ p , $ q , $ r ) { return countWays ( $ p , $ q , $ r , 0 ) + countWays ( $ p , $ q , $ r , 1 ) + countWays ( $ p , $ q , $ r , 2 ) ; } $ p = 1 ; $ q = 1 ; $ r = 1 ; echo ( countUtil ( $ p , $ q , $ r ) ) ; ? >"}
{"text":"Count number of ways to partition a set into k subsets | Returns count of different partitions of n elements in k subsets ; Base cases ; S ( n + 1 , k ) = k * S ( n , k ) + S ( n , k - 1 ) ; Driver Code","code":"< ? php function countP ( $ n , $ k ) { if ( $ n == 0 $ k == 0 $ k > $ n ) return 0 ; if ( $ k == 1 $ k == $ n ) return 1 ; return $ k * countP ( $ n - 1 , $ k ) + countP ( $ n - 1 , $ k - 1 ) ; } echo countP ( 3 , 2 ) ; ? >"}
{"text":"Count number of ways to partition a set into k subsets | Returns count of different partitions of n elements in k subsets ; Table to store results of subproblems ; Base cases ; Fill rest of the entries in dp [ ] [ ] in bottom up manner ; Driver Code","code":"< ? php function countP ( $ n , $ k ) { $ dp [ $ n + 1 ] [ $ k + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ dp [ 0 ] [ $ k ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) if ( $ j == 1 $ i == $ j ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ j * $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ k ] ; } echo countP ( 5 , 2 ) ; ? >"}
{"text":"Count number of ways to cover a distance | Returns count of ways to cover ' dist ' ; Base cases ; Recur for all previous 3 and add the results ; Driver Code","code":"< ? php function printCountRec ( $ dist ) { if ( $ dist < 0 ) return 0 ; if ( $ dist == 0 ) return 1 ; return printCountRec ( $ dist - 1 ) + printCountRec ( $ dist - 2 ) + printCountRec ( $ dist - 3 ) ; } $ dist = 4 ; echo printCountRec ( $ dist ) ; ? >"}
{"text":"Count numbers from 1 to n that have 4 as a digit | Returns sum of all digits in numbers from 1 to n ; One by one compute sum of digits in every number from 1 to n ; A utility function to compute sum of digits in a given number x ; Driver Code","code":"< ? php function countNumbersWith4 ( $ n ) { for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ result += has4 ( $ x ) ? 1 : 0 ; return $ result ; } function has4 ( $ x ) { while ( $ x != 0 ) { if ( $ x % 10 == 4 ) return true ; $ x = intval ( $ x \/ 10 ) ; } return false ; } $ n = 328 ; echo \" Count \u2581 of \u2581 numbers \u2581 from \u2581 1 \u2581 to \u2581 \" . $ n . \" \u2581 that \u2581 have \u2581 4 \u2581 as \u2581 a \u2581 a \u2581 digit \u2581 is \u2581 \" . countNumbersWith4 ( $ n ) ; ? >"}
{"text":"Count numbers from 1 to n that have 4 as a digit | Function to count numbers from 1 to n that have 4 as a digit ; Base case ; d = number of digits minus one in n . For 328 , d is 2 ; computing count of numbers from 1 to 10 ^ d - 1 , d = 0 a [ 0 ] = 0 ; d = 1 a [ 1 ] = count of numbers from 0 to 9 is 1 d = 2 a [ 2 ] = count of numbers from 0 to 99 is a [ 1 ] * 9 + 10 = 19 d = 3 a [ 3 ] = count of numbers from 0 to 999 is a [ 2 ] * 19 + 100 = 171 ; Computing 10 ^ d ; Most significant digit ( msd ) of n , For 328 , msd is 3 which can be obtained using 328 \/ 100 ; If MSD is 4. For example if n = 428 , then count of numbers is sum of following . 1 ) Count of numbers from 1 to 399 2 ) Count of numbers from 400 to 428 which is 29. ; IF MSD > 4. For example if n is 728 , then count of numbers is sum of following . 1 ) Count of numbers from 1 to 399 and count of numbers from 500 to 699 , i . e . , \" a [ 2 ] \u2581 * \u2581 6\" 2 ) Count of numbers from 400 to 499 , i . e . 100 3 ) Count of numbers from 700 to 728 , recur for 28 ; IF MSD < 4. For example if n is 328 , then count of numbers is sum of following . 1 ) Count of numbers from 1 to 299 a 2 ) Count of numbers from 300 to 328 , recur for 28 ; Driver Code","code":"< ? php function countNumbersWith4 ( $ n ) { if ( $ n < 4 ) return 0 ; $ d = ( int ) log10 ( $ n ) ; $ a = array_fill ( 0 , $ d + 1 , NULL ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 9 + ceil ( pow ( 10 , $ i - 1 ) ) ; $ p = ceil ( pow ( 10 , $ d ) ) ; $ msd = intval ( $ n \/ $ p ) ; if ( $ msd == 4 ) return ( $ msd ) * $ a [ $ d ] + ( $ n % $ p ) + 1 ; if ( $ msd > 4 ) return ( $ msd - 1 ) * $ a [ $ d ] + $ p + countNumbersWith4 ( $ n % $ p ) ; return ( $ msd ) * $ a [ $ d ] + countNumbersWith4 ( $ n % $ p ) ; } $ n = 328 ; echo \" Count \u2581 of \u2581 numbers \u2581 from \u2581 1 \u2581 to \u2581 \" . $ n . \" \u2581 that \u2581 have \u2581 4 \u2581 as \u2581 a \u2581 digit \u2581 is \u2581 \" . countNumbersWith4 ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Remove minimum elements from either side such that 2 * min becomes more than max | Returns the minimum number of removals from either end in arr [ l . . h ] so that 2 * min becomes greater than max . ; Initialize starting and ending indexes of the maximum sized subarray with property 2 * min > max ; Choose different elements as starting point ; Initialize min and max for the current start ; Choose different ending points for current start ; Update min and max if necessary ; If the property is violated , then no point to continue for a bigger array ; Update longest_start and longest_end if needed ; If not even a single element follow the property , then return n ; Return the number of elements to be removed ; Driver Code","code":"< ? php function minRemovalsDP ( $ arr , $ n ) { $ longest_start = -1 ; $ longest_end = 0 ; for ( $ start = 0 ; $ start < $ n ; $ start ++ ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; for ( $ end = $ start ; $ end < $ n ; $ end ++ ) { $ val = $ arr [ $ end ] ; if ( $ val < $ min ) $ min = $ val ; if ( $ val > $ max ) $ max = $ val ; if ( 2 * $ min <= $ max ) break ; if ( $ end - $ start > $ longest_end - $ longest_start $ longest_start == -1 ) { $ longest_start = $ start ; $ longest_end = $ end ; } } } if ( $ longest_start == -1 ) return $ n ; return ( $ n - ( $ longest_end - $ longest_start + 1 ) ) ; } $ arr = array ( 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ) ; $ n = sizeof ( $ arr ) ; echo minRemovalsDP ( $ arr , $ n ) ; ? >"}
{"text":"Optimal Strategy for a Game | DP | Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Create a table to store solutions of subproblems ; Fill table using above recursive formula . Note that the table is filled in diagonal fashion ( similar to http : goo . gl \/ PQqoS ) , from diagonal elements to table [ 0 ] [ n - 1 ] which is the result . ; Here x is value of F ( i + 2 , j ) , y is F ( i + 1 , j - 1 ) and z is F ( i , j - 2 ) in above recursive formula ; Driver Code","code":"< ? php function optimalStrategyOfGame ( $ arr , $ n ) { $ table = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ x = ( ( $ i + 2 ) <= $ j ) ? $ table [ $ i + 2 ] [ $ j ] : 0 ; $ y = ( ( $ i + 1 ) <= ( $ j - 1 ) ) ? $ table [ $ i + 1 ] [ $ j - 1 ] : 0 ; $ z = ( $ i <= ( $ j - 2 ) ) ? $ table [ $ i ] [ $ j - 2 ] : 0 ; $ table [ $ i ] [ $ j ] = max ( $ arr [ $ i ] + min ( $ x , $ y ) , $ arr [ $ j ] + min ( $ y , $ z ) ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; } $ arr1 = array ( 8 , 15 , 3 , 7 ) ; $ n = count ( $ arr1 ) ; print ( optimalStrategyOfGame ( $ arr1 , $ n ) . \" \" ) ; $ arr2 = array ( 2 , 2 , 2 , 2 ) ; $ n = count ( $ arr2 ) ; print ( optimalStrategyOfGame ( $ arr2 , $ n ) . \" \" ) ; $ arr3 = array ( 20 , 30 , 2 , 2 , 2 , 10 ) ; $ n = count ( $ arr3 ) ; print ( optimalStrategyOfGame ( $ arr3 , $ n ) . \" \" ) ; ? >"}
{"text":"Maximum Sum Increasing Subsequence | DP | maxSumIS ( ) returns the maximum sum of increasing subsequence in arr [ ] of size n ; Initialize msis values for all indexes ; Compute maximum sum values in bottom up manner ; Pick maximum of all msis values ; Driver Code","code":"< ? php function maxSumIS ( $ arr , $ n ) { $ max = 0 ; $ msis = array ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ msis [ $ i ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ msis [ $ i ] < $ msis [ $ j ] + $ arr [ $ i ] ) $ msis [ $ i ] = $ msis [ $ j ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ msis [ $ i ] ) $ max = $ msis [ $ i ] ; return $ max ; } $ arr = array ( 1 , 101 , 2 , 3 , 100 , 4 , 5 ) ; $ n = count ( $ arr ) ; echo \" Sum \u2581 of \u2581 maximum \u2581 sum \u2581 increasing \u2581 subsequence \u2581 is \u2581 \" . maxSumIS ( $ arr , $ n ) ; ? >"}
{"text":"Count strings that end with the given pattern | Function that return true if str ends with pat ; Pattern is larger in length than the string ; We match starting from the end while patLen is greater than or equal to 0. ; If at any index str doesn 't match  with pattern ; If str ends with the given pattern ; Function to return the count of required strings ; If current string ends with the given pattern ; Driver code","code":"< ? php function endsWith ( $ str , $ pat ) { $ patLen = strlen ( $ pat ) ; $ strLen = strlen ( $ str ) ; if ( $ patLen > $ strLen ) return false ; $ patLen -- ; $ strLen -- ; while ( $ patLen >= 0 ) { if ( $ pat [ $ patLen ] != $ str [ $ strLen ] ) return false ; $ patLen -- ; $ strLen -- ; } return true ; } function countOfStrings ( $ pat , $ n , $ sArr ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( endsWith ( $ sArr [ $ i ] , $ pat ) ) $ count ++ ; return $ count ; } $ pat = \" ks \" ; $ n = 4 ; $ sArr = array ( \" geeks \" , \" geeksforgeeks \" , \" games \" , \" unit \" ) ; echo countOfStrings ( $ pat , $ n , $ sArr ) ; ? >"}
{"text":"Length of the longest substring with consecutive characters | Function to return the ending index for the largest valid sub - string \/ starting from index i ; If the current character appears after the previous character according to the given circular alphabetical order ; Function to return the length of the longest sub - string of consecutive characters from str ; Valid sub - string exists from index i to end ; Update the length ; Driver code","code":"< ? php function getEndingIndex ( $ str , $ n , $ i ) { $ i ++ ; while ( $ i < $ n ) { $ curr = $ str [ $ i ] ; $ prev = $ str [ $ i - 1 ] ; if ( ( $ curr == ' a ' && $ prev == ' z ' ) || ( ord ( $ curr ) - ord ( $ prev ) == 1 ) ) $ i ++ ; else break ; } return $ i - 1 ; } function largestSubStr ( $ str , $ n ) { $ len = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ end = getEndingIndex ( $ str , $ n , $ i ) ; $ len = max ( $ end - $ i + 1 , $ len ) ; $ i = $ end + 1 ; } return $ len ; } $ str = \" abcabcdefabc \" ; $ n = strlen ( $ str ) ; echo largestSubStr ( $ str , $ n ) ; ? >"}
{"text":"Sum of integers upto N with given unit digit ( Set 2 ) | Function to return the required sum ; Decrement N ; Driver code","code":"< ? php function getSum ( $ n , $ d ) { if ( $ n < $ d ) return 0 ; while ( $ n % 10 != $ d ) $ n -- ; $ k = ( int ) ( $ n \/ 10 ) ; return ( $ k + 1 ) * $ d + ( $ k * 10 + 10 * $ k * $ k ) \/ 2 ; } $ n = 30 ; $ d = 3 ; echo getSum ( $ n , $ d ) ; ? >"}
{"text":"Minimum characters to be replaced to remove the given substring | function to calculate minimum characters to replace ; mismatch occurs ; if all characters matched , i . e , there is a substring of ' a ' which is same as string ' b ' ; increment i to index m - 1 such that minimum characters are replaced in ' a ' ; Driver Code","code":"< ? php function replace ( $ A , $ B ) { $ n = strlen ( $ A ) ; $ m = strlen ( $ B ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ i + $ j >= $ n ) { break ; } else if ( $ A [ $ i + $ j ] != $ B [ $ j ] ) { break ; } } if ( $ j == $ m ) { $ count ++ ; $ i = $ i + $ m - 1 ; } } return $ count ; } $ str1 = \" aaaaaaaa \" ; $ str2 = \" aaa \" ; echo ( replace ( $ str1 , $ str2 ) ) ; ? >"}
{"text":"Check if a string is substring of another | Returns true if s1 is substring of s2 ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; Driver Code","code":"< ? php function isSubstring ( $ s1 , $ s2 ) { $ M = strlen ( $ s1 ) ; $ N = strlen ( $ s2 ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { $ j = 0 ; for ( ; $ j < $ M ; $ j ++ ) if ( $ s2 [ $ i + $ j ] != $ s1 [ $ j ] ) break ; if ( $ j == $ M ) return $ i ; } return -1 ; } $ s1 = \" for \" ; $ s2 = \" geeksforgeeks \" ; $ res = isSubstring ( $ s1 , $ s2 ) ; if ( $ res == -1 ) echo \" Not \u2581 present \" ; else echo \" Present \u2581 at \u2581 index \u2581 \" . $ res ; ? >"}
{"text":"Find all the patterns of \"1(0 + ) 1\" in a given string | SET 1 ( General Approach ) | Function to count patterns ; Variable to store the last character ; We found 0 and last character was '1' , state change ; After the stream of 0 ' s , \u2581 \u2581 we \u2581 got \u2581 a \u2581 ' 1 ', counter  incremented ; Last character stored ; Driver Code","code":"< ? php function patternCount ( $ str ) { $ last = $ str [ 0 ] ; $ i = 1 ; $ counter = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == '0' && $ last == '1' ) { while ( $ str [ $ i ] == '0' ) $ i ++ ; if ( $ str [ $ i ] == '1' ) $ counter ++ ; } $ last = $ str [ $ i ] ; $ i ++ ; } return $ counter ; } $ str = \"1001ab010abc01001\" ; echo patternCount ( $ str ) ; ? >"}
{"text":"Maximum length prefix of one string that occurs as subsequence in another | Return the maximum length prefix which is subsequence . ; Iterating string T . ; If end of string S . ; If character match , increment counter . ; Driver Code","code":"< ? php function maxPrefix ( $ s , $ t ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ t ) ; $ i ++ ) { if ( $ count == strlen ( $ s ) ) break ; if ( $ t [ $ i ] == $ s [ $ count ] ) $ count ++ ; } return $ count ; } { $ S = \" digger \" ; $ T = \" biggerdiagram \" ; echo maxPrefix ( $ S , $ T ) ; return 0 ; } ? >"}
{"text":"Replace all occurrences of string AB with C without using extra space | PHP program to replace all occurrences of \" AB \" with \" C \" ; Start traversing from second character ; If previous character is ' A ' and current character is 'B\" ; Replace previous character with ' C ' and move all subsequent characters one position back ; Driver code","code":"< ? php function translate ( & $ str ) { if ( $ str [ 0 ] == ' ' ) return ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i - 1 ] == ' A ' && $ str [ $ i ] == ' B ' ) { $ str [ $ i - 1 ] = ' C ' ; for ( $ j = $ i ; $ j < strlen ( $ str ) ; $ j ++ ) $ str [ $ j ] = $ str [ $ j + 1 ] ; } } return ; } $ str = \" helloABworldABGfG \" ; translate ( $ str ) ; echo \" The \u2581 modified \u2581 string \u2581 is \u2581 : STRNEWLINE \" ; echo $ str ; ? >"}
{"text":"Find letter 's position in Alphabet using Bit operation | Function to calculate the position of characters ; Performing AND operation with number 31 $ ; Driver code","code":"< ? php function positions ( $ str , $ n ) { $ a = 31 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { print ( ( ord ( $ str [ $ i ] ) & ( $ a ) ) . \" \" ) ; } } $ str = \" Geeks \" ; $ n = strlen ( $ str ) ; positions ( $ str , $ n ) ; ? >"}
{"text":"Length of the longest substring that do not contain any palindrome | Function to find the length of the longest substring ; initializing the variables ; checking palindrome of size 2 example : aa ; checking palindrome of size 3 example : aba ; else incrementing length of substring ; $max1 = max ( $max1 , $len + 1 ) ; finding maximum ; if there exits single character then it is always palindrome ; Driver Code","code":"< ? php function lenoflongestnonpalindrome ( $ s ) { $ max1 = 1 ; $ len = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ len = 0 ; else if ( $ s [ $ i + 1 ] == $ s [ $ i - 1 ] && $ i > 0 ) $ len = 1 ; $ len ++ ; } if ( $ max1 == 1 ) return 0 ; else return $ max1 ; } $ s = \" synapse \" ; echo lenoflongestnonpalindrome ( $ s ) , \" \" ; ? >"}
{"text":"Make lexicographically smallest palindrome by substituting missing characters | Function to return the lexicographically smallest palindrome that can be made from the given string after replacing the required characters ; If characters are missing at both the positions then substitute it with ' a ' ; If only str [ j ] = ' * ' then update it with the value at str [ i ] ; If only str [ i ] = ' * ' then update it with the value at str [ j ] ; If characters at both positions are not equal and != ' * ' then the string cannot be made palindrome ; Return the required palindrome ; Driver code","code":"< ? php function makePalindrome ( $ str ) { $ i = 0 ; $ j = strlen ( $ str ) - 1 ; while ( $ i <= $ j ) { if ( $ str [ $ i ] == ' * ' && $ str [ $ j ] == ' * ' ) { $ str [ $ i ] = ' a ' ; $ str [ $ j ] = ' a ' ; } else if ( $ str [ $ j ] == ' * ' ) $ str [ $ j ] = $ str [ $ i ] ; else if ( $ str [ $ i ] == ' * ' ) $ str [ $ i ] = $ str [ $ j ] ; else if ( $ str [ $ i ] != $ str [ $ j ] ) return \" - 1\" ; $ i ++ ; $ j -- ; } return $ str ; } $ str = \" na * an \" ; echo makePalindrome ( $ str ) ; ? >"}
{"text":"Calculate score for the given binary string | Function to return the score for the given binary string ; Traverse through string character ; Initialize current chunk 's size ; Get current character ; Calculate total chunk size of same characters ; Add \/ subtract pow ( chunkSize , 2 ) depending upon character ; Return the score ; Driver code","code":"< ? php function calcScore ( $ str ) { $ score = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len { $ chunkSize = 1 ; $ currentChar = $ str [ $ i ++ ] ; while ( $ i < $ len && $ str [ $ i ] == $ currentChar ) { $ chunkSize ++ ; $ i ++ ; } if ( $ currentChar == '1' ) $ score += pow ( $ chunkSize , 2 ) ; else $ score -= pow ( $ chunkSize , 2 ) ; } return $ score ; } $ str = \"11011\" ; echo calcScore ( $ str ) ; ? >"}
{"text":"Number of sub | Function to return the count of required sub - strings ; Left and right counters for characters on both sides of sub - string window ; Left and right pointer on both sides of sub - string window ; Initialize the frequency ; Result and length of string ; Initialize the left pointer ; Initialize the right pointer ; Traverse all the window sub - strings ; Counting the characters on left side of the sub - string window ; Counting the characters on right side of the sub - string window ; Add the possible sub - strings on both sides to result ; Setting the frequency for next sub - string window ; Reset the left and right counters ; Driver code","code":"< ? php function countSubString ( $ s , $ c , $ k ) { $ leftCount = 0 ; $ rightCount = 0 ; $ left = 0 ; $ right = 0 ; $ freq = 0 ; $ result = 0 ; $ len = strlen ( $ s ) ; while ( $ s [ $ left ] != $ c && $ left < $ len ) { $ left ++ ; $ leftCount ++ ; } $ right = $ left + 1 ; while ( $ freq != ( $ k - 1 ) && ( $ right - 1 ) < $ len ) { if ( $ s [ $ right ] == $ c ) $ freq ++ ; $ right ++ ; } while ( $ left < $ len && ( $ right - 1 ) < $ len ) { while ( $ s [ $ left ] != $ c && $ left < $ len ) { $ left ++ ; $ leftCount ++ ; } while ( $ right < $ len && $ s [ $ right ] != $ c ) { if ( $ s [ $ right ] == $ c ) $ freq ++ ; $ right ++ ; $ rightCount ++ ; } $ result = $ result + ( $ leftCount + 1 ) * ( $ rightCount + 1 ) ; $ freq = $ k - 1 ; $ leftCount = 0 ; $ rightCount = 0 ; $ left ++ ; $ right ++ ; } return $ result ; } $ s = \" abada \" ; $ c = ' a ' ; $ k = 2 ; echo countSubString ( $ s , $ c , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check whether the given string is a valid identifier | Function that returns true if str is a valid identifier ; If first character is invalid ; Traverse the string for the rest of the characters ; String is a valid identifier ; Driver code","code":"< ? php function isValid ( $ str , $ n ) { if ( ! ( ( $ str [ 0 ] >= ' a ' && $ str [ 0 ] <= ' z ' ) || ( $ str [ 0 ] >= ' A ' && $ str [ 0 ] <= ' Z ' ) $ str [ 0 ] == ' _ ' ) ) return false ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! ( ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) || ( $ str [ $ i ] >= '0' && $ str [ $ i ] <= '9' ) $ str [ $ i ] == ' _ ' ) ) return false ; } return true ; } $ str = \" _ geeks123\" ; $ n = strlen ( $ str ) ; if ( isValid ( $ str , $ n ) ) print ( \" Valid \" ) ; else print ( \" Invalid \" ) ; ? >"}
{"text":"Capitalize the first and last character of each word in a string | PHP program to capitalise the first and last character of each word in a string . ; Create an equivalent string of the given string ; $k stores index of first character and $i is going to store index of last character . ; Check if the character is a small letter If yes , then Capitalise ; Driver code","code":"< ? php function FirstAndLast ( $ str ) { $ ch = $ str ; for ( $ i = 0 ; $ i < strlen ( $ ch ) ; $ i ++ ) { $ k = $ i ; while ( $ i < strlen ( $ ch ) && $ ch [ $ i ] != ' \u2581 ' ) $ i ++ ; $ ch [ $ k ] = chr ( ( $ ch [ $ k ] >= ' a ' && $ ch [ $ k ] <= ' z ' ) ? ( ord ( $ ch [ $ k ] ) - 32 ) : ( ord ( $ ch [ $ k ] ) ) ) ; $ ch [ $ i - 1 ] = chr ( ( $ ch [ $ i - 1 ] >= ' a ' && $ ch [ $ i - 1 ] <= ' z ' ) ? ( ord ( $ ch [ $ i - 1 ] ) - 32 ) : ( ord ( $ ch [ $ i - 1 ] ) ) ) ; } return $ ch ; } $ str = \" Geeks \u2581 for \u2581 Geeks \" ; echo $ str , \" STRNEWLINE \" ; echo FirstAndLast ( $ str ) ; ? >"}
{"text":"Find the number of players who roll the dice when the dice output sequence is given | Function to return the number of players ; Initialize cnt as 0 ; Iterate in the string ; Check for numbers other than x ; Driver code","code":"< ? php function findM ( $ s , $ x ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] ) - ord ( '0' ) != $ x ) $ cnt ++ ; } return $ cnt ; } $ s = \"3662123\" ; $ x = 6 ; echo findM ( $ s , $ x ) ; ? >"}
{"text":"Find the longest sub | Function to find longest prefix suffix ; To store longest prefix suffix ; Length of the previous longest prefix suffix ; lps [ 0 ] is always 0 ; Loop calculates lps [ i ] for i = 1 to n - 1 ; ( pat [ i ] != pat [ len ] ) ; If len = 0 ; Function to find the longest substring which is prefix as well as a sub - string of s [ 1. . . n - 2 ] ; Find longest prefix suffix ; If lps of n - 1 is zero ; At any position lps [ i ] equals to lps [ n - 1 ] ; If answer is not possible ; Driver code ; function call","code":"< ? php function compute_lps ( $ s ) { $ n = strlen ( $ s ) ; $ lps = array ( ) ; $ len = 0 ; $ lps [ 0 ] = 0 ; $ i = 1 ; while ( $ i < $ n ) { if ( $ s [ $ i ] == $ s [ $ len ] ) { $ len ++ ; $ lps [ $ i ] = $ len ; $ i ++ ; } else { if ( $ len != 0 ) $ len = $ lps [ $ len - 1 ] ; else { $ lps [ $ i ] = 0 ; $ i ++ ; } } } return $ lps ; } function Longestsubstring ( $ s ) { $ lps = compute_lps ( $ s ) ; $ n = strlen ( $ s ) ; if ( $ lps [ $ n - 1 ] == 0 ) { echo - 1 ; return ; } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ lps [ $ i ] == $ lps [ $ n - 1 ] ) { echo substr ( $ s , 0 , $ lps [ $ i ] ) ; return ; } } if ( $ lps [ $ lps [ $ n - 1 ] - 1 ] == 0 ) echo - 1 ; else echo substr ( $ s , 0 , $ lps [ $ lps [ $ n - 1 ] - 1 ] ) ; } $ s = \" fixprefixsuffix \" ; Longestsubstring ( $ s ) ; ? >"}
{"text":"Pairs of strings which on concatenating contains each character of \" string \" | PHP implementation of the approach ; Function to return the bitmask for the string ; Function to return the count of pairs ; bitMask [ i ] will store the count of strings from the array whose bitmask is i ; To store the count of pairs ; MAX - 1 = 63 i . e . 111111 in binary ; arr [ i ] cannot make s pair with itself i . e . ( arr [ i ] , arr [ i ] ) ; Driver code","code":"< ? php $ MAX = 64 ; function getBitmask ( $ s ) { $ temp = 0 ; for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ j ] == ' s ' ) { $ temp = $ temp | ( 1 ) ; } else if ( $ s [ $ j ] == ' t ' ) { $ temp = $ temp | ( 2 ) ; } else if ( $ s [ $ j ] == ' r ' ) { $ temp = $ temp | ( 4 ) ; } else if ( $ s [ $ j ] == ' i ' ) { $ temp = $ temp | ( 8 ) ; } else if ( $ s [ $ j ] == ' n ' ) { $ temp = $ temp | ( 16 ) ; } else if ( $ s [ $ j ] == ' g ' ) { $ temp = $ temp | ( 32 ) ; } } return $ temp ; } function countPairs ( $ arr , $ n ) { $ bitMask = array_fill ( 0 , $ GLOBALS [ ' MAX ' ] , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ bitMask [ getBitmask ( $ arr [ $ i ] ) ] ++ ; $ cnt = 0 ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' MAX ' ] ; $ i ++ ) { for ( $ j = $ i ; $ j < $ GLOBALS [ ' MAX ' ] ; $ j ++ ) { if ( ( $ i $ j ) == ( $ GLOBALS [ ' MAX ' ] - 1 ) ) { if ( $ i == $ j ) $ cnt += floor ( ( $ bitMask [ $ i ] * $ bitMask [ $ i ] - 1 ) \/ 2 ) ; else $ cnt += ( $ bitMask [ $ i ] * $ bitMask [ $ j ] ) ; } } } return $ cnt ; } $ arr = array ( \" strrr \" , \" string \" , \" gstrin \" ) ; $ n = count ( $ arr ) ; echo countPairs ( $ arr , $ n ) ; ? >"}
{"text":"Find the count of sub | Function to return the count of required occurrence ; To store the count of occurrences ; Check first four characters from ith position ; Variables for counting the required characters ; Check the four contiguous characters which can be reordered to form ' clap ' ; If all four contiguous characters are present then increment cnt variable ; Driver code","code":"< ? php function countOcc ( $ s ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) - 3 ; $ i ++ ) { $ c = 0 ; $ l = 0 ; $ a = 0 ; $ p = 0 ; for ( $ j = $ i ; $ j < $ i + 4 ; $ j ++ ) { switch ( $ s [ $ j ] ) { case ' c ' : $ c ++ ; break ; case ' l ' : $ l ++ ; break ; case ' a ' : $ a ++ ; break ; case ' p ' : $ p ++ ; break ; } } if ( $ c == 1 && $ l == 1 && $ a == 1 && $ p == 1 ) $ cnt ++ ; } return $ cnt ; } $ s = \" clapc \" ; echo countOcc ( strtolower ( $ s ) ) ; ? >"}
{"text":"Number of ways in which the substring in range [ L , R ] can be formed using characters out of the range | Function to return the number of ways to form the sub - string ; Initialize a hash - table with 0 ; Iterate in the string and count the frequency of characters that do not lie in the range L and R ; Out of range characters ; Stores the final number of ways ; Iterate for the sub - string in the range L and R ; If exists then multiply the number of ways and decrement the frequency ; If does not exist the sub - string cannot be formed ; Return the answer ; Driver code","code":"< ? php function calculateWays ( $ s , $ n , $ l , $ r ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { $ freq [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ l $ i > $ r ) $ freq [ ord ( $ s [ $ i ] ) - 97 ] ++ ; } $ ways = 1 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ freq [ ord ( $ s [ $ i ] ) - 97 ] ) { $ ways = $ ways * $ freq [ ord ( $ s [ $ i ] ) - 97 ] ; $ freq [ ord ( $ s [ $ i ] ) - 97 ] -- ; } else { $ ways = 0 ; break ; } } return $ ways ; } $ s = \" cabcaab \" ; $ n = strlen ( $ s ) ; $ l = 1 ; $ r = 3 ; echo calculateWays ( $ s , $ n , $ l , $ r ) ; ? >"}
{"text":"Convert the ASCII value sentence to its equivalent string | Function to print the character sequence for the given ASCII sentence ; Append the current digit ; If num is within the required range ; Convert num to char ; Reset num to 0 ; Driver code","code":"< ? php function asciiToSentence ( $ string , $ length ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ num = $ num * 10 + ( ord ( $ string [ $ i ] ) - ord ( '0' ) ) ; if ( $ num >= 32 && $ num <= 122 ) { $ ch = chr ( $ num ) ; print ( $ ch ) ; $ num = 0 ; } } } $ string = \"7110110110711510211111471101101107115\" ; $ length = strlen ( $ string ) ; asciiToSentence ( $ string , $ length ) ; ? >"}
{"text":"Count of buttons pressed in a keypad mobile | Array to store how many times a button has to be pressed for typing a particular character ; Function to return the count of buttons pressed to type the given string ; Count the key presses ; Return the required count ; Driver code","code":"< ? php $ arr = array ( 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ) ; function countKeyPressed ( $ str , $ len ) { global $ arr ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ count = $ count + $ arr [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; return $ count ; } $ str = \" abcdef \" ; $ len = strlen ( $ str ) ; echo countKeyPressed ( $ str , $ len ) ; ? >"}
{"text":"First string from the given array whose reverse is also present in the same array | Function that returns true if s1 is equal to reverse of s2 ; If both the strings differ in length ; In case of any character mismatch ; Function to return the first word whose reverse is also present in the array ; Check every string ; Pair with every other string appearing after the current string ; If first string is equal to the reverse of the second string ; No such string exists ; Driver code","code":"< ? php function isReverseEqual ( $ s1 , $ s2 ) { if ( strlen ( $ s1 ) != strlen ( $ s2 ) ) return false ; $ len = strlen ( $ s1 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) if ( $ s1 [ $ i ] != $ s2 [ $ len - $ i - 1 ] ) return false ; return true ; } function getWord ( $ str , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( isReverseEqual ( $ str [ $ i ] , $ str [ $ j ] ) ) return $ str [ $ i ] ; return \" - 1\" ; } $ str = array ( \" geeks \" , \" for \" , \" skeeg \" ) ; $ n = count ( $ str ) ; print ( getWord ( $ str , $ n ) ) ; ? >"}
{"text":"Check if the given string is K | Function that return true if sub - of length $k starting at index $i is also a prefix of the string ; $k length sub - cannot start at index $i ; Character mismatch between the prefix and the sub - starting at index $i ; Function that returns true if $str is K - periodic ; Check whether all the sub - strings $str [ 0 , $k - 1 ] , $str [ $k , 2 k - 1 ] ... are equal to the $k length prefix of the ; Driver code","code":"< ? php function isPrefix ( $ str , $ len , $ i , $ k ) { if ( $ i + $ k > $ len ) return false ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) { if ( $ str [ $ i ] != $ str [ $ j ] ) return false ; $ i ++ ; } return true ; } function isKPeriodic ( $ str , $ len , $ k ) { for ( $ i = $ k ; $ i < $ len ; $ i += $ k ) if ( ! isPrefix ( $ str , $ len , $ i , $ k ) ) return false ; return true ; } $ str = \" geeksgeeks \" ; $ len = strlen ( $ str ) ; $ k = 5 ; if ( isKPeriodic ( $ str , $ len , $ k ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Minimum number of letters needed to make a total of n | Function to return the minimum letters required to make a total of n ; Driver code","code":"< ? php function minLettersNeeded ( $ n ) { if ( $ n % 26 == 0 ) return floor ( ( $ n \/ 26 ) ) ; else return floor ( ( $ n \/ 26 ) + 1 ) ; } $ n = 52 ; echo minLettersNeeded ( $ n ) ; ? >"}
{"text":"Minimum number of replacements to make the binary string alternating | Set 2 | Function to return the minimum number of characters of the given binary string to be replaced to make the string alternating ; If there is 1 at even index positions ; If there is 0 at odd index positions ; Driver code","code":"< ? php function minReplacement ( $ s , $ len ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == '1' ) $ ans ++ ; if ( $ i % 2 == 1 && $ s [ $ i ] == '0' ) $ ans ++ ; } return min ( $ ans , $ len - $ ans ) ; } $ s = \"1100\" ; $ len = strlen ( $ s ) ; echo minReplacement ( $ s , $ len ) ; ? >"}
{"text":"Group consecutive characters of same type in a string | Function to return the modified string ; Store original string ; Remove all white spaces ; To store the resultant string ; Traverse the string ; Group upper case characters ; Group numeric characters ; Group arithmetic operators ; Return the resultant string ; Driver code","code":"< ? php function groupCharacters ( $ s , $ len ) { $ temp = \" \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) if ( $ s [ $ i ] != ' \u2581 ' ) $ temp = $ temp . $ s [ $ i ] ; $ len = strlen ( $ temp ) ; $ ans = \" \" ; $ i = 0 ; while ( $ i < $ len ) { if ( ord ( $ temp [ $ i ] ) >= ord ( ' A ' ) && ord ( $ temp [ $ i ] ) <= ord ( ' Z ' ) ) { while ( $ i < $ len && ord ( $ temp [ $ i ] ) >= ord ( ' A ' ) && ord ( $ temp [ $ i ] ) <= ord ( ' Z ' ) ) { $ ans = $ ans . $ temp [ $ i ] ; $ i ++ ; } $ ans = $ ans . \" \u2581 \" ; } else if ( ord ( $ temp [ $ i ] ) >= ord ( '0' ) && ord ( $ temp [ $ i ] ) <= ord ( '9' ) ) { while ( $ i < $ len && ord ( $ temp [ $ i ] ) >= ord ( '0' ) && ord ( $ temp [ $ i ] ) <= ord ( '9' ) ) { $ ans = $ ans . $ temp [ $ i ] ; $ i ++ ; } $ ans = $ ans . \" \u2581 \" ; } else { while ( $ i < $ len && ord ( $ temp [ $ i ] ) >= ord ( ' * ' ) && ord ( $ temp [ $ i ] ) <= ord ( ' \/ ' ) ) { $ ans = $ ans . $ temp [ $ i ] ; $ i ++ ; } $ ans = $ ans . \" \u2581 \" ; } } return $ ans ; } $ s = \"34FTG234 + \u2581 + - \u2581 * \" ; $ len = strlen ( $ s ) ; print ( groupCharacters ( $ s , $ len ) ) ; ? >"}
{"text":"Find the minimum number of preprocess moves required to make two strings equal | Function to return the minimum number of pre - processing moves required on string A ; Length of the given strings ; To store the required answer ; To store frequency of 4 characters ; Run a loop upto n \/ 2 ; If size is 4 ; If size is 3 ; If size is 2 ; If n is odd ; Driver code","code":"< ? php function Preprocess ( $ A , $ B ) { $ n = strlen ( $ A ) ; $ ans = 0 ; $ mp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mp [ $ A [ $ i ] ] = 0 ; for ( $ i = 0 ; $ i < floor ( $ n \/ 2 ) ; $ i ++ ) { $ mp [ $ A [ $ i ] ] ++ ; $ mp [ $ A [ $ n - $ i - 1 ] ] ++ ; $ mp [ $ B [ $ i ] ] ++ ; $ mp [ $ B [ $ n - $ i - 1 ] ] ++ ; $ sz = sizeof ( $ mp ) ; if ( $ sz == 4 ) $ ans += 2 ; else if ( $ sz == 3 ) if ( $ A [ $ i ] == $ A [ $ n - $ i - 1 ] ) $ ans += 1 ; else $ ans += 1 ; else if ( $ sz == 2 ) $ ans += $ mp [ $ A [ $ i ] ] != 2 ; } if ( $ n % 2 == 1 && ( $ A [ floor ( $ n \/ 2 ) ] != $ B [ floor ( $ n \/ 2 ) ] ) ) $ ans ++ ; return $ ans ; } $ A = \" abacaba \" ; $ B = \" bacabaa \" ; echo Preprocess ( $ A , $ B ) ; ? >"}
{"text":"Check whether two strings are equivalent or not according to given condition | This function returns the least lexicogr aphical string obtained from its two halves ; Base Case - If string size is 1 ; Divide the string into its two halves ; Form least lexicographical string ; Driver Code","code":"< ? php function leastLexiString ( $ s ) { if ( strlen ( $ s ) & 1 ) return $ s ; $ x = leastLexiString ( substr ( $ s , 0 , floor ( strlen ( $ s ) \/ 2 ) ) ) ; $ y = leastLexiString ( substr ( $ s , floor ( strlen ( $ s ) \/ 2 ) , strlen ( $ s ) ) ) ; return min ( $ x . $ y , $ y . $ x ) ; } function areEquivalent ( $ a , $ b ) { return ( leastLexiString ( $ a ) == leastLexiString ( $ b ) ) ; } $ a = \" aaba \" ; $ b = \" abaa \" ; if ( areEquivalent ( $ a , $ b ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; $ a = \" aabb \" ; $ b = \" abab \" ; if ( areEquivalent ( $ a , $ b ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; ? >"}
{"text":"Generate a string consisting of characters ' a ' and ' b ' that satisfy the given conditions | Function to generate and print the required string ; More ' b ' , append \" bba \" ; More ' a ' , append \" aab \" ; Equal number of ' a ' and ' b ' append \" ab \" ; Driver code","code":"< ? php function generateString ( $ A , $ B ) { $ rt = \" \" ; while ( 0 < $ A 0 < $ B ) { if ( $ A < $ B ) { if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } } else if ( $ B < $ A ) { if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } } else { if ( 0 < $ A -- ) { $ rt . = ( ' a ' ) ; } if ( 0 < $ B -- ) { $ rt . = ( ' b ' ) ; } } } echo ( $ rt ) ; } $ A = 2 ; $ B = 6 ; generateString ( $ A , $ B ) ; ? >"}
{"text":"Lexicographically largest sub | Function to return the lexicographically largest sub - sequence of s ; Get the max character from the string ; Use all the occurrences of the current maximum character ; Repeat the steps for the remaining string ; Driver code","code":"< ? php function getSubSeq ( $ s , $ n ) { $ res = \" \" ; $ cr = 0 ; while ( $ cr < $ n ) { $ mx = $ s [ $ cr ] ; for ( $ i = $ cr + 1 ; $ i < $ n ; $ i ++ ) $ mx = max ( $ mx , $ s [ $ i ] ) ; $ lst = $ cr ; for ( $ i = $ cr ; $ i < $ n ; $ i ++ ) if ( $ s [ $ i ] == $ mx ) { $ res . = $ s [ $ i ] ; $ lst = $ i ; } $ cr = $ lst + 1 ; } return $ res ; } $ s = \" geeksforgeeks \" ; $ n = strlen ( $ s ) ; echo getSubSeq ( $ s , $ n ) ; ? >"}
{"text":"Count of sub | Function to return the count of sub - strings of str that are divisible by k ; Take all sub - strings starting from i ; If current sub - string is divisible by k ; Return the required count ; Driver code","code":"< ? php function countSubStr ( $ str , $ len , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ n = 0 ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ n = $ n * 10 + ( $ str [ $ j ] - '0' ) ; if ( $ n % $ k == 0 ) $ count ++ ; } } return $ count ; } $ str = \"33445\" ; $ len = strlen ( $ str ) ; $ k = 11 ; echo countSubStr ( $ str , $ len , $ k ) ; ? >"}
{"text":"Find the resulting Colour Combination | Function to return Colour Combination ; Check for B * G = Y ; Check for B * Y = G ; Check for Y * G = B ; Driver Code","code":"< ? php function Colour_Combination ( $ s ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ temp != $ s [ $ i ] ) { if ( ( $ temp == ' B ' $ temp == ' G ' ) && ( $ s [ $ i ] == ' G ' $ s [ $ i ] == ' B ' ) ) $ temp = ' Y ' ; else if ( ( $ temp == ' B ' $ temp == ' Y ' ) && ( $ s [ $ i ] == ' Y ' $ s [ $ i ] == ' B ' ) ) $ temp = ' G ' ; else $ temp = ' B ' ; } } return $ temp ; } $ s = \" GBYGB \" ; echo Colour_Combination ( $ s ) ; ? >"}
{"text":"Reverse Middle X Characters | Function to reverse the middle x characters in a string ; Find the position from where the characters have to be reversed ; Print the first n characters ; Print the middle x characters in reverse ; Print the last n characters ; Driver code","code":"< ? php function reverse ( $ str , $ x ) { $ n = ( strlen ( $ str ) - $ x ) \/ 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x - 1 ; $ i >= $ n ; $ i -- ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x ; $ i < strlen ( $ str ) ; $ i ++ ) echo $ str [ $ i ] ; } $ str = \" geeksforgeeks \" ; $ x = 3 ; reverse ( $ str , $ x ) ; ? >"}
{"text":"Minimize the number of replacements to get a string with same number of ' a ' , ' b ' and ' c ' in it | Function to count numbers ; Count the number of ' a ' , ' b ' and ' c ' in string ; If equal previously ; If not a multiple of 3 ; Increase the number of a ' s \u2581 by \u2581 \u2581 \u2581 removing \u2581 extra \u2581 ' b ' and ;c;  ; Check if it is ' b ' and it is more than n \/ 3 ; Check if it is ' c ' and it more than n \/ 3 ; Increase the number of b ' s \u2581 by \u2581 \u2581 \u2581 removing \u2581 extra \u2581 ' c '  ; Check if it is ' c ' and it more than n \/ 3 ; Increase the number of c 's from back  ; Check if it is ' a ' and it is more than n \/ 3 ; Increase the number of b 's from back  ; Check if it is ' a ' and it is more than n \/ 3 ; Increase the number of c 's from back  ; Check if it is ' b ' and it more than n \/ 3 ; Driver Code","code":"< ? php function lexoSmallest ( $ s , $ n ) { $ ca = 0 ; $ cb = 0 ; $ cc = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ ca ++ ; else if ( $ s [ $ i ] == ' b ' ) $ cb ++ ; else $ cc ++ ; } if ( $ ca == $ cb && $ cb == $ cc ) { return $ s ; } $ cnt = floor ( $ n \/ 3 ) ; if ( $ cnt * 3 != $ n ) { return \" - 1\" ; } $ i = 0 ; while ( $ ca < $ cnt && $ i < $ n ) { if ( $ s [ $ i ] == ' b ' && $ cb > $ cnt ) { $ cb -- ; $ s [ $ i ] = ' a ' ; $ ca ++ ; } else if ( $ s [ $ i ] == ' c ' && $ cc > $ cnt ) { $ cc -- ; $ s [ $ i ] = ' a ' ; $ ca ++ ; } $ i ++ ; } $ i = 0 ; while ( $ cb < $ cnt && $ i < $ n ) { if ( $ s [ $ i ] == ' c ' && $ cc > $ cnt ) { $ cc -- ; $ s [ $ i ] = '1' ; $ cb ++ ; } $ i ++ ; } $ i = $ n - 1 ; while ( $ cc < $ cnt && $ i >= 0 ) { if ( $ s [ $ i ] == ' a ' && $ ca > $ cnt ) { $ ca -- ; $ s [ $ i ] = ' c ' ; $ cc ++ ; } $ i -- ; } $ i = $ n - 1 ; while ( $ cb < $ cnt && $ i >= 0 ) { if ( $ s [ $ i ] == ' a ' && $ ca > $ cnt ) { $ ca -- ; $ s [ $ i ] = ' b ' ; $ cb ++ ; } $ i -- ; } $ i = $ n - 1 ; while ( $ cc < $ cnt && $ i >= 0 ) { if ( $ s [ $ i ] == ' b ' && $ cb > $ cnt ) { $ cb -- ; $ s [ $ i ] = ' c ' ; $ cc ++ ; } $ i -- ; } return $ s ; } $ s = \" aaaaaa \" ; $ n = strlen ( $ s ) ; echo lexoSmallest ( $ s , $ n ) ; ? >"}
{"text":"Minimum moves to reach from i to j in a cyclic string | Function to return the count of steps required to move from i to j ; Starting from i + 1 ; Count of steps ; Current character ; If current character is different from previous ; Increment steps ; Update current character ; Return total steps ; Function to return the minimum number of steps required to reach j from i ; Swap the values so that i <= j ; Steps to go from i to j ( left to right ) ; While going from i to j ( right to left ) First go from i to 0 then from ( n - 1 ) to j ; If first and last character is different then it 'll add a step to stepsToLeft  ; Return the minimum of two paths ; Driver code","code":"< ? php function getSteps ( $ str , $ i , $ j , $ n ) { $ k = $ i + 1 ; $ steps = 0 ; $ ch = $ str [ $ i ] ; while ( $ k <= $ j ) { if ( $ str [ $ k ] != $ ch ) { $ steps ++ ; $ ch = $ str [ $ k ] ; } $ k ++ ; } return $ steps ; } function getMinSteps ( $ str , $ i , $ j , $ n ) { if ( $ j < $ i ) { $ temp = $ i ; $ i = $ j ; $ j = $ temp ; } $ stepsToRight = getSteps ( $ str , $ i , $ j , $ n ) ; $ stepsToLeft = getSteps ( $ str , 0 , $ i , $ n ) + getSteps ( $ str , $ j , $ n - 1 , $ n ) ; if ( $ str [ 0 ] != $ str [ $ n - 1 ] ) $ stepsToLeft ++ ; return min ( $ stepsToLeft , $ stepsToRight ) ; } $ str = \" SSNSS \" ; $ n = strlen ( $ str ) ; $ i = 0 ; $ j = 3 ; echo getMinSteps ( $ str , $ i , $ j , $ n ) ; ? >"}
{"text":"Remove consecutive alphabets which are in same case | Function to return the modified string ; Traverse through the remaining characters in the string ; If the current and the previous characters are not in the same case then take the character ; Driver code","code":"< ? php function removeChars ( $ s ) { $ modifiedStr = \" \" ; $ modifiedStr = $ modifiedStr . $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ctype_upper ( $ s [ $ i ] ) && ctype_lower ( $ s [ $ i - 1 ] ) || ctype_lower ( $ s [ $ i ] ) && ctype_upper ( $ s [ $ i - 1 ] ) ) $ modifiedStr = $ modifiedStr . $ s [ $ i ] ; } return $ modifiedStr ; } $ s = \" GeeksForGeeks \" ; echo removeChars ( $ s ) ; ? >"}
{"text":"Cost to make a string Panagram | Function to return the total cost required to make the string Pangram ; Mark all the alphabets that occurred in the string ; Calculate the total cost for the missing alphabets ; Driver Code","code":"< ? php function pangramCost ( $ arr , $ str ) { $ cost = 0 ; $ occurred = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ occurred [ $ i ] = false ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ idx = ord ( $ str [ $ i ] ) - 97 ; $ occurred [ $ idx ] = true ; } for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ occurred [ $ i ] == false ) $ cost += $ arr [ $ i ] ; } return $ cost ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 ) ; $ str = \" abcdefghijklmopqrstuvwz \" ; echo pangramCost ( $ arr , $ str ) ; ? >"}
{"text":"Recursive program to insert a star between pair of identical characters | Function to insert * at desired position ; Append current character ; If we reached last character ; If next character is same , append ' * ' ; Driver code","code":"< ? php function pairStar ( & $ input , & $ output , $ i = 0 ) { $ output = $ output . $ input [ $ i ] ; if ( $ i == strlen ( $ input ) - 1 ) return ; if ( $ input [ $ i ] == $ input [ $ i + 1 ] ) $ output = $ output . ' * ' ; pairStar ( $ input , $ output , $ i +1 ) ; } $ input = \" geeks \" ; $ output = \" \" ; pairStar ( $ input , $ output ) ; echo $ output ; return 0 ; ? >"}
{"text":"Maximum number of removals of given subsequence from a string | Function to return max possible operation of the given type that can be performed on str ; Increment count of sub - sequence ' g ' ; Increment count of sub - sequence ' gk ' if ' g ' is available ; Increment count of sub - sequence ' gks ' if sub - sequence ' gk ' appeared previously ; Return the count of sub - sequence ' gks ' ; Driver code","code":"< ? php function maxOperations ( $ str ) { $ i = $ g = $ gk = $ gks = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == ' g ' ) { $ g ++ ; } else if ( $ str [ $ i ] == ' k ' ) { if ( $ g > 0 ) { $ g -- ; $ gk ++ ; } } else if ( $ str [ $ i ] == ' s ' ) { if ( $ gk > 0 ) { $ gk -- ; $ gks ++ ; } } } return $ gks ; } $ a = \" ggkssk \" ; echo maxOperations ( $ a ) ; ? >"}
{"text":"Final string after performing given operations | Function to return the modified string ; Count number of ' x ' ; Count number of ' y ' ; min ( x , y ) number of ' x ' and ' y ' will be deleted ; Driver Code","code":"< ? php function printFinalString ( $ s ) { $ n = strlen ( $ s ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' x ' ) $ x ++ ; else $ y ++ ; } $ finalString = ( string ) null ; if ( $ x > $ y ) for ( $ i = 0 ; $ i < $ x - $ y ; $ i ++ ) $ finalString . = \" x \" ; else for ( $ i = 0 ; $ i < $ y - $ x ; $ i ++ ) $ finalString . = \" y \" ; return $ finalString ; } $ s = \" xxyyxyy \" ; echo printFinalString ( $ s ) ; ? >"}
{"text":"String which when repeated exactly K times gives a permutation of S | Function to return a string which when repeated exactly k times gives a permutation of s ; size of string ; to frequency of each character ; get frequency of each character ; to store final answer ; check if frequency is divisible by k ; add to answer ; if frequency is not divisible by k ; Driver code ; function call","code":"< ? php function K_String ( $ s , $ k ) { $ n = strlen ( $ s ) ; $ fre = $ array = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ fre [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ str = \" \" ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ fre [ $ i ] % $ k == 0 ) { $ x = $ fre [ $ i ] \/ $ k ; while ( $ x -- ) { $ str . = chr ( $ i + ord ( ' a ' ) ) ; } } else { return \" - 1\" ; } } return $ str ; } $ s = \" aabb \" ; $ k = 2 ; echo K_String ( $ s , $ k ) ; ? >"}
{"text":"Count and Print the alphabets having ASCII value not in the range [ l , r ] | Function to count the number of characters whose ascii value not in range [ l , r ] ; Initializing the count to 0 ; using map to print a character only once ; Increment the count if the value is less ; return the count ; Driver code","code":"< ? php function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ m = array_fill ( 0 , 256 , NULL ) ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( ! ( $ l <= ord ( $ str [ $ i ] ) and ord ( $ str [ $ i ] ) <= $ r ) ) { $ cnt ++ ; if ( isset ( $ m [ ord ( $ str [ $ i ] ) ] ) != 1 ) { echo $ str [ $ i ] . \" \" ; $ m [ ord ( $ str [ $ i ] ) ] ++ ; } } } return $ cnt ; } $ str = \" geeksforgeeks \" ; $ l = 102 ; $ r = 111 ; echo \" Characters \u2581 with \u2581 ASCII \u2581 values \u2581 not \u2581 in \u2581 the \u2581 \" . \" in the given string are : \" echo \" and their count is \" . CountCharacters ( $ str , $ l , $ r ) ; ? >"}
{"text":"Count the number of words having sum of ASCII values less than and greater than k | Function to count the words ; Sum of ascii values ; Number of words having sum of ascii less than k ; If character is a space ; Add the ascii value to sum ; Handling the Last word separately ; Driver code","code":"< ? php function CountWords ( $ str , $ k ) { $ sum = 0 ; $ NumberOfWords = 0 ; $ counter = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) { if ( $ str [ $ i ] == ' \u2581 ' ) { if ( $ sum < $ k ) $ counter ++ ; $ sum = 0 ; $ NumberOfWords ++ ; } else $ sum += ord ( $ str [ $ i ] ) ; } $ NumberOfWords ++ ; if ( $ sum < $ k ) $ counter ++ ; echo \" Number \u2581 of \u2581 words \u2581 having \u2581 sum \u2581 of \u2581 ASCII \" . \" values less than k = \" \u2581 . \u2581 $ counter \u2581 . \u2581 \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" Number of words having sum of ASCII \" \u2581 . STRNEWLINE TABSYMBOL TABSYMBOL \" values greater than or equal to k = \" ( $ NumberOfWords - $ counter ) ; } $ str = \" Learn \u2581 how \u2581 to \u2581 code \" ; $ k = 400 ; CountWords ( $ str , $ k ) ; ? >"}
{"text":"Find the count of palindromic sub | PHP program to find the count of palindromic sub - string of a string in it 's ascending form ; function to return count of palindromic sub - string ; calculate frequency ; calculate count of palindromic sub - string ; return result ; Driver Code","code":"< ? php $ MAX_CHAR = 26 ; function countPalindrome ( $ str ) { global $ MAX_CHAR ; $ n = strlen ( $ str ) ; $ sum = 0 ; $ hashTable = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hashTable [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ hashTable [ $ i ] ) $ sum += ( int ) ( $ hashTable [ $ i ] * ( $ hashTable [ $ i ] + 1 ) \/ 2 ) ; } return $ sum ; } $ str = \" ananananddd \" ; echo countPalindrome ( $ str ) ; ? >"}
{"text":"Minimum number of elements to be removed so that pairwise consecutive elements are same | Function to count the minimum number of elements to remove from a number so that pairwise two consecutive digits are same . ; initialize counting variable ; check if two consecutive digits are same ; Driver code","code":"< ? php function countConsecutive ( $ s ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ i ++ ; else $ count ++ ; } return $ count ; } $ str = \"44522255\" ; echo countConsecutive ( $ str ) ; ? >"}
{"text":"Smallest odd digits number not less than N | function to check if all digits are odd of a given number ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the smallest number with all digits odd ; iterate till we find a number with all digits odd ; Driver Code","code":"< ? php function check_digits ( $ n ) { while ( $ n > 1 ) { if ( ( $ n % 10 ) % 2 == 0 ) return 0 ; $ n = ( int ) $ n \/ 10 ; } return 1 ; } function smallest_number ( $ n ) { for ( $ i = $ n ; ; $ i ++ ) if ( check_digits ( $ i ) ) return $ i ; } $ N = 2397 ; echo smallest_number ( $ N ) ; ? >"}
{"text":"Count and Print the alphabets having ASCII value in the range [ l , r ] | Function to count the number of characters whose ascii value is in range [ l , r ] ; Initializing the count to 0 ; Increment the count if the value is less ; return the count ; Driver code","code":"< ? php function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ l <= ord ( $ str [ $ i ] ) && ord ( $ str [ $ i ] ) <= $ r ) { $ cnt ++ ; echo $ str [ $ i ] . \" \" ; } } return $ cnt ; } $ str = \" geeksforgeeks \" ; $ l = 102 ; $ r = 111 ; echo \" Characters \u2581 with \u2581 ASCII \u2581 values \" . \" \u2581 in \u2581 the \u2581 range \u2581 [ l , \u2581 r ] \u2581 are \u2581 STRNEWLINE \" ; echo \" and their count is \" . CountCharacters ( $ str , $ l , $ r ) ; ? >"}
{"text":"Minimum steps to remove substring 010 from a binary string | Function to find the minimum steps ; substring \"010\" found ; Get the binary string ; Find the minimum steps","code":"< ? php function minSteps ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) - 2 ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) { if ( $ str [ $ i + 1 ] == '1' ) { if ( $ str [ $ i + 2 ] == '0' ) { $ count ++ ; $ i += 2 ; } } } } return $ count ; } $ str = \"0101010\" ; echo ( minSteps ( $ str ) ) ; ? >"}
{"text":"Count of alphabets having ASCII value less than and greater than k | Function to count the number of characters whose ascii value is less than k ; Initialising the count to 0 ; Incrementing the count if the value is less ; return the count ; Driver code","code":"< ? php function CountCharacters ( $ str , $ k ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] < chr ( $ k ) ) $ cnt += 1 ; } return $ cnt ; } $ str = \" GeeksForGeeks \" ; $ k = 90 ; $ count = CountCharacters ( $ str , $ k ) ; echo ( \" Characters \u2581 with \u2581 ASCII \u2581 values \" . \" \u2581 less \u2581 than \u2581 K \u2581 are \u2581 \" . $ count ) ; echo ( \" Characters with ASCII values \" \u2581 . STRNEWLINE TABSYMBOL \" greater than or equal to K are \" ( strlen ( $ str ) - $ count ) ) ; ? >"}
{"text":"Arrangement of the characters of a word such that all vowels are at odd places | Function to return the factorial of a number ; calculating nPr ; Function to find the number of $ways in which the characters of the word can be arranged such that the vowels occupy only the odd positions ; Get total even positions ; Get total odd positions ; Store $frequency of each character of the string ; Count total number of vowels ; Count total number of consonants ; Calculate the total number of ways ; Driver code","code":"< ? php function fact ( $ n ) { $ f = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ f = $ f * $ i ; } return $ f ; } function npr ( $ n , $ r ) { return fact ( $ n ) \/ fact ( $ n - $ r ) ; } function countPermutations ( $ str ) { $ even = floor ( strlen ( $ str ) \/ 2 ) ; $ odd = strlen ( $ str ) - $ even ; $ ways = 0 ; $ freq = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { ++ $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; } $ nvowels = $ freq [ 0 ] + $ freq [ 4 ] + $ freq [ 8 ] + $ freq [ 14 ] + $ freq [ 20 ] ; $ nconsonants = strlen ( $ str ) - $ nvowels ; $ ways = npr ( $ odd , $ nvowels ) * npr ( $ nconsonants , $ nconsonants ) ; return $ ways ; } $ str = \" geeks \" ; echo countPermutations ( $ str ) ; ? >"}
{"text":"Replace consonants with next immediate consonants alphabetically in a String | Function to check if a character is vowel or not ; Function that replaces consonant with next immediate consonant alphabatically ; Start traversing the string ; if character is z , than replace it with character b ; if the alphabet is not z ; replace the element with next immediate alphabet ; if next immediate alphabet is vowel , than take next 2 nd immediate alphabet ( since no two vowels occurs consecutively in alphabets ) hence no further checking is required ; Driver code","code":"< ? php function isVowel ( $ ch ) { if ( $ ch != ' a ' && $ ch != ' e ' && $ ch != ' i ' && $ ch != ' o ' && $ ch != ' u ' ) return false ; return true ; } function replaceConsonants ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ! isVowel ( $ s [ $ i ] ) ) { if ( $ s [ $ i ] == ' z ' ) $ s [ $ i ] = ' b ' ; else { $ s [ $ i ] = chr ( ord ( $ s [ $ i ] ) + 1 ) ; if ( isVowel ( $ s [ $ i ] ) ) $ s [ $ i ] = chr ( ord ( $ s [ $ i ] ) + 1 ) ; } } } return $ s ; } $ s = \" geeksforgeeks \" ; echo replaceConsonants ( $ s ) ; ? >"}
{"text":"Count changes in Led Lights to display digits one by one | PHP program to count number of on offs to display digits of a number . ; store the led lights required to display a particular number . ; compute the change in led and keep on adding the change ; Driver code","code":"< ? php function countOnOff ( $ n ) { $ Led = array ( 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 ) ; $ len = strlen ( $ n ) ; $ sum = $ Led [ $ n [ 0 ] - '0' ] ; for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { $ sum = $ sum + abs ( $ Led [ $ n [ $ i ] - '0' ] - $ Led [ $ n [ $ i - 1 ] - '0' ] ) ; } return $ sum ; } $ n = \"082\" ; echo countOnOff ( $ n ) ; ? >"}
{"text":"Maximum Consecutive Zeroes in Concatenated Binary String | returns the maximum size of a substring consisting only of zeroes after k concatenation ; stores the maximum length of the required substring ; if the current character is 0 ; stores maximum length of current substrings with zeroes ; if the whole $is filled with zero ; computes the length of the maximal prefix which contains only zeroes ; computes the length of the maximal suffix which contains only zeroes ; if more than 1 concatenations are to be made ; Driver code","code":"< ? php function max_length_substring ( $ st , $ n , $ k ) { $ max_len = 0 ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ st [ $ i ] == '0' ) $ len ++ ; else $ len = 0 ; $ max_len = max ( $ max_len , $ len ) ; } if ( $ max_len == $ n ) return $ n * $ k ; $ pref = 0 ; $ suff = 0 ; for ( $ i = 0 ; $ st [ $ i ] == '0' ; ++ $ i , ++ $ pref ) ; for ( $ i = $ n - 1 ; $ st [ $ i ] == '0' ; -- $ i , ++ $ suff ) ; if ( $ k > 1 ) $ max_len = max ( $ max_len , $ pref + $ suff ) ; return $ max_len ; } $ n = 6 ; $ k = 3 ; $ st = \"110010\" ; $ ans = max_length_substring ( $ st , $ n , $ k ) ; echo $ ans ; ? >"}
{"text":"Count number of substrings with numeric value greater than X | Function that counts valid sub - strings ; Only take those numbers that do not start w$ith '0' . ; converting the sub - str$ing starting from index ' i ' and having length ' len ' to int and checking if it is greater than X or not ; Driver code","code":"< ? php function countSubStr ( $ S , $ X ) { $ cnt = 0 ; $ N = strlen ( $ S ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ S [ $ i ] != '0' ) { for ( $ len = 1 ; ( $ i + $ len ) <= $ N ; ++ $ len ) { $ num = intval ( substr ( $ S , $ i , $ len ) ) ; if ( $ num > $ X ) $ cnt ++ ; } } } return $ cnt ; } $ S = \"2222\" ; $ X = 97 ; echo countSubStr ( $ S , $ X ) ; ? >"}
{"text":"Check whether a binary string can be formed by concatenating given N numbers sequentially | Function that returns false if the number passed as argument contains digit ( s ) other than '0' or '1' ; Function that checks whether the binary string can be formed or not ; Empty string for storing the binary number ; check if a [ i ] can be a part of the binary string ; Conversion of int into string ; if a [ i ] can 't be a part  then break the loop ; possible to create binary string ; impossible to create binary string ; Driver code","code":"< ? php function isBinary ( $ n ) { while ( $ n != 0 ) { $ temp = $ n % 10 ; if ( $ temp != 0 && $ temp != 1 ) { return false ; } $ n = intval ( $ n \/ 10 ) ; } return true ; } function formBinaryStr ( $ n , & $ a ) { $ flag = true ; $ s = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isBinary ( $ a [ $ i ] ) ) $ s = $ s . strval ( $ a [ $ i ] ) ; else { $ flag = false ; break ; } } if ( $ flag ) echo $ s . \" STRNEWLINE \" ; else echo \" - 1 STRNEWLINE \" ; } $ a = array ( 10 , 1 , 0 , 11 , 10 ) ; $ N = sizeof ( $ a ) \/ sizeof ( $ a [ 0 ] ) ; formBinaryStr ( $ N , $ a ) ; ? >"}
{"text":"Check if all the palindromic sub | Function to check if the string is palindrome ; Function that checks whether all the palindromic sub - strings are of odd length . ; Creating each substring ; If the sub - string is of even length and is a palindrome then , we return False ; Driver code","code":"< ? php function checkPalindrome ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ strlen ( $ s ) - $ i - 1 ] ) return false ; } return true ; } function CheckOdd ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = \" \" ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ x = $ x . $ s [ $ i ] ; if ( strlen ( $ x ) % 2 == 0 && checkPalindrome ( $ x ) == true ) return false ; } } return true ; } $ s = \" geeksforgeeks \" ; if ( CheckOdd ( $ s ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Number of permutations of a string in which all the occurrences of a given character occurs together | Function to return factorial of the number passed as argument ; Function to get the total permutations which satisfy the given condition ; Create has to store count of each character ; Store character occurrences ; Count number of times Particular character comes ; If particular character isn 't  present in the string then return 0 ; Remove count of particular character ; Total length of the string ; Assume all occurrences of particular character as a single character . ; Compute factorial of the length ; Divide by the factorials of the no . of occurrences of all the characters . ; return the result ; Driver Code ; Assuming the string and the character are all in uppercase","code":"< ? php function fact ( $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result *= $ i ; return $ result ; } function getResult ( $ str , $ ch ) { $ has = array_fill ( 0 , 26 , NULL ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ has [ ord ( $ str [ $ i ] ) - ord ( ' A ' ) ] ++ ; $ particular = $ has [ ord ( $ ch ) - ord ( ' A ' ) ] ; if ( $ particular == 0 ) return 0 ; $ has [ ord ( $ ch ) - ord ( ' A ' ) ] = 0 ; $ total = strlen ( $ str ) ; $ total = $ total - $ particular + 1 ; $ result = fact ( $ total ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ has [ $ i ] > 1 ) { $ result = $ result \/ fact ( $ has [ $ i ] ) ; } } return $ result ; } $ str = \" MISSISSIPPI \" ; echo getResult ( $ str , ' S ' ) . \" STRNEWLINE \" ; ? >"}
{"text":"Arrangement of words without changing the relative position of vowel and consonants | this function return n ! ; this will return total number of ways ; freq maintains frequency of each character in word ; check character is vowel or not ; the characters that are not vowel must be consonant ; number of ways to arrange vowel ; multiply both as these are independent ; string contains only capital letters ; this will contain ans","code":"< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function count1 ( $ word ) { $ freq = array_fill ( 0 , 27 , 0 ) ; for ( $ i = 0 ; $ i < 27 ; $ i ++ ) $ freq [ $ i ] = 0 ; $ vowel = 0 ; $ consonant = 0 ; for ( $ i = 0 ; $ i < strlen ( $ word ) ; $ i ++ ) { $ freq [ ord ( $ word [ $ i ] ) - 65 ] ++ ; if ( $ word [ $ i ] == ' A ' $ word [ $ i ] == ' E ' $ word [ $ i ] == ' I ' $ word [ $ i ] == ' O ' $ word [ $ i ] == ' U ' ) { $ vowel ++ ; } else $ consonant ++ ; } $ vowelArrange = factorial ( $ vowel ) ; $ vowelArrange \/= factorial ( $ freq [ 0 ] ) ; $ vowelArrange \/= factorial ( $ freq [ 4 ] ) ; $ vowelArrange \/= factorial ( $ freq [ 8 ] ) ; $ vowelArrange \/= factorial ( $ freq [ 14 ] ) ; $ vowelArrange \/= factorial ( $ freq [ 20 ] ) ; $ consonantArrange = factorial ( $ consonant ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i != 0 && $ i != 4 && $ i != 8 && $ i != 14 && $ i != 20 ) $ consonantArrange \/= factorial ( $ freq [ $ i ] ) ; } $ total = $ vowelArrange * $ consonantArrange ; return $ total ; } $ word = \" COMPUTER \" ; $ ans = count1 ( $ word ) ; echo ( $ ans ) ; ? >"}
{"text":"Program to find the product of ASCII values of characters in a string | Function to find product of ASCII value of characters in string ; Traverse string to find the product ; Return the product ; Driver code","code":"< ? php function productAscii ( $ str ) { $ prod = 1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ prod *= ord ( $ str [ $ i ] ) ; } return $ prod ; } $ str = \" GfG \" ; echo productAscii ( $ str ) ; ? >"}
{"text":"Balance a string after removing extra brackets | Print balanced and remove extra brackets from string ; Maintain a count for opening brackets Traversing string ; check if opening bracket ; print str [ i ] and increment count by 1 ; check if closing bracket and count != 0 ; decrement count by 1 ; if str [ i ] not a closing brackets print it ; balanced brackets if opening brackets are more then closing brackets ; print remaining closing brackets ; Driver code","code":"< ? php function balancedString ( $ str ) { $ count = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) { echo $ str [ $ i ] ; $ count ++ ; } else if ( $ str [ $ i ] == ' ) ' && $ count != 0 ) { echo $ str [ $ i ] ; $ count -- ; } else if ( $ str [ $ i ] != ' ) ' ) echo $ str [ $ i ] ; } if ( $ count != 0 ) for ( $ i = 0 ; $ i < $ count ; $ i ++ ) echo \" ) \" ; } $ str = \" gau ) ra ) v ( ku ( mar ( rajput ) ) \" ; balancedString ( $ str ) ; ? >"}
{"text":"Count strings with consonants and vowels at alternate position | Function to find the count of strings ; Variable to store the final result ; Loop iterating through string ; If ' $ ' is present at the even position in the string ; ' sum ' is multiplied by 21 ; If ' $ ' is present at the odd position in the string ; ' sum ' is multiplied by 5 ; Let the string ' str ' be s$$e$ ; Print result","code":"< ? php function countStrings ( $ s ) { $ sum = 1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == ' $ ' ) $ sum *= 21 ; else if ( $ s [ $ i ] == ' $ ' ) $ sum *= 5 ; } return $ sum ; } $ str = \" s\\ $ \\ $ e\\ $ \" ; echo countStrings ( $ str ) ; ? >"}
{"text":"Remove duplicates from a string in O ( 1 ) extra space | Function to remove duplicates ; keeps track of visited characters ; gets character value ; keeps track of length of resultant string ; check if Xth bit of counter is unset ; mark current character as visited ; Driver code","code":"< ? php function removeDuplicatesFromString ( $ str ) { $ counter = 0 ; $ i = 0 ; $ size = strlen ( $ str ) ; $ x = 0 ; $ length = 0 ; while ( $ i < $ size ) { $ x = ord ( $ str [ $ i ] ) - 97 ; if ( ( $ counter & ( 1 << $ x ) ) == 0 ) { $ str [ $ length ] = chr ( 97 + $ x ) ; $ counter = $ counter | ( 1 << $ x ) ; $ length ++ ; } $ i ++ ; } return substr ( $ str , 0 , $ length ) ; } $ str = \" geeksforgeeks \" ; echo removeDuplicatesFromString ( $ str ) ; ? >"}
{"text":"Check if the characters in a string form a Palindrome in O ( 1 ) extra space | Utility function to get the position of first character in the string ; Get the position of first character in the string ; Utility function to get the position of last character in the string ; Get the position of last character in the string ; Function to check if the characters in the given string forms a Palindrome in O ( 1 ) extra space ; break , when all letters are checked ; if mismatch found , break the loop ; Driver code","code":"< ? php function firstPos ( $ str , $ start , $ end ) { $ firstChar = -1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { if ( $ str [ $ i ] >= ' a ' and $ str [ $ i ] <= ' z ' ) { $ firstChar = $ i ; break ; } } return $ firstChar ; } function lastPos ( $ str , $ start , $ end ) { $ lastChar = -1 ; for ( $ i = $ start ; $ i >= $ end ; $ i -- ) { if ( $ str [ $ i ] >= ' a ' and $ str [ $ i ] <= ' z ' ) { $ lastChar = $ i ; break ; } } return $ lastChar ; } function isPalindrome ( $ str ) { $ firstChar = 0 ; $ lastChar = count ( $ str ) - 1 ; $ ch = true ; for ( $ i = 0 ; $ i < count ( $ str ) ; $ i ++ ) { $ firstChar = firstPos ( $ str , $ firstChar , $ lastChar ) ; $ lastChar = lastPos ( $ str , $ lastChar , $ firstChar ) ; if ( $ lastChar < 0 or $ firstChar < 0 ) break ; if ( $ str [ $ firstChar ] == $ str [ $ lastChar ] ) { $ firstChar ++ ; $ lastChar -- ; continue ; } $ ch = false ; break ; } return ( $ ch ) ; } $ str = \" m \u2581 a \u2581 343 \u2581 la \u2581 y \u2581 a \u2581 l \u2581 am \" ; if ( isPalindrome ( $ str ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Maximum power of jump required to reach the end of string | Function to calculate the maximum power of the jump ; Initialize the count with 1 ; Find the character at last index ; Start traversing the string ; Check if the current char is equal to the last character ; max_so_far stores maximum value of the power of the jump from starting to ith position ; Reset the count to 1 ; Else , increment the number of jumps \/ count ; Return the maximum number of jumps ; Driver code","code":"< ? php function powerOfJump ( $ s ) { $ count = 1 ; $ max_so_far = PHP_INT_MIN ; $ ch = $ s [ strlen ( $ s ) - 1 ] ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) { if ( $ count > $ max_so_far ) { $ max_so_far = $ count ; } $ count = 1 ; } else $ count ++ ; } return $ max_so_far ; } $ st = \"1010101\" ; echo powerOfJump ( $ st ) ; ? >"}
{"text":"Average of ASCII values of characters of a given string | Function to find average of ASCII value of chars ; loop to sum the ascii value of chars ; Returning average of chars ; Driver code","code":"< ? php function averageValue ( $ s ) { $ sum_char = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ sum_char += ord ( $ s [ $ i ] ) ; } return ( int ) ( $ sum_char \/ strlen ( $ s ) ) ; } $ s = \" GeeksforGeeks \" ; echo averageValue ( $ s ) ; ? >"}
{"text":"Longest Common Prefix Matching | Set | A Utility Function to find the common prefix between first and last strings ; Compare str1 and str2 ; A Function that returns the longest common prefix from the array of strings ; sorts the N set of strings ; prints the common prefix of the first and the last string of the set of strings ; Driver Code","code":"< ? php function commonPrefixUtil ( $ str1 , $ str2 ) { $ result = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; for ( $ i = 0 , $ j = 0 ; $ i <= $ n1 - 1 && $ j <= $ n2 - 1 ; $ i ++ , $ j ++ ) { if ( $ str1 [ $ i ] != $ str2 [ $ j ] ) break ; $ result = $ result . $ str1 [ $ i ] ; } return ( $ result ) ; } function commonPrefix ( & $ arr , $ n ) { sort ( $ arr ) ; echo commonPrefixUtil ( $ arr [ 0 ] , $ arr [ $ n - 1 ] ) ; } $ arr = array ( \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" ) ; $ n = sizeof ( $ arr ) ; commonPrefix ( $ arr , $ n ) ; ? >"}
{"text":"Add n binary strings | This function adds two binary strings and return result as a third string ; Initialize result ; Initialize digit sum ; Traverse both strings starting from last characters ; Compute sum of last digits and carry ; If current digit sum is 1 or 3 , add 1 to result ; Compute carry ; Move to next digits ; function to add n binary strings ; Driver code","code":"< ? php function addBinaryUtil ( $ a , $ b ) { $ result = \" \" ; $ s = 0 ; $ i = strlen ( $ a ) - 1 ; $ j = strlen ( $ b ) - 1 ; while ( $ i >= 0 $ j >= 0 $ s == 1 ) { $ s += ( ( $ i >= 0 ) ? ord ( $ a [ $ i ] ) - ord ( '0' ) : 0 ) ; $ s += ( ( $ j >= 0 ) ? ord ( $ b [ $ j ] ) - ord ( '0' ) : 0 ) ; $ result = chr ( $ s % 2 + ord ( '0' ) ) . $ result ; $ s = ( int ) ( $ s \/ 2 ) ; $ i -- ; $ j -- ; } return $ result ; } function addBinary ( $ arr , $ n ) { $ result = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result = addBinaryUtil ( $ result , $ arr [ $ i ] ) ; return $ result ; } $ arr = array ( \"1\" , \"10\" , \"11\" ) ; $ n = count ( $ arr ) ; echo addBinary ( $ arr , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Prefixes with more a than b | Function to count prefixes ; calculating for string S ; count == 0 or when N == 1 ; when all characters are a or a - b == 0 ; checking for saturation of string after repetitive addition ; Driver Code","code":"< ? php function prefix ( $ k , $ n ) { $ a = 0 ; $ b = 0 ; $ count = 0 ; $ i = 0 ; $ len = strlen ( $ k ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ k [ $ i ] == ' a ' ) $ a ++ ; if ( $ k [ $ i ] == ' b ' ) $ b ++ ; if ( $ a > $ b ) { $ count ++ ; } } if ( $ count == 0 $ n == 1 ) { echo ( $ count ) ; return 0 ; } if ( $ count == $ len $ a - $ b == 0 ) { echo ( $ count * $ n ) ; return 0 ; } $ n2 = $ n - 1 ; $ count2 = 0 ; while ( $ n2 != 0 ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ k [ $ i ] == ' a ' ) $ a ++ ; if ( $ k [ $ i ] == ' b ' ) $ b ++ ; if ( $ a > $ b ) { $ count2 ++ ; } } $ count += $ count2 ; $ n2 -- ; if ( $ count2 == 0 ) break ; if ( $ count2 == $ len ) { $ count += ( $ n2 * $ count2 ) ; break ; } $ count2 = 0 ; } return $ count ; } $ S = \" aba \" ; $ N = 2 ; echo ( prefix ( $ S , $ N ) . \" \" ) ; $ S = \" baa \" ; $ N = 3 ; echo ( prefix ( $ S , $ N ) . \" \" ) ;"}
{"text":"Number of common base strings for two strings | function for finding common divisor . ; Checking if ' base ' is base string of ' s1' ; Checking if ' base ' is base string of ' s2' ; Driver code","code":"< ? php function isCommonBase ( $ base , $ s1 , $ s2 ) { for ( $ j = 0 ; $ j < strlen ( $ s1 ) ; ++ $ j ) if ( $ base [ $ j % strlen ( $ base ) ] != $ s1 [ $ j ] ) return false ; for ( $ j = 0 ; $ j < strlen ( $ s2 ) ; ++ $ j ) if ( $ base [ $ j % strlen ( $ base ) ] != $ s2 [ $ j ] ) return false ; return true ; } function countCommonBases ( $ s1 , $ s2 ) { $ n1 = strlen ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; $ count = 0 ; for ( $ i = 1 ; $ i <= min ( $ n1 , $ n2 ) ; $ i ++ ) { $ base = substr ( $ s1 , 0 , $ i ) ; if ( isCommonBase ( $ base , $ s1 , $ s2 ) ) $ count ++ ; } return $ count ; } $ s1 = \" pqrspqrs \" ; $ s2 = \" pqrspqrspqrspqrs \" ; echo countCommonBases ( $ s1 , $ s2 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Perfect Square String | PHP program to find if string is a perfect square or not . ; calculating the length of the string ; calculating the ASCII value of the string ; Find floating point value of square root of x . ; If square root is an integer ; Driver code","code":"< ? php function isPerfectSquareString ( $ str ) { $ sum = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ sum += ( int ) $ str [ $ i ] ; $ squareRoot = sqrt ( $ sum ) ; return ( ( $ squareRoot - floor ( $ squareRoot ) ) == 0 ) ; } $ str = \" d \" ; if ( isPerfectSquareString ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Remove consecutive vowels from string | function which returns True or False for occurrence of a vowel ; this compares vowel with character ' c ' ; function to print resultant string ; print 1 st character ; loop to check for each character ; comparison of consecutive characters ; Driver code","code":"< ? php function is_vow ( $ c ) { return ( $ c == ' a ' ) || ( $ c == ' e ' ) || ( $ c == ' i ' ) || ( $ c == ' o ' ) || ( $ c == ' u ' ) ; } function removeVowels ( $ str ) { printf ( $ str [ 0 ] ) ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ( ! is_vow ( $ str [ $ i - 1 ] ) ) || ( ! is_vow ( $ str [ $ i ] ) ) ) printf ( $ str [ $ i ] ) ; } $ str = \" \u2581 geeks \u2581 for \u2581 geeks \" ; removeVowels ( $ str ) ; ? >"}
{"text":"Transform a string such that it has abcd . . z as a subsequence | function to transform string with string passed as reference ; initializing the variable ch to ' a ' ; if the length of string is less than 26 , we can 't obtain the required  subsequence ; if ch has reached ' z ' , it means we have transformed our string such that required subsequence can be obtained ; current character is not greater than ch , then replace it with ch and increment ch ; Driver Code","code":"< ? php function transformString ( & $ s ) { $ ch = \" a \" ; if ( strlen ( $ s ) < 26 ) return false ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ ch ) > ord ( \" z \" ) ) break ; if ( $ s [ $ i ] <= $ ch ) { $ s [ $ i ] = $ ch ; $ ch = chr ( ord ( $ ch ) + 1 ) ; } } if ( $ ch <= \" z \" ) return false ; return true ; } $ str = \" aaaaaaaaaaaaaaaaaaaaaaaaaa \" ; if ( transformString ( $ str ) ) echo $ str ; else echo \" Not \u2581 Possible \" ; ? >"}
{"text":"Number of pairs with Pandigital Concatenation | Checks if a given $is Pandigital ; digit i is not present thus not pandigital ; Returns number of pairs of strings resulting in Pandigital Concatenations ; iterate over all pair of strings ; Driver code","code":"< ? php function isPanDigital ( $ s ) { $ digits = array ( ) ; $ digits = array_fill ( 0 , 10 , false ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) $ digits [ ord ( $ s [ $ i ] ) - ord ( '0' ) ] = true ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) if ( $ digits [ $ i ] == false ) return false ; return true ; } function countPandigitalPairs ( & $ v ) { $ pairs = 0 ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < count ( $ v ) ; $ j ++ ) { if ( isPanDigital ( $ v [ $ i ] . $ v [ $ j ] ) ) { $ pairs ++ ; } } } return $ pairs ; } $ v = array ( \"123567\" , \"098234\" , \"14765\" , \"19804\" ) ; echo ( countPandigitalPairs ( $ v ) ) ; ? >"}
{"text":"Minimum changes to a string to make all substrings distinct | Returns minimum changes to str so that no substring is repeated . ; If length is more than maximum allowed characters , we cannot get the required string . ; Variable to store count of distinct characters ; To store counts of different characters ; Answer is , n - number of distinct char ; Driver Code","code":"< ? php function minChanges ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n > 26 ) return -1 ; $ dist_count = 0 ; $ count = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ count [ ord ( $ str [ $ i ] ) - 97 ] == 0 ) $ dist_count ++ ; $ count [ ord ( $ str [ $ i ] ) - 97 ] ++ ; } return ( $ n - $ dist_count ) ; } $ str = \" aebaecedabbee \" ; echo minChanges ( $ str ) ; ? >"}
{"text":"Number of strings of length N with no palindromic sub string | Return the count of strings with no palindromic substring . ; Driver Code","code":"< ? php function numofstring ( $ n , $ m ) { if ( $ n == 1 ) return $ m ; if ( $ n == 2 ) return $ m * ( $ m - 1 ) ; return $ m * ( $ m - 1 ) * pow ( $ m - 2 , $ n - 2 ) ; } { $ n = 2 ; $ m = 3 ; echo numofstring ( $ n , $ m ) ; return 0 ; } ? >"}
{"text":"Count special palindromes in a String | Function to count special Palindromic susbstring ; store count of special Palindromic substring ; it will store the count of continues same char ; traverse string character from left to right ; store same character count ; count smiler character ; Case : 1 so total number of substring that we can generate are : K * ( K + 1 ) \/ 2 here K is sameCharCount ; store current same char count in sameChar [ ] array ; increment i ; Case 2 : Count all odd length Special Palindromic substring ; if current character is equal to previous one then we assign Previous same character count to current one ; case 2 : odd length ; subtract all single length substring ; Driver Code","code":"< ? php function CountSpecialPalindrome ( $ str ) { $ n = strlen ( $ str ) ; $ result = 0 ; $ sameChar = array_fill ( 0 , $ n , 0 ) ; $ i = 0 ; while ( $ i < $ n ) { $ sameCharCount = 1 ; $ j = $ i + 1 ; while ( $ j < $ n ) { if ( $ str [ $ i ] != $ str [ $ j ] ) break ; $ sameCharCount ++ ; $ j ++ ; } $ result += ( int ) ( $ sameCharCount * ( $ sameCharCount + 1 ) \/ 2 ) ; $ sameChar [ $ i ] = $ sameCharCount ; $ i = $ j ; } for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ str [ $ j ] == $ str [ $ j - 1 ] ) $ sameChar [ $ j ] = $ sameChar [ $ j - 1 ] ; if ( $ j > 0 && $ j < ( $ n - 1 ) && ( $ str [ $ j - 1 ] == $ str [ $ j + 1 ] && $ str [ $ j ] != $ str [ $ j - 1 ] ) ) $ result += $ sameChar [ $ j - 1 ] < $ sameChar [ $ j + 1 ] ? $ sameChar [ $ j - 1 ] : $ sameChar [ $ j + 1 ] ; } return $ result - $ n ; } $ str = \" abccba \" ; echo CountSpecialPalindrome ( $ str ) ; ? >"}
{"text":"Print Bracket Number | function to print the bracket number ; used to print the bracket number for the left bracket ; used to obtain the bracket number for the right bracket ; traverse the given expression ' exp ' ; if current character is a left bracket ; print ' left _ bnum ' , ; push ' left _ bum ' on to the stack ' right _ bnum ' ; increment ' left _ bnum ' by 1 ; else if current character is a right bracket ; print the top element of stack ' right _ bnum ' it will be the right bracket number ; pop the top element from the stack ; Driver Code","code":"< ? php function printBracketNumber ( $ exp , $ n ) { $ left_bnum = 1 ; $ right_bnum = array ( ) ; $ t = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ exp [ $ i ] == ' ( ' ) { echo $ left_bnum . \" \" ; $ right_bnum [ $ t ++ ] = $ left_bnum ; $ left_bnum ++ ; } else if ( $ exp [ $ i ] == ' ) ' ) { echo $ right_bnum [ $ t - 1 ] . \" \" ; $ right_bnum [ $ t - 1 ] = 1 ; $ t -- ; } } } $ exp = \" ( a + ( b * c ) ) + ( d \/ e ) \" ; $ n = strlen ( $ exp ) ; printBracketNumber ( $ exp , $ n ) ; ? >"}
{"text":"Find if a string starts and ends with another given string | PHP program to find if a given corner string is present at corners . ; If length of corner string is more , it cannot be present at corners . ; Return true if corner string is present at both corners of given string . ; Driver Code","code":"< ? php function isCornerPresent ( $ str , $ corner ) { $ n = strlen ( $ str ) ; $ cl = strlen ( $ corner ) ; if ( $ n < $ cl ) return false ; return ( ! strcmp ( substr ( $ str , 0 , $ cl ) , $ corner ) && ! strcmp ( substr ( $ str , $ n - $ cl , $ cl ) , $ corner ) ) ; } $ str = \" geeksforgeeks \" ; $ corner = \" geeks \" ; if ( isCornerPresent ( $ str , $ corner ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Converting one string to other using append and delete last operations | Returns true if it is possible to convert str1 to str2 using k operations . ; Case A ( i ) ; finding common length of both string ; Case A ( ii ) - ; Case B ; Driver Code","code":"< ? php function isConvertible ( $ str1 , $ str2 , $ k ) { if ( ( strlen ( $ str1 ) + strlen ( $ str2 ) ) < $ k ) return true ; $ commonLength = 0 ; for ( $ i = 0 ; $ i < min ( strlen ( $ str1 ) , strlen ( $ str2 ) ) ; $ i ++ ) { if ( $ str1 == $ str2 ) $ commonLength += 1 ; else break ; } if ( ( $ k - strlen ( $ str1 ) - strlen ( $ str2 ) + 2 * $ commonLength ) % 2 == 0 ) return true ; return false ; } $ str1 = \" geek \" ; $ str2 = \" geek \" ; $ k = 7 ; if ( isConvertible ( $ str1 , $ str2 , $ k ) ) echo \" Yes \" . \" STRNEWLINE \" ; else echo \" No \" . \" STRNEWLINE \" ; $ str1 = \" geeks \" ; $ str2 = \" geek \" ; $ k = 5 ; if ( isConvertible ( $ str1 , $ str2 , $ k ) ) echo \" Yes \" . \" STRNEWLINE \" ; else echo \" No \" . \" STRNEWLINE \" ; ? >"}
{"text":"Maximum distinct lowercase alphabets between two uppercase | PHP Program to find maximum lowercase alphabets present between two uppercase alphabets ; Function which computes the maximum number of distinct lowercase alphabets between two uppercase alphabets ; Ignoring lowercase characters in the beginning . ; We start from next of first capital letter and traverse through remaining character . ; If character is in uppercase , ; Count all distinct lower case characters ; Update maximum count ; Reset count array ; If character is in lowercase ; Driver Code","code":"< ? php $ MAX_CHAR = 26 ; function maxLower ( $ str ) { global $ MAX_CHAR ; $ n = strlen ( $ str ) ; $ i = 0 ; for ( ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) { $ i ++ ; break ; } } $ maxCount = 0 ; $ count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; for ( ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) { $ currCount = 0 ; for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) if ( $ count [ $ j ] > 0 ) $ currCount ++ ; $ maxCount = max ( $ maxCount , $ currCount ) ; $ count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; } if ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; } return $ maxCount ; } $ str = \" zACaAbbaazzC \" ; echo maxLower ( $ str ) ; ? >"}
{"text":"First uppercase letter in a string ( Iterative and Recursive ) | Function to find string which has first character of each word . ; Driver code","code":"< ? php function first ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ctype_upper ( $ str [ $ i ] ) ) { return $ str [ $ i ] ; } return 0 ; } $ str = \" geeksforGeeKS \" ; $ res = first ( $ str ) ; if ( ord ( $ res ) == ord ( 0 ) ) echo \" No \u2581 uppercase \u2581 letter \" ; else echo $ res . \" STRNEWLINE \" ; ? >"}
{"text":"Counting even decimal value substrings in a binary string | generate all substring in arr [ 0. . n - 1 ] ; store the count ; Pick starting point ; Pick ending point ; substring between current starting and ending points ; increment power of 2 by one ; Driver Code","code":"< ? php function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ decimalValue = 0 ; $ powerOf2 = 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { $ decimalValue += ( ( $ str [ $ k ] - '0' ) * $ powerOf2 ) ; $ powerOf2 *= 2 ; } if ( $ decimalValue % 2 == 0 ) $ result ++ ; } } return $ result ; } $ str = \"10010\" ; $ n = 5 ; echo evenDecimalValue ( $ str , $ n ) ; ? >"}
{"text":"Create a new string by alternately combining the characters of two halves of the string in reverse | Function performing calculations ; Calculating the two halves of string s as first and second . The final string p ; It joins the characters to final string in reverse order ; It joins the characters to final string in reverse order ; Driver code ; Calling function","code":"< ? php function solve ( $ s ) { $ l = strlen ( $ s ) ; $ x = $ l \/ 2 ; $ y = $ l ; $ p = \" \" ; while ( $ x > 0 && $ y > $ l \/ 2 ) { $ p = $ p . $ s [ $ x - 1 ] ; $ x -- ; $ p = $ p . $ s [ $ y - 1 ] ; $ y -- ; } if ( $ y > $ l \/ 2 ) { $ p = $ p . $ s [ $ y - 1 ] ; $ y -- ; } echo $ p ; } $ s = \" sunshine \" ; solve ( $ s ) ; ? >"}
{"text":"Program for length of a string using recursion | Function to calculate length ; if we reach at the end of the string ; Driver Code","code":"< ? php function recLen ( & $ str , $ i ) { if ( $ i == strlen ( $ str ) ) return 0 ; else return 1 + recLen ( $ str , $ i + 1 ) ; } $ str = \" GeeksforGeeks \" ; echo ( recLen ( $ str , 0 ) ) ; ? >"}
{"text":"Count consonants in a string ( Iterative and recursive methods ) | Function to check for consonant ; To handle lower case ; To check is character is Consonant ; Driver code","code":"< ? php function isConsonant ( $ ch ) { $ ch = strtoupper ( $ ch ) ; return ! ( $ ch == ' A ' $ ch == ' E ' $ ch == ' I ' $ ch == ' O ' $ ch == ' U ' ) && ord ( $ ch ) >= 65 && ord ( $ ch ) <= 90 ; } function totalConsonants ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( isConsonant ( $ str [ $ i ] ) ) ++ $ count ; return $ count ; } $ str = \" abc \u2581 de \" ; echo totalConsonants ( $ str ) ; return 0 ; ? >"}
{"text":"Check if actual binary representation of a number is palindrome | function to reverse bits of a number ; traversing bits of ' n ' from the right ; bitwise left shift ' rev ' by 1 ; if current bit is '1' ; bitwise right shift ' n ' by 1 ; required number ; function to check whether binary representation of a number is palindrome or not ; get the number by reversing bits in the binary representation of ' n ' ; Driver code","code":"< ? php function reverseBits ( $ n ) { $ rev = 0 ; while ( $ n > 0 ) { $ rev <<= 1 ; if ( $ n & 1 == 1 ) $ rev ^= 1 ; $ n >>= 1 ; } return $ rev ; } function isPalindrome ( $ n ) { $ rev = reverseBits ( $ n ) ; return ( $ n == $ rev ) ; } $ n = 9 ; if ( isPalindrome ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; ? >"}
{"text":"Find the arrangement of queue at given time | prints the arrangement at time = t ; Checking the entire queue for every moment from time = 1 to time = t . ; If current index contains ' B ' and next index contains ' G ' then swap ; Driver code","code":"< ? php function solve ( $ n , $ t , $ s ) { for ( $ i = 0 ; $ i < $ t ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) { if ( $ s [ $ j ] == ' B ' && $ s [ $ j + 1 ] == ' G ' ) { $ temp = $ s [ $ j ] ; $ s [ $ j ] = $ s [ $ j + 1 ] ; $ s [ $ j + 1 ] = $ temp ; $ j ++ ; } } } echo ( $ s ) ; } $ n = 6 ; $ t = 2 ; $ s = \" BBGBBG \" ; solve ( $ n , $ t , $ s ) ; ? >"}
{"text":"Add two numbers represented by two arrays | Return sum of two number represented by the arrays . Size of a [ ] is greater than b [ ] . It is made sure be the wrapper function ; array to store sum . ; Until we reach beginning of array . we are comparing only for second array because we have already compare the size of array in wrapper function . ; find sum of corresponding element of both array . ; Finding carry for next sum . ; If second array size is less than the first array size . ; Add carry to first array elements . ; If there is carry on adding 0 index elements . append 1 to total sum . ; Converting array into number . ; Wrapper Function ; Making first array which have greater number of element ; Driven Code","code":"< ? php function calSumUtil ( $ a , $ b , $ n , $ m ) { $ sum = array ( ) ; $ i = $ n - 1 ; $ j = $ m - 1 ; $ k = $ n - 1 ; $ carry = 0 ; $ s = 0 ; while ( $ j >= 0 ) { $ s = $ a [ $ i ] + $ b [ $ j ] + $ carry ; $ sum [ $ k ] = ( $ s % 10 ) ; $ carry = $ s \/ 10 ; $ k -- ; $ i -- ; $ j -- ; } while ( $ i >= 0 ) { $ s = $ a [ $ i ] + $ carry ; $ sum [ $ k ] = ( $ s % 10 ) ; $ carry = $ s \/ 10 ; $ i -- ; $ k -- ; } $ ans = 0 ; if ( $ carry ) $ ans = 10 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ ans += $ sum [ $ i ] ; $ ans *= 10 ; } return $ ans \/ 10 ; } function calSum ( $ a , $ b , $ n , $ m ) { if ( $ n >= $ m ) return calSumUtil ( $ a , $ b , $ n , $ m ) ; else return calSumUtil ( $ b , $ a , $ m , $ n ) ; } $ a = array ( 9 , 3 , 9 ) ; $ b = array ( 6 , 1 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; echo calSum ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text":"Longest Common Anagram Subsequence | PHP implementation to find the length of the longest common anagram subsequence ; function to find the length of the longest common anagram subsequence ; hash tables for storing frequencies of each character ; calculate frequency of each character of ' str1' ; calculate frequency of each character of ' str2' ; for each character add its minimum frequency out of the two strings in ' len ' ; required length ; Driver Code","code":"< ? php $ SIZE = 26 ; function longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) { global $ SIZE ; $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ len = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ len += min ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; } return $ len ; } $ str1 = \" abdacp \" ; $ str2 = \" ckamb \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; echo ( \" Length \u2581 = \u2581 \" . longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) ) ; ? >"}
{"text":"Panalphabetic window in a string | Return if given string contain panalphabetic window . ; traversing the string ; if character of string is equal to ch , increment ch . ; if all characters are found , return true . ; Driver Code","code":"< ? php function isPanalphabeticWindow ( $ s , $ n ) { $ ch = ' a ' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) $ ch ++ ; if ( $ ch == ' z ' ) return true ; } return false ; } $ s = \" abujm \u2581 zvcd \u2581 acefc \u2581 deghf \u2581 gijkle \" . \" \u2581 m \u2581 n \u2581 o \u2581 p \u2581 pafqrstuvwxyzfap \" ; $ n = strlen ( $ s ) ; if ( isPanalphabeticWindow ( $ s , $ n ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; ? >"}
{"text":"Program to print characters present at prime indexes in a given string | PHP Program to print Characters at Prime index in a given String ; Corner case ; Check from 2 to n - 1 ; Function to print character at prime index ; Loop to check if index prime or not ; Driver Code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; } function prime_index ( $ input ) { $ n = strlen ( $ input ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( isPrime ( $ i ) ) echo $ input [ $ i - 1 ] ; } $ input = \" GeeksforGeeks \" ; prime_index ( $ input ) ; ? >"}
{"text":"Check whether a given string is Heterogram or not | PHP Program to check whether the given string is Heterogram or not . ; traversing the string . ; ignore the space ; if already encountered ; else return false . ; Driven Code","code":"< ? php function isHeterogram ( $ s , $ n ) { $ hash = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ hash [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != ' \u2581 ' ) { if ( $ hash [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] == 0 ) $ hash [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] = 1 ; else return false ; } } return true ; } $ s = \" the \u2581 big \u2581 dwarf \u2581 only \u2581 jumps \" ; $ n = strlen ( $ s ) ; if ( isHeterogram ( $ s , $ n ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; ? >"}
{"text":"Print given sentence into its equivalent ASCII form | Function to compute the ASCII value of each character one by one ; Driver code","code":"< ? php function ASCIISentence ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) echo ord ( $ str [ $ i ] ) ; } $ str = \" GeeksforGeeks \" ; echo \" ASCII \u2581 Sentence : \" . \" STRNEWLINE \" ; ASCIISentence ( $ str ) ; ? >"}
{"text":"Snake case of a given sentence | Function to replace spaces and convert into snake case ; Converting space to underscor ; If not space , convert into lower character ; Driver Code ; Calling function","code":"< ? php function convert ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' \u2581 ' ) $ str [ $ i ] = ' _ ' ; else $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; } echo $ str ; } $ str = \" I \u2581 got \u2581 intern \u2581 at \u2581 geeksforgeeks \" ; convert ( $ str ) ; ? >"}
{"text":"Replace a character c1 with c2 and c2 with c1 in a string S | PHP program to replace c1 with c2 and c2 with c1 ; loop to traverse in the string ; check for c1 and replace ; check for c2 and replace ; Driver Code","code":"< ? php function replace ( $ s , $ c1 , $ c2 ) { $ l = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == $ c1 ) $ s [ $ i ] = $ c2 ; else if ( $ s [ $ i ] == $ c2 ) $ s [ $ i ] = $ c1 ; } return $ s ; } $ s = \" grrksfoegrrks \" ; $ c1 = ' e ' ; $ c2 = ' r ' ; echo replace ( $ s , $ c1 , $ c2 ) ; ? >"}
{"text":"Construct lexicographically smallest palindrome | function for printing palindrome ; iterate till i < j ; continue if str [ i ] == str [ j ] ; update str [ i ] = str [ j ] = ' a ' if both are ' * ' ; update str [ i ] = str [ j ] if only str [ i ] = ' * ' ; update str [ j ] = str [ i ] if only str [ j ] = ' * ' ; else print not possible and return ; Driver Code","code":"< ? php function constructPalin ( $ str , $ len ) { $ i = 0 ; $ j = $ len - 1 ; for ( ; $ i < $ j ; $ i ++ , $ j -- ) { if ( $ str [ $ i ] == $ str [ $ j ] && $ str [ $ i ] != ' * ' ) continue ; else if ( $ str [ $ i ] == $ str [ $ j ] && $ str [ $ i ] == ' * ' ) { $ str [ $ i ] = ' a ' ; $ str [ $ j ] = ' a ' ; continue ; } else if ( $ str [ $ i ] == ' * ' ) { $ str [ $ i ] = $ str [ $ j ] ; continue ; } else if ( $ str [ $ j ] == ' * ' ) { $ str [ $ j ] = $ str [ $ i ] ; continue ; } echo \" Not \u2581 Possible \" ; return \" \" ; } return $ str ; } $ str = \" bca * xc * * b \" ; $ len = strlen ( $ str ) ; echo constructPalin ( $ str , $ len ) ; ? >"}
{"text":"Printing string in plus \u2018 + \u2019 pattern in the matrix | Function to make a cross in the matrix ; As , it is not possible to make the cross exactly in the middle of the matrix with an even length string . ; declaring a 2D array i . e a matrix ; Now , we will fill all the elements of the array with ' X ' ; Now , we will place the characters of the string in the matrix , such that a cross is formed in it . ; here the characters of the string will be added in the middle column of our array . ; here the characters of the string will be added in the middle row of our array . ; Now finally , we will print the array ; Driver Code","code":"< ? php function carveCross ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n % 2 == 0 ) { echo ( \" Not \u2581 possible . \u2581 Please \u2581 enter \u2581 \" ) ; echo ( \" odd \u2581 length \u2581 string . STRNEWLINE \" ) ; } else { $ arr = array ( ) ; $ m = $ n \/ 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ arr [ $ i ] [ $ j ] = ' X ' ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] [ $ m ] = $ str [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ m ] [ $ i ] = $ str [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo ( $ arr [ $ i ] [ $ j ] . \" \" ) ; } echo ( \" STRNEWLINE \" ) ; } } } $ str = \" PICTURE \" ; carveCross ( $ str ) ; ? >"}
{"text":"Program to find remainder when large number is divided by 11 | Function to return remainder ; len is variable to store the length of number string . ; loop that find remainder ; Driver code","code":"< ? php function remainder ( $ str ) { $ len = strlen ( $ str ) ; $ num ; $ rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ num = $ rem * 10 + ( $ str [ $ i ] - '0' ) ; $ rem = $ num % 11 ; } return $ rem ; } $ str = \"3435346456547566345436457867978\" ; echo ( remainder ( $ str ) ) ; ? >"}
{"text":"Generate permutations with only adjacent swaps allowed | PHP program to generate permutations with only one swap allowed . ; don 't swap the current position ; Swap with the next character and revert the changes . As explained above , swapping with previous is is not needed as it anyways happens for next character . ; Driver code","code":"< ? php function findPermutations ( $ str , $ index , $ n ) { if ( $ index >= $ n || ( $ index + 1 ) >= $ n ) { echo $ str , \" STRNEWLINE \" ; return ; } findPermutations ( $ str , $ index + 1 , $ n ) ; list ( $ str [ $ index ] , $ str [ $ index + 1 ] ) = array ( $ str [ $ index + 1 ] , $ str [ $ index ] ) ; findPermutations ( $ str , $ index + 2 , $ n ) ; list ( $ str [ $ index ] , $ str [ $ index + 1 ] ) = array ( $ str [ $ index + 1 ] , $ str [ $ index ] ) ; } $ str = \"12345\" ; $ n = strlen ( $ str ) ; findPermutations ( $ str , 0 , $ n ) ; ? >"}
{"text":"Check if an encoding represents a unique binary string | PHP program to check if given encoding represents a single string ; Return true if sum becomes k ; Driver Code","code":"< ? php function isUnique ( $ a , $ n , $ k ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; $ sum += $ n - 1 ; return ( $ sum == $ k ) ; } $ a = array ( 3 , 3 , 3 ) ; $ n = count ( $ a ) ; $ k = 12 ; if ( isUnique ( $ a , $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Number of positions where a letter can be inserted such that a string becomes palindrome | Function to check if the string is palindrome ; to know the length of string ; if the given string is a palindrome ( Case - I ) ; Sub - case - III ) ; if the length is even ; sub - case - I ; sub - case - II ; insertion point ; Case - I ; Case - II ; Driver code","code":"< ? php function isPalindrome ( $ s , $ i , $ j ) { $ p = $ j ; for ( $ k = $ i ; $ k <= $ p ; $ k ++ ) { if ( $ s [ $ k ] != $ s [ $ p ] ) return false ; $ p -- ; } return true ; } function countWays ( $ s ) { $ n = strlen ( $ s ) ; $ count = 0 ; if ( isPalindrome ( $ s , 0 , $ n - 1 ) ) { for ( $ i = $ n \/ 2 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ count ++ ; else break ; } if ( $ n % 2 == 0 ) { $ count ++ ; $ count = 2 * $ count + 1 ; } else $ count = 2 * $ count + 2 ; } else { for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ n - 1 - $ i ] ) { $ j = $ n - 1 - $ i ; if ( isPalindrome ( $ s , $ i , $ n - 2 - $ i ) ) { for ( $ k = $ i - 1 ; $ k >= 0 ; $ k -- ) { if ( $ s [ $ k ] != $ s [ $ j ] ) break ; $ count ++ ; } $ count ++ ; } if ( isPalindrome ( $ s , $ i + 1 , $ n - 1 - $ i ) ) { for ( $ k = $ n - $ i ; $ k < $ n ; $ k ++ ) { if ( $ s [ $ k ] != $ s [ $ i ] ) break ; $ count ++ ; } $ count ++ ; } break ; } } } return $ count ; } $ s = \" abca \" ; echo countWays ( $ s ) ; ? >"}
{"text":"Count of substrings of a binary string containing K ones | method returns total number of substring having K ones ; initialize index having zero sum as 1 ; loop over binary characters of string ; update countOfOne variable with value of ith character ; if value reaches more than K , then update result ; add frequency of indices , having sum ( current sum - K ) , to the result ; update frequency of one 's count ; Driver code","code":"< ? php function countOfSubstringWithKOnes ( $ s , $ K ) { $ N = strlen ( $ s ) ; $ res = 0 ; $ countOfOne = 0 ; $ freq = array ( ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ freq [ $ i ] = 0 ; $ freq [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ countOfOne += ( $ s [ $ i ] - '0' ) ; if ( $ countOfOne >= $ K ) { $ res = $ res + $ freq [ $ countOfOne - $ K ] ; } $ freq [ $ countOfOne ] ++ ; } return $ res ; } $ s = \"10010\" ; $ K = 1 ; echo countOfSubstringWithKOnes ( $ s , $ K ) , \" \" ; ? >"}
{"text":"Next higher palindromic number using the same set of digits | function to reverse the digits in the range i to j in ' num ' ; function to find next higher palindromic number using the same set of digits ; if length of number is less than '3' then no higher palindromic number can be formed ; find the index of last digit in the 1 st half of ' num ' ; Start from the ( mid - 1 ) th digit and find the first digit that is smaller than the digit next to it . ; If no such digit is found , then all digits are in descending order which means there cannot be a greater palindromic number with same set of digits ; Find the smallest digit on right side of ith digit which is greater than num [ i ] up to index ' mid ' ; swap num [ i ] with num [ smallest ] ; as the number is a palindrome , the same swap of digits should be performed in the 2 nd half of ' num ' ; reverse digits in the range ( i + 1 ) to mid ; if n is even , then reverse digits in the range mid + 1 to n - i - 2 ; else if n is odd , then reverse digits in the range mid + 2 to n - i - 2 ; required next higher palindromic number ; Driver Code","code":"< ? php function reverse ( & $ num , $ i , $ j ) { while ( $ i < $ j ) { $ t = $ num [ $ i ] ; $ num [ $ i ] = $ num [ $ j ] ; $ num [ $ j ] = $ t ; $ i ++ ; $ j -- ; } } function nextPalin ( $ num , $ n ) { if ( $ n <= 3 ) { echo \" Not \u2581 Possible \" ; return ; } $ mid = ( $ n \/ 2 ) - 1 ; $ i = $ mid - 1 ; $ j ; for ( ; $ i >= 0 ; $ i -- ) if ( $ num [ $ i ] < $ num [ $ i + 1 ] ) break ; if ( $ i < 0 ) { echo \" Not \u2581 Possible \" ; return ; } $ smallest = $ i + 1 ; $ j = 0 ; for ( $ j = $ i + 2 ; $ j <= $ mid ; $ j ++ ) if ( $ num [ $ j ] > $ num [ $ i ] && $ num [ $ j ] < $ num [ $ smallest ] ) $ smallest = $ j ; $ t = $ num [ $ i ] ; $ num [ $ i ] = $ num [ $ smallest ] ; $ num [ $ smallest ] = $ t ; $ t = $ num [ $ n - $ i - 1 ] ; $ num [ $ n - $ i - 1 ] = $ num [ $ n - $ smallest - 1 ] ; $ num [ $ n - $ smallest - 1 ] = $ t ; reverse ( $ num , $ i + 1 , $ mid ) ; if ( $ n % 2 == 0 ) reverse ( $ num , $ mid + 1 , $ n - $ i - 2 ) ; else reverse ( $ num , $ mid + 2 , $ n - $ i - 2 ) ; echo \" Next \u2581 Palindrome : \u2581 \" . $ num ; } $ num = \"4697557964\" ; $ n = strlen ( $ num ) ; nextPalin ( $ num , $ n ) ; ? >"}
{"text":"Print N | function to generate n digit numbers ; if number generated ; Append 1 at the current number and reduce the remaining places by one ; If more ones than zeros , append 0 to the current number and reduce the remaining places by one ; Driver Code ; Function call","code":"< ? php function printRec ( $ number , $ extraOnes , $ remainingPlaces ) { if ( 0 == $ remainingPlaces ) { echo ( $ number . \" \" ) ; return ; } printRec ( $ number . \"1\" , $ extraOnes + 1 , $ remainingPlaces - 1 ) ; if ( 0 < $ extraOnes ) printRec ( $ number . \"0\" , $ extraOnes - 1 , $ remainingPlaces - 1 ) ; } function printNums ( $ n ) { $ str = \" \" ; printRec ( $ str , 0 , $ n ) ; } $ n = 4 ; printNums ( $ n ) ;"}
{"text":"Longest Common Substring in an Array of Strings | function to find the stem ( longest common substring ) from the string array ; Determine size of the array ; Take first word from array as reference ; generating all possible substrings of our reference string arr [ 0 ] i . e s ; Check if the generated stem is common to all words ; If current substring is present in all strings and its length is greater than current result ; Driver Code ; Function call","code":"< ? php function findstem ( $ arr ) { $ n = count ( $ arr ) ; $ s = $ arr [ 0 ] ; $ len = strlen ( $ s ) ; $ res = \" \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ len ; $ j ++ ) { $ stem = substr ( $ s , $ i , $ j - $ i ) ; $ k = 1 ; for ( $ k = 1 ; $ k < $ n ; $ k ++ ) if ( ! strpos ( $ arr [ $ k ] , $ stem ) ) break ; if ( $ k <= $ n && strlen ( $ res ) < strlen ( $ stem ) ) $ res = $ stem ; } } return $ res ; } $ arr = array ( \" grace \" , \" graceful \" , \" disgraceful \" , \" gracefully \" ) ; $ stems = findstem ( $ arr ) ; print ( $ stems ) ; ? >"}
{"text":"Next higher number using atmost one swap operation | function to find the next higher number using atmost one swap operation ; to store the index of the largest digit encountered so far from the right ; to store the index of rightmost digit which has a digit greater to it on its right side ; finding the ' index ' of rightmost digit which has a digit greater to it on its right side ; required digit found , store its ' index ' and break ; if no such digit is found which has a larger digit on its right side ; to store the index of the smallest digit greater than the digit at ' index ' and right to it ; finding the index of the smallest digit greater than the digit at ' index ' and right to it ; swapping the digits ; required number ; Driver Code","code":"< ? php function nxtHighUsingAtMostOneSwap ( $ num ) { $ l = strlen ( $ num ) ; $ posRMax = $ l - 1 ; $ index = -1 ; for ( $ i = $ l - 2 ; $ i >= 0 ; $ i -- ) { if ( $ num [ $ i ] >= $ num [ $ posRMax ] ) $ posRMax = $ i ; else { $ index = $ i ; break ; } } if ( $ index == -1 ) return \" Not \u2581 Possible \" ; $ greatSmallDgt = -1 ; for ( $ i = $ l - 1 ; $ i > $ index ; $ i -- ) { if ( $ num [ $ i ] > $ num [ $ index ] ) { if ( $ greatSmallDgt == -1 ) $ greatSmallDgt = $ i ; else if ( $ num [ $ i ] <= $ num [ $ greatSmallDgt ] ) $ greatSmallDgt = $ i ; } } $ temp = $ num [ $ index ] ; $ num [ $ index ] = $ num [ $ greatSmallDgt ] ; $ num [ $ greatSmallDgt ] = $ temp ; return $ num ; } $ num = \"218765\" ; echo \" Original \u2581 number : \u2581 \" . $ num . \" STRNEWLINE \" ; echo \" Next \u2581 higher \u2581 number : \u2581 \" . nxtHighUsingAtMostOneSwap ( $ num ) ; ? >"}
{"text":"Longest substring of vowels | PHP program to find the longest substring of vowels . ; Increment current count if s [ i ] is vowel ; check previous value is greater then or not ; Driver code","code":"< ? php function isVowel ( $ c ) { return ( $ c == ' a ' $ c == ' e ' $ c == ' i ' $ c == ' o ' $ c == ' u ' ) ; } function longestVowel ( $ s ) { $ count = 0 ; $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( isVowel ( $ s [ $ i ] ) ) $ count ++ ; else { $ res = max ( $ res , $ count ) ; $ count = 0 ; } } return max ( $ res , $ count ) ; } $ s = \" theeare \" ; echo longestVowel ( $ s ) ; ? >"}
{"text":"Number of substrings with count of each character as k | PHP program to count number of substrings with counts of distinct characters as k . ; Returns true if all values in freq [ ] are either 0 or k . ; Returns count of substrings where frequency of every present character is k ; Pick a starting point ; Initialize all frequencies as 0 for this starting point ; One by one pick ending points ; Increment frequency of current char ; If frequency becomes more than k , we can 't have more substrings  starting with i ; If frequency becomes k , then check other frequencies as well . ; Driver code","code":"< ? php $ MAX_CHAR = 26 ; function check ( & $ freq , $ k ) { global $ MAX_CHAR ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ freq [ $ i ] && $ freq [ $ i ] != $ k ) return false ; return true ; } function substrings ( $ s , $ k ) { global $ MAX_CHAR ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ freq = array_fill ( 0 , $ MAX_CHAR , NULL ) ; for ( $ j = $ i ; $ j < strlen ( $ s ) ; $ j ++ ) { $ index = ord ( $ s [ $ j ] ) - ord ( ' a ' ) ; $ freq [ $ index ] ++ ; if ( $ freq [ $ index ] > $ k ) break ; else if ( $ freq [ $ index ] == $ k && check ( $ freq , $ k ) == true ) $ res ++ ; } } return $ res ; } $ s = \" aabbcc \" ; $ k = 2 ; echo substrings ( $ s , $ k ) . \" STRNEWLINE \" ; $ s = \" aabbc \" ; $ k = 2 ; echo substrings ( $ s , $ k ) . \" STRNEWLINE \" ; ? >"}
{"text":"Recursive solution to count substrings with same first and last characters | Function to count substrings with same first and last characters ; base cases ; Driver Code","code":"< ? php function countSubstrs ( $ str , $ i , $ j , $ n ) { if ( $ n == 1 ) return 1 ; if ( $ n <= 0 ) return 0 ; $ res = countSubstrs ( $ str , $ i + 1 , $ j , $ n - 1 ) + countSubstrs ( $ str , $ i , $ j - 1 , $ n - 1 ) - countSubstrs ( $ str , $ i + 1 , $ j - 1 , $ n - 2 ) ; if ( $ str [ $ i ] == $ str [ $ j ] ) $ res ++ ; return $ res ; } $ str = \" abcab \" ; $ n = strlen ( $ str ) ; echo ( countSubstrs ( $ str , 0 , $ n - 1 , $ n ) ) ; ? >"}
{"text":"Minimum Number of Manipulations required to make two Strings Anagram Without Deletion of Character | Counts the no of manipulations required ; store the count of character ; iterate though the first String and update count ; iterate through the second string update char_count . if character is not found in char_count then increase count ; Driver code","code":"< ? php function countManipulations ( $ s1 , $ s2 ) { $ count = 0 ; $ char_count = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ s1 ) ; $ i ++ ) $ char_count [ ord ( $ s1 [ $ i ] ) - ord ( ' a ' ) ] += 1 ; for ( $ i = 0 ; $ i < strlen ( $ s2 ) ; $ i ++ ) { $ char_count [ ord ( $ s2 [ $ i ] ) - ord ( ' a ' ) ] -= 1 ; } for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ char_count [ i ] != 0 ) { $ count += abs ( $ char_count [ i ] ) ; } } return $ count ; } $ s1 = \" ddcf \" ; $ s2 = \" cedk \" ; echo countManipulations ( $ s1 , $ s2 ) ; ? >"}
{"text":"Given two strings check which string makes a palindrome first | Given two strings , check which string makes palindrome first . ; returns winner of two strings ; Count frequencies of characters in both given strings ; Check if there is a character that appears more than once in A and does not appear in B ; Driver Code","code":"< ? php $ MAX_CHAR = 26 ; function stringPalindrome ( $ A , $ B ) { global $ MAX_CHAR ; $ countA = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ countB = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ l1 = strlen ( $ A ) ; $ l2 = strlen ( $ B ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ countA [ ord ( $ A [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ countB [ ord ( $ B [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( ( $ countA [ $ i ] > 1 && $ countB [ $ i ] == 0 ) ) return ' A ' ; return ' B ' ; } $ a = \" abcdea \" ; $ b = \" bcdesg \" ; echo stringPalindrome ( $ a , $ b ) ; ? >"}
{"text":"Find numbers of balancing positions in string | PHP program to find number of balancing points in string ; function to return number of balancing points ; hash array for storing hash of string initialized by 0 being global ; process string initially for rightVisited ; check for balancing points ; for every position inc left hash & dec rightVisited ; check whether both hash have same character or not ; Either both leftVisited [ j ] and rightVisited [ j ] should have none zero value or both should have zero value ; if both have same character increment count ; Driver Code","code":"< ? php $ MAX_CHAR = 256 ; function countBalance ( $ str ) { global $ MAX_CHAR ; $ leftVisited = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ rightVisited = array_fill ( 0 , $ MAX_CHAR , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ rightVisited [ ord ( $ str [ $ i ] ) ] ++ ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ leftVisited [ ord ( $ str [ $ i ] ) ] ++ ; $ rightVisited [ ord ( $ str [ $ i ] ) ] -- ; for ( $ j = 0 ; $ j < $ MAX_CHAR ; $ j ++ ) { if ( ( $ leftVisited [ $ j ] == 0 && $ rightVisited [ $ j ] != 0 ) || ( $ leftVisited [ $ j ] != 0 && $ rightVisited [ $ j ] == 0 ) ) break ; } if ( $ j == $ MAX_CHAR ) $ res ++ ; } return $ res ; } $ str = \" abaababa \" ; echo countBalance ( $ str ) ; ? >"}
{"text":"Min flips of continuous characters to make all characters same in a string | To find min number of flips in binary string ; If last character is not equal to str [ i ] increase res ; To return min flips ; Driver Code","code":"< ? php function findFlips ( $ str , $ n ) { $ last = ' \u2581 ' ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ last != $ str [ $ i ] ) $ res ++ ; $ last = $ str [ $ i ] ; } return intval ( $ res \/ 2 ) ; } $ str = \"00011110001110\" ; $ n = strlen ( $ str ) ; echo findFlips ( $ str , $ n ) ; ? >"}
{"text":"Maximum length substring having all same characters after k changes | function to find the maximum length of substring having character ch ; traverse the whole string ; if character is not same as ch increase count ; While count > k traverse the string again until count becomes less than k and decrease the count when characters are not same ; length of substring will be rightIndex - leftIndex + 1. Compare this with the maximum length and return maximum length ; function which returns maximum length of substring ; Driver code","code":"< ? php function findLen ( $ A , $ n , $ k , $ ch ) { $ maxlen = 1 ; $ cnt = 0 ; $ l = 0 ; $ r = 0 ; while ( $ r < $ n ) { if ( $ A [ $ r ] != $ ch ) ++ $ cnt ; while ( $ cnt > $ k ) { if ( $ A [ $ l ] != $ ch ) -- $ cnt ; ++ $ l ; } $ maxlen = max ( $ maxlen , $ r - $ l + 1 ) ; ++ $ r ; } return $ maxlen ; } function answer ( $ A , $ n , $ k ) { $ maxlen = 1 ; for ( $ i = 0 ; $ i < 26 ; ++ $ i ) { $ maxlen = max ( $ maxlen , findLen ( $ A , $ n , $ k , $ i + ' A ' ) ) ; $ maxlen = max ( $ maxlen , findLen ( $ A , $ n , $ k , $ i + ' a ' ) ) ; } return $ maxlen ; } $ n = 5 ; $ k = 2 ; $ A = \" ABABA \" ; echo \" Maximum length = \" \u2581 . \u2581 answer ( $ A , \u2581 $ n , \u2581 $ k ) \u2581 . \u2581 \" \" $ n = 6 ; $ k = 4 ; $ B = \" HHHHHH \" ; echo \" Maximum length = \" \u2581 . \u2581 answer ( $ B , \u2581 $ n , \u2581 $ k ) \u2581 . \u2581 \" \" ? >"}
{"text":"Check if both halves of the string have same set of characters | PHP program to check if it is possible to split string or not ; function to check if we can split string or not ; Counter array initialized with 0 ; Length of the string ; traverse till the middle element is reached ; First half ; Second half ; Checking if values are different set flag to 1 ; String to be checked","code":"< ? php $ MAX_CHAR = 26 ; function checkCorrectOrNot ( $ s ) { global $ MAX_CHAR ; $ count1 = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ count2 = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ n = strlen ( $ s ) ; if ( $ n == 1 ) return true ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) { $ count1 [ $ s [ $ i ] - ' a ' ] ++ ; $ count2 [ $ s [ $ j ] - ' a ' ] ++ ; } for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count1 [ $ i ] != $ count2 [ $ i ] ) return false ; return true ; } $ s = \" abab \" ; if ( checkCorrectOrNot ( $ s ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Extract maximum numeric value from a given string | Set 1 ( General approach ) | Utility function to find maximum string ; If both having equal lengths ; Reach first unmatched character \/ value ; Return string with maximum value ; If different lengths return string with maximum length ; Function to extract the maximum value ; Start traversing the string ; Ignore leading zeroes ; Store numeric value into a string ; Update maximum string ; To handle the case if there is only 0 numeric value ; Return maximum string ; Drivers program","code":"< ? php function maximumNum ( $ curr_num , $ res ) { $ len1 = strlen ( $ curr_num ) ; $ len2 = strlen ( $ res ) ; if ( $ len1 == $ len2 ) { $ i = 0 ; while ( $ curr_num [ $ i ] == $ res [ $ i ] ) $ i ++ ; if ( $ curr_num [ $ i ] < $ res [ $ i ] ) return $ res ; else return $ curr_num ; } return $ len1 < $ len2 ? $ res : $ curr_num ; } function extractMaximum ( $ str ) { $ n = strlen ( $ str ) ; $ curr_num = \" \" ; $ res = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n && $ str [ $ i ] == '0' ) $ i ++ ; while ( $ i < $ n && $ str [ $ i ] >= '0' && $ str [ $ i ] <= '9' ) { $ curr_num . = $ str [ $ i ] ; $ i ++ ; } if ( $ i == $ n ) break ; if ( strlen ( $ curr_num ) > 0 ) $ i -- ; $ res = maximumNum ( $ curr_num , $ res ) ; $ curr_num = \" \" ; } if ( strlen ( $ curr_num ) == 0 && strlen ( $ res ) == 0 ) $ res . = '0' ; return maximumNum ( $ curr_num , $ res ) ; } $ str = \"100klh564abc365bg \" ; echo extractMaximum ( $ str ) ; ? >"}
{"text":"To check divisibility of any large number by 999 | function to check divisibility ; Append required 0 s at the beginning . ; add digits in group of three in gSum ; group saves 3 - digit group ; calculate result till 3 digit sum ; Driver Code","code":"< ? php function isDivisible999 ( $ num ) { $ n = strlen ( $ num ) ; if ( $ n == 0 && $ num [ 0 ] == '0' ) return true ; if ( $ n % 3 == 1 ) $ num = \"00\" . $ num ; if ( $ n % 3 == 2 ) $ num = \"0\" . $ num ; $ gSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 3 ) { $ group = 0 ; $ group += ( ord ( $ num [ $ i ] ) - 48 ) * 100 ; $ group += ( ord ( $ num [ $ i + 1 ] ) - 48 ) * 10 ; $ group += ( ord ( $ num [ $ i + 2 ] ) - 48 ) ; $ gSum += $ group ; } if ( $ gSum > 1000 ) { $ num = strval ( $ gSum ) ; $ n = strlen ( $ num ) ; $ gSum = isDivisible999 ( $ num ) ; } return ( $ gSum == 999 ) ; } $ num = \"1998\" ; if ( isDivisible999 ( $ num ) ) echo \" Divisible \" ; else echo \" Not \u2581 divisible \" ; ? >"}
{"text":"Rearrange a string in sorted order followed by the integer sum | PHP program for above implementation ; Function to return string in lexicographic order followed by integers sum ; Traverse the string ; Count occurrence of uppercase alphabets ; Store sum of integers ; Traverse for all characters A to Z ; Append the current character in the string no . of times it occurs in the given string ; Append the sum of integers ; return resultant string ; Driver Code","code":"< ? php $ MAX_CHAR = 26 ; function arrangeString ( $ str ) { global $ MAX_CHAR ; $ char_count = array_fill ( 0 , $ MAX_CHAR , NULL ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) $ char_count [ ord ( $ str [ $ i ] ) - ord ( ' A ' ) ] ++ ; else $ sum = $ sum + ( ord ( $ str [ $ i ] ) - ord ( '0' ) ) ; } $ res = \" \" ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) { $ ch = chr ( ord ( ' A ' ) + $ i ) ; while ( $ char_count [ $ i ] -- ) $ res = $ res . $ ch ; } if ( $ sum > 0 ) $ res = $ res . strval ( $ sum ) ; return $ res ; } $ str = \" ACCBA10D2EW30\" ; echo arrangeString ( $ str ) ; ? >"}
{"text":"Program to print all substrings of a given string | Function to print all sub strings ; Pick starting point ; Pick ending point ; Print characters from current starting point to current ending point . ; Driver Code","code":"< ? php function subString ( $ str , $ n ) { for ( $ len = 1 ; $ len <= $ n ; $ len ++ ) { for ( $ i = 0 ; $ i <= $ n - $ len ; $ i ++ ) { $ j = $ i + $ len - 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ str [ $ k ] ; echo \" STRNEWLINE \" ; } } } $ str = \" abc \" ; subString ( $ str , strlen ( $ str ) ) ; ? >"}
{"text":"Program to count vowels in a string ( Iterative and Recursive ) | Function to check the Vowel ; Returns count of vowels in str ; if ( isVowel ( $str [ $i ] ) ) Check for vowel ; string object ; Total numbers of Vowel","code":"< ? php function isVowel ( $ ch ) { $ ch = strtoupper ( $ ch ) ; return ( $ ch == ' A ' $ ch == ' E ' $ ch == ' I ' $ ch == ' O ' $ ch == ' U ' ) ; } function countVowels ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) ++ $ count ; return $ count ; } $ str = \" abc \u2581 de \" ; echo countVowels ( $ str ) . \" STRNEWLINE \" ; ? >"}
{"text":"Generate all rotations of a given string | Print all the rotated string . ; Generate all rotations one by one and print ; Current index in str ; Current index in temp ; Copying the second part from the point of rotation . ; Copying the first part from the point of rotation . ; Driver Code","code":"< ? php function printRotatedString ( $ str ) { $ len = strlen ( $ str ) ; $ temp = \" \u2581 \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ j = $ i ; $ k = 0 ; while ( $ j < $ len ) { $ temp [ $ k ] = $ str [ $ j ] ; $ k ++ ; $ j ++ ; } $ j = 0 ; while ( $ j < $ i ) { $ temp [ $ k ] = $ str [ $ j ] ; $ j ++ ; $ k ++ ; } echo $ temp . \" STRNEWLINE \" ; } } $ str = \" geeks \" ; printRotatedString ( $ str ) ; ? >"}
{"text":"Longest Non | utility function to check whether a string is palindrome or not ; Check for palindrome . ; palindrome string ; function to find maximum length substring which is not palindrome ; to check whether all characters of the string are same or not ; All characters are same , we can 't  make a non-palindromic string. ; If string is palindrome , we can make it non - palindrome by removing any corner character ; Complete string is not a palindrome . ; Driver code","code":"< ? php function isPalindrome ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) if ( $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) return false ; return true ; } function maxLengthNonPalinSubstring ( $ str ) { $ n = strlen ( $ str ) ; $ ch = $ str [ 0 ] ; $ i = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] != $ ch ) break ; if ( $ i == $ n ) return 0 ; if ( isPalindrome ( $ str ) ) return ( $ n - 1 ) ; return $ n ; } $ str = \" abba \" ; echo \" Maximum \u2581 Length \u2581 = \u2581 \" , maxLengthNonPalinSubstring ( $ str ) ; ? >"}
{"text":"Check whether K | PHP program to check if k - th bit of a given number is set or not using right shift operator . ; Driver code","code":"< ? php function isKthBitSet ( $ n , $ k ) { if ( ( $ n >> ( $ k - 1 ) ) & 1 ) echo \" SET \" ; else echo \" NOT \u2581 SET \" ; } $ n = 5 ; $ k = 1 ; isKthBitSet ( $ n , $ k ) ; ? >"}
{"text":"Lexicographically first palindromic string | PHP program to find first palindromic permutation of given string ; Function to count frequency of each char in the string . freq [ 0 ] for ' a ' , ... . , freq [ 25 ] for ' z ' ; Cases to check whether a palindr0mic string can be formed or not ; count_odd to count no of chars with odd frequency ; For even length string no odd freq character ; For odd length string one odd freq character ; Function to find odd freq char and reducing its freq by 1 returns \" \" if odd freq char is not present ; To find lexicographically first palindromic string . ; Assigning odd freq character if present else empty string . ; Traverse characters in increasing order ; Divide all occurrences into two halves . Note that odd character is removed by findOddAndRemoveItsFreq ( ) ; creating front string ; creating rear string ; Final palindromic string which is lexicographically first ; Driver code","code":"< ? php $ MAX_CHAR = 26 ; function countFreq ( $ str , & $ freq , $ len ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; } function canMakePalindrome ( $ freq , $ len ) { global $ MAX_CHAR ; $ count_odd = 0 ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ freq [ $ i ] % 2 != 0 ) $ count_odd ++ ; if ( $ len % 2 == 0 ) { if ( $ count_odd > 0 ) return false ; else return true ; } if ( $ count_odd != 1 ) return false ; return true ; } function findOddAndRemoveItsFreq ( $ freq ) { global $ MAX_CHAR ; $ odd_str = \" \" ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) { if ( $ freq [ $ i ] % 2 != 0 ) { $ freq [ $ i ] -- ; $ odd_str . = chr ( $ i + ord ( ' a ' ) ) ; return $ odd_str ; } } return $ odd_str ; } function findPalindromicString ( $ str ) { global $ MAX_CHAR ; $ len = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ MAX_CHAR , 0 ) ; countFreq ( $ str , $ freq , $ len ) ; if ( ! canMakePalindrome ( $ freq , $ len ) ) return \" No \u2581 Palindromic \u2581 String \" ; $ odd_str = findOddAndRemoveItsFreq ( $ freq ) ; $ front_str = \" \" ; $ rear_str = \" \u2581 \" ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) { $ temp = \" \" ; if ( $ freq [ $ i ] != 0 ) { $ ch = chr ( $ i + ord ( ' a ' ) ) ; for ( $ j = 1 ; $ j <= ( int ) ( $ freq [ $ i ] \/ 2 ) ; $ j ++ ) $ temp . = $ ch ; $ front_str . = $ temp ; $ rear_str = $ temp . $ rear_str ; } } return ( $ front_str . $ odd_str . $ rear_str ) ; } $ str = \" malayalam \" ; echo findPalindromicString ( $ str ) ; ? >"}
{"text":"Count substrings with same first and last characters | Returns true if first and last characters of s are same . ; Starting point of substring ; Length of substring ; Check if current substring has same starting and ending characters . ; Driver Code","code":"< ? php function checkEquality ( $ s ) { return ( $ s [ 0 ] == $ s [ strlen ( $ s ) - 1 ] ) ; } function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ len = 1 ; $ len <= $ n - $ i ; $ len ++ ) if ( checkEquality ( substr ( $ s , $ i , $ len ) ) ) $ result ++ ; return $ result ; } $ s = \" abcab \" ; print ( countSubstringWithEqualEnds ( $ s ) ) ; ? >"}
{"text":"Count substrings with same first and last characters | Space efficient PHP program to count all substrings with same first and last characters . ; Iterating through all substrings in way so that we can find first and last character easily ; Driver Code","code":"< ? php function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ s [ $ i ] == $ s [ $ j ] ) $ result ++ ; return $ result ; } $ s = \" abcab \" ; echo countSubstringWithEqualEnds ( $ s ) ;"}
{"text":"Maximum consecutive repeating character in string | function to find out the maximum repeating character in given string ; Find the maximum repeating character starting from str [ i ] ; Update result if required ; Driver code","code":"< ? php function maxRepeating ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ cur_count = 1 ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) { if ( $ str [ $ i ] != $ str [ $ j ] ) break ; $ cur_count ++ ; } if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } } return $ res ; } $ str = \" aaaabbaaccde \" ; echo maxRepeating ( $ str ) ; ? >"}
{"text":"Sum of two large numbers | Function for finding sum of larger numbers ; Before proceeding further , make sure length of str2 is larger . ; Take an empty string for storing result ; Calculate length of both string ; Reverse both of strings ; Do school mathematics , compute sum of current digits and carry ; Calculate carry for next step ; Add remaining digits of larger number ; Add remaining carry ; reverse resultant string ; Driver code","code":"< ? php function findSum ( $ str1 , $ str2 ) { if ( strlen ( $ str1 ) > strlen ( $ str2 ) ) { $ t = $ str1 ; $ str1 = $ str2 ; $ str2 = $ t ; } $ str = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; $ str1 = strrev ( $ str1 ) ; $ str2 = strrev ( $ str2 ) ; $ carry = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) { $ sum = ( ( ord ( $ str1 [ $ i ] ) -48 ) + ( ( ord ( $ str2 [ $ i ] ) -48 ) + $ carry ) ) ; $ str . = chr ( $ sum % 10 + 48 ) ; $ carry = ( int ) ( $ sum \/ 10 ) ; } for ( $ i = $ n1 ; $ i < $ n2 ; $ i ++ ) { $ sum = ( ( ord ( $ str2 [ $ i ] ) -48 ) + $ carry ) ; $ str . = chr ( $ sum % 10 + 48 ) ; $ carry = ( int ) ( $ sum \/ 10 ) ; } if ( $ carry ) $ str . = chr ( $ carry + 48 ) ; $ str = strrev ( $ str ) ; return $ str ; } $ str1 = \"12\" ; $ str2 = \"198111\" ; echo findSum ( $ str1 , $ str2 ) ; ? >"}
{"text":"Sum of two large numbers | Function for finding sum of larger numbers ; Before proceeding further , make sure length of str2 is larger . ; Take an empty string for storing result ; Calculate length of both string ; Initially take carry zero ; Traverse from end of both strings ; Do school mathematics , compute sum of current digits and carry ; Add remaining digits of str2 [ ] ; Add remaining carry ; reverse resultant string ; Driver code","code":"< ? php function findSum ( $ str1 , $ str2 ) { if ( strlen ( $ str1 ) > strlen ( $ str2 ) ) { $ temp = $ str1 ; $ str1 = $ str2 ; $ str2 = $ temp ; } $ str3 = \" \" ; $ n1 = strlen ( $ str1 ) ; $ n2 = strlen ( $ str2 ) ; $ diff = $ n2 - $ n1 ; $ carry = 0 ; for ( $ i = $ n1 - 1 ; $ i >= 0 ; $ i -- ) { $ sum = ( ( ord ( $ str1 [ $ i ] ) - ord ( '0' ) ) + ( ( ord ( $ str2 [ $ i + $ diff ] ) - ord ( '0' ) ) ) + $ carry ) ; $ str3 . = chr ( $ sum % 10 + ord ( '0' ) ) ; $ carry = ( int ) ( $ sum \/ 10 ) ; } for ( $ i = $ n2 - $ n1 - 1 ; $ i >= 0 ; $ i -- ) { $ sum = ( ( ord ( $ str2 [ $ i ] ) - ord ( '0' ) ) + $ carry ) ; $ str3 . = chr ( $ sum % 10 + ord ( '0' ) ) ; $ carry = ( int ) ( $ sum \/ 10 ) ; } if ( $ carry ) $ str3 . = chr ( $ carry + ord ( '0' ) ) ; return strrev ( $ str3 ) ; } $ str1 = \"12\" ; $ str2 = \"198111\" ; print ( findSum ( $ str1 , $ str2 ) ) ; ? >"}
{"text":"Efficiently check if a string has all unique characters without using any additional data structure | Returns true if all characters of str are unique . Assumptions : ( 1 ) str contains only characters from ' a ' to ' z ' ( 2 ) integers are stored using 32 bits ; An integer to store presence \/ absence of 26 characters using its 32 bits . ; If bit corresponding to current character is already set ; set bit in checker ; Driver code","code":"< ? php function areChractersUnique ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < $ len = strlen ( $ str ) ; ++ $ i ) { $ val = ( $ str [ $ i ] - ' a ' ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return false ; $ checker |= ( 1 << $ val ) ; } return true ; } $ s = \" aaabbccdaa \" ; if ( areChractersUnique ( $ s ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Count of words whose i | Return the count of words . ; If word contain single letter , return 1. ; Checking for first letter . ; Traversing the string and multiplying for combinations . ; If all three letters are same . ; If two letter are distinct . ; If all three letter are distinct . ; Checking for last letter . ; Driver Code","code":"< ? php function countWords ( $ str , $ len ) { $ count = 1 ; if ( $ len == 1 ) return $ count ; if ( $ str [ 0 ] == $ str [ 1 ] ) $ count *= 1 ; else $ count *= 2 ; for ( $ j = 1 ; $ j < $ len - 1 ; $ j ++ ) { if ( $ str [ $ j ] == $ str [ $ j - 1 ] && $ str [ $ j ] == $ str [ $ j + 1 ] ) $ count *= 1 ; else if ( $ str [ $ j ] == $ str [ $ j - 1 ] $ str [ $ j ] == $ str [ $ j + 1 ] $ str [ $ j - 1 ] == $ str [ $ j + 1 ] ) $ count *= 2 ; else $ count *= 3 ; } if ( $ str [ $ len - 1 ] == $ str [ $ len - 2 ] ) $ count *= 1 ; else $ count *= 2 ; return $ count ; } $ str = \" abc \" ; $ len = strlen ( $ str ) ; echo countWords ( $ str , $ len ) ; ? >"}
{"text":"Maximum and minimum sums from two numbers with digit replacements | Find new value of x after replacing digit \" from \" to \" to \" ; Required digit found , replace it ; Returns maximum and minimum possible sums of x1 and x2 if digit replacements are allowed . ; We always get minimum sum if we replace 6 with 5. ; We always get maximum sum if we replace 5 with 6. ; Driver code","code":"< ? php function replaceDig ( $ x , $ from , $ to ) { $ result = 0 ; $ multiply = 1 ; while ( $ x > 0 ) { $ reminder = $ x % 10 ; if ( $ reminder == $ from ) $ result = $ result + $ to * $ multiply ; else $ result = $ result + $ reminder * $ multiply ; $ multiply *= 10 ; $ x = $ x \/ 10 ; } return $ result ; } function calculateMinMaxSum ( $ x1 , $ x2 ) { $ minSum = replaceDig ( $ x1 , 6 , 5 ) + replaceDig ( $ x2 , 6 , 5 ) ; $ maxSum = replaceDig ( $ x1 , 5 , 6 ) + replaceDig ( $ x2 , 5 , 6 ) ; echo \" Minimum sum = \" \u2581 , \u2581 $ minSum , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" Maximum sum = \" } $ x1 = 5466 ; $ x2 = 4555 ; calculateMinMaxSum ( $ x1 , $ x2 ) ; ? >"}
{"text":"Queries on substring palindrome formation | Query type 1 : update string position i with character x . ; Print \" Yes \" if range [ L . . R ] can form palindrome , else print \" No \" . ; Find the frequency of each character in S [ L ... R ] . ; Checking if more than one character have frequency greater than 1. ; Driver code","code":"< ? php function qType1 ( $ l , $ x , & $ str ) { $ str [ $ l - 1 ] = $ x ; } function qType2 ( $ l , $ r , $ str ) { $ freq = array_fill ( 0 , 27 , 0 ) ; for ( $ i = $ l - 1 ; $ i <= $ r - 1 ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; $ count = 0 ; for ( $ j = 0 ; $ j < 26 ; $ j ++ ) if ( $ freq [ $ j ] % 2 ) $ count ++ ; ( $ count <= 1 ) ? ( print ( \" Yes STRNEWLINE \" ) ) : ( print ( \" No STRNEWLINE \" ) ) ; } $ str = \" geeksforgeeks \" ; $ n = strlen ( $ str ) ; qType1 ( 4 , ' g ' , $ str ) ; qType2 ( 1 , 4 , $ str ) ; qType2 ( 2 , 3 , $ str ) ; qType1 ( 10 , ' t ' , $ str ) ; qType2 ( 10 , 11 , $ str ) ; ? >"}
{"text":"Efficient method for 2 's complement of a binary string | Function to find two 's complement ; Traverse the string to get first '1' from the last of string ; If there exists no '1' concatenate 1 at the starting of string ; Continue traversal after the position of first '1' ; Just flip the values ; return the modified string ; Driver code","code":"< ? php function findTwoscomplement ( $ str ) { $ n = strlen ( $ str ) ; $ i ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == '1' ) break ; if ( $ i == -1 ) return '1' + $ str ; for ( $ k = $ i - 1 ; $ k >= 0 ; $ k -- ) { if ( $ str [ $ k ] == '1' ) $ str [ $ k ] = '0' ; else $ str [ $ k ] = '1' ; } return $ str ; ; } $ str = \"00000101\" ; echo findTwoscomplement ( $ str ) ; ? >"}
{"text":"Check length of a string is equal to the number appended at its last | Function to find if given number is equal to length or not ; Traverse string from end and find the number stored at the end . x is used to store power of 10. ; Check if number is equal to string length except that number 's digits ; Driver code","code":"< ? php function isequal ( $ str ) { $ n = strlen ( $ str ) ; $ num = 0 ; $ x = 1 ; $ i = $ n - 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( '0' <= $ str [ $ i ] && $ str [ $ i ] <= '9' ) { $ num = ( $ str [ $ i ] - '0' ) * $ x + $ num ; $ x = $ x * 10 ; if ( $ num >= $ n ) return false ; } else break ; } return $ num == $ i + 1 ; } $ str = \" geeksforgeeks13\" ; if ( isequal ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; ? >"}
{"text":"Minimum number of characters to be removed to make a binary string alternate | Returns count of minimum characters to be removed to make s alternate . ; if two alternating characters of string are same ; then need to delete a character ; Driver code","code":"< ? php function countToMake0lternate ( $ s ) { $ result = 0 ; for ( $ i = 0 ; $ i < ( strlen ( $ s ) - 1 ) ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ result ++ ; return $ result ; } echo countToMake0lternate ( \" 000111 \" ) , \" \" ; echo countToMake0lternate ( \" 11111 \" ) , \" \" ; echo countToMake0lternate ( \" 01010101 \" ) ; ? >"}
{"text":"Smallest Palindrome after replacement | Utility method to check str is possible palindrome after ignoring ; If both left and right character are not dot and they are not equal also , then it is not possible to make this string a palindrome ; Returns lexicographically smallest palindrome string , if possible ; loop through character of string ; if one of character is dot , replace dot with other character ; if both character are dot , then replace them with smallest character ' a ' ; return the result ; Driver code","code":"< ? php function isPossiblePalindrome ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n \/ 2 ; $ i ++ ) { if ( $ str [ $ i ] != ' . ' && $ str [ $ n - $ i - 1 ] != ' . ' && $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) return false ; } return true ; } function smallestPalindrome ( $ str ) { if ( ! isPossiblePalindrome ( $ str ) ) return \" Not \u2581 Possible \" ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' . ' ) { if ( $ str [ $ n - $ i - 1 ] != ' . ' ) $ str [ $ i ] = $ str [ $ n - $ i - 1 ] ; else $ str [ $ i ] = $ str [ $ n - $ i - 1 ] = ' a ' ; } } return $ str ; } $ str = \" ab . . e . c . a \" ; echo smallestPalindrome ( $ str ) ; ? >"}
{"text":"Number of flips to make binary string alternate | Set 1 | Utility method to flip a character ; Utility method to get minimum flips when alternate string starts with expected char ; if current character is not expected , increase flip count ; flip expected character each time ; method return minimum flip to make binary string alternate ; return minimum of following two 1 ) flips when alternate string starts with 0 2 ) flips when alternate string starts with 1 ; Driver code to test above method","code":"< ? php function flip ( $ ch ) { return ( $ ch == '0' ) ? '1' : '0' ; } function getFlipWithStartingCharcter ( $ str , $ expected ) { $ flipCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] != $ expected ) $ flipCount ++ ; $ expected = flip ( $ expected ) ; } return $ flipCount ; } function minFlipToMakeStringAlternate ( $ str ) { return min ( getFlipWithStartingCharcter ( $ str , '0' ) , getFlipWithStartingCharcter ( $ str , '1' ) ) ; } $ str = \"0001010111\" ; echo minFlipToMakeStringAlternate ( $ str ) ; ? >"}
{"text":"Remainder with 7 for large numbers | Function which return Remainder after dividing the number by 7 ; This series is used to find remainder with 7 ; Index of next element in series ; Initialize result ; Traverse num from end ; Find current digit of num ; Add next term to result ; Move to next term in series ; Make sure that result never goes beyond 7. ; Make sure that remainder is positive ; Driver Code","code":"< ? php function remainderWith7 ( $ num ) { $ series = array ( 1 , 3 , 2 , -1 , -3 , -2 ) ; $ series_index = 0 ; $ result = 0 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ digit = $ num [ $ i ] - '0' ; $ result += $ digit * $ series [ $ series_index ] ; $ series_index = ( $ series_index + 1 ) % 6 ; $ result %= 7 ; } if ( $ result < 0 ) $ result = ( $ result + 7 ) % 7 ; return $ result ; } { $ str = \"12345\" ; echo \" Remainder \u2581 with \u2581 7 \u2581 is \u2581 \" , ( remainderWith7 ( $ str ) ) ; return 0 ; } ? >"}
{"text":"Converting Decimal Number lying between 1 to 3999 to Roman Numerals | Function to calculate roman equivalent ; storing roman values of digits from 0 - 9 when placed at different places ; Converting to roman ; Driver Code","code":"< ? php function intToRoman ( $ num ) { $ m = array ( \" \" , \" M \" , \" MM \" , \" MMM \" ) ; $ c = array ( \" \" , \" C \" , \" CC \" , \" CCC \" , \" CD \" , \" D \" , \" DC \" , \" DCC \" , \" DCCC \" , \" CM \" ) ; $ x = array ( \" \" , \" X \" , \" XX \" , \" XXX \" , \" XL \" , \" L \" , \" LX \" , \" LXX \" , \" LXXX \" , \" XC \" ) ; $ i = array ( \" \" , \" I \" , \" II \" , \" III \" , \" IV \" , \" V \" , \" VI \" , \" VII \" , \" VIII \" , \" IX \" ) ; $ thousands = $ m [ $ num \/ 1000 ] ; $ hundereds = $ c [ ( $ num % 1000 ) \/ 100 ] ; $ tens = $ x [ ( $ num % 100 ) \/ 10 ] ; $ ones = $ i [ $ num % 10 ] ; $ ans = $ thousands . $ hundereds . $ tens . $ ones ; return $ ans ; } $ number = 3549 ; echo intToRoman ( $ number ) ;"}
{"text":"Print string of odd length in ' X ' format | Function to print given string in cross pattern ; i and j are the indexes of characters to be displayed in the ith iteration i = 0 initially and go upto length of string j = length of string initially in each iteration of i , we increment i and decrement j , we print character only of k == i or k == j ; Driver code","code":"< ? php function pattern ( $ str , $ len ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ j = $ len - 1 - $ i ; for ( $ k = 0 ; $ k < $ len ; $ k ++ ) { if ( $ k == $ i $ k == $ j ) echo $ str [ $ k ] ; else echo \" \u2581 \" ; } echo \" STRNEWLINE \" ; } } $ str = \" geeksforgeeks \" ; $ len = strlen ( $ str ) ; pattern ( $ str , $ len ) ; ? >"}
{"text":"Find the smallest window in a string containing all characters of another string | PHP program to find smallest window containing all characters of a pattern . ; Function to find smallest window containing all characters of ' pat ' ; check if string ' s \u2581 length \u2581 is \u2581 less \u2581 \u2581 than \u2581 pattern ' s length . If yes then no such window can exist ; store occurrence ofs characters of pattern ; start traversing the string $count = 0 ; count of characters ; count occurrence of characters of string ; If string ' s \u2581 char \u2581 matches \u2581 with \u2581 \u2581 pattern ' s char then increment count ; if all the characters are matched ; Try to minimize the window i . e . , check if any character is occurring more no . of times than its occurrence in pattern , if yes then remove it from starting and also remove the useless characters . ; update window size ; If no window found ; Return substring starting from start_index and length min_len ; Driver code","code":"< ? php define ( \" no _ of _ chars \" , 256 ) ; function findSubString ( & $ str , & $ pat ) { $ len1 = strlen ( $ str ) ; $ len2 = strlen ( $ pat ) ; if ( $ len1 < $ len2 ) { echo \" No \u2581 such \u2581 window \u2581 exists \" ; return \" \" ; } $ hash_pat = array_fill ( 0 , no_of_chars , 0 ) ; $ hash_str = array_fill ( 0 , no_of_chars , 0 ) ; for ( $ i = 0 ; $ i < $ len2 ; $ i ++ ) $ hash_pat [ ord ( $ pat [ $ i ] ) ] ++ ; $ start = 0 ; $ start_index = -1 ; $ min_len = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ len1 ; $ j ++ ) { $ hash_str [ ord ( $ str [ $ j ] ) ] ++ ; if ( $ hash_str [ ord ( $ str [ $ j ] ) ] <= $ hash_pat [ ord ( $ str [ $ j ] ) ] ) $ count ++ ; if ( $ count == $ len2 ) { while ( $ hash_str [ ord ( $ str [ $ start ] ) ] > $ hash_pat [ ord ( $ str [ $ start ] ) ] || $ hash_pat [ ord ( $ str [ $ start ] ) ] == 0 ) { if ( $ hash_str [ ord ( $ str [ $ start ] ) ] > $ hash_pat [ ord ( $ str [ $ start ] ) ] ) $ hash_str [ ord ( $ str [ $ start ] ) ] -- ; $ start ++ ; } $ len_window = $ j - $ start + 1 ; if ( $ min_len > $ len_window ) { $ min_len = $ len_window ; $ start_index = $ start ; } } } if ( $ start_index == -1 ) { echo \" No \u2581 such \u2581 window \u2581 exists \" ; return \" \" ; } return substr ( $ str , $ start_index , $ min_len ) ; } $ str = \" this \u2581 is \u2581 a \u2581 test \u2581 string \" ; $ pat = \" tist \" ; echo \" Smallest \u2581 window \u2581 is \u2581 : \u2581 STRNEWLINE \" . findSubString ( $ str , $ pat ) ; ? >"}
{"text":"Prime numbers after prime P with sum S | vector to store prime and N primes whose sum equals given S ; function to check prime number ; square root of x ; since 1 is not prime number ; if any factor is found return false ; no factor found ; function to display N primes whose sum equals S ; function to evaluate all possible N primes whose sum equals S ; if total equals S And total is reached using N primes ; display the N primes ; if total is greater than S or if index has reached last element ; add prime [ index ] to set vector ; include the ( index ) th prime to total ; remove element from set vector ; exclude ( index ) th prime ; function to generate all primes ; all primes less than S itself ; if i is prime add it to prime vector ; if primes are less than N ; Driver Code","code":"< ? php $ set = array ( ) ; $ prime = array ( ) ; function isPrime ( $ x ) { $ sqroot = sqrt ( $ x ) ; $ flag = true ; if ( $ x == 1 ) return false ; for ( $ i = 2 ; $ i <= $ sqroot ; $ i ++ ) if ( $ x % $ i == 0 ) return false ; return true ; } function display ( ) { global $ set , $ prime ; $ length = count ( $ set ) ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) echo ( $ set [ $ i ] . \" \u2581 \" ) ; echo ( \" STRNEWLINE \" ) ; } function primeSum ( $ total , $ N , $ S , $ index ) { global $ set , $ prime ; if ( $ total == $ S && count ( $ set ) == $ N ) { display ( ) ; return ; } if ( $ total > $ S || $ index == count ( $ prime ) ) return ; array_push ( $ set , $ prime [ $ index ] ) ; primeSum ( $ total + $ prime [ $ index ] , $ N , $ S , $ index + 1 ) ; array_pop ( $ set ) ; primeSum ( $ total , $ N , $ S , $ index + 1 ) ; } function allPrime ( $ N , $ S , $ P ) { global $ set , $ prime ; for ( $ i = $ P + 1 ; $ i <= $ S ; $ i ++ ) { if ( isPrime ( $ i ) ) array_push ( $ prime , $ i ) ; } if ( count ( $ prime ) < $ N ) return ; primeSum ( 0 , $ N , $ S , 0 ) ; } $ S = 54 ; $ N = 2 ; $ P = 3 ; allPrime ( $ N , $ S , $ P ) ; ? >"}
{"text":"Find 2 ^ ( 2 ^ A ) % B | Function to return 2 ^ ( 2 ^ A ) % B ; $Base case , 2 ^ ( 2 ^ 1 ) % B = 4 % B ; Driver code ; Print 2 ^ ( 2 ^ $A ) % $B","code":"< ? php function F ( $ A , $ B ) { if ( $ A == 1 ) return ( 4 % $ B ) ; else { $ temp = F ( $ A - 1 , $ B ) ; return ( $ temp * $ temp ) % $ B ; } } $ A = 25 ; $ B = 50 ; echo F ( $ A , $ B ) ;"}
{"text":"Sum of i * countDigits ( i ) ^ 2 for all i in range [ L , R ] | PHP implementation of the approach ; Function to return the required sum ; If range is valid ; Sum of AP ; Driver code","code":"< ? php $ MOD = 1000000007 ; function rangeSum ( $ l , $ r ) { global $ MOD ; $ a = 1 ; $ b = 9 ; $ res = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ L = max ( $ l , $ a ) ; $ R = min ( $ r , $ b ) ; if ( $ L <= $ R ) { $ sum = ( $ L + $ R ) * ( $ R - $ L + 1 ) \/ 2 ; $ res += ( $ i * $ i ) * ( $ sum % $ MOD ) ; $ res %= $ MOD ; } $ a = $ a * 10 ; $ b = $ b * 10 + 9 ; } return $ res ; } $ l = 98 ; $ r = 102 ; echo rangeSum ( $ l , $ r ) ; ? >"}
{"text":"Generate a random permutation of elements from range [ L , R ] ( Divide and Conquer ) | To store the random permutation ; Utility function to print the generated permutation ; Function to return a random number between x and y ; Recursive function to generate the random permutation ; Base condition ; Random number returned from the function ; Inserting random number in vector ; Recursion call for [ l , n - 1 ] ; Recursion call for [ n + 1 , r ] ; Driver code ; Generate permutation ; Print the generated permutation","code":"< ? php $ permutation = array ( ) ; function printPermutation ( ) { global $ permutation ; foreach ( $ permutation as $ i ) echo $ i . \" \" ; } function give_random_number ( $ l , $ r ) { $ x = rand ( ) % ( $ r - $ l + 1 ) + $ l ; return $ x ; } function generate_random_permutation ( $ l , $ r ) { global $ permutation ; if ( $ l > $ r ) return ; $ n = give_random_number ( $ l , $ r ) ; array_push ( $ permutation , $ n ) ; generate_random_permutation ( $ l , $ n - 1 ) ; generate_random_permutation ( $ n + 1 , $ r ) ; } $ l = 5 ; $ r = 15 ; generate_random_permutation ( $ l , $ r ) ; printPermutation ( ) ; ? >"}
{"text":"Minimum number N such that total set bits of all numbers from 1 to N is at | Function to count sum of set bits of all numbers till N ; Function to find the minimum number ; Binary search for the lowest number ; Find mid number ; Check if it is atleast x ; Driver Code","code":"< ? php function getSetBitsFromOneToN ( $ N ) { $ two = 2 ; $ ans = 0 ; $ n = $ N ; while ( $ n ) { $ ans += ( int ) ( $ N \/ $ two ) * ( $ two >> 1 ) ; if ( ( $ N & ( $ two - 1 ) ) > ( $ two >> 1 ) - 1 ) $ ans += ( $ N & ( $ two - 1 ) ) - ( $ two >> 1 ) + 1 ; $ two <<= 1 ; $ n >>= 1 ; } return $ ans ; } function findMinimum ( $ x ) { $ low = 0 ; $ high = 100000 ; $ ans = $ high ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( getSetBitsFromOneToN ( $ mid ) >= $ x ) { $ ans = min ( $ ans , $ mid ) ; $ high = $ mid - 1 ; } else $ low = $ mid + 1 ; } return $ ans ; } $ x = 20 ; echo findMinimum ( $ x ) ; ? >"}
{"text":"Numbers whose factorials end with n zeros | Function to calculate trailing zeros ; binary search for first number with n trailing zeros ; Print all numbers after low with n trailing zeros . ; Print result ; Driver code","code":"< ? php function trailingZeroes ( $ n ) { $ cnt = 0 ; while ( $ n > 0 ) { $ n = intval ( $ n \/ 5 ) ; $ cnt += $ n ; } return $ cnt ; } function binarySearch ( $ n ) { $ low = 0 ; while ( $ low < $ high ) { $ mid = intval ( ( $ low + $ high ) \/ 2 ) ; $ count = trailingZeroes ( $ mid ) ; if ( $ count < $ n ) $ low = $ mid + 1 ; else $ high = $ mid ; } $ result = array ( ) ; while ( trailingZeroes ( $ low ) == $ n ) { array_push ( $ result , $ low ) ; $ low ++ ; } for ( $ i = 0 ; $ i < sizeof ( $ result ) ; $ i ++ ) echo $ result [ $ i ] . \" \u2581 \" ; } $ n = 2 ; binarySearch ( $ n ) ; ? >"}
{"text":"Number of days after which tank will become empty | Method returns minimum number of days after which tank will become empty ; Driver code","code":"< ? php function minDaysToEmpty ( $ C , $ l ) { if ( $ l >= $ C ) return $ C ; $ eq_root = ( int ) sqrt ( 1 + 8 * ( $ C - $ l ) - 1 ) \/ 2 ; return ceil ( $ eq_root ) + $ l ; } echo minDaysToEmpty ( 5 , 2 ) , \" STRNEWLINE \" ; echo minDaysToEmpty ( 6514683 , 4965 ) , \" \" ; ? >"}
{"text":"K | Program to find kth element from two sorted arrays ; Driver Code","code":"< ? php function kth ( $ arr1 , $ arr2 , $ m , $ n , $ k ) { $ sorted1 [ $ m + $ n ] = 0 ; $ i = 0 ; $ j = 0 ; $ d = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; else $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ m ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n ) $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; return $ sorted1 [ $ k - 1 ] ; } $ arr1 = array ( 2 , 3 , 6 , 7 , 9 ) ; $ arr2 = array ( 1 , 4 , 8 , 10 ) ; $ k = 5 ; echo kth ( $ arr1 , $ arr2 , 5 , 4 , $ k ) ; ? >"}
{"text":"Minimum difference between adjacent elements of array which contain elements from each row of a matrix | PHP program to find the minimum absolute difference between any of the adjacent elements of an array which is created by picking one element from each row of the matrix . ; Return smallest element greater than or equal to the current element . ; Return the minimum absolute difference adjacent elements of array ; Sort each row of the matrix . ; For each matrix element ; Search smallest element in the next row which is greater than or equal to the current element ; largest element which is smaller than the current element in the next row must be just before smallest element which is greater than or equal to the current element because rows are sorted . ; Driver Code","code":"< ? php $ R = 2 ; $ C = 2 ; function bsearch ( $ low , $ high , $ n , $ arr ) { $ mid = ( $ low + $ high ) \/ 2 ; if ( $ low <= $ high ) { if ( $ arr [ $ mid ] < $ n ) return bsearch ( $ mid + 1 , $ high , $ n , $ arr ) ; return bsearch ( $ low , $ mid - 1 , $ n , $ arr ) ; } return $ low ; } function mindiff ( $ arr , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) sort ( $ arr ) ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ p = bsearch ( 0 , $ m - 1 , $ arr [ $ i ] [ $ j ] , $ arr [ $ i + 1 ] ) ; $ ans = min ( $ ans , abs ( $ arr [ $ i + 1 ] [ $ p ] - $ arr [ $ i ] [ $ j ] ) ) ; if ( $ p - 1 >= 0 ) $ ans = min ( $ ans , abs ( $ arr [ $ i + 1 ] [ $ p - 1 ] - $ arr [ $ i ] [ $ j ] ) ) ; } } return $ ans ; } $ m = array ( 8 , 5 , 6 , 8 ) ; echo mindiff ( $ m , $ R , $ C ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find bitonic point in given bitonic sequence | Function to find bitonic point using binary search ; base condition to check if arr [ mid ] is bitonic point or not ; We assume that sequence is bitonic . We go to right subarray if middle point is part of increasing subsequence . Else we go to left subarray . ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ left , $ right ) { if ( $ left <= $ right ) { $ mid = ( $ left + $ right ) \/ 2 ; if ( $ arr [ $ mid - 1 ] < $ arr [ $ mid ] && $ arr [ $ mid ] > $ arr [ $ mid + 1 ] ) return $ mid ; if ( $ arr [ $ mid ] < $ arr [ $ mid + 1 ] ) return binarySearch ( $ arr , $ mid + 1 , $ right ) ; else return binarySearch ( $ arr , $ left , $ mid - 1 ) ; } return -1 ; } $ arr = array ( 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 ) ; $ n = sizeof ( $ arr ) ; $ index = binarySearch ( $ arr , 1 , $ n - 2 ) ; if ( $ index != -1 ) echo $ arr [ $ index ] ; ? >"}
{"text":"Find the only repeating element in a sorted array of size n | Returns index of second appearance of a repeating element . The function assumes that array elements are in range from 1 to n - 1. ; low = 0 , high = n - 1 ; ; Check if the mid element is the repeating one ; If mid element is not at its position that means the repeated element is in left ; If mid is at proper position then repeated one is in right . ; Driver code","code":"< ? php function findRepeatingElement ( $ arr , $ low , $ high ) { if ( $ low > $ high ) return -1 ; $ mid = floor ( ( $ low + $ high ) \/ 2 ) ; if ( $ arr [ $ mid ] != $ mid + 1 ) { if ( $ mid > 0 && $ arr [ $ mid ] == $ arr [ $ mid - 1 ] ) return $ mid ; return findRepeatingElement ( $ arr , $ low , $ mid - 1 ) ; } return findRepeatingElement ( $ arr , $ mid + 1 , $ high ) ; } $ arr = array ( 1 , 2 , 3 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; $ index = findRepeatingElement ( $ arr , 0 , $ n - 1 ) ; if ( $ index != -1 ) echo $ arr [ $ index ] ; ? >"}
{"text":"Find cubic root of a number | Returns the absolute value of n - mid * mid * mid ; Returns cube root of a no n ; Set start and end for binary search ; Set precision ; If error is less than e then mid is our answer so return mid ; If mid * mid * mid is greater than n set end = mid ; If mid * mid * mid is less than n set start = mid ; Driver Code","code":"< ? php function diff ( $ n , $ mid ) { if ( $ n > ( $ mid * $ mid * $ mid ) ) return ( $ n - ( $ mid * $ mid * $ mid ) ) ; else return ( ( $ mid * $ mid * $ mid ) - $ n ) ; } function cubicRoot ( $ n ) { $ start = 0 ; $ end = $ n ; $ e = 0.0000001 ; while ( true ) { $ mid = ( ( $ start + $ end ) \/ 2 ) ; $ error = diff ( $ n , $ mid ) ; if ( $ error <= $ e ) return $ mid ; if ( ( $ mid * $ mid * $ mid ) > $ n ) $ end = $ mid ; else $ start = $ mid ; } } $ n = 3 ; echo ( \" Cubic \u2581 root \u2581 of \u2581 $ n \u2581 is \u2581 \" ) ; echo ( cubicRoot ( $ n ) ) ; ? >"}
{"text":"Square root of an integer | Returns floor of square root of x ; Base cases ; Starting from 1 , try all numbers until i * i is greater than or equal to x . ; Driver Code","code":"< ? php function floorSqrt ( $ x ) { if ( $ x == 0 $ x == 1 ) return $ x ; $ i = 1 ; $ result = 1 ; while ( $ result <= $ x ) { $ i ++ ; $ result = $ i * $ i ; } return $ i - 1 ; } $ x = 11 ; echo floorSqrt ( $ x ) , \" STRNEWLINE \" ; ? >"}
{"text":"Sum of internal angles of a Polygon | Function to return the sum of internal angles of an n - sided polygon ; Driver code","code":"< ? php function sumOfInternalAngles ( $ n ) { if ( $ n < 3 ) return 0 ; return ( ( $ n - 2 ) * 180 ) ; } $ n = 5 ; echo ( sumOfInternalAngles ( $ n ) ) ; ? >"}
{"text":"Find the diagonal of the Cube | Function to find length of diagonal of cube ; Formula to Find length of diagonal of cube ; Driver code ; Function call","code":"< ? php function diagonal_length ( $ a ) { $ L ; $ L = $ a * sqrt ( 3 ) ; return $ L ; } $ a = 5 ; echo diagonal_length ( $ a ) ; ? >"}
{"text":"Find area of the larger circle when radius of the smaller circle and difference in the area is given | PHP implementation of the approach ; Function to return the area of the bigger circle ; Find the radius of the bigger circle ; Calculate the area of the bigger circle ; Driver Code","code":"< ? php const PI = 3.14 ; function find_area ( $ r , $ d ) { $ R = $ d \/ PI ; $ R += pow ( $ r , 2 ) ; $ R = sqrt ( $ R ) ; $ area = PI * pow ( $ R , 2 ) ; return $ area ; } $ r = 4 ; $ d = 5 ; echo ( find_area ( $ r , $ d ) ) ; ? >"}
{"text":"Check whether Quadrilateral is valid or not if angles are given | Function to check if a given quadrilateral is valid or not ; Check condition ; Driver Code","code":"< ? php function Valid ( $ a , $ b , $ c , $ d ) { if ( $ a + $ b + $ c + $ d == 360 ) return true ; return false ; } $ a = 80 ; $ b = 70 ; $ c = 100 ; $ d = 110 ; if ( Valid ( $ a , $ b , $ c , $ d ) ) echo ( \" Valid \u2581 quadrilateral \" ) ; else echo ( \" Invalid \u2581 quadrilateral \" ) ; ? >"}
{"text":"Number of common tangents between two circles if their centers and radius is given | PHP program to find the number of common tangents between the two circles ; Driver code","code":"< ? php function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; } $ x1 = -10 ; $ y1 = 8 ; $ x2 = 14 ; $ y2 = -24 ; $ r1 = 30 ; $ r2 = 10 ; $ t = circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) ; if ( $ t == 1 ) echo \" There \u2581 are \u2581 3 \u2581 common \u2581 tangents \" , \" \u2581 between \u2581 the \u2581 circles . \" ; else if ( $ t < 0 ) echo \" There \u2581 are \u2581 4 \u2581 common \u2581 tangents \" , \" \u2581 between \u2581 the \u2581 circles . \" ; else echo \" There \u2581 are \u2581 2 \u2581 common \u2581 tangents \" , \" \u2581 between \u2581 the \u2581 circles . \" ; ? >"}
{"text":"Ratio of the distance between the centers of the circles and the point of intersection of two transverse common tangents to the circles | PHP program to find the ratio of the distance between the centres of the circles and the point of intersection of two transverse common tangents to the circles which do not touch each other ; Function to find the ratio ; Driver code","code":"< ? php function GCD ( $ a , $ b ) { return ( $ b != 0 ? GCD ( $ b , $ a % $ b ) : $ a ) ; } function ratiotang ( $ r1 , $ r2 ) { echo \" The \u2581 ratio \u2581 is \u2581 \" , $ r1 \/ GCD ( $ r1 , $ r2 ) , \" : \" , $ r2 \/ GCD ( $ r1 , $ r2 ) ; } $ r1 = 4 ; $ r2 = 8 ; ratiotang ( $ r1 , $ r2 ) ; ? >"}
{"text":"Program to find the number of region in Planar Graph | Function to return the number of regions in a Planar Graph ; Driver code","code":"< ? php function Regions ( $ Vertices , $ Edges ) { $ R = $ Edges + 2 - $ Vertices ; return $ R ; } $ V = 5 ; $ E = 7 ; echo ( Regions ( $ V , $ E ) ) ; ? >"}
{"text":"Ratio of the distance between the centers of the circles and the point of intersection of two direct common tangents to the circles | Function to find the GCD ; Function to find the ratio ; Driver code","code":"< ? php function GCD ( $ a , $ b ) { return ( $ b != 0 ? GCD ( $ b , $ a % $ b ) : $ a ) ; } function ratiotang ( $ r1 , $ r2 ) { echo \" The \u2581 ratio \u2581 is \u2581 \" , $ r1 \/ GCD ( $ r1 , $ r2 ) , \" \u2581 : \u2581 \" , $ r2 \/ GCD ( $ r1 , $ r2 ) ; } $ r1 = 4 ; $ r2 = 6 ; ratiotang ( $ r1 , $ r2 ) ; ? >"}
{"text":"Length of the transverse common tangent between the two non intersecting circles | Function to find the length of the transverse common tangent ; Driver code","code":"< ? php function lengthOfTangent ( $ r1 , $ r2 , $ d ) { echo \" The \u2581 length \u2581 of \u2581 the \u2581 transverse \u2581 common \u2581 tangent \u2581 is \u2581 \" , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 + $ r2 ) , 2 ) ) ; } $ r1 = 4 ; $ r2 = 6 ; $ d = 12 ; lengthOfTangent ( $ r1 , $ r2 , $ d ) ; ? >"}
{"text":"Area of plot remaining at the end | Function to return the area of the remaining plot ; Continue while plot has positive area and there are persons left ; If length > breadth then subtract breadth from length ; Else subtract length from breadth ; Driver code","code":"< ? php function remainingArea ( $ N , $ M , $ K ) { while ( $ K -- && $ N && $ M ) { if ( $ N > $ M ) $ N = $ N - $ M ; else $ M = $ M - $ N ; } if ( $ N > 0 && $ M > 0 ) return $ N * $ M ; else return 0 ; } $ N = 5 ; $ M = 3 ; $ K = 2 ; echo remainingArea ( $ N , $ M , $ K ) ; ? >"}
{"text":"Length of the direct common tangent between two externally touching circles | Function to find the length of the direct common tangent ; Driver code","code":"< ? php function lengtang ( $ r1 , $ r2 ) { echo \" The \u2581 length \u2581 of \u2581 the \u2581 \" , \" direct \u2581 common \u2581 tangent \u2581 is \u2581 \" , 2 * sqrt ( $ r1 * $ r2 ) ; } $ r1 = 5 ; $ r2 = 9 ; lengtang ( $ r1 , $ r2 ) ; ? >"}
{"text":"Shortest distance between a point and a circle | Function to find the shortest distance ; Driver code","code":"< ? php function dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) { echo \" The \u2581 shortest \u2581 distance \u2581 between \u2581 a \u2581 point \u2581 and \u2581 a \u2581 circle \u2581 is \u2581 \" , sqrt ( ( pow ( ( $ x2 - $ x1 ) , 2 ) ) + ( pow ( ( $ y2 - $ y1 ) , 2 ) ) ) - $ r ; } $ x1 = 4 ; $ y1 = 6 ; $ x2 = 35 ; $ y2 = 42 ; $ r = 5 ; dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) ; ? >"}
{"text":"Distance between two parallel lines | Function to find the distance between parallel lines ; Driver Code","code":"< ? php function dist ( $ m , $ b1 , $ b2 ) { $ d = abs ( $ b2 - $ b1 ) \/ ( ( $ m * $ m ) - 1 ) ; return $ d ; } $ m = 2 ; $ b1 = 4 ; $ b2 = 3 ; echo dist ( $ m , $ b1 , $ b2 ) ; ? >"}
{"text":"Length of the normal from origin on a straight line whose intercepts are given | Function to find the normal of the straight line ; Length of the normal ; Driver code","code":"< ? php function normal ( $ m , $ n ) { $ N = ( abs ( $ m ) * abs ( $ n ) ) \/ sqrt ( ( abs ( $ m ) * abs ( $ m ) ) + ( abs ( $ n ) * abs ( $ n ) ) ) ; return $ N ; } $ m = -5 ; $ n = 3 ; echo normal ( $ m , $ n ) ; ? >"}
{"text":"Check if it is possible to create a polygon with given n sides | Function that returns true if it is possible to form a polygon with the given sides ; Sum stores the sum of all the sides and maxS stores the length of the largest side ; If the length of the largest side is less than the sum of the other remaining sides ; Driver code","code":"< ? php function isPossible ( $ a , $ n ) { $ sum = 0 ; $ maxS = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; $ maxS = max ( $ a [ $ i ] , $ maxS ) ; } if ( ( $ sum - $ maxS ) > $ maxS ) return true ; return false ; } $ a = array ( 2 , 3 , 4 ) ; $ n = count ( $ a ) ; if ( isPossible ( $ a , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find the area of the shaded region formed by the intersection of four semicircles in a square | Function to return the area of the shaded region ; Area of the square ; Area of the semicircle ; There are 4 semicircles shadedArea = Area of 4 semicircles - Area of square ; Driver code","code":"< ? php function findAreaShaded ( $ a ) { $ sqArea = $ a * $ a ; $ semiCircleArea = ( 3.14 * ( $ a * $ a ) \/ 8 ) ; $ ShadedArea = 4 * $ semiCircleArea - $ sqArea ; return $ ShadedArea ; } $ a = 10 ; echo findAreaShaded ( $ a ) ; ? >"}
{"text":"Number of steps required to reach point ( x , y ) from ( 0 , 0 ) using zig | Function to return the required position ; Driver Code","code":"< ? php function countSteps ( $ x , $ y ) { if ( $ x < $ y ) { return $ x + $ y + 2 * ( ( $ y - $ x ) \/ 2 ) ; } else { return $ x + $ y + 2 * ( ( ( $ x - $ y ) + 1 ) \/ 2 ) ; } } $ x = 4 ; $ y = 3 ; echo ( countSteps ( $ x , $ y ) ) ; ? >"}
{"text":"Find whether only two parallel lines contain all coordinates points or not | Find if slope is good with only two intercept ; if set of lines have only two distinct intercept ; Function to check if required solution exist ; check the result by processing the slope by starting three points ; Driver code","code":"< ? php function isSlopeGood ( $ slope , $ arr , $ n ) { $ setOfLines = array_fill ( 0 , max ( $ arr ) * $ n , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ setOfLines [ $ arr [ $ i ] - $ slope * $ i ] = 1 ; $ setOfLines = array_unique ( $ setOfLines ) ; return ( count ( $ setOfLines ) == 2 ) ; } function checkForParallel ( $ arr , $ n ) { $ slope1 = isSlopeGood ( $ arr [ 1 ] - $ arr [ 0 ] , $ arr , $ n ) ; $ slope2 = isSlopeGood ( $ arr [ 2 ] - $ arr [ 1 ] , $ arr , $ n ) ; $ slope3 = isSlopeGood ( ( int ) ( ( $ arr [ 2 ] - $ arr [ 0 ] ) \/ 2 ) , $ arr , $ n ) ; return ( $ slope1 $ slope2 $ slope3 ) ; } $ arr = array ( 1 , 6 , 3 , 8 , 5 ) ; $ n = count ( $ arr ) ; echo ( int ) checkForParallel ( $ arr , $ n ) . \" \" ; ? >"}
{"text":"Check whether the point ( x , y ) lies on a given line | Function that return true if the given point lies on the given line ; If ( x , y ) satisfies the equation of the line ; Driver code","code":"< ? php function pointIsOnLine ( $ m , $ c , $ x , $ y ) { if ( $ y == ( ( $ m * $ x ) + $ c ) ) return true ; return false ; } $ m = 3 ; $ c = 2 ; $ x = 1 ; $ y = 5 ; if ( pointIsOnLine ( $ m , $ c , $ x , $ y ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Biggest Reuleaux Triangle inscribed within a square which is inscribed within an ellipse | Function to find the biggest reuleaux triangle ; length of the axes cannot be negative ; height of the reuleaux triangle ; area of the reuleaux triangle ; Driver code","code":"< ? php function Area ( $ a , $ b ) { if ( $ a < 0 && $ b < 0 ) return -1 ; $ h = sqrt ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) \/ ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; } $ a = 5 ; $ b = 4 ; echo round ( Area ( $ a , $ b ) , 7 ) ; ? >"}
{"text":"Maximum given sized rectangles that can be cut out of a sheet of paper | Function to return the maximum rectangles possible ; Cut rectangles horizontally if possible ; One rectangle is a single cell ; Total rectangles = total cells ; Cut rectangles vertically if possible ; Return the maximum possible rectangles ; Driver code","code":"< ? php function maxRectangles ( $ L , $ B , $ l , $ b ) { $ horizontal = 0 ; $ vertical = 0 ; if ( $ l <= $ L && $ b <= $ B ) { $ columns = ( int ) ( $ B \/ $ b ) ; $ rows = ( int ) ( $ L \/ $ l ) ; $ horizontal = $ rows * $ columns ; } if ( $ l <= $ B && $ b <= $ L ) { $ columns = ( int ) ( $ L \/ $ b ) ; $ rows = ( int ) ( $ B \/ $ l ) ; $ vertical = $ rows * $ columns ; } return max ( $ horizontal , $ vertical ) ; } $ L = 10 ; $ B = 7 ; $ l = 4 ; $ b = 3 ; print ( maxRectangles ( $ L , $ B , $ l , $ b ) ) ; ? >"}
{"text":"Largest right circular cone that can be inscribed within a sphere which is inscribed within a cube | Function to find the biggest right circular cone ; side cannot be negative ; radius of right circular cone ; height of right circular cone ; volume of right circular cone ; Driver code","code":"< ? php function cone ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a * sqrt ( 2 ) ) \/ 3 ; $ h = ( 2 * $ a ) \/ 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; } $ a = 5 ; echo round ( cone ( $ a ) , 4 ) ; ? >"}
{"text":"Biggest Reuleaux Triangle inscribed within a square which is inscribed within a hexagon | Function to find the biggest reuleaux triangle ; side cannot be negative ; height of the reuleaux triangle ; area of the reuleaux triangle ; Driver code","code":"< ? php function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ h = 1.268 * $ a ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; } $ a = 5 ; echo round ( Area ( $ a ) , 4 ) ; ? >"}
{"text":"Biggest Reuleaux Triangle inscirbed within a square inscribed in a semicircle | Function to find the biggest reuleaux triangle ; radius cannot be negative ; height of the reuleaux triangle ; area of the reuleaux triangle ; Driver code","code":"< ? php function Area ( $ r ) { if ( $ r < 0 ) return -1 ; $ x = ( 2 * $ r ) \/ sqrt ( 5 ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; } $ r = 5 ; echo Area ( $ r ) ; ? >"}
{"text":"Biggest Reuleaux Triangle inscribed within a Square inscribed in an equilateral triangle | Function to find the biggest reuleaux triangle ; side cannot be negative ; height of the reuleaux triangle ; area of the reuleaux triangle ; Driver code","code":"< ? php function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; } $ a = 5 ; echo Area ( $ a ) . \" STRNEWLINE \" ;"}
{"text":"Program for Area Of Square after N | Function to calculate area of square after given number of folds ; Driver Code","code":"< ? php function areaSquare ( $ side , $ fold ) { $ area = $ side * $ side ; return $ area * 1.0 \/ pow ( 2 , $ fold ) ; } $ side = 4 ; $ fold = 2 ; echo areaSquare ( $ side , $ fold ) ; ? >"}
{"text":"Biggest Reuleaux Triangle within a Square which is inscribed within a Circle | Function to find the Area of the Reuleaux triangle ; radius cannot be negative ; Area of the Reuleaux triangle ; Driver code","code":"< ? php function ReuleauxArea ( $ r ) { if ( $ r < 0 ) return -1 ; $ A = 0.70477 * 2 * pow ( $ r , 2 ) ; return $ A ; } $ r = 6 ; echo ReuleauxArea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text":"Largest right circular cylinder that can be inscribed within a cone which is in turn inscribed within a cube | Function to find the biggest right circular cylinder ; side cannot be negative ; radius of right circular cylinder ; height of right circular cylinder ; volume of right circular cylinder ; Driver code","code":"< ? php function cyl ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( 2 * $ a * sqrt ( 2 ) ) \/ 3 ; $ h = ( 2 * $ a ) \/ 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; } $ a = 5 ; echo cyl ( $ a ) ; ? >"}
{"text":"Biggest Reuleaux Triangle within a Square which is inscribed within a Right angle Triangle | Function to find the biggest reuleaux triangle ; the height or base or hypotenuse cannot be negative ; height of the reuleaux triangle ; area of the reuleaux triangle ; Driver code","code":"< ? php function Area ( $ l , $ b , $ h ) { if ( $ l < 0 or $ b < 0 or $ h < 0 ) return -1 ; $ x = ( $ l * $ b ) \/ ( $ l + $ b ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; } $ l = 5 ; $ b = 12 ; $ h = 13 ; echo Area ( $ l , $ b , $ h ) ; ? >"}
{"text":"Largest square that can be inscribed within a hexagon which is inscribed within an equilateral triangle | Function to find the side of the square ; Side cannot be negative ; side of the square ; Driver code","code":"< ? php function squareSide ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.423 * $ a ; return $ x ; } $ a = 8 ; echo squareSide ( $ a ) ; ? >"}
{"text":"Check if it is possible to draw a straight line with the given direction cosines | Function that returns true if a straight line is possible ; Driver code","code":"< ? php function isPossible ( $ x , $ y , $ z ) { $ a = round ( $ x * $ x + $ y * $ y + $ z * $ z ) ; if ( ceil ( $ a ) == 1 && floor ( $ a ) == 1 ) return true ; return false ; } $ l = 0.70710678 ; $ m = 0.5 ; $ n = 0.5 ; if ( isPossible ( $ l , $ m , $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ;"}
{"text":"Length of Diagonal of a n | Function to find the diagonal of a regular polygon ; Side and side length cannot be negative ; diagonal degree converted to radians ; Driver code","code":"< ? php function polydiagonal ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return 2 * $ a * sin ( ( ( ( $ n - 2 ) * 180 ) \/ ( 2 * $ n ) ) * 3.14159 \/ 180 ) ; } $ a = 9 ; $ n = 10 ; echo polydiagonal ( $ n , $ a ) ; ? >"}
{"text":"Diagonal of a Regular Decagon | Function to return the diagonal of a regular decagon ; Side cannot be negative ; Length of the diagonal ; Driver code","code":"< ? php function decdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.902 * $ a ; return $ d ; } $ a = 9 ; echo decdiagonal ( $ a ) ; ? >"}
{"text":"Diagonal of a Regular Heptagon | Function to return the diagonal of a regular heptagon ; Side cannot be negative ; Length of the diagonal ; Driver code","code":"< ? php function heptdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.802 * $ a ; return $ d ; } $ a = 6 ; echo heptdiagonal ( $ a ) ;"}
{"text":"Diagonal of a Regular Hexagon | Function to find the diagonal of a regular hexagon ; Side cannot be negative ; Length of the diagonal ; Driver code","code":"< ? php function hexDiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.73 * $ a ; return $ d ; } $ a = 9 ; echo hexDiagonal ( $ a ) , \" STRNEWLINE \" ; ? >"}
{"text":"Area of Reuleaux Triangle | Function to find the Area of the Reuleaux triangle ; Side cannot be negative ; Area of the Reuleaux triangle ; Driver code","code":"< ? php function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; } $ a = 6 ; echo ReuleauxArea ( $ a ) ;"}
{"text":"Largest Square that can be inscribed within a hexagon | Function to find the area of the square ; Side cannot be negative ; Area of the square ; Driver code","code":"< ? php function squareArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( 1.268 , 2 ) * pow ( $ a , 2 ) ; return $ area ; } $ a = 6 ; echo squareArea ( $ a ) , \" STRNEWLINE \" ; ? >"}
{"text":"Volume of cube using its space diagonal | Function to calculate Volume ; Formula to find Volume ; space diagonal of Cube","code":"< ? php function CubeVolume ( $ d ) { $ Volume ; $ Volume = ( sqrt ( 3 ) * pow ( $ d , 3 ) ) \/ 9 ; return $ Volume ; } $ d = 5 ; echo \" Volume \u2581 of \u2581 Cube : \u2581 \" , CubeVolume ( $ d ) ; ? >"}
{"text":"Perimeter and Area of Varignon 's Parallelogram | Function to find the perimeter ; Function to find the area ; Driver code","code":"< ? php function per ( $ a , $ b ) { return ( $ a + $ b ) ; } function area ( $ s ) { return ( $ s \/ 2 ) ; } $ a = 7 ; $ b = 8 ; $ s = 10 ; echo ( per ( $ a , $ b ) \" \" ) ; echo \" STRNEWLINE \" ; echo ( area ( $ s ) ) ; ? >"}
{"text":"Area of a leaf inside a square | PHP program to find the area of leaf inside a square ; Function to find area of leaf ; Driver code","code":"< ? php $ PI = 3.14159265 ; function area_leaf ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI \/ 2 - 1 ) ) ; } $ a = 7 ; echo ( area_leaf ( $ a ) ) ; ? >"}
{"text":"Length of rope tied around three equal circles touching each other | PHP program to find the length of rope ; Function to find the length of rope ; Driver code","code":"< ? php $ PI = 3.14159265 ; function length_rope ( $ r ) { global $ PI ; return ( ( 2 * $ PI * $ r ) + 6 * $ r ) ; } $ r = 7 ; echo ( length_rope ( $ r ) ) ; ? >"}
{"text":"Area of Incircle of a Right Angled Triangle | PHP program to find the area of inscribed circle of right angled triangle ; Function to find area of inscribed circle ; Driver code","code":"< ? php $ PI = 3.14159265 ; function area_inscribed ( $ P , $ B , $ H ) { global $ PI ; return ( ( $ P + $ B - $ H ) * ( $ P + $ B - $ H ) * ( $ PI \/ 4 ) ) ; } $ P = 3 ; $ B = 4 ; $ H = 5 ; echo ( area_inscribed ( $ P , $ B , $ H ) ) ; ? >"}
{"text":"Area of Circumcircle of a Right Angled Triangle | PHP program to find the area of Cicumscribed circle of right angled triangle ; Function to find area of circumscribed circle ; Driver code","code":"< ? php $ PI = 3.14159265 ; function area_circumscribed ( $ c ) { global $ PI ; return ( $ c * $ c * ( $ PI \/ 4 ) ) ; } $ c = 8 ; echo ( area_circumscribed ( $ c ) ) ; ? >"}
{"text":"Largest right circular cylinder that can be inscribed within a cone | Function to find the biggest right circular cylinder ; radius and height cannot be negative ; radius of right circular cylinder ; height of right circular cylinder ; volume of right circular cylinder ; Driver code","code":"< ? php function cyl ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = ( int ) ( 2 * $ r ) \/ 3 ; $ H = ( int ) ( 2 * $ h ) \/ 3 ; $ V = 3.14 * pow ( $ R , 2 ) * $ H ; return $ V ; } $ r = 4 ; $ h = 8 ; echo cyl ( $ r , $ h ) ; ? >"}
{"text":"Largest cube that can be inscribed within a right circular cylinder | Function to find the volume of the cube ; height and radius cannot be negative ; volume of the cube ; Driver code","code":"< ? php function cube ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = pow ( $ h , 3 ) ; return $ a ; } $ h = 5 ; $ r = 4 ; echo cube ( $ h , $ r ) ; ? >"}
{"text":"Volume of biggest sphere within a right circular cylinder | Function to find the biggest sphere ; radius and height cannot be negative ; radius of sphere ; Driver code","code":"< ? php function sph ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = $ r ; return $ R ; } $ r = 4 ; $ h = 8 ; echo sph ( $ r , $ h ) ; ? >"}
{"text":"Volume of largest right circular cylinder within a Sphere | Function to find the biggest right circular cylinder ; radius cannot be negative ; volume of cylinder ; Driver code","code":"< ? php function cyl ( $ R ) { if ( $ R < 0 ) return -1 ; $ V = ( 2 * 3.14 * pow ( $ R , 3 ) ) \/ ( 3 * sqrt ( 3 ) ) ; return $ V ; } $ R = 4 ; echo cyl ( $ R ) ; ? >"}
{"text":"Longest rod that can be inserted within a right circular cylinder | Function to find the side of the cube ; height and radius cannot be negative ; length of rod ; Driver code","code":"< ? php function rod ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ l = sqrt ( pow ( $ h , 2 ) + 4 * pow ( $ r , 2 ) ) ; return $ l ; } $ h = 4 ; $ r = 1.5 ; echo rod ( $ h , $ r ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program to calculate the Area and Perimeter of Incircle of an Equilateral Triangle | PHP program to find the area of inscribed circle of equilateral triangle ; function to find area of inscribed circle ; function to find perimeter of inscribed circle ; Driver code","code":"< ? php $ PI = 3.14159265 ; function area_inscribed ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI \/ 12 ) ) ; } function perm_inscribed ( $ a ) { global $ PI ; return ( $ PI * ( $ a \/ sqrt ( 3 ) ) ) ; } $ a = 6 ; echo ( \" Area \u2581 of \u2581 inscribed \u2581 circle \u2581 is \u2581 : \" ) ; echo ( area_inscribed ( $ a ) ) ; echo ( \" Perimeter \u2581 of \u2581 inscribed \u2581 circle \u2581 is \u2581 : \" ) ; echo ( perm_inscribed ( $ a ) ) ; ? >"}
{"text":"Largest cube that can be inscribed within a right circular cone | Function to find the side of the cube ; height and radius cannot be negative ; side of the cube ; Driver code","code":"< ? php function cubeSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = ( $ h * $ r * sqrt ( 2 ) ) \/ ( $ h + sqrt ( 2 ) * $ r ) ; return $ a ; } $ h = 5 ; $ r = 6 ; echo cubeSide ( $ h , $ r ) ; ? >"}
{"text":"Largest right circular cone that can be inscribed within a sphere | Function to find the radius of the cone ; radius cannot be negative ; radius of the cone ; Function to find the height of the cone ; side cannot be negative ; height of the cone ; Driver code","code":"< ? php function coner ( $ R ) { if ( $ R < 0 ) return -1 ; $ r = ( 2 * sqrt ( 2 ) * $ R ) \/ 3 ; return $ r ; } function coneh ( $ R ) { if ( $ R < 0 ) return -1 ; $ h = ( 4 * $ R ) \/ 3 ; return $ h ; } $ R = 10 ; echo ( \" r \u2581 = \u2581 \" ) ; echo coner ( $ R ) ; echo ( \" , \u2581 \" ) ; echo ( \" h \u2581 = \u2581 \" ) ; echo ( coneh ( $ R ) ) ; ? >"}
{"text":"Largest cone that can be inscribed within a cube | Function to find the radius of the cone ; side cannot be negative ; radius of the cone ; Function to find the height of the cone ; side cannot be negative ; height of the cone ; Driver code","code":"< ? php function coneRadius ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = $ a \/ sqrt ( 2 ) ; return $ r ; } function coneHeight ( $ a ) { if ( $ a < 0 ) return -1 ; $ h = $ a ; return $ h ; } $ a = 6 ; echo ( \" r \u2581 = \u2581 \" ) ; echo coneRadius ( $ a ) ; echo ( \" , \u2581 \" ) ; echo ( \" h \u2581 = \u2581 \" ) ; echo ( coneHeight ( $ a ) ) ; ? >"}
{"text":"Largest cube that can be inscribed within the sphere | Function to find the side of the cube ; radius cannot be negative ; side of the cube ; Driver code","code":"< ? php function largestCube ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( float ) ( ( 2 * $ r ) \/ sqrt ( 3 ) ) ; return $ a ; } $ r = 5 ; echo largestCube ( $ r ) ; ? >"}
{"text":"Largest sphere that can be inscribed inside a cube | Function to find the radius of the sphere ; side cannot be negative ; radius of the sphere ; Driver code","code":"< ? php function sphere ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a \/ 2 ) ; return $ r ; } $ a = 5 ; echo sphere ( $ a ) ; ? >"}
{"text":"Minimum Cuts can be made in the Chessboard such that it is not divided into 2 parts | function that calculates the maximum no . of cuts ; Driver Code ; Calling function .","code":"< ? php function numberOfCuts ( $ M , $ N ) { $ result = 0 ; $ result = ( $ M - 1 ) * ( $ N - 1 ) ; return $ result ; } $ M = 4 ; $ N = 4 ; $ Cuts = numberOfCuts ( $ M , $ N ) ; echo \" Maximum \u2581 cuts \u2581 = \u2581 \" , $ Cuts ; ? >"}
{"text":"Find maximum volume of a cuboid from the given perimeter and area | function to return maximum volume ; calculate length ; calculate volume ; return result ; Driver code ; Function call","code":"< ? php function maxVol ( $ P , $ A ) { $ l = ( $ P - sqrt ( $ P * $ P - 24 * $ A ) ) \/ 12 ; $ V = $ l * ( $ A \/ 2.0 - $ l * ( $ P \/ 4.0 - $ l ) ) ; return $ V ; } $ P = 20 ; $ A = 16 ; echo maxVol ( $ P , $ A ) ; ? >"}
{"text":"Program to calculate area and perimeter of a rhombus whose diagonals are given | calculate area and perimeter of a rhombus ; Driver code","code":"< ? php function rhombusAreaPeri ( $ d1 , $ d2 ) { $ area = ( $ d1 * $ d2 ) \/ 2 ; $ perimeter = 2 * sqrt ( pow ( $ d1 , 2 ) + pow ( $ d2 , 2 ) ) ; echo \" The \u2581 area \u2581 of \u2581 rhombus \u2581 with \u2581 diagonals \u2581 \" . $ d1 . \" \u2581 and \u2581 \" . $ d2 . \" \u2581 is \u2581 \" . $ area . \" . \" . \" STRNEWLINE \" ; echo \" The \u2581 perimeter \u2581 of \u2581 rhombus \u2581 with \u2581 diagonals \u2581 \" . $ d1 . \" \u2581 and \u2581 \" . $ d2 . \" \u2581 is \u2581 \" . $ perimeter . \" . \" . \" STRNEWLINE \" ; } $ d1 = 2 ; $ d2 = 4 ; rhombusAreaPeri ( $ d1 , $ d2 ) ; ? >"}
{"text":"Area of decagon inscribed within the circle | Function to find the area of the decagon ; radius cannot be negative ; area of the decagon ; Driver code","code":"< ? php function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = ( 5 * pow ( $ r , 2 ) * ( 3 - sqrt ( 5 ) ) * ( sqrt ( 5 ) + ( 2 * sqrt ( 5 ) ) ) ) \/ 4 ; return $ area ; } $ r = 8 ; echo area ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text":"Maximum area of rectangle possible with given perimeter | Function to find max area ; return area ; Driver code","code":"< ? php function maxArea ( $ perimeter ) { $ length = ( int ) ceil ( $ perimeter \/ 4 ) ; $ breadth = ( int ) floor ( $ perimeter \/ 4 ) ; return ( $ length * $ breadth ) ; } $ n = 38 ; echo \" Maximum \u2581 Area \u2581 = \u2581 \" , maxArea ( $ n ) ; ? >"}
{"text":"Find the foot of perpendicular of a point in a 3 D plane | Function to find foot of perpendicular ; Driver Code ; function call","code":"< ? php function foot ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) \/ ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; echo \" x2 = \" \u2581 . \u2581 round ( $ x2 , \u2581 1 ) ; STRNEWLINE TABSYMBOL echo \u2581 \" y2 = \" \u2581 . \u2581 round ( $ y2 , \u2581 1 ) ; STRNEWLINE TABSYMBOL echo \u2581 \" z2 = \" } $ a = 1 ; $ b = -2 ; $ c = 0 ; $ d = 0 ; $ x1 = -1 ; $ y1 = 3 ; $ z1 = 4 ; foot ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) ; ? >"}
{"text":"Minimum squares to evenly cut a rectangle | PHP program to find minimum number of squares to make a given rectangle . ; if we take gcd ( l , w ) , this will be largest possible side for square , hence minimum number of square . ; Number of squares . ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { return $ b ? gcd ( $ b , $ a % $ b ) : $ a ; } function countRectangles ( $ l , $ w ) { $ squareSide = gcd ( $ l , $ w ) ; return ( $ l * $ w ) \/ ( $ squareSide * $ squareSide ) ; } $ l = 4 ; $ w = 6 ; echo countRectangles ( $ l , $ w ) . \" STRNEWLINE \" ; ? >"}
{"text":"Equation of circle from center and radius | Function to find the equation of circle ; Printing result ; Driver code","code":"< ? php function circle_equation ( $ x1 , $ y1 , $ r ) { $ a = -2 * $ x1 ; $ b = -2 * $ y1 ; $ c = ( $ r * $ r ) - ( $ x1 * $ x1 ) - ( $ y1 * $ y1 ) ; echo \" x ^ 2 + ( \" \u2581 . \u2581 $ a \u2581 . \u2581 \" x ) + \" echo \" y ^ 2 \u2581 + \u2581 ( \" . $ b . \" \u2581 y ) \u2581 = \u2581 \" ; echo $ c . \" . \" . \" STRNEWLINE \" ; } $ x1 = 2 ; $ y1 = -3 ; $ r = 8 ; circle_equation ( $ x1 , $ y1 , $ r ) ; ? >"}
{"text":"Program to find the Area and Perimeter of a Semicircle | Function for calculating the area ; Formula for finding the area ; Function for calculating the perimeter ; Formula for finding the perimeter ; Get the radius ; Find the area ; Find the perimeter","code":"< ? php function area ( $ r ) { return ( 0.5 ) * ( 3.14 ) * ( $ r * $ r ) ; } function perimeter ( $ r ) { return ( 3.14 ) * ( $ r ) ; } $ r = 10 ; echo \" The \u2581 Area \u2581 of \u2581 Semicircle : \u2581 \" , area ( $ r ) , \" STRNEWLINE \" ; echo \" The \u2581 Perimeter \u2581 of \u2581 Semicircle : \u2581 \" , perimeter ( $ r ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if the given vectors are at equilibrium or not | Function to check the equilibrium of three vectors ; summing the x coordinates ; summing the y coordinates ; summing the z coordinates ; Checking the condition for equilibrium ; Driver code ; Checking for equilibrium","code":"< ? php function checkEquilibrium ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ resx = $ x1 + $ x2 + $ x3 ; $ resy = $ y1 + $ y2 + $ y3 ; $ resz = $ z1 + $ z2 + $ z3 ; if ( $ resx == 0 and $ resy == 0 and $ resz == 0 ) return true ; else return false ; } $ x1 = -2 ; $ y1 = -7 ; $ z1 = -9 ; $ x2 = 5 ; $ y2 = -14 ; $ z2 = 14 ; $ x3 = -3 ; $ y3 = 21 ; $ z3 = -5 ; if ( checkEquilibrium ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) ) echo \" The \u2581 vectors \u2581 are \u2581 at \u2581 equilibrium . \" ; else echo \" The \u2581 vectors \u2581 are \u2581 not \u2581 at \u2581 equilibrium . \" ; ? >"}
{"text":"Find Tangent at a given point on the curve | function for find Tangent ; differentiate given equation ; check that point on the curve or not ; if differentiate is negative ; differentiate is positive ; differentiate is zero ; declare variable ; call function findTangent","code":"< ? php function findTangent ( $ A , $ x , $ y ) { $ dif = $ A - $ x * 2 ; if ( $ y == ( 2 * $ x - $ x * $ x ) ) { if ( $ dif < 0 ) echo \" y = \" , \u2581 $ dif \u2581 , \u2581 \" x \" ( $ x * $ dif ) + ( $ y ) ; else if ( $ dif > 0 ) echo \" y \u2581 = \u2581 \" , $ dif , \" x + \" , - $ x * $ dif + $ y ; else echo \" Not \u2581 possible \" ; } } $ A = 2 ; $ x = 2 ; $ y = 0 ; findTangent ( $ A , $ x , $ y ) ; ? >"}
{"text":"Find length of Diagonal of Hexagon | Function to find the diagonal of the hexagon ; side cannot be negative ; diagonal of the hexagon ; Driver code","code":"< ? php function hexadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return 2 * $ a ; } $ a = 4 ; echo hexadiagonal ( $ a ) ; ? >"}
{"text":"Program to find the side of the Octagon inscribed within the square | Function to find the side of the octagon ; side cannot be negative ; side of the octagon ; Get he square side ; Find the side length of the square","code":"< ? php function octaside ( $ a ) { if ( $ a < 0 ) return -1 ; $ s = $ a \/ ( sqrt ( 2 ) + 1 ) ; return $ s ; } $ a = 4 ; echo octaside ( $ a ) ; ? >"}
{"text":"Check if it is possible to move from ( 0 , 0 ) to ( x , y ) in N steps | Function to check whether it is possible or not to move from ( 0 , 0 ) to ( x , y ) in exactly n steps ; Driver code","code":"< ? php function Arrive ( $ a , $ b , $ n ) { if ( $ n >= abs ( $ a ) + abs ( $ b ) and ( $ n - ( abs ( $ a ) + abs ( $ b ) ) ) % 2 == 0 ) return true ; return false ; } $ a = 5 ; $ b = 5 ; $ n = 11 ; if ( Arrive ( $ a , $ b , $ n ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text":"Check if it is possible to move from ( a , 0 ) to ( b , 0 ) with given jumps | Function to check if it is possible ; Driver code ; function call","code":"< ? php function Move ( $ a , $ x , $ b ) { if ( ( ( ( $ b - $ a ) % $ x == 0 ) || ( ( $ b - $ a - 1 ) % $ x == 0 ) && $ a + 1 != $ b ) && $ b >= $ a ) return true ; return false ; } $ a = 3 ; $ x = 2 ; $ b = 7 ; if ( Move ( $ a , $ x , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Area of a triangle inscribed in a rectangle which is inscribed in an ellipse | Function to find the area of the triangle ; length of a and b cannot be negative ; area of the triangle ; Driver code","code":"< ? php function area ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = $ a * $ b ; return $ A ; } $ a = 5 ; $ b = 2 ; echo area ( $ a , $ b ) ; ? >"}
{"text":"Circumradius of the rectangle | Function to find the radius of the circumcircle ; the sides cannot be negative ; Radius of the circumcircle ; Return the radius ; Get the sides of the triangle ; Find the radius of the circumcircle","code":"< ? php function findRadiusOfcircumcircle ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ radius = sqrt ( pow ( $ l , 2 ) + pow ( $ b , 2 ) ) \/ 2 ; return $ radius ; } $ l = 4 ; $ b = 3 ; echo findRadiusOfcircumcircle ( $ l , $ b ) ; ? >"}
{"text":"Area of the circumcircle of any triangles with sides given | Function to find the area of the circumcircle ; the sides cannot be negative ; semi - perimeter of the circle ; area of triangle ; area of the circle ; Get the sides of the triangle ; Find and print the area of the circumcircle","code":"< ? php function circlearea ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) \/ 2 ; $ At = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ A = 3.14 * pow ( ( ( $ a * $ b * $ c ) \/ ( 4 * $ At ) ) , 2 ) ; return $ A ; } $ a = 4 ; $ b = 5 ; $ c = 3 ; echo circlearea ( $ a , $ b , $ c ) ; ? >"}
{"text":"Find the altitude and area of an isosceles triangle | function to find the altitude ; return altitude ; function to find the area ; return area ; Driver Code","code":"< ? php function altitude ( $ a , $ b ) { return sqrt ( pow ( $ a , 2 ) - ( pow ( $ b , 2 ) \/ 4 ) ) ; } function area ( $ b , $ h ) { return ( 1 * $ b * $ h ) \/ 2 ; } $ a = 2 ; $ b = 3 ; $ h = altitude ( $ a , $ b ) ; echo \" Altitude = \" \u2581 , \u2581 $ h \u2581 , \u2581 \" , \" echo \" Area \u2581 = \u2581 \" , area ( $ b , $ h ) ; ? >"}
{"text":"Program to find the surface area of the square pyramid | function to find the surface area ; Driver Code ; surface area of the square pyramid","code":"< ? php function surfaceArea ( $ b , $ s ) { return 2 * $ b * $ s + pow ( $ b , 2 ) ; } $ b = 3 ; $ s = 4 ; echo surfaceArea ( $ b , $ s ) ; ? >"}
{"text":"Area of largest triangle that can be inscribed within a rectangle | Function to find the area of the triangle ; a and b cannot be negative ; area of the triangle ; Driver code","code":"< ? php function trianglearea ( $ l , $ b ) { if ( $ l < 0 or $ b < 0 ) return -1 ; $ area = ( $ l * $ b ) \/ 2 ; return $ area ; } $ l = 5 ; $ b = 4 ; echo trianglearea ( $ l , $ b ) ; ? >"}
{"text":"Check if any square ( with one colored cell ) can be divided into two equal parts | function to check if it 's possible to divide the square in two equal parts ; if the painted square is linked anyway to the center of the square then it 's  not possible ; else yes it 's possible ; initialize the size of the square ; initialize the dimension of the painted square","code":"< ? php function halfsquare ( $ n , $ x , $ y ) { $ half = $ n \/ 2 ; if ( ( $ half == $ x $ half == $ x - 1 ) && ( $ half == $ y $ half == $ y - 1 ) ) echo \" NO \" ; else echo \" YES \" ; } $ n = 100 ; $ x = 51 ; $ y = 100 ; halfsquare ( $ n , $ x , $ y ) ; ? >"}
{"text":"Check if it is possible to reach vector B by rotating vector A and adding vector C to it | function to check if vector B is possible from vector A ; if d = 0 , then you need to add nothing to vector A ; for all four quadrants ; initialize all three vector coordinates","code":"< ? php function check ( $ a , $ b , $ p , $ q ) { $ d = $ p * $ p + $ q * $ q ; if ( $ d == 0 ) return ( $ a == 0 && $ b == 0 ) ; else return ( ( $ a * $ p + $ b * $ q ) % $ d == 0 && ( $ b * $ p - $ a * $ q ) % $ d == 0 ) ; } function check1 ( $ a , $ b , $ x , $ y , $ p , $ q ) { if ( check ( $ a - $ x , $ b - $ y , $ p , $ q ) || check ( $ a + $ x , $ b + $ y , $ p , $ q ) || check ( $ a - $ y , $ b + $ x , $ p , $ q ) || check ( $ a + $ y , $ b - $ x , $ p , $ q ) ) return true ; else return false ; } $ a = -4 ; $ b = -2 ; $ x = 0 ; $ y = 0 ; $ p = -2 ; $ q = -1 ; if ( check1 ( $ a , $ b , $ x , $ y , $ p , $ q ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Largest triangle that can be inscribed in an ellipse | Function to find the area of the triangle ; a and b cannot be negative ; area of the triangle ; Driver code","code":"< ? php function trianglearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) \/ ( 4 * $ b ) ; return $ area ; } $ a = 4 ; $ b = 2 ; echo trianglearea ( $ a , $ b ) ; ? >"}
{"text":"Area of the Largest square that can be inscribed in an ellipse | Function to find the area of the square ; a and b cannot be negative ; area of the square ; Driver code","code":"< ? php function squarearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; $ area = 4 * ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) \/ ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; return $ area ; } $ a = 4 ; $ b = 2 ; print ( squarearea ( $ a , $ b ) ) ; ? >"}
{"text":"Largest triangle that can be inscribed in a semicircle | Function to find the area of the triangle ; the radius cannot be negative ; area of the triangle ; Driver code","code":"< ? php function trianglearea ( $ r ) { if ( $ r < 0 ) return -1 ; return $ r * $ r ; } $ r = 5 ; echo trianglearea ( $ r ) ; ? >"}
{"text":"Largest square that can be inscribed in a semicircle | Function to find the area of the square ; the radius cannot be negative ; area of the square ; Driver code","code":"< ? php function squarearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = 4 * ( pow ( $ r , 2 ) \/ 5 ) ; return $ a ; } $ r = 5 ; echo squarearea ( $ r ) ; ? >"}
{"text":"Area of Largest rectangle that can be inscribed in an Ellipse | Function to find the area of the rectangle ; a and b cannot be negative ; area of the rectangle ; Driver code","code":"< ? php function rectanglearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; return 2 * $ a * $ b ; } $ a = 10 ; $ b = 8 ; echo rectanglearea ( $ a , $ b ) ; ? >"}
{"text":"Area of a largest square fit in a right angle triangle | Function to find the area of the biggest square ; the height or base or hypotenuse cannot be negative ; side of the square ; squaring to get the area ; Driver code","code":"< ? php function squareArea ( $ l , $ b , $ h ) { if ( $ l < 0 $ b < 0 $ h < 0 ) return -1 ; $ a = ( $ l * $ b ) \/ ( $ l + $ b ) ; return $ a * $ a ; } $ l = 5 ; $ b = 12 ; $ h = 13 ; echo round ( squareArea ( $ l , $ b , $ h ) , 4 ) ; ? >"}
{"text":"Queries to check if it is possible to join boxes in a circle | PHP implementation of above approach ; Print the answer to each query ; setting the flag for exception ; replacing the greater element in i and j ; checking if that box is not used in previous query . ; checking if connecting to the same box ; case 1 : x < i and y lies between i and j ; case 2 : x lies between i and j and y > j ; if flag is not reset inbetween . ; Driver code","code":"< ? php $ MAX = 50 ; function solveQuery ( $ n , $ q , & $ qi , & $ qj ) { global $ MAX ; $ arr = array_fill ( 0 , $ MAX , NULL ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = 0 ; for ( $ k = 0 ; $ k < $ q ; $ k ++ ) { $ flag = 0 ; if ( $ qj [ $ k ] < $ qi [ $ k ] ) { $ temp = $ qi [ $ k ] ; $ qi [ $ k ] = $ qj [ $ k ] ; $ qj [ $ k ] = $ temp ; } if ( $ arr [ $ qi [ $ k ] ] != 0 $ arr [ $ qj [ $ k ] ] != 0 ) $ flag = 1 ; else if ( $ qi [ $ k ] == $ qj [ $ k ] ) $ flag = 1 ; else { for ( $ i = 1 ; $ i < $ qi [ $ k ] ; $ i ++ ) { if ( $ arr [ $ i ] != 0 && $ arr [ $ i ] < $ qj [ $ k ] && $ qi [ $ k ] < $ arr [ $ i ] ) { $ flag = 1 ; break ; } } if ( $ flag == 0 ) { for ( $ i = $ qi [ $ k ] + 1 ; $ i < $ qj [ $ k ] ; $ i ++ ) { if ( $ arr [ $ i ] != 0 && $ arr [ $ i ] > $ qj [ $ k ] ) { $ flag = 1 ; break ; } } } } if ( $ flag == 0 ) { echo \" YES STRNEWLINE \" ; $ arr [ $ qi [ $ k ] ] = $ qj [ $ k ] ; $ arr [ $ qj [ $ k ] ] = $ qi [ $ k ] ; } else echo \" NO STRNEWLINE \" ; } } $ n = 10 ; $ q = 7 ; $ qi = array ( 1 , 2 , 2 , 2 , 9 , 10 , 8 ) ; $ qj = array ( 5 , 7 , 3 , 4 , 9 , 9 , 6 ) ; solveQuery ( $ n , $ q , $ qi , $ qj ) ; ? >"}
{"text":"Minimum squares to cover a rectangle | PHP program to find the minimum number of squares to cover the surface of the rectangle with given dimensions ; function to count the number of squares that can cover the surface of the rectangle ; Driver code","code":"< ? php function squares ( $ l , $ b , $ a ) { return ceil ( $ l \/ ( double ) $ a ) * ceil ( $ b \/ ( double ) $ a ) ; } $ l = 11 ; $ b = 23 ; $ a = 14 ; echo squares ( $ l , $ b , $ a ) ; ? >"}
{"text":"Smallest square formed with given rectangles | Recursive function to return gcd of a and b ; Everything divides 0 ; Base case ; a is greater ; Function to find the area of the smallest square ; the length or breadth or side cannot be negative ; LCM of length and breadth ; squaring to get the area ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return 0 ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; } function squarearea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ n = ( $ l * $ b ) \/ gcd ( $ l , $ b ) ; return $ n * $ n ; } $ l = 6 ; $ b = 4 ; echo squarearea ( $ l , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find all angles of a triangle in 3D | function for finding the angle ; Driver code","code":"< ? php function angle_triangle ( $ x1 , $ x2 , $ x3 , $ y1 , $ y2 , $ y3 , $ z1 , $ z2 , $ z3 ) { $ num = ( $ x2 - $ x1 ) * ( $ x3 - $ x1 ) + ( $ y2 - $ y1 ) * ( $ y3 - $ y1 ) + ( $ z2 - $ z1 ) * ( $ z3 - $ z1 ) ; $ den = sqrt ( pow ( ( $ x2 - $ x1 ) , 2 ) + pow ( ( $ y2 - $ y1 ) , 2 ) + pow ( ( $ z2 - $ z1 ) , 2 ) ) * sqrt ( pow ( ( $ x3 - $ x1 ) , 2 ) + pow ( ( $ y3 - $ y1 ) , 2 ) + pow ( ( $ z3 - $ z1 ) , 2 ) ) ; $ angle = acos ( $ num \/ $ den ) * ( 180.0 \/ 3.141592653589793238463 ) ; return $ angle ; } $ x1 = -1 ; $ y1 = 3 ; $ z1 = 2 ; $ x2 = 2 ; $ y2 = 3 ; $ z2 = 5 ; $ x3 = 3 ; $ y3 = 5 ; $ z3 = -2 ; $ angle_A = angle_triangle ( $ x1 , $ x2 , $ x3 , $ y1 , $ y2 , $ y3 , $ z1 , $ z2 , $ z3 ) ; $ angle_B = angle_triangle ( $ x2 , $ x3 , $ x1 , $ y2 , $ y3 , $ y1 , $ z2 , $ z3 , $ z1 ) ; $ angle_C = angle_triangle ( $ x3 , $ x2 , $ x1 , $ y3 , $ y2 , $ y1 , $ z3 , $ z2 , $ z1 ) ; echo \" Angles \u2581 are \u2581 : STRNEWLINE \" ; echo \" angle A = \" \u2581 . \u2581 round ( $ angle _ A , \u2581 3 ) \u2581 . \u2581 \" degree \" ; STRNEWLINE echo \u2581 \" angle B = \" \u2581 . \u2581 round ( $ angle _ B , \u2581 3 ) \u2581 . \u2581 \" degree \" ; STRNEWLINE echo \u2581 \" angle C = \" \u2581 . \u2581 round ( $ angle _ C , \u2581 3 ) \u2581 . \u2581 \" degree \" ? >"}
{"text":"Minimum number of square tiles required to fill the rectangular floor | Function to find the number of tiles ; if breadth is divisible by side of square ; tiles required is N \/ s ; one more tile required ; if length is divisible by side of square ; tiles required is M \/ s ; one more tile required ; input length and breadth of rectangle and side of square","code":"< ? php function solve ( $ M , $ N , $ s ) { if ( $ N % $ s == 0 ) { $ N = $ N \/ $ s ; } else { $ N = ( $ N \/ $ s ) + 1 ; } if ( $ M % $ s == 0 ) { $ M = $ M \/ $ s ; } else { $ M = ( $ M \/ $ s ) + 1 ; } return ( int ) $ M * $ N ; } $ N = 12 ; $ M = 13 ; $ s = 4 ; echo solve ( $ M , $ N , $ s ) ; ? >"}
{"text":"Minimum number of square tiles required to fill the rectangular floor | Function to find the number of tiles ; no of tiles ; input length and breadth of rectangle and side of square","code":"< ? php function solve ( $ M , $ N , $ s ) { $ ans = ( ( int ) ( ceil ( $ M \/ $ s ) ) * ( int ) ( ceil ( $ N \/ $ s ) ) ) ; return $ ans ; } $ N = 12 ; $ M = 13 ; $ s = 4 ; echo solve ( $ M , $ N , $ s ) ; ? >"}
{"text":"Program to find equation of a plane passing through 3 points | Function to find equation of plane . ; Driver Code","code":"< ? php function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; echo sprintf ( \" equation \u2581 of \u2581 the \u2581 plane \u2581 is \u2581 % .2fx \" . \" \u2581 + \u2581 % .2fy \u2581 + \u2581 % .2fz \u2581 + \u2581 % .2f \u2581 = \u2581 0\" , $ a , $ b , $ c , $ d ) ; } $ x1 = -1 ; $ y1 = 2 ; $ z1 = 1 ; $ x2 = 0 ; $ y2 = -3 ; $ z2 = 2 ; $ x3 = 1 ; $ y3 = 1 ; $ z3 = -4 ; equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) ; ? >"}
{"text":"Perpendicular distance between a point and a Line in 2 D | Function to find distance ; Driver Code","code":"< ? php function shortest_distance ( $ x1 , $ y1 , $ a , $ b , $ c ) { $ d = abs ( ( $ a * $ x1 + $ b * $ y1 + $ c ) ) \/ ( sqrt ( $ a * $ a + $ b * $ b ) ) ; echo \" Perpendicular \u2581 distance \u2581 is \u2581 \" , $ d ; } $ x1 = 5 ; $ y1 = 6 ; $ a = -2 ; $ b = 3 ; $ c = 4 ; shortest_distance ( $ x1 , $ y1 , $ a , $ b , $ c ) ; ? >"}
{"text":"Program to determine the octant of the axial plane | Function to print octant ; Driver Code","code":"< ? php function octant ( $ x , $ y , $ z ) { if ( $ x >= 0 && $ y >= 0 && $ z >= 0 ) echo \" Point \u2581 lies \u2581 in \u2581 1st \u2581 octant STRNEWLINE \" ; else if ( $ x < 0 && $ y >= 0 && $ z >= 0 ) echo \" Point \u2581 lies \u2581 in \u2581 2nd \u2581 octant STRNEWLINE \" ; else if ( $ x < 0 && $ y < 0 && $ z >= 0 ) echo \" Point \u2581 lies \u2581 in \u2581 3rd \u2581 octant STRNEWLINE \" ; else if ( $ x >= 0 && $ y < 0 && $ z >= 0 ) echo \" Point \u2581 lies \u2581 in \u2581 4th \u2581 octant STRNEWLINE \" ; else if ( $ x >= 0 && $ y >= 0 && $ z < 0 ) echo \" Point \u2581 lies \u2581 in \u2581 5th \u2581 octant STRNEWLINE \" ; else if ( $ x < 0 && $ y >= 0 && $ z < 0 ) echo \" Point \u2581 lies \u2581 in \u2581 6th \u2581 octant STRNEWLINE \" ; else if ( $ x < 0 && $ y < 0 && $ z < 0 ) echo \" Point \u2581 lies \u2581 in \u2581 7th \u2581 octant STRNEWLINE \" ; else if ( $ x >= 0 && $ y < 0 && $ z < 0 ) echo \" Point \u2581 lies \u2581 in \u2581 8th \u2581 octant STRNEWLINE \" ; } $ x = 2 ; $ y = 3 ; $ z = 4 ; octant ( $ x , $ y , $ z ) ; $ x = -4 ; $ y = 2 ; $ z = -8 ; octant ( $ x , $ y , $ z ) ; $ x = -6 ; $ y = -2 ; $ z = 8 ; octant ( $ x , $ y , $ z ) ; ? >"}
{"text":"Number of triangles in a plane if no more than two points are collinear | Function to find number of triangles in a plane . ; Formula to find number of triangles nC3 = n * ( n - 1 ) * ( n - 2 ) \/ 6 ; Driver code","code":"< ? php function countNumberOfTriangles ( $ n ) { return $ n * ( $ n - 1 ) * ( $ n - 2 ) \/ 6 ; } $ n = 4 ; echo countNumberOfTriangles ( $ n ) ; ? >"}
{"text":"Centered tridecagonal number | Function to find nth centered tridecagonal number ; Formula to calculate nth centered tridecagonal number ; Driver Code","code":"< ? php function centeredTridecagonalNum ( $ n ) { return ( 13 * $ n * ( $ n - 1 ) + 2 ) \/ 2 ; } $ n = 3 ; echo centeredTridecagonalNum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo centeredTridecagonalNum ( $ n ) ; ? >"}
{"text":"Pentagonal Pyramidal Number | function to get nth Pentagonal pyramidal number . ; Running loop from 1 to n ; get nth pentagonal number ; add to sum ; Driver Code","code":"< ? php function pentagon_pyramidal ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ p = ( 3 * $ i * $ i - $ i ) \/ 2 ; $ sum = $ sum + $ p ; } return $ sum ; } $ n = 4 ; echo pentagon_pyramidal ( $ n ) ; ? >"}
{"text":"Pentagonal Pyramidal Number | function to get nth Pentagonal pyramidal number . ; Driver Code","code":"< ? php function pentagon_pyramidal ( $ n ) { return $ n * $ n * ( $ n + 1 ) \/ 2 ; } $ n = 4 ; echo pentagon_pyramidal ( $ n ) ; ? >"}
{"text":"Check if three straight lines are concurrent or not | Return true if three line are concurrent , else false . ; Driver Code","code":"< ? php function checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) { return ( $ a3 * ( $ b1 * $ c2 - $ b2 * $ c1 ) + $ b3 * ( $ c1 * $ a2 - $ c2 * $ a1 ) + $ c3 * ( $ a1 * $ b2 - $ a2 * $ b1 ) == 0 ) ; } $ a1 = 2 ; $ b1 = -3 ; $ c1 = 5 ; $ a2 = 3 ; $ b2 = 4 ; $ c2 = -7 ; $ a3 = 9 ; $ b3 = -5 ; $ c3 = 8 ; if ( checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Centered Octadecagonal Number | centered octadecagon function ; Formula to calculate nth centered octadecagonal number ; Driver Code","code":"< ? php function center_octadecagon_num ( $ n ) { return ( 9 * $ n * $ n - 9 * $ n + 1 ) ; } $ n = 3 ; echo $ n , \" th \u2581 centered \u2581 octadecagonal \u2581 \" . \" number \u2581 : \u2581 \" , center_octadecagon_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 13 ; echo $ n , \" th \u2581 centered \u2581 octadecagonal \u2581 \" . \" number \u2581 : \u2581 \" , center_octadecagon_num ( $ n ) ; ? >"}
{"text":"Centered decagonal number | Centered decagonal number function ; Formula to calculate nth centered decagonal number & return it into main function . ; Driver Code","code":"< ? php function centereddecagonalnum ( $ n ) { return ( 5 * $ n * $ n + 5 * $ n + 1 ) ; } $ n = 5 ; echo $ n , \" th \u2581 centered \u2581 decagonal \" , \" number : \u2581 \" ; echo centereddecagonalnum ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 9 ; echo $ n , \" th \u2581 centered \u2581 decagonal \" , \" number : \u2581 \" ; echo centereddecagonalnum ( $ n ) ; ? >"}
{"text":"Lexicographically Kth smallest way to reach given coordinate from origin | Return ( a + b ) ! \/ a ! b ! ; finding ( a + b ) ! ; finding ( a + b ) ! \/ a ! ; finding ( a + b ) ! \/ b ! ; Return the Kth smallest way to reach given coordinate from origin ; if at origin ; if on y - axis ; decrement y . ; Move vertical ; recursive call to take next step . ; If on x - axis ; decrement x . ; Move horizontal . ; recursive call to take next step . ; If x + y C x is greater than K ; Move Horizontal ; recursive call to take next step . ; Move vertical ; recursive call to take next step . ; Driver Code","code":"< ? php function factorial ( $ a , $ b ) { $ res = 1 ; for ( $ i = 1 ; $ i <= ( $ a + $ b ) ; $ i ++ ) $ res = $ res * $ i ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) $ res = $ res \/ $ i ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) $ res = $ res \/ $ i ; return $ res ; } function Ksmallest ( $ x , $ y , $ k ) { if ( $ x == 0 && $ y == 0 ) return ; else if ( $ x == 0 ) { $ y -- ; echo ( \" V \" ) ; Ksmallest ( $ x , $ y , $ k ) ; } else if ( $ y == 0 ) { $ x -- ; echo ( \" H \" ) ; Ksmallest ( $ x , $ y , $ k ) ; } else { if ( factorial ( $ x - 1 , $ y ) > $ k ) { echo ( \" H \" ) ; Ksmallest ( $ x - 1 , $ y , $ k ) ; } else { echo ( \" V \" ) ; Ksmallest ( $ x , $ y - 1 , $ k - factorial ( $ x - 1 , $ y ) ) ; } } } $ x = 2 ; $ y = 2 ; $ k = 2 ; Ksmallest ( $ x , $ y , $ k ) ; ? >"}
{"text":"Centered pentagonal number | Centered pentagonal number function ; Formula to calculate nth Centered pentagonal number and return it into main function . ; Driver Code","code":"< ? php function centered_pentagonal_Num ( $ n ) { return ( 5 * $ n * $ n - 5 * $ n + 2 ) \/ 2 ; } $ n = 7 ; echo $ n , \" th \u2581 Centered \u2581 pentagonal \u2581 number : \u2581 \" ; echo centered_pentagonal_Num ( $ n ) ; ? >"}
{"text":"Find maximum and minimum distance between magnets | Function for finding distance between pivots ; Function for minimum distance ; Function for maximum distance ; Driver code","code":"< ? php function pivotDis ( $ x0 , $ y0 , $ x1 , $ y1 ) { return sqrt ( ( $ x1 - $ x0 ) * ( $ x1 - $ x0 ) + ( $ y1 - $ y0 ) * ( $ y1 - $ y0 ) ) ; } function minDis ( $ D , $ r1 , $ r2 ) { return max ( ( $ D - $ r1 - $ r2 ) , 0 ) ; } function maxDis ( $ D , $ r1 , $ r2 ) { return $ D + $ r1 + $ r2 ; } $ x0 = 0 ; $ y0 = 0 ; $ x1 = 8 ; $ y1 = 0 ; $ r1 = 4 ; $ r2 = 5 ; $ D = pivotDis ( $ x0 , $ y0 , $ x1 , $ y1 ) ; echo \" Distance \u2581 while \u2581 repulsion \u2581 = \u2581 \" , maxDis ( $ D , $ r1 , $ r2 ) ; echo \" Distance while attraction = \" , minDis ( $ D , $ r1 , $ r2 ) ; ? >"}
{"text":"Maximize a value for a semicircle of given radius | Function to find the maximum value of F ; using the formula derived for getting the maximum value of F ; Drivers code","code":"< ? php function maximumValueOfF ( $ R ) { return 4 * $ R * $ R + 0.25 ; } $ R = 3 ; echo maximumValueOfF ( $ R ) ; ? >"}
{"text":"Find the other end point of a line with given one end and mid | PHP function to find the end point of a line ; find end point for x coordinates ; find end point for y coordinates ; Driven Program","code":"< ? php function otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) { $ x2 = ( 2 * $ m1 - $ x1 ) ; $ y2 = ( 2 * $ m2 - $ y1 ) ; echo \" x2 \u2581 = \u2581 \" . $ x2 . \" , \u2581 y2 \u2581 = \u2581 \" . $ y2 ; } $ x1 = -4 ; $ y1 = -1 ; $ m1 = 3 ; $ m2 = 5 ; otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) ; ? >"}
{"text":"Coordinates of rectangle with given points lie inside | function to print coordinate of smallest rectangle ; find Xmax and Xmin ; find Ymax and Ymin ; print all four coordinates ; Driver Code","code":"< ? php function printRect ( $ X , $ Y , $ n ) { $ Xmax = max ( $ X ) ; $ Xmin = min ( $ X ) ; $ Ymax = max ( $ Y ) ; $ Ymin = min ( $ Y ) ; echo \" { \" , $ Xmin , \" , \u2581 \" , $ Ymin , \" } \" , \" STRNEWLINE \" ; echo \" { \" , $ Xmin , \" , \u2581 \" , $ Ymax , \" } \" , \" STRNEWLINE \" ; echo \" { \" , $ Xmax , \" , \u2581 \" , $ Ymax , \" } \" , \" STRNEWLINE \" ; echo \" { \" , $ Xmax , \" , \u2581 \" , $ Ymin , \" } \" ; } $ X = array ( 4 , 3 , 6 , 1 , -1 , 12 ) ; $ Y = array ( 4 , 1 , 10 , 3 , 7 , -1 ) ; $ n = count ( $ X ) ; printRect ( $ X , $ Y , $ n ) ; ? >"}
{"text":"Check if a line passes through the origin | PHP program to find if line passing through two coordinates also passes through origin or not ; Driver code","code":"< ? php function checkOrigin ( $ x1 , $ y1 , $ x2 , $ y2 ) { return ( $ x1 * ( $ y2 - $ y1 ) == $ y1 * ( $ x2 - $ x1 ) ) ; } if ( checkOrigin ( 1 , 28 , 2 , 56 ) == true ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Number of horizontal or vertical line segments to connect 3 points | Function to check if the third point forms a rectangle with other two points at corners ; Returns true if point k can be used as a joining point to connect using two line segments ; Check for the valid polyline with two segments ; Check whether the X - coordinates or Y - cocordinates are same . ; Iterate over all pairs to check for two line segments ; Otherwise answer is three . ; Driver code","code":"< ? php function isBetween ( $ a , $ b , $ c ) { return min ( $ a , $ b ) <= $ c and $ c <= max ( $ a , $ b ) ; } function canJoin ( $ x , $ y , $ i , $ j , $ k ) { return ( $ x [ $ k ] == $ x [ $ i ] or $ x [ $ k ] == $ x [ $ j ] ) and isBetween ( $ y [ $ i ] , $ y [ $ j ] , $ y [ $ k ] ) or ( $ y [ $ k ] == $ y [ $ i ] or $ y [ $ k ] == $ y [ $ j ] ) and isBetween ( $ x [ $ i ] , $ x [ $ j ] , $ x [ $ k ] ) ; } function countLineSegments ( $ x , $ y ) { if ( ( $ x [ 0 ] == $ x [ 1 ] and $ x [ 1 ] == $ x [ 2 ] ) or ( $ y [ 0 ] == $ y [ 1 ] and $ y [ 1 ] == $ y [ 2 ] ) ) return 1 ; else if ( canJoin ( $ x , $ y , 0 , 1 , 2 ) or canJoin ( $ x , $ y , 0 , 2 , 1 ) || canJoin ( $ x , $ y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; } $ x = array ( ) ; $ y = array ( ) ; $ x [ 0 ] = -1 ; $ y [ 0 ] = -1 ; $ x [ 1 ] = -1 ; $ y [ 1 ] = 3 ; $ x [ 2 ] = 4 ; $ y [ 2 ] = 3 ; echo countLineSegments ( $ x , $ y ) ; ? >"}
{"text":"Pythagorean Quadruple | function for checking ; Driver Code","code":"< ? php function pythagorean_quadruple ( $ a , $ b , $ c , $ d ) { $ sum = $ a * $ a + $ b * $ b + $ c * $ c ; if ( $ d * $ d == $ sum ) return true ; else return false ; } $ a = 1 ; $ b = 2 ; $ c = 2 ; $ d = 3 ; if ( pythagorean_quadruple ( $ a , $ b , $ c , $ d ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program for Volume and Surface area of Frustum of Cone | Function to calculate Volume of frustum of cone ; Function to calculate Curved Surface area of frustum of cone ; Function to calculate Total Surface area of frustum of cone ; Driver Code ; Printing value of volume and surface area","code":"< ? php function volume ( $ r , $ R , $ h ) { $ pi = 3.14159 ; return ( 1 \/ ( 3 ) ) * $ pi * $ h * ( $ r * $ r + $ R * $ R + $ r * $ R ) ; } function curved_surface_area ( $ r , $ R , $ l ) { $ pi = 3.14159 ; return $ pi * $ l * ( $ R + $ r ) ; } function total_surface_area ( $ r , $ R , $ l , $ h ) { $ pi = 3.14159 ; return ( $ pi * $ l * ( $ R + $ r ) + $ pi * ( $ r * $ r + $ R * $ R ) ) ; } $ small_radius = 3 ; $ big_radius = 8 ; $ slant_height = 13 ; $ height = 12 ; echo ( \" Volume \u2581 Of \u2581 Frustum \u2581 of \u2581 Cone \u2581 : \u2581 \" ) ; echo ( volume ( $ small_radius , $ big_radius , $ height ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Curved \u2581 Surface \u2581 Area \u2581 Of \u2581 Frustum \u2581 of \u2581 Cone \u2581 : \u2581 \" ) ; echo ( curved_surface_area ( $ small_radius , $ big_radius , $ slant_height ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Total \u2581 Surface \u2581 Area \u2581 Of \u2581 Frustum \u2581 of \u2581 Cone \u2581 : \u2581 \" ) ; echo ( total_surface_area ( $ small_radius , $ big_radius , $ slant_height , $ height ) ) ; ? >"}
{"text":"Program to find Perimeter \/ Circumference of Square and Rectangle | PHP program to find Circumference of a square ; Driver Code","code":"< ? php function Circumference ( $ a ) { return 4 * $ a ; } $ a = 5 ; echo \" Circumference \u2581 of \u2581 a \u2581 \" . \" square \u2581 is \u2581 \" , Circumference ( $ a ) ; ? >"}
{"text":"Maximum area of quadrilateral | PHP program to find maximum are of a quadrilateral ; Calculating the semi - perimeter of the given quadrilateral ; Applying Brahmagupta 's formula to  get maximum area of quadrilateral ; Driver code","code":"< ? php function maxArea ( $ a , $ b , $ c , $ d ) { $ semiperimeter = ( $ a + $ b + $ c + $ d ) \/ 2 ; return sqrt ( ( $ semiperimeter - $ a ) * ( $ semiperimeter - $ b ) * ( $ semiperimeter - $ c ) * ( $ semiperimeter - $ d ) ) ; } $ a = 1 ; $ b = 2 ; $ c = 1 ; $ d = 2 ; echo ( maxArea ( $ a , $ b , $ c , $ d ) ) ; ? >"}
{"text":"Find minimum radius such that atleast k point lie inside the circle | Return minimum distance required so that aleast k point lie inside the circle . ; Finding distance between of each point from origin ; Sorting the distance ; Driver Code","code":"< ? php function minRadius ( $ k , $ x , $ y , $ n ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dis [ $ i ] = $ x [ $ i ] * $ x [ $ i ] + $ y [ $ i ] * $ y [ $ i ] ; sort ( $ dis ) ; return $ dis [ $ k - 1 ] ; } $ k = 3 ; $ x = array ( 1 , -1 , 1 ) ; $ y = array ( 1 , -1 , -1 ) ; $ n = count ( $ x ) ; echo minRadius ( $ k , $ x , $ y , $ n ) ; ? >"}
{"text":"Program for Area And Perimeter Of Rectangle | Utility function ; Driver program","code":"< ? php function areaRectangle ( $ a , $ b ) { $ area = $ a * $ b ; return $ area ; } function perimeterRectangle ( $ a , $ b ) { $ perimeter = 2 * ( $ a + $ b ) ; return $ perimeter ; } $ a = 5 ; $ b = 6 ; echo ( \" Area \u2581 = \u2581 \" ) ; echo ( areaRectangle ( $ a , $ b ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Perimeter \u2581 = \u2581 \" ) ; echo ( perimeterRectangle ( $ a , $ b ) ) ; ? >"}
{"text":"Program for Area Of Square | PHP program to find the aria of the square ; Driver Code","code":"< ? php function areaSquare ( $ side ) { $ area = $ side * $ side ; return $ area ; } $ side = 4 ; echo ( areaSquare ( $ side ) ) ; ? >"}
{"text":"Minimum Perimeter of n blocks | PHP program to find minimum perimeter using n blocks . ; if n is a perfect square ; Number of rows ; perimeter of the rectangular grid ; if there are blocks left ; Driver code","code":"< ? php function minPerimeter ( $ n ) { $ l = floor ( sqrt ( $ n ) ) ; $ sq = $ l * $ l ; if ( $ sq == $ n ) return $ l * 4 ; else { $ row = floor ( $ n \/ $ l ) ; $ perimeter = 2 * ( $ l + $ row ) ; if ( $ n % $ l != 0 ) $ perimeter += 2 ; return $ perimeter ; } } $ n = 10 ; echo minPerimeter ( $ n ) ; ? >"}
{"text":"Find if it 's possible to rotate the page by an angle or not. | function to find if it 's possible to rotate page or not ; Calculating distance b \/ w points ; If distance is not equal ; If the points are in same line ; Points a , b , and c","code":"< ? php function possibleOrNot ( $ a1 , $ a2 , $ b1 , $ b2 , $ c1 , $ c2 ) { $ dis1 = pow ( $ b1 - $ a1 , 2 ) + pow ( $ b2 - $ a2 , 2 ) ; $ dis2 = pow ( $ c1 - $ b1 , 2 ) + pow ( $ c2 - $ b2 , 2 ) ; if ( $ dis1 != $ dis2 ) echo \" No \" ; else if ( $ b1 == ( ( $ a1 + $ c1 ) \/ 2.0 ) && $ b2 == ( ( $ a2 + $ c2 ) \/ 2.0 ) ) echo \" No \" ; else echo \" Yes \" ; } $ a1 = 1 ; $ a2 = 0 ; $ b1 = 2 ; $ b2 = 0 ; $ c1 = 3 ; $ c2 = 0 ; possibleOrNot ( $ a1 , $ a2 , $ b1 , $ b2 , $ c1 , $ c2 ) ; ? >"}
{"text":"Check if two given circles touch or intersect each other | PHP program to check if two circles touch each other or not . ; Driver code","code":"< ? php function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; } $ x1 = -10 ; $ y1 = 8 ; $ x2 = 14 ; $ y2 = -24 ; $ r1 = 30 ; $ r2 = 10 ; $ t = circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) ; if ( $ t == 1 ) echo \" Circle \u2581 touch \u2581 to \u2581 each \u2581 other . \" ; else if ( $ t < 0 ) echo \" Circle \u2581 not \u2581 touch \u2581 to \u2581 each \u2581 other . \" ; else echo \" Circle \u2581 intersect \u2581 to \u2581 each \u2581 other . \" ; ? >"}
{"text":"Count of obtuse angles in a circle with ' k ' equidistant points between 2 given points | PHP program to count number of obtuse angles for given two points . ; There are two arcs connecting a and b . Let us count points on both arcs . ; Both arcs have same number of points ; Points on smaller arc is answer ; Driver code","code":"< ? php function countObtuseAngles ( $ a , $ b , $ k ) { $ c1 = ( $ b - $ a ) - 1 ; $ c2 = ( $ k - $ b ) + ( $ a - 1 ) ; if ( $ c1 == $ c2 ) return 0 ; return min ( $ c1 , $ c2 ) ; } $ k = 6 ; $ a = 1 ; $ b = 3 ; echo countObtuseAngles ( $ a , $ b , $ k ) ; ? >"}
{"text":"Count of acute , obtuse and right triangles with given sides | Find the number of acute , right , obtuse triangle that can be formed from given array . ; Finding the square of each element of array . ; Sort the sides of array and their squares . ; x for acute triangles y for right triangles z for obtuse triangles ; Finding the farthest point p where a ^ 2 + b ^ 2 >= c ^ 2. ; Finding the farthest point q where a + b > c . ; If point p make right triangle . ; All triangle between j and p are acute triangles . So add p - j - 1 in x . ; Increment y by 1. ; All triangle between q and p are acute triangles . So add q - p in z . ; If no right triangle ; All triangle between j and p are acute triangles . So add p - j in x . ; All triangle between q and p are acute triangles . So add q - p in z . ; Driver Code","code":"< ? php function findTriangle ( $ a , $ n ) { $ b [ $ n + 2 ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] * $ a [ $ i ] ; sort ( $ a ) ; sort ( $ b ) ; $ x = 0 ; $ y = 0 ; $ z = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ p = $ i + 1 ; $ q = $ i + 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { while ( $ p < $ n - 1 && $ b [ $ i ] + $ b [ $ j ] >= $ b [ $ p + 1 ] ) $ p ++ ; $ q = max ( $ q , $ p ) ; while ( $ q < $ n - 1 && $ a [ $ i ] + $ a [ $ j ] > $ a [ $ q + 1 ] ) $ q ++ ; if ( $ b [ $ i ] + $ b [ $ j ] == $ b [ $ p ] ) { $ x += max ( $ p - $ j - 1 , 0 ) ; $ y ++ ; $ z += $ q - $ p ; } else { $ x += max ( $ p - $ j , 0 ) ; $ z += $ q - $ p ; } } } echo \" Acute \u2581 Triangle : \u2581 \" , $ x , \" STRNEWLINE \" ; echo \" Right \u2581 Triangle : \u2581 \" , $ y , \" STRNEWLINE \" ; echo \" Obtuse \u2581 Triangle : \u2581 \" , $ z , \" STRNEWLINE \" ; } $ arr = array ( 2 , 3 , 9 , 10 , 12 , 15 ) ; $ n = sizeof ( $ arr ) ; findTriangle ( $ arr , $ n ) ; ? >"}
{"text":"Area of a polygon with given n ordered vertices | ( X [ i ] , Y [ i ] ) are coordinates of i 'th point. ; Initialize area ; Calculate value of shoelace formula ; j is previous vertex to i ; Return absolute value ; Driver Code","code":"< ? php function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area \/ 2.0 ) ; } $ X = array ( 0 , 2 , 4 ) ; $ Y = array ( 1 , 3 , 7 ) ; $ n = sizeof ( $ X ) ; echo polygonArea ( $ X , $ Y , $ n ) ; ? >"}
{"text":"Program to find the last digit of X in base Y | Function to find the last digit of X in base Y ; Driver code","code":"< ? php function last_digit ( $ X , $ Y ) { echo ( $ X % $ Y ) ; } $ X = 55 ; $ Y = 3 ; last_digit ( $ X , $ Y ) ; ? >"}
{"text":"Roots of the quadratic equation when a + b + c = 0 without using Shridharacharya formula | Function to print the roots of the quadratic equation when a + b + c = 0 ; Driver code","code":"< ? php function printRoots ( $ a , $ b , $ c ) { echo \"1\" ; echo \" , \u2581 \" ; echo $ c \/ ( $ a * 1.0 ) ; } $ a = 2 ; $ b = 3 ; $ c = -5 ; printRoots ( $ a , $ b , $ c ) ; ? >"}
{"text":"Quadruplet pair with XOR zero in the given Array | PHP implementation of the approach ; Function that returns true if the array contains a valid quadruplet pair ; We can always find a valid quadruplet pair for array size greater than MAX ; For smaller size arrays , perform brute force ; Driver code","code":"< ? php const MAX = 130 ; function validQuadruple ( $ arr , $ n ) { if ( $ n >= MAX ) return true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ^ $ arr [ $ k ] ^ $ arr [ $ l ] ) == 0 ) { return true ; } } return false ; } $ arr = array ( 1 , 0 , 2 , 3 , 7 ) ; $ n = count ( $ arr ) ; if ( validQuadruple ( $ arr , $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Check whether a number can be represented as sum of K distinct positive integers | Function that returns true if n can be represented as the sum of exactly k distinct positive integers ; If n can be represented as 1 + 2 + 3 + ... + ( k - 1 ) + ( k + x ) ; Driver code","code":"< ? php function solve ( $ n , $ k ) { if ( $ n >= ( $ k * ( $ k + 1 ) ) \/ 2 ) { return true ; } return false ; } $ n = 12 ; $ k = 4 ; if ( solve ( $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Bitwise AND of sub | Function to return the minimum possible value of | K - X | where X is the bitwise AND of the elements of some sub - array ; Check all possible sub - arrays ; Find the overall minimum ; Driver code","code":"< ? php function closetAND ( & $ arr , $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ X = $ arr [ $ i ] ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ X &= $ arr [ $ j ] ; $ ans = min ( $ ans , abs ( $ k - $ X ) ) ; } } return $ ans ; } $ arr = array ( 4 , 7 , 10 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ k = 2 ; echo closetAND ( $ arr , $ n , $ k ) ; return 0 ; ? >"}
{"text":"Program to find the rate percentage from compound interest of consecutive years | Function to return the required rate percentage ; Driver code","code":"< ? php function Rate ( $ N1 , $ N2 ) { $ rate = ( $ N2 - $ N1 ) * 100 \/ $ N1 ; return $ rate ; } $ N1 = 100 ; $ N2 = 120 ; echo Rate ( $ N1 , $ N2 ) , \" % \" ; ? >"}
{"text":"Find prime number K in an array such that ( A [ i ] % K ) is maximum | Function to return the count of primes in the given array ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; To store the maximum prime number ; If current element is prime then update the maximum prime ; Return the maximum prime number from the array ; Driver code","code":"< ? php function getPrime ( $ arr , $ n ) { $ max_val = max ( $ arr ) ; $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ maximum = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) $ maximum = max ( $ maximum , $ arr [ $ i ] ) ; } return $ maximum ; } $ arr = array ( 2 , 10 , 15 , 7 , 6 , 8 , 13 ) ; $ n = count ( $ arr ) ; echo getPrime ( $ arr , $ n ) ; ? >"}
{"text":"Minimum integer such that it leaves a remainder 1 on dividing with any element from the range [ 2 , N ] | Function to return the smallest number which on dividing with any element from the range [ 2 , N ] leaves a remainder of 1 ; Find the LCM of the elements from the range [ 2 , N ] ; Return the required number ; Driver code","code":"< ? php function getMinNum ( $ N ) { $ lcm = 1 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) $ lcm = ( ( $ i * $ lcm ) \/ ( __gcd ( $ i , $ lcm ) ) ) ; return ( $ lcm + 1 ) ; } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ N = 5 ; echo ( getMinNum ( $ N ) ) ; ? >"}
{"text":"Maximum number of edges in Bipartite graph | Function to return the maximum number of edges possible in a Bipartite graph with N vertices ; Driver code","code":"< ? php function maxEdges ( $ N ) { $ edges = 0 ; $ edges = floor ( ( $ N * $ N ) \/ 4 ) ; return $ edges ; } $ N = 5 ; echo maxEdges ( $ N ) ; ? >"}
{"text":"Find permutation of first N natural numbers that satisfies the given condition | Function to find permutation ( p ) of first N natural numbers such that there are exactly K elements of permutation such that GCD ( p [ i ] , i ) > 1 ; First place all the numbers in their respective places ; Modify for first n - k integers ; In first index place n - k ; Print the permutation ; Driver code","code":"< ? php function Permutation ( $ n , $ k ) { $ p = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ p [ $ i ] = $ i ; for ( $ i = 1 ; $ i < $ n - $ k ; $ i ++ ) $ p [ $ i + 1 ] = $ i ; $ p [ 1 ] = $ n - $ k ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ p [ $ i ] , \" \u2581 \" ; } $ n = 5 ; $ k = 2 ; Permutation ( $ n , $ k ) ; ? >"}
{"text":"Number of positions such that adding K to the element is greater than sum of all other elements | Function that will find out the valid position ; find sum of all the elements ; adding K to the element and check whether it is greater than sum of all other elements ; Driver code","code":"< ? php function validPosition ( $ arr , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ sum += $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( ( $ arr [ $ i ] + $ K ) > ( $ sum - $ arr [ $ i ] ) ) $ count ++ ; } return $ count ; } $ arr = array ( 2 , 1 , 6 , 7 ) ; $ K = 4 ; $ N = count ( $ arr ) ; echo validPosition ( $ arr , $ N , $ K ) ; ? >"}
{"text":"Find element with the maximum set bits in an array | Function to return the element from the array which has the maximum set bits ; To store the required element and the maximum set bits so far ; Count of set bits in the current element ; Update the max ; Driver code","code":"< ? php function maxBitElement ( $ arr , $ n ) { $ num = 0 ; $ max = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ cnt = BitCount ( $ arr [ $ i ] ) ; if ( $ cnt > $ max ) { $ max = $ cnt ; $ num = $ arr [ $ i ] ; } } return $ num ; } function BitCount ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ count ++ ; $ n &= ( $ n - 1 ) ; } return $ count ; } $ arr = array ( 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 ) ; $ n = count ( $ arr ) ; echo ( maxBitElement ( $ arr , $ n ) ) ; ? >"}
{"text":"Smallest and Largest sum of two n | Function to return the smallest sum of 2 n - digit numbers ; Function to return the largest sum of 2 n - digit numbers ; Driver code","code":"< ? php function smallestSum ( $ n ) { if ( $ n == 1 ) return 0 ; return ( 2 * pow ( 10 , $ n - 1 ) ) ; } function largestSum ( $ n ) { return 2 * ( pow ( 10 , $ n ) - 1 ) ; } $ n = 4 ; echo \" Largest = \" \u2581 . \u2581 largestSum ( $ n ) \u2581 . \u2581 \" \" ; STRNEWLINE echo \u2581 \" Smallest = \" ? >"}
{"text":"Given two arrays count all pairs whose sum is an odd number | Function that returns the number of pairs ; Count of odd and even numbers ; Traverse in the first array and count the number of odd and evene numbers in them ; Traverse in the second array and count the number of odd and evene numbers in them ; Count the number of pairs ; Return the number of pairs ; Driver code","code":"< ? php function count_pairs ( $ a , $ b , $ n , $ m ) { $ odd1 = 0 ; $ even1 = 0 ; $ odd2 = 0 ; $ even2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 ) $ odd1 ++ ; else $ even1 ++ ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ b [ $ i ] % 2 ) $ odd2 ++ ; else $ even2 ++ ; } $ pairs = min ( $ odd1 , $ even2 ) + min ( $ odd2 , $ even1 ) ; return $ pairs ; } $ a = array ( 9 , 14 , 6 , 2 , 11 ) ; $ b = array ( 8 , 4 , 7 , 20 ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; echo count_pairs ( $ a , $ b , $ n , $ m ) ; ? >"}
{"text":"Print steps to make a number in form of 2 ^ X | Function to find the leftmost unset bit in a number . ; Function that perform the step ; Find the leftmost unset bit ; If the number has no bit unset , it means it is in form 2 ^ x - 1 ; Count the steps ; Iterate till number is of form 2 ^ x - 1 ; At even step increase by 1 ; Odd step xor with any 2 ^ m - 1 ; Find the leftmost unset bit ; 2 ^ m - 1 ; Perform the step ; Increase the steps ; Driver code","code":"< ? php function find_leftmost_unsetbit ( $ n ) { $ ind = -1 ; $ i = 1 ; while ( $ n ) { if ( ! ( $ n & 1 ) ) $ ind = $ i ; $ i ++ ; $ n >>= 1 ; } return $ ind ; } function perform_steps ( $ n ) { $ left = find_leftmost_unsetbit ( $ n ) ; if ( $ left == -1 ) { echo \" No \u2581 steps \u2581 required \" ; return ; } $ step = 1 ; while ( find_leftmost_unsetbit ( $ n ) != -1 ) { if ( $ step % 2 == 0 ) { $ n += 1 ; echo \" Step \" , $ step , \" : \u2581 Increase \u2581 by \u2581 1 STRNEWLINE \" ; } else { $ m = find_leftmost_unsetbit ( $ n ) ; $ num = pow ( 2 , $ m ) - 1 ; $ n = $ n ^ $ num ; echo \" Step \" , $ step , \" : \u2581 Xor \u2581 with \u2581 \" , $ num , \" STRNEWLINE \" ; } $ step += 1 ; } } $ n = 39 ; perform_steps ( $ n ) ; ? >"}
{"text":"Determine the position of the third person on regular N sided polygon | Function to find out the number of that vertices ; Another person can 't stand on  vertex on which 2 children stand. ; calculating minimum jumps from each vertex . ; Calculate sum of jumps . ; Driver code ; Calling function","code":"< ? php function vertices ( $ N , $ A , $ B ) { $ position = 0 ; $ minisum = PHP_INT_MAX ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i == $ A $ i == $ B ) continue ; else { $ x = abs ( $ i - $ A ) ; $ y = abs ( $ i - $ B ) ; $ sum = $ x + $ y ; if ( $ sum < $ minisum ) { $ minisum = $ sum ; $ position = $ i ; } } } return $ position ; } $ N = 3 ; $ A = 1 ; $ B = 2 ; echo \" Vertex = \" ? >"}
{"text":"Find sum of factorials in an array | Function to return the factorial of n ; Function to return the sum of factorials of the array elements ; To store the required sum ; Add factorial of all the elements ; Driver code","code":"< ? php function factorial ( $ n ) { $ f = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ f *= $ i ; } return $ f ; } function sumFactorial ( $ arr , $ n ) { $ s = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s += factorial ( $ arr [ $ i ] ) ; } return $ s ; } $ arr = array ( 7 , 3 , 5 , 4 , 8 ) ; $ n = sizeof ( $ arr ) ; echo sumFactorial ( $ arr , $ n ) ; ? >"}
{"text":"Highest power of 2 that divides a number represented in binary | Function to return the highest power of 2 which divides the given binary number ; To store the highest required power of 2 ; Counting number of consecutive zeros from the end in the given binary string ; Driver code","code":"< ? php function highestPower ( $ str , $ len ) { $ ans = 0 ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == '0' ) $ ans ++ ; else break ; } return $ ans ; } $ str = \"100100\" ; $ len = strlen ( $ str ) ; echo highestPower ( $ str , $ len ) ; ? >"}
{"text":"Number of ways to arrange K different objects taking N objects at a time | PHP implementation of the approach ; Function to return n ! % p ; $res = 1 ; Initialize result ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Returns n ^ ( - 1 ) mod p ; Returns nCr % p using Fermat 's little theorem. ; Base case ; Fill factorial array so that we can find all factorial of r , n and n - r ; Function to return the number of ways to arrange K different objects taking N objects at a time ; Driver Code ; Function call","code":"< ? php $ mod = ( 1e9 + 7 ) ; function factorial ( $ n , $ p ) { for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = ( $ res * $ i ) % $ p ; return $ res ; } function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( ( $ y & 1 ) == 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modInverse ( $ n , $ p ) { return power ( $ n , $ p - 2 , $ p ) ; } function nCrModP ( $ n , $ r , $ p ) { if ( $ r == 0 ) return 1 ; $ fac = array ( ( int ) $ n + 1 ) ; $ fac [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i % $ p ; return ( $ fac [ ( int ) $ n ] * modInverse ( $ fac [ ( int ) $ r ] , $ p ) % $ p * modInverse ( $ fac [ ( int ) $ n - ( int ) $ r ] , $ p ) % $ p ) % $ p ; } function countArrangements ( $ n , $ k , $ p ) { return ( factorial ( $ n , $ p ) * nCrModP ( $ k , $ n , $ p ) ) % $ p ; } { $ N = 5 ; $ K = 8 ; echo ( countArrangements ( $ N , $ K , $ mod ) ) ; }"}
{"text":"Find maximum product of digits among numbers less than or equal to N | Function that returns the maximum product of digits among numbers less than or equal to N ; Driver code","code":"< ? php function maxProd ( $ N ) { if ( $ N == 0 ) return 1 ; if ( $ N < 10 ) return $ N ; return max ( maxProd ( ( int ) ( $ N \/ 10 ) ) * ( $ N % 10 ) , maxProd ( ( int ) ( $ N \/ 10 ) - 1 ) * 9 ) ; } $ N = 390 ; echo maxProd ( $ N ) ; ? >"}
{"text":"Check if a number from every row can be selected such that xor of the numbers is greater than zero | PHP program to implement the above approach ; Function to check if a number from every row can be selected such that xor of the numbers is greater than zero ; Find the xor of first column for every row ; If Xorr is 0 ; Traverse in the matrix ; Check is atleast 2 distinct elements ; Driver code","code":"< ? php $ N = 2 ; $ M = 3 ; function check ( $ mat ) { global $ N ; global $ M ; $ xorr = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ xorr = $ xorr ^ $ mat [ $ i ] [ 0 ] ; } if ( $ xorr != 0 ) return true ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ M ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ i ] [ 0 ] ) return true ; } } return false ; } $ mat = array ( array ( 7 , 7 , 7 ) , array ( 10 , 10 , 7 ) ) ; if ( check ( $ mat ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sum of the series 1 , 2 , 4 , 3 , 5 , 7 , 9 , 6 , 8 , 10 , 11 , 13. . till N | Function to find the sum of first N odd numbers ; Function to find the sum of first N even numbers ; Function to overall find the sum of series ; Initial odd numbers ; Initial even numbers ; First power of 2 ; Check for parity for odd \/ even ; Counts the sum ; Get the minimum out of remaining num or power of 2 ; Decrease that much numbers from num ; If the segment has odd numbers ; Summate the odd numbers By exclusion ; Increase number of odd numbers ; If the segment has even numbers ; Summate the even numbers By exclusion ; Increase number of even numbers ; Next set of numbers ; Change parity for odd \/ even ; Driver code","code":"< ? php function sumodd ( $ n ) { return ( $ n * $ n ) ; } function sumeven ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; } function findSum ( $ num ) { $ sumo = 0 ; $ sume = 0 ; $ x = 1 ; $ cur = 0 ; $ ans = 0 ; while ( $ num > 0 ) { $ inc = min ( $ x , $ num ) ; $ num -= $ inc ; if ( $ cur == 0 ) { $ ans = $ ans + sumodd ( $ sumo + $ inc ) - sumodd ( $ sumo ) ; $ sumo += $ inc ; } else { $ ans = $ ans + sumeven ( $ sume + $ inc ) - sumeven ( $ sume ) ; $ sume += $ inc ; } $ x *= 2 ; $ cur ^= 1 ; } return $ ans ; } $ n = 4 ; echo findSum ( $ n ) ; ? >"}
{"text":"Find the nth term of the given series | Function to return the nth term of the given series ; Driver code","code":"< ? php function oddTriangularNumber ( $ N ) { return ( $ N * ( ( 2 * $ N ) - 1 ) ) ; } $ N = 3 ; echo oddTriangularNumber ( $ N ) ; ? >"}
{"text":"Check if given two straight lines are identical or not | Function to check if they are identical ; Driver Code","code":"< ? php function idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { if ( ( $ a1 \/ $ a2 == $ b1 \/ $ b2 ) && ( $ a1 \/ $ a2 == $ c1 \/ $ c2 ) && ( $ b1 \/ $ b2 == $ c1 \/ $ c2 ) ) echo \" The \u2581 given \u2581 straight \u2581 lines \u2581 are \u2581 identical \" , \" STRNEWLINE \" ; else echo \" The \u2581 given \u2581 straight \u2581 lines \u2581 are \u2581 not \u2581 identical \" , \" STRNEWLINE \" ; } $ a1 = -2 ; $ b1 = 4 ; $ c1 = 3 ; $ a2 = -6 ; $ b2 = 12 ; $ c2 = 9 ; idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) ; ? >"}
{"text":"Equation of straight line passing through a given point which bisects it into two equal line segments | Function to print the equation of the required line ; Driver code","code":"< ? php function line ( $ x0 , $ y0 ) { $ c = 2 * $ y0 * $ x0 ; echo $ y0 , \" x \" , \" \u2581 + \u2581 \" , $ x0 , \" y \u2581 = \u2581 \" , $ c ; } $ x0 = 4 ; $ y0 = 3 ; line ( $ x0 , $ y0 ) ; ? >"}
{"text":"Find the original matrix when largest element in a row and a column are given | PHP implementation of the approach ; Function that prints the original matrix ; Iterate in the row ; Iterate in the column ; If previously existed an element ; Driver code","code":"< ? php $ N = 3 ; $ M = 7 ; function printOriginalMatrix ( $ a , $ b , $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) echo min ( $ a [ $ i ] , $ b [ $ j ] ) . \" \u2581 \" ; else echo \"0\" . \" \u2581 \" ; } echo \" \\r STRNEWLINE \" ; } } $ a = array ( 2 , 1 , 3 ) ; $ b = array ( 2 , 3 , 0 , 0 , 2 , 0 , 1 ) ; $ mat = array ( array ( 1 , 0 , 0 , 0 , 1 , 0 , 0 ) , array ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ) , array ( 1 , 1 , 0 , 0 , 0 , 0 , 0 ) ) ; printOriginalMatrix ( $ a , $ b , $ mat ) ; ? >"}
{"text":"Calculate the loss incurred in selling the given items at discounted price | Function to return the x % of n ; Function to return the total loss ; To store the total loss ; Original price of the item ; The price at which the item will be sold ; The discounted price of the item ; Loss incurred ; Driver code ; Total items","code":"< ? php function percent ( $ n , $ x ) { $ p = ( int ) ( $ n ) * $ x ; $ p \/= 100 ; return $ p ; } function getLoss ( $ price , $ quantity , $ X , $ n ) { $ loss = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ originalPrice = $ price [ $ i ] ; $ sellingPrice = $ originalPrice + percent ( $ originalPrice , $ X [ $ i ] ) ; $ afterDiscount = $ sellingPrice - percent ( $ sellingPrice , $ X [ $ i ] ) ; $ loss += ( ( $ originalPrice - $ afterDiscount ) * $ quantity [ $ i ] ) ; } return $ loss ; } $ price = array ( 20 , 48 , 200 , 100 ) ; $ quantity = array ( 20 , 48 , 1 , 1 ) ; $ X = array ( 0 , 48 , 200 , 5 ) ; $ n = count ( $ X ) ; echo getLoss ( $ price , $ quantity , $ X , $ n ) ; ? >"}
{"text":"Maximum difference between two elements in an Array | Function to return the maximum absolute difference between any two elements of the array ; To store the minimum and the maximum elements from the array ; Driver code","code":"< ? php function maxAbsDiff ( $ arr , $ n ) { $ minEle = $ arr [ 0 ] ; $ maxEle = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ minEle = min ( $ minEle , $ arr [ $ i ] ) ; $ maxEle = max ( $ maxEle , $ arr [ $ i ] ) ; } return ( $ maxEle - $ minEle ) ; } $ arr = array ( 2 , 1 , 5 , 3 ) ; $ n = sizeof ( $ arr ) ; echo maxAbsDiff ( $ arr , $ n ) ;"}
{"text":"Maximize the maximum subarray sum after removing atmost one element | Function to return the maximum sub - array sum ; Initialized ; Traverse in the array ; Increase the sum ; If sub - array sum is more than the previous ; If sum is negative ; Function that returns the maximum sub - array sum after removing an element from the same sub - array ; Maximum sub - array sum using Kadane 's Algorithm ; Re - apply Kadane 's with minor changes ; Increase the sum ; If sub - array sum is greater than the previous ; If elements are 0 , no removal ; If elements are more , then store the minimum value in the sub - array obtained till now ; If sum is negative ; Re - initialize everything ; Driver code","code":"< ? php function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; } function maximizeSum ( $ a , $ n ) { $ cnt = 0 ; $ mini = PHP_INT_MAX ; $ minSubarray = PHP_INT_MAX ; $ sum = maxSubArraySum ( $ a , $ n ) ; $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; $ cnt ++ ; $ minSubarray = min ( $ a [ $ i ] , $ minSubarray ) ; if ( $ sum == $ max_ending_here ) { if ( $ cnt == 1 ) $ mini = min ( $ mini , 0 ) ; else $ mini = min ( $ mini , $ minSubarray ) ; } if ( $ max_ending_here < 0 ) { $ max_ending_here = 0 ; $ cnt = 0 ; $ minSubarray = PHP_INT_MAX ; } } return $ sum - $ mini ; } $ a = array ( 1 , 2 , 3 , -2 , 3 ) ; $ n = sizeof ( $ a ) \/ sizeof ( $ a [ 0 ] ) ; echo maximizeSum ( $ a , $ n ) ; ? >"}
{"text":"3 | Function that returns true if n is an Osiris number ; 3 rd digit ; 2 nd digit ; 1 st digit ; Check the required condition ; Driver code","code":"< ? php function isOsiris ( $ n ) { $ a = $ n % 10 ; $ b = floor ( $ n \/ 10 ) % 10 ; $ c = floor ( $ n \/ 100 ) ; $ digit_sum = $ a + $ b + $ c ; if ( $ n == ( 2 * ( $ digit_sum ) * 11 ) ) { return true ; } return false ; } $ n = 132 ; if ( isOsiris ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Dudeney Numbers | Function that returns true if n is a Dudeney number ; If n is not a perfect cube ; Last digit ; Update the digit sum ; Remove the last digit ; If cube root of n is not equal to the sum of its digits ; Driver code","code":"< ? php function isDudeney ( $ n ) { $ cube_rt = floor ( round ( ( pow ( $ n , 1.0 \/ 3.0 ) ) ) ) ; if ( $ cube_rt * $ cube_rt * $ cube_rt != $ n ) return false ; $ dig_sum = 0 ; $ temp = $ n ; while ( $ temp > 0 ) { $ rem = $ temp % 10 ; $ dig_sum += $ rem ; $ temp = $ temp \/ 10 ; } if ( $ cube_rt != $ dig_sum ) return false ; return true ; } $ n = 17576 ; if ( isDudeney ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Number of triangles possible with given lengths of sticks which are powers of 2 | Function to return the number of positive area triangles ; To store the count of total triangles ; To store the count of pairs of sticks with equal lengths ; Back - traverse and count the number of triangles ; Count the number of pairs ; If we have one remaining stick and we have a pair ; Count 1 triangle ; Reduce one pair ; Count the remaining triangles that can be formed ; Driver code","code":"< ? php Function countTriangles ( $ a , $ n ) { $ cnt = 0 ; $ pairs = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ pairs += $ a [ $ i ] \/ 2 ; if ( $ a [ $ i ] % 2 == 1 && $ pairs > 0 ) { $ cnt += 1 ; $ pairs -= 1 ; } } $ cnt += ( int ) ( ( 2 * $ pairs ) \/ 3 ) ; return $ cnt ; } $ a = array ( 1 , 2 , 2 , 2 , 2 ) ; $ n = sizeof ( $ a ) ; echo ( countTriangles ( $ a , $ n ) ) ; ? >"}
{"text":"Smallest N digit number which is a multiple of 5 | Function to return the smallest n digit number which is a multiple of 5 ; Driver code","code":"< ? php function smallestMultiple ( $ n ) { if ( $ n == 1 ) return 5 ; return pow ( 10 , $ n - 1 ) ; } $ n = 4 ; echo smallestMultiple ( $ n ) ; ? >"}
{"text":"Find HCF of two numbers without using recursion or Euclidean algorithm | Function to return the HCF of x and y ; Minimum of the two numbers ; If both the numbers are divisible by the minimum of these two then the HCF is equal to the minimum ; Highest number between 2 and minimum \/ 2 which can divide both the numbers is the required HCF ; If both the numbers are divisible by i ; 1 divides every number ; Driver code","code":"< ? php function getHCF ( $ x , $ y ) { $ minimum = min ( $ x , $ y ) ; if ( $ x % $ minimum == 0 && $ y % $ minimum == 0 ) return $ minimum ; for ( $ i = $ minimum \/ 2 ; $ i >= 2 ; $ i -- ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) return $ i ; } return 1 ; } $ x = 16 ; $ y = 32 ; echo ( getHCF ( $ x , $ y ) ) ; ? >"}
{"text":"Check if product of first N natural numbers is divisible by their sum | Function that returns true if n is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that return true if the product of the first n natural numbers is divisible by the sum of first n natural numbers ; Driver code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isDivisible ( $ n ) { if ( isPrime ( $ n + 1 ) ) return false ; return true ; } $ n = 6 ; if ( isDivisible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Maximum sum of cocktail glass in a 2D matrix | PHP implementation of the approach ; Function to return the maximum sum of a cocktail glass ; If no cocktail glass is possible ; Initialize max_sum with the mini ; Here loop runs ( R - 2 ) * ( C - 2 ) times considering different top left cells of cocktail glasses ; Considering mat [ i ] [ j ] as the top left cell of the cocktail glass ; Update the max_sum ; Driver code","code":"< ? php $ R = 5 ; $ C = 5 ; function findMaxCock ( $ ar ) { global $ R , $ C ; if ( $ R < 3 $ C < 3 ) return -1 ; $ max_sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ R - 2 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C - 2 ; $ j ++ ) { $ sum = ( $ ar [ $ i ] [ $ j ] + $ ar [ $ i ] [ $ j + 2 ] ) + ( $ ar [ $ i + 1 ] [ $ j + 1 ] ) + ( $ ar [ $ i + 2 ] [ $ j ] + $ ar [ $ i + 2 ] [ $ j + 1 ] + $ ar [ $ i + 2 ] [ $ j + 2 ] ) ; $ max_sum = max ( $ max_sum , $ sum ) ; } } return $ max_sum ; } $ ar = array ( array ( 0 , 3 , 0 , 6 , 0 ) , array ( 0 , 1 , 1 , 0 , 0 ) , array ( 1 , 1 , 1 , 0 , 0 ) , array ( 0 , 0 , 2 , 0 , 1 ) , array ( 0 , 2 , 0 , 1 , 3 ) ) ; echo ( findMaxCock ( $ ar ) ) ; ? >"}
{"text":"Find the number of sub arrays in the permutation of first N natural numbers such that their median is M | Function to return the count of sub - arrays in the given permutation of first n natural numbers such that their median is m ; If element is less than m ; If element greater than m ; If m is found ; Count the answer ; Increment sum ; Driver code","code":"< ? php function segments ( $ n , $ p , $ m ) { $ c = array ( ) ; $ c [ 0 ] = 1 ; $ has = false ; $ sum = 0 ; $ ans = 0 ; for ( $ r = 0 ; $ r < $ n ; $ r ++ ) { if ( $ p [ $ r ] < $ m ) $ sum -- ; else if ( $ p [ $ r ] > $ m ) $ sum ++ ; if ( $ p [ $ r ] == $ m ) $ has = true ; if ( $ has ) $ ans += $ c [ $ sum ] + $ c [ $ sum - 1 ] ; else $ c [ $ sum ] ++ ; } return $ ans ; } $ a = array ( 2 , 4 , 5 , 3 , 1 ) ; $ n = count ( $ a ) ; $ m = 4 ; echo segments ( $ n , $ a , $ m ) ; ? >"}
{"text":"Program to calculate the number of odd days in given number of years | Function to return the count of odd days ; Count of years divisible by 100 and 400 ; Every 4 th year is a leap year ; Every 100 th year is divisible by 4 but is not a leap year ; Every 400 th year is divisible by 100 but is a leap year ; Total number of extra days ; modulo ( 7 ) for final answer ; Number of days","code":"< ? php function oddDays ( $ N ) { $ hund1 = floor ( $ N \/ 100 ) ; $ hund4 = floor ( $ N \/ 400 ) ; $ leap = $ N >> 2 ; $ ord = $ N - $ leap ; if ( $ hund1 ) { $ ord += $ hund1 ; $ leap -= $ hund1 ; } if ( $ hund4 ) { $ ord -= $ hund4 ; $ leap += $ hund4 ; } $ days = $ ord + $ leap * 2 ; $ odd = $ days % 7 ; return $ odd ; } $ N = 100 ; echo oddDays ( $ N ) ; ? >"}
{"text":"Largest ellipse that can be inscribed within a rectangle which in turn is inscribed within a semicircle | Function to find the area of the biggest ellipse ; the radius cannot be negative ; area of the ellipse ; Driver code","code":"< ? php function ellipsearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3.14 * $ r * $ r ) \/ 4 ; return $ a ; } $ r = 5 ; echo ellipsearea ( $ r ) . \" STRNEWLINE \" ; ? >"}
{"text":"Count all prefixes of the given binary array which are divisible by x | Function to return the count of total binary prefix which are divisible by x ; Initialize with zero ; Convert all prefixes to decimal ; If number is divisible by x then increase count ; Driver code","code":"< ? php function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = $ number * 2 + $ arr [ $ i ] ; if ( ( $ number % $ x == 0 ) ) $ count += 1 ; } return $ count ; } $ arr = array ( 1 , 0 , 1 , 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; $ x = 2 ; echo CntDivbyX ( $ arr , $ n , $ x ) ;"}
{"text":"Count consecutive pairs of same elements | Function to return the count of consecutive elements in the array which are equal ; If consecutive elements are same ; Driver code","code":"< ? php function countCon ( $ ar , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ cnt ++ ; } return $ cnt ; } $ ar = array ( 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 ) ; $ n = sizeof ( $ ar ) ; echo countCon ( $ ar , $ n ) ; ? >"}
{"text":"Reduce the fraction to its lowest form | Function to reduce a fraction to its lowest form ; Driver Code","code":"< ? php function reduceFraction ( $ x , $ y ) { $ d ; $ d = __gcd ( $ x , $ y ) ; $ x = $ x \/ $ d ; $ y = $ y \/ $ d ; echo ( \" x \u2581 = \u2581 \" . $ x . \" , y = \" } function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } $ x = 16 ; $ y = 10 ; reduceFraction ( $ x , $ y ) ; ? >"}
{"text":"Times required by Simple interest for the Principal to become Y times itself | Function to return the no . of years ; Driver code","code":"< ? php function noOfYears ( $ t1 , $ n1 , $ t2 ) { $ years = ( ( $ t2 - 1 ) * $ n1 \/ ( $ t1 - 1 ) ) ; return $ years ; } $ T1 = 3 ; $ N1 = 5 ; $ T2 = 6 ; print ( noOfYears ( $ T1 , $ N1 , $ T2 ) ) ; ? >"}
{"text":"Check if a given number divides the sum of the factorials of its digits | Function that returns true if n divides the sum of the factorials of its digits ; To store factorials of digits ; To store sum of the factorials of the digits ; Store copy of the given number ; Store sum of the factorials of the digits ; If it is divisible ; Driver code","code":"< ? php function isPossible ( $ n ) { $ fac = array ( ) ; $ fac [ 0 ] = $ fac [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 10 ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i ; $ sum = 0 ; $ x = $ n ; while ( $ x ) { $ sum += $ fac [ $ x % 10 ] ; $ x \/= 10 ; } if ( $ sum % $ n == 0 ) return true ; return false ; } $ n = 19 ; if ( isPossible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find the longest subsequence of an array having LCM at most K | Function to find the longest subsequence having LCM less than or equal to K ; Map to store unique elements and their frequencies ; Update the frequencies ; Array to store the count of numbers whom 1 <= X <= K is a multiple of ; Check every unique element ; Find all its multiples <= K ; Store its frequency ; Obtain the number having maximum count ; Condition to check if answer doesn 't exist ; Print the answer ; Driver code","code":"< ? php function findSubsequence ( $ arr , $ n , $ k ) { $ M = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ M [ $ arr [ $ i ] ] = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) ++ $ M [ $ arr [ $ i ] ] ; $ numCount = array ( ) ; for ( $ i = 0 ; $ i <= $ k ; ++ $ i ) $ numCount [ $ i ] = 0 ; foreach ( $ M as $ key = > $ value ) { if ( $ key <= $ k ) { for ( $ i = 1 ; ; ++ $ i ) { if ( $ key * $ i > $ k ) break ; $ numCount [ $ key * $ i ] += $ value ; } } else break ; } $ lcm = 0 ; $ length = 0 ; for ( $ i = 1 ; $ i <= $ k ; ++ $ i ) { if ( $ numCount [ $ i ] > $ length ) { $ length = $ numCount [ $ i ] ; $ lcm = $ i ; } } if ( $ lcm == 0 ) echo - 1 << \" STRNEWLINE \" ; else { echo \" LCM = \" , \u2581 $ lcm , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" , Length = \" , \u2581 $ length , \u2581 \" \" ; STRNEWLINE TABSYMBOL TABSYMBOL echo \u2581 \" Indexes = \" for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ lcm % $ arr [ $ i ] == 0 ) echo $ i , \" \u2581 \" ; } } $ k = 14 ; $ arr = array ( 2 , 3 , 4 , 5 ) ; $ n = count ( $ arr ) ; findSubsequence ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Count number of binary strings of length N having only 0 ' s \u2581 and \u2581 1' s | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Function to count the number of binary strings of length N having only 0 ' s \u2581 and \u2581 1' s ; Driver code","code":"< ? php function power ( $ x , $ y ) { $ p = 1000000007 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function findCount ( $ N ) { $ count = power ( 2 , $ N ) ; return $ count ; } $ N = 25 ; echo findCount ( $ N ) ; ? >"}
{"text":"XOR of all the elements in the given range [ L , R ] | Function to return the most significant bit ; Function to return the required XOR ; Finding the MSB ; Value of the current bit to be added ; To store the final answer ; Loop for case 1 ; Edge case when both the integers lie in the same segment of continuous 1 s ; To store whether parity of count is odd ; Updating the answer if parity is odd ; Updating the number to be added ; Case 2 ; Driver code ; Final answer","code":"< ? php function msb ( $ x ) { $ ret = 0 ; while ( ( $ x >> ( $ ret + 1 ) ) != 0 ) $ ret ++ ; return $ ret ; } function xorRange ( $ l , $ r ) { $ max_bit = msb ( $ r ) ; $ mul = 2 ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ max_bit ; $ i ++ ) { if ( ( int ) ( ( $ l \/ $ mul ) * $ mul ) == ( int ) ( ( $ r \/ $ mul ) * $ mul ) ) { if ( ( ( $ l & ( 1 << $ i ) ) != 0 ) && ( $ r - $ l + 1 ) % 2 == 1 ) $ ans += $ mul ; $ mul *= 2 ; continue ; } $ odd_c = 0 ; if ( ( ( $ l & ( 1 << $ i ) ) != 0 ) && $ l % 2 == 1 ) $ odd_c = ( $ odd_c ^ 1 ) ; if ( ( ( $ r & ( 1 << $ i ) ) != 0 ) && $ r % 2 == 0 ) $ odd_c = ( $ odd_c ^ 1 ) ; if ( $ odd_c ) $ ans += $ mul ; $ mul *= 2 ; } $ zero_bit_cnt = ( int ) ( ( $ r - $ l + 1 ) \/ 2 ) ; if ( $ l % 2 == 1 && $ r % 2 == 1 ) $ zero_bit_cnt ++ ; if ( $ zero_bit_cnt % 2 == 1 ) $ ans ++ ; return $ ans ; } $ l = 1 ; $ r = 4 ; echo xorRange ( $ l , $ r ) ; ? >"}
{"text":"XOR of all the elements in the given range [ L , R ] | Function to return the required XOR ; Modulus operator are expensive on most of the computers . n & 3 will be equivalent to n % 4 n % 4 ; If n is a multiple of 4 ; If n % 4 gives remainder 1 ; If n % 4 gives remainder 2 ; If n % 4 gives remainder 3 ; Driver code","code":"< ? php function computeXOR ( $ n ) { $ x = $ n & 3 ; switch ( $ x ) { case 0 : return $ n ; case 1 : return 1 ; case 2 : return $ n + 1 ; case 3 : return 0 ; } return 0 ; } $ l = 1 ; $ r = 4 ; echo ( computeXOR ( $ r ) ^ computeXOR ( $ l - 1 ) ) ; ? >"}
{"text":"Find the number of integers from 1 to n which contains digits 0 ' s \u2581 and \u2581 1' s only | Function to find the number of integers from 1 to n which contains 0 ' s \u2581 and \u2581 1' s only ; If number is greater than n ; otherwise add count this number and call two functions ; Driver code","code":"< ? php function countNumbers ( $ x , $ n ) { if ( $ x > $ n ) return 0 ; return 1 + countNumbers ( $ x * 10 , $ n ) + countNumbers ( $ x * 10 + 1 , $ n ) ; } $ n = 120 ; echo ( countNumbers ( 1 , $ n ) ) ; ? >"}
{"text":"Check if factorial of N is divisible by the sum of squares of first N natural numbers | Function to count number of times prime P divide factorial N ; Lengendre Formula ; Function to find count number of times all prime P divide summation ; Formula for summation of square after removing n and constant 6 ; Loop to traverse over all prime P which divide summation ; If Number itself is a Prime Number ; Driver Code","code":"< ? php function checkfact ( $ N , $ countprime , $ prime ) { $ countfact = 0 ; if ( $ prime == 2 $ prime == 3 ) $ countfact ++ ; $ divide = $ prime ; while ( ( int ) ( $ N \/ $ divide ) != 0 ) { $ countfact += ( int ) ( $ N \/ $ divide ) ; $ divide = $ divide * $ divide ; } if ( $ countfact >= $ countprime ) return true ; else return false ; } function check ( $ N ) { $ sumsquares = ( $ N + 1 ) * ( 2 * $ N + 1 ) ; $ countprime = 0 ; for ( $ i = 2 ; $ i <= sqrt ( $ sumsquares ) ; $ i ++ ) { $ flag = 0 ; while ( $ sumsquares % $ i == 0 ) { $ flag = 1 ; $ countprime ++ ; $ sumsquares = ( int ) ( $ sumsquares \/ $ i ) ; } if ( $ flag == 1 ) { if ( checkfact ( $ N - 1 , $ countprime , $ i ) ) return false ; $ countprime = 0 ; } } if ( $ sumsquares != 1 ) if ( checkfact ( $ N - 1 , 1 , $ sumsquares ) ) return false ; return true ; } $ N = 5 ; if ( check ( $ N ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Count the number of non | PHP program to count number of non increasing subarrays ; Initialize result ; Initialize length of current non increasing subarray ; Traverse through the array ; If arr [ i + 1 ] is less than or equal to arr [ i ] , then increment length ; Else Update count and reset length ; If last length is more than 1 ; Driver code","code":"< ? php function countNonIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] <= $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( $ len + 1 ) * $ len ) \/ 2 ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( $ len + 1 ) * $ len ) \/ 2 ; return $ cnt ; } $ arr = array ( 5 , 2 , 3 , 7 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; echo countNonIncreasing ( $ arr , $ n ) ; ? >"}
{"text":"Find the good permutation of first N natural numbers | Function to print the good permutation of first N natural numbers ; If n is odd ; Otherwise ; Driver code","code":"< ? php function printPermutation ( $ n ) { if ( $ n % 2 != 0 ) { echo ( \" - 1\" ) ; } else for ( $ i = 1 ; $ i <= $ n \/ 2 ; $ i ++ ) { echo ( 2 * $ i . \" \u2581 \" . ( ( 2 * $ i ) - 1 ) . \" \u2581 \" ) ; } return $ n ; } $ n = 4 ; printPermutation ( $ n ) ; ? >"}
{"text":"Minimum number operations required to convert n to m | Set | PHP implementation of the above approach ; Function to find the minimum number of steps ; If n exceeds M ; If N reaches the target ; The minimum of both the states will be the answer ; Driver code","code":"< ? php $ MAXN = 10000000 ; function minimumSteps ( $ n , $ m , $ a , $ b ) { global $ MAXN ; if ( $ n > $ m ) return $ MAXN ; if ( $ n == $ m ) return 0 ; return min ( 1 + minimumSteps ( $ n * $ a , $ m , $ a , $ b ) , 1 + minimumSteps ( $ n * $ b , $ m , $ a , $ b ) ) ; } $ n = 120 ; $ m = 51840 ; $ a = 2 ; $ b = 3 ; echo minimumSteps ( $ n , $ m , $ a , $ b ) ; ? >"}
{"text":"Minimum number of given operation required to convert n to m | Function to return the minimum operations required ; Counting all 2 s ; Counting all 3 s ; If q contained only 2 and 3 as the only prime factors then it must be 1 now ; Driver code","code":"< ? php function minOperations ( $ n , $ m ) { if ( $ m % $ n != 0 ) return -1 ; $ minOperations = 0 ; $ q = $ m \/ $ n ; while ( $ q % 2 == 0 ) { $ q = $ q \/ 2 ; $ minOperations ++ ; } while ( $ q % 3 == 0 ) { $ q = $ q \/ 3 ; $ minOperations ++ ; } if ( $ q == 1 ) return $ minOperations ; return -1 ; } $ n = 120 ; $ m = 51840 ; echo ( minOperations ( $ n , $ m ) ) ; ? >"}
{"text":"Sum of Fibonacci Numbers in a range | Function to return the nth Fibonacci number ; Function to return the required sum ; To store the sum ; Calculate the sum ; Driver code","code":"< ? php function fib ( $ n ) { $ phi = ( 1 + sqrt ( 5 ) ) \/ 2 ; return ( int ) round ( pow ( $ phi , $ n ) \/ sqrt ( 5 ) ) ; } function calculateSum ( $ l , $ r ) { $ sum = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) $ sum += fib ( $ i ) ; return $ sum ; } $ l = 4 ; $ r = 8 ; echo calculateSum ( $ l , $ r ) ; ? >"}
{"text":"Largest sphere that can be inscribed within a cube which is in turn inscribed within a right circular cone | Function to find the radius of the sphere ; height and radius cannot be negative ; radius of the sphere ; Driver code","code":"< ? php function sphereSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ R = ( ( $ h * $ r * sqrt ( 2 ) ) \/ ( $ h + sqrt ( 2 ) * $ r ) ) \/ 2 ; return $ R ; } $ h = 5 ; $ r = 6 ; echo ( sphereSide ( $ h , $ r ) ) ; ? >"}
{"text":"Find the number of ways to divide number into four parts such that a = c and b = d | Function to find the number of ways to divide N into four parts such that a = c and b = d ; Driver code","code":"< ? php function possibleways ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else if ( $ n % 4 == 0 ) return $ n \/ 4 - 1 ; else return $ n \/ 4 ; } $ n = 20 ; echo possibleways ( $ n ) ; ? >"}
{"text":"Count sub | Function to count sub - arrays whose product is divisible by K ; Calculate the product of the current sub - array ; If product of the current sub - array is divisible by K ; Driver code","code":"< ? php function countSubarrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ product = 1 ; for ( $ x = $ i ; $ x <= $ j ; $ x ++ ) $ product *= $ arr [ $ x ] ; if ( $ product % $ K == 0 ) $ count ++ ; } } return $ count ; } $ arr = array ( 6 , 2 , 8 ) ; $ n = count ( $ arr ) ; $ K = 4 ; echo countSubarrays ( $ arr , $ n , $ K ) ; ? >"}
{"text":"Find a pair from the given array with maximum nCr value | Function to print the pair that gives maximum nCr ; This gives the value of N in nCr ; Case 1 : When N is odd ; Case 2 : When N is even ; Driver code","code":"< ? php function printMaxValPair ( $ v , $ n ) { sort ( $ v ) ; $ N = $ v [ $ n - 1 ] ; if ( $ N % 2 == 1 ) { $ first_maxima = $ N \/ 2 ; $ second_maxima = $ first_maxima + 1 ; $ ans1 = 3e18 ; $ ans2 = 3e18 ; $ from_left = -1 ; $ from_right = -1 ; $ from = -1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ v [ $ i ] > $ first_maxima ) { $ from = $ i ; break ; } else { $ diff = $ first_maxima - $ v [ $ i ] ; if ( $ diff < $ ans1 ) { $ ans1 = $ diff ; $ from_left = $ v [ $ i ] ; } } } $ from_right = $ v [ $ from ] ; $ diff1 = $ first_maxima - $ from_left ; $ diff2 = $ from_right - $ second_maxima ; if ( $ diff1 < $ diff2 ) echo $ N . \" \u2581 \" . $ from_left ; else echo $ N . \" \u2581 \" . $ from_right ; } else { $ maxima = $ N \/ 2 ; $ ans1 = 3e18 ; $ R = -1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { $ diff = abs ( $ v [ $ i ] - $ maxima ) ; if ( $ diff < $ ans1 ) { $ ans1 = $ diff ; $ R = $ v [ $ i ] ; } } echo $ N . \" \u2581 \" . $ R ; } } $ v = array ( 1 , 1 , 2 , 3 , 6 , 1 ) ; $ n = count ( $ v ) ; printMaxValPair ( $ v , $ n ) ; ? >"}
{"text":"Find the number of good permutations | Function to return the count of good permutations ; For m = 0 , ans is 1 ; If k is greater than 1 ; If k is greater than 2 ; If k is greater than 3 ; Driver code","code":"< ? php function Permutations ( $ n , $ k ) { $ ans = 1 ; if ( $ k >= 2 ) $ ans += ( $ n ) * ( $ n - 1 ) \/ 2 ; if ( $ k >= 3 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * 2 \/ 6 ; if ( $ k >= 4 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) * 9 \/ 24 ; return $ ans ; } $ n = 5 ; $ k = 2 ; echo ( Permutations ( $ n , $ k ) ) ; ? >"}
{"text":"Count integers in a range which are divisible by their euler totient value | Function to return a ^ n ; Function to return count of integers that satisfy n % phi ( n ) = 0 ; Driver Code","code":"< ? php function power ( $ a , $ n ) { if ( $ n == 0 ) return 1 ; $ p = power ( $ a , $ n \/ 2 ) ; $ p = $ p * $ p ; if ( $ n & 1 ) $ p = $ p * $ a ; return $ p ; } function countIntegers ( $ l , $ r ) { $ ans = 0 ; $ i = 1 ; $ v = power ( 2 , $ i ) ; while ( $ v <= $ r ) { while ( $ v <= $ r ) { if ( $ v >= $ l ) $ ans ++ ; $ v = $ v * 3 ; } $ i ++ ; $ v = power ( 2 , $ i ) ; } if ( $ l == 1 ) $ ans ++ ; return $ ans ; } $ l = 12 ; $ r = 21 ; echo countIntegers ( $ l , $ r ) ; ? >"}
{"text":"Number of pairs from the first N natural numbers whose sum is divisible by K | Function to find the number of pairs from the set of natural numbers up to N whose sum is divisible by K ; Declaring a Hash to store count ; Storing the count of integers with a specific remainder in Hash array ; Check if K is even ; Count of pairs when both integers are divisible by K ; Count of pairs when one remainder is R and other remainder is K - R ; Count of pairs when both the remainders are K \/ 2 ; Count of pairs when both integers are divisible by K ; Count of pairs when one remainder is R and other remainder is K - R ; Driver code ; Print the count of pairs","code":"< ? php function findPairCount ( $ N , $ K ) { $ count = 0 ; $ rem = array ( 0 , $ K , NULL ) ; $ rem [ 0 ] = intval ( $ N \/ $ K ) ; for ( $ i = 1 ; $ i < $ K ; $ i ++ ) $ rem [ $ i ] = intval ( ( $ N - $ i ) \/ $ K ) + 1 ; if ( $ K % 2 == 0 ) { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) \/ 2 ) ; for ( $ i = 1 ; $ i < intval ( $ K \/ 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; $ count += ( $ rem [ intval ( $ K \/ 2 ) ] * intval ( ( $ rem [ intval ( $ K \/ 2 ) ] - 1 ) ) \/ 2 ) ; } else { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) \/ 2 ) ; for ( $ i = 1 ; $ i <= intval ( $ K \/ 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; } return $ count ; } $ N = 10 ; $ K = 4 ; echo findPairCount ( $ N , $ K ) ; ? >"}
{"text":"Find the sum of all Truncatable primes below N | PHP implementation of the approach ; To check if a number is prime or not ; Sieve of Eratosthenes function to find all prime numbers ; Function to return the sum of all truncatable primes below n ; To store the required sum ; Check every number below n ; Check from right to left ; If number is not prime at any stage ; Check from left to right ; If number is not prime at any stage ; If flag is still true ; Return the required sum ; Driver code","code":"< ? php $ N = 10005 ; $ prime = array_fill ( 0 , $ N , true ) ; function sieve ( ) { global $ prime , $ N ; $ prime [ 1 ] = false ; $ prime [ 0 ] = false ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ prime [ $ i ] ) for ( $ j = $ i * 2 ; $ j < $ N ; $ j += $ i ) $ prime [ $ j ] = false ; } function sumTruncatablePrimes ( $ n ) { global $ prime , $ N ; $ sum = 0 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ num = $ i ; $ flag = true ; while ( $ num ) { if ( ! $ prime [ $ num ] ) { $ flag = false ; break ; } $ num = ( int ) ( $ num \/ 10 ) ; } $ num = $ i ; $ power = 10 ; while ( ( int ) ( $ num \/ $ power ) ) { if ( ! $ prime [ $ num % $ power ] ) { $ flag = false ; break ; } $ power *= 10 ; } if ( $ flag ) $ sum += $ i ; } return $ sum ; } $ n = 25 ; sieve ( ) ; echo sumTruncatablePrimes ( $ n ) ; ? >"}
{"text":"Smallest and Largest N | Function to print the largest and the smallest n - digit perfect squares ; Smallest n - digit perfect square ; Largest n - digit perfect square ; Driver code","code":"< ? php function nDigitPerfectSquares ( $ n ) { echo pow ( ceil ( sqrt ( pow ( 10 , $ n - 1 ) ) ) , 2 ) , \" \" ; echo pow ( ceil ( sqrt ( pow ( 10 , $ n ) ) ) - 1 , 2 ) ; } $ n = 4 ; nDigitPerfectSquares ( $ n ) ; ? >"}
{"text":"Maximum trace possible for any sub | PHP implementation of the approach ; Function to return the maximum trace possible for a sub - matrix of the given matrix ; Calculate the trace for each of the sub - matrix with top left corner at cell ( r , s ) ; Update the maximum trace ; Return the maximum trace ; Driver code","code":"< ? php $ N = 3 ; function MaxTraceSub ( $ mat ) { global $ N ; $ max_trace = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r = $ i ; $ s = $ j ; $ trace = 0 ; while ( $ r < $ N && $ s < $ N ) { $ trace += $ mat [ $ r ] [ $ s ] ; $ r ++ ; $ s ++ ; $ max_trace = max ( $ trace , $ max_trace ) ; } } } return $ max_trace ; } $ mat = array ( array ( 10 , 2 , 5 ) , array ( 6 , 10 , 4 ) , array ( 2 , 7 , -10 ) ) ; print ( MaxTraceSub ( $ mat ) ) ; ? >"}
{"text":"Check if matrix can be converted to another matrix by transposing square sub | PHP implementation of the approach ; Function that returns true if matrix1 can be converted to matrix2 with the given operation ; Traverse all the diagonals starting at first column ; Traverse in diagonal ; Store the diagonal elements ; Move up ; Sort the elements ; Check if they are same ; Traverse all the diagonals starting at last row ; Traverse in the diagonal ; Store diagonal elements ; Sort all elements ; Check for same ; If every element matches ; Driver code","code":"< ? php $ n = 3 ; $ m = 3 ; function check ( $ a , $ b ) { global $ n , $ m ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ v1 = array ( ) ; $ v2 = array ( ) ; $ r = $ i ; $ col = 0 ; while ( $ r >= 0 && $ col < $ m ) { array_push ( $ v1 , $ a [ $ r ] [ $ col ] ) ; array_push ( $ v2 , $ b [ $ r ] [ $ col ] ) ; $ r -- ; $ col ++ ; } sort ( $ v1 ) ; sort ( $ v2 ) ; for ( $ i = 0 ; $ i < count ( $ v1 ) ; $ i ++ ) { if ( $ v1 [ $ i ] != $ v2 [ $ i ] ) return false ; } } for ( $ j = 1 ; $ j < $ m ; $ j ++ ) { $ v1 = array ( ) ; $ v2 = array ( ) ; $ r = $ n - 1 ; $ col = $ j ; while ( $ r >= 0 && $ col < $ m ) { array_push ( $ v1 , $ a [ $ r ] [ $ col ] ) ; array_push ( $ v2 , $ b [ $ r ] [ $ col ] ) ; $ r -- ; $ col ++ ; } sort ( $ v1 ) ; sort ( $ v2 ) ; for ( $ i = 0 ; $ i < count ( $ v1 ) ; $ i ++ ) { if ( $ v1 [ $ i ] != $ v2 [ $ i ] ) return false ; } } return true ; } $ a = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; $ b = array ( array ( 1 , 4 , 7 ) , array ( 2 , 5 , 6 ) , array ( 3 , 8 , 9 ) ) ; if ( check ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Last digit of Product of two Large or Small numbers ( a * b ) | Function to print last digit of product a * b ; Driver code","code":"< ? php function lastDigit ( $ a , $ b ) { $ lastDig = ( ord ( $ a [ strlen ( $ a ) - 1 ] ) - 48 ) * ( ord ( $ b [ strlen ( $ b ) - 1 ] ) - 48 ) ; echo $ lastDig % 10 ; } $ a = \"1234567891233\" ; $ b = \"1234567891233156\" ; lastDigit ( $ a , $ b ) ; ? >"}
{"text":"Smallest and Largest Palindrome with N Digits | Function to print the smallest and largest palindrome with N digits ; Driver Code","code":"< ? php function printPalindrome ( $ n ) { if ( $ n == 1 ) { echo \" Smallest \u2581 Palindrome : \u2581 0 STRNEWLINE \" ; echo \" Largest \u2581 Palindrome : \u2581 9\" ; } else { echo \" Smallest \u2581 Palindrome : \u2581 \" , pow ( 10 , $ n - 1 ) + 1 ; echo \" Largest Palindrome : \" pow ( 10 , $ n ) - 1 ; } } $ n = 4 ; printPalindrome ( $ n ) ; ? >"}
{"text":"Addition of two numbers without propagating Carry | Function to print sum of 2 numbers without propagating carry ; Reverse a ; Reverse b ; Generate sum Since length of both a and b are same , take any one of them . ; Extract digits from a and b and add ; If sum is single digit ; If sum is not single digit reverse sum ; Extract digits from sum and append to result ; Driver code","code":"< ? php function printSum ( $ a , $ b ) { $ res = 0 ; $ temp1 = 0 ; $ temp2 = 0 ; while ( $ a != 0 ) { $ temp1 = $ temp1 * 10 + ( $ a % 10 ) ; $ a = ( int ) ( $ a \/ 10 ) ; } $ a = $ temp1 ; while ( $ b != 0 ) { $ temp2 = $ temp2 * 10 + ( $ b % 10 ) ; $ b = ( int ) ( $ b \/ 10 ) ; } $ b = $ temp2 ; while ( $ a != 0 ) { $ sum = ( $ a % 10 + $ b % 10 ) ; if ( ( int ) ( $ sum \/ 10 ) == 0 ) { $ res = $ res * 10 + $ sum ; } else { $ temp1 = 0 ; while ( $ sum != 0 ) { $ temp1 = $ temp1 * 10 + ( $ sum % 10 ) ; $ sum = ( int ) ( $ sum \/ 10 ) ; } $ sum = $ temp1 ; while ( $ sum != 0 ) { $ res = $ res * 10 + ( $ sum % 10 ) ; $ sum = ( int ) ( $ sum \/ 10 ) ; } } $ a = ( int ) ( $ a \/ 10 ) ; $ b = ( int ) ( $ b \/ 10 ) ; } return $ res ; } $ a = 7752 ; $ b = 8834 ; echo ( printSum ( $ a , $ b ) ) ; ? >"}
{"text":"Number of digits before the decimal point in the division of two numbers | Function to return the number of digits before the decimal in a \/ b ; Absolute value of a \/ b ; If result is 0 ; Count number of digits in the result ; Return the required count of digits ; Driver code","code":"< ? php function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a \/ $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p \/ 10 ) ; } return $ count ; } $ a = 100 ; $ b = 10 ; echo countDigits ( $ a , $ b ) ; ? >"}
{"text":"Number of digits before the decimal point in the division of two numbers | Function to return the number of digits before the decimal in a \/ b ; Return the required count of digits ; Driver code","code":"< ? php function countDigits ( $ a , $ b ) { return floor ( log10 ( abs ( $ a ) ) - log10 ( abs ( $ b ) ) ) + 1 ; } $ a = 100 ; $ b = 10 ; echo countDigits ( $ a , $ b ) ; ? >"}
{"text":"Smallest odd number with N digits | Function to return smallest even number with n digits ; Driver Code","code":"< ? php function smallestOdd ( $ n ) { if ( $ n == 1 ) return 1 ; return pow ( 10 , $ n - 1 ) + 1 ; } $ n = 4 ; echo smallestOdd ( $ n ) ; ? >"}
{"text":"Largest Even and Odd N | Function to print the largest n - digit even and odd numbers ; Driver code","code":"< ? php function findNumbers ( $ n ) { $ odd = pow ( 10 , $ n ) - 1 ; $ even = $ odd - 1 ; echo \" Even \u2581 = \u2581 $ even \u2581 STRNEWLINE \" ; echo \" Odd \u2581 = \u2581 $ odd \" ; } $ n = 4 ; findNumbers ( $ n ) ; ? >"}
{"text":"Longest sub | Function to return the length of the longest sub - array whose product of elements is 0 ; Driver code","code":"< ? php function longestSubArray ( $ arr , $ n ) { $ isZeroPresent = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) { $ isZeroPresent = true ; break ; } } if ( $ isZeroPresent ) return $ n ; return 0 ; } $ arr = array ( 1 , 2 , 3 , 0 , 1 , 2 , 0 ) ; $ n = sizeof ( $ arr ) ; echo longestSubArray ( $ arr , $ n ) ; ? >"}
{"text":"Smallest Even number with N digits | Function to return smallest even number with n digits ; Driver Code","code":"< ? php function smallestEven ( $ n ) { if ( $ n == 1 ) return 0 ; return pow ( 10 , $ n - 1 ) ; } $ n = 4 ; echo smallestEven ( $ n ) ; ? >"}
{"text":"Maximize profit when divisibility by two numbers have associated profits | PHP implementation of the approach ; Function to return the maximum profit ; min ( x , y ) * n \/ lcm ( a , b ) ; Driver code","code":"< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function maxProfit ( $ n , $ a , $ b , $ x , $ y ) { $ res = $ x * ( $ n \/ $ a ) ; $ res += $ y * ( $ n \/ $ b ) ; $ res -= min ( $ x , $ y ) * ( $ n \/ ( ( $ a * $ b ) \/ __gcd ( $ a , $ b ) ) ) ; return $ res ; } $ n = 6 ; $ a = 6 ; $ b = 2 ; $ x = 8 ; $ y = 2 ; print ( maxProfit ( $ n , $ a , $ b , $ x , $ y ) ) ; ? >"}
{"text":"Series summation if T ( n ) is given and n is very large | PHP implementation of the approach ; Function to return the sum of the given series ; Driver code","code":"< ? php $ GLOBALS [ ' MOD ' ] = 1000000007 ; function sumOfSeries ( $ n ) { $ ans = pow ( $ n % $ GLOBALS [ ' MOD ' ] , 2 ) ; return ( $ ans % $ GLOBALS [ ' MOD ' ] ) ; } $ n = 10 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text":"Kth odd number in an array | Function to return the kth odd element from the array ; Traverse the array ; If current element is odd ; If kth odd element is found ; Total odd elements in the array are < k ; Driver code","code":"< ? php function kthOdd ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 1 ) $ k -- ; if ( $ k == 0 ) return $ arr [ $ i ] ; } return -1 ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; echo ( kthOdd ( $ arr , $ n , $ k ) ) ; ? >"}
{"text":"Find last five digits of a given five digit number raised to power five | Function to find the last five digits of a five digit number raised to power five ; Driver code","code":"< ? php function lastFiveDigits ( $ n ) { $ n = ( int ) ( $ n \/ 10000 ) * 10000 + ( ( int ) ( $ n \/ 100 ) % 10 ) * 1000 + ( $ n % 10 ) * 100 + ( ( int ) ( $ n \/ 10 ) % 10 ) * 10 + ( int ) ( $ n \/ 1000 ) % 10 ; $ ans = 1 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { $ ans *= $ n ; $ ans %= 100000 ; } echo $ ans ; } $ n = 12345 ; lastFiveDigits ( $ n ) ; ? >"}
{"text":"Sum of ( maximum element | PHP implementation of the above approach ; Function to return a ^ n % mod ; Compute sum of max ( A ) - min ( A ) for all subsets ; Sort the array . ; Maxs = 2 ^ i - 1 ; Mins = 2 ^ ( n - 1 - i ) - 1 ; Driver code","code":"< ? php $ mod = 1000000007 ; function power ( $ a , $ n ) { global $ mod ; if ( $ n == 0 ) return 1 ; $ p = power ( $ a , $ n \/ 2 ) % $ mod ; $ p = ( $ p * $ p ) % $ mod ; if ( $ n & 1 ) { $ p = ( $ p * $ a ) % $ mod ; } return $ p ; } function computeSum ( & $ arr , $ n ) { global $ mod ; sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ maxs = ( power ( 2 , $ i ) - 1 + $ mod ) % $ mod ; $ maxs = ( $ maxs * $ arr [ $ i ] ) % $ mod ; $ mins = ( power ( 2 , $ n - 1 - $ i ) - 1 + $ mod ) % $ mod ; $ mins = ( $ mins * $ arr [ $ i ] ) % $ mod ; $ V = ( $ maxs - $ mins + $ mod ) % $ mod ; $ sum = ( $ sum + $ V ) % $ mod ; } return $ sum ; } $ arr = array ( 4 , 3 , 1 ) ; $ n = sizeof ( $ arr ) ; echo computeSum ( $ arr , $ n ) ; ? >"}
{"text":"Count of all N digit numbers such that num + Rev ( num ) = 10 ^ N | Function to return the count of such numbers ; If n is odd ; Driver code","code":"< ? php function countNumbers ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; return ( 9 * ( int ) pow ( 10 , $ n \/ 2 - 1 ) ) ; } $ n = 2 ; echo ( countNumbers ( $ n ) ) ;"}
{"text":"Count of numbers having only 1 set bit in the range [ 0 , n ] | Function to return the required count ; To store the count of numbers ; Every power of 2 contains only 1 set bit ; Driver code","code":"< ? php function count_t ( $ n ) { $ cnt = 0 ; $ p = 1 ; while ( $ p <= $ n ) { $ cnt ++ ; $ p *= 2 ; } return $ cnt ; } $ n = 7 ; echo count_t ( $ n ) ; ? >"}
{"text":"Find the K | Function to find the K - th minimum element from an array concatenated M times ; Sort the elements in ascending order ; Return the K 'th Min element  present at ( (K-1) \/ M ) index ; Driver Code","code":"< ? php function KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) { sort ( $ A ) ; return ( $ A [ ( ( $ K - 1 ) \/ $ M ) ] ) ; } $ A = array ( 3 , 1 , 2 ) ; $ M = 3 ; $ K = 4 ; $ N = sizeof ( $ A ) ; echo ( KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) ) ; ? >"}
{"text":"Sum of all i such that ( 2 ^ i + 1 ) % 3 = 0 where i is in range [ 1 , n ] | Function to return the required sum ; Total odd numbers from 1 to n ; Sum of first n odd numbers ; Driver code","code":"< ? php function sumN ( $ n ) { $ n = ( int ) ( ( $ n + 1 ) \/ 2 ) ; return ( $ n * $ n ) ; } $ n = 3 ; echo sumN ( $ n ) ; ? >"}
{"text":"Numbers that are not divisible by any number in the range [ 2 , 10 ] | Function to return the count of numbers from 1 to N which are not divisible by any number in the range [ 2 , 10 ] ; Driver code","code":"< ? php function countNumbers ( $ n ) { return ( int ) ( $ n - $ n \/ 2 ) - ( int ) ( $ n \/ 3 ) - ( int ) ( $ n \/ 5 ) - ( int ) ( $ n \/ 7 ) + ( int ) ( $ n \/ 6 ) + ( int ) ( $ n \/ 10 ) + ( int ) ( $ n \/ 14 ) + ( int ) ( $ n \/ 15 ) + ( int ) ( $ n \/ 21 ) + ( int ) ( $ n \/ 35 ) - ( int ) ( $ n \/ 30 ) - ( int ) ( $ n \/ 42 ) - ( int ) ( $ n \/ 70 ) - ( int ) ( $ n \/ 105 ) + ( int ) ( $ n \/ 210 ) ; } $ n = 20 ; echo ( countNumbers ( $ n ) ) ; ? >"}
{"text":"Maximum Primes whose sum is equal to given N | Function to find max count of primes ; if n is even n \/ 2 is required answer if n is odd floor ( n \/ 2 ) = ( int ) ( n \/ 2 ) is required answer ; Driver Code","code":"< ? php function maxPrimes ( $ n ) { return ( int ) ( $ n \/ 2 ) ; } $ n = 17 ; echo maxPrimes ( $ n ) ; ? >"}
{"text":"Sum of the series ( 1 * 2 ) + ( 2 * 3 ) + ( 3 * 4 ) + ... ... upto n terms | Function to return sum ; Driver code","code":"< ? php function sum ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) \/ 3 ; } $ n = 2 ; echo sum ( $ n ) ; ? >"}
{"text":"Smallest divisor D of N such that gcd ( D , M ) is greater than 1 | PHP implementation of the above approach ; Function to find the minimum divisor ; Iterate for all factors of N ; Check for gcd > 1 ; Check for gcd > 1 ; If gcd is m itself ; Driver code","code":"< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function findMinimum ( $ n , $ m ) { $ mini = $ m ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ sec = $ n \/ $ i ; if ( __gcd ( $ m , $ i ) > 1 ) { return $ i ; } else if ( __gcd ( $ sec , $ m ) > 1 ) { $ mini = min ( $ sec , $ mini ) ; } } } if ( $ mini == $ m ) return -1 ; else return $ mini ; } $ n = 8 ; $ m = 10 ; echo ( findMinimum ( $ n , $ m ) ) ;"}
{"text":"Find Nth term of the series 1 , 5 , 32 , 288 ... | Function to generate a fixed \\ number ; Finding nth term ; Driver Code","code":"< ? php function nthTerm ( $ N ) { $ nth = 0 ; $ i ; for ( $ i = $ N ; $ i > 0 ; $ i -- ) { $ nth += pow ( $ i , $ i ) ; } return $ nth ; } $ N = 3 ; echo ( nthTerm ( $ N ) ) ; ? >"}
{"text":"Find kth smallest number in range [ 1 , n ] when all the odd numbers are deleted | Function to return the kth smallest element from the range [ 1 , n ] after removing all the odd elements ; Driver code","code":"< ? php function kthSmallest ( $ n , $ k ) { return ( 2 * $ k ) ; } $ n = 8 ; $ k = 4 ; echo ( kthSmallest ( $ n , $ k ) ) ; ? >"}
{"text":"Check if a number can be represented as sum of non zero powers of 2 | Function that return true if n can be represented as the sum of powers of 2 without using 2 ^ 0 ; Driver code","code":"< ? php function isSumOfPowersOfTwo ( $ n ) { if ( $ n % 2 == 1 ) return false ; else return true ; } $ n = 10 ; if ( isSumOfPowersOfTwo ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Minimize sum of adjacent difference with removal of one element from array | Function to find the element ; Value variable for storing the total value ; Declaring maximum value as zero ; If array contains on element ; Storing the maximum value in temp variable ; Adding the adjacent difference modulus values of removed element . Removing adjacent difference modulus value after removing element ; Returning total value - maximum value ; Drivers code","code":"< ? php function findMinRemoval ( $ arr , $ n ) { $ value = 0 ; $ maximum = 0 ; if ( $ n == 1 ) return 0 ; $ temp = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i != 0 && $ i != $ n - 1 ) { $ value = $ value + abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; $ temp = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) + abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) - abs ( $ arr [ $ i - 1 ] - $ arr [ $ i + 1 ] ) ; } else if ( $ i == 0 ) { $ value = $ value + abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; $ temp = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; } else $ temp = abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; $ maximum = max ( $ maximum , $ temp ) ; } return ( $ value - $ maximum ) ; } $ arr = array ( 1 , 5 , 3 , 2 , 10 ) ; $ n = count ( $ arr ) ; echo findMinRemoval ( $ arr , $ n ) ; ? >"}
{"text":"Time until distance gets equal to X between two objects moving in opposite direction | Function to return the time for which the two policemen can communicate ; time = distance \/ speed ; Driver code","code":"< ? php function getTime ( $ u , $ v , $ x ) { $ speed = $ u + $ v ; $ time = $ x \/ $ speed ; return $ time ; } $ u = 3 ; $ v = 3 ; $ x = 3 ; echo getTime ( $ u , $ v , $ x ) ; ? >"}
{"text":"Given number of matches played , find number of teams in tournament | Function to return the number of teams ; sqrt ( b ^ 2 - 4 ac ) ; First root ( - b + sqrt ( b ^ 2 - 4 ac ) ) \/ 2 a ; Second root ( - b - sqrt ( b ^ 2 - 4 ac ) ) \/ 2 a ; Return the positive root ; Driver code","code":"< ? php function number_of_teams ( $ M ) { $ sqr = sqrt ( 1 + ( 8 * $ M ) ) ; $ N1 = ( 1 + $ sqr ) \/ 2 ; $ N2 = ( 1 - $ sqr ) \/ 2 ; if ( $ N1 > 0 ) return $ N1 ; return $ N2 ; } $ M = 45 ; echo number_of_teams ( $ M ) ; ? >"}
{"text":"Sum of numbers from 1 to N which are in Lucas Sequence | Function to return the required sum ; Generate lucas number and keep on adding them ; Driver code","code":"< ? php function LucasSum ( $ N ) { $ sum = 0 ; $ a = 2 ; $ b = 1 ; $ c ; $ sum += $ a ; while ( $ b <= $ N ) { $ sum += $ b ; $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ sum ; } $ N = 20 ; echo ( LucasSum ( $ N ) ) ; ? >"}
{"text":"Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | Function to return the count of required numbers ; Count of numbers in range which are divisible by 6 ; Driver code","code":"< ? php function countNumbers ( $ l , $ r ) { return ( ( int ) ( $ r \/ 6 ) - ( int ) ( ( $ l - 1 ) \/ 6 ) ) ; } $ l = 1000 ; $ r = 6000 ; echo ( countNumbers ( $ l , $ r ) ) ; ? >"}
{"text":"Sum of minimum element of all sub | Function to find the sum of minimum of all subsequence ; Driver code","code":"< ? php function findMinSum ( $ arr , $ n ) { $ occ1 = ( $ n ) ; $ occ = $ occ1 - 1 ; $ Sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ Sum += $ arr [ $ i ] * pow ( 2 , $ occ ) ; $ occ -= 1 ; } return $ Sum ; } $ arr = array ( 1 , 2 , 4 , 5 ) ; $ n = count ( $ arr ) ; echo findMinSum ( $ arr , $ n ) ; ? >"}
{"text":"Count numbers in range 1 to N which are divisible by X but not by Y | Function to count total numbers divisible by x but not y in range 1 to N ; Check if Number is divisible by x but not Y if yes , Increment count ; Driver Code","code":"< ? php function countNumbers ( $ X , $ Y , $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( ( $ i % $ X == 0 ) && ( $ i % $ Y != 0 ) ) $ count ++ ; } return $ count ; } $ X = 2 ; $ Y = 3 ; $ N = 10 ; echo ( countNumbers ( $ X , $ Y , $ N ) ) ; ? >"}
{"text":"Position of a person diametrically opposite on a circle | Function to return the required position ; Driver code","code":"< ? php function getPosition ( $ n , $ m ) { if ( $ m > ( $ n \/ 2 ) ) return ( $ m - ( $ n \/ 2 ) ) ; return ( $ m + ( $ n \/ 2 ) ) ; } $ n = 8 ; $ m = 5 ; echo getPosition ( $ n , $ m ) ; ? >"}
{"text":"Minimum operations required to modify the array such that parity of adjacent elements is different | Function to return the parity of a number ; Function to return the minimum number of operations required ; Operation needs to be performed ; Parity of previous element ; Parity of next element ; Update parity of current element to be other than the parities of the previous and the next number ; Driver Code","code":"< ? php function parity ( $ a ) { return $ a % 3 ; } function solve ( $ array , $ size ) { $ operations = 0 ; for ( $ i = 0 ; $ i < $ size - 1 ; $ i ++ ) { if ( parity ( $ array [ $ i ] ) == parity ( $ array [ $ i + 1 ] ) ) { $ operations ++ ; if ( $ i + 2 < $ size ) { $ pari1 = parity ( $ array [ $ i ] ) ; $ pari2 = parity ( $ array [ $ i + 2 ] ) ; if ( $ pari1 == $ pari2 ) { if ( $ pari1 == 0 ) $ array [ $ i + 1 ] = 1 ; else if ( $ pari1 == 1 ) $ array [ $ i + 1 ] = 0 ; else $ array [ $ i + 1 ] = 1 ; } else { if ( ( $ pari1 == 0 && $ pari2 == 1 ) || ( $ pari1 == 1 && $ pari2 == 0 ) ) $ array [ $ i + 1 ] = 2 ; if ( ( $ pari1 == 1 && $ pari2 == 2 ) || ( $ pari1 == 2 && $ pari2 == 1 ) ) $ array [ $ i + 1 ] = 0 ; if ( ( $ pari1 == 2 && $ pari2 == 0 ) || ( $ pari1 == 0 && $ pari2 == 2 ) ) $ array [ $ i + 1 ] = 1 ; } } } } return $ operations ; } $ array = array ( 2 , 1 , 3 , 0 ) ; $ size = count ( $ array ) ; echo solve ( $ array , $ size ) ; ? >"}
{"text":"XOR of XORs of all sub | Function to find to required XOR value ; Nested loop to find the number of sub - matrix each index belongs to ; Number of ways to choose from top - left elements ; Number of ways to choose from bottom - right elements ; Driver Code","code":"< ? php function submatrixXor ( $ arr ) { $ ans = 0 ; $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; if ( ( $ top_left % 2 == 1 ) && ( $ bottom_right % 2 == 1 ) ) $ ans = ( $ ans ^ $ arr [ $ i ] [ $ j ] ) ; } } return $ ans ; } $ arr = array ( array ( 6 , 7 , 13 ) , array ( 8 , 3 , 4 ) , array ( 9 , 7 , 6 ) ) ; echo submatrixXor ( $ arr ) ; # This  code is contributed by Ryuga NEW_LINE ? >"}
{"text":"Find Nth positive number whose digital root is X | Function to find the digital root of a number ; Function to find the Nth number with digital root as X ; Counter variable to keep the count of valid numbers ; Find digital root ; Check if is required answer or not ; Print the answer if you have found it and breakout of the loop ; Driver Code","code":"< ? php function findDigitalRoot ( $ num ) { $ sum = PHP_INT_MAX ; $ tempNum = $ num ; while ( $ sum >= 10 ) { $ sum = 0 ; while ( $ tempNum > 0 ) { $ sum += $ tempNum % 10 ; $ tempNum \/= 10 ; } $ tempNum = $ sum ; } return $ sum ; } function findAnswer ( $ X , $ N ) { $ counter = 0 ; for ( $ i = 1 ; $ counter < $ N ; ++ $ i ) { $ digitalRoot = findDigitalRoot ( $ i ) ; if ( $ digitalRoot == $ X ) { ++ $ counter ; } if ( $ counter == $ N ) { echo ( $ i ) ; break ; } } } $ X = 1 ; $ N = 3 ; findAnswer ( $ X , $ N ) ;"}
{"text":"Find Nth positive number whose digital root is X | Function to find the N - th number with digital root as X ; Driver Code","code":"< ? php function findAnswer ( $ X , $ N ) { return ( $ N - 1 ) * 9 + $ X ; } $ X = 7 ; $ N = 43 ; echo ( findAnswer ( $ X , $ N ) ) ; ? >"}
{"text":"Sum of the natural numbers ( up to N ) whose modulo with K yield R | Function to return the sum ; If current number gives R as the remainder on dividing by K ; Update the sum ; Return the sum ; Driver code","code":"< ? php function count1 ( $ N , $ K , $ R ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % $ K == $ R ) $ sum += $ i ; } return $ sum ; } $ N = 20 ; $ K = 4 ; $ R = 3 ; echo count1 ( $ N , $ K , $ R ) ; ? >"}
{"text":"Find the number of solutions to the given equation | Function to return the count of valid values of X ; Iterate through all possible sum of digits of X ; Get current value of X for sum of digits i ; Find sum of digits of cr ; If cr is a valid choice for X ; Return the count ; Driver code","code":"< ? php function getCount ( $ a , $ b , $ c ) { $ count = 0 ; for ( $ i = 1 ; $ i <= 81 ; $ i ++ ) { $ cr = $ b * ( int ) pow ( $ i , $ a ) + $ c ; $ tmp = $ cr ; $ sm = 0 ; while ( $ tmp != 0 ) { $ sm += $ tmp % 10 ; $ tmp \/= 10 ; } if ( $ sm == $ i && $ cr < 1e9 ) $ count ++ ; } return $ count ; } { $ a = 3 ; $ b = 2 ; $ c = 8 ; echo ( getCount ( $ a , $ b , $ c ) ) ; }"}
{"text":"Check if an array of 1 s and 2 s can be divided into 2 parts with equal sum | Function to check if it is possible to split the array in two parts with equal sum ; Calculate sum of elements and count of 1 's ; If total sum is odd , return False ; If sum of each part is even , return True ; If sum of each part is even but there is atleast one 1 ; Driver Code","code":"< ? php function isSpiltPossible ( $ n , $ a ) { $ sum = 0 ; $ c1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; if ( $ a [ $ i ] == 1 ) { $ c1 ++ ; } } if ( $ sum % 2 != 0 ) return false ; if ( ( $ sum \/ 2 ) % 2 == 0 ) return true ; if ( $ c1 > 0 ) return true ; else return false ; } $ n = 3 ; $ a = array ( 1 , 1 , 2 ) ; if ( isSpiltPossible ( $ n , $ a ) ) echo ( \" YES \" ) ; else echo ( \" NO \" ) ; ? >"}
{"text":"Sum of all Submatrices of a Given Matrix | Function to find the sum of all possible submatrices of a given Matrix ; Variable to store the required sum ; Nested loop to find the number of submatrices , each number belongs to ; Number of ways to choose from top - left elements ; Number of ways to choose from bottom - right elements ; Driver Code","code":"< ? php function matrixSum ( $ arr ) { $ n = 3 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; $ sum += ( $ top_left * $ bottom_right * $ arr [ $ i ] [ $ j ] ) ; } return $ sum ; } $ arr = array ( array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) , array ( 1 , 1 , 1 ) ) ; echo matrixSum ( $ arr ) ; ? >"}
{"text":"Maximum Bitwise AND pair from given range | Function to return the maximum bitwise AND possible among all the possible pairs ; Maximum among all ( i , j ) pairs ; Driver code","code":"< ? php function maxAND ( $ L , $ R ) { $ maximum = $ L & $ R ; for ( $ i = $ L ; $ i < $ R ; $ i ++ ) for ( $ j = $ i + 1 ; $ j <= $ R ; $ j ++ ) $ maximum = max ( $ maximum , ( $ i & $ j ) ) ; return $ maximum ; } $ L = 1 ; $ R = 632 ; echo ( maxAND ( $ L , $ R ) ) ; ? >"}
{"text":"Split the array into odd number of segments of odd lengths | Function to check ; Check the result by processing the first & last element and size ; Driver code","code":"< ? php function checkArray ( $ arr , $ n ) { return ( $ arr [ 0 ] % 2 ) && ( $ arr [ $ n - 1 ] % 2 ) && ( $ n % 2 ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; echo checkArray ( $ arr , $ n ) ; ? >"}
{"text":"Minimum removals to make array sum odd | Function to find minimum removals ; Count odd numbers ; If the counter is odd return 0 otherwise return 1 ; Driver Code","code":"< ? php function findCount ( $ arr , $ n ) { $ countOdd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 1 ) $ countOdd ++ ; if ( $ countOdd % 2 == 0 ) return 1 ; else return 0 ; } $ arr = array ( 1 , 2 , 3 , 5 , 1 ) ; $ n = sizeof ( $ arr ) ; echo ( findCount ( $ arr , $ n ) ) ; ? >"}
{"text":"Check whether the number can be made perfect square after adding 1 | Function that returns true if x is a perfect square ; Find floating point value of square root of x ; If square root is an integer ; Function that returns true if n is a sunny number ; If ( n + 1 ) is a perfect square ; Driver code","code":"< ? php function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; } function isSunnyNum ( $ n ) { if ( isPerfectSquare ( $ n + 1 ) ) return true ; return false ; } $ n = 3 ; if ( isSunnyNum ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Count primes that can be expressed as sum of two consecutive primes and 1 | PHP implementation of the approach ; To check if a number is prime or not ; To store possible numbers ; Function to return all prime numbers ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked . ; Function to count all possible prime numbers that can be expressed as the sum of two consecutive primes and one ; All possible prime numbers below N ; Driver code","code":"< ? php $ N = 10005 ; $ isprime = array_fill ( 0 , $ N , true ) ; $ can = array_fill ( 0 , $ N , false ) ; function SieveOfEratosthenes ( ) { global $ N , $ isprime ; for ( $ p = 2 ; $ p * $ p < $ N ; $ p ++ ) { if ( $ isprime [ $ p ] == true ) { for ( $ i = $ p * $ p ; $ i < $ N ; $ i += $ p ) $ isprime [ $ i ] = false ; } } $ primes = array ( ) ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ isprime [ $ i ] ) array_push ( $ primes , $ i ) ; return $ primes ; } function Prime_Numbers ( $ n ) { global $ N , $ can , $ isprime ; $ primes = SieveOfEratosthenes ( ) ; for ( $ i = 0 ; $ i < count ( $ primes ) - 1 ; $ i ++ ) if ( $ primes [ $ i ] + $ primes [ $ i + 1 ] + 1 < $ N ) $ can [ $ primes [ $ i ] + $ primes [ $ i + 1 ] + 1 ] = true ; $ ans = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ can [ $ i ] and $ isprime [ $ i ] ) { $ ans ++ ; } } return $ ans ; } $ n = 50 ; echo Prime_Numbers ( $ n ) ; ? >"}
{"text":"Sum of bitwise AND of all subarrays | Function to find the sum of bitwise AND of all subarrays ; variable to store the final sum ; multiplier ; variable to check if counting is on ; variable to store the length of the subarrays ; loop to find the contiguous segments ; updating the multiplier ; returning the sum ; Driver Code","code":"< ? php function findAndSum ( $ arr , $ n ) { $ sum = 0 ; $ mul = 1 ; for ( $ i = 0 ; $ i < 30 ; $ i ++ ) { $ count_on = 0 ; $ l = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) > 0 ) if ( $ count_on ) $ l ++ ; else { $ count_on = 1 ; $ l ++ ; } else if ( $ count_on ) { $ sum += ( ( $ mul * $ l * ( $ l + 1 ) ) \/ 2 ) ; $ count_on = 0 ; $ l = 0 ; } } if ( $ count_on ) { $ sum += ( ( $ mul * $ l * ( $ l + 1 ) ) \/ 2 ) ; $ count_on = 0 ; $ l = 0 ; } $ mul *= 2 ; } return $ sum ; } $ arr = array ( 7 , 1 , 1 , 5 ) ; $ n = sizeof ( $ arr ) ; echo findAndSum ( $ arr , $ n ) ; ? >"}
{"text":"Source to destination in 2 | Function that returns true if it is possible to move from source to the destination with the given moves ; Driver code","code":"< ? php function isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) { if ( abs ( $ Sx - $ Dx ) % $ x == 0 && abs ( $ Sy - $ Dy ) % $ y == 0 && ( abs ( $ Sx - $ Dx ) \/ $ x ) % 2 == ( abs ( $ Sy - $ Dy ) \/ $ y ) % 2 ) return true ; return false ; } $ Sx = 0 ; $ Sy = 0 ; $ Dx = 0 ; $ Dy = 0 ; $ x = 3 ; $ y = 4 ; if ( isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Count of pairs ( x , y ) in an array such that x < y | Function to return the number of pairs ( x , y ) such that x < y ; To store the number of valid pairs ; If a valid pair is found ; Return the count of valid pairs ; Driver code","code":"< ? php function getPairs ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { for ( $ j = 0 ; $ j < sizeof ( $ a ) ; $ j ++ ) { if ( $ a [ $ i ] < $ a [ $ j ] ) $ count ++ ; } } return $ count ; } $ a = array ( 2 , 4 , 3 , 1 ) ; echo getPairs ( $ a ) ; ? >"}
{"text":"Composite numbers with digit sum 1 | Function that returns true if number n is a composite number ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if the eventual digit sum of number nm is 1 ; Loop till the sum is not single digit number ; Intitialize the sum as zero ; Find the sum of digits ; If sum is eventually 1 ; Function to print the required numbers from the given range ; If i is one of the required numbers ; Driver code","code":"< ? php function isComposite ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return false ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return true ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return true ; return false ; } function isDigitSumOne ( $ nm ) { while ( $ nm > 9 ) { $ sum_digit = 0 ; while ( $ nm > 0 ) { $ digit = $ nm % 10 ; $ sum_digit = $ sum_digit + $ digit ; $ nm = floor ( $ nm \/ 10 ) ; } $ nm = $ sum_digit ; } if ( $ nm == 1 ) return true ; else return false ; } function printValidNums ( $ l , $ r ) { for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( isComposite ( $ i ) && isDigitSumOne ( $ i ) ) echo $ i , \" \u2581 \" ; } } $ l = 10 ; $ r = 100 ; printValidNums ( $ l , $ r ) ; ? >"}
{"text":"Determine the count of Leaf nodes in an N | Function to calculate leaf nodes in n - ary tree ; Driver code","code":"< ? php function calcNodes ( $ N , $ I ) { $ result = 0 ; $ result = $ I * ( $ N - 1 ) + 1 ; return $ result ; } $ N = 5 ; $ I = 2 ; echo \" Leaf \u2581 nodes \u2581 = \u2581 \" . calcNodes ( $ N , $ I ) ; ? >"}
{"text":"An application on Bertrand 's ballot theorem | PHP implementation of the approach ; Function to calculate factorial of a number mod 1000000007 ; Factorial of i = factorial of ( i - 1 ) * i ; ; Taking mod aint with calculation . ; Function for modular exponentiation ; If p is odd ; If p is even ; Function to return the count of required permutations ; Calculating multiplicative modular inverse for x ! and multiplying with ans ; Calculating multiplicative modular inverse for y ! and multiplying with ans ; Pre - compute factorials","code":"< ? php $ mod = 1000000007 ; $ arr = array_fill ( 0 , 10001 , 0 ) ; function cal_factorial ( ) { global $ arr , $ mod ; $ arr [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= 10000 ; $ i ++ ) { $ arr [ $ i ] = ( $ arr [ $ i - 1 ] * $ i ) % $ mod ; } } function mod_exponent ( $ num , $ p ) { global $ mod ; if ( $ p == 0 ) return 1 ; if ( ( $ p & 1 ) ) { return ( ( $ num % $ mod ) * ( mod_exponent ( ( $ num * $ num ) % $ mod , $ p \/ 2 ) ) % $ mod ) % $ mod ; } else if ( ! ( $ p & 1 ) ) return ( mod_exponent ( ( $ num * $ num ) % $ mod , $ p \/ 2 ) ) % $ mod ; } function getCount ( $ x , $ y ) { global $ arr , $ mod ; $ ans = $ arr [ $ x + $ y - 1 ] ; $ ans *= mod_exponent ( $ arr [ $ x ] , $ mod - 2 ) ; $ ans %= $ mod ; $ ans *= mod_exponent ( $ arr [ $ y ] , $ mod - 2 ) ; $ ans %= $ mod ; $ ans *= ( $ x - $ y ) ; $ ans %= $ mod ; return $ ans ; } cal_factorial ( ) ; $ x = 3 ; $ y = 1 ; print ( getCount ( $ x , $ y ) ) ; ? >"}
{"text":"Find the values of X and Y in the Given Equations | Function to find the values of X and Y ; base condition ; required answer ; Driver Code","code":"< ? php function findValues ( $ a , $ b ) { if ( ( $ a - $ b ) % 2 == 1 ) { echo \" - 1\" ; return ; } echo ( $ a - $ b ) \/ 2 , \" \u2581 \" , ( $ a + $ b ) \/ 2 ; } $ a = 12 ; $ b = 8 ; findValues ( $ a , $ b ) ; ? >"}
{"text":"Count triplet pairs ( A , B , C ) of points in 2 | Function to return the count of possible triplets ; Insert all the points in a set ; If the mid point exists in the set ; Return the count of valid triplets ; Driver code","code":"< ? php function countTriplets ( $ n , $ points ) { $ pts = array ( ) ; $ ct = 0 ; for ( $ i = 0 ; $ i < count ( $ points ) ; $ i ++ ) { for ( $ j = 0 ; $ j < count ( $ points [ $ i ] ) ; $ j ++ ) { $ pts [ ] = $ points [ $ i ] [ $ j ] ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ x = $ points [ $ i ] [ 0 ] + $ points [ $ j ] [ 0 ] ; $ y = $ points [ $ i ] [ 1 ] + $ points [ $ j ] [ 1 ] ; if ( $ x % 2 == 0 and $ y % 2 == 0 ) if ( in_array ( ( int ) ( $ x \/ 2 ) , $ pts ) and in_array ( ( int ) ( $ y \/ 2 ) , $ pts ) ) $ ct += 1 ; } return $ ct ; } $ points = array ( array ( 1 , 1 ) , array ( 2 , 2 ) , array ( 3 , 3 ) ) ; $ n = count ( $ points ) ; print ( countTriplets ( $ n , $ points ) ) ; ? >"}
{"text":"Concentration of juice after mixing n glasses in equal proportion | Function to return the concentration of the resultant mixture ; Driver code","code":"< ? php function mixtureConcentration ( $ n , $ p ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += $ p [ $ i ] ; $ res \/= $ n ; return $ res ; } $ arr = array ( 0 , 20 , 20 ) ; $ n = count ( $ arr ) ; print ( round ( mixtureConcentration ( $ n , $ arr ) , 4 ) ) ; ? >"}
{"text":"Number of elements with even factors in the given range | Function to count the perfect squares ; Driver code","code":"< ? php function countOddSquares ( $ n , $ m ) { return ( int ) pow ( $ m , 0.5 ) - ( int ) pow ( $ n - 1 , 0.5 ) ; } $ n = 5 ; $ m = 100 ; echo \" Count \u2581 is \u2581 \" , ( $ m - $ n + 1 ) - countOddSquares ( $ n , $ m ) ; ? >"}
{"text":"Total position where king can reach on a chessboard in exactly M moves | Function to return the number of squares that the king can reach in the given number of moves ; Calculate initial and final coordinates ; Since chessboard is of size 8 X8 so if any coordinate is less than 1 or greater than 8 make it 1 or 8. ; Calculate total positions ; Driver code","code":"< ? php function Square ( $ row , $ column , $ moves ) { $ a = 0 ; $ b = 0 ; $ c = 0 ; $ d = 0 ; $ total = 0 ; $ a = $ row - $ moves ; $ b = $ row + $ moves ; $ c = $ column - $ moves ; $ d = $ column + $ moves ; if ( $ a < 1 ) $ a = 1 ; if ( $ c < 1 ) $ c = 1 ; if ( $ b > 8 ) $ b = 8 ; if ( $ d > 8 ) $ d = 8 ; $ total = ( $ b - $ a + 1 ) * ( $ d - $ c + 1 ) - 1 ; return $ total ; } $ R = 4 ; $ C = 5 ; $ M = 2 ; echo Square ( $ R , $ C , $ M ) ; ? >"}
{"text":"Find M | number whosesum till one digit is N ; Driver Code","code":"< ? php function findNumber ( $ n , $ m ) { $ num = ( $ m - 1 ) * 9 + $ n ; return $ num ; } $ n = 2 ; $ m = 5 ; echo findNumber ( $ n , $ m ) ; ? >"}
{"text":"Check if a number can be represented as a sum of 2 triangular numbers | Function to check if it is possible or not ; Store all triangular numbers up to N in a Set ; Check if a pair exists ; Driver Code","code":"< ? php function checkTriangularSumRepresentation ( $ n ) { $ tri = array ( ) ; $ i = 1 ; while ( true ) { $ x = $ i * ( $ i + 1 ) ; if ( $ x >= $ n ) break ; array_push ( $ tri , $ x ) ; $ i += 1 ; } foreach ( $ tri as $ tm ) if ( in_array ( $ n - $ tm , $ tri ) ) return true ; return false ; } $ n = 24 ; if ( checkTriangularSumRepresentation ( $ n ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text":"Absolute difference between the first X and last X Digits of N | Function to find the number of digits in the integer ; Function to find the absolute difference ; Store the last x digits in last ; Count the no . of digits in N ; Remove the digits except the first x ; Store the first x digits in first ; Return the absolute difference between the first and last ; Driver code","code":"< ? php function digitsCount ( $ n ) { $ len = 0 ; while ( $ n > 0 ) { $ len ++ ; $ n = ( int ) ( $ n \/ 10 ) ; } return $ len ; } function absoluteFirstLast ( $ n , $ x ) { $ i = 0 ; $ mod = 1 ; while ( $ i < $ x ) { $ mod *= 10 ; $ i ++ ; } $ last = $ n % $ mod ; $ len = digitsCount ( $ n ) ; while ( $ len != $ x ) { $ n = ( int ) ( $ n \/ 10 ) ; $ len -- ; } $ first = $ n ; return abs ( $ first - $ last ) ; } $ n = 21546 ; $ x = 2 ; echo absoluteFirstLast ( $ n , $ x ) ; ? >"}
{"text":"Generate minimum sum sequence of integers with even elements greater | Function to print the required sequence ; arr [ ] will hold the sequence sum variable will store the sum of the sequence ; If sum of the sequence is odd ; Print the sequence ; Driver Code","code":"< ? php function make_sequence ( $ N ) { $ arr = array ( ) ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 1 ) $ arr [ $ i ] = 1 ; else $ arr [ $ i ] = 2 ; $ sum += $ arr [ $ i ] ; } if ( $ sum % 2 == 1 ) $ arr [ 2 ] = 3 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ N = 9 ; make_sequence ( $ N ) ; ? >"}
{"text":"Count Odd and Even numbers in a range from L to R | Return the number of odd numbers in the range [ L , R ] ; if either R or L is odd ; Driver code","code":"< ? php function countOdd ( $ L , $ R ) { $ N = ( $ R - $ L ) \/ 2 ; if ( $ R % 2 != 0 $ L % 2 != 0 ) $ N ++ ; return $ N ; } $ L = 3 ; $ R = 7 ; $ odds = countOdd ( $ L , $ R ) ; $ evens = ( $ R - $ L + 1 ) - $ odds ; echo \" Count \u2581 of \u2581 odd \u2581 numbers \u2581 is \u2581 \" . $ odds . \" STRNEWLINE \" ; echo \" Count \u2581 of \u2581 even \u2581 numbers \u2581 is \u2581 \" . $ evens ; ? >"}
{"text":"Cost of painting n * m grid | Function to return the minimum cost ; Driver code","code":"< ? php function getMinCost ( $ n , $ m ) { $ cost = ( $ n - 1 ) * $ m + ( $ m - 1 ) * $ n ; return $ cost ; } $ n = 4 ; $ m = 5 ; echo getMinCost ( $ n , $ m ) ; ? >"}
{"text":"Minimum operations required to make all the array elements equal | Function to return the minimum number of given operation required to make all the array elements equal ; Check if all the elements from kth index to last are equal ; Finding the 1 st element which is not equal to the kth element ; Driver code","code":"< ? php function minOperation ( $ n , $ k , & $ a ) { for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] != $ a [ $ k - 1 ] ) return -1 ; } for ( $ i = $ k - 2 ; $ i > -1 ; $ i -- ) { if ( $ a [ $ i ] != $ a [ $ k - 1 ] ) return ( $ i + 1 ) ; } } $ n = 5 ; $ k = 3 ; $ a = array ( 2 , 1 , 1 , 1 , 1 ) ; echo ( minOperation ( $ n , $ k , $ a ) ) ; ? >"}
{"text":"Number of Simple Graph with N Vertices and M Edges | Function to return the value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * ... * 1 ] ; Driver Code","code":"< ? php function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res ; } $ N = 5 ; $ M = 1 ; $ P = floor ( ( $ N * ( $ N - 1 ) ) \/ 2 ) ; echo binomialCoeff ( $ P , $ M ) ; ? >"}
{"text":"Increasing sequence with given GCD | Function to print the required sequence ; Driver Code","code":"< ? php function generateSequence ( $ n , $ g ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ i * $ g . \" \u2581 \" ; } $ n = 6 ; $ g = 5 ; generateSequence ( $ n , $ g ) ; ? >"}
{"text":"Program to find LCM of two Fibonnaci Numbers | PHP Program to find LCM of Fib ( a ) and Fib ( b ) ; Create an array for memoization ; Function to return the n 'th Fibonacci number using table f[]. ; Base cases ; If fib ( n ) is already computed ; Applying recursive formula Note value n & 1 is 1 if n is odd , else 0. ; Function to return gcd of a and b ; Function to return the LCM of Fib ( a ) and Fib ( a ) ; Driver code","code":"< ? php $ GLOBALS [ ' MAX ' ] = 1000 ; $ GLOBALS [ ' f ' ] = array ( ) ; for ( $ i = 0 ; $ i < $ GLOBALS [ ' MAX ' ] ; $ i ++ ) $ GLOBALS [ ' f ' ] [ $ i ] = 0 ; function fib ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return ( $ GLOBALS [ ' f ' ] [ $ n ] = 1 ) ; if ( $ GLOBALS [ ' f ' ] [ $ n ] ) return $ GLOBALS [ ' f ' ] [ $ n ] ; $ k = ( $ n & 1 ) ? ( $ n + 1 ) \/ 2 : $ n \/ 2 ; $ GLOBALS [ ' f ' ] [ $ n ] = ( $ n & 1 ) ? ( fib ( $ k ) * fib ( $ k ) + fib ( $ k - 1 ) * fib ( $ k - 1 ) ) : ( 2 * fib ( $ k - 1 ) + fib ( $ k ) ) * fib ( $ k ) ; return $ GLOBALS [ ' f ' ] [ $ n ] ; } function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findLCMFibonacci ( $ a , $ b ) { return ( fib ( $ a ) * fib ( $ b ) ) \/ fib ( gcd ( $ a , $ b ) ) ; } $ a = 3 ; $ b = 12 ; echo findLCMFibonacci ( $ a , $ b ) ; ? >"}
{"text":"Check whether XOR of all numbers in a given range is even or odd | Function to check if XOR of all numbers in range [ L , R ] is Even or Odd ; Count odd Numbers in range [ L , R ] ; Check if count of odd Numbers is even or odd ; Driver Code","code":"< ? php function isEvenOrOdd ( $ L , $ R ) { $ oddCount = floor ( ( $ R - $ L ) \/ 2 ) ; if ( $ R % 2 == 1 $ L % 2 == 1 ) $ oddCount ++ ; if ( $ oddCount % 2 == 0 ) return \" Even \" ; else return \" Odd \" ; } $ L = 5 ; $ R = 15 ; echo isEvenOrOdd ( $ L , $ R ) ; ? >"}
{"text":"Count number of trailing zeros in ( 1 ^ 1 ) * ( 2 ^ 2 ) * ( 3 ^ 3 ) * ( 4 ^ 4 ) * . . | Function to return the number of trailing zeros ; To store the number of 2 s and 5 s ; If we get a factor 2 then we have i number of 2 s because the power of the number is raised to i ; If we get a factor 5 then we have i number of 5 s because the power of the number is raised to i ; Take the minimum of them ; Driver code","code":"< ? php function trailing_zeros ( $ N ) { $ count_of_two = 0 ; $ count_of_five = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ val = $ i ; while ( $ val % 2 == 0 && $ val > 0 ) { $ val \/= 2 ; $ count_of_two += $ i ; } while ( $ val % 5 == 0 && $ val > 0 ) { $ val \/= 5 ; $ count_of_five += $ i ; } } $ ans = min ( $ count_of_two , $ count_of_five ) ; return $ ans ; } $ N = 12 ; echo trailing_zeros ( $ N ) ; ? >"}
{"text":"Midpoint ellipse drawing algorithm | PHP program for implementing Mid - Point Ellipse Drawing Algorithm ; Initial decision parameter of region 1 ; For region 1 ; Print points based on 4 - way symmetry ; Checking and updating value of decision parameter based on algorithm ; Decision parameter of region 2 ; Plotting points of region 2 ; printing points based on 4 - way symmetry ; Checking and updating parameter value based on algorithm ; To draw a ellipse of major and minor radius 15 , 10 centred at ( 50 , 50 )","code":"< ? php function midptellipse ( $ rx , $ ry , $ xc , $ yc ) { $ x = 0 ; $ y = $ ry ; $ d1 = ( $ ry * $ ry ) - ( $ rx * $ rx * $ ry ) + ( 0.25 * $ rx * $ rx ) ; $ dx = 2 * $ ry * $ ry * $ x ; $ dy = 2 * $ rx * $ rx * $ y ; while ( $ dx < $ dy ) { echo \" ( \u2581 \" , $ x + $ xc , \" , \u2581 \" , $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; echo \" ( \u2581 \" , - $ x + $ xc , \" , \u2581 \" , $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; echo \" ( \u2581 \" , $ x + $ xc , \" , \u2581 \" , - $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; echo \" ( \u2581 \" , - $ x + $ xc , \" , \u2581 \" , - $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; if ( $ d1 < 0 ) { $ x ++ ; $ dx = $ dx + ( 2 * $ ry * $ ry ) ; $ d1 = $ d1 + $ dx + ( $ ry * $ ry ) ; } else { $ x ++ ; $ y -- ; $ dx = $ dx + ( 2 * $ ry * $ ry ) ; $ dy = $ dy - ( 2 * $ rx * $ rx ) ; $ d1 = $ d1 + $ dx - $ dy + ( $ ry * $ ry ) ; } } $ d2 = ( ( $ ry * $ ry ) * ( ( $ x + 0.5 ) * ( $ x + 0.5 ) ) ) + ( ( $ rx * $ rx ) * ( ( $ y - 1 ) * ( $ y - 1 ) ) ) - ( $ rx * $ rx * $ ry * $ ry ) ; while ( $ y >= 0 ) { echo \" ( \u2581 \" , $ x + $ xc , \" , \u2581 \" , $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; echo \" ( \u2581 \" , - $ x + $ xc , \" , \u2581 \" , $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; echo \" ( \u2581 \" , $ x + $ xc , \" , \u2581 \" , - $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; echo \" ( \u2581 \" , - $ x + $ xc , \" , \u2581 \" , - $ y + $ yc , \" \u2581 ) STRNEWLINE \" ; if ( $ d2 > 0 ) { $ y -- ; $ dy = $ dy - ( 2 * $ rx * $ rx ) ; $ d2 = $ d2 + ( $ rx * $ rx ) - $ dy ; } else { $ y -- ; $ x ++ ; $ dx = $ dx + ( 2 * $ ry * $ ry ) ; $ dy = $ dy - ( 2 * $ rx * $ rx ) ; $ d2 = $ d2 + $ dx - $ dy + ( $ rx * $ rx ) ; } } } midptellipse ( 10 , 15 , 50 , 50 ) ; ? >"}
{"text":"Program to check if a number is divisible by sum of its digits | Function to check if the given number is divisible by sum of its digits ; Find sum of digits ; check if sum of digits divides n ; Driver Code","code":"< ? php function isDivisible ( $ n ) { $ temp = $ n ; $ sum = 0 ; while ( $ n ) { $ k = $ n % 10 ; $ sum += $ k ; $ n = ( int ) ( $ n \/ 10 ) ; } if ( $ temp % $ sum == 0 ) return \" YES \" ; return \" NO \" ; } $ n = 123 ; print ( isDivisible ( $ n ) ) ; ? >"}
{"text":"Find the final X and Y when they are Altering under given condition | Function to get final value of X and Y ; Following the sequence but by replacing minus with modulo ; Step 1 ; Step 2 ; Step 3 ; Otherwise terminate ; Get the initial X and Y values ; Find the result","code":"< ? php function alter ( $ x , $ y ) { while ( true ) { if ( $ x == 0 $ y == 0 ) break ; if ( $ x >= 2 * $ y ) $ x = $ x % ( 2 * $ y ) ; else if ( $ y >= 2 * $ x ) $ y = $ y % ( 2 * $ x ) ; else break ; } echo \" X = \" , \u2581 $ x , \u2581 \" , \" , \u2581 \" Y = \" } $ x = 12 ; $ y = 5 ; alter ( $ x , $ y ) ; ? >"}
{"text":"Print all multiplicative primes <= N | Function to return the digit product of n ; Function to print all multiplicative primes <= n ; Create a boolean array \" prime [ 0 . . n + 1 ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; If i is prime and its digit sum is also prime i . e . i is a multiplicative prime ; Driver code","code":"< ? php function digitProduct ( $ n ) { $ prod = 1 ; while ( $ n ) { $ prod = $ prod * ( $ n % 10 ) ; $ n = floor ( $ n \/ 10 ) ; } return $ prod ; } function printMultiplicativePrimes ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] && $ prime [ digitProduct ( $ i ) ] ) echo $ i , \" \u2581 \" ; } } $ n = 10 ; printMultiplicativePrimes ( $ n ) ; ? >"}
{"text":"Largest number less than or equal to N \/ 2 which is coprime to N | Function to calculate gcd of two number ; Function to check if two numbers are coprime or not ; two numbers are coprime if their gcd is 1 ; Function to find largest integer less than or equal to N \/ 2 and coprime with N ; Check one by one all numbers less than or equal to N \/ 2 ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; else return gcd ( $ b , $ a % $ b ) ; } function coPrime ( $ n1 , $ n2 ) { if ( gcd ( $ n1 , $ n2 ) == 1 ) return true ; else return false ; } function largestCoprime ( $ N ) { $ half = floor ( $ N \/ 2 ) ; while ( coPrime ( $ N , $ half ) == false ) $ half -- ; return $ half ; } $ n = 50 ; echo largestCoprime ( $ n ) ;"}
{"text":"Largest number less than or equal to N \/ 2 which is coprime to N | Function to find largest integer less than or equal to N \/ 2 and is coprime with N ; Handle the case for N = 6 ; Driver code","code":"< ? php function largestCoprime ( $ N ) { if ( $ N == 6 ) return 1 ; else if ( $ N % 4 == 0 ) return ( $ N \/ 2 ) - 1 ; else if ( $ N % 2 == 0 ) return ( $ N \/ 2 ) - 2 ; else return ( ( $ N - 1 ) \/ 2 ) ; } $ n = 50 ; echo largestCoprime ( $ n ) ; ? >"}
{"text":"Print all safe primes below N | Function to print first n safe primes ; Initialize all entries of integer array as 1. A value in prime [ i ] will finally be 0 if i is Not a prime , else 1 ; 0 and 1 are not primes ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; If i is prime ; 2 p + 1 ; If 2 p + 1 is also a prime then set prime [ 2 p + 1 ] = 2 ; i is a safe prime ; Driver code","code":"< ? php function printSafePrimes ( $ n ) { $ prime = array ( ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = 1 ; $ prime [ 0 ] = $ prime [ 1 ] = 0 ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == 1 ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = 0 ; } } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] != 0 ) { $ temp = ( 2 * $ i ) + 1 ; if ( $ temp <= $ n && $ prime [ $ temp ] != 0 ) $ prime [ $ temp ] = 2 ; } } for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) if ( $ prime [ $ i ] == 2 ) echo $ i , \" \u2581 \" ; } $ n = 20 ; printSafePrimes ( $ n ) ; ? >"}
{"text":"Minimum multiplications with { 2 , 3 , 7 } to make two numbers equal | Function to find powers of 2 , 3 and 7 in x ; To keep count of each divisor ; To store the result ; Count powers of 2 in x ; Count powers of 3 in x ; Count powers of 7 in x ; Remaining number which is not divisible by 2 , 3 or 7 ; Function to return the minimum number of given operations required to make a and b equal ; a = x * 2 ^ a1 * 3 ^ a2 * 7 ^ a3 va [ 0 ] = a1 va [ 1 ] = a2 va [ 2 ] = a3 va [ 3 ] = x ; Similarly for b ; If a and b cannot be made equal with the given operation . Note that va [ 3 ] and vb [ 3 ] contain remaining numbers after repeated divisions with 2 , 3 and 7. If remaining numbers are not same then we cannot make them equal . ; Minimum number of operations required ; Driver code","code":"< ? php function Divisors ( $ x ) { $ c = 0 ; $ v = array ( ) ; while ( $ x % 2 == 0 ) { $ c ++ ; $ x = floor ( $ x \/ 2 ) ; } array_push ( $ v , $ c ) ; $ c = 0 ; while ( $ x % 3 == 0 ) { $ c ++ ; $ x = floor ( $ x \/ 3 ) ; } array_push ( $ v , $ c ) ; $ c = 0 ; while ( $ x % 7 == 0 ) { $ c ++ ; $ x = floor ( $ x \/ 7 ) ; } array_push ( $ v , $ c ) ; array_push ( $ v , $ x ) ; return $ v ; } function MinOperations ( $ a , $ b ) { $ va = Divisors ( $ a ) ; $ vb = Divisors ( $ b ) ; if ( $ va [ 3 ] != $ vb [ 3 ] ) return -1 ; $ minOperations = abs ( $ va [ 0 ] - $ vb [ 0 ] ) + abs ( $ va [ 1 ] - $ vb [ 1 ] ) + abs ( $ va [ 2 ] - $ vb [ 2 ] ) ; return $ minOperations ; } $ a = 14 ; $ b = 28 ; echo MinOperations ( $ a , $ b ) ; ? >"}
{"text":"Product of N with its largest odd digit | Function to return the largest odd digit in n ; If all digits are even then - 1 will be returned ; Last digit from n ; If current digit is odd and > maxOdd ; Remove last digit ; Return the maximum odd digit ; Function to return the product of n with its largest odd digit ; If there are no odd digits in n ; Product of n with its largest odd digit ; Driver code","code":"< ? php function largestOddDigit ( $ n ) { $ maxOdd = -1 ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ digit % 2 == 1 && $ digit > $ maxOdd ) $ maxOdd = $ digit ; $ n = $ n \/ 10 ; } return $ maxOdd ; } function getProduct ( $ n ) { $ maxOdd = largestOddDigit ( $ n ) ; if ( $ maxOdd == -1 ) return -1 ; return ( $ n * $ maxOdd ) ; } $ n = 12345 ; echo getProduct ( $ n ) ; ? >"}
{"text":"Sum of LCM ( 1 , n ) , LCM ( 2 , n ) , LCM ( 3 , n ) , ... , LCM ( n , n ) | PHP implementation of the approach ; Euler totient Function ; Function to return the required LCM sum ; Summation of d * ETF ( d ) where d belongs to set of divisors of n ; Driver code","code":"< ? php $ n = 10002 ; $ phi = array_fill ( 0 , $ n + 2 , 0 ) ; $ ans = array_fill ( 0 , $ n + 2 , 0 ) ; function ETF ( ) { global $ phi , $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ phi [ $ i ] = $ i ; } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ phi [ $ i ] == $ i ) { $ phi [ $ i ] = $ i - 1 ; for ( $ j = 2 * $ i ; $ j <= $ n ; $ j += $ i ) { $ phi [ $ j ] = ( int ) ( ( $ phi [ $ j ] * ( $ i - 1 ) ) \/ $ i ) ; } } } } function LcmSum ( $ m ) { ETF ( ) ; global $ ans , $ n , $ phi ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = $ i ; $ j <= $ n ; $ j += $ i ) { $ ans [ $ j ] += ( $ i * $ phi [ $ i ] ) ; } } $ answer = $ ans [ $ m ] ; $ answer = ( $ answer + 1 ) * $ m ; $ answer = ( int ) ( $ answer \/ 2 ) ; return $ answer ; } $ m = 5 ; echo LcmSum ( $ m ) ; ? >"}
{"text":"Permutations of string such that no two vowels are adjacent | Factorial of a number ; Function to find c ( n , r ) ; Function to count permutations of string such that no two vowels are adjacent ; Finding the frequencies of the characters ; finding the no . of vowels and consonants in given word ; finding places for the vowels ; ways to fill consonants 6 ! \/ 2 ! ; ways to put vowels 7 C5 x 5 ! ; Driver code","code":"< ? php function factorial ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function ncr ( $ n , $ r ) { return factorial ( $ n ) \/ ( factorial ( $ r ) * factorial ( $ n - $ r ) ) ; } function countWays ( $ str ) { $ freq = array_fill ( 0 , 26 , NULL ) ; $ nvowels = 0 ; $ nconsonants = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) ++ $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i == 0 $ i == 4 $ i == 8 $ i == 14 $ i == 20 ) $ nvowels += $ freq [ $ i ] ; else $ nconsonants += $ freq [ $ i ] ; } $ vplaces = $ nconsonants + 1 ; $ cways = factorial ( $ nconsonants ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i != 0 && $ i != 4 && $ i != 8 && $ i != 14 && $ i != 20 && $ freq [ $ i ] > 1 ) { $ cways = $ cways \/ factorial ( $ freq [ $ i ] ) ; } } $ vways = ncr ( $ vplaces , $ nvowels ) * factorial ( $ nvowels ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ i == 0 $ i == 4 $ i == 8 $ i == 14 $ i == 20 && $ freq [ $ i ] > 1 ) { $ vways = $ vways \/ factorial ( $ freq [ $ i ] ) ; } } return $ cways * $ vways ; } $ str = \" permutation \" ; echo countWays ( $ str ) . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text":"Pairs from an array that satisfy the given condition | Function to return the number of set bits in n ; Function to return the count of required pairs ; Set bits for first element of the pair ; Set bits for second element of the pair ; Set bits of the resultant number which is the XOR of both the elements of the pair ; If the condition is satisfied ; Increment the count ; Return the total count ; Driver code","code":"< ? php function setBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n = $ n & ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function countPairs ( & $ a , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ setbits_x = setBits ( $ a [ $ i ] ) ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ setbits_y = setBits ( $ a [ $ j ] ) ; $ setbits_xor_xy = setBits ( $ a [ $ i ] ^ $ a [ $ j ] ) ; if ( $ setbits_x + $ setbits_y == $ setbits_xor_xy ) $ count ++ ; } } return $ count ; } $ a = array ( 2 , 3 , 4 , 5 , 6 ) ; $ n = sizeof ( $ a ) \/ sizeof ( $ a [ 0 ] ) ; echo countPairs ( $ a , $ n ) ; ? >"}
{"text":"Number of array elements derivable from D after performing certain operations | Function to return gcd of a and b ; Function to Return the number of elements of arr [ ] which can be derived from D by performing ( + A , - A , + B , - B ) ; find the gcd of A and B ; counter stores the number of array elements which can be derived from D ; arr [ i ] can be derived from D only if | arr [ i ] - D | is divisible by gcd of A and B ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findPossibleDerivables ( $ arr , $ n , $ D , $ A , $ B ) { $ gcdAB = gcd ( $ A , $ B ) ; $ counter = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( abs ( $ arr [ $ i ] - $ D ) % $ gcdAB ) == 0 ) { $ counter ++ ; } } return $ counter ; } $ arr = array ( 1 , 2 , 3 , 4 , 7 , 13 ) ; $ n = sizeof ( $ arr ) ; $ D = 5 ; $ A = 4 ; $ B = 2 ; echo findPossibleDerivables ( $ arr , $ n , $ D , $ A , $ B ) , \" \" ; $ a = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ a ) ; $ D = 6 ; $ A = 3 ; $ B = 2 ; echo findPossibleDerivables ( $ arr , $ n , $ D , $ A , $ B ) , \" \" ; ? >"}
{"text":"Find the sum of first N terms of the series 2 * 3 * 5 , 3 * 5 * 7 , 4 * 7 * 9 , ... | Function to return the sum of the first n terms of the given series ; As described in the approach ; Driver code","code":"< ? php function calculateSum ( $ n ) { return ( $ n * ( 2 * $ n * $ n * $ n + 12 * $ n * $ n + 25 * $ n + 21 ) ) \/ 2 ; } $ n = 3 ; echo calculateSum ( $ n ) ; ? >"}
{"text":"Find elements of array using XOR of consecutive elements | Function to find the array elements using XOR of consecutive elements ; first element a i . e elements [ 0 ] = a ; To get the next elements we have to calculate xor of previous elements with given xor of 2 consecutive elements . e . g . if a ^ b = k1 so to get b xor a both side . b = k1 ^ a ; Printing the original array elements ; Driver Code","code":"< ? php function getElements ( $ a , & $ arr , & $ n ) { $ elements [ 0 ] = $ a ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ elements [ $ i + 1 ] = $ arr [ $ i ] ^ $ elements [ $ i ] ; } for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) { echo ( $ elements [ $ i ] . \" \" ) ; } } $ arr = array ( 13 , 2 , 6 , 1 ) ; $ n = sizeof ( $ arr ) ; $ a = 5 ; getElements ( $ a , $ arr , $ n ) ; ? >"}
{"text":"Check if the sum of distinct digits of two integers are equal | Function to return the sum of distinct digits of a number ; Take last digit ; If digit has not been used before ; Set digit as used ; Remove last digit ; Function to check whether the sum of distinct digits of two numbers are equal ; Driver code","code":"< ? php function distinctDigitSum ( $ n ) { $ used [ 10 ] = array ( ) ; $ sum = 0 ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ used > 0 ) { $ used [ $ digit ] = true ; $ sum += $ digit ; } $ n = ( int ) $ n \/ 10 ; } return $ sum ; } function checkSum ( $ m , $ n ) { $ sumM = distinctDigitSum ( $ m ) ; $ sumN = distinctDigitSum ( $ n ) ; if ( $ sumM != $ sumN ) return \" YES \" ; return \" NO \" ; } $ m = 2452 ; $ n = 9222 ; echo ( checkSum ( $ m , $ n ) ) ; ? >"}
{"text":"Find nth Hermite number | Utility function to calculate double factorial of a number ; Function to return nth Hermite number ; If n is even then return 0 ; If n is odd ; Calculate double factorial of ( n - 1 ) and multiply it with 2 ^ ( n \/ 2 ) ; If n \/ 2 is odd then nth Hermite number will be negative ; Return nth Hermite number ; Driver Code ; Print nth Hermite number","code":"< ? php function doubleFactorial ( $ n ) { $ fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i = $ i + 2 ) { $ fact = $ fact * $ i ; } return $ fact ; } function hermiteNumber ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else { $ number = ( pow ( 2 , $ n \/ 2 ) ) * doubleFactorial ( $ n - 1 ) ; if ( ( $ n \/ 2 ) % 2 == 1 ) $ number = $ number * -1 ; return $ number ; } } $ n = 6 ; echo hermiteNumber ( $ n ) ; ? >"}
{"text":"Sum of integers upto N with given unit digit | Function to return the required sum ; If the unit digit is d ; Driver code","code":"< ? php function getSum ( $ n , $ d ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 10 == $ d ) $ sum += $ i ; } return $ sum ; } $ n = 30 ; $ d = 3 ; echo getSum ( $ n , $ d ) ; ? >"}
{"text":"Split a number into 3 parts such that none of the parts is divisible by 3 | PHP program to split a number into three parts such than none of them is divisible by 3. ; Print x = 1 , y = 1 and z = N - 2 ; Otherwise , print x = 1 , y = 2 and z = N - 3 ; Driver code","code":"< ? php function printThreeParts ( $ N ) { if ( $ N % 3 == 0 ) echo \" \u2581 x \u2581 = \u2581 1 , \u2581 y \u2581 = \u2581 1 , \u2581 z \u2581 = \u2581 \" . ( $ N - 2 ) . \" STRNEWLINE \" ; else echo \" \u2581 x \u2581 = \u2581 1 , \u2581 y \u2581 = \u2581 2 , \u2581 z \u2581 = \u2581 \" . ( $ N - 3 ) . \" STRNEWLINE \" ; } $ N = 10 ; printThreeParts ( $ N ) ; ? >"}
{"text":"Minimum absolute difference of a number and its closest prime | Function to check if a number is prime or not ; Function to find the minimum absolute difference between a number and its closest prime ; Variables to store first prime above and below N ; Finding first prime number greater than N ; Finding first prime number less than N ; Variables to store the differences ; Driver code","code":"< ? php function isPrime ( $ N ) { for ( $ i = 2 ; $ i <= sqrt ( $ N ) ; $ i ++ ) { if ( $ N % $ i == 0 ) return false ; } return true ; } function getDifference ( $ N ) { if ( $ N == 0 ) return 2 ; else if ( $ N == 1 ) return 1 ; else if ( isPrime ( $ N ) ) return 0 ; $ aboveN = -1 ; $ belowN = -1 ; $ n1 = $ N + 1 ; while ( true ) { if ( isPrime ( $ n1 ) ) { $ aboveN = $ n1 ; break ; } else $ n1 ++ ; } $ n1 = $ N - 1 ; while ( true ) { if ( isPrime ( $ n1 ) ) { $ belowN = $ n1 ; break ; } else $ n1 -- ; } $ diff1 = $ aboveN - $ N ; $ diff2 = $ N - $ belowN ; return min ( $ diff1 , $ diff2 ) ; } $ N = 25 ; echo getDifference ( $ N ) . \" STRNEWLINE \" ;"}
{"text":"Check if the sum of perfect squares in an array is divisible by x | Function that returns true if the sum of all the perfect squares of the given array is divisible by x ; If arr [ i ] is a perfect square ; Driver code","code":"< ? php function check ( $ arr , $ x , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = sqrt ( $ arr [ $ i ] ) ; if ( floor ( $ x ) == ceil ( $ x ) ) { $ sum += $ arr [ $ i ] ; } } if ( ( $ sum % $ x ) == 0 ) return true ; else return false ; } $ arr = array ( 2 , 3 , 4 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; $ x = 13 ; if ( ! check ( $ arr , $ x , $ n ) ) { echo \" Yes \" ; } else { echo \" No \" ; } ? >"}
{"text":"Minimum and Maximum number of pairs in m teams of n people | PHP program to find minimum and maximum no . of pairs ; Driver code","code":"< ? php function MinimumMaximumPairs ( $ n , $ m ) { $ max_pairs = ( ( $ n - $ m + 1 ) * ( $ n - $ m ) ) \/ 2 ; $ min_pairs = $ m * ( int ) ( ( ( ( int ) ( $ n - $ m ) \/ $ m + 1 ) * ( ( int ) ( $ n - $ m ) \/ $ m ) ) \/ 2 ) + ( int ) ceil ( ( $ n - $ m ) \/ $ m ) * ( ( $ n - $ m ) % $ m ) ; echo ( \" Minimum \u2581 no . \u2581 of \u2581 pairs \u2581 = \u2581 \" . \" $ min _ pairs \" . \" STRNEWLINE \" ) ; echo ( \" Maximum \u2581 no . \u2581 of \u2581 pairs \u2581 = \u2581 \" . \" $ max _ pairs \" ) ; } $ n = 5 ; $ m = 2 ; MinimumMaximumPairs ( $ n , $ m ) ; ? >"}
{"text":"Larger of a ^ b or b ^ a ( a raised to power b or b raised to power a ) | Function to find the greater value ; Driver code","code":"< ? php function findGreater ( $ a , $ b ) { $ x = ( double ) $ a * ( double ) ( log ( ( double ) ( $ b ) ) ) ; $ y = ( double ) $ b * ( double ) ( log ( ( double ) ( $ a ) ) ) ; if ( $ y > $ x ) { echo \" a ^ b \u2581 is \u2581 greater \" , \" STRNEWLINE \" ; } else if ( $ y < $ x ) { echo \" b ^ a \u2581 is \u2581 greater \" , \" STRNEWLINE \" ; } else { echo \" Both \u2581 are \u2581 equal \" , \" STRNEWLINE \" ; } } $ a = 3 ; $ b = 5 ; $ c = 2 ; $ d = 4 ; findGreater ( $ a , $ b ) ; findGreater ( $ c , $ d ) ; ? >"}
{"text":"Expressing a fraction as a natural number under modulo ' m ' | Function to return the GCD of given numbers ; Recursive function to return ( x ^ n ) % m ; Function to return the fraction modulo mod ; ( b ^ m - 2 ) % m ; Final answer ; Driver code","code":"< ? php function abc ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return abc ( $ b % $ a , $ a ) ; } function modexp ( $ x , $ n ) { $ m = 1000000007 ; if ( $ n == 0 ) { return 1 ; } else if ( $ n % 2 == 0 ) { return modexp ( ( $ x * $ x ) % $ m , $ n \/ 2 ) ; } else { return ( $ x * modexp ( ( $ x * $ x ) % $ m , ( $ n - 1 ) \/ 2 ) % $ m ) ; } } function getFractionModulo ( $ a , $ b ) { $ m = 1000000007 ; $ c = abc ( $ a , $ b ) ; $ a = $ a \/ $ c ; $ b = $ b \/ $ c ; $ d = modexp ( $ b , $ m - 2 ) ; $ ans = ( ( $ a % $ m ) * ( $ d % $ m ) ) % $ m ; return $ ans ; } $ a = 2 ; $ b = 6 ; echo ( getFractionModulo ( $ a , $ b ) ) ; ? >"}
{"text":"Find sum of a number and its maximum prime factor | Function to return the sum of n and it 's largest prime factor ; Initialise maxPrime to - 1. ; n must be odd at this point , thus skip the even numbers and iterate only odd numbers ; This condition is to handle the case when n is a prime number greater than 2 ; finally return the sum . ; Driver Code","code":"< ? php function maxPrimeFactors ( $ n ) { $ num = $ n ; $ maxPrime = -1 ; while ( $ n % 2 == 0 ) { $ maxPrime = 2 ; $ n \/= 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { while ( $ n % $ i == 0 ) { $ maxPrime = $ i ; $ n = $ n \/ $ i ; } } if ( $ n > 2 ) $ maxPrime = $ n ; $ sum = $ maxPrime + $ num ; return $ sum ; } $ n = 19 ; echo maxPrimeFactors ( $ n ) ; ? >"}
{"text":"Largest number less than N with digit sum greater than the digit sum of N | Function to return the sum of the digits of n ; Loop for each digit of the number ; Function to return the greatest number less than n such that the sum of its digits is greater than the sum of the digits of n ; Starting from n - 1 ; Check until 1 ; If i satisfies the given condition ; If the condition is not satisfied ; Driver code","code":"< ? php function sumOfDigits ( $ n ) { $ res = 0 ; while ( $ n > 0 ) { $ res += $ n % 10 ; $ n \/= 10 ; } return $ res ; } function findNumber ( $ n ) { $ i = $ n - 1 ; while ( $ i > 0 ) { if ( sumOfDigits ( $ i ) > sumOfDigits ( $ n ) ) return $ i ; $ i -- ; } return -1 ; } $ n = 824 ; echo findNumber ( $ n ) ; ? >"}
{"text":"Find the Nth term of the series 14 , 28 , 20 , 40 , ... . . | Function to find the N - th term ; initializing the 1 st number ; loop from 2 nd term to nth term ; if i is even , double the previous number ; if i is odd , subtract 8 from previous number ; Driver Code","code":"< ? php function findNth ( $ N ) { $ b = 14 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 0 ) $ b = $ b * 2 ; else $ b = $ b - 8 ; } return $ b ; } $ N = 6 ; echo findNth ( $ N ) ; ? >"}
{"text":"Problem of 8 Neighbours of an element in a 2 | Dimension of Array ; Count of 1 s ; Counting all neighbouring 1 s ; Comparing the number of neighbouring 1 s with given ranges ; Copying changes to the main matrix ; Driver code ; Function call to calculate the resultant matrix after ' K ' iterations . ; Printing Result","code":"< ? php #define N  4 NEW_LINE function predictMatrix ( $ arr , $ range1a , $ range1b , $ range0a , $ range0b , $ K , $ b ) { $ N = 4 ; $ c = 0 ; while ( $ K -- ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ c = 0 ; if ( $ i > 0 && $ arr [ $ i - 1 ] [ $ j ] == 1 ) $ c ++ ; if ( $ j > 0 && $ arr [ $ i ] [ $ j - 1 ] == 1 ) $ c ++ ; if ( $ i > 0 && $ j > 0 && $ arr [ $ i - 1 ] [ $ j - 1 ] == 1 ) $ c ++ ; if ( $ i < $ N - 1 && $ arr [ $ i + 1 ] [ $ j ] == 1 ) $ c ++ ; if ( $ j < $ N - 1 && $ arr [ $ i ] [ $ j + 1 ] == 1 ) $ c ++ ; if ( $ i < $ N - 1 && $ j < $ N - 1 && $ arr [ $ i + 1 ] [ $ j + 1 ] == 1 ) $ c ++ ; if ( $ i < $ N - 1 && $ j > 0 && $ arr [ $ i + 1 ] [ $ j - 1 ] == 1 ) $ c ++ ; if ( $ i > 0 && $ j < $ N - 1 && $ arr [ $ i - 1 ] [ $ j + 1 ] == 1 ) $ c ++ ; if ( $ arr [ $ i ] [ $ j ] == 1 ) { if ( $ c >= $ range1a && $ c <= $ range1b ) $ b [ $ i ] [ $ j ] = 1 ; else $ b [ $ i ] [ $ j ] = 0 ; } if ( $ arr [ $ i ] [ $ j ] == 0 ) { if ( $ c >= $ range0a && $ c <= $ range0b ) $ b [ $ i ] [ $ j ] = 1 ; else $ b [ $ i ] [ $ j ] = 0 ; } } } for ( $ k = 0 ; $ k < $ N ; $ k ++ ) for ( $ m = 0 ; $ m < $ N ; $ m ++ ) $ arr [ $ k ] [ $ m ] = $ b [ $ k ] [ $ m ] ; } return $ b ; } $ N = 4 ; $ arr = array ( array ( 0 , 0 , 0 , 0 ) , array ( 0 , 1 , 1 , 0 ) , array ( 0 , 0 , 1 , 0 ) , array ( 0 , 1 , 0 , 1 ) ) ; $ range1a = 2 ; $ range1b = 2 ; $ range0a = 2 ; $ range0b = 3 ; $ K = 3 ; $ b = array ( array ( 0 ) ) ; $ b1 = predictMatrix ( $ arr , $ range1a , $ range1b , $ range0a , $ range0b , $ K , $ b ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { echo \" STRNEWLINE \" ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) echo $ b1 [ $ i ] [ $ j ] . \" \u2581 \" ; }"}
{"text":"Number of moves required to guess a permutation . | Function that returns the required moves ; Final move ; Driver Code","code":"< ? php function countMoves ( $ n ) { $ ct = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ct += $ i * ( $ n - $ i ) ; $ ct += $ n ; return $ ct ; } $ n = 3 ; echo countMoves ( $ n ) ; ? >"}
{"text":"Count Numbers with N digits which consists of even number of 0 \u2019 s | Function to count Numbers with N digits which consists of odd number of 0 's ; Driver code","code":"< ? php function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - 1 ) - ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) \/ 2 ; } $ n = 2 ; echo countNumbers ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find determinant of matrix generated by array rotation | PHP program for finding determinant of generated matrix ; Function to calculate determinant ; Driver code","code":"< ? php $ N = 3 ; function calcDeterminant ( $ arr ) { global $ N ; $ determinant = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ determinant += pow ( $ arr [ $ i ] , 3 ) ; } $ determinant -= 3 * $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] ; return $ determinant ; } $ arr = array ( 4 , 5 , 3 ) ; echo calcDeterminant ( $ arr ) ; ? >"}
{"text":"Minimum elements to be added in a range so that count of elements is divisible by K | PHP implementation of the approach ; Total elements in the range ; If total elements are already divisible by k ; Value that must be added to count in order to make it divisible by k ; Driver Program to test above function","code":"< ? php function minimumMoves ( $ k , $ l , $ r ) { $ count = $ r - $ l + 1 ; if ( $ count % $ k == 0 ) return 0 ; return ( $ k - ( $ count % $ k ) ) ; } $ k = 3 ; $ l = 10 ; $ r = 10 ; echo minimumMoves ( $ k , $ l , $ r ) ; ? >"}
{"text":"Sum of all even numbers in range L and R | Function to return the sum of all natural numbers ; Function to return sum of even numbers in range L and R ; Driver Code","code":"< ? php function sumNatural ( $ n ) { $ sum = ( $ n * ( $ n + 1 ) ) ; return $ sum ; } function sumEven ( $ l , $ r ) { return sumNatural ( ( int ) ( $ r \/ 2 ) ) - sumNatural ( ( int ) ( ( $ l - 1 ) \/ 2 ) ) ; } $ l = 2 ; $ r = 5 ; echo \" Sum \u2581 of \u2581 Natural \u2581 numbers \u2581 \" . \" from \u2581 L \u2581 to \u2581 R \u2581 is \u2581 \" . sumEven ( $ l , $ r ) ; ? >"}
{"text":"Check if N is divisible by a number which is composed of the digits from the set { A , B } | Function to check whether n is divisible by a number whose digits are either a or b ; base condition ; recursive call ; Check for all numbers beginning with ' a ' or ' b ' ; Driver Code","code":"< ? php function isDivisibleRec ( $ x , $ a , $ b , $ n ) { if ( $ x > $ n ) return false ; if ( $ n % $ x == 0 ) return true ; return ( isDivisibleRec ( $ x * 10 + $ a , $ a , $ b , $ n ) || isDivisibleRec ( $ x * 10 + $ b , $ a , $ b , $ n ) ) ; } function isDivisible ( $ a , $ b , $ n ) { return isDivisibleRec ( $ a , $ a , $ b , $ n ) || isDivisibleRec ( $ b , $ a , $ b , $ n ) ; } $ a = 3 ; $ b = 5 ; $ n = 53 ; if ( isDivisible ( $ a , $ b , $ n ) ) echo \" Yes \" ; else echo \" No \" ;"}
{"text":"Minimum number of moves required to reach the destination by the king in a chess board | function to Find the minimum number of moves required to reach the destination by the king in a chess board ; minimum number of steps ; while the king is not in the same row or column as the destination ; Go up ; Go down ; Go left ; Go right ; Driver code","code":"< ? php function MinSteps ( $ SourceX , $ SourceY , $ DestX , $ DestY ) { echo max ( abs ( $ SourceX - $ DestX ) , abs ( $ SourceY - $ DestY ) ) . \" \" ; while ( ( $ SourceX != $ DestX ) || ( $ SourceY != $ DestY ) ) { if ( $ SourceX < $ DestX ) { echo ' U ' ; $ SourceX ++ ; } if ( $ SourceX > $ DestX ) { echo ' D ' ; $ SourceX -- ; } if ( $ SourceY > $ DestY ) { echo ' L ' ; $ SourceY -- ; } if ( $ SourceY < $ DestY ) { echo ' R ' ; $ SourceY ++ ; } echo \" STRNEWLINE \" ; } } $ sourceX = 4 ; $ sourceY = 4 ; $ destinationX = 7 ; $ destinationY = 0 ; MinSteps ( $ sourceX , $ sourceY , $ destinationX , $ destinationY ) ; ? >"}
{"text":"Count of pairs in an array whose sum is a perfect square | Function to return an ArrayList containing all the perfect squares upto n ; while current perfect square is less than or equal to n ; Function to print the sum of maximum two elements from the array ; Function to return the count of numbers that when added with n give a perfect square ; temp > n is checked so that pairs ( x , y ) and ( y , x ) don 't get counted twice  ; Function to count the pairs whose sum is a perfect square ; Sum of the maximum two elements from the array ; List of perfect squares upto max ; Contains all the array elements ; Add count of the elements that when added with arr [ i ] give a perfect square ; Driver code","code":"< ? php function getPerfectSquares ( $ n ) { $ perfectSquares = array ( ) ; $ current = 1 ; $ i = 1 ; while ( $ current <= $ n ) { array_push ( $ perfectSquares , $ current ) ; $ current = ( int ) pow ( ++ $ i , 2 ) ; } return $ perfectSquares ; } function maxPairSum ( $ arr ) { $ n = count ( $ arr ) ; $ max ; $ secondMax ; if ( $ arr [ 0 ] > $ arr [ 1 ] ) { $ max = $ arr [ 0 ] ; $ secondMax = $ arr [ 1 ] ; } else { $ max = $ arr [ 1 ] ; $ secondMax = $ arr [ 0 ] ; } for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) { $ secondMax = $ max ; $ max = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ secondMax ) { $ secondMax = $ arr [ $ i ] ; } } return ( $ max + $ secondMax ) ; } function countPairsWith ( $ n , $ perfectSquares , $ nums ) { $ count = 0 ; for ( $ i = 0 ; $ i < count ( $ perfectSquares ) ; $ i ++ ) { $ temp = $ perfectSquares [ $ i ] - $ n ; if ( $ temp > $ n && in_array ( $ temp , $ nums ) ) $ count ++ ; } return $ count ; } function countPairs ( $ arr ) { $ n = count ( $ arr ) ; $ max = maxPairSum ( $ arr ) ; $ perfectSquares = getPerfectSquares ( $ max ) ; $ nums = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) array_push ( $ nums , $ arr [ $ i ] ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count += countPairsWith ( $ arr [ $ i ] , $ perfectSquares , $ nums ) ; } return $ count ; } $ arr = array ( 2 , 3 , 6 , 9 , 10 , 20 ) ; echo countPairs ( $ arr ) ; ? >"}
{"text":"Element equal to the sum of all the remaining elements | Function to find the element ; sum is use to store sum of all elements of array ; iterate over all elements ; Driver code","code":"< ? php function findEle ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ sum - $ arr [ $ i ] ) return $ arr [ $ i ] ; return -1 ; } $ arr = array ( 1 , 2 , 3 , 6 ) ; $ n = sizeof ( $ arr ) ; echo findEle ( $ arr , $ n ) ; ? >"}
{"text":"Sum of all natural numbers in range L to R | Function to return the sum of all natural numbers ; Function to return the sum of all numbers in range L and R ; Driver Code","code":"< ? php function sumNatural ( $ n ) { $ sum = ( $ n * ( $ n + 1 ) ) \/ 2 ; return $ sum ; } function suminRange ( $ l , $ r ) { return sumNatural ( $ r ) - sumNatural ( $ l - 1 ) ; } $ l = 2 ; $ r = 5 ; echo \" Sum \u2581 of \u2581 Natural \u2581 numbers \u2581 \" . \" from \u2581 L \u2581 to \u2581 R \u2581 is \u2581 \" , suminRange ( $ l , $ r ) ; ? >"}
{"text":"Check if a large number is divisible by 75 or not | check divisibleBy3 ; to store sum of Digit ; traversing through each digit ; summing up Digit ; check if sumOfDigit is divisibleBy3 ; check divisibleBy25 ; if a single digit number ; length of the number ; taking the last two digit ; checking if the lastTwo digit is divisibleBy25 ; Function to check divisibleBy75 or not ; check if divisibleBy3 and divisibleBy25 ; Driver Code ; divisible ; if divisibleBy75","code":"< ? php function divisibleBy3 ( $ number ) { $ sumOfDigit = 0 ; for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) $ sumOfDigit += $ number [ $ i ] - '0' ; if ( $ sumOfDigit % 3 == 0 ) return true ; return false ; } function divisibleBy25 ( $ number ) { if ( strlen ( $ number ) < 2 ) return false ; $ length = strlen ( $ number ) ; $ lastTwo = ( $ number [ $ length - 2 ] - '0' ) * 10 + ( $ number [ $ length - 1 ] - '0' ) ; if ( $ lastTwo % 25 == 0 ) return true ; return false ; } function divisibleBy75 ( $ number ) { if ( divisibleBy3 ( $ number ) && divisibleBy25 ( $ number ) ) return true ; return false ; } $ number = \"754586672150\" ; $ divisible = divisibleBy75 ( $ number ) ; if ( $ divisible ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find the other number when LCM and HCF given | Function that will calculates the zeroes at the end ; Driver code ; Calling function .","code":"< ? php function otherNumber ( $ A , $ Lcm , $ Hcf ) { return ( $ Lcm * $ Hcf ) \/ $ A ; } $ A = 8 ; $ Lcm = 8 ; $ Hcf = 1 ; $ result = otherNumber ( $ A , $ Lcm , $ Hcf ) ; echo \" B = \""}
{"text":"Overall percentage change from successive changes | PHP implementation of above approach ; Calculate successive change of 1 st 2 change ; Calculate successive change for rest of the value ; Driver code ; Calling function","code":"< ? php function successiveChange ( $ arr , $ N ) { $ result = 0 ; $ var1 = $ arr [ 0 ] ; $ var2 = $ arr [ 1 ] ; $ result = $ var1 + $ var2 + ( ( $ var1 * $ var2 ) \/ 100 ) ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) $ result = $ result + $ arr [ $ i ] + ( ( $ result * $ arr [ $ i ] ) \/ 100 ) ; return $ result ; } $ arr = array ( 10 , 20 , 30 , 10 ) ; $ N = count ( $ arr ) ; $ result = successiveChange ( $ arr , $ N ) ; echo \" Percentage \u2581 change \u2581 is \u2581 = \u2581 \" , $ result , \" \u2581 % \" ; ? >"}
{"text":"Minimum numbers ( smaller than or equal to N ) with sum S | Function to find the minimum numbers required to get to S ; Driver Code","code":"< ? php function minimumNumbers ( $ n , $ s ) { if ( $ s % $ n ) return round ( $ s \/ $ n + 1 ) ; else return round ( $ s \/ $ n ) ; } $ n = 5 ; $ s = 11 ; echo minimumNumbers ( $ n , $ s ) ; ? >"}
{"text":"Sum of multiples of A and B less than N | PHP program to find the sum of all multiples of A and B below N ; Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of A and B below N ; Since , we need the sum of multiples less than N ; common factors of A and B ; Driver code","code":"< ? php function __gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return __gcd ( $ b , $ a % $ b ) ; } function sumAP ( $ n , $ d ) { $ n = ( int ) ( $ n \/ $ d ) ; return ( $ n ) * ( 1 + $ n ) * $ d \/ 2 ; } function sumMultiples ( $ A , $ B , $ n ) { $ n -- ; $ common = ( int ) ( ( $ A * $ B ) \/ __gcd ( $ A , $ B ) ) ; return sumAP ( $ n , $ A ) + sumAP ( $ n , $ B ) - sumAP ( $ n , $ common ) ; } $ n = 100 ; $ A = 5 ; $ B = 10 ; echo \" Sum = \" ? >"}
{"text":"Check if a prime number can be expressed as sum of two Prime Numbers | Function to check whether a number is prime or not ; Function to check if a prime number can be expressed as sum of two Prime Numbers ; if the number is prime , and number - 2 is also prime ; Driver code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) return false ; } return true ; } function isPossible ( $ N ) { if ( isPrime ( $ N ) && isPrime ( $ N - 2 ) ) return true ; else return false ; } $ n = 13 ; if ( isPossible ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Largest sub | function to return the length of the largest sub - array of an array every element of whose is a perfect square ; if both a and b are equal then arr [ i ] is a perfect square ; Driver code","code":"< ? php function contiguousPerfectSquare ( $ arr , $ n ) { $ current_length = 0 ; $ max_length = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b = ( float ) sqrt ( $ arr [ $ i ] ) ; $ a = ( int ) $ b ; if ( $ a == $ b ) $ current_length = $ current_length + 1 ; else $ current_length = 0 ; $ max_length = max ( $ max_length , $ current_length ) ; } return $ max_length ; } $ arr = array ( 9 , 75 , 4 , 64 , 121 , 25 ) ; $ n = sizeof ( $ arr ) ; echo contiguousPerfectSquare ( $ arr , $ n ) ; ? >"}
{"text":"Count pairs of numbers from 1 to N with Product divisible by their Sum | Function to count pairs ; variable to store count ; Generate all possible pairs such that 1 <= x < y < n ; Driver code","code":"< ? php function countPairs ( $ n ) { $ count = 0 ; for ( $ x = 1 ; $ x < $ n ; $ x ++ ) { for ( $ y = $ x + 1 ; $ y <= $ n ; $ y ++ ) { if ( ( $ y * $ x ) % ( $ y + $ x ) == 0 ) $ count ++ ; } } return $ count ; } $ n = 15 ; echo countPairs ( $ n ) ; ? >"}
{"text":"Find the index of the left pointer after possible moves in the array | Function that returns the index of the left pointer ; there 's only one element  in the array ; initially both are at end ; Driver code","code":"< ? php function getIndex ( $ a , $ n ) { if ( $ n == 1 ) return 0 ; $ ptrL = 0 ; $ ptrR = $ n - 1 ; $ sumL = $ a [ 0 ] ; $ sumR = $ a [ $ n - 1 ] ; while ( $ ptrR - $ ptrL > 1 ) { if ( $ sumL < $ sumR ) { $ ptrL ++ ; $ sumL += $ a [ $ ptrL ] ; } else if ( $ sumL > $ sumR ) { $ ptrR -- ; $ sumR += $ a [ $ ptrR ] ; } else { break ; } } return $ ptrL ; } $ a = array ( 2 , 7 , 9 , 8 , 7 ) ; $ n = count ( $ a ) ; echo getIndex ( $ a , $ n ) ; ? >"}
{"text":"Find the position of the last removed element from the array | Function to find the original position of the element which will be removed last ; take ceil of every number ; Since position is index + 1 ; Driver code","code":"< ? php function getPosition ( $ a , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = ( $ a [ $ i ] \/ $ m + ( $ a [ $ i ] % $ m != 0 ) ) ; } $ ans = -1 ; $ max = -1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ max < $ a [ $ i ] ) { $ max = $ a [ $ i ] ; $ ans = $ i ; } } return $ ans + 1 ; } $ a = array ( 2 , 5 , 4 ) ; $ n = sizeof ( $ a ) ; $ m = 2 ; echo getPosition ( $ a , $ n , $ m ) ; ? >"}
{"text":"Find the value of f ( n ) \/ f ( r ) * f ( n | Function to find value of given F ( n ) ; iterate over n ; calculate result ; return the result ; Driver code","code":"< ? php function calcFunction ( $ n , $ r ) { $ finalDenominator = 1 ; $ mx = max ( $ r , $ n - $ r ) ; for ( $ i = $ mx + 1 ; $ i <= $ n ; $ i ++ ) { $ denominator = pow ( $ i , $ i ) ; $ numerator = pow ( $ i - $ mx , $ i - $ mx ) ; $ finalDenominator = ( $ finalDenominator * $ denominator ) \/ $ numerator ; } return $ finalDenominator ; } $ n = 6 ; $ r = 2 ; echo \"1 \/ \" , calcFunction ( $ n , $ r ) ; ? >"}
{"text":"Find the number after successive division | Function to find the number ; Driver Code","code":"< ? php function findNum ( $ div , $ rem , $ N ) { $ num = $ rem [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ num = $ num * $ div [ $ i ] + $ rem [ $ i ] ; } return $ num ; } $ div = array ( 8 , 3 ) ; $ rem = array ( 2 , 2 ) ; $ N = sizeof ( $ div ) ; echo findNum ( $ div , $ rem , $ N ) ; ? >"}
{"text":"Program to find the profit or loss when CP of N items is equal to SP of M items | Function to calculate Profit or loss ; Driver Code","code":"< ? php function profitLoss ( $ N , $ M ) { if ( $ N == $ M ) echo \" No \u2581 Profit \u2581 nor \u2581 Loss \" ; else { $ result = 0.0 ; $ result = ( abs ( $ N - $ M ) ) \/ $ M ; if ( $ N - $ M < 0 ) echo \" Loss \u2581 = \u2581 - \" , $ result * 100 , \" % \" ; else echo \" Profit \u2581 = \u2581 \" , $ result * 100 , \" % \" ; } } $ N = 8 ; $ M = 9 ; profitLoss ( $ N , $ M ) ; ? >"}
{"text":"Count pieces of circle after N cuts | Function to find number of pieces of circle after N cuts ; Driver Code","code":"< ? php function countPieces ( $ N ) { return 2 * $ N ; } $ N = 100 ; echo countPieces ( $ N ) ; ? >"}
{"text":"Sum of all the multiples of 3 and 7 below N | Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 3 and 7 below N ; Since , we need the sum of multiples less than N ; Driver code","code":"< ? php function sumAP ( $ n , $ d ) { $ n = ( int ) ( $ n \/ $ d ) ; return ( $ n ) * ( 1 + $ n ) * ( $ d \/ 2 ) ; } function sumMultiples ( $ n ) { $ n -- ; return sumAP ( $ n , 3 ) + sumAP ( $ n , 7 ) - sumAP ( $ n , 21 ) ; } $ n = 24 ; echo sumMultiples ( $ n ) ; ? >"}
{"text":"Check whether product of digits at even places is divisible by sum of digits at odd place of a number | Below function checks whether product of digits at even places is divisible by sum of digits at odd places ; if size is even ; if size is odd ; Driver code","code":"< ? php function productSumDivisible ( $ n , $ size ) { $ sum = 0 ; $ product = 1 ; while ( $ n > 0 ) { if ( $ size % 2 == 0 ) { $ product *= $ n % 10 ; } else { $ sum += $ n % 10 ; } $ n = $ n \/ 10 ; $ size -- ; } if ( $ product % $ sum == 0 ) return true ; return false ; } $ n = 1234 ; $ len = 4 ; if ( productSumDivisible ( $ n , $ len ) ) echo \" TRUE \" ; else echo \" FALSE \" ; ? >"}
{"text":"GCD of a number raised to some power and another number | PHP program to find GCD of a ^ n and b ; Returns GCD of a ^ n and b . ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function powGCD ( $ a , $ n , $ b ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ a = $ a * $ a ; return gcd ( $ a , $ b ) ; } $ a = 10 ; $ b = 5 ; $ n = 2 ; echo powGCD ( $ a , $ n , $ b ) ; ? >"}
{"text":"Position after taking N steps to the right and left in an alternate manner | Function to return the last destination ; Driver Code","code":"< ? php function lastCoordinate ( $ n , $ a , $ b ) { return ( ( $ n + 1 ) \/ 2 ) * $ a - ( int ) ( $ n \/ 2 ) * $ b ; } $ n = 3 ; $ a = 5 ; $ b = 2 ; echo lastCoordinate ( $ n , $ a , $ b ) ; ? >"}
{"text":"Smallest number greater than or equal to N divisible by K | Function to find the smallest number greater than or equal to N that is divisible by k ; Driver code","code":"< ? php function findNum ( $ N , $ K ) { $ rem = ( $ N + $ K ) % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N + $ K - $ rem ; } $ N = 45 ; $ K = 6 ; echo \" Smallest \u2581 number \u2581 greater \u2581 than \u2581 \" . \" or \u2581 equal \u2581 to \u2581 \" , $ N ; echo \" that is divisible by \" \u2581 , \u2581 $ K \u2581 , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" is \" ? >"}
{"text":"Sum and Product of digits in a number that divide the number | Print the sum and product of digits that divides the number . ; Fetching each digit of the number ; Checking if digit is greater than 0 and can divides n . ; Driver code","code":"< ? php function countDigit ( $ n ) { $ temp = $ n ; $ sum = 0 ; $ product = 1 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp = ( int ) ( $ temp \/ 10 ) ; if ( $ d > 0 && $ n % $ d == 0 ) { $ sum += $ d ; $ product *= $ d ; } } echo \" Sum = \" . $ sum ; STRNEWLINE TABSYMBOL echo \u2581 \" Product = \" } $ n = 1012 ; countDigit ( $ n ) ; ? >"}
{"text":"Largest number smaller than or equal to N divisible by K | Function to find the largest number smaller than or equal to N that is divisible by k ; Driver code","code":"< ? php function findNum ( $ N , $ K ) { $ rem = $ N % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N - $ rem ; } $ N = 45 ; $ K = 6 ; echo \" Largest \u2581 number \u2581 smaller \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 \" , $ N , \" that is divisible by \" , \u2581 $ K , \u2581 \" is \" findNum ( $ N , $ K ) ; ? >"}
{"text":"Check if any permutation of a number is divisible by 3 and is Palindromic | Function to check if any permutation of a number is divisible by 3 and is Palindromic ; Hash array to store frequency of digits of n ; traverse the digits of integer and store their frequency ; Calculate the sum of digits simultaneously ; Check if number is not divisible by 3 ; If more than one digits have odd frequency , palindromic permutation not possible ; Driver Code","code":"< ? php function isDivisiblePalindrome ( $ n ) { $ hash = array ( 0 ) ; $ digitSum = 0 ; while ( $ n ) { $ digitSum += $ n % 10 ; $ hash ++ ; $ n \/= 10 ; } if ( $ digitSum % 3 != 0 ) return false ; $ oddCount = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { if ( $ hash % 2 != 0 ) $ oddCount ++ ; } if ( $ oddCount > 1 ) return true ; else return false ; } $ n = 34734 ; if ( isDivisiblePalindrome ( $ n ) ) echo \" True \" ; else echo \" False \" ; # This  Code is contributed by Tushill. NEW_LINE ? >"}
{"text":"Check whether product of digits at even places of a number is divisible by K | Below function checks whether product of digits at even places is divisible by K ; if position is even ; Driver code","code":"< ? php function productDivisible ( $ n , $ k ) { $ product = 1 ; $ position = 1 ; while ( $ n > 0 ) { if ( $ position % 2 == 0 ) $ product *= $ n % 10 ; $ n = ( int ) ( $ n \/ 10 ) ; $ position ++ ; } if ( $ product % $ k == 0 ) return true ; return false ; } $ n = 321922 ; $ k = 3 ; if ( productDivisible ( $ n , $ k ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Permutations of n things taken r at a time with k things together | Function to find factorial of a number ; Function to calculate p ( n , r ) ; Function to find the number of permutations of n different things taken r at a time with k things grouped together ; Driver code","code":"< ? php function factorial ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function npr ( $ n , $ r ) { $ pnr = factorial ( $ n ) \/ factorial ( $ n - $ r ) ; return $ pnr ; } function countPermutations ( $ n , $ r , $ k ) { return factorial ( $ k ) * ( $ r - $ k + 1 ) * npr ( $ n - $ k , $ r - $ k ) ; } $ n = 8 ; $ r = 5 ; $ k = 2 ; echo countPermutations ( $ n , $ r , $ k ) ; ? >"}
{"text":"Greatest Integer Function | Function to calculate the GIF value of a number ; GIF is the floor of a number ; Driver code","code":"< ? php function GIF ( $ n ) { return floor ( $ n ) ; } $ n = 2.3 ; echo GIF ( $ n ) ; ? >"}
{"text":"Number of triangles formed from a set of points on three lines | Returns factorial of a number ; calculate c ( n , r ) ; Driver code","code":"< ? php function factorial ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact = $ fact * $ i ; return $ fact ; } function ncr ( $ n , $ r ) { return factorial ( $ n ) \/ ( factorial ( $ r ) * factorial ( $ n - $ r ) ) ; } $ m = 3 ; $ n = 4 ; $ k = 5 ; $ totalTriangles = ncr ( $ m + $ n + $ k , 3 ) - ncr ( $ m , 3 ) - ncr ( $ n , 3 ) - ncr ( $ k , 3 ) ; echo $ totalTriangles . \" STRNEWLINE \" ;"}
{"text":"Check whether sum of digits at odd places of a number is divisible by K | function that checks the divisibility of the sum of the digits at odd places of the given number ; if position is odd ; Driver code","code":"< ? php function SumDivisible ( $ n , $ k ) { $ sum = 0 ; $ position = 1 ; while ( $ n > 0 ) { if ( $ position % 2 == 1 ) $ sum += $ n % 10 ; $ n = ( int ) $ n \/ 10 ; $ position ++ ; } if ( $ sum % $ k == 0 ) return true ; return false ; } $ n = 592452 ; $ k = 3 ; if ( SumDivisible ( $ n , $ k ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Check if a triangle of positive area is possible with the given angles | PHP program to check if a triangle of positive area is possible with the given angles ; Checking if the sum of three angles is 180 and none of the angles is zero ; Checking if sum of any two angles is greater than equal to the third one ; Driver Code","code":"< ? php function isTriangleExists ( $ a , $ b , $ c ) { if ( $ a != 0 && $ b != 0 && $ c != 0 && ( $ a + $ b + $ c ) == 180 ) if ( ( $ a + $ b ) >= $ c || ( $ b + $ c ) >= $ a || ( $ a + $ c ) >= $ b ) return \" YES \" ; else return \" NO \" ; else return \" NO \" ; } $ a = 50 ; $ b = 60 ; $ c = 70 ; echo isTriangleExists ( $ a , $ b , $ c ) ; ? >"}
{"text":"Find maximum value of x such that n ! % ( k ^ x ) = 0 | Function to maximize the value of x such that n ! % ( k ^ x ) = 0 ; Find square root of k and add 1 to it ; Run the loop from 2 to m and k should be greater than 1 ; optimize the value of k ; Minimum store ; Driver Code","code":"< ? php function findX ( $ n , $ k ) { $ r = $ n ; $ m = ( int ) sqrt ( $ k ) + 1 ; for ( $ i = 2 ; $ i <= $ m && $ k > 1 ; $ i ++ ) { if ( $ i == $ m ) { $ i = $ k ; } for ( $ u = $ v = 0 ; $ k % $ i == 0 ; $ v ++ ) { $ k = ( int ) ( $ k \/ $ i ) ; } if ( $ v > 0 ) { $ t = $ n ; while ( $ t > 0 ) { $ t = ( int ) ( $ t \/ $ i ) ; $ u = $ u + $ t ; } $ r = min ( $ r , ( int ) ( $ u \/ $ v ) ) ; } } return $ r ; } $ n = 5 ; $ k = 2 ; echo findX ( $ n , $ k ) ; ? >"}
{"text":"Ways of selecting men and women from a group to make a team | Returns factorial of the number ; Function to calculate ncr ; Function to calculate the total possible ways ; Driver code","code":"< ? php function fact ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ fact *= $ i ; return $ fact ; } function ncr ( $ n , $ r ) { $ ncr = ( int ) ( fact ( $ n ) \/ ( fact ( $ r ) * fact ( $ n - $ r ) ) ) ; return $ ncr ; } function ways ( $ m , $ w , $ n , $ k ) { $ ans = 0 ; while ( $ m >= $ k ) { $ ans += ncr ( $ m , $ k ) * ncr ( $ w , $ n - $ k ) ; $ k += 1 ; } return $ ans ; } $ m = 7 ; $ w = 6 ; $ n = 5 ; $ k = 3 ; echo ways ( $ m , $ w , $ n , $ k ) ;"}
{"text":"Sum of greatest odd divisor of numbers in given range | Function to return sum of first n odd numbers ; Recursive function to return sum of greatest odd divisor of numbers in range [ 1 , n ] ; { Odd n ; { Even n ; Function to return sum of greatest odd divisor of numbers in range [ a , b ] ; Driver code","code":"< ? php function square ( $ n ) { return $ n * $ n ; } function sum ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n % 2 == 1 ) return square ( ( int ) ( ( $ n + 1 ) \/ 2 ) ) + sum ( ( int ) ( $ n \/ 2 ) ) ; } else return square ( ( int ) ( $ n \/ 2 ) ) + sum ( ( int ) ( $ n \/ 2 ) ) ; } } function oddDivSum ( $ a , $ b ) { return sum ( $ b ) - sum ( $ a - 1 ) ; } $ a = 3 ; $ b = 9 ; echo oddDivSum ( $ a , $ b ) ; ? >"}
{"text":"Minimum numbers needed to express every integer below N as a sum | function to count length of binary expression of n ; Driver code","code":"< ? php function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; } $ n = 32 ; echo \" Minimum \u2581 value \u2581 of \u2581 K \u2581 is \u2581 = \u2581 \" , countBits ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if a number is an Achilles number or not | Function to check if the number is powerful number ; First divide the number repeatedly by 2 ; If only 2 ^ 1 divides n ( not higher powers ) , then return false ; if n is not a power of 2 then this loop will execute repeat above process ; Find highest power of \" factor \" that divides n ; If only factor ^ 1 divides n ( not higher powers ) , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Utility function to check if number is a perfect power or not ; Function to check Achilles Number ; Driver Code","code":"< ? php function isPowerful ( $ n ) { while ( $ n % 2 == 0 ) { $ power = 0 ; while ( $ n % 2 == 0 ) { $ n \/= 2 ; $ power ++ ; } if ( $ power == 1 ) return false ; } for ( $ factor = 3 ; $ factor <= sqrt ( $ n ) ; $ factor += 2 ) { $ power = 0 ; while ( $ n % $ factor == 0 ) { $ n = $ n \/ $ factor ; $ power ++ ; } if ( $ power == 1 ) return false ; } return ( $ n == 1 ) ; } function isPower ( $ a ) { if ( $ a == 1 ) return true ; for ( $ i = 2 ; $ i * $ i <= $ a ; $ i ++ ) { $ val = log ( $ a ) \/ log ( $ i ) ; if ( ( $ val - ( int ) $ val ) < 0.00000001 ) return true ; } return false ; } function isAchillesNumber ( $ n ) { if ( isPowerful ( $ n ) && ! isPower ( $ n ) ) return true ; else return false ; } $ n = 72 ; if ( isAchillesNumber ( $ n ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; $ n = 36 ; if ( isAchillesNumber ( $ n ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; ? >"}
{"text":"Program to find count of numbers having odd number of divisors in given range | Function to count numbers having odd number of divisors in range [ A , B ] ; variable to odd divisor count ; iterate from a to b and count their number of divisors ; variable to divisor count ; if count of divisor is odd then increase res by 1 ; Driver code","code":"< ? php function OddDivCount ( $ a , $ b ) { $ res = 0 ; for ( $ i = $ a ; $ i <= $ b ; ++ $ i ) { $ divCount = 0 ; for ( $ j = 1 ; $ j <= $ i ; ++ $ j ) { if ( $ i % $ j == 0 ) { ++ $ divCount ; } } if ( $ divCount % 2 ) { ++ $ res ; } } return $ res ; } $ a = 1 ; $ b = 10 ; echo OddDivCount ( $ a , $ b ) ; ? >"}
{"text":"Largest factor of a given number which is a perfect square | Function to find the largest factor of a given number which is a perfect square ; Initialise the answer to 1 ; Finding the prime factors till sqrt ( num ) ; Frequency of the prime factor in the factorisation initialised to 0 ; If the frequency is odd then multiply i frequency - 1 times to the answer ; Else if it is even , multiply it frequency times ; Driver Code","code":"< ? php function largestSquareFactor ( $ num ) { $ answer = 1 ; for ( $ i = 2 ; $ i < sqrt ( $ num ) ; ++ $ i ) { $ cnt = 0 ; $ j = $ i ; while ( $ num % $ j == 0 ) { $ cnt ++ ; $ j *= $ i ; } if ( $ cnt & 1 ) { $ cnt -- ; $ answer *= pow ( $ i , $ cnt ) ; } else { $ answer *= pow ( $ i , $ cnt ) ; } } return $ answer ; } $ N = 420 ; echo largestSquareFactor ( $ N ) ; ? >"}
{"text":"Find the Nth term of the series 2 + 6 + 13 + 23 + . . . | calculate Nth term of given series ; Driver code","code":"< ? php function Nth_Term ( $ n ) { return ( 3 * pow ( $ n , 2 ) - $ n + 2 ) \/ ( 2 ) ; } $ N = 5 ; echo ( Nth_Term ( $ N ) ) ; ? >"}
{"text":"All possible numbers of N digits and base B without leading zeros | function to count all permutations ; count of all permutations ; count of permutations with leading zeros ; Return the permutations without leading zeros ; Driver code","code":"< ? php function countPermutations ( $ N , $ B ) { $ x = pow ( $ B , $ N ) ; $ y = pow ( $ B , $ N - 1 ) ; echo ( $ x - $ y ) , \" STRNEWLINE \" ; } $ N = 6 ; $ B = 4 ; countPermutations ( $ N , $ B ) ; ? >"}
{"text":"Absolute difference between the Product of Non | Function to find the difference between the product of non - primes and the product of primes of an array . ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store the product of primes in P1 and the product of non primes in P2 ; the number is prime ; the number is non - prime ; Return the absolute difference ; Driver Code ; Find the absolute difference","code":"< ? php function calculateDifference ( $ arr , $ n ) { $ max_val = max ( $ arr ) ; $ prime = array_fill ( 0 , $ max_val , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ P1 = 1 ; $ P2 = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) { $ P1 *= $ arr [ $ i ] ; } else if ( $ arr [ $ i ] != 1 ) { $ P2 *= $ arr [ $ i ] ; } } return abs ( $ P2 - $ P1 ) ; } $ arr = array ( 1 , 3 , 5 , 10 , 15 , 7 ) ; $ n = count ( $ arr , COUNT_NORMAL ) ; echo CalculateDifference ( $ arr , $ n ) ; ? >"}
{"text":"Maximum count of equal numbers in an array after performing given operations | Function to find the maximum number of equal numbers in an array ; to store sum of elements ; if sum of numbers is not divisible by n ; Driver Code ; size of an array","code":"< ? php function EqualNumbers ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; if ( $ sum % $ n ) return $ n - 1 ; return $ n ; } $ a = array ( 1 , 4 , 1 ) ; $ n = sizeof ( $ a ) ; echo EqualNumbers ( $ a , $ n ) ;"}
{"text":"Count number of ordered pairs with Even and Odd Sums | function to count odd sum pair ; if number is even ; if number is odd ; count of ordered pairs ; function to count even sum pair ; Driver code","code":"< ? php function count_odd_pair ( $ n , $ a ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } $ ans = $ odd * $ even * 2 ; return $ ans ; } function count_even_pair ( $ odd_sum_pairs , $ n ) { $ total_pairs = ( $ n * ( $ n - 1 ) ) ; $ ans = $ total_pairs - $ odd_sum_pairs ; return $ ans ; } $ n = 6 ; $ a = array ( 2 , 4 , 5 , 9 , 1 , 8 ) ; $ odd_sum_pairs = count_odd_pair ( $ n , $ a ) ; $ even_sum_pairs = count_even_pair ( $ odd_sum_pairs , $ n ) ; echo \" Even \u2581 Sum \u2581 Pairs \u2581 = \u2581 $ even _ sum _ pairs \u2581 STRNEWLINE \" ; echo \" Odd \u2581 Sum \u2581 Pairs = \u2581 $ odd _ sum _ pairs \u2581 STRNEWLINE \" ; ? >"}
{"text":"Steps required to visit M points in order on a circular ring of N points | Function to count the steps required ; Start at 1 ; Initialize steps ; If nxt is greater than cur ; Now we are at a [ i ] ; Driver code","code":"< ? php function findSteps ( $ n , $ m , $ a ) { $ cur = 1 ; $ steps = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ a [ $ i ] >= $ cur ) $ steps += ( $ a [ $ i ] - $ cur ) ; else $ steps += ( $ n - $ cur + $ a [ $ i ] ) ; $ cur = $ a [ $ i ] ; } return $ steps ; } $ n = 3 ; $ m = 3 ; $ a = array ( 2 , 1 , 2 ) ; echo findSteps ( $ n , $ m , $ a ) ; ? >"}
{"text":"Program to Convert Hexadecimal Number to Binary | function to convert Hexadecimal to Binary Number ; Get the Hexadecimal number ; Convert HexaDecimal to Binary","code":"< ? php function HexToBin ( $ hexdec ) { $ i = 0 ; while ( $ hexdec [ $ i ] ) { switch ( $ hexdec [ $ i ] ) { case '0' : echo \"0000\" ; break ; case '1' : echo \"0001\" ; break ; case '2' : echo \"0010\" ; break ; case '3' : echo \"0011\" ; break ; case '4' : echo \"0100\" ; break ; case '5' : echo \"0101\" ; break ; case '6' : echo \"0110\" ; break ; case '7' : echo \"0111\" ; break ; case '8' : echo \"1000\" ; break ; case '9' : echo \"1001\" ; break ; case ' A ' : case ' a ' : echo \"1010\" ; break ; case ' B ' : case ' b ' : echo \"1011\" ; break ; case ' C ' : case ' c ' : echo \"1100\" ; break ; case ' D ' : case ' d ' : echo \"1101\" ; break ; case ' E ' : case ' e ' : echo \"1110\" ; break ; case ' F ' : case ' f ' : echo \"1111\" ; break ; default : echo \" Invalid hexadecimal digit \" $ hexdec [ $ i ] ; } $ i ++ ; } } $ hexdec = \"1AC5\" ; echo \" Equivalent Binary value is : \" HexToBin ( $ hexdec ) ;"}
{"text":"Count unordered pairs ( i , j ) such that product of a [ i ] and a [ j ] is power of two | Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Function to Count unordered pairs ; is a number can be expressed as power of two ; count total number of unordered pairs ; Driver code","code":"< ? php function isPowerOfTwo ( $ x ) { return ( $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ) ; } function Count_pairs ( $ a , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPowerOfTwo ( $ a [ $ i ] ) ) $ count ++ ; } $ ans = ( $ count * ( $ count - 1 ) ) \/ 2 ; echo $ ans , \" STRNEWLINE \" ; } $ a = array ( 2 , 5 , 8 , 16 , 128 ) ; $ n = sizeof ( $ a ) ; Count_pairs ( $ a , $ n ) ; ? >"}
{"text":"Ways of dividing a group into two halves such that two elements are in different groups | This function will return the factorial of a given number ; This function will calculate nCr of given n and r ; This function will Calculate number of ways ; Driver Code","code":"< ? php function factorial ( $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result = $ result * $ i ; return $ result ; } function nCr ( $ n , $ r ) { return factorial ( $ n ) \/ ( factorial ( $ r ) * factorial ( $ n - $ r ) ) ; } function calculate_result ( $ n ) { $ result = 2 * nCr ( ( $ n - 2 ) , ( $ n \/ 2 - 1 ) ) ; return $ result ; } $ a = 2 ; $ b = 4 ; echo calculate_result ( 2 * $ a ) . \" STRNEWLINE \" ; echo calculate_result ( 2 * $ b ) . \" STRNEWLINE \" ; ? >"}
{"text":"Print values of ' a ' in equation ( a + b ) <= n and a + b is divisible by x | function to Find values of a , in equation ( a + b ) <= n and a + b is divisible by x . ; least possible which is divisible by x ; run a loop to get required answer ; increase value by x ; answer is possible ; Driver code ; function call","code":"< ? php function PossibleValues ( $ b , $ x , $ n ) { $ leastdivisible = ( intval ( $ b \/ $ x ) + 1 ) * $ x ; $ flag = 1 ; while ( $ leastdivisible <= $ n ) { if ( $ leastdivisible - $ b >= 1 ) { echo $ leastdivisible - $ b . \" \" ; $ leastdivisible += $ x ; $ flag = 0 ; } else break ; } if ( $ flag ) echo \" - 1\" ; } $ b = 10 ; $ x = 6 ; $ n = 40 ; PossibleValues ( $ b , $ x , $ n ) ; ? >"}
{"text":"Check if all sub | Function to calculate product of digits between given indexes ; Function to check if all sub - numbers have distinct Digit product ; Length of number N ; Digit array ; to maintain digit products ; Finding all possible subarrays ; Driver code","code":"< ? php function digitProduct ( $ digits , $ start , $ end ) { $ pro = 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ pro *= $ digits [ $ i ] ; } return $ pro ; } function isDistinct ( $ N ) { $ s = \" $ N \" ; $ len = sizeof ( $ s ) ; $ digits = array ( ) ; $ products = array ( ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ digits [ $ i ] = $ s [ $ i ] - '0' ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ val = digitProduct ( $ digits , $ i , $ j ) ; if ( in_array ( $ val , $ products ) ) return false ; else array_push ( $ products , $ val ) ; } } return true ; } $ N = 324 ; if ( isDistinct ( $ N ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Hilbert Number | Utility function to return Nth Hilbert Number ; Driver code","code":"< ? php function nthHilbertNumber ( $ n ) { return 4 * ( $ n - 1 ) + 1 ; } $ n = 5 ; echo nthHilbertNumber ( $ n ) ; ? >"}
{"text":"Program to find the nth Kynea number | Function to calculate nth kynea number ; Firstly calculate 2 ^ n + 1 ; Now calculate ( 2 ^ n + 1 ) ^ 2 ; Now calculate ( ( 2 ^ n + 1 ) ^ 2 ) - 2 ; return nth Kynea number ; Driver Code ; print nth kynea number","code":"< ? php function nthKyneaNumber ( $ n ) { $ n = ( 1 << $ n ) + 1 ; $ n = $ n * $ n ; $ n = $ n - 2 ; return $ n ; } $ n = 8 ; echo nthKyneaNumber ( $ n ) ;"}
{"text":"Program to find the nth Kynea number | Function to calculate nth kynea number ; Calculate nth kynea number ; Driver Code ; print nth kynea number","code":"< ? php function nthKyneaNumber ( $ n ) { return ( ( 1 << ( 2 * $ n ) ) + ( 1 << ( $ n + 1 ) ) - 1 ) ; } $ n = 2 ; echo nthKyneaNumber ( $ n ) ; ? >"}
{"text":"Program to check whether a number is Proth number or not | Utility function to check power of two ; Function to check if the Given number is Proth number or not ; check if k divides n or not ; Check if n \/ k is power of 2 or not ; update k to next odd number ; If we reach here means there exists no value of K Such that k is odd number and n \/ k is a power of 2 greater than k ; Get n ; Check n for Proth Number","code":"< ? php function isPowerOfTwo ( $ n ) { return ( $ n && ! ( $ n & ( $ n - 1 ) ) ) ; } function isProthNumber ( $ n ) { $ k = 1 ; while ( $ k < ( $ n \/ $ k ) ) { if ( $ n % $ k == 0 ) { if ( isPowerOfTwo ( $ n \/ $ k ) ) return true ; } $ k = $ k + 2 ; } return false ; } $ n = 25 ; if ( isProthNumber ( $ n - 1 ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find last two digits of sum of N factorials | Function to find the unit ' s \u2581 and \u2581 ten ' s place digit ; Let us write for cases when N is smaller than or equal to 10. ; We know following ( 1 ! + 2 ! + 3 ! + 4 ! ... + 10 ! ) % 100 = 13 else ( N >= 10 ) ; Driver code","code":"< ? php function get_last_two_digit ( $ N ) { if ( $ N <= 10 ) { $ ans = 0 ; $ fac = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fac = $ fac * $ i ; $ ans += $ fac ; } return $ ans % 100 ; } return 13 ; } $ N = 1 ; for ( $ N = 1 ; $ N <= 10 ; $ N ++ ) echo \" For \u2581 N \u2581 = \u2581 \" . $ N . \" \u2581 : \u2581 \" . get_last_two_digit ( $ N ) . \" STRNEWLINE \" ;"}
{"text":"Check whether product of ' n ' numbers is even or odd | function to check whether product of ' n ' numbers is even or odd ; if a single even number is found , then final product will be an even number ; product is an odd number ; Driver code","code":"< ? php function isProductEven ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] & 1 ) == 0 ) return true ; return false ; } $ arr = array ( 2 , 4 , 3 , 5 ) ; $ n = sizeof ( $ arr ) ; if ( isProductEven ( $ arr , $ n ) ) echo \" Even \" ; else echo \" Odd \" ; ? >"}
{"text":"Sum of squares of Fibonacci numbers | Function to calculate sum of squares of Fibonacci numbers ; Initialize result ; Add remaining terms ; Driver Code","code":"< ? php function calculateSquareSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = ( $ fibo [ 0 ] * $ fibo [ 0 ] ) + ( $ fibo [ 1 ] * $ fibo [ 1 ] ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += ( $ fibo [ $ i ] * $ fibo [ $ i ] ) ; } return $ sum ; } $ n = 6 ; echo \" Sum \u2581 of \u2581 squares \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \u2581 \" , calculateSquareSum ( $ n ) ; ? >"}
{"text":"Value of the series ( 1 ^ 3 + 2 ^ 3 + 3 ^ 3 + ... + n ^ 3 ) mod 4 for a given n | function for obtaining the value of f ( n ) mod 4 ; Find the remainder of n when divided by 4 ; If n is of the form 4 k or 4 k + 3 ; If n is of the form 4 k + 1 or 4 k + 2 ; Driver code","code":"< ? php function fnMod ( $ n ) { $ rem = $ n % 4 ; if ( $ rem == 0 or $ rem == 3 ) return 0 ; else if ( $ rem == 1 or $ rem == 2 ) return 1 ; } $ n = 6 ; echo fnMod ( $ n ) ; ? >"}
{"text":"Minimum increment operations to make the array in increasing order | function to find minimum moves required to make the array in increasing order ; to store answer ; iterate over an array ; non - increasing order ; add moves to answer ; increase the element ; return required answer ; Driver code","code":"< ? php function MinimumMoves ( & $ a , $ n , $ x ) { $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ a [ $ i - 1 ] ) { $ p = ( $ a [ $ i - 1 ] - $ a [ $ i ] ) \/ $ x + 1 ; $ ans += $ p ; $ a [ $ i ] += $ p * $ x ; } } return $ ans ; } $ arr = array ( 1 , 3 , 3 , 2 ) ; $ x = 2 ; $ n = sizeof ( $ arr ) ; echo ( ( int ) MinimumMoves ( $ arr , $ n , $ x ) ) ; ? >"}
{"text":"Check if a large number is divisible by 2 , 3 and 5 or not | function to return sum of digits of a number ; function to Check if a large number is divisible by 2 , 3 and 5 or not ; Driver code","code":"< ? php function SumOfDigits ( $ str , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( int ) ( $ str [ $ i ] - '0' ) ; return $ sum ; } function Divisible ( $ str , $ n ) { if ( SumOfDigits ( $ str , $ n ) % 3 == 0 and $ str [ $ n - 1 ] == '0' ) return true ; return false ; } $ str = \"263730746028908374890\" ; $ n = strlen ( $ str ) ; if ( Divisible ( $ str , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Count all the numbers in a range with smallest factor as K | Function to check if k is a prime number or not ; Corner case ; Check from 2 to n - 1 ; Function to check if a number is not divisible by any number between 2 and K - 1 ; to check if the num is divisible by any numbers between 2 and k - 1 ; if not divisible by any number between 2 and k - 1 but divisible by k ; Function to find count of numbers in range [ a , b ] with smallest factor as K ; a number can be divisible only by k and not by any number less than k only if k is a prime ; to check if a number has smallest factor as K ; Driver code","code":"< ? php function isPrime ( $ k ) { if ( $ k <= 1 ) return false ; for ( $ i = 2 ; $ i < $ k ; $ i ++ ) if ( $ k % $ i == 0 ) return false ; return true ; } function check ( $ num , $ k ) { $ flag = 1 ; for ( $ i = 2 ; $ i < $ k ; $ i ++ ) { if ( $ num % $ i == 0 ) $ flag = 0 ; } if ( $ flag == 1 ) { if ( $ num % $ k == 0 ) return 1 ; else return 0 ; } else return 0 ; } function findCount ( $ a , $ b , $ k ) { $ count = 0 ; if ( ! isPrime ( $ k ) ) return 0 ; else { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { $ ans = check ( $ i , $ k ) ; if ( $ ans == 1 ) $ count ++ ; else continue ; } } return $ count ; } $ a = 2020 ; $ b = 6300 ; $ k = 29 ; echo ( findCount ( $ a , $ b , $ k ) ) ; ? >"}
{"text":"Number of solutions for x < y , where a <= x <= b and c <= y <= d and x , y are integers | function to Find the number of solutions for x < y , where a <= x <= b and c <= y <= d and x , y integers . ; to store answer ; iterate explicitly over all possible values of x ; return answer ; Driver code ; function call","code":"< ? php function NumberOfSolutions ( $ a , $ b , $ c , $ d ) { $ ans = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ d >= max ( $ c , $ i + 1 ) ) $ ans += $ d - max ( $ c , $ i + 1 ) + 1 ; return $ ans ; } $ a = 2 ; $ b = 3 ; $ c = 3 ; $ d = 4 ; echo NumberOfSolutions ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text":"Minimum value possible of a given function from the given set | Function to find the value of F ( n ) ; Driver code","code":"< ? php function findF_N ( $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans += ( $ i + 1 ) * ( $ n - $ i - 1 ) ; return $ ans ; } $ n = 3 ; echo findF_N ( $ n ) ;"}
{"text":"Find N digits number which is divisible by D | Function to return N digits number which is divisible by D ; to store answer ; Driver code","code":"< ? php function findNumber ( $ n , $ d ) { $ ans = \" \" ; if ( $ d != 10 ) { $ ans . = strval ( $ d ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } else { if ( n == 1 ) $ ans . = \" Impossible \" ; else $ ans . = '1' ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } return $ ans ; } $ n = 12 ; $ d = 3 ; print ( findNumber ( $ n , $ d ) ) ;"}
{"text":"Count all the numbers less than 10 ^ 6 whose minimum prime factor is N | PHP implementation of above approach ; the sieve of prime number and count of minimum prime factor ; form the prime sieve ; 1 is not a prime number ; form the sieve ; if i is prime ; if i is the least prime factor ; mark the number j as non prime ; count the numbers whose least prime factor is i ; form the sieve ; display ; display","code":"< ? php $ MAX = 1000000 ; $ sieve_Prime = array_fill ( 0 , $ MAX + 4 , NULL ) ; $ sieve_count = array_fill ( 0 , $ MAX + 4 , NULL ) ; function form_sieve ( ) { global $ sieve_Prime , $ sieve_count , $ MAX ; $ sieve_Prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ MAX ; $ i ++ ) { if ( $ sieve_Prime [ $ i ] == 0 ) { for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) { if ( $ sieve_Prime [ $ j ] == 0 ) { $ sieve_Prime [ $ j ] = 1 ; $ sieve_count [ $ i ] ++ ; } } } } } form_sieve ( ) ; $ n = 2 ; echo \" Count = \" \u2581 . \u2581 ( $ sieve _ count [ $ n ] \u2581 + \u2581 1 ) \u2581 . \u2581 \" \" $ n = 3 ; echo \" Count = \" \u2581 . \u2581 ( $ sieve _ count [ $ n ] \u2581 + \u2581 1 ) \u2581 . \u2581 \" \" ? >"}
{"text":"Find the largest good number in the divisors of given number N | function to return distinct prime factors ; to store distinct prime factors ; run a loop upto sqrt ( n ) ; place this prime factor in vector ; This condition is to handle the case when n is a prime number greater than 1 ; function that returns good number ; distinct prime factors ; to store answer ; product of all distinct prime factors is required answer ; Driver code ; function call","code":"< ? php function PrimeFactors ( $ n ) { $ v = array ( ) ; $ x = $ n ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ x % $ i == 0 ) { array_push ( $ v , $ i ) ; while ( $ x % $ i == 0 ) $ x \/= $ i ; } } if ( $ x > 1 ) array_push ( $ v , $ x ) ; return $ v ; } function GoodNumber ( $ n ) { $ v = PrimeFactors ( $ n ) ; $ ans = 1 ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) $ ans *= $ v [ $ i ] ; return $ ans ; } $ n = 12 ; echo GoodNumber ( $ n ) ; ? >"}
{"text":"Find Largest Special Prime which is less than or equal to a given number | Function to check whether the number is a special prime or not ; While number is not equal to zero ; If the number is not prime return false . ; Else remove the last digit by dividing the number by 10. ; If the number has become zero then the number is special prime , hence return true ; Function to find the Largest Special Prime which is less than or equal to a given number ; Initially all numbers are considered Primes . ; There is always an answer possible ; Checking if the number is a special prime or not ; If yes print the number and break the loop . ; Else decrement the number . ; Driver code","code":"< ? php function checkSpecialPrime ( & $ sieve , $ num ) { while ( $ num ) { if ( ! $ sieve [ $ num ] ) { return false ; } $ num = ( int ) ( $ num \/ 10 ) ; } return true ; } function findSpecialPrime ( $ N ) { $ sieve = array_fill ( 0 , $ N + 10 , true ) ; $ sieve [ 0 ] = $ sieve [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { if ( $ sieve [ $ i ] ) { for ( $ j = $ i * $ i ; $ j <= $ N ; $ j += $ i ) { $ sieve [ $ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( $ sieve , $ N ) ) { echo $ N . \" STRNEWLINE \" ; break ; } else $ N -- ; } } findSpecialPrime ( 379 ) ; findSpecialPrime ( 100 ) ; ? >"}
{"text":"Check if a number is a Pythagorean Prime or not | Function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver Code ; Check if number is prime and of the form 4 * n + 1","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 or $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 or $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } $ n = 13 ; if ( isPrime ( $ n ) && ( $ n % 4 == 1 ) ) { echo \" YES \" ; } else { echo \" NO \" ; } ? >"}
{"text":"Divide an isosceles triangle in two parts with ratio of areas as n : m | Function to return the height ; type cast the n , m into float ; calculate the height for cut ; Driver code","code":"< ? php function heightCalculate ( $ H , $ n , $ m ) { $ N = $ n * 1.0 ; $ M = $ m * 1.0 ; $ h = $ H * sqrt ( $ N \/ ( $ N + $ M ) ) ; return $ h ; } $ H = 10 ; $ n = 3 ; $ m = 4 ; echo heightCalculate ( $ H , $ n , $ m ) ; ? >"}
{"text":"Check n ^ 2 | Check a number is prime or not ; run a loop upto square of given number ; Check if n ^ 2 - m ^ 2 is prime ; Driver code","code":"< ? php function isprime ( $ x ) { for ( $ i = 2 ; $ i * $ i <= $ x ; $ i ++ ) if ( $ x % i == 0 ) return false ; return true ; } function isNSqMinusnMSqPrime ( $ m , $ n ) { if ( $ n - $ m == 1 and isprime ( $ m + $ n ) ) return true ; else return false ; } $ m = 13 ; $ n = 16 ; if ( isNSqMinusnMSqPrime ( $ m , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find ' N ' number of solutions with the given inequality equations | Function to calculate all the solutions ; there is no solutions ; print first element as y - n + 1 ; print rest n - 1 elements as 1 ; initialize the number of elements and the value of x an y","code":"< ? php function findsolution ( $ n , $ x , $ y ) { if ( ( $ y - $ n + 1 ) * ( $ y - $ n + 1 ) + $ n - 1 < $ x $ y < $ n ) { echo \" No \u2581 solution \" ; return ; } echo $ y - $ n + 1 ; while ( $ n -- > 1 ) echo \" STRNEWLINE \" . 1 ; } $ n = 5 ; $ x = 15 ; $ y = 15 ; findsolution ( $ n , $ x , $ y ) ;"}
{"text":"Number of different positions where a person can stand | Function to find the position ; Driver code","code":"< ? php function findPosition ( $ n , $ f , $ b ) { return $ n - max ( $ f + 1 , $ n - $ b ) + 1 ; } $ n = 5 ; $ f = 2 ; $ b = 3 ; echo findPosition ( $ n , $ f , $ b ) ; ? >"}
{"text":"Program for n | Function to find the Nth odd number ; Driver code","code":"< ? php function nthOdd ( $ n ) { return ( 2 * $ n - 1 ) ; } $ n = 10 ; echo nthOdd ( $ n ) ; ? >"}
{"text":"Program for n | Function to find the nth even number ; Driver code","code":"< ? php function nthEven ( $ n ) { return ( 2 * $ n ) ; } $ n = 10 ; echo nthEven ( $ n ) ; ? >"}
{"text":"Program to find the Nth Harmonic Number | Function to find N - th Harmonic Number ; H1 = 1 ; loop to apply the forumula Hn = H1 + H2 + H3 ... + Hn - 1 + Hn - 1 + 1 \/ n ; Driver Code","code":"< ? php function nthHarmonic ( $ N ) { $ harmonic = 1.00 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ harmonic += ( float ) 1 \/ $ i ; } return $ harmonic ; } $ N = 8 ; echo nthHarmonic ( $ N ) ; ? >"}
{"text":"Program to find Nth term of series 0 , 7 , 18 , 33 , 51 , 75 , 102 , 133 , ... . . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + $ n - 3 ; } $ N = 4 ; echo nthTerm ( $ N ) + \" STRNEWLINE \" ; ? >"}
{"text":"Program to find Nth term of series 0 , 10 , 30 , 60 , 99 , 150 , 210 , 280. ... ... ... . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 5 * pow ( $ n , 2 ) - 5 * $ n ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Program to find Nth term of series 2 , 12 , 28 , 50 , 77 , 112 , 152 , 198 , ... . . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + $ n - 2 ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Program to find Nth term of series 4 , 14 , 28 , 46 , 68 , 94 , 124 , 158 , ... . . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 4 * $ n - 2 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program to find Nth term of series 0 , 11 , 28 , 51 , 79 , 115 , 156 , 203 , ... . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + 2 * $ n - 5 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ;"}
{"text":"Program to find Nth term of series 0 , 9 , 22 , 39 , 60 , 85 , 114 , 147 , ... . . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 3 * $ n - 5 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program to find Nth term of series 3 , 12 , 29 , 54 , 86 , 128 , 177 , 234 , ... . . | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 3 * $ n + 2 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find other two sides and angles of a right angle triangle | PHP program to print all sides and angles of right angle triangle given one side ; Function to find angle A Angle in front of side a ; applied cosine rule ; convert into degrees ; Function to find angle B Angle in front of side b ; applied cosine rule ; convert into degrees and return ; Function to print all angles of the right angled triangle ; for calculate angle A ; for calculate angle B ; Function to find other two sides of the right angled triangle ; if n is odd ; case of n = 1 handled separately ; case of n = 2 handled separately ; Print angles of the triangle ; Driver Code","code":"< ? php $ PI = 3.1415926535 ; function findAnglesA ( $ a , $ b , $ c ) { global $ PI ; $ A = acos ( ( $ b * $ b + $ c * $ c - $ a * $ a ) \/ ( 2 * $ b * $ c ) ) ; return $ A * 180 \/ $ PI ; } function findAnglesB ( $ a , $ b , $ c ) { global $ PI ; $ B = acos ( ( $ a * $ a + $ c * $ c - $ b * $ b ) \/ ( 2 * $ a * $ c ) ) ; return $ B * 180 \/ $ PI ; } function printAngles ( $ a , $ b , $ c ) { $ x = ( double ) $ a ; $ y = ( double ) $ b ; $ z = ( double ) $ c ; $ A = findAnglesA ( $ x , $ y , $ z ) ; $ B = findAnglesB ( $ x , $ y , $ z ) ; echo \" Angles \u2581 are \u2581 A \u2581 = \u2581 \" . $ A . \" , B = \" \u2581 . \u2581 $ B \u2581 . \u2581 \" , C = 90 \" ; } function printOtherSides ( $ n ) { if ( $ n & 1 ) { if ( $ n == 1 ) echo \" - 1 STRNEWLINE \" ; else { $ b = ( $ n * $ n - 1 ) \/ 2 ; $ c = ( $ n * $ n + 1 ) \/ 2 ; echo \" Side \u2581 b \u2581 = \u2581 \" . $ b . \" , \u2581 Side \u2581 c \u2581 = \u2581 \" . $ c . \" STRNEWLINE \" ; } } else { if ( $ n == 2 ) echo \" - 1 STRNEWLINE \" ; else { $ b = $ n * $ n \/ 4 - 1 ; $ c = $ n * $ n \/ 4 + 1 ; echo \" Side \u2581 b \u2581 = \u2581 \" . $ b . \" , \u2581 Side \u2581 c \u2581 = \u2581 \" . $ c . \" STRNEWLINE \" ; } } printAngles ( $ n , $ b , $ c ) ; } $ a = 12 ; printOtherSides ( $ a ) ; ? >"}
{"text":"Sum of the first N terms of the series 2 , 6 , 12 , 20 , 30. ... | Function to calculate the sum ; number of terms to be included in the sum ; find the Sn","code":"< ? php function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) \/ 2 + $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) \/ 6 ; } $ n = 3 ; echo \" Sum = \" ? >"}
{"text":"Program to find the Nth term of the series 0 , 5 , 14 , 27 , 44 , ... ... . . | Calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) - $ n - 1 ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Program to find the Nth term of the series 0 , 5 , 18 , 39 , 67 , 105 , 150 , 203 , ... | calculate Nth term of series ; Driver code","code":"< ? php function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 7 * $ n + 3 ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Check whether a given Number is Power | PHP program to find whether a number is power - isolated or not ; for 2 as prime factor ; for odd prime factor ; calculate product of powers and prime factors ; check result for power - isolation ; driver code","code":"< ? php function checkIfPowerIsolated ( $ num ) { $ input = $ num ; $ count = 0 ; $ factor = array ( ) ; if ( $ num % 2 == 0 ) { while ( $ num % 2 == 0 ) { ++ $ count ; $ num \/= 2 ; } $ factor [ 2 ] = $ count ; } for ( $ i = 3 ; $ i * $ i <= $ num ; $ i += 2 ) { $ count = 0 ; while ( $ num % $ i == 0 ) { ++ $ count ; $ num \/= $ i ; } if ( $ count ) $ factor [ $ i ] = $ count ; } if ( $ num > 1 ) $ factor [ $ num ] = 1 ; $ product = 1 ; foreach ( $ factor as $ primefactor = > $ power ) { $ product = $ product * $ primefactor * $ power ; } if ( $ product == $ input ) print_r ( \" Power - isolated \u2581 Integer STRNEWLINE \" ) ; else print_r ( \" Not \u2581 a \u2581 Power - isolated \u2581 Integer STRNEWLINE \" ) ; } checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; ? >"}
{"text":"Program to find the Nth term of the series 3 , 7 , 13 , 21 , 31. ... . | Function to calculate sum ; Return Nth term ; declaration of number of terms ; Get the Nth term","code":"< ? php function getNthTerm ( $ N ) { return ( pow ( $ N , 2 ) + $ N + 1 ) ; } $ N = 11 ; echo getNthTerm ( $ N ) ; ? >"}
{"text":"Sum of the numbers upto N that are divisible by 2 or 5 | Function to find the sum ; sum2 is sum of numbers divisible by 2 ; sum5 is sum of number divisible by 5 ; sum10 of numbers divisible by 2 and 5 ; Driver Code","code":"< ? php function findSum ( $ n ) { $ sum2 = ( ( int ) ( $ n \/ 2 ) * ( 4 + ( ( int ) ( $ n \/ 2 ) - 1 ) * 2 ) ) \/ 2 ; $ sum5 = ( ( int ) ( $ n \/ 5 ) * ( 10 + ( $ n \/ 5 - 1 ) * 5 ) ) \/ 2 ; $ sum10 = ( ( int ) ( $ n \/ 10 ) * ( 20 + ( $ n \/ 10 - 1 ) * 10 ) ) \/ 2 ; return $ sum2 + $ sum5 - $ sum10 ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text":"Ratio of mth and nth terms of an A . P . with given ratio of sums | function to calculate ratio of mth and nth term ; ratio will be tm \/ tn = ( 2 * m - 1 ) \/ ( 2 * n - 1 ) ; Driver code","code":"< ? php function CalculateRatio ( $ m , $ n ) { return ( 2 * $ m - 1 ) \/ ( 2 * $ n - 1 ) ; } $ m = 6 ; $ n = 2 ; echo CalculateRatio ( $ m , $ n ) ; ? >"}
{"text":"Find the sum of n terms of the series 1 , 8 , 27 , 64 ... . | Function to calculate the sum ; Return total sum ; Driver code","code":"< ? php function calculateSum ( $ n ) { return pow ( $ n * ( $ n + 1 ) \/ 2 , 2 ) ; } $ n = 4 ; echo calculateSum ( $ n ) ; ? >"}
{"text":"Sum of Digits in a ^ n till a single digit | This function finds single digit sum of n . ; Returns single digit sum of a ^ n . We use modular exponentiation technique . ; Driver code","code":"< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } function powerDigitSum ( $ a , $ n ) { $ res = 1 ; while ( $ n ) { if ( $ n % 2 == 1 ) { $ res = $ res * digSum ( $ a ) ; $ res = digSum ( $ res ) ; } $ a = digSum ( digSum ( $ a ) * digSum ( $ a ) ) ; $ n \/= 2 ; } return $ res ; } $ a = 9 ; $ n = 4 ; echo powerDigitSum ( $ a , $ n ) ; ? >"}
{"text":"Program to find total number of edges in a Complete Graph | Function to find the total number of edges in a complete graph with N vertices ; Driver Code","code":"< ? php function totEdge ( $ n ) { $ result = 0 ; $ result = ( $ n * ( $ n - 1 ) ) \/ 2 ; return $ result ; } $ n = 6 ; echo totEdge ( $ n ) ; ? >"}
{"text":"Program to find the count of coins of each type from the given ratio | function to calculate coin ; Converting each of them in rupees . As we are given totalRupees = 1800 ; Driver Code","code":"< ? php function coin ( $ totalRupees , $ X , $ Y , $ Z ) { $ one = 0 ; $ fifty = 0 ; $ twentyfive = 0 ; $ result = 0 ; $ total = 0 ; $ one = $ X * 1 ; $ fifty = ( ( $ Y * 1 ) \/ 2.0 ) ; $ twentyfive = ( ( $ Z * 1 ) \/ 4.0 ) ; $ total = $ one + $ fifty + $ twentyfive ; $ result = ( ( $ totalRupees ) \/ $ total ) ; return $ result ; } $ totalRupees = 1800 ; $ X = 1 ; $ Y = 2 ; $ Z = 4 ; $ Rupees = coin ( $ totalRupees , $ X , $ Y , $ Z ) ; echo \"1 \u2581 rupess \u2581 coins \u2581 = \u2581 \" , $ Rupees * 1 , \" STRNEWLINE \" ; echo \"50 \u2581 paisa \u2581 coins \u2581 = \u2581 \" , $ Rupees * 2 , \" STRNEWLINE \" ; echo \"25 \u2581 paisa \u2581 coins \u2581 = \u2581 \" , $ Rupees * 4 , \" STRNEWLINE \" ; ? >"}
{"text":"Find the sum of series 0. X + 0. XX + 0. XXX + ... upto k terms | function which return the sum of series ; Driver code","code":"< ? php function sumOfSeries ( $ x , $ k ) { return ( ( $ x ) \/ 81 ) * ( 9 * $ k - 1 + pow ( 10 , ( -1 ) * $ k ) ) ; } $ x = 9 ; $ k = 20 ; echo sumOfSeries ( $ x , $ k ) ; ? >"}
{"text":"Maximize the product of four factors of a Number | For calculation of a ^ b ; Function to check ; every odd and number less than 3. ; every number divisible by 4. ; every number divisible by 6. ; every number divisible by 10. ; for every even number which is not divisible by above values . ; Driver code","code":"< ? php function modExp ( $ a , $ b ) { $ result = 1 ; while ( $ b > 0 ) { if ( $ b & 1 ) $ result = $ result * $ a ; $ a = $ a * $ a ; $ b \/= 2 ; } return $ result ; } function check ( $ num ) { if ( $ num & 1 $ num < 3 ) return -1 ; else if ( $ num % 4 == 0 ) return modExp ( $ num \/ 4 , 4 ) ; else if ( $ num % 6 == 0 ) return modExp ( $ num \/ 3 , 2 ) * modExp ( $ num \/ 6 , 2 ) ; else if ( $ num % 10 == 0 ) return modExp ( $ num \/ 5 , 2 ) * ( $ num \/ 10 ) * ( $ num \/ 2 ) ; else return -1 ; } $ num = 10 ; echo check ( $ num ) ; ? >"}
{"text":"Check if any large number is divisible by 17 or not | Function to check if the number is divisible by 17 or not ; Extracting the last digit ; Truncating the number ; Subtracting the five times the last digit from the remaining number ; Return n is divisible by 17 ; Driver code","code":"< ? php function isDivisible ( $ n ) { while ( $ n \/ 100 != 0 ) { $ d = ( int ) $ n % 10 ; $ n \/= 10 ; $ n -= $ d * 5 ; } return ( $ n % 17 == 0 ) ; } $ n = 19877658 ; if ( isDivisible ( $ n ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text":"Minimum number of elements to be removed to make XOR maximum | PHP implementation to find minimum number of elements to remove to get maximum XOR value ; First n in the below condition is for the case where n is 0 ; Function to find minimum number of elements to be removed . ; Driver code ; print minimum number of elements to be removed","code":"< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } function removeElement ( $ n ) { if ( $ n == 1 $ n == 2 ) return 0 ; $ a = nextPowerOf2 ( $ n ) ; if ( $ n == $ a $ n == $ a - 1 ) return 1 ; else if ( $ n == $ a - 2 ) return 0 ; else if ( $ n % 2 == 0 ) return 1 ; else return 2 ; } $ n = 5 ; echo removeElement ( $ n ) ; ? >"}
{"text":"Program to find Length of Bridge using Speed and Length of Train | function to calculate the length of bridge ; Assuming the input variables","code":"< ? php function bridge_length ( $ trainLength , $ Speed , $ Time ) { return ( ( $ Time * $ Speed ) - $ trainLength ) ; } $ trainLength = 120 ; $ Speed = 30 ; $ Time = 18 ; echo \" Length \u2581 of \u2581 bridge \u2581 = \u2581 \" . bridge_length ( $ trainLength , $ Speed , $ Time ) . \" \u2581 meters \" ; ? >"}
{"text":"Program to find sum of the given sequence | function to find moudulo inverse under 10 ^ 9 + 7 ; Function to find the sum of the given sequence ; Driver code","code":"< ? php function modInv ( $ x ) { $ MOD = 1000000007 ; $ n = $ MOD - 2 ; $ result = 1 ; while ( $ n ) { if ( $ n & 1 ) $ result = $ result * $ x % $ MOD ; $ x = $ x * $ x % $ MOD ; $ n = $ n \/ 2 ; } return $ result ; } function getSum ( $ n , $ k ) { $ MOD = 1000000007 ; $ ans = 1 ; for ( $ i = $ n + 1 ; $ i > $ n - $ k ; $ i -- ) $ ans = $ ans * $ i % $ MOD ; $ ans = $ ans * modInv ( $ k + 1 ) % $ MOD ; return $ ans ; } $ n = 3 ; $ k = 2 ; echo getSum ( $ n , $ k ) ; ? >"}
{"text":"Triplet with no element divisible by 3 and sum N | Function to print a , b and c ; check if n - 2 is divisible by 3 or not ; Driver code","code":"< ? php function printCombination ( $ n ) { echo \"1 \u2581 \" ; if ( ( $ n - 2 ) % 3 == 0 ) echo \"2 \u2581 \" . ( $ n - 3 ) ; else echo \"1 \u2581 \" . ( $ n - 2 ) ; } $ n = 233 ; printCombination ( $ n ) ; ? >"}
{"text":"Pairs with GCD equal to one in the given range | Function to print all pairs ; check if even ; We can print all adjacent pairs for ( int i = l ; i < r ; i += 2 ) { cout << \" { \" << i << \" , \u2581 \" << i + 1 << \" } , \u2581 \" ; } ; Driver Code","code":"< ? php function checkPairs ( $ l , $ r ) { if ( ( $ l - $ r ) % 2 == 0 ) return false ; return true ; } $ l = 1 ; $ r = 8 ; if ( checkPairs ( $ l , $ r ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Check if a number with even number of digits is palindrome or not | Function to check if the number is palindrome ; if divisible by 11 then true ; if not divisible by 11 ; Driver code","code":"< ? php function isPalindrome ( $ n ) { if ( $ n % 11 == 0 ) { return true ; } return false ; } echo isPalindrome ( 123321 ) ? \" Palindrome \" : \" Not \u2581 Palindrome \" ; ? >"}
{"text":"Count number of triplets with product equal to given number with duplicates allowed | The target value for which we have to find the solution ; This variable contains the total count of triplets found ; Loop from the first to the third last integer in the list ; Check if arr [ i ] is a factor of target or not . If not , skip to the next element ; Check if the pair ( arr [ i ] , arr [ j ] ) can be a part of triplet whose product is equal to the target ; Find the remaining element of the triplet ; If element is found . increment the total count of the triplets","code":"< ? php $ target = 93 ; $ arr = array ( 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ) ; $ length = sizeof ( $ arr ) ; $ totalCount = 0 ; for ( $ i = 0 ; $ i < $ length - 2 ; $ i ++ ) { if ( $ target % $ arr [ $ i ] == 0 ) { for ( $ j = $ i + 1 ; $ j < $ length - 1 ; $ j ++ ) { if ( $ target % ( $ arr [ $ i ] * $ arr [ $ j ] ) == 0 ) { $ toFind = $ target \/ ( $ arr [ $ i ] * $ arr [ $ j ] ) ; for ( $ k = $ j + 1 ; $ k < $ length ; $ k ++ ) { if ( $ arr [ $ k ] == $ toFind ) { $ totalCount ++ ; } } } } } } echo ( \" Total \u2581 number \u2581 of \u2581 triplets \u2581 found \u2581 : \u2581 \" ) ; echo ( $ totalCount ) ; ? >"}
{"text":"Number of Permutations such that no Three Terms forms Increasing Subsequence | Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn \/ ( n + 1 ) ; Driver code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ res = $ res * ( $ n - $ i ) ; $ res = $ res \/ ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return $ c \/ ( $ n + 1 ) ; } $ n = 3 ; print ( catalan ( $ n ) ) ; ? >"}
{"text":"Fascinating Number | function to check if number is fascinating or not ; frequency count array using 1 indexing ; obtaining the resultant number using string concatenation ; Traversing the string character by character ; gives integer value of a character digit ; To check if any digit has appeared multiple times ; Traversing through freq array to check if any digit was missing ; Input number ; Not a valid number ; Calling the function to check if input number is fascinating or not","code":"< ? php function isFascinating ( $ num ) { $ freq = array_fill ( 0 , 10 , NULL ) ; $ val = \" \" . $ num . ( $ num * 2 ) . ( $ num * 3 ) ; for ( $ i = 0 ; $ i < strlen ( $ val ) ; $ i ++ ) { $ digit = $ val [ $ i ] - '0' ; if ( $ freq [ $ digit ] > 0 && $ digit != 0 ) return false ; else $ freq [ $ digit ] ++ ; } for ( $ i = 1 ; $ i < 10 ; $ i ++ ) { if ( $ freq [ $ i ] == 0 ) return false ; } return true ; } $ num = 192 ; if ( $ num < 100 ) echo \" No \" ; else { $ ans = isFascinating ( $ num ) ; if ( $ ans ) echo \" Yes \" ; else echo \" No \" ; } ? >"}
{"text":"Count ways to distribute m items among n people | function used to generate binomial coefficient time complexity O ( m ) ; Helper function for generating no of ways to distribute m . mangoes amongst n people ; not enough mangoes to be distributed ; ways -> ( n + m - 1 ) C ( n - 1 ) ; m represents number of mangoes n represents number of people","code":"< ? php function binomial_coefficient ( $ n , $ m ) { $ res = 1 ; if ( $ m > $ n - $ m ) $ m = $ n - $ m ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res ; } function calculate_ways ( $ m , $ n ) { if ( $ m < $ n ) return 0 ; $ ways = binomial_coefficient ( $ n + $ m - 1 , $ n - 1 ) ; return $ ways ; } $ m = 7 ; $ n = 5 ; $ result = calculate_ways ( $ m , $ n ) ; echo $ result ; ? >"}
{"text":"Queries to count the number of unordered co | PHP program to find number of unordered coprime pairs of integers from 1 to N ; to store euler 's totient function ; to store required answer ; Computes and prints totient of all numbers smaller than or equal to N . ; Initialise the phi [ ] with 1 ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 \/ p ) ; function to compute number coprime pairs ; function call to compute euler totient function ; prefix sum of all euler totient function values ; function call","code":"< ? php $ N = 100005 ; $ phi = array_fill ( 0 , $ N , 0 ) ; $ S = array_fill ( 0 , $ N , 0 ) ; function computeTotient ( ) { global $ N , $ phi , $ S ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ phi [ $ i ] = $ i ; for ( $ p = 2 ; $ p < $ N ; $ p ++ ) { if ( $ phi [ $ p ] == $ p ) { $ phi [ $ p ] = $ p - 1 ; for ( $ i = 2 * $ p ; $ i < $ N ; $ i += $ p ) { $ phi [ $ i ] = ( int ) ( ( $ phi [ $ i ] \/ $ p ) * ( $ p - 1 ) ) ; } } } } function CoPrimes ( ) { global $ N , $ phi , $ S ; computeTotient ( ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ S [ $ i ] = $ S [ $ i - 1 ] + $ phi [ $ i ] ; } CoPrimes ( ) ; $ q = array ( 3 , 4 ) ; $ n = sizeof ( $ q ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo \" Number \u2581 of \u2581 unordered \u2581 coprime STRNEWLINE \" . \" pairs \u2581 of \u2581 integers \u2581 from \u2581 1 \u2581 to \u2581 \" . $ q [ $ i ] . \" \u2581 are \u2581 \" . $ S [ $ q [ $ i ] ] . \" STRNEWLINE \" ; ? >"}
{"text":"N | Function to return the decimal value of a binary number ; Initializing base value to 1 , i . e 2 ^ 0 ; find the binary representation of the N - th number in sequence ; base case ; answer string ; add n - 1 1 's ; add 0 ; add n 1 's at end ; Driver Code","code":"< ? php function binaryToDecimal ( $ n ) { $ num = $ n ; $ dec_value = 0 ; $ base = 1 ; $ len = strlen ( $ num ) ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( $ num [ $ i ] == '1' ) $ dec_value += $ base ; $ base = $ base * 2 ; } return $ dec_value ; } function numberSequence ( $ n ) { if ( $ n == 1 ) return 1 ; $ s = \" \" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ s . = '1' ; $ s . = '0' ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s . = '1' ; $ num = binaryToDecimal ( $ s ) ; return $ num ; } $ n = 4 ; echo numberSequence ( $ n ) ; ? >"}
{"text":"N | Function to find the N - th term ; calculates the N - th term ; Driver Code","code":"< ? php function numberSequence ( $ n ) { $ num = pow ( 4 , $ n ) - pow ( 2 , $ n ) - 1 ; return $ num ; } $ n = 4 ; echo numberSequence ( $ n ) ; ? >"}
{"text":"Alternate Primes till N | Function for checking number is prime or not ; if flag = 0 then number is prime and return 1 otherwise return 0 ; Function for printing alternate prime number ; counter is initialize with 0 ; looping through 2 to n - 1 ; function calling along with if condition ; if counter is multiple of 2 then only print prime number ; Driver code ; Function calling","code":"< ? php function prime ( $ num ) { $ flag = 0 ; for ( $ i = 2 ; $ i <= $ num \/ 2 ; $ i ++ ) { if ( $ num % $ i == 0 ) { $ flag = 1 ; break ; } } if ( $ flag == 0 ) return 1 ; else return 0 ; } function print_alternate_prime ( $ n ) { $ counter = 0 ; for ( $ num = 2 ; $ num < $ n ; $ num ++ ) { if ( prime ( $ num ) == 1 ) { if ( $ counter % 2 == 0 ) echo $ num . \" \" ; $ counter += 1 ; } } } $ n = 15 ; echo \" Following \u2581 are \u2581 the \u2581 alternate \u2581 prime \u2581 \" . \" number \u2581 smaller \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 \" . $ n . \" STRNEWLINE \" ; print_alternate_prime ( $ n ) ; ? >"}
{"text":"Alternate Primes till N | PHP program to print all primes smaller than or equal to n using Sieve of Eratosthenes ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers ; for next prime to get printed ; Driver Code","code":"< ? php function SieveOfEratosthenes ( $ n ) { $ prime = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ flag = true ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { if ( $ flag ) { echo $ p . \" \" ; $ flag = false ; } else { $ flag = true ; } } } } $ n = 15 ; echo \" Following \u2581 are \u2581 the \u2581 alternate \" . \" \u2581 prime \u2581 numbers \u2581 smaller \u2581 \" . \" than \u2581 or \u2581 equal \u2581 to \u2581 \" . $ n . \" STRNEWLINE \" ; SieveOfEratosthenes ( $ n ) ; ? >"}
{"text":"Find maximum among x ^ ( y ^ 2 ) or y ^ ( x ^ 2 ) where x and y are given | Function to find maximum ; Case 1 ; Case 2 ; Driver Code","code":"< ? php function findGreater ( $ x , $ y ) { if ( $ x > $ y ) { return false ; } else { return true ; } } $ x = 4 ; $ y = 9 ; if ( findGreater ( $ x , $ y ) == true ) echo ( \"1 STRNEWLINE \" ) ; else echo ( \"2 STRNEWLINE \" ) ; ? >"}
{"text":"Maximum profit after buying and selling stocks with transaction fees | PHP implementation of above approach ; b [ 0 ] will contain the maximum profit ; b [ 1 ] will contain the day on which we are getting the maximum profit ; here finding the max profit ; if we get less then or equal to zero it means we are not getting the profit ; check if sum is greater then maximum then store the new maximum ; Driver code","code":"< ? php function max_profit ( & $ a , & $ b , $ n , $ fee ) { $ diff_day = 1 ; $ sum = 0 ; $ b [ 0 ] = 0 ; $ b [ 1 ] = $ diff_day ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ l = 0 ; $ r = $ diff_day ; $ sum = 0 ; for ( $ j = $ n - 1 ; $ j >= $ i ; $ j -- ) { $ profit = ( $ a [ $ r ] - $ a [ $ l ] ) - $ fee ; if ( $ profit > 0 ) { $ sum = $ sum + $ profit ; } $ l ++ ; $ r ++ ; } if ( $ b [ 0 ] < $ sum ) { $ b [ 0 ] = $ sum ; $ b [ 1 ] = $ diff_day ; } $ diff_day ++ ; } } $ arr = array ( 6 , 1 , 7 , 2 , 8 , 4 ) ; $ n = sizeof ( $ arr ) ; $ b = array ( ) ; $ tranFee = 2 ; max_profit ( $ arr , $ b , $ n , $ tranFee ) ; echo ( $ b [ 0 ] ) ; echo ( \" , \u2581 \" ) ; echo ( $ b [ 1 ] ) ; ? >"}
{"text":"Eggs dropping puzzle ( Binomial Coefficient and Binary Search Solution ) | Find sum of binomial coefficients xCi ( where i varies from 1 to n ) . If the sum becomes more than K ; Do binary search to find minimum number of trials in worst case . ; Initialize low and high as 1 st and last floors ; Do binary search , for every mid , find sum of binomial coefficients and check if the sum is greater than k or not . ; Driver Code","code":"< ? php function binomialCoeff ( $ x , $ n , $ k ) { $ sum = 0 ; $ term = 1 ; for ( $ i = 1 ; $ i <= $ n && $ sum < $ k ; ++ $ i ) { $ term *= $ x - $ i + 1 ; $ term \/= $ i ; $ sum += $ term ; } return $ sum ; } function minTrials ( $ n , $ k ) { $ low = 1 ; $ high = $ k ; while ( $ low < $ high ) { $ mid = ( $ low + $ high ) \/ 2 ; if ( binomialCoeff ( $ mid , $ n , $ k ) < $ k ) $ low = $ mid + 1 ; else $ high = $ mid ; } return ( int ) $ low ; } echo minTrials ( 2 , 10 ) ; ? >"}
{"text":"Find next palindrome prime | PHP program to find next palindromic prime for a given number . ; if ( 8 <= N <= 11 ) return 11 ; generate odd length palindrome number which will cover given constraint . ; if y >= N and it is a prime number then return it . ; Driver code","code":"< ? php function isPrime ( $ num ) { if ( $ num < 2 $ num % 2 == 0 ) return $ num == 2 ; for ( $ i = 3 ; $ i * $ i <= $ num ; $ i += 2 ) if ( $ num % $ i == 0 ) return false ; return true ; } function primePalindrome ( $ N ) { if ( 8 <= $ N && $ N <= 11 ) return 11 ; for ( $ x = 1 ; $ x < 100000 ; ++ $ x ) { $ s = strval ( $ x ) ; $ r = strrev ( $ s ) ; $ y = intval ( $ s . substr ( $ r , 1 ) ) ; if ( $ y >= $ N && isPrime ( $ y ) == true ) return $ y ; } return -1 ; } print ( primePalindrome ( 112 ) ) ; ? >"}
{"text":"Number of integral solutions for equation x = b * ( sumofdigits ( x ) ^ a ) + c | This function returns the sum of the digits of a number ; This function creates the array of valid numbers ; this computes s ( x ) ^ a ; this gives the result of equation ; checking if the sum same as i ; counter to keep track of numbers ; resultant array ; prints the number ; Driver Code ; calculate which value of x are possible","code":"< ? php function getsum ( $ a ) { $ r = 0 ; $ sum = 0 ; while ( $ a > 0 ) { $ r = $ a % 10 ; $ sum = $ sum + $ r ; $ a = ( int ) ( $ a \/ 10 ) ; } return $ sum ; } function value ( $ a , $ b , $ c ) { $ co = 0 ; $ p = 0 ; $ no ; $ r = 0 ; $ x = 0 ; $ q = 0 ; $ w = 0 ; $ v = array ( ) ; $ u = 0 ; for ( $ i = 1 ; $ i < 82 ; $ i ++ ) { $ no = pow ( $ i , $ a ) ; $ no = $ b * $ no + $ c ; if ( $ no > 0 && $ no < 1000000000 ) { $ x = getsum ( $ no ) ; if ( $ x == $ i ) { $ q ++ ; $ v [ $ u ++ ] = $ no ; $ w ++ ; } } } for ( $ i = 0 ; $ i < $ u ; $ i ++ ) { echo $ v [ $ i ] . \" \" ; } } $ a = 2 ; $ b = 2 ; $ c = -1 ; value ( $ a , $ b , $ c ) ; ? >"}
{"text":"Cunningham chain | Function to print Cunningham chain of the second kind ; Iterate till all elements are printed ; check prime or not ; Driver Code","code":"< ? php function print_t ( $ p0 ) { $ p1 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 - ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . \" \" ; $ i ++ ; } } $ p0 = 19 ; print_t ( $ p0 ) ;"}
{"text":"Count pairs with Bitwise AND as ODD number | PHP program to count pairs with Odd AND ; Count total odd numbers ; return count of even pair ; Driver Code ; calling function findOddPair and print number of odd pair","code":"< ? php function findOddPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ( $ A [ $ i ] % 2 == 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) \/ 2 ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo ( findOddPair ( $ a , $ n ) ) ; ? >"}
{"text":"Surd number | Returns true if x is Surd number ; Try all powers of i ; Driver code","code":"< ? php function isSurd ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i ; while ( $ j < $ n ) $ j = $ j * $ i ; if ( $ j == $ n ) return false ; } return true ; } $ n = 15 ; if ( isSurd ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Program to find last two digits of 2 ^ n | Find the first digit ; Get the last digit from the number ; Remove last digit from number ; Get the last digit from the number ( last second of num ) ; Take last digit to ten 's position i.e.  last second digit ; Add the value of ones and tens to make it complete 2 digit number ; return the first digit ; Driver Code ; pow function used","code":"< ? php function LastTwoDigit ( $ num ) { $ one = $ num % 10 ; $ num \/= 10 ; $ tens = $ num % 10 ; $ tens *= 10 ; $ num = $ tens + $ one ; return $ num ; } $ n = 10 ; $ num = 1 ; $ num = pow ( 2 , $ n ) ; echo ( \" Last \u2581 \" . 2 ) ; echo ( \" \u2581 digits \u2581 of \u2581 \" . 2 ) ; echo ( \" ^ \" . $ n . \" \u2581 = \u2581 \" ) ; echo ( LastTwoDigit ( $ num ) ) ; ? >"}
{"text":"Program to find last two digits of 2 ^ n | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; PHP function to calculate number of digits in x ; PHP function to print last 2 digits of 2 ^ n ; Generating 10 ^ 2 ; Calling modular exponentiation ; Printing leftmost zeros . Since ( 2 ^ n ) % 2 can have digits less then 2. In that case we need to print zeros ; If temp is not zero then print temp . If temp is zero then already printed ; Driver Code","code":"< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function numberOfDigits ( $ x ) { $ i = 0 ; while ( $ x ) { $ x \/= 10 ; $ i ++ ; } return $ i ; } function LastTwoDigit ( $ n ) { echo ( \" Last \u2581 \" . 2 ) ; echo ( \" \u2581 digits \u2581 of \u2581 \" . 2 ) ; echo ( \" ^ \" . $ n . \" \u2581 = \u2581 \" ) ; $ temp = 1 ; for ( $ i = 1 ; $ i <= 2 ; $ i ++ ) $ temp *= 10 ; $ temp = power ( 2 , $ n , $ temp ) ; for ( $ i = 0 ; $ i < 2 - numberOfDigits ( $ temp ) ; $ i ++ ) echo ( 0 ) ; if ( $ temp ) echo ( $ temp ) ; } $ n = 72 ; LastTwoDigit ( $ n ) ; ? >"}
{"text":"Find gcd ( a ^ n , c ) where a , n and c can vary from 1 to 10 ^ 9 | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Finds GCD of a and b ; Finds GCD of a ^ n and c ; check if c is a divisor of a ; First compute ( a ^ n ) % c ; Now simply return GCD of modulo power and c . ; Driver code","code":"< ? php function modPower ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } function gcdPow ( $ a , $ n , $ c ) { if ( $ a % $ c == 0 ) return $ c ; $ modexpo = modPower ( $ a , $ n , $ c ) ; return gcd ( $ modexpo , $ c ) ; } $ a = 10248585 ; $ n = 1000000 ; $ c = 12564 ; echo gcdPow ( $ a , $ n , $ c ) ; ? >"}
{"text":"Number of sub arrays with odd sum | PHP code to find count of sub - arrays with odd sum ; Find sum of all subarrays and increment result if sum is odd ; Driver code","code":"< ? php function countOddSum ( & $ ar , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ val = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ val = $ val + $ ar [ $ j ] ; if ( $ val % 2 != 0 ) $ result ++ ; } } return ( $ result ) ; } $ ar = array ( 5 , 4 , 4 , 5 , 1 , 3 ) ; $ n = sizeof ( $ ar ) ; echo \" The \u2581 Number \u2581 of \u2581 Subarrays \u2581 with \u2581 odd \u2581 \" ; echo \" sum \u2581 is \u2581 \" . countOddSum ( $ ar , $ n ) ; ? >"}
{"text":"Number of sub arrays with odd sum | PHP proggram to find count of sub - arrays with odd sum ; A temporary array of size 2. temp [ 0 ] is going to store count of even subarrays and temp [ 1 ] count of odd . temp [ 0 ] is initialized as 1 because there is a single odd element is also counted as a subarray ; Initialize count . sum is sum of elements under modulo 2 and ending with arr [ i ] . ; i ' th \u2581 iteration \u2581 computes \u2581 sum \u2581 \u2581 of \u2581 arr [ 0 . . i ] \u2581 under \u2581 modulo \u2581 2 \u2581 \u2581 and \u2581 increments \u2581 even \/ odd \u2581 count \u2581 \u2581 according \u2581 to \u2581 sum ' s value ; 2 is added to handle negative numbers ; Increment even \/ odd count ; An odd can be formed by even - odd pair ; Driver code","code":"< ? php function countOddSum ( $ ar , $ n ) { $ temp = array ( 1 , 0 ) ; $ result = 0 ; $ val = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ val = ( ( $ val + $ ar [ $ i ] ) % 2 + 2 ) % 2 ; $ temp [ $ val ] ++ ; } $ result = ( $ temp [ 0 ] * $ temp [ 1 ] ) ; return ( $ result ) ; } $ ar = array ( 5 , 4 , 4 , 5 , 1 , 3 ) ; $ n = sizeof ( $ ar ) ; echo \" The \u2581 Number \u2581 of \u2581 Subarrays \u2581 with \u2581 odd \" . \" \u2581 sum \u2581 is \u2581 \" . countOddSum ( $ ar , $ n ) ; ? >"}
{"text":"Program to print factors of a number in pairs | PHP program to print prime factors in pairs . ; Driver code","code":"< ? php function printPFsInPairs ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i . \" * \" . \u2581 $ n \u2581 \/ \u2581 $ i \u2581 . \" \" } $ n = 24 ; printPFsInPairs ( $ n ) ; return 0 ; ? >"}
{"text":"Sum of elements in range L | Function to find the sum between L and R ; array created ; fill the first half of array ; fill the second half of array ; find the sum between range ; Driver Code","code":"< ? php function rangesum ( $ n , $ l , $ r ) { $ arr = array_fill ( 0 , $ n , 0 ) ; $ c = 1 ; $ i = 0 ; while ( $ c <= $ n ) { $ arr [ $ i ++ ] = $ c ; $ c += 2 ; } $ c = 2 ; while ( $ c <= $ n ) { $ arr [ $ i ++ ] = $ c ; $ c += 2 ; } $ sum = 0 ; for ( $ i = $ l - 1 ; $ i < $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; } return $ sum ; } $ n = 12 ; $ l = 1 ; $ r = 11 ; echo ( rangesum ( $ n , $ l , $ r ) ) ; ? >"}
{"text":"Program to find the Interior and Exterior Angle of a Regular Polygon | function to find the interior and exterior angle ; formula to find the interior angle ; formula to find the exterior angle ; Displaying the output ; Driver code ; Function calling","code":"< ? php function findAngle ( $ n ) { $ interiorAngle ; $ exteriorAngle ; $ interiorAngle = ( $ n - 2 ) * 180 \/ $ n ; $ exteriorAngle = 360 \/ $ n ; echo \" Interior \u2581 angle : \u2581 \" , $ interiorAngle , \" STRNEWLINE \" ; echo \" Exterior \u2581 angle : \u2581 \" , $ exteriorAngle ; } $ n = 10 ; findAngle ( $ n ) ; ? >"}
{"text":"Program to calculate distance between two points in 3 D | function to print distance ; Driver Code ; function call for distance","code":"< ? php function distance ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ d = sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) + pow ( $ z2 - $ z1 , 2 ) * 1.0 ) ; echo \" Distance \u2581 is \u2581 \" . $ d ; } $ x1 = 2 ; $ y1 = -5 ; $ z1 = 7 ; $ x2 = 3 ; $ y2 = 4 ; $ z2 = 5 ; distance ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) ; ? >"}
{"text":"Check if the large number formed is divisible by 41 or not | Check if a number is divisible by 41 or not ; array to store all the digits ; base values ; calculate remaining digits ; calculate answer ; check for divisibility ; Driver Code","code":"< ? php function DivisibleBy41 ( $ first , $ second , $ c , $ n ) { $ digit [ $ n ] = range ( 1 , $ n ) ; $ digit [ 0 ] = $ first ; $ digit [ 1 ] = $ second ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ digit [ $ i ] = ( $ digit [ $ i - 1 ] * $ c + $ digit [ $ i - 2 ] ) % 10 ; $ ans = $ digit [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans = ( $ ans * 10 + $ digit [ $ i ] ) % 41 ; if ( $ ans % 41 == 0 ) return true ; else return false ; } $ first = 1 ; $ second = 2 ; $ c = 1 ; $ n = 3 ; if ( DivisibleBy41 ( $ first , $ second , $ c , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Program to print pentatope numbers upto Nth term | Function to generate nth tetrahedral number ; Function to print pentatope number series upto nth term . ; Initialize prev as 0. It store the sum of all previously generated pentatope numbers ; Loop to print pentatope series ; Find ith tetrahedral number ; Add ith tetrahedral number to sum of all previously generated tetrahedral number to get ith pentatope number ; Update sum of all previously generated tetrahedral number ; Driver code ; Function call to print pentatope number series","code":"< ? php function findTetrahedralNumber ( $ n ) { return ( ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) \/ 6 ) ; } function printSeries ( $ n ) { $ prev = 0 ; $ curr ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ curr = findTetrahedralNumber ( $ i ) ; $ curr = $ curr + $ prev ; echo ( $ curr . \" \" ) ; $ prev = $ curr ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text":"Program to print pentatope numbers upto Nth term | Function to print pentatope series up to nth term ; Loop to print pentatope number series ; calculate and print ith pentatope number ; Driver code ; Function call to print pentatope number series","code":"< ? php function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = ( $ i * ( $ i + 1 ) * ( $ i + 2 ) * ( $ i + 3 ) \/ 24 ) ; echo ( $ num . \" \" ) ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text":"Find unique pairs such that each element is less than or equal to N | Finding the number of unique pairs ; Using the derived formula ; Printing the unique pairs ; Driver Code","code":"< ? php function No_Of_Pairs ( $ N ) { $ i = 1 ; while ( ( $ i * $ i * $ i ) + ( 2 * $ i * $ i ) + $ i <= $ N ) $ i ++ ; return ( $ i - 1 ) ; } function print_pairs ( $ pairs ) { $ i = 1 ; $ mul ; for ( $ i = 1 ; $ i <= $ pairs ; $ i ++ ) { $ mul = $ i * ( $ i + 1 ) ; echo \" Pair \u2581 no . \" , $ i , \" \u2581 - - > \u2581 ( \" , ( $ mul * $ i ) , \" , \u2581 \" , $ mul * ( $ i + 1 ) , \" ) \u2581 STRNEWLINE \" ; } } $ N = 500 ; $ pairs ; $ mul ; $ i = 1 ; $ pairs = No_Of_Pairs ( $ N ) ; echo \" No . \u2581 of \u2581 pairs \u2581 = \u2581 \" , $ pairs , \" \u2581 STRNEWLINE \" ; print_pairs ( $ pairs ) ; ? >"}
{"text":"Program to print tetrahedral numbers upto Nth term | function to generate nth triangular number ; function to print tetrahedral number series up to n ; Initialize prev as 0. It store the sum of all previously generated triangular number ; Loop to print series ; Find ithh triangular number ; Add ith triangular number to sum of all previously generated triangular number to get ith tetrahedral number ; Update sum of all previously generated triangular number ; Driver code ; function call to print series","code":"< ? php function findTriangularNumber ( $ n ) { return ( $ n * ( $ n + 1 ) ) \/ 2 ; } function printSeries ( $ n ) { $ prev = 0 ; $ curr ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ curr = findTriangularNumber ( $ i ) ; $ curr = $ curr + $ prev ; echo ( $ curr . \" \" ) ; $ prev = $ curr ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text":"Program to print tetrahedral numbers upto Nth term | function to print tetrahedral number series up to n ; loop to print series ; Calculate and print ith tetrahedral number ; Driver code ; function call to print series","code":"< ? php function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = $ i * ( $ i + 1 ) * ( $ i + 2 ) \/ 6 ; echo ( $ num . \" \" ) ; } } $ n = 10 ; printSeries ( $ n ) ; ? >"}
{"text":"Number of odd and even results for every value of x in range [ min , max ] after performing N steps | Function that prints the number of odd and even results ; If constant at layer i is even , beven is true , otherwise false . If the coefficient of x at layer i is even , aeven is true , otherwise false . ; If any of the coefficients at any layer is found to be even , then the product of all the coefficients will always be even . ; Checking whether the constant added after all layers is even or odd . ; Assuming input x is even . ; Assuming input x is odd . ; Displaying the counts . ; Driver Code","code":"< ? php function count_even_odd ( $ min , $ max , $ steps ) { $ beven = true ; $ aeven = false ; $ n = 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = $ steps [ $ i ] [ 0 ] ; $ b = $ steps [ $ i ] [ 1 ] ; if ( ! ( $ aeven $ a & 1 ) ) $ aeven = true ; if ( $ beven ) { if ( $ b & 1 ) $ beven = false ; } else if ( ! ( $ a & 1 ) ) { if ( ! ( $ b & 1 ) ) $ beven = true ; } else { if ( $ b & 1 ) $ beven = true ; } } if ( $ beven ) { $ even = ( int ) $ max \/ 2 - ( int ) ( $ min - 1 ) \/ 2 ; $ odd = 0 ; } else { $ even = ( int ) $ max \/ 2 - ( int ) ( $ min - 1 ) \/ 2 ; $ odd = 0 ; } if ( ! ( $ beven ^ $ aeven ) ) $ even += $ max - $ min + 1 - ( int ) $ max \/ 2 + ( int ) ( $ min - 1 ) \/ 2 ; else $ odd += $ max - $ min + 1 - ( int ) $ max \/ 2 + ( int ) ( $ min - 1 ) \/ 2 ; echo \" even = \" \u2581 , \u2581 $ even , STRNEWLINE TABSYMBOL TABSYMBOL \" , odd = \" , \u2581 $ odd , \u2581 \" \" } $ min = 1 ; $ max = 4 ; $ steps = array ( array ( 1 , 2 ) , array ( 3 , 4 ) ) ; count_even_odd ( $ min , $ max , $ steps ) ; ? >"}
{"text":"Maximum number of ones in a N * N matrix with given constraints | Function that returns the maximum number of ones ; Minimum number of zeroes ; Totol cells = square of the size of the matrices ; Initialising the answer ; Initialising the variables","code":"< ? php function getMaxOnes ( $ n , $ x ) { $ zeroes = ( int ) ( $ n \/ $ x ) ; $ zeroes = $ zeroes * $ zeroes ; $ total = $ n * $ n ; $ ans = $ total - $ zeroes ; return $ ans ; } $ n = 5 ; $ x = 2 ; echo getMaxOnes ( $ n , $ x ) ; ? >"}
{"text":"Check if a M | PHP program to check if M - th fibonacci divides N - th fibonacci ; exceptional case for F ( 2 ) ; if none of the above cases , hence not divisible ; Driver Code","code":"< ? php function check ( $ n , $ m ) { if ( $ n == 2 $ m == 2 $ n % $ m == 0 ) { echo \" Yes \" , \" STRNEWLINE \" ; } else { echo \" No \" , \" \u2581 STRNEWLINE \" ; } } $ m = 3 ; $ n = 9 ; check ( $ n , $ m ) ; ? >"}
{"text":"Surface Area and Volume of Hexagonal Prism | Function to calculate Surface area ; Formula to calculate surface area ; Display surface area ; Function to calculate Volume ; formula to calculate Volume ; Display Volume ; Driver Code ; surface area function call ; volume function call","code":"< ? php function findSurfaceArea ( $ a , $ h ) { $ Area ; $ Area = 6 * $ a * $ h + 3 * sqrt ( 3 ) * $ a * $ a ; echo \" Surface \u2581 Area : \u2581 \" , $ Area , \" STRNEWLINE \" ; } function findVolume ( $ a , $ h ) { $ Volume ; $ Volume = 3 * sqrt ( 3 ) * $ a * $ a * $ h \/ 2 ; echo \" Volume : \u2581 \" , $ Volume ; } $ a = 5 ; $ h = 10 ; findSurfaceArea ( $ a , $ h ) ; findVolume ( $ a , $ h ) ; ? >"}
{"text":"Minimum number of mails required to distribute all the questions | Function returns the min no of mails required ; Using the formula derived above ; no of questions ; no of students ; maximum no of questions a mail can hold ; Calling function","code":"< ? php function MinimumMail ( $ n , $ k , $ x ) { $ m = ( $ n - 1 ) + ceil ( ( $ n - 1 ) * 1.0 \/ $ x ) * ( $ n - 1 ) + ceil ( $ n * 1.0 \/ $ x ) * ( $ k - $ n ) ; return $ m ; } $ N = 4 ; $ K = 9 ; $ X = 2 ; echo MinimumMail ( $ N , $ K , $ X ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program to find the Area of an Ellipse | Function to find area of an ellipse . ; formula to find the area of an Ellipse . ; Display the result ; Driver code","code":"< ? php function findArea ( $ a , $ b ) { $ Area ; $ Area = 3.142 * $ a * $ b ; echo \" Area : \u2581 \" . $ Area ; } $ a = 5 ; $ b = 4 ; findArea ( $ a , $ b ) ; ? >"}
{"text":"Compute power of power k times % m | Function to compute the given value ; compute power k times ; Driver Code ; Calling function","code":"< ? php function calculate ( $ x , $ k , $ m ) { $ result = $ x ; $ k -- ; while ( $ k -- ) { $ result = pow ( $ result , $ x ) ; if ( $ result > $ m ) $ result %= $ m ; } return $ result ; } $ x = 5 ; $ k = 2 ; $ m = 3 ; echo calculate ( $ x , $ k , $ m ) ; ? >"}
{"text":"Recursive program to check if number is palindrome or not | Recursive function that returns the reverse of digits ; base case ; stores the reverse of a number ; Driver Code","code":"< ? php function rev ( $ n , $ temp ) { if ( $ n == 0 ) return $ temp ; $ temp = ( $ temp * 10 ) + ( $ n % 10 ) ; return rev ( $ n \/ 10 , $ temp ) ; } $ n = 121 ; $ temp = rev ( $ n , 0 ) ; if ( $ temp != $ n ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text":"Program to find greater value between a ^ n and b ^ n | Function to find the greater value ; If n is even ; Driver code","code":"< ? php function findGreater ( $ a , $ b , $ n ) { if ( ! ( $ n & 1 ) ) { $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; } if ( $ a == $ b ) echo \" a ^ n \u2581 is \u2581 equal \u2581 to \u2581 b ^ n \" ; else if ( $ a > $ b ) echo \" a ^ n \u2581 is \u2581 greater \u2581 than \u2581 b ^ n \" ; else echo \" b ^ n \u2581 is \u2581 greater \u2581 than \u2581 a ^ n \" ; } $ a = 12 ; $ b = 24 ; $ n = 5 ; findGreater ( $ a , $ b , $ n ) ; ? >"}
{"text":"Print first n Fibonacci Numbers using direct formula | Function to calculate fibonacci using recurrence relation formula ; Using direct formula ; Driver code","code":"< ? php function fibonacci ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ fib = ( pow ( ( 1 + sqrt ( 5 ) ) , $ i ) - pow ( ( 1 - sqrt ( 5 ) ) , $ i ) ) \/ ( pow ( 2 , $ i ) * sqrt ( 5 ) ) ; echo $ fib , \" \" ; } } $ n = 8 ; fibonacci ( $ n ) ; ? >"}
{"text":"Centered Hexadecagonal Number | centered hexadecagonal function ; Formula to calculate nth centered hexadecagonal number ; Driver Code","code":"< ? php function center_hexadecagonal_num ( $ n ) { return 8 * $ n * $ n - 8 * $ n + 1 ; } $ n = 2 ; echo $ n , \" th \u2581 centered \u2581 hexadecagonal \u2581 number \u2581 : \u2581 \" , center_hexadecagonal_num ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 12 ; echo $ n , \" th \u2581 centered \u2581 hexadecagonal \u2581 numbe \u2581 : \u2581 \" , center_hexadecagonal_num ( $ n ) ; ? >"}
{"text":"Check if the n | PHP Program to check if the nth is odd or even in a sequence where each term is sum of previous two term ; Return if the nth term is even or odd . ; Return true if odd ; Driver Code","code":"< ? php $ MAX = 100 ; function findNature ( $ a , $ b , $ n ) { global $ MAX ; $ seq = array_fill ( 0 , $ MAX , 0 ) ; $ seq [ 0 ] = $ a ; $ seq [ 1 ] = $ b ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ seq [ $ i ] = $ seq [ $ i - 1 ] + $ seq [ $ i - 2 ] ; return ( $ seq [ $ n ] & 1 ) ; } $ a = 2 ; $ b = 4 ; $ n = 3 ; if ( findNature ( $ a , $ b , $ n ) ) echo \" Odd \" ; else echo \" Even \" ; ? >"}
{"text":"Program to compare m ^ n and n ^ m | function to compare m ^ n and n ^ m ; m ^ n ; n ^ m ; Driver Code ; function call to compare m ^ n and n ^ m","code":"< ? php function check ( $ m , $ n ) { $ RHS = $ m * log ( $ n ) ; $ LHS = $ n * log ( $ m ) ; if ( $ LHS > $ RHS ) echo \" m ^ n \u2581 > \u2581 n ^ m \" ; else if ( $ LHS < $ RHS ) echo \" m ^ n \u2581 < \u2581 n ^ m \" ; else echo \" m ^ n \u2581 = \u2581 n ^ m \" ; } $ m = 987654321 ; $ n = 123456987 ; check ( $ m , $ n ) ; ? >"}
{"text":"Find the GCD that lies in given range | Return the greatest common divisor of two numbers ; Return the gretest common divisor of a and b which lie in the given range . ; Loop from 1 to sqrt ( GCD ( a , b ) . ; if i divides the GCD ( a , b ) , then find maximum of three numbers res , i and g \/ i ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } function maxDivisorRange ( $ a , $ b , $ l , $ h ) { $ g = gcd ( $ a , $ b ) ; $ res = -1 ; for ( $ i = $ l ; $ i * $ i <= $ g and $ i <= $ h ; $ i ++ ) if ( $ g % $ i == 0 ) $ res = max ( $ res , max ( $ i , $ g \/ $ i ) ) ; return $ res ; } $ a = 3 ; $ b = 27 ; $ l = 1 ; $ h = 5 ; echo maxDivisorRange ( $ a , $ b , $ l , $ h ) ; ? >"}
{"text":"Number expressed as sum of five consecutive integers | function to check if a number can be expressed as sum of five consecutive integers . ; if n is 0 ; if n is positive , increment loop by 1. ; if n is negative , decrement loop by 1. ; Running loop from 0 to n - 4 ; check if sum of five consecutive integer is equal to n . ; Driver Code","code":"< ? php function checksum ( $ n ) { if ( $ n == 0 ) { echo \" - 2 \u2581 - 1 \u2581 0 \u2581 1 \u2581 2\" , \" STRNEWLINE \" ; return ; } $ inc ; if ( $ n > 0 ) $ inc = 1 ; else $ inc = -1 ; for ( $ i = 0 ; $ i <= $ n - 4 ; $ i += $ inc ) { if ( $ i + $ i + 1 + $ i + 2 + $ i + 3 + $ i + 4 == $ n ) { echo $ i , \" \" \u2581 , \u2581 $ i \u2581 + \u2581 1 , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" \" \u2581 , \u2581 $ i \u2581 + \u2581 2 , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" \" \u2581 , \u2581 $ i \u2581 + \u2581 3 , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" \" return ; } } echo \" - 1\" ; } $ n = 15 ; checksum ( $ n ) ; ? >"}
{"text":"Number expressed as sum of five consecutive integers | function to check if a number can be expressed as sum of five consecutive integers . ; if n is multiple of 5 ; else print \" - 1\" . ; Driver Code","code":"< ? php function checksum ( $ n ) { if ( $ n % 5 == 0 ) echo $ n \/ 5 - 2 , \" \u2581 \" , $ n \/ 5 - 1 , \" \u2581 \" , $ n \/ 5 , \" \u2581 \" , $ n \/ 5 + 1 , \" \u2581 \" , $ n \/ 5 + 2 ; else echo \" - 1\" ; } $ n = 15 ; checksum ( $ n ) ; ? >"}
{"text":"n | Function to find the nth term of series ; Loop to add 4 th powers ; Driver code","code":"< ? php function sumOfSeries ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i * $ i * $ i * $ i ; return $ ans ; } $ n = 4 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text":"Number of unmarked integers in a special sieve | PHP Program to determine the number of unmarked integers in a special sieve ; Driver Code","code":"< ? php function countUnmarked ( $ N ) { if ( $ N % 2 == 0 ) return $ N \/ 2 ; else return $ N \/ 2 + 1 ; } $ N = 4 ; echo \" Number \u2581 of \u2581 unmarked \u2581 elements : \u2581 \" , countUnmarked ( $ N ) ; ? >"}
{"text":"Sum of series 1 * 1 ! + 2 * 2 ! + \u2026\u2026 . . + n * n ! | PHP program to find sum of the series . ; Function to calculate required series ; Driver code","code":"< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function calculateSeries ( $ n ) { return factorial ( $ n + 1 ) - 1 ; } $ n = 3 ; echo calculateSeries ( $ n ) ; ? >"}
{"text":"Sum of series 1 * 1 * 2 ! + 2 * 2 * 3 ! + \u2026\u2026 . . + n * n * ( n + 1 ) ! | PHP program to find sum of the series . ; Function to calculate required series ; Driver code","code":"< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = $ res * $ i ; return $ res ; } function calculateSeries ( $ n ) { return 2 + ( $ n * $ n + $ n - 2 ) * factorial ( $ n + 1 ) ; } $ n = 3 ; echo calculateSeries ( $ n ) ; ? >"}
{"text":"Forming smallest array with given constraints | Return the size of smallest array with given constraint . ; Driver Code","code":"< ? php function minimumLength ( $ x , $ y , $ z ) { return 1 + abs ( $ x - $ y ) + abs ( $ y - $ z ) ; } $ x = 3 ; $ y = 1 ; $ z = 2 ; echo minimumLength ( $ x , $ y , $ z ) ; ? >"}
{"text":"Find the other | function to find the other - end point of diameter ; find end point for x coordinates ; find end point for y coordinates ; Driven Program","code":"< ? php function endPointOfDiameterofCircle ( $ x1 , $ y1 , $ c1 , $ c2 ) { echo \" x2 = \" , (2 \u2581 * \u2581 $ c1 \u2581 - \u2581 $ x1 ) , \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" y2 = \" } $ x1 = -4 ; $ y1 = -1 ; $ c1 = 3 ; $ c2 = 5 ; endPointOfDiameterofCircle ( $ x1 , $ y1 , $ c1 , $ c2 ) ; ? >"}
{"text":"Newton 's Divided Difference Interpolation Formula | Function to find the product term ; Function for calculating divided difference table ; Function for applying Newton 's  divided difference formula  ; Function for displaying divided difference table ; number of inputs given ; y [ ] [ ] is used for divided difference table where y [ ] [ 0 ] is used for input ; calculating divided difference table ; displaying divided difference table ; value to be interpolated ; printing the value","code":"< ? php function proterm ( $ i , $ value , $ x ) { $ pro = 1 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ pro = $ pro * ( $ value - $ x [ $ j ] ) ; } return $ pro ; } function dividedDiffTable ( $ x , & $ y , $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) { $ y [ $ j ] [ $ i ] = ( $ y [ $ j ] [ $ i - 1 ] - $ y [ $ j + 1 ] [ $ i - 1 ] ) \/ ( $ x [ $ j ] - $ x [ $ i + $ j ] ) ; } } } function applyFormula ( $ value , $ x , $ y , $ n ) { $ sum = $ y [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( proterm ( $ i , $ value , $ x ) * $ y [ 0 ] [ $ i ] ) ; } return $ sum ; } function printDiffTable ( $ y , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) { echo round ( $ y [ $ i ] [ $ j ] , 4 ) . \" \" ; } echo \" \" ; } } $ n = 4 ; $ y = array_fill ( 0 , 10 , array_fill ( 0 , 10 , 0 ) ) ; $ x = array ( 5 , 6 , 9 , 11 ) ; $ y [ 0 ] [ 0 ] = 12 ; $ y [ 1 ] [ 0 ] = 13 ; $ y [ 2 ] [ 0 ] = 14 ; $ y [ 3 ] [ 0 ] = 16 ; dividedDiffTable ( $ x , $ y , $ n ) ; printDiffTable ( $ y , $ n ) ; $ value = 7 ; echo \" Value at \" \u2581 . \u2581 $ value \u2581 . \u2581 \" is \" round ( applyFormula ( $ value , $ x , $ y , $ n ) , 2 ) . \" STRNEWLINE \" ? >"}
{"text":"Centered heptagonal number | Function to find Centered heptagonal number ; Formula to calculate nth Centered heptagonal number ; Driver Code","code":"< ? php function centered_heptagonal_num ( $ n ) { return ( 7 * $ n * $ n - 7 * $ n + 2 ) \/ 2 ; } $ n = 5 ; echo $ n , \" th \u2581 Centered \u2581 heptagonal \u2581 number \u2581 : \u2581 \" ; echo centered_heptagonal_num ( $ n ) ; ? >"}
{"text":"Sum of square | Function to find sum of sum of square of first n natural number ; Driver Code","code":"< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ i * ( $ i + 1 ) * ( 2 * $ i + 1 ) ) \/ 6 ) ; return $ sum ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text":"Check if a given matrix is Hankel or not | PHP Program to check if given matrix is Hankel Matrix or not . ; Function to check if given matrix is Hankel Matrix or not . ; for each row ; for each column ; checking if i + j is less than n ; checking if the element is equal to the corresponding diagonal constant ; checking if the element is equal to the corresponding diagonal constant ; Driver code","code":"< ? php $ N = 4 ; function checkHankelMatrix ( $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i + $ j < $ n ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j ] [ 0 ] ) return false ; } else { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j - $ n + 1 ] [ $ n - 1 ] ) return false ; } } } return true ; } $ n = 4 ; $ m = array ( array ( 1 , 2 , 3 , 5 ) , array ( 2 , 3 , 5 , 8 ) , array ( 3 , 5 , 8 , 0 ) , array ( 5 , 8 , 0 , 9 ) ) ; if ( checkHankelMatrix ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if a number can be expressed as power | Set 2 ( Using Log ) | PHP program to find if a number can be expressed as x raised to power y . ; Find Log n in different bases and check if the value is an integer ; Driver code","code":"< ? php function isPower ( $ n ) { for ( $ x = 2 ; $ x <= sqrt ( $ n ) ; $ x ++ ) { $ f = log ( $ n ) \/ log ( $ x ) ; if ( ( $ f - ( int ) $ f ) == 0.0 ) return true ; } return false ; } for ( $ i = 2 ; $ i < 100 ; $ i ++ ) if ( isPower ( ( int ) $ i ) ) echo $ i . \" \" ; ? >"}
{"text":"Queries on sum of odd number digit sums of all the factors of a number | PHP Program to answer queries on sum of sum of odd number digits of all the factors of a number ; finding sum of odd digit number in each integer . ; for each number ; using previous number sum , finding the current number num of odd digit also , adding last digit if it is odd . ; finding sum of sum of odd digit of all the factors of a number . ; for each possible factor ; adding the contribution . ; Wrapper function ; Driver Code","code":"< ? php $ N = 1000005 ; function sumOddDigit ( & $ digitSum ) { global $ N ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ digitSum [ $ i ] = $ digitSum [ intval ( $ i \/ 10 ) ] + intval ( $ i & 1 ) * ( $ i % 10 ) ; } } function sumFactor ( $ digitSum , & $ factorDigitSum ) { global $ N ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) { $ factorDigitSum [ $ j ] += $ digitSum [ $ i ] ; } } } function wrapper ( $ q , $ n ) { global $ N ; $ digitSum = array ( ) ; $ factorDigitSum = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ digitSum [ $ i ] = 0 ; $ factorDigitSum [ $ i ] = 0 ; } sumOddDigit ( $ digitSum ) ; sumFactor ( $ digitSum , $ factorDigitSum ) ; for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo ( $ factorDigitSum [ $ n [ $ i ] ] . \" \u2581 \" ) ; } $ q = 2 ; $ n = array ( 10 , 36 ) ; wrapper ( $ q , $ n ) ; ? >"}
{"text":"Number of digits in the nth number made of given four digits | Efficient function to calculate number of digits in the nth number constructed by using 6 , 1 , 4 and 9 as digits in the ascending order . ; Number of digits increase after every i - th number where i increases in powers of 4. ; Driver Code","code":"< ? php function number_of_digits ( $ n ) { $ i ; $ res ; $ sum = 0 ; for ( $ i = 4 , $ res = 1 ; ; $ i *= 4 , $ res ++ ) { $ sum += $ i ; if ( $ sum >= $ n ) break ; } return $ res ; } $ n = 21 ; echo number_of_digits ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Print prime numbers from 1 to N in reverse order | PHP program to print all primes between 1 to N in reverse order using Sieve of Eratosthenes ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers in reverse order ; static input ; to display ; Reverseorder ( $N ) ; calling the function","code":"< ? php function Reverseorder ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = $ n ; $ p >= 2 ; $ p -- ) if ( $ prime [ $ p ] ) echo $ p . \" \" ; } $ N = 25 ; echo \" Prime \u2581 number \u2581 in \u2581 reverse \u2581 order STRNEWLINE \" ; if ( $ N == 1 ) echo \" No \u2581 prime \u2581 no \u2581 exist \u2581 in \u2581 this \u2581 range \" ; else ? >"}
{"text":"Finding n | Function to generate a fixed number ; Driver Method","code":"< ? php function magicOfSequence ( $ N ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ sum += ( $ i * $ i * $ i + $ i * 2 ) ; return $ sum ; } $ N = 4 ; echo magicOfSequence ( $ N ) ; ? >"}
{"text":"Expressing a number as sum of consecutive | Set 2 ( Using odd factors ) | returns the number of odd factors ; If i is an odd factor and n is a perfect square ; If n is not perfect square ; N as sum of consecutive numbers","code":"< ? php function countOddFactors ( $ n ) { $ odd_factors = 0 ; for ( $ i = 1 ; 1 * $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( 1 * $ i * $ i == $ n ) { if ( $ i & 1 ) $ odd_factors ++ ; } else { if ( $ i & 1 ) $ odd_factors ++ ; $ factor = $ n \/ $ i ; if ( $ factor & 1 ) $ odd_factors ++ ; } } } return $ odd_factors - 1 ; } $ N = 15 ; echo ( countOddFactors ( $ N ) . ( \" \" ) ) ; $ N = 10 ; echo ( countOddFactors ( $ N ) ) ; ? >"}
{"text":"Making zero array by decrementing pairs of adjacent | PHP program to find if it is possible to make all array elements 0 by decrement operations . ; used for storing the sum of even and odd position element in array . ; if position is odd , store sum value of odd position in odd ; if position is even , store sum value of even position in even ; Driver Code","code":"< ? php function isPossibleToZero ( $ a , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ odd += $ a [ $ i ] ; else $ even += $ a [ $ i ] ; } return ( $ odd == $ even ) ; } $ arr = array ( 0 , 1 , 1 , 0 ) ; $ n = sizeof ( $ arr ) ; if ( isPossibleToZero ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Program for sum of cos ( x ) series | PHP program to find the sum of cos ( x ) series ; here x is in degree . we have to convert it to radian for using it with series formula , as in series expansion angle is in radian ; Driver Code","code":"< ? php $ PI = 3.142 ; function cosXSertiesSum ( $ x , $ n ) { global $ PI ; $ x = $ x * ( $ PI \/ 180.0 ) ; $ res = 1 ; $ sign = 1 ; $ fact = 1 ; $ pow = 1 ; for ( $ i = 1 ; $ i < 5 ; $ i ++ ) { $ sign = $ sign * -1 ; $ fact = $ fact * ( 2 * $ i - 1 ) * ( 2 * $ i ) ; $ pow = $ pow * $ x * $ x ; $ res = $ res + $ sign * $ pow \/ $ fact ; } return $ res ; } $ x = 50 ; $ n = 5 ; echo cosXSertiesSum ( $ x , 5 ) ; ? >"}
{"text":"Sum of digits written in different bases from 2 to n | function to calculate sum of digit for a given base ; Sum of digits ; Calculating the number ( n ) by taking mod with the base and adding remainder to the result and parallelly reducing the num value . ; returning the result ; function calling for multiple bases ; Driver code","code":"< ? php function solve ( $ n , $ base ) { $ result = 0 ; while ( $ n > 0 ) { $ remainder = $ n % $ base ; $ result = $ result + $ remainder ; $ n = $ n \/ $ base ; } return $ result ; } function printSumsOfDigits ( $ n ) { for ( $ base = 2 ; $ base < $ n ; ++ $ base ) { echo ( solve ( $ n , $ base ) ) ; echo ( \" \u2581 \" ) ; } } $ n = 8 ; printSumsOfDigits ( $ n ) ; ? >"}
{"text":"Possible two sets from first N natural numbers difference of sums as D | Function returns true if it is possible to split into two sets otherwise returns false ; Driver code","code":"< ? php function check ( $ N , $ D ) { $ temp = ( $ N * ( $ N + 1 ) ) \/ 2 + $ D ; return ( $ temp % 2 == 0 ) ; } $ N = 5 ; $ M = 7 ; if ( check ( $ N , $ M ) ) echo ( \" yes \" ) ; else echo ( \" no \" ) ;"}
{"text":"Minimum digits to remove to make a number Perfect Square | function to check minimum number of digits should be removed to make this number a perfect square ; size of the string ; our final answer ; to store string which is perfect square . ; We make all possible subsequences ; to check jth bit is set or not . ; we do not consider a number with leading zeros ; convert our temporary string into integer ; checking temp is perfect square or not . ; taking maximum sized string ; print PerfectSquare ; Driver code","code":"< ? php function perfectSquare ( $ s ) { $ n = strlen ( $ s ) ; $ ans = -1 ; $ num = \" \" ; for ( $ i = 1 ; $ i < ( 1 << $ n ) ; $ i ++ ) { $ str = \" \" ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ i >> $ j ) & 1 ) { $ str = $ str . $ s [ $ j ] ; } } if ( $ str [ 0 ] != '0' ) { $ temp = 0 ; for ( $ j = 0 ; $ j < strlen ( $ str ) ; $ j ++ ) $ temp = $ temp * 10 + ( ord ( $ str [ $ j ] ) - ord ( '0' ) ) ; $ k = ( int ) ( sqrt ( $ temp ) ) ; if ( ( $ k * $ k ) == $ temp ) { if ( $ ans < strlen ( $ str ) ) { $ ans = strlen ( $ str ) ; $ num = $ str ; } } } } if ( $ ans == -1 ) return $ ans ; else { echo ( $ num . \" \" ) ; return ( $ n - $ ans ) ; } } echo ( perfectSquare ( \"8314\" ) . \" STRNEWLINE \" ) ; echo ( perfectSquare ( \"753\" ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Lagrange 's four square theorem | Prints all the possible combinations 4 numbers whose sum of squares is equal to the given no . ; loops checking the sum of squares ; if sum of four squares equals the given no . ; printing the numbers ; Driver Code ; 74 = 0 * 0 + 0 * 0 + 5 * 5 + 7 * 7 74 = 0 * 0 + 1 * 1 + 3 * 3 + 8 * 8 74 = 0 * 0 + 3 * 3 + 4 * 4 + 7 * 7 74 = 1 * 1 + 1 * 1 + 6 * 6 + 6 * 6 74 = 2 * 2 + 3 * 3 + 5 * 5 + 6 * 6","code":"< ? php function printFourSquares ( $ a ) { for ( $ i = 0 ; $ i * $ i <= $ a ; $ i ++ ) { for ( $ j = $ i ; $ j * $ j <= $ a ; $ j ++ ) { for ( $ k = $ j ; $ k * $ k <= $ a ; $ k ++ ) { for ( $ l = $ k ; $ l * $ l <= $ a ; $ l ++ ) { if ( $ i * $ i + $ j * $ j + $ k * $ k + $ l * $ l == $ a ) { echo $ a , \" = \" \u2581 , \u2581 $ i \u2581 , \u2581 \" * \" \u2581 , $ i , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" + \" \u2581 , \u2581 $ j \u2581 , \u2581 \" * \" \u2581 , \u2581 $ j \u2581 , \u2581 \" + \" echo $ k , \" * \" \u2581 , \u2581 $ k \u2581 , \u2581 \" + \" $ l , \" * \" , $ l , \" STRNEWLINE \" ; } } } } } } $ a = 74 ; printFourSquares ( $ a ) ; ? >"}
{"text":"Hardy | A function to count prime factors of a given number n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; This condition is to handle the case when n is a prime number greater than 2 ; Driver Code","code":"< ? php function exactPrimeFactorCount ( $ n ) { $ count = 0 ; if ( $ n % 2 == 0 ) { $ count ++ ; while ( $ n % 2 == 0 ) $ n = $ n \/ 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ count ++ ; while ( $ n % $ i == 0 ) $ n = $ n \/ $ i ; } } if ( $ n > 2 ) $ count ++ ; return $ count ; } $ n = 51242183 ; echo \" The \u2581 number \u2581 of \u2581 distinct \u2581 prime \" . \" \u2581 factors \u2581 is \/ are \u2581 \" , exactPrimeFactorCount ( $ n ) , \" STRNEWLINE \" ; echo \" The \u2581 value \u2581 of \u2581 log ( log ( n ) ) \u2581 \" . \" is \u2581 \" , log ( log ( $ n ) ) , \" STRNEWLINE \" ; ? >"}
{"text":"Number of Digits in a ^ b | function to calculate number of digits in a ^ b ; Driver Code","code":"< ? php function no_of_digit ( $ a , $ b ) { return ( ( int ) ( $ b * log10 ( $ a ) ) + 1 ) ; } $ a = 2 ; $ b = 100 ; echo ( \" no . \u2581 of \u2581 digits \u2581 = \u2581 \" . no_of_digit ( $ a , $ b ) ) ; ? >"}
{"text":"Check whether a number is Emirpimes or not | Checking whether a number is semi - prime or not ; Increment count of prime numbers ; If number is still greater than 1 , after exiting the for loop add it to the count variable as it indicates the number is a prime number ; Return '1' if count is equal to '2' else return '0' ; Checking whether a number is emirpimes or not ; Number itself is not semiprime . ; Finding reverse of n . ; The definition of emirpimes excludes palindromes , hence we do not check further , if the number entered is a palindrome ; Checking whether the reverse of the semi prime number entered is also a semi prime number or not ; Driver Code","code":"< ? php function checkSemiprime ( $ num ) { $ cnt = 0 ; for ( $ i = 2 ; $ cnt < 2 && $ i * $ i <= $ num ; ++ $ i ) { while ( $ num % $ i == 0 ) { $ num \/= $ i ; ++ $ cnt ; } } if ( $ num > 1 ) ++ $ cnt ; return $ cnt == 2 ; } function isEmirpimes ( $ n ) { if ( checkSemiprime ( $ n ) == false ) return false ; $ r = 0 ; for ( $ t = $ n ; $ t != 0 ; $ t = $ t \/ $ n ) $ r = $ r * 10 + $ t % 10 ; if ( $ r == $ n ) return false ; return ( checkSemiprime ( $ r ) ) ; } $ n = 15 ; if ( isEmirpimes ( $ n ) ) echo \" No \" ; else echo \" Yes \" ; ? >"}
{"text":"Generate a list of n consecutive composite numbers ( An interesting method ) | function to find factorial of given number ; Prints n consecutive numbers . ; Driver Code","code":"< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res *= $ i ; return $ res ; } function printNComposite ( int $ n ) { $ fact = factorial ( $ n + 1 ) ; for ( $ i = 2 ; $ i <= $ n + 1 ; ++ $ i ) echo $ fact + $ i , \" \u2581 \" ; } $ n = 4 ; printNComposite ( $ n ) ; ? >"}
{"text":"Frugal Number | Finding primes upto entered number ; Finding primes by Sieve of Eratosthenes method ; If prime [ i ] is not changed , then it is prime ; Update all multiples of p ; Forming array of the prime numbers found ; Returns number of digits in n ; Checking whether a number is Frugal or not ; Finding number of digits in prime factorization of the number ; Exponent for current factor ; Counting number of times this prime factor divides ( Finding exponent ) ; Finding number of digits in the exponent Avoiding exponents of value 1 ; Checking condition for frugal number ; Driver Code","code":"< ? php function primes ( $ n ) { $ prime = array ( ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ prime [ $ i ] == true ) { for ( $ j = $ i * 2 ; $ j <= $ n ; $ j += $ i ) $ prime [ $ j ] = false ; } } $ arr = array ( ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ prime [ $ i ] ) array_push ( $ arr , $ i ) ; return $ arr ; } function countDigits ( $ n ) { $ temp = $ n ; $ c = 0 ; while ( $ temp != 0 ) { $ temp = intval ( $ temp \/ 10 ) ; $ c ++ ; } return $ c ; } function frugal ( $ n ) { $ r = primes ( $ n ) ; $ t = $ n ; $ s = 0 ; for ( $ i = 0 ; $ i < count ( $ r ) ; $ i ++ ) { if ( $ t % $ r [ $ i ] == 0 ) { $ k = 0 ; while ( $ t % $ r [ $ i ] == 0 ) { $ t = intval ( $ t \/ $ r [ $ i ] ) ; $ k ++ ; } if ( $ k == 1 ) $ s = $ s + countDigits ( $ r [ $ i ] ) ; else if ( $ k != 1 ) $ s = $ s + countDigits ( $ r [ $ i ] ) + countDigits ( $ k ) ; } } return ( countDigits ( $ n ) > $ s && $ s != 0 ) ; } $ n = 343 ; if ( frugal ( $ n ) ) echo ( \" A \u2581 Frugal \u2581 number STRNEWLINE \" ) ; else echo ( \" Not \u2581 a \u2581 frugal \u2581 number STRNEWLINE \" ) ; ? >"}
{"text":"N | PHP program to find n - th number which is both square and cube . ; Driver code","code":"< ? php function nthSquareCube ( $ n ) { return $ n * $ n * $ n * $ n * $ n * $ n ; } $ n = 5 ; echo ( nthSquareCube ( $ n ) ) ; ? >"}
{"text":"Squared triangular number ( Sum of cubes ) | Function to find if the given number is sum of the cubes of first n natural numbers ; Start adding cubes of the numbers from 1 ; If sum becomes equal to s return n ; Driver code","code":"< ? php function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n * $ n * $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; } $ s = 9 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo ( \" - 1\" ) ; else echo ( $ n ) ; ? >"}
{"text":"Number with even sum of digits | Function to find kth good number . ; Find the last digit of n . ; If last digit is between 0 to 4 then return 2 * n . ; If last digit is between 5 to 9 then return 2 * n + 1. ; Driver code","code":"< ? php function findKthGoodNo ( $ n ) { $ lastDig = $ n % 10 ; if ( $ lastDig >= 0 && $ lastDig <= 4 ) return $ n << 1 ; else return ( $ n << 1 ) + 1 ; } $ n = 10 ; echo ( findKthGoodNo ( $ n ) ) ; ? >"}
{"text":"Nicomachu 's Theorem | PHP program to verify Nicomachu 's Theorem ; Compute sum of cubes ; Check if sum is equal to given formula . ; Driver Code","code":"< ? php function NicomachuTheorum_sum ( $ n ) { $ sum = 0 ; for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) $ sum += $ k * $ k * $ k ; $ triNo = $ n * ( $ n + 1 ) \/ 2 ; if ( $ sum == $ triNo * $ triNo ) echo \" Yes \" ; else echo \" No \" ; } $ n = 5 ; NicomachuTheorum_sum ( $ n ) ; ? >"}
{"text":"Largest even digit number not greater than N | function to check if all digits are even of a given number ; iterate for all digits ; if digit is odd ; all digits are even ; function to return the largest number with all digits even ; Iterate till we find a number with all digits even ; Driver Code","code":"< ? php function checkDigits ( $ n ) { while ( $ n ) { if ( ( $ n % 10 ) % 2 ) return 0 ; $ n \/= 10 ; } return 1 ; } function largestNumber ( $ n ) { for ( $ i = $ n ; ; $ i -- ) if ( checkDigits ( $ i ) ) return $ i ; } $ N = 23 ; echo ( largestNumber ( $ N ) ) ; ? >"}
{"text":"Largest even digit number not greater than N | function to return the largest number with all digits even ; convert the number to a string for easy operations ; find first odd digit ; if no digit , then N is the answer ; till first odd digit , add all even numbers ; decrease 1 from the odd digit ; add 0 in the rest of the digits ; Driver Code","code":"< ? php function largestNumber ( $ n ) { $ s = \" \" ; $ duplicate = $ n ; while ( $ n ) { $ s = chr ( $ n % 10 + 48 ) . $ s ; $ n = ( int ) ( $ n \/ 10 ) ; } $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] - '0' ) % 2 & 1 ) { $ index = $ i ; break ; } } if ( $ index == -1 ) return $ duplicate ; $ num = 0 ; for ( $ i = 0 ; $ i < $ index ; $ i ++ ) $ num = $ num * 10 + ( ord ( $ s [ $ i ] ) - ord ( '0' ) ) ; $ num = $ num * 10 + ( ( ord ( $ s [ $ i ] ) - ord ( '0' ) ) - 1 ) ; for ( $ i = $ index + 1 ; $ i < strlen ( $ s ) ; $ i ++ ) $ num = $ num * 10 + 8 ; return $ num ; } $ N = 24578 ; echo largestNumber ( $ N ) ; ? >"}
{"text":"Number of digits in 2 raised to power n | Function to find number of digits in 2 ^ n ; Driver code","code":"< ? php function countDigits ( $ n ) { return intval ( $ n * log10 ( 2 ) + 1 ) ; } $ n = 5 ; echo ( countDigits ( $ n ) ) ; ? >"}
{"text":"Smallest even digits number not less than N | function to check if all digits are even of a given number ; iterate for all digits ; if digit is odd ; all digits are even ; function to return the smallest number with all digits even ; iterate till we find a number with all digits even ; Driver Code","code":"< ? php function check_digits ( $ n ) { while ( $ n ) { if ( ( $ n % 10 ) % 2 ) return 0 ; $ n \/= 10 ; } return 1 ; } function smallest_number ( $ n ) { for ( $ i = $ n ; ; $ i ++ ) if ( check_digits ( $ i ) ) return $ i ; } $ N = 2397 ; echo smallest_number ( $ N ) ; ? >"}
{"text":"Smallest triangular number larger than p | PHP code to find the bucket to choose for picking flowers out of it ; Driver code","code":"< ? php function findBucketNo ( $ p ) { return ceil ( ( sqrt ( 8 * $ p + 1 ) - 1 ) \/ 2 ) ; } $ p = 10 ; echo ( findBucketNo ( $ p ) ) ; ? >"}
{"text":"LCM of factorial and its neighbors | function to calculate the factorial ; returning the factorial of the largest number in the given three consecutive numbers ; Driver code","code":"< ? php function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } function LCMOfNeighbourFact ( $ n ) { return factorial ( $ n + 1 ) ; } $ N = 5 ; echo ( LCMOfNeighbourFact ( $ N ) ) ; ? >"}
{"text":"Check if the given two numbers are friendly pair or not | Returns sum of all factors of n . ; Traversing through all prime factors . ; THE BELOW STATEMENT MAKES IT BETTER THAN ABOVE METHOD AS WE REDUCE VALUE OF n . ; This condition is to handle the case when n is a prime number greater than 2. ; Function to return gcd of a and b ; Function to check if the given two number are friendly pair or not . ; Finding the sum of factors of n and m ; finding gcd of n and sum of its factors . ; finding gcd of m and sum of its factors . ; checking is numerator and denominator of abundancy index of both number are equal or not . ; Driver code","code":"< ? php function sumofFactors ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n \/ $ i ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function checkFriendly ( $ n , $ m ) { $ sumFactors_n = sumofFactors ( $ n ) ; $ sumFactors_m = sumofFactors ( $ m ) ; $ gcd_n = gcd ( $ n , $ sumFactors_n ) ; $ gcd_m = gcd ( $ m , $ sumFactors_m ) ; if ( $ n \/ $ gcd_n == $ m \/ $ gcd_m and $ sumFactors_n \/ $ gcd_n == $ sumFactors_m \/ $ gcd_m ) return true ; else return false ; } $ n = 6 ; $ m = 28 ; if ( checkFriendly ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find n | PHP program to find n - th Fortunate number ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to Find primorial of order n ( product of first n prime numbers ) . ; Function to find next prime number greater than n ; Note that difference ( or m ) should be greater than 1. ; loop continuously until isPrime returns true for a number above n ; Ignoring the prime number that is 1 greater than n ; Returns n - th Fortunate number ; Driver Code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function primorial ( $ n ) { $ p = 2 ; $ n -- ; for ( $ i = 3 ; $ n != 0 ; $ i ++ ) { if ( isPrime ( $ i ) ) { $ p = $ p * $ i ; $ n -- ; } $ i ++ ; } return $ p ; } function findNextPrime ( $ n ) { $ nextPrime = $ n + 2 ; while ( true ) { if ( isPrime ( $ nextPrime ) ) break ; $ nextPrime ++ ; } return $ nextPrime ; } function fortunateNumber ( $ n ) { $ p = primorial ( $ n ) ; return findNextPrime ( $ p ) - $ p ; } $ n = 5 ; echo fortunateNumber ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Probability for three randomly chosen numbers to be in AP | function to calculate probability ; Driver code","code":"< ? php function procal ( $ n ) { return ( 3.0 * $ n ) \/ ( 4.0 * ( $ n * $ n ) - 1 ) ; } $ a = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ a ) ; echo procal ( $ n ) ; ? >"}
{"text":"Fermat 's Last Theorem | PHP program to verify fermat 's last theorem for a given range and n. ; Check if there exists a triplet such that a ^ n + b ^ n = c ^ n ; Driver Code","code":"< ? php function testSomeNumbers ( $ limit , $ n ) { if ( $ n < 3 ) for ( $ a = 1 ; $ a <= $ limit ; $ a ++ ) for ( $ b = $ a ; $ b <= $ limit ; $ b ++ ) { $ pow_sum = pow ( $ a , $ n ) + pow ( $ b , $ n ) ; $ c = pow ( $ pow_sum , 1.0 \/ $ n ) ; $ c_pow = pow ( $ c , $ n ) ; if ( $ c_pow != $ pow_sum ) { echo \" Count \u2581 example \u2581 found \" ; return ; } } echo \" No \u2581 counter \u2581 example \u2581 within \u2581 \" . \" given \u2581 range \u2581 and \u2581 data \" ; } testSomeNumbers ( 10 , 3 ) ; ? >"}
{"text":"Product of given N fractions in reduced form | Function to return gcd of a and b ; Print the Product of N fraction in Reduced Form . ; finding the product of all N numerators and denominators . ; Finding GCD of new numerator and denominator ; Converting into reduced form . ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function productReduce ( $ n , $ num , $ den ) { $ new_num = 1 ; $ new_den = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ new_num *= $ num [ $ i ] ; $ new_den *= $ den [ $ i ] ; } $ GCD = gcd ( $ new_num , $ new_den ) ; $ new_num \/= $ GCD ; $ new_den \/= $ GCD ; echo $ new_num , \" \/ \" , $ new_den , \" STRNEWLINE \" ; } $ n = 3 ; $ num = array ( 1 , 2 , 5 ) ; $ den = array ( 2 , 1 , 6 ) ; productReduce ( $ n , $ num , $ den ) ; ? >"}
{"text":"Find value of ( n ^ 1 + n ^ 2 + n ^ 3 + n ^ 4 ) mod 5 for given n | function for f ( n ) mod 5 ; if n % 5 == 1 return 4 ; else return 0 ; Driver Code","code":"< ? php function fnMod ( $ n ) { if ( $ n % 5 == 1 ) return 4 ; else return 0 ; } $ n = 10 ; echo fnMod ( $ n ) , \" STRNEWLINE \" ; $ n = 11 ; echo fnMod ( $ n ) ; ? >"}
{"text":"Recursive sum of digits of a number formed by repeated appends | return single digit sum of a number . ; Returns recursive sum of digits of a number formed by repeating a number X number of times until sum become single digit . ; Driver Code","code":"< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } function repeatedNumberSum ( $ n , $ x ) { $ sum = $ x * digSum ( $ n ) ; return digSum ( $ sum ) ; } $ n = 24 ; $ x = 3 ; echo repeatedNumberSum ( $ n , $ x ) ; ? >"}
{"text":"Sum of n digit numbers divisible by a given number | Returns sum of n digit numbers divisible by ' number ' ; compute the first and last term ; sum of number which having n digit and divisible by number ; Driver code","code":"< ? php function totalSumDivisibleByNum ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ sum = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ sum += $ i ; return $ sum ; } $ n = 3 ; $ num = 7 ; echo totalSumDivisibleByNum ( $ n , $ num ) , \" \" ; ? >"}
{"text":"Count n digit numbers divisible by given number | Returns count of n digit numbers divisible by ' number ' ; compute the first and last term ; count total number of which having n digit and divisible by number ; Driver code","code":"< ? php function numberofterm ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ count = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ count ++ ; return $ count ; } $ n = 3 ; $ num = 7 ; echo numberofterm ( $ n , $ num ) ; ? >"}
{"text":"N | PHP program to find N - th term in George Cantor set of rational numbers ; let i = numerator ; let j = denominator ; to keep the check of no . of terms ; loop till k is not equal to n ; check if k is already equal to N then the first term is the required rational number ; loop for traversing from right to left downwards diagonally ; loop for traversing from left to right upwards diagonally ; Driver Code","code":"< ? php function georgeCantor ( $ n ) { $ i = 1 ; $ j = 1 ; $ k = 1 ; while ( $ k < $ n ) { $ j ++ ; $ k ++ ; if ( $ k == $ n ) break ; while ( $ j > 1 && $ k < $ n ) { $ i ++ ; $ j -- ; $ k ++ ; } if ( $ k == $ n ) break ; $ i ++ ; $ k ++ ; if ( $ k == $ n ) break ; while ( $ i > 1 && $ k < $ n ) { $ i -- ; $ j ++ ; $ k ++ ; } } echo \" N - th \u2581 term \u2581 : \u2581 \" , $ i , \" \/ \" , $ j ; } $ n = 15 ; georgeCantor ( $ n ) ; ? >"}
{"text":"Number is divisible by 29 or not | Returns true if n is divisible by 29 else returns false . ; add the lastdigit * 3 to remaining number until number becomes of only 2 digit ; return true if number is divisible by 29 another ; Driver Code","code":"< ? php function isDivisible ( $ n ) { while ( intval ( $ n \/ 100 ) ) { $ last_digit = $ n % 10 ; $ n = intval ( $ n \/ 10 ) ; $ n += $ last_digit * 3 ; } return ( $ n % 29 == 0 ) ; } $ n = 348 ; if ( isDivisible ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Solve the Linear Equation of Single Variable | Function to solve the given equation ; Traverse the equation ; For cases such as : x , - x , + x ; Flip sign once ' = ' is seen ; There may be a number left in the end ; For infinite solutions ; For no solution ; x = total sum \/ coeff of x ' - ' sign indicates moving numeric value to right hand side ; Driver code","code":"< ? php function solveEquation ( $ equation ) { $ n = strlen ( $ equation ) ; $ sign = 1 ; $ coeff = 0 ; $ total = 0 ; $ i = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ equation [ $ j ] == ' + ' $ equation [ $ j ] == ' - ' ) { if ( $ j > $ i ) $ total += $ sign * intval ( substr ( $ equation , $ i , $ j - $ i ) ) ; $ i = $ j ; } else if ( $ equation [ $ j ] == ' x ' ) { if ( ( $ i == $ j ) $ equation [ $ j - 1 ] == ' + ' ) $ coeff += $ sign ; else if ( $ equation [ $ j - 1 ] == ' - ' ) $ coeff -= $ sign ; else $ coeff += $ sign * intval ( substr ( $ equation , $ i , $ j - $ i ) ) ; $ i = $ j + 1 ; } else if ( $ equation [ $ j ] == ' = ' ) { if ( $ j > $ i ) $ total += $ sign * intval ( substr ( $ equation , $ i , $ j - $ i ) ) ; $ sign = -1 ; $ i = $ j + 1 ; } } if ( $ i < $ n ) $ total += $ sign * intval ( substr ( $ equation , $ i ) ) ; if ( $ coeff == 0 && $ total == 0 ) return \" Infinite \u2581 solutions \" ; if ( $ coeff == 0 && $ total ) return \" No \u2581 solution \" ; $ ans = - $ total \/ $ coeff ; return \" x \u2581 = \u2581 \" . $ ans ; } $ equation = \" x + 5-3 + x = 6 + x - 2\" ; echo ( solveEquation ( $ equation ) ) ; ? >"}
{"text":"Check if a given number is Pronic | Efficient Approach | function to check Pronic Number ; Checking Pronic Number by multiplying consecutive numbers ; Driver Code","code":"< ? php function pronic_check ( $ n ) { $ x = floor ( sqrt ( $ n ) ) ; if ( $ x * ( $ x + 1 ) == $ n ) return true ; else return false ; } $ n = 56 ; if ( pronic_check ( $ n ) == true ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Writing power function for large numbers | This function multiplies x with the number represented by res [ ] . res_size is size of res [ ] or number of digits in the number represented by res [ ] . This function uses simple school mathematics for multiplication . This function may value of res_size and returns the new value of res_size ; Initialize carry ; One by one multiply n with individual digits of res [ ] ; Store last digit of ' prod ' in res [ ] ; Put rest in carry ; Put carry in res and increase result size ; This function finds power of a number x ; printing value \"1\" for power = 0 ; Initialize result ; Multiply x n times ( x ^ n = x * x * x ... . n times ) ; Driver Code","code":"< ? php function multiply ( $ x , $ res ) { $ carry = 0 ; $ res_size = count ( $ res ) ; for ( $ i = 0 ; $ i < $ res_size ; $ i ++ ) { $ prod = $ res [ $ i ] * $ x + $ carry ; $ res [ $ i ] = $ prod % 10 ; $ carry = ( int ) ( $ prod \/ 10 ) ; } while ( $ carry ) { if ( $ carry % 10 ) $ res [ $ res_size ++ ] = $ carry % 10 ; $ carry = ( int ) ( $ carry \/ 10 ) ; } return $ res ; } function power ( $ x , $ n ) { if ( $ n == 0 ) { echo \"1\" ; return ; } $ res_size = 0 ; $ res = array ( ) ; $ temp = $ x ; while ( $ temp != 0 ) { $ res [ $ res_size ++ ] = $ temp % 10 ; $ temp = $ temp \/ 10 ; } for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res = multiply ( $ x , $ res ) ; echo $ x . \" ^ \" . $ n . \" \u2581 = \u2581 \" ; $ O = 0 ; for ( $ i = count ( $ res ) - 1 ; $ i >= 0 ; $ i -- , $ O ++ ) if ( $ res [ $ i ] ) break ; for ( $ i = count ( $ res ) - $ O - 1 ; $ i >= 0 ; $ i -- ) echo $ res [ $ i ] ; } $ exponent = 100 ; $ base = 2 ; power ( $ base , $ exponent ) ; ? >"}
{"text":"P | function to check if number n is a P - smooth number or not ; prime factorise it by 2 ; if the number is divisible by 2 ; check for all the possible numbers that can divide it ; prime factorize it by i ; stores the maximum if maximum and i , if i divides the number ; if n at the end is a prime number , then it a divisor itself ; Driver Code","code":"< ? php function check ( $ n , $ p ) { $ maximum = -1 ; while ( ! ( $ n % 2 ) ) { $ maximum = max ( $ maximum , 2 ) ; $ n = $ n \/ 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { while ( $ n % $ i == 0 ) { $ maximum = max ( $ maximum , $ i ) ; $ n = $ n \/ $ i ; } } if ( $ n > 2 ) $ maximum = max ( $ maximum , $ n ) ; return ( $ maximum <= $ p ) ; } $ n = 24 ; $ p = 7 ; if ( check ( $ n , $ p ) ) echo ( \" yes \" ) ; else echo ( \" no \" ) ; ? >"}
{"text":"Time when minute hand and hour hand coincide | function to find the minute ; finding the angle between minute hand and the first hour hand ; Driver code","code":"< ? php function find_time ( $ h1 ) { $ theta = 30 * $ h1 ; echo ( \" ( \" . ( $ theta * 2 ) . \" \/ \" \u2581 . \u2581 \" 11 \" \u2581 . \u2581 \" ) \" \u2581 . \u2581 \" minutes \" } $ h1 = 3 ; find_time ( $ h1 ) ; ? >"}
{"text":"Sum of Series ( n ^ 2 | function that calculate the sum of the nth series ; using formula of the nth term ; Driver Code","code":"< ? php function sum_series ( $ n ) { $ nSquare = $ n * $ n ; return $ nSquare * ( $ nSquare - 1 ) \/ 4 ; } $ n = 2 ; echo ( sum_series ( $ n ) ) ; ? >"}
{"text":"Check if a number is sandwiched between primes | returns true if number n is prime ; 0 and 1 both are non - primes ; finding square root of n ; checking if n has any factor upto square root of n if yes its not prime ; Driver Code","code":"< ? php function isPrime ( $ n ) { if ( $ n == 0 $ n == 1 ) return false ; $ root = sqrt ( $ n ) ; for ( $ i = 2 ; $ i <= $ root ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; } function isSandwitched ( $ n ) { return ( isPrime ( $ n - 1 ) && isPrime ( $ n + 1 ) ) ; } $ n = 642 ; echo $ n , \" \u2581 : \u2581 \" ; if ( isSandwitched ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ n = 9 ; echo $ n , \" \u2581 : \u2581 \" ; if ( isSandwitched ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Tomohiko Sakamoto 's Algorithm | function to implement tomohiko sakamoto algorithm ; array with leading number of days values ; if month is less than 3 reduce year by 1 ; Driver Code","code":"< ? php function day_of_the_week ( $ y , $ m , $ d ) { $ t = array ( 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ) ; if ( $ m < 3 ) $ y -= 1 ; return ( ( $ y + $ y \/ 4 - $ y \/ 100 + $ y \/ 400 + $ t [ $ m - 1 ] + $ d ) % 7 ) ; } $ day = 13 ; $ month = 7 ; $ year = 2017 ; echo day_of_the_week ( $ year , $ month , $ day ) ; ? >"}
{"text":"Recursive program for prime number | Returns true if n is prime , else return false . i is current divisor to check . ; Base cases ; Check for next divisor ; Driver Code","code":"< ? php function isPrime ( $ n , $ i = 2 ) { if ( $ n <= 2 ) return ( $ n == 2 ) ? true : false ; if ( $ n % $ i == 0 ) return false ; if ( $ i * $ i > $ n ) return true ; return isPrime ( $ n , $ i + 1 ) ; } $ n = 15 ; if ( isPrime ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Square Free Number | Returns true if n is a square free number , else returns false . ; If 2 again divides n , then n is not a square free number . ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; Check if i is a prime factor ; If i again divides , then n is not square free ; Driver Code","code":"< ? php function isSquareFree ( $ n ) { if ( $ n % 2 == 0 ) $ n = $ n \/ 2 ; if ( $ n % 2 == 0 ) return false ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ n = $ n \/ $ i ; if ( $ n % $ i == 0 ) return false ; } } return true ; } $ n = 10 ; if ( isSquareFree ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Area of a square from diagonal length | Returns area of square from given diagonal ; Driver Code","code":"< ? php function findArea ( $ d ) { return ( $ d * $ d ) \/ 2 ; } $ d = 10 ; echo ( findArea ( $ d ) ) ; ? >"}
{"text":"Sum of series 1 ^ 2 + 3 ^ 2 + 5 ^ 2 + . . . + ( 2 * n | Function to find sum of series . ; Driver code","code":"< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( 2 * $ i - 1 ) * ( 2 * $ i - 1 ) ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Sum of series 1 ^ 2 + 3 ^ 2 + 5 ^ 2 + . . . + ( 2 * n | Function that find sum of series . ; Formula to find sum of series . ; Driver code","code":"< ? php function sumOfSeries ( $ n ) { return ( $ n * ( 2 * $ n - 1 ) * ( 2 * $ n + 1 ) ) \/ 3 ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Program to implement standard error of mean | Function to find sample mean . ; loop to calculate sum of array elements . ; Function to calculate sample standard deviation . ; Function to calculate sample error . ; Formula to find sample error . ; Driver Code","code":"< ? php function mean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; return $ sum \/ $ n ; } function SSD ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) * ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) ; return sqrt ( $ sum \/ ( $ n - 1 ) ) ; } function sampleError ( $ arr , $ n ) { return SSD ( $ arr , $ n ) \/ sqrt ( $ n ) ; } { $ arr = array ( 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo sampleError ( $ arr , $ n ) ; return 0 ; } ? >"}
{"text":"Minimum moves to reach target on a infinite line | Set 2 | Function to find minimum steps to reach target ; Handling negatives$ by symmetry$ ; Keep moving while sum is smaller i . e calculating n ; case 1 : d is even ; d is odd ; Driver code ; Function call","code":"< ? php function StepstoReachTarget ( $ target ) { $ target = abs ( $ target ) ; $ n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * $ target ) ) \/ 2 ) ; $ sum = $ n * ( $ n + 1 ) \/ 2 ; if ( $ sum == $ target ) return $ n ; $ d = $ sum - $ target ; if ( ( $ d & 1 ) == 0 ) return n ; else return $ n + ( ( $ n & 1 ) ? 2 : 1 ) ; } $ target = 5 ; echo StepstoReachTarget ( $ target ) ; ? >"}
{"text":"Sum of series 2 \/ 3 | Function to find sum of series up - to n terms ; initializing counter by 1 ; variable to calculate result ; while loop until nth term is not reached ; boolean type variable for checking validation ; Driver Code","code":"< ? php function seriesSum ( $ n ) { $ i = 1 ; $ res = 0.0 ; $ sign = true ; while ( $ n > 0 ) { $ n -- ; if ( $ sign ) { $ sign = ! $ sign ; $ res = $ res + ( double ) ++ $ i \/ ++ $ i ; } else { $ sign = ! $ sign ; $ res = $ res - ( double ) ++ $ i \/ ++ $ i ; } } return $ res ; } $ n = 5 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text":"Number of Symmetric Relations on a Set | function find the square of n ; Base case ; Return 2 ^ ( n ( n + 1 ) \/ 2 ) ; Driver code","code":"< ? php function countSymmetric ( $ n ) { if ( $ n == 0 ) return 1 ; return 1 << ( ( $ n * ( $ n + 1 ) ) \/ 2 ) ; } $ n = 3 ; echo ( countSymmetric ( $ n ) ) ; ? >"}
{"text":"Program for centered nonagonal number | Function to find nth centered nonagonal number . ; Formula to find nth centered nonagonal number . ; Driver Code","code":"< ? php function centeredNonagonal ( $ n ) { return ( 3 * $ n - 2 ) * ( 3 * $ n - 1 ) \/ 2 ; } $ n = 10 ; echo centeredNonagonal ( $ n ) ; ? >"}
{"text":"Program for Mean Absolute Deviation | Function to find mean of the array elements . ; Calculate sum of all elements . ; Function to find mean absolute deviation of given elements . ; Calculate the sum of absolute deviation about mean . ; Return mean absolute deviation about mean . ; Driver Code","code":"< ? php function Mean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; return $ sum \/ $ n ; } function meanAbsoluteDeviation ( $ arr , $ n ) { $ absSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ absSum = $ absSum + abs ( $ arr [ $ i ] - Mean ( $ arr , $ n ) ) ; return $ absSum \/ $ n ; } $ arr = array ( 10 , 15 , 15 , 17 , 18 , 21 ) ; $ n = sizeof ( $ arr ) ; echo meanAbsoluteDeviation ( $ arr , $ n ) ; ? >"}
{"text":"Find if it is possible to get a ratio from given ranges of costs and quantities | Returns true if it is possible to get ratio r from given cost and quantity ranges . ; Calculating cost corresponding to value of i ; Driver Code","code":"< ? php function isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) { for ( $ i = $ lowQuant ; $ i <= $ upQuant ; $ i ++ ) { $ ans = $ i * $ r ; if ( $ lowCost <= $ ans && $ ans <= $ upCost ) return true ; } return false ; } $ lowCost = 14 ; $ upCost = 30 ; $ lowQuant = 5 ; $ upQuant = 12 ; $ r = 9 ; if ( isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) ) echo \" Yes \" ; else echo \" No \" ; # This  code is contributed by ajit NEW_LINE ? >"}
{"text":"Find N integers with given difference between product and sum | Function to implement calculation ; Driver Code","code":"< ? php function findNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo \"1\" , \" \u2581 \" ; echo \"2\" , \" \u2581 \" ; echo $ n + $ d , \" STRNEWLINE \" ; } $ N = 3 ; $ D = 5 ; findNumbers ( $ N , $ D ) ; ? >"}
{"text":"Sum of fourth powers of first n odd natural numbers | calculate the sum of fourth power of first n odd natural numbers ; Driver Code","code":"< ? php function oddNumSum ( $ n ) { return ( $ n * ( 2 * $ n + 1 ) * ( 24 * $ n * $ n * $ n - 12 * $ n * $ n - 14 * $ n + 7 ) ) \/ 15 ; } $ n = 4 ; echo ( oddNumSum ( $ n ) ) ; ? >"}
{"text":"Trailing number of 0 s in product of two factorials | Returns number of zeros in factorial n ; dividing x by powers of 5 and update count ; Returns count of trailing zeros in M ! x N ! ; Driver Code","code":"< ? php function trailingZero ( $ x ) { $ i = 5 ; $ count = 0 ; while ( $ x > $ i ) { $ count = $ count + ( int ) ( $ x \/ $ i ) ; $ i = $ i * 5 ; } return $ count ; } function countProductTrailing ( $ M , $ N ) { return trailingZero ( $ N ) + trailingZero ( $ M ) ; } $ N = 67 ; $ M = 98 ; echo ( countProductTrailing ( $ N , $ M ) ) ; ? >"}
{"text":"Trimorphic Number | Function to check Trimorphic number ; Store the cube ; Start Comparing digits ; Return false , if any digit of N doesn ' t \u2581 match \u2581 with \u2581 \u2581 its \u2581 cube ' s digits from last ; Reduce N and cube ; Driver code","code":"< ? php function isTrimorphic ( $ N ) { $ cube = $ N * $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ cube % 10 ) return -1 ; $ N \/= 10 ; $ cube \/= 10 ; } return 1 ; } $ N = 24 ; $ r = isTrimorphic ( $ N ) ? \" trimorphic \" : \" not \u2581 trimporphic \" ; echo $ r ; ? >"}
{"text":"Trimorphic Number | Functions to find nth Trimorphic number ; Comparing the digits ; Return false , if any digit of num doesn ' t \u2581 match \u2581 with \u2581 \u2581 its \u2581 cube ' s digits from last ; Reduce num and cube ; Check in max int size ; check number is Trimorphic or not ; if counter is equal to the n then return nth number ; Driver code","code":"< ? php function checkTrimorphic ( $ num ) { $ cube = $ num * $ num * $ num ; while ( $ num > 0 ) { if ( $ num % 10 != $ cube % 10 ) return false ; $ num = ( int ) ( $ num \/ 10 ) ; $ cube = ( int ) ( $ cube \/ 10 ) ; } return true ; } function nthTrimorphic ( $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < PHP_INT_MAX ; $ i ++ ) { if ( checkTrimorphic ( $ i ) ) $ count ++ ; if ( $ count == $ n ) return $ i ; } } $ n = 9 ; echo nthTrimorphic ( $ n ) ; ? >"}
{"text":"Find minimum moves to reach target on an infinite line | PHP program to find minimum moves to reach target if we can move i steps in i - th move . ; Handling negatives by symmetry ; Keep moving while sum is smaller or difference is odd . ; Driver code","code":"< ? php function reachTarget ( $ target ) { $ target = abs ( $ target ) ; $ sum = 0 ; $ step = 0 ; while ( $ sum < $ target or ( $ sum - $ target ) % 2 != 0 ) { $ step ++ ; $ sum += $ step ; } return $ step ; } $ target = 5 ; echo reachTarget ( $ target ) ; ? >"}
{"text":"Sum of fifth powers of the first n natural numbers | calculate the sum of fifth power of first n natural numbers ; Driver Code","code":"< ? php function fifthPowerSum ( $ n ) { return ( ( 2 * $ n * $ n * $ n * $ n * $ n * $ n ) + ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 5 * $ n * $ n * $ n * $ n ) - ( $ n * $ n ) ) \/ 12 ; } $ n = 5 ; echo ( fifthPowerSum ( $ n ) ) ; ? >"}
{"text":"Find unit digit of x raised to power y | Returns unit digit of x raised to power y ; Initialize result as 1 to handle case when y is 0. ; One by one multiply with x mod 10 to avoid overflow . ; Driver Code","code":"< ? php function unitDigitXRaisedY ( $ x , $ y ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ y ; $ i ++ ) $ res = ( $ res * $ x ) % 10 ; return $ res ; } echo ( unitDigitXRaisedY ( 4 , 2 ) ) ; ? >"}
{"text":"Max occurring divisor in an interval | function to find max occurring divisor interval [ x , y ] ; if there is only one number in the in the interval , return that number ; otherwise , 2 is the max occurring divisor ; Driver code","code":"< ? php function findDivisor ( $ x , $ y ) { if ( $ x == $ y ) return $ y ; return 2 ; } $ x = 3 ; $ y = 16 ; echo findDivisor ( $ x , $ y ) ; ? >"}
{"text":"Average of Squares of Natural Numbers | Function to calculate average of square number ; Driver code","code":"< ? php function AvgofSquareN ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum \/ $ n ; } $ n = 2 ; echo ( AvgofSquareN ( $ n ) ) ; ? >"}
{"text":"Find sum of even factors of a number | Returns sum of all factors of n . ; If n is odd , then there are no even factors . ; Traversing through all prime factors . ; While i divides n , print i and divide n ; here we remove the 2 ^ 0 that is 1. All other factors ; This condition is to handle the case when n is a prime number . ; Driver code","code":"< ? php function sumofFactors ( $ n ) { if ( $ n % 2 != 0 ) return 0 ; $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = floor ( $ n \/ $ i ) ; if ( $ i == 2 && $ count == 1 ) $ curr_sum = 0 ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } $ n = 18 ; echo sumofFactors ( $ n ) ; ? >"}
{"text":"Program to determine focal length of a spherical mirror | Determines focal length of a spherical concave mirror ; Determines focal length of a spherical convex mirror ; Driver function","code":"< ? php function focal_length_concave ( $ R ) { return $ R \/ 2 ; } function focal_length_convex ( $ R ) { return - ( $ R \/ 2 ) ; } $ R = 30 ; echo \" Focal \u2581 length \u2581 of \u2581 spherical \" , \" concave \u2581 mirror \u2581 is \u2581 : \u2581 \" , focal_length_concave ( $ R ) , \" \u2581 units STRNEWLINE \" ; echo \" Focal \u2581 length \u2581 of \u2581 spherical \" , \" \u2581 convex \u2581 mirror \u2581 is \u2581 : \u2581 \" , focal_length_convex ( $ R ) , \" \u2581 units \" ; ? >"}
{"text":"Find sum of odd factors of a number | Returns sum of all factors of n . ; Traversing through all prime factors . ; ignore even factors by removing all powers of 2 ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number . ; Driver code","code":"< ? php function sumofoddFactors ( $ n ) { $ res = 1 ; while ( $ n % 2 == 0 ) $ n = $ n \/ 2 ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n \/ $ i ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } $ n = 30 ; echo sumofoddFactors ( $ n ) ; ? >"}
{"text":"Number of non | return number of non negative integral solutions ; initialize total = 0 ; Base Case if n = 1 and val >= 0 then it should return 1 ; iterate the loop till equal the val ; total solution of equations and again call the recursive function Solutions ( variable , value ) ; return the total no possible solution ; Driver Code","code":"< ? php function countSolutions ( $ n , $ val ) { $ total = 0 ; if ( $ n == 1 && $ val >= 0 ) return 1 ; for ( $ i = 0 ; $ i <= $ val ; $ i ++ ) { $ total += countSolutions ( $ n - 1 , $ val - $ i ) ; } return $ total ; } $ n = 5 ; $ val = 20 ; echo countSolutions ( $ n , $ val ) ; ? >"}
{"text":"Fibonomial coefficient and Fibonomial triangle | PHP Program to print Fibonomial Triangle of height n . ; Function to produce Fibonacci Series . ; 0 th and 1 st number of the series are 0 and 1 ; Add the previous 2 numbers in the series and store it ; Function to produce fibonomial coefficient ; Function to print Fibonomial Triangle . ; Finding the fibonacci series . ; to store triangle value . ; initialising the 0 th element of each row and diagonal element equal to 0. ; for each row . ; for each column . ; finding each element using recurrence relation . ; printing the Fibonomial Triangle . ; Driven Program","code":"< ? php $ N = 6 ; function fib ( & $ f , $ n ) { $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ f [ $ i ] = $ f [ $ i - 1 ] + $ f [ $ i - 2 ] ; } function fibcoef ( $ fc , $ f , $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ fc [ $ i ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ k = $ j ; while ( $ k -- ) $ fc [ $ i ] [ $ j ] *= $ f [ $ k ] ; $ k = 1 ; while ( ( $ j + 1 ) != $ k ) $ fc [ $ i ] [ $ j ] \/= $ f [ $ k ++ ] ; } } } function printFibonomialTriangle ( $ n ) { global $ N ; $ f = array_fill ( 0 , $ N + 1 , 0 ) ; fib ( $ f , $ n ) ; $ dp = array_fill ( 0 , $ N + 1 , array_fill ( 0 , $ N + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ f [ $ i - $ j + 1 ] * $ dp [ $ i - 1 ] [ $ j - 1 ] + $ f [ $ j - 1 ] * $ dp [ $ i - 1 ] [ $ j ] ; } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo $ dp [ $ i ] [ $ j ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } } $ n = 6 ; printFibonomialTriangle ( $ n ) ; ? >"}
{"text":"Sum of Arithmetic Geometric Sequence | Return the sum of first n term of AGP ; finding the each term of AGP and adding it to sum . ; Driver Code","code":"< ? php function sumofNterm ( $ a , $ d , $ b , $ r , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ a + ( $ i - 1 ) * $ d ) * ( $ b * pow ( $ r , $ i - 1 ) ) ) ; return $ sum ; } $ a = 1 ; $ d = 1 ; $ b = 2 ; $ r = 2 ; $ n = 3 ; echo ( sumofNterm ( $ a , $ d , $ b , $ r , $ n ) ) ; ? >"}
{"text":"Sum of the series 2 + ( 2 + 4 ) + ( 2 + 4 + 6 ) + ( 2 + 4 + 6 + 8 ) + \u2026\u2026 + ( 2 + 4 + 6 + 8 + \u2026 . + 2 n ) | function to find the sum of the given series ; first term of each i - th term ; next term ; required sum ; Driver program to test above","code":"< ? php function sumOfTheSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ k = 2 ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ sum += $ k ; $ k += 2 ; } } return $ sum ; } $ n = 5 ; echo \" Sum = \" ? >"}
{"text":"Program to find sum of series 1 * 2 * 3 + 2 * 3 * 4 + 3 * 4 * 5 + . . . + n * ( n + 1 ) * ( n + 2 ) | Function to calculate sum of series . ; Driver Code","code":"< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * ( $ i + 1 ) * ( $ i + 2 ) ; return $ sum ; } $ n = 10 ; echo sumOfSeries ( $ n ) ; ? >"}
{"text":"Program to get the Sum of series : 1 | Function to get the series ; Sum of n - 1 terms starting from 2 nd term ; Driver Code","code":"< ? php function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct ; $ j ; $ y = 2 ; $ m ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = 1 ; for ( $ j = 1 ; $ j <= $ y ; $ j ++ ) { $ fct = $ fct * $ j ; } $ term = $ term * ( -1 ) ; $ m = $ term * pow ( $ x , $ y ) \/ $ fct ; $ sum = $ sum + $ m ; $ y += 2 ; } return $ sum ; } $ x = 9 ; $ n = 10 ; $ precision = 4 ; echo substr ( number_format ( Series ( $ x , $ n ) , $ precision + 1 , ' . ' , ' ' ) , 0 , -1 ) ; ? >"}
{"text":"Program to get the Sum of series : 1 | Function to get the series ; Computing sum of remaining n - 1 terms . ; Driver Code","code":"< ? php function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct = 1 ; $ p = 1 ; $ multi = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = $ fct * $ multi * ( $ multi + 1 ) ; $ p = $ p * $ x * $ x ; $ term = ( -1 ) * $ term ; $ multi += 2 ; $ sum = $ sum + ( $ term * $ p ) \/ $ fct ; } return $ sum ; } $ x = 9 ; $ n = 10 ; $ precision = 4 ; echo substr ( number_format ( Series ( $ x , $ n ) , $ precision + 1 , ' . ' , ' ' ) , 0 , -1 ) ; ? >"}
{"text":"Find the number of consecutive zero at the end after multiplying n numbers | Function to count two 's factor ; Count number of 2 s present in n ; Function to count five 's factor ; Function to count number of zeros ; Count the two 's  factor of n number ; Count the five 's  factor of n number ; Return the minimum ; Driver Code","code":"< ? php function two_factor ( $ n ) { $ twocount = 0 ; while ( $ n % 2 == 0 ) { $ twocount ++ ; $ n = ( int ) ( $ n \/ 2 ) ; } return $ twocount ; } function five_factor ( $ n ) { $ fivecount = 0 ; while ( $ n % 5 == 0 ) { $ fivecount ++ ; $ n = ( int ) ( $ n \/ 5 ) ; } return $ fivecount ; } function find_con_zero ( $ arr , $ n ) { $ twocount = 0 ; $ fivecount = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ twocount += two_factor ( $ arr [ $ i ] ) ; $ fivecount += five_factor ( $ arr [ $ i ] ) ; } if ( $ twocount < $ fivecount ) return $ twocount ; else return $ fivecount ; } $ arr = array ( 100 , 10 , 5 , 25 , 35 , 14 ) ; $ n = 6 ; echo find_con_zero ( $ arr , $ n ) ; ? >"}
{"text":"First occurrence of a digit in a given fraction | function to print the first digit ; reduce the number to its mod ; traverse for every decimal places ; get every fraction places when ( a * 10 \/ b ) \/ c ; check if it is equal to the required integer ; mod the number ; Driver Code","code":"< ? php function first ( $ a , $ b , $ c ) { $ a %= $ b ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) { $ a = $ a * 10 ; if ( $ a \/ $ b == $ c ) return $ i ; $ a %= $ b ; } return -1 ; } $ a = 1 ; $ b = 4 ; $ c = 5 ; echo first ( $ a , $ b , $ c ) ; ? >"}
{"text":"Minimize the absolute difference of sum of two subsets | function to print difference ; summation of n elements ; if divisible by 4 ; if remainder 1 or 2. In case of remainder 2 , we divide elements from 3 to n in groups of size 4 and put 1 in one group and 2 in group . This also makes difference 1. ; We put elements from 4 to n in groups of size 4. Remaining elements 1 , 2 and 3 can be divided as ( 1 , 2 ) and ( 3 ) . ; Driver code","code":"< ? php function subsetDifference ( $ n ) { $ s = $ n * ( $ n + 1 ) \/ 2 ; if ( $ n % 4 == 0 ) { echo \" First \u2581 subset \u2581 sum \u2581 = \u2581 \" , floor ( $ s \/ 2 ) ; echo \" Second subset sum = \" , floor ( $ s \/ 2 ) ; echo \" Difference = \" } else { if ( $ n % 4 == 1 $ n % 4 == 2 ) { echo \" First \u2581 subset \u2581 sum \u2581 = \u2581 \" , floor ( $ s \/ 2 ) ; echo \" Second subset sum = \" , floor ( $ s \/ 2 + 1 ) ; echo \" Difference = \" } else { echo \" First \u2581 subset \u2581 sum \u2581 = \u2581 \" , floor ( $ s \/ 2 ) ; echo \" Second subset sum = \" , floor ( $ s \/ 2 ) ; echo \" Difference = \" \u2581 , \u2581 0 ; } } } $ n = 6 ; subsetDifference ( $ n ) ; ? >"}
{"text":"Time required to meet in equilateral triangle | function to calculate time to meet ; Driver Code","code":"< ? php function timeToMeet ( $ s , $ v ) { $ V = 3 * $ v \/ 2 ; $ time = $ s \/ $ V ; echo $ time ; } $ s = 25 ; $ v = 56 ; timeToMeet ( $ s , $ v ) ; ? >"}
{"text":"Check if a number can be written as sum of three consecutive integers | function to check if a number can be written as sum of three consecutive integer . ; if n is 0 ; if n is positive , increment loop by 1. ; if n is negative , decrement loop by 1. ; Running loop from 0 to n - 2 ; check if sum of three consecutive integer is equal to n . ; Driver Code","code":"< ? php function checksum ( $ n ) { if ( $ n == 0 ) { echo \" - 1 \u2581 0 \u2581 1\" ; return ; } $ inc ; if ( $ n > 0 ) $ inc = 1 ; else $ inc = -1 ; for ( $ i = 0 ; $ i <= $ n - 2 ; $ i += $ inc ) { if ( $ i + $ i + 1 + $ i + 2 == $ n ) { echo $ i , \" \u2581 \" , $ i + 1 , \" \u2581 \" , $ i + 2 ; return ; } } echo \" - 1\" ; } $ n = 6 ; checksum ( $ n ) ; ? >"}
{"text":"Sum of all divisors from 1 to n | Utility function to find sum of all divisor of number up to ' n ' ; Find all divisors of i and add them ; Driver code","code":"< ? php function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j * $ j <= $ i ; ++ $ j ) { if ( $ i % $ j == 0 ) { if ( $ i \/ $ j == $ j ) $ sum += $ j ; else $ sum += $ j + $ i \/ $ j ; } } } return $ sum ; } $ n = 4 ; echo \" \" , \u2581 divisorSum ( $ n ) , \u2581 \" \" $ n = 5 ; echo divisorSum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program for Binomial Coefficients table | Function to print binomial table ; B ( m , x ) is 1 if either m or x is 0. ; Otherwise using recursive formula B ( m , x ) = B ( m , x - 1 ) * ( m - x + 1 ) \/ x ; Driver Code","code":"< ? php function printbinomial ( $ max ) { for ( $ m = 0 ; $ m <= $ max ; $ m ++ ) { echo $ m ; $ binom = 1 ; for ( $ x = 0 ; $ x <= $ m ; $ x ++ ) { if ( $ m != 0 && $ x != 0 ) $ binom = $ binom * ( $ m - $ x + 1 ) \/ $ x ; echo \" \u2581 \" , $ binom , \" \u2581 \" ; } echo \" STRNEWLINE \" ; } } $ max = 10 ; printbinomial ( $ max ) ; ? >"}
{"text":"Find largest prime factor of a number | A function to find largest prime factor ; Initialize the maximum prime factor variable with the lowest one ; Print the number of 2 s that divide n ; equivalent to n \/= 2 ; n must be odd at this point ; now we have to iterate only for integers who does not have prime factor 2 and 3 ; This condition is to handle the case when n is a prime number greater than 4 ; Driver Code","code":"< ? php function maxPrimeFactors ( $ n ) { $ maxPrime = -1 ; while ( $ n % 2 == 0 ) { $ maxPrime = 2 ; $ n >>= 1 ; } while ( $ n % 3 == 0 ) { $ maxPrime = 3 ; $ n = $ n \/ 3 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { while ( $ n % $ i == 0 ) { $ maxPrime = $ i ; $ n = $ n \/ $ i ; } while ( $ n % ( $ i + 2 ) == 0 ) { $ maxPrime = $ i + 2 ; $ n = $ n \/ ( $ i + 2 ) ; } } if ( $ n > 4 ) $ maxPrime = $ n ; return $ maxPrime ; } $ n = 15 ; echo maxPrimeFactors ( $ n ) , \" STRNEWLINE \" ; $ n = 25698751364526 ; echo maxPrimeFactors ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count unset bits in a range | Function to get no of set bits in the binary representation of ' n ' ; function to count unset bits in the given range ; calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; returns number of unset bits in the range ' l ' to ' r ' in ' n ' ; Driver code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function countUnsetBitsInGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; return ( $ r - $ l + 1 ) - countSetBits ( $ n & $ num ) ; } $ n = 80 ; $ l = 1 ; $ r = 4 ; echo countUnsetBitsInGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text":"Sum of fourth power of first n even natural numbers | calculate the sum of fourth power of first n even natural numbers ; made even number ; Driver Code","code":"< ? php function evenPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ j = 2 * $ i ; $ sum = $ sum + ( $ j * $ j * $ j * $ j ) ; } return $ sum ; } $ n = 5 ; echo ( evenPowerSum ( $ n ) ) ; ? >"}
{"text":"Sum of fourth power of first n even natural numbers | calculate the sum of fourth power of first n even natural numbers ; Driver Code","code":"< ? php function evenPowerSum ( $ n ) { return ( 8 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) * ( 3 * $ n * $ n + 3 * $ n - 1 ) ) \/ 15 ; } $ n = 4 ; echo ( evenPowerSum ( $ n ) ) ; ? >"}
{"text":"Balanced Prime | PHP Program to find Nth Balanced Prime ; Return the Nth balanced prime . ; Sieve of Eratosthenes ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; storing all primes ; Finding the Nth balanced Prime ; Driven Program","code":"< ? php $ MAX = 501 ; function balancedprime ( $ n ) { global $ MAX ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ v = array ( ) ; for ( $ p = 3 ; $ p <= $ MAX ; $ p += 2 ) if ( $ prime [ $ p ] ) array_push ( $ v , $ p ) ; $ count = 0 ; for ( $ i = 1 ; $ i < count ( $ v ) ; $ i ++ ) { if ( $ v [ $ i ] == ( $ v [ $ i + 1 ] + $ v [ $ i - 1 ] ) \/ 2 ) $ count ++ ; if ( $ count == $ n ) return $ v [ $ i ] ; } } $ n = 4 ; echo balancedprime ( $ n ) ; ? >"}
{"text":"Smallest integer which has n factors or more | PHP program to print the smallest integer with n factors or more ; array to store prime factors ; function to generate all prime factors of numbers from 1 to 10 ^ 6 ; Initializes all the positions with their value . ; Initializes all multiples of 2 with 2 ; A modified version of Sieve of Eratosthenes to store the smallest prime factor that divides every number . ; check if it has no prime factor . ; Initializes of j starting from i * i ; if it has no prime factor before , then stores the smallest prime divisor ; function to calculate number of factors ; stores the smallest prime number that divides n ; stores the count of number of times a prime number divides n . ; reduces to the next number after prime factorization of n ; false when prime factorization is done ; if the same prime number is dividing n , then we increase the count ; if its a new prime factor that is factorizing n , then we again set c = 1 and change dup to the new prime factor , and apply the formula explained above . ; prime factorizes a number ; for the last prime factor ; function to find the smallest integer with n factors or more . ; check if no of factors is more than n or not ; generate prime factors of number upto 10 ^ 6","code":"< ? php $ MAX = 100001 ; $ factor = array_fill ( 0 , $ MAX , 0 ) ; function generatePrimeFactors ( ) { global $ MAX ; global $ factor ; $ factor [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ factor [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAX ; $ i += 2 ) $ factor [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ factor [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) { if ( $ factor [ $ j ] == $ j ) $ factor [ $ j ] = $ i ; } } } } function calculateNoOFactors ( $ n ) { global $ factor ; if ( $ n == 1 ) return 1 ; $ ans = 1 ; $ dup = $ factor [ $ n ] ; $ c = 1 ; $ j = ( int ) ( $ n \/ $ factor [ $ n ] ) ; while ( $ j != 1 ) { if ( $ factor [ $ j ] == $ dup ) $ c += 1 ; else { $ dup = $ factor [ $ j ] ; $ ans = $ ans * ( $ c + 1 ) ; $ c = 1 ; } $ j = ( int ) ( $ j \/ $ factor [ $ j ] ) ; } $ ans = $ ans * ( $ c + 1 ) ; return $ ans ; } function smallest ( $ n ) { for ( $ i = 1 ; ; $ i ++ ) if ( calculateNoOFactors ( $ i ) >= $ n ) return $ i ; } generatePrimeFactors ( ) ; $ n = 4 ; echo smallest ( $ n ) ; ? >"}
{"text":"Sum of squares of first n natural numbers | Return the sum of square of first n natural numbers ; Iterate i from 1 and n finding square of i and add to sum . ; Driven Code","code":"< ? php function squaresum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; } $ n = 4 ; echo ( squaresum ( $ n ) ) ; ? >"}
{"text":"Break a number such that sum of maximum divisors of all parts is minimum | Function to check if a number is prime or not . ; If n is an even number ( we can write it as sum of two primes ) ; If n is odd and n - 2 is prime . ; If n is odd , n - 3 must be even . ; Driver code","code":"< ? php function isPrime ( $ n ) { $ i = 2 ; while ( $ i * $ i <= $ n ) { if ( $ n % $ i == 0 ) return false ; $ i ++ ; } return true ; } function minimumSum ( $ n ) { if ( isPrime ( $ n ) ) return 1 ; if ( $ n % 2 == 0 ) return 2 ; if ( isPrime ( $ n - 2 ) ) return 2 ; return 3 ; } $ n = 27 ; echo minimumSum ( $ n ) ; ? >"}
{"text":"Find first and last digits of a number | Find the first digit ; Remove last digit from number till only one digit is left ; return the first digit ; Find the last digit ; return the last digit ; Driver Code","code":"< ? php function firstDigit ( $ n ) { while ( $ n >= 10 ) $ n \/= 10 ; return ( int ) $ n ; } function lastDigit ( $ n ) { return ( ( int ) $ n % 10 ) ; } $ n = 98562 ; echo firstDigit ( $ n ) . \" \u2581 \" . lastDigit ( $ n ) . \" STRNEWLINE \" ;"}
{"text":"Find first and last digits of a number | Find the first digit ; Find total number of digits - 1 ; Find first digit ; Return first digit ; Find the last digit ; return the last digit ; Driver Code","code":"< ? php function firstDigit ( $ n ) { $ digits = ( int ) log10 ( $ n ) ; $ n = ( int ) ( $ n \/ pow ( 10 , $ digits ) ) ; return $ n ; } function lastDigit ( $ n ) { return ( $ n % 10 ) ; } $ n = 98562 ; echo firstDigit ( $ n ) , \" \" , lastDigit ( $ n ) , \" \" ; ? >"}
{"text":"Express an odd number as sum of prime numbers | Function to check if a number is prime or not . ; Prints at most three prime numbers whose sum is n . ; CASE - I ; CASE - II ; CASE - III ; Driver code","code":"< ? php function isPrime ( $ x ) { if ( $ x == 0 $ x == 1 ) return false ; for ( $ i = 2 ; $ i * $ i <= $ x ; ++ $ i ) if ( $ x % $ i == 0 ) return false ; return true ; } function findPrimes ( $ n ) { if ( isPrime ( $ n ) ) echo ( $ n ) ; else if ( isPrime ( $ n - 2 ) ) echo ( 2 . \" \u2581 \" . ( $ n - 2 ) ) ; else { echo ( 3 . \" \u2581 \" ) ; $ n = $ n - 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPrime ( $ i ) && isPrime ( $ n - $ i ) ) { echo ( $ i . \" \" . ( $ n - $ i ) ) ; break ; } } } } $ n = 27 ; findPrimes ( $ n ) ; ? >"}
{"text":"AKS Primality Test | array used to store coefficients . ; function to calculate the coefficients of ( x - 1 ) ^ n - ( x ^ n - 1 ) with the help of Pascal 's triangle . ; function to check whether the number is prime or not ; Calculating all the coefficients by the function coef and storing all the coefficients in c array . ; checking all the coefficients whether they are divisible by n or not . if n is not prime , then loop breaks and ( i > 0 ) . ; Return true if all coefficients are divisible by n . ; Driver Code","code":"< ? php global $ c ; function coef ( $ n ) { $ c [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ c [ 0 ] = - $ c [ 0 ] , $ i ++ ) { $ c [ 1 + $ i ] = 1 ; for ( $ j = $ i ; $ j > 0 ; $ j -- ) $ c [ $ j ] = $ c [ $ j - 1 ] - $ c [ $ j ] ; } } function isPrime ( $ n ) { global $ c ; coef ( $ n ) ; $ i = $ n ; while ( $ i -- && $ c [ $ i ] % $ n == 0 ) return $ i < 0 ; } $ n = 37 ; if ( isPrime ( $ n ) ) echo \" Not \u2581 Prime \" , \" STRNEWLINE \" ; else echo \" Prime \" , \" STRNEWLINE \" ; ? >"}
{"text":"Motzkin number | Return the nth Motzkin Number . ; Base Case ; Recursive step ; Driven Code","code":"< ? php function motzkin ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return ( ( 2 * $ n + 1 ) * motzkin ( $ n - 1 ) + ( 3 * $ n - 3 ) * motzkin ( $ n - 2 ) ) \/ ( $ n + 2 ) ; } $ n = 8 ; echo ( motzkin ( $ n ) ) ; ? >"}
{"text":"Sum of the series 0.6 , 0.06 , 0.006 , 0.0006 , ... to n terms | function which return the the sum of series ; Driver code","code":"< ? php function sumOfSeries ( $ n ) { return ( 0.666 ) * ( 1 - 1 \/ pow ( 10 , $ n ) ) ; } $ n = 2 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Narcissistic number | Function to count digits ; Returns true if n is Narcissistic number ; count the number of digits ; calculates the sum of digits raised to power ; Driver Code","code":"< ? php function countDigit ( $ n ) { if ( $ n == 0 ) return 0 ; return ( 1 + countDigit ( $ n \/ 10 ) ) ; } function check ( $ n ) { $ l = countDigit ( $ n ) ; $ dup = $ n ; $ sum = 0 ; while ( $ dup ) { $ sum += pow ( $ dup % 10 , $ l ) ; $ dup = ( int ) $ dup \/ 10 ; } return ( $ n == $ sum ) ; } $ n = 1634 ; if ( check ( ! $ n ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text":"Sum of squares of first n natural numbers | Function to calculate sum ; Driver code","code":"< ? php function summation ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; } $ n = 2 ; echo summation ( $ n ) ; ? >"}
{"text":"Leyland Number | PHP program to print first N Leyland Numbers . ; Print first n Leyland Number . ; Outer loop for x from 2 to n . ; Inner loop for y from 2 to x . ; Calculating x ^ y + y ^ x ; Sorting the all Leyland Number . ; Printing first n Leyland number . ; Driver Code","code":"< ? php $ MAX = 100 ; function leyland ( $ n ) { $ ans ; $ index = 0 ; for ( $ x = 2 ; $ x <= $ n ; $ x ++ ) { for ( $ y = 2 ; $ y <= $ x ; $ y ++ ) { $ temp = pow ( $ x , $ y ) + pow ( $ y , $ x ) ; $ ans [ $ index ] = $ temp ; $ index ++ ; } } sort ( $ ans ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ ans [ $ i ] . \" \u2581 \" ; } $ n = 6 ; leyland ( $ n ) ; ? >"}
{"text":"Nicomachus\u00e2 \u20ac\u2122 s Theorem ( Sum of k | Return the sum of k - th group of positive odd integers . ; Finding first element of kth group . ; Finding the sum . ; Driver code","code":"< ? php function kthgroupsum ( $ k ) { $ cur = ( $ k * ( $ k - 1 ) ) + 1 ; $ sum = 0 ; while ( $ k -- ) { $ sum += $ cur ; $ cur += 2 ; } return $ sum ; } $ k = 3 ; echo kthgroupsum ( $ k ) ; ? >"}
{"text":"n | Returns n - th term of the series 2 , 12 , 36 , 80 , 150 ; driver code","code":"< ? php function nthTerm ( $ n ) { return ( $ n * $ n ) + ( $ n * $ n * $ n ) ; } $ n = 4 ; echo ( nthTerm ( $ n ) ) ; ? >"}
{"text":"Sum of the series 1 , 3 , 6 , 10. . . ( Triangular Numbers ) | Function to find the sum of series ; Driver code","code":"< ? php function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) \/ 6 ; } $ n = 4 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text":"Calculate speed , distance and time | Function to calculate speed ; Function to calculate distance traveled ; Function to calculate time taken ; Calling function cal_speed ( ) ; Calling function cal_dis ( ) ; Calling function cal_time ( )","code":"< ? php function cal_speed ( $ dist , $ time ) { echo \" Distance ( km ) : \" echo \" Time ( hr ) : \" return $ dist \/ $ time ; } function cal_dis ( $ speed , $ time ) { echo \" Time ( hr ) : \" echo \" Speed ( km \/ hr ) : \" return $ speed * $ time ; } function cal_time ( $ dist , $ speed ) { echo \" Distance ( km ) : \" echo \" Speed ( km \/ hr ) : \" return $ speed * $ dist ; } echo \" \u2581 The \u2581 calculated \u2581 Speed ( km \u2581 \/ \u2581 hr ) \u2581 is \u2581 : \u2581 \" . cal_speed ( 45.9 , 2.0 ) . \" STRNEWLINE \" ; echo \" The calculated Distance ( km ) : \" . cal_dis ( 62.9 , 2.5 ) . \" \" ; echo \" The calculated Time ( hr ) : \" . cal_time ( 48.0 , 4.5 ) . \" \" ; ? >"}
{"text":"Print factorials of a range in right aligned format | PHP Program to print format of factorial ; vector for store the result ; variable for store the each number factorial ; copy of first number ; found first number factorial ; push the first number in result vector ; incerement the first number ; found the all reaming number factorial loop is working until all required number factorial founded ; store the result of factorial ; incerement the first number ; return the result ; function for print the result ; setw ( ) is used for fill the blank right is used for right justification of data ; number which found the factorial of between range ; store the result of factorial ; function for found factorial ; function for print format","code":"< ? php function find_factorial ( $ num1 , $ num2 ) { $ vec ; $ t = 0 ; $ fac = 1 ; $ temp = $ num1 ; while ( 1 ) { if ( $ temp == 1 ) break ; $ fac *= $ temp ; $ temp -- ; } $ vec [ $ t ++ ] = $ fac ; $ num1 ++ ; while ( $ num1 <= $ num2 ) { $ fac *= $ num1 ; $ vec [ $ t ++ ] = $ fac ; $ num1 ++ ; } return ( $ vec ) ; } function print_format ( $ result ) { $ x = count ( $ result ) ; $ digits = strlen ( ( string ) $ result [ $ x - 1 ] ) ; for ( $ i = 0 ; $ i < $ x ; $ i ++ ) { echo str_pad ( $ result [ $ i ] , ( $ digits + 1 ) , \" \" , \u2581 STR _ PAD _ LEFT ) \u2581 . \u2581 \" \" } } $ m = 10 ; $ n = 20 ; $ result_fac ; $ result_fac = find_factorial ( $ m , $ n ) ; print_format ( $ result_fac ) ; ? >"}
{"text":"Find n | Function to find the nth term of series ; Loop to add numbers ; Driver code","code":"< ? php function term ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i ; return $ ans ; } $ n = 4 ; echo ( term ( $ n ) ) ; ? >"}
{"text":"Find the average of first N natural numbers | Return the average of first n natural numbers ; Driver Code","code":"< ? php function avgOfFirstN ( $ n ) { return ( float ) ( 1 + $ n ) \/ 2 ; } $ n = 20 ; echo ( avgOfFirstN ( $ n ) ) ; ? >"}
{"text":"Find the sum of the series 1 + 11 + 111 + 1111 + ... . . upto n terms | Function for finding summation ; Driver Code","code":"< ? php function summation ( $ n ) { $ sum ; $ sum = ( pow ( 10 , $ n + 1 ) - 10 - ( 9 * $ n ) ) \/ 81 ; return $ sum ; } $ n = 5 ; echo summation ( $ n ) ; ? >"}
{"text":"Sum of the Series 1 + x \/ 1 + x ^ 2 \/ 2 + x ^ 3 \/ 3 + . . + x ^ n \/ n | code to print the sum of the series ; Driver code","code":"< ? php function sum ( $ x , $ n ) { $ i ; $ total = 1.0 ; $ multi = $ x ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ total = $ total + $ multi \/ $ i ; $ multi = $ multi * $ x ; } return $ total ; } $ x = 2 ; $ n = 5 ; echo ( sum ( $ x , $ n ) ) ; ? >"}
{"text":"Find n | function to solve the quadratic equation ; calculating the Nth term ; Driver Code","code":"< ? php function term ( $ n ) { $ x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * $ n ) ) ) \/ 2 ) ; return $ x ; } $ n = 5 ; echo ( ( int ) term ( $ n ) ) ; ? >"}
{"text":"Deserium Number | Returns count of digits in n . ; Returns true if x is Diserium ; Compute powers of digits from right to left . ; If sum of powers is same as given number . ; Driver Code","code":"< ? php function countDigits ( $ n ) { $ c = 0 ; do { $ c ++ ; $ n = $ n \/ 10 ; } while ( $ n != 0 ) ; return $ c ; } function isDeserium ( $ x ) { $ temp = $ x ; $ p = countDigits ( $ x ) ; $ sum = 0 ; while ( $ x != 0 ) { $ digit = $ x % 10 ; $ sum += pow ( $ digit , $ p ) ; $ p -- ; $ x = $ x \/ 10 ; } return ( $ sum == $ temp ) ; } $ x = 135 ; if ( isDeserium ( $ x ) ) echo \" No \" ; else echo \" Yes \" ; ? >"}
{"text":"Largest number by which given 3 numbers should be divided such that they leaves same remainder | __gcd function ; function return number which divides these three number and leaves same remainder . ; We find the differences of all three pairs ; Return GCD of three differences . ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function sameRemainder ( $ a , $ b , $ c ) { $ a1 = ( $ b - $ a ) ; $ b1 = ( $ c - $ b ) ; $ c1 = ( $ c - $ a ) ; return gcd ( $ a1 , gcd ( $ b1 , $ c1 ) ) ; } $ a = 62 ; $ b = 132 ; $ c = 237 ; echo sameRemainder ( $ a , $ b , $ c ) ; ? >"}
{"text":"Find combined mean and variance of two series | Function to find mean of series . ; Function to find the standard deviation of series . ; Function to find combined variance of two different series . ; mean1 and mean2 are the mean of two arrays . ; sd1 and sd2 are the standard deviation of two array . ; combinedMean is variable to store the combined mean of both array . ; d1_square and d2_square are the combined mean deviation . ; combinedVar is variable to store combined variance of both array . ; Driver Code ; Function call to combined mean .","code":"< ? php function mean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + $ arr [ $ i ] ; $ mean = ( float ) ( $ sum \/ $ n ) ; return $ mean ; } function sd ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) * ( $ arr [ $ i ] - mean ( $ arr , $ n ) ) ; $ sdd = $ sum \/ $ n ; return $ sdd ; } function combinedVariance ( $ arr1 , $ arr2 , $ n , $ m ) { $ mean1 = mean ( $ arr1 , $ n ) ; $ mean2 = mean ( $ arr2 , $ m ) ; echo ( \" Mean1 : \u2581 \" . round ( $ mean1 , 2 ) . \" \" \u2581 . STRNEWLINE TABSYMBOL TABSYMBOL \" mean2 : \" $ sd1 = sd ( $ arr1 , $ n ) ; $ sd2 = sd ( $ arr2 , $ m ) ; echo ( \" StandardDeviation1 : \" \u2581 . \u2581 round ( $ sd1 , \u2581 2 ) \u2581 . \u2581 \" \" STRNEWLINE TABSYMBOL TABSYMBOL . \u2581 \" StandardDeviation2 : \" $ combinedMean = ( float ) ( $ n * $ mean1 + $ m * $ mean2 ) \/ ( $ n + $ m ) ; echo ( \" Combined Mean : \" round ( $ combinedMean , 2 ) ) ; $ d1_square = ( $ mean1 - $ combinedMean ) * ( $ mean1 - $ combinedMean ) ; $ d2_square = ( $ mean2 - $ combinedMean ) * ( $ mean2 - $ combinedMean ) ; echo ( \" d1 square : \" \u2581 . \u2581 round ( $ d1 _ square , \u2581 2 ) \u2581 . \u2581 \" \" STRNEWLINE TABSYMBOL TABSYMBOL . \u2581 \" d2_square : \" $ combinedVar = ( $ n * ( $ sd1 + $ d1_square ) + $ m * ( $ sd2 + $ d2_square ) ) \/ ( $ n + $ m ) ; return $ combinedVar ; } $ arr1 = array ( 23 , 45 , 34 , 78 , 12 , 76 , 34 ) ; $ arr2 = array ( 65 , 67 , 34 , 23 , 45 ) ; $ n = sizeof ( $ arr1 ) ; $ m = sizeof ( $ arr2 ) ; echo ( \" Combined Variance : \" . round ( combinedVariance ( $ arr1 , $ arr2 , $ n , $ m ) , 2 ) ) ; ? >"}
{"text":"Check if a large number is divisible by 13 or not | Returns true if number is divisible by 13 else returns false ; Append required 0 s at the beginning . ; Same as strcat ( num , \"00\" ) ; in c . ; Same as strcat ( num , \"0\" ) ; in c . ; Alternatively add \/ subtract digits in group of three to result . ; Store group of three numbers in group variable . ; Generate alternate series of plus and minus ; Driver code","code":"< ? php function checkDivisibility ( $ num ) { $ length = strlen ( $ num ) ; if ( $ length == 1 && $ num [ 0 ] == '0' ) return true ; if ( $ length % 3 == 1 ) { $ num += \"00\" ; $ length += 2 ; } else if ( $ length % 3 == 2 ) { $ num += \"0\" ; $ length += 1 ; } $ sum = 0 ; $ p = 1 ; for ( $ i = $ length - 1 ; $ i >= 0 ; $ i -- ) { $ group = 0 ; $ group += $ num [ $ i -- ] - '0' ; $ group += ( $ num [ $ i -- ] - '0' ) * 10 ; $ group += ( $ num [ $ i ] - '0' ) * 100 ; $ sum = $ sum + $ group * $ p ; $ p *= ( -1 ) ; } $ sum = abs ( $ sum ) ; return ( $ sum % 13 == 0 ) ; } $ number = \"83959092724\" ; if ( checkDivisibility ( $ number ) ) echo ( $ number . \" \u2581 is \u2581 divisible \u2581 by \u2581 13 . \" ) ; else echo ( $ number . \" \u2581 is \u2581 not \u2581 divisible \u2581 by \u2581 13 . \" ) ; ? >"}
{"text":"Given two numbers a and b find all x such that a % x = b | PHP program to find x such that a % x is equal to b . ; if a is less than b then no solution ; if a is equal to b then every number greater than a will be the solution so its infinity ; count variable store the number of values possible ; checking for both divisor and quotient whether they divide ( a - b ) completely and greater than b . ; Here y is added twice in the last iteration so 1 y should be decremented to get correct solution ; Driver Code","code":"< ? php function modularEquation ( $ a , $ b ) { if ( $ a < $ b ) { echo \" No \u2581 solution \u2581 possible \u2581 \" ; return ; } if ( $ a == $ b ) { echo \" Infinite \u2581 Solution \u2581 possible \u2581 \" ; return ; } $ count = 0 ; $ n = $ a - $ b ; $ y = sqrt ( $ a - $ b ) ; for ( $ i = 1 ; $ i <= $ y ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i > $ b ) $ count ++ ; if ( $ i > $ b ) $ count ++ ; } } if ( $ y * $ y == $ n && $ y > $ b ) $ count -- ; echo $ count ; } $ a = 21 ; $ b = 5 ; modularEquation ( $ a , $ b ) ; ? >"}
{"text":"Count different numbers that can be generated such that there digits sum is equal to ' n ' | Function to count ' num ' as sum of digits ( 1 , 2 , 3 , 4 ) ; Initialize dp [ ] array ; Base case ; Initialize the current dp [ ] array as '0' ; if i == j then there is only one way to write with element itself ' i ' ; If j == 1 , then there exist two ways , one from '1' and other from '4' ; if i - j is positive then pick the element from ' i - j ' element of dp [ ] array ; Check for modulas ; return the final answer ; Driver code","code":"< ? php function countWays ( $ num ) { $ dp [ $ num + 1 ] = array ( ) ; $ MOD = 100000000 + 7 ; $ dp [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ num ; ++ $ i ) { $ dp [ $ i ] = 0 ; for ( $ j = 1 ; $ j <= 3 ; ++ $ j ) { if ( $ i - $ j == 0 ) $ dp [ $ i ] += 1 ; else if ( $ j == 1 ) $ dp [ $ i ] += $ dp [ $ i - $ j ] * 2 ; else if ( $ i - $ j > 0 ) $ dp [ $ i ] += $ dp [ $ i - $ j ] ; if ( $ dp [ $ i ] >= $ MOD ) $ dp [ $ i ] %= $ MOD ; } } return $ dp [ $ num ] ; } $ n = 3 ; echo countWays ( $ n ) ; ? >"}
{"text":"Check whether a number can be represented by sum of two squares | Check whether a number can be represented by sum of two squares using Fermat Theorem . ; Count all the prime factors . ; Ifany prime factor of the form ( 4 k + 3 ) ( 4 k + 3 ) occurs an odd number of times . ; If n itself is a x prime number and can be expressed in the form of 4 k + 3 we return false . ; Driver Code","code":"< ? php function judgeSquareSum ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ count = 0 ; if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) { $ count ++ ; $ n = ( int ) $ n \/ $ i ; } if ( $ i % 4 == 3 && $ count % 2 != 0 ) return false ; } } return $ n % 4 != 3 ; } $ n = 17 ; if ( judgeSquareSum ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Total no of 1 's in numbers | function to count the frequency of 1. ; Driver Code","code":"< ? php function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) { $ divider = $ i * 10 ; $ countr += ( int ) ( $ n \/ $ divider ) * $ i + min ( max ( $ n % $ divider - $ i + 1 , 0 ) , $ i ) ; } return $ countr ; } $ n = 13 ; echo countDigitOne ( $ n ) , \" STRNEWLINE \" ; $ n = 113 ; echo countDigitOne ( $ n ) , \" STRNEWLINE \" ; $ n = 205 ; echo countDigitOne ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Largest number with prime digits | check if character is prime ; replace with previous prime character ; if 2 erase s [ i ] and replace next with 7 ; find first non prime char ; find first char greater than 2 ; like 20 ; like 7721 ; replace remaining with 7 ; Driver code","code":"< ? php function isPrime ( $ c ) { return ( $ c == '2' $ c == '3' $ c == '5' $ c == '7' ) ? 1 : 0 ; } function decrease ( $ s , $ i ) { if ( $ s [ $ i ] <= '2' ) { $ s [ $ i ] = ' * ' ; $ a = str_split ( $ s ) ; $ s = \" \" ; for ( $ h = 0 ; $ h < count ( $ a ) ; $ h ++ ) if ( $ a [ $ h ] != ' * ' ) $ s = $ s . $ a [ $ h ] ; $ s [ $ i ] = '7' ; } else if ( $ s [ $ i ] == '3' ) $ s [ $ i ] = '2' ; else if ( $ s [ $ i ] <= '5' ) $ s [ $ i ] = '3' ; else if ( $ s [ $ i ] <= '7' ) $ s [ $ i ] = '5' ; else $ s [ $ i ] = '7' ; return $ s ; } function primeDigits ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( isPrime ( $ s [ $ i ] ) == 0 ) { while ( $ i >= 0 && $ s [ $ i ] <= '2' ) -- $ i ; if ( $ i < 0 ) { $ i = 0 ; $ s = decrease ( $ s , $ i ) ; } else $ s = decrease ( $ s , $ i ) ; for ( $ j = $ i + 1 ; $ j < strlen ( $ s ) ; $ j ++ ) $ s [ $ j ] = '7' ; break ; } } return $ s ; } $ s = \"45\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"1000\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"7721\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"7221\" ; echo primeDigits ( $ s ) . \" STRNEWLINE \" ; $ s = \"74545678912345689748593275897894708927680\" ; echo primeDigits ( $ s ) ; ? >"}
{"text":"Print digit 's position to be removed to make a number divisible by 6 | Function to print the number divisible by 6 after exactly removing a digit ; stores the sum of all elements ; traverses the string and converts string to number array and sums up ; if ( $a [ $n - 1 ] % 2 ) ODD CHECK ; if second last is odd or sum of n - 1 elements are not divisible by 3. ; second last is even and print n - 1 elements removing last digit ; last digit removed ; counter to check if any element after removing , its sum % 3 == 0 ; traverse till second last element ; to check if any element after removing , its sum % 3 == 0 ; the leftmost element ; break at the leftmost element ; stores the right most element ; if no element has been found as a [ i + 1 ] > a [ i ] ; if second last is even , then remove last if ( sum - last ) % 3 == 0 ; if no element which on removing gives sum % 3 == 0 ; Driver Code","code":"< ? php function greatest ( $ s ) { $ n = strlen ( $ s ) ; $ a [ $ n ] = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ s [ $ i ] - '0' ; $ sum += $ a [ $ i ] ; } { if ( $ a [ $ n - 2 ] % 2 != 0 or ( $ sum - $ a [ $ n - 1 ] ) % 3 != 0 ) { echo \" - 1\" , \" STRNEWLINE \" ; } else { echo $ n , \" STRNEWLINE \" ; } } else { $ re = $ sum % 3 ; $ del = -1 ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( ( $ a [ $ i ] ) % 3 == $ re ) { if ( $ a [ $ i + 1 ] > $ a [ $ i ] ) { $ del = $ i ; $ flag = 1 ; break ; } else { $ del = $ i ; } } } if ( $ flag == 0 ) { if ( $ a [ $ n - 2 ] % 2 == 0 and $ re == $ a [ $ n - 1 ] % 3 ) $ del = $ n - 1 ; } if ( $ del == -1 ) echo - 1 , \" STRNEWLINE \" ; else { echo $ del + 1 , \" STRNEWLINE \" ; } } } $ s = \"7510222\" ; greatest ( $ s ) ; ? >"}
{"text":"Representation of a number in powers of other | PHP program to check if m can be represented as powers of w . ; break ; None of 3 worked . ; If m is not zero means , it can 't be  represented in terms of powers of w. ; Driver code","code":"< ? php function asPowerSum ( $ w , $ m ) { while ( $ m ) { if ( ( $ m - 1 ) % $ w == 0 ) $ m = ( $ m - 1 ) \/ $ w ; else if ( ( $ m + 1 ) % $ w == 0 ) $ m = ( $ m + 1 ) \/ $ w ; else if ( $ m % $ w == 0 ) $ m = $ m \/ $ w ; else } return ( $ m == 0 ) ; } $ w = 3 ; $ m = 7 ; if ( asPowerSum ( $ w , $ m ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Number of digits to be removed to make a number divisible by 3 | function to count the no of removal of digits to make a very large number divisible by 3 ; add up all the digits of num ; if num is already is divisible by 3 then no digits are to be removed ; if there is single digit , then it is not possible to remove one digit . ; traverse through the number and find out if any number on removal makes the sum divisible by 3 ; if there are two numbers then it is not possible to remove two digits . ; Otherwise we can always make a number multiple of 2 by removing 2 digits . ; Driver Code","code":"< ? php function divisible ( $ num ) { $ n = strlen ( $ num ) ; $ sum = ( $ num ) ; ( $ num ) ; 0 - '0' ; if ( $ sum % 3 == 0 ) return 0 ; if ( $ n == 1 ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ sum % 3 == ( $ num [ $ i ] - '0' ) % 3 ) return 1 ; if ( $ n == 2 ) return -1 ; return 2 ; } $ num = \"1234\" ; echo divisible ( $ num ) ; ? >"}
{"text":"Program for dot product and cross product of two vectors | PHP implementation for dot product and cross product of two vector . ; Function that return dot product of two vector array . ; Loop for calculate cot product ; Function to find cross product of two vector array . ; Driver Code ; dotproduct function call ; crossproduct function call ; Loop that print cross product of two vector array .","code":"< ? php $ n = 3 ; function dotproduct ( $ vect_A , $ vect_B ) { global $ n ; $ product = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product + $ vect_A [ $ i ] * $ vect_B [ $ i ] ; return $ product ; } function crossproduct ( $ vect_A , $ vect_B , $ cross_P ) { $ cross_P [ 0 ] = $ vect_A [ 1 ] * $ vect_B [ 2 ] - $ vect_A [ 2 ] * $ vect_B [ 1 ] ; $ cross_P [ 1 ] = $ vect_A [ 2 ] * $ vect_B [ 0 ] - $ vect_A [ 0 ] * $ vect_B [ 2 ] ; $ cross_P [ 2 ] = $ vect_A [ 0 ] * $ vect_B [ 1 ] - $ vect_A [ 1 ] * $ vect_B [ 0 ] ; return $ cross_P ; } $ vect_A = array ( 3 , -5 , 4 ) ; $ vect_B = array ( 2 , 6 , 5 ) ; $ cross_P = array_fill ( 0 , $ n , 0 ) ; echo \" Dot \u2581 product : \" ; echo dotproduct ( $ vect_A , $ vect_B ) ; echo \" Cross product : \" $ cross_P = crossproduct ( $ vect_A , $ vect_B , $ cross_P ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ cross_P [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Count ways to express even number \u00e2 \u20ac\u02dc n\u00e2 \u20ac\u2122 as sum of even integers | Initialize mod variable as constant ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Return number of ways to write ' n ' as sum of even integers ; Driver code","code":"< ? php $ MOD = 1000000000.0 ; function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( 1 * $ res * $ x ) % $ p ; $ x = ( 1 * $ x * $ x ) % $ p ; } return $ res ; } function countEvenWays ( $ n ) { global $ MOD ; return power ( 2 , $ n \/ 2 - 1 , $ MOD ) ; } $ n = 6 ; echo countEvenWays ( $ n ) , \" STRNEWLINE \" ; $ n = 8 ; echo countEvenWays ( $ n ) ; ? >"}
{"text":"Number of steps to convert to prime factors | PHP program to count number of steps required to convert an integer array to array of factors . ; array to store prime factors ; function to generate all prime factors of numbers from 1 to 10 ^ 6 ; Initializes all the positions with their value . ; Initializes all multiples of 2 with 2 ; A modified version of Sieve of Eratosthenes to store the smallest prime factor that divides every number . ; check if it has no prime factor . ; Initializes of j starting from i * i ; if it has no prime factor before , then stores the smallest prime divisor ; function to calculate the number of representations ; keep an count of prime factors ; traverse for every element ; count the no of factors ; subtract 1 if Ai is not 1 as the last step wont be taken into count ; call sieve to calculate the factors","code":"< ? php $ MAX = 100001 ; $ factor = array_fill ( 0 , $ MAX + 1 , 0 ) ; function cal_factor ( ) { global $ factor , $ MAX ; $ factor [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) $ factor [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAX ; $ i += 2 ) $ factor [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ factor [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i ) { if ( $ factor [ $ j ] == $ j ) $ factor [ $ j ] = $ i ; } } } } function no_of_representations ( $ a , $ n ) { global $ factor , $ MAX ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = $ a [ $ i ] ; $ flag = 0 ; while ( $ factor [ $ temp ] != 1 ) { $ flag = -1 ; $ count ++ ; $ temp = ( int ) ( $ temp \/ $ factor [ $ temp ] ) ; } $ count += $ flag ; } return $ count ; } cal_factor ( ) ; $ a = array ( 4 , 4 , 4 ) ; $ n = count ( $ a ) ; echo no_of_representations ( $ a , $ n ) ; ? >"}
{"text":"Subsequences of size three in an array whose sum is divisible by m | Brute Force Implementation ( Time Complexity : O ( N ^ 3 ) ) PHP program to find count of subsequences of size three divisible by M . ; Three nested loop to find all the sub sequences of length three in the given array A [ ] . ; checking if the sum of the chosen three number is divisible by m . ; Driver code","code":"< ? php function coutSubSeq ( $ A , $ N , $ M ) { $ sum = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ N ; $ k ++ ) { $ sum = $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] ; if ( $ sum % $ M == 0 ) $ ans ++ ; } } } return $ ans ; } $ M = 3 ; $ A = array ( 1 , 2 , 4 , 3 ) ; $ N = count ( $ A ) ; echo coutSubSeq ( $ A , $ N , $ M ) ; ? >"}
{"text":"Subsequences of size three in an array whose sum is divisible by m | O ( M ^ 2 ) time complexity PHP program to find count of subsequences of size three divisible by M . ; Storing frequencies of all remainders when divided by M . ; including i and j in the sum rem calculate the remainder required to make the sum divisible by M ; if the required number is less than j , we skip as we have already calculated for that value before . As j here starts with i and rem is less than j . ; if satisfies the first case . ; if satisfies the second case ; if satisfies the third case ; Driver code","code":"< ? php function countSubSeq ( $ A , $ N , $ M ) { $ ans = 0 ; $ h = array_fill ( 0 , $ M , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ A [ $ i ] = $ A [ $ i ] % $ M ; $ h [ $ A [ $ i ] ] ++ ; } for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = $ i ; $ j < $ M ; $ j ++ ) { $ rem = ( $ M - ( $ i + $ j ) % $ M ) % $ M ; if ( $ rem < $ j ) continue ; if ( $ i == $ j && $ rem == $ j ) $ ans += $ h [ $ i ] * ( $ h [ $ i ] - 1 ) * ( $ h [ $ i ] - 2 ) \/ 6 ; else if ( $ i == $ j ) $ ans += $ h [ $ i ] * ( $ h [ $ i ] - 1 ) * $ h [ $ rem ] \/ 2 ; else if ( $ i == $ rem ) $ ans += $ h [ $ i ] * ( $ h [ $ i ] - 1 ) * $ h [ $ j ] \/ 2 ; else if ( $ rem == $ j ) $ ans += $ h [ $ j ] * ( $ h [ $ j ] - 1 ) * $ h [ $ i ] \/ 2 ; else $ ans = $ ans + $ h [ $ i ] * $ h [ $ j ] * $ h [ $ rem ] ; } } return $ ans ; } $ M = 3 ; $ A = array ( 1 , 2 , 4 , 3 ) ; $ N = count ( $ A ) ; echo countSubSeq ( $ A , $ N , $ M ) ; ? >"}
{"text":"Find n | utility function ; since first element of the series is 7 , we initialise a variable with 7 ; Using iteration to find nth term ; Driver Code","code":"< ? php function findTerm ( $ n ) { if ( $ n == 1 ) return $ n ; else { $ term = 7 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ term = $ term * 2 + ( $ i - 1 ) ; return $ term ; } } $ n = 5 ; echo ( findTerm ( $ n ) ) ; ? >"}
{"text":"Find n | Returns n - th number in sequence 1 , 1 , 2 , 1 , 2 , 3 , 1 , 2 , 4 , ... ; One by one subtract counts elements in different blocks ; Driver code","code":"< ? php function findNumber ( $ n ) { $ n -- ; $ i = 1 ; while ( $ n >= 0 ) { $ n -= $ i ; ++ $ i ; } return ( $ n + $ i ) ; } $ n = 3 ; echo findNumber ( $ n ) ; ? >"}
{"text":"Program to find correlation coefficient | function that returns correlation coefficient . ; sum of elements of array X . ; sum of elements of array Y . ; sum of X [ i ] * Y [ i ] . ; sum of square of array elements . ; use formula for calculating correlation coefficient . ; Driver Code ; Find the size of array . ; Function call to correlationCoefficient .","code":"< ? php function correlationCoefficient ( $ X , $ Y , $ n ) { $ sum_X = 0 ; $ sum_Y = 0 ; $ sum_XY = 0 ; $ squareSum_X = 0 ; $ squareSum_Y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_X = $ sum_X + $ X [ $ i ] ; $ sum_Y = $ sum_Y + $ Y [ $ i ] ; $ sum_XY = $ sum_XY + $ X [ $ i ] * $ Y [ $ i ] ; $ squareSum_X = $ squareSum_X + $ X [ $ i ] * $ X [ $ i ] ; $ squareSum_Y = $ squareSum_Y + $ Y [ $ i ] * $ Y [ $ i ] ; } $ corr = ( float ) ( $ n * $ sum_XY - $ sum_X * $ sum_Y ) \/ sqrt ( ( $ n * $ squareSum_X - $ sum_X * $ sum_X ) * ( $ n * $ squareSum_Y - $ sum_Y * $ sum_Y ) ) ; return $ corr ; } $ X = array ( 15 , 18 , 21 , 24 , 27 ) ; $ Y = array ( 25 , 25 , 27 , 31 , 32 ) ; $ n = sizeof ( $ X ) ; echo correlationCoefficient ( $ X , $ Y , $ n ) ; ? >"}
{"text":"Find the number of spectators standing in the stadium at time t | PHP program to find number of spectators standing at a time ; If the time is less than k then we can print directly t time . ; If the time is n then k spectators are standing . ; Otherwise we calculate the spectators standing . ; Stores the value of n , k and t t is time n & k is the number of specators","code":"< ? php function result ( $ n , $ k , $ t ) { if ( $ t <= $ k ) echo t ; else if ( $ t <= $ n ) echo k ; else { $ temp = $ t - $ n ; $ temp = $ k - $ temp ; echo $ temp ; } } $ n = 10 ; $ k = 5 ; $ t = 12 ; result ( $ n , $ k , $ t ) ; ? >"}
{"text":"Program for weighted mean of natural numbers . | Function to calculate weighted mean . ; Take num array and corresponding weight array and initialize it . ; Calculate the size of array . ; Check the size of both array is equal or not .","code":"< ? php function weightedMean ( $ X , $ W , $ n ) { $ sum = 0 ; $ numWeight = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numWeight = $ numWeight + $ X [ $ i ] * $ W [ $ i ] ; $ sum = $ sum + $ W [ $ i ] ; } return ( float ) ( $ numWeight \/ $ sum ) ; } $ X = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ W = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ n = sizeof ( $ X ) ; $ m = sizeof ( $ W ) ; if ( $ n == $ m ) echo ( weightedMean ( $ X , $ W , $ n ) ) ; else echo ( \" - 1\" ) ; ? >"}
{"text":"Program to find GCD of floating point numbers | Recursive function to return gcd of a and b ; base case ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a < $ b ) return gcd ( $ b , $ a ) ; if ( abs ( $ b ) < 0.001 ) return $ a ; else return ( gcd ( $ b , $ a - floor ( $ a \/ $ b ) * $ b ) ) ; } $ a = 1.20 ; $ b = 22.5 ; echo gcd ( $ a , $ b ) ; ? >"}
{"text":"Program for harmonic mean of numbers | Function that returns harmonic mean . ; Declare sum variables and initialize with zero ; Driver code","code":"< ? php function harmonicMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( float ) ( 1 \/ $ arr [ $ i ] ) ; return ( float ) ( $ n \/ $ sum ) ; } $ arr = array ( 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ) ; $ n = sizeof ( $ arr ) ; echo ( harmonicMean ( $ arr , $ n ) ) ; ? >"}
{"text":"Program for harmonic mean of numbers | Function that returns harmonic mean . ; Driver code","code":"< ? php function harmonicMean ( $ arr , $ freq , $ n ) { $ sum = 0 ; $ frequency_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( float ) ( $ freq [ $ i ] \/ $ arr [ $ i ] ) ; $ frequency_sum = $ frequency_sum + $ freq [ $ i ] ; } return ( $ frequency_sum \/ $ sum ) ; } $ num = array ( 13 , 14 , 15 , 16 , 17 ) ; $ freq = array ( 2 , 5 , 13 , 7 , 3 ) ; $ n = sizeof ( $ num ) ; echo ( harmonicMean ( $ num , $ freq , $ n ) ) ; ? >"}
{"text":"First collision point of two series | PHP program to calculate the colliding point of two series ; Iterating through n terms of the first series ; x is i - th term of first series ; d is first element of second series and c is common difference for second series . ; If no term of first series is found ; Driver Code","code":"< ? php function point ( $ a , $ b , $ c , $ d , $ n ) { $ x ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = $ b + $ i * $ a ; if ( ( $ x - $ d ) % $ c == 0 and $ x - $ d >= 0 ) { echo $ x ; $ flag = 1 ; break ; } } if ( $ flag == 0 ) { echo \" No \u2581 collision \u2581 po $ \" ; } } $ a = 20 ; $ b = 2 ; $ c = 9 ; $ d = 19 ; $ n = 20 ; point ( $ a , $ b , $ c , $ d , $ n ) ; ? >"}
{"text":"Armstrong Numbers between two integers | Prints Armstrong Numbers in given range ; number of digits calculation ; compute sum of nth power of its digits ; checks if number i is equal to the sum of nth power of its digits ; Driver code","code":"< ? php function findArmstrong ( $ low , $ high ) { for ( $ i = $ low + 1 ; $ i < $ high ; ++ $ i ) { $ x = $ i ; $ n = 0 ; while ( $ x != 0 ) { $ x = ( int ) ( $ x \/ 10 ) ; ++ $ n ; } $ pow_sum = 0 ; $ x = $ i ; while ( $ x != 0 ) { $ digit = $ x % 10 ; $ pow_sum += ( int ) ( pow ( $ digit , $ n ) ) ; $ x = ( int ) ( $ x \/ 10 ) ; } if ( $ pow_sum == $ i ) echo $ i . \" \" ; } } $ num1 = 100 ; $ num2 = 400 ; findArmstrong ( $ num1 , $ num2 ) ; ? >"}
{"text":"Pair with maximum GCD from two arrays | Find the maximum GCD pair with maximum sum ; array to keep a count of existing elements ; first [ i ] and second [ i ] are going to store maximum multiples of i in a [ ] and b [ ] respectively . ; traverse through the first array to mark the elements in cnt ; Find maximum multiple of every number in first array ; Find maximum multiple of every number in second array We re - initialise cnt [ ] and traverse through the second array to mark the elements in cnt ; if the multiple is present in the second array then store the max of number or the pre - existing element ; traverse for every elements and checks the maximum N that is present in both the arrays ; Driver code ; Maximum possible value of elements in both arrays .","code":"< ? php function gcdMax ( $ a , $ b , $ n , $ N ) { $ cnt = array_fill ( 0 , $ N , 0 ) ; $ first = array_fill ( 0 , $ N , 0 ) ; $ second = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cnt [ $ a [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; ++ $ i ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ first [ $ i ] = max ( $ first [ $ i ] , $ j ) ; $ cnt = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cnt [ $ b [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ second [ $ i ] = max ( $ second [ $ i ] , $ j ) ; $ x = $ N - 1 ; for ( ; $ x >= 0 ; $ x -- ) if ( $ first [ $ x ] && $ second [ $ x ] ) break ; echo $ first [ $ x ] . \" \u2581 \" . $ second [ $ x ] . \" STRNEWLINE \" ; } $ a = array ( 3 , 1 , 4 , 2 , 8 ) ; $ b = array ( 5 , 2 , 12 , 8 , 3 ) ; $ n = sizeof ( $ a ) ; $ N = 20 ; gcdMax ( $ a , $ b , $ n , $ N ) ; ? >"}
{"text":"Pierpont Prime | PHP program to print Pierpont prime numbers smaller than n . ; Finding all numbers having factor power of 2 and 3 Using sieve ; Storing number of the form 2 ^ i . 3 ^ k + 1. ; Finding prime number using sieve of Eratosthenes . Reusing same array as result of above computations in v . ; Printing n pierpont primes smaller than n ; Driver Code","code":"< ? php function printPierpont ( $ n ) { $ arr = array_fill ( 0 , $ n + 1 , false ) ; $ two = 1 ; $ three = 1 ; while ( $ two + 1 < $ n ) { $ arr [ $ two ] = true ; while ( $ two * $ three + 1 < $ n ) { $ arr [ $ three ] = true ; $ arr [ $ two * $ three ] = true ; $ three *= 3 ; } $ three = 1 ; $ two *= 2 ; } $ v ; $ x = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] ) $ v [ $ x ++ ] = $ i + 1 ; $ arr1 = array_fill ( 0 , count ( $ arr ) , false ) ; for ( $ p = 2 ; $ p * $ p < $ n ; $ p ++ ) { if ( $ arr1 [ $ p ] == false ) for ( $ i = $ p * 2 ; $ i < $ n ; $ i += $ p ) $ arr1 [ $ i ] = true ; } for ( $ i = 0 ; $ i < $ x ; $ i ++ ) if ( ! $ arr1 [ $ v [ $ i ] ] ) echo $ v [ $ i ] . \" \u2581 \" ; } $ n = 200 ; printPierpont ( $ n ) ; ? >"}
{"text":"Woodall Number | PHP program to check if a number is Woodball or not . ; If number is even , return false . ; If x is 1 , return true . ; Add 1 to make x even ; While x is divisible by 2 ; Divide x by 2 ; Count the power ; If at any point power and x became equal , return true . ; Driver Code","code":"< ? php function isWoodall ( $ x ) { if ( $ x % 2 == 0 ) return false ; if ( $ x == 1 ) return true ; $ x ++ ; $ p = 0 ; while ( $ x % 2 == 0 ) { $ x = $ x \/ 2 ; $ p ++ ; if ( $ p == $ x ) return true ; } return false ; } $ x = 383 ; if ( isWoodall ( $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Print k numbers where all pairs are divisible by m | function to generate k numbers whose difference is divisible by m ; Using an adjacency list like representation to store numbers that lead to same remainder . ; stores the modulus when divided by m ; If we found k elements which have same remainder . ; If we could not find k elements ; Driver Code","code":"< ? php function print_result ( $ a , $ n , $ k , $ m ) { $ v = array_fill ( 0 , $ m + 1 , array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ rem = $ a [ $ i ] % $ m ; array_push ( $ v [ $ rem ] , $ a [ $ i ] ) ; if ( count ( $ v [ $ rem ] ) == $ k ) { for ( $ j = 0 ; $ j < $ k ; $ j ++ ) echo $ v [ $ rem ] [ $ j ] . \" \u2581 \" ; return ; } } echo \" - 1\" ; } $ a = array ( 1 , 8 , 4 ) ; $ n = count ( $ a ) ; print_result ( $ a , $ n , 2 , 3 ) ; ? >"}
{"text":"Smallest x such that 1 * n , 2 * n , ... x * n have all digits from 1 to 9 | Returns smallest value x such that 1 * n , 2 * n , 3 * n ... x * n have all digits from 1 to 9 at least once ; taking temporary array and variable . ; iterate till we get all the 10 digits at least once ; checking all the digits ; Driver code","code":"< ? php function smallestX ( $ n ) { $ temp = array_fill ( 0 , 10 , false ) ; if ( $ n == 0 ) return -1 ; $ count = 0 ; $ x = 0 ; for ( $ x = 1 ; $ count < 10 ; $ x ++ ) { $ y = $ x * $ n ; while ( $ y ) { if ( $ temp [ $ y % 10 ] == false ) { $ count ++ ; $ temp [ $ y % 10 ] = true ; } $ y = ( int ) ( $ y \/ 10 ) ; } } return $ x - 1 ; } $ n = 5 ; echo smallestX ( $ n ) ; ? >"}
{"text":"Find a number x such that sum of x and its digits is equal to given n . | utility function for digit sum ; function for finding x ; iterate from 1 to n . For every no . check if its digit sum with it is equal to n . ; if no such i found return - 1 ; Driver Code","code":"< ? php function digSum ( $ n ) { $ sum = 0 ; $ rem = 0 ; while ( $ n ) { $ rem = $ n % 10 ; $ sum += $ rem ; $ n \/= 10 ; } return $ sum ; } function findX ( $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( $ i + digSum ( $ i ) == $ n ) return $ i ; return -1 ; } $ n = 43 ; echo \" x = \" ? >"}
{"text":"9 's complement of a decimal number | PHP program to find 9 's complement of a number. ; Driver code","code":"< ? php function complement ( $ number ) { for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) if ( $ number [ $ i ] != ' . ' ) $ number [ $ i ] = '9' - $ number [ $ i ] + '0' ; echo \"9 ' s \u2581 complement \u2581 is \u2581 : \u2581 \" , $ number ; } $ number = \"345.45\" ; complement ( $ number ) ; ? >"}
{"text":"Ways to express a number as product of two different factors | To count number of ways in which number expressed as product of two different numbers ; To store count of such pairs ; Counting number of pairs upto sqrt ( n ) - 1 ; To return count of pairs ; Driver Code","code":"< ? php function countWays ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ count ++ ; return $ count ; } $ n = 12 ; echo countWays ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count divisors of n that have at | function to return true if any digit of m is present in hash [ ] . ; check till last digit ; if number is also present in original number then return true ; if no number matches then return 1 ; Count the no of divisors that have at least 1 digits same ; Store digits present in n in a hash [ ] ; marks that the number is present ; last digit removed ; loop to traverse from 1 to sqrt ( n ) to count divisors ; if i is the factor ; call the function to check if any digits match or not ; if n \/ i != i then a different number , then check it also ; return the answer ; Driver code","code":"< ? php function isDigitPresent ( $ m , $ hash ) { while ( $ m ) { if ( $ hash [ $ m % 10 ] ) return true ; $ m = ( int ) ( $ m \/ 10 ) ; } return false ; } function countDivisibles ( $ n ) { $ hash = array_fill ( 0 , 10 , false ) ; $ m = $ n ; while ( $ m ) { $ hash [ $ m % 10 ] = true ; $ m = ( int ) ( $ m \/ 10 ) ; } $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( isDigitPresent ( $ i , $ hash ) ) $ ans ++ ; if ( ( int ) ( $ n \/ $ i ) != $ i ) { if ( isDigitPresent ( ( int ) ( $ n \/ $ i ) , $ hash ) ) $ ans ++ ; } } } return $ ans ; } $ n = 15 ; echo countDivisibles ( $ n ) ; ? >"}
{"text":"Doolittle Algorithm : LU Decomposition | PHP Program to decompose a matrix into lower and upper triangular matrix ; Decomposing matrix into Upper and Lower triangular matrix ; Upper Triangular ; Summation of L ( i , j ) * U ( j , k ) ; Evaluating U ( i , k ) ; Lower Triangular ; $lower [ $i ] [ $i ] = 1 ; Diagonal as 1 ; Summation of L ( k , j ) * U ( j , i ) ; Evaluating L ( k , i ) ; setw is for displaying nicely ; Displaying the result : ; Lower ; Upper ; Driver code","code":"< ? php $ MAX = 100 ; function luDecomposition ( $ mat , $ n ) { $ lower ; $ upper ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ lower [ $ i ] [ $ j ] = 0 ; $ upper [ $ i ] [ $ j ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ k = $ i ; $ k < $ n ; $ k ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ sum += ( $ lower [ $ i ] [ $ j ] * $ upper [ $ j ] [ $ k ] ) ; $ upper [ $ i ] [ $ k ] = $ mat [ $ i ] [ $ k ] - $ sum ; } for ( $ k = $ i ; $ k < $ n ; $ k ++ ) { if ( $ i == $ k ) else { $ sum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ sum += ( $ lower [ $ k ] [ $ j ] * $ upper [ $ j ] [ $ i ] ) ; $ lower [ $ k ] [ $ i ] = ( int ) ( ( $ mat [ $ k ] [ $ i ] - $ sum ) \/ $ upper [ $ i ] [ $ i ] ) ; } } } echo \" TABSYMBOL TABSYMBOL Lower \u2581 Triangular \" ; echo \" TABSYMBOL TABSYMBOL TABSYMBOL Upper \u2581 Triangular STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo \" TABSYMBOL \" . $ lower [ $ i ] [ $ j ] . \" TABSYMBOL \" ; echo \" TABSYMBOL \" ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ upper [ $ i ] [ $ j ] . \" TABSYMBOL \" ; echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 2 , -1 , -2 ) , array ( -4 , 6 , 3 ) , array ( -4 , -2 , 8 ) ) ; luDecomposition ( $ mat , 3 ) ; ? >"}
{"text":"Divide number into two parts divisible by given numbers | method prints divisible parts if possible , otherwise prints ' Not \u2581 possible ' ; creating arrays to store reminder ; looping over all suffix and storing reminder with f ; getting suffix reminder from previous suffix reminder ; looping over all prefix and storing reminder with s ; getting prefix reminder from next prefix reminder ; updating base value ; now looping over all reminders to check partition condition ; if both reminders are 0 and digit itself is not 0 , then print result and return ; if we reach here , then string can ' be partitioned  under constraints ; Driver code","code":"< ? php function printTwoDivisibleParts ( $ num , $ f , $ s ) { $ N = strlen ( $ num ) ; $ prefixReminder = array_fill ( 0 , $ N + 1 , 0 ) ; $ suffixReminder = array_fill ( 0 , $ N + 1 , 0 ) ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ suffixReminder [ $ i ] = ( $ suffixReminder [ $ i - 1 ] * 10 + ( ord ( $ num [ $ i - 1 ] ) - 48 ) ) % $ f ; $ base = 1 ; for ( $ i = $ N - 1 ; $ i >= 0 ; $ i -- ) { $ prefixReminder [ $ i ] = ( $ prefixReminder [ $ i + 1 ] + ( ord ( $ num [ $ i ] ) - 48 ) * $ base ) % $ s ; $ base = ( $ base * 10 ) % $ s ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ prefixReminder [ $ i ] == 0 && $ suffixReminder [ $ i ] == 0 && $ num [ $ i ] != '0' ) { echo substr ( $ num , 0 , $ i ) . \" \u2581 \" . substr ( $ num , $ i ) . \" STRNEWLINE \" ; return ; } } echo \" Not \u2581 Possible STRNEWLINE \" ; } $ num = \"246904096\" ; $ f = 12345 ; $ s = 1024 ; printTwoDivisibleParts ( $ num , $ f , $ s ) ; ? >"}
{"text":"Number of subarrays whose minimum and maximum are same | calculate the no of contiguous subarrays which has same minimum and maximum ; stores the answer ; loop to traverse from 0 - n ; start checking subarray from next element ; traverse for finding subarrays ; if the elements are same then we check further and keep a count of same numbers in ' r ' ; the no of elements in between r and i with same elements . ; the no of subarrays that can be formed between i and r ; again start checking from the next index ; returns answer ; Driver Code","code":"< ? php function calculate ( $ a , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ r = $ i + 1 ; for ( $ j = $ r ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ i ] == $ a [ $ j ] ) $ r += 1 ; else break ; } $ d = $ r - $ i ; $ ans += ( $ d * ( $ d + 1 ) \/ 2 ) ; $ i = $ r - 1 ; } return $ ans ; } $ a = array ( 2 , 4 , 5 , 3 , 3 , 3 ) ; $ n = count ( $ a ) ; echo calculate ( $ a , $ n ) ; ? >"}
{"text":"Count of numbers satisfying m + sum ( m ) + sum ( sum ( m ) ) = N | function that returns sum of digits in a number ; initially sum of digits is 0 ; loop runs till all digits have been extracted ; last digit from backside ; sums up the digits ; the number is reduced to the number removing the last digit ; returns the sum of digits in a number ; function to calculate the count of such occurrences ; counter to calculate the occurrences ; loop to traverse from n - 97 to n ; calls the function to calculate the sum of digits of i ; calls the function to calculate the sum of digits of a ; if the summation is equal to n then increase counter by 1 ; returns the count ; Driver Code ; calls the function to get the answer","code":"< ? php function sum ( $ n ) { $ rem = 0 ; $ sum_of_digits = 0 ; while ( $ n > 0 ) { $ rem = $ n % 10 ; $ sum_of_digits += $ rem ; $ n = $ n \/ 10 ; } return $ sum_of_digits ; } function countt ( $ n ) { $ c = 0 ; for ( $ i = $ n - 97 ; $ i <= $ n ; $ i ++ ) { $ a = sum ( $ i ) ; $ b = sum ( $ a ) ; if ( ( $ i + $ a + $ b ) == $ n ) { $ c += 1 ; } } return $ c ; } $ n = 9939 ; echo countt ( $ n ) ; ? >"}
{"text":"Check if a number is power of k using base changing method | PHP program to check if a number can be raised to k ; loop to change base n to base = k ; Find current digit in base k ; If digit is neither 0 nor 1 ; Make sure that only one 1 is present . ; Driver code","code":"< ? php function isPowerOfK ( $ n , $ k ) { $ oneSeen = false ; while ( $ n > 0 ) { $ digit = $ n % $ k ; if ( $ digit > 1 ) return false ; if ( $ digit == 1 ) { if ( $ oneSeen ) return false ; $ oneSeen = true ; } $ n = ( int ) $ n \/ $ k ; } return true ; } $ n = 64 ; $ k = 4 ; if ( isPowerOfK ( $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if number is palindrome or not in Octal | PHP program to check if octal representation of a number is prime ; Function to Check no is in octal or not ; Function To check no is palindrome or not ; If number is already in octal , we traverse digits using repeated division with 10. Else we traverse digits using repeated division with 8 ; To store individual digits ; Traversing all digits ; checking if octal no is palindrome ; Driver Code","code":"< ? php $ MAX_DIGITS = 20 ; function isOctal ( $ n ) { while ( $ n ) { if ( ( $ n % 10 ) >= 8 ) return false ; else $ n = ( int ) $ n \/ 10 ; } return true ; } function isPalindrome ( $ n ) { global $ MAX_DIGITS ; $ divide = ( isOctal ( $ n ) == false ) ? 8 : 10 ; $ octal ; $ i = 0 ; while ( $ n != 0 ) { $ octal [ $ i ++ ] = $ n % $ divide ; $ n = ( int ) $ n \/ $ divide ; } for ( $ j = $ i - 1 , $ k = 0 ; $ k <= $ j ; $ j -- , $ k ++ ) if ( $ octal [ $ j ] != $ octal [ $ k ] ) return -1 ; return 0 ; } $ n = 97 ; if ( isPalindrome ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find all factorial numbers less than or equal to n | PHP program to find all factorial numbers smaller than or equal to n . ; Compute next factorial using previous ; Driver code","code":"< ? php function printFactorialNums ( $ n ) { $ fact = 1 ; $ x = 2 ; while ( $ fact <= $ n ) { echo $ fact , \" \" ; $ fact = $ fact * $ x ; $ x ++ ; } } $ n = 100 ; echo printFactorialNums ( $ n ) ; ? >"}
{"text":"Check whether a number has exactly three distinct factors or not | Utility function to check whether a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check whether given number has three distinct factors or not ; Find square root of number ; Check whether number is perfect square or not ; If number is perfect square , check whether square root is prime or not ; Driver Code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isThreeDisctFactors ( $ n ) { $ sq = sqrt ( $ n ) ; if ( $ sq * $ sq != $ n ) return false ; return isPrime ( $ sq ) ? true : false ; } $ num = 9 ; if ( isThreeDisctFactors ( $ num ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ num = 15 ; if ( isThreeDisctFactors ( $ num ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; $ num = 12397923568441 ; if ( isThreeDisctFactors ( $ num ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Find the last digit when factorial of A divides factorial of B | Function which computes the last digit of resultant of B ! \/ A ! ; If A = B , B ! = A ! and B ! \/ A ! = 1 ; If difference ( B - A ) >= 5 , answer = 0 ; If non of the conditions are true , we iterate from A + 1 to B and multiply them . We are only concerned for the last digit , thus we take modulus of 10 ; Driver Code","code":"< ? php function computeLastDigit ( $ A , $ B ) { $ variable = 1 ; if ( $ A == $ B ) return 1 ; else if ( ( $ B - $ A ) >= 5 ) return 0 ; else { for ( $ i = $ A + 1 ; $ i <= $ B ; $ i ++ ) $ variable = ( $ variable * ( $ i % 10 ) ) % 10 ; return $ variable % 10 ; } } echo computeLastDigit ( 2632 , 2634 ) ; ? >"}
{"text":"Program for sum of arithmetic series | Function to find sum of series . ; Driver Code","code":"< ? php function sumOfAP ( $ a , $ d , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ a ; $ a = $ a + $ d ; } return $ sum ; } $ n = 20 ; $ a = 2.5 ; $ d = 1.5 ; echo ( sumOfAP ( $ a , $ d , $ n ) ) ; ? >"}
{"text":"Product of factors of number | PHP program to calculate product of factors of number ; function to product the factors ; If factors are equal , multiply only once ; Otherwise multiply both ; Driver Code","code":"< ? php $ M = 1000000007 ; function multiplyFactors ( $ n ) { global $ M ; $ prod = 1 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ prod = ( $ prod * $ i ) % $ M ; else { $ prod = ( $ prod * $ i ) % $ M ; $ prod = ( $ prod * $ n \/ $ i ) % $ M ; } } } return $ prod ; } $ n = 12 ; echo multiplyFactors ( $ n ) ; ? >"}
{"text":"Product of factors of number | PHP program to calculate product of factors of number ; Iterative Function to calculate ( x ^ y ) in O ( log y ) ; function to count the factors ; If factors are equal , count only once ; Otherwise count both ; Calculate product of factors ; If numFactor is odd return power ( n , numFactor \/ 2 ) * sqrt ( n ) ; Driver code","code":"< ? php $ M = 1000000007 ; function power ( $ x , $ y ) { global $ M ; $ res = 1 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ M ; $ y = ( $ y >> 1 ) % $ M ; $ x = ( $ x * $ x ) % $ M ; } return $ res ; } function countFactors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ count ++ ; else $ count += 2 ; } } return $ count ; } function multiplyFactors ( $ n ) { $ numFactor = countFactors ( $ n ) ; $ product = power ( $ n , $ numFactor \/ 2 ) ; if ( $ numFactor & 1 ) $ product = ( $ product * sqrt ( $ n ) ) % $ M ; return $ product ; } $ n = 12 ; echo multiplyFactors ( $ n ) ; ? >"}
{"text":"Decimal representation of given binary string is divisible by 10 or not | function to check whether decimal representation of given binary number is divisible by 10 or not ; if last digit is '1' , then number is not divisible by 10 ; to accumulate the sum of last digits in perfect powers of 2 ; traverse from the 2 nd last up to 1 st digit in ' bin ' ; if digit in '1' ; calculate digit 's  position from the right ; according to the digit 's  position, obtain the last  digit of the applicable  perfect power of 2 ; if last digit is 0 , then divisible by 10 ; not divisible by 10 ; Driver Code","code":"< ? php function isDivisibleBy10 ( $ bin ) { $ n = strlen ( $ bin ) ; if ( $ bin [ $ n - 1 ] == '1' ) return false ; $ sum = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ bin [ $ i ] == '1' ) { $ posFromRight = $ n - $ i - 1 ; if ( $ posFromRight % 4 == 1 ) $ sum = $ sum + 2 ; else if ( $ posFromRight % 4 == 2 ) $ sum = $ sum + 4 ; else if ( $ posFromRight % 4 == 3 ) $ sum = $ sum + 8 ; else if ( $ posFromRight % 4 == 0 ) $ sum = $ sum + 6 ; } } if ( $ sum % 10 == 0 ) return true ; return false ; } $ bin = \"11000111001110\" ; if ( isDivisibleBy10 ( $ bin ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Tribonacci Numbers | A space optimized based PHP program to print first n Tribinocci numbers . | ; Initialize first three numbers ; Loop to add previous three numbers for each number starting from 3 and then assign first , second , third to second , third , and curr to third respectively ; Driver code","code":"< ? php function printTrib ( $ n ) { if ( $ n < 1 ) return ; $ first = 0 ; $ second = 0 ; $ third = 1 ; echo $ first , \" \" ; if ( $ n > 1 ) echo $ second , \" \u2581 \" ; if ( $ n > 2 ) echo $ second , \" \u2581 \" ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third ; $ first = $ second ; $ second = $ third ; $ third = $ curr ; echo $ curr , \" \" ; } } $ n = 10 ; printTrib ( $ n ) ; ? >"}
{"text":"Prime Number of Set Bits in Binary Representation | Set 2 | Function to create an array of prime numbers upto number ' n ' ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Append all the prime numbers to the list ; Utility function to count the number of set bits ; Driver program ; Here prime numbers are checked till the maximum number of bits possible because that the maximum bit sum possible is the number of bits itself .","code":"< ? php function SieveOfEratosthenes ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) for ( $ i = $ p * 2 ; $ i < $ n + 1 ; $ i += $ p ) $ prime [ $ i ] = false ; } $ lis = array ( ) ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) if ( $ prime [ $ p ] ) array_push ( $ lis , $ p ) ; return $ lis ; } function setBits ( $ n ) { $ cnt = 0 ; while ( $ n ) { if ( $ n & 1 ) $ cnt ++ ; $ n >>= 1 ; } ; return $ cnt ; } $ x = 4 ; $ y = 8 ; $ count = 0 ; $ primeArr = SieveOfEratosthenes ( ceil ( log ( $ y , 2 ) ) ) ; for ( $ i = $ x ; $ i < $ y + 1 ; $ i ++ ) { $ temp = setBits ( $ i ) ; if ( in_array ( $ temp , $ primeArr ) ) $ count += 1 ; } print ( $ count ) ; ? >"}
{"text":"Count squares with odd side length in Chessboard | Function to return the count of odd length squares possible ; To store the required count ; For all odd values of i ; Add the count of possible squares of length i ; Return the required count ; Driver code","code":"< ? php function count_square ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i = $ i + 2 ) { $ k = $ n - $ i + 1 ; $ count += ( $ k * $ k ) ; } return $ count ; } $ N = 8 ; echo count_square ( $ N ) ; ? >"}
{"text":"Count of elements whose absolute difference with the sum of all the other elements is greater than k | Function to return the number of anomalies ; To store the count of anomalies ; To store the sum of the array elements ; Find the sum of the array elements ; Count the anomalies ; Driver code","code":"< ? php function countAnomalies ( $ arr , $ n , $ k ) { $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( abs ( $ arr [ $ i ] - ( $ sum - $ arr [ $ i ] ) ) > $ k ) $ cnt ++ ; return $ cnt ; } $ arr = array ( 1 , 3 , 5 ) ; $ n = count ( $ arr ) ; $ k = 1 ; echo countAnomalies ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find the number of integers x in range ( 1 , N ) for which x and x + 1 have same number of divisors | PHP implementation of the approach ; To store number of divisors and Prefix sum of such numbers ; Function to find the number of integers 1 < x < N for which x and x + 1 have the same number of positive divisors ; Count the number of divisors ; Run a loop upto sqrt ( i ) ; If j is divisor of i ; If it is perfect square ; x and x + 1 have same number of positive divisors ; Function call ; Required answer","code":"< ? php $ N = 100005 ; $ d = array_fill ( 0 , $ N , NULL ) ; $ pre = array_fill ( 0 , $ N , NULL ) ; function Positive_Divisors ( ) { global $ N , $ d , $ pre ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j <= $ i ; $ j ++ ) { if ( $ i % $ j == 0 ) { if ( $ j * $ j == $ i ) $ d [ $ i ] ++ ; else $ d [ $ i ] += 2 ; } } } $ ans = 0 ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) { if ( $ d [ $ i ] == $ d [ $ i - 1 ] ) $ ans ++ ; $ pre [ $ i ] = $ ans ; } } Positive_Divisors ( ) ; $ n = 15 ; echo $ pre [ $ n ] ; return 0 ; ? >"}
{"text":"Length of the smallest number which is divisible by K and formed by using 1 's only | Function to return length of the resultant number ; If K is a multiple of 2 or 5 ; Generate all possible numbers 1 , 11 , 111 , 111 , ... , K 1 's ; If number is divisible by k then return the length ; Driver code","code":"< ? php function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = $ number * 10 + 1 ; if ( ( $ number % $ K == 0 ) ) return $ len ; } return -1 ; } $ K = 7 ; echo numLen ( $ K ) ; ? >"}
{"text":"Find if the given number is present in the infinite sequence or not | Function that returns true if the sequence will contain B ; Driver code","code":"< ? php function doesContainB ( $ a , $ b , $ c ) { if ( $ a == $ b ) return true ; if ( ( $ b - $ a ) * $ c > 0 && ( $ b - $ a ) % $ c == 0 ) return true ; return false ; } $ a = 1 ; $ b = 7 ; $ c = 3 ; if ( doesContainB ( $ a , $ b , $ c ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find a permutation of 2 N numbers such that the result of given expression is exactly 2 K | Function to find the required permutation of first 2 * N natural numbers ; Iterate in blocks of 2 ; We need more increments , so print in reverse order ; We have enough increments , so print in same order ; Driver Code","code":"< ? php function printPermutation ( $ n , $ k ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ x = 2 * $ i - 1 ; $ y = 2 * $ i ; if ( $ i <= $ k ) echo $ y . \" \" \u2581 . \u2581 $ x \u2581 . \u2581 \" \" else echo $ x . \" \u2581 \" . $ y . \" \u2581 \" ; } } $ n = 2 ; $ k = 1 ; printPermutation ( $ n , $ k ) ; ? >"}
{"text":"Maximize the sum of products of the degrees between any two vertices of the tree | Function to return the maximum possible sum ; Initialize degree for node u to 2 ; If u is the leaf node or the root node ; Initialize degree for node v to 2 ; If v is the leaf node or the root node ; Update the sum ; Driver code","code":"< ? php function maxSum ( $ N ) { $ ans = 0 ; for ( $ u = 1 ; $ u <= $ N ; $ u ++ ) { for ( $ v = 1 ; $ v <= $ N ; $ v ++ ) { if ( $ u == $ v ) continue ; $ degreeU = 2 ; if ( $ u == 1 $ u == $ N ) $ degreeU = 1 ; $ degreeV = 2 ; if ( $ v == 1 $ v == $ N ) $ degreeV = 1 ; $ ans += ( $ degreeU * $ degreeV ) ; } } return $ ans ; } $ N = 6 ; echo maxSum ( $ N ) ; ? >"}
{"text":"Find integers that divides maximum number of elements of the array | Function to print the integers that divide the maximum number of elements from the array ; Initialize two lists to store rank and factors ; Start from 2 till the maximum element in arr ; Initialize a variable to count the number of elements it is a factor of ; Maximum rank in the rank list ; Print all the elements with rank m ; Driver code","code":"< ? php function maximumFactor ( $ arr ) { $ rank = array ( ) ; $ factors = array ( ) ; for ( $ i = 2 ; $ i <= max ( $ arr ) ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < sizeof ( $ arr ) ; $ j ++ ) if ( $ arr [ $ j ] % $ i == 0 ) $ count += 1 ; array_push ( $ rank , $ count ) ; array_push ( $ factors , $ i ) ; } $ m = max ( $ rank ) ; for ( $ i = 0 ; $ i < sizeof ( $ rank ) ; $ i ++ ) { if ( $ rank [ $ i ] == $ m ) echo $ factors [ $ i ] , \" \u2581 \" ; } } $ arr = array ( 120 , 15 , 24 , 63 , 18 ) ; maximumFactor ( $ arr ) ? >"}
{"text":"Natural Numbers | Returns sum of first n natural numbers ; Driver code","code":"< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text":"Median | Function for calculating median ; First we sort the array ; check for even case ; Driver Code","code":"< ? php function findMedian ( & $ a , $ n ) { sort ( $ a ) ; if ( $ n % 2 != 0 ) return ( double ) $ a [ $ n \/ 2 ] ; return ( double ) ( $ a [ ( $ n - 1 ) \/ 2 ] + $ a [ $ n \/ 2 ] ) \/ 2.0 ; } $ a = array ( 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ) ; $ n = sizeof ( $ a ) ; echo \" Median \u2581 = \u2581 \" . findMedian ( $ a , $ n ) ; ? >"}
{"text":"Mean | Function for calculating mean ; Driver Code","code":"< ? php function findMean ( & $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; return ( double ) $ sum \/ ( double ) $ n ; } $ a = array ( 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ) ; $ n = sizeof ( $ a ) ; echo \" Mean \u2581 = \u2581 \" . findMean ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Check if the array has an element which is equal to product of remaining elements | Function to Check if the array has an element which is equal to product of all the remaining elements ; Storing frequency in map ; Calculate the product of all the elements ; If the prod is a perfect square ; then check if its square root exist in the array or not ; Driver code","code":"< ? php function CheckArray ( $ arr , $ n ) { $ prod = 1 ; $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { array_push ( $ freq , $ arr [ $ i ] ) ; $ prod *= $ arr [ $ i ] ; } $ freq = array_unique ( $ freq ) ; $ root = ( int ) ( sqrt ( $ prod ) ) ; if ( $ root * $ root == $ prod ) if ( in_array ( $ root , $ freq ) ) return true ; return false ; } $ arr = array ( 1 , 2 , 12 , 3 , 2 ) ; $ n = count ( $ arr ) ; if ( CheckArray ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Check whether a number has consecutive 0 's in the given base or not | We first convert to given base , then check if the converted number has two consecutive 0 s or not ; Function to convert N into base K ; Weight of each digit ; Function to check for consecutive 0 ; Flag to check if there are consecutive zero or not ; If there are two consecutive zero then returning false ; Driver code","code":"< ? php function hasConsecutiveZeroes ( $ N , $ K ) { $ z = toK ( $ N , $ K ) ; if ( check ( $ z ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; } function toK ( $ N , $ K ) { $ w = 1 ; $ s = 0 ; while ( $ N != 0 ) { $ r = $ N % $ K ; $ N = ( int ) ( $ N \/ $ K ) ; $ s = $ r * $ w + $ s ; $ w *= 10 ; } return $ s ; } function check ( $ N ) { $ fl = false ; while ( $ N != 0 ) { $ r = $ N % 10 ; $ N = ( int ) ( $ N \/ 10 ) ; if ( $ fl == true and $ r == 0 ) return false ; if ( $ r > 0 ) { $ fl = false ; continue ; } $ fl = true ; } return true ; } $ N = 15 ; $ K = 8 ; hasConsecutiveZeroes ( $ N , $ K ) ; ? >"}
{"text":"Sum of every K\u00e2 \u20ac\u2122 th prime number in an array | PHP implementation of the approach ; 0 and 1 are not prime numbers ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; compute the answer ; count of primes ; sum of the primes ; traverse the array ; if the number is a prime ; increase the count ; if it is the K 'th prime ; create the sieve","code":"< ? php $ MAX = 100000 ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ prime ; $ prime [ 1 ] = false ; $ prime [ 0 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } } function SumOfKthPrimes ( $ arr , $ n , $ k ) { global $ MAX , $ prime ; $ c = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ prime [ $ arr [ $ i ] ] ) { $ c ++ ; if ( $ c % $ k == 0 ) { $ sum += $ arr [ $ i ] ; $ c = 0 ; } } } echo $ sum . \" STRNEWLINE \" ; } SieveOfEratosthenes ( ) ; $ arr = array ( 2 , 3 , 5 , 7 , 11 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; SumOfKthPrimes ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find the super power of a given Number | PHP for finding super power of n ; global hash for prime ; sieve method for storing a list of prime ; function to return super power ; find the super power ; Driver Code","code":"< ? php $ MAX = 100000 ; $ prime = array_fill ( 0 , 100002 , true ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ prime ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) if ( $ prime [ $ p ] == true ) for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } function superpower ( $ n ) { SieveOfEratosthenes ( ) ; global $ MAX , $ prime ; $ superPower = 0 ; $ factor = 0 ; $ i = 2 ; while ( $ n > 1 && $ i <= $ MAX ) { if ( $ prime [ $ i ] ) { $ factor = 0 ; while ( $ n % $ i == 0 && $ n > 1 ) { $ factor ++ ; $ n = $ n \/ $ i ; } if ( $ superPower < $ factor ) $ superPower = $ factor ; } $ i ++ ; } return $ superPower ; } $ n = 256 ; echo superpower ( $ n ) ; ? >"}
{"text":"Smallest prime divisor of a number | Function to find the smallest divisor ; if divisible by 2 ; iterate from 3 to sqrt ( n ) ; Driver Code","code":"< ? php function smallestDivisor ( $ n ) { if ( $ n % 2 == 0 ) return 2 ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) { if ( $ n % $ i == 0 ) return $ i ; } return $ n ; } $ n = 31 ; echo smallestDivisor ( $ n ) ; ? >"}
{"text":"Count Number of animals in a zoo from given number of head and legs | Function that calculates Rabbits ; Driver code","code":"< ? php function countRabbits ( $ Heads , $ Legs ) { $ count = 0 ; $ count = ( $ Legs ) - 2 * ( $ Heads ) ; $ count = ( int ) $ count \/ 2 ; return $ count ; } $ Heads = 100 ; $ Legs = 300 ; $ Rabbits = countRabbits ( $ Heads , $ Legs ) ; echo \" Rabbits = \" \u2581 , \u2581 $ Rabbits \u2581 , \u2581 \" \" ; STRNEWLINE echo \u2581 \" Pigeons = \" $ Rabbits , \" STRNEWLINE \" ; ? >"}
{"text":"Program to evaluate the expression ( \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00be\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u2026\u00a1\u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u2026\u00be\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00be\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00e2 \u20ac\u00a6\u00a1\u00ac\u00b9 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u2026\u00a1\u00ac \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6\u00a1\u00ac \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00be\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00e2 \u20ac\u00a6\u00a1\u00ac\u00a6\u00a1 X + 1 ) ^ 6 + ( \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00be\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u2026\u00a1\u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u2026\u00be\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00be\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00e2 \u20ac\u00a6\u00a1\u00ac\u00b9 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u2026\u00a1\u00ac \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6\u00a1\u00ac \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u00a2 \u00e2 \u20ac \u017e \u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00be\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00e2 \u20ac\u00a6\u00a1\u00ac\u00a6\u00a1 X | Function to find the sum ; Driver Code","code":"< ? php function calculateSum ( $ n ) { $ a = ( int ) $ n ; return ( 2 * ( pow ( $ n , 6 ) + 15 * pow ( $ n , 4 ) + 15 * pow ( $ n , 2 ) + 1 ) ) ; } $ n = 1.4142 ; echo ceil ( calculateSum ( $ n ) ) ; ? >"}
{"text":"Find the sum of series 3 , | calculate sum upto N term of series ; Driver code","code":"< ? php function Sum_upto_nth_Term ( $ n ) { return ( 1 - pow ( -2 , $ n ) ) ; } $ N = 5 ; echo ( Sum_upto_nth_Term ( $ N ) ) ; ? >"}
{"text":"Count numbers whose XOR with N is equal to OR with N | Function to calculate count of numbers with XOR equals OR ; variable to store count of unset bits ; Driver code","code":"< ? php function xorEqualsOrCount ( $ N ) { $ count = 0 ; while ( $ N > 0 ) { $ bit = $ N % 2 ; if ( $ bit == 0 ) $ count ++ ; $ N = intval ( $ N \/ 2 ) ; } return pow ( 2 , $ count ) ; } $ N = 7 ; echo xorEqualsOrCount ( $ N ) ; ? >"}
{"text":"Program to find sum of 1 + x \/ 2 ! + x ^ 2 \/ 3 ! + ... + x ^ n \/ ( n + 1 ) ! | Function to find the factorial of a number ; Function to compute the sum ; Iterate the loop till n and compute the formula ; Get x and n ; Print output","code":"< ? php function fact ( $ n ) { if ( $ n == 1 ) return 1 ; return $ n * fact ( $ n - 1 ) ; } function sum ( $ x , $ n ) { $ total = 1.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ total = $ total + ( pow ( $ x , $ i ) \/ fact ( $ i + 1 ) ) ; } return $ total ; } $ x = 5 ; $ n = 4 ; echo \" Sum \u2581 is : \u2581 \" , sum ( $ x , $ n ) ; ? >"}
{"text":"Find Sum of Series 1 ^ 2 | PHP program to find sum of series 1 ^ 2 - 2 ^ 2 + 3 ^ 3 - 4 ^ 4 + ... Function to find sum of series ; If i is even ; If i is odd ; return the result ; Get n ; Find the sum ; Get n ; Find the sum ; This Code is Contributed by anuj_67","code":"< ? php function sum_of_series ( $ n ) { $ result = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ result = $ result - pow ( $ i , 2 ) ; else $ result = $ result + pow ( $ i , 2 ) ; } return $ result ; } $ n = 3 ; echo sum_of_series ( $ n ) , \" STRNEWLINE \" ; $ n = 10 ; echo sum_of_series ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program to find the sum of the series 23 + 45 + 75 + ... . . upto N terms | calculate Nth term of series ; Get the value of N ; Get the sum of the series","code":"< ? php function findSum ( $ N ) { return ( 2 * $ N * ( $ N + 1 ) * ( 4 * $ N + 17 ) + 54 * $ N ) \/ 6 ; } $ N = 4 ; echo findSum ( $ N ) ; ? >"}
{"text":"Program to find the value of sin ( n\u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6\u00bd \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac\u00b9 \u00c3\u0192\u00c6 \u2019 \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u20ac \u0161 \u00ac \u00c3 \u2026 \u00e2 \u20ac \u0153 ) | PHP Program to find the value of sin ( n ? ) ; This function use to calculate the binomial coefficient upto 15 ; use simple DP to find coefficient ; Function to find the value of ; find cosTheta from sinTheta ; store required answer ; use to toggle sign in sequence . ; Driver code .","code":"< ? php $ MAX = 16 ; $ nCr = array_fill ( 0 , $ MAX , array_fill ( 0 , $ MAX , 0 ) ) ; function binomial ( ) { global $ MAX , $ nCr ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ nCr [ $ i ] [ $ j ] = 1 ; else $ nCr [ $ i ] [ $ j ] = $ nCr [ $ i - 1 ] [ $ j ] + $ nCr [ $ i - 1 ] [ $ j - 1 ] ; } } } function findCosNTheta ( $ sinTheta , $ n ) { global $ MAX , $ nCr ; $ cosTheta = sqrt ( 1 - $ sinTheta * $ sinTheta ) ; $ ans = 0 ; $ toggle = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) { $ ans = $ ans + $ nCr [ $ n ] [ $ i ] * pow ( $ cosTheta , $ n - $ i ) * pow ( $ sinTheta , $ i ) * $ toggle ; $ toggle = $ toggle * -1 ; } return $ ans ; } binomial ( ) ; $ sinTheta = 0.5 ; $ n = 10 ; echo findCosNTheta ( $ sinTheta , $ n ) ; ? >"}
{"text":"Program to find Nth term of series 9 , 23 , 45 , 75 , 113. . . | calculate Nth term of series ; Get the value of N ; Find the Nth term and print it","code":"< ? php function nthTerm ( $ N ) { return ( 2 * $ N + 3 ) * ( 2 * $ N + 3 ) - 2 * $ N ; } $ N = 4 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Find sum of the series 1 + 22 + 333 + 4444 + ... ... upto n terms | Function to calculate sum ; Return sum ; Driver code","code":"< ? php function findSum ( $ n ) { return ( pow ( 10 , $ n + 1 ) * ( 9 * $ n - 1 ) + 10 ) \/ pow ( 9 , 3 ) - $ n * ( $ n + 1 ) \/ 18 ; } $ n = 3 ; echo findSum ( $ n ) ; ? >"}
{"text":"Find sum of the series 1 | Function to calculate sum ; when n is odd ; when n is not odd ; Driver code","code":"< ? php function solve_sum ( $ n ) { if ( $ n % 2 == 1 ) return ( $ n + 1 ) \/ 2 ; return - $ n \/ 2 ; } $ n = 8 ; echo solve_sum ( $ n ) ; ? >"}
{"text":"Check if a number can be expressed as a ^ b | Set 2 | PHP program to check if a number can be expressed as a ^ b . ; Driver code","code":"< ? php function isPower ( $ a ) { if ( $ a == 1 ) return true ; for ( $ i = 2 ; $ i * $ i <= $ a ; $ i ++ ) { $ val = log ( $ a ) \/ log ( $ i ) ; if ( ( $ val - $ val ) < 0.00000001 ) return true ; } return false ; } $ n = 16 ; echo ( isPower ( $ n ) ? \" Yes \" : \" No \" ) ;"}
{"text":"Program to calculate Root Mean Square | Function that Calculate Root Mean Square ; Calculate square . ; Calculate Mean . ; Calculate Root . ; Driver code","code":"< ? php function rmsValue ( $ arr , $ n ) { $ square = 0 ; $ mean = 0.0 ; $ root = 0.0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ square += pow ( $ arr [ $ i ] , 2 ) ; } $ mean = ( $ square \/ ( float ) ( $ n ) ) ; $ root = sqrt ( $ mean ) ; return $ root ; } $ arr = array ( 10 , 4 , 6 , 8 ) ; $ n = sizeof ( $ arr ) ; echo rmsValue ( $ arr , $ n ) ; ? >"}
{"text":"Program to find the quantity after mixture replacement | Function to calculate the Remaining amount . ; calculate Right hand Side ( RHS ) . ; calculate Amount left by multiply it with original value . ; Driver Code","code":"< ? php function Mixture ( $ X , $ Y , $ Z ) { $ result = 0.0 ; $ result1 = 0.0 ; $ result1 = ( ( $ X - $ Y ) \/ $ X ) ; $ result = pow ( $ result1 , $ Z ) ; $ result = $ result * $ X ; return $ result ; } $ X = 10 ; $ Y = 2 ; $ Z = 2 ; echo Mixture ( $ X , $ Y , $ Z ) , \" \u2581 litres \" ; ? >"}
{"text":"Sum of sum of all subsets of a set formed by first N natural numbers | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with the result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; function to find ff ( n ) ; In formula n is starting from zero ; calculate answer using formula 2 ^ n * ( n ^ 2 + n + 2 ) - 1 ; whenever answer is greater than or equals to mod then modulo it . ; adding modulo while subtraction is very necessary otherwise it will cause wrong answer ; Driver code ; function call","code":"< ? php function power ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function check ( $ n ) { $ mod = 1e9 + 7 ; $ n -- ; $ ans = $ n * $ n ; if ( $ ans >= $ mod ) $ ans %= $ mod ; $ ans += $ n + 2 ; if ( $ ans >= $ mod ) $ ans %= $ mod ; $ ans = ( power ( 2 , $ n , $ mod ) % $ mod * $ ans % $ mod ) % $ mod ; $ ans = ( $ ans - 1 + $ mod ) % $ mod ; return $ ans ; } $ n = 4 ; echo check ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program to find LCM of 2 numbers without using GCD | Function to return LCM of two numbers ; Driver Code","code":"< ? php function findLCM ( $ a , $ b ) { $ lar = max ( $ a , $ b ) ; $ small = min ( $ a , $ b ) ; for ( $ i = $ lar ; ; $ i += $ lar ) { if ( $ i % $ small == 0 ) return $ i ; } } $ a = 5 ; $ b = 7 ; echo \" LCM \u2581 of \u2581 \" , $ a , \" \u2581 and \u2581 \" , $ b , \" \u2581 is \u2581 \" , findLCM ( $ a , $ b ) ; ? >"}
{"text":"Smarandache | Function to collect first ' n ' prime numbers ; List to store first ' n ' primes ; Function to generate Smarandache - Wellin Sequence ; Storing the first ' n ' prime numbers in a list ; Driver Code","code":"< ? php function primes ( $ n ) { $ i = 2 ; $ j = 0 ; $ result ; $ z = 0 ; while ( $ j < $ n ) { $ flag = true ; for ( $ item = 2 ; $ item <= ( int ) ( $ i * 1 \/ 2 ) ; $ item ++ ) if ( $ i % $ item == 0 && $ i != $ item ) { $ flag = false ; break ; } if ( $ flag ) { $ result [ $ z ++ ] = $ i ; $ j += 1 ; } $ i += 1 ; } return $ result ; } function smar_wln ( $ n ) { $ arr = primes ( $ n ) ; for ( $ i = 0 ; $ i < count ( $ arr ) ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo $ arr [ $ j ] ; echo \" \u2581 \" ; } } $ n = 5 ; echo \" First \u2581 $ n \u2581 terms \u2581 of \u2581 the \" . \" \u2581 Sequence \u2581 are STRNEWLINE \" ; smar_wln ( $ n ) ; ? >"}
{"text":"Pentatope number | function for Pentatope number ; formula for find Pentatope nth term ; Driver Code","code":"< ? php function Pentatope_number ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) \/ 24 ; } $ n = 7 ; echo $ n , \" th \u2581 Pentatope \u2581 number \u2581 : \" , Pentatope_number ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo $ n , \" th \u2581 Pentatope \u2581 number \u2581 : \" , Pentatope_number ( $ n ) ; ? >"}
{"text":"Program for Centered Icosahedral Number | Function to find Centered icosahedral number ; Formula to calculate nth Centered icosahedral number and return it into main function . ; Driver Code","code":"< ? php function centeredIcosahedralNum ( $ n ) { return ( 2 * $ n + 1 ) * ( 5 * $ n * $ n + 5 * $ n + 3 ) \/ 3 ; } $ n = 10 ; echo centeredIcosahedralNum ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo centeredIcosahedralNum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Centered Square Number | Function to calculate Centered square number function ; Formula to calculate nth Centered square number ; Driver Code","code":"< ? php function centered_square_num ( $ n ) { return $ n * $ n + ( ( $ n - 1 ) * ( $ n - 1 ) ) ; } $ n = 7 ; echo $ n , \" th \u2581 Centered \u2581 square \u2581 number : \u2581 \" ; echo centered_square_num ( $ n ) ; ? >"}
{"text":"Sum of first n natural numbers | Function to find the sum of series ; Driver code","code":"< ? php function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) \/ 6 ; } $ n = 4 ; echo ( seriesSum ( $ n ) ) ; ? >"}
{"text":"Dodecagonal number | function for Dodecagonal number ; formula for find Dodecagonal nth term ; Driver code","code":"< ? php function Dodecagonal_number ( $ n ) { return 5 * $ n * $ n - 4 * $ n ; } $ n = 7 ; echo Dodecagonal_number ( $ n ) , \" STRNEWLINE \" ; $ n = 12 ; echo Dodecagonal_number ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Arithmetic Number | Sieve Of Eratosthenes ; 1 is not a prime number ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Storing primes in an array ; Update value in primesquare [ p * p ] , if p is prime . ; Function to count divisors ; If number is 1 , then it will have only 1 as a factor . So , total factors will be 1. ; for storing primes upto n ; Calling SieveOfEratosthenes to store prime factors of n and to store square of prime factors of n ; ans will contain total number of distinct divisors ; Loop for counting factors of n ; a [ i ] is not less than cube root n ; Calculating power of a [ i ] in n . cnt is power of prime a [ i ] in n . ; if a [ i ] is a factor of n ; incrementing power ; Calculating number of divisors . If n = a ^ p * b ^ q then total divisors of n are ( p + 1 ) * ( q + 1 ) ; First case ; Second case ; Third casse ; return $ans ; Total divisors ; Returns sum of all factors of n . ; Traversing through all prime factors . ; This condition is to handle the case when n is a prime number greater than 2. ; Check if number is Arithmetic Number or not . ; Driver code","code":"< ? php function SieveOfEratosthenes ( $ n , & $ prime , & $ primesquare , & $ a ) { for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ i = 0 ; $ i <= ( $ n * $ n + 1 ) ; $ i ++ ) $ primesquare [ $ i ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ j = 0 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { $ a [ $ j ] = $ p ; $ primesquare [ $ p * $ p ] = true ; $ j ++ ; } } } function countDivisors ( $ n ) { if ( $ n == 1 ) return 1 ; $ prime = array_fill ( 0 , ( $ n + 1 ) , false ) ; $ primesquare = array_fill ( 0 , ( $ n * $ n + 1 ) , false ) ; $ a = array_fill ( 0 , $ n , 0 ) ; SieveOfEratosthenes ( $ n , $ prime , $ primesquare , $ a ) ; $ ans = 1 ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ a [ $ i ] * $ a [ $ i ] * $ a [ $ i ] > $ n ) break ; $ cnt = 1 ; while ( $ n % $ a [ $ i ] == 0 ) { $ n = ( int ) ( $ n \/ $ a [ $ i ] ) ; $ cnt = $ cnt + 1 ; } $ ans = $ ans * $ cnt ; } if ( $ prime [ $ n ] ) $ ans = $ ans * 2 ; else if ( $ primesquare [ $ n ] ) $ ans = $ ans * 3 ; else if ( $ n != 1 ) $ ans = $ ans * 4 ; } function sumofFactors ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = ( int ) ( $ n \/ $ i ) ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; } function checkArithmetic ( $ n ) { $ count = countDivisors ( $ n ) ; $ sum = sumofFactors ( $ n ) ; return ( $ sum % $ count == 0 ) ; } $ n = 6 ; echo ( checkArithmetic ( $ n ) ) ? \" Yes \" : \" No \" ; ? >"}
{"text":"Finding n | A formula based PHP program to find sum of series with cubes of first n natural numbers ; Driver Code","code":"< ? php function magicOfSequence ( $ N ) { return ( $ N * ( $ N + 1 ) \/ 2 ) + 2 * $ N ; } $ N = 6 ; echo magicOfSequence ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Form a number using corner digits of powers | Find next power by multiplying N with current power ; Store digits of Power one by one . ; Calculate carry . ; Store carry in Power array . ; Prints number formed by corner digits of powers of N . ; Storing N raised to power 0 ; Initializing empty result ; One by one compute next powers and add their corner digits . ; Call Function that store power in Power array . ; Store unit and last digits of power in res . ; Driver Code","code":"< ? php function nextPower ( $ N , & $ power ) { $ carry = 0 ; for ( $ i = 0 ; $ i < count ( $ power ) ; $ i ++ ) { $ prod = ( $ power [ $ i ] * $ N ) + $ carry ; $ power [ $ i ] = $ prod % 10 ; $ carry = ( int ) ( $ prod \/ 10 ) ; } while ( $ carry ) { array_push ( $ power , $ carry % 10 ) ; $ carry = ( int ) ( $ carry \/ 10 ) ; } } function printPowerNumber ( $ X , $ N ) { $ power = array ( ) ; array_push ( $ power , 1 ) ; $ res = array ( ) ; for ( $ i = 1 ; $ i <= $ X ; $ i ++ ) { nextPower ( $ N , $ power ) ; array_push ( $ res , $ power [ count ( $ power ) - 1 ] ) ; array_push ( $ res , $ power [ 0 ] ) ; } for ( $ i = 0 ; $ i < count ( $ res ) ; $ i ++ ) echo ( $ res [ $ i ] ) ; } $ N = 19 ; $ X = 4 ; printPowerNumber ( $ X , $ N ) ; ? >"}
{"text":"First digit in factorial of a number | PHP program for finding the First digit of the large factorial number ; Removing trailing 0 s as this does not change first digit . ; loop for divide the fact until it become the single digit and return the fact ; Driver Code","code":"< ? php function firstDigit ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fact = $ fact * $ i ; while ( $ fact % 10 == 0 ) $ fact = $ fact \/ 10 ; } while ( $ fact >= 10 ) $ fact = $ fact \/ 10 ; return floor ( $ fact ) ; } $ n = 5 ; echo firstDigit ( $ n ) ; ? >"}
{"text":"Sum of the series 1.2 . 3 + 2.3 . 4 + ... + n ( n + 1 ) ( n + 2 ) | PHP program to find sum of the series 1.2 . 3 + 2.3 . 4 + 3.4 . 5 + ... ; Driver Code","code":"< ? php function sumofseries ( $ n ) { $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ res += ( $ i ) * ( $ i + 1 ) * ( $ i + 2 ) ; return $ res ; } echo sumofseries ( 3 ) ; ? >"}
{"text":"Find N Geometric Means between A and B | Pr$s N geometric means between A and B . ; calculate common ratio ( R ) ; for finding N the Geometric mean between A and B ; Driver Code","code":"< ? php function printGMeans ( $ A , $ B , $ N ) { $ R = pow ( ( $ B \/ $ A ) , 1.0 \/ ( $ N + 1 ) ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ A * pow ( $ R , $ i ) , \" \u2581 \" ; } $ A = 3 ; $ B = 81 ; $ N = 2 ; printGMeans ( $ A , $ B , $ N ) ; ? >"}
{"text":"Numbers having difference with digit sum more than s | function for digit sum ; function to calculate count of integer s . t . integer - digSum > s ; if n < s no integer possible ; iterate for s range and then calculate total count of such integer if starting integer is found ; if no integer found return 0 ; Driver Code","code":"< ? php function digitSum ( $ n ) { $ digSum = 0 ; while ( $ n ) { $ digSum += $ n % 10 ; $ n \/= 10 ; } return $ digSum ; } function countInteger ( $ n , $ s ) { if ( $ n < $ s ) return 0 ; for ( $ i = $ s ; $ i <= min ( $ n , $ s + 163 ) ; $ i ++ ) if ( ( $ i - digitSum ( $ i ) ) > $ s ) return ( $ n - $ i + 1 ) ; return 0 ; } $ n = 1000 ; $ s = 100 ; echo countInteger ( $ n , $ s ) ; ? >"}
{"text":"Division without using ' \/ ' operator | Function to find division without using ' \/ ' operator ; Handling negative numbers ; if num1 is greater than equal to num2 subtract num2 from num1 and increase quotient by one . ; checking if neg equals to 1 then making quotient negative ; Driver program","code":"< ? php function division ( $ num1 , $ num2 ) { if ( $ num1 == 0 ) return 0 ; if ( $ num2 == 0 ) return INT_MAX ; $ negResult = false ; if ( $ num1 < 0 ) { $ num1 = - $ num1 ; if ( $ num2 < 0 ) $ num2 = - $ num2 ; else $ negResult = true ; } else if ( $ num2 < 0 ) { $ num2 = - $ num2 ; $ negResult = true ; } $ quotient = 0 ; while ( $ num1 >= $ num2 ) { $ num1 = $ num1 - $ num2 ; $ quotient ++ ; } if ( $ negResult ) $ quotient = - $ quotient ; return $ quotient ; } $ num1 = 13 ; $ num2 = 2 ; echo division ( $ num1 , $ num2 ) ; ? >"}
{"text":"Nonagonal number | Function to find nonagonal number series . ; Driver Code","code":"< ? php function Nonagonal ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ i * ( 7 * $ i - 5 ) \/ 2 ; echo \" \u2581 \" ; } } $ n = 10 ; Nonagonal ( $ n ) ; ? >"}
{"text":"Find n | func for calualtion ; for summation of square of first n - natural nos . ; summation of first n natural nos . ; return result ; Driver Code","code":"< ? php function seriesFunc ( $ n ) { $ sumSquare = ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) \/ 6 ; $ sumNatural = ( $ n * ( $ n + 1 ) \/ 2 ) ; return ( $ sumSquare + $ sumNatural + 1 ) ; } $ n = 8 ; echo ( seriesFunc ( $ n ) . \" \" ) ; $ n = 13 ; echo ( seriesFunc ( $ n ) . \" \" ) ; ? >"}
{"text":"Program to check Plus Perfect Number | function to check plus perfect number ; calculating number of digits ; calculating plus perfect number ; checking whether number is plus perfect or not ; Driver Code","code":"< ? php function checkplusperfect ( $ x ) { $ temp = $ x ; $ n = 0 ; while ( $ x != 0 ) { $ x \/= 10 ; $ n ++ ; } $ x = $ temp ; $ sum = 0 ; while ( $ x != 0 ) { $ sum += pow ( $ x % 10 , $ n ) ; $ x \/= 10 ; } return ( $ sum == $ temp ) ; } $ x = 9474 ; if ( checkplusperfect ( ! $ x ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Number of distinct subsets of a set | Returns 2 ^ n ; Driver Code","code":"< ? php function subsetCount ( $ arr , $ n ) { return 1 << $ n ; } $ A = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ A ) ; echo ( subsetCount ( $ A , $ n ) ) ; ? >"}
{"text":"Program to calculate GST from original and net prices | PHP Program to compute GST from original and net prices . ; return value after calculate GST % ; Driver Code","code":"< ? php function Calculate_GST ( $ org_cost , $ N_price ) { return ( ( ( $ N_price - $ org_cost ) * 100 ) \/ $ org_cost ) ; } $ org_cost = 100 ; $ N_price = 120 ; echo ( \" GST \u2581 = \u2581 \" ) ; echo ( Calculate_GST ( $ org_cost , $ N_price ) ) ; echo ( \" \u2581 % \u2581 \" ) ; ? >"}
{"text":"Centered hexagonal number | Function to find centered hexadecimal number . ; Formula to calculate nth centered hexadecimal number and return it into main function . ; Driver Code","code":"< ? php function centeredHexagonalNumber ( $ n ) { return 3 * $ n * ( $ n - 1 ) + 1 ; } $ n = 10 ; echo $ n , \" th \u2581 centered \u2581 hexagonal \u2581 number : \u2581 \" ; echo centeredHexagonalNumber ( $ n ) ; ? >"}
{"text":"Find the distance covered to collect items at equal distances | function to calculate the distance ; Driver program","code":"< ? php function find_distance ( $ n ) { return $ n * ( ( 3 * $ n ) + 7 ) ; } $ n = 5 ; echo \" Distance = \" ? >"}
{"text":"Twin Prime Numbers | Please refer below post for details of this function https : goo . gl \/ Wv3fGv ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Returns true if n1 and n2 are twin primes ; Driver code","code":"< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function twinPrime ( $ n1 , $ n2 ) { return ( isPrime ( $ n1 ) && isPrime ( $ n2 ) && abs ( $ n1 - $ n2 ) == 2 ) ; } $ n1 = 11 ; $ n2 = 13 ; if ( twinPrime ( $ n1 , $ n2 ) ) echo \" Twin \u2581 Prime \" , \" STRNEWLINE \" ; else echo \" STRNEWLINE \" , \" Not \u2581 Twin \u2581 Prime \" , \" STRNEWLINE \" ; ? >"}
{"text":"Sum of the sequence 2 , 22 , 222 , ... ... ... | function which return the the sum of series ; Driver Code","code":"< ? php function sumOfSeries ( $ n ) { return 0.0246 * ( pow ( 10 , $ n ) - 1 - ( 9 * $ n ) ) ; } $ n = 3 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Find sum of even index binomial coefficients | Returns value of even indexed Binomial Coefficient Sum which is 2 raised to power n - 1. ; Driver Code","code":"< ? php function evenbinomialCoeffSum ( $ n ) { return ( 1 << ( $ n - 1 ) ) ; } $ n = 4 ; echo evenbinomialCoeffSum ( $ n ) ; ? >"}
{"text":"Program to print triangular number series till n | Function to find triangular number ; For each iteration increase j by 1 and add it into k ; Increasing j by 1 ; Add value of j into k and update k ; Driver Code","code":"< ? php function triangular_series ( $ n ) { $ i ; $ j = 1 ; $ k = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo ( \" \u2581 \" . $ k . \" \u2581 \" ) ; $ j = $ j + 1 ; $ k = $ k + $ j ; } } $ n = 5 ; triangular_series ( $ n ) ; ? >"}
{"text":"Sum of the series 1 + ( 1 + 3 ) + ( 1 + 3 + 5 ) + ( 1 + 3 + 5 + 7 ) + \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6 \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6 + ( 1 + 3 + 5 + 7 + \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6 + ( 2 n | functionn to find the sum of the given series ; required sum ; Driver Code","code":"< ? php function sumOfTheSeries ( $ n ) { return ( $ n * ( $ n + 1 ) \/ 2 ) * ( 2 * $ n + 1 ) \/ 3 ; } $ n = 5 ; echo \" Sum \u2581 = \u2581 \" . sumOfTheSeries ( $ n ) ; ? >"}
{"text":"Sum of the series 1 + ( 1 + 2 ) + ( 1 + 2 + 3 ) + ( 1 + 2 + 3 + 4 ) + ... ... + ( 1 + 2 + 3 + 4 + ... + n ) | Function to find sum of given series ; Driver Code","code":"< ? php function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum += $ j ; return $ sum ; } $ n = 10 ; echo ( sumOfSeries ( $ n ) ) ; ? >"}
{"text":"Number of triangles after N moves | function to calculate number of triangles in Nth step ; Driver Code","code":"< ? php function numberOfTriangles ( $ n ) { $ ans = 2 * ( pow ( 3 , $ n ) ) - 1 ; return $ ans ; } $ n = 2 ; echo numberOfTriangles ( $ n ) ; ? >"}
{"text":"Motzkin number | Return the nth Motzkin Number . ; Base case ; Finding i - th Motzkin number . ; Driven Code","code":"< ? php function motzkin ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = ( ( 2 * $ i + 1 ) * $ dp [ $ i - 1 ] + ( 3 * $ i - 3 ) * $ dp [ $ i - 2 ] ) \/ ( $ i + 2 ) ; return $ dp [ $ n ] ; } $ n = 8 ; echo ( motzkin ( $ n ) ) ; ? >"}
{"text":"Nicomachus\u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122 \u00c3\u0192\u00e2 \u20ac \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00e2 \u201e\u00a2\u00a2 \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00e2 \u20ac\u00a6\u00a1\u00ac \u00c3\u0192\u00c6 \u2019 \u00c3 \u2020 \u00e2 \u20ac\u2122\u00a2 \u00c3\u0192\u00c6 \u2019\u00a2 \u00c3\u0192 \u00a2 \u00c3 \u00a2 \u00e2 \u201a\u00ac \u00c5 \u00a1\u00ac \u00c3\u0192\u00e2 \u20ac\u00a6\u00be\u00a2 s Theorem ( Sum of k | Return the sum of kth group of positive odd integer . ; Driven Code","code":"< ? php function kthgroupsum ( $ k ) { return $ k * $ k * $ k ; } $ k = 3 ; echo kthgroupsum ( $ k ) ; ? >"}
{"text":"Find x , y , z that satisfy 2 \/ n = 1 \/ x + 1 \/ y + 1 \/ z | function to find x y and z that satisfy given equation . ; Driver Code","code":"< ? php function printXYZ ( $ n ) { if ( $ n == 1 ) echo - 1 ; else echo \" x \u2581 is \u2581 \" , $ n , \" STRNEWLINE y \u2581 is \u2581 \" , $ n + 1 , \" STRNEWLINE z \u2581 is \u2581 \" , $ n * ( $ n + 1 ) ; } $ n = 7 ; printXYZ ( $ n ) ; ? >"}
{"text":"Find n | Function to find nth term ; Driver code","code":"< ? php function term ( $ n ) { return $ n * ( $ n + 1 ) \/ 2 ; } $ n = 4 ; echo ( term ( $ n ) ) ; ? >"}
{"text":"Find Harmonic mean using Arithmetic mean and Geometric mean | Function to calculate arithmetic mean , geometric mean and harmonic mean ; Driver Code","code":"< ? php function compute ( $ a , $ b ) { $ AM ; $ GM ; $ HM ; $ AM = ( $ a + $ b ) \/ 2 ; $ GM = sqrt ( $ a * $ b ) ; $ HM = ( $ GM * $ GM ) \/ $ AM ; return $ HM ; } $ a = 5 ; $ b = 15 ; $ HM = compute ( $ a , $ b ) ; echo \" Harmonic \u2581 Mean \u2581 between \u2581 \" . $ a . \" \u2581 and \u2581 \" . $ b . \" \u2581 is \u2581 \" . $ HM ; return 0 ; ? >"}
{"text":"Find n | Returns n - th element of the series ; Driver Code","code":"< ? php function series ( $ n ) { return ( 8 * $ n * $ n ) + 1 ; } $ n = 5 ; echo ( series ( $ n ) ) ; ? >"}
{"text":"Check if a number is divisible by all prime divisors of another number | PHP program to find if all prime factors of y divide x . ; Returns true if all prime factors of y divide x . ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { return $ b == 0 ? $ a : gcd ( $ b , $ a % $ b ) ; } function isDivisible ( $ x , $ y ) { if ( $ y == 1 ) return true ; $ z = gcd ( $ x , $ y ) ; if ( $ z == 1 ) return false ; return isDivisible ( $ x , $ y \/ $ z ) ; } $ x = 18 ; $ y = 12 ; if ( isDivisible ( $ x , $ y ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Program to find Sum of a Series a ^ 1 \/ 1 ! + a ^ 2 \/ 2 ! + a ^ 3 \/ 3 ! + a ^ 4 \/ 4 ! + \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6 \u00c3 \u00a2 \u00e2 \u201a\u00ac\u00a6 . + a ^ n \/ n ! | Function to calculate sum of given series ; multiply ( a \/ i ) to previous term ; store result in res ; Driver Code","code":"< ? php function sumOfSeries ( $ a , $ num ) { $ res = 0 ; $ prev = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ prev *= ( $ a \/ $ i ) ; $ res = $ res + $ prev ; } return ( $ res ) ; } $ n = 5 ; $ a = 2 ; echo ( sumOfSeries ( $ a , $ n ) ) ; ? >"}
{"text":"Program for Celsius To Fahrenheit conversion | function to convert Celsius scale to Fahrenheit scale ; Driver Code","code":"< ? php function Cel_To_Fah ( $ n ) { return ( ( $ n * 9.0 \/ 5.0 ) + 32.0 ) ; } $ n = 20.0 ; echo Cel_To_Fah ( $ n ) ; ? >"}
{"text":"Series with largest GCD and sum equals to n | function to generate and print the sequence ; stores the maximum gcd that can be possible of sequence . ; if maximum gcd comes out to be zero then not possible ; the smallest gcd possible is 1 ; traverse the array to find out the max gcd possible ; checks if the number is divisible or not ; checks if x is smaller then the max gcd possible and x is greater then the resultant gcd till now , then r = x ; checks if n \/ x is smaller than the max gcd possible and n \/ x is greater then the resultant gcd till now , then r = x ; traverses and prints d , 2d , 3d , ... , ( k - 1 ) d , ; computes the last element of the sequence n - s . ; prints the last element ; Driver Code","code":"< ? php function print_sequence ( $ n , $ k ) { $ b = ( int ) ( $ n \/ ( $ k * ( $ k + 1 ) \/ 2 ) ) ; if ( $ b == 0 ) { echo ( -1 ) ; } else { $ r = 1 ; for ( $ x = 1 ; $ x * $ x <= $ n ; $ x ++ ) { if ( $ n % $ x != 0 ) continue ; if ( $ x <= $ b && $ x > $ r ) $ r = $ x ; if ( $ n \/ $ x <= $ b && $ n \/ $ x > $ r ) $ r = $ n \/ $ x ; } for ( $ i = 1 ; $ i < $ k ; $ i ++ ) echo ( $ r * $ i . \" \u2581 \" ) ; $ res = $ n - ( $ r * ( $ k * ( $ k - 1 ) \/ 2 ) ) ; echo ( $ res . \" \" ) ; } } $ n = 24 ; $ k = 4 ; print_sequence ( $ n , $ k ) ; $ n = 24 ; $ k = 5 ; print_sequence ( $ n , $ k ) ; $ n = 6 ; $ k = 4 ; print_sequence ( $ n , $ k ) ; ? >"}
{"text":"Number of compositions of a natural number | PHP program to find the total number of compositions of a natural number ; Return 2 raised to power ( n - 1 ) ; Driver Code","code":"< ? php function countCompositions ( $ n ) { return ( ( 1 ) << ( $ n - 1 ) ) ; } $ n = 4 ; echo countCompositions ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program to count digits in an integer ( 4 Different Methods ) | Recursive PHP program to count number of digits in a number ; Driver Code","code":"< ? php function countDigit ( $ n ) { if ( $ n \/ 10 == 0 ) return 1 ; return 1 + countDigit ( ( int ) ( $ n \/ 10 ) ) ; } $ n = 345289467 ; print ( \" Number \u2581 of \u2581 digits \u2581 : \u2581 \" . ( countDigit ( $ n ) ) ) ; ? >"}
{"text":"Tribonacci Numbers | A DP based PHP program to print first n Tribonacci numbers . ; Driver code","code":"< ? php function printTrib ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 0 ; $ dp [ 2 ] = 1 ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , \" \u2581 \" ; } $ n = 10 ; printTrib ( $ n ) ; ? >"}
{"text":"Tribonacci Numbers | Program to print first n tribonacci numbers Matrix Multiplication function for 3 * 3 matrix ; Recursive function to raise the matrix T to the power n ; base condition . ; recursively call to square the matrix ; calculating square of the matrix T ; if n is odd multiply it one time with M ; base condition ; $T [ 0 ] [ 0 ] contains the tribonacci number so return it ; Driver Code","code":"< ? php function multiply ( & $ T , $ M ) { $ a = $ T [ 0 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ T [ 0 ] [ 1 ] * $ M [ 1 ] [ 0 ] + $ T [ 0 ] [ 2 ] * $ M [ 2 ] [ 0 ] ; $ b = $ T [ 0 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ T [ 0 ] [ 1 ] * $ M [ 1 ] [ 1 ] + $ T [ 0 ] [ 2 ] * $ M [ 2 ] [ 1 ] ; $ c = $ T [ 0 ] [ 0 ] * $ M [ 0 ] [ 2 ] + $ T [ 0 ] [ 1 ] * $ M [ 1 ] [ 2 ] + $ T [ 0 ] [ 2 ] * $ M [ 2 ] [ 2 ] ; $ d = $ T [ 1 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ T [ 1 ] [ 1 ] * $ M [ 1 ] [ 0 ] + $ T [ 1 ] [ 2 ] * $ M [ 2 ] [ 0 ] ; $ e = $ T [ 1 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ T [ 1 ] [ 1 ] * $ M [ 1 ] [ 1 ] + $ T [ 1 ] [ 2 ] * $ M [ 2 ] [ 1 ] ; $ f = $ T [ 1 ] [ 0 ] * $ M [ 0 ] [ 2 ] + $ T [ 1 ] [ 1 ] * $ M [ 1 ] [ 2 ] + $ T [ 1 ] [ 2 ] * $ M [ 2 ] [ 2 ] ; $ g = $ T [ 2 ] [ 0 ] * $ M [ 0 ] [ 0 ] + $ T [ 2 ] [ 1 ] * $ M [ 1 ] [ 0 ] + $ T [ 2 ] [ 2 ] * $ M [ 2 ] [ 0 ] ; $ h = $ T [ 2 ] [ 0 ] * $ M [ 0 ] [ 1 ] + $ T [ 2 ] [ 1 ] * $ M [ 1 ] [ 1 ] + $ T [ 2 ] [ 2 ] * $ M [ 2 ] [ 1 ] ; $ i = $ T [ 2 ] [ 0 ] * $ M [ 0 ] [ 2 ] + $ T [ 2 ] [ 1 ] * $ M [ 1 ] [ 2 ] + $ T [ 2 ] [ 2 ] * $ M [ 2 ] [ 2 ] ; $ T [ 0 ] [ 0 ] = $ a ; $ T [ 0 ] [ 1 ] = $ b ; $ T [ 0 ] [ 2 ] = $ c ; $ T [ 1 ] [ 0 ] = $ d ; $ T [ 1 ] [ 1 ] = $ e ; $ T [ 1 ] [ 2 ] = $ f ; $ T [ 2 ] [ 0 ] = $ g ; $ T [ 2 ] [ 1 ] = $ h ; $ T [ 2 ] [ 2 ] = $ i ; } function power ( & $ T , $ n ) { if ( $ n == 0 $ n == 1 ) return ; $ M = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; power ( $ T , ( int ) ( $ n \/ 2 ) ) ; multiply ( $ T , $ T ) ; if ( $ n % 2 ) multiply ( $ T , $ M ) ; } function tribonacci ( $ n ) { $ T = array ( array ( 1 , 1 , 1 ) , array ( 1 , 0 , 0 ) , array ( 0 , 1 , 0 ) ) ; if ( $ n == 0 $ n == 1 ) return 0 ; else power ( $ T , $ n - 2 ) ; return $ T [ 0 ] [ 0 ] ; } $ n = 10 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo tribonacci ( $ i ) . \" \u2581 \" ; echo \" STRNEWLINE \" ; ? >"}
{"text":"Geometric mean ( Two Methods ) | function to calculate geometric mean and return float value . ; declare sum variable and initialize it to 1. ; Compute the sum of all the elements in the array . ; compute geometric mean through formula antilog ( ( ( log ( 1 ) + log ( 2 ) + . . . + log ( n ) ) \/ n ) and return the value ; Driver Code ; function call","code":"< ? php function geometricMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + log ( $ arr [ $ i ] ) ; $ sum = $ sum \/ $ n ; return exp ( $ sum ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) ; $ n = count ( $ arr ) ; echo geometricMean ( $ arr , $ n ) ; ? >"}
{"text":"Smallest number k such that the product of digits of k is equal to n | function to find smallest number k such that the product of digits of k is equal to n ; if ' n ' is a single digit number , then it is the required number ; stack the store the digits ; repeatedly divide ' n ' by the numbers from 9 to 2 until all the numbers are used or ' n ' > 1 ; save the digit ' i ' that divides ' n ' onto the stack ; if true , then no number ' k ' can be formed ; pop digits from the stack ' digits ' and add them to ' k ' ; required smallest number ; Driver code","code":"< ? php function smallestNumber ( $ n ) { if ( $ n >= 0 && $ n <= 9 ) return $ n ; $ digits = array ( ) ; for ( $ i = 9 ; $ i >= 2 && $ n > 1 ; $ i -- ) { while ( $ n % $ i == 0 ) { array_push ( $ digits , $ i ) ; $ n = ( int ) ( $ n \/ $ i ) ; } } if ( $ n != 1 ) return -1 ; $ k = 0 ; while ( ! empty ( $ digits ) ) $ k = $ k * 10 + array_pop ( $ digits ) ; return $ k ; } $ n = 100 ; echo smallestNumber ( $ n ) ; ? >"}
{"text":"Check if a number is magic ( Recursive sum of digits is 1 ) | PHP program to check if a number is Magic number . ; Note that the loop continues if n is 0 and sum is non - zero . It stops when n becomes 0 and sum becomes single digit . ; Return true if sum becomes 1. ; Driver code","code":"< ? php function isMagic ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n \/= 10 ; } return ( $ sum == 1 ) ; } $ n = 1234 ; if ( isMagic ( $ n ) ) echo \" Magic \u2581 Number \" ; else echo \" Not \u2581 a \u2581 magic \u2581 Number \" ; ? >"}
{"text":"Sylvester 's sequence | PHP program to print terms of Sylvester 's sequence ; To store the product . ; To store the current number . ; Loop till n . ; Driver Code","code":"< ? php $ N = 1000000007 ; function printSequence ( $ n ) { global $ N ; $ a = 1 ; $ ans = 2 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ ans , \" \" ; $ ans = ( ( $ a % $ N ) * ( $ ans % $ N ) ) % $ N ; $ a = $ ans ; $ ans = ( $ ans + 1 ) % $ N ; } } $ n = 6 ; printSequence ( $ n ) ; ? >"}
{"text":"Program to find sum of first n natural numbers | Returns sum of first n natural numbers ; Driver code","code":"< ? php function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; } $ n = 5 ; echo findSum ( $ n ) ; ? >"}
{"text":"Hailstone Numbers | function to print hailstone numbers and to calculate the number of steps required ; N is initially 1. ; N is reduced to 1. ; If N is Even . ; N is Odd . ; Driver Code ; Function to generate Hailstone Numbers ; Output : Number of Steps","code":"< ? php function HailstoneNumbers ( $ N ) { static $ c ; echo $ N . \" \" ; if ( $ N == 1 && $ c == 0 ) { return $ c ; } else if ( $ N == 1 && $ c != 0 ) { $ c ++ ; return $ c ; } else if ( $ N % 2 == 0 ) { $ c ++ ; HailstoneNumbers ( ( int ) ( $ N \/ 2 ) ) ; } else if ( $ N % 2 != 0 ) { $ c ++ ; HailstoneNumbers ( 3 * $ N + 1 ) ; } return $ c ; } $ N = 7 ; $ x = HailstoneNumbers ( $ N ) ; echo \" Number of Steps : \" ? >"}
{"text":"Find m | Function to return mth summation ; base case ; Driver Code","code":"< ? php function SUM ( $ n , $ m ) { if ( $ m == 1 ) return ( $ n * ( $ n + 1 ) \/ 2 ) ; $ sum = SUM ( $ n , $ m - 1 ) ; return ( $ sum * ( $ sum + 1 ) \/ 2 ) ; } $ n = 5 ; $ m = 3 ; echo \" SUM ( \" , $ n , \" , \u2581 \" , $ m , \" ) : \u2581 \" , SUM ( $ n , $ m ) ; ? >"}
{"text":"Find smallest number n such that n XOR n + 1 equals to given k . | function to return the required n ; if k is of form 2 ^ i - 1 ; Driver Code","code":"< ? php function xorCalc ( $ k ) { if ( $ k == 1 ) return 2 ; if ( ( ( $ k + 1 ) & $ k ) == 0 ) return floor ( $ k \/ 2 ) ; return 1 ; } $ k = 31 ; echo xorCalc ( $ k ) ; ? >"}
{"text":"Find n | PHP program to find n - th number containing only 4 and 7. ; If n is odd , append 4 and move to parent ; If n is even , append 7 and move to parent ; Reverse res and return . ; Driver code","code":"< ? php function findNthNo ( $ n ) { $ res = \" \" ; while ( $ n >= 1 ) { if ( $ n & 1 ) { $ res = $ res . \"4\" ; $ n = ( int ) ( ( $ n - 1 ) \/ 2 ) ; } else { $ res = $ res . \"7\" ; $ n = ( int ) ( ( $ n - 2 ) \/ 2 ) ; } } return strrev ( $ res ) ; } $ n = 13 ; echo findNthNo ( $ n ) ; ? >"}
{"text":"Total number of divisors for a given number | program for finding no . of divisors ; sieve method for prime calculation ; Traversing through all prime numbers ; calculate number of divisor with formula total div = ( p1 + 1 ) * ( p2 + 1 ) * ... . . * ( pn + 1 ) where n = ( a1 ^ p1 ) * ( a2 ^ p2 ) . ... * ( an ^ pn ) ai being prime divisor for n and pi are their respective power in factorization ; Driver Code","code":"< ? php function divCount ( $ n ) { $ hash = array_fill ( 0 , $ n + 1 , 1 ) ; for ( $ p = 2 ; ( $ p * $ p ) < $ n ; $ p ++ ) if ( $ hash [ $ p ] == 1 ) for ( $ i = ( $ p * 2 ) ; $ i < $ n ; $ i = ( $ i + $ p ) ) $ hash [ $ i ] = 0 ; $ total = 1 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ hash [ $ p ] == 1 ) { $ count = 0 ; if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) { $ n = ( $ n \/ $ p ) ; $ count ++ ; } $ total = $ total * ( $ count + 1 ) ; } } } return $ total ; } $ n = 24 ; echo divCount ( $ n ) ; ? >"}
{"text":"Maximum number of unique prime factors | Return smallest number having maximum prime factors . ; Sieve of eratosthenes method to count number of unique prime factors . ; Return maximum element in arr [ ] ; Driver Code","code":"< ? php function maxPrimefactorNum ( $ N ) { $ arr = array_fill ( 0 , $ N + 1 , 0 ) ; for ( $ i = 2 ; $ i * $ i <= $ N ; $ i ++ ) { if ( ! $ arr [ $ i ] ) for ( $ j = 2 * $ i ; $ j <= $ N ; $ j += $ i ) $ arr [ $ j ] ++ ; $ arr [ $ i ] = 1 ; } return max ( $ arr ) ; } $ N = 40 ; echo maxPrimefactorNum ( $ N ) ; ? >"}
{"text":"Decimal to binary conversion without using arithmetic operators | function for decimal to binary conversion without using arithmetic operators ; to store the binary equivalent of decimal ; to get the last binary digit of the number ' n ' and accumulate it at the beginning of ' bin ' ; right shift ' n ' by 1 ; required binary number ; Driver Code","code":"< ? php function decToBin ( $ n ) { if ( $ n == 0 ) return \"0\" ; $ bin = \" \" ; while ( $ n > 0 ) { $ bin = ( ( $ n & 1 ) == 0 ? '0' : '1' ) . $ bin ; $ n >>= 1 ; } return $ bin ; } $ n = 38 ; echo decToBin ( $ n ) ; ? >"}
{"text":"Sum of array elements that is first continuously increasing then decreasing | Efficient PHP method to find sum of the elements of array that is halfway increasing and then halfway decreassing ; Driver code","code":"< ? php function arraySum ( $ arr , $ n ) { $ x = ( $ n + 1 ) \/ 2 ; return ( $ arr [ 0 ] - 1 ) * $ n + $ x * $ x ; } $ arr = array ( 10 , 11 , 12 , 13 , 12 , 11 , 10 ) ; $ n = sizeof ( $ arr ) ; echo ( arraySum ( $ arr , $ n ) ) ; ? >"}
{"text":"Balance pans using given weights that are powers of a number | method returns true if balancing of scale is possible ; baseForm vector will store T 's  representation on base a in reverse order ; convert T to representation on base a ; make first digit of representation as 0 ; loop over base representation of T ; if any digit is not 0 , 1 , ( a - 1 ) or a then balancing is not possible ; if digit is a or ( a - 1 ) then increase left index ' s \u2581 count \/ \u2581 ( case , \u2581 when \u2581 this \u2581 weight \u2581 is \u2581 transferred \u2581 to \u2581 T ' s side ) ; if representation is processed then balancing is possible ; Driver Code","code":"< ? php function isBalancePossible ( $ T , $ a ) { $ baseForm = array ( ) ; while ( $ T ) { array_push ( $ baseForm , $ T % $ a ) ; $ T = ( int ) ( $ T \/ $ a ) ; } array_push ( $ baseForm , 0 ) ; for ( $ i = 0 ; $ i < count ( $ baseForm ) ; $ i ++ ) { if ( $ baseForm [ $ i ] != 0 && $ baseForm [ $ i ] != 1 && $ baseForm [ $ i ] != ( $ a - 1 ) && $ baseForm [ $ i ] != $ a ) return false ; if ( $ baseForm [ $ i ] == $ a || $ baseForm [ $ i ] == ( $ a - 1 ) ) $ baseForm [ $ i + 1 ] += 1 ; } return true ; } $ T = 11 ; $ a = 4 ; $ balancePossible = isBalancePossible ( $ T , $ a ) ; if ( $ balancePossible ) echo \" Balance \u2581 is \u2581 possible STRNEWLINE \" ; else echo \" Balance \u2581 is \u2581 not \u2581 possible STRNEWLINE \" ; ? >"}
{"text":"Number of digits in the product of two numbers | function to count number of digits in the product of two numbers ; if either of the number is 0 , then product will be 0 ; required count of digits ; Driver Code","code":"< ? php function countDigits ( $ a , $ b ) { if ( $ a == 0 or $ b == 0 ) return 1 ; return floor ( log10 ( abs ( $ a ) ) + log10 ( abs ( $ b ) ) ) + 1 ; } $ a = 33 ; $ b = -24 ; echo countDigits ( $ a , $ b ) ; ? >"}
{"text":"Distributing M items in a circle of size N starting from K | n == > Size of circle m == > Number of items k == > Initial position ; n - k + 1 is number of positions before we reach beginning of circle . If m is less than this value , then we can simply return ( m - 1 ) th position ; Let us compute remaining items before we reach beginning . ; We compute m % n to skip all complete rounds . If we reach end , we return n else we return m % n ; Driver code","code":"< ? php function lastPosition ( $ n , $ m , $ k ) { if ( $ m <= $ n - $ k + 1 ) return $ m + $ k - 1 ; $ m = $ m - ( $ n - $ k + 1 ) ; return ( $ m % $ n == 0 ) ? $ n : ( $ m % $ n ) ; } $ n = 5 ; $ m = 8 ; $ k = 2 ; echo lastPosition ( $ n , $ m , $ k ) ; ? >"}
{"text":"An interesting solution to get all prime numbers smaller than n | PHP program to prints prime numbers smaller than n ; Compute factorials and apply Wilson 's  theorem. ; Driver code","code":"< ? php function primesInRange ( $ n ) { $ fact = 1 ; for ( $ k = 2 ; $ k < $ n ; $ k ++ ) { $ fact = $ fact * ( $ k - 1 ) ; if ( ( $ fact + 1 ) % $ k == 0 ) print ( $ k . \" STRNEWLINE \" ) ; } } $ n = 15 ; primesInRange ( $ n ) ; ? >"}
{"text":"A product array puzzle | Set 2 ( O ( 1 ) Space ) | epsilon value to maintain precision ; to hold sum of all values ; output product for each index antilog to find original product value ; Driver code","code":"< ? php $ EPS = 1e-9 ; function productPuzzle ( $ a , $ n ) { global $ EPS ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( double ) log10 ( $ a [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( int ) ( $ EPS + pow ( ( double ) 10.00 , $ sum - log10 ( $ a [ $ i ] ) ) ) . \" \u2581 \" ; } $ a = array ( 10 , 3 , 5 , 6 , 2 ) ; $ n = count ( $ a ) ; echo \" The \u2581 product \u2581 array \u2581 is : \u2581 STRNEWLINE \" ; productPuzzle ( $ a , $ n ) ; ? >"}
{"text":"Change all even bits in a number to 0 | Returns modified number with all even bits 0. ; To store sum of bits at even positions . ; To store bits to shift ; One by one put all even bits to end ; If current last bit is set , add it to ans ; Next shift position ; Driver code","code":"< ? php function changeEvenBits ( $ n ) { $ to_subtract = 0 ; $ m = 0 ; for ( $ x = $ n ; $ x ; $ x >>= 2 ) { if ( $ x & 1 ) $ to_subtract += ( 1 << $ m ) ; $ m += 2 ; } return $ n - $ to_subtract ; } $ n = 30 ; echo changeEvenBits ( $ n ) ; ? >"}
{"text":"Find the number closest to n and divisible by m | function to find the number closest to n and divisible by m ; find the quotient ; 1 st possible closest number ; 2 nd possible closest number ; if true , then n1 is the required closest number ; else n2 is the required closest number ; Driver Code","code":"< ? php function closestNumber ( $ n , $ m ) { $ q = ( int ) ( $ n \/ $ m ) ; $ n1 = $ m * $ q ; $ n2 = ( $ n * $ m ) > 0 ? ( $ m * ( $ q + 1 ) ) : ( $ m * ( $ q - 1 ) ) ; if ( abs ( $ n - $ n1 ) < abs ( $ n - $ n2 ) ) return $ n1 ; return $ n2 ; } $ n = 13 ; $ m = 4 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; $ n = -15 ; $ m = 6 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; $ n = 0 ; $ m = 8 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; $ n = 18 ; $ m = -7 ; echo closestNumber ( $ n , $ m ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if a given number is Pronic | function to check Pronic Number ; Checking Pronic Number by multiplying consecutive numbers ; Printing Pronic Numbers upto 200","code":"< ? php function checkPronic ( $ x ) { for ( $ i = 0 ; $ i <= ( sqrt ( $ x ) ) ; $ i ++ ) if ( $ x == $ i * ( $ i + 1 ) ) return true ; return false ; } for ( $ i = 0 ; $ i <= 200 ; $ i ++ ) if ( checkPronic ( $ i ) ) echo $ i , \" \u2581 \" ; ? >"}
{"text":"Find minimum sum of factors of number | To find minimum sum of product of number ; Find factors of number and add to the sum ; Return sum of numbers having minimum product ; Driver Code","code":"< ? php function findMinSum ( $ num ) { $ sum = 0 ; for ( $ i = 2 ; $ i * $ i <= $ num ; $ i ++ ) { while ( $ num % $ i == 0 ) { $ sum += $ i ; $ num \/= $ i ; } } $ sum += $ num ; return $ sum ; } $ num = 12 ; echo ( findMinSum ( $ num ) ) ; ? >"}
{"text":"Minimum number with digits as 4 and 7 only and given sum | Prints minimum number with given digit sum and only allowed digits as 4 and 7. ; Cases where all remaining digits are 4 or 7 ( Remaining sum of digits should be multiple of 4 or 7 ) ; If both 4 s and 7 s are there in digit sum , we subtract a 4. ; Driver code","code":"< ? php function findMin ( $ sum ) { $ a = 0 ; $ b = 0 ; while ( $ sum > 0 ) { if ( $ sum % 7 == 0 ) { $ b ++ ; $ sum -= 7 ; } else if ( $ sum % 4 == 0 ) { $ a ++ ; $ sum -= 4 ; } else { $ a ++ ; $ sum -= 4 ; } } if ( $ sum < 0 ) { echo ( \" - 1n \" ) ; return ; } for ( $ i = 0 ; $ i < $ a ; $ i ++ ) echo ( \"4\" ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) echo ( \"7\" ) ; echo ( \" STRNEWLINE \" ) ; } findMin ( 15 ) ; ? >"}
{"text":"Add minimum number to an array so that the sum becomes even | Function to find out minimum number ; Count odd number of terms in array ; Driver code","code":"< ? php function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd += 1 ; return ( $ odd % 2 ) ? 1 : 2 ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; $ n = count ( $ arr ) ; echo minNum ( $ arr , $ n ) ; ? >"}
{"text":"Find maximum number that can be formed using digits of a given number | Function to print the maximum number ; hashed array to store count of digits ; Converting given number to string ; Updating the count array ; result is to store the final number ; Traversing the count array to calculate the maximum number ; return the result ; Driver program to test above function","code":"< ? php function printMaxNum ( $ num ) { $ count = array_fill ( 0 , 10 , NULL ) ; $ str = ( string ) $ num ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - ord ( '0' ) ] ++ ; $ result = 0 ; $ multiplier = 1 ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { while ( $ count [ $ i ] > 0 ) { $ result = $ result + ( $ i * $ multiplier ) ; $ count [ $ i ] -- ; $ multiplier = $ multiplier * 10 ; } } return $ result ; } $ num = 38293367 ; echo printMaxNum ( $ num ) ; ? >"}
{"text":"Form the largest number using at most one swap operation | function to form the largest number by applying atmost one swap operation ; for the rightmost digit , there will be no greater right digit ; index of the greatest right digit till the current index from the right direction ; traverse the array from second right element up to the left element ; if ' num [ i ] ' is less than the greatest digit encountered so far ; else ; there is no greater right digit for ' num [ i ] ' ; update ' right ' index ; traverse the ' rightMax [ ] ' array from left to right ; if for the current digit , greater right digit exists then swap it with its greater right digit and break ; performing the required swap operation ; required largest number ; Driver Code","code":"< ? php function largestNumber ( $ num ) { $ n = strlen ( $ num ) ; $ rightMax [ $ n ] = array ( 0 ) ; $ right ; $ rightMax [ $ n - 1 ] = -1 ; $ right = $ n - 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ num [ $ i ] < $ num [ $ right ] ) $ rightMax [ $ i ] = $ right ; else { $ rightMax [ $ i ] = -1 ; $ right = $ i ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ rightMax [ $ i ] != -1 ) { list ( $ num [ $ i ] , $ num [ $ rightMax [ $ i ] ] ) = array ( $ num [ $ rightMax [ $ i ] ] , $ num [ $ i ] ) ; break ; } } return $ num ; } $ num = \"8725634\" ; echo \" Largest \u2581 number : \u2581 \" , largestNumber ( $ num ) ; ? >"}
{"text":"Binomial Random Variables | function to calculate nCr i . e . , number of ways to choose r out of n objects ; Since nCr is same as nC ( n - r ) To decrease number of iterations ; function to calculate binomial r . v . probability ; Driver code","code":"< ? php function nCr ( $ n , $ r ) { if ( $ r > $ n \/ 2 ) $ r = $ n - $ r ; $ answer = 1 ; for ( $ i = 1 ; $ i <= $ r ; $ i ++ ) { $ answer *= ( $ n - $ r + $ i ) ; $ answer \/= $ i ; } return $ answer ; } function binomialProbability ( $ n , $ k , $ p ) { return nCr ( $ n , $ k ) * pow ( $ p , $ k ) * pow ( 1 - $ p , $ n - $ k ) ; } $ n = 10 ; $ k = 5 ; $ p = 1.0 \/ 3 ; $ probability = binomialProbability ( $ n , $ k , $ p ) ; echo \" Probability \u2581 of \u2581 \" . $ k ; echo \" \u2581 heads \u2581 when \u2581 a \u2581 coin \u2581 is \u2581 tossed \u2581 \" . $ n ; echo \" \u2581 times \u2581 where \u2581 probability \u2581 of \u2581 \" . \" each \u2581 head \u2581 is \u2581 \" . $ p ; echo \" is = \" ? >"}
{"text":"Find pair with maximum GCD in an array | Function to find GCD of pair with max GCD in the array ; Computing highest element ; Array to store the count of divisors i . e . Potential GCDs ; Iterating over every element ; Calculating all the divisors ; Divisor found ; Incrementing count for divisor ; Element \/ divisor is also a divisor Checking if both divisors are not same ; Checking the highest potential GCD ; If this divisor can divide at least 2 numbers , it is a GCD of at least 1 pair ; Array in which pair with max GCD is to be found ; Size of array","code":"< ? php function findMaxGCD ( $ arr , $ n ) { $ high = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ high = max ( $ high , $ arr [ $ i ] ) ; $ divisors = array_fill ( 0 , $ high + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= ( int ) ( sqrt ( $ arr [ $ i ] ) ) ; $ j ++ ) { if ( $ arr [ $ i ] % $ j == 0 ) { $ divisors [ $ j ] ++ ; if ( $ j != ( int ) ( $ arr [ $ i ] \/ $ j ) ) $ divisors [ ( int ) ( $ arr [ $ i ] \/ $ j ) ] ++ ; } } } for ( $ i = $ high ; $ i >= 1 ; $ i -- ) if ( $ divisors [ $ i ] > 1 ) return $ i ; } $ arr = array ( 1 , 2 , 4 , 8 , 8 , 12 ) ; $ n = sizeof ( $ arr ) ; echo findMaxGCD ( $ arr , $ n ) ; ? >"}
{"text":"Find pair with maximum GCD in an array | function to find GCD of pair with max GCD in the array ; Calculating MAX in array ; Maintaining count array ; Variable to store the multiples of a number ; Iterating from MAX to 1 GCD is always between MAX and 1. The first GCD found will be the highest as we are decrementing the potential GCD ; Iterating from current potential GCD till it is less than MAX ; A multiple found ; Incrementing potential GCD by itself To check i , 2 i , 3 i ... . ; 2 multiples found , max GCD found ; Array in which pair with max GCD is to be found ; Size of array","code":"< ? php function findMaxGCD ( $ arr , $ n ) { $ high = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ high = max ( $ high , $ arr [ $ i ] ) ; $ count = array_fill ( 0 , $ high + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ $ arr [ $ i ] ] ++ ; $ counter = 0 ; for ( $ i = $ high ; $ i >= 1 ; $ i -- ) { $ j = $ i ; $ counter = 0 ; while ( $ j <= $ high ) { if ( $ count [ $ j ] >= 2 ) return $ j ; else if ( $ count [ $ j ] == 1 ) $ counter ++ ; $ j += $ i ; if ( $ counter == 2 ) return $ i ; } } } $ arr = array ( 1 , 2 , 4 , 8 , 8 , 12 ) ; $ n = count ( $ arr ) ; print ( findMaxGCD ( $ arr , $ n ) ) ; ? >"}
{"text":"Evil Number | returns number of 1 s from the binary number ; counting 1 s ; Check if number is evil or not ; converting n to binary form ; calculating remainder ; storing the remainders in binary form as a number ; Calling the count_one function to count and return number of 1 s in bin ; Driver Code","code":"< ? php function count_one ( $ n ) { $ c_one = 0 ; while ( $ n != 0 ) { $ rem = $ n % 10 ; if ( $ rem == 1 ) $ c_one = $ c_one + 1 ; $ n = $ n \/ 10 ; } return $ c_one ; } function checkEvil ( $ n ) { $ i = 0 ; $ bin = 0 ; $ n_one = 0 ; while ( $ n != 0 ) { $ r = $ n % 2 ; $ bin = $ bin + $ r * ( pow ( 10 , $ i ) ) ; $ n = $ n \/ 2 ; } $ n_one = count_one ( $ bin ) ; if ( $ n_one % 2 == 0 ) return 1 ; else return 0 ; } $ i ; $ check ; $ num ; $ num = 32 ; $ check = checkEvil ( $ num ) ; if ( $ check == 1 ) echo $ num , \" \u2581 is \u2581 Evil \u2581 Number STRNEWLINE \" ; else echo $ num , \" \u2581 is \u2581 Odious \u2581 Number STRNEWLINE \" ; ? >"}
{"text":"Count number of pairs ( A <= N , B <= N ) such that gcd ( A , B ) is B | returns number of valid pairs ; initialize k ; loop till imin <= n ; Initialize result ; max i with given k floor ( n \/ k ) ; adding k * ( number of i with floor ( n \/ i ) = k to ans ; set imin = imax + 1 and k = n \/ imin ; Driver Code","code":"< ? php function CountPairs ( $ n ) { $ k = $ n ; $ imin = 1 ; $ ans = 0 ; while ( $ imin <= $ n ) { $ imax = $ n \/ $ k ; $ ans += $ k * ( $ imax - $ imin + 1 ) ; $ imin = $ imax + 1 ; $ k = ( int ) ( $ n \/ $ imin ) ; } return $ ans ; } echo ( CountPairs ( 1 ) . \" STRNEWLINE \" ) ; echo ( CountPairs ( 2 ) . \" STRNEWLINE \" ) ; echo ( CountPairs ( 3 ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Find the last digit of given series | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; $x = $x % $p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now $y = $y >> 1 ; y = y \/ 2 ; Returns modulo inverse of a with respect to m using extended Euclid Algorithm ; q is quotient ; m is remainder now , process same as Euclid 's algo  ; Make x1 positive ; Function to calculate the above expression ; Initialize the result ; Compute first part of expression ; Compute second part of expression i . e . , ( ( 4 ^ ( n + 1 ) - 1 ) \/ 3 ) mod 10 Since division of 3 in modulo can ' t \u2581 \u2581 \u2581 be \u2581 performed \u2581 directly \u2581 therefore \u2581 we \u2581 \u2581 \u2581 need \u2581 to \u2581 find \u2581 it ' s modulo Inverse ; Driver code","code":"< ? php function powermod ( $ x , $ y , $ p ) { while ( $ y > 0 ) { if ( ( $ y & 1 ) > 0 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function modInverse ( $ a , $ m ) { $ m0 = $ m ; $ x0 = 0 ; $ x1 = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a \/ $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ x0 ; $ x0 = $ x1 - $ q * $ x0 ; $ x1 = $ t ; } if ( $ x1 < 0 ) $ x1 += $ m0 ; return $ x1 ; } function evaluteExpression ( $ n ) { $ firstsum = 0 ; $ mod = 10 ; for ( $ i = 2 , $ j = 0 ; ( 1 << $ j ) <= $ n ; $ i *= $ i , ++ $ j ) $ firstsum = ( $ firstsum + $ i ) % $ mod ; $ secondsum = ( powermod ( 4 , $ n + 1 , $ mod ) - 1 ) * modInverse ( 3 , $ mod ) ; return ( $ firstsum * $ secondsum ) % $ mod ; } $ n = 3 ; echo evaluteExpression ( $ n ) . \" STRNEWLINE \" ; $ n = 10 ; echo evaluteExpression ( $ n ) ; ? >"}
{"text":"Finding power of prime number p in n ! | Returns power of p in n ! ; initializing answer ; initializing ; loop until temp <= n ; add number of numbers divisible by n ; each time multiply temp by p ; Driver function","code":"< ? php function PowerOFPINnfactorial ( $ n , $ p ) { $ ans = 0 ; $ temp = $ p ; while ( $ temp <= $ n ) { $ ans += $ n \/ $ temp ; $ temp = $ temp * $ p ; } return $ ans ; } echo PowerOFPINnfactorial ( 4 , 2 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program for Binary To Decimal Conversion | Function to convert binary to decimal ; Initializing base value to 1 , i . e 2 ^ 0 ; Driver Code","code":"< ? php function binaryToDecimal ( $ n ) { $ num = $ n ; $ dec_value = 0 ; $ base = 1 ; $ temp = $ num ; while ( $ temp ) { $ last_digit = $ temp % 10 ; $ temp = $ temp \/ 10 ; $ dec_value += $ last_digit * $ base ; $ base = $ base * 2 ; } return $ dec_value ; } $ num = 10101001 ; echo binaryToDecimal ( $ num ) , \" STRNEWLINE \" ; ? >"}
{"text":"Calculating Factorials using Stirling Approximation | Function for calculating factorial ; value of natural e ; evaluating factorial using stirling approximation ; Driver Code","code":"< ? php function stirlingFactorial ( $ n ) { if ( $ n == 1 ) return 1 ; $ z ; $ e = 2.71 ; $ z = sqrt ( 2 * 3.14 * $ n ) * pow ( ( $ n \/ $ e ) , $ n ) ; return floor ( $ z ) ; } echo stirlingFactorial ( 1 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 2 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 3 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 4 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 5 ) , \" STRNEWLINE \" ; echo stirlingFactorial ( 6 ) , \" \u2581 STRNEWLINE \" ; echo stirlingFactorial ( 7 ) , \" \u2581 STRNEWLINE \" ; ? >"}
{"text":"Count pairs with Odd XOR | A function will return number of pair whose XOR is odd ; To store count of odd and even numbers ; Increase even if number is even otherwise increase odd ; Return number of pairs ; Driver Code","code":"< ? php function countXorPair ( $ arr , $ n ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } return $ odd * $ even ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo countXorPair ( $ arr , $ n ) ; ? >"}
{"text":"Lychrel Number Implementation | Max Iterations ; Function to check whether number is Lychrel Number ; Function to check whether the number is Palindrome ; Function to reverse the number ; Driver Code","code":"< ? php $ MAX_ITERATIONS = 20 ; function isLychrel ( $ number ) { global $ MAX_ITERATIONS ; for ( $ i = 0 ; $ i < $ MAX_ITERATIONS ; $ i ++ ) { $ number = $ number + reverse ( $ number ) ; if ( isPalindrome ( $ number ) ) return \" false \" ; } return \" true \" ; } function isPalindrome ( $ number ) { return $ number == reverse ( $ number ) ; } function reverse ( $ number ) { $ reverse = 0 ; while ( $ number > 0 ) { $ remainder = $ number % 10 ; $ reverse = ( $ reverse * 10 ) + $ remainder ; $ number = ( int ) ( $ number \/ 10 ) ; } return $ reverse ; } $ number = 295 ; echo $ number . \" \u2581 is \u2581 lychrel ? \u2581 \" . isLychrel ( $ number ) ; ? >"}
{"text":"Rectangular ( or Pronic ) Numbers | Returns n - th rectangular number ; Driver Code","code":"< ? php function findRectNum ( $ n ) { return $ n * ( $ n + 1 ) ; } $ n = 6 ; echo findRectNum ( $ n ) ; ? >"}
{"text":"Program for Muller Method | PHP Program to find root of a function , f ( x ) ; Function to calculate f ( x ) ; Taking f ( x ) = x ^ 3 + 2 x ^ 2 + 10 x - 20 ; Calculating various constants required to calculate x3 ; Taking the root which is closer to x2 ; checking for resemblance of x3 with x2 till two decimal places ; Driver main function","code":"< ? php $ MAX_ITERATIONS = 10000 ; function f ( $ x ) { return 1 * pow ( $ x , 3 ) + 2 * $ x * $ x + 10 * $ x - 20 ; } function Muller ( $ a , $ b , $ c ) { global $ MAX_ITERATIONS ; $ res = 0 ; for ( $ i = 0 ; ; ++ $ i ) { $ f1 = f ( $ a ) ; $ f2 = f ( $ b ) ; $ f3 = f ( $ c ) ; $ d1 = $ f1 - $ f3 ; $ d2 = $ f2 - $ f3 ; $ h1 = $ a - $ c ; $ h2 = $ b - $ c ; $ a0 = $ f3 ; $ a1 = ( ( ( $ d2 * pow ( $ h1 , 2 ) ) - ( $ d1 * pow ( $ h2 , 2 ) ) ) \/ ( ( $ h1 * $ h2 ) * ( $ h1 - $ h2 ) ) ) ; $ a2 = ( ( ( $ d1 * $ h2 ) - ( $ d2 * $ h1 ) ) \/ ( ( $ h1 * $ h2 ) * ( $ h1 - $ h2 ) ) ) ; $ x = ( ( -2 * $ a0 ) \/ ( $ a1 + abs ( sqrt ( $ a1 * $ a1 - 4 * $ a0 * $ a2 ) ) ) ) ; $ y = ( ( -2 * $ a0 ) \/ ( $ a1 - abs ( sqrt ( $ a1 * $ a1 - 4 * $ a0 * $ a2 ) ) ) ) ; if ( $ x >= $ y ) $ res = $ x + $ c ; else $ res = $ y + $ c ; $ m = $ res * 100 ; $ n = $ c * 100 ; $ m = floor ( $ m ) ; $ n = floor ( $ n ) ; if ( $ m == $ n ) break ; $ a = $ b ; $ b = $ c ; $ c = $ res ; if ( $ i > $ MAX_ITERATIONS ) { echo \" Root \u2581 cannot \u2581 be \u2581 found \u2581 using \u2581 Muller ' s \u2581 method \" ; break ; } } if ( $ i <= $ MAX_ITERATIONS ) echo \" The \u2581 value \u2581 of \u2581 the \u2581 root \u2581 is \u2581 \" . round ( $ res , 4 ) ; } $ a = 0 ; $ b = 1 ; $ c = 2 ; Muller ( $ a , $ b , $ c ) ; ? >"}
{"text":"Optimized Euler Totient Function for Multiple Evaluations | PHP program to efficiently compute values of euler totient function for multiple inputs . ; Stores prime numbers upto MAX - 1 values ; Finds prime numbers upto MAX - 1 and stores them in vector p ; if prime [ i ] is not marked before ; fill vector for every newly encountered prime ; run this loop till square root of MAX , mark the index i * j as not prime ; function to find totient of n ; this loop runs sqrt ( n \/ ln ( n ) ) times ; subtract multiples of p [ i ] from r ; Remove all occurrences of p [ i ] in n ; when n has prime factor greater than sqrt ( n ) ; preprocess all prime numbers upto 10 ^ 5","code":"< ? php $ MAX = 100001 ; $ p = array ( ) ; function sieve ( ) { global $ MAX , $ p ; $ isPrime = array_fill ( 0 , $ MAX + 1 , 0 ) ; for ( $ i = 2 ; $ i <= $ MAX ; $ i ++ ) { if ( $ isPrime [ $ i ] == 0 ) { array_push ( $ p , $ i ) ; for ( $ j = 2 ; $ i * $ j <= $ MAX ; $ j ++ ) $ isPrime [ $ i * $ j ] = 1 ; } } } function phi ( $ n ) { global $ p ; $ res = $ n ; for ( $ i = 0 ; $ p [ $ i ] * $ p [ $ i ] <= $ n ; $ i ++ ) { if ( $ n % $ p [ $ i ] == 0 ) { $ res -= ( int ) ( $ res \/ $ p [ $ i ] ) ; while ( $ n % $ p [ $ i ] == 0 ) $ n = ( int ) ( $ n \/ $ p [ $ i ] ) ; } } if ( $ n > 1 ) $ res -= ( int ) ( $ res \/ $ n ) ; return $ res ; } sieve ( ) ; print ( phi ( 11 ) . \" STRNEWLINE \" ) ; print ( phi ( 21 ) . \" STRNEWLINE \" ) ; print ( phi ( 31 ) . \" STRNEWLINE \" ) ; print ( phi ( 41 ) . \" STRNEWLINE \" ) ; print ( phi ( 51 ) . \" STRNEWLINE \" ) ; print ( phi ( 61 ) . \" STRNEWLINE \" ) ; print ( phi ( 91 ) . \" STRNEWLINE \" ) ; print ( phi ( 101 ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Finding n | Prints n - th number where each digit is a prime number ; Finding the length of n - th number ; Count of numbers with len - 1 digits ; Count of numbers with i digits ; if i is the length of such number then n < 4 * ( 4 ^ ( i - 1 ) - 1 ) \/ 3 and n >= 4 * ( 4 ^ i - 1 ) \/ 3 if a valid i is found break the loop ; check for i + 1 ; Finding ith digit at ith place ; j = 1 means 2 j = 2 means ... j = 4 means 7 ; if prev_count + 4 ^ ( len - i ) is less than n , increase prev_count by 4 ^ ( x - i ) ; else print the ith digit and break ; Driver Code","code":"< ? php function nthprimedigitsnumber ( $ n ) { $ len = 1 ; $ prev_count = 0 ; while ( true ) { $ curr_count = $ prev_count + pow ( 4 , $ len ) ; if ( $ prev_count < $ n && $ curr_count >= $ n ) break ; $ len ++ ; $ prev_count = $ curr_count ; } for ( $ i = 1 ; $ i <= $ len ; $ i ++ ) { for ( $ j = 1 ; $ j <= 4 ; $ j ++ ) { if ( $ prev_count + pow ( 4 , $ len - $ i ) < $ n ) $ prev_count += pow ( 4 , $ len - $ i ) ; else { if ( $ j == 1 ) echo \"2\" ; else if ( $ j == 2 ) echo \"3\" ; else if ( $ j == 3 ) echo \"5\" ; else if ( $ j == 4 ) echo \"7\" ; break ; } } } echo \" STRNEWLINE \" ; } nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; ? >"}
{"text":"Cassini\u00e2 \u20ac\u2122 s Identity | Returns ( - 1 ) ^ n ; Driver Code","code":"< ? php function cassini ( $ n ) { return ( $ n & 1 ) ? -1 : 1 ; } $ n = 5 ; echo ( cassini ( $ n ) ) ; ? >"}
{"text":"Find if a number is divisible by every number in a list | Function which check is a number divided with every element in list or not ; Driver Code","code":"< ? php function findNoIsDivisibleOrNot ( $ a , $ n , $ l ) { for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ a [ $ i ] % $ n != 0 ) return false ; } return true ; } $ a = array ( 14 , 12 , 4 , 18 ) ; $ n = 2 ; $ l = sizeof ( $ a ) ; if ( findNoIsDivisibleOrNot ( $ a , $ n , $ l ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Find a range of composite numbers of given length | method to find factorial of given number ; to print range of length n having all composite integers ; Driver Code","code":"< ? php function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } function printRange ( $ n ) { $ a = factorial ( $ n + 2 ) + 2 ; $ b = $ a + $ n - 1 ; echo \" [ \" , $ a , \" , \u2581 \" , $ b , \" ] \" ; return 0 ; } $ n = 3 ; printRange ( $ n ) ; ? >"}
{"text":"Find minimum value to assign all array elements so that array product becomes greater | PHP program to find minimum value that can be assigned to all elements so that product becomes greater than current product . ; sort the array to apply Binary search ; using log property add every logarithmic value of element to val $val = 0 ; where ld is long double ; set left and right extremities to find min value ; multiplying n to mid , to find the correct min value ; Driver code","code":"< ? php function findMinValue ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ val += ( log ( $ arr [ $ i ] ) ) ; $ left = $ arr [ 0 ] ; $ right = $ arr [ $ n - 1 ] + 1 ; $ ans = 0 ; while ( $ left <= $ right ) { $ mid = ( int ) ( $ left + $ right ) \/ 2 ; $ temp = $ n * ( log ( $ mid ) ) ; if ( $ val < $ temp ) { $ ans = $ mid ; $ right = $ mid - 1 ; } else $ left = $ mid + 1 ; } return ( floor ( $ ans ) ) ; } $ arr = array ( 4 , 2 , 1 , 10 , 6 ) ; $ n = sizeof ( $ arr ) ; echo findMinValue ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find the sum of all the terms in the n | function to find the required sum ; sum = n * ( 2 * n ^ 2 + 1 ) ; Driver Code","code":"< ? php function sumOfTermsInNthRow ( $ n ) { $ sum = $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; return $ sum ; } $ n = 4 ; echo \" Sum \u2581 of \u2581 all \u2581 the \u2581 terms \u2581 in \u2581 nth \u2581 row \u2581 = \u2581 \" , sumOfTermsInNthRow ( $ n ) ; ? >"}
{"text":"First digit in product of an array of numbers | PHP implementation to find first digit of a single number ; Keep dividing by 10 until it is greater than equal to 10 ; Driver Code","code":"< ? php function firstDigit ( $ x ) { while ( $ x >= 10 ) $ x = $ x \/ 10 ; return floor ( $ x ) ; } echo firstDigit ( 12345 ) , \" STRNEWLINE \" ; echo firstDigit ( 5432 ) ; ? >"}
{"text":"Find the occurrences of digit d in the range [ 0. . n ] | PHP program to count appearances of a digit ' d ' in range from [ 0. . n ] ; Initialize result ; Count appearances in numbers starting from d . ; When the last digit is equal to d ; When the first digit is equal to d then ; increment result as well as number ; In case of reverse of number such as 12 and 21 ; Driver code","code":"< ? php function getOccurence ( $ n , $ d ) { $ result = 0 ; $ itr = $ d ; while ( $ itr <= $ n ) { if ( $ itr % 10 == $ d ) $ result ++ ; if ( $ itr != 0 && floor ( $ itr \/ 10 ) == $ d ) { $ result ++ ; $ itr ++ ; } else if ( floor ( $ itr \/ 10 ) == $ d - 1 ) $ itr = $ itr + ( 10 - $ d ) ; else $ itr = $ itr + 10 ; } return $ result ; } $ n = 11 ; $ d = 1 ; echo getOccurence ( $ n , $ d ) ; ? >"}
{"text":"Program to calculate the value of sin ( x ) and cos ( x ) using Expansion | Function for calculation ; Converting degrees to radian ; maps the sum along the series ; holds the actual value of sin ( n ) ; Driver Code","code":"< ? php function cal_cos ( $ n ) { $ accuracy = 0.0001 ; $ n = $ n * ( 3.142 \/ 180.0 ) ; $ x1 = 1 ; $ cosx = $ x1 ; $ cosval = cos ( $ n ) ; $ i = 1 ; do { $ denominator = 2 * $ i * ( 2 * $ i - 1 ) ; $ x1 = - $ x1 * $ n * $ n \/ $ denominator ; $ cosx = $ cosx + $ x1 ; $ i = $ i + 1 ; } while ( $ accuracy <= abs ( $ cosval - $ cosx ) ) ; echo round ( $ cosx , 6 ) ; } $ n = 30 ; cal_cos ( $ n ) ; ? >"}
{"text":"Find sum of digits in factorial of a number | Function to multiply x with large number stored in vector v . Result is stored in v . ; Calculate res + prev carry ; updation at ith position ; Returns sum of digits in n ! ; One by one multiply i to current vector and update the vector . ; Find sum of digits in vector v [ ] ; Driver code","code":"< ? php function multiply ( & $ v , $ x ) { $ carry = 0 ; $ size = count ( $ v ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ res = $ carry + $ v [ $ i ] * $ x ; $ v [ $ i ] = $ res % 10 ; $ carry = ( int ) ( $ res \/ 10 ) ; } while ( $ carry != 0 ) { array_push ( $ v , $ carry % 10 ) ; $ carry = ( int ) ( $ carry \/ 10 ) ; } } function findSumOfDigits ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) multiply ( $ v , $ i ) ; $ sum = 0 ; $ size = count ( $ v ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) $ sum += $ v [ $ i ] ; return $ sum ; } $ n = 1000 ; print ( findSumOfDigits ( $ n ) ) ; ? >"}
{"text":"Find other two sides of a right angle triangle | Finds two sides of a right angle triangle if it they exist . ; if n is odd ; case of n = 1 handled separately ; case of n = 2 handled separately ; Driver Code","code":"< ? php function printOtherSides ( $ n ) { if ( $ n & 1 ) { if ( $ n == 1 ) echo - 1 ; else { $ b = ( $ n * $ n - 1 ) \/ 2 ; $ c = ( $ n * $ n + 1 ) \/ 2 ; echo \" b \u2581 = \u2581 \" , $ b , \" , \u2581 c \u2581 = \u2581 \" , $ c ; } } else { if ( $ n == 2 ) echo - 1 ; else { $ b = $ n * $ n \/ 4 - 1 ; $ c = $ n * $ n \/ 4 + 1 ; echo \" b \u2581 = \u2581 \" , $ b , \" , \u2581 c \u2581 = \u2581 \" , $ c ; } } } $ a = 3 ; printOtherSides ( $ a ) ; return 0 ; ? >"}
{"text":"Minimum positive integer to divide a number such that the result is an odd | PHP program to make a number odd ; Return 1 if already odd ; Check on dividing with a number when the result becomes odd Return that number ; If n is divided by i and n \/ i is odd then return i ; Driver code","code":"< ? php function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( ( $ n % $ i == 0 ) && ( ( $ n \/ $ i ) % 2 == 1 ) ) return $ i ; } $ n = 36 ; echo makeOdd ( $ n ) ; ? >"}
{"text":"XOR of all subarray XORs | Set 2 | Returns XOR of all subarray xors ; if even number of terms are there , all numbers will appear even number of times . So result is 0. ; else initialize result by 0 as ( a xor 0 = a ) ; Driver Code","code":"< ? php function getTotalXorOfSubarrayXors ( $ arr , $ N ) { if ( $ N % 2 == 0 ) return 0 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i += 2 ) $ res ^= $ arr [ $ i ] ; return $ res ; } $ arr = array ( 3 , 5 , 2 , 4 , 6 ) ; $ N = count ( $ arr ) ; echo getTotalXorOfSubarrayXors ( $ arr , $ N ) ; ? >"}
{"text":"Fill array with 1 's using minimum iterations of filling neighbors | Returns count of iterations to fill arr [ ] with 1 s . ; Start traversing the array ; Traverse until a 0 is found ; Count contiguous 0 s ; Condition for Case 3 ; Condition to check if Case 1 satisfies : ; If count_zero is even ; If count_zero is odd ; Reset count_zero ; Case 2 ; Update res ; Driver code","code":"< ? php function countIterations ( $ arr , $ n ) { $ oneFound = false ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; ) { if ( $ arr [ $ i ] == 1 ) $ oneFound = true ; while ( $ i < $ n && $ arr [ $ i ] == 1 ) $ i ++ ; $ count_zero = 0 ; while ( $ i < $ n && $ arr [ $ i ] == 0 ) { $ count_zero ++ ; $ i ++ ; } if ( $ oneFound == false && $ i == $ n ) return -1 ; $ curr_count ; if ( $ i < $ n && $ oneFound == true ) { if ( $ count_zero & 1 == 0 ) $ curr_count = $ count_zero \/ 2 ; else $ curr_count = ( $ count_zero + 1 ) \/ 2 ; $ count_zero = 0 ; } else { $ curr_count = $ count_zero ; $ count_zero = 0 ; } $ res = max ( $ res , $ curr_count ) ; } return $ res ; } $ arr = array ( 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo countIterations ( $ arr , $ n ) ; ? >"}
{"text":"Express a number as sum of consecutive numbers | Print consecutive numbers from last to first ; Driver Code","code":"< ? php function printConsecutive ( $ last , $ first ) { echo $ first ++ ; for ( $ x = $ first ; $ x <= $ last ; $ x ++ ) echo \" + \" } function findConsecutive ( $ N ) { for ( $ last = 1 ; $ last < $ N ; $ last ++ ) { for ( $ first = 0 ; $ first < $ last ; $ first ++ ) { if ( 2 * $ N == ( $ last - $ first ) * ( $ last + $ first + 1 ) ) { echo $ N , \" \u2581 = \u2581 \" ; printConsecutive ( $ last , $ first + 1 ) ; return ; } } } echo \" - 1\" ; } $ n = 12 ; findConsecutive ( $ n ) ; ? >"}
{"text":"Find n | Return n - th number in series made of 4 and 7 ; create an array of size ( n + 1 ) ; If i is odd ; Driver code","code":"< ? php function printNthElement ( $ n ) { $ arr [ 1 ] = 4 ; $ arr [ 2 ] = 7 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i \/ 2 ] * 10 + 4 ; else $ arr [ $ i ] = $ arr [ ( $ i \/ 2 ) - 1 ] * 10 + 7 ; } return $ arr [ $ n ] ; } $ n = 6 ; echo ( printNthElement ( $ n ) ) ; ? >"}
{"text":"Maximum sum of distinct numbers such that LCM of these numbers is N | Returns maximum sum of numbers with LCM as N ; Initialize result ; Finding a divisor of n and adding it to max_sum ; Driver code","code":"< ? php function maxSumLCM ( $ n ) { $ max_sum = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ max_sum += $ i ; if ( $ n \/ $ i != $ i ) $ max_sum += ( $ n \/ $ i ) ; } } return $ max_sum ; } $ n = 2 ; echo MaxSumLCM ( $ n ) ; ? >"}
{"text":"Square root of a number using log | PHP program to demonstrate finding square root of a number using sqrt ( )","code":"< ? php $ n = 12 ; echo sqrt ( $ n ) ; ? >"}
{"text":"Maximum value of an integer for which factorial can be calculated on a machine | PHP program to find maximum value of an integer for which factorial can be calculated on your system ; when fact crosses its size , it gives negative value ; Driver Code","code":"< ? php function findMaxValue ( ) { $ res = 2 ; $ fact = 2 ; $ pos = -1 ; while ( true ) { $ mystring = $ fact ; $ pos = strpos ( $ mystring , ' E ' ) ; if ( $ pos > 0 ) break ; $ res ++ ; $ fact = $ fact * $ res ; } return $ res - 1 ; } echo \" Maximum \u2581 value \u2581 of \" . \" \u2581 integer \u2581 \" . findMaxValue ( ) ; ? >"}
{"text":"Check if LCM of array elements is divisible by a prime number or not | Function to check any number of array is divisible by k or not ; If any array element is divisible by k , then LCM of whole array should also be divisible . ; Driver Code","code":"< ? php function func ( $ a , $ k , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] % $ k == 0 ) return true ; return false ; } $ a = array ( 14 , 27 , 38 , 76 , 84 ) ; $ k = 19 ; $ res = func ( $ a , $ k , 5 ) ; if ( $ res ) echo \" true \" ; else echo \" false \" ; ? >"}
{"text":"Find the closest and smaller tidy number | PHP program to find closest tidy number smaller than the given number ; check whether string violates tidy property ; if string violates tidy property , then decrease the value stored at that index by 1 and replace all the value stored right to that index by 9 ; Driver code ; num will store closest tidy number","code":"< ? php function tidyNum ( $ str , $ len ) { for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] > $ str [ $ i + 1 ] ) { $ x = ord ( $ str [ $ i ] ) ; $ x -- ; $ str [ $ i ] = chr ( $ x ) ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) $ str [ $ j ] = '9' ; } } return $ str ; } $ str = \"11333445538\" ; $ len = strlen ( $ str ) ; $ num = tidyNum ( $ str , $ len ) ; echo $ num ; ? >"}
{"text":"Count of m digit integers that are divisible by an integer n | Returns count of m digit numbers having n as divisor ; generating largest number of m digit ; generating largest number of m - 1 digit ; returning number of dividend ; Driver code","code":"< ? php function findCount ( $ m , $ n ) { $ num1 = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ num1 = ( $ num1 * 10 ) + 9 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < ( $ m - 1 ) ; $ i ++ ) $ num2 = ( $ num2 * 10 ) + 9 ; return ( ( $ num1 \/ $ n ) - ( $ num2 \/ $ n ) ) ; } $ m = 2 ; $ n = 6 ; echo findCount ( $ m , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find the n | function to calculate nth number made of even digits only ; variable to note how many such numbers have been found till now ; bool variable to check if 1 , 3 , 5 , 7 , 9 is there or not ; checking each digit of the number ; If 1 , 3 , 5 , 7 , 9 is found temp is changed to false ; temp is true it means that it does not have 1 , 3 , 5 , 7 , 9 ; If nth such number is found return it ; Driver Code","code":"< ? php function findNthEvenDigitNumber ( $ n ) { $ count = 0 ; for ( $ i = 0 ; ; $ i ++ ) { $ curr = $ i ; $ isCurrEvenDigit = true ; while ( $ curr != 0 ) { if ( $ curr % 10 == 1 $ curr % 10 == 3 $ curr % 10 == 5 $ curr % 10 == 7 $ curr % 10 == 9 ) $ isCurrEvenDigit = false ; $ curr = $ curr \/ 10 ; } if ( $ isCurrEvenDigit == true ) $ count ++ ; if ( $ count == $ n ) return $ i ; } } echo findNthEvenDigitNumber ( 2 ) , \" STRNEWLINE \" ; echo findNthEvenDigitNumber ( 10 ) ; ? >"}
{"text":"Find the n | function to find nth number made of even digits only ; If n = 1 return 0 ; vector to store the digits when converted into base 5 ; Reduce n to n - 1 to exclude 0 ; Reduce n to base 5 number and store digits ; pushing the digits into vector ; variable to represent the number after converting it to base 5. Since the digits are be in reverse order , we traverse vector from back ; return 2 * result ( to convert digits 0 , 1 , 2 , 3 , 4 to 0 , 2 , 4 , 6 , 8. ; Driver Code","code":"< ? php function findNthEvenDigitNumber ( $ n ) { if ( $ n == 1 ) return 0 ; $ v = array ( ) ; $ n = $ n - 1 ; while ( $ n > 0 ) { array_push ( $ v , $ n % 5 ) ; $ n = ( int ) ( $ n \/ 5 ) ; } $ result = 0 ; for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) { $ result = $ result * 10 ; $ result = $ result + $ v [ $ i ] ; } return 2 * $ result ; } echo findNthEvenDigitNumber ( 2 ) . \" STRNEWLINE \" ; echo findNthEvenDigitNumber ( 10 ) . \" STRNEWLINE \" ? >"}
{"text":"Check if a large number is divisible by 25 or not | Function to find that number divisible by 25 or not . ; If length of string is single digit then it 's not divisible by 25 ; Driver code","code":"< ? php function isDivisibleBy25 ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 1 ) return false ; return ( ( $ str [ $ n - 1 ] - '0' == 0 && $ str [ $ n - 2 ] - '0' == 0 ) || ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 25 == 0 ) ; } $ str = \"76955\" ; $ x = isDivisibleBy25 ( $ str ) ? \" Yes \" : \" No \u2581 \" ; echo ( $ x ) ; ? >"}
{"text":"Check a large number is divisible by 16 or not | Function to find that number divisible by 16 or not ; Empty string ; If there is double digit ; If there is triple digit ; If number formed by last four digits is divisible by 16. ; Driver code","code":"< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 && $ n == 1 ) return false ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( $ n == 3 ) return ( ( ( $ str [ $ n - 3 ] - '0' ) * 100 + ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; $ fourth_last = $ str [ $ n - 4 ] - '0' ; return ( ( $ fourth_last * 1000 + $ third_last * 100 + $ second_last * 10 + $ last ) % 16 == 0 ) ; } $ str = \"769528\" ; $ x = check ( $ str ) ? \" Yes \" : \" No \u2581 \" ; echo ( $ x ) ; ? >"}
{"text":"Find Index of given fibonacci number in constant time | A simple PHP program to find index of given Fibonacci number . ; if Fibonacci number is less than 2 , its index will be same as number ; iterate until generated fibonacci number is less than given fibonacci number ; res keeps track of number of generated fibonacci number ; Driver Code","code":"< ? php function findIndex ( $ n ) { if ( $ n <= 1 ) return $ n ; $ a = 0 ; $ b = 1 ; $ c = 1 ; $ res = 1 ; while ( $ c < $ n ) { $ c = $ a + $ b ; $ res ++ ; $ a = $ b ; $ b = $ c ; } return $ res ; } $ result = findIndex ( 21 ) ; echo ( $ result ) ; ? >"}
{"text":"Determine whether a given number is a Hyperperfect Number | function to find the sum of all proper divisors ( excluding 1 and N ) ; Iterate only until sqrt N as we are going to generate pairs to produce divisors ; As divisors occur in pairs , we can take the values i and N \/ i as long as i divides N ; Function to check whether the given number is prime ; base and corner cases ; Since integers can be represented as some 6 * k + y where y >= 0 , we can eliminate all integers that can be expressed in this form ; start from 5 as this is the next prime number ; Returns true if N is a K - Hyperperfect number Else returns false . ; Condition from the definition of hyperperfect ; Driver Code ; First two statements test against the condition N = 1 + K * ( sum ( proper divisors ) )","code":"< ? php function divisorSum ( $ N , $ K ) { $ sum = 0 ; for ( $ i = 2 ; $ i <= ceil ( sqrt ( $ N ) ) ; $ i ++ ) if ( $ N % $ i == 0 ) $ sum += ( $ i + $ N \/ $ i ) ; return $ sum ; } function isPrime ( $ n ) { if ( $ n == 1 $ n == 0 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isHyperPerfect ( $ N , $ K ) { $ sum = divisorSum ( $ N , $ K ) ; if ( ( 1 + $ K * ( $ sum ) ) == $ N ) return true ; else return false ; } $ N1 = 1570153 ; $ K1 = 12 ; $ N2 = 321 ; $ K2 = 3 ; if ( isHyperPerfect ( $ N1 , $ K1 ) ) echo $ N1 , \" \u2581 is \u2581 \" , $ K1 , \" - HyperPerfect \" , \" STRNEWLINE \" ; else echo $ N1 , \" \u2581 is \u2581 not \u2581 \" , $ K1 , \" - HyperPerfect \" , \" STRNEWLINE \" ; if ( isHyperPerfect ( $ N2 , $ K2 ) ) echo $ N2 , \" \u2581 is \u2581 \" , K2 , \" - HyperPerfect \" , \" STRNEWLINE \" ; else echo $ N2 , \" \u2581 is \u2581 not \u2581 \" , $ K2 , \" - HyperPerfect \" , \" STRNEWLINE \" ; ? >"}
{"text":"Given a number n , find the first k digits of n ^ n | function to calculate first k digits of n ^ n ; take log10 of n ^ n . log10 ( n ^ n ) = n * log10 ( n ) ; We now try to separate the decimal and integral part of the \/ product . The floor function returns the smallest integer less than or equal to the argument . So in this case , product - floor ( product ) will give us the decimal part of product ; we now exponentiate this back by raising 10 to the power of decimal part ; We now try to find the power of 10 by which we will have to multiply the decimal part to obtain our final answer ; Driver Code","code":"< ? php function firstkdigits ( $ n , $ k ) { $ product = $ n * log10 ( $ n ) ; $ decimal_part = $ product - floor ( $ product ) ; $ decimal_part = pow ( 10 , $ decimal_part ) ; $ digits = pow ( 10 , $ k - 1 ) ; $ i = 0 ; return floor ( $ decimal_part * $ digits ) ; } $ n = 1450 ; $ k = 6 ; echo firstkdigits ( $ n , $ k ) ; ? >"}
{"text":"Generate k digit numbers with digits in strictly increasing order | number -- > Current value of number . x -- > Current digit to be considered k -- > Remaining number of digits ; Try all possible greater digits ; Generates all well ordered numbers of length k ; Driver code","code":"< ? php function printWellOrdered ( $ number , $ x , $ k ) { if ( $ k == 0 ) { echo $ number , \" \" ; return ; } for ( $ i = ( $ x + 1 ) ; $ i < 10 ; $ i ++ ) printWellOrdered ( $ number * 10 + $ i , $ i , $ k - 1 ) ; } function generateWellOrdered ( $ k ) { printWellOrdered ( 0 , 0 , $ k ) ; } $ k = 3 ; generateWellOrdered ( $ k ) ; ? >"}
{"text":"Multiply large integers under large modulo | Returns ( a * b ) % mod ; Update a if it is more than or equal to mod ; If b is odd , add a with result ; Here we assume that doing 2 * a doesn 't cause overflow ; $b >>= 1 ; b = b \/ 2 ; Driver Code","code":"< ? php function moduloMultiplication ( $ a , $ b , $ mod ) { $ a %= $ mod ; while ( $ b ) { if ( $ b & 1 ) $ res = ( $ res + $ a ) % $ mod ; $ a = ( 2 * $ a ) % $ mod ; } return $ res ; } $ a = 10123465234878998 ; $ b = 65746311545646431 ; $ m = 10005412336548794 ; echo moduloMultiplication ( $ a , $ b , $ m ) ; ? >"}
{"text":"Number of occurrences of 2 as a digit in numbers from 0 to n | Counts the number of 2 s in a number at d - th digit ; if the digit in spot digit is ; Counts the number of '2' digits between 0 and n ; Convert integer to String to find its length ; Traverse every digit and count for every digit ; Driver Code","code":"< ? php function count2sinRangeAtDigit ( $ number , $ d ) { $ powerOf10 = ( int ) pow ( 10 , $ d ) ; $ nextPowerOf10 = $ powerOf10 * 10 ; $ right = $ number % $ powerOf10 ; $ roundDown = $ number - $ number % $ nextPowerOf10 ; $ roundup = $ roundDown + $ nextPowerOf10 ; $ digit = ( $ number \/ $ powerOf10 ) % 10 ; if ( $ digit < 2 ) return $ roundDown \/ 10 ; if ( $ digit == 2 ) return $ roundDown \/ 10 + $ right + 1 ; return $ roundup \/ 10 ; } function numberOf2sinRange ( $ number ) { $ s = strval ( $ number ) ; $ len = strlen ( $ s ) ; $ count = 0 ; for ( $ digit = 0 ; $ digit < $ len ; $ digit ++ ) $ count += count2sinRangeAtDigit ( $ number , $ digit ) ; return $ count ; } print ( numberOf2sinRange ( 22 ) . \" STRNEWLINE \" ) ; print ( numberOf2sinRange ( 100 ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Program to find Star number | Returns n - th star number ; Driver code","code":"< ? php function findStarNum ( $ n ) { return ( 6 * $ n * ( $ n - 1 ) + 1 ) ; } $ n = 3 ; echo findStarNum ( $ n ) ; ? >"}
{"text":"Check if a large number is divisible by 5 or not | Function to find that number divisible by 5 or not . The function assumes that string length is at least one . ; Driver code","code":"< ? php function isDivisibleBy5 ( $ str ) { $ n = strlen ( $ str ) ; return ( ( ( $ str [ $ n - 1 ] - '0' ) == 0 ) || ( ( $ str [ $ n - 1 ] - '0' ) == 5 ) ) ; } $ str = \"76955\" ; $ x = isDivisibleBy5 ( $ str ) ? \" Yes \" : \" No \" ; echo ( $ x ) ; ? >"}
{"text":"Tidy Number ( Digits in non | Returns true if num is Tidy ; To store previous digit ( Assigning initial value which is more than any digit ) ; Traverse all digits from right to left and check if any digit is smaller than previous . ; Driver code","code":"< ? php function isTidy ( $ num ) { $ prev = 10 ; while ( $ num ) { $ rem = $ num % 10 ; $ num = ( int ) $ num \/ 10 ; if ( $ rem > $ prev ) return false ; $ prev = $ rem ; } return true ; } $ num = 1556 ; if ( isTidy ( $ num ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Nth Square free number | Function to find nth square free number ; To maintain count of square free number ; Loop for square free numbers ; Checking whether square of a number is divisible by any number which is a perfect square ; If number is square free ; If the cnt becomes n , return the number ; Driver Code","code":"< ? php function squareFree ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; ; $ i ++ ) { $ isSqFree = true ; for ( $ j = 2 ; $ j * $ j <= $ i ; $ j ++ ) { if ( $ i % ( $ j * $ j ) == 0 ) { $ isSqFree = false ; break ; } } if ( $ isSqFree == true ) { $ cnt ++ ; if ( $ cnt == $ n ) return $ i ; } } return 0 ; } $ n = 10 ; echo ( squareFree ( $ n ) ) ; ? >"}
{"text":"Find if n can be written as product of k numbers | Prints k factors of n if n can be written as multiple of k numbers . Else prints - 1. ; A vector to store all prime factors of n ; Insert all 2 's in vector ; n must be odd at this point So we skip one element ( i = i + 2 ) ; This is to handle when n > 2 and n is prime ; If size ( P ) < k , k factors are not possible ; printing first k - 1 factors ; calculating and printing product of rest of numbers ; Driver Code","code":"< ? php function kFactors ( $ n , $ k ) { $ P = array ( ) ; while ( $ n % 2 == 0 ) { array_push ( $ P , 2 ) ; $ n = ( int ) ( $ n \/ 2 ) ; } for ( $ i = 3 ; $ i * $ i <= $ n ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { $ n = ( int ) ( $ n \/ $ i ) ; array_push ( $ P , $ i ) ; } } if ( $ n > 2 ) array_push ( $ P , $ n ) ; if ( count ( $ P ) < $ k ) { echo \" - 1 STRNEWLINE \" ; return ; } for ( $ i = 0 ; $ i < $ k - 1 ; $ i ++ ) echo $ P [ $ i ] . \" , \" $ product = 1 ; for ( $ i = $ k - 1 ; $ i < count ( $ P ) ; $ i ++ ) $ product = $ product * $ P [ $ i ] ; echo $ product ; } $ n = 54 ; $ k = 3 ; kFactors ( $ n , $ k ) ; ? >"}
{"text":"Largest number smaller than or equal to n and digits in non | Returns the required number ; loop to recursively check the numbers less than or equal to given number ; Keep traversing digits from right to left . For every digit check if it is smaller than prev_dig ; We found the required number ; Driver Code","code":"< ? php function nondecdigits ( $ n ) { $ x = 0 ; for ( $ x = $ n ; $ x >= 1 ; $ x -- ) { $ no = $ x ; $ prev_dig = 11 ; $ flag = true ; while ( $ no != 0 ) { if ( $ prev_dig < $ no % 10 ) { $ flag = false ; break ; } $ prev_dig = $ no % 10 ; $ no \/= 10 ; } if ( $ flag == true ) break ; } return $ x ; } $ n = 200 ; echo nondecdigits ( $ n ) ; ? >"}
{"text":"Largest number smaller than or equal to n and digits in non | Prints the largest number smaller than s and digits in non - decreasing order . ; array to store digits of number ; conversion of characters of string int number ; variable holds the value of index after which all digits are set 9 ; Checking the condition if the digit is less than its left digit ; If first digit is 0 no need to print it ; Driver Code","code":"< ? php function nondecdigits ( $ s ) { $ m = strlen ( $ s ) ; $ a [ $ m ] = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ a [ $ i ] = $ s [ $ i ] - '0' ; $ level = $ m - 1 ; for ( $ i = $ m - 1 ; $ i > 0 ; $ i -- ) { if ( $ a [ $ i ] < $ a [ $ i - 1 ] ) { $ a [ $ i - 1 ] -- ; $ level = $ i - 1 ; } } if ( $ a [ 0 ] != 0 ) { for ( $ i = 0 ; $ i <= $ level ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = $ level + 1 ; $ i < $ m ; $ i ++ ) echo \"9\" ; } else { for ( $ i = 1 ; $ i < $ level ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = $ level + 1 ; $ i < $ m ; $ i ++ ) echo \"9\" ; } } $ n = \"200\" ; nondecdigits ( $ n ) ; ? >"}
{"text":"Count Divisors of n in O ( n ^ 1 \/ 3 ) | function to count the divisors ; If divisors are equal , count only one ; Otherwise count both ; Driver Code","code":"< ? php function countDivisors ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ cnt ++ ; else $ cnt = $ cnt + 2 ; } } return $ cnt ; } echo \" Total \u2581 distinct \u2581 divisors \u2581 of \u2581 100 \u2581 are \u2581 : \u2581 \" , countDivisors ( 100 ) ; ? >"}
{"text":"Check if the door is open or closed | Function to check whether ' n ' has even number of factors or not ; if ' n ' is a perfect square it has odd number of factors ; else ' n ' has even number of factors ; Function to find and print status of each door ; If even number of factors final status is closed ; else odd number of factors final status is open ; Driver Code","code":"< ? php function hasEvenNumberOfFactors ( $ n ) { $ root_n = sqrt ( $ n ) ; if ( ( $ root_n * $ root_n ) == $ n ) return false ; return true ; } function printStatusOfDoors ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( hasEvenNumberOfFactors ( $ i ) ) echo \" closed \" , \" \u2581 \" ; else echo \" open \" , \" \u2581 \" ; } } $ n = 5 ; printStatusOfDoors ( $ n ) ; ? >"}
{"text":"Check if frequency of each digit is less than the digit | Function to validate number ( Check if frequency of adigit is less than thedigit itself or not ) ; If current digit of temp is same as i ; if frequency is greater than digit value , return false ; Driver Code","code":"< ? php function validate ( $ n ) { for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ temp = $ n ; $ count = 0 ; while ( $ temp ) { if ( $ temp % 10 == $ i ) $ count ++ ; if ( $ count > $ i ) return -1 ; $ temp \/= 10 ; } } return 1 ; } $ n = 1552793 ; $ geek = validate ( $ n ) ? \" True \" : \" False \" ; echo ( $ geek ) ; ? >"}
{"text":"Check if a larger number divisible by 36 | Function to check whether a number is divisible by 36 or not ; null number cannot be divisible by 36 ; single digit number other than 0 is not divisible by 36 ; number formed by the last 2 digits ; if number is not divisible by 4 ; number is divisible by 4 calculate sum of digits ; sum of digits is not divisible by 9 ; number is divisible by 4 and 9 hence , number is divisible by 36 ; Driver Code","code":"< ? php function divisibleBy36 ( $ num ) { $ l = strlen ( $ num ) ; if ( $ l == 0 ) return \" No \" ; if ( $ l == 1 && $ num [ 0 ] != '0' ) return \" No \" ; $ two_digit_num = ( $ num [ $ l - 2 ] - '0' ) * 10 + ( $ num [ $ l - 1 ] - '0' ) ; if ( $ two_digit_num % 4 != 0 ) return \" No \" ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum % 9 != 0 ) return \" No \" ; return \" Yes \" ; } $ num = \"92567812197966231384\" ; echo ( divisibleBy36 ( $ num ) ) ; ? >"}
{"text":"Check if a large number is divisible by 8 or not | Function to find that number divisible by 8 or not ; Empty string ; If there is single digit ; If there is double digit ; If number formed by last three digits is divisible by 8. ; Driver code","code":"< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 ) return false ; if ( $ n == 1 ) return ( ( $ str [ 0 ] - '0' ) % 8 == 0 ) ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 8 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; return ( ( $ third_last * 100 + $ second_last * 10 + $ last ) % 8 == 0 ) ; } $ str = \"76952\" ; $ x = check ( $ str ) ? \" Yes \" : \" No \u2581 \" ; echo ( $ x ) ; ? >"}
{"text":"Prime points ( Points that split a number into two primes ) | Function to count number of digits ; Function to check whether a number is prime or not . Returns 0 if prime else - 1 ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to print prime points ; counting digits ; As single and double digit numbers do not have left and right number pairs ; Finding all left and right pairs . Printing the prime points accordingly . Discarding first and last index point ; Calculating left number ; Calculating right number ; Prime point condition ; No prime point found ; Driver Code","code":"< ? php function countDigits ( $ n ) { $ count = 0 ; while ( $ n > 0 ) { $ count ++ ; $ n = ( int ) ( $ n \/ 10 ) ; } return $ count ; } function checkPrime ( $ n ) { if ( $ n <= 1 ) return -1 ; if ( $ n <= 3 ) return 0 ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return -1 ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return -1 ; return 0 ; } function printPrimePoints ( $ n ) { $ count = countDigits ( $ n ) ; if ( $ count == 1 $ count == 2 ) { echo \" - 1\" ; return ; } $ found = false ; for ( $ i = 1 ; $ i < ( $ count - 1 ) ; $ i ++ ) { $ left = ( int ) ( $ n \/ ( ( int ) pow ( 10 , $ count - $ i ) ) ) ; $ right = $ n % ( ( int ) pow ( 10 , $ count - $ i - 1 ) ) ; if ( checkPrime ( $ left ) == 0 && checkPrime ( $ right ) == 0 ) { echo $ i , \" \" ; $ found = true ; } } if ( $ found == false ) echo \" - 1\" ; } $ n = 2317 ; printPrimePoints ( $ n ) ; ? >"}
{"text":"Find ways an Integer can be expressed as sum of n | Function to calculate and return the power of any given number ; Function to check power representations recursively ; Initialize number of ways to express x as n - th powers of different natural numbers ; Calling power of ' i ' raised to ' n ' ; Recursively check all greater values of i ; If sum of powers is equal to x then increase the value of result . ; Return the final result ; Driver Code .","code":"< ? php function power ( $ num , $ n ) { if ( $ n == 0 ) return 1 ; else if ( $ n % 2 == 0 ) return power ( $ num , ( int ) ( $ n \/ 2 ) ) * power ( $ num , ( int ) ( $ n \/ 2 ) ) ; else return $ num * power ( $ num , ( int ) ( $ n \/ 2 ) ) * power ( $ num , ( int ) ( $ n \/ 2 ) ) ; } function checkRecursive ( $ x , $ n , $ curr_num = 1 , $ curr_sum = 0 ) { $ results = 0 ; $ p = power ( $ curr_num , $ n ) ; while ( $ p + $ curr_sum < $ x ) { $ results += checkRecursive ( $ x , $ n , $ curr_num + 1 , $ p + $ curr_sum ) ; $ curr_num ++ ; $ p = power ( $ curr_num , $ n ) ; } if ( $ p + $ curr_sum == $ x ) $ results ++ ; return $ results ; } $ x = 10 ; $ n = 2 ; echo ( checkRecursive ( $ x , $ n ) ) ; ? >"}
{"text":"Number Theory | Generators of finite cyclic group under addition | Function to return gcd of a and b ; Print generators of n ; 1 is always a generator ; A number x is generator of GCD is 1 ; Driver program to test above function","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function printGenerators ( $ n ) { echo \"1 \u2581 \" ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( gcd ( $ i , $ n ) == 1 ) echo $ i , \" \u2581 \" ; } $ n = 10 ; printGenerators ( $ n ) ; ? >"}
{"text":"Check if a large number is divisible by 3 or not | Function to find that number divisible by 3 or not ; Compute sum of digits ; Check if sum of digits is divisible by 3. ; Driver code","code":"< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; } $ str = \"1332\" ; $ x = check ( $ str ) ? \" Yes \" : \" No \u2581 \" ; echo ( $ x ) ; ? >"}
{"text":"Count all perfect divisors of a number | Below is PHP code to count total perfect divisors ; Pre - compute counts of all perfect divisors of all numbers upto MAX . ; Iterate through all the multiples of i * i ; Increment all such multiples by 1 ; Returns count of perfect divisors of n . ; Driver code","code":"< ? php $ MAX = 10001 ; $ perfectDiv = array_fill ( 0 , $ MAX , 0 ) ; function precomputeCounts ( ) { global $ MAX , $ perfectDiv ; for ( $ i = 1 ; $ i * $ i < $ MAX ; ++ $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAX ; $ j += $ i * $ i ) ++ $ perfectDiv [ $ j ] ; } } function countPerfectDivisors ( $ n ) { global $ perfectDiv ; return $ perfectDiv [ $ n ] ; } precomputeCounts ( ) ; $ n = 16 ; echo \" Total \u2581 perfect \u2581 divisors \u2581 of \u2581 \" . $ n . \" \u2581 = \u2581 \" . countPerfectDivisors ( $ n ) . \" STRNEWLINE \" ; $ n = 12 ; echo \" Total \u2581 perfect \u2581 divisors \u2581 of \u2581 \" . $ n . \" \u2581 = \u2581 \" . countPerfectDivisors ( $ n ) ; ? >"}
{"text":"Prime Factorization using Sieve O ( log n ) for multiple queries | PHP program to find prime factorization of a number n in O ( Log n ) time with precomputation allowed . ; stores smallest prime factor for every number ; Calculating SPF ( Smallest Prime Factor ) for every number till MAXN . Time Complexity : O ( nloglogn ) ; marking smallest prime factor for every number to be itself . ; separately marking spf for every even number as 2 ; checking if i is prime ; marking SPF for all numbers divisible by i ; marking spf [ j ] if it is not previously marked ; A O ( log n ) function returning primefactorization by dividing by smallest prime factor at every step ; precalculating Smallest Prime Factor ; calling getFactorization function","code":"< ? php $ MAXN = 19999 ; $ spf = array_fill ( 0 , $ MAXN , 0 ) ; function sieve ( ) { global $ MAXN , $ spf ; $ spf [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAXN ; $ i ++ ) $ spf [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAXN ; $ i += 2 ) $ spf [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAXN ; $ i ++ ) { if ( $ spf [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAXN ; $ j += $ i ) if ( $ spf [ $ j ] == $ j ) $ spf [ $ j ] = $ i ; } } } function getFactorization ( $ x ) { global $ spf ; $ ret = array ( ) ; while ( $ x != 1 ) { array_push ( $ ret , $ spf [ $ x ] ) ; if ( $ spf [ $ x ] ) $ x = ( int ) ( $ x \/ $ spf [ $ x ] ) ; } return $ ret ; } sieve ( ) ; $ x = 12246 ; echo \" prime \u2581 factorization \u2581 for \u2581 \" . $ x . \" \u2581 : \u2581 \" ; $ p = getFactorization ( $ x ) ; for ( $ i = 0 ; $ i < count ( $ p ) ; $ i ++ ) echo $ p [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Largest subsequence having GCD greater than 1 | Returns length of the largest subsequence with GCD more than 1. ; Finding the Maximum value in arr [ ] ; Iterate from 2 to maximum possible divisor of all give values ; If we found divisor , increment count ; Driver code","code":"< ? php function largestGCDSubsequence ( $ arr , $ n ) { $ ans = 0 ; $ maxele = max ( $ arr ) ; for ( $ i = 2 ; $ i <= $ maxele ; ++ $ i ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( $ arr [ $ j ] % $ i == 0 ) ++ $ count ; } $ ans = max ( $ ans , $ count ) ; } return $ ans ; } $ arr = array ( 3 , 6 , 2 , 5 , 4 ) ; $ size = count ( $ arr ) ; echo largestGCDSubsequence ( $ arr , $ size ) ; ? >"}
{"text":"Queries on the sum of prime factor counts in a range | PHP program to find sum prime factors in given range . ; using sieve method to evaluating the prime factor of numbers ; if i is prime ; setting number of prime factor of a prime number . ; Returns sum of counts of prime factors in range from l to r . This function mainly uses count [ ] which is filled by Sieve ( ) ; finding the sum of number of prime factor of numbers in a range . ; Driver Code","code":"< ? php $ MAX = 100006 ; function sieve ( & $ count ) { global $ MAX ; for ( $ i = 2 ; $ i * $ i <= $ MAX ; $ i ++ ) { if ( $ count [ $ i ] == 0 ) { for ( $ j = 2 * $ i ; $ j < $ MAX ; $ j += $ i ) $ count [ $ j ] ++ ; $ count [ $ i ] = 1 ; } } } function query ( $ count , $ l , $ r ) { $ sum = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) $ sum += $ count [ $ i ] ; return $ sum ; } $ count = array_fill ( 0 , $ MAX , 0 ) ; sieve ( $ count ) ; echo query ( $ count , 6 , 10 ) . \" \" . query ( $ count , 1 , 5 ) ; ? >"}
{"text":"Generation of n numbers with given set of factors | Generate n numbers with factors in factor [ ] ; array of k to store next multiples of given factors ; Prints n numbers $output = 0 ; Next number to print as output ; Find the next smallest multiple ; Printing minimum in each iteration print the value if output is not equal to current value ( to avoid the duplicates ) ; incrementing the current value by the respective factor ; Driver code","code":"< ? php function generateNumbers ( $ factor , $ n , $ k ) { $ next = array_fill ( 0 , $ k , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ) { $ toincrement = 0 ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ next [ $ j ] < $ next [ $ toincrement ] ) $ toincrement = $ j ; if ( $ output != $ next [ $ toincrement ] ) { $ output = $ next [ $ toincrement ] ; echo $ next [ $ toincrement ] . \" \" ; $ i ++ ; } $ next [ $ toincrement ] += $ factor [ $ toincrement ] ; } } $ factor = array ( 3 , 5 , 7 ) ; $ n = 10 ; $ k = count ( $ factor ) ; generateNumbers ( $ factor , $ n , $ k ) ; ? >"}
{"text":"Multiplicative order | function for GCD ; Function return smallest + ve integer that holds condition A ^ k ( mod N ) = 1 ; result store power of A that rised to the power N - 1 ; modular arithmetic ; return smallest + ve integer ; increment power ; Driver Code","code":"< ? php function GCD ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return GCD ( $ b , $ a % $ b ) ; } function multiplicativeOrder ( $ A , $ N ) { if ( GCD ( $ A , $ N ) != 1 ) return -1 ; $ result = 1 ; $ K = 1 ; while ( $ K < $ N ) { $ result = ( $ result * $ A ) % $ N ; if ( $ result == 1 ) return $ K ; $ K ++ ; } return -1 ; } $ A = 4 ; $ N = 7 ; echo ( multiplicativeOrder ( $ A , $ N ) ) ; ? >"}
{"text":"Sum of product of x and y such that floor ( n \/ x ) = y | Return the sum of natural number in a range . ; n * ( n + 1 ) \/ 2. ; Return the sum of product x * y . ; Iterating i from 1 to sqrt ( n ) ; Finding the upper limit . ; Finding the lower limit . ; Driven Code","code":"< ? php function sumOfRange ( $ a , $ b ) { $ i = ( $ a * ( $ a + 1 ) ) >> 1 ; $ j = ( $ b * ( $ b + 1 ) ) >> 1 ; return ( $ i - $ j ) ; } function sumofproduct ( $ n ) { $ sum = 0 ; $ root = sqrt ( $ n ) ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) { $ up = ( int ) ( $ n \/ $ i ) ; $ low = max ( ( int ) ( $ n \/ ( $ i + 1 ) ) , $ root ) ; $ sum += ( $ i * sumOfRange ( $ up , $ low ) ) ; $ sum += ( $ i * ( int ) ( $ n \/ $ i ) ) ; } return $ sum ; } $ n = 10 ; echo sumofproduct ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Minimum number of power terms with sum equal to n | Return minimum power terms of x required ; if x is 1 , return n since any power of 1 is 1 only . ; Consider n = a * x + b where a = n \/ x and b = n % x . ; Update count of powers for 1 's added ; Repeat the process for reduced n ; Driver Code","code":"< ? php function minPower ( $ n , $ x ) { if ( $ x == 1 ) return $ n ; $ ans = 0 ; while ( $ n > 0 ) { $ ans += ( $ n % $ x ) ; $ n \/= $ x ; } return $ ans ; } $ n = 5 ; $ x = 3 ; echo ( minPower ( $ n , $ x ) ) ; ? >"}
{"text":"Sum of Perrin Numbers | function for sum of first n Perrin number . ; if ( $n == 0 ) n = 0 ; if ( $n == 1 ) n = 1 ; if ( $n == 2 ) n = 2 ; calculate k = 5 sum of three previous step . ; Sum remaining numbers ; calculate next term ; Driver code","code":"< ? php function calSum ( $ n ) { $ a = 3 ; $ b = 0 ; $ c = 2 ; return 3 ; return 3 ; return 5 ; $ sum = 5 ; while ( $ n > 2 ) { $ d = $ a + $ b ; $ sum += $ d ; $ a = $ b ; $ b = $ c ; $ c = $ d ; $ n -- ; } return $ sum ; } $ n = 9 ; echo calSum ( $ n ) ; ? >"}
{"text":"Print the kth common factor of two numbers | Returns k 'th common factor of x and y. ; Find smaller of two numbers ; Count common factors until we either reach small or count becomes k . ; If we reached small ; Driver code","code":"< ? php function findKCF ( $ x , $ y , $ k ) { $ small = min ( $ x , $ y ) ; $ count = 1 ; for ( $ i = 2 ; $ i <= $ small ; $ i ++ ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) $ count ++ ; if ( $ count == $ k ) return $ i ; } return -1 ; } $ x = 4 ; $ y = 24 ; $ k = 3 ; echo findKCF ( $ x , $ y , $ k ) ; ? >"}
{"text":"Find minimum number to be divided to make a number a perfect square | Return the minimum number to be divided to make n a perfect square . ; Since 2 is only even prime , compute its power separately . ; If count is odd , it must be removed by dividing n by prime number . ; If count is odd , it must be removed by dividing n by prime number . ; Driver Code","code":"< ? php function findMinNumber ( $ n ) { $ count = 0 ; $ ans = 1 ; while ( $ n % 2 == 0 ) { $ count ++ ; $ n \/= 2 ; } if ( $ count % 2 ) $ ans *= 2 ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { $ count = 0 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n \/= $ i ; } if ( $ count % 2 ) $ ans *= $ i ; } if ( $ n > 2 ) $ ans *= $ n ; return $ ans ; } $ n = 72 ; echo findMinNumber ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Program to implement Collatz Conjecture | Function to find if n reaches to 1 or not . ; Return true if n is positive ; Driver code","code":"< ? php function isToOne ( $ n ) { if ( $ n > 0 ) return true ; return false ; } $ n = 5 ; isToOne ( $ n ) ? print ( \" Yes \" ) : print ( \" No \" ) ; ? >"}
{"text":"GCD of two numbers formed by n repeating x and y times | Return the Greatest common Divisor of two numbers . ; Prints Greatest Common Divisor of number formed by n repeating x times and y times . ; Finding GCD of x and y . ; Print n , g times . ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function findgcd ( $ n , $ x , $ y ) { $ g = gcd ( $ x , $ y ) ; for ( $ i = 0 ; $ i < $ g ; $ i ++ ) echo ( $ n ) ; } $ n = 123 ; $ x = 5 ; $ y = 2 ; findgcd ( $ n , $ x , $ y ) ; ? >"}
{"text":"Count natural numbers whose factorials are divisible by x but not y | GCD function to compute the greatest divisor among a and b ; Returns first number whose factorial is divisible by x . ; Result ; Remove common factors ; We found first i . ; Count of natural numbers whose factorials are divisible by x but not y . ; Return difference between first natural number whose factorial is divisible by y and first natural number whose factorial is divisible by x . ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( ( $ a % $ b ) == 0 ) return $ b ; return gcd ( $ b , $ a % $ b ) ; } function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ new_x = $ x ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ new_x \/= gcd ( $ i , $ new_x ) ; if ( $ new_x == 1 ) break ; } return $ i ; } function countFactorialXNotY ( $ x , $ y ) { return ( firstFactorialDivisibleNumber ( $ y ) - firstFactorialDivisibleNumber ( $ x ) ) ; } $ x = 15 ; $ y = 25 ; echo ( countFactorialXNotY ( $ x , $ y ) ) ; ? >"}
{"text":"Find the first natural number whose factorial is divisible by x | Returns first number whose factorial divides x . ; Result ; Driver code","code":"< ? php function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ fact = 1 ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ fact = $ fact * $ i ; if ( $ fact % $ x == 0 ) break ; } return $ i ; } $ x = 16 ; echo ( firstFactorialDivisibleNumber ( $ x ) ) ; ? >"}
{"text":"Find two prime numbers with given sum | Generate all prime numbers less than n . ; Initialize all entries of boolean array as true . A value in isPrime [ i ] will finally be false if i is Not a prime , else true bool isPrime [ n + 1 ] ; ; If isPrime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Prints a prime pair with given sum ; Generating primes using Sieve ; Traversing all numbers to find first pair ; Driver Code","code":"< ? php function SieveOfEratosthenes ( $ n , & $ isPrime ) { $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ isPrime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ isPrime [ $ p ] == true ) { for ( $ i = $ p * $ p ; $ i <= $ n ; $ i += $ p ) $ isPrime [ $ i ] = false ; } } } function findPrimePair ( $ n ) { $ isPrime = array_fill ( 0 , $ n + 1 , NULL ) ; SieveOfEratosthenes ( $ n , $ isPrime ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ isPrime [ $ i ] && $ isPrime [ $ n - $ i ] ) { echo $ i . \" \u2581 \" . ( $ n - $ i ) ; return ; } } } $ n = 74 ; findPrimePair ( $ n ) ; ? >"}
{"text":"Count numbers with same first and last digits | method to get first digit of x ; method to return count of numbers with same starting and ending digit from 1 upto x ; get ten - spans from 1 to x ; add 9 to consider all 1 digit numbers ; Find first and last digits ; If last digit is greater than first digit then decrease count by 1 ; Method to return count of numbers with same starting and ending digit between start and end ; Driver Code","code":"< ? php function getFirstDigit ( $ x ) { while ( $ x >= 10 ) $ x \/= 10 ; return $ x ; } function getCountWithSameStartAndEndFrom1 ( $ x ) { if ( $ x < 10 ) return $ x ; $ tens = $ x \/ 10 ; $ res = $ tens + 9 ; $ firstDigit = getFirstDigit ( $ x ) ; $ lastDigit = $ x % 10 ; if ( $ lastDigit < $ firstDigit ) $ res -- ; return $ res ; } function getCountWithSameStartAndEnd ( $ start , $ end ) { return getCountWithSameStartAndEndFrom1 ( $ end ) - getCountWithSameStartAndEndFrom1 ( $ start - 1 ) ; } $ start = 5 ; $ end = 40 ; echo getCountWithSameStartAndEnd ( $ start , $ end ) ; ? >"}
{"text":"Right | Generate all prime numbers less than n . ; Initialize all entries of boolean array as true . A value in isPrime [ i ] will finally be false if i is Not a prime , else true bool isPrime [ n + 1 ] ; ; If isPrime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Returns true if n is right - truncatable , else false ; Generating primes using Sieve ; Checking whether the number remains prime when the last ( \" right \" ) digit is successively removed ; Driver Code","code":"< ? php function sieveOfEratosthenes ( $ n , & $ isPrime ) { $ isPrime [ 0 ] = $ isPrime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ isPrime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ isPrime [ $ i ] = false ; } } } function rightTruPrime ( $ n ) { $ isPrime = array_fill ( 0 , $ n + 1 , true ) ; sieveOfEratosthenes ( $ n , $ isPrime ) ; while ( $ n ) { if ( $ isPrime [ $ n ] ) $ n = ( int ) ( $ n \/ 10 ) ; else return false ; } return true ; } $ n = 59399 ; if ( rightTruPrime ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Mersenne Prime | Generate all prime numbers less than n . ; Initialize all entries of boolean array as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to generate mersenne primes less than or equal to n ; Generating primes using Sieve ; Generate all numbers of the form 2 ^ k - 1 and smaller than or equal to n . ; Checking whether number is prime and is one less then the power of 2 ; Driver Code","code":"< ? php function SieveOf ( $ n ) { $ prime = array ( $ n + 1 ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ prime [ $ i ] = true ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } return $ prime ; } function mersennePrimes ( $ n ) { $ prime = SieveOf ( $ n ) ; for ( $ k = 2 ; ( ( 1 << $ k ) - 1 ) <= $ n ; $ k ++ ) { $ num = ( 1 << $ k ) - 1 ; if ( $ prime [ $ num ] ) echo $ num . \" \" ; } } $ n = 31 ; echo \" Mersenne \u2581 prime \u2581 numbers \u2581 smaller \u2581 \" . \" than \u2581 or \u2581 equal \u2581 to \u2581 $ n \u2581 \" . mersennePrimes ( $ n ) ; ? >"}
{"text":"Find sum of modulo K of first N natural number | Return sum of modulo K of first N natural numbers . ; Iterate from 1 to N && evaluating and adding i % K . ; Driver Code","code":"< ? php function findSum ( $ N , $ K ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ ans += ( $ i % $ K ) ; return $ ans ; } $ N = 10 ; $ K = 2 ; echo findSum ( $ N , $ K ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find sum of modulo K of first N natural number | Return sum of modulo K of first N natural numbers . ; Counting the number of times 1 , 2 , . . , K - 1 , 0 sequence occurs . ; Finding the number of elements left which are incomplete of sequence Leads to Case 1 type . ; adding multiplication of number of times 1 , 2 , . . , K - 1 , 0 sequence occurs and sum of first k natural number and sequence from case 1. ; Driver program","code":"< ? php function findSum ( $ N , $ K ) { $ ans = 0 ; $ y = $ N \/ $ K ; $ x = $ N % $ K ; $ ans = ( $ K * ( $ K - 1 ) \/ 2 ) * $ y + ( $ x * ( $ x + 1 ) ) \/ 2 ; return $ ans ; } $ N = 10 ; $ K = 2 ; echo findSum ( $ N , $ K ) ; ? >"}
{"text":"Smallest number to multiply to convert floating point to natural | Finding GCD of two number ; Returns smallest integer k such that k * str becomes natural . str is an input floating point number ; Find size of string representing a floating point number . ; Below is used to find denominator in fraction form . ; Used to find value of count_after_dot ; To find numerator in fraction form of given number . For example , for 30.25 , numerator would be 3025. ; If there was no dot , then number is already a natural . ; Find denominator in fraction form . For example , for 30.25 , denominator is 100 ; Result is denominator divided by GCD - of - numerator - and - denominator . For example , for 30.25 , result is 100 \/ GCD ( 3025 , 100 ) = 100 \/ 25 = 4 ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; } function findnum ( $ str ) { $ n = strlen ( $ str ) ; $ count_after_dot = 0 ; $ dot_seen = false ; $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] != ' . ' ) { $ num = $ num * 10 + ( $ str [ $ i ] - '0' ) ; if ( $ dot_seen == true ) $ count_after_dot ++ ; } else $ dot_seen = true ; } if ( $ dot_seen == false ) return 1 ; $ dem = pow ( 10 , $ count_after_dot ) ; return ( $ dem \/ gcd ( $ num , $ dem ) ) ; } { $ str = \"5.125\" ; echo findnum ( $ str ) ; return 0 ; } ? >"}
{"text":"Find the maximum number of handshakes | Calculating the maximum number of handshake using derived formula . ; Driver Code","code":"< ? php function maxHandshake ( $ n ) { return ( $ n * ( $ n - 1 ) ) \/ 2 ; } $ n = 10 ; echo maxHandshake ( $ n ) ; ? >"}
{"text":"Count digits in given number N which divide N | Utility function to check divisibility by digit ; ( N [ i ] - '0' ) gives the digit value and form the number ; Function to count digits which appears in N and divide N divide [ 10 ] -- > array which tells that particular digit divides N or not count [ 10 ] -- > counts frequency of digits which divide N ; We initialize all digits of N as not divisible by N . ; start checking divisibility of N by digits 2 to 9 ; if digit divides N then mark it as true ; Now traverse the number string to find and increment result whenever a digit divides N . ; Driver Code","code":"< ? php function divisible ( $ N , $ digit ) { $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ N ) ; $ i ++ ) { $ ans = ( $ ans * 10 + ( int ) ( $ N [ $ i ] - '0' ) ) ; $ ans %= $ digit ; } return ( $ ans == 0 ) ; } function allDigits ( $ N ) { $ divide = array_fill ( 0 , 10 , false ) ; for ( $ digit = 2 ; $ digit <= 9 ; $ digit ++ ) { if ( divisible ( $ N , $ digit ) ) $ divide [ $ digit ] = true ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ N ) ; $ i ++ ) { if ( $ divide [ ( int ) ( $ N [ $ i ] - '0' ) ] == true ) $ result ++ ; } return $ result ; } $ N = \"122324\" ; echo allDigits ( $ N ) ; ? >"}
{"text":"Count numbers which can be constructed using two numbers | Returns count of numbers from 1 to n that can be formed using x and y . ; Create an auxiliary array and initialize it as false . An entry arr [ i ] = true is going to mean that i can be formed using x and y ; x and y can be formed using x and y . ; Initialize result ; Traverse all numbers and increment result if a number can be formed using x and y . ; If i can be formed using x and y ; Then i + x and i + y can also be formed using x and y . ; Increment result ; Driver code","code":"< ? php function countNums ( $ n , $ x , $ y ) { $ arr = array_fill ( 0 , $ n + 1 , false ) ; if ( $ x <= $ n ) $ arr [ $ x ] = true ; if ( $ y <= $ n ) $ arr [ $ y ] = true ; $ result = 0 ; for ( $ i = min ( $ x , $ y ) ; $ i <= $ n ; $ i ++ ) { if ( $ arr [ $ i ] ) { if ( $ i + $ x <= $ n ) $ arr [ $ i + $ x ] = true ; if ( $ i + $ y <= $ n ) $ arr [ $ i + $ y ] = true ; $ result ++ ; } } return $ result ; } $ n = 15 ; $ x = 5 ; $ y = 7 ; echo countNums ( $ n , $ x , $ y ) ; ? >"}
{"text":"Emirp numbers | Function to find reverse of any number ; Sieve method used for generating emirp number ( use of sieve ofEratosthenes ) ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Traverse all prime numbers ; Find reverse a number ; A number is emrip if it is not a palindrome number and its reverse is also prime . ; Mark reverse prime as false so that it 's  not printed again ; Driver Code","code":"< ? php function reverse ( $ x ) { $ rev = 0 ; while ( $ x > 0 ) { $ rev = ( $ rev * 10 ) + $ x % 10 ; $ x = ( int ) ( $ x \/ 10 ) ; } return $ rev ; } function printEmirp ( $ n ) { $ prime = array_fill ( 0 , ( $ n + 1 ) , 1 ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == 1 ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = 0 ; } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == 1 ) { $ rev = reverse ( $ p ) ; if ( $ p != $ rev && $ rev <= $ n && $ prime [ $ rev ] == 1 ) { echo $ p . \" \" \u2581 . \u2581 $ rev \u2581 . \u2581 \" \" $ prime [ $ rev ] = 0 ; } } } } $ n = 100 ; printEmirp ( $ n ) ; ? >"}
{"text":"Abundant Number | Function to calculate sum of divisors ; Note that this loop runs till square root of n ; If divisors are equal , take only one of them ; Otherwise take both ; calculate sum of all proper divisors only ; Function to check Abundant Number ; Return true if sum of divisors is greater than n . ; Driver Code","code":"< ? php function getSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ sum = $ sum + $ i ; else { $ sum = $ sum + $ i ; $ sum = $ sum + ( $ n \/ $ i ) ; } } } $ sum = $ sum - $ n ; return $ sum ; } function checkAbundant ( $ n ) { return ( getSum ( $ n ) > $ n ) ; } $ k = checkAbundant ( 12 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ k ) ; $ k = checkAbundant ( 15 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ k ) ; ? >"}
{"text":"Powerful Number | function to check if the number is powerful ; First divide the number repeatedly by 2 ; If only 2 ^ 1 divides n ( not higher powers ) , then return false ; if n is not a power of 2 then this loop will execute repeat above process ; Find highest power of \" factor \" that divides n ; If only factor ^ 1 divides n ( not higher powers ) , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Driver Code","code":"< ? php function isPowerful ( $ n ) { while ( $ n % 2 == 0 ) { $ power = 0 ; while ( $ n % 2 == 0 ) { $ n \/= 2 ; $ power ++ ; } if ( $ power == 1 ) return false ; } for ( $ factor = 3 ; $ factor <= sqrt ( $ n ) ; $ factor += 2 ) { $ power = 0 ; while ( $ n % $ factor == 0 ) { $ n = $ n \/ $ factor ; $ power ++ ; } if ( $ power == 1 ) return false ; } return ( $ n == 1 ) ; } $ d = isPowerful ( 20 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo $ d ; $ d = isPowerful ( 27 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo $ d ; ? >"}
{"text":"Deficient Number | Function to calculate sum of divisors ; Initialize sum of prime factors ; Note that this loop runs till square root of n ; If divisors are equal , take only one of them ; Otherwise take both ; Function to check Deficient Number ; Check if sum ( n ) < 2 * n ; Driver Code","code":"< ? php function divisorsSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) { $ sum = $ sum + $ i ; } else { $ sum = $ sum + $ i ; $ sum = $ sum + ( $ n \/ $ i ) ; } } } return $ sum ; } function isDeficient ( $ n ) { return ( divisorsSum ( $ n ) < ( 2 * $ n ) ) ; } $ ds = isDeficient ( 12 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ ds ) ; $ ds = isDeficient ( 15 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ; echo ( $ ds ) ; ? >"}
{"text":"Smith Number | PHP program to to check whether a number is Smith Number or not . ; array to store all prime less than and equal to 10 ^ 6 ; utility function for sieve of sundaram ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half . This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j ; Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1 ; Since 2 is a prime number ; Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; Returns true if n is a Smith number , else false . ; Find sum the digits of prime factors of n ; If primes [ i ] is a prime factor , add its digits to pDigitSum . ; If n != 1 then one prime factor still to be summed up ; ; All prime factors digits summed up Now sum the original number digits ; If sum of digits in prime factors and sum of digits in original number are same , then return true . Else return false . ; Finding all prime numbers before limit . These numbers are used to find prime factors .","code":"< ? php $ MAX = 10000 ; $ primes = array ( ) ; function sieveSundaram ( ) { global $ MAX , $ primes ; $ marked = array_fill ( 0 , ( $ MAX \/ 2 + 100 ) , false ) ; for ( $ i = 1 ; $ i <= ( sqrt ( $ MAX ) - 1 ) \/ 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= $ MAX \/ 2 ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = true ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= $ MAX \/ 2 ; $ i ++ ) if ( $ marked [ $ i ] == false ) array_push ( $ primes , 2 * $ i + 1 ) ; } function isSmith ( $ n ) { global $ MAX , $ primes ; $ original_no = $ n ; $ pDigitSum = 0 ; for ( $ i = 0 ; $ primes [ $ i ] <= $ n \/ 2 ; $ i ++ ) { while ( $ n % $ primes [ $ i ] == 0 ) { $ p = $ primes [ $ i ] ; $ n = $ n \/ $ p ; while ( $ p > 0 ) { $ pDigitSum += ( $ p % 10 ) ; $ p = $ p \/ 10 ; } } } if ( $ n != 1 && $ n != $ original_no ) { while ( $ n > 0 ) { $ pDigitSum = $ pDigitSum + $ n % 10 ; $ n = $ n \/ 10 ; } } $ sumDigits = 0 ; while ( $ original_no > 0 ) { $ sumDigits = $ sumDigits + $ original_no % 10 ; $ original_no = $ original_no \/ 10 ; } return ( $ pDigitSum == $ sumDigits ) ; } sieveSundaram ( ) ; echo \" Printing \u2581 first \u2581 few \u2581 Smith \u2581 Numbers \" . \" \u2581 using \u2581 isSmith ( ) STRNEWLINE \" ; for ( $ i = 1 ; $ i < 500 ; $ i ++ ) if ( isSmith ( $ i ) ) echo $ i . \" \" ; ? >"}
{"text":"Kaprekar Number | Returns true if n is a Kaprekar number , else false ; Count number of digits in square ; Split the square at different points and see if sum of any pair of splitted numbers is equal to n . ; To avoid numbers like 10 , 100 , 1000 ( These are not Karprekar numbers ; Find sum of current parts and compare with n ; compare with original number ; Driver code","code":"< ? php function iskaprekar ( $ n ) { if ( $ n == 1 ) return true ; $ sq_n = $ n * $ n ; $ count_digits = 0 ; while ( $ sq_n ) { $ count_digits ++ ; $ sq_n = ( int ) ( $ sq_n \/ 10 ) ; } for ( $ r_digits = 1 ; $ r_digits < $ count_digits ; $ r_digits ++ ) { $ eq_parts = pow ( 10 , $ r_digits ) ; if ( $ eq_parts == $ n ) continue ; $ sum = ( int ) ( $ sq_n1 \/ $ eq_parts ) + $ sq_n1 % $ eq_parts ; if ( $ sum == $ n ) return true ; } return false ; } echo \" Printing \u2581 first \u2581 few \u2581 Kaprekar \u2581 \" . \" Numbers \u2581 using \u2581 iskaprekar ( ) STRNEWLINE \" ; for ( $ i = 1 ; $ i < 10000 ; $ i ++ ) if ( iskaprekar ( $ i ) ) echo $ i . \" \" ; ? >"}
{"text":"Keith Number | Returns true if x is Keith , else false . ; Store all digits of x in a vector \" terms \" Also find number of digits and store in \" n \" . ; $n = 0 ; n is number of digits in x ; To get digits in right order ( from MSB to LSB ) ; Keep finding next trms of a sequence generated using digits of x until we either reach x or a number greate than x ; Next term is sum of previous n terms ; When the control comes out of the while loop , either the next_term is equal to the number or greater than it . If next_term is equal to x , then x is a Keith number , else not ; Driver Code","code":"< ? php function isKeith ( $ x ) { $ terms = array ( ) ; $ temp = $ x ; while ( $ temp > 0 ) { array_push ( $ terms , $ temp % 10 ) ; $ temp = ( int ) ( $ temp \/ 10 ) ; $ n ++ ; } $ terms = array_reverse ( $ terms ) ; $ next_term = 0 ; $ i = $ n ; while ( $ next_term < $ x ) { $ next_term = 0 ; for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ next_term += $ terms [ $ i - $ j ] ; array_push ( $ terms , $ next_term ) ; $ i ++ ; } return ( $ next_term == $ x ) ; } isKeith ( 14 ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; isKeith ( 12 ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; isKeith ( 197 ) ? print ( \" Yes STRNEWLINE \" ) : print ( \" No STRNEWLINE \" ) ; ? >"}
{"text":"Check if a number can be expressed as a sum of consecutive numbers | This function returns true if n can be expressed sum of consecutive . ; We basically return true if n is a power of two ; Driver code","code":"< ? php function canBeSumofConsec ( $ n ) { return ( ( $ n & ( $ n - 1 ) ) && $ n ) ; } $ n = 15 ; if ( canBeSumofConsec ( $ n ) ) echo \" true \" ; else echo \" false \" ; ? >"}
{"text":"Even Fibonacci Numbers Sum | Returns sum of even Fibonacci numbers which are less than or equal to given limit . ; Initialize first two even prime numbers and their sum ; calculating sum of even Fibonacci value ; get next even value of Fibonacci sequence ; If we go beyond limit , we break loop ; Move to next even number and update sum ; Driver code","code":"< ? php function evenFibSum ( $ limit ) { if ( $ limit < 2 ) return 0 ; $ ef1 = 0 ; $ ef2 = 2 ; $ sum = $ ef1 + $ ef2 ; while ( $ ef2 <= $ limit ) { $ ef3 = 4 * $ ef2 + $ ef1 ; if ( $ ef3 > $ limit ) break ; $ ef1 = $ ef2 ; $ ef2 = $ ef3 ; $ sum += $ ef2 ; } return $ sum ; } $ limit = 400 ; echo ( evenFibSum ( $ limit ) ) ; ? >"}
{"text":"Find numbers with K odd divisors in a given range | function to check if number is perfect square or not ; Function to return count of divisors of a number ; Note that this loop runs till square root ; If divisors are equal , count it only once ; Otherwise print both ; Function to calculate all divisors having exactly k divisors between a and b ; Initialize result ; calculate only for perfect square numbers ; check if number is perfect square or not ; total divisors of number equals to k or not ; Driver Code","code":"< ? php function isPerfect ( $ n ) { $ s = sqrt ( $ n ) ; return ( $ s * $ s == $ n ) ; } function divisorsCount ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) + 1 ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n \/ $ i == $ i ) $ count += 1 ; else $ count += 2 ; } } return $ count ; } function kDivisors ( $ a , $ b , $ k ) { $ count = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { if ( isPerfect ( $ i ) ) if ( divisorsCount ( $ i ) == $ k ) $ count ++ ; } return $ count ; } $ a = 2 ; $ b = 49 ; $ k = 3 ; echo kDivisors ( $ a , $ b , $ k ) ; ? >"}
{"text":"Nth Even Fibonacci Number | Function which return nth even fibonnaci number ; calculation of Fn = 4 * ( Fn - 1 ) + Fn - 2 ; Driver Code","code":"< ? php function evenFib ( $ n ) { if ( $ n < 1 ) return $ n ; if ( $ n == 1 ) return 2 ; return ( ( 4 * evenFib ( $ n - 1 ) ) + evenFib ( $ n - 2 ) ) ; } $ n = 7 ; echo ( evenFib ( $ n ) ) ; ? >"}
{"text":"N 'th Smart Number | Limit on result ; Function to calculate n 'th smart number  ; Initialize all numbers as not prime ; iterate to mark all primes and smart number ; Traverse all numbers till maximum limit ; ' i ' is maked as prime number because it is not multiple of any other prime ; mark all multiples of ' i ' as non prime ; If i is the third prime factor of j then add it to result as it has at least three prime factors . ; Sort all smart numbers ; return n 'th smart number  ; Driver program to run the case","code":"< ? php $ MAX = 3000 ; function smartNumber ( $ n ) { global $ MAX ; $ primes = array_fill ( 0 , $ MAX , 0 ) ; $ result = array ( ) ; for ( $ i = 2 ; $ i < $ MAX ; $ i ++ ) { if ( $ primes [ $ i ] == 0 ) { $ primes [ $ i ] = 1 ; for ( $ j = $ i * 2 ; $ j < $ MAX ; $ j = $ j + $ i ) { $ primes [ $ j ] -= 1 ; if ( ( $ primes [ $ j ] + 3 ) == 0 ) array_push ( $ result , $ j ) ; } } } sort ( $ result ) ; return $ result [ $ n - 1 ] ; } $ n = 50 ; echo smartNumber ( $ n ) ; ? >"}
{"text":"Repeated subtraction among two numbers | Returns count of steps before one of the numbers become 0 after repeated subtractions . ; If y divides x , then simply return x \/ y . ; Else recur . Note that this function works even if x is smaller than y because in that case first recursive call exchanges roles of x and y . ; Driver code","code":"< ? php function countSteps ( $ x , $ y ) { if ( $ x % $ y == 0 ) return floor ( ( ( int ) $ x \/ $ y ) ) ; return floor ( ( ( int ) $ x \/ $ y ) + countSteps ( $ y , $ x % $ y ) ) ; } $ x = 100 ; $ y = 19 ; echo countSteps ( $ x , $ y ) ; ? >"}
{"text":"Count number of solutions of x ^ 2 = 1 ( mod p ) in given range | Program to count number of values that satisfy x ^ 2 = 1 mod p where x lies in range [ 1 , n ] ; Initialize result ; Traverse all numbers smaller than given number p . Note that we don 't traverse from  1 to n, but 1 to p ; If x is a solution , then count all numbers of the form x + i * p such that x + i * p is in range [ 1 , n ] ; The largest number in the form of x + p * i in range [ 1 , n ] ; Add count of numbers of the form x + p * i . 1 is added for x itself . ; Driver code","code":"< ? php function findCountOfSolutions ( $ n , $ p ) { $ ans = 0 ; for ( $ x = 1 ; $ x < $ p ; $ x ++ ) { if ( ( $ x * $ x ) % $ p == 1 ) { $ last = $ x + $ p * ( $ n \/ $ p ) ; if ( $ last > $ n ) $ last -= $ p ; $ ans += ( ( $ last - $ x ) \/ $ p + 1 ) ; } } return $ ans ; } $ n = 10 ; $ p = 5 ; echo findCountOfSolutions ( $ n , $ p ) ; ? >"}
{"text":"Kaprekar Constant | This function checks validity of kaprekar ' s \u2581 constant . \u2581 It \u2581 returns \u2581 kaprekar ' s constant for any four digit number \" n \" such that all digits of n are not same . ; Store current n as previous number ; Get four digits of given number ; Sort all four dgits in ascending order And giet in the form of number \" asc \" ; Get all four dgits in descending order in the form of number \" desc \" ; Get the difference of two numbers ; If difference is same as previous , we have reached kaprekar 's constant ; Else recur ; A wrapper over kaprekarRec ( ) ; Trying few four digit numbers , we always get 6174","code":"< ? php function kaprekarRec ( $ n , $ prev ) { if ( $ n == 0 ) return 0 ; $ prev = $ n ; $ digits = array_fill ( 0 , 4 , 0 ) ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ digits [ $ i ] = $ n % 10 ; $ n = ( int ) ( $ n \/ 10 ) ; } sort ( $ digits ) ; $ asc = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) $ asc = $ asc * 10 + $ digits [ $ i ] ; rsort ( $ digits ) ; $ desc = 0 ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) $ desc = $ desc * 10 + $ digits [ $ i ] ; $ diff = abs ( $ asc - $ desc ) ; if ( $ diff == $ prev ) return $ diff ; return kaprekarRec ( $ diff , $ prev ) ; } function kaprekar ( $ n ) { $ rev = 0 ; return kaprekarRec ( $ n , $ rev ) ; } echo kaprekar ( 1000 ) . \" STRNEWLINE \" ; echo kaprekar ( 1112 ) . \" STRNEWLINE \" ; echo kaprekar ( 9812 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Bakhshali Approximation for computing square roots | This PHP program gives result approximated to 5 decimal places . ; This will be the nearest perfect square to s ; This is the sqrt of pSq ; Find the nearest perfect square to s ; calculate d ; calculate P ; calculate A ; calculate sqrt ( S ) . ; Driver Code","code":"< ? php function sqroot ( $ s ) { $ pSq = 0 ; $ N = 0 ; for ( $ i = intval ( $ s ) ; $ i > 0 ; $ i -- ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ j * $ j == $ i ) { $ pSq = $ i ; $ N = $ j ; break ; } } if ( $ pSq > 0 ) break ; } $ d = $ s - $ pSq ; $ P = $ d \/ ( 2.0 * $ N ) ; $ A = $ N + $ P ; $ sqrt_of_s = $ A - ( ( $ P * $ P ) \/ ( 2.0 * $ A ) ) ; return $ sqrt_of_s ; } $ num = 9.2345 ; $ sqroot_of_num = sqroot ( $ num ) ; echo \" Square \u2581 root \u2581 of \u2581 \" . $ num . \" \u2581 = \u2581 \" . round ( ( $ sqroot_of_num * 100000.0 ) \/ 100000.0 , 5 ) ; ? >"}
{"text":"Breaking an Integer to get Maximum Product | method return x ^ a in log ( a ) time ; Method returns maximum product obtained by breaking N ; base case 2 = 1 + 1 ; base case 3 = 2 + 1 ; breaking based on mod with 3 ; If divides evenly , then break into all 3 ; If division gives mod as 1 , then break as 4 + power of 3 for remaining part ; If division gives mod as 2 , then break as 2 + power of 3 for remaining part ; Driver code to test above methods","code":"< ? php function power ( $ x , $ a ) { $ res = 1 ; while ( $ a ) { if ( $ a & 1 ) $ res = $ res * $ x ; $ x = $ x * $ x ; $ a >>= 1 ; } return $ res ; } function breakInteger ( $ N ) { if ( $ N == 2 ) return 1 ; if ( $ N == 3 ) return 2 ; $ maxProduct = 0 ; switch ( $ N % 3 ) { case 0 : $ maxProduct = power ( 3 , $ N \/ 3 ) ; break ; case 1 : $ maxProduct = 2 * 2 * power ( 3 , ( $ N \/ 3 ) - 1 ) ; break ; case 2 : $ maxProduct = 2 * power ( 3 , $ N \/ 3 ) ; break ; } return $ maxProduct ; } $ maxProduct = breakInteger ( 10 ) ; echo $ maxProduct ; ? >"}
{"text":"Finding sum of digits of a number until sum becomes single digit | PHP program to find sum of digits of a number until sum becomes single digit . ; Loop to do sum while sum is not less than or equal to 9 ; Driver Code","code":"< ? php function digSum ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n = ( int ) $ n \/ 10 ; } return $ sum ; } $ n = 1234 ; echo digSum ( $ n ) ; ? >"}
{"text":"Finding sum of digits of a number until sum becomes single digit | Driver program to test the above function","code":"< ? php function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; } $ n = 9999 ; echo digSum ( $ n ) ; ? >"}
{"text":"Multiples of 3 or 7 | Returns count of all numbers smaller than or equal to n and multiples of 3 or 7 or both ; Driver code","code":"< ? php function countMultiples ( $ n ) { return floor ( $ n \/ 3 + $ n \/ 7 - $ n \/ 21 ) ; } echo \" Count = \" ? >"}
{"text":"Find Last Digit of a ^ b for Large Numbers | Function to find b % a ; Initialize result ; calculating mod of b with a to make b like 0 <= b < a ; return $mod ; return modulo ; function to find last digit of a ^ b ; if a and b both are 0 ; if exponent is 0 ; if base is 0 ; if exponent is divisible by 4 that means last digit will be pow ( a , 4 ) % 10. if exponent is not divisible by 4 that means last digit will be pow ( a , b % 4 ) % 10 ; Find last digit in ' a ' and compute its exponent ; Return last digit of result ; Driver program to run test case","code":"< ? php function Modulo ( $ a , $ b ) { $ mod = 0 ; for ( $ i = 0 ; $ i < strlen ( $ b ) ; $ i ++ ) $ mod = ( $ mod * 10 + $ b [ $ i ] - '0' ) % $ a ; } function LastDigit ( $ a , $ b ) { $ len_a = strlen ( $ a ) ; $ len_b = strlen ( $ b ) ; if ( $ len_a == 1 && $ len_b == 1 && $ b [ 0 ] == '0' && $ a [ 0 ] == '0' ) return 1 ; if ( $ len_b == 1 && $ b [ 0 ] == '0' ) return 1 ; if ( $ len_a == 1 && $ a [ 0 ] == '0' ) return 0 ; $ exp = ( Modulo ( 4 , $ b ) == 0 ) ? 4 : Modulo ( 4 , $ b ) ; $ res = pow ( $ a [ $ len_a - 1 ] - '0' , $ exp ) ; return $ res % 10 ; } $ a = \"117\" ; $ b = \"3\" ; echo LastDigit ( $ a , $ b ) ; ? >"}
{"text":"Reverse and Add Function | Iterative function to reverse digits of num ; Function to check whether he number is palindrome or not ; Reverse and Add Function ; Reversing the digits of the number ; Adding the reversed number with the original ; Checking whether the number is palindrome or not ; Driver Code","code":"< ? php function reversDigits ( $ num ) { $ rev_num = 0 ; while ( $ num > 0 ) { $ rev_num = $ rev_num * 10 + $ num % 10 ; $ num = ( int ) ( $ num \/ 10 ) ; } return $ rev_num ; } function isPalindrome ( $ num ) { return ( reversDigits ( $ num ) == $ num ) ; } function ReverseandAdd ( $ num ) { $ rev_num = 0 ; while ( $ num <= 4294967295 ) { $ rev_num = reversDigits ( $ num ) ; $ num = $ num + $ rev_num ; if ( isPalindrome ( $ num ) ) { print ( $ num . \" \" ) ; break ; } else if ( $ num > 4294967295 ) { print ( \" No \u2581 palindrome \u2581 exist \" ) ; } } } ReverseandAdd ( 195 ) ; ReverseandAdd ( 265 ) ; ? >"}
{"text":"Stein 's Algorithm for finding GCD | Function to implement Stein 's Algorithm ; GCD ( 0 , b ) == b ; GCD ( a , 0 ) == a , GCD ( 0 , 0 ) == 0 ; look for factors of 2 if ( ~ $a & 1 ) a is even ; if ( $b & 1 ) b is odd ; else both a and b are even ; if ( ~ $b & 1 ) a is odd , b is even ; reduce larger number ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == $ b ) return $ a ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; { return gcd ( $ a >> 1 , $ b ) ; return gcd ( $ a >> 1 , $ b >> 1 ) << 1 ; } return gcd ( $ a , $ b >> 1 ) ; if ( $ a > $ b ) return gcd ( ( $ a - $ b ) >> 1 , $ b ) ; return gcd ( ( $ b - $ a ) >> 1 , $ a ) ; } $ a = 34 ; $ b = 17 ; echo \" Gcd \u2581 of \u2581 given \u2581 numbers \u2581 is : \u2581 \" , gcd ( $ a , $ b ) ; ? >"}
{"text":"Print all n | n , sum -- > value of inputs out -- > output array index -- > index of next digit to be filled in output array ; Base case ; If number becomes N - digit ; if sum of its digits is equal to given sum , print it ; Traverse through every digit . Note that here we ' re \u2581 considering \u2581 leading \u2581 \u2581 0' s as digits ; append current digit to number ; recurse for next digit with reduced sum ; This is mainly a wrapper over findNDigitNumsUtil . It explicitly handles leading digit ; output array to store N - digit numbers ; fill 1 st position by every digit from 1 to 9 and calls findNDigitNumsUtil ( ) for remaining positions ; Driver Code","code":"< ? php function findNDigitNumsUtil ( $ n , $ sum , $ out , $ index ) { if ( $ index > $ n $ sum < 0 ) return ; if ( $ index == $ n ) { if ( $ sum == 0 ) { $ out [ $ index ] = ' ' ; foreach ( $ out as & $ value ) print ( $ value ) ; print ( \" \u2581 \" ) ; } return ; } for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ out [ $ index ] = chr ( $ i + ord ( '0' ) ) ; findNDigitNumsUtil ( $ n , $ sum - $ i , $ out , $ index + 1 ) ; } } function findNDigitNums ( $ n , $ sum ) { $ out = array_fill ( 0 , $ n + 1 , false ) ; for ( $ i = 1 ; $ i <= 9 ; $ i ++ ) { $ out [ 0 ] = chr ( $ i + ord ( '0' ) ) ; findNDigitNumsUtil ( $ n , $ sum - $ i , $ out , 1 ) ; } } $ n = 2 ; $ sum = 3 ; findNDigitNums ( $ n , $ sum ) ; ? >"}
{"text":"Palindromic Primes | A function that returns true only if num contains one digit ; comparison operation is faster than division operation . So using following instead of \" return \u2581 num \u2581 \/ \u2581 10 \u2581 = = \u2581 0 ; \" ; A recursive function to find out whether num is palindrome or not . Initially , dupNum contains address of a copy of num . ; Base case ( needed for recursion termination ) : This statement \/ mainly compares the first digit with the last digit ; This is the key line in this method . Note that all recursive \/ calls have a separate copy of num , but they all share same copy of dupNum . We divide num while moving up the recursion tree ; The following statements are executed when we move up the recursion call tree ; At this point , if num % 10 contains ith digit from beginning , then ( dupNum ) % 10 contains ith digit from end ; The main function that uses recursive function isPalUtil ( ) to find out whether num is palindrome or not ; If num is negative , make it positive ; Create a separate copy of num , so that modifications made to address dupNum don 't change the input number.  $dupNum = $num; dupNum = num ; Function to generate all primes and checking whether number is palindromic or not ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all palindromic prime numbers ; checking whether the given number is prime palindromic or not ; Driver Code","code":"< ? php function oneDigit ( $ num ) { return ( $ num >= 0 && $ num < 10 ) ; } function isPalUtil ( $ num , $ dupNum ) { if ( oneDigit ( $ num ) ) return ( $ num == ( $ dupNum ) % 10 ) ; if ( ! isPalUtil ( ( int ) ( $ num \/ 10 ) , $ dupNum ) ) return false ; $ dupNum = ( int ) ( $ dupNum \/ 10 ) ; return ( $ num % 10 == ( $ dupNum ) % 10 ) ; } function isPal ( $ num ) { if ( $ num < 0 ) $ num = - $ num ; return isPalUtil ( $ num , $ dupNum ) ; } function printPalPrimesLessThanN ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) { $ prime [ $ i ] = false ; } } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] && isPal ( $ p ) ) { print ( $ p . \" \" ) ; } } } $ n = 100 ; print ( \" Palindromic \u2581 primes \u2581 smaller \u2581 \" . \" than \u2581 or \u2581 equal \u2581 to \u2581 \" . $ n . \" \u2581 are \u2581 : STRNEWLINE \" ) ; printPalPrimesLessThanN ( $ n ) ; ? >"}
{"text":"Almost Prime Numbers | A function to count all prime factors of a given number ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , count i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; A function to print the first n numbers that are k - almost primes . ; Print this number if it is k - prime ; Increment count of k - primes printed so far ; Driver Code","code":"< ? php function countPrimeFactors ( $ n ) { $ count = 0 ; while ( $ n % 2 == 0 ) { $ n = $ n \/ 2 ; $ count ++ ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { $ n = $ n \/ $ i ; $ count ++ ; } } if ( $ n > 2 ) $ count ++ ; return ( $ count ) ; } function printKAlmostPrimes ( $ k , $ n ) { for ( $ i = 1 , $ num = 2 ; $ i <= $ n ; $ num ++ ) { if ( countPrimeFactors ( $ num ) == $ k ) { echo ( $ num ) ; echo ( \" \u2581 \" ) ; $ i ++ ; } } return ; } $ n = 10 ; $ k = 2 ; echo \" First \u2581 $ n \u2581 $ k - almost \u2581 prime \u2581 numbers : STRNEWLINE \" ; printKAlmostPrimes ( $ k , $ n ) ; ? >"}
{"text":"Program to add two fractions | Function to return gcd of a and b ; Function to convert the obtained fraction into it 's simplest form ; Finding gcd of both terms ; Converting both terms into simpler terms by dividing them by common factor ; Function to add two fractions ; Finding gcd of den1 and den2 ; Denominator of final fraction obtained finding LCM of den1 and den2 LCM * GCD = a * b ; Changing the fractions to have same denominator Numerator of the final fraction obtained ; Calling function to convert final fraction into it 's  simplest form ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function lowest ( & $ den3 , & $ num3 ) { $ common_factor = gcd ( $ num3 , $ den3 ) ; $ den3 = ( int ) $ den3 \/ $ common_factor ; $ num3 = ( int ) $ num3 \/ $ common_factor ; } function addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , & $ num3 , & $ den3 ) { $ den3 = gcd ( $ den1 , $ den2 ) ; $ den3 = ( $ den1 * $ den2 ) \/ $ den3 ; $ num3 = ( $ num1 ) * ( $ den3 \/ $ den1 ) + ( $ num2 ) * ( $ den3 \/ $ den2 ) ; lowest ( $ den3 , $ num3 ) ; } $ num1 = 1 ; $ den1 = 500 ; $ num2 = 2 ; $ den2 = 1500 ; $ den3 ; $ num3 ; addFraction ( $ num1 , $ den1 , $ num2 , $ den2 , $ num3 , $ den3 ) ; echo $ num1 , \" \/ \" , $ den1 , \" \u2581 + \u2581 \" , $ num2 , \" \/ \" , $ den2 , \" \u2581 is \u2581 equal \u2581 to \u2581 \" , $ num3 , \" \/ \" , $ den3 , \" STRNEWLINE \" ; ? >"}
{"text":"The Lazy Caterer 's Problem | This function receives an integer n and returns the maximum number of pieces that can be made form pancake using n cuts ; Use the formula ; Driver Code","code":"< ? php function findPieces ( $ n ) { return ( $ n * ( $ n + 1 ) ) \/ 2 + 1 ; } echo findPieces ( 1 ) , \" STRNEWLINE \" ; echo findPieces ( 2 ) , \" STRNEWLINE \" ; echo findPieces ( 3 ) , \" STRNEWLINE \" ; echo findPieces ( 50 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count digits in a factorial | Set 2 | Returns the number of digits present in n ! Since the result can be large long long is used as return type ; factorial of - ve number doesn 't exists ; base case ; Use Kamenetsky formula to calculate the number of digits ; Driver Code","code":"< ? php function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ x = ( ( $ n * log10 ( $ n \/ M_E ) + log10 ( 2 * M_PI * $ n ) \/ 2.0 ) ) ; return floor ( $ x ) + 1 ; } echo findDigits ( 1 ) . \" STRNEWLINE \" ; echo findDigits ( 50000000 ) . \" STRNEWLINE \" ; echo findDigits ( 1000000000 ) . \" STRNEWLINE \" ; echo findDigits ( 120 ) ; ? >"}
{"text":"Count digits in a factorial | Set 1 | This function receives an integer n , and returns the number of digits present in n ! ; factorial exists only for n >= 0 ; base case ; else iterate through n and calculate the value ; Driver code","code":"< ? php function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ digits = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ digits += log10 ( $ i ) ; return floor ( $ digits ) + 1 ; } echo findDigits ( 1 ) , \" STRNEWLINE \" ; echo findDigits ( 5 ) , \" STRNEWLINE \" ; echo findDigits ( 10 ) , \" STRNEWLINE \" ; echo findDigits ( 120 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Find number of subarrays with even sum | PHP program to count number of sub - arrays whose sum is even using brute force Time Complexity - O ( N ^ 2 ) Space Complexity - O ( 1 ) ; Find sum of all subarrays and increment result if sum is even ; Driver code","code":"< ? php function countEvenSum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ sum = $ sum + $ arr [ $ j ] ; if ( $ sum % 2 == 0 ) $ result ++ ; } } return ( $ result ) ; } $ arr = array ( 1 , 2 , 2 , 3 , 4 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" The \u2581 Number \u2581 of \u2581 Subarrays \u2581 \" , \" with \u2581 even \u2581 sum \u2581 is \u2581 \" , countEvenSum ( $ arr , $ n ) ; ? >"}
{"text":"Find number of subarrays with even sum | PHP program to count number of sub - arrays with even sum using an efficient algorithm Time Complexity - O ( N ) Space Complexity - O ( 1 ) ; A temporary array of size 2. temp [ 0 ] is going to store count of even subarrays and temp [ 1 ] count of odd . temp [ 0 ] is initialized as 1 because there a single even element is also counted as a subarray ; Initialize count . sum is sum of elements under modulo 2 and ending with arr [ i ] . ; i ' th \u2581 iteration \u2581 computes \u2581 \u2581 sum \u2581 of \u2581 arr [ 0 . . i ] \u2581 under \u2581 \u2581 modulo \u2581 2 \u2581 and \u2581 increments \u2581 \u2581 even \/ odd \u2581 count \u2581 according \u2581 \u2581 to \u2581 sum ' s value ; 2 is added to handle negative numbers ; Increment even \/ odd count ; Use handshake lemma to count even subarrays ( Note that an even can be formed by two even or two odd ) ; Driver code","code":"< ? php function countEvenSum ( $ arr , $ n ) { $ temp = array ( 1 , 0 ) ; $ result = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = ( ( $ sum + $ arr [ $ i ] ) % 2 + 2 ) % 2 ; $ temp [ $ sum ] ++ ; } $ result = $ result + ( int ) ( $ temp [ 0 ] * ( $ temp [ 0 ] - 1 ) \/ 2 ) ; $ result = $ result + ( int ) ( $ temp [ 1 ] * ( $ temp [ 1 ] - 1 ) \/ 2 ) ; return ( $ result ) ; } $ arr = array ( 1 , 2 , 2 , 3 , 4 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" The \u2581 Number \u2581 of \u2581 Subarrays \u2581 \" . \" with \u2581 even \" , \" \u2581 sum \u2581 is \u2581 \" , countEvenSum ( $ arr , $ n ) ; ? >"}
{"text":"Sum of Fibonacci Numbers | Computes value of first fibonacci numbers ; Initialize result ; Add remaining terms ; Driver Code","code":"< ? php function calculateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = $ fibo [ 0 ] + $ fibo [ 1 ] ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += $ fibo [ $ i ] ; } return $ sum ; } $ n = 4 ; echo \" Sum \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \u2581 \" , calculateSum ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Sum of Fibonacci Numbers | PHP Program to find sum of Fibonacci numbers in O ( Log n ) time . ; Create an array for memoization ; Returns n 'th Fibonacci number using table f[] ; Base cases ; If fib ( n ) is already computed ; Applying above formula [ Note value n & 1 is 1 if n is odd , else 0 ] . ; Computes value of first Fibonacci numbers ; Driver Code","code":"< ? php $ MAX = 1000 ; $ f = array_fill ( 0 , $ MAX , 0 ) ; function fib ( $ n ) { global $ f ; if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return ( $ f [ $ n ] = 1 ) ; if ( $ f [ $ n ] ) return $ f [ $ n ] ; $ k = ( $ n & 1 ) ? ( $ n + 1 ) \/ 2 : $ n \/ 2 ; $ f [ $ n ] = ( $ n & 1 ) ? ( fib ( $ k ) * fib ( $ k ) + fib ( $ k - 1 ) * fib ( $ k - 1 ) ) : ( 2 * fib ( $ k - 1 ) + fib ( $ k ) ) * fib ( $ k ) ; return $ f [ $ n ] ; } function calculateSum ( $ n ) { return fib ( $ n + 2 ) - 1 ; } $ n = 4 ; print ( \" Sum \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \u2581 \" . calculateSum ( $ n ) ) ; ? >"}
{"text":"Find all combinations that add upto given number | arr - array to store the combination index - next location in array num - given number reducedNum - reduced number ; Base condition ; If combination is found , print it ; Find the previous number stored in arr [ ] It helps in maintaining increasing order ; note loop starts from previous number i . e . at array location index - 1 ; next element of array is k ; call recursively with reduced number ; Function to find out all combinations of positive numbers that add upto given number . It uses findCombinationsUtil ( ) ; array to store the combinations It can contain max n elements ; find all combinations ; Driver code","code":"< ? php function findCombinationsUtil ( $ arr , $ index , $ num , $ reducedNum ) { if ( $ reducedNum < 0 ) return ; if ( $ reducedNum == 0 ) { for ( $ i = 0 ; $ i < $ index ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; return ; } $ prev = ( $ index == 0 ) ? 1 : $ arr [ $ index - 1 ] ; for ( $ k = $ prev ; $ k <= $ num ; $ k ++ ) { $ arr [ $ index ] = $ k ; findCombinationsUtil ( $ arr , $ index + 1 , $ num , $ reducedNum - $ k ) ; } } function findCombinations ( $ n ) { $ arr = array ( ) ; findCombinationsUtil ( $ arr , 0 , $ n , $ n ) ; } $ n = 5 ; findCombinations ( $ n ) ; ? >"}
{"text":"Find Square Root under Modulo p | Set 2 ( Shanks Tonelli algorithm ) | utility function to find pow ( base , exponent ) % modulus ; utility function to find gcd ; Returns k such that b ^ k = 1 ( mod p ) ; Initializing k with first odd prime number ; function return p - 1 ( = x argument ) as x * 2 ^ e , where x will be odd sending e as reference because updation is needed in actual e ; Main function for finding the modular square root ; a and p should be coprime for finding the modular square root ; If below expression return ( p - 1 ) then modular square root is not possible ; expressing p - 1 , in terms of s * 2 ^ e , where s is odd number ; finding smallest q such that q ^ ( ( p - 1 ) \/ 2 ) ( mod p ) = p - 1 ; q - 1 is in place of ( - 1 % p ) ; Initializing variable x , b and g ; keep looping until b become 1 or m becomes 0 ; finding m such that b ^ ( 2 ^ m ) = 1 ; updating value of x , g and b according to algorithm ; Driver Code ; p should be prime","code":"< ? php function pow1 ( $ base , $ exponent , $ modulus ) { $ result = 1 ; $ base = $ base % $ modulus ; while ( $ exponent > 0 ) { if ( $ exponent % 2 == 1 ) $ result = ( $ result * $ base ) % $ modulus ; $ exponent = $ exponent >> 1 ; $ base = ( $ base * $ base ) % $ modulus ; } return $ result ; } function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; else return gcd ( $ b , $ a % $ b ) ; } function order ( $ p , $ b ) { if ( gcd ( $ p , $ b ) != 1 ) { print ( \" p \u2581 and \u2581 b \u2581 are \u2581 not \u2581 co - prime . STRNEWLINE \" ) ; return -1 ; } $ k = 3 ; while ( 1 ) { if ( pow1 ( $ b , $ k , $ p ) == 1 ) return $ k ; $ k ++ ; } } function convertx2e ( $ x , & $ e ) { $ e = 0 ; while ( $ x % 2 == 0 ) { $ x = ( int ) ( $ x \/ 2 ) ; $ e ++ ; } return $ x ; } function STonelli ( $ n , $ p ) { if ( gcd ( $ n , $ p ) != 1 ) { print ( \" a \u2581 and \u2581 p \u2581 are \u2581 not \u2581 coprime STRNEWLINE \" ) ; return -1 ; } if ( pow1 ( $ n , ( $ p - 1 ) \/ 2 , $ p ) == ( $ p - 1 ) ) { printf ( \" no \u2581 sqrt \u2581 possible STRNEWLINE \" ) ; return -1 ; } $ e = 0 ; $ s = convertx2e ( $ p - 1 , $ e ) ; $ q = 2 ; for ( ; ; $ q ++ ) { if ( pow1 ( $ q , ( $ p - 1 ) \/ 2 , $ p ) == ( $ p - 1 ) ) break ; } $ x = pow1 ( $ n , ( $ s + 1 ) \/ 2 , $ p ) ; $ b = pow1 ( $ n , $ s , $ p ) ; $ g = pow1 ( $ q , $ s , $ p ) ; $ r = $ e ; while ( 1 ) { $ m = 0 ; for ( ; $ m < $ r ; $ m ++ ) { if ( order ( $ p , $ b ) == -1 ) return -1 ; if ( order ( $ p , $ b ) == pow ( 2 , $ m ) ) break ; } if ( $ m == 0 ) return $ x ; $ x = ( $ x * pow1 ( $ g , pow ( 2 , $ r - $ m - 1 ) , $ p ) ) % $ p ; $ g = pow1 ( $ g , pow ( 2 , $ r - $ m ) , $ p ) ; $ b = ( $ b * $ g ) % $ p ; if ( $ b == 1 ) return $ x ; $ r = $ m ; } } $ n = 2 ; $ p = 113 ; $ x = STonelli ( $ n , $ p ) ; if ( $ x == -1 ) print ( \" Modular \u2581 square \u2581 root \u2581 is \u2581 not \u2581 exist STRNEWLINE \" ) ; else print ( \" Modular \u2581 square \u2581 root \u2581 of \u2581 \" . \" $ n \u2581 and \u2581 $ p \u2581 is \u2581 $ x STRNEWLINE \" ) ; ? >"}
{"text":"Check if a number is a power of another number | PHP program to check given number number y ; logarithm function to calculate value ; Note : this is double ; compare to the result1 or result2 both are equal ; Driver Code","code":"< ? php function isPower ( $ x , $ y ) { $ res1 = log ( $ y ) \/ log ( $ x ) ; $ res2 = log ( $ y ) \/ log ( $ x ) ; return ( $ res1 == $ res2 ) ; } echo isPower ( 27 , 729 ) ; ? >"}
{"text":"Program to find the Roots of Quadratic equation | Prints roots of quadratic equation ax * 2 + bx + x ; If a is 0 , then equation is not quadratic , but linear ; d < 0 ; Driver code ; Function call","code":"< ? php function findRoots ( $ a , $ b , $ c ) { if ( $ a == 0 ) { echo \" Invalid \" ; return ; } $ d = $ b * $ b - 4 * $ a * $ c ; $ sqrt_val = sqrt ( abs ( $ d ) ) ; if ( $ d > 0 ) { echo \" Roots \u2581 are \u2581 real \u2581 and \u2581 \" . \" different \u2581 STRNEWLINE \" ; echo ( - $ b + $ sqrt_val ) \/ ( 2 * $ a ) , \" STRNEWLINE \" , ( - $ b - $ sqrt_val ) \/ ( 2 * $ a ) ; } else if ( $ d == 0 ) { echo \" Roots \u2581 are \u2581 real \u2581 and \u2581 same \u2581 STRNEWLINE \" ; echo - $ b \/ ( 2 * $ a ) ; } else { echo \" Roots \u2581 are \u2581 complex \u2581 STRNEWLINE \" ; echo - $ b \/ ( 2 * $ a ) , \" \u2581 + \u2581 i \" , $ sqrt_val , \" STRNEWLINE \" , - $ b \/ ( 2 * $ a ) , \" \u2581 - \u2581 i \" , $ sqrt_val ; } } $ a = 1 ; $ b = -7 ; $ c = 12 ; findRoots ( $ a , $ b , $ c ) ; ? >"}
{"text":"Check perfect square using addition \/ subtraction | This function returns true if n is perfect square , else false ; sum is sum of all odd numbers . i is used one by one hold odd numbers ; Driver code","code":"< ? php function isPerfectSquare ( $ n ) { for ( $ sum = 0 , $ i = 1 ; $ sum < $ n ; $ i += 2 ) { $ sum += $ i ; if ( $ sum == $ n ) return true ; } return false ; } if ( isPerfectSquare ( 35 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isPerfectSquare ( 49 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Count ' d ' digit positive integers with 0 as a digit | Returns count of ' d ' digit integers have 0 as a digit ; Driver Code","code":"< ? php function findCount ( $ d ) { return 9 * ( pow ( 10 , $ d - 1 ) - pow ( 9 , $ d - 1 ) ) ; } { $ d = 1 ; echo findCount ( $ d ) , \" STRNEWLINE \" ; $ d = 2 ; echo findCount ( $ d ) , \" STRNEWLINE \" ; $ d = 4 ; echo findCount ( $ d ) , \" STRNEWLINE \" ; return 0 ; } ? >"}
{"text":"Dyck path | Returns count Dyck paths in n x n grid ; Compute value of 2 nCn ; return 2 nCn \/ ( n + 1 ) ; Driver Code","code":"< ? php function countDyckPaths ( $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ res *= ( 2 * $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res \/ ( $ n + 1 ) ; } $ n = 4 ; echo \" Number \u2581 of \u2581 Dyck \u2581 Paths \u2581 is \u2581 \" , countDyckPaths ( $ n ) ; ? >"}
{"text":"Triangular Numbers | Returns true if ' num ' is triangular , else false ; Base case ; A Triangular number must be sum of first n natural numbers ; Driver code","code":"< ? php function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ sum = 0 ; for ( $ n = 1 ; $ sum <= $ num ; $ n ++ ) { $ sum = $ sum + $ n ; if ( $ sum == $ num ) return true ; } return false ; } $ n = 55 ; if ( isTriangular ( $ n ) ) echo \" The \u2581 number \u2581 is \u2581 a \u2581 triangular \u2581 number \" ; else echo \" The \u2581 number \u2581 is \u2581 NOT \u2581 a \u2581 triangular \u2581 number \" ; ? >"}
{"text":"Triangular Numbers | Returns true if num is triangular ; Considering the equation n * ( n + 1 ) \/ 2 = num The equation is : a ( n ^ 2 ) + bn + c = 0 \"; ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Driver code","code":"< ? php function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ c = ( -2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return false ; $ root1 = ( - $ b + ( float ) sqrt ( $ d ) ) \/ ( 2 * $ a ) ; $ root2 = ( - $ b - ( float ) sqrt ( $ d ) ) \/ ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return true ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return true ; return false ; } $ num = 55 ; if ( isTriangular ( $ num ) ) echo ( \" The \u2581 number \u2581 is \" . \" \u2581 a \u2581 triangular \u2581 number \" ) ; else echo ( \" The \u2581 number \u2581 \" . \" is \u2581 NOT \u2581 a \u2581 triangular \u2581 number \" ) ; ? >"}
{"text":"Convert from any base to decimal and vice versa | To return value of a char . For example , 2 is returned for '2' . 10 is returned for ' A ' , 11 for ' B ' ; Function to convert a number from given base ' b ' to decimal ; Initialize power of base ; Initialize result ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 2 ] * base + str [ len - 3 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Driver code","code":"< ? php function val ( $ c ) { if ( $ c >= '0' && $ c <= '9' ) return ord ( $ c ) - ord ( '0' ) ; else return ord ( $ c ) - ord ( ' A ' ) + 10 ; } function toDeci ( $ str , $ base ) { $ len = strlen ( $ str ) ; $ power = 1 ; $ num = 0 ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { if ( val ( $ str [ $ i ] ) >= $ base ) { print ( \" Invalid \u2581 Number \" ) ; return -1 ; } $ num += val ( $ str [ $ i ] ) * $ power ; $ power = $ power * $ base ; } return $ num ; } $ str = \"11A \" ; $ base = 16 ; print ( \" Decimal \u2581 equivalent \u2581 of \u2581 $ str \u2581 \" . \" in \u2581 base \u2581 $ base \u2581 is \u2581 \" . toDeci ( $ str , $ base ) ) ; ? >"}
{"text":"Frobenius coin problem | Utility function to find gcd ; Function to print the desired output ; Solution doesn 't exist   if GCD is not 1 ; Else apply the formula ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { $ c ; while ( $ a != 0 ) { $ c = $ a ; $ a = $ b % $ a ; $ b = $ c ; } return $ b ; } function forbenius ( $ X , $ Y ) { if ( gcd ( $ X , $ Y ) != 1 ) { echo \" NA STRNEWLINE \" ; return ; } $ A = ( $ X * $ Y ) - ( $ X + $ Y ) ; $ N = ( $ X - 1 ) * ( $ Y - 1 ) \/ 2 ; echo \" Largest Amount = \" , \u2581 $ A , \u2581 \" \" ; STRNEWLINE TABSYMBOL echo \u2581 \" Total Count = \" , \u2581 $ N , \u2581 \" \" } $ X = 2 ; $ Y = 5 ; forbenius ( $ X , $ Y ) ; $ X = 5 ; $ Y = 10 ; echo \" STRNEWLINE \" ; forbenius ( $ X , $ Y ) ; ? >"}
{"text":"Gray to Binary and Binary to Gray conversion | Helper function to xor two characters ; Helper function to flip the bit ; function to convert binary string to gray string ; MSB of gray code is same as binary code ; Compute remaining bits , next bit is computed by doing XOR of previous and current in Binary ; Concatenate XOR of previous bit with current bit ; function to convert gray code string to binary string ; MSB of binary code is same as gray code ; Compute remaining bits ; If current bit is 0 , concatenate previous bit ; Else , concatenate invert of previous bit ; Driver Code","code":"< ? php function xor_c ( $ a , $ b ) { return ( $ a == $ b ) ? '0' : '1' ; } function flip ( $ c ) { return ( $ c == '0' ) ? '1' : '0' ; } function binarytoGray ( $ binary ) { $ gray = \" \" ; $ gray . = $ binary [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ binary ) ; $ i ++ ) { $ gray . = xor_c ( $ binary [ $ i - 1 ] , $ binary [ $ i ] ) ; } return $ gray ; } function graytoBinary ( $ gray ) { $ binary = \" \" ; $ binary . = $ gray [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ gray ) ; $ i ++ ) { if ( $ gray [ $ i ] == '0' ) $ binary . = $ binary [ $ i - 1 ] ; else $ binary . = flip ( $ binary [ $ i - 1 ] ) ; } return $ binary ; } $ binary = \"01001\" ; print ( \" Gray \u2581 code \u2581 of \u2581 \" . $ binary . \" \u2581 is \u2581 \" . binarytoGray ( $ binary ) . \" STRNEWLINE \" ) ; $ gray = \"01101\" ; print ( \" Binary \u2581 code \u2581 of \u2581 \" . $ gray . \" \u2581 is \u2581 \" . graytoBinary ( $ gray ) ) ; ? >"}
{"text":"Solving f ( n ) = ( 1 ) + ( 2 * 3 ) + ( 4 * 5 * 6 ) . . . n using Recursion | Recursive function for finding sum of series calculated - number of terms till which sum of terms has been calculated current - number of terms for which sum has to be calculated N - Number of terms in the function to be calculated ; checking termination condition ; product of terms till current ; recursive call for adding terms next in the series ; input number of terms in the series ; invoking the function to calculate the sum","code":"< ? php function seriesSum ( $ calculated , $ current , $ N ) { $ i ; $ cur = 1 ; if ( $ current == $ N + 1 ) return 0 ; for ( $ i = $ calculated ; $ i < $ calculated + $ current ; $ i ++ ) $ cur *= $ i ; return $ cur + seriesSum ( $ i , $ current + 1 , $ N ) ; } $ N = 5 ; echo ( seriesSum ( 1 , 1 , $ N ) ) ; ? >"}
{"text":"Compute n ! under modulo p | Returns value of n ! % p ; Driver Code","code":"< ? php function modFact ( $ n , $ p ) { if ( $ n >= $ p ) return 0 ; $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result = ( $ result * $ i ) % $ p ; return $ result ; } $ n = 25 ; $ p = 29 ; echo modFact ( $ n , $ p ) ; ? >"}
{"text":"Chinese Remainder Theorem | Set 2 ( Inverse Modulo based Implementation ) | Returns modulo inverse of a with respect to m using extended Euclid Algorithm . Refer below post for details : https : www . geeksforgeeks . org \/ multiplicative - inverse - under - modulo - m \/ ; Apply extended Euclid Algorithm ; q is quotient ; m is remainder now , process same as euclid 's algo ; Make x1 positive ; k is size of num [ ] and rem [ ] . Returns the smallest number x such that : x % num [ 0 ] = rem [ 0 ] , x % num [ 1 ] = rem [ 1 ] , ... ... ... ... ... ... x % num [ k - 2 ] = rem [ k - 1 ] Assumption : Numbers in num [ ] are pairwise coprime ( gcd forevery pair is 1 ) ; Compute product of all numbers ; Initialize result ; Apply above formula ; Driver Code","code":"< ? php function inv ( $ a , $ m ) { $ m0 = $ m ; $ x0 = 0 ; $ x1 = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a \/ $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ x0 ; $ x0 = $ x1 - $ q * $ x0 ; $ x1 = $ t ; } if ( $ x1 < 0 ) $ x1 += $ m0 ; return $ x1 ; } function findMinX ( $ num , $ rem , $ k ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ prod *= $ num [ $ i ] ; $ result = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ pp = ( int ) $ prod \/ $ num [ $ i ] ; $ result += $ rem [ $ i ] * inv ( $ pp , $ num [ $ i ] ) * $ pp ; } return $ result % $ prod ; } $ num = array ( 3 , 4 , 5 ) ; $ rem = array ( 2 , 3 , 1 ) ; $ k = sizeof ( $ num ) ; echo \" x \u2581 is \u2581 \" . findMinX ( $ num , $ rem , $ k ) ; ? >"}
{"text":"Chinese Remainder Theorem | Set 1 ( Introduction ) | k is size of num [ ] and rem [ ] . Returns the smallest number x such that : x % num [ 0 ] = rem [ 0 ] , x % num [ 1 ] = rem [ 1 ] , ... ... ... ... ... ... x % num [ k - 2 ] = rem [ k - 1 ] Assumption : Numbers in num [ ] are pairwise coprime ( gcd forevery pair is 1 ) ; As per the Chinise remainder theorem , this loop will always break . ; Check if remainder of x % num [ j ] is rem [ j ] or not ( for all j from 0 to k - 1 ) ; If all remainders matched , we found x ; Else try next number ; Driver Code","code":"< ? php function findMinX ( $ num , $ rem , $ k ) { while ( true ) { $ j ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ x % $ num [ $ j ] != $ rem [ $ j ] ) break ; if ( $ j == $ k ) return $ x ; $ x ++ ; } return $ x ; } $ num = array ( 3 , 4 , 5 ) ; $ rem = array ( 2 , 3 , 1 ) ; $ k = sizeof ( $ num ) ; echo \" x \u2581 is \u2581 \" , findMinX ( $ num , $ rem , $ k ) ; ? >"}
{"text":"Compute nCr % p | Set 2 ( Lucas Theorem ) | Returns nCr % p . In this Lucas Theorem based program , this function is only called for n < p and r < p . ; The array C is going to store last row of pascal triangle at the end . And last entry of last row is nCr ; Top row of Pascal Triangle ; One by constructs remaining rows of Pascal Triangle from top to bottom ; Fill entries of current row using previous row values ; Lucas Theorem based function that returns nCr % p . This function works like decimal to binary conversion recursive function . First we compute last digits of n and r in base p , then recur for remaining digits ; Base case ; Compute last digits of n and r in base p ; Compute result for last digits computed above , and for remaining digits . Multiply the two results and compute the result of multiplication in modulo p . ; $r \/ $p , $p ) * Last digits of n and r nCrModpDP ( $ni , $ri , $p ) ) % $p ; Remaining digits ; Driver Code","code":"< ? php function nCrModpDP ( $ n , $ r , $ p ) { $ C = array_fill ( 0 , $ n + 1 , false ) ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ r ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = ( $ C [ $ j ] + $ C [ $ j - 1 ] ) % $ p ; } return $ C [ $ r ] ; } function nCrModpLucas ( $ n , $ r , $ p ) { if ( $ r == 0 ) return 1 ; $ ni = $ n % $ p ; $ ri = $ r % $ p ; return ( nCrModpLucas ( $ n \/ $ p , } $ n = 1000 ; $ r = 900 ; $ p = 13 ; echo \" Value \u2581 of \u2581 nCr \u2581 % \u2581 p \u2581 is \u2581 \" , nCrModpLucas ( $ n , $ r , $ p ) ; ? >"}
{"text":"Print all Good numbers in given range | To check whether n is a good number and doesn ' t \u2581 contain \u2581 digit \u2581 ' d '. ; Get last digit and initialize sum from right side ; If last digit is d , return ; Traverse remaining digits ; Current digit ; If digit is d or digit is less than or equal to sum of digits on right side ; Update sum and n ; Print Good numbers in range [ L , R ] ; Traverse all numbers in given range ; If current numbers is good , print it . ; Driver Code ; Print good numbers in [ L , R ]","code":"< ? php function isValid ( $ n , $ d ) { $ digit = $ n % 10 ; $ sum = $ digit ; if ( $ digit == $ d ) return false ; $ n = ( int ) ( $ n \/ 10 ) ; while ( $ n ) { $ digit = $ n % 10 ; if ( $ digit == $ d $ digit <= $ sum ) return false ; else { $ sum += $ digit ; $ n = ( int ) ( $ n \/ 10 ) ; } } return 1 ; } function printGoodNumbers ( $ L , $ R , $ d ) { for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( isValid ( $ i , $ d ) ) echo $ i . \" \" ; } } $ L = 410 ; $ R = 520 ; $ d = 3 ; printGoodNumbers ( $ L , $ R , $ d ) ; ? >"}
{"text":"Zeckendorf 's Theorem (Non | Returns the greatest Fibonacci Number smaller than or equal to n . ; Corner cases ; Find the greatest Fibonacci Number smaller than n . ; Prints Fibonacci Representation of n using greedy algorithm ; Find the greates Fibonacci Number smaller than or equal to n ; Print the found fibonacci number ; Reduce n ; Driver Code","code":"< ? php function nearestSmallerEqFib ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; $ f1 = 0 ; $ f2 = 1 ; $ f3 = 1 ; while ( $ f3 <= $ n ) { $ f1 = $ f2 ; $ f2 = $ f3 ; $ f3 = $ f1 + $ f2 ; } return $ f2 ; } function printFibRepresntation ( $ n ) { while ( $ n > 0 ) { $ f = nearestSmallerEqFib ( $ n ) ; echo $ f , \" \" ; $ n = $ n - $ f ; } } $ n = 30 ; echo \" Non - neighbouring \u2581 Fibonacci \u2581 Representation \u2581 of \u2581 \" , $ n , \" \u2581 is \u2581 STRNEWLINE \" ; printFibRepresntation ( $ n ) ; ? >"}
{"text":"Count number of ways to divide a number in 4 parts | A Dynamic Programming based solution to count number of ways to represent n as sum of four numbers ; \" parts \" is number of parts left , n is the value left \" nextPart \" is starting point from where we start trying for next part . ; Base cases ; If this subproblem is already solved ; Count number of ways for remaining number n - i remaining parts \" parts - 1\" , and for all part varying from ' nextPart ' to ' n ' ; Store computed answer in table and return result ; This function mainly initializes dp table and calls countWaysUtil ( ) ; Driver Code","code":"< ? php $ dp = array_fill ( 0 , 501 , array_fill ( 0 , 501 , array_fill ( 0 , 5 , -1 ) ) ) ; function countWaysUtil ( $ n , $ parts , $ nextPart ) { global $ dp ; if ( $ parts == 0 && $ n == 0 ) return 1 ; if ( $ n <= 0 $ parts <= 0 ) return 0 ; if ( $ dp [ $ n ] [ $ nextPart ] [ $ parts ] != -1 ) return $ dp [ $ n ] [ $ nextPart ] [ $ parts ] ; for ( $ i = $ nextPart ; $ i <= $ n ; $ i ++ ) $ ans += countWaysUtil ( $ n - $ i , $ parts - 1 , $ i ) ; return ( $ dp [ $ n ] [ $ nextPart ] [ $ parts ] = $ ans ) ; } function countWays ( $ n ) { return countWaysUtil ( $ n , 4 , 1 ) ; } $ n = 8 ; echo countWays ( $ n ) ; ? >"}
{"text":"Find the smallest twins in given range | PHP program to find the smallest twin in given range ; Create a boolean array \" prime [ 0 . . high ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Look for the smallest twin ; If p is not marked , then it is a prime ; Update all multiples of p ; Now print the smallest twin in range ; Driver Code","code":"< ? php function printTwins ( $ low , $ high ) { $ prime = array_fill ( 0 , $ high + 1 , true ) ; $ twin = false ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p <= floor ( sqrt ( $ high ) ) + 1 ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ high ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) { if ( $ prime [ $ i ] && $ prime [ $ i + 2 ] ) { print ( \" Smallest \u2581 twins \u2581 in \u2581 given \u2581 range : \u2581 ( $ i , \u2581 \" . ( $ i + 2 ) . \" ) \" ) ; $ twin = true ; break ; } } if ( $ twin == false ) print ( \" No \u2581 such \u2581 pair \u2581 exists STRNEWLINE \" ) ; } printTwins ( 10 , 100 ) ; ? >"}
{"text":"Find Next Sparse Number | PHP program to find next sparse number ; Find binary representation of x and store it in bin [ ] . bin [ 0 ] contains least significant bit ( LSB ) , next bit is in bin [ 1 ] , and so on . ; There my be extra bit in result , so add one extra bit ; The position till which all bits are finalized ; Start from second bit ( next to LSB ) ; If current bit and its previous bit are 1 , but next bit is not 1. ; Make the next bit 1 ; Make all bits before current bit as 0 to make sure that we get the smallest next number ; Store position of the bit set so that this bit and bits before it are not changed next time . ; Find decimal equivalent of modified bin [ ] ; Driver Code","code":"< ? php function nextSparse ( $ x ) { $ bin = array ( ) ; while ( $ x != 0 ) { array_push ( $ bin , $ x & 1 ) ; $ x >>= 1 ; } array_push ( $ bin , 0 ) ; $ last_final = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ bin [ $ i ] == 1 && $ bin [ $ i - 1 ] == 1 && $ bin [ $ i + 1 ] != 1 ) { $ bin [ $ i + 1 ] = 1 ; for ( $ j = $ i ; $ j >= $ last_final ; $ j -- ) $ bin [ $ j ] = 0 ; $ last_final = $ i + 1 ; } } $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans += $ bin [ $ i ] * ( 1 << $ i ) ; return $ ans ; } $ x = 38 ; echo \" Next \u2581 Sparse \u2581 Number \u2581 is \u2581 \" . nextSparse ( $ x ) ; ? >"}
{"text":"Sum of bit differences among all pairs | PHP program to compute sum of pairwise bit differences ; Initialize result ; traverse over all bits ; count number of elements with i 'th bit set ; Add \" count \u2581 * \u2581 ( n \u2581 - \u2581 count ) \u2581 * \u2581 2\" to the answer ; Driver Code","code":"< ? php function sumBitDifferences ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) ) $ count ++ ; $ ans += ( $ count * ( $ n - $ count ) * 2 ) ; } return $ ans ; } $ arr = array ( 1 , 3 , 5 ) ; $ n = sizeof ( $ arr ) ; echo sumBitDifferences ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Print all non | function to print array arr [ 0. . n - 1 ] ; Recursive Function to generate all non - increasing sequences with sum x arr [ ] -- > Elements of current sequence curr_sum -- > Current Sum curr_idx -- > Current index in arr [ ] ; If current sum is equal to x , then we found a sequence ; Try placing all numbers from 1 to x - curr_sum at current index ; The placed number must also be smaller than previously placed numbers and it may be equal to the previous stored value , i . e . , arr [ curr_idx - 1 ] if there exists a previous number ; Place number at curr_idx ; Recur ; Try next number ; A wrapper over generateUtil ( ) ; Array to store sequences on by one ; Driver Code","code":"< ? php function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; echo \" \u2581 STRNEWLINE \" ; } function generateUtil ( $ x , $ arr , $ curr_sum , $ curr_idx ) { if ( $ curr_sum == $ x ) { printArr ( $ arr , $ curr_idx ) ; return ; } $ num = 1 ; while ( $ num <= $ x - $ curr_sum and ( $ curr_idx == 0 or $ num <= $ arr [ $ curr_idx - 1 ] ) ) { $ arr [ $ curr_idx ] = $ num ; generateUtil ( $ x , $ arr , $ curr_sum + $ num , $ curr_idx + 1 ) ; $ num ++ ; } } function generate ( $ x ) { $ arr = array ( ) ; generateUtil ( $ x , $ arr , 0 , 0 ) ; } $ x = 5 ; generate ( $ x ) ; ? >"}
{"text":"Perfect Number | Returns true if n is perfect ; To store sum of divisors ; Find all divisors and add them ; If sum of divisors is equal to n , then n is a perfect number ; Driver Code","code":"< ? php function isPerfect ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i * $ i != $ n ) $ sum = $ sum + $ i + ( int ) ( $ n \/ $ i ) ; else $ sum = $ sum + $ i ; } } if ( $ sum == $ n && $ n != 1 ) return true ; return false ; } echo \" Below \u2581 are \u2581 all \u2581 perfect \u2581 numbers \u2581 till \u2581 10000 STRNEWLINE \" ; for ( $ n = 2 ; $ n < 10000 ; $ n ++ ) if ( isPerfect ( $ n ) ) echo \" $ n \u2581 is \u2581 a \u2581 perfect \u2581 number STRNEWLINE \" ; ? >"}
{"text":"Check if a given number can be represented in given a no . of digits in any base | Returns true if ' num ' can be represented usind ' dig ' digits in ' base ' ; Base case ; If there are more than 1 digits left and number is more than base , then remove last digit by doing num \/ base , reduce the number of digits and recur ; return true of num can be represented in ' dig ' digits in any base from 2 to 32 ; Check for all bases one by one ; Driver Code","code":"< ? php function checkUtil ( $ num , $ dig , $ base ) { if ( $ dig == 1 && $ num < $ base ) return true ; if ( $ dig > 1 && $ num >= $ base ) return checkUtil ( $ num \/ $ base , -- $ dig , $ base ) ; return false ; } function check ( $ num , $ dig ) { for ( $ base = 2 ; $ base <= 32 ; $ base ++ ) if ( checkUtil ( $ num , $ dig , $ base ) ) return true ; return false ; } $ num = 8 ; $ dig = 3 ; if ( check ( $ num , $ dig ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"How to compute mod of a big number ? | Function to compute num ( mod a ) ; Initialize result ; One by one process all digits of ' num ' ; Driver Code","code":"< ? php function mod ( $ num , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ r = strlen ( $ num ) ; $ i ++ ) $ res = ( $ res * 10 + $ num [ $ i ] - '0' ) % $ a ; return $ res ; } $ num = \"12316767678678\" ; echo mod ( $ num , 10 ) ; ? >"}
{"text":"Modular multiplicative inverse | A naive method to find modulor multiplicative inverse of ' a ' under modulo ' m ' ; Driver Code ; Function call","code":"< ? php function modInverse ( $ a , $ m ) { for ( $ x = 1 ; $ x < $ m ; $ x ++ ) if ( ( ( $ a % $ m ) * ( $ x % $ m ) ) % $ m == 1 ) return $ x ; } $ a = 3 ; $ m = 11 ; echo modInverse ( $ a , $ m ) ; a . . . >"}
{"text":"Modular multiplicative inverse | Returns modulo inverse of a with respect to m using extended Euclid Algorithm Assumption : a and m are coprimes , i . e . , gcd ( a , m ) = 1 ; q is quotient ; m is remainder now , process same as Euclid 's algo ; Update y and x ; Make x positive ; Driver Code ; Function call","code":"< ? php function modInverse ( $ a , $ m ) { $ m0 = $ m ; $ y = 0 ; $ x = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a \/ $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ y ; $ y = $ x - $ q * $ y ; $ x = $ t ; } if ( $ x < 0 ) $ x += $ m0 ; return $ x ; } $ a = 3 ; $ m = 11 ; echo \" Modular \u2581 multiplicative \u2581 inverse \u2581 is STRNEWLINE \" , modInverse ( $ a , $ m ) ; a . . . >"}
{"text":"Euler 's Totient Function | Function to return gcd of a and b ; A simple method to evaluate Euler Totient Function ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function phi ( $ n ) { $ result = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( gcd ( $ i , $ n ) == 1 ) $ result ++ ; return $ result ; } for ( $ n = 1 ; $ n <= 10 ; $ n ++ ) echo \" phi ( \" . $ n . \" ) \u2581 = \" . phi ( $ n ) . \" STRNEWLINE \" ; I >"}
{"text":"Euler 's Totient Function | PHP program to calculate Euler ' s \u2581 Totient \u2581 Function \u2581 using \u2581 Euler ' s product formula ; Initialize result as n ; Consider all prime factors of n and for every prime factor p , multiply result with ( 1 - 1 \/ p ) ; Check if p is a prime factor . ; If yes , then update n and result ; If n has a prime factor greater than sqrt ( n ) ( There can be at - most one such prime factor ) ; Driver Code","code":"< ? php function phi ( $ n ) { $ result = $ n ; for ( $ p = 2 ; $ p * $ p <= $ n ; ++ $ p ) { if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) $ n \/= $ p ; $ result *= ( 1.0 - ( 1.0 \/ $ p ) ) ; } } if ( $ n > 1 ) $ result *= ( 1.0 - ( 1.0 \/ $ n ) ) ; return intval ( $ result ) ; } for ( $ n = 1 ; $ n <= 10 ; $ n ++ ) echo \" phi ( \" . $ n . \" ) \u2581 = \" . phi ( $ n ) . \" STRNEWLINE \" ; I >"}
{"text":"Efficient Program to Compute Sum of Series 1 \/ 1 ! + 1 \/ 2 ! + 1 \/ 3 ! + 1 \/ 4 ! + . . + 1 \/ n ! | Utility function to find ; A Simple Function to return value of 1 \/ 1 ! + 1 \/ 2 ! + . . + 1 \/ n ! ; Driver Code","code":"< ? php function factorial ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res *= $ i ; return $ res ; } function sum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 1.0 \/ factorial ( $ i ) ; return $ sum ; } $ n = 5 ; echo ( sum ( $ n ) ) ; ? >"}
{"text":"Find the number of valid parentheses expressions of given length | Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn \/ ( n + 1 ) ; Function to find possible ways to put balanced parenthesis in an expression of length n ; If n is odd , not possible to create any valid parentheses ; Otherwise return n \/ 2 'th  Catalan Number ; Driver Code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res ; } function catalan ( $ n ) { $ c = binomialCoeff ( 2 * $ n , $ n ) ; return $ c \/ ( $ n + 1 ) ; } function findWays ( $ n ) { if ( $ n & 1 ) return 0 ; return catalan ( $ n \/ 2 ) ; } $ n = 6 ; echo \" Total \u2581 possible \u2581 expressions \u2581 of \u2581 length \u2581 \" , $ n , \" \u2581 is \u2581 \" , findWays ( 6 ) ; ? >"}
{"text":"Program to evaluate simple expressions | A utility function to check if a given character is operand ; utility function to find value of and operand ; This function evaluates simple expressions . It returns - 1 if the given expression is invalid . ; Base Case : Given expression is empty ; The first character must be an operand , find its value ; Traverse the remaining characters in pairs ; The next character must be an operator , and next to next an operand ; If next to next character is not an operand ; Update result according to the operator ; If not a valid operator ; Driver Code","code":"< ? php function isOperand ( $ c ) { return ( $ c >= '0' && $ c <= '9' ) ; } function value ( $ c ) { return ( $ c - '0' ) ; } function evaluate ( $ exp ) { $ len = strlen ( $ exp ) ; if ( $ len == 0 ) return -1 ; $ res = ( int ) ( value ( $ exp [ 0 ] ) ) ; for ( $ i = 1 ; $ i < $ len ; $ i += 2 ) { $ opr = $ exp [ $ i ] ; $ opd = $ exp [ $ i + 1 ] ; if ( ! isOperand ( $ opd ) ) return -1 ; if ( $ opr == ' + ' ) $ res += value ( $ opd ) ; else if ( $ opr == ' - ' ) $ res -= ( int ) ( value ( $ opd ) ) ; else if ( $ opr == ' * ' ) $ res *= ( int ) ( value ( $ opd ) ) ; else if ( $ opr == ' \/ ' ) $ res \/= ( int ) ( value ( $ opd ) ) ; else return -1 ; } return $ res ; } $ expr1 = \"1 + 2*5 + 3\" ; $ res = evaluate ( $ expr1 ) ; ( $ res == -1 ) ? print ( $ expr1 . \" \u2581 is \u2581 Invalid STRNEWLINE \" ) : print ( \" Value \u2581 of \u2581 \" . $ expr1 . \" \u2581 is \u2581 \" . $ res . \" STRNEWLINE \" ) ; $ expr2 = \"1 + 2*3\" ; $ res = evaluate ( $ expr2 ) ; ( $ res == -1 ) ? print ( $ expr2 . \" \u2581 is \u2581 Invalid STRNEWLINE \" ) : print ( \" Value \u2581 of \u2581 \" . $ expr2 . \" \u2581 is \u2581 \" . $ res . \" STRNEWLINE \" ) ; $ expr3 = \"4-2 + 6*3\" ; $ res = evaluate ( $ expr3 ) ; ( $ res == -1 ) ? print ( $ expr3 . \" \u2581 is \u2581 Invalid STRNEWLINE \" ) : print ( \" Value \u2581 of \u2581 \" . $ expr3 . \" \u2581 is \u2581 \" . $ res . \" STRNEWLINE \" ) ; $ expr4 = \"1 + + 2\" ; $ res = evaluate ( $ expr4 ) ; ( $ res == -1 ) ? print ( $ expr4 . \" \u2581 is \u2581 Invalid STRNEWLINE \" ) : print ( \" Value \u2581 of \u2581 \" . $ expr4 . \" \u2581 is \u2581 \" . $ res . \" STRNEWLINE \" ) ; ? >"}
{"text":"Program to print first n Fibonacci Numbers | Set 1 | Function to print first n Fibonacci Numbers ; Driver Code","code":"< ? php function printFibonacciNumbers ( $ n ) { $ f1 = 0 ; $ f2 = 1 ; $ i ; if ( $ n < 1 ) return ; echo ( $ f1 ) ; echo ( \" \u2581 \" ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { echo ( $ f2 ) ; echo ( \" \u2581 \" ) ; $ next = $ f1 + $ f2 ; $ f1 = $ f2 ; $ f2 = $ next ; } } printFibonacciNumbers ( 7 ) ; ? >"}
{"text":"Program to find LCM of two numbers | Recursive function to return gcd of a and b ; Function to return LCM of two numbers ; Driver Code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function lcm ( $ a , $ b ) { return ( $ a \/ gcd ( $ a , $ b ) ) * $ b ; } $ a = 15 ; $ b = 20 ; echo \" LCM \u2581 of \u2581 \" , $ a , \" \u2581 and \u2581 \" , $ b , \" \u2581 is \u2581 \" , lcm ( $ a , $ b ) ; ? >"}
{"text":"Program to convert a given number to words | A function that prints given number in words ; Get number of digits in given number ; Base cases ; The first string is not used , it is to make array indexing simple ; The first string is not used , it is to make array indexing simple ; The first two string are not used , they are to make array indexing simple ; Used for debugging purpose only ; For single digit number ; Iterate while num is not ' \\0' ; Code path for first 2 digits ; here len can be 3 or 4 ; Code path for last 2 digits ; Need to explicitly handle 10 - 19. Sum of the two digits is used as index of \" two _ digits \" array of strings ; Need to explicitely handle 20 ; Rest of the two digit numbers i . e . , 21 to 99 ; Driver Code","code":"< ? php function convert_to_words ( $ num ) { $ len = strlen ( $ num ) ; if ( $ len == 0 ) { echo \" empty \u2581 string STRNEWLINE \" ; return ; } if ( $ len > 4 ) { echo \" Length \u2581 more \u2581 than \u2581 4 \u2581 \" . \" is \u2581 not \u2581 supported STRNEWLINE \" ; return ; } $ single_digits = array ( \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" ) ; $ two_digits = array ( \" \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" ) ; $ tens_multiple = array ( \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" ) ; $ tens_power = array ( \" hundred \" , \" thousand \" ) ; echo $ num . \" : \u2581 \" ; if ( $ len == 1 ) { echo $ single_digits [ $ num [ 0 ] - '0' ] . \" \u2581 STRNEWLINE \" ; return ; } $ x = 0 ; while ( $ x < strlen ( $ num ) ) { if ( $ len >= 3 ) { if ( $ num [ $ x ] - '0' != 0 ) { echo $ single_digits [ $ num [ $ x ] - '0' ] . \" \" ; echo $ tens_power [ $ len - 3 ] . \" \" ; } -- $ len ; } else { if ( $ num [ $ x ] - '0' == 1 ) { $ sum = $ num [ $ x ] - '0' + $ num [ $ x ] - '0' ; echo $ two_digits [ $ sum ] . \" \u2581 STRNEWLINE \" ; return ; } else if ( $ num [ $ x ] - '0' == 2 && $ num [ $ x + 1 ] - '0' == 0 ) { echo \" twenty STRNEWLINE \" ; return ; } else { $ i = $ num [ $ x ] - '0' ; if ( $ i > 0 ) echo $ tens_multiple [ $ i ] . \" \u2581 \" ; else echo \" \" ; ++ $ x ; if ( $ num [ $ x ] - '0' != 0 ) echo $ single_digits [ $ num [ $ x ] - '0' ] . \" \u2581 STRNEWLINE \" ; } } ++ $ x ; } } convert_to_words ( \"9923\" ) ; convert_to_words ( \"523\" ) ; convert_to_words ( \"89\" ) ; convert_to_words ( \"8\" ) ; ? >"}
{"text":"Check if a number is multiple of 5 without using \/ and % operators | Assuming that integre takes 4 bytes , there can be maximum 10 digits in a integer ; Check the last character of string ; Driver Code","code":"< ? php $ MAX = 11 ; function isMultipleof5 ( $ n ) { global $ MAX ; $ str = ( string ) $ n ; $ len = strlen ( $ str ) ; if ( $ str [ $ len - 1 ] == '5' $ str [ $ len - 1 ] == '0' ) return true ; return false ; } $ n = 19 ; if ( isMultipleof5 ( $ n ) == true ) echo \" $ n \u2581 is \u2581 multiple \u2581 of \u2581 5\" ; else echo \" $ n \u2581 is \u2581 not \u2581 a \u2581 multiple \u2581 of \u2581 5\" ; ? >"}
{"text":"Sum of Bitwise OR of all pairs in a given array | Returns value of \" arr [ 0 ] \u2581 | \u2581 arr [ 1 ] \u2581 + \u2581 arr [ 0 ] \u2581 | \u2581 arr [ 2 ] \u2581 + \u2581 . . . \u2581 arr [ i ] \u2581 | \u2581 arr [ j ] \u2581 + \u2581 . . . . . \u2581 arr [ n - 2 ] \u2581 | \u2581 arr [ n - 1 ] \" ; Initialize result ; Consider all pairs ( arr [ i ] , arr [ j ) such that i < j ; Driver Code","code":"< ? php function pairORSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] | $ arr [ $ j ] ; return $ ans ; } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo pairORSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Multiply a number by 15 without using * and \/ operators | Function to return ( 15 * N ) without using ' * ' or ' \/ ' operator ; prod = 16 * n ; ( ( 16 * n ) - n ) = 15 * n ; Driver code","code":"< ? php function multiplyByFifteen ( $ n ) { $ prod = ( $ n << 4 ) ; $ prod = $ prod - $ n ; return $ prod ; } $ n = 7 ; echo multiplyByFifteen ( $ n ) ; ? >"}
{"text":"Minimum value among AND of elements of every subset of an array | PHP program for the above approach ; Find AND of whole array ; Print the answer ; Driver code","code":"< ? php function minAND ( $ arr , $ n ) { $ s = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ s = $ s & $ arr [ $ i ] ; } print ( $ s . \" \" ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = count ( $ arr ) ; minAND ( $ arr , $ n ) ; ? >"}
{"text":"Modify a binary array to Bitwise AND of all elements as 1 | Function to check if it is possible or not ; Driver code","code":"< ? php function check ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] ) return true ; return false ; } $ a = array ( 0 , 1 , 0 , 1 ) ; $ n = sizeof ( $ a ) ; if ( check ( $ a , $ n ) ) echo \" YES STRNEWLINE \" ; else echo \" NO STRNEWLINE \" ; ? >"}
{"text":"Find array using different XORs of elements in groups of size 4 | Utility function to print the contents of the array ; Function to find the required array ; Print the array ; Driver code","code":"< ? php function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; } function findArray ( $ q , $ n ) { $ ans ; $ arr = array ( $ n ) ; for ( $ k = 0 , $ j = 0 ; $ j < $ n \/ 4 ; $ j ++ ) { $ ans = $ q [ $ k ] ^ $ q [ $ k + 3 ] ; $ arr [ $ k + 1 ] = $ q [ $ k + 1 ] ^ $ ans ; $ arr [ $ k + 2 ] = $ q [ $ k + 2 ] ^ $ ans ; $ arr [ $ k ] = $ q [ $ k ] ^ ( ( $ arr [ $ k + 1 ] ) ^ ( $ arr [ $ k + 2 ] ) ) ; $ arr [ $ k + 3 ] = $ q [ $ k + 3 ] ^ ( $ arr [ $ k + 1 ] ^ $ arr [ $ k + 2 ] ) ; $ k += 4 ; } printArray ( $ arr , $ n ) ; } { $ q = array ( 4 , 1 , 7 , 0 ) ; $ n = sizeof ( $ q ) ; findArray ( $ q , $ n ) ; }"}
{"text":"Check if the binary representation of a number has equal number of 0 s and 1 s in blocks | function to convert decimal to binary ; Count same bits in last block ; If n is 0 or it has all 1 s , then it is not considered to have equal number of 0 s and 1 s in blocks . ; Count same bits in all remaining blocks . ; Driver Code","code":"< ? php function isEqualBlock ( $ n ) { $ first_bit = $ n % 2 ; $ first_count = 1 ; $ n = ( int ) ( $ n \/ 2 ) ; while ( $ n % 2 == $ first_bit && $ n > 0 ) { $ n = ( int ) ( $ n \/ 2 ) ; $ first_count ++ ; } if ( $ n == 0 ) return false ; while ( $ n > 0 ) { $ first_bit = $ n % 2 ; $ curr_count = 1 ; $ n = ( int ) ( $ n \/ 2 ) ; while ( $ n % 2 == $ first_bit ) { $ n = ( int ) ( $ n \/ 2 ) ; $ curr_count ++ ; } if ( $ curr_count != $ first_count ) return false ; } return true ; } $ n = 51 ; if ( isEqualBlock ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"First and Last Three Bits | Function to print the first and last 3 bits equivalent decimal number ; Number formed from last three bits ; Let us get first three bits in n ; Number formed from first three bits ; Printing result ; Driver code","code":"< ? php function binToDecimal3 ( $ n ) { $ last_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; $ n = $ n >> 3 ; while ( $ n > 7 ) $ n = $ n >> 1 ; $ first_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; echo ( $ first_3 ) ; echo ( \" \u2581 \" ) ; echo ( $ last_3 ) ; } $ n = 86 ; binToDecimal3 ( $ n ) ; ? >"}
{"text":"Count of numbers which can be made power of 2 by given operation | Function that returns true if x is a power of 2 ; If x & ( x - 1 ) = 0 then x is a power of 2 ; Function to return the required count ; If a [ i ] or ( a [ i ] + 1 ) is a power of 2 ; Driver Code","code":"< ? php function isPowerOfTwo ( $ x ) { if ( $ x == 0 ) return false ; if ( ! ( $ x & ( $ x - 1 ) ) ) return true ; else return false ; } function countNum ( $ a , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( isPowerOfTwo ( $ a [ $ i ] ) || isPowerOfTwo ( $ a [ $ i ] + 1 ) ) $ cnt ++ ; } return $ cnt ; } $ arr = array ( 5 , 6 , 9 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo countNum ( $ arr , $ n ) ; ? >"}
{"text":"Sum of elements from an array having even parity | Function that returns true if x has even parity ; We basically count set bits https : www . geeksforgeeks . org \/ count - set - bits - in - an - integer \/ ; Function to return the sum of the elements from an array which have even parity ; If a [ i ] has even parity ; Driver code","code":"< ? php function checkEvenParity ( $ x ) { $ parity = 0 ; while ( $ x != 0 ) { $ x = ( $ x & ( $ x - 1 ) ) ; $ parity ++ ; } if ( $ parity % 2 == 0 ) return true ; else return false ; } function sumlist ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( checkEvenParity ( $ a [ $ i ] ) ) $ sum += $ a [ $ i ] ; } return $ sum ; } $ arr = array ( 2 , 4 , 3 , 5 , 9 ) ; $ n = sizeof ( $ arr ) ; echo sumlist ( $ arr , $ n ) ; ? >"}
{"text":"Number of pairs with Bitwise OR as Odd number | Function to count pairs with odd OR ; find OR operation check odd or odd ; return count of odd pair ; Driver Code","code":"< ? php function findOddPair ( $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] $ A [ $ j ] ) % 2 != 0 ) $ oddPair ++ ; } } return $ oddPair ; } $ A = array ( 5 , 6 , 2 , 8 ) ; $ N = sizeof ( $ A ) \/ sizeof ( $ A [ 0 ] ) ; echo findOddPair ( $ A , $ N ) , \" STRNEWLINE \" ; #This  code is contributed by ajit NEW_LINE ? >"}
{"text":"Count pairs with Bitwise XOR as EVEN number | Function to count number of even pairs ; variable for counting even pairs ; find all pairs ; find XOR operation check even or even ; return number of even pair ; Driver Code ; calling function findevenPair and print number of even pair","code":"< ? php function findevenPair ( & $ A , $ N ) { $ evenPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] ^ $ A [ $ j ] ) % 2 == 0 ) $ evenPair ++ ; } } return $ evenPair ; } $ A = array ( 5 , 4 , 7 , 2 , 1 ) ; $ N = sizeof ( $ A ) ; echo ( findevenPair ( $ A , $ N ) ) ; ? >"}
{"text":"Count pairs with Bitwise XOR as EVEN number | Function to count number of even pairs ; find all pairs ; return number of even pair ; Driver Code ; calling function findEvenPair and print number of even pair","code":"< ? php function findEvenPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 != 0 ) $ count ++ ; } $ totalPairs = ( $ N * ( $ N - 1 ) \/ 2 ) ; $ oddEvenPairs = $ count * ( $ N - $ count ) ; return $ totalPairs - $ oddEvenPairs ; } $ a = array ( 5 , 4 , 7 , 2 , 1 ) ; $ n = sizeof ( $ a ) ; echo findEvenPair ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Count pairs with Bitwise | Function to count number of pairs EVEN bitwise AND ; variable for counting even pairs ; find all pairs ; find AND operation to check evenpair ; return number of even pair ; Driver Code","code":"< ? php function findevenPair ( $ A , $ N ) { $ evenPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 == 0 ) $ evenPair ++ ; } } return $ evenPair ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo findevenPair ( $ a , $ n ) ; ? >"}
{"text":"Count pairs with Bitwise | Function to count number of pairs with EVEN bitwise AND ; count odd numbers ; count odd pairs ; return number of even pair ; Driver Code","code":"< ? php function findevenPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] % 2 != 0 ) $ count ++ ; $ oddCount = $ count * ( $ count - 1 ) \/ 2 ; return ( $ N * ( $ N - 1 ) \/ 2 ) - $ oddCount ; } $ a = array ( 5 , 1 , 3 , 2 ) ; $ n = sizeof ( $ a ) ; echo findevenPair ( $ a , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find a value whose XOR with given number is maximum | Function To Calculate Answer ; Find number of bits in the given integer ; XOR the given integer with poe ( 2 , number_of_bits - 1 and print the result ; Driver Code","code":"< ? php function calculate ( $ X ) { $ number_of_bits = 8 ; return ( ( 1 << $ number_of_bits ) - 1 ) ^ $ X ; } $ X = 4 ; echo \" Required \u2581 Number \u2581 is \u2581 : \u2581 \" . calculate ( $ X ) . \" STRNEWLINE \" ; ? >"}
{"text":"Replace every element of the array with BitWise XOR of all other | Function to replace the elements ; Calculate the xor of all the elements ; Replace every element by the xor of all other elements ; Driver code ; Print the modified array .","code":"< ? php function ReplaceElements ( $ arr , $ n ) { $ X = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ X ^= $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ arr [ $ i ] = $ X ^ $ arr [ $ i ] ; } return $ arr ; } $ arr = array ( 2 , 3 , 3 , 5 , 5 ) ; $ n = sizeof ( $ arr ) ; $ arr1 = ReplaceElements ( $ arr , $ n ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { echo ( $ arr1 [ $ i ] . \" \" ) ; } ? >"}
{"text":"Assign other value to a variable from two possible values | Function to alternate the values ; Driver Code","code":"< ? php function alternate ( & $ a , & $ b , & $ x ) { $ x = $ a ^ $ b ^ $ x ; } $ a = -10 ; $ b = 15 ; $ x = $ a ; echo \" x \u2581 is \u2581 : \u2581 \" , $ x ; alternate ( $ a , $ b , $ x ) ; echo \" After exchange \" ; echo \" x is : \" ? >"}
{"text":"Number of leading zeros in binary representation of a given number | Function to count the no . of leading zeros ; Driver Code","code":"< ? php function countZeros ( $ x ) { $ y ; $ n = 32 ; $ y = $ x >> 16 ; if ( $ y != 0 ) { $ n = $ n - 16 ; $ x = $ y ; } $ y = $ x >> 8 ; if ( $ y != 0 ) { $ n = $ n - 8 ; $ x = $ y ; } $ y = $ x >> 4 ; if ( $ y != 0 ) { $ n = $ n - 4 ; $ x = $ y ; } $ y = $ x >> 2 ; if ( $ y != 0 ) { $ n = $ n - 2 ; $ x = $ y ; } $ y = $ x >> 1 ; if ( $ y != 0 ) return $ n - 2 ; return $ n - $ x ; } $ x = 101 ; echo countZeros ( $ x ) ;"}
{"text":"Comparing leading zeros in binary representations of two numbers | Function to compare the no . of leading zeros ; if both have same no . of leading zeros ; if y has more leading zeros ; Driver Code","code":"< ? php function LeadingZeros ( $ x , $ y ) { if ( ( $ x ^ $ y ) <= ( $ x & $ y ) ) echo \" Equal \" else if ( ( $ x & ( ~ $ y ) ) > $ y ) echo $ y ; else echo $ x ; } $ x = 10 ; $ y = 16 ; LeadingZeros ( $ x , $ y ) ; ? >"}
{"text":"Number of mismatching bits in the binary representation of two integers | compute number of different bits ; since , the numbers are less than 2 ^ 31 run the loop from '0' to '31' only ; right shift both the numbers by ' i ' and check if the bit at the 0 th position is different ; Driver code ; find number of different bits","code":"< ? php function solve ( $ A , $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { if ( ( ( $ A >> $ i ) & 1 ) != ( ( $ B >> $ i ) & 1 ) ) { $ count ++ ; } } echo \" Number \u2581 of \u2581 different \u2581 bits \u2581 : \u2581 $ count \" ; } $ A = 12 ; $ B = 15 ; solve ( $ A , $ B ) ; ? >"}
{"text":"Set the rightmost off bit | PHP program to set the rightmost unset bit ; If all bits are set ; Set rightmost 0 bit ; Driver Code","code":"< ? php function setRightmostUnsetBit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; return $ n | ( $ n + 1 ) ; } $ n = 21 ; echo setRightmostUnsetBit ( $ n ) ; ? >"}
{"text":"Find bitwise AND ( & ) of all possible sub | function to return AND of sub - arrays ; Driver Code ; size of the array ; print and of all subarrays","code":"< ? php function ANDS ( & $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans &= $ a [ $ i ] ; return $ ans ; } $ a = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ a ) ; echo ANDS ( $ a , $ n ) ; ? >"}
{"text":"2 's complement for a givin string using XOR | PHP program to find 2 's complement using XOR. ; A flag used to find if a 1 bit is seen or not . ; xor operator is used to flip the ; bits after converting in to ASCII values ; if there is no 1 in the string so just add 1 in starting of string and return ; Driver code","code":"< ? php function TwoscomplementbyXOR ( $ str ) { $ n = strlen ( $ str ) ; $ check_bit = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == '0' && $ check_bit == 0 ) { continue ; } else { if ( $ check_bit == 1 ) $ str [ $ i ] = ( $ str [ $ i ] - '0' ) ^ 1 + '0' ; $ check_bit = 1 ; } } if ( $ check_bit == 0 ) return \"1\" + $ str ; else return $ str ; } $ str = \"101\" ; echo TwoscomplementbyXOR ( $ str ) ; ? >"}
{"text":"Check whether bits are in alternate pattern in the given range | function to check whether bits are in alternate pattern in the given range ; right shift n by ( l - 1 ) bits ; get the bit at the last position in ' num ' ; right shift ' num ' by 1 ; loop until there are bits in the given range ; get the bit at the last position in ' num ' ; if true , then bits are not in alternate pattern ; update ' prev ' ; right shift ' num ' by 1 ; bits are in alternate pattern in the given range ; Driver Code","code":"< ? php function bitsAreInAltPatrnInGivenTRange ( $ n , $ l , $ r ) { $ num = $ n >> ( $ l - 1 ) ; $ prev = $ num & 1 ; $ num = $ num >> 1 ; for ( $ i = 1 ; $ i <= ( $ r - $ l ) ; $ i ++ ) { $ curr = $ num & 1 ; if ( $ curr == $ prev ) return false ; $ prev = $ curr ; $ num = $ num >> 1 ; } return true ; } $ n = 18 ; $ l = 1 ; $ r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( $ n , $ l , $ r ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Increment a number without using ++ or + | function that increment the value . ; Invert bits and apply negative sign ; Driver code","code":"< ? php function increment ( $ i ) { $ i = - ( ~ $ i ) ; return $ i ; } $ n = 3 ; echo increment ( $ n ) ; ? >"}
{"text":"Maximum sum by adding numbers with same number of set bits | count the number of bits for each element of array ; Count the number of set bits ; Function to return the the maximum sum ; Calculate the ; Assuming the number to be a maximum of 32 bits ; Add the number to the number of set bits ; Find the maximum sum ; Driver code","code":"< ? php function bit_count ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n = $ n & ( $ n - 1 ) ; } return $ count ; } function maxsum ( $ arr , $ n ) { $ bits = array ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ bits [ $ i ] = bit_count ( $ arr [ $ i ] ) ; } $ sum = array_fill ( 0 , 32 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum [ $ bits [ $ i ] ] += $ arr [ $ i ] ; } $ maximum = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ maximum = max ( $ sum [ $ i ] , $ maximum ) ; } return $ maximum ; } $ arr = array ( 2 , 3 , 8 , 5 , 6 , 7 ) ; $ n = sizeof ( $ arr ) ; echo maxsum ( $ arr , $ n ) ; ? >"}
{"text":"Sum of XOR of sum of all pairs in an array | PHP program to find XOR of pair sums . ; Driver Code","code":"< ? php function xor_pair_sum ( $ ar , $ n ) { $ total = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ total = $ total ^ $ ar [ $ i ] ; return ( 2 * $ total ) ; } $ data = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ data ) ; echo xor_pair_sum ( $ data , $ n ) ; ? >"}
{"text":"Count pairs with Bitwise OR as Even number | PHP program to count pairs with even OR ; Count total even numbers in array . ; return count of even pair ; Driver Code","code":"< ? php function findEvenPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) \/ 2 ; } $ A = array ( 5 , 6 , 2 , 8 ) ; $ N = sizeof ( $ A ) ; echo findEvenPair ( $ A , $ N ) . \" STRNEWLINE \" ; ? >"}
{"text":"Check whether all the bits are unset in the given range | function to check whether all the bits are unset in the given range or not ; calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; new number which could only have one or more set bits in the range l to r and nowhere else ; if true , then all bits are unset in the given range ; else all bits are not unset in the given range ; Driver Code","code":"< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return true ; return false ; } $ n = 17 ; $ l = 2 ; $ r = 4 ; if ( allBitsSetInTheGivenRange ( $ n , $ l , $ r ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if a number has same number of set and unset bits | Function to check if a number has same setbits and unset bits ; iterate for all bits of a number ; if set ; if unset ; right shift number by 1 ; is number of set bits are equal to unset bits ; Driver Code ; function to check","code":"< ? php function checkSame ( $ n ) { $ set = 0 ; $ unset = 0 ; while ( $ n ) { if ( $ n & 1 ) $ set ++ ; else $ unset ++ ; $ n = $ n >> 1 ; } if ( $ set == $ unset ) return true ; else return false ; } $ n = 12 ; if ( checkSame ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find i\u00e2 \u20ac\u2122 th index character in a binary string obtained after n iterations | Set 2 | Function to find the i - th character ; distance between two consecutive elements after N iterations ; binary representation of M ; kth digit will be derived from root for sure ; Check whether there is need to flip root or not ; Driver Code","code":"< ? php function KthCharacter ( $ m , $ n , $ k ) { $ distance = pow ( 2 , $ n ) ; $ Block_number = intval ( $ k \/ $ distance ) ; $ remaining = $ k % $ distance ; $ s = array ( 32 ) ; $ x = 0 ; for ( ; $ m > 0 ; $ x ++ ) { $ s [ $ x ] = $ m % 2 ; $ m = intval ( $ m \/ 2 ) ; } $ root = $ s [ $ x - 1 - $ Block_number ] ; if ( $ remaining == 0 ) { echo $ root . \" STRNEWLINE \" ; return ; } $ flip = true ; while ( $ remaining > 1 ) { if ( $ remaining & 1 ) { $ flip = ! $ flip ; } $ remaining = $ remaining >> 1 ; } if ( $ flip ) { echo ! $ root . \" STRNEWLINE \" ; } else { echo $ root . \" STRNEWLINE \" ; } } $ m = 5 ; $ k = 5 ; $ n = 3 ; KthCharacter ( $ m , $ n , $ k ) ; ? >"}
{"text":"Check whether the number has only first and last bits set | Set 2 | function to check whether the number has only first and last bits set ; Driver Code","code":"< ? php function onlyFirstAndLastAreSet ( $ n ) { if ( $ n == 1 ) return true ; if ( $ n == 2 ) return false ; return ( ( ( $ n - 1 ) & ( $ n - 2 ) ) == 0 ) ; } $ n = 9 ; if ( onlyFirstAndLastAreSet ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Number with set bits only between L | Function to return the integer with all the bits set in range L - R ; iterate from L to R and add all powers of 2 ; Driver Code","code":"< ? php function getInteger ( $ L , $ R ) { $ number = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) $ number += pow ( 2 , $ i ) ; return $ number ; } $ L = 2 ; $ R = 5 ; echo getInteger ( $ L , $ R ) ; ? >"}
{"text":"Number with set bits only between L | Function to return the integer with all the bits set in range L - R ; Driver Code","code":"< ? php function setbitsfromLtoR ( $ L , $ R ) { return ( 1 << ( $ R + 1 ) ) - ( 1 << $ L ) ; } $ L = 2 ; $ R = 5 ; echo setbitsfromLtoR ( $ L , $ R ) ; ? >"}
{"text":"XOR of Sum of every possible pair of an array | Function to find XOR of sum of all pairs ; Calculate xor of all the elements ; Return twice of xor value ; Driver code","code":"< ? php function findXor ( $ arr , $ n ) { $ xoR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ xoR = $ xoR ^ $ arr [ $ i ] ; } return $ xoR * 2 ; } $ arr = array ( 1 , 5 , 6 ) ; $ n = count ( $ arr ) ; echo findXor ( $ arr , $ n ) ; ? >"}
{"text":"Two odd occurring elements in an array where all other occur even times | PHP code to find two odd occurring elements in an array where all other elements appear even number of times . ; Find XOR of all numbers ; Find a set bit in the XOR ( We find rightmost set bit here ) ; Traverse through all numbers and divide them in two groups ( i ) Having set bit set at same position as the only set bit in set_bit ( ii ) Having 0 bit at same position as the only set bit in set_bit ; XOR of two different sets are our required numbers . ; Driver code","code":"< ? php function printOdds ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res ^ $ arr [ $ i ] ; $ set_bit = $ res & ( ~ ( $ res - 1 ) ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo ( $ x . \" \u2581 \" . $ y ) ; } $ arr = array ( 2 , 3 , 3 , 4 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; printOdds ( $ arr , $ n ) ; ? >"}
{"text":"Maximum subset with bitwise OR equal to k | function to find the maximum subset with bitwise OR equal to k ; If the bitwise OR of k and element is equal to k , then include that element in the subset ; Store the bitwise OR of elements in v ; If ans is not equal to k , subset doesn 't exist ; Driver Code","code":"< ? php function subsetBitwiseORk ( $ arr , $ n , $ k ) { $ v = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ arr [ $ i ] $ k ) == $ k ) array_push ( $ v , $ arr [ $ i ] ) ; } $ ans = 0 ; for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) $ ans |= $ v [ $ i ] ; if ( $ ans != $ k ) { echo ( \" Subset \u2581 does \u2581 not \u2581 exist STRNEWLINE \" ) ; return ; } for ( $ i = 0 ; $ i < count ( $ v ) ; $ i ++ ) echo ( $ v [ $ i ] . \" \u2581 \" ) ; } $ k = 3 ; $ arr = array ( 1 , 4 , 2 ) ; $ n = count ( $ arr ) ; subsetBitwiseORk ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Number whose XOR sum with given array is a given number k | This function returns the number to be inserted in the given array ; initialise the answer with k ; XOR of all elements in the array ; Driver Code","code":"< ? php function findEletobeInserted ( $ A , $ n , $ k ) { $ ans = $ k ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans ^= $ A [ $ i ] ; return $ ans ; } $ A = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = count ( $ A ) ; $ k = 10 ; echo findEletobeInserted ( $ A , $ n , $ k ) ; echo \" \u2581 has \u2581 to \u2581 be \u2581 inserted \" ; echo \" \u2581 in \u2581 the \u2581 given \u2581 array \u2581 to \u2581 make \u2581 xor \u2581 sum \u2581 of \u2581 \" ; echo $ k , \" STRNEWLINE \" ; ? >"}
{"text":"Sum of bitwise AND of all possible subsets of given set | PHP program to calculate sum of Bit - wise and sum of all subsets of an array ; assuming representation of each element is in 32 bit ; iterating array element ; Counting the set bit of array in ith position ; counting subset which produce sum when particular bit position is set . ; multiplying every position subset with 2 ^ i to count the sum . ; Driver code","code":"< ? php $ BITS = 32 ; function andSum ( $ arr , $ n ) { global $ BITS ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ BITS ; $ i ++ ) { $ countSetBits = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & ( 1 << $ i ) ) $ countSetBits ++ ; } $ subset = ( 1 << $ countSetBits ) - 1 ; $ subset = ( $ subset * ( 1 << $ i ) ) ; $ ans += $ subset ; } return $ ans ; } $ arr = array ( 1 , 2 , 3 ) ; $ size = count ( $ arr ) ; echo andSum ( $ arr , $ size ) ; ? >"}
{"text":"Maximize the number by rearranging bits | An efficient Java program to find minimum number formed by bits of a given number . ; Returns maximum number formed by bits of a given number . ; _popcnt32 ( a ) gives number of 1 's present in binary  representation of a. ; If a$32 bits are set . ; find a number witn n least significant set bits . ; Now shift result by 32 - n ; Driver Code","code":"< ? php function _popcnt32 ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ n = $ n & ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function maximize ( $ a ) { $ n = _popcnt32 ( $ a ) ; if ( $ n == 32 ) return $ a ; $ res = ( 1 << $ n ) - 1 ; return ( $ res << ( 32 - $ n ) ) ; } $ a = 3 ; echo ( maximize ( $ a ) ) ; ? >"}
{"text":"Maximum steps to transform 0 to X with bitwise AND | Function to get no of set bits in binary representation of positive integer n ; Driver code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; } $ i = 3 ; echo ( countSetBits ( $ i ) ) ; ? >"}
{"text":"Check a number is odd or even without modulus operator | Returns true if n is even , else odd ; Driver code","code":"< ? php function isEven ( $ n ) { $ isEven = true ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ isEven = ! $ isEven ; return $ isEven ; } $ n = 101 ; $ is = isEven ( $ n ) ? \" Even \" : \" Odd \" ; echo \" $ is \" ? >"}
{"text":"Check a number is odd or even without modulus operator | Returns true if n is even , else odd ; Return true if n \/ 2 does not result in a float value . ; Driver code","code":"< ? php function isEven ( $ n ) { return ( ( int ) ( $ n \/ 2 ) * 2 == $ n ) ; } $ n = 101 ; if ( isEven ( $ n ) ) echo ( \" Even \" ) ; else echo ( \" Odd \" ) ; ? >"}
{"text":"Bitwise recursive addition of two integers | php program to do recursive addition of two integers ; If bitwise & is 0 , then there is not going to be any carry . Hence result of XOR is addition . ; Driver code","code":"< ? php function add ( $ x , $ y ) { $ keep = ( $ x & $ y ) << 1 ; $ res = $ x ^ $ y ; if ( $ keep == 0 ) { echo $ res ; exit ( 0 ) ; } add ( $ keep , $ res ) ; } $ k = add ( 15 , 38 ) ; ? >"}
{"text":"Count pairs in an array which have at least one digit common | Returns true if the pair is valid , otherwise false ; converting integers to strings ; Iterate over the strings and check if a character in first string is also present in second string , return true ; No common digit found ; Returns the number of valid pairs ; Iterate over all possible pairs ; Driver Code","code":"< ? php function checkValidPair ( $ num1 , $ num2 ) { $ s1 = ( string ) $ num1 ; $ s2 = ( string ) $ num2 ; for ( $ i = 0 ; $ i < strlen ( $ s1 ) ; $ i ++ ) for ( $ j = 0 ; $ j < strlen ( $ s2 ) ; $ j ++ ) if ( $ s1 [ $ i ] == $ s2 [ $ j ] ) return true ; return false ; } function countPairs ( & $ arr , $ n ) { $ numberOfPairs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( checkValidPair ( $ arr [ $ i ] , $ arr [ $ j ] ) ) $ numberOfPairs ++ ; return $ numberOfPairs ; } $ arr = array ( 10 , 12 , 24 ) ; $ n = sizeof ( $ arr ) ; echo ( countPairs ( $ arr , $ n ) ) ; ? >"}
{"text":"Check if bitwise AND of any subset is power of two | Check for power of 2 or not ; Check if there exist a subset whose bitwise AND is power of 2. ; if there is only one element in the set . ; Finding a number with all bit sets . ; check all the positions at which the bit is set . ; include all those elements whose i - th bit is set ; check for the set contains elements make a power of 2 or not ; Driver Code","code":"< ? php function isPowerOf2 ( $ num ) { return ( $ num && ! ( $ num & ( $ num - 1 ) ) ) ; } function checkSubsequence ( $ arr , $ n ) { $ NUM_BITS = 32 ; if ( $ n == 1 ) return isPowerOf2 ( $ arr [ 0 ] ) ; $ total = 0 ; for ( $ i = 0 ; $ i < $ NUM_BITS ; $ i ++ ) $ total = $ total | ( 1 << $ i ) ; for ( $ i = 0 ; $ i < $ NUM_BITS ; $ i ++ ) { $ ans = $ total ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & ( 1 << $ i ) ) $ ans = $ ans & $ arr [ $ j ] ; } if ( isPowerOf2 ( $ ans ) ) return true ; } return false ; } $ arr = array ( 12 , 13 , 7 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; if ( checkSubsequence ( $ arr , $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Find the winner in nim | function to find winner of NIM - game ; case when Alice is winner ; when Bob is winner ; Driver Code","code":"< ? php function findWinner ( $ A , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res ^= $ A [ $ i ] ; if ( $ res == 0 or $ n % 2 == 0 ) return \" Alice \" ; else return \" Bob \" ; } $ A = array ( 1 , 4 , 3 , 5 ) ; $ n = count ( $ A ) ; echo \" Winner = \" ? >"}
{"text":"Fibbinary Numbers ( No consecutive 1 s in binary ) | function to check whether a number is fibbinary or not ; if the number does not contain adjacent ones then ( n & ( n >> 1 ) ) operation results to 0 ; not a fibbinary number ; Driver code","code":"< ? php function isFibbinaryNum ( $ n ) { if ( ( $ n & ( $ n >> 1 ) ) == 0 ) return true ; return false ; } $ n = 10 ; if ( isFibbinaryNum ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Maximum XOR | function to calculate maximum XOR value ; Return ( 2 ^ c - 1 ) ; Driver Code","code":"< ? php function maxXOR ( $ n , $ k ) { $ c = log ( $ n , 2 ) + 1 ; return ( ( 1 << $ c ) - 1 ) ; } $ n = 12 ; $ k = 3 ; echo maxXOR ( $ n , $ k ) ; ? >"}
{"text":"Divide two integers without using multiplication , division and mod operator | Function to divide a by b and return floor value it ; Calculate sign of divisor i . e . , sign will be negative either one of them is negative only iff otherwise it will be positive ; remove sign of operands ; Initialize the quotient ; test down from the highest bit and accumulate the tentative value for valid bit ; if the sign value computed earlier is - 1 then negate the value of quotient ; Driver code","code":"< ? php function divide ( $ dividend , $ divisor ) { $ sign = ( ( $ dividend < 0 ) ^ ( $ divisor < 0 ) ) ? -1 : 1 ; $ dividend = abs ( $ dividend ) ; $ divisor = abs ( $ divisor ) ; $ quotient = 0 ; $ temp = 0 ; for ( $ i = 31 ; $ i >= 0 ; -- $ i ) { if ( $ temp + ( $ divisor << $ i ) <= $ dividend ) { $ temp += $ divisor << $ i ; $ quotient |= ( double ) ( 1 ) << $ i ; } } if ( $ sign == -1 ) $ quotient = - $ quotient ; return $ quotient ; } $ a = 10 ; $ b = 3 ; echo divide ( $ a , $ b ) . \" STRNEWLINE \" ; $ a = 43 ; $ b = -8 ; echo divide ( $ a , $ b ) ; ? >"}
{"text":"XOR of two numbers after making length of their binary representations equal | function to count the number of bits in binary representation of an integer ; initialize count ; count till n is non zero ; right shift by 1 i . e , divide by 2 ; function to calculate the xor of two numbers by adding trailing zeros to the number having less number of bits in its binary representation . ; stores the minimum and maximum ; left shift if the number of bits are less in binary representation ; Driver Code","code":"< ? php function count1 ( $ n ) { $ c = 0 ; while ( $ n ) { $ c ++ ; $ n = $ n >> 1 ; } return $ c ; } function XOR1 ( $ a , $ b ) { $ c = min ( $ a , $ b ) ; $ d = max ( $ a , $ b ) ; if ( count1 ( $ c ) < count1 ( $ d ) ) $ c = $ c << ( count1 ( $ d ) - count1 ( $ c ) ) ; return ( $ c ^ $ d ) ; } $ a = 13 ; $ b = 5 ; echo XOR1 ( $ a , $ b ) ; ? >"}
{"text":"Swap every two bits in bytes | PHP program to swap every two bits in a byte . ; Extracting the high bit shift it to lowbit Extracting the low bit shift it to highbit ; Driver Code","code":"< ? php function swapBitsInPair ( $ x ) { return ( ( $ x & 0b10101010 ) >> 1 ) | ( ( $ x & 0b01010101 ) << 1 ) ; } $ x = 4 ; echo swapBitsInPair ( $ x ) ; ? >"}
{"text":"Alternate bits of two numbers to create a new number | set even bit of number n ; res for store 101010. . number ; generate number form of 101010. . ... till temp size ; if bit is even then generate number and or with res ; return set even bit number ; set odd bit of number m ; res for store 101010. . number ; generate number form of 101010. . . . till temp size ; if bit is even then generate number and or with res ; return set odd bit number ; set even bit of number n ; set odd bit of number m ; take OR with these number ; Driver code ; n = 1 0 1 0 ^ ^ m = 1 0 1 1 ^ ^ result = 1 0 1 1","code":"< ? php function setevenbits ( $ n ) { $ temp = $ n ; $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n & $ res ) ; } function setoddbits ( $ m ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ m ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ m & $ res ) ; } function getAlternateBits ( $ n , $ m ) { $ tempn = setevenbits ( $ n ) ; $ tempm = setoddbits ( $ m ) ; return ( $ tempn $ tempm ) ; } $ n = 10 ; $ m = 11 ; echo getAlternateBits ( $ n , $ m ) ; ? >"}
{"text":"Decimal representation of given binary string is divisible by 20 or not | function to check whether decimal representation of given binary number is divisible by 10 or not ; if last digit is '1' , then number is not divisible by 10 ; to accumulate the sum of last digits in perfect powers of 2 ; traverse from the 2 nd last up to 1 st digit in ' bin ' ; if digit in '1' ; calculate digit 's position  from the right ; according to the digit 's position,  obtain the last digit of the  applicable perfect power of 2 ; if last digit is 0 , then divisible by 10 ; not divisible by 10 ; function to check whether decimal representation of given binary number is divisible by 20 or not ; if ' bin ' is an odd number ; check if bin ( 0. . n - 2 ) is divisible by 10 or not ; Driver code","code":"< ? php function isDivisibleBy10 ( $ bin , $ n ) { if ( $ bin [ $ n - 1 ] == '1' ) return false ; $ sum = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ bin [ $ i ] == '1' ) { $ posFromRight = $ n - $ i - 1 ; if ( $ posFromRight % 4 == 1 ) $ sum = $ sum + 2 ; else if ( $ posFromRight % 4 == 2 ) $ sum = $ sum + 4 ; else if ( $ posFromRight % 4 == 3 ) $ sum = $ sum + 8 ; else if ( $ posFromRight % 4 == 0 ) $ sum = $ sum + 6 ; } } if ( $ sum % 10 == 0 ) return true ; return false ; } function isDivisibleBy20 ( $ bin , $ n ) { if ( $ bin [ $ n - 1 ] == '1' ) return false ; return isDivisibleBy10 ( $ bin , $ n - 1 ) ; } $ bin = \"101000\" ; $ n = strlen ( $ bin ) ; if ( isDivisibleBy20 ( $ bin , $ n - 1 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"For every set bit of a number toggle bits of other | function for the Nega_bit ; Driver code","code":"< ? php function toggleBits ( $ n1 , $ n2 ) { return $ n1 ^ $ n2 ; } $ n1 = 2 ; $ n2 = 5 ; echo toggleBits ( $ n1 , $ n2 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Toggle all even bits of a number | Returns a number which has all even bits of n toggled . ; Generate number form of 101010 . . till of same order as n ; if bit is even then generate number and or with res ; return toggled number ; Driver code","code":"< ? php function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; } $ n = 11 ; echo evenbittogglenumber ( $ n ) ; ? >"}
{"text":"Toggle first and last bits of a number | Returns a number which has same bit count as n and has only first and last bits as set . ; set all the bit of the number ; Adding one to n now unsets all bits and moves MSB to one place . Now we shift the number by 1 and add 1. ; if number is 1 ; take XOR with first and last set bit number ; Driver code","code":"< ? php function takeLandFsetbits ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return ( ( $ n + 1 ) >> 1 ) + 1 ; } function toggleFandLbits ( int $ n ) { if ( $ n == 1 ) return 0 ; return $ n ^ takeLandFsetbits ( $ n ) ; } $ n = 10 ; echo toggleFandLbits ( $ n ) ; ? >"}
{"text":"Odious number | Function to get no of set bits in binary ; Check if number is odious or not ; Driver Code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function checkOdious ( $ n ) { return ( countSetBits ( $ n ) % 2 == 1 ) ; } $ num = 32 ; if ( checkOdious ( $ num ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Set the Left most unset bit | set left most unset bit ; if number contain all 1 then return n ; Find position of leftmost unset bit . ; if temp L . S . B is zero then unset bit pos is change ; return OR of number and unset bit pos ; Driver code","code":"< ? php function setleftmostunsetbit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; $ pos = 0 ; for ( $ temp = $ n , $ count = 0 ; $ temp > 0 ; $ temp >>= 1 , $ count ++ ) if ( ( $ temp & 1 ) == 0 ) $ pos = $ count ; return ( $ n | ( 1 << ( $ pos ) ) ) ; } $ n = 10 ; echo setleftmostunsetbit ( $ n ) ; ? >"}
{"text":"Maximum XOR using K numbers from 1 to n | To return max xor sum of 1 to n using at most k numbers ; If k is 1 then maximum possible sum is n ; Finding number greater than or equal to n with most significant bit same as n . For example , if n is 4 , result is 7. If n is 5 or 6 , result is 7 ; Return res - 1 which denotes a number with all bits set to 1 ; Driver code","code":"< ? php function maxXorSum ( $ n , $ k ) { if ( $ k == 1 ) return $ n ; $ res = 1 ; while ( $ res <= $ n ) $ res <<= 1 ; return $ res - 1 ; } $ n = 4 ; $ k = 3 ; echo maxXorSum ( $ n , $ k ) ; ? >"}
{"text":"Increment a number by one by manipulating the bits | function to find the position of rightmost set bit ; function to toggle the last m bits ; calculating a number ' num ' having ' m ' bits and all are set ; toggle the last m bits and return the number ; function to increment a number by one by manipulating the bits ; get position of rightmost unset bit if all bits of ' n ' are set , then the bit left to the MSB is the rightmost unset bit ; kth bit of n is being set by this operation ; from the right toggle all the bits before the k - th ; required number ; Driver code","code":"< ? php function getPosOfRightmostSetBit ( $ n ) { $ t = $ n & - $ n ; return log ( $ t , 2 ) ; } function toggleLastKBits ( $ n , $ k ) { $ num = ( 1 << $ k ) - 1 ; return ( $ n ^ $ num ) ; } function incrementByOne ( $ n ) { $ k = getPosOfRightmostSetBit ( ~ $ n ) ; $ n = ( ( 1 << $ k ) $ n ) ; if ( $ k != 0 ) $ n = toggleLastKBits ( $ n , $ k ) ; return $ n ; } $ n = 15 ; echo incrementByOne ( $ n ) ; ? >"}
{"text":"XNOR of two numbers | log ( n ) solution ; Make sure a is larger ; for last bit of a ; for last bit of b ; counter for count bit and set bit in xnornum ; to make new xnor number ; for set bits in new xnor number ; get last bit of a ; get last bit of b ; Check if current two bits are same ; counter for count bit ; Driver code","code":"< ? php function xnor ( $ a , $ b ) { if ( $ a < $ b ) list ( $ a , $ b ) = array ( $ b , $ a ) ; if ( $ a == 0 && $ b == 0 ) return 1 ; $ a_rem = 0 ; $ b_rem = 0 ; $ count = 0 ; $ xnornum = 0 ; while ( $ a ) { $ a_rem = $ a & 1 ; $ b_rem = $ b & 1 ; if ( $ a_rem == $ b_rem ) $ xnornum |= ( 1 << $ count ) ; $ count ++ ; $ a = $ a >> 1 ; $ b = $ b >> 1 ; } return $ xnornum ; } $ a = 10 ; $ b = 50 ; echo xnor ( $ a , $ b ) ; ? >"}
{"text":"XNOR of two numbers | Please refer below post for details of this function https : www . geeksforgeeks . org \/ toggle - bits - significant - bit \/ ; Make a copy of n as we are going to change it . ; Suppose n is 273 ( binary is 100010001 ) . It does following 100010001 | 010001000 = 110011001 ; This makes sure 4 bits ( From MSB and including MSB ) are set . It does following 110011001 | 001100110 = 111111111 ; Returns XNOR of num1 and num2 ; if num2 is greater then we swap this number in num1 ; Driver code","code":"< ? php function togglebit ( $ n ) { if ( $ n == 0 ) return 1 ; $ i = $ n ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return $ i ^ $ n ; } function XNOR ( $ num1 , $ num2 ) { if ( $ num1 < $ num2 ) list ( $ num1 , $ num2 ) = array ( $ num2 , $ num1 ) ; $ num1 = togglebit ( $ num1 ) ; return $ num1 ^ $ num2 ; } $ num1 = 10 ; $ num2 = 20 ; echo XNOR ( $ num1 , $ num2 ) ; ? >"}
{"text":"Maximum OR sum of sub | function to find maximum OR sum ; OR sum of all the elements in both arrays ; Driver Code","code":"< ? php function MaximumSum ( $ a , $ b , $ n ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 |= $ a [ $ i ] ; $ sum2 |= $ b [ $ i ] ; } echo ( $ sum1 + $ sum2 ) . \" STRNEWLINE \" ; } $ A = array ( 1 , 2 , 4 , 3 , 2 ) ; $ B = array ( 2 , 3 , 3 , 12 , 1 ) ; $ n = sizeof ( $ A ) \/ sizeof ( $ A [ 0 ] ) ; MaximumSum ( $ A , $ B , $ n ) ; ? >"}
{"text":"Check whether the two numbers differ at one bit position only | function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; function to check whether the two numbers differ at one bit position only ; Driver Code","code":"< ? php function isPowerOfTwo ( $ x ) { $ y = 0 ; if ( $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ) $ y = 1 ; return $ y ; } function differAtOneBitPos ( $ a , $ b ) { return isPowerOfTwo ( $ a ^ $ b ) ; } $ a = 13 ; $ b = 9 ; if ( differAtOneBitPos ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Multiplication with a power of 2 | Returns 2 raised to power n ; Driver Code","code":"< ? php function power2 ( $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 2 ; return power2 ( $ n \/ 2 ) * power2 ( $ n \/ 2 ) ; } function multiply ( $ x , $ n ) { return $ x * power2 ( $ n ) ; } $ x = 70 ; $ n = 2 ; echo multiply ( $ x , $ n ) ; ? >"}
{"text":"Multiplication with a power of 2 | Efficient PHP program to compute x * ( 2 ^ n ) ; Driver Code","code":"< ? php function multiply ( $ x , $ n ) { return $ x << $ n ; } $ x = 70 ; $ n = 2 ; echo multiply ( $ x , $ n ) ; ? >"}
{"text":"Check if n is divisible by power of 2 without using arithmetic operators | function to check whether n is divisible by pow ( 2 , m ) ; if expression results to 0 , then n is divisible by pow ( 2 , m ) ; n is not divisible ; Driver Code","code":"< ? php function isDivBy2PowerM ( $ n , $ m ) { if ( ( $ n & ( ( 1 << $ m ) - 1 ) ) == 0 ) return true ; return false ; } $ n = 8 ; $ m = 2 ; if ( isDivBy2PowerM ( $ n , $ m ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Game of Nim with removal of one stone allowed | Return true if player A wins , return false if player B wins . ; Checking the last bit of N . ; Driver Code","code":"< ? php function findWinner ( $ N ) { return $ N & 1 ; } $ N = 15 ; if ( findWinner ( $ N ) ) echo \" Player \u2581 A \" ; else echo \" Player \u2581 B \" ; ? >"}
{"text":"Toggle all odd bits of a number | Returns a number which has all odd bits of n toggled . ; Generate number form of 101010. . . . . till of same order as n ; if bit is odd , then generate number and or with res ; return toggled number ; Driver code","code":"< ? php function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; } $ n = 11 ; echo evenbittogglenumber ( $ n ) ; ? >"}
{"text":"Quotient and remainder dividing by 2 ^ k ( a power of 2 ) | function to print remainder and quotient ; print Remainder by n AND ( m - 1 ) ; print quotient by right shifting n by ( log ( m , 2 ) ) times 2 is base ; Driver Code","code":"< ? php function divide ( $ n , $ m ) { echo \" Remainder = \" . \u2581 ( ( $ n ) \u2581 & ( $ m \u2581 - \u2581 1 ) ) ; STRNEWLINE TABSYMBOL echo \u2581 \" Quotient = \" } $ n = 43 ; $ m = 8 ; divide ( $ n , $ m ) ; ? >"}
{"text":"Maximum AND value of a pair in an array | Function for finding maximum and value pair ; Driver Code","code":"< ? php function maxAND ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ res = max ( $ res , $ arr [ $ i ] & $ arr [ $ j ] ) ; return $ res ; } $ arr = array ( 4 , 8 , 6 , 2 ) ; $ n = count ( $ arr ) ; echo \" Maximum \u2581 AND \u2581 Value \u2581 = \u2581 \" , maxAND ( $ arr , $ n ) ; ? >"}
{"text":"Check if a number is positive , negative or zero using bit operators | function to return 1 if it is zero returns 0 if it is negative returns 2 if it is positive ; string array to store all kinds of number ; function call to check the sign of number ; Driver Code","code":"< ? php function index ( $ i ) { return 1 + ( $ i >> 31 ) - ( - $ i >> 31 ) ; } function check ( $ n ) { $ s = array ( \" negative \" , \" zero \" , \" positive \" ) ; $ val = index ( $ n ) ; echo $ n , \" \u2581 is \u2581 \" , $ s [ $ val ] , \" STRNEWLINE \" ; } check ( 30 ) ; check ( -20 ) ; check ( 0 ) ; ? >"}
{"text":"Divisibility by 64 with removal of bits allowed | function to check if it is possible to make it a multiple of 64. ; counter to count 0 's ; length of the string ; loop which traverses right to left and calculates the number of zeros before 1. ; Driver Code","code":"< ? php function checking ( $ s ) { $ c = 0 ; $ n = strlen ( $ s ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' ) $ c ++ ; if ( $ c >= 6 and $ s [ $ i ] == '1' ) return true ; } return false ; } $ s = \"100010001\" ; if ( checking ( $ s ) ) echo \" Possible \" ; else echo \" Not \u2581 possible \" ; ? >"}
{"text":"Modify a bit at a given position | Returns modified n . ; Driver code","code":"< ? php function modifyBit ( $ n , $ p , $ b ) { $ mask = 1 << $ p ; return ( $ n & ~ $ mask ) | ( ( $ b << $ p ) & $ mask ) ; } echo modifyBit ( 6 , 2 , 0 ) , \" STRNEWLINE \" ; echo modifyBit ( 6 , 5 , 1 ) , \" STRNEWLINE \" ; ? >"}
{"text":"Count set bits in a range | Function to get no of set bits in the binary representation of ' n ' ; function to count set bits in the given range ; calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; returns number of set bits in the range ' l ' to ' r ' in ' n ' ; Driver Code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function countSetBitsInGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; return countSetBits ( $ n & $ num ) ; } $ n = 42 ; $ l = 2 ; $ r = 5 ; echo countSetBitsInGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text":"Check if one of the numbers is one 's complement of the other | function to check if all the bits are set or not in the binary representation of ' n ' ; all bits are not set ; if true , then all bits are set ; else all bits are not set ; function to check if one of the two numbers is one 's complement of the other ; Driver Code","code":"< ? php function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return false ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return true ; return false ; } function isOnesComplementOfOther ( $ a , $ b ) { return areAllBitsSet ( $ a ^ $ b ) ; } $ a = 10 ; $ b = 5 ; if ( isOnesComplementOfOther ( $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Unique element in an array where all elements occur k times except one | PHP program to find unique element where every element appears k times except one ; Create a count array to store count of numbers that have a particular bit set . count [ i ] stores count of array elements with i - th bit set . ; AND ( bitwise ) each element of the array with each set digit ( one at a time ) to get the count of set bits at each position ; Now consider all bits whose count is not multiple of k to form the required number . ; Driver Code","code":"< ? php function findUnique ( $ a , $ n , $ k ) { $ INT_SIZE = 8 * PHP_INT_SIZE ; $ count = array ( ) ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ j ] & ( 1 << $ i ) ) != 0 ) $ count [ $ i ] += 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ res += ( $ count [ $ i ] % $ k ) * ( 1 << $ i ) ; return $ res ; } $ a = array ( 6 , 2 , 5 , 2 , 2 , 6 , 6 ) ; $ n = count ( $ a ) ; $ k = 3 ; echo findUnique ( $ a , $ n , $ k ) ; ? >"}
{"text":"Check whether the number has only first and last bits set | function to check whether ' n ' is a power of 2 or not ; function to check whether the number has only first and last bits set ; Driver Code","code":"< ? php function powerOfTwo ( $ n ) { return ( ! ( $ n & $ n - 1 ) ) ; } function onlyFirstAndLastAreSet ( $ n ) { if ( $ n == 1 ) return true ; if ( $ n == 2 ) return false ; return powerOfTwo ( $ n - 1 ) ; } $ n = 9 ; if ( onlyFirstAndLastAreSet ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if a number has bits in alternate pattern | Set | function to check if all the bits are set or not in the binary representation of ' n ' ; if true , then all bits are set ; else all bits are not set ; function to check if a number has bits in alternate pattern ; to check if all bits are set in ' num ' ; Driver Code","code":"< ? php function allBitsAreSet ( $ n ) { if ( ( ( $ n + 1 ) & $ n ) == 0 ) return true ; return false ; } function bitsAreInAltOrder ( $ n ) { $ num = $ n ^ ( $ n >> 1 ) ; return allBitsAreSet ( $ num ) ; } $ n = 10 ; if ( bitsAreInAltOrder ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum flips required to maximize a number with k set bits | function for finding set bit ; return count of set bit ; function for finding min flip ; number of bits in n ; Find the largest number of same size with k set bits ; Count bit differences to find required flipping . ; Driver Code","code":"< ? php function setBit ( $ xorValue ) { $ count = 0 ; while ( $ xorValue ) { if ( $ xorValue % 2 ) $ count ++ ; $ xorValue \/= 2 ; } return $ count ; } function minFlip ( $ n , $ k ) { $ size = log ( $ n ) + 1 ; $ max = pow ( 2 , $ k ) - 1 ; $ max = $ max << ( $ size - $ k ) ; $ xorValue = ( $ n ^ $ max ) ; return ( setBit ( $ xorValue ) ) ; } $ n = 27 ; $ k = 3 ; echo \" Min \u2581 Flips \u2581 = \u2581 \" , minFlip ( $ n , $ k ) ; ? >"}
{"text":"Set all the bits in given range of a number | function to toggle bits in the given range ; calculating a number ' range ' having set bits in the range from l to r and all other bits as 0 ( or unset ) . ; Driver code","code":"< ? php function setallbitgivenrange ( $ n , $ l , $ r ) { $ range = ( ( ( 1 << ( $ l - 1 ) ) - 1 ) ^ ( ( 1 << ( $ r ) ) - 1 ) ) ; return ( $ n $ range ) ; } $ n = 17 ; $ l = 2 ; $ r = 3 ; echo setallbitgivenrange ( $ n , $ l , $ r ) ; ? >"}
{"text":"Count total bits in a number | PHP program to find total bit in given number ; log function in base 2 take only integer part ; Driver Code","code":"< ? php function countBits ( $ number ) { return ( int ) ( log ( $ number ) \/ log ( 2 ) ) + 1 ; } $ num = 65 ; echo ( countBits ( $ num ) ) ; ? >"}
{"text":"Check whether all the bits are unset in the given range or not | function to check whether all the bits are unset in the given range or not ; calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; new number which will only have one or more set bits in the range l to r and nowhere else ; if new num is 0 , then all bits are unset in the given range ; else all bits are not unset ; Driver Code","code":"< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return \" Yes \" ; return \" No \" ; } $ n = 17 ; $ l = 2 ; $ r = 4 ; echo allBitsSetInTheGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text":"Toggle all bits after most significant bit | Returns a number which has all set bits starting from MSB of n ; This makes sure two bits ( From MSB and including MSB ) are set ; This makes sure 4 bits ( From MSB and including MSB ) are set ; Driver Code","code":"< ? php function setAllBitsAfterMSB ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; return $ n ; } function toggle ( & $ n ) { $ n = $ n ^ setAllBitsAfterMSB ( $ n ) ; } $ n = 10 ; toggle ( $ n ) ; echo $ n ; ? >"}
{"text":"Position of rightmost common bit in two numbers | Function to find the position of rightmost set bit in ' n ' ; Function to find the position of rightmost same bit in the binary representations of ' m ' and ' n ' ; position of rightmost same bit ; Driver Code","code":"< ? php function getRightMostSetBit ( $ n ) { return log ( $ n & - $ n ) + 1 ; } function posOfRightMostSameBit ( $ m , $ n ) { return getRightMostSetBit ( ~ ( $ m ^ $ n ) ) ; } $ m = 16 ; $ n = 7 ; echo \" Position \u2581 = \u2581 \" , ceil ( posOfRightMostSameBit ( $ m , $ n ) ) ; ? >"}
{"text":"Check whether all the bits are set in the given range | function to check whether all the bits are set in the given range or not ; Calculating a number ' num ' having ' r ' number of bits and bits in the range l to r are the only set bits ; new number which will only have one or more set bits in the range l to r and nowhere else ; if both are equal , then all bits are set in the given range ; else all bits are not set ; Driver Code","code":"< ? php function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ num == $ new_num ) return \" Yes \" ; return \" No \" ; } $ n = 22 ; $ l = 2 ; $ r = 3 ; echo allBitsSetInTheGivenRange ( $ n , $ l , $ r ) ; ? >"}
{"text":"1 to n bit numbers with no consecutive 1 s in binary representation | Print all numbers upto n bits with no consecutive set bits . ; Let us first compute 2 raised to power n . ; loop 1 to n to check all the numbers ; A number i doesn ' t \u2581 contain \u2581 \u2581 consecutive \u2581 set \u2581 bits \u2581 if \u2581 \u2581 bitwise \u2581 and \u2581 of \u2581 i \u2581 and \u2581 left \u2581 \u2581 shifted \u2581 i \u2581 do ' t contain a commons set bit . ; Driver code","code":"< ? php function printNonConsecutive ( $ n ) { $ p = ( 1 << $ n ) ; for ( $ i = 1 ; $ i < $ p ; $ i ++ ) if ( ( $ i & ( $ i << 1 ) ) == 0 ) echo $ i . \" \" ; } $ n = 3 ; printNonConsecutive ( $ n ) ; ? >"}
{"text":"Find the n | Efficient PHP program to find n - th palindrome ; Construct the nth binary palindrome with the given group number , aux_number and operation type ; No need to insert any bit in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and  fill around middle ; Insert bit 0 in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and fill  around middle ; else Insert bit 1 in the middle ; Length of the final binary representation ; Fill first and last bit as 1 ; Start filling the a [ ] from middle , with the aux_num binary representation ; Get the auxiliary number 's ith bit and fill  around middle ; Convert the number to decimal from binary ; Will return the nth binary palindrome number ; Add number of elements in all the groups , until the group of the nth number is found ; Total number of elements until this group ; Element 's offset position in the group ; Finding which bit to be placed in the middle and finding the number , which we will fill from the middle in both directions ; We need to fill this auxiliary number in binary form the middle in both directions ; $op = 0 ; Need to Insert 0 at middle ; $op = 1 ; Need to Insert 1 at middle ; Driver code ; Function Call","code":"< ? php $ INT_SIZE = 32 ; function constructNthNumber ( $ group_no , $ aux_num , $ op ) { global $ INT_SIZE ; $ a = array_fill ( 0 , $ INT_SIZE , 0 ) ; $ num = 0 ; $ i = 0 ; $ len_f = 0 ; if ( $ op == 2 ) { $ len_f = 2 * $ group_no ; $ a [ $ len_f - 1 ] = $ a [ 0 ] = 1 ; while ( $ aux_num ) { $ a [ $ group_no + i ] = $ a [ $ group_no - 1 - $ i ] = $ aux_num & 1 ; $ aux_num = $ aux_num >> 1 ; $ i ++ ; } } else if ( $ op == 0 ) { $ len_f = 2 * $ group_no + 1 ; $ a [ $ len_f - 1 ] = $ a [ 0 ] = 1 ; $ a [ $ group_no ] = 0 ; while ( $ aux_num ) { $ a [ $ group_no + 1 + $ i ] = $ a [ $ group_no - 1 - $ i ] = $ aux_num & 1 ; $ aux_num = $ aux_num >> 1 ; $ i ++ ; } } { $ len_f = 2 * $ group_no + 1 ; $ a [ $ len_f - 1 ] = $ a [ 0 ] = 1 ; $ a [ $ group_no ] = 1 ; while ( $ aux_num ) { $ a [ $ group_no + 1 + $ i ] = $ a [ $ group_no - 1 - $ i ] = $ aux_num & 1 ; $ aux_num = $ aux_num >> 1 ; $ i ++ ; } } for ( $ i = 0 ; $ i < $ len_f ; $ i ++ ) $ num += ( 1 << $ i ) * $ a [ $ i ] ; return $ num ; } function getNthNumber ( $ n ) { $ group_no = 0 ; $ count_upto_group = 0 ; $ count_temp = 1 ; $ op = $ aux_num = 0 ; while ( $ count_temp < $ n ) { $ group_no ++ ; $ count_upto_group = $ count_temp ; $ count_temp += 3 * ( 1 << ( $ group_no - 1 ) ) ; } $ group_offset = $ n - $ count_upto_group - 1 ; if ( ( $ group_offset + 1 ) <= ( 1 << ( $ group_no - 1 ) ) ) { $ aux_num = $ group_offset ; } else { if ( ( ( $ group_offset + 1 ) - ( 1 << ( $ group_no - 1 ) ) ) % 2 ) else $ aux_num = ( int ) ( ( ( $ group_offset ) - ( 1 << ( $ group_no - 1 ) ) ) \/ 2 ) ; } return constructNthNumber ( $ group_no , $ aux_num , $ op ) ; } $ n = 9 ; print ( getNthNumber ( $ n ) ) ; ? >"}
{"text":"Sum of numbers with exactly 2 bits set | To count number of set bits ; To calculate sum of numbers ; To count sum of number whose 2 bit are set ; Driver Code","code":"< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ n &= ( $ n - 1 ) ; $ count ++ ; } return $ count ; } function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) if ( countSetBits ( $ i ) == 2 ) $ sum += $ i ; return $ sum ; } $ n = 10 ; echo findSum ( $ n ) ; ? >"}
{"text":"Toggle the last m bits | function to toggle the last m bits ; calculating a number ' num ' having ' m ' bits and all are set . ; toggle the last m bits and return the number ; Driver code","code":"< ? php function toggleLastMBits ( $ n , $ m ) { $ num = ( 1 << $ m ) - 1 ; return ( $ n ^ $ num ) ; } { $ n = 107 ; $ m = 4 ; echo toggleLastMBits ( $ n , $ m ) ; return 0 ; } ? >"}
{"text":"Previous smaller integer having one less number of set bits | function to find the position of rightmost set bit . ; function to find the previous smaller integer ; position of rightmost set bit of n ; turn off or unset the bit at position ' pos ' ; Driver Code","code":"< ? php function getFirstSetBitPos ( $ n ) { return log ( $ n & - $ n ) + 1 ; } function previousSmallerInteger ( $ n ) { $ pos = getFirstSetBitPos ( $ n ) ; return ( $ n & ~ ( 1 << ( $ pos - 1 ) ) ) ; } $ n = 25 ; echo \" Previous \u2581 smaller \u2581 Integer \u2581 = \u2581 \" , previousSmallerInteger ( $ n ) ; ? >"}
{"text":"Check if all bits of a number are set | function to check if all the bits are set or not in the binary representation of ' n ' ; all bits are not set ; loop till n becomes '0' ; if the last bit is not set ; right shift ' n ' by 1 ; all bits are set ; Driver Code","code":"< ? php function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return \" No \" ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) return \" No \" ; $ n = $ n >> 1 ; } return \" Yes \" ; } $ n = 7 ; echo areAllBitsSet ( $ n ) ; ? >"}
{"text":"Check if all bits of a number are set | function to check if all the bits are set or not in the binary representation of ' n ' ; all bits are not set ; if true , then all bits are set ; else all bits are not set ; Driver Code","code":"< ? php function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return \" No \" ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return \" Yes \" ; return \" No \" ; } $ n = 7 ; echo areAllBitsSet ( $ n ) ; ? >"}
{"text":"Next greater integer having one more number of set bits | function to find the position of rightmost set bit . Returns - 1 if there are no set bits ; function to find the next greater integer ; position of rightmost unset bit of n by passing ~ n as argument ; if n consists of unset bits , then set the rightmost unset bit ; n does not consists of unset bits ; Driver Code","code":"< ? php function getFirstSetBitPos ( $ n ) { return ( log ( $ n & - $ n + 1 ) ) - 1 ; } function nextGreaterWithOneMoreSetBit ( $ n ) { $ pos = getFirstSetBitPos ( ~ $ n ) ; if ( $ pos > -1 ) return ( 1 << $ pos ) | $ n ; return ( ( $ n << 1 ) + 1 ) ; } $ n = 10 ; echo \" Next \u2581 greater \u2581 integer \u2581 = \u2581 \" , nextGreaterWithOneMoreSetBit ( $ n ) ; ? >"}
{"text":"Count numbers whose sum with x is equal to XOR with x | Function to find total 0 bit in a number ; Function to find Count of non - negative numbers less than or equal to x , whose bitwise XOR and SUM with x are equal . ; count number of zero bit in x ; power of 2 to count ; Driver code ; Function call","code":"< ? php function CountZeroBit ( $ x ) { $ count = 0 ; while ( $ x ) { if ( ! ( $ x & 1 ) ) $ count ++ ; $ x >>= 1 ; } return $ count ; } function CountXORandSumEqual ( $ x ) { $ count = CountZeroBit ( $ x ) ; return ( 1 << $ count ) ; } $ x = 10 ; echo CountXORandSumEqual ( $ x ) ; ? >"}
{"text":"Find missing number in another array which is shuffled copy | Returns the missing number Size of arr2 [ ] is n - 1 ; Missing number ' mnum ' ; 1 st array is of size ' n ' ; 2 nd array is of size ' n \u2581 - \u2581 1' ; Required missing number ; Driver Code","code":"< ? php function missingNumber ( $ arr1 , $ arr2 , $ n ) { $ mnum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mnum = $ mnum ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ mnum = $ mnum ^ $ arr2 [ $ i ] ; return $ mnum ; } $ arr1 = array ( 4 , 8 , 1 , 3 , 7 ) ; $ arr2 = array ( 7 , 4 , 3 , 1 ) ; $ n = count ( $ arr1 ) ; echo \" Missing \u2581 number \u2581 = \u2581 \" , missingNumber ( $ arr1 , $ arr2 , $ n ) ; ? >"}
{"text":"Change bits to make specific OR value | Returns max of three numbers ; Returns count of bits in N ; Returns bit at ' pos ' position ; Utility method to toggle bit at ' pos ' position ; method returns minimum number of bit flip to get T as OR value of A and B ; Loop over maximum number of bits among A , B and T ; T 's bit is set, try to toggle  bit of B, if not already ; if A 's bit is set,   flip that ; if B 's bit is set,  flip that ; if K is less than 0 then we can make A | B == T ; Loop over bits one more time to minimise A further ; If both bit are set , then Unset A 's bit to minimise it ; If A ' s \u2581 bit \u2581 is \u2581 1 \u2581 and \u2581 B ' s bit is 0 , toggle both ; Output changed value of A and B ; Driver Code","code":"< ? php function maxDD ( $ a , $ b , $ c ) { return max ( $ a , ( max ( $ b , $ c ) ) ) ; } function bitCount ( $ N ) { $ cnt = 0 ; while ( $ N ) { $ cnt ++ ; $ N >>= 1 ; } return $ cnt ; } function at_position ( $ num , $ pos ) { $ bit = $ num & ( 1 << $ pos ) ; return $ bit ; } function toggle ( & $ num , $ pos ) { $ num ^= ( 1 << $ pos ) ; } function minChangeToReachTaregetOR ( $ A , $ B , $ K , $ T ) { $ maxlen = max ( bitCount ( $ A ) , bitCount ( $ B ) , bitCount ( $ T ) ) ; for ( $ i = $ maxlen - 1 ; $ i >= 0 ; $ i -- ) { $ bitA = at_position ( $ A , $ i ) ; $ bitB = at_position ( $ B , $ i ) ; $ bitT = at_position ( $ T , $ i ) ; if ( $ bitT ) { if ( ! $ bitA && ! $ bitB ) { toggle ( $ B , $ i ) ; $ K -- ; } } else { if ( $ bitA ) { toggle ( $ A , $ i ) ; $ K -- ; } if ( $ bitB ) { toggle ( $ B , $ i ) ; $ K -- ; } } } if ( $ K < 0 ) { echo \" Not \u2581 possible STRNEWLINE \" ; return ; } for ( $ i = $ maxlen - 1 ; $ K > 0 && $ i >= 0 ; -- $ i ) { $ bitA = at_position ( $ A , $ i ) ; $ bitB = at_position ( $ B , $ i ) ; $ bitT = at_position ( $ T , $ i ) ; if ( $ bitT ) { if ( $ bitA && $ bitB ) { toggle ( $ A , $ i ) ; $ K -- ; } } if ( $ bitA && ! $ bitB && $ K >= 2 ) { toggle ( $ A , $ i ) ; toggle ( $ B , $ i ) ; $ K -= 2 ; } } echo $ A , \" \" \u2581 , \u2581 $ B \u2581 , \u2581 \" \" } $ A = 175 ; $ B = 66 ; $ K = 5 ; $ T = 100 ; minChangeToReachTaregetOR ( $ A , $ B , $ K , $ T ) ; ? >"}
{"text":"Count smaller values whose XOR with x is greater than x | PHP program to find count of values whose XOR with x is greater than x and values are smaller than x ; Initialize result ; Traversing through all bits of x ; If current last bit of x is set then increment count by n . Here n is a power of 2 corresponding to position of bit ; Simultaneously calculate the 2 ^ n ; Replace x with x \/ 2 ; ; Driver code","code":"< ? php function countValues ( $ x ) { $ count = 0 ; $ n = 1 ; while ( $ x != 0 ) { if ( $ x % 2 == 0 ) $ count += $ n ; $ n *= 2 ; $ x \/= 2 ; $ x = ( int ) $ x ; } return $ count ; } $ x = 10 ; echo countValues ( $ x ) ; ? >"}
{"text":"Construct an array from XOR of all elements of array except element at same index | function to construct new array ; calculate xor of array ; update array ; Driver code ; print result","code":"< ? php function constructXOR ( & $ A , $ n ) { $ XOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ XOR ^= $ A [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ A [ $ i ] = $ XOR ^ $ A [ $ i ] ; } $ A = array ( 2 , 4 , 1 , 3 , 5 ) ; $ n = sizeof ( $ A ) ; constructXOR ( $ A , $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ A [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Count all pairs of an array which differ in K bits | Utility function to count total ones in a number ; Function to count pairs of K different bits ; initialize final answer ; Check for K differ bit ; Driver code","code":"< ? php function bitCount ( $ n ) { $ count = 0 ; while ( $ n ) { if ( $ n & 1 ) ++ $ count ; $ n >>= 1 ; } return $ count ; } function countPairsWithKDiff ( $ arr , $ n , $ k ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { for ( $ j = $ i + 1 ; $ j < $ n ; ++ $ j ) { $ xoredNum = $ arr [ $ i ] ^ $ arr [ $ j ] ; if ( $ k == bitCount ( $ xoredNum ) ) ++ $ ans ; } } return $ ans ; } $ k = 2 ; $ arr = array ( 2 , 4 , 1 , 3 , 1 ) ; $ n = count ( $ arr ) ; echo \" Total \u2581 pairs \u2581 for \u2581 k \u2581 = \u2581 \" , $ k , \" \u2581 are \u2581 \" , countPairsWithKDiff ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"Multiplication of two numbers with shift operator | Function for multiplication ; check for set bit and left shift n , count times ; increment of place value ( count ) ; Driver code","code":"< ? php function multiply ( $ n , $ m ) { $ ans = 0 ; $ count = 0 ; while ( $ m ) { if ( $ m % 2 == 1 ) $ ans += $ n << $ count ; $ count ++ ; $ m \/= 2 ; } return $ ans ; } $ n = 20 ; $ m = 13 ; echo multiply ( $ n , $ m ) ; ? >"}
{"text":"Compare two integers without using any Comparison operator | function return true if A ^ B > 0 else false ; Driver Code","code":"< ? php function EqualNumber ( $ A , $ B ) { return ( $ A ^ $ B ) ; } $ A = 5 ; $ B = 6 ; echo ( ( int ) ! ( EqualNumber ( $ A , $ B ) ) ) . \" STRNEWLINE \" ; ? >"}
{"text":"Check if bits of a number has count of consecutive set bits in increasing order | Returns true if n has counts of consecutive 1 's are increasing order. ; Initialize previous count ; We traverse bits from right to left and check if counts are decreasing order . ; Ignore 0 s until we reach a set bit . ; Count current set bits ; Compare current with previous and update previous . ; Driver code","code":"< ? php function areSetBitsIncreasing ( $ n ) { $ prev_count = PHP_INT_MAX ; while ( $ n > 0 ) { while ( $ n > 0 && $ n % 2 == 0 ) $ n = $ n \/ 2 ; $ curr_count = 1 ; while ( $ n > 0 and $ n % 2 == 1 ) { $ n = $ n \/ 2 ; $ curr_count ++ ; } if ( $ curr_count >= $ prev_count ) return false ; $ prev_count = $ curr_count ; } return true ; } $ n = 10 ; if ( areSetBitsIncreasing ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if a number has bits in alternate pattern | Set 1 | Returns true if n has alternate bit pattern else false ; Store last bit ; Traverse through remaining bits ; If current bit is same as previous ; Driver code","code":"< ? php function findPattern ( $ n ) { $ prev = $ n % 2 ; $ n = $ n \/ 2 ; while ( $ n > 0 ) { $ curr = $ n % 2 ; if ( $ curr == $ prev ) return false ; $ prev = $ curr ; $ n = floor ( $ n \/ 2 ) ; } return true ; } $ n = 10 ; if ( findPattern ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; return 0 ; ? >"}
{"text":"XOR counts of 0 s and 1 s in binary representation | Returns XOR of counts 0 s and 1 s in binary representation of n . ; calculating count of zeros and ones ; Driver Code","code":"< ? php function countXOR ( $ n ) { $ count0 = 0 ; $ count1 = 0 ; while ( $ n ) { ( $ n % 2 == 0 ) ? $ count0 ++ : $ count1 ++ ; $ n = intval ( $ n \/ 2 ) ; } return ( $ count0 ^ $ count1 ) ; } $ n = 31 ; echo countXOR ( $ n ) ; ? >"}
{"text":"Bitwise and ( or & ) of a range | Find position of MSB in n . For example if n = 17 , then position of MSB is 4. If n = 7 , value of MSB is 3 ; Function to find Bit - wise & of all numbers from x to y . ; $res = 0 ; Initialize result ; Find positions of MSB in x and y ; If positions are not same , return ; Add 2 ^ msb_p1 to result ; subtract 2 ^ msb_p1 from x and y . ; Driver code","code":"< ? php function msbPos ( $ n ) { $ msb_p = -1 ; while ( $ n > 0 ) { $ n = $ n >> 1 ; $ msb_p ++ ; } return $ msb_p ; } function andOperator ( $ x , $ y ) { while ( $ x > 0 && $ y > 0 ) { $ msb_p1 = msbPos ( $ x ) ; $ msb_p2 = msbPos ( $ y ) ; if ( $ msb_p1 != $ msb_p2 ) break ; $ msb_val = ( 1 << $ msb_p1 ) ; $ res = $ res + $ msb_val ; $ x = $ x - $ msb_val ; $ y = $ y - $ msb_val ; } return $ res ; } $ x = 10 ; $ y = 15 ; echo andOperator ( $ x , $ y ) ; ? >"}
{"text":"Multiply a number with 10 without using multiplication operator | Function to find multiplication of n with 10 without using multiplication operator ; Driver Code","code":"< ? php function multiplyTen ( $ n ) { return ( $ n << 1 ) + ( $ n << 3 ) ; } $ n = 50 ; echo multiplyTen ( $ n ) ; ? >"}
{"text":"Equal Sum and XOR | function to count number of values less than equal to n that satisfy the given condition ; Traverse all numbers from 0 to n and increment result only when given condition is satisfied . ; Driver Code","code":"< ? php function countValues ( $ n ) { $ countV = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n + $ i ) == ( $ n ^ $ i ) ) $ countV ++ ; return $ countV ; } $ n = 12 ; echo countValues ( $ n ) ; ? >"}
{"text":"Equal Sum and XOR | function to count number of values less than equal to n that satisfy the given condition ; unset_bits keeps track of count of un - set bits in binary representation of n ; Return 2 ^ unset_bits ; Driver code","code":"< ? php function countValues ( $ n ) { $ unset_bits = 0 ; while ( $ n ) { if ( ( $ n & 1 ) == 0 ) $ unset_bits ++ ; $ n = $ n >> 1 ; } return 1 << $ unset_bits ; } $ n = 12 ; echo countValues ( $ n ) ; ? >"}
{"text":"Find profession in a special family | Returns ' e ' if profession of node at given level and position is engineer . Else doctor . The function assumes that given position and level have valid values . ; Base case ; Recursively find parent 's  profession. If parent is  a Doctor, this node will  be a doctor if it is at  odd position and an engineer  if at even position ; If parent is an engineer , then current node will be an engineer if at odd position and doctor if even position . ; Driver code","code":"< ? php function findProffesion ( $ level , $ pos ) { if ( $ level == 1 ) return ' e ' ; if ( findProffesion ( $ level - 1 , ( $ pos + 1 ) \/ 2 ) == ' d ' ) return ( $ pos % 2 ) ? ' d ' : ' e ' ; return ( $ pos % 2 ) ? ' e ' : ' d ' ; } $ level = 4 ; $ pos = 2 ; if ( ( findProffesion ( $ level , $ pos ) == ' e ' ) == true ) echo \" Engineer \" ; else echo \" Doctor \" ; ? >"}
{"text":"Print first n numbers with exactly two set bits | Prints first n numbers with two set bits ; Initialize higher of two sets bits ; Keep reducing n for every number with two set bits . ; Consider all lower set bits for current higher set bit ; Print current number ; If we have found n numbers ; Consider next lower bit for current higher bit . ; Increment higher set bit ; Driver code","code":"< ? php function printTwoSetBitNums ( $ n ) { $ x = 1 ; while ( $ n > 0 ) { $ y = 0 ; while ( $ y < $ x ) { echo ( 1 << $ x ) + ( 1 << $ y ) , \" \u2581 \" ; $ n -- ; if ( $ n == 0 ) return ; $ y ++ ; } $ x ++ ; } } printTwoSetBitNums ( 4 ) ; ? >"}
{"text":"Generate 0 and 1 with 25 % and 75 % probability | Random Function to that returns 0 or 1 with equal probability ; rand ( ) function will generate odd or even number with equal probability . If rand ( ) generates odd number , the function will return 1 else it will return 0. ; Random Function to that returns 1 with 75 % probability and 0 with 25 % probability using Bitwise OR ; Driver Code Initialize random number generator ; This code is contributed m_kit","code":"< ? php function rand50 ( ) { return rand ( ) & 1 ; } function rand75 ( ) { return rand50 ( ) | rand50 ( ) ; } srand ( time ( NULL ) ) ; for ( $ i = 0 ; $ i < 50 ; $ i ++ ) echo rand75 ( ) ; ? >"}
{"text":"Find even occurring elements in an array of limited range | Function to find the even occurring elements in given array ; do for each element of array ; left - shift 1 by value of current element ; Toggle the bit everytime element gets repeated ; Traverse array again and use _xor to find even occurring elements ; left - shift 1 by value of current element ; Each 0 in _xor represents an even occurrence ; print the even occurring numbers ; set bit as 1 to avoid printing duplicates ; Driver code","code":"< ? php function printRepeatingEven ( $ arr , $ n ) { $ _xor = 0 ; $ pos ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ pos = 1 << $ arr [ $ i ] ; $ _xor ^= $ pos ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ pos = 1 << $ arr [ $ i ] ; if ( ! ( $ pos & $ _xor ) ) { echo $ arr [ $ i ] , \" \" ; $ _xor ^= $ pos ; } } } $ arr = array ( 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 ) ; $ n = sizeof ( $ arr ) ; printRepeatingEven ( $ arr , $ n ) ; ? >"}
{"text":"Check if a number is Bleak | Function to get no of set bits in binary representation of passed binary no . ; Returns true if n is Bleak ; Check for all numbers ' x ' smaller than n . If x + countSetBits ( x ) becomes n , then n can 't be Bleak ; Driver code","code":"< ? php function countSetBits ( $ x ) { $ count = 0 ; while ( $ x ) { $ x &= ( $ x - 1 ) ; $ count ++ ; } return $ count ; } function isBleak ( $ n ) { for ( $ x = 1 ; $ x < $ n ; $ x ++ ) if ( $ x + countSetBits ( $ x ) == $ n ) return false ; return true ; } if ( isBleak ( 3 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isBleak ( 4 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Find the maximum subset XOR of a given set | Number of bits to represent int ; Function to return maximum XOR subset in set [ ] ; Initialize index of chosen elements ; Traverse through all bits of integer starting from the most significant bit ( MSB ) ; Initialize index of maximum element and the maximum element ; If i 'th bit of set[j]  is set and set[j] is  greater than max so far. ; If there was no element with i 'th  bit set, move to smaller i ; Put maximum element with i ' th \u2581 bit \u2581 \u2581 set \u2581 at \u2581 index \u2581 ' index ' ; Update maxInd and increment index ; Do XOR of set [ maxIndex ] with all numbers having i 'th bit as set. ; XOR set [ maxInd ] those numbers which have the i 'th bit set ; Increment index of chosen elements ; Final result is XOR of all elements ; Driver Code","code":"< ? php $ INT_BITS = 32 ; function maxSubarrayXOR ( & $ set , $ n ) { global $ INT_BITS ; $ index = 0 ; for ( $ i = $ INT_BITS - 1 ; $ i >= 0 ; $ i -- ) { $ maxInd = $ index ; $ maxEle = 0 ; for ( $ j = $ index ; $ j < $ n ; $ j ++ ) { if ( ( $ set [ $ j ] & ( 1 << $ i ) ) != 0 && $ set [ $ j ] > $ maxEle ) { $ maxEle = $ set [ $ j ] ; $ maxInd = $ j ; } } if ( $ maxEle == 0 ) continue ; $ t = $ set [ $ index ] ; $ set [ $ index ] = $ set [ $ maxInd ] ; $ set [ $ maxInd ] = $ t ; $ maxInd = $ index ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ j != $ maxInd && ( $ set [ $ j ] & ( 1 << $ i ) ) != 0 ) $ set [ $ j ] = $ set [ $ j ] ^ $ set [ $ maxInd ] ; } $ index ++ ; } $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res ^= $ set [ $ i ] ; return $ res ; } $ set = array ( 9 , 8 , 5 ) ; $ n = sizeof ( $ set ) ; echo \" Max \u2581 subset \u2581 XOR \u2581 is \u2581 \" ; echo maxSubarrayXOR ( $ set , $ n ) ; ? >"}
{"text":"Given a set , find XOR of the XOR 's of all subsets. | Returns XOR of all XOR 's of given subset ; XOR is 1 only when n is 1 , else 0 ; Driver Code","code":"< ? php function findXOR ( $ Set , $ n ) { if ( $ n == 1 ) return $ Set [ 0 ] ; else return 0 ; } $ Set = array ( 1 , 2 , 3 ) ; $ n = count ( $ Set ) ; echo \" XOR \u2581 of \u2581 XOR ' s \u2581 of \u2581 all \u2581 subsets \u2581 is \u2581 \" , findXOR ( $ Set , $ n ) ; ? >"}
{"text":"Find XOR of two number without using XOR operator | Returns XOR of x and y ; Driver Code","code":"< ? php function myXOR ( $ x , $ y ) { return ( $ x $ y ) & ( ~ $ x ~ $ y ) ; } $ x = 3 ; $ y = 5 ; echo \" XOR \u2581 is \u2581 \" , myXOR ( $ x , $ y ) ; ? >"}
{"text":"Freivald\u00e2 \u20ac\u2122 s Algorithm to check if a matrix is product of two | PHP code to implement FreivaldaTMs Algorithm ; Function to check if ABx = Cx ; Generate a random vector ; Now comput B * r for evaluating expression A * ( B * r ) - ( C * r ) ; Now comput C * r for evaluating expression A * ( B * r ) - ( C * r ) ; Now comput A * ( B * r ) for evaluating expression A * ( B * r ) - ( C * r ) ; Finally check if value of expression A * ( B * r ) - ( C * r ) is 0 or not ; Runs k iterations Freivald . The value of k determines accuracy . Higher value means higher accuracy . ; Driver code","code":"< ? php $ N = 2 ; function freivald ( $ a , $ b , $ c ) { global $ N ; $ r = array ( ) ; $ br = array ( ) ; $ cr = array ( ) ; $ axbr = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r [ $ i ] = mt_rand ( ) % 2 ; $ br [ $ i ] = 0 ; $ cr [ $ i ] = 0 ; $ axbr [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ br [ $ i ] = $ br [ $ i ] + $ b [ $ i ] [ $ j ] * $ r [ $ j ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ cr [ $ i ] = $ cr [ $ i ] + $ c [ $ i ] [ $ j ] * $ r [ $ j ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ axbr [ $ i ] = $ axbr [ $ i ] + $ a [ $ i ] [ $ j ] * $ br [ $ j ] ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ axbr [ $ i ] - $ cr [ $ i ] != 0 ) return false ; return true ; } function isProduct ( $ a , $ b , $ c , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( freivald ( $ a , $ b , $ c ) == false ) return false ; return true ; } $ a = array ( array ( 1 , 1 ) , array ( 1 , 1 ) ) ; $ b = array ( array ( 1 , 1 ) , array ( 1 , 1 ) ) ; $ c = array ( array ( 2 , 2 ) , array ( 2 , 2 ) ) ; $ k = 2 ; if ( isProduct ( $ a , $ b , $ c , $ k ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text":"Expectation or expected value of an array | Function to calculate expectation ; variable prb is for probability of each element which is same for each element ; calculating expectation overall ; returning expectation as sum ; Driver Code ; Function for calculating expectation ; Display expectation of given array","code":"< ? php function calc_Expectation ( $ a , $ n ) { $ prb = ( 1 \/ $ n ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] * $ prb ; return $ sum ; } $ n = 6.0 ; $ a = array ( 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 ) ; $ expect = calc_Expectation ( $ a , $ n ) ; echo \" Expectation \u2581 of \u2581 array \u2581 E ( X ) \u2581 is \u2581 : \u2581 \" . $ expect . \" STRNEWLINE \" ; ? >"}
{"text":"Choose points from two ranges such that no point lies in both the ranges | Function to find the required points ; Driver code","code":"< ? php function findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) { $ x = ( $ l1 != $ l2 ) ? min ( $ l1 , $ l2 ) : -1 ; $ y = ( $ r1 != $ r2 ) ? max ( $ r1 , $ r2 ) : -1 ; echo $ x , \" \" , $ y ; } $ l1 = 5 ; $ r1 = 10 ; $ l2 = 1 ; $ r2 = 7 ; findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) ; ? >"}
{"text":"Tail Recursion | A NON - tail - recursive function . The function is not tail recursive because the value returned by fact ( n - 1 ) is used in fact ( n ) and call to fact ( n - 1 ) is not the last thing done by fact ( n ) ; Driver Code","code":"< ? php function fact ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * fact ( $ n - 1 ) ; } echo fact ( 5 ) ; ? >"}
{"text":"Print numbers in descending order along with their frequencies | Function to print the elements in descending along with their frequencies ; Sorts the element in decreasing order ; traverse the array elements ; Prints the number and count ; Prints the last step ; Driver Code","code":"< ? php function printElements ( & $ a , $ n ) { rsort ( $ a ) ; $ cnt = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] != $ a [ $ i + 1 ] ) { echo ( $ a [ $ i ] ) ; echo ( \" \u2581 occurs \u2581 \" ) ; echo $ cnt ; echo ( \" \u2581 times STRNEWLINE \" ) ; $ cnt = 1 ; } else $ cnt += 1 ; } echo ( $ a [ $ n - 1 ] ) ; echo ( \" \u2581 occurs \u2581 \" ) ; echo $ cnt ; echo ( \" \u2581 times STRNEWLINE \" ) ; } $ a = array ( 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ) ; $ n = sizeof ( $ a ) ; printElements ( $ a , $ n ) ; ? >"}
{"text":"Find element position in given monotonic sequence | PHP implementation of the approach from math import log2 , floor ; Function to return the value of f ( n ) for given values of a , b , c , n ; if c is 0 , then value of n can be in order of 10 ^ 15. if c != 0 , then n ^ 3 value has to be in order of 10 ^ 18 so maximum value of n can be 10 ^ 6. ; for efficient searching , use binary search . ; Driver code","code":"< ? php $ SMALL_N = 1000000 ; $ LARGE_N = 1000000000000000 ; function func ( $ a , $ b , $ c , $ n ) { $ res = $ a * $ n ; $ logVlaue = floor ( log ( $ n , 2 ) ) ; $ res += $ b * $ n * $ logVlaue ; $ res += $ c * ( $ n * $ n * $ n ) ; return $ res ; } function getPositionInSeries ( $ a , $ b , $ c , $ k ) { global $ SMALL_N , $ LARGE_N ; $ start = 1 ; $ end = $ SMALL_N ; if ( $ c == 0 ) $ end = $ LARGE_N ; $ ans = 0 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) \/ 2 ) ; $ val = func ( $ a , $ b , $ c , $ mid ) ; if ( $ val == $ k ) { $ ans = $ mid ; break ; } else if ( $ val > $ k ) $ end = $ mid - 1 ; else $ start = $ mid + 1 ; } return $ ans ; } $ a = 2 ; $ b = 1 ; $ c = 1 ; $ k = 12168587437017 ; print ( getPositionInSeries ( $ a , $ b , $ c , $ k ) ) ; ? >"}
{"text":"Check whether ( i , j ) exists such that arr [ i ] != arr [ j ] and arr [ arr [ i ] ] is equal to arr [ arr [ j ] ] | Function that will tell whether such Indices present or Not . ; Checking 1 st condition i . e whether Arr [ i ] equal to Arr [ j ] or not ; Checking 2 nd condition i . e whether Arr [ Arr [ i ] ] equal to Arr [ Arr [ j ] ] or not . ; Driver Code ; Calling function .","code":"< ? php function checkIndices ( $ Arr , $ N ) { for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( $ Arr [ $ i ] != $ Arr [ $ j ] ) { if ( $ Arr [ $ Arr [ $ i ] - 1 ] == $ Arr [ $ Arr [ $ j ] - 1 ] ) return true ; } } } return false ; } $ Arr = array ( 3 , 2 , 1 , 1 , 4 ) ; $ N = sizeof ( $ Arr ) ; if ( checkIndices ( $ Arr , $ N ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Print all pairs with given sum | Returns number of pairs in arr [ 0. . n - 1 ] with sum equal to ' sum ' ; Initialize result ; Consider all possible pairs and check their sums ; Driver Code","code":"< ? php function printPairs ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) echo \" ( \" , $ arr [ $ i ] , \" , \u2581 \" , $ arr [ $ j ] , \" ) \" , \" STRNEWLINE \" ; } $ arr = array ( 1 , 5 , 7 , -1 , 5 ) ; $ n = sizeof ( $ arr ) ; $ sum = 6 ; printPairs ( $ arr , $ n , $ sum ) ; ? >"}
{"text":"Making elements distinct in a sorted array by minimum increments | To find minimum sum of unique elements . ; While current element is same as previous or has become smaller than previous . ; Driver code","code":"< ? php function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { $ j = $ i ; while ( $ j < $ n && $ arr [ $ j ] <= $ arr [ $ j - 1 ] ) { $ arr [ $ j ] = $ arr [ $ j ] + 1 ; $ j ++ ; } } $ sum = $ sum + $ arr [ $ i ] ; } return $ sum ; } $ arr = array ( 2 , 2 , 3 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; echo minSum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Making elements distinct in a sorted array by minimum increments | To find minimum sum of unique elements . ; If violation happens , make current value as 1 plus previous value and add to sum . ; No violation . ; Driver code","code":"< ? php function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= $ prev ) { $ prev = $ prev + 1 ; $ sum = $ sum + $ prev ; } else { $ sum = $ sum + $ arr [ $ i ] ; $ prev = $ arr [ $ i ] ; } } return $ sum ; } $ arr = array ( 2 , 2 , 3 , 5 , 6 ) ; $ n = count ( $ arr ) ; echo minSum ( $ arr , $ n ) ; ? >"}
{"text":"Pandigital Product | To check the string formed from multiplicand , multiplier and product is pandigital ; calculate the multiplicand , multiplier , and product eligible for pandigital ; Driver Code","code":"< ? php function isPandigital ( $ str ) { if ( strlen ( $ str ) != 9 ) return false ; $ x = str_split ( $ str ) ; sort ( $ x ) ; $ x = implode ( $ x ) ; return strcmp ( $ x , \"123456789\" ) ; } function PandigitalProduct_1_9 ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 && isPandigital ( strval ( $ n ) . strval ( $ i ) . strval ( ( int ) ( $ n \/ $ i ) ) ) ) return true ; return false ; } $ n = 6050 ; if ( PandigitalProduct_1_9 ( $ n ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text":"Median and Mode using Counting Sort | Function that sort input array a [ ] and calculate mode and median using counting sort . ; The output array b [ ] will have sorted array ; variable to store max of input array which will to have size of count array ; auxiliary ( count ) array to store count . Initialize count array as 0. Size of count array will be equal to ( max + 1 ) . ; Store count of each element of input array ; mode is the index with maximum count ; Update count [ ] array with sum ; Sorted output array b [ ] to calculate median ; Median according to odd and even array size respectively . ; Output the result ; Driver Code","code":"< ? php function printModeMedian ( $ a , $ n ) { $ b [ $ n ] = array ( ) ; $ max = max ( $ a ) ; $ t = $ max + 1 ; $ count [ $ t ] = array ( ) ; for ( $ i = 0 ; $ i < $ t ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ $ a [ $ i ] ] ++ ; $ mode = 0 ; $ k = $ count [ 0 ] ; for ( $ i = 1 ; $ i < $ t ; $ i ++ ) { if ( $ count [ $ i ] > $ k ) { $ k = $ count [ $ i ] ; $ mode = $ i ; } } for ( $ i = 1 ; $ i < $ t ; $ i ++ ) $ count [ $ i ] = $ count [ $ i ] + $ count [ $ i - 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b [ $ count [ $ a [ $ i ] ] - 1 ] = $ a [ $ i ] ; $ count [ $ a [ $ i ] ] -- ; } $ median ; if ( $ n % 2 != 0 ) $ median = $ b [ $ n \/ 2 ] ; else $ median = ( $ b [ ( $ n - 1 ) \/ 2 ] + $ b [ ( $ n \/ 2 ) ] ) \/ 2.0 ; echo \" median = \" , \u2581 $ median , \u2581 \" \" \u2581 ; STRNEWLINE TABSYMBOL echo \u2581 \" mode = \" } $ a = array ( 1 , 4 , 1 , 2 , 7 , 1 , 2 , 5 , 3 , 6 ) ; $ n = sizeof ( $ a ) ; printModeMedian ( $ a , $ n ) ; ? >"}
{"text":"Check if both halves of the string have at least one different character | PHP implementation to check if both halves of the string have at least one different character ; Function which break string into two halves Counts frequency of characters in each half Compares the two counter array and returns true if these counter arrays differ ; Declaration and initialization of counter array ; Driver function","code":"< ? php $ MAX = 26 ; function function_1 ( $ str ) { global $ MAX ; $ l = strlen ( $ str ) ; $ counter1 = array_fill ( 0 , $ MAX , NULL ) ; $ counter2 = array_fill ( 0 , $ MAX , NULL ) ; for ( $ i = 0 ; $ i < $ l \/ 2 ; $ i ++ ) $ counter1 [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = $ l \/ 2 ; $ i < $ l ; $ i ++ ) $ counter2 [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) if ( $ counter2 [ $ i ] != $ counter1 [ $ i ] ) return true ; return false ; } $ str = \" abcasdsabcae \" ; if ( function_1 ( $ str ) ) echo \" Yes , \u2581 both \u2581 halves \u2581 differ \" . \" \u2581 by \u2581 at \u2581 least \u2581 one \u2581 character \" ; else echo \" No , \u2581 both \u2581 halves \u2581 do \u2581 \" . \" not \u2581 differ \u2581 at \u2581 all \" ; return 0 ; ? >"}
{"text":"Minimum difference between max and min of all K | returns min difference between max and min of any K - size subset ; sort the array so that close elements come together . ; initialize result by a big integer number ; loop over first ( N - K ) elements of the array only ; get difference between max and min of current K - sized segment ; Driver Code","code":"< ? php function minDifferenceAmongMaxMin ( $ arr , $ N , $ K ) { $ INT_MAX = 2 ; sort ( $ arr ) ; sort ( $ arr , $ N ) ; $ res = $ INT_MAX ; for ( $ i = 0 ; $ i <= ( $ N - $ K ) ; $ i ++ ) { $ curSeqDiff = $ arr [ $ i + $ K - 1 ] - $ arr [ $ i ] ; $ res = min ( $ res , $ curSeqDiff ) ; } return $ res ; } $ arr = array ( 10 , 20 , 30 , 100 , 101 , 102 ) ; $ N = sizeof ( $ arr ) ; $ K = 3 ; echo minDifferenceAmongMaxMin ( $ arr , $ N , $ K ) ; ? >"}
{"text":"Position of an element after stable sort | Method returns the position of arr [ idx ] after performing stable - sort on array ; Count of elements smaller than current element plus the equal element occurring before given index ; If element is smaller then increase the smaller count ; If element is equal then increase count only if it occurs before ; Driver Code","code":"< ? php function getIndexInSortedArray ( $ arr , $ n , $ idx ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ idx ] ) $ result ++ ; if ( $ arr [ $ i ] == $ arr [ $ idx ] and $ i < $ idx ) $ result ++ ; } return $ result ; } $ arr = array ( 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 ) ; $ n = count ( $ arr ) ; $ idxOfEle = 5 ; echo getIndexInSortedArray ( $ arr , $ n , $ idxOfEle ) ; ? >"}
{"text":"Find the maximum possible value of a [ i ] % a [ j ] over all pairs of i and j | Function that returns the second largest element in the array if exists , else 0 ; There must be at least two elements ; To store the maximum and the second maximum element from the array ; If current element is greater than first then update both first and second ; If arr [ i ] is in between first and second then update second ; No second maximum found ; Driver code","code":"< ? php function getMaxValue ( $ arr , $ arr_size ) { if ( $ arr_size < 2 ) { return 0 ; } $ first = $ second = - ( PHP_INT_MAX - 1 ) ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] != $ first ) $ second = $ arr [ $ i ] ; } if ( $ second == - ( PHP_INT_MAX - 1 ) ) return 0 ; else return $ second ; } $ arr = array ( 4 , 5 , 1 , 8 ) ; $ n = count ( $ arr ) ; echo getMaxValue ( $ arr , $ n ) ; ? >"}
{"text":"Maximize the value of the given expression | Function to return the maximum result ; To store the count of negative integers ; Sum of all the three integers ; Product of all the three integers ; To store the smallest and the largest among all the three integers ; Calculate the count of negative integers ; Depending upon count of negatives ; When all three are positive integers ; For single negative integer ; For two negative integers ; For three negative integers ; Driver Code","code":"< ? php function maximumResult ( $ a , $ b , $ c ) { $ countOfNegative = 0 ; $ sum = $ a + $ b + $ c ; $ product = $ a * $ b * $ c ; $ largest = max ( $ a , $ b , $ c ) ; $ smallest = min ( $ a , $ b , $ c ) ; if ( $ a < 0 ) $ countOfNegative ++ ; if ( $ b < 0 ) $ countOfNegative ++ ; if ( $ c < 0 ) $ countOfNegative ++ ; switch ( $ countOfNegative ) { case 0 : return ( $ sum - $ largest ) * $ largest ; case 1 : return ( $ product \/ $ smallest ) + $ smallest ; case 2 : return ( $ product \/ $ largest ) + $ largest ; case 3 : return ( $ sum - $ smallest ) * $ smallest ; } } $ a = -2 ; $ b = -1 ; $ c = -4 ; echo maximumResult ( $ a , $ b , $ c ) ; ? >"}
{"text":"Maximum students to pass after giving bonus to everybody and not exceeding 100 marks | Function to return the number of students that can pass ; maximum marks ; maximum bonus marks that can be given ; counting the number of students that can pass ; Driver code","code":"< ? php function check ( $ n , $ marks ) { $ x = max ( $ marks ) ; $ bonus = 100 - $ x ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ marks [ $ i ] + $ bonus >= 50 ) $ c += 1 ; } return $ c ; } $ n = 5 ; $ marks = array ( 0 , 21 , 83 , 45 , 64 ) ; echo check ( $ n , $ marks ) ;"}
{"text":"Sum of first N natural numbers which are not powers of K | Function to return the sum of first n natural numbers which are not positive powers of k ; sum of first n natural numbers ; subtract all positive powers of k which are less than n ; next power of k ; Driver code","code":"< ? php function find_sum ( $ n , $ k ) { $ total_sum = ( $ n * ( $ n + 1 ) ) \/ 2 ; $ power = $ k ; while ( $ power <= $ n ) { $ total_sum -= $ power ; $ power *= $ k ; } return $ total_sum ; } $ n = 11 ; $ k = 2 ; echo find_sum ( $ n , $ k ) ; ? >"}
{"text":"Minimum number of operations required to delete all elements of the array | function to find minimum operations ; sort array ; prepare hash of array ; Driver Code","code":"< ? php function minOperations ( & $ arr , $ n ) { $ hashTable = array ( ) ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ hashTable [ $ arr [ $ i ] ] ++ ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ hashTable [ $ arr [ $ i ] ] ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] % $ arr [ $ i ] == 0 ) $ hashTable [ $ arr [ $ j ] ] = 0 ; $ res ++ ; } } return $ res ; } $ arr = array ( 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ) ; $ n = sizeof ( $ arr ) ; echo minOperations ( $ arr , $ n ) ; ? >"}
{"text":"Sorting array with reverse around middle | PHP program to find possibility to sort by multiple subarray reverse operarion ; making the copy of the original array ; sorting the copied array ; checking mirror image of elements of sorted copy array and equivalent element of original array ; Driver code","code":"< ? php function ifPossible ( & $ arr , $ n ) { $ cp = array ( ) ; $ cp = $ arr ; sort ( $ cp ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! ( $ arr [ $ i ] == $ cp [ $ i ] ) && ! ( $ arr [ $ n - 1 - $ i ] == $ cp [ $ i ] ) ) return false ; } return true ; } $ arr = array ( 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 ) ; $ n = sizeof ( $ arr ) ; if ( ifPossible ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum cost to reach end of array array when a maximum jump of K index is allowed | Function to return the minimum cost to reach the last index ; If we reach the last index ; Already visited state ; Initially maximum ; Visit all possible reachable index ; If inside range ; We cannot move any further ; Memoize ; Driver Code","code":"< ? php function FindMinimumCost ( $ ind , $ a , $ n , $ k , $ dp ) { if ( $ ind == ( $ n - 1 ) ) return 0 ; else if ( $ dp [ $ ind ] != -1 ) return $ dp [ $ ind ] ; else { $ ans = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( $ ind + $ i < $ n ) $ ans = min ( $ ans , abs ( $ a [ $ ind + $ i ] - $ a [ $ ind ] ) + FindMinimumCost ( $ ind + $ i , $ a , $ n , $ k , $ dp ) ) ; else break ; } return $ dp [ $ ind ] = $ ans ; } } $ a = array ( 10 , 30 , 40 , 50 , 20 ) ; $ k = 3 ; $ n = sizeof ( $ a ) ; $ dp = array ( ) ; $ dp = array_fill ( 0 , $ n , -1 ) ; echo ( FindMinimumCost ( 0 , $ a , $ n , $ k , $ dp ) ) ; ? >"}
{"text":"Sum of all even factors of numbers in the range [ l , r ] | PHP implementation of the approach ; Function to calculate the prefix sum of all the even factors ; Add i to all the multiples of i ; Update the prefix sum ; Function to return the sum of all the even factors of the numbers in the given range ; Driver code","code":"< ? php $ MAX = 10000 ; $ prefix = array_fill ( 0 , $ MAX , 0 ) ; function sieve_modified ( ) { global $ MAX , $ prefix ; for ( $ i = 2 ; $ i < $ MAX ; $ i += 2 ) { for ( $ j = $ i ; $ j < $ MAX ; $ j += $ i ) $ prefix [ $ j ] += $ i ; } for ( $ i = 1 ; $ i < $ MAX ; $ i ++ ) $ prefix [ $ i ] += $ prefix [ $ i - 1 ] ; } function sumEvenFactors ( $ L , $ R ) { global $ MAX , $ prefix ; return ( $ prefix [ $ R ] - $ prefix [ $ L - 1 ] ) ; } sieve_modified ( ) ; $ l = 6 ; $ r = 10 ; echo sumEvenFactors ( $ l , $ r ) ; ? >"}
{"text":"Balanced expressions such that given positions have opening brackets | Set 2 | Function to find Number of proper bracket expressions ; If open - closed brackets < 0 ; If index reaches the end of expression ; If brackets are balanced ; If already stored in dp ; If the current index has assigned open bracket ; Move forward increasing the length of open brackets ; Move forward by inserting open as well as closed brackets on that index ; return the answer ; DP array to precompute the answer ; Open brackets at position 1 ; Calling the find function to calculate the answer","code":"< ? php function find ( $ index , $ openbrk , $ n , & $ dp , & $ adj ) { if ( $ openbrk < 0 ) return 0 ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) return 1 ; else return 0 ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; if ( $ adj [ $ index ] == 1 ) { $ dp [ $ index ] [ $ openbrk ] = find ( $ index + 1 , $ openbrk + 1 , $ n , $ dp , $ adj ) ; } else { $ dp [ $ index ] [ $ openbrk ] = find ( $ index + 1 , $ openbrk + 1 , $ n , $ dp , $ adj ) + find ( $ index + 1 , $ openbrk - 1 , $ n , $ dp , $ adj ) ; } return $ dp [ $ index ] [ $ openbrk ] ; } $ N = 1000 ; $ dp = array ( array ( ) ) ; $ n = 2 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = -1 ; } } $ adj = array ( 1 , 0 , 0 , 0 ) ; echo find ( 0 , 0 , 2 * $ n , $ dp , $ adj ) . \" STRNEWLINE \" ; ? >"}
{"text":"Maximize array elements upto given number | Utility function to find maximum possible value ; If entire array is traversed , then compare current value in num to overall maximum obtained so far . ; Case 1 : Subtract current element from value so far if result is greater than or equal to zero . ; Case 2 : Add current element to value so far if result is less than or equal to maxLimit . ; Function to find maximum possible value that can be obtained using array elements and given number . ; variable to store maximum value that can be obtained . ; variable to store current index position . ; call to utility function to find maximum possible value that can be obtained . ; Driver code","code":"< ? php function findMaxValUtil ( $ arr , $ n , $ num , $ maxLimit , $ ind , & $ ans ) { if ( $ ind == $ n ) { $ ans = max ( $ ans , $ num ) ; return ; } if ( $ num - $ arr [ $ ind ] >= 0 ) { findMaxValUtil ( $ arr , $ n , $ num - $ arr [ $ ind ] , $ maxLimit , $ ind + 1 , $ ans ) ; } if ( $ num + $ arr [ $ ind ] <= $ maxLimit ) { findMaxValUtil ( $ arr , $ n , $ num + $ arr [ $ ind ] , $ maxLimit , $ ind + 1 , $ ans ) ; } } function findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) { $ ans = 0 ; $ ind = 0 ; findMaxValUtil ( $ arr , $ n , $ num , $ maxLimit , $ ind , $ ans ) ; return $ ans ; } $ num = 1 ; $ arr = array ( 3 , 10 , 6 , 4 , 5 ) ; $ n = count ( $ arr ) ; $ maxLimit = 15 ; echo ( findMaxVal ( $ arr , $ n , $ num , $ maxLimit ) ) ; ? >"}
{"text":"Print equal sum sets of array ( Partition problem ) | Set 1 | Function to print the equal sum sets of the array . ; Print set 1. ; Print set 2. ; Utility function to find the sets of the array which have equal sum . ; If entire array is traversed , compare both the sums . ; If sums are equal print both sets and return true to show sets are found . ; If sums are not equal then return sets are not found . ; Add current element to set 1. ; Recursive call after adding current element to set 1. ; If this inclusion results in equal sum sets partition then return true to show desired sets are found . ; If not then backtrack by removing current element from set1 and include it in set 2. ; Recursive call after including current element to set 2. ; Return true if array arr can be partitioned into two equal sum sets or not . ; Calculate sum of elements in array . ; If sum is odd then array cannot be partitioned . ; Declare vectors to store both the sets . ; Find both the sets . ; Driver code","code":"< ? php function printSets ( $ set1 , $ set2 ) { $ i = 0 ; for ( $ i = 0 ; $ i < count ( $ set1 ) ; $ i ++ ) { echo ( $ set1 [ $ i ] . \" \" ) ; } echo ( \" STRNEWLINE \" ) ; for ( $ i = 0 ; $ i < count ( $ set2 ) ; $ i ++ ) { echo ( $ set2 [ $ i ] . \" \" ) ; } } function findSets ( $ arr , $ n , & $ set1 , & $ set2 , $ sum1 , $ sum2 , $ pos ) { if ( $ pos == $ n ) { if ( $ sum1 == $ sum2 ) { printSets ( $ set1 , $ set2 ) ; return true ; } else return false ; } array_push ( $ set1 , $ arr [ $ pos ] ) ; $ res = findSets ( $ arr , $ n , $ set1 , $ set2 , $ sum1 + $ arr [ $ pos ] , $ sum2 , $ pos + 1 ) ; if ( $ res ) return $ res ; array_pop ( $ set1 ) ; array_push ( $ set2 , $ arr [ $ pos ] ) ; return findSets ( $ arr , $ n , $ set1 , $ set2 , $ sum1 , $ sum2 + $ arr [ $ pos ] , $ pos + 1 ) ; } function isPartitionPoss ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( $ sum % 2 != 0 ) return false ; $ set1 = array ( ) ; $ set2 = array ( ) ; return findSets ( $ arr , $ n , $ set1 , $ set2 , 0 , 0 , 0 ) ; } $ arr = array ( 5 , 5 , 1 , 11 ) ; $ n = count ( $ arr ) ; if ( isPartitionPoss ( $ arr , $ n ) == false ) echo ( \" - 1\" ) ; ? >"}
{"text":"Maximum subarray sum in O ( n ) using prefix sum | Function to compute maximum subarray sum in linear time . ; Initialize minimum prefix sum to 0. ; Initialize maximum subarray sum so far to - infinity . ; Initialize and compute the prefix sum array . ; loop through the array , keep track of minimum prefix sum so far and maximum subarray sum . ; Test case 1 ; Test case 2","code":"< ? php function maximumSumSubarray ( $ arr , $ n ) { $ min_prefix_sum = 0 ; $ res = PHP_INT_MIN ; $ prefix_sum = array ( ) ; $ prefix_sum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prefix_sum [ $ i ] = $ prefix_sum [ $ i - 1 ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res = max ( $ res , $ prefix_sum [ $ i ] - $ min_prefix_sum ) ; $ min_prefix_sum = min ( $ min_prefix_sum , $ prefix_sum [ $ i ] ) ; } return $ res ; } $ arr1 = array ( -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 ) ; $ n1 = count ( $ arr1 ) ; echo maximumSumSubarray ( $ arr1 , $ n1 ) , \" \" ; $ arr2 = array ( 4 , -8 , 9 , -4 , 1 , -8 , -1 , 6 ) ; $ n2 = count ( $ arr2 ) ; echo maximumSumSubarray ( $ arr2 , $ n2 ) ; ? >"}
{"text":"Counting numbers of n digits that are monotone | PHP program to count numbers of n digits that are monotone . ; Considering all possible digits as { 1 , 2 , 3 , . .9 } ; DP [ i ] [ j ] is going to store monotone numbers of length i + 1 considering j + 1 digits . ; Unit length numbers ; Single digit numbers ; Filling rest of the entries in bottom up manner . ; Driver code","code":"< ? php function getNumMonotone ( $ len ) { $ DP_s = 9 ; $ DP = array ( array_fill ( 0 , $ len , 0 ) , array_fill ( 0 , $ len , 0 ) ) ; for ( $ i = 0 ; $ i < $ DP_s ; ++ $ i ) $ DP [ 0 ] [ $ i ] = $ i + 1 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) $ DP [ $ i ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ len ; ++ $ i ) for ( $ j = 1 ; $ j < $ DP_s ; ++ $ j ) $ DP [ $ i ] [ $ j ] = $ DP [ $ i - 1 ] [ $ j ] + $ DP [ $ i ] [ $ j - 1 ] ; return $ DP [ $ len - 1 ] [ $ DP_s - 1 ] ; } echo getNumMonotone ( 10 ) ; ? >"}
{"text":"Newman | Function to find the n - th element ; Declare array to store sequence ; Driver Code","code":"< ? php function sequence ( $ n ) { $ i ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ f [ $ i ] = $ f [ $ f [ $ i - 1 ] ] + $ f [ $ i - $ f [ $ i - 1 ] ] ; return $ f [ $ n ] ; } $ n = 10 ; echo ( sequence ( $ n ) ) ; ? >"}
{"text":"Maximum product of an increasing subsequence | Returns product of maximum product increasing subsequence . ; Initialize MPIS values ; Compute optimized MPIS values considering every element as ending element of sequence ; Pick maximum of all product values ; Driver program to test above function","code":"< ? php function lis ( & $ arr , $ n ) { $ mpis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mpis [ $ i ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ mpis [ $ i ] < ( $ mpis [ $ j ] * $ arr [ $ i ] ) ) $ mpis [ $ i ] = $ mpis [ $ j ] * $ arr [ $ i ] ; return max ( $ mpis ) ; } $ arr = array ( 3 , 100 , 4 , 5 , 150 , 6 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo lis ( $ arr , $ n ) ; return 0 ; ? >"}
{"text":"Hosoya 's Triangle | PHP Program to print Hosoya 's triangle of height n. ; Base case ; Recursive step ; Print the Hosoya triangle of height n . ; Driven Code","code":"< ? php function Hosoya ( int $ n , int $ m ) { if ( ( $ n == 0 && $ m == 0 ) || ( $ n == 1 && $ m == 0 ) || ( $ n == 1 && $ m == 1 ) || ( $ n == 2 && $ m == 1 ) ) return 1 ; if ( $ n > $ m ) return Hosoya ( $ n - 1 , $ m ) + Hosoya ( $ n - 2 , $ m ) ; else if ( $ m == $ n ) return Hosoya ( $ n - 1 , $ m - 1 ) + Hosoya ( $ n - 2 , $ m - 2 ) ; else return 0 ; } function printHosoya ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) echo Hosoya ( $ i , $ j ) , \" \u2581 \" ; echo \" STRNEWLINE \" ; } } $ n = 5 ; printHosoya ( $ n ) ; ? >"}
{"text":"Eulerian Number | Return euleriannumber A ( n , m ) ; Driven Code","code":"< ? php function eulerian ( $ n , $ m ) { if ( $ m >= $ n $ n == 0 ) return 0 ; if ( $ m == 0 ) return 1 ; return ( $ n - $ m ) * eulerian ( $ n - 1 , $ m - 1 ) + ( $ m + 1 ) * eulerian ( $ n - 1 , $ m ) ; } $ n = 3 ; $ m = 1 ; echo eulerian ( $ n , $ m ) ; ? >"}
{"text":"Largest divisible pairs subset | function to find the longest Subsequence ; dp [ i ] is going to store size of largest divisible subset beginning with a [ i ] . ; Since last element is largest , d [ n - 1 ] is 1 ; Fill values for smaller elements . ; Find all multiples of a [ i ] and consider the multiple that has largest subset beginning with it . ; Return maximum value from dp [ ] ; Driver Code","code":"< ? php function largestSubset ( $ a , $ n ) { $ dp = array ( ) ; $ dp [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ mxm = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] == 0 or $ a [ $ i ] % $ a [ $ j ] == 0 ) $ mxm = max ( $ mxm , $ dp [ $ j ] ) ; $ dp [ $ i ] = 1 + $ mxm ; } return max ( $ dp ) ; } $ a = array ( 1 , 3 , 6 , 13 , 17 , 18 ) ; $ n = count ( $ a ) ; echo largestSubset ( $ a , $ n ) ; ? >"}
{"text":"Friends Pairing Problem | Returns count of ways n people can remain single or paired up . ; Filling dp [ ] in bottom - up manner using recursive formula explained above . ; Driver code","code":"< ? php function countFriendsPairings ( $ n ) { $ dp [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ i <= 2 ) $ dp [ $ i ] = $ i ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; } $ n = 4 ; echo countFriendsPairings ( $ n ) ; ? >"}
{"text":"Friends Pairing Problem | Returns count of ways n people can remain single or paired up . ; Driver code","code":"< ? php function countFriendsPairings ( $ n ) { $ a = 1 ; $ b = 2 ; $ c = 0 ; if ( $ n <= 2 ) { return $ n ; } for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = $ b + ( $ i - 1 ) * $ a ; $ a = $ b ; $ b = $ c ; } return $ c ; } $ n = 4 ; print ( countFriendsPairings ( $ n ) ) ; ? >"}
{"text":"LCS ( Longest Common Subsequence ) of three strings | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] and Z [ 0. . o - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] [ o + 1 ] in bottom up fashion . Note that L [ i ] [ j ] [ k ] contains length of LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] and Z [ 0. . ... k - 1 ] ; L [ m ] [ n ] [ o ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] and Z [ 0. . o - 1 ] ; Driver code","code":"< ? php function lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) { $ L [ $ m + 1 ] [ $ n + 1 ] [ $ o + 1 ] = array ( array ( array ( ) ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ o ; $ k ++ ) { if ( $ i == 0 $ j == 0 $ k == 0 ) $ L [ $ i ] [ $ j ] [ $ k ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] && $ X [ $ i - 1 ] == $ Z [ $ k - 1 ] ) $ L [ $ i ] [ $ j ] [ $ k ] = $ L [ $ i - 1 ] [ $ j - 1 ] [ $ k - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] [ $ k ] = max ( max ( $ L [ $ i - 1 ] [ $ j ] [ $ k ] , $ L [ $ i ] [ $ j - 1 ] [ $ k ] ) , $ L [ $ i ] [ $ j ] [ $ k - 1 ] ) ; } } } return $ L [ $ m ] [ $ n ] [ $ o ] ; } $ X = \" AGGT12\" ; $ Y = \"12TXAYB \" ; $ Z = \"12XBA \" ; $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ o = strlen ( $ Z ) ; echo \" Length \u2581 of \u2581 LCS \u2581 is \u2581 \" . lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) ; ? >"}
{"text":"Longest Repeating Subsequence | This function mainly returns LCS ( str , str ) with a condition that same characters at same index are not considered . ; Create and initialize DP table ; Fill dp table ( similar to LCS loops ) ; If characters match and indexes are not same ; If characters do not match ; Driver Code","code":"< ? php function findLongestRepeatingSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } } return $ dp [ $ n ] [ $ n ] ; } $ str = \" aabb \" ; echo \" The \u2581 length \u2581 of \u2581 the \u2581 largest \u2581 \" . \" subsequence \u2581 that \u2581 repeats \u2581 itself \u2581 is \u2581 : \u2581 \" , findLongestRepeatingSubSeq ( $ str ) ; ? >"}
{"text":"Count all possible paths from top left to bottom right of a mXn matrix | Returns count of possible paths to reach cell at row number m and column number n from the topmost leftmost cell ( cell at 1 , 1 ) ; Create a 1D array to store results of subproblems ; Driver Code","code":"< ? php function numberOfPaths ( $ m , $ n ) { $ dp = array ( ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { $ dp [ $ j ] += $ dp [ $ j - 1 ] ; } } return $ dp [ $ n - 1 ] ; } echo numberOfPaths ( 3 , 3 ) ; ? >"}
{"text":"Find Nth term of series 1 , 4 , 15 , 72 , 420. . . | Function to find factorial of N with recursion ; base condition ; use recursion ; calculate Nth term of series ; Driver Code","code":"< ? php function factorial ( $ N ) { if ( $ N == 0 or $ N == 1 ) return 1 ; return $ N * factorial ( $ N - 1 ) ; } function nthTerm ( $ N ) { return ( factorial ( $ N ) * ( $ N + 2 ) \/ 2 ) ; } $ N = 6 ; echo nthTerm ( $ N ) ; ? >"}
{"text":"Character whose frequency is equal to the sum of frequencies of other characters of the given string | Function that returns true if some character exists in the given string whose frequency is equal to the sum frequencies of other characters of the string ; If string is of odd length ; To store the frequency of each character of the string ; Update the frequencies of the characters ; No such character exists ; Driver code","code":"< ? php function isFrequencyEqual ( $ str , $ len ) { if ( $ len % 2 == 1 ) return false ; $ freq = array ( ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ freq [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - 97 ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ freq [ $ i ] == $ len \/ 2 ) return true ; return false ; } $ str = \" geeksforgeeks \" ; $ len = strlen ( $ str ) ; if ( isFrequencyEqual ( $ str , $ len ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum replacements to make adjacent characters unequal in a ternary string | Function to count the number of minimal replacements ; Find the length of the string ; Iterate in the string ; Check if adjacent is similar ; If not the last pair ; Check for character which is not same in i + 1 and i - 1 ; else Last pair ; Check for character which is not same in i - 1 index ; Driver Code","code":"< ? php function countMinimalReplacements ( $ s ) { $ n = strlen ( $ s ) ; $ cnt = 0 ; $ str = \"012\" ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ cnt += 1 ; if ( $ i != ( $ n - 1 ) ) { for ( $ it = 0 ; $ it < strlen ( $ str ) ; $ it ++ ) { if ( $ str [ $ it ] != $ s [ $ i + 1 ] && $ str [ $ it ] != $ s [ $ i - 1 ] ) { $ s [ $ i ] = $ str [ $ it ] ; break ; } } } { for ( $ it = 0 ; $ it < strlen ( $ str ) ; $ it ++ ) { if ( $ str [ $ it ] != $ s [ $ i - 1 ] ) { $ s [ $ i ] = $ str [ $ it ] ; break ; } } } } } return $ cnt ; } $ s = \"201220211\" ; echo countMinimalReplacements ( $ s ) ; ? >"}
{"text":"Sub | Function that returns the index of next occurrence of the character c in string str starting from index start ; Starting from start ; If current character = c ; Not found ; Function to return the count of required sub - strings ; Stores running count of ' x ' starting from the end ; Next index of ' x ' starting from index 0 ; Next index of ' y ' starting from index 0 ; To store the count of required sub - strings ; If ' y ' appears before ' x ' it won 't contribute to a valid sub-string ; Find next occurrence of ' y ' ; If ' y ' appears after ' x ' every sub - string ending at an ' x ' appearing after this ' y ' and starting with the current ' x ' is a valid sub - string ; Find next occurrence of ' x ' ; Return the count ; Driver code","code":"< ? php function nextIndex ( $ str , $ start , $ c ) { for ( $ i = $ start ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ c ) return $ i ; } return -1 ; } function countSubStrings ( $ str ) { $ n = strlen ( $ str ) ; $ countX = array ( 0 , $ n , NULL ) ; $ count = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] == ' x ' ) $ count ++ ; $ countX [ $ i ] = $ count ; } $ nextIndexX = nextIndex ( $ str , 0 , ' x ' ) ; $ nextIndexY = nextIndex ( $ str , 0 , ' y ' ) ; $ count = 0 ; while ( $ nextIndexX != -1 && $ nextIndexY != -1 ) { if ( $ nextIndexX > $ nextIndexY ) { $ nextIndexY = nextIndex ( $ str , $ nextIndexY + 1 , ' y ' ) ; continue ; } else { $ count += $ countX [ $ nextIndexY ] ; $ nextIndexX = nextIndex ( $ str , $ nextIndexX + 1 , ' x ' ) ; } } return $ count ; } $ s = \" xyyxx \" ; echo countSubStrings ( $ s ) ; ? >"}
{"text":"Character replacement after removing duplicates from a string | Function to minimize string ; duplicate characters are removed ; checks if character has previously occurred or not if not then add it to the minimized string ' mstr ' ; return $mstr ; minimized string ; Utility function to print the minimized , replaced string ; Creating final string by replacing character ; index calculation ; echo \" Final \u2581 string : \u2581 \" . $finalStr ; final string ; Driver code","code":"< ? php function minimize ( $ str ) { $ mstr = \" \u2581 \" ; $ flagchar = array_fill ( 0 , 26 , 0 ) ; $ l = strlen ( $ str ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ flagchar [ ord ( $ ch ) - 97 ] == 0 ) { $ mstr . = $ ch ; $ flagchar [ ord ( $ ch ) - 97 ] = 1 ; } } } function replaceMinimizeUtil ( $ str ) { $ finalStr = \" \" ; $ l = strlen ( $ str ) ; for ( $ i = 0 ; $ i < strlen ( $ minimizedStr ) ; $ i ++ ) { $ ch = $ minimizedStr [ $ i ] ; $ index = ( ord ( $ ch ) * ord ( $ ch ) ) % $ l ; $ finalStr = $ finalStr . $ str [ $ index ] ; } } $ str = \" geeks \" ; replaceMinimizeUtil ( $ str ) ; ? >"}
{"text":"Latin alphabet cipher | function for calculating the encryption ; Driver Code","code":"< ? php function cipher ( $ str ) { if ( ! ctype_alpha ( $ str ) ) { printf ( \" Enter \u2581 only \u2581 \" + \" alphabets \u2581 and \u2581 space STRNEWLINE \" ) ; return ; } printf ( \" Encrypted \u2581 Code \u2581 using \u2581 \" ) ; printf ( \" Latin \u2581 Alphabet STRNEWLINE \" ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) echo ( ord ( $ str [ $ i ] ) - 65 + 1 ) . \" \u2581 \" ; else if ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) echo ( ord ( $ str [ $ i ] ) - 97 + 1 ) . \" \u2581 \" ; } echo \" STRNEWLINE \" ; } $ str = \" geeksforgeeks \" ; cipher ( $ str ) ; ? >"}
{"text":"Round the given number to nearest multiple of 10 | function to round the number ; Smaller multiple ; Larger multiple ; Return of closest of two ; Driver Code","code":"< ? php function roundFunation ( $ n ) { $ a = ( int ) ( $ n \/ 10 ) * 10 ; $ b = ( $ a + 10 ) ; return ( $ n - $ a > $ b - $ n ) ? $ b : $ a ; } $ n = 4722 ; echo roundFunation ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Number of subsequences as \" ab \" in a string repeated K times | PHP code to find number of subsequences of \" ab \" in the string S which is repeated K times . ; Count of ' a ' s ; Count of ' b ' s ; occurrence of \" ab \" s in string S ; Add following two : 1 ) K * ( Occurrences of \" ab \" in single string ) 2 ) a is from one string and b is from other . ; Driver code","code":"< ? php function countOccurrences ( $ s , $ K ) { $ n = strlen ( $ s ) ; $ C = 0 ; $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ c1 ++ ; if ( $ s [ $ i ] == ' b ' ) { $ c2 ++ ; $ C = $ C + $ c1 ; } } return $ C * $ K + ( $ K * ( $ K - 1 ) \/ 2 ) * $ c1 * $ c2 ; } $ S = \" abcb \" ; $ k = 2 ; echo countOccurrences ( $ S , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"String with k distinct characters and no same characters adjacent | Function to find a string of length n with k distinct characters . ; Initialize result with first k Latin letters ; Fill remaining n - k letters by repeating k letters again and again . ; Driver code","code":"< ? php function findString ( $ n , $ k ) { $ res = \" \" ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ res = $ res . chr ( ord ( ' a ' ) + $ i ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - $ k ; $ i ++ ) { $ res = $ res . chr ( ord ( ' a ' ) + $ count ) ; $ count ++ ; if ( $ count == $ k ) $ count = 0 ; } return $ res ; } $ n = 5 ; $ k = 2 ; echo findString ( $ n , $ k ) ; ? >"}
{"text":"Program to count vowels in a string ( Iterative and Recursive ) | Function to check the Vowel ; to count total number of vowel from 0 to n ; string object ; Total numbers of Vowel","code":"< ? php function isVowel ( $ ch ) { $ ch = strtoupper ( $ ch ) ; return ( $ ch == ' A ' $ ch == ' E ' $ ch == ' I ' $ ch == ' O ' $ ch == ' U ' ) ; } function countVovels ( $ str , $ n ) { if ( $ n == 1 ) return isVowel ( $ str [ $ n - 1 ] ) ; return countVovels ( $ str , $ n - 1 ) + isVowel ( $ str [ $ n - 1 ] ) ; } $ str = \" abc \u2581 de \" ; echo countVovels ( $ str , strlen ( $ str ) ) . \" \" ; ? >"}
{"text":"Generate all rotations of a given string | Print all the rotated string . ; Concatenate str with itself ; Print all substrings of size n . Note that size of temp is 2 n ; Driver code","code":"< ? php function printRotatedString ( $ str ) { $ n = strlen ( $ str ) ; $ temp = $ str . $ str ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j != $ n ; $ j ++ ) print ( $ temp [ $ i + $ j ] ) ; print ( \" STRNEWLINE \" ) ; } } $ str = \" geeks \" ; printRotatedString ( $ str ) ; ? >"}
{"text":"Check if frequency of all characters can become same by one removal | PHP program to get same frequency character string by removal of at most one char ; Utility method to get index of character ch in lower alphabet characters ; Returns true if all non - zero elements values are same ; get first non - zero element ; check equality of each element with variable same ; Returns true if we can make all character frequencies same ; fill frequency array ; if all frequencies are same , then return true ; Try decreasing frequency of all character by one and then check all equality of all non - zero frequencies ; Check character only if it occurs in str ; Driver code","code":"< ? php $ M = 26 ; function getIdx ( $ ch ) { return ( $ ch - ' a ' ) ; } function allSame ( & $ freq , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ freq [ $ i ] > 0 ) { $ same = $ freq [ $ i ] ; break ; } } for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ freq [ $ j ] > 0 && $ freq [ $ j ] != $ same ) return false ; return true ; } function possibleSameCharFreqByOneRemoval ( $ str ) { global $ M ; $ l = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ M , NULL ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ freq [ getIdx ( $ str [ $ i ] ) ] ++ ; if ( allSame ( $ freq , $ M ) ) return true ; for ( $ c = ' a ' ; $ c <= ' z ' ; $ c ++ ) { $ i = getIdx ( $ c ) ; if ( $ freq [ $ i ] > 0 ) { $ freq [ $ i ] -- ; if ( allSame ( $ freq , $ M ) ) return true ; $ freq [ $ i ] ++ ; } } return false ; } $ str = \" xyyzz \" ; if ( possibleSameCharFreqByOneRemoval ( $ str ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Check if a large number is divisible by 11 or not | Function to find that number divisible by 11 or not ; Compute sum of even and odd digit sums ; When i is even , position of digit is odd ; Check its difference is divisible by 11 or not ; Driver code","code":"< ? php function check ( $ str ) { $ n = strlen ( $ str ) ; $ oddDigSum = 0 ; $ evenDigSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ oddDigSum += ( $ str [ $ i ] - '0' ) ; else $ evenDigSum += ( $ str [ $ i ] - '0' ) ; } return ( ( $ oddDigSum - $ evenDigSum ) % 11 == 0 ) ; } $ str = \"76945\" ; $ x = check ( $ str ) ? \" Yes \" : \" No \u2581 \" ; echo ( $ x ) ; ? >"}
{"text":"Hamming Distance between two strings | function to calculate Hamming distance ; Driver Code ; function call","code":"< ? php function hammingDist ( $ str1 , $ str2 ) { $ i = 0 ; $ count = 0 ; while ( isset ( $ str1 [ $ i ] ) != ' ' ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) $ count ++ ; $ i ++ ; } return $ count ; } $ str1 = \" geekspractice \" ; $ str2 = \" nerdspractise \" ; echo hammingDist ( $ str1 , $ str2 ) ; ? >"}
{"text":"Check if two strings are k | PHP program to check if two strings are k anagram or not . ; Function to check that string is k - anagram or not ; If both strings are not of equal length then return false ; Store the occurrence of all characters in a hash_array ; Count number of characters that are different in both strings ; Return true if count is less than or equal to k ; Driver Code","code":"< ? php $ MAX_CHAR = 26 ; function arekAnagrams ( $ str1 , $ str2 , $ k ) { global $ MAX_CHAR ; $ n = strlen ( $ str1 ) ; if ( strlen ( $ str2 ) != $ n ) return false ; $ count1 = ( 0 ) ; $ count2 = ( 0 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count1 [ $ i ] > $ count2 [ $ i ] ) $ count = $ count + abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return ( $ count <= $ k ) ; } $ str1 = \" anagram \" ; $ str2 = \" grammar \" ; $ k = 2 ; if ( arekAnagrams ( $ str1 , $ str2 , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Given a binary string , count number of substrings that start and end with 1. | A simple PHP program to count number of substrings starting and ending with 1 ; Pick a starting point ; Return count of possible pairs among m 1 's ; Driver Code","code":"< ? php function countSubStr ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { $ m ++ ; } } return $ m * ( $ m - 1 ) \/ 2 ; } $ str = \"00100101\" ; echo countSubStr ( $ str ) ; ? >"}
{"text":"Given a number as a string , find the number of contiguous subsequences which recursively add up to 9 | PHP program to count substrings with recursive sum equal to 9 ; To store result ; Consider every character as beginning of substring ; sum of digits in current substring ; One by one choose every character as an ending character ; Add current digit to sum , if sum becomes multiple of 5 then increment count . Let us do modular arithmetic to avoid overflow for big strings ; Driver Code","code":"< ? php function count9s ( $ number ) { $ count = 0 ; $ n = strlen ( $ number ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ number [ $ i ] - '0' ; if ( $ number [ $ i ] == '9' ) $ count ++ ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ sum = ( $ sum + $ number [ $ j ] - '0' ) % 9 ; if ( $ sum == 0 ) $ count ++ ; } } return $ count ; } echo count9s ( \" 4189 \" ) , \" STRNEWLINE \" ; echo count9s ( \" 1809 \" ) ; ? >"}
{"text":"Collect all coins in minimum number of steps | recursive method to collect coins from height array l to r , with height h already collected ; if l is more than r , no steps needed ; loop over heights to get minimum height index ; choose minimum from , 1 ) collecting coins using all vertical lines ( total r - l ) 2 ) collecting coins using lower horizontal lines and recursively on left and right segments ; method returns minimum number of step to collect coin from stack , with height in height [ ] array ; Driver Code","code":"< ? php function minStepsRecur ( $ height , $ l , $ r , $ h ) { if ( $ l >= $ r ) return 0 ; $ m = $ l ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) if ( $ height [ $ i ] < $ height [ $ m ] ) $ m = $ i ; return min ( $ r - $ l , minStepsRecur ( $ height , $ l , $ m , $ height [ $ m ] ) + minStepsRecur ( $ height , $ m + 1 , $ r , $ height [ $ m ] ) + $ height [ $ m ] - $ h ) ; } function minSteps ( $ height , $ N ) { return minStepsRecur ( $ height , 0 , $ N , 0 ) ; } $ height = array ( 2 , 1 , 2 , 5 , 1 ) ; $ N = sizeof ( $ height ) ; echo minSteps ( $ height , $ N ) ; ? >"}
{"text":"Biggest Reuleaux Triangle within A Square | Function to find the Area of the Reuleaux triangle ; Side cannot be negative ; Area of the Reuleaux triangle ; Driver code","code":"< ? php function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; } $ a = 6 ; echo ReuleauxArea ( $ a ) . \" STRNEWLINE \" ; ? >"}
{"text":"Largest hexagon that can be inscribed within a square | Function to return the side of the hexagon ; Side cannot be negative ; Side of the hexagon ; Driver code","code":"< ? php function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.5176 * $ a ; return $ x ; } $ a = 6 ; echo hexagonside ( $ a ) ; ? >"}
{"text":"Largest hexagon that can be inscribed within an equilateral triangle | Function to find the side of the hexagon ; Side cannot be negative ; Side of the hexagon ; Driver code","code":"< ? php function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = $ a \/ 3 ; return $ x ; } $ a = 6 ; echo hexagonside ( $ a ) ; ? >"}
{"text":"Find middle point segment from given segment lengths | Function that returns the segment for the middle point ; the middle point ; stores the segment index ; increment sum by length of the segment ; if the middle is in between two segments ; if sum is greater than middle point ; Driver code","code":"< ? php function findSegment ( $ n , $ m , $ segment_length ) { $ meet_point = ( 1.0 * $ n ) \/ 2.0 ; $ sum = 0 ; $ segment_number = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ sum += $ segment_length [ $ i ] ; if ( ( double ) $ sum == $ meet_point ) { $ segment_number = -1 ; break ; } if ( $ sum > $ meet_point ) { $ segment_number = $ i + 1 ; break ; } } return $ segment_number ; } $ n = 13 ; $ m = 3 ; $ segment_length = array ( 3 , 2 , 8 ) ; $ ans = findSegment ( $ n , $ m , $ segment_length ) ; echo ( $ ans ) ; ? >"}
{"text":"Maximum points of intersection n lines | nC2 = ( n ) * ( n - 1 ) \/ 2 ; ; n is number of line","code":"< ? php function countMaxIntersect ( $ n ) { return ( $ n ) * ( $ n - 1 ) \/ 2 ; } $ n = 8 ; echo countMaxIntersect ( $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program to find volume and surface area of pentagonal prism | function for surface area ; function for VOlume ; Driver Code","code":"< ? php function surfaceArea ( $ a , $ b , $ h ) { return 5 * $ a * $ b + 5 * $ b * $ h ; } function volume ( $ b , $ h ) { return ( 5 * $ b * $ h ) \/ 2 ; } $ a = 5 ; $ b = 3 ; $ h = 7 ; echo \" surface \u2581 area \u2581 = \u2581 \" , surfaceArea ( $ a , $ b , $ h ) , \" , \u2581 \" ; echo \" volume = \" ? >"}
{"text":"Check if a point is inside , outside or on the parabola | Function to check the point ; checking the equation of parabola with the given point ; Driver code","code":"< ? php function checkpoint ( $ h , $ k , $ x , $ y , $ a ) { $ p = pow ( ( $ y - $ k ) , 2 ) - 4 * $ a * ( $ x - $ h ) ; return $ p ; } $ h = 0 ; $ k = 0 ; $ x = 2 ; $ y = 1 ; $ a = 4 ; if ( checkpoint ( $ h , $ k , $ x , $ y , $ a ) > 0 ) echo \" Outside \" ; else if ( checkpoint ( $ h , $ k , $ x , $ y , $ a ) == 0 ) echo \" On \u2581 the \u2581 parabola \" ; else echo \" Inside \" ; ? >"}
{"text":"Check if a point is inside , outside or on the ellipse | Function to check the point ; checking the equation of ellipse with the given point ; Driver code","code":"< ? php function checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) { $ p = ( pow ( ( $ x - $ h ) , 2 ) \/ pow ( $ a , 2 ) ) + ( pow ( ( $ y - $ k ) , 2 ) \/ pow ( $ b , 2 ) ) ; return $ p ; } $ h = 0 ; $ k = 0 ; $ x = 2 ; $ y = 1 ; $ a = 4 ; $ b = 5 ; if ( checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) > 1 ) echo ( \" Outside \" ) ; else if ( checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) == 1 ) echo ( \" On \u2581 the \u2581 ellipse \" ) ; else echo ( \" Inside \" ) ; ? >"}
{"text":"Area of circle inscribed within rhombus | Function to find the area of the inscribed circle ; the diagonals cannot be negative ; area of the circle ; Driver code","code":"< ? php function circlearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = ( 3.14 * pow ( $ a , 2 ) * pow ( $ b , 2 ) ) \/ ( 4 * ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) ) ; return $ A ; } $ a = 8 ; $ b = 10 ; echo circlearea ( $ a , $ b ) ; ? >"}
{"text":"The biggest possible circle that can be inscribed in a rectangle | Function to find the area of the biggest circle ; the length and breadth cannot be negative ; area of the circle ; Driver code","code":"< ? php function circlearea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; if ( $ l < $ b ) return 3.14 * pow ( $ l \/ 2 , 2 ) ; else return 3.14 * pow ( $ b \/ 2 , 2 ) ; } $ l = 4 ; $ b = 8 ; echo circlearea ( $ l , $ b ) . \" STRNEWLINE \" ; ? >"}
{"text":"Centered cube number | Function to find Centered cube number ; Formula to calculate nth Centered cube number & return it into main function . ; Driver Code","code":"< ? php function centered_cube ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 1 ) ; } $ n = 3 ; echo $ n , \" th \u2581 Centered \u2581 cube \u2581 number : \u2581 \" ; echo centered_cube ( $ n ) ; echo \" STRNEWLINE \" ; $ n = 10 ; echo $ n , \" th \u2581 Centered \u2581 cube \u2581 number : \u2581 \" ; echo centered_cube ( $ n ) ; ? >"}
{"text":"Find the center of the circle using endpoints of diameter | function to find the center of the circle ; Driven Code","code":"< ? php function center ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) \/ 2 . \" , \u2581 \" . ( float ) ( $ y1 + $ y2 ) \/ 2 ) ; } $ x1 = -9 ; $ y1 = 3 ; $ x2 = 5 ; $ y2 = -7 ; center ( $ x1 , $ x2 , $ y1 , $ y2 ) ; ? >"}
{"text":"Program to calculate volume of Octahedron | utility Function ; Driver Function","code":"< ? php function vol_of_octahedron ( $ side ) { return ( ( $ side * $ side * $ side ) * ( sqrt ( 2 ) \/ 3 ) ) ; } $ side = 3 ; echo ( \" Volume \u2581 of \u2581 octahedron \u2581 = \" ) ; echo ( vol_of_octahedron ( $ side ) ) ; ? >"}
{"text":"Program to calculate volume of Ellipsoid | Function to find the volume ; Driver Code","code":"< ? php function volumeOfEllipsoid ( $ r1 , $ r2 , $ r3 ) { $ pi = 3.14 ; return 1.33 * $ pi * $ r1 * $ r2 * $ r3 ; } $ r1 = 2.3 ; $ r2 = 3.4 ; $ r3 = 5.7 ; echo ( \" volume \u2581 of \u2581 ellipsoid \u2581 is \u2581 : \u2581 \" ) ; echo ( volumeOfEllipsoid ( $ r1 , $ r2 , $ r3 ) ) ; ? >"}
{"text":"Program to calculate Area Of Octagon | Utility function ; Driver Code","code":"< ? php function areaOctagon ( $ side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * $ side * $ side ) ; } $ side = 4 ; echo ( \" Area \u2581 of \u2581 Regular \u2581 Octagon \u2581 = \u2581 \" ) ; echo ( areaOctagon ( $ side ) ) ; ? >"}
{"text":"Program for Volume and Surface Area of Cube | utility function ; driver function","code":"< ? php function areaCube ( $ a ) { return ( $ a * $ a * $ a ) ; } function surfaceCube ( $ a ) { return ( 6 * $ a * $ a ) ; } $ a = 5 ; echo ( \" Area \u2581 = \u2581 \" ) ; echo ( areaCube ( $ a ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Total \u2581 surface \u2581 area \u2581 = \u2581 \" ) ; echo ( surfaceCube ( $ a ) ) ; ? >"}
{"text":"Minimum revolutions to move center of a circle to a target | Minimum revolutions to move center from ( x1 , y1 ) to ( x2 , y2 ) ; Driver code","code":"< ? php function minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) { $ d = sqrt ( ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ) ; return ceil ( $ d \/ ( 2 * $ r ) ) ; } $ r = 2 ; $ x1 = 0 ; $ y1 = 0 ; $ x2 = 0 ; $ y2 = 4 ; echo minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) ; ? >"}
{"text":"Find all sides of a right angled triangle from given hypotenuse and area | Set 1 | limit for float comparison ; Utility method to get area of right angle triangle , given base and hypotenuse ; Prints base and height of triangle using hypotenuse and area information ; maximum area will be obtained when base and height are equal ( = sqrt ( h * h \/ 2 ) ) ; if given area itself is larger than maxArea then no solution is possible ; binary search for base ; get height by pythagorean rule ; Driver Code","code":"< ? php $ eps = .0000001 ; function getArea ( $ base , $ hypotenuse ) { $ height = sqrt ( $ hypotenuse * $ hypotenuse - $ base * $ base ) ; return 0.5 * $ base * $ height ; } function printRightAngleTriangle ( $ hypotenuse , $ area ) { global $ eps ; $ hsquare = $ hypotenuse * $ hypotenuse ; $ sideForMaxArea = sqrt ( $ hsquare \/ 2.0 ) ; $ maxArea = getArea ( $ sideForMaxArea , $ hypotenuse ) ; if ( $ area > $ maxArea ) { echo \" Not \u2581 possiblen \" ; return ; } $ low = 0.0 ; $ high = $ sideForMaxArea ; $ base ; while ( abs ( $ high - $ low ) > $ eps ) { $ base = ( $ low + $ high ) \/ 2.0 ; if ( getArea ( $ base , $ hypotenuse ) >= $ area ) $ high = $ base ; else $ low = $ base ; } $ height = sqrt ( $ hsquare - $ base * $ base ) ; echo ( ceil ( $ base ) ) , \" \u2581 \" , ( floor ( $ height ) ) , \" STRNEWLINE \" ; } $ hypotenuse = 5 ; $ area = 6 ; printRightAngleTriangle ( $ hypotenuse , $ area ) ; ? >"}
{"text":"Circle and Lattice Points | Function to count Lattice points on a circle ; Initialize result as 4 for ( r , 0 ) , ( - r . 0 ) , ( 0 , r ) and ( 0 , - r ) ; Check every value that can be potential x ; Find a potential y ; checking whether square root is an integer or not . Count increments by 4 for four different quadrant values ; Driver Code","code":"< ? php function countLattice ( $ r ) { if ( $ r <= 0 ) return 0 ; $ result = 4 ; for ( $ x = 1 ; $ x < $ r ; $ x ++ ) { $ ySquare = $ r * $ r - $ x * $ x ; $ y = ceil ( sqrt ( $ ySquare ) ) ; if ( $ y * $ y == $ ySquare ) $ result += 4 ; } return $ result ; } $ r = 5 ; echo countLattice ( $ r ) ; ? >"}
{"text":"Find number of magical pairs of string of length L | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is >= p ; If y is odd , multiply x with result ; Y must be even now $y = $y >> 1 ; y = y \/ 2 ; Driver Code","code":"< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } $ L = 2 ; $ P = pow ( 10 , 9 ) ; $ ans = power ( 325 , $ L , $ P ) ; echo $ ans , \" STRNEWLINE \" ; ? >"}
{"text":"Longest substring of only 4 's from the first N characters of the infinite string | PHP implementation of the approach ; Function to return the length of longest contiguous string containing only 4 aTMs from the first N characters of the string ; Initialize result ; Initialize prefix sum array of characters and product variable ; Preprocessing of prefix sum array ; Initialize variable to store the string length where N belongs to ; Finding the string length where N belongs to ; Driver Code","code":"< ? php $ MAXN = 30 ; function countMaxLength ( $ N ) { $ res = 0 ; $ pre = array ( ) ; $ p = 1 ; $ pre [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' AXN ' ; $ i ++ ) { $ p *= 2 ; $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ i * $ p ; } $ ind = 0 ; for ( $ i = 1 ; $ i < $ GLOBALS [ ' AXN ' ; $ i ++ ) { if ( $ pre [ $ i ] >= $ N ) { $ ind = $ i ; break ; } } $ x = $ N - $ pre [ $ ind - 1 ] ; $ y = 2 * $ ind - 1 ; if ( $ x >= $ y ) $ res = min ( $ x , $ y ) ; else $ res = max ( $ x , 2 * ( $ ind - 2 ) + 1 ) ; return $ res ; } $ N = 25 ; echo countMaxLength ( $ N ) ; ? >"}
{"text":"Difference between Recursion and Iteration | -- -- - Recursion -- -- - method to find factorial of given number ; recursion call ; -- -- - Iteration -- -- - Method to find the factorial of a given number ; using iteration ; Driver method","code":"< ? php function factorialUsingRecursion ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorialUsingRecursion ( $ n - 1 ) ; } function factorialUsingIteration ( $ n ) { $ res = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res *= $ i ; return $ res ; } $ num = 5 ; print ( \" Factorial \u2581 of \u2581 \" . $ num . \" \u2581 using \u2581 Recursion \u2581 is : \u2581 \" . factorialUsingRecursion ( 5 ) . \" STRNEWLINE \" ) ; print ( \" Factorial \u2581 of \u2581 \" . $ num . \" \u2581 using \u2581 Iteration \u2581 is : \u2581 \" . factorialUsingIteration ( 5 ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Find maximum sum taking every Kth element in the array | Function to return the maximum sum for every possible sequence such that a [ i ] + a [ i + k ] + a [ i + 2 k ] + ... + a [ i + qk ] is maximized ; Initialize the maximum with the smallest value ; Initialize the sum array with zero ; Iterate from the right ; Update the sum starting at the current element ; Update the maximum so far ; Driver code","code":"< ? php function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; $ sum = array ( $ n ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ i + $ K < $ n ) $ sum [ $ i ] = $ sum [ $ i + $ K ] + $ arr [ $ i ] ; else $ sum [ $ i ] = $ arr [ $ i ] ; $ maximum = max ( $ maximum , $ sum [ $ i ] ) ; } return $ maximum ; } { $ arr = array ( 3 , 6 , 4 , 7 , 2 ) ; $ n = sizeof ( $ arr ) ; $ K = 2 ; echo ( maxSum ( $ arr , $ n , $ K ) ) ; }"}
{"text":"Find a distinct pair ( x , y ) in given range such that x divides y | PHP implementation of the approach ; Driver code","code":"< ? php function findpair ( $ l , $ r ) { $ c = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ r ; $ j ++ ) { if ( $ j % $ i == 0 && $ j != $ i ) { echo ( $ i . \" , \u2581 \" . $ j ) ; $ c = 1 ; break ; } } if ( $ c == 1 ) break ; } } $ l = 1 ; $ r = 10 ; findpair ( $ l , $ r ) ; ? >"}
{"text":"Check if the given array can be reduced to zeros with the given operation performed given number of times | Function that returns true if the array can be reduced to 0 s with the given operation performed given number of times ; Add in Set only unique elements ; Count of all the unique elements in the array ; Driver code","code":"< ? php function check ( & $ arr , $ N , $ K ) { $ unique = array_unique ( $ arr ) ; if ( count ( $ unique ) == $ K ) return true ; return false ; } $ arr = array ( 1 , 1 , 2 , 3 ) ; $ N = count ( $ arr ) ; $ K = 3 ; if ( check ( $ arr , $ N , $ K ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum index i such that all the elements from index i to given index are equal | Function to return the minimum required index ; Start from arr [ pos - 1 ] ; All elements are equal from arr [ i + 1 ] to arr [ pos ] ; Driver code ; Function Call","code":"< ? php function minIndex ( $ arr , $ n , $ pos ) { $ num = $ arr [ $ pos ] ; $ i = $ pos - 1 ; while ( $ i >= 0 ) { if ( $ arr [ $ i ] != $ num ) break ; $ i -- ; } return $ i + 1 ; } $ arr = array ( 2 , 1 , 1 , 1 , 5 , 2 ) ; $ n = sizeof ( $ arr ) ; $ pos = 4 ; echo minIndex ( $ arr , $ n , $ pos ) ; ? >"}
{"text":"Count of strings that become equal to one of the two strings after one removal | Function to return the count of the required strings ; Searching index after longest common prefix ends ; Searching index before longest common suffix ends ; If str1 = str2 ; If only 1 character is different in both the strings ; Checking remaining part of string for equality ; Searching in right of string h ( g to h ) ; Driver code","code":"< ? php function findAnswer ( $ str1 , $ str2 , $ n ) { $ ans = 2 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) { $ l = $ i ; break ; } } for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) { $ r = $ i ; break ; } } if ( $ r < $ l ) return 26 * ( $ n + 1 ) ; else if ( $ l == $ r ) return $ ans ; else { for ( $ i = $ l + 1 ; $ i <= $ r ; $ i ++ ) { if ( $ str1 [ $ i ] != $ str2 [ $ i - 1 ] ) { $ ans -- ; break ; } } for ( $ i = $ l + 1 ; $ i <= $ r ; $ i ++ ) { if ( $ str1 [ $ i - 1 ] != $ str2 [ $ i ] ) { $ ans -- ; break ; } } return $ ans ; } } $ str1 = \" toy \" ; $ str2 = \" try \" ; $ n = strlen ( $ str1 ) ; echo findAnswer ( $ str1 , $ str2 , $ n ) ; ? >"}
{"text":"Minimize the maximum minimum difference after one removal from array | Function to return the minimum required difference ; Sort the given array ; When minimum element is removed ; When maximum element is removed ; Return the minimum of diff1 and diff2 ; Driver Code","code":"< ? php function findMinDifference ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ diff1 = $ arr [ $ n - 1 ] - $ arr [ 1 ] ; $ diff2 = $ arr [ $ n - 2 ] - $ arr [ 0 ] ; return min ( $ diff1 , $ diff2 ) ; } $ arr = array ( 1 , 2 , 4 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo findMinDifference ( $ arr , $ n ) ;"}
{"text":"Minimize the maximum minimum difference after one removal from array | Function to return the minimum required difference ; If current element is greater than max ; max will become secondMax ; Update the max ; If current element is greater than secondMax but smaller than max ; Update the secondMax ; If current element is smaller than min ; min will become secondMin ; Update the min ; If current element is smaller than secondMin but greater than min ; Update the secondMin ; Minimum of the two possible differences ; Driver code","code":"< ? php function findMinDifference ( $ arr , $ n ) { $ min__ = $ secondMax = ( $ arr [ 0 ] < $ arr [ 1 ] ) ? $ arr [ 0 ] : $ arr [ 1 ] ; $ max__ = $ secondMin = ( $ arr [ 0 ] < $ arr [ 1 ] ) ? $ arr [ 1 ] : $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max__ ) { $ secondMax = $ max__ ; $ max__ = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ secondMax ) { $ secondMax = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ min__ ) { $ secondMin = $ min__ ; $ min__ = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ secondMin ) { $ secondMin = $ arr [ $ i ] ; } } $ diff = min ( $ max__ - $ secondMin , $ secondMax - $ min__ ) ; return $ diff ; } $ arr = array ( 1 , 2 , 4 , 3 , 4 ) ; $ n = count ( $ arr ) ; print ( findMinDifference ( $ arr , $ n ) ) ; ? >"}
{"text":"Integers from the range that are composed of a single distinct digit | Boolean function to check distinct digits of a number ; Take last digit ; Check if all other digits are same as last digit ; Remove last digit ; Function to return the count of integers that are composed of a single distinct digit only ; If i has single distinct digit ; Driver code","code":"< ? php function checkDistinct ( $ x ) { $ last = $ x % 10 ; while ( $ x ) { if ( $ x % 10 != $ last ) return false ; $ x = floor ( $ x \/ 10 ) ; } return true ; } function findCount ( $ L , $ R ) { $ count = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( checkDistinct ( $ i ) ) $ count += 1 ; } return $ count ; } $ L = 10 ; $ R = 50 ; echo findCount ( $ L , $ R ) ; ? >"}
{"text":"Smallest Pair Sum in an array | Function to return the sum of the minimum pair from the array ; If found new minimum ; Minimum now becomes second minimum ; Update minimum ; If current element is > min and < secondMin ; Update secondMin ; Return the sum of the minimum pair ; Driver code","code":"< ? php function smallest_pair ( $ a , $ n ) { $ min = PHP_INT_MAX ; $ secondMin = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] < $ min ) { $ secondMin = $ min ; $ min = $ a [ $ j ] ; } else if ( ( $ a [ $ j ] < $ secondMin ) && $ a [ $ j ] != $ min ) $ secondMin = $ a [ $ j ] ; } return ( $ secondMin + $ min ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo smallest_pair ( $ arr , $ n ) ; ? >"}
{"text":"Longest subarray with elements divisible by k | function to find longest subarray ; This will contain length of longest subarray found ; Driver code","code":"< ? php function longestsubarray ( $ arr , $ n , $ k ) { $ current_count = 0 ; $ max_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ current_count ++ ; else $ current_count = 0 ; $ max_count = max ( $ current_count , $ max_count ) ; } return $ max_count ; } $ arr = array ( 2 , 5 , 11 , 32 , 64 , 88 ) ; $ n = sizeof ( $ arr ) ; $ k = 8 ; echo longestsubarray ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Check if a string contains a palindromic sub | function to check if two consecutive same characters are present ; Driver Code","code":"< ? php function check ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) return true ; return false ; } $ s = \" xzyyz \" ; if ( check ( $ s ) ) echo \" YES \" , \" STRNEWLINE \" ; else echo \" NO \" , \" STRNEWLINE \" ; ? >"}
{"text":"Number of anomalies in an array | A simple PHP solution to count anomalies in an array . ; Driver Code","code":"< ? php function countAnomalies ( & $ arr , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= $ k ) break ; if ( $ j == $ n ) $ res ++ ; } return $ res ; } $ arr = array ( 7 , 1 , 8 ) ; $ k = 5 ; $ n = sizeof ( $ arr ) ; echo countAnomalies ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Find pair with maximum difference in any column of a Matrix | Function to find the column with max difference ; Traverse matrix column wise ; Insert elements of column to vector ; calculating difference between maximum and minimum ; driver code","code":"< ? php function colMaxDiff ( $ mat ) { $ N = 5 ; $ max_diff = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ max_val = $ mat [ 0 ] [ $ i ] ; $ min_val = $ mat [ 0 ] [ $ i ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) { $ max_val = max ( $ max_val , $ mat [ $ j ] [ $ i ] ) ; $ min_val = min ( $ min_val , $ mat [ $ j ] [ $ i ] ) ; } $ max_diff = max ( $ max_diff , $ max_val - $ min_val ) ; } return $ max_diff ; } $ mat = array ( array ( 1 , 2 , 3 , 4 , 5 ) , array ( 5 , 3 , 5 , 4 , 0 ) , array ( 5 , 6 , 7 , 8 , 9 ) , array ( 0 , 6 , 3 , 4 , 12 ) , array ( 9 , 7 , 12 , 4 , 3 ) ) ; echo \" Max \u2581 difference \u2581 : \u2581 \" . colMaxDiff ( $ mat ) . \" STRNEWLINE \" ;"}
{"text":"Find the Missing Number in a sorted array | A binary search based program to find the only missing number in a sorted array of distinct elements within limited range . ; Driver Code","code":"< ? php function search ( $ ar , $ size ) { $ a = 0 ; $ b = $ size - 1 ; $ mid ; while ( ( $ b - $ a ) > 1 ) { $ mid = ( int ) ( ( $ a + $ b ) \/ 2 ) ; if ( ( $ ar [ $ a ] - $ a ) != ( $ ar [ $ mid ] - $ mid ) ) $ b = $ mid ; else if ( ( $ ar [ $ b ] - $ b ) != ( $ ar [ $ mid ] - $ mid ) ) $ a = $ mid ; } return ( $ ar [ $ a ] + 1 ) ; } $ ar = array ( 1 , 2 , 3 , 4 , 5 , 6 , 8 ) ; $ size = sizeof ( $ ar ) ; echo \" Missing \u2581 number : \u2581 \" , search ( $ ar , $ size ) ; ? >"}
{"text":"Delete array element in given index range [ L | Delete L to R elements ; Return size of Array after delete element ; Driver Code","code":"< ? php function deleteElement ( & $ A , $ L , $ R , $ N ) { $ i = 0 ; $ j = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ i <= $ L $ i >= $ R ) { $ A [ $ j ] = $ A [ $ i ] ; $ j ++ ; } } return $ j ; } $ A = array ( 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ) ; $ L = 2 ; $ R = 7 ; $ n = sizeof ( $ A ) ; $ res_size = deleteElement ( $ A , $ L , $ R , $ n ) ; for ( $ i = 0 ; $ i < $ res_size ; $ i ++ ) { echo ( $ A [ $ i ] ) ; echo ( \" \u2581 \" ) ; } ? >"}
{"text":"Find the only missing number in a sorted array | PHP program to find the only missing element . ; If this is the first element which is not index + 1 , then missing element is mid + 1 ; if this is not the first missing element search in left side ; if it follows index + 1 property then search in right side ; if no element is missing ; Driver Code","code":"< ? php function findmissing ( & $ ar , $ N ) { $ r = $ N - 1 ; $ l = 0 ; while ( $ l <= $ r ) { $ mid = ( $ l + $ r ) \/ 2 ; if ( $ ar [ $ mid ] != $ mid + 1 && $ ar [ $ mid - 1 ] == $ mid ) return ( $ mid + 1 ) ; if ( $ ar [ $ mid ] != $ mid + 1 ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return ( -1 ) ; } $ ar = array ( 1 , 2 , 3 , 4 , 5 , 7 , 8 ) ; $ N = sizeof ( $ ar ) ; echo ( findmissing ( $ ar , $ N ) ) ; ? >"}
{"text":"Find index of first occurrence when an unsorted array is sorted | PHP program to find index of first occurrence of x when array is sorted . ; lower_bound returns iterator pointing to first element that does not compare less to x . ; If x is not present return - 1. ; Code driven","code":"< ? php function findFirst ( $ arr , $ n , $ x ) { sort ( $ arr ) ; $ ptr = floor ( $ arr ) ; return ( $ ptr != $ x ) ? 1 : ( $ ptr - $ arr ) ; } $ x = 20 ; $ arr = array ( 10 , 30 , 20 , 50 , 20 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; echo findFirst ( $ arr , $ n , $ x ) ; #This  code is contributed by Tushil. NEW_LINE ? >"}
{"text":"Find index of first occurrence when an unsorted array is sorted | PHP program to find index of first occurrence of x when array is sorted . ; Driver Code","code":"< ? php function findFirst ( $ arr , $ n , $ x ) { $ count = 0 ; $ isX = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) $ isX = true ; else if ( $ arr [ $ i ] < $ x ) $ count ++ ; } return ( $ isX == false ) ? -1 : $ count ; } $ x = 20 ; $ arr = array ( 10 , 30 , 20 , 50 , 20 ) ; $ n = sizeof ( $ arr ) ; echo findFirst ( $ arr , $ n , $ x ) ; ? >"}
{"text":"Find duplicate in an array in O ( n ) and by using O ( 1 ) extra space | Function to find duplicate ; Find the intersection point of the slow and fast . ; Find the \" entrance \" to the cycle . ; Driver code","code":"< ? php function findDuplicate ( & $ arr ) { $ slow = $ arr [ 0 ] ; $ fast = $ arr [ 0 ] ; do { $ slow = $ arr [ $ slow ] ; $ fast = $ arr [ $ arr [ $ fast ] ] ; } while ( $ slow != $ fast ) ; $ ptr1 = $ arr [ 0 ] ; $ ptr2 = $ slow ; while ( $ ptr1 != $ ptr2 ) { $ ptr1 = $ arr [ $ ptr1 ] ; $ ptr2 = $ arr [ $ ptr2 ] ; } return $ ptr1 ; } $ arr = array ( 1 , 3 , 2 , 1 ) ; echo \" \u2581 \" . findDuplicate ( $ arr ) ; ? >"}
{"text":"Number of Larger Elements on right side in a string | PHP program to count greater characters on right side of every character . ; Arrays to store result and character counts . ; start from right side of string ; Driver code","code":"< ? php $ MAX_CHAR = 26 ; function printGreaterCount ( $ str ) { global $ MAX_CHAR ; $ len = strlen ( $ str ) ; $ ans = array_fill ( 0 , $ len , 0 ) ; $ count = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ j = ord ( $ str [ $ i ] ) - ord ( ' a ' ) + 1 ; $ j < $ MAX_CHAR ; $ j ++ ) $ ans [ $ i ] += $ count [ $ j ] ; } for ( $ i = 0 ; $ i < $ len ; $ i ++ ) echo $ ans [ $ i ] . \" \u2581 \" ; } $ str = \" abcd \" ; printGreaterCount ( $ str ) ; ? >"}
{"text":"Maximum product quadruple ( sub | Function to find a maximum product of a quadruple in array of integers of size n ; if size is less than 4 , no quadruple exists ; Initialize Maximum , second maximum , third maximum and fourth maximum element ; Initialize Minimum , second minimum , third minimum and fourth minimum element ; Update Maximum , second maximum , third maximum and fourth maximum element ; Update second maximum , third maximum and fourth maximum element ; Update third maximum and fourth maximum element ; Update fourth maximum element ; Update Minimum , second minimum , third minimum and fourth minimum element ; Update second minimum , third minimum and fourth minimum element ; Update third minimum and fourth minimum element ; Update fourth minimum element ; Return the maximum of x , y and z ; Driver Code","code":"< ? php function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ maxA = -2147483648 ; $ maxB = -2147483648 ; $ maxC = -2147483648 ; $ maxD = -2147483648 ; $ minA = 2147483647 ; $ minB = 2147483647 ; $ minC = 2147483647 ; $ minD = 2147483647 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ maxA ) { $ maxD = $ maxC ; $ maxC = $ maxB ; $ maxB = $ maxA ; $ maxA = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] > $ maxB ) { $ maxD = $ maxC ; $ maxC = $ maxB ; $ maxB = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] > $ maxC ) { $ maxD = $ maxC ; $ maxC = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] > $ maxD ) $ maxD = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minA ) { $ minD = $ minC ; $ minC = $ minB ; $ minB = $ minA ; $ minA = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] < $ minB ) { $ minD = $ minC ; $ minC = $ minB ; $ minB = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] < $ minC ) { $ minD = $ minC ; $ minC = $ arr [ $ i ] ; } elseif ( $ arr [ $ i ] < $ minD ) $ minD = $ arr [ $ i ] ; } $ x = $ maxA * $ maxB * $ maxC * $ maxD ; $ y = $ minA * $ minB * $ minC * $ minD ; $ z = $ minA * $ minB * $ maxA * $ maxB ; return max ( $ x , max ( $ y , $ z ) ) ; } $ arr = array ( 1 , -4 , 3 , -6 , 7 , 0 ) ; $ n = count ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) echo \" No \u2581 Quadruple \u2581 Exists \" ; else echo \" Maximum \u2581 product \u2581 is \u2581 \" . $ max ; ? >"}
{"text":"Ways to choose three points with distance between the most distant points <= L | Returns the number of triplets with distance between farthest points <= L ; sort to get ordered triplets so that we can find the distance between farthest points belonging to a triplet ; generate and check for all possible triplets : { arr [ i ] , arr [ j ] , arr [ k ] } ; Since the array is sorted the farthest points will be a [ i ] and a [ k ] ; ; set of n points on the X axis","code":"< ? php function countTripletsLessThanL ( $ n , $ L , $ arr ) { sort ( $ arr ) ; $ ways = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { $ mostDistantDistance = $ arr [ $ k ] - $ arr [ $ i ] ; if ( $ mostDistantDistance <= $ L ) { $ ways ++ ; } } } } return $ ways ; } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; $ L = 3 ; $ ans = countTripletsLessThanL ( $ n , $ L , $ arr ) ; echo \" Total \u2581 Number \u2581 of \u2581 ways \u2581 = \u2581 \" , $ ans , \" STRNEWLINE \" ; ? >"}
{"text":"Find the one missing number in range | Find the missing number in a range ; here we xor of all the number ; xor last number ; Driver code","code":"< ? php function missingNum ( $ arr , $ n ) { $ minvalue = min ( $ arr ) ; $ xornum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ xornum ^= ( $ minvalue ) ^ $ arr [ $ i ] ; $ minvalue ++ ; } return $ xornum ^ $ minvalue ; } $ arr = array ( 13 , 12 , 11 , 15 ) ; $ n = sizeof ( $ arr ) ; echo missingNum ( $ arr , $ n ) ; ? >"}
{"text":"Find last index of a character in a string | Returns last index of x if it is present . Else returns - 1. ; String in which char is to be found ; char whose index is to be found","code":"< ? php function findLastIndex ( $ str , $ x ) { $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ index = $ i ; return $ index ; } $ str = \" geeksforgeeks \" ; $ x = ' e ' ; $ index = findLastIndex ( $ str , $ x ) ; if ( $ index == -1 ) echo ( \" Character \u2581 not \u2581 found \" ) ; else echo ( \" Last \u2581 index \u2581 is \u2581 \" . $ index ) ; ? >"}
{"text":"Find last index of a character in a string | Returns last index of x if it is present . Else returns - 1. ; Traverse from right ; Driver code","code":"< ? php function findLastIndex ( $ str , $ x ) { for ( $ i = strlen ( $ str ) - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == $ x ) return $ i ; return -1 ; } $ str = \" geeksforgeeks \" ; $ x = ' e ' ; $ index = findLastIndex ( $ str , $ x ) ; if ( $ index == -1 ) echo ( \" Character \u2581 not \u2581 found \" ) ; else echo ( \" Last \u2581 index \u2581 is \u2581 \" . $ index ) ; ? >"}
{"text":"Smallest number whose set bits are maximum in a given range | Returns smallest number whose set bits are maximum in given range . ; Driver code","code":"< ? php function countMaxSetBits ( $ left , $ right ) { while ( ( $ left | ( $ left + 1 ) ) <= $ right ) $ left |= $ left + 1 ; return $ left ; } $ l = 1 ; $ r = 5 ; echo countMaxSetBits ( $ l , $ r ) , \" STRNEWLINE \" ; $ l = 1 ; $ r = 10 ; echo countMaxSetBits ( $ l , $ r ) ; ? >"}
{"text":"Find if given number is sum of first n natural numbers | Function to find no . of elements to be added to get s ; Apply Binary search ; Find mid ; find sum of 1 to mid natural numbers using formula ; If sum is equal to n return mid ; If greater than n do r = mid - 1 ; else do l = mid + 1 ; If not possible , return - 1 ; Drivers code","code":"< ? php function findS ( $ s ) { $ l = 1 ; $ r = 1 + ( int ) $ s \/ 2 ; while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) \/ 2 ) ; $ sum = ( int ) ( $ mid * ( $ mid + 1 ) \/ 2 ) ; if ( $ sum == $ s ) return $ mid ; else if ( $ sum > $ s ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; } $ s = 15 ; $ n = findS ( $ s ) ; if ( $ n == -1 ) echo \" - 1\" ; else echo $ n ; ? >"}
{"text":"Program to print an array in Pendulum Arrangement with constant space | Function to print the Pendulum arrangement of the given array ; Sort the array ; pos stores the index of the last element of the array ; odd stores the last odd index in the array ; Move all odd index positioned elements to the right ; Shift the elements by one position from odd to pos ; Reverse the element from 0 to ( n - 1 ) \/ 2 ; Printing the pendulum arrangement ; Driver code","code":"< ? php function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr ) ; $ pos = $ n - 1 ; if ( $ n % 2 == 0 ) $ odd = $ n - 1 ; else $ odd = $ n - 2 ; while ( $ odd > 0 ) { $ temp = $ arr [ $ odd ] ; $ in = $ odd ; while ( $ in != $ pos ) { $ arr [ $ in ] = $ arr [ $ in + 1 ] ; $ in ++ ; } $ arr [ $ in ] = $ temp ; $ odd = $ odd - 2 ; $ pos = $ pos - 1 ; } $ start = 0 ; $ end = floor ( ( $ n - 1 ) \/ 2 ) ; for ( ; $ start < $ end ; $ start ++ , $ end -- ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ end ] ; $ arr [ $ end ] = $ temp ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , \" \u2581 \" ; } $ arr = array ( 11 , 2 , 4 , 55 , 6 , 8 ) ; $ n = count ( $ arr ) ; pendulumArrangement ( $ arr , $ n ) ; ? >"}
{"text":"Minimum number greater than the maximum of array which cannot be formed using the numbers in the array | Function that returns the minimum number greater than maximum of the array that cannot be formed using the elements of the array ; Sort the given array ; Maximum number in the array ; table [ i ] will store the minimum number of elements from the array to form i ; Calculate the minimum number of elements from the array required to form the numbers from 1 to ( 2 * max ) ; If there exists a number greater than the maximum element of the array that can be formed using the numbers of array ; Driver code","code":"< ? php function findNumber ( $ arr , $ n ) { sort ( $ arr ) ; $ max = $ arr [ $ n - 1 ] ; $ table = array ( ( 2 * $ max ) + 1 ) ; $ table [ 0 ] = 0 ; for ( $ i = 1 ; $ i < ( 2 * $ max ) + 1 ; $ i ++ ) $ table [ $ i ] = PHP_INT_MAX ; $ ans = -1 ; for ( $ i = 1 ; $ i < ( 2 * $ max ) + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] <= $ i ) { $ res = $ table [ $ i - $ arr [ $ j ] ] ; if ( $ res != PHP_INT_MAX && $ res + 1 < $ table [ $ i ] ) $ table [ $ i ] = $ res + 1 ; } } if ( $ i > $ arr [ $ n - 1 ] && $ table [ $ i ] == PHP_INT_MAX ) { $ ans = $ i ; break ; } } return $ ans ; } { $ arr = array ( 6 , 7 , 15 ) ; $ n = sizeof ( $ arr ) ; echo ( findNumber ( $ arr , $ n ) ) ; }"}
{"text":"Maximum number of segments that can contain the given points | Function to return the maximum number of segments ; Sort both the vectors ; Initially pointing to the first element of b [ ] ; Try to find a match in b [ ] ; The segment ends before b [ j ] ; The point lies within the segment ; The segment starts after b [ j ] ; Return the required count ; Driver code","code":"< ? php function countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) { sort ( $ a ) ; sort ( $ b ) ; $ j = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ a [ $ i ] + $ y < $ b [ $ j ] ) break ; if ( $ b [ $ j ] >= $ a [ $ i ] - $ x && $ b [ $ j ] <= $ a [ $ i ] + $ y ) { $ count ++ ; $ j ++ ; break ; } else $ j ++ ; } } return $ count ; } $ x = 1 ; $ y = 4 ; $ a = array ( 1 , 5 ) ; $ n = count ( $ a ) ; $ b = array ( 1 , 1 , 2 ) ; $ m = count ( $ b ) ; echo countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) ; ? >"}
{"text":"Smallest subarray containing minimum and maximum values | Function to return length of smallest subarray containing both maximum and minimum value ; find maximum and minimum values in the array ; iterate over the array and set answer to smallest difference between position of maximum and position of minimum value ; last occurrence of minValue ; last occurrence of maxValue ; Driver code","code":"< ? php function minSubarray ( $ A , $ n ) { $ minValue = min ( $ A ) ; $ maxValue = max ( $ A ) ; $ pos_min = -1 ; $ pos_max = -1 ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] == $ minValue ) $ pos_min = $ i ; if ( $ A [ $ i ] == $ maxValue ) $ pos_max = $ i ; if ( $ pos_max != -1 and $ pos_min != -1 ) $ ans = min ( $ ans , abs ( $ pos_min - $ pos_max ) + 1 ) ; } return $ ans ; } $ A = array ( 1 , 5 , 9 , 7 , 1 , 9 , 4 ) ; $ n = sizeof ( $ A ) ; echo minSubarray ( $ A , $ n ) ; ? >"}
{"text":"Minimum number of consecutive sequences that can be formed in an array | PHP program find the minimum number of consecutive sequences in an array ; Driver Code ; function call to print required answer","code":"< ? php function countSequences ( $ arr , $ n ) { $ count = 1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; return $ count ; } $ arr = array ( 1 , 7 , 3 , 5 , 10 ) ; $ n = count ( $ arr ) ; echo countSequences ( $ arr , $ n ) ; ? >"}
{"text":"Minimum number of increment \/ decrement operations such that array contains all elements from 1 to N | Function to find the minimum operations ; Sort the given array ; Count operations by assigning a [ i ] = i + 1 ; Driver Code","code":"< ? php function minimumMoves ( $ a , $ n ) { $ operations = 0 ; sort ( $ a ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ operations += abs ( $ a [ $ i ] - ( $ i + 1 ) ) ; return $ operations ; } $ arr = array ( 5 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo minimumMoves ( $ arr , $ n ) ; ? >"}
{"text":"Print a case where the given sorting algorithm fails | Function to print a case where the given sorting algorithm fails ; only case where it fails ; Driver Code","code":"< ? php function printCase ( $ n ) { if ( $ n <= 2 ) { echo ( -1 ) ; return ; } for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { echo ( $ i ) ; echo ( \" \u2581 \" ) ; } } $ n = 3 ; printCase ( $ n ) ; ? >"}
{"text":"Find the missing elements from 1 to M in given N ranges | Function to find missing elements from given Ranges ; First of all sort all the given ranges ; store ans in a different vector ; prev is use to store end of last range ; j is used as a counter for ranges ; for last segment ; finally print all answer ; Driver Code ; Store ranges in vector of pair","code":"< ? php function findMissingNumber ( $ ranges , $ m ) { sort ( $ ranges ) ; $ ans = [ ] ; $ prev = 0 ; for ( $ j = 0 ; $ j < count ( $ ranges ) ; $ j ++ ) { $ start = $ ranges [ $ j ] [ 0 ] ; $ end = $ ranges [ $ j ] [ 1 ] ; for ( $ i = $ prev + 1 ; $ i < $ start ; $ i ++ ) array_push ( $ ans , $ i ) ; $ prev = $ end ; } for ( $ i = $ prev + 1 ; $ i < $ m + 1 ; $ i ++ ) array_push ( $ ans , $ i ) ; for ( $ i = 0 ; $ i < count ( $ ans ) ; $ i ++ ) { if ( $ ans [ $ i ] <= $ m ) echo \" $ ans [ $ i ] \u2581 \" ; } } $ N = 2 ; $ M = 6 ; $ ranges = [ ] ; array_push ( $ ranges , [ 1 , 2 ] ) ; array_push ( $ ranges , [ 4 , 5 ] ) ; findMissingNumber ( $ ranges , $ M ) ? >"}
{"text":"Check whether it is possible to make both arrays equal by modifying a single element | Function to check if both sequences can be made equal ; Sorting both the arrays ; Flag to tell if there are more than one mismatch ; To stores the index of mismatched element ; If there is more than one mismatch then return False ; If there is no mismatch or the difference between the mismatching elements is <= k then return true ; Driver Code","code":"< ? php function check ( $ n , $ k , & $ a , & $ b ) { sort ( $ a ) ; sort ( $ b ) ; $ fl = False ; $ ind = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] != $ b [ $ i ] ) { if ( $ fl == True ) return False ; $ fl = True ; $ ind = $ i ; } } if ( $ ind == -1 || abs ( $ a [ $ ind ] - $ b [ $ ind ] ) <= $ k ) return True ; return False ; } $ n = 2 ; $ k = 4 ; $ a = array ( 1 , 5 ) ; $ b = array ( 1 , 1 ) ; if ( check ( $ n , $ k , $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Sum of width ( max and min diff ) of all Subsequences | PHP implementation of above approach ; Function to return sum of width of all subsets ; Sort the array ; Driver Code","code":"< ? php $ MOD = 1000000007 ; function SubseqWidths ( & $ A , $ n ) { global $ MOD ; sort ( $ A ) ; $ pow2 = array_fill ( 0 , $ n , NULL ) ; $ pow2 [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ pow2 [ $ i ] = ( $ pow2 [ $ i - 1 ] * 2 ) % $ MOD ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans = ( $ ans + ( $ pow2 [ $ i ] - $ pow2 [ $ n - 1 - $ i ] ) * $ A [ $ i ] ) % $ MOD ; return $ ans ; } $ A = array ( 5 , 6 , 4 , 3 , 8 ) ; $ n = sizeof ( $ A ) ; echo SubseqWidths ( $ A , $ n ) ; ? >"}
{"text":"Covering maximum array elements with given value | Function to find value for covering maximum array elements ; sort the students in ascending based on the candies ; To store the number of happy students ; To store the running sum ; If the current student can 't be made happy ; increment the count if we can make the ith student happy ; If the sum = x then answer is n ; If the count is equal to n then the answer is n - 1 ; driver code","code":"< ? php function maxArrayCover ( $ a , $ n , $ x ) { sort ( $ a ) ; $ cc = 0 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s += $ a [ $ i ] ; if ( $ s > $ x ) { break ; } $ cc += 1 ; } if ( array_sum ( $ a ) == $ x ) { return $ n ; } else { if ( $ cc == $ n ) { return $ n - 1 ; } else { return $ cc ; } } } $ n = 3 ; $ x = 70 ; $ a = array ( 10 , 20 , 30 ) ; echo maxArrayCover ( $ a , $ n , $ x ) ; ? >"}
{"text":"Maximum Sum of Products of Two Arrays | Function that calculates maximum sum of products of two arrays ; Variable to store the sum of products of array elements ; length of the arrays ; Sorting both the arrays ; Traversing both the arrays and calculating sum of product ; Driver code","code":"< ? php function maximumSOP ( & $ a , & $ b ) { $ sop = 0 ; $ n = sizeof ( $ a ) ; sort ( $ a ) ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sop = $ sop + ( $ a [ $ i ] * $ b [ $ i ] ) ; } return $ sop ; } $ A = array ( 1 , 2 , 3 ) ; $ B = array ( 4 , 5 , 1 ) ; echo maximumSOP ( $ A , $ B ) ; ? >"}
{"text":"Count number of triplets with product equal to given number | Set 2 | Function to count such triplets ; Sort the array ; three pointer technique ; Calculate the product of a triplet ; Check if that product is greater than m , decrement mid ; Check if that product is smaller than m , increment start ; Check if that product is equal to m , decrement mid , increment start and increment the count of pairs ; Drivers code","code":"< ? php function countTriplets ( $ arr , $ n , $ m ) { $ count = 0 ; sort ( $ arr ) ; $ end ; $ start ; $ mid ; for ( $ end = $ n - 1 ; $ end >= 2 ; $ end -- ) { $ start = 0 ; $ mid = $ end - 1 ; while ( $ start < $ mid ) { $ prod = $ arr [ $ end ] * $ arr [ $ start ] * $ arr [ $ mid ] ; if ( $ prod > $ m ) $ mid -- ; else if ( $ prod < $ m ) $ start ++ ; else if ( $ prod == $ m ) { $ count ++ ; $ mid -- ; $ start ++ ; } } } return $ count ; } $ arr = array ( 1 , 1 , 1 , 1 , 1 , 1 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; $ m = 1 ; echo countTriplets ( $ arr , $ n , $ m ) ; #This  Code is Contributed by ajit NEW_LINE ? >"}
{"text":"Sort 3 numbers | PHP program to sort an array of size 3 ; Insert arr [ 1 ] ; Insert arr [ 2 ] ; Driver Code","code":"< ? php function sort3 ( & $ arr , $ temp ) { if ( $ arr [ 1 ] < $ arr [ 0 ] ) { $ temp [ 0 ] = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 1 ] ; $ arr [ 1 ] = $ temp [ 0 ] ; } if ( $ arr [ 2 ] < $ arr [ 1 ] ) { $ temp [ 0 ] = $ arr [ 1 ] ; $ arr [ 1 ] = $ arr [ 2 ] ; $ arr [ 2 ] = $ temp [ 0 ] ; } if ( $ arr [ 1 ] < $ arr [ 0 ] ) { $ temp [ 0 ] = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 1 ] ; $ arr [ 1 ] = $ temp [ 0 ] ; } } $ a = array ( 10 , 12 , 5 ) ; $ temp1 = array ( 10 ) ; sort3 ( $ a , $ temp1 ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) echo ( $ a [ $ i ] . \" \u2581 \" ) ; ? >"}
{"text":"Print triplets with sum less than k | PHP program to print triplets with sum smaller than a given value ; Sort input array ; Every iteration of loop counts triplet with first element as arr [ i ] . ; Initialize other two elements as corner elements of subarray arr [ j + 1. . k ] ; Use Meet in the Middle concept ; If sum of current triplet is more or equal , move right corner to look for smaller values ; Else move left corner ; This is important . For current i and j , there are total k - j third elements . ; Driver Code","code":"< ? php function printTriplets ( $ arr , $ n , $ sum ) { sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { $ j = $ i + 1 ; $ k = $ n - 1 ; while ( $ j < $ k ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ sum ) $ k -- ; else { for ( $ x = $ j + 1 ; $ x <= $ k ; $ x ++ ) echo $ arr [ $ i ] . \" , \" \u2581 . \u2581 $ arr [ $ j ] \u2581 . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL \" , \" \u2581 . \u2581 $ arr [ $ x ] \u2581 . \u2581 \" \" $ j ++ ; } } } } $ arr = array ( 5 , 1 , 3 , 4 , 7 ) ; $ n = sizeof ( $ arr ) ; $ sum = 12 ; printTriplets ( $ arr , $ n , $ sum ) ; ? >"}
{"text":"Check whether an array can be fit into another array rearranging the elements in the array | Returns true if the array A can be fit into array B , otherwise false ; Sort both the arrays ; Iterate over the loop and check whether every array element of A is less than or equal to its corresponding array element of B ; Driver Code","code":"< ? php function checkFittingArrays ( $ A , $ B , $ N ) { sort ( $ A ) ; sort ( $ B ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] > $ B [ $ i ] ) return false ; return true ; } $ A = array ( 7 , 5 , 3 , 2 ) ; $ B = array ( 5 , 4 , 8 , 7 ) ; $ N = count ( $ A ) ; if ( checkFittingArrays ( $ A , $ B , $ N ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Maximise the number of toys that can be purchased with amount K | This functions returns the required number of toys ; sort the cost array ; Check if we can buy ith toy or not ; Increment the count variable ; Driver Code","code":"< ? php function maximum_toys ( $ cost , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; sort ( $ cost ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ sum + $ cost [ $ i ] <= $ K ) { $ sum = $ sum + $ cost [ $ i ] ; $ count ++ ; } } return $ count ; } $ K = 50 ; $ cost = array ( 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 ) ; $ N = count ( $ cost ) ; echo maximum_toys ( $ cost , $ N , $ K ) , \" STRNEWLINE \" ; ? >"}
{"text":"Check if given array is almost sorted ( elements are at | function for checking almost sort ; One by one compare adjacents . ; check whether resultant is sorted or not ; is resultant is sorted return true ; Driver Code","code":"< ? php function almostSort ( $ A , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) { list ( $ A [ $ i ] , $ A [ $ i + 1 ] ) = array ( $ A [ $ i + 1 ] , $ A [ $ i ] ) ; $ i ++ ; } } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) return false ; return true ; } $ A = array ( 1 , 3 , 2 , 4 , 6 , 5 ) ; $ n = sizeof ( $ A ) ; if ( almostSort ( $ A , $ n ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" Yes \" , \" STRNEWLINE \" ; ? >"}
{"text":"Efficiently merging two sorted arrays with O ( 1 ) extra space | Function to find next gap . ; comparing elements in the first array . ; comparing elements in both arrays . ; comparing elements in the second array . ; Driver code ; Function Call","code":"< ? php function nextGap ( $ gap ) { if ( $ gap <= 1 ) return 0 ; return ( $ gap \/ 2 ) + ( $ gap % 2 ) ; } function merge ( $ arr1 , $ arr2 , $ n , $ m ) { $ i ; $ j ; $ gap = $ n + $ m ; for ( $ gap = nextGap ( $ gap ) ; $ gap > 0 ; $ gap = nextGap ( $ gap ) ) { for ( $ i = 0 ; $ i + $ gap < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] > $ arr1 [ $ i + $ gap ] ) { $ tmp = $ arr1 [ $ i ] ; $ arr1 [ $ i ] = $ arr1 [ $ i + $ gap ] ; $ arr1 [ $ i + $ gap ] = $ tmp ; } for ( $ j = $ gap > $ n ? $ gap - $ n : 0 ; $ i < $ n && $ j < $ m ; $ i ++ , $ j ++ ) if ( $ arr1 [ $ i ] > $ arr2 [ $ j ] ) { $ tmp = $ arr1 [ $ i ] ; $ arr1 [ $ i ] = $ arr2 [ $ j ] ; $ arr2 [ $ j ] = $ tmp ; } if ( $ j < $ m ) { for ( $ j = 0 ; $ j + $ gap < $ m ; $ j ++ ) if ( $ arr2 [ $ j ] > $ arr2 [ $ j + $ gap ] ) { $ tmp = $ arr2 [ $ j ] ; $ arr2 [ $ j ] = $ arr2 [ $ j + $ gap ] ; $ arr2 [ $ j + $ gap ] = $ tmp ; } } } echo \" First \u2581 Array : \u2581 \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr1 [ $ i ] . \" \u2581 \" ; echo \" Second Array : \" for ( $ i = 0 ; $ i < $ m ; $ i ++ ) echo $ arr2 [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ a1 = array ( 10 , 27 , 38 , 43 , 82 ) ; $ a2 = array ( 3 , 9 ) ; $ n = sizeof ( $ a1 ) ; $ m = sizeof ( $ a2 ) ; merge ( $ a1 , $ a2 , $ n , $ m ) ; ? >"}
{"text":"Merge two sorted arrays | Merge $arr1 [ 0. . $n1 - 1 ] and $arr2 [ 0. . $n2 - 1 ] into $arr3 [ 0. . $n1 + $n2 - 1 ] ; Traverse both array ; Check if current element of first array is smaller than current element of second array . If yes , store first array element and increment first array index . Otherwise do same with second array ; Store remaining elements of first array ; Store remaining elements of second array ; Driver code","code":"< ? php function mergeArrays ( & $ arr1 , & $ arr2 , $ n1 , $ n2 , & $ arr3 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ arr3 [ $ k ++ ] = $ arr1 [ $ i ++ ] ; else $ arr3 [ $ k ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ n1 ) $ arr3 [ $ k ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n2 ) $ arr3 [ $ k ++ ] = $ arr2 [ $ j ++ ] ; } $ arr1 = array ( 1 , 3 , 5 , 7 ) ; $ n1 = sizeof ( $ arr1 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 ) ; $ n2 = sizeof ( $ arr2 ) ; $ arr3 [ $ n1 + $ n2 ] = array ( ) ; mergeArrays ( $ arr1 , $ arr2 , $ n1 , $ n2 , $ arr3 ) ; echo \" Array \u2581 after \u2581 merging \u2581 STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n1 + $ n2 ; $ i ++ ) echo $ arr3 [ $ i ] . \" \u2581 \" ; ? >"}
{"text":"Chocolate Distribution Problem | arr [ 0. . n - 1 ] represents sizes of packets m is number of students . Returns minimum difference between maximum and minimum values of distribution . ; if there are no chocolates or number of students is 0 ; Sort the given packets ; Number of students cannot be more than number of packets ; Largest number of chocolates ; Find the subarray of size m such that difference between last ( maximum in case of sorted ) and first ( minimum in case of sorted ) elements of subarray is minimum . ; Driver Code ; $m = 7 ; Number of students","code":"< ? php function findMinDiff ( $ arr , $ n , $ m ) { if ( $ m == 0 $ n == 0 ) return 0 ; sort ( $ arr ) ; if ( $ n < $ m ) return -1 ; $ min_diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i + $ m - 1 < $ n ; $ i ++ ) { $ diff = $ arr [ $ i + $ m - 1 ] - $ arr [ $ i ] ; if ( $ diff < $ min_diff ) $ min_diff = $ diff ; } return $ min_diff ; } $ arr = array ( 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum \u2581 difference \u2581 is \u2581 \" , findMinDiff ( $ arr , $ n , $ m ) ; ? >"}
{"text":"Absolute distinct count in a sorted array | The function returns return number of distinct absolute values among the elements of the array ; initialize count as number of elements ; Remove duplicate elements from the left of the current window ( i , j ) and also decrease the count ; Remove duplicate elements from the right of the current window ( i , j ) and also decrease the count ; break if only one element is left ; Now look for the zero sum pair in current window ( i , j ) ; decrease the count if ( positive , negative ) pair is encountered ; Driver code","code":"< ? php function distinctCount ( $ arr , $ n ) { $ count = $ n ; $ i = 0 ; $ j = $ n - 1 ; $ sum = 0 ; while ( $ i < $ j ) { while ( $ i != $ j && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count -- ; $ i ++ ; } while ( $ i != $ j && $ arr [ $ j ] == $ arr [ $ j - 1 ] ) { $ count -- ; $ j -- ; } if ( $ i == $ j ) break ; $ sum = $ arr [ $ i ] + $ arr [ $ j ] ; if ( $ sum == 0 ) { $ count -- ; $ i ++ ; $ j -- ; } else if ( $ sum < 0 ) $ i ++ ; else $ j -- ; } return $ count ; } $ arr = array ( -2 , -1 , 0 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; echo \" Count \u2581 of \u2581 absolute \u2581 distinct \u2581 values \u2581 : \u2581 \" . distinctCount ( $ arr , $ n ) ; ? >"}
{"text":"Sort an almost sorted array where only two elements are swapped | This function sorts an array that can be sorted by single swap ; Traverse the given array from rightmost side ; Check if arr [ i ] is not in order ; Find the other element to be swapped with arr [ i ] ; Swap the pair ; A utility function to print an array of size n ; Driver Code","code":"< ? php function sortByOneSwap ( & $ arr , $ n ) { for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ arr [ $ i ] < $ arr [ $ i - 1 ] ) { $ j = $ i - 1 ; while ( $ j >= 0 && $ arr [ $ i ] < $ arr [ $ j ] ) $ j -- ; $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j + 1 ] ; $ arr [ $ j + 1 ] = $ temp ; break ; } } } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 10 , 30 , 20 , 40 , 50 , 60 , 70 ) ; $ n = sizeof ( $ arr ) ; echo \" Given \u2581 array \u2581 is \u2581 \" . \" STRNEWLINE \" ; printArray ( $ arr , $ n ) ; sortByOneSwap ( $ arr , $ n ) ; echo \" Sorted \u2581 array \u2581 is \u2581 \" . \" STRNEWLINE \" ; printArray ( $ arr , $ n ) ;"}
{"text":"Pancake sorting | Reverses arr [ 0. . i ] ; Returns index of the maximum element in arr [ 0. . n - 1 ] ; The main function that sorts given array using flip operations ; Start from the complete array and one by one reduce current size by one ; Find index of the maximum element in arr [ 0. . curr_size - 1 ] ; Move the maximum element to end of current array if it 's not already  at the end ; To move at the end , first move maximum number to beginning ; Now move the maximum number to end by reversing current array ; A utility function to print n array of size n ; Driver code","code":"< ? php function flip ( & $ arr , $ i ) { $ start = 0 ; while ( $ start < $ i ) { $ temp = $ arr [ $ start ] ; $ arr [ $ start ] = $ arr [ $ i ] ; $ arr [ $ i ] = $ temp ; $ start ++ ; $ i -- ; } } function findMax ( $ arr , $ n ) { $ mi = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ mi ] ) $ mi = $ i ; return $ mi ; } function pancakeSort ( & $ arr , $ n ) { for ( $ curr_size = $ n ; $ curr_size > 1 ; -- $ curr_size ) { $ mi = findMax ( $ arr , $ curr_size ) ; if ( $ mi != $ curr_size - 1 ) { flip ( $ arr , $ mi ) ; flip ( $ arr , $ curr_size -1 ) ; } } } function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; ++ $ i ) print ( $ arr [ $ i ] . \" \u2581 \" ) ; } $ arr = array ( 23 , 10 , 20 , 11 , 12 , 6 , 7 ) ; $ n = count ( $ arr ) ; pancakeSort ( $ arr , $ n ) ; echo ( \" Sorted \u2581 Array \u2581 STRNEWLINE \" ) ; printArray ( $ arr , $ n ) ; return 0 ; ? >"}
{"text":"Maximize the given number by replacing a segment of digits with the alternate digits given | PHP implementation of the approach Function to return the maximized number ; Iterate till the end of the string ; Check if it is greater or not ; Replace with the alternate till smaller ; Return original s in case no change took place ; Driver Code ; This Code is contributed is Tushill .","code":"< ? php function get_maximum ( $ s , $ a ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] - '0' < $ a [ $ s [ $ i ] - '0' ] ) { $ j = $ i ; while ( $ j < $ n && ( $ s [ $ j ] - '0' <= $ a [ $ s [ $ j ] - '0' ] ) ) { $ s [ $ j ] = '0' + $ a [ $ s [ $ j ] - '0' ] ; $ j ++ ; } return $ s ; } } return $ s ; } $ s = \"1337\" ; $ a = array ( 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ) ; echo get_maximum ( $ s , $ a ) ; ? >"}
{"text":"Number of times the largest perfect square number can be subtracted from N | Function to return the count of steps ; Variable to store the count of steps ; Iterate while N > 0 ; Get the largest perfect square and subtract it from N ; Increment steps ; Return the required count ; Driver code","code":"< ? php function countSteps ( $ n ) { $ steps = 0 ; while ( $ n ) { $ largest = ( int ) sqrt ( $ n ) ; $ n -= ( $ largest * $ largest ) ; $ steps ++ ; } return $ steps ; } $ n = 85 ; echo countSteps ( $ n ) ; ? >"}
{"text":"Maximum array sum that can be obtained after exactly k changes | Utility function to return the sum of the array elements ; Function to return the maximized sum of the array after performing the given operation exactly k times ; Sort the array elements ; Change signs of the negative elements starting from the smallest ; If a single operation has to be performed then it must be performed on the smallest positive element ; To store the index of the minimum element ; Update the minimum index ; Perform remaining operation on the smallest element ; Return the sum of the updated array ; Driver code","code":"< ? php function sumArr ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; return $ sum ; } function maxSum ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n && $ k > 0 && $ arr [ $ i ] < 0 ) { $ arr [ $ i ] *= -1 ; $ k -- ; $ i ++ ; } if ( $ k % 2 == 1 ) { $ min = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ min ] > $ arr [ $ i ] ) $ min = $ i ; $ arr [ $ min ] *= -1 ; } return sumArr ( $ arr , $ n ) ; } $ arr = array ( -5 , 4 , 1 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; $ k = 4 ; echo maxSum ( $ arr , $ n , $ k ) , \" STRNEWLINE \" ; ? >"}
{"text":"Given count of digits 1 , 2 , 3 , 4 , find the maximum sum possible | Function to find the maximum possible sum ; To store required sum ; Number of 234 's can be formed ; Sum obtained with 234 s ; Remaining 2 's ; Sum obtained with 12 s ; Return the required sum ; Driver code","code":"< ? php function Maxsum ( $ c1 , $ c2 , $ c3 , $ c4 ) { $ sum = 0 ; $ two34 = min ( $ c2 , min ( $ c3 , $ c4 ) ) ; $ sum = $ two34 * 234 ; $ c2 -= $ two34 ; $ sum += min ( $ c2 , $ c1 ) * 12 ; return $ sum ; } $ c1 = 5 ; $ c2 = 2 ; $ c3 = 3 ; $ c4 = 4 ; echo Maxsum ( $ c1 , $ c2 , $ c3 , $ c4 ) ; ? >"}
{"text":"Count of pairs from 1 to a and 1 to b whose sum is divisible by N | Function to find the distinct pairs from 1 - a & 1 - b such that their sum is divisible by n . ; pairs from 1 to n * ( a \/ n ) and 1 to n * ( b \/ n ) ; pairs from 1 to n * ( a \/ n ) and n * ( b \/ n ) to b ; pairs from n * ( a \/ n ) to a and 1 to n * ( b \/ n ) ; pairs from n * ( a \/ n ) to a and n * ( b \/ n ) to b ; Return answer ; Driver code","code":"< ? php function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; $ ans += $ n * ( int ) ( $ a \/ $ n ) * ( int ) ( $ b \/ $ n ) ; $ ans += ( int ) ( $ a \/ $ n ) * ( $ b % $ n ) ; $ ans += ( $ a % $ n ) * ( int ) ( $ b \/ $ n ) ; $ ans += ( ( $ a % $ n ) + ( int ) ( $ b % $ n ) ) \/ $ n ; return $ ans ; } $ a = 5 ; $ b = 13 ; $ n = 3 ; echo findCountOfPairs ( $ a , $ b , $ n ) ; ? >"}
{"text":"Generate array with minimum sum which can be deleted in P steps | Function to find the required array ; calculating minimum possible sum ; Array ; place first P natural elements ; Fill rest of the elements with 1 ; Driver Code","code":"< ? php function findArray ( $ N , $ P ) { $ ans = ( $ P * ( $ P + 1 ) ) \/ 2 + ( $ N - $ P ) ; $ arr [ $ N + 1 ] = array ( ) ; for ( $ i = 1 ; $ i <= $ P ; $ i ++ ) $ arr [ $ i ] = $ i ; for ( $ i = $ P + 1 ; $ i <= $ N ; $ i ++ ) $ arr [ $ i ] = 1 ; echo \" The \u2581 Minimum \u2581 Possible \u2581 Sum \u2581 is : \u2581 \" , $ ans , \" STRNEWLINE \" ; echo \" The \u2581 Array \u2581 Elements \u2581 are : \u2581 STRNEWLINE \" ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ arr [ $ i ] , ' \u2581 ' ; } $ N = 5 ; $ P = 3 ; findArray ( $ N , $ P ) ; ? >"}
{"text":"Find Intersection of all Intervals | Function to print the intersection ; First interval ; Check rest of the intervals and find the intersection ; If no intersection exists ; Else update the intersection ; Driver code","code":"< ? php function findIntersection ( $ intervals , $ N ) { $ l = $ intervals [ 0 ] [ 0 ] ; $ r = $ intervals [ 0 ] [ 1 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { if ( $ intervals [ $ i ] [ 0 ] > $ r $ intervals [ $ i ] [ 1 ] < $ l ) { echo - 1 ; return ; } else { $ l = max ( $ l , $ intervals [ $ i ] [ 0 ] ) ; $ r = min ( $ r , $ intervals [ $ i ] [ 1 ] ) ; } } echo \" [ \" \u2581 . \u2581 $ l \u2581 . \u2581 \" , \" \u2581 . \u2581 $ r \u2581 . \u2581 \" ] \" ; } $ intervals = array ( array ( 1 , 6 ) , array ( 2 , 8 ) , array ( 3 , 10 ) , array ( 5 , 8 ) ) ; $ N = sizeof ( $ intervals ) ; findIntersection ( $ intervals , $ N ) ; ? >"}
{"text":"Maximum size of sub | Function that compares a and b ; Function to return length of longest subarray that satisfies one of the given conditions ; Driver Code ; Print the required answer","code":"< ? php function cmp ( $ a , $ b ) { return ( $ a > $ b ) - ( $ a < $ b ) ; } function maxSubarraySize ( $ arr ) { $ N = sizeof ( $ arr ) ; $ ans = 1 ; $ anchor = 0 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ c = cmp ( $ arr [ $ i - 1 ] , $ arr [ $ i ] ) ; if ( $ c == 0 ) $ anchor = $ i ; else if ( $ i == $ N - 1 or $ c * cmp ( $ arr [ $ i ] , $ arr [ $ i + 1 ] ) != -1 ) { $ ans = max ( $ ans , $ i - $ anchor + 1 ) ; $ anchor = $ i ; } } return $ ans ; } $ arr = array ( 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 ) ; echo maxSubarraySize ( $ arr ) ; ? >"}
{"text":"Count valid pairs in the array satisfying given conditions | Function to return total valid pairs ; Initialize count of all the elements ; frequency count of all the elements ; Add total valid pairs ; Exclude pairs made with a single element i . e . ( x , x ) ; Driver Code ; Function call to print required answer","code":"< ? php function ValidPairs ( $ arr , $ n ) { $ count = array_fill ( 0 , 121 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ $ arr [ $ i ] ] += 1 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) continue ; if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) % 2 == 1 ) continue ; $ ans += $ count [ $ arr [ $ i ] ] * $ count [ $ arr [ $ j ] ] ; if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ ans -= $ count [ $ arr [ $ i ] ] ; } return $ ans ; } $ arr = array ( 16 , 17 , 18 ) ; $ n = count ( $ arr ) ; echo ( ValidPairs ( $ arr , $ n ) ) ; ? >"}
{"text":"Minimum number of 1 's to be replaced in a binary array | Function to find minimum number of 1 ' s \u2581 to \u2581 be \u2581 replaced \u2581 to \u2581 0' s ; return final answer ; Driver Code","code":"< ? php function minChanges ( $ A , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { if ( ( $ i - 1 >= 0 ) && $ A [ $ i - 1 ] == 1 && $ A [ $ i + 1 ] == 1 && $ A [ $ i ] == 0 ) { $ A [ $ i + 1 ] = 0 ; $ cnt ++ ; } } return $ cnt ; } $ A = array ( 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ) ; $ n = sizeof ( $ A ) ; echo minChanges ( $ A , $ n ) ; ? >"}
{"text":"Number of closing brackets needed to complete a regular bracket sequence | Function to find number of closing brackets and complete a regular bracket sequence ; Finding the length of sequence ; Counting opening brackets ; Counting closing brackets ; Checking if at any position the number of closing bracket is more then answer is impossible ; If possible , print ' s ' and required closing brackets . ; Driver Code","code":"< ? php function completeSequence ( $ s ) { $ n = strlen ( $ s ) ; $ open = 0 ; $ close = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' ( ' ) $ open ++ ; else $ close ++ ; if ( $ close > $ open ) { echo ( \" IMPOSSIBLE \" ) ; return ; } } echo ( $ s ) ; for ( $ i = 0 ; $ i < $ open - $ close ; $ i ++ ) echo ( \" ) \" ) ; } $ s = \" ( ( ) ( ( ) ( \" ; completeSequence ( $ s ) ; ? >"}
{"text":"Lexicographically smallest permutation with no digits at Original Index | Function to print the smallest permutation ; when n is even ; when n is odd ; handling last 3 digit ; add EOL and print result ; Driver Code","code":"< ? php function smallestPermute ( $ n ) { $ res = array_fill ( 0 , $ n + 1 , \" \" ) ; if ( $ n % 2 == 0 ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ res [ $ i ] = chr ( 48 + $ i + 2 ) ; else $ res [ $ i ] = chr ( 48 + $ i ) ; } } else { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { if ( $ i % 2 == 0 ) $ res [ $ i ] = chr ( 48 + $ i + 2 ) ; else $ res [ $ i ] = chr ( 48 + $ i ) ; } $ res [ $ n - 1 ] = chr ( 48 + $ n - 2 ) ; $ res [ $ n - 2 ] = chr ( 48 + $ n ) ; $ res [ $ n - 3 ] = chr ( 48 + $ n - 1 ) ; } $ res [ $ n ] = ' \\0' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ res [ $ i ] ; } } $ n = 7 ; smallestPermute ( $ n ) ; ? >"}
{"text":"Minimum array insertions required to make consecutive difference <= K | Function to return minimum number of insertions required ; Initialize insertions to 0 ; return total insertions ; Driver Code","code":"< ? php function minInsertions ( $ H , $ n , $ K ) { $ inser = 0 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) { $ diff = abs ( $ H [ $ i ] - $ H [ $ i - 1 ] ) ; if ( $ diff <= $ K ) continue ; else $ inser += ceil ( $ diff \/ $ K ) - 1 ; } return $ inser ; } $ H = array ( 2 , 4 , 8 , 16 ) ; $ K = 3 ; $ n = sizeof ( $ H ) ; echo minInsertions ( $ H , $ n , $ K ) ; ? >"}
{"text":"Minimum number of operations required to reduce N to 1 | Function that returns the minimum number of operations to be performed to reduce the number to 1 ; To stores the total number of operations to be performed ; if n is divisible by 3 then reduce it to n \/ 3 ; if n modulo 3 is 1 decrement it by 1 ; if n modulo 3 is 2 then increment it by 1 ; update the counter ; Driver code","code":"< ? php function count_minimum_operations ( $ n ) { $ count = 0 ; while ( $ n > 1 ) { if ( $ n % 3 == 0 ) $ n \/= 3 ; else if ( $ n % 3 == 1 ) $ n -- ; else { if ( $ n == 2 ) $ n -- ; else $ n ++ ; } $ count ++ ; } return $ count ; } $ n = 4 ; $ ans = count_minimum_operations ( $ n ) ; echo $ ans , \" STRNEWLINE \" ; ? >"}
{"text":"Maximize the sum of array by multiplying prefix of array with | PHP implementation of the approach ; To store sum ; To store ending indices of the chosen prefix arrays ; Adding the absolute value of a [ i ] ; If i == 0 then there is no index to be flipped in ( i - 1 ) position ; print the maximised sum ; print the ending indices of the chosen prefix arrays ; Driver Code","code":"< ? php function maxSum ( $ a , $ n ) { $ s = 0 ; $ l = array ( ) ; for ( $ i = 0 ; $ i < count ( $ a ) ; $ i ++ ) { $ s += abs ( $ a [ $ i ] ) ; if ( $ a [ $ i ] >= 0 ) continue ; if ( $ i == 0 ) array_push ( $ l , $ i + 1 ) ; else { array_push ( $ l , $ i + 1 ) ; array_push ( $ l , $ i ) ; } } echo $ s . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < count ( $ l ) ; $ i ++ ) echo $ l [ $ i ] . \" \u2581 \" ; } $ n = 4 ; $ a = array ( 1 , -2 , -3 , 4 ) ; maxSum ( $ a , $ n ) ; ? >"}
{"text":"Find the longest common prefix between two strings after performing swaps on second string | PHP program to find the longest common prefix between two strings after performing swaps on the second string ; $a = strlen ( $x ) ; length of x $b = strlen ( $y ) ; length of y ; creating frequency array of characters of y ; storing the length of longest common prefix ; checking if the frequency of the character at position i in x in b is greater than zero or not if zero we increase the prefix count by 1 ; Driver Code","code":"< ? php function LengthLCP ( $ x , $ y ) { $ fr = array_fill ( 0 , 26 , NULL ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) { $ fr [ ord ( $ y [ $ i ] ) - 97 ] += 1 ; } $ c = 0 ; for ( $ i = 0 ; $ i < $ a ; $ i ++ ) { if ( $ fr [ ord ( $ x [ $ i ] ) - 97 ] > 0 ) { $ c += 1 ; $ fr [ ord ( $ x [ $ i ] ) - 97 ] -= 1 ; } else break ; } echo $ c ; } $ x = \" here \" ; $ y = \" there \" ; LengthLCP ( $ x , $ y ) ; return 0 ; ? >"}
{"text":"All possible co | Function to count possible pairs ; total count of numbers in range ; printing count of pairs ; Driver code","code":"< ? php function CountPair ( $ L , $ R ) { $ x = ( $ R - $ L + 1 ) ; echo $ x \/ 2 , \" STRNEWLINE \" ; } $ L = 1 ; $ R = 8 ; CountPair ( $ L , $ R ) ; ? >"}
{"text":"Problems not solved at the end of Nth day | Function to find problems not solved at the end of Nth day ; Driver Code","code":"< ? php function problemsLeft ( $ K , $ P , $ N ) { if ( $ K <= $ P ) return 0 ; else return ( $ K - $ P ) * $ N ; } $ K = 4 ; $ P = 1 ; $ N = 10 ; echo problemsLeft ( $ K , $ P , $ N ) ; ? >"}
{"text":"Number of chocolates left after k iterations | Function to find the chocolates left ; Driver code","code":"< ? php function results ( $ n , $ k ) { return round ( pow ( $ n , ( 1.0 \/ pow ( 2 , $ k ) ) ) ) ; } $ k = 3 ; $ n = 100000000 ; echo ( \" Chocolates \u2581 left \u2581 after \u2581 \" ) ; echo ( $ k ) ; echo ( \" \u2581 iterations \u2581 are \u2581 \" ) ; echo ( results ( $ n , $ k ) ) ; ? >"}
{"text":"Make array elements equal in Minimum Steps | Returns the minimum steps required to make an array of N elements equal , where the first array element equals M ; Corner Case 1 : When N = 1 ; Corner Case 2 : When N = 2 else if ( $N == 2 ) corner case 2 ; Driver Code","code":"< ? php function steps ( $ N , $ M ) { if ( $ N == 1 ) return 0 ; return $ M ; return 2 * $ M + ( $ N - 3 ) ; } $ N = 4 ; $ M = 4 ; echo steps ( $ N , $ M ) ; ? >"}
{"text":"Check if it is possible to survive on Island | Function to find the minimum $days ; If we can not buy at least a week supply of food during the first week OR We can not buy a day supply of food on the first day then we can 't survive. ; If we can survive then we can buy ceil ( A \/ N ) times where A is total units of food required . ; Driver code","code":"< ? php function survival ( $ S , $ N , $ M ) { if ( ( ( $ N * 6 ) < ( $ M * 7 ) && $ S > 6 ) $ M > $ N ) echo \" No \" ; else { $ days = ( $ M * $ S ) \/ $ N ; if ( ( ( $ M * $ S ) % $ N ) != 0 ) $ days ++ ; echo \" Yes \u2581 \" , floor ( $ days ) ; } } $ S = 10 ; $ N = 16 ; $ M = 2 ; survival ( $ S , $ N , $ M ) ; ? >"}
