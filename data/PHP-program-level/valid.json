{"text":"Program to convert Centimeters to Pixels | Function to convert centimeter to pixels ; Driver Code","code":"< ? php function Conversion ( $ centi ) { $ pixels = ( 96 * $ centi ) \/ 2.54 ; echo ( $ pixels . \" \" ) ; } $ centi = 15 ; Conversion ( $ centi ) ; ? >"}
{"text":"Find the maximum possible value of the minimum value of modified array | Function to find the maximum possible value of the minimum value of the modified array ; To store minimum value of array ; To store sum of elements of array ; Solution is not possible ; zero is the possible value ; minimum possible value ; maximum possible value ; to store a required answer ; Binary Search ; If mid is possible then try to increase required answer ; If mid is not possible then decrease required answer ; Return required answer ; Driver Code","code":"< ? php function maxOfMin ( $ a , $ n , $ S ) { $ mi = PHP_INT_MAX ; $ s1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s1 += $ a [ $ i ] ; $ mi = min ( $ a [ $ i ] , $ mi ) ; } if ( $ s1 < $ S ) return -1 ; if ( $ s1 == $ S ) return 0 ; $ low = 0 ; $ high = $ mi ; $ ans ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) \/ 2 ; if ( $ s1 - ( $ mid * $ n ) >= $ S ) { $ ans = $ mid ; $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; } $ a = array ( 10 , 10 , 10 , 10 , 10 ) ; $ S = 10 ; $ n = sizeof ( $ a ) ; echo maxOfMin ( $ a , $ n , $ S ) ; ? >"}
{"text":"Program to print ' N ' alphabet using the number pattern from 1 to n | Function to print the desired Alphabet N Pattern ; Declaring the values of Right , Left and Diagonal values ; Main Loop for the rows ; For the left Values ; Spaces for the diagonals ; Condition for the diagonals ; Spaces for the Right Values ; For the right values ; Size of the Pattern ; Calling the function to print the desired Pattern","code":"< ? php function Alphabet_N_Pattern ( $ N ) { $ index ; $ side_index ; $ size ; $ Right = 1 ; $ Left = 1 ; $ Diagonal = 2 ; for ( $ index = 0 ; $ index < $ N ; $ index ++ ) { echo $ Left ++ ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ index ) ; $ side_index ++ ) echo \" \u2581 \" ; if ( $ index != 0 && $ index != $ N - 1 ) echo $ Diagonal ++ ; else echo \" \u2581 \" ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ N - $ index - 1 ) ; $ side_index ++ ) echo \" \u2581 \" ; echo $ Right ++ ; echo \" STRNEWLINE \" ; } } $ Size = 6 ; Alphabet_N_Pattern ( $ Size ) ; ? >"}
{"text":"Check if the sum of digits of a number N divides it | Function to check if sum of digits of a number divides it ; Calculate sum of all of digits of N ; Driver Code","code":"< ? php function isSumDivides ( $ N ) { $ temp = $ N ; $ sum = 0 ; while ( $ temp ) { $ sum += $ temp % 10 ; $ temp = ( int ) $ temp \/ 10 ; } if ( $ N % $ sum == 0 ) return 1 ; else return 0 ; } $ N = 12 ; if ( isSumDivides ( $ N ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text":"Sum of numbers from 1 to N which are divisible by 3 or 4 | Function to calculate the sum of numbers divisible by 3 or 4 ; Driver Code","code":"< ? php function sum ( $ N ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = ( ( $ N \/ 3 ) ) * ( 2 * 3 + ( $ N \/ 3 - 1 ) * 3 ) \/ 2 ; $ S2 = ( ( $ N \/ 4 ) ) * ( 2 * 4 + ( $ N \/ 4 - 1 ) * 4 ) \/ 2 ; $ S3 = ( ( $ N \/ 12 ) ) * ( 2 * 12 + ( $ N \/ 12 - 1 ) * 12 ) \/ 2 ; return $ S1 + $ S2 - $ S3 ; } $ N = 20 ; echo sum ( 12 ) ; ? >"}
{"text":"Next greater number than N with exactly one bit different in binary representation of N | Function to find next greater number than N with exactly one bit different in binary representation of N ; It is guaranteed that there is a bit zero in the number ; If the shifted bit is zero then break ; increase the bit shift ; increase the power of 2 ; set the lowest bit of the number ; Driver code ; display the next number","code":"< ? php function nextGreater ( $ N ) { $ power_of_2 = 1 ; $ shift_count = 0 ; while ( true ) { if ( ( ( $ N >> $ shift_count ) & 1 ) % 2 == 0 ) break ; $ shift_count ++ ; $ power_of_2 = $ power_of_2 * 2 ; } return ( $ N + $ power_of_2 ) ; } $ N = 11 ; echo \" The \u2581 next \u2581 number \u2581 is \u2581 = \u2581 \" , nextGreater ( $ N ) ; ? >"}
{"text":"Tetranacci Numbers | Function to print the N - th tetranacci number ; base cases ; Driver code","code":"< ? php function printTetra ( $ n ) { $ dp = array_fill ( 0 , $ n + 5 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = $ dp [ 2 ] = 1 ; $ dp [ 3 ] = 2 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] + $ dp [ $ i - 4 ] ; echo $ dp [ $ n ] ; } $ n = 10 ; printTetra ( $ n ) ; ? >"}
{"text":"Maximum sum in circular array such that no two elements are adjacent | Function to calculate the sum from 0 th position to ( n - 2 ) th position ; copy the element of original array to dp [ ] ; find the maximum element in the array ; start from 2 nd to n - 1 th pos ; traverse for all pairs bottom - up approach ; dp - condition ; find maximum sum ; return the maximum ; Function to find the maximum sum from 1 st position to n - 1 - th position ; Traverse from third to n - th pos ; bootom - up approach ; dp condition ; find max sum ; return max ; Driver Code","code":"< ? php function maxSum1 ( $ arr , $ n ) { $ dp [ $ n ] = array ( ) ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; if ( $ maxi < $ arr [ $ i ] ) $ maxi = $ arr [ $ i ] ; } for ( $ i = 2 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i - 1 ; $ j ++ ) { if ( $ dp [ $ i ] < $ dp [ $ j ] + $ arr [ $ i ] ) { $ dp [ $ i ] = $ dp [ $ j ] + $ arr [ $ i ] ; if ( $ maxi < $ dp [ $ i ] ) $ maxi = $ dp [ $ i ] ; } } } return $ maxi ; } function maxSum2 ( $ arr , $ n ) { $ dp [ $ n ] = array ( ) ; $ maxi = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; if ( $ maxi < $ arr [ $ i ] ) $ maxi = $ arr [ $ i ] ; } for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i - 1 ; $ j ++ ) { if ( $ dp [ $ i ] < $ arr [ $ i ] + $ dp [ $ j ] ) { $ dp [ $ i ] = $ arr [ $ i ] + $ dp [ $ j ] ; if ( $ maxi < $ dp [ $ i ] ) $ maxi = $ dp [ $ i ] ; } } } return $ maxi ; } function findMaxSum ( $ arr , $ n ) { return max ( maxSum1 ( $ arr , $ n ) , maxSum2 ( $ arr , $ n ) ) ; } $ arr = array ( 1 , 2 , 3 , 1 ) ; $ n = sizeof ( $ arr ) ; echo findMaxSum ( $ arr , $ n ) ; ? >"}
{"text":"Permutation Coefficient | Returns value of Permutation Coefficient P ( n , k ) ; Calculate value of Permutation Coefficient in bottom up manner ; Base Cases ; Calculate value using previosly stored values ; This step is important as P ( i , j ) = 0 for j > i ; Driver Code","code":"< ? php function permutationCoeff ( $ n , $ k ) { $ P = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ k ) ; $ j ++ ) { if ( $ j == 0 ) $ P [ $ i ] [ $ j ] = 1 ; else $ P [ $ i ] [ $ j ] = $ P [ $ i - 1 ] [ $ j ] + ( $ j * $ P [ $ i - 1 ] [ $ j - 1 ] ) ; $ P [ $ i ] [ $ j + 1 ] = 0 ; } } return $ P [ $ n ] [ $ k ] ; } $ n = 10 ; $ k = 2 ; echo \" Value \u2581 of \u2581 P ( \" , $ n , \" \u2581 , \" , $ k , \" ) \u2581 is \u2581 \" , permutationCoeff ( $ n , $ k ) ; ? >"}
{"text":"Permutation Coefficient | Returns value of Permutation Coefficient P ( n , k ) ; base case ; Calculate value factorials up to n ; P ( n , k ) = n ! \/ ( n - k ) ! ; Driver Code","code":"< ? php function permutationCoeff ( $ n , $ k ) { $ fact = array ( ) ; $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ i * $ fact [ $ i - 1 ] ; return $ fact [ $ n ] \/ $ fact [ $ n - $ k ] ; } $ n = 10 ; $ k = 2 ; echo \" Value \u2581 of \u2581 P ( \" , $ n , \" \u2581 \" , $ k , \" ) \u2581 is \u2581 \" , permutationCoeff ( $ n , $ k ) ; ? >"}
{"text":"Dynamic Programming | Returns true if there is a subset of set with sun equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; Driver Code","code":"< ? php function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = 6 ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; else echo \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; ? >"}
{"text":"Number of ways to remove a sub | Function to return the number of ways of removing a sub - string from $s such that all the remaining characters are same ; To store the count of prefix and suffix ; Loop to count prefix ; Loop to count suffix ; First and last characters of the string are same ; Otherwise ; Driver Code","code":"< ? php function no_of_ways ( $ s ) { $ n = strlen ( $ s ) ; $ count_left = 0 ; $ count_right = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ s [ $ i ] == $ s [ 0 ] ) { ++ $ count_left ; } else break ; } for ( $ i = $ n - 1 ; $ i >= 0 ; -- $ i ) { if ( $ s [ $ i ] == $ s [ $ n - 1 ] ) { ++ $ count_right ; } else break ; } if ( $ s [ 0 ] == $ s [ $ n - 1 ] ) return ( ( $ count_left + 1 ) * ( $ count_right + 1 ) ) ; else return ( $ count_left + $ count_right + 1 ) ; } $ s = \" geeksforgeeks \" ; echo no_of_ways ( $ s ) ; ? >"}
{"text":"Count number of indices such that s [ i ] = s [ i + 1 ] : Range queries | Function to create prefix array ; Function to return the result of the query ; Driver Code ; Query 1 ; Query 2","code":"< ? php function preCompute ( $ n , $ s , & $ pref ) { $ pref [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ pref [ $ i ] = $ pref [ $ i - 1 ] ; if ( $ s [ $ i - 1 ] == $ s [ $ i ] ) $ pref [ $ i ] ++ ; } } function query ( & $ pref , $ l , $ r ) { return $ pref [ $ r ] - $ pref [ $ l ] ; } $ s = \" ggggggg \" ; $ n = strlen ( $ s ) ; $ pref = array_fill ( 0 , $ n , NULL ) ; preCompute ( $ n , $ s , $ pref ) ; $ l = 1 ; $ r = 2 ; echo query ( $ pref , $ l , $ r ) . \" STRNEWLINE \" ; $ l = 1 ; $ r = 5 ; echo query ( $ pref , $ l , $ r ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find the direction from given string | Function to find the final direction ; if count is positive that implies resultant is clockwise direction ; if count is negative that implies resultant is anti - clockwise direction ; Driver code","code":"< ? php function findDirection ( $ s ) { $ count = 0 ; $ d = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ 0 ] == ' ' ) return null ; if ( $ s [ $ i ] == ' L ' ) $ count -= 1 ; else { if ( $ s [ $ i ] == ' R ' ) $ count += 1 ; } } if ( $ count > 0 ) { if ( $ count % 4 == 0 ) $ d = \" N \" ; else if ( $ count % 4 == 1 ) $ d = \" E \" ; else if ( $ count % 4 == 2 ) $ d = \" S \" ; else if ( $ count % 4 == 3 ) $ d = \" W \" ; } if ( $ count < 0 ) { if ( $ count % 4 == 0 ) $ d = \" N \" ; else if ( $ count % 4 == -1 ) $ d = \" W \" ; else if ( $ count % 4 == -2 ) $ d = \" S \" ; else if ( $ count % 4 == -3 ) $ d = \" E \" ; } return $ d ; } $ s = \" LLRLRRL \" ; echo findDirection ( $ s ) . \" STRNEWLINE \" ; $ s = \" LL \" ; echo findDirection ( $ s ) . \" STRNEWLINE \" ; ? >"}
{"text":"Replace every character of string by character whose ASCII value is K times more than it | Function to move string character ; changed string ; iterate for every characters ; ASCII value ; store the duplicate ; if k - th ahead character exceed ' z ' ; print the new string ; Driver code ; function call","code":"< ? php function encode ( $ s , $ k ) { $ newS = \" \" ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; ++ $ i ) { $ val = ord ( $ s [ $ i ] ) ; $ dup = $ k ; if ( $ val + $ k > 122 ) { $ k -= ( 122 - $ val ) ; $ k = $ k % 26 ; $ newS = $ newS . chr ( 96 + $ k ) ; } else $ newS = $ newS . chr ( $ val + $ k ) ; $ k = $ dup ; } echo $ newS ; } $ str = \" abc \" ; $ k = 28 ; encode ( $ str , $ k ) ; ? >"}
{"text":"Modify string by removing vowels in between two consonants | Function to check if the character x is a vowel or not ; Returns the updated string formed after removing all the Sandwiched Vowels from the given string ; string to store the Updated String after removing the Sandwiched Vowels ; traverse the string from left to right ; if the current character is the first or the last character of the string then , this needs to be appended to the updatedString , since the corner alphabet irrespective of it being a vowel or a consonant , is never ' Sandwiched ' ; Check if the current character of the string is a vowel and both the previous and the next characters are consonants , if so then this is a sandwiched vowel , thus is ignored and not appended to the updated string ; if this character is not a sandwiched Vowel append it to the updated String ; Driver Code ; Remove all the Sandwitched Vowels","code":"< ? php function isVowel ( $ x ) { if ( $ x == ' a ' $ x == ' e ' $ x == ' i ' $ x == ' o ' $ x == ' u ' ) return true ; else return false ; } function updateSandwichedVowels ( $ a ) { $ n = strlen ( $ a ) ; $ updatedString = \" \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! $ i $ i == $ n - 1 ) { $ updatedString . = $ a [ $ i ] ; continue ; } if ( isVowel ( $ a [ $ i ] ) && ! isVowel ( $ a [ $ i - 1 ] ) && ! isVowel ( $ a [ $ i + 1 ] ) ) { continue ; } $ updatedString . = $ a [ $ i ] ; } return $ updatedString ; } $ str = \" geeksforgeeks \" ; $ updatedString = updateSandwichedVowels ( $ str ) ; echo $ updatedString ; ? >"}
{"text":"Number of N digit integers with weight W | Function to find total possible numbers with n digits and weight w ; When Weight of an integer is Positive ; Subtract the weight from 9 ; When weight of an integer is negative ; add the weight to 10 to make it positive ; number of digits in an integer and w as weight ; print the total possible numbers with n digits and weight w","code":"< ? php function findNumbers ( $ n , $ w ) { $ x = 0 ; $ sum = 0 ; if ( $ w >= 0 && $ w <= 8 ) { $ x = 9 - $ w ; } else if ( $ w >= -9 && $ w <= -1 ) { $ x = 10 + $ w ; } $ sum = pow ( 10 , $ n - 2 ) ; $ sum = ( $ x * $ sum ) ; return $ sum ; } $ n = 3 ; $ w = 4 ; echo findNumbers ( $ n , $ w ) ;"}
{"text":"Maximum height of triangular arrangement of array values | PHP program to find the maximum height of Pyramidal Arrangement of array values ; Just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) \/ 2 elements in the array ; updating the result value each time ; otherwise we have exceeded n value ; Driver Code","code":"< ? php function MaximumHeight ( $ a , $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ y = ( $ i * ( $ i + 1 ) ) \/ 2 ; if ( $ y < $ n ) $ result = $ i ; else break ; } return $ result ; } $ arr = array ( 40 , 100 , 20 , 30 ) ; $ n = count ( $ arr ) ; echo MaximumHeight ( $ arr , $ n ) ; ? >"}
{"text":"k | PHP program to find k - th element in the Odd - Even sequence . ; insert all the odd numbers from 1 to n . ; insert all the even numbers from 1 to n . ; Driver code","code":"< ? php function findK ( $ n , $ k ) { $ a ; $ index = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 1 ) $ a [ $ index ++ ] = $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 0 ) $ a [ $ index ++ ] = $ i ; return ( $ a [ $ k - 1 ] ) ; } $ n = 10 ; $ k = 3 ; echo findK ( $ n , $ k ) ; ? >"}
{"text":"One line function for factorial of a number | PHP program to find factorial of given number ; single line to find factorial ; Driver Code","code":"< ? php function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; } $ num = 5 ; echo \" Factorial \u2581 of \u2581 \" , $ num , \" \u2581 is \u2581 \" , factorial ( $ num ) ; ? >"}
{"text":"Pell Number | calculate nth pell number ; Driver Code","code":"< ? php function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; $ a = 1 ; $ b = 2 ; $ c ; $ i ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = 2 * $ b + $ a ; $ a = $ b ; $ b = $ c ; } return $ b ; } $ n = 4 ; echo ( pell ( $ n ) ) ; ? >"}
{"text":"An efficient way to check whether n | Returns true if n - th Fibonacci number is multiple of 10. ; Driver Code","code":"< ? php function isMultipleOf10 ( $ n ) { return ( $ n % 15 == 0 ) ; } $ n = 30 ; if ( isMultipleOf10 ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Find politeness of a number | A function to count all odd prime factors of a given number n ; Eliminate all even prime factor of number of n ; n must be odd at this point , so iterate for only odd numbers till sqrt ( n ) ; if i divides n , then start counting of Odd divisors ; If n odd prime still remains then count it ; Driver Code","code":"< ? php function countOddPrimeFactors ( $ n ) { $ result = 1 ; while ( $ n % 2 == 0 ) $ n \/= 2 ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) { $ divCount = 0 ; while ( $ n % $ i == 0 ) { $ n \/= $ i ; ++ $ divCount ; } $ result *= $ divCount + 1 ; } if ( $ n > 2 ) $ result *= 2 ; return $ result ; } function politness ( $ n ) { return countOddPrimeFactors ( $ n ) - 1 ; } $ n = 90 ; echo \" Politness \u2581 of \u2581 \" , $ n , \" \u2581 = \u2581 \" , politness ( $ n ) , \" STRNEWLINE \" ; $ n = 15 ; echo \" Politness \u2581 of \u2581 \" , $ n , \" \u2581 = \u2581 \" , politness ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Nearest prime less than given number n | PHP program to find the nearest prime to n . ; array to store all primes less than 10 ^ 6 ; Utility function of Sieve of Sundaram ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x ; This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j ; eliminate indexes which does not produce primes ; Since 2 is a prime number ; Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; modified binary search to find nearest prime less than N ; base condition is , if we are reaching at left corner or right corner of primes [ ] array then return that corner element because before or after that we don 't have any prime number in  primes array ; now if n is itself a prime so it will be present in primes array and here we have to find nearest prime less than n so we will return primes [ mid - 1 ] ; now if primes [ mid ] < n and primes [ mid + 1 ] > n that means we reached at nearest prime ; Driver Code","code":"< ? php $ MAX = 10000 ; $ primes = array ( ) ; function Sieve ( ) { global $ MAX , $ primes ; $ n = $ MAX ; $ nNew = ( int ) ( sqrt ( $ n ) ) ; $ marked = array_fill ( 0 , ( int ) ( $ n \/ 2 + 500 ) , 0 ) ; for ( $ i = 1 ; $ i <= ( $ nNew - 1 ) \/ 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= $ n \/ 2 ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = 1 ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= $ n \/ 2 ; $ i ++ ) if ( $ marked [ $ i ] == 0 ) array_push ( $ primes , 2 * $ i + 1 ) ; } function binarySearch ( $ left , $ right , $ n ) { global $ primes ; if ( $ left <= $ right ) { $ mid = ( int ) ( ( $ left + $ right ) \/ 2 ) ; if ( $ mid == 0 || $ mid == count ( $ primes ) - 1 ) return $ primes [ $ mid ] ; if ( $ primes [ $ mid ] == $ n ) return $ primes [ $ mid - 1 ] ; if ( $ primes [ $ mid ] < $ n && $ primes [ $ mid + 1 ] > $ n ) return $ primes [ $ mid ] ; if ( $ n < $ primes [ $ mid ] ) return binarySearch ( $ left , $ mid - 1 , $ n ) ; else return binarySearch ( $ mid + 1 , $ right , $ n ) ; } return 0 ; } Sieve ( ) ; $ n = 17 ; echo binarySearch ( 0 , count ( $ primes ) - 1 , $ n ) ; ? >"}
{"text":"Program for factorial of a number | function to find factorial of given number ; Driver Code","code":"< ? php function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; } $ num = 5 ; echo \" Factorial \u2581 of \u2581 \" , $ num , \" \u2581 is \u2581 \" , factorial ( $ num ) ; ? >"}
{"text":"k | Returns k - th distinct element in arr . ; Check if current element is present somewhere else . ; If element is unique ; Driver Code","code":"< ? php function printKDistinct ( $ arr , $ n , $ k ) { $ dist_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && $ arr [ $ j ] == $ arr [ $ i ] ) break ; if ( $ j == $ n ) $ dist_count ++ ; if ( $ dist_count == $ k ) return $ arr [ $ i ] ; } return -1 ; } $ ar = array ( 1 , 2 , 1 , 3 , 4 , 2 ) ; $ n = sizeof ( $ ar ) \/ sizeof ( $ ar [ 0 ] ) ; $ k = 2 ; echo printKDistinct ( $ ar , $ n , $ k ) ; ? >"}
{"text":"Find number of pairs in an array such that their XOR is 0 | Function to calculate the count ; Sorting the list using built in function ; Traversing through the elements ; Counting frequency of each elements ; Adding the contribution of the frequency to the answer ; Driver Code ; Print the count","code":"< ? php function calculate ( $ a , $ n ) { sort ( $ a ) ; $ count = 1 ; $ answer = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i - 1 ] ) { $ count += 1 ; } else { $ answer = $ answer + ( $ count * ( $ count - 1 ) ) \/ 2 ; $ count = 1 ; } } $ answer = $ answer + ( $ count * ( $ count - 1 ) ) \/ 2 ; return $ answer ; } $ a = array ( 1 , 2 , 1 , 2 , 4 ) ; $ n = count ( $ a ) ; echo calculate ( $ a , $ n ) ; ? >"}
{"text":"Find number of pairs in an array such that their XOR is 0 | Function to calculate the answer ; Finding the maximum of the array ; Creating frequency array With initial value 0 ; Traversing through the array ; Counting frequency ; Traversing through the frequency array ; Calculating answer ; Driver Code ; Function calling","code":"< ? php function calculate ( $ a , $ n ) { $ maximum = max ( $ a ) ; $ frequency = array_fill ( 0 , $ maximum + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ frequency [ $ a [ $ i ] ] += 1 ; } $ answer = 0 ; for ( $ i = 0 ; $ i < ( $ maximum ) + 1 ; $ i ++ ) { $ answer = $ answer + $ frequency [ $ i ] * ( $ frequency [ $ i ] - 1 ) ; } return $ answer \/ 2 ; } $ a = array ( 1 , 2 , 1 , 2 , 4 ) ; $ n = count ( $ a ) ; echo ( calculate ( $ a , $ n ) ) ; ? >"}
{"text":"Largest subarray with equal number of 0 s and 1 s | This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray . ; Pick a starting point as i ; Consider all subarrays starting from i ; If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far ; Driver Code","code":"< ? php function findSubArray ( & $ arr , $ n ) { $ sum = 0 ; $ maxsize = -1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ sum = ( $ arr [ $ i ] == 0 ) ? -1 : 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { ( $ arr [ $ j ] == 0 ) ? ( $ sum += -1 ) : ( $ sum += 1 ) ; if ( $ sum == 0 && $ maxsize < $ j - $ i + 1 ) { $ maxsize = $ j - $ i + 1 ; $ startindex = $ i ; } } } if ( $ maxsize == -1 ) echo \" No \u2581 such \u2581 subarray \" ; else echo $ startindex . \" \u2581 to \u2581 \" . ( $ startindex + $ maxsize - 1 ) ; return $ maxsize ; } $ arr = array ( 1 , 0 , 0 , 1 , 0 , 1 , 1 ) ; $ size = sizeof ( $ arr ) ; findSubArray ( $ arr , $ size ) ; ? >"}
{"text":"Maximum element in a sorted and rotated array | Function to return the maximum element ; This condition is for the case when array is not rotated at all ; Find mid ; Check if mid reaches 0 , it is greater than next element or not ; Check if mid itself is maximum element ; Decide whether we need to go to the left half or the right half ; Driver code","code":"< ? php function findMax ( $ arr , $ low , $ high ) { if ( $ high <= $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( $ high - $ low ) \/ 2 ; if ( $ mid == 0 && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) return $ arr [ 0 ] ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] && $ mid > 0 && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) { return $ arr [ $ mid ] ; } if ( $ arr [ $ low ] > $ arr [ $ mid ] ) { return findMax ( $ arr , $ low , $ mid - 1 ) ; } else { return findMax ( $ arr , $ mid + 1 , $ high ) ; } } $ arr = array ( 5 , 6 , 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo findMax ( $ arr , 0 , $ n - 1 ) ;"}
{"text":"Search an element in a sorted and rotated array | Returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1 ; If arr [ l ... mid ] is sorted ; As this subarray is sorted , we can quickly check if key lies in half or other half ; If key not lies in first half subarray , Divide other half into two subarrays , such that we can quickly check if key lies in other half ; If arr [ l . . mid ] is not sorted , then arr [ mid ... r ] must be sorted ; Driver Code","code":"< ? php function search ( $ arr , $ l , $ h , $ key ) { if ( $ l > $ h ) return -1 ; $ mid = ( $ l + $ h ) \/ 2 ; if ( $ arr [ $ mid ] == $ key ) return $ mid ; if ( $ arr [ $ l ] <= $ arr [ $ mid ] ) { if ( $ key >= $ arr [ $ l ] && $ key <= $ arr [ $ mid ] ) return search ( $ arr , $ l , $ mid - 1 , $ key ) ; return search ( $ arr , $ mid + 1 , $ h , $ key ) ; } if ( $ key >= $ arr [ $ mid ] && $ key <= $ arr [ $ h ] ) return search ( $ arr , $ mid + 1 , $ h , $ key ) ; return search ( $ arr , $ l , $ mid - 1 , $ key ) ; } $ arr = array ( 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; $ key = 6 ; $ i = search ( $ arr , 0 , $ n - 1 , $ key ) ; if ( $ i != -1 ) echo \" Index : \u2581 \" , floor ( $ i ) , \" \u2581 STRNEWLINE \" ; else echo \" Key \u2581 not \u2581 found \" ; ? >"}
{"text":"Find the minimum element in a sorted and rotated array | PHP program to find minimum element in a sorted and rotated array ; This condition is needed to handle the case when array is not rotated at all ; If there is only one element left ; Find mid ; Check if element ( mid + 1 ) is minimum element . Consider the cases like ( 3 , 4 , 5 , 1 , 2 ) ; Check if mid itself is minimum element ; Decide whether we need to go to left half or right half ; Driver Code","code":"< ? php function findMin ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return $ arr [ 0 ] ; if ( $ high == $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( $ high - $ low ) \/ 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return $ arr [ $ mid + 1 ] ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return findMin ( $ arr , $ low , $ mid - 1 ) ; return findMin ( $ arr , $ mid + 1 , $ high ) ; } $ arr1 = array ( 5 , 6 , 1 , 2 , 3 , 4 ) ; $ n1 = sizeof ( $ arr1 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr1 , 0 , $ n1 - 1 ) . \" STRNEWLINE \" ; $ arr2 = array ( 1 , 2 , 3 , 4 ) ; $ n2 = sizeof ( $ arr2 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr2 , 0 , $ n2 - 1 ) . \" STRNEWLINE \" ; $ arr3 = array ( 1 ) ; $ n3 = sizeof ( $ arr3 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr3 , 0 , $ n3 - 1 ) . \" STRNEWLINE \" ; $ arr4 = array ( 1 , 2 ) ; $ n4 = sizeof ( $ arr4 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr4 , 0 , $ n4 - 1 ) . \" STRNEWLINE \" ; $ arr5 = array ( 2 , 1 ) ; $ n5 = sizeof ( $ arr5 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr5 , 0 , $ n5 - 1 ) . \" STRNEWLINE \" ; $ arr6 = array ( 5 , 6 , 7 , 1 , 2 , 3 , 4 ) ; $ n6 = sizeof ( $ arr6 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr6 , 0 , $ n6 - 1 ) . \" STRNEWLINE \" ; $ arr7 = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; $ n7 = sizeof ( $ arr7 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr7 , 0 , $ n7 - 1 ) . \" STRNEWLINE \" ; $ arr8 = array ( 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ) ; $ n8 = sizeof ( $ arr8 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr8 , 0 , $ n8 - 1 ) . \" STRNEWLINE \" ; $ arr9 = array ( 3 , 4 , 5 , 1 , 2 ) ; $ n9 = sizeof ( $ arr9 ) ; echo \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" . findMin ( $ arr9 , 0 , $ n9 - 1 ) . \" STRNEWLINE \" ; ? >"}
{"text":"Find the smallest and second smallest elements in an array | Function to print first smallest and second smallest elements ; There should be atleast two elements ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver Code","code":"< ? php function print2Smallest ( $ arr , $ arr_size ) { $ INT_MAX = 2147483647 ; if ( $ arr_size < 2 ) { echo ( \" \u2581 Invalid \u2581 Input \u2581 \" ) ; return ; } $ first = $ second = $ INT_MAX ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { if ( $ arr [ $ i ] < $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second && $ arr [ $ i ] != $ first ) $ second = $ arr [ $ i ] ; } if ( $ second == $ INT_MAX ) echo ( \" There \u2581 is \u2581 no \u2581 second \u2581 smallest \u2581 element STRNEWLINE \" ) ; else echo \" The \u2581 smallest \u2581 element \u2581 is \u2581 \" , $ first , \" \u2581 and \u2581 second \u2581 Smallest \u2581 element \u2581 is \u2581 \" , $ second ; } $ arr = array ( 12 , 13 , 1 , 10 , 34 , 1 ) ; $ n = count ( $ arr ) ; print2Smallest ( $ arr , $ n ) ? >"}
{"text":"Subset Sum Problem in O ( sum ) space | Returns true if there exists a subset with given sum in arr [ ] ; The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ] ; A subset with sum 0 is always possible ; If there exists no element no sum is possible ; Driver code","code":"< ? php function isSubsetSum ( $ arr , $ n , $ sum ) { $ subset [ 2 ] [ $ sum + 1 ] = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ sum ; $ j ++ ) { if ( $ j == 0 ) $ subset [ $ i % 2 ] [ $ j ] = true ; else if ( $ i == 0 ) $ subset [ $ i % 2 ] [ $ j ] = false ; else if ( $ arr [ $ i - 1 ] <= $ j ) $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j - $ arr [ $ i - 1 ] ] || $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; else $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; } } return $ subset [ $ n % 2 ] [ $ sum ] ; } $ arr = array ( 6 , 2 , 5 ) ; $ sum = 7 ; $ n = sizeof ( $ arr ) ; if ( isSubsetSum ( $ arr , $ n , $ sum ) == true ) echo ( \" There \u2581 exists \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) ; else echo ( \" No \u2581 subset \u2581 exists \u2581 with \u2581 given \u2581 sum \" ) ; ? >"}
{"text":"Maximum equlibrium sum in an array | Function to find maximum equilibrium sum . ; Driver Code","code":"< ? php function findMaxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ prefix_sum = $ arr [ $ i ] ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ prefix_sum += $ arr [ $ j ] ; $ suffix_sum = $ arr [ $ i ] ; for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) $ suffix_sum += $ arr [ $ j ] ; if ( $ prefix_sum == $ suffix_sum ) $ res = max ( $ res , $ prefix_sum ) ; } return $ res ; } $ arr = array ( -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 ) ; $ n = count ( $ arr ) ; echo findMaxSum ( $ arr , $ n ) ; ? >"}
{"text":"Maximum equlibrium sum in an array | Function to find maximum equilibrium sum . ; Array to store prefix sum . ; Array to store suffix sum . ; Variable to store maximum sum . ; Calculate prefix sum . ; Calculate suffix sum and compare it with prefix sum . Update ans accordingly . ; Driver Code","code":"< ? php function findMaxSum ( $ arr , $ n ) { $ preSum [ $ n ] = array ( ) ; $ suffSum [ $ n ] = array ( ) ; $ ans = PHP_INT_MIN ; $ preSum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i ] = $ preSum [ $ i - 1 ] + $ arr [ $ i ] ; $ suffSum [ $ n - 1 ] = $ arr [ $ n - 1 ] ; if ( $ preSum [ $ n - 1 ] == $ suffSum [ $ n - 1 ] ) $ ans = max ( $ ans , $ preSum [ $ n - 1 ] ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] + $ arr [ $ i ] ; if ( $ suffSum [ $ i ] == $ preSum [ $ i ] ) $ ans = max ( $ ans , $ preSum [ $ i ] ) ; } return $ ans ; } $ arr = array ( -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 ) ; $ n = sizeof ( $ arr ) ; echo findMaxSum ( $ arr , $ n ) ;"}
{"text":"Majority Element | Function to find Majority element in an array ; sentinels ; update maxCount if count of current element is greater ; if maxCount is greater than n \/ 2 return the corresponding element ; Driver code ; Function calling","code":"< ? php function findMajority ( $ arr , $ n ) { $ maxCount = 0 ; $ index = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count > $ maxCount ) { $ maxCount = $ count ; $ index = $ i ; } } if ( $ maxCount > $ n \/ 2 ) echo $ arr [ $ index ] . \" STRNEWLINE \" ; else echo \" No \u2581 Majority \u2581 Element \" . \" STRNEWLINE \" ; } $ arr = array ( 1 , 1 , 2 , 1 , 3 , 5 , 1 ) ; $ n = sizeof ( $ arr ) ; findMajority ( $ arr , $ n ) ;"}
{"text":"Majority Element | Function to find the candidate for Majority ; Function to check if the candidate occurs more than n \/ 2 times ; Function to print Majority Element ; Find the candidate for Majority ; Print the candidate if it is Majority ; Driver Code ; Function calling","code":"< ? php function findCandidate ( $ a , $ size ) { $ maj_index = 0 ; $ count = 1 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { if ( $ a [ $ maj_index ] == $ a [ $ i ] ) $ count ++ ; else $ count -- ; if ( $ count == 0 ) { $ maj_index = $ i ; $ count = 1 ; } } return $ a [ $ maj_index ] ; } function isMajority ( $ a , $ size , $ cand ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) if ( $ a [ $ i ] == $ cand ) $ count ++ ; if ( $ count > $ size \/ 2 ) return 1 ; else return 0 ; } function printMajority ( $ a , $ size ) { $ cand = findCandidate ( $ a , $ size ) ; if ( isMajority ( $ a , $ size , $ cand ) ) echo \" \u2581 \" , $ cand , \" \u2581 \" ; else echo \" No \u2581 Majority \u2581 Element \" ; } $ a = array ( 1 , 3 , 3 , 1 , 2 ) ; $ size = sizeof ( $ a ) ; printMajority ( $ a , $ size ) ; ? >"}
{"text":"Dynamic Programming | Returns true if there is a subset of set [ ] with sum equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; uncomment this code to print table ; Driver code","code":"< ? php function isSubsetSum ( $ set , $ n , $ sum ) { $ subset = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ subset [ $ i ] [ 0 ] = true ; for ( $ i = 1 ; $ i <= $ sum ; $ i ++ ) $ subset [ 0 ] [ $ i ] = false ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ sum ; $ j ++ ) { if ( $ j < $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] ; if ( $ j >= $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] || $ subset [ $ i - 1 ] [ $ j - $ set [ $ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; printf ( \" n \" ) ; } return $ subset [ $ n ] [ $ sum ] ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = count ( $ set ) ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; else echo \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; ? >"}
{"text":"Online Queries for GCD of array after divide operations | PHP implementation of the approach returns the gcd after all updates in the array ; Function to calculate gcd of onine queries ; stores the gcd of the initial array elements ; calculates the gcd ; performing online queries ; index is 1 based ; divide the array element ; calculates the current gcd ; print the gcd after each step ; Driver code","code":"< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function print_gcd_online ( $ n , $ m , $ query , $ arr ) { $ max_gcd = 0 ; $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ max_gcd = gcd ( $ max_gcd , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ query [ $ i ] [ 0 ] -- ; $ arr [ $ query [ $ i ] [ 0 ] ] \/= $ query [ $ i ] [ 1 ] ; $ max_gcd = gcd ( $ arr [ $ query [ $ i ] [ 0 ] ] , $ max_gcd ) ; echo ( $ max_gcd ) , \" STRNEWLINE \" ; } } $ n = 3 ; $ m = 3 ; $ query ; $ arr = array ( 36 , 24 , 72 ) ; $ query [ 0 ] [ 0 ] = 1 ; $ query [ 0 ] [ 1 ] = 3 ; $ query [ 1 ] [ 0 ] = 3 ; $ query [ 1 ] [ 1 ] = 12 ; $ query [ 2 ] [ 0 ] = 2 ; $ query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( $ n , $ m , $ query , $ arr ) ; ? >"}
{"text":"Numbers in range [ L , R ] such that the count of their divisors is both even and prime | PHP implementation of the approach ; stores whether the number is prime or not ; stores the count of prime numbers less than or equal to the index ; create the sieve ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all the entries as true . A value in prime [ i ] will finally be false if ' i ' is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; stores the prefix sum of number of primes less than or equal to ' i ' ; create the sieve ; ' l ' and ' r ' are the lower and upper bounds of the range ; get the value of count ; display the count","code":"< ? php $ MAX = 100000 ; $ prime = array_fill ( 0 , $ MAX + 1 , true ) ; $ sum = array_fill ( 0 , $ MAX + 1 , 0 ) ; function SieveOfEratosthenes ( ) { global $ MAX , $ sum , $ prime ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ MAX ; $ p ++ ) { if ( $ prime [ $ p ] ) { for ( $ i = $ p * 2 ; $ i <= $ MAX ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ i = 1 ; $ i <= $ MAX ; $ i ++ ) { if ( $ prime [ $ i ] == true ) $ sum [ $ i ] = 1 ; $ sum [ $ i ] += $ sum [ $ i - 1 ] ; } } SieveOfEratosthenes ( ) ; $ l = 3 ; $ r = 9 ; $ c = ( $ sum [ $ r ] - $ sum [ $ l - 1 ] ) ; echo \" Count : \" \u2581 . \u2581 $ c \u2581 . \u2581 \" \" ? >"}
{"text":"Area of a circle inscribed in a rectangle which is inscribed in a semicircle | Function to find the area of the circle ; radius cannot be negative ; area of the circle ; Driver code","code":"< ? php function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = 3.14 * pow ( $ r \/ ( 2 * sqrt ( 2 ) ) , 2 ) ; return $ area ; } $ a = 5 ; echo area ( $ a ) ;"}
{"text":"Find count of Almost Prime numbers from 1 to N | PHP program to count almost prime numbers from 1 to n ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to count almost prime numbers from 1 to n ; to store required answer ; 6 is first almost prime number ; to count prime factors ; if it is perfect square ; if I is almost prime number ; Driver Code","code":"< ? php $ N = 100005 ; $ prime = array_fill ( 0 , $ N , true ) ; function SieveOfEratosthenes ( ) { global $ N , $ prime ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p < ( int ) ( sqrt ( $ N ) ) ; $ p ++ ) { if ( $ prime [ $ p ] == true ) for ( $ i = 2 * $ p ; $ i < $ N ; $ i += $ p ) $ prime [ $ i ] = false ; } } function almostPrimes ( $ n ) { global $ prime ; $ ans = 0 ; for ( $ i = 6 ; $ i < $ n + 1 ; $ i ++ ) { $ c = 0 ; for ( $ j = 2 ; $ i >= $ j * $ j ; $ j ++ ) { if ( $ i % $ j == 0 ) { if ( $ j * $ j == $ i ) { if ( $ prime [ $ j ] ) $ c += 1 ; } else { if ( $ prime [ $ j ] ) $ c += 1 ; if ( $ prime [ ( $ i \/ $ j ) ] ) $ c += 1 ; } } } if ( $ c == 2 ) $ ans += 1 ; } return $ ans ; } SieveOfEratosthenes ( ) ; $ n = 21 ; print ( almostPrimes ( $ n ) ) ; ? >"}
{"text":"Divide a number into two parts such that sum of digits is maximum | Returns sum of digits of x ; Returns closest number to x in terms of 9 's. ; Driver code","code":"< ? php function sumOfDigitsSingle ( $ x ) { $ ans = 0 ; while ( $ x ) { $ ans += $ x % 10 ; $ x \/= 10 ; } return $ ans ; } function closest ( $ x ) { $ ans = 0 ; while ( $ ans * 10 + 9 <= $ x ) $ ans = $ ans * 10 + 9 ; return $ ans ; } function sumOfDigitsTwoParts ( $ N ) { $ A = closest ( $ N ) ; return sumOfDigitsSingle ( $ A ) + sumOfDigitsSingle ( $ N - $ A ) ; } $ N = 35 ; echo sumOfDigitsTwoParts ( $ N ) ; ? >"}
{"text":"Primality Test | Set 5 ( Using Lucas | Function to check whether \/ ( 2 ^ p - 1 ) is prime or not . ; generate the number ; First number of the series ; Generate the rest ( p - 2 ) terms of the series . ; now if the ( p - 1 ) th term is 0 return true else false . ; Driver Code Check whether 2 ^ p - 1 is prime or not .","code":"< ? php function isPrime ( $ p ) { $ checkNumber = pow ( 2 , $ p ) - 1 ; $ nextval = 4 % $ checkNumber ; for ( $ i = 1 ; $ i < $ p - 1 ; $ i ++ ) $ nextval = ( $ nextval * $ nextval - 2 ) % $ checkNumber ; return ( $ nextval == 0 ) ; } $ p = 7 ; $ checkNumber = pow ( 2 , $ p ) - 1 ; if ( isPrime ( $ p ) ) echo $ checkNumber , \" \u2581 is \u2581 Prime . \" ; else echo $ checkNumber , \" \u2581 is \u2581 not \u2581 Prime . \" ; ? >"}
{"text":"Sophie Germain Prime | function to detect prime number here we have used sieve method https : www . geeksforgeeks . org \/ sieve - of - eratosthenes \/ to detect prime number ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; We have made array till 2 * n + 1 so that we can check prime number till that and conclude about sophie german prime . ; checking every i whether it is sophie german prime or not . ; Driver code","code":"< ? php function sieve ( $ n , & $ prime ) { for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } } function printSophieGermanNumber ( $ n ) { $ prime = array ( ) ; for ( $ i = 0 ; $ i < ( 2 * $ n + 1 ) ; $ i ++ ) $ prime [ $ i ] = true ; sieve ( 2 * $ n + 1 , $ prime ) ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { if ( $ prime [ $ i ] && $ prime [ 2 * $ i + 1 ] ) echo ( $ i . \" \u2581 \" ) ; } } $ n = 25 ; printSophieGermanNumber ( $ n ) ; ? >"}
{"text":"Bessel 's Interpolation | calculating u mentioned in the formula ; calculating factorial of given number n ; Number of values given ; y [ ] [ ] is used for difference table with y [ ] [ 0 ] used for input ; Calculating the central difference table ; Displaying the central difference table ; value to interpolate at ; Initializing u and sum ; k is origin thats is f ( 0 ) ; if ( $n % 2 ) origin for odd ; $k = $n \/ 2 - 1 ; origin for even ; Solving using bessel 's formula","code":"< ? php function ucal ( $ u , $ n ) { if ( $ n == 0 ) return 1 ; $ temp = $ u ; for ( $ i = 1 ; $ i <= ( int ) ( $ n \/ 2 ) ; $ i ++ ) $ temp = $ temp * ( $ u - $ i ) ; for ( $ i = 1 ; $ i < ( int ) ( $ n \/ 2 ) ; $ i ++ ) $ temp = $ temp * ( $ u + $ i ) ; return $ temp ; } function fact ( $ n ) { $ f = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ f *= $ i ; return $ f ; } $ n = 6 ; $ x = array ( 25 , 26 , 27 , 28 , 29 , 30 ) ; $ y ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ y [ $ i ] [ $ j ] = 0.0 ; $ y [ 0 ] [ 0 ] = 4.000 ; $ y [ 1 ] [ 0 ] = 3.846 ; $ y [ 2 ] [ 0 ] = 3.704 ; $ y [ 3 ] [ 0 ] = 3.571 ; $ y [ 4 ] [ 0 ] = 3.448 ; $ y [ 5 ] [ 0 ] = 3.333 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) $ y [ $ j ] [ $ i ] = $ y [ $ j + 1 ] [ $ i - 1 ] - $ y [ $ j ] [ $ i - 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ i ; $ j ++ ) echo str_pad ( $ y [ $ i ] [ $ j ] , 4 ) . \" TABSYMBOL \" ; echo \" STRNEWLINE \" ; } $ value = 27.4 ; $ sum = ( $ y [ 2 ] [ 0 ] + $ y [ 3 ] [ 0 ] ) \/ 2 ; $ k ; $ k = $ n \/ 2 ; else $ u = ( $ value - $ x [ $ k ] ) \/ ( $ x [ 1 ] - $ x [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 ) $ sum = $ sum + ( ( $ u - 0.5 ) * ucal ( $ u , $ i - 1 ) * $ y [ $ k ] [ $ i ] ) \/ fact ( $ i ) ; else $ sum = $ sum + ( ucal ( $ u , $ i ) * ( $ y [ $ k ] [ $ i ] + $ y [ -- $ k ] [ $ i ] ) \/ ( fact ( $ i ) * 2 ) ) ; } echo \" Value \u2581 at \u2581 \" . $ value . \" \u2581 is \u2581 \" . $ sum . \" STRNEWLINE \" ; ? >"}
{"text":"An efficient way to check whether n | A simple PHP program to check if n - th Fibonacci number is multiple of 10. ; Returns true if n - th Fibonacci number is multiple of 10. ; Driver code","code":"< ? php function fibonacci ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n <= 1 ) return $ n ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ c ; } function isMultipleOf10 ( $ n ) { $ f = fibonacci ( 30 ) ; return ( $ f % 10 == 0 ) ; } $ n = 30 ; if ( isMultipleOf10 ( $ n ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Program to find whether a given number is power of 2 | Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver Code","code":"< ? php function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; } if ( isPowerOfTwo ( 31 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isPowerOfTwo ( 64 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text":"Smallest power of 2 which is greater than or equal to sum of array elements | Function to find the nearest power of 2 ; The number ; If already a power of 2 ; Find the next power of 2 ; Function to find the memory used ; Sum of array ; Traverse and find the sum of array ; Function call to find the nearest power of 2 ; Driver Code","code":"< ? php function nextPowerOf2 ( $ n ) { $ p = 1 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ p < $ n ) $ p <<= 1 ; return $ p ; } function memoryUsed ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ nearest = nextPowerOf2 ( $ sum ) ; return $ nearest ; } $ arr = array ( 1 , 2 , 3 , 2 ) ; $ n = sizeof ( $ arr ) ; echo ( memoryUsed ( $ arr , $ n ) ) ; ? >"}
{"text":"Toggling k | Php program to toggle k - th bit of n ; Driver code","code":"< ? php function toggleKthBit ( $ n , $ k ) { return ( $ n ^ ( 1 << ( $ k - 1 ) ) ) ; } $ n = 5 ; $ k = 1 ; echo toggleKthBit ( $ n , $ k ) ; ? >"}
{"text":"Smallest power of 2 greater than or equal to n | PHP program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code","code":"< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } $ n = 0 ; echo ( nextPowerOf2 ( $ n ) ) ; ? >"}
{"text":"Tetranacci Numbers | Function to print the N - th tetranacci number ; Initialize first four numbers to base cases ; declare a current variable ; Loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively ; Driver code","code":"< ? php function printTetra ( $ n ) { if ( $ n < 0 ) return ; $ first = 0 ; $ second = 1 ; $ third = 1 ; $ fourth = 2 ; $ curr ; if ( $ n == 0 ) echo $ first ; else if ( $ n == 1 $ n == 2 ) echo $ second ; else if ( $ n == 3 ) echo $ fourth ; else { for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third + $ fourth ; $ first = $ second ; $ second = $ third ; $ third = $ fourth ; $ fourth = $ curr ; } echo $ curr ; } } $ n = 10 ; printTetra ( $ n ) ; ? >"}
{"text":"Count ways to reach the nth stair using step 1 , 2 or 3 | A recursive function used by countWays ; Driver Code","code":"< ? php function countWays ( $ n ) { $ res [ 0 ] = 1 ; $ res [ 1 ] = 1 ; $ res [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = $ res [ $ i - 1 ] + $ res [ $ i - 2 ] + $ res [ $ i - 3 ] ; return $ res [ $ n ] ; } $ n = 4 ; echo countWays ( $ n ) ; ? >"}
{"text":"Dynamic Programming | High | Returns maximum amount of task that can be done till day n ; If n is less than equal to 0 , then no solution exists ; Determines which task to choose on day n , then returns the maximum till that day ; Driver Code","code":"< ? php function maxTasks ( $ high , $ low , $ n ) { if ( $ n <= 0 ) return 0 ; return max ( $ high [ $ n - 1 ] + maxTasks ( $ high , $ low , ( $ n - 2 ) ) , $ low [ $ n - 1 ] + maxTasks ( $ high , $ low , ( $ n - 1 ) ) ) ; } $ n = 5 ; $ high = array ( 3 , 6 , 8 , 7 , 6 ) ; $ low = array ( 1 , 5 , 4 , 5 , 3 ) ; print ( maxTasks ( $ high , $ low , $ n ) ) ; ? >"}
{"text":"Count substrings that starts with character X and ends with character Y | function to count substrings starting with character X and ending with character Y ; to store total count of required substrings ; to store count of character ' x ' up to the point the string ' str ' has been traversed so far ; traverse ' str ' form left to right ; if true , increment ' count _ x ' ; if true accumulate ' count _ x ' to ' tot _ count ' ; required count ; Driver code","code":"< ? php function countSubstr ( $ str , $ n , $ x , $ y ) { $ tot_count = 0 ; $ count_x = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) $ count_x ++ ; if ( $ str [ $ i ] == $ y ) $ tot_count += $ count_x ; } return $ tot_count ; } $ str = \" abbcaceghcak \" ; $ n = strlen ( $ str ) ; $ x = ' a ' ; $ y = ' c ' ; echo \" Count = \""}
{"text":"Count words in a given string | PHP program to count no of words from given input string ; returns number of words in str ; word count ; Scan all characters one by one ; If next character is a separator , set the state as OUT ; If next character is not a word separator and state is OUT , then set the state as IN and increment word count ; Move to next character ; Driver Code","code":"< ? php $ OUT = 0 ; $ IN = 1 ; function countWords ( $ str ) { global $ OUT , $ IN ; $ state = $ OUT ; $ wc = 0 ; $ i = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == \" \u2581 \" $ str [ $ i ] == \" STRNEWLINE \" $ str [ $ i ] == \" TABSYMBOL \" ) $ state = $ OUT ; else if ( $ state == $ OUT ) { $ state = $ IN ; ++ $ wc ; } ++ $ i ; } return $ wc ; } $ str = \" One \u2581 two TABSYMBOL TABSYMBOL three STRNEWLINE \u2581 four TABSYMBOL five \u2581 \" ; echo \" No \u2581 of \u2581 words \u2581 : \u2581 \" . countWords ( $ str ) ; ? >"}
{"text":"Enneadecagonal number | Function to calculate Enneadecagonal number ; Formula for finding nth Enneadecagonal number ; Driver Code","code":"< ? php function nthEnneadecagonal ( $ n ) { return ( 17 * $ n * $ n - 15 * $ n ) \/ 2 ; } $ n = 6 ; echo $ n , \" th \u2581 Enneadecagonal \u2581 number \u2581 : \" , nthEnneadecagonal ( $ n ) ; ? >"}
{"text":"Area of a Circumscribed Circle of a Square | PHP Program to find the area of a circumscribed circle ; function returns the area ; Driver code","code":"< ? php $ PI = 3.14159265 ; function areacircumscribed ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI \/ 2 ) ) ; } $ a = 6 ; echo \" \u2581 Area \u2581 of \u2581 an \u2581 circumscribed \u2581 circle \u2581 is \u2581 : \u2581 \" , areacircumscribed ( $ a ) ; ? >"}
{"text":"Tetranacci Numbers | Function to return the N - th tetranacci number ; base cases ; base cases ; base cases ; function to print the nth tetranacci number ; Driver code","code":"< ? php function printTetraRec ( $ n ) { if ( $ n == 0 ) return 0 ; if ( $ n == 1 $ n == 2 ) return 1 ; if ( $ n == 3 ) return 2 ; else return printTetraRec ( $ n - 1 ) + printTetraRec ( $ n - 2 ) + printTetraRec ( $ n - 3 ) + printTetraRec ( $ n - 4 ) ; } function printTetra ( $ n ) { echo printTetraRec ( $ n ) . \" \" ; } $ n = 10 ; printTetra ( $ n ) ; ? >"}
{"text":"Dynamic Programming | High | A DP based PHP program to find maximum tasks . Returns the maximum among the 2 numbers ; Returns the maximum among the 2 numbers ; Returns maximum amount of task that can be done till day n ; An array task_dp that stores the maximum task done ; If n = 0 , no solution exists ; If n = 1 , high effort task on that day will be the solution ; Fill the entire array determining which task to choose on day i ; Driver code","code":"< ? php function max1 ( $ x , $ y ) { return ( $ x > $ y ? $ x : $ y ) ; } return ( $ x > $ y ? $ x : $ y ) ; } function maxTasks ( $ high , $ low , $ n ) { $ task_dp = array ( $ n + 1 ) ; $ task_dp [ 0 ] = 0 ; $ task_dp [ 1 ] = $ high [ 0 ] ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ task_dp [ $ i ] = max ( $ high [ $ i - 1 ] + $ task_dp [ $ i - 2 ] , $ low [ $ i - 1 ] + $ task_dp [ $ i - 1 ] ) ; return $ task_dp [ $ n ] ; } { $ n = 5 ; $ high = array ( 3 , 6 , 8 , 7 , 6 ) ; $ low = array ( 1 , 5 , 4 , 5 , 3 ) ; echo ( maxTasks ( $ high , $ low , $ n ) ) ; }"}
{"text":"Permutation Coefficient | A O ( n ) time and O ( 1 ) extra space PHP solution to calculate the Permutation Coefficient ; Compute n ! and ( n - k ) ! ; Driver Code","code":"< ? php function PermutationCoeff ( $ n , $ k ) { $ Fn = 1 ; $ Fk ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ Fn *= $ i ; if ( $ i == $ n - $ k ) $ Fk = $ Fn ; } $ coeff = $ Fn \/ $ Fk ; return $ coeff ; } $ n = 10 ; $ k = 2 ; echo \" Value \u2581 of \u2581 P ( \" , $ n , \" , \u2581 \" , $ k , \" ) STRNEWLINE TABSYMBOL TABSYMBOL is \u2581 \" , PermutationCoeff ( $ n , $ k ) ; ? >"}
{"text":"DFA for Strings not ending with \" THE \" | dfa tells the number associated with the present state ; This function is for the starting state ( zeroth ) of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; This function is for the first state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) ; On receiving ' H ' or ' h ' goto second state ( 2 ) ; else goto starting state ( 0 ) ; This function is for the second state of DFA ; On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 ) ; This function is for the third state of DFA ; On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 ) ; store length of string ; Driver Code","code":"< ? php $ dfa = 0 ; function start ( $ c ) { global $ dfa ; if ( $ c == ' t ' $ c == ' T ' ) $ dfa = 1 ; } function state1 ( $ c ) { global $ dfa ; if ( $ c == ' t ' $ c == ' T ' ) $ dfa = 1 ; else if ( $ c == ' h ' $ c == ' H ' ) $ dfa = 2 ; else $ dfa = 0 ; } function state2 ( $ c ) { global $ dfa ; if ( $ c == ' e ' $ c == ' E ' ) $ dfa = 3 ; else $ dfa = 0 ; } function state3 ( $ c ) { global $ dfa ; if ( $ c == ' t ' $ c == ' T ' ) $ dfa = 1 ; else $ dfa = 0 ; } function isAccepted ( $ str ) { global $ dfa ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ dfa == 0 ) start ( $ str [ $ i ] ) ; else if ( $ dfa == 1 ) state1 ( $ str [ $ i ] ) ; else if ( $ dfa == 2 ) state2 ( $ str [ $ i ] ) ; else state3 ( $ str [ $ i ] ) ; } return ( $ dfa != 3 ) ; } $ str = \" forTHEgeeks \" ; if ( isAccepted ( $ str ) == true ) echo \" ACCEPTED STRNEWLINE \" ; else echo \" NOT \u2581 ACCEPTED STRNEWLINE \" ; ? >"}
{"text":"Check whether given string can be generated after concatenating given strings | Function that return true if pre is a prefix of str ; While there are characters to match ; If characters differ at any position ; str starts with pre ; Function that return true if suff is a suffix of str ; While there are characters to match ; I$f characters differ at any position ; str ends with suff ; Function that returns true if str = a + b or str = b + a ; str cannot be generated by concatenating a and b ; If str starts with a i . e . a is a prefix of str ; Check if the rest of the characters are equal to b i . e . b is a suffix of str ; If str starts with b i . e . b is a prefix of str ; Check if the rest of the characters are equal to a i . e . a is a suffix of str ; Driver code","code":"< ? php function startsWith ( $ str , $ pre ) { $ strLen = strlen ( $ str ) ; $ preLen = strlen ( $ pre ) ; $ i = 0 ; $ j = 0 ; while ( $ i < $ strLen && $ j < $ preLen ) { if ( $ str [ $ i ] != $ pre [ $ j ] ) return false ; $ i ++ ; $ j ++ ; } return true ; } function endsWith ( $ str , $ suff ) { $ i = strlen ( $ str ) - 0 ; $ j = strlen ( $ suff ) - 0 ; while ( $ i >= 0 && $ j >= 0 ) { if ( $ str [ $ i ] != $ suff [ $ j ] ) return false ; $ i -- ; $ j -- ; } return true ; } function checkString ( $ str , $ a , $ b ) { if ( strlen ( $ str ) != strlen ( $ a ) + strlen ( $ b ) ) return false ; if ( startsWith ( $ str , $ a ) ) { if ( endsWith ( $ str , $ b ) ) return true ; } if ( startsWith ( $ str , $ b ) ) { if ( endsWith ( $ str , $ a ) ) return true ; } return false ; } $ str = \" GeeksforGeeks \" ; $ a = \" Geeksfo \" ; $ b = \" rGeeks \" ; if ( checkString ( $ str , $ a , $ b ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Minimum number of operations to move all uppercase characters before all lower case characters | Function to return the minimum number of operations required ; To store the indices of the last uppercase and the first lowercase character ; Find the last uppercase character ; Find the first lowercase character ; If all the characters are either uppercase or lowercase ; Count of uppercase characters that appear after the first lowercase character ; Count of lowercase characters that appear before the last uppercase character ; Return the minimum operations required ; Driver Code","code":"< ? php function minOperations ( $ str , $ n ) { $ i ; $ lastUpper = -1 ; $ firstLower = -1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( ctype_upper ( $ str [ $ i ] ) ) { $ lastUpper = $ i ; break ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ctype_lower ( $ str [ $ i ] ) ) { $ firstLower = $ i ; break ; } } if ( $ lastUpper == -1 $ firstLower == -1 ) return 0 ; $ countUpper = 0 ; for ( $ i = $ firstLower ; $ i < $ n ; $ i ++ ) { if ( ctype_upper ( $ str [ $ i ] ) ) { $ countUpper ++ ; } } $ countLower = 0 ; for ( $ i = 0 ; $ i < $ lastUpper ; $ i ++ ) { if ( ctype_lower ( $ str [ $ i ] ) ) { $ countLower ++ ; } } return min ( $ countLower , $ countUpper ) ; } { $ str = \" geEksFOrGEekS \" ; $ n = strlen ( $ str ) ; echo ( minOperations ( $ str , $ n ) ) ; } ? >"}
{"text":"Probability of rain on N + 1 th day | Function to find the probability ; count 1 ; find probability ; Driver Code","code":"< ? php function rainDayProbability ( $ a , $ n ) { $ count = 0 ; $ m ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ count ++ ; } $ m = $ count \/ $ n ; return $ m ; } $ a = array ( 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ) ; $ n = count ( $ a ) ; echo rainDayProbability ( $ a , $ n ) ; ? >"}
{"text":"Program to find the sum of a Series 1 + 1 \/ 2 ^ 2 + 1 \/ 3 ^ 3 + \u00e2 \u20ac\u00a6 . . + 1 \/ n ^ n | Function to calculate the following series ; Driver Code","code":"< ? php function Series ( $ n ) { $ i ; $ sums = 0.0 ; $ ser ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ ser = 1 \/ pow ( $ i , $ i ) ; $ sums += $ ser ; } return $ sums ; } $ n = 3 ; $ res = Series ( $ n ) ; echo $ res ; ? >"}
{"text":"Ternary Search | Function to perform Ternary Search ; Find the mid1 and mid2 ; Check if key is present at any mid ; Since key is not present at mid , check in which region it is present then repeat the Search operation in that region ; The key lies in between l and mid1 ; The key lies in between mid2 and r ; The key lies in between mid1 and mid2 ; Key not found ; Get the array Sort the array if not sorted ; Starting index ; length of array ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result ; Key to be searched in the array ; Search the key using ternarySearch ; Print the result","code":"< ? php function ternarySearch ( $ l , $ r , $ key , $ ar ) { if ( $ r >= $ l ) { $ mid1 = ( int ) ( $ l + ( $ r - $ l ) \/ 3 ) ; $ mid2 = ( int ) ( $ r - ( $ r - $ l ) \/ 3 ) ; if ( $ ar [ $ mid1 ] == $ key ) { return $ mid1 ; } if ( $ ar [ $ mid2 ] == $ key ) { return $ mid2 ; } if ( $ key < $ ar [ $ mid1 ] ) { return ternarySearch ( $ l , $ mid1 - 1 , $ key , $ ar ) ; } else if ( $ key > $ ar [ $ mid2 ] ) { return ternarySearch ( $ mid2 + 1 , $ r , $ key , $ ar ) ; } else { return ternarySearch ( $ mid1 + 1 , $ mid2 - 1 , $ key , $ ar ) ; } } return -1 ; } $ ar = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; $ l = 0 ; $ r = 9 ; $ key = 5 ; $ p = ternarySearch ( $ l , $ r , $ key , $ ar ) ; echo \" Index \u2581 of \u2581 \" , $ key , \" \u2581 is \u2581 \" , ( int ) $ p , \" STRNEWLINE \" ; $ key = 50 ; $ p = ternarySearch ( $ l , $ r , $ key , $ ar ) ; echo \" Index \u2581 of \u2581 \" , $ key , \" \u2581 is \u2581 \" , ( int ) $ p , \" STRNEWLINE \" ; ? >"}
{"text":"Print characters and their frequencies in order of occurrence | PHP implementation to print the character and its frequency in order of its occurrence ; function to print the character and its frequency in order of its occurrence ; size of the string ' str ' ; ' freq [ ] ' implemented as hash table ; accumulate frequency of each character in ' str ' ; traverse ' str ' from left to right ; if frequency of character str [ i ] is not equal to 0 ; print the character along with its frequency ; update frequency of str [ i ] to 0 so that the same character is not printed again ; Driver Code","code":"< ? php $ SIZE = 26 ; function printCharWithFreq ( $ str ) { global $ SIZE ; $ n = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ SIZE , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] != 0 ) { echo $ str [ $ i ] . $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] . \" \" ; $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] = 0 ; } } } $ str = \" geeksforgeeks \" ; printCharWithFreq ( $ str ) ; ? >"}
{"text":"Check horizontal and vertical symmetry in binary matrix | PHP program to find if a matrix is symmetric . ; Initializing as both horizontal and vertical symmetric . ; Checking for Horizontal Symmetry . We compare first row with last row , second row with second last row and so on . ; Checking each cell of a column . ; check if every cell is identical ; Checking for Vertical Symmetry . We compare first column with last column , second xolumn with second last column and so on . ; Checking each cell of a row . ; check if every cell is identical ; Driver Code","code":"< ? php function checkHV ( $ arr , $ N , $ M ) { $ horizontal = true ; $ vertical = true ; for ( $ i = 0 , $ k = $ N - 1 ; $ i < $ N \/ 2 ; $ i ++ , $ k -- ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] != $ arr [ $ k ] [ $ j ] ) { $ horizontal = false ; break ; } } } for ( $ i = 0 , $ k = $ M - 1 ; $ i < $ M \/ 2 ; $ i ++ , $ k -- ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] != $ arr [ $ k ] [ $ j ] ) { $ horizontal = false ; break ; } } } if ( ! $ horizontal && ! $ vertical ) echo \" NO STRNEWLINE \" ; else if ( $ horizontal && ! $ vertical ) cout << \" HORIZONTAL STRNEWLINE \" ; else if ( $ vertical && ! $ horizontal ) echo \" VERTICAL STRNEWLINE \" ; else echo \" BOTH STRNEWLINE \" ; } $ mat = array ( array ( 1 , 0 , 1 ) , array ( 0 , 0 , 0 ) , array ( 1 , 0 , 1 ) ) ; checkHV ( $ mat , 3 , 3 ) ; ? >"}
{"text":"Program for addition of two matrices | PHP program for addition of two matrices ; This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code","code":"< ? php $ N = 4 ; function add ( & $ A , & $ B , & $ C ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] + $ B [ $ i ] [ $ j ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ N = 4 ; add ( $ A , $ B , $ C ) ; echo \" Result \u2581 matrix \u2581 is \u2581 STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo \" \u2581 \" ; } echo \" STRNEWLINE \" ; } ? >"}
{"text":"Program for subtraction of matrices | This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ] ; Driver code","code":"< ? php function subtract ( & $ A , & $ B , & $ C ) { $ N = 4 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] - $ B [ $ i ] [ $ j ] ; } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; subtract ( $ A , $ B , $ C ) ; echo \" Result \u2581 matrix \u2581 is \u2581 STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo \" \u2581 \" ; } echo \" STRNEWLINE \" ; } ? >"}
{"text":"Find a Fixed Point ( Value equal to index ) in a given array | PHP program to check fixed point in an array using linear search ; If no fixed point present then return - 1 ; Driver Code","code":"< ? php function linearSearch ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ i ) return $ i ; } return -1 ; } $ arr = array ( -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ) ; $ n = count ( $ arr ) ; echo \" Fixed \u2581 Point \u2581 is \u2581 \" . linearSearch ( $ arr , $ n ) ; ? >"}
{"text":"Find a Fixed Point ( Value equal to index ) in a given array | PHP program to check fixed po in an array using binary search ; low + ( high - low ) \/ 2 ; ; Return - 1 if there is no Fixed Po ; Driver Code","code":"< ? php function binarySearch ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = ( int ) ( ( $ low + $ high ) \/ 2 ) ; if ( $ mid == $ arr [ $ mid ] ) return $ mid ; if ( $ mid > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) ) ; } return -1 ; } $ arr = array ( -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ) ; $ n = count ( $ arr ) ; echo \" Fixed \u2581 Point \u2581 is : \u2581 \" . binarySearch ( $ arr , 0 , $ n - 1 ) ; ? >"}
{"text":"Maximum triplet sum in array | PHP code to find maximum triplet sum ; Initialize sum with INT_MIN ; Driver Code","code":"< ? php function maxTripletSum ( $ arr , $ n ) { $ sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ sum < $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ) $ sum = $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ; return $ sum ; } $ arr = array ( 1 , 0 , 8 , 6 , 4 , 2 ) ; $ n = count ( $ arr ) ; echo maxTripletSum ( $ arr , $ n ) ; ? >"}
{"text":"Maximum triplet sum in array | This function assumes that there are at least three elements in arr [ ] . ; sort the given array ; After sorting the array . Add last three element of the given array ; Driver code","code":"< ? php function maxTripletSum ( $ arr , $ n ) { sort ( $ arr ) ; return $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] + $ arr [ $ n - 3 ] ; } $ arr = array ( 1 , 0 , 8 , 6 , 4 , 2 ) ; $ n = count ( $ arr ) ; echo maxTripletSum ( $ arr , $ n ) ; ? >"}
{"text":"Maximum triplet sum in array | This function assumes that there are at least three elements in arr [ ] . ; Initialize Maximum , second maximum and third maximum element ; Update Maximum , second maximum and third maximum element ; Update second maximum and third maximum element ; Update third maximum element ; Driven code","code":"< ? php function maxTripletSum ( $ arr , $ n ) { $ maxA = PHP_INT_MIN ; $ maxB = PHP_INT_MIN ; $ maxC = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ maxA ) { $ maxC = $ maxB ; $ maxB = $ maxA ; $ maxA = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ maxB ) { $ maxC = $ maxB ; $ maxB = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ maxC ) $ maxC = $ arr [ $ i ] ; } return ( $ maxA + $ maxB + $ maxC ) ; } $ arr = array ( 1 , 0 , 8 , 6 , 4 , 2 ) ; $ n = count ( $ arr ) ; echo maxTripletSum ( $ arr , $ n ) ; ? >"}
{"text":"Linear Search | PHP code for linearly search x in arr [ ] . If x is present then return its location , otherwise return - 1 ; Driver Code ; Function call","code":"< ? php function search ( $ arr , $ x ) { $ n = sizeof ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; } return -1 ; } $ arr = array ( 2 , 3 , 4 , 10 , 40 ) ; $ x = 10 ; $ result = search ( $ arr , $ x ) ; if ( $ result == -1 ) echo \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ; else echo \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" , $ result ; ? >"}
{"text":"Counting Sort | PHP Program for counting sort ; The main function that sort the given string arr [ ] in alphabatical order ; The output character array that will have sorted arr ; Create a count array to store count of inidividul characters and initialize count array as 0 ; Store count of each character ; Change count [ i ] so that count [ i ] now contains actual position of this character in output array ; Build the output character array To make it stable we are operating in reverse order . ; Copy the output array to arr , so that arr now contains sorted characters ; Driver Code","code":"< ? php $ RANGE = 255 ; function countSort ( $ arr ) { global $ RANGE ; $ output = array ( strlen ( $ arr ) ) ; $ len = strlen ( $ arr ) ; $ count = array_fill ( 0 , $ RANGE + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) ++ $ count [ ord ( $ arr [ $ i ] ) ] ; for ( $ i = 1 ; $ i <= $ RANGE ; ++ $ i ) $ count [ $ i ] += $ count [ $ i - 1 ] ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { $ output [ $ count [ ord ( $ arr [ $ i ] ) ] - 1 ] = $ arr [ $ i ] ; -- $ count [ ord ( $ arr [ $ i ] ) ] ; } for ( $ i = 0 ; $ i < $ len ; ++ $ i ) $ arr [ $ i ] = $ output [ $ i ] ; return $ arr ; } $ arr = \" geeksforgeeks \" ; $ arr = countSort ( $ arr ) ; echo \" Sorted \u2581 character \u2581 array \u2581 is \u2581 \" . $ arr ; ? >"}
{"text":"Binomial Coefficient | DP | Returns value of Binomial Coefficient C ( n , k ) ; Base Cases ; Recur ; Driver Code","code":"< ? php function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; if ( $ k == 0 $ k == $ n ) return 1 ; return binomialCoeff ( $ n - 1 , $ k - 1 ) + binomialCoeff ( $ n - 1 , $ k ) ; } $ n = 5 ; $ k = 2 ; echo \" Value \u2581 of \u2581 C \" , \" ( \" , $ n , $ k , \" ) \u2581 is \u2581 \" , binomialCoeff ( $ n , $ k ) ; ? >"}
{"text":"Binomial Coefficient | DP | PHP program for space optimized Dynamic Programming Solution of Binomial Coefficient ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Driver Code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , $ k + 1 , 0 ) ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; } $ n = 5 ; $ k = 2 ; echo \" Value \u2581 of \u2581 C [ $ n , \u2581 $ k ] \u2581 is \u2581 \" . binomialCoeff ( $ n , $ k ) ; ? >"}
{"text":"Dynamic Programming | Returns true if there is a subset of set with sun equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; Driver Code","code":"< ? php function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = 6 ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; else echo \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; ? >"}
{"text":"Dynamic Programming | Returns true if there is a subset of set [ ] with sun equal to given sum ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in botton up manner ; print table ; Driver code","code":"< ? php function isSubsetSum ( $ set , $ n , $ sum ) { $ subset = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ subset [ $ i ] [ 0 ] = true ; for ( $ i = 1 ; $ i <= $ sum ; $ i ++ ) $ subset [ 0 ] [ $ i ] = false ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ sum ; $ j ++ ) { if ( $ j < $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] ; if ( $ j >= $ set [ $ i - 1 ] ) $ subset [ $ i ] [ $ j ] = $ subset [ $ i - 1 ] [ $ j ] || $ subset [ $ i - 1 ] [ $ j - $ set [ $ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( \" % 4d \" , subset [ i ] [ j ] ) ; printf ( \" n \" ) ; } return $ subset [ $ n ] [ $ sum ] ; } $ set = array ( 3 , 34 , 4 , 12 , 5 , 2 ) ; $ sum = 9 ; $ n = count ( $ set ) ; if ( isSubsetSum ( $ set , $ n , $ sum ) == true ) echo \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; else echo \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ; ? >"}
{"text":"How to print maximum number of A 's using given four keys | A recursive function that returns the optimal length string for N keystrokes ; The optimal string length is N when N is smaller than 7 ; Initialize result ; TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way . ; If the breakpoint is s at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1]; ; Driver code ; for the rest of the array we will rely on the previous entries to compute new ones","code":"< ? php function findoptimal ( $ N ) { if ( $ N <= 6 ) return $ N ; $ max = 0 ; $ b ; for ( $ b = $ N - 3 ; $ b >= 1 ; $ b -= 1 ) { $ curr = ( $ N - $ b - 1 ) * findoptimal ( $ b ) ; if ( $ curr > $ max ) $ max = $ curr ; } return $ max ; } $ N ; for ( $ N = 1 ; $ N <= 20 ; $ N += 1 ) echo ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \" . $ N . \" keystrokes \u2581 is \u2581 \" . findoptimal ( $ N ) . \" STRNEWLINE \" ) ; ? >"}
{"text":"Write a program to calculate pow ( x , n ) | Function to calculate x raised to the power y ; Driver Code","code":"< ? php function power ( $ x , $ y ) { if ( $ y == 0 ) return 1 ; else if ( $ y % 2 == 0 ) return power ( $ x , ( int ) $ y \/ 2 ) * power ( $ x , ( int ) $ y \/ 2 ) ; else return $ x * power ( $ x , ( int ) $ y \/ 2 ) * power ( $ x , ( int ) $ y \/ 2 ) ; } $ x = 2 ; $ y = 3 ; echo power ( $ x , $ y ) ; ? >"}
{"text":"Write a program to calculate pow ( x , n ) | Extended version of power function that can work for float x and negative y ; Driver Code","code":"< ? php function power ( $ x , $ y ) { $ temp ; if ( $ y == 0 ) return 1 ; $ temp = power ( $ x , $ y \/ 2 ) ; if ( $ y % 2 == 0 ) return $ temp * $ temp ; else { if ( $ y > 0 ) return $ x * $ temp * $ temp ; else return ( $ temp * $ temp ) \/ $ x ; } } $ x = 2 ; $ y = -3 ; echo power ( $ x , $ y ) ; ? >"}
{"text":"Babylonian method for square root | Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e decides the accuracy level ; Driver Code","code":"< ? php function squareRoot ( $ n ) { $ x = $ n ; $ y = 1 ; $ e = 0.000001 ; while ( $ x - $ y > $ e ) { $ x = ( $ x + $ y ) \/ 2 ; $ y = $ n \/ $ x ; } return $ x ; } { $ n = 50 ; echo \" Square \u2581 root \u2581 of \u2581 $ n \u2581 is \u2581 \" , squareRoot ( $ n ) ; } ? >"}
{"text":"Average of a stream of numbers | Returns the new average after including x ; Prints average of a stream of numbers ; Driver Code","code":"< ? php function getAvg ( $ prev_avg , $ x , $ n ) { return ( $ prev_avg * $ n + $ x ) \/ ( $ n + 1 ) ; } function streamAvg ( $ arr , $ n ) { $ avg = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ avg = getAvg ( $ avg , $ arr [ $ i ] , $ i ) ; echo \" Average \u2581 of \u2581 \" , $ i + 1 , \" numbers \u2581 is \u2581 \" , $ avg , \" STRNEWLINE \" ; } return ; } $ arr = array ( 10 , 20 , 30 , 40 , 50 , 60 ) ; $ n = sizeof ( $ arr ) ; streamAvg ( $ arr , $ n ) ; ? >"}
{"text":"Average of a stream of numbers | Returns the new average after including x ; Prints average of a stream of numbers ; Driver Code","code":"< ? php function getAvg ( $ x ) { static $ sum ; static $ n ; $ sum += $ x ; return ( ( ( float ) $ sum ) \/ ++ $ n ) ; } function streamAvg ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ avg = getAvg ( $ arr [ $ i ] ) ; echo \" Average \u2581 of \u2581 \" . ( $ i + 1 ) . \" \u2581 numbers \u2581 is \u2581 \" . $ avg . \" \u2581 STRNEWLINE \" ; } return ; } $ arr = array ( 10 , 20 , 30 , 40 , 50 , 60 ) ; $ n = sizeof ( $ arr ) \/ sizeof ( $ arr [ 0 ] ) ; streamAvg ( $ arr , $ n ) ; ? >"}
{"text":"Space and time efficient Binomial Coefficient | Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ] ; Driver Code","code":"< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res \/= ( $ i + 1 ) ; } return $ res ; } $ n = 8 ; $ k = 2 ; echo \" \u2581 Value \u2581 of \u2581 C \u2581 ( $ n , \u2581 $ k ) \u2581 is \u2581 \" , binomialCoeff ( $ n , $ k ) ; ? >"}
{"text":"Efficient program to print all prime factors of a given number | function to print all prime factors of a given number n ; Print the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Driver Code","code":"< ? php function primeFactors ( $ n ) { while ( $ n % 2 == 0 ) { echo 2 , \" \u2581 \" ; $ n = $ n \/ 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { echo $ i , \" \" ; $ n = $ n \/ $ i ; } } if ( $ n > 2 ) echo $ n , \" \u2581 \" ; } $ n = 315 ; primeFactors ( $ n ) ; ? >"}
{"text":"Print all possible combinations of r elements in a given array of size n | The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed ; Current combination is ready to be printed , print it ; replace index with all possible elements . The condition \" end - i + 1 \u2581 > = \u2581 \u2581 r - index \" makes sure that including one element at index will make a combination with remaining elements at remaining positions ; Driver Code","code":"< ? php function printCombination ( $ arr , $ n , $ r ) { $ data = array ( ) ; combinationUtil ( $ arr , $ data , 0 , $ n - 1 , 0 , $ r ) ; } function combinationUtil ( $ arr , $ data , $ start , $ end , $ index , $ r ) { if ( $ index == $ r ) { for ( $ j = 0 ; $ j < $ r ; $ j ++ ) echo $ data [ $ j ] ; echo \" STRNEWLINE \" ; return ; } for ( $ i = $ start ; $ i <= $ end && $ end - $ i + 1 >= $ r - $ index ; $ i ++ ) { $ data [ $ index ] = $ arr [ $ i ] ; combinationUtil ( $ arr , $ data , $ i + 1 , $ end , $ index + 1 , $ r ) ; } } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ r = 3 ; $ n = sizeof ( $ arr ) ; printCombination ( $ arr , $ n , $ r ) ; ? >"}
{"text":"Print all possible combinations of r elements in a given array of size n | The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( ) ; A temporary array to store all combination one by one ; Print all combination using temprary array ' data [ ] ' ; arr [ ] -- -> Input Array n -- -> Size of input array r -- -> Size of a combination to be printed index -- -> Current index in data [ ] data [ ] -- -> Temporary array to store current combination i -- -> index of current element in arr [ ] ; Current cobination is ready , print it ; When no more elements are there to put in data [ ] ; current is included , put next at next location ; current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed ) ; Driver Code","code":"< ? php function printCombination ( $ arr , $ n , $ r ) { $ data = Array ( ) ; combinationUtil ( $ arr , $ n , $ r , 0 , $ data , 0 ) ; } function combinationUtil ( $ arr , $ n , $ r , $ index , $ data , $ i ) { if ( $ index == $ r ) { for ( $ j = 0 ; $ j < $ r ; $ j ++ ) echo $ data [ $ j ] , \" \u2581 \" ; echo \" STRNEWLINE \" ; return ; } if ( $ i >= $ n ) return ; $ data [ $ index ] = $ arr [ $ i ] ; combinationUtil ( $ arr , $ n , $ r , $ index + 1 , $ data , $ i + 1 ) ; combinationUtil ( $ arr , $ n , $ r , $ index , $ data , $ i + 1 ) ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ r = 3 ; $ n = sizeof ( $ arr ) ; printCombination ( $ arr , $ n , $ r ) ; ? >"}
{"text":"Count all possible groups of size 2 or 3 that have sum as multiple of 3 | Returns count of all possible groups that can be formed from elements of a [ ] . ; Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i ; To store the result ; Count elements with remainder 0 , 1 and 2 ; Case 3. a : Count groups of size 2 from 0 remainder elements ; Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder ; Case 4. a : Count groups of size 3 with all 0 remainder elements ; Case 4. b : Count groups of size 3 with all 1 remainder elements ; Case 4. c : Count groups of size 3 with all 2 remainder elements ; Case 4. c : Count groups of size 3 with different remainders ; Return total count stored in res ; Driver Code","code":"< ? php function findgroups ( $ arr , $ n ) { $ c = array ( 0 , 0 , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ c [ $ arr [ $ i ] % 3 ] += 1 ; $ res += ( ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) ) >> 1 ) ; $ res += $ c [ 1 ] * $ c [ 2 ] ; $ res += ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) * ( $ c [ 0 ] - 2 ) ) \/ 6 ; $ res += ( $ c [ 1 ] * ( $ c [ 1 ] - 1 ) * ( $ c [ 1 ] - 2 ) ) \/ 6 ; $ res += ( ( $ c [ 2 ] * ( $ c [ 2 ] - 1 ) * ( $ c [ 2 ] - 2 ) ) \/ 6 ) ; $ res += $ c [ 0 ] * $ c [ 1 ] * $ c [ 2 ] ; return $ res ; } $ arr = array ( 3 , 6 , 7 , 2 , 9 ) ; $ n = count ( $ arr ) ; echo \" Required \u2581 number \u2581 of \u2581 groups \u2581 are \u2581 \" . ( int ) ( findgroups ( $ arr , $ n ) ) ; ? >"}
{"text":"Smallest power of 2 greater than or equal to n | PHP program to find smallest power of 2 greater than or equal to n ; First n in the below condition is for the case where n is 0 ; Driver Code","code":"< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } $ n = 0 ; echo ( nextPowerOf2 ( $ n ) ) ; ? >"}
{"text":"Smallest power of 2 greater than or equal to n | Program to find smallest power of 2 greater than or equal to n ; Driver Code","code":"< ? php function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; } $ n = 5 ; echo ( nextPowerOf2 ( $ n ) ) ; ? >"}
{"text":"Smallest power of 2 greater than or equal to n | Finds next power of two for n . If n itself is a power of two then returns n ; Driver Code","code":"< ? php function nextPowerOf2 ( $ n ) { $ n -- ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ n ++ ; return $ n ; } $ n = 5 ; echo nextPowerOf2 ( $ n ) ; ? >"}
{"text":"Segregate 0 s and 1 s in an array | Function to segregate 0 s and 1 s ; Counts the no of zeros in arr ; Loop fills the arr with 0 until count ; Loop fills remaining arr space with 1 ; Function to print segregated array ; Driver Code","code":"< ? php function segregate0and1 ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) $ count ++ ; } for ( $ i = 0 ; $ i < $ count ; $ i ++ ) $ arr [ $ i ] = 0 ; for ( $ i = $ count ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = 1 ; } function toprint ( & $ arr , $ n ) { echo ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; } $ arr = array ( 0 , 1 , 0 , 1 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; segregate0and1 ( $ arr , $ n ) ; toprint ( $ arr , $ n ) ; ? >"}
{"text":"Segregate 0 s and 1 s in an array | Function to put all 0 s on left and all 1 s on right ; Initialize left and right indexes ; Increment left index while we see 0 at left ; Decrement right index while we see 1 at right ; If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ] ; Driver code","code":"< ? php function segregate0and1 ( & $ arr , $ size ) { $ left = 0 ; $ right = $ size - 1 ; while ( $ left < $ right ) { while ( $ arr [ $ left ] == 0 && $ left < $ right ) $ left ++ ; while ( $ arr [ $ right ] == 1 && $ left < $ right ) $ right -- ; if ( $ left < $ right ) { $ arr [ $ left ] = 0 ; $ arr [ $ right ] = 1 ; $ left ++ ; $ right -- ; } } } $ arr = array ( 0 , 1 , 0 , 1 , 1 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; segregate0and1 ( $ arr , $ arr_size ) ; printf ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" ) ; for ( $ i = 0 ; $ i < 6 ; $ i ++ ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; ? >"}
{"text":"Segregate 0 s and 1 s in an array | Function to put all 0 s on left and all 1 s on right ; Driver Code","code":"< ? php function segregate0and1 ( & $ arr , $ size ) { $ type0 = 0 ; $ type1 = $ size - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else $ type0 ++ ; } } $ arr = array ( 0 , 1 , 0 , 1 , 1 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; segregate0and1 ( $ arr , $ arr_size ) ; echo ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" ) ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) echo ( $ arr [ $ i ] . \" \u2581 \" ) ; ? >"}
{"text":"Given an array arr [ ] , find the maximum j | For a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ] ; Driver Code","code":"< ? php function maxIndexDiff ( $ arr , $ n ) { $ maxDiff = -1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = $ n - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] > $ arr [ $ i ] && $ maxDiff < ( $ j - $ i ) ) $ maxDiff = $ j - $ i ; } } return $ maxDiff ; } $ arr = array ( 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 ) ; $ n = count ( $ arr ) ; $ maxDiff = maxIndexDiff ( $ arr , $ n ) ; echo $ maxDiff ; ? >"}
{"text":"k | Function to find k - th missing element ; interating over the array ; check if i - th and ( i + 1 ) - th element are not consecutive ; save their difference ; check for difference and given k ; if found ; Input array ; k - th missing element to be found in the array ; calling function to find missing element","code":"< ? php function missingK ( & $ a , $ k , $ n ) { $ difference = 0 ; $ ans = 0 ; $ count = $ k ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ difference = 0 ; if ( ( $ a [ $ i ] + 1 ) != $ a [ $ i + 1 ] ) { $ difference += ( $ a [ $ i + 1 ] - $ a [ $ i ] ) - 1 ; if ( $ difference >= $ count ) { $ ans = $ a [ $ i ] + $ count ; $ flag = 1 ; break ; } else $ count -= $ difference ; } } if ( $ flag ) return $ ans ; else return -1 ; } $ a = array ( 1 , 5 , 11 , 19 ) ; $ k = 11 ; $ n = count ( $ a ) ; $ missing = missingK ( $ a , $ k , $ n ) ; echo $ missing ; ? >"}
{"text":"Minimum rotations required to get the same string | Returns count of rotations to get the same string back . ; tmp is the concatenated string . ; substring from i index of original string size . ; if substring matches with original string then we will come out of the loop . ; Driver code","code":"< ? php function findRotations ( $ str ) { $ tmp = ( $ str + $ str ) ; $ n = strlen ( $ str ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ substring = $ tmp . substr ( $ i , strlen ( $ str ) ) ; if ( $ str == $ substring ) return $ i ; } return $ n ; } $ str = \" abc \" ; echo findRotations ( $ str ) , \" STRNEWLINE \" ; ? >"}
{"text":"k | Function to find the sum of minimum of all subarrays ; Insert all the elements in a set ; Find the maximum and minimum element ; Traverse from the minimum to maximum element ; Check if \" i \" is missing ; Check if it is kth missing ; If no kth element is missing ; Driver code","code":"< ? php function findKth ( $ arr , $ n , $ k ) { $ missing = array ( ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) array_push ( $ missing , $ arr [ $ i ] ) ; $ missing = array_unique ( $ missing ) ; $ maxm = max ( $ arr ) ; $ minm = min ( $ arr ) ; for ( $ i = $ minm + 1 ; $ i < $ maxm ; $ i ++ ) { if ( ! in_array ( $ i , $ missing , false ) ) $ count += 1 ; if ( $ count == $ k ) return $ i ; } return -1 ; } $ arr = array ( 2 , 10 , 9 , 4 ) ; $ n = sizeof ( $ arr ) ; $ k = 5 ; echo findKth ( $ arr , $ n , $ k ) ; ? >"}
{"text":"Number of Binary Strings of length N with K adjacent Set Bits | Function to find the number of Bit Strings of length N with K adjacent set bits ; Base Case when we form bit string of length n ; if f ( bit string ) = k , count this way ; Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset ; set the bit at currentIndex ; unset the bit at currentIndex ; Driver Code ; total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )","code":"< ? php function waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex , $ adjacentSetBits , $ lastBit ) { if ( $ currentIndex == $ n ) { if ( $ adjacentSetBits == $ k ) return 1 ; return 0 ; } $ noOfWays = 0 ; if ( $ lastBit == 1 ) { $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits + 1 , 1 ) ; $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits , 0 ) ; } else if ( ! $ lastBit ) { $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits , 1 ) ; $ noOfWays += waysToKAdjacentSetBits ( $ n , $ k , $ currentIndex + 1 , $ adjacentSetBits , 0 ) ; } return $ noOfWays ; } $ n = 5 ; $ k = 2 ; $ totalWays = waysToKAdjacentSetBits ( $ n , $ k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( $ n , $ k , 1 , 0 , 0 ) ; echo \" Number \u2581 of \u2581 ways \u2581 = \u2581 \" , $ totalWays , \" STRNEWLINE \" ; ? >"}
{"text":"Count ways to reach the nth stair using step 1 , 2 or 3 | Returns count of ways to reach n - th stair using 1 or 2 or 3 steps . ; Driver code","code":"< ? php function findStep ( $ n ) { if ( $ n == 1 $ n == 0 ) return 1 ; else if ( $ n == 2 ) return 2 ; else return findStep ( $ n - 3 ) + findStep ( $ n - 2 ) + findStep ( $ n - 1 ) ; } $ n = 4 ; echo findStep ( $ n ) ; ? >"}
{"text":"Partition problem | DP | A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum ; Base Cases ; If last element is greater than sum , then ignore it ; else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element ; Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false ; Calculate sum of the elements in array ; If sum is odd , there cannot be two subsets with equal sum ; Find if there is subset with sum equal to half of total sum ; Driver Code ; Function call","code":"< ? php function isSubsetSum ( $ arr , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 && $ sum != 0 ) return false ; if ( $ arr [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ arr , $ n - 1 , $ sum ) ; return isSubsetSum ( $ arr , $ n - 1 , $ sum ) || isSubsetSum ( $ arr , $ n - 1 , $ sum - $ arr [ $ n - 1 ] ) ; } function findPartiion ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( $ sum % 2 != 0 ) return false ; return isSubsetSum ( $ arr , $ n , $ sum \/ 2 ) ; } $ arr = array ( 3 , 1 , 5 , 9 , 12 ) ; $ n = count ( $ arr ) ; if ( findPartiion ( $ arr , $ n ) == true ) echo \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ; else echo \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ; ? >"}
{"text":"Find repeated character present first in a string | PHP program to find the first character that is repeated ; this is O ( N ^ 2 ) method ; Driver code","code":"< ? php function findRepeatFirstN2 ( $ s ) { $ p = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { for ( $ j = ( $ i + 1 ) ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ i ] == $ s [ $ j ] ) { $ p = $ i ; break ; } } if ( $ p != -1 ) break ; } return $ p ; } $ str = \" geeksforgeeks \" ; $ pos = findRepeatFirstN2 ( $ str ) ; if ( $ pos == -1 ) echo ( \" Not \u2581 found \" ) ; else echo ( $ str [ $ pos ] ) ; ? >"}
{"text":"Count number of strings ( made of R , G and B ) using given combination | Function to calculate number of strings ; Store factorial of numbers up to n for further computation ; Find the remaining values to be added ; Make all possible combinations of R , B and G for the remaining value ; Compute permutation of each combination one by one and add them . ; Return total no . of strings \/ permutation ; Driver Code","code":"< ? php function possibleStrings ( $ n , $ r , $ b , $ g ) { $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ fact [ $ i - 1 ] * $ i ; $ left = $ n - ( $ r + $ g + $ b ) ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ left ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ left - $ i ; $ j ++ ) { $ k = $ left - ( $ i + $ j ) ; $ sum = $ sum + $ fact [ $ n ] \/ ( $ fact [ $ i + $ r ] * $ fact [ $ j + $ b ] * $ fact [ $ k + $ g ] ) ; } } return $ sum ; } $ n = 4 ; $ r = 2 ; $ b = 0 ; $ g = 1 ; echo possibleStrings ( $ n , $ r , $ b , $ g ) ; ? >"}
{"text":"Remove minimum number of characters so that two strings become anagram | function to calculate minimum numbers of characters to be removed to make two strings anagram ; make hash array for both string and calculate frequency of each character ; count frequency of each character in first string ; count frequency of each character in second string ; traverse count arrays to find number of characters to be removed ; Driver Code","code":"< ? php function remAnagram ( $ str1 , $ str2 ) { $ count1 = array ( 26 ) ; $ count2 = array ( 26 ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) $ count1 [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) $ count2 [ $ str2 [ $ i ] - ' a ' ] ++ ; $ result = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ result += abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return $ result ; } { $ str1 = \" bcadeh \" ; $ str2 = \" hea \" ; echo ( remAnagram ( $ str1 , $ str2 ) ) ; }"}
{"text":"Print path from root to all nodes in a Complete Binary Tree | Function to print path of all the nodes nth node represent as given node kth node represents as left and right node ; base condition if kth node value is greater then nth node then its means kth node is not valid so we not store it into the res simply we just return ; Storing node into res ; Print the path from root to node ; store left path of a tree So for left we will go node ( kThNode * 2 ) ; right path of a tree and for right we will go node ( kThNode * 2 + 1 ) ; Function to print path from root to all of the nodes ; res is for store the path from root to particulate node ; Print path from root to all node . third argument 1 because of we have to consider root node is 1 ; Given Node ; Print path from root to all node .","code":"< ? php function printPath ( $ res , $ nThNode , $ kThNode ) { if ( $ kThNode > $ nThNode ) return ; array_push ( $ res , $ kThNode ) ; for ( $ i = 0 ; $ i < count ( $ res ) ; $ i ++ ) echo $ res [ $ i ] . \" \u2581 \" ; echo \" STRNEWLINE \" ; printPath ( $ res , $ nThNode , $ kThNode * 2 ) ; printPath ( $ res , $ nThNode , $ kThNode * 2 + 1 ) ; } function printPathToCoverAllNodeUtil ( $ nThNode ) { $ res = array ( ) ; printPath ( $ res , $ nThNode , 1 ) ; } $ nThNode = 7 ; printPathToCoverAllNodeUtil ( $ nThNode ) ; ? >"}
{"text":"Minimum length of the shortest path of a triangle | function to get the minimum length of the shorter side of the triangle ; traversing through each points on the plane ; if sum of a points is greater than the previous one , the maximum gets replaced ; print the length ; initialize the number of points ; points on the plane","code":"< ? php function shortestLength ( $ n , & $ x , & $ y ) { $ answer = 0 ; $ i = 0 ; while ( $ n -- ) { if ( $ x [ $ i ] + $ y [ $ i ] > $ answer ) $ answer = $ x [ $ i ] + $ y [ $ i ] ; $ i ++ ; } echo \" Length \u2581 - > \u2581 \" . $ answer . \" STRNEWLINE \" ; echo \" Path \u2581 - > \u2581 \" . \" ( 1 , \" \u2581 . $ answer \u2581 . \" ) \" . STRNEWLINE TABSYMBOL TABSYMBOL \" and ( \" \u2581 . $ answer \u2581 . \u2581 \" , 1 ) \" ; } $ n = 4 ; $ x = array ( 1 , 4 , 2 , 1 ) ; $ y = array ( 4 , 1 , 1 , 2 ) ; shortestLength ( $ n , $ x , $ y ) ; ? >"}
{"text":"Intersecting rectangle when bottom | function to find intersection rectangle of given two rectangles . ; gives bottom - left point of intersection rectangle ; gives top - right point of intersection rectangle ; no intersection ; gives top - left point of intersection rectangle ; gives bottom - right point of intersection rectangle ; bottom - left and top - right corners of first rectangle ; bottom - left and top - right corners of first rectangle ; function call","code":"< ? php function FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { $ x5 = max ( $ x1 , $ x3 ) ; $ y5 = max ( $ y1 , $ y3 ) ; $ x6 = min ( $ x2 , $ x4 ) ; $ y6 = min ( $ y2 , $ y4 ) ; if ( $ x5 > $ x6 $ y5 > $ y6 ) { echo \" No \u2581 intersection \" ; return ; } echo \" ( \" . $ x5 . \" , \" \u2581 . \u2581 $ y5 \u2581 . \u2581 \" ) \" ; echo \" ( \" . $ x6 . \" , \" \u2581 . \u2581 $ y6 \u2581 . \u2581 \" ) \" ; $ x7 = $ x5 ; $ y7 = $ y6 ; echo \" ( \" . $ x7 . \" , \" \u2581 . \u2581 $ y7 \u2581 . \u2581 \" ) \" ; $ x8 = $ x6 ; $ y8 = $ y5 ; echo \" ( \" . $ x8 . \" , \" \u2581 . \u2581 $ y8 \u2581 . \u2581 \" ) \" ; } $ x1 = 0 ; $ y1 = 0 ; $ x2 = 10 ; $ y2 = 8 ; $ x3 = 2 ; $ y3 = 3 ; $ x4 = 7 ; $ y4 = 9 ; FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) ; ? >"}
{"text":"Area of triangle formed by the axes of co | Function to find area ; Driver code","code":"< ? php function area ( $ a , $ b , $ c ) { $ d = abs ( ( $ c * $ c ) \/ ( 2 * $ a * $ b ) ) ; return $ d ; } $ a = -2 ; $ b = 4 ; $ c = 3 ; echo area ( $ a , $ b , $ c ) ; ? >"}
{"text":"Sum of two numbers where one number is represented as array of digits | Function to return the vector containing the answer ; Vector v is to store each digits sum and vector ans is to store the answer ; No carry in the beginning ; Start loop from the end and take element one by one ; Array index and last digit of number ; Maintain carry of summation ; Push the digit value into the array ; K value is greater then 0 ; Push digits of K one by one in the array ; Also maintain carry with summation ; Reverse the elements of vector v and store it in vector ans ; Driver code ; Print the answer","code":"< ? php function addToArrayForm ( $ A , $ K ) { $ v = array ( ) ; $ ans = array ( ) ; $ rem = 0 ; $ i = 0 ; for ( $ i = count ( $ A ) - 1 ; $ i >= 0 ; $ i -- ) { $ my = $ A [ $ i ] + $ K % 10 + $ rem ; if ( $ my > 9 ) { $ rem = 1 ; array_push ( $ v , $ my % 10 ) ; } else { array_push ( $ v , $ my ) ; $ rem = 0 ; } $ K = floor ( $ K \/ 10 ) ; } while ( $ K > 0 ) { $ my = $ K % 10 + $ rem ; array_push ( $ v , $ my % 10 ) ; if ( $ my \/ 10 > 0 ) $ rem = 1 ; else $ rem = 0 ; $ K = floor ( $ K \/ 10 ) ; } if ( $ rem > 0 ) array_push ( $ v , $ rem ) ; for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) array_push ( $ ans , $ v [ $ i ] ) ; return $ ans ; } $ A = array ( 2 , 7 , 4 ) ; $ K = 181 ; $ ans = addToArrayForm ( $ A , $ K ) ; for ( $ i = 0 ; $ i < count ( $ ans ) ; $ i ++ ) echo $ ans [ $ i ] ; ? >"}
{"text":"Third last digit in 5 ^ N for given N | Function to find the element ; if n < 3 ; If n is even return 6 If n is odd return 1 ; Driver code","code":"< ? php function findThirdDigit ( $ n ) { if ( $ n < 3 ) return 0 ; return $ n & 1 ? 1 : 6 ; } $ n = 7 ; echo findThirdDigit ( $ n ) ; ? >"}
{"text":"Probability of A winning the match when individual probabilities of hitting the target given | Function to return the probability of A winning ; p and q store the values of fractions a \/ b and c \/ d ; To store the winning probability of A ; Driver code","code":"< ? php function getProbability ( $ a , $ b , $ c , $ d ) { $ p = $ a \/ $ b ; $ q = $ c \/ $ d ; $ ans = $ p * ( 1 \/ ( 1 - ( 1 - $ q ) * ( 1 - $ p ) ) ) ; return round ( $ ans , 6 ) ; } $ a = 1 ; $ b = 2 ; $ c = 10 ; $ d = 11 ; echo getProbability ( $ a , $ b , $ c , $ d ) ; ? >"}
{"text":"Largest palindromic number in an array | Function to check if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digits are not same then return false ; Removing the leading and trailing digits from the number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function to find the largest palindromic number ; If a palindrome larger than the currentMax is found ; Return the largest palindromic number from the array ; Driver Code ; print required answer","code":"< ? php function isPalindrome ( $ n ) { $ divisor = 1 ; while ( ( int ) ( $ n \/ $ divisor ) >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = ( int ) ( $ n \/ $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( $ n % $ divisor ) \/ 10 ; $ divisor = $ divisor \/ 100 ; } return true ; } function largestPalindrome ( $ A , $ n ) { $ currentMax = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ A [ $ i ] > $ currentMax && isPalindrome ( $ A [ $ i ] ) ) $ currentMax = $ A [ $ i ] ; } return $ currentMax ; } $ A = array ( 1 , 232 , 54545 , 999991 ) ; $ n = sizeof ( $ A ) ; echo ( largestPalindrome ( $ A , $ n ) ) ; ? >"}
{"text":"Reduce the array to a single element with the given operation | Function to return the final element ; Driver code","code":"< ? php function getFinalElement ( $ n ) { $ finalNum = 0 ; for ( $ finalNum = 2 ; ( $ finalNum * 2 ) <= $ n ; $ finalNum *= 2 ) ; return $ finalNum ; } $ N = 12 ; echo getFinalElement ( $ N ) ; ? >"}
{"text":"Sum of all odd length palindromic numbers within the range [ L , R ] | Function that returns true if the given number is a palindrome ; Here we are generating a new number ( reverse_num ) by reversing the digits of original input number ; If the original input number ( num ) is equal to its reverse ( reverse_num ) then its palindrome else it is not . ; Function that returns true if the given number is of odd length ; Function to return the sum of all odd length palindromic numbers within the given range ; if number is palindrome and of odd length ; Driver code","code":"< ? php function isPalindrome ( $ num ) { $ reverse_num = 0 ; $ remainder ; $ temp ; $ temp = $ num ; while ( $ temp != 0 ) { $ remainder = $ temp % 10 ; $ reverse_num = $ reverse_num * 10 + $ remainder ; $ temp = ( int ) ( $ temp \/ 10 ) ; } if ( $ reverse_num == $ num ) { return true ; } return false ; } function isOddLength ( $ num ) { $ count = 0 ; while ( $ num > 0 ) { $ num = ( int ) ( $ num \/ 10 ) ; $ count ++ ; } if ( $ count % 2 != 0 ) { return true ; } return false ; } function sumOfAllPalindrome ( $ L , $ R ) { $ sum = 0 ; if ( $ L <= $ R ) for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { if ( isPalindrome ( $ i ) && isOddLength ( $ i ) ) { $ sum += $ i ; } } return $ sum ; } $ L = 110 ; $ R = 1130 ; echo sumOfAllPalindrome ( $ L , $ R ) ; ? >"}
{"text":"Sum of Fibonacci Numbers with alternate negatives | Computes value of first fibonacci numbers and stores their alternate sum ; Initialize result ; Add remaining terms ; For even terms ; For odd terms ; Return the alternating sum ; Get n ; Find the alternating sum","code":"< ? php function calculateAlternateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = pow ( $ fibo [ 0 ] , 2 ) + pow ( $ fibo [ 1 ] , 2 ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum -= $ fibo [ $ i ] ; else $ sum += $ fibo [ $ i ] ; } return $ sum ; } $ n = 8 ; echo ( \" Alternating \u2581 Fibonacci \u2581 Sum \u2581 upto \u2581 \" ) ; echo $ n ; echo \" \u2581 terms : \u2581 \" ; echo ( calculateAlternateSum ( $ n ) ) ; ? >"}
{"text":"Find nth Term of the Series 1 2 2 4 4 4 4 8 8 8 8 8 8 8 8 ... | Function that will return nth term ; Get n ; Get the value ; Get n ; Get the value","code":"< ? php function getValue ( $ n ) { $ i = 0 ; $ k = 1 ; while ( $ i < $ n ) { $ i = $ i + $ k ; $ k = $ k * 2 ; } return ( int ) $ k \/ 2 ; } $ n = 9 ; echo getValue ( $ n ) , \" STRNEWLINE \" ; $ n = 1025 ; echo getValue ( $ n ) , \" STRNEWLINE \" ; ? >"}
{"text":"Construct a frequency array of digits of the values obtained from x ^ 1 , x ^ 2 , ... ... . . , x ^ n | Function that traverses digits in a number and modifies frequency count array ; Array to keep count of digits ; Traversing through x ^ 1 to x ^ n ; For power function , both its parameters are to be in double ; calling countDigits function on x ^ i ; Printing count of digits 0 - 9 ; Driver code","code":"< ? php function countDigits ( $ val , & $ arr ) { while ( $ val > 0 ) { $ digit = $ val % 10 ; $ arr [ ( int ) ( $ digit ) ] += 1 ; $ val = ( int ) ( $ val \/ 10 ) ; } return ; } function countFrequency ( $ x , $ n ) { $ freq_count = array_fill ( 0 , 10 , 0 ) ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) { $ val = pow ( $ x , $ i ) ; countDigits ( $ val , $ freq_count ) ; } for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { echo $ freq_count [ $ i ] . \" \" ; } } $ x = 15 ; $ n = 3 ; countFrequency ( $ x , $ n ) ? >"}
{"text":"Number of values of b such that a = b + ( a ^ b ) | function to return the number of solutions ; check for every possible value ; Driver Code","code":"< ? php function countSolutions ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ a ; $ i ++ ) { if ( $ a == ( $ i + ( $ a ^ $ i ) ) ) $ count ++ ; } return $ count ; } $ a = 3 ; echo countSolutions ( $ a ) ; ? >"}
{"text":"Number of values of b such that a = b + ( a ^ b ) | function to return the number of solutions ; Driver Code","code":"< ? php function countSolutions ( $ a ) { $ count = bitCount ( $ a ) ; $ count = ( int ) pow ( 2 , $ count ) ; return $ count ; } function bitCount ( $ n ) { $ count = 0 ; while ( $ n != 0 ) { $ count ++ ; $ n &= ( $ n - 1 ) ; } return $ count ; } $ a = 3 ; echo ( countSolutions ( $ a ) ) ; ? >"}
{"text":"Sum of Area of all possible square inside a rectangle | Function to calculate the sum of area of all possible squares that comes inside the rectangle ; Square with max size possible ; calculate total square of a given size ; calculate area of squares of a particular size ; total area ; increment size ; Driver Code","code":"< ? php function calculateAreaSum ( $ l , $ b ) { $ size = 1 ; $ maxSize = min ( $ l , $ b ) ; $ totalArea = 0 ; for ( $ i = 1 ; $ i <= $ maxSize ; $ i ++ ) { $ totalSquares = ( $ l - $ size + 1 ) * ( $ b - $ size + 1 ) ; $ area = $ totalSquares * $ size * $ size ; $ totalArea += $ area ; $ size ++ ; } return $ totalArea ; } $ l = 4 ; $ b = 3 ; echo calculateAreaSum ( $ l , $ b ) ; ? >"}
{"text":"Hyperfactorial of a number | function to calculate the value of hyperfactorial ; initialise the val to 1 ; returns the hyperfactorial of a number ; Driver code","code":"< ? php function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ val = $ val * pow ( $ i , $ i ) ; } return $ val ; } $ num = 5 ; echo boost_hyperfactorial ( $ num ) ; ? >"}
{"text":"Hyperfactorial of a number | function to calculate the value of hyperfactorial ; initialise the val to 1 ; 1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . . ; returns the hyperfactorial of a number ; Driver code","code":"< ? php function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ val *= $ i ; } } return $ val ; } $ num = 5 ; echo boost_hyperfactorial ( $ num ) ; ? >"}
{"text":"Subtract 1 without arithmetic operators | PHP code to subtract one from a given number ; Flip all the set bits until we find a 1 ; flip the rightmost 1 bit ; Driver Code","code":"< ? php function subtractOne ( $ x ) { $ m = 1 ; while ( ! ( $ x & $ m ) ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; } echo subtractOne ( 13 ) ; ? >"}
{"text":"Find the mean vector of a Matrix | PHP program to find mean vector of given matrix ; Function to find mean vector ; loop to traverse each column ; to calculate mean of each row ; to store sum of elements of a column ; Driver Code","code":"< ? php $ rows = 3 ; $ cols = 3 ; function meanVector ( $ mat ) { global $ rows , $ cols ; echo \" [ \u2581 \" ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { $ mean = 0.00 ; $ sum = 0 ; for ( $ j = 0 ; $ j < $ cols ; $ j ++ ) $ sum += $ mat [ $ j ] [ $ i ] ; $ mean = $ sum \/ $ rows ; echo $ mean , \" \" ; \u2581 } \u2581 echo \u2581 \" ] \" } $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 5 , 6 ) , array ( 7 , 8 , 9 ) ) ; meanVector ( $ mat ) ; ? >"}
{"text":"Hoax Number | Function to find distinct prime factors of given number n ; n is odd at this point , since it is no longer divisible by 2. So we can test only for the odd numbers , whether they are factors of n ; Check if i is prime factor ; This condition is to handle the case when n is a prime number greater than 2 ; Function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained ; Distinct prime factors of n are being stored in vector pf ; If n is a prime number , it cannot be a hoax number ; Finding sum of digits of distinct prime factors of the number n ; Finding sum of digits in current prime factor pf [ i ] . ; Finding sum of digits of number n ; Comparing the two calculated sums ; Driver Code","code":"< ? php function primeFactors ( $ n ) { $ res = array ( ) ; if ( $ n % 2 == 0 ) { while ( $ n % 2 == 0 ) $ n = ( int ) $ n \/ 2 ; array_push ( $ res , 2 ) ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) $ n = ( int ) $ n \/ $ i ; array_push ( $ res , $ i ) ; } } if ( $ n > 2 ) array_push ( $ res , $ n ) ; return $ res ; } function isHoax ( $ n ) { $ pf = primeFactors ( $ n ) ; if ( $ pf [ 0 ] == $ n ) return false ; $ all_pf_sum = 0 ; for ( $ i = 0 ; $ i < count ( $ pf ) ; $ i ++ ) { $ pf_sum ; for ( $ pf_sum = 0 ; $ pf [ $ i ] > 0 ; $ pf_sum += $ pf [ $ i ] % 10 , $ pf [ $ i ] \/= 10 ) ; $ all_pf_sum += $ pf_sum ; } for ( $ sum_n = 0 ; $ n > 0 ; $ sum_n += $ n % 10 , $ n \/= 10 ) ; return $ sum_n == $ all_pf_sum ; } $ n = 84 ; if ( isHoax ( $ n ) ) echo ( \" A \u2581 Hoax \u2581 Number STRNEWLINE \" ) ; else echo ( \" Not \u2581 a \u2581 Hoax \u2581 Number STRNEWLINE \" ) ; ? >"}
{"text":"Modular multiplicative inverse from 1 to n | A naive method to find modular multiplicative inverse of ' a ' under modulo ' prime ' ; Driver Program","code":"< ? php function modInverse ( int $ a , int $ prime ) { $ a = $ a % $ prime ; for ( $ x = 1 ; $ x < $ prime ; $ x ++ ) if ( ( $ a * $ x ) % $ prime == 1 ) return $ x ; return -1 ; } function printModIverses ( $ n , $ prime ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo modInverse ( $ i , $ prime ) , \" \u2581 \" ; } $ n = 10 ; $ prime = 17 ; printModIverses ( $ n , $ prime ) ; ? >"}
{"text":"Convert to number with digits as 3 and 8 only | function for minimum operation ; remainder and operations count ; count digits not equal to 3 or 8 ; Driver Code","code":"< ? php function minOp ( $ num ) { $ count = 0 ; while ( $ num ) { $ rem = intval ( $ num % 10 ) ; if ( ! ( $ rem == 3 $ rem == 8 ) ) $ count ++ ; $ num = intval ( $ num \/ 10 ) ; } return $ count ; } $ num = 234198 ; echo \" Minimum \u2581 Operations \u2581 = \u2581 \" . minOp ( $ num ) ; ? >"}
{"text":"Biggest integer which has maximum digit sum in range from 1 to n | function to calculate the sum of digits of a number . ; Returns the maximum number with maximum sum of digits . ; initializing b as 1 and initial max sum to be of n ; iterates from right to left in a digit ; while iterating this is the number from from right to left ; calls the function to check if sum of cur is more then of ans ; reduces the number to one unit less ; Driver Code","code":"< ? php function sumOfDigits ( $ a ) { $ sum = 0 ; while ( $ a ) { $ sum += $ a % 10 ; $ a = ( int ) $ a \/ 10 ; } return $ sum ; } function findMax ( $ x ) { $ b = 1 ; $ ans = $ x ; while ( $ x ) { $ cur = ( $ x - 1 ) * $ b + ( $ b - 1 ) ; if ( sumOfDigits ( $ cur ) > sumOfDigits ( $ ans ) || ( sumOfDigits ( $ cur ) == sumOfDigits ( $ ans ) && $ cur > $ ans ) ) $ ans = $ cur ; $ x = ( int ) $ x \/ 10 ; $ b *= 10 ; } return $ ans ; } $ n = 521 ; echo findMax ( $ n ) ; ? >"}
{"text":"Interquartile Range ( IQR ) | Function to give index of the median ; Function to calculate IQR ; Index of median of entire data ; Median of first half ; Median of second half ; IQR calculation ; Driver Function","code":"< ? php function median ( $ a , $ l , $ r ) { $ n = $ r - $ l + 1 ; $ n = ( int ) ( ( $ n + 1 ) \/ 2 ) - 1 ; return $ n + $ l ; } function IQR ( $ a , $ n ) { sort ( $ a ) ; $ mid_index = median ( $ a , 0 , $ n ) ; $ Q1 = $ a [ median ( $ a , 0 , $ mid_index ) ] ; $ Q3 = $ a [ $ mid_index + median ( $ a , $ mid_index + 1 , $ n ) ] ; return ( $ Q3 - $ Q1 ) ; } $ a = array ( 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 ) ; $ n = count ( $ a ) ; echo IQR ( $ a , $ n ) ; ? >"}
{"text":"Largest palindromic number in an array | Function to check if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digits are not same then return false ; Removing the leading and trailing digits from the number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function to find the largest palindromic number ; Sort the array ; If number is palindrome ; If no palindromic number found ; Driver Code ; print required answer","code":"< ? php function isPalindrome ( $ n ) { $ divisor = 1 ; while ( ( int ) ( $ n \/ $ divisor ) >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = ( int ) ( $ n \/ $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( int ) ( ( $ n % $ divisor ) \/ 10 ) ; $ divisor = ( int ) ( $ divisor \/ 100 ) ; } return true ; } function largestPalindrome ( $ A , $ n ) { sort ( $ A ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; -- $ i ) { if ( isPalindrome ( $ A [ $ i ] ) ) return $ A [ $ i ] ; } return -1 ; } $ A = array ( 1 , 232 , 54545 , 999991 ) ; $ n = sizeof ( $ A ) ; echo largestPalindrome ( $ A , $ n ) ; ? >"}
{"text":"Sum of the multiples of two numbers below N | Function to return the sum of all the integers below N which are multiples of either A or B ; If i is a multiple of a or b ; Driver code","code":"< ? php function findSum ( $ n , $ a , $ b ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ i % $ a == 0 $ i % $ b == 0 ) $ sum += $ i ; return $ sum ; } $ n = 10 ; $ a = 3 ; $ b = 5 ; echo findSum ( $ n , $ a , $ b ) ; ? >"}
{"text":"Subtract 1 without arithmetic operators | Driver code","code":"< ? php function subtractOne ( $ x ) { return ( ( $ x << 1 ) + ( ~ $ x ) ) ; } print ( subtractOne ( 13 ) ) ; ? >"}
{"text":"Pell Number | calculate nth pell number ; Driver Code","code":"< ? php function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; return 2 * pell ( $ n - 1 ) + pell ( $ n - 2 ) ; } $ n = 4 ; echo ( pell ( $ n ) ) ; ? >"}
{"text":"Finding LCM of more than two ( or array ) numbers without using GCD | Returns LCM of arr [ 0. . n - 1 ] ; Find the maximum value in arr [ ] ; Initialize result ; Find all factors that are present in two or more array elements . $x = 2 ; Current factor . ; To store indexes of all array elements that are divisible by x . ; If there are 2 or more array elements that are divisible by x . ; Reduce all array elements divisible by x . ; Then multiply all reduced array elements ; Driver code","code":"< ? php function LCM ( $ arr , $ n ) { $ max_num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max_num < $ arr [ $ i ] ) $ max_num = $ arr [ $ i ] ; $ res = 1 ; while ( $ x <= $ max_num ) { $ indexes = array ( ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] % $ x == 0 ) array_push ( $ indexes , $ j ) ; if ( count ( $ indexes ) >= 2 ) { for ( $ j = 0 ; $ j < count ( $ indexes ) ; $ j ++ ) $ arr [ $ indexes [ $ j ] ] = ( int ) ( $ arr [ $ indexes [ $ j ] ] \/ $ x ) ; $ res = $ res * $ x ; } else $ x ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res * $ arr [ $ i ] ; return $ res ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ) ; $ n = count ( $ arr ) ; echo LCM ( $ arr , $ n ) . \" STRNEWLINE \" ; ? >"}
{"text":"Program for Goldbach\u00e2 \u20ac\u2122 s Conjecture ( Two Primes with given Sum ) | PHP program to implement Goldbach 's conjecture ; Array to store all prime less than and equal to 10 ^ 6 ; Utility function for Sieve of Sundaram ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half . This array is used to separate numbers of the form i + j + 2 * i * j from others where 1 <= i <= j ; Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1 ; Since 2 is a prime number ; Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; Function to perform Goldbach 's conjecture ; Return if number is not even or less than 3 ; Check only upto half of number ; find difference by subtracting current prime from n ; Search if the difference is also a prime number ; Express as a sum of primes ; Finding all prime numbers before limit ; Express number as a sum of two primes","code":"< ? php $ MAX = 10000 ; $ primes = array ( ) ; function sieveSundaram ( ) { global $ MAX , $ primes ; $ marked = array_fill ( 0 , ( int ) ( $ MAX \/ 2 ) + 100 , false ) ; for ( $ i = 1 ; $ i <= ( sqrt ( $ MAX ) - 1 ) \/ 2 ; $ i ++ ) for ( $ j = ( $ i * ( $ i + 1 ) ) << 1 ; $ j <= $ MAX \/ 2 ; $ j = $ j + 2 * $ i + 1 ) $ marked [ $ j ] = true ; array_push ( $ primes , 2 ) ; for ( $ i = 1 ; $ i <= $ MAX \/ 2 ; $ i ++ ) if ( $ marked [ $ i ] == false ) array_push ( $ primes , 2 * $ i + 1 ) ; } function findPrimes ( $ n ) { global $ MAX , $ primes ; if ( $ n <= 2 $ n % 2 != 0 ) { print ( \" Invalid \u2581 Input \u2581 STRNEWLINE \" ) ; return ; } for ( $ i = 0 ; $ primes [ $ i ] <= $ n \/ 2 ; $ i ++ ) { $ diff = $ n - $ primes [ $ i ] ; if ( in_array ( $ diff , $ primes ) ) { print ( $ primes [ $ i ] . \" + \" \u2581 . \u2581 $ diff \u2581 . \u2581 \" = \" \u2581 . \u2581 $ n \u2581 . \u2581 \" \" return ; } } } sieveSundaram ( ) ; findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; ? >"}
{"text":"k | A function to generate prime factors of a given number n and return k - th prime factor ; Find the number of 2 's  that divide k ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , store i and divide n ; This condition is to handle the case where n is a prime number greater than 2 ; Driver Code","code":"< ? php function kPrimeFactor ( $ n , $ k ) { while ( $ n % 2 == 0 ) { $ k -- ; $ n = $ n \/ 2 ; if ( $ k == 0 ) return 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { while ( $ n % $ i == 0 ) { if ( $ k == 1 ) return $ i ; $ k -- ; $ n = $ n \/ $ i ; } } if ( $ n > 2 && $ k == 1 ) return $ n ; return -1 ; } { $ n = 12 ; $ k = 3 ; echo kPrimeFactor ( $ n , $ k ) , \" STRNEWLINE \" ; $ n = 14 ; $ k = 3 ; echo kPrimeFactor ( $ n , $ k ) ; return 0 ; } ? >"}
{"text":"k | PHP program to find k - th prime factor using Sieve Of Eratosthenes . This program is efficient when we have a range of numbers . ; Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if MAX is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7 ; Create a boolean array \" prime [ 0 . . MAX ] \" and initialize all entries in it as false . ; Initializing smallest factor equal to 2 for all the even numbers ; For odd numbers less then equal to n ; s ( i ) for a prime is the number itself ; For all multiples of current prime number ; i is the smallest prime factor for number \" i * j \" . ; Function to generate prime factors and return its k - th prime factor . s [ i ] stores least prime factor of i . ; Keep dividing n by least prime factor while either n is not 1 or count of prime factors is not k . ; To keep track of count of prime factors ; Divide n to find next prime factor ; s [ i ] is going to store prime factor of i .","code":"< ? php $ MAX = 10001 ; function sieveOfEratosthenes ( & $ s ) { global $ MAX ; $ prime = array_fill ( 0 , $ MAX + 1 , false ) ; for ( $ i = 2 ; $ i <= $ MAX ; $ i += 2 ) $ s [ $ i ] = 2 ; for ( $ i = 3 ; $ i <= $ MAX ; $ i += 2 ) { if ( $ prime [ $ i ] == false ) { $ s [ $ i ] = $ i ; for ( $ j = $ i ; $ j * $ i <= $ MAX ; $ j += 2 ) { if ( $ prime [ $ i * $ j ] == false ) { $ prime [ $ i * $ j ] = true ; $ s [ $ i * $ j ] = $ i ; } } } } } function kPrimeFactor ( $ n , $ k , $ s ) { while ( $ n > 1 ) { if ( $ k == 1 ) return $ s [ $ n ] ; $ k -- ; $ n = ( int ) ( $ n \/ $ s [ $ n ] ) ; } return -1 ; } $ s = array_fill ( 0 , $ MAX + 1 , -1 ) ; sieveOfEratosthenes ( $ s ) ; $ n = 12 ; $ k = 3 ; print ( kPrimeFactor ( $ n , $ k , $ s ) . \" \" ) ; $ n = 14 ; $ k = 3 ; print ( kPrimeFactor ( $ n , $ k , $ s ) ) ; ? >"}
{"text":"Euler 's criterion (Check if square root under modulo p exists) | Returns true if square root of n under modulo p exists ; One by one check all numbers from 2 to p - 1 ; Driver Code","code":"< ? php function squareRootExists ( $ n , $ p ) { $ n = $ n % $ p ; for ( $ x = 2 ; $ x < $ p ; $ x ++ ) if ( ( $ x * $ x ) % $ p == $ n ) return true ; return false ; } $ p = 7 ; $ n = 2 ; if ( squareRootExists ( $ n , $ p ) == true ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text":"Legendre 's formula (Given p and n, find the largest x such that p^x divides n!) | Returns largest power of p that divides n ! ; Initialize result ; Calculate x = n \/ p + n \/ ( p ^ 2 ) + n \/ ( p ^ 3 ) + ... . ; Driver Code","code":"< ? php function largestPower ( $ n , $ p ) { $ x = 0 ; while ( $ n ) { $ n = ( int ) $ n \/ $ p ; $ x += $ n ; } return floor ( $ x ) ; } $ n = 10 ; $ p = 3 ; echo \" The \u2581 largest \u2581 power \u2581 of \u2581 \" , $ p ; echo \" \u2581 that \u2581 divides \u2581 \" , $ n , \" ! \u2581 is \u2581 \" ; echo largestPower ( $ n , $ p ) ; ? >"}
{"text":"Program for factorial of a number | PHP program to find factorial of given number ; single line to find factorial ; Driver Code","code":"< ? php function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; } $ num = 5 ; echo \" Factorial \u2581 of \u2581 \" , $ num , \" \u2581 is \u2581 \" , factorial ( $ num ) ; ? >"}
{"text":"Reverse actual bits of the given number | function to reverse bits of a number ; traversing bits of ' n ' from the right ; bitwise left shift ' rev ' by 1 ; if current bit is '1' ; bitwise right shift ' n ' by 1 ; required number ; Driver code","code":"< ? php function reverseBits ( $ n ) { $ rev = 0 ; while ( $ n > 0 ) { $ rev <<= 1 ; if ( $ n & 1 == 1 ) $ rev ^= 1 ; $ n >>= 1 ; } return $ rev ; } $ n = 11 ; echo reverseBits ( $ n ) ; ? >"}
{"text":"Ways to split array into two groups of same XOR value | Return the count number of ways to split array into two groups such that each grouphas equal XOR value . ; We can split only if XOR is 0. Since XOR of all is 0 , we can consider all subsets as one group . ; Driver Code","code":"< ? php function countgroup ( $ a , $ n ) { $ xs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ xs = $ xs ^ $ a [ $ i ] ; if ( $ xs == 0 ) return ( 1 << ( $ n - 1 ) ) - 1 ; return 0 ; } $ a = array ( 1 , 2 , 3 ) ; $ n = count ( $ a ) ; echo countgroup ( $ a , $ n ) ; ? >"}
{"text":"Extract ' k ' bits from a given position in a number . | Function to extract k bits from p position and returns the extracted value as integer ; Driver Code","code":"< ? php function bitExtracted ( $ number , $ k , $ p ) { return ( ( ( 1 << $ k ) - 1 ) & ( $ number >> ( $ p - 1 ) ) ) ; } $ number = 171 ; $ k = 5 ; $ p = 2 ; echo \" The \u2581 extracted \u2581 number \u2581 is \u2581 \" , bitExtracted ( $ number , $ k , $ p ) ; ? >"}
{"text":"Efficiently check whether n is a multiple of 4 or not | function to check whether ' n ' is a multiple of 4 or not ; if true , then ' n ' is a multiple of 4 ; else ' n ' is not a multiple of 4 ; Driver Code","code":"< ? php function isAMultipleOf4 ( $ n ) { if ( ( $ n & 3 ) == 0 ) return \" Yes \" ; return \" No \" ; } $ n = 16 ; echo isAMultipleOf4 ( $ n ) ; ? >"}
{"text":"Calculate square of a number without using * , \/ and pow ( ) | PHP implementation to calculate square without using * and pow ( ) ; handle negative input ; Initialize result ; Add n to res n - 1 times ; Driver Code","code":"< ? php function square ( $ n ) { if ( $ n < 0 ) $ n = - $ n ; $ res = $ n ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res += $ n ; return $ res ; } for ( $ n = 1 ; $ n <= 5 ; $ n ++ ) echo \" n = \" , \u2581 $ n , \u2581 \" , \" , \u2581 \" n ^ 2 = \" , square ( $ n ) , \" STRNEWLINE \u2581 \" ; ? >"}
{"text":"Find a point that lies inside exactly K given squares | PHP implementation of the approach ; Driver Code","code":"< ? php function PointInKSquares ( $ n , $ a , $ k ) { sort ( $ a ) ; return $ a [ $ n - $ k ] ; } $ k = 2 ; $ a = array ( 1 , 2 , 3 , 4 ) ; $ n = sizeof ( $ a ) ; $ x = PointInKSquares ( $ n , $ a , $ k ) ; echo \" ( \" . $ x . \" , \" \u2581 . \u2581 $ x \u2581 . \u2581 \" ) \" ; ? >"}
{"text":"Number of n digit stepping numbers | Space optimized solution | function that calculates the answer ; dp [ j ] stores count of i digit stepping numbers ending with digit j . ; To store result of length i - 1 before updating dp [ j ] for length i . ; if n is 1 then answer will be 10. ; Initialize values for count of digits equal to 1. ; Compute values for count of digits more than 1. ; If ending digit is 0 ; If ending digit is 9 ; For other digits . ; stores the final answer ; Driver program to test the above function","code":"< ? php function answer ( $ n ) { $ dp = array_fill ( 0 , 10 , 0 ) ; $ prev = array_fill ( 0 , 10 , 0 ) ; ; if ( $ n == 1 ) return 10 ; for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) $ dp [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { $ prev [ $ j ] = $ dp [ $ j ] ; } for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { if ( $ j == 0 ) $ dp [ $ j ] = $ prev [ $ j + 1 ] ; else if ( $ j == 9 ) $ dp [ $ j ] = $ prev [ $ j - 1 ] ; else $ dp [ $ j ] = $ prev [ $ j - 1 ] + $ prev [ $ j + 1 ] ; } } $ sum = 0 ; for ( $ j = 1 ; $ j <= 9 ; $ j ++ ) $ sum += $ dp [ $ j ] ; return $ sum ; } $ n = 2 ; echo answer ( $ n ) ; ? >"}
{"text":"Minimum changes required to make a Catalan Sequence | PHP implementation of the approach ; To store first N Catalan numbers ; Function to find first n Catalan numbers ; Initialize first two values in table ; Filong entries in catalan [ ] using recursive formula ; Function to return the minimum changes required ; Find first n Catalan Numbers ; a and b are first two Catalan Sequence numbers ; Insert first n catalan elements to set ; If catalan element is present in the array then remove it from set ; Return the remaining number of elements in the set ; Driver code","code":"< ? php $ MAX = 1000 ; $ catalan = array_fill ( 0 , $ MAX , 0 ) ; function catalanDP ( $ n ) { global $ catalan ; $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } } } function CatalanSequence ( $ arr , $ n ) { global $ catalan ; catalanDP ( $ n ) ; $ s = array ( ) ; $ a = $ b = 1 ; array_push ( $ s , $ a ) ; if ( $ n >= 2 ) { array_push ( $ s , $ b ) ; } for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ catalan [ $ i ] ) ; } $ s = array_unique ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( in_array ( $ arr [ $ i ] , $ s ) ) { unset ( $ s [ array_search ( $ arr [ $ i ] , $ s ) ] ) ; } } return count ( $ s ) ; } $ arr = array ( 1 , 1 , 2 , 5 , 41 ) ; $ n = count ( $ arr ) ; print ( CatalanSequence ( $ arr , $ n ) ) ; ? >"}
{"text":"Largest gap in an array | function to solve the given problem ; Driver Code","code":"< ? php function solve ( $ a , $ n ) { $ max1 = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ a [ $ i ] - $ a [ $ j ] ) > $ max1 ) { $ max1 = abs ( $ a [ $ i ] - $ a [ $ j ] ) ; } } } return $ max1 ; } $ arr = array ( -1 , 2 , 3 , -4 , -10 , 22 ) ; $ size = count ( $ arr ) ; echo \" Largest \u2581 gap \u2581 is \u2581 : \u2581 \" , solve ( $ arr , $ size ) ; ? >"}
{"text":"Largest gap in an array | function to solve the given problem ; finding maximum and minimum of an array ; Driver Code","code":"< ? php function solve ( $ a , $ n ) { $ min1 = $ a [ 0 ] ; $ max1 = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) $ max1 = $ a [ $ i ] ; if ( $ a [ $ i ] < $ min1 ) $ min1 = $ a [ $ i ] ; } return abs ( $ min1 - $ max1 ) ; } $ arr = array ( -1 , 2 , 3 , 4 , -10 ) ; $ size = count ( $ arr ) ; echo \" Largest \u2581 gap \u2581 is \u2581 : \u2581 \" , solve ( $ arr , $ size ) ; ? >"}
{"text":"Smallest subset with sum greater than all other elements | function to find minimum elements needed . ; calculating HALF of array sum ; sort the array in descending order . ; current sum greater than sum ; Driver Code","code":"< ? php function minElements ( $ arr , $ n ) { $ halfSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ halfSum = $ halfSum + $ arr [ $ i ] ; $ halfSum = $ halfSum \/ 2 ; rsort ( $ arr ) ; $ res = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] ; $ res ++ ; if ( $ curr_sum > $ halfSum ) return $ res ; } return $ res ; } $ arr = array ( 3 , 1 , 7 , 1 ) ; $ n = sizeof ( $ arr ) ; echo minElements ( $ arr , $ n ) ; ? >"}
{"text":"Minimum cost to reach a point N from 0 with two different operations allowed | Function to return minimum cost to reach destination ; Initialize cost to 0 ; going backwards until we reach initial position ; if 2 * X jump is better than X + 1 ; if X + 1 jump is better ; return cost ; Driver Code","code":"< ? php function minCost ( $ N , $ P , $ Q ) { $ cost = 0 ; while ( $ N > 0 ) { if ( $ N & 1 ) { $ cost += $ P ; $ N -- ; } else { $ temp = $ N \/ 2 ; if ( $ temp * $ P > $ Q ) $ cost += $ Q ; else $ cost += $ P * $ temp ; $ N \/= 2 ; } } return $ cost ; } $ N = 9 ; $ P = 5 ; $ Q = 1 ; echo minCost ( $ N , $ P , $ Q ) ; ? >"}
