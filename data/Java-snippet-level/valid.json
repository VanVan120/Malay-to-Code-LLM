{"text":"Java program to convert centimeter to pixels","code":"import java . io . * ; class GFG {"}
{"text":"Function to convert centimeters to pixels","code":"static double Conversion ( double centi ) { double pixels = ( 96 * centi ) \/ 2.54 ; System . out . println ( pixels ) ; return 0 ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int centi = 15 ; Conversion ( centi ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Method that returns the corresponding output by taking the given inputs .","code":"static int xor_operations ( int N , int arr [ ] , int M , int K ) {"}
{"text":"If this condition is satisfied , value of M is invalid","code":"if ( M < 0 M >= N ) return - 1 ;"}
{"text":"Check if index K is valid","code":"if ( K < 0 K >= N - M ) return - 1 ;"}
{"text":"Loop to perform M operations","code":"for ( int p = 0 ; p < M ; p ++ ) {"}
{"text":"Creating a temporary list","code":"Vector < Integer > temp = new Vector < Integer > ( ) ;"}
{"text":"Traversing the array","code":"for ( int i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"Calculate XOR values of adjacent elements","code":"int value = arr [ i ] ^ arr [ i + 1 ] ;"}
{"text":"Adding this value to the temporary list","code":"temp . add ( value ) ;"}
{"text":"Update the original array","code":"arr [ i ] = temp . get ( i ) ; } }"}
{"text":"Getting value at index K","code":"int ans = arr [ K ] ; return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Number of elements","code":"int N = 5 ;"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 1 , 4 , 5 , 6 , 7 } ; int M = 1 , K = 2 ;"}
{"text":"Function call","code":"System . out . print ( xor_operations ( N , arr , M , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the K consecutive elements with a sum equal to N","code":"public static void canBreakN ( long n ) {"}
{"text":"Iterate over [ 2 , INF ]","code":"for ( long i = 2 ; ; i ++ ) {"}
{"text":"Store the sum","code":"long m = i * ( i + 1 ) \/ 2 ;"}
{"text":"If the sum exceeds N then break the loop","code":"if ( m > n ) break ; long k = n - m ;"}
{"text":"Common difference should be divisible by number of terms","code":"if ( k % i != 0 ) continue ;"}
{"text":"Print value of i & return","code":"System . out . println ( i ) ; return ; }"}
{"text":"Print \" - 1\" if not possible to break N","code":"System . out . println ( \" - 1\" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N","code":"long N = 12 ;"}
{"text":"Function call","code":"canBreakN ( N ) ; } }"}
{"text":"Java program to find two coprime divisors of a given number such that both are greater than 1","code":"import java . util . * ; class GFG {"}
{"text":"Function which finds the required pair of divisors of N","code":"public static void findCoprimePair ( int N ) {"}
{"text":"We iterate upto sqrt ( N ) as we can find all the divisors of N in this time","code":"for ( int x = 2 ; x <= Math . sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) {"}
{"text":"If x is a divisor of N keep dividing as long as possible","code":"while ( N % x == 0 ) { N \/= x ; } if ( N > 1 ) {"}
{"text":"We have found a required pair","code":"System . out . println ( x + \" \u2581 \" + N ) ; return ; } } }"}
{"text":"No such pair of divisors of N was found , hence print - 1","code":"System . out . println ( - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Sample example 1","code":"int N = 45 ; findCoprimePair ( N ) ;"}
{"text":"Sample example 2","code":"N = 25 ; findCoprimePair ( N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static int MAX = 10000 ;"}
{"text":"Array to store all prime less than and equal to MAX .","code":"static Vector < Integer > primes = new Vector < Integer > ( ) ;"}
{"text":"Function for Sieve of Sundaram","code":"static void sieveSundaram ( ) {"}
{"text":"Boolean Array","code":"boolean marked [ ] = new boolean [ MAX \/ 2 + 1 ] ;"}
{"text":"Mark all numbers which do not generate prime number by 2 * i + 1","code":"for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) \/ 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX \/ 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } }"}
{"text":"Since 2 is a prime number","code":"primes . add ( 2 ) ;"}
{"text":"Print remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for ( int i = 1 ; i <= MAX \/ 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; }"}
{"text":"Function that returns true if n is a Wasteful number","code":"static boolean isWasteful ( int n ) { if ( n == 1 ) return false ;"}
{"text":"Count digits in original number","code":"int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no \/ 10 ; } int pDigit = 0 , count_exp = 0 , p = 0 ;"}
{"text":"Count all digits in prime factors of N pDigit is going to hold this value .","code":"for ( int i = 0 ; primes . get ( i ) <= n \/ 2 ; i ++ ) {"}
{"text":"Count powers of p in n","code":"while ( n % primes . get ( i ) == 0 ) {"}
{"text":"If primes [ i ] is a prime factor ,","code":"p = primes . get ( i ) ; n = n \/ p ;"}
{"text":"Count the power of prime factors","code":"count_exp ++ ; }"}
{"text":"Add its digits to pDigit","code":"while ( p > 0 ) { pDigit ++ ; p = p \/ 10 ; }"}
{"text":"Add digits of power of prime factors to pDigit .","code":"while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp \/ 10 ; } }"}
{"text":"If n != 1 then one prime factor still to be summed up","code":"if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n \/ 10 ; } }"}
{"text":"If digits in prime factors is more than digits in original number then return true . Else return false .","code":"return ( pDigit > sumDigits ) ; }"}
{"text":"Function to print Wasteful Number before N","code":"static void Solve ( int N ) {"}
{"text":"Iterate till N and check if i is wastefull or not","code":"for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { System . out . print ( i + \" \u2581 \" ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Precompute prime numbers upto 10 ^ 6","code":"sieveSundaram ( ) ; int N = 10 ;"}
{"text":"Function Call","code":"Solve ( N ) ; } }"}
{"text":"Java simple recursive program to print Nth Hexanacci numbers .","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the Nth Hexanacci number","code":"static int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; } static void printhexa ( int n ) { System . out . print ( printhexaRec ( n ) + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 11 ; printhexa ( n ) ; } }"}
{"text":"Java implementation to print Nth term of hexanacci numbers .","code":"class GFG {"}
{"text":"Function to print the Nth term of the Hexanacci number","code":"static void printhexa ( int n ) { if ( n < 0 ) return ;"}
{"text":"Initialize first five numbers to base cases","code":"int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ;"}
{"text":"Declare a current variable","code":"int curr = 0 ; if ( n < 6 ) System . out . println ( first ) ; else if ( n == 6 ) System . out . println ( sixth ) ; else {"}
{"text":"Loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth fifth to second , third , fourth , fifth and curr to sixth respectively","code":"for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } System . out . println ( curr ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 11 ; printhexa ( n ) ; } }"}
{"text":"Java program to find the smallest number whose sum of digits is also N","code":"class GFG {"}
{"text":"Function to find the smallest number whose sum of digits is also N","code":"static void smallestNumber ( int N ) { System . out . print ( ( N % 9 + 1 ) * Math . pow ( 10 , ( N \/ 9 ) ) - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 10 ; smallestNumber ( N ) ; } }"}
{"text":"Java program to find compositorial of composite numbers","code":"import java . util . * ; class GFG { static Vector < Integer > compo = new Vector < Integer > ( ) ;"}
{"text":"Function to check if a number is composite .","code":"static boolean isComposite ( int n ) {"}
{"text":"Corner cases","code":"if ( n <= 3 ) return false ;"}
{"text":"This is checked so that we can skip the middle five numbers in the below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; }"}
{"text":"This function stores all composite numbers less than N","code":"static void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . add ( i ) ; l += 1 ; } } } }"}
{"text":"Function to calculate the compositorial of n","code":"static int calculateCompositorial ( int n ) {"}
{"text":"Multiply first n composite number","code":"int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo . get ( i ) ; return result ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ;"}
{"text":"Vector to store all the composite less than N","code":"Compositorial_list ( n ) ; System . out . print ( ( calculateCompositorial ( n ) ) ) ; } }"}
{"text":"Java implementation to find out the powers of N that add upto K","code":"class GFG {"}
{"text":"Initializing the PowerArray with all 0 's","code":"static int b [ ] = new int [ 50 ] ;"}
{"text":"Function to find the powers of N that add up to K","code":"static int PowerArray ( int n , int k ) {"}
{"text":"Initializing the counter","code":"int count = 0 ;"}
{"text":"Executing the while loop until K is greater than 0","code":"while ( k > 0 ) { if ( k % n == 0 ) { k \/= n ; count ++ ; }"}
{"text":"If K % N == 1 , then the power array is incremented by 1","code":"else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ;"}
{"text":"Checking if any power is occurred more than once","code":"if ( b [ count ] > 1 ) { System . out . print ( - 1 ) ; return 0 ; } }"}
{"text":"For any other value , the sum of powers cannot be added up to K","code":"else { System . out . print ( - 1 ) ; return 0 ; } }"}
{"text":"Printing the powers of N that sum up to K","code":"for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { System . out . print ( i + \" , \u2581 \" ) ; } } return Integer . MIN_VALUE ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; } }"}
{"text":"Java Program to find the value 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K","code":"class GFG {"}
{"text":"Function to find value of 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K","code":"static int findSum ( int N , int k ) {"}
{"text":"Initialise sum to 0","code":"int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) {"}
{"text":"Find the value of pow ( i , 4 ) and then add it to the sum","code":"sum += ( int ) Math . pow ( i , k ) ; }"}
{"text":"Return the sum","code":"return sum ; }"}
{"text":"Drivers Code","code":"public static void main ( String [ ] args ) { int N = 8 , k = 4 ;"}
{"text":"Function call to find the sum","code":"System . out . println ( findSum ( N , k ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the count of indices that satisfy the given condition","code":"static int countIndices ( int arr [ ] , int n ) {"}
{"text":"To store the result","code":"int cnt = 0 ;"}
{"text":"To store the current maximum Initialized to 0 since there are only positive elements in the array","code":"int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"i is a valid index","code":"if ( max < arr [ i ] ) {"}
{"text":"Update the maximum so far","code":"max = arr [ i ] ;"}
{"text":"Increment the counter","code":"cnt ++ ; } } return cnt ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( countIndices ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Binary representation of the digits","code":"static String bin [ ] = { \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" } ;"}
{"text":"Function to return the maximum frequency of s modulo with a power of 2","code":"static int maxFreq ( String s ) {"}
{"text":"Store the binary representation","code":"String binary = \" \" ;"}
{"text":"Convert the octal to binary","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s . charAt ( i ) - '0' ] ; }"}
{"text":"Remove the LSB","code":"binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ )"}
{"text":"If there is 1 in the binary representation","code":"if ( binary . charAt ( i ) == '1' ) {"}
{"text":"Find the number of zeroes in between two 1 's in the binary representation","code":"count = Math . max ( count , j - prev ) ; prev = j ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String octal = \"13\" ; System . out . println ( maxFreq ( octal ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int sz = 100000 ; static boolean isPrime [ ] = new boolean [ sz + 1 ] ;"}
{"text":"Function for Sieve of Eratosthenes","code":"static void sieve ( ) { for ( int i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }"}
{"text":"Function to print all the prime numbers with d digits","code":"static void findPrimesD ( int d ) {"}
{"text":"Range to check integers","code":"int left = ( int ) Math . pow ( 10 , d - 1 ) ; int right = ( int ) Math . pow ( 10 , d ) - 1 ;"}
{"text":"For every integer in the range","code":"for ( int i = left ; i <= right ; i ++ ) {"}
{"text":"If the current integer is prime","code":"if ( isPrime [ i ] ) { System . out . print ( i + \" \u2581 \" ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"Generate primes","code":"sieve ( ) ; int d = 1 ; findPrimesD ( d ) ; } }"}
{"text":"Java program to find number of cells in the table contains X","code":"class GFG {"}
{"text":"Function to find number of cells in the table contains X","code":"public static int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 6 , x = 12 ;"}
{"text":"Function call","code":"System . out . println ( Cells ( n , x ) ) ; } }"}
{"text":"Java program to find the maximum possible value of the minimum value of modified array","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the maximum possible value of the minimum value of the modified array","code":"static int maxOfMin ( int a [ ] , int n , int S ) {"}
{"text":"To store minimum value of array","code":"int mi = Integer . MAX_VALUE ;"}
{"text":"To store sum of elements of array","code":"int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . min ( a [ i ] , mi ) ; }"}
{"text":"Solution is not possible","code":"if ( s1 < S ) return - 1 ;"}
{"text":"zero is the possible value","code":"if ( s1 == S ) return 0 ;"}
{"text":"minimum possible value","code":"int low = 0 ;"}
{"text":"maximum possible value","code":"int high = mi ;"}
{"text":"to store a required answer","code":"int ans = 0 ;"}
{"text":"Binary Search","code":"while ( low <= high ) { int mid = ( low + high ) \/ 2 ;"}
{"text":"If mid is possible then try to increase required answer","code":"if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; }"}
{"text":"If mid is not possible then decrease required answer","code":"else high = mid - 1 ; }"}
{"text":"Return required answer","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 10 , 10 , 10 , 10 , 10 } ; int S = 10 ; int n = a . length ; System . out . println ( maxOfMin ( a , n , S ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class solution {"}
{"text":"Function to print the desired Alphabet N Pattern","code":"static void Alphabet_N_Pattern ( int N ) { int index , side_index , size ;"}
{"text":"Declaring the values of Right , Left and Diagonal values","code":"int Right = 1 , Left = 1 , Diagonal = 2 ;"}
{"text":"Main Loop for the rows","code":"for ( index = 0 ; index < N ; index ++ ) {"}
{"text":"For the left Values","code":"System . out . print ( Left ++ ) ;"}
{"text":"Spaces for the diagonals","code":"for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) System . out . print ( \" \u2581 \" ) ;"}
{"text":"Condition for the diagonals","code":"if ( index != 0 && index != N - 1 ) System . out . print ( Diagonal ++ ) ; else System . out . print ( \" \u2581 \" ) ;"}
{"text":"Spaces for the Right Values","code":"for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) System . out . print ( \" \u2581 \" ) ;"}
{"text":"For the right values","code":"System . out . print ( Right ++ ) ; System . out . println ( ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Size of the Pattern","code":"int Size = 6 ;"}
{"text":"Calling the function to print the desired Pattern","code":"Alphabet_N_Pattern ( Size ) ; } }"}
{"text":"Java program to check if sum of digits of a number divides it","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to check if sum of digits of a number divides it","code":"static int isSumDivides ( int N ) { int temp = N ; int sum = 0 ;"}
{"text":"Calculate sum of all of digits of N","code":"while ( temp > 0 ) { sum += temp % 10 ; temp \/= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int N = 12 ; if ( isSumDivides ( N ) == 1 ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } }"}
{"text":"Java program to find sum of numbers from 1 to N which are divisible by 3 or 4","code":"class GFG {"}
{"text":"Function to calculate the sum of numbers divisible by 3 or 4","code":"static int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N \/ 3 ) ) * ( 2 * 3 + ( N \/ 3 - 1 ) * 3 ) \/ 2 ; S2 = ( ( N \/ 4 ) ) * ( 2 * 4 + ( N \/ 4 - 1 ) * 4 ) \/ 2 ; S3 = ( ( N \/ 12 ) ) * ( 2 * 12 + ( N \/ 12 - 1 ) * 12 ) \/ 2 ; return S1 + S2 - S3 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 20 ; System . out . print ( sum ( 12 ) ) ; } }"}
{"text":"Java program to find next greater number than N with exactly one bit different in binary representation of N","code":"class GFG {"}
{"text":"Function to find next greater number than N with exactly one bit different in binary representation of N","code":"static int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ;"}
{"text":"It is guaranteed that there is a bit zero in the number","code":"while ( true ) {"}
{"text":"If the shifted bit is zero then break","code":"if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ;"}
{"text":"increase the bit shift","code":"shift_count ++ ;"}
{"text":"increase the power of 2","code":"power_of_2 = power_of_2 * 2 ; }"}
{"text":"set the lowest bit of the number","code":"return ( N + power_of_2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] a ) { int N = 11 ;"}
{"text":"display the next number","code":"System . out . println ( \" The \u2581 next \u2581 number \u2581 is \u2581 = \u2581 \" + nextGreater ( N ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to return the count of the total number of ways to cover the distance with 1 , 2 and 3 steps","code":"static int countWays ( int n ) {"}
{"text":"Base conditions","code":"if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ;"}
{"text":"To store the last three stages","code":"int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ;"}
{"text":"Find the numbers of steps required to reach the distance i","code":"for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; }"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countWays ( n ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG { static int n = 6 , m = 6 ;"}
{"text":"Function to find the maximum value","code":"static void maxSum ( long arr [ ] [ ] ) {"}
{"text":"Dp table","code":"long [ ] [ ] dp = new long [ n + 1 ] [ 3 ] ;"}
{"text":"Fill the dp in bottom up manner","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Maximum of the three sections","code":"long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"Maximum of the first section","code":"if ( ( j \/ ( m \/ 3 ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; }"}
{"text":"Maximum of the second section","code":"else if ( ( j \/ ( m \/ 3 ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; }"}
{"text":"Maximum of the third section","code":"else if ( ( j \/ ( m \/ 3 ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } }"}
{"text":"If we choose element from section 1 , we cannot have selection from same section in adjacent rows","code":"dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; }"}
{"text":"Print the maximum sum","code":"System . out . print ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { long arr [ ] [ ] = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the total palindromic odd length sub - sequences","code":"static void solve ( char [ ] s ) { int n = s . length ;"}
{"text":"dp array to store the number of palindromic subsequences for 0 to i - 1 and j + 1 to n - 1","code":"int [ ] [ ] dp = new int [ n ] [ n ] ;"}
{"text":"We will start with the largest distance between i and j","code":"for ( int len = n - 1 ; len >= 0 ; -- len ) {"}
{"text":"For each len , we fix our i","code":"for ( int i = 0 ; i + len < n ; ++ i ) {"}
{"text":"For this i we will find our j","code":"int j = i + len ;"}
{"text":"Base cases","code":"if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) {"}
{"text":"If the characters are equal then look for out of bound index","code":"if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) {"}
{"text":"We have only 1 way that is to just pick these characters","code":"dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) {"}
{"text":"If the characters are not equal","code":"if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) {"}
{"text":"Subtract it as we have counted it twice","code":"dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } Vector < Integer > ways = new Vector < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) {"}
{"text":"We have just 1 palindrome sequence of length 1","code":"ways . add ( 1 ) ; } else {"}
{"text":"Else total ways would be sum of dp [ i - 1 ] [ i + 1 ] , that is number of palindrome sub - sequences from 1 to i - 1 + number of palindrome sub - sequences from i + 1 to n - 1","code":"int total = dp [ i - 1 ] [ i + 1 ] ; ways . add ( total ) ; } } for ( int i = 0 ; i < ways . size ( ) ; ++ i ) { System . out . print ( ways . get ( i ) + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { char [ ] s = \" xyxyx \" . toCharArray ( ) ; solve ( s ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; public class GFG {"}
{"text":"Function to return the number of chicks on the nth day","code":"static long getChicks ( int n ) {"}
{"text":"Size of dp [ ] has to be at least 6 ( 1 - based indexing )","code":"int size = Math . max ( n , 7 ) ; long [ ] dp = new long [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ;"}
{"text":"Every day current population will be three times of the previous day","code":"for ( int i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; }"}
{"text":"Manually calculated value","code":"dp [ 6 ] = 726 ;"}
{"text":"From 8 th day onwards","code":"for ( int i = 8 ; i <= n ; i ++ ) {"}
{"text":"Chick population decreases by 2 \/ 3 everyday . For 8 th day on [ i - 6 ] i . e 2 nd day population was 3 and so 2 new born die on the 6 th day and so on for the upcoming days","code":"dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] \/ 3 ) ) * 3 ; } return dp [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( getChicks ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to return the number of chicks on the nth day","code":"static int getChicks ( int n ) { int chicks = ( int ) Math . pow ( 3 , n - 1 ) ; return chicks ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( getChicks ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int n = 3 ;"}
{"text":"2d array to store states of dp","code":"static int [ ] [ ] dp = new int [ n ] [ n ] ;"}
{"text":"Array to determine whether a state has been solved before","code":"static int [ ] [ ] v = new int [ n ] [ n ] ;"}
{"text":"Function to return the minimum steps required","code":"static int minSteps ( int i , int j , int arr [ ] [ ] ) {"}
{"text":"Base cases","code":"if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; }"}
{"text":"If a state has been solved before it won 't be evaluated again","code":"if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ;"}
{"text":"Recurrence relation","code":"for ( int k = Math . max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= Math . min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 4 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { System . out . println ( - 1 ) ; } else { System . out . println ( ans ) ; } } }"}
{"text":"Java program to implement above approach","code":"class GFG { static int n = 3 ;"}
{"text":"2d array to store states of dp","code":"static int dp [ ] [ ] = new int [ n ] [ n ] ;"}
{"text":"array to determine whether a state has been solved before","code":"static int [ ] [ ] v = new int [ n ] [ n ] ;"}
{"text":"Function to find the minimum number of steps to reach the end of matrix","code":"static int minSteps ( int i , int j , int arr [ ] [ ] ) {"}
{"text":"base cases","code":"if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; }"}
{"text":"if a state has been solved before it won 't be evaluated again.","code":"if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ;"}
{"text":"recurrence relation","code":"dp [ i ] [ j ] = 1 + Math . min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { System . out . println ( - 1 ) ; } else { System . out . println ( ans ) ; } } }"}
{"text":"A memoization based program to find maximum treasure that can be collected .","code":"import java . util . * ; class GFG { static int MAX = 1001 ; static int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;"}
{"text":"k is current index and col is previous color .","code":"static int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) {"}
{"text":"if ( k == n ) base case","code":"return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; int sum = 0 ;"}
{"text":"check if color of this city is equal to prev visited city","code":"if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ;"}
{"text":"return max of both options","code":"return dp [ k ] [ col ] = sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A = - 5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = color . length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ; } }"}
{"text":"A DP based Java program to print the nth tetranacci number","code":"class GFG {"}
{"text":"Function to print the N - th tetranacci number","code":"static void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ;"}
{"text":"base cases","code":"dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . out . print ( dp [ n ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; printTetra ( n ) ; } }"}
{"text":"Java program to find maximum sum in a circular array such that no elements are adjacent in the sum .","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the sum from 0 th position to ( n - 2 ) th position","code":"static int maxSum1 ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"copy the element of original array to dp [ ]","code":"dp [ i ] = arr [ i ] ;"}
{"text":"find the maximum element in the array","code":"if ( maxi < arr [ i ] ) maxi = arr [ i ] ; }"}
{"text":"start from 2 nd to n - 1 th pos","code":"for ( int i = 2 ; i < n - 1 ; i ++ ) {"}
{"text":"traverse for all pairs bottom - up approach","code":"for ( int j = 0 ; j < i - 1 ; j ++ ) {"}
{"text":"dp - condition","code":"if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ;"}
{"text":"find maximum sum","code":"if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } }"}
{"text":"return the maximum","code":"return maxi ; }"}
{"text":"Function to find the maximum sum from 1 st position to n - 1 - th position","code":"static int maxSum2 ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; }"}
{"text":"Traverse from third to n - th pos","code":"for ( int i = 3 ; i < n ; i ++ ) {"}
{"text":"bootom - up approach","code":"for ( int j = 1 ; j < i - 1 ; j ++ ) {"}
{"text":"dp condition","code":"if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ;"}
{"text":"find max sum","code":"if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } }"}
{"text":"return max","code":"return maxi ; } static int findMaxSum ( int arr [ ] , int n ) { int t = Math . max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }"}
{"text":"Java code for Dynamic Programming based solution that uses table P [ ] [ ] to calculate the Permutation Coefficient","code":"import java . io . * ; import java . math . * ; class GFG {"}
{"text":"Returns value of Permutation Coefficient P ( n , k )","code":"static int permutationCoeff ( int n , int k ) { int P [ ] [ ] = new int [ n + 2 ] [ k + 2 ] ;"}
{"text":"Calculate value of Permutation Coefficient in bottom up manner","code":"for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) {"}
{"text":"Base Cases","code":"if ( j == 0 ) P [ i ] [ j ] = 1 ;"}
{"text":"Calculate value using previosly stored values","code":"else P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) ;"}
{"text":"This step is important as P ( i , j ) = 0 for j > i","code":"P [ i ] [ j + 1 ] = 0 ; } } return P [ n ] [ k ] ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 10 , k = 2 ; System . out . println ( \" Value \u2581 of \u2581 P ( \u2581 \" + n + \" , \" + k + \" ) \" + \" \u2581 is \u2581 \" + permutationCoeff ( n , k ) ) ; } }"}
{"text":"A O ( n ) solution that uses table fact [ ] to calculate the Permutation Coefficient","code":"import java . io . * ; public class GFG {"}
{"text":"Returns value of Permutation Coefficient P ( n , k )","code":"static int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ;"}
{"text":"base case","code":"fact [ 0 ] = 1 ;"}
{"text":"Calculate value factorials up to n","code":"for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ;"}
{"text":"P ( n , k ) = n ! \/ ( n - k ) !","code":"return fact [ n ] \/ fact [ n - k ] ; }"}
{"text":"Driver Code","code":"static public void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( \" Value \u2581 of \" + \" \u2581 P ( \u2581 \" + n + \" , \u2581 \" + k + \" ) \u2581 is \u2581 \" + permutationCoeff ( n , k ) ) ; } }"}
{"text":"A recursive solution for subset sum problem","code":"class GFG {"}
{"text":"Returns true if there is a subset of set [ ] with sum equal to given sum","code":"static boolean isSubsetSum ( int set [ ] , int n , int sum ) {"}
{"text":"Base Cases","code":"if ( sum == 0 ) return true ; if ( n == 0 ) return false ;"}
{"text":"If last element is greater than sum , then ignore it","code":"if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ;"}
{"text":"else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element","code":"return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }"}
{"text":"Java program to find bitwise XOR between binary string A and all the cyclic permutations of binary string B","code":"public class GFG {"}
{"text":"Implementation of Z - algorithm for linear time pattern searching","code":"static void compute_z ( String s , int z [ ] ) { int l = 0 , r = 0 ; int n = s . length ( ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s . charAt ( r - l ) == s . charAt ( r ) ) r ++ ; z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s . charAt ( r - l ) == s . charAt ( r ) ) r ++ ; z [ i ] = r - l ; r -- ; } } } }"}
{"text":"Function to get the count of the cyclic permutations of b that given 0 when XORed with a","code":"static int countPermutation ( String a , String b ) {"}
{"text":"concatenate b with b","code":"b = b + b ;"}
{"text":"new b now contains all the cyclic permutations of old b as it 's sub-strings","code":"b = b . substring ( 0 , b . length ( ) - 1 ) ;"}
{"text":"concatenate pattern with text","code":"int ans = 0 ; String s = a + \" $ \" + b ; int n = s . length ( ) ;"}
{"text":"Fill z array used in Z algorithm","code":"int z [ ] = new int [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) {"}
{"text":"pattern occurs at index i since z value of i equals pattern length","code":"if ( z [ i ] == a . length ( ) ) ans ++ ; } return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String a = \"101\" ; String b = \"101\" ; System . out . println ( countPermutation ( a , b ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find lexicographically smallest subsequence of size K","code":"static void smallestSubsequence ( char [ ] S , int K ) {"}
{"text":"Length of String","code":"int N = S . length ;"}
{"text":"Stores the minimum subsequence","code":"Stack < Character > answer = new Stack < > ( ) ;"}
{"text":"Traverse the String S","code":"for ( int i = 0 ; i < N ; ++ i ) {"}
{"text":"If the stack is empty","code":"if ( answer . isEmpty ( ) ) { answer . add ( S [ i ] ) ; } else {"}
{"text":"Iterate till the current character is less than the the character at the top of stack","code":"while ( ( ! answer . isEmpty ( ) ) && ( S [ i ] < answer . peek ( ) )"}
{"text":"Check if there are enough characters remaining to obtain length K","code":"&& ( answer . size ( ) - 1 + N - i >= K ) ) { answer . pop ( ) ; }"}
{"text":"If stack size is < K","code":"if ( answer . isEmpty ( ) || answer . size ( ) < K ) {"}
{"text":"Push the current character into it","code":"answer . add ( S [ i ] ) ; } } }"}
{"text":"Stores the resultant String","code":"String ret = \" \" ;"}
{"text":"Iterate until stack is empty","code":"while ( ! answer . isEmpty ( ) ) { ret += ( answer . peek ( ) ) ; answer . pop ( ) ; }"}
{"text":"Reverse the String","code":"ret = reverse ( ret ) ;"}
{"text":"Print the String","code":"System . out . print ( ret ) ; } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" aabdaabc \" ; int K = 3 ; smallestSubsequence ( S . toCharArray ( ) , K ) ; } }"}
{"text":"Java program to check if the given string is right to left diagonal or not","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if the given string is right to left diagonal or not","code":"public static boolean is_rtol ( String s ) { int tmp = ( int ) ( Math . sqrt ( s . length ( ) ) ) - 1 ; char first = s . charAt ( tmp ) ;"}
{"text":"Iterate over string","code":"for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) {"}
{"text":"If character is not same as the first character then return false","code":"if ( s . charAt ( pos ) != first ) { return false ; } } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given String str","code":"String str = \" abcxabxcaxbcxabc \" ;"}
{"text":"Function call","code":"if ( is_rtol ( str ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }"}
{"text":"Java program to check if a given string can be split into substrings of size K having an equal sum of ASCII values .","code":"class GFG {"}
{"text":"Function for checking string","code":"static boolean check ( String str , int K ) {"}
{"text":"Check if the string can be split into substrings of K length only","code":"if ( str . length ( ) % K == 0 ) { int sum = 0 , i ;"}
{"text":"Compute the sum of first substring of length K","code":"for ( i = 0 ; i < K ; i ++ ) { sum += str . charAt ( i ) ; }"}
{"text":"Compute the sum of remaining substrings","code":"for ( int j = i ; j < str . length ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str . charAt ( p ) ;"}
{"text":"Check if sum is equal to that of the first substring","code":"if ( s_comp != sum )"}
{"text":"Since all sums are not equal , return false","code":"return false ; }"}
{"text":"All sums are equal , Return true","code":"return true ; }"}
{"text":"All substrings cannot be of size K","code":"return false ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int K = 3 ; String str = \" abdcbbdba \" ; if ( check ( str , K ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to maximize the sum of the count of zeros and ones in the left and right substring","code":"static int maxSum ( String str ) { int maximumSum = 0 ;"}
{"text":"To store the total ones","code":"int totalOnes = 0 ;"}
{"text":"Count the total numbers of ones in string str","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '1' ) { totalOnes ++ ; } }"}
{"text":"To store the count of zeros and ones while traversing string","code":"int zero = 0 , ones = 0 ;"}
{"text":"Iterate the given string and update the maximum sum","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' ) { zero ++ ; } else { ones ++ ; }"}
{"text":"Update the maximum Sum","code":"maximumSum = Math . max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given binary string","code":"String str = \"011101\" ;"}
{"text":"Function call","code":"System . out . println ( maxSum ( str ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the length of the longest substring such that no three consecutive characters are same","code":"static int maxLenSubStr ( String s ) {"}
{"text":"If the length of the given string is less than 3","code":"if ( s . length ( ) < 3 ) return s . length ( ) ;"}
{"text":"Initialize temporary and final ans to 2 as this is the minimum length of substring when length of the given string is greater than 2","code":"int temp = 2 ; int ans = 2 ;"}
{"text":"Traverse the string from the third character to the last","code":"for ( int i = 2 ; i < s . length ( ) ; i ++ ) {"}
{"text":"If no three consecutive characters are same then increment temporary count","code":"if ( s . charAt ( i ) != s . charAt ( i - 1 ) || s . charAt ( i ) != s . charAt ( i - 2 ) ) temp ++ ;"}
{"text":"Else update the final ans and reset the temporary count","code":"else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" baaabbabbb \" ; System . out . println ( maxLenSubStr ( s ) ) ; } }"}
{"text":"Java program to count number of ways of removing a substring from a string such that all remaining characters are equal","code":"import java . util . * ; class solution {"}
{"text":"Function to return the number of ways of removing a sub - string from s such that all the remaining characters are same","code":"static int no_of_ways ( String s ) { int n = s . length ( ) ;"}
{"text":"To store the count of prefix and suffix","code":"int count_left = 0 , count_right = 0 ;"}
{"text":"Loop to count prefix","code":"for ( int i = 0 ; i < n ; ++ i ) { if ( s . charAt ( i ) == s . charAt ( 0 ) ) { ++ count_left ; } else break ; }"}
{"text":"Loop to count suffix","code":"for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == s . charAt ( n - 1 ) ) { ++ count_right ; } else break ; }"}
{"text":"First and last characters of the string are same","code":"if ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ;"}
{"text":"Otherwise","code":"else return ( count_left + count_right + 1 ) ; }"}
{"text":"Driver function","code":"public static void main ( String args [ ] ) { String s = \" geeksforgeeks \" ; System . out . println ( no_of_ways ( s ) ) ; } }"}
{"text":"Java program to find substring with","code":"import java . io . * ; class GFG {"}
{"text":"Function to create prefix array","code":"static void preCompute ( int n , String s , int pref [ ] ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s . charAt ( i - 1 ) == s . charAt ( i ) ) pref [ i ] ++ ; } }"}
{"text":"Function to return the result of the query","code":"static int query ( int pref [ ] , int l , int r ) { return pref [ r ] - pref [ l ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \" ggggggg \" ; int n = s . length ( ) ; int pref [ ] = new int [ n ] ; preCompute ( n , s , pref ) ;"}
{"text":"Query 1","code":"int l = 1 ; int r = 2 ; System . out . println ( query ( pref , l , r ) ) ;"}
{"text":"Query 2","code":"l = 1 ; r = 5 ; System . out . println ( query ( pref , l , r ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the final direction","code":"static String findDirection ( String s ) { int count = 0 ; String d = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( 0 ) == 'NEW_LINE') return null ; if ( s . charAt ( i ) == ' L ' ) count -- ; else { if ( s . charAt ( i ) == ' R ' ) count ++ ; } }"}
{"text":"if count is positive that implies resultant is clockwise direction","code":"if ( count > 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == 1 ) d = \" E \" ; else if ( count % 4 == 2 ) d = \" S \" ; else if ( count % 4 == 3 ) d = \" W \" ; }"}
{"text":"if count is negative that implies resultant is anti - clockwise direction","code":"if ( count < 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == - 1 ) d = \" W \" ; else if ( count % 4 == - 2 ) d = \" S \" ; else if ( count % 4 == - 3 ) d = \" E \" ; } return d ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" LLRLRRL \" ; System . out . println ( findDirection ( s ) ) ; s = \" LL \" ; System . out . println ( findDirection ( s ) ) ; } }"}
{"text":"Java program to check if lowercase and uppercase characters are in same order","code":"public class GFG {"}
{"text":"Function to check if both the case follow the same order","code":"static boolean isCheck ( String str ) { int len = str . length ( ) ; String lowerStr = \" \" , upperStr = \" \" ; char [ ] str1 = str . toCharArray ( ) ;"}
{"text":"Traverse the string","code":"for ( int i = 0 ; i < len ; i ++ ) {"}
{"text":"Store both lowercase and uppercase in two different strings","code":"if ( ( int ) ( str1 [ i ] ) >= 65 && ( int ) str1 [ i ] <= 91 ) upperStr = upperStr + str1 [ i ] ; else lowerStr = lowerStr + str1 [ i ] ; }"}
{"text":"transform lowerStr1 to upper","code":"String transformStr = lowerStr . toUpperCase ( ) ; return ( transformStr . equals ( upperStr ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeGkEEsKS \" ; if ( isCheck ( str ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to move every character K times ahead in a given string","code":"class GFG {"}
{"text":"Function to move string character","code":"static void encode ( String s , int k ) {"}
{"text":"changed string","code":"String newS = \" \" ;"}
{"text":"iterate for every characters","code":"for ( int i = 0 ; i < s . length ( ) ; ++ i ) {"}
{"text":"ASCII value","code":"int val = s . charAt ( i ) ;"}
{"text":"store the duplicate","code":"int dup = k ;"}
{"text":"if k - th ahead character exceed ' z '","code":"if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += ( char ) ( 96 + k ) ; } else { newS += ( char ) ( val + k ) ; } k = dup ; }"}
{"text":"print the new string","code":"System . out . println ( newS ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" abc \" ; int k = 28 ;"}
{"text":"function call","code":"encode ( str , k ) ; } }"}
{"text":"Java program to remove all Vowels in between two consonants from the string","code":"import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to check if the character x is a vowel or not","code":"static boolean isVowel ( char x ) { if ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) return true ; else return false ; }"}
{"text":"Returns the updated string formed after removing all the Sandwiched Vowels from the given string","code":"static String updateSandwichedVowels ( String a ) { int n = a . length ( ) ;"}
{"text":"string to store the Updated String after removing the Sandwiched Vowels","code":"String updatedString = \" \" ;"}
{"text":"traverse the string from left to right","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"if the current character is the first or the last character of the string then , this needs to be appended to the updatedString , since the corner alphabet irrespective of it being a vowel or a consonant , is never ' Sandwiched '","code":"if ( i == 0 i == n - 1 ) { updatedString += a . charAt ( i ) ; continue ; }"}
{"text":"Check if the current character of the string is a vowel and both the previous and the next characters are consonants , if so then this is a sandwiched vowel , thus is ignored and not appended to the updated string","code":"if ( isVowel ( a . charAt ( i ) ) == true && isVowel ( a . charAt ( i - 1 ) ) == false && isVowel ( a . charAt ( i + 1 ) ) == false ) { continue ; }"}
{"text":"if this character is not a sandwiched Vowel append it to the updated String","code":"updatedString += a . charAt ( i ) ; } return updatedString ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ;"}
{"text":"Remove all the Sandwitched Vowels","code":"String updatedString = updateSandwichedVowels ( str ) ; System . out . print ( updatedString ) ; } }"}
{"text":"Java program to print paths with maximum element in the path greater than K","code":"import java . util . * ; class GFG {"}
{"text":"A Binary Tree node","code":"static class Node { int data ; Node left , right ; } ; static int ans ;"}
{"text":"A utility function to create a new node","code":"static Node newNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; newNode . left = newNode . right = null ; return ( newNode ) ; }"}
{"text":"A recursive function to print the paths whose maximum element is greater than or equal to K .","code":"static void findPathUtil ( Node root , int k , Vector < Integer > path , int flag ) { if ( root == null ) return ;"}
{"text":"If the current node value is greater than or equal to k , then all the subtrees following that node will get printed , flag = 1 indicates to print the required path","code":"if ( root . data >= k ) flag = 1 ;"}
{"text":"If the leaf node is encountered , then the path is printed if the size of the path vector is greater than 0","code":"if ( root . left == null && root . right == null ) { if ( flag == 1 ) { ans = 1 ; System . out . print ( \" ( \" ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { System . out . print ( path . get ( i ) + \" , \u2581 \" ) ; } System . out . print ( root . data + \" ) , \u2581 \" ) ; } return ; }"}
{"text":"Append the node to the path vector","code":"path . add ( root . data ) ;"}
{"text":"Recur left and right subtrees","code":"findPathUtil ( root . left , k , path , flag ) ; findPathUtil ( root . right , k , path , flag ) ;"}
{"text":"Backtracking to return the vector and print the path if the flag is 1","code":"path . remove ( path . size ( ) - 1 ) ; }"}
{"text":"Function to initialize the variables and call the utility function to print the paths with maximum values greater than or equal to K","code":"static void findPath ( Node root , int k ) {"}
{"text":"Initialize flag","code":"int flag = 0 ;"}
{"text":"ans is used to check empty condition","code":"ans = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ;"}
{"text":"Call function that print path","code":"findPathUtil ( root , k , v , flag ) ;"}
{"text":"If the path doesn 't exist","code":"if ( ans == 0 ) System . out . print ( \" - 1\" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int K = 25 ;"}
{"text":"Constructing the following tree : 10 \/ \\ 5 8 \/ \\ \/ \\ 29 2 1 98 \/ \\ 20 50","code":"Node root = newNode ( 10 ) ; root . left = newNode ( 5 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 29 ) ; root . left . right = newNode ( 2 ) ; root . right . right = newNode ( 98 ) ; root . right . left = newNode ( 1 ) ; root . right . right . right = newNode ( 50 ) ; root . left . left . left = newNode ( 20 ) ; findPath ( root , K ) ; } }"}
{"text":"Java program to find N - th tridecagonal number","code":"class GFG {"}
{"text":"Function to find N - th tridecagonal number","code":"static int Tridecagonal_num ( int n ) {"}
{"text":"Formula to calculate nth tridecagonal number","code":"return ( 11 * n * n - 9 * n ) \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Tridecagonal_num ( n ) + \"NEW_LINE\"); n = 10 ; System . out . print ( Tridecagonal_num ( n ) + \"NEW_LINE\"); } }"}
{"text":"Java program to checks if a binary tree is max heap or not","code":"import java . util . * ; class GFG {"}
{"text":"Tree node structure","code":"static class Node { int data ; Node left ; Node right ; } ;"}
{"text":"To add a new node","code":"static Node newNode ( int k ) { Node node = new Node ( ) ; node . data = k ; node . right = node . left = null ; return node ; } static boolean isHeap ( Node root ) { Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; boolean nullish = false ; while ( ! q . isEmpty ( ) ) { Node temp = q . peek ( ) ; q . remove ( ) ; if ( temp . left != null ) { if ( nullish temp . left . data >= temp . data ) { return false ; } q . add ( temp . left ) ; } else { nullish = true ; } if ( temp . right != null ) { if ( nullish temp . right . data >= temp . data ) { return false ; } q . add ( temp . right ) ; } else { nullish = true ; } } return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Node root = null ; root = newNode ( 10 ) ; root . left = newNode ( 9 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 7 ) ; root . left . right = newNode ( 6 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 4 ) ; root . left . left . left = newNode ( 3 ) ; root . left . left . right = newNode ( 2 ) ; root . left . right . left = newNode ( 1 ) ;"}
{"text":"Function call","code":"if ( isHeap ( root ) ) System . out . print ( \"Given binary tree is a HeapNEW_LINE\"); else System . out . print ( \"Given binary tree is not a HeapNEW_LINE\"); } }"}
{"text":"Java program to find total possible numbers with n digits and weight w","code":"class GFG {"}
{"text":"Function to find total possible numbers with n digits and weight w","code":"static int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ;"}
{"text":"When Weight of an integer is Positive","code":"if ( w >= 0 && w <= 8 ) {"}
{"text":"Subtract the weight from 9","code":"x = 9 - w ; }"}
{"text":"When weight of an integer is negative","code":"else if ( w >= - 9 && w <= - 1 ) {"}
{"text":"add the weight to 10 to make it positive","code":"x = 10 + w ; } sum = ( int ) Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n , w ;"}
{"text":"number of digits in an integer and w as weight","code":"n = 3 ; w = 4 ;"}
{"text":"print the total possible numbers with n digits and weight w","code":"System . out . println ( findNumbers ( n , w ) ) ; } }"}
{"text":"Java program to find the maximum height of Pyramidal Arrangement of array values","code":"import java . io . * ; class GFG { static int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) {"}
{"text":"Just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) \/ 2 elements in the array","code":"int y = ( i * ( i + 1 ) ) \/ 2 ;"}
{"text":"updating the result value each time","code":"if ( y < n ) result = i ;"}
{"text":"otherwise we have exceeded n value","code":"else break ; } return result ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 40 , 100 , 20 , 30 } ; int n = arr . length ; System . out . println ( MaximumHeight ( arr , n ) ) ; } }"}
{"text":"Java program to find k - th element in the Odd - Even sequence .","code":"import java . util . * ; class GFG { static int findK ( int n , int k ) { ArrayList < Integer > a = new ArrayList < Integer > ( n ) ;"}
{"text":"insert all the odd numbers from 1 to n .","code":"for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . add ( i ) ;"}
{"text":"insert all the even numbers from 1 to n .","code":"for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . add ( i ) ; return ( a . get ( k - 1 ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 , k = 3 ; System . out . println ( findK ( n , k ) ) ; } }"}
{"text":"Java program to find factorial of given number","code":"import java . io . * ; class GFG { static int factorial ( int n ) {"}
{"text":"single line to find factorial","code":"return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( \" Factorial \u2581 of \u2581 \" + num + \" \u2581 is \u2581 \" + factorial ( num ) ) ; } }"}
{"text":"Iterative Pell Number Series in Java","code":"class PellNumber {"}
{"text":"calculate nth pell number","code":"public static int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }"}
{"text":"driver function","code":"public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( pell ( n ) ) ; } }"}
{"text":"A simple Java program to check if n - th Fibonacci number is multiple of 10.","code":"class Fibonacci {"}
{"text":"Returns true if n - th Fibonacci number is multiple of 10.","code":"static boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }"}
{"text":"main function","code":"public static void main ( String [ ] args ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to find politeness of a number","code":"public class Politeness {"}
{"text":"A function to count all odd prime factors of a given number n","code":"static int countOddPrimeFactors ( int n ) { int result = 1 ;"}
{"text":"Eliminate all even prime factor of number of n","code":"while ( n % 2 == 0 ) n \/= 2 ;"}
{"text":"n must be odd at this point , so iterate for only odd numbers till sqrt ( n )","code":"for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ;"}
{"text":"if i divides n , then start counting of Odd divisors","code":"while ( n % i == 0 ) { n \/= i ; ++ divCount ; } result *= divCount + 1 ; }"}
{"text":"If n odd prime still remains then count it","code":"if ( n > 2 ) result *= 2 ; return result ; } static int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 90 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; n = 15 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; } }"}
{"text":"Java program to find the nearest prime to n .","code":"import java . util . * ; class GFG { static int MAX = 1000000 ;"}
{"text":"array to store all primes less than 10 ^ 6","code":"static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;"}
{"text":"Utility function of Sieve of Sundaram","code":"static void Sieve ( ) { int n = MAX ;"}
{"text":"In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x","code":"int nNew = ( int ) Math . sqrt ( n ) ;"}
{"text":"This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j","code":"int [ ] marked = new int [ n \/ 2 + 500 ] ;"}
{"text":"eliminate indexes which does not produce primes","code":"for ( int i = 1 ; i <= ( nNew - 1 ) \/ 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n \/ 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ;"}
{"text":"Since 2 is a prime number","code":"primes . add ( 2 ) ;"}
{"text":"Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for ( int i = 1 ; i <= n \/ 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . add ( 2 * i + 1 ) ; }"}
{"text":"modified binary search to find nearest prime less than N","code":"static int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) \/ 2 ;"}
{"text":"base condition is , if we are reaching at left corner or right corner of primes [ ] array then return that corner element because before or after that we don 't have any prime number in  primes array","code":"if ( mid == 0 || mid == primes . size ( ) - 1 ) return primes . get ( mid ) ;"}
{"text":"now if n is itself a prime so it will be present in primes array and here we have to find nearest prime less than n so we will return primes [ mid - 1 ]","code":"if ( primes . get ( mid ) == n ) return primes . get ( mid - 1 ) ;"}
{"text":"now if primes [ mid ] < n and primes [ mid + 1 ] > n that mean we reached at nearest prime","code":"if ( primes . get ( mid ) < n && primes . get ( mid + 1 ) > n ) return primes . get ( mid ) ; if ( n < primes . get ( mid ) ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Sieve ( ) ; int n = 17 ; System . out . println ( binarySearch ( 0 , primes . size ( ) - 1 , n ) ) ; } }"}
{"text":"Java program to find factorial of given number","code":"class Test {"}
{"text":"method to find factorial of given number","code":"static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( \" Factorial \u2581 of \u2581 \" + num + \" \u2581 is \u2581 \" + factorial ( 5 ) ) ; } }"}
{"text":"Java program to unset the rightmost set bit","code":"import java . util . * ; class GFG {"}
{"text":"Unsets the rightmost set bit of n and returns the result","code":"static int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 12 ; System . out . print ( \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \u2581 \" ) ; System . out . print ( \" rightmost \u2581 set \u2581 bit : \u2581 \" + FlipBits ( N ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . HashSet ; class GFG {"}
{"text":"function to count maximum XOR value for a triplet","code":"static void Maximum_xor_Triplet ( int n , int a [ ] ) {"}
{"text":"set is used to avoid repetitions","code":"HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) {"}
{"text":"store all possible unique XOR value of pairs","code":"s . add ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; for ( Integer i : s ) { for ( int j = 0 ; j < n ; j ++ ) {"}
{"text":"store maximum value","code":"ans = Math . max ( ans , i ^ a [ j ] ) ; } } System . out . println ( ans ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 8 , 15 } ; int n = a . length ; Maximum_xor_Triplet ( n , a ) ; } }"}
{"text":"A sorting based Java program to find missing elements from an array","code":"import java . util . Arrays ; public class PrintMissing {"}
{"text":"Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]","code":"static void printMissing ( int ar [ ] , int low , int high ) { Arrays . sort ( ar ) ;"}
{"text":"Do binary search for ' low ' in sorted array and find index of first element which either equal to or greater than low .","code":"int index = ceilindex ( ar , low , 0 , ar . length - 1 ) ; int x = low ;"}
{"text":"Start from the found index and linearly search every range element x after this index in arr [ ]","code":"while ( index < ar . length && x <= high ) {"}
{"text":"If x doesn 't math with current element  print it","code":"if ( ar [ index ] != x ) { System . out . print ( x + \" \u2581 \" ) ; }"}
{"text":"If x matches , move to next element in arr [ ]","code":"else index ++ ;"}
{"text":"Move to next element in range [ low , high ]","code":"x ++ ; }"}
{"text":"Print range elements thar are greater than the last element of sorted array .","code":"while ( x <= high ) { System . out . print ( x + \" \u2581 \" ) ; x ++ ; } }"}
{"text":"Utility function to find ceil index of given element","code":"static int ceilindex ( int ar [ ] , int val , int low , int high ) { if ( val < ar [ 0 ] ) return 0 ; if ( val > ar [ ar . length - 1 ] ) return ar . length ; int mid = ( low + high ) \/ 2 ; if ( ar [ mid ] == val ) return mid ; if ( ar [ mid ] < val ) { if ( mid + 1 < high && ar [ mid + 1 ] >= val ) return mid + 1 ; return ceilindex ( ar , val , mid + 1 , high ) ; } else { if ( mid - 1 >= low && ar [ mid - 1 ] < val ) return mid ; return ceilindex ( ar , val , low , mid - 1 ) ; } }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }"}
{"text":"An array based Java program to find missing elements from an array","code":"import java . util . Arrays ; public class Print {"}
{"text":"Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]","code":"static void printMissing ( int arr [ ] , int low , int high ) {"}
{"text":"Create boolean array of size high - low + 1 , each index i representing wether ( i + low ) th element found or not .","code":"boolean [ ] points_of_range = new boolean [ high - low + 1 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) {"}
{"text":"if ith element of arr is in range low to high then mark corresponding index as true in array","code":"if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; }"}
{"text":"Traverse through the range and print all elements whose value is false","code":"for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) System . out . print ( ( low + x ) + \" \u2581 \" ) ; } }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }"}
{"text":"A hashing based Java program to find missing elements from an array","code":"import java . util . Arrays ; import java . util . HashSet ; public class Print {"}
{"text":"Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]","code":"static void printMissing ( int ar [ ] , int low , int high ) { HashSet < Integer > hs = new HashSet < > ( ) ;"}
{"text":"Insert all elements of arr [ ] in set","code":"for ( int i = 0 ; i < ar . length ; i ++ ) hs . add ( ar [ i ] ) ;"}
{"text":"Traverse throught the range an print all missing elements","code":"for ( int i = low ; i <= high ; i ++ ) { if ( ! hs . contains ( i ) ) { System . out . print ( i + \" \u2581 \" ) ; } } }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }"}
{"text":"Java program to find the k - th missing element in a given sequence","code":"import java . util . * ; class GFG {"}
{"text":"Returns k - th missing element . It returns - 1 if no k is more than number of missing elements .","code":"static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) {"}
{"text":"Insert all elements of givens sequence b [ ] .","code":"LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ;"}
{"text":"Traverse through increasing sequence and keep track of count of missing numbers .","code":"int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int b [ ] = { 4 , 10 , 6 , 8 , 12 } ; int n1 = a . length ; int n2 = b . length ; int k = 3 ; System . out . println ( find ( a , b , k , n1 , n2 ) ) ; } }"}
{"text":"Java code for above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum number of string required to generate the original string","code":"static void findString ( String S , int N ) {"}
{"text":"Stores the frequency of each character of string S","code":"int [ ] amounts = new int [ 26 ] ;"}
{"text":"Iterate over the range [ 0 , 25 ]","code":"for ( int i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; }"}
{"text":"Stores the frequency of each character of string S","code":"for ( int i = 0 ; i < S . length ( ) ; i ++ ) { amounts [ ( int ) ( S . charAt ( i ) - 97 ) ] ++ ; } int count = 0 ;"}
{"text":"Count unique characters in S","code":"for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; }"}
{"text":"If unique characters is greater then N , then return - 1","code":"if ( count > N ) { System . out . print ( \" - 1\" ) ; }"}
{"text":"Otherwise","code":"else { String ans = \" \" ; int high = 100001 ; int low = 0 ; int mid , total ;"}
{"text":"Perform Binary Search","code":"while ( ( high - low ) > 1 ) { total = 0 ;"}
{"text":"Find the value of mid","code":"mid = ( high + low ) \/ 2 ;"}
{"text":"Iterate over the range [ 0 , 26 ]","code":"for ( int i = 0 ; i < 26 ; i ++ ) {"}
{"text":"If the amount [ i ] is greater than 0","code":"if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) \/ mid + 1 ; } }"}
{"text":"Update the ranges","code":"if ( total <= N ) { high = mid ; } else { low = mid ; } } System . out . print ( high + \" \u2581 \" ) ; total = 0 ;"}
{"text":"Find the resultant string","code":"for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) \/ high + 1 ; for ( int j = 0 ; j < ( ( amounts [ i ] - 1 ) \/ high + 1 ) ; j ++ ) {"}
{"text":"Generate the subsequence","code":"ans += ( char ) ( i + 97 ) ; } } }"}
{"text":"If the length of resultant string is less than N than add a character ' a '","code":"for ( int i = total ; i < N ; i ++ ) { ans += ' a ' ; } String reverse = \" \" ; int Len = ans . length ( ) - 1 ; while ( Len >= 0 ) { reverse = reverse + ans . charAt ( Len ) ; Len -- ; }"}
{"text":"Print the string","code":"System . out . print ( reverse ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" toffee \" ; int K = 4 ; findString ( S , K ) ; } }"}
{"text":"Java program to find first repeating element in arr [ ]","code":"import java . util . * ; class Main {"}
{"text":"This function prints the first repeating element in arr [ ]","code":"static void printFirstRepeating ( int arr [ ] ) {"}
{"text":"Initialize index of first repeating element","code":"int min = - 1 ;"}
{"text":"Creates an empty hashset","code":"HashSet < Integer > set = new HashSet < > ( ) ;"}
{"text":"Traverse the input array from right to left","code":"for ( int i = arr . length - 1 ; i >= 0 ; i -- ) {"}
{"text":"If element is already in hash set , update min","code":"if ( set . contains ( arr [ i ] ) ) min = i ;"}
{"text":"Else add element to hash set","code":"else set . add ( arr [ i ] ) ; }"}
{"text":"Print the result","code":"if ( min != - 1 ) System . out . println ( \" The \u2581 first \u2581 repeating \u2581 element \u2581 is \u2581 \" + arr [ min ] ) ; else System . out . println ( \" There \u2581 are \u2581 no \u2581 repeating \u2581 elements \" ) ; }"}
{"text":"Driver method to test above method","code":"public static void main ( String [ ] args ) throws java . lang . Exception { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; printFirstRepeating ( arr ) ; } }"}
{"text":"Java program to find first repeating element in arr [ ]","code":"public class GFG {"}
{"text":"This function prints the first repeating element in arr [ ]","code":"static void printFirstRepeating ( int [ ] arr , int n ) {"}
{"text":"This will set k = 1 , if any repeating element found","code":"int k = 0 ;"}
{"text":"max = maximum from ( all elements & n )","code":"int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ;"}
{"text":"Array a is for storing 1 st time occurence of element initialized by 0","code":"int [ ] a = new int [ max + 1 ] ;"}
{"text":"Store 1 in array b if element is duplicate initialized by 0","code":"int [ ] b = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Duplicate element found","code":"if ( a [ arr [ i ] ] != 0 ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else"}
{"text":"storing 1 st occurence of arr [ i ]","code":"a [ arr [ i ] ] = i ; } if ( k == 0 ) System . out . println ( \" No \u2581 repeating \u2581 element \u2581 found \" ) ; else { int min = max + 1 ;"}
{"text":"trace array a & find repeating element with min index","code":"for ( int i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] != 0 && min > a [ i ] && b [ i ] != 0 ) min = a [ i ] ; System . out . print ( arr [ min ] ) ; } System . out . println ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = arr . length ; printFirstRepeating ( arr , n ) ; } }"}
{"text":"Java program to print k - th distinct element in a given array","code":"class GFG {"}
{"text":"Returns k - th distinct element in arr .","code":"static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Check if current element is present somewhere else .","code":"int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ;"}
{"text":"If element is unique","code":"if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = ar . length ; int k = 2 ; System . out . print ( printKDistinct ( ar , n , k ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . Vector ; class GFG {"}
{"text":"Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together","code":"static void countSubarrays ( int [ ] A ) {"}
{"text":"Stores the count","code":"int res = 0 ;"}
{"text":"Initialize cur with first element","code":"int curr = A [ 0 ] ; int [ ] cnt = new int [ A . length ] ; cnt [ 0 ] = 1 ; for ( int c = 1 ; c < A . length ; c ++ ) {"}
{"text":"If the next element is same as the current element","code":"if ( A == curr )"}
{"text":"Increment count","code":"cnt ++ ; else"}
{"text":"Update curr","code":"curr = A ; cnt = 1 ; }"}
{"text":"Iterate over the array count","code":"for ( int i = 1 ; i < cnt . length ; i ++ ) {"}
{"text":"Consider the minimum","code":"res += Math . min ( cnt [ i - 1 ] , cnt [ i ] ) ; } System . out . println ( res - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given arr [ ]","code":"int [ ] A = { 1 , 1 , 0 , 0 , 1 , 0 } ;"}
{"text":"Function Call","code":"countSubarrays ( A ) ; } }"}
{"text":"Java Program for the above approach","code":"import java . util . * ; class GfG {"}
{"text":"Tree node","code":"static class Node { int val ; Node left , right ; }"}
{"text":"Function to return new tree node","code":"static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . val = data ; temp . left = null ; temp . right = null ; return temp ; }"}
{"text":"Function to check if the tree is even - odd tree","code":"public static boolean isEvenOddBinaryTree ( Node root ) { if ( root == null ) return true ;"}
{"text":"Stores nodes of each level","code":"Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ;"}
{"text":"Store the current level of the binary tree","code":"int level = 0 ;"}
{"text":"Traverse until the queue is empty","code":"while ( ! q . isEmpty ( ) ) {"}
{"text":"Stores the number of nodes present in the current level","code":"int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node node = q . poll ( ) ;"}
{"text":"Check if the level is even or odd","code":"if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; }"}
{"text":"Add the nodes of the next level into the queue","code":"if ( node . left != null ) { q . add ( node . left ) ; } if ( node . right != null ) { q . add ( node . right ) ; } }"}
{"text":"Increment the level count","code":"level ++ ; } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Construct a Binary Tree","code":"Node root = null ; root = newNode ( 2 ) ; root . left = newNode ( 3 ) ; root . right = newNode ( 9 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 10 ) ; root . right . right = newNode ( 6 ) ;"}
{"text":"Check if the binary tree is even - odd tree or not","code":"if ( isEvenOddBinaryTree ( root ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java program to implement the above approach","code":"class GFG { static int findMaxLen ( int a [ ] , int n ) {"}
{"text":"Stores the frequency of array elements","code":"int freq [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } int maxFreqElement = Integer . MIN_VALUE ; int maxFreqCount = 1 ; for ( int i = 1 ; i <= n ; ++ i ) {"}
{"text":"Find the highest frequency in the array","code":"if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; }"}
{"text":"Increase count of max frequent element","code":"else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } int ans ;"}
{"text":"If no repetition is present","code":"if ( maxFreqElement == 1 ) ans = 0 ; else {"}
{"text":"Find the maximum distance","code":"ans = ( ( n - maxFreqCount ) \/ ( maxFreqElement - 1 ) ) ; }"}
{"text":"Return the max distance","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 } ; int n = a . length ; System . out . print ( findMaxLen ( a , n ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to obtain the middle index of the range","code":"static int getMid ( int s , int e ) { return s + ( e - s ) \/ 2 ; }"}
{"text":"Recursive function to get the sum of values in the given range from the array . The following are parameters for this function . st . Pointer to segment tree node . Index of current node in the segment tree ss & se . Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r . Starting and ending indexes of range query","code":"static int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) {"}
{"text":"If the segment of this node lies completely within the given range","code":"if ( l <= ss && r >= se )"}
{"text":"Return maximum in the segment","code":"return st [ node ] ;"}
{"text":"If the segment of this node lies outside the given range","code":"if ( se < l ss > r ) return - 1 ;"}
{"text":"If segment of this node lies partially in the given range","code":"int mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }"}
{"text":"Function to return the maximum in the range from [ l , r ]","code":"static int getMax ( int [ ] st , int n , int l , int r ) {"}
{"text":"Check for erroneous input values","code":"if ( l < 0 r > n - 1 l > r ) { System . out . printf ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }"}
{"text":"Function to conSegment Tree for the subarray [ ss . . se ]","code":"static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) {"}
{"text":"For a single element","code":"if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; }"}
{"text":"Otherwise","code":"int mid = getMid ( ss , se ) ;"}
{"text":"Recur for left subtree","code":"st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) ,"}
{"text":"Recur for right subtree","code":"constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; }"}
{"text":"Function to conSegment Tree from the given array","code":"static int [ ] constructST ( int arr [ ] , int n ) {"}
{"text":"Height of Segment Tree","code":"int x = ( int ) ( Math . ceil ( Math . log ( n ) ) ) ;"}
{"text":"Maximum size of Segment Tree","code":"int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ;"}
{"text":"Allocate memory","code":"int [ ] st = new int [ max_size ] ;"}
{"text":"Fill the allocated memory","code":"constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;"}
{"text":"Return the constructed Segment Tree","code":"return st ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 0 } ; int n = arr . length ;"}
{"text":"Build the Segment Tree from the given array","code":"int [ ] st = constructST ( arr , n ) ; int [ ] [ ] Q = { { 1 , 3 } , { 0 , 2 } } ; for ( int i = 0 ; i < Q . length ; i ++ ) { int max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; int ok = 0 ; for ( int j = 30 ; j >= 0 ; j -- ) { if ( ( max & ( 1 << j ) ) != 0 ) ok = 1 ; if ( ok <= 0 ) continue ; max |= ( 1 << j ) ; } System . out . print ( max + \" \u2581 \" ) ; } } }"}
{"text":"Java program to find number of pairs in an array such that their XOR is 0","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the count","code":"static int calculate ( int a [ ] , int n ) {"}
{"text":"Sorting the list using built in function","code":"Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ;"}
{"text":"Traversing through the elements","code":"for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) {"}
{"text":"Counting frequency of each elements","code":"count += 1 ; } else {"}
{"text":"Adding the contribution of the frequency to the answer","code":"answer = answer + ( count * ( count - 1 ) ) \/ 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) \/ 2 ; return answer ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = a . length ;"}
{"text":"Print the count","code":"System . out . println ( calculate ( a , n ) ) ; } }"}
{"text":"Java program to find number of pairs in an array such that their XOR is 0","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the answer","code":"static int calculate ( int a [ ] , int n ) {"}
{"text":"Finding the maximum of the array","code":"int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;"}
{"text":"Creating frequency array With initial value 0","code":"int frequency [ ] = new int [ maximum + 1 ] ;"}
{"text":"Traversing through the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Counting frequency","code":"frequency [ a [ i ] ] += 1 ; } int answer = 0 ;"}
{"text":"Traversing through the frequency array","code":"for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) {"}
{"text":"Calculating answer","code":"answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = a . length ;"}
{"text":"Function calling","code":"System . out . println ( calculate ( a , n ) ) ; } }"}
{"text":"This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray .","code":"int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ;"}
{"text":"Pick a starting point as i","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;"}
{"text":"Consider all subarrays starting from i","code":"for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ;"}
{"text":"If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far","code":"if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( \" No \u2581 such \u2581 subarray \" ) ; else System . out . println ( startindex + \" \u2581 to \u2581 \" + endindex ) ; return maxsize ; }"}
{"text":"Driver program to test the above functions","code":"public static void main ( String [ ] args ) { LargestSubArray sub ; sub = new LargestSubArray ( ) ; int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = arr . length ; sub . findSubArray ( arr , size ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the maximum element","code":"static int findMax ( int arr [ ] , int low , int high ) {"}
{"text":"If there is only one element left","code":"if ( high == low ) return arr [ low ] ;"}
{"text":"Find mid","code":"int mid = low + ( high - low ) \/ 2 ;"}
{"text":"Check if mid reaches 0 , it is greater than next element or not","code":"if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; }"}
{"text":"Decide whether we need to go to the left half or the right half","code":"if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 6 , 5 , 4 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( findMax ( arr , 0 , n - 1 ) ) ; } }"}
{"text":"Java program to illustrate the iterative approach to ternary search","code":"class GFG {"}
{"text":"Function to perform Ternary Search","code":"static int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) {"}
{"text":"Find the mid1 mid2","code":"int mid1 = l + ( r - l ) \/ 3 ; int mid2 = r - ( r - l ) \/ 3 ;"}
{"text":"Check if key is present at any mid","code":"if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }"}
{"text":"Since key is not present at mid , check in which region it is present then repeat the Search operation in that region","code":"if ( key < ar [ mid1 ] ) {"}
{"text":"The key lies in between l and mid1","code":"r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) {"}
{"text":"The key lies in between mid2 and r","code":"l = mid2 + 1 ; } else {"}
{"text":"The key lies in between mid1 and mid2","code":"l = mid1 + 1 ; r = mid2 - 1 ; } }"}
{"text":"Key not found","code":"return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int l , r , p , key ;"}
{"text":"Get the array Sort the array if not sorted","code":"int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ;"}
{"text":"Starting index","code":"l = 0 ;"}
{"text":"length of array","code":"r = 9 ;"}
{"text":"Key to be searched in the array","code":"key = 5 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ;"}
{"text":"Key to be searched in the array","code":"key = 50 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ; } }"}
{"text":"function to print the majority Number","code":"static int majorityNumber ( int arr [ ] , int n ) { int ans = - 1 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } if ( freq . get ( arr [ i ] ) > n \/ 2 ) ans = arr [ i ] ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 2 , 2 , 1 , 1 , 1 , 2 , 2 } ; int n = a . length ; System . out . println ( majorityNumber ( a , n ) ) ; } }"}
{"text":"Java program to search an element in sorted and rotated array using single pass of Binary Search","code":"class Main {"}
{"text":"Returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1","code":"static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) \/ 2 ; if ( arr [ mid ] == key ) return mid ;"}
{"text":"If arr [ l ... mid ] first subarray is sorted","code":"if ( arr [ l ] <= arr [ mid ] ) {"}
{"text":"As this subarray is sorted , we can quickly check if key lies in half or other half","code":"if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;"}
{"text":"If key not lies in first half subarray , Divide other half into two subarrays , such that we can quickly check if key lies in other half","code":"return search ( arr , mid + 1 , h , key ) ; }"}
{"text":"If arr [ l . . mid ] first subarray is not sorted , then arr [ mid ... h ] must be sorted subarry","code":"if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }"}
{"text":"main function","code":"public static void main ( String args [ ] ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = arr . length ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) System . out . println ( \" Index : \u2581 \" + i ) ; else System . out . println ( \" Key \u2581 not \u2581 found \" ) ; } }"}
{"text":"Java program to find minimum element in a sorted and rotated array","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class Minimum { static int findMin ( int arr [ ] , int low , int high ) {"}
{"text":"This condition is needed to handle the case when array is not rotated at all","code":"if ( high < low ) return arr [ 0 ] ;"}
{"text":"If there is only one element left","code":"if ( high == low ) return arr [ low ] ;"}
{"text":"Find mid","code":"int mid = low + ( high - low ) \/ 2 ;"}
{"text":"Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 }","code":"if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ;"}
{"text":"Check if mid itself is minimum element","code":"if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ;"}
{"text":"Decide whether we need to go to left half or right half","code":"if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }"}
{"text":"Driver Program","code":"public static void main ( String [ ] args ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = arr3 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = arr4 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = arr5 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }"}
{"text":"Java program to find minimum element in a sorted and rotated array contating duplicate elements .","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to find minimum element","code":"public static int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) \/ 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = arr3 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = arr4 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = arr5 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }"}
{"text":"Java program to find k - th absolute difference between two elements","code":"import java . util . Scanner ; import java . util . Arrays ; class GFG {"}
{"text":"returns number of pairs with absolute difference less than or equal to mid","code":"static int countPairs ( int [ ] a , int n , int mid ) { int res = 0 , value ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Upper bound returns pointer to position of next higher number than a [ i ] + mid in a [ i . . n - 1 ] . We subtract ( ub + i + 1 ) from this position to count","code":"int ub = upperbound ( a , n , a [ i ] + mid ) ; res += ( ub - ( i - 1 ) ) ; } return res ; }"}
{"text":"returns the upper bound","code":"static int upperbound ( int a [ ] , int n , int value ) { int low = 0 ; int high = n ; while ( low < high ) { final int mid = ( low + high ) \/ 2 ; if ( value >= a [ mid ] ) low = mid + 1 ; else high = mid ; } return low ; }"}
{"text":"Returns k - th absolute difference","code":"static int kthDiff ( int a [ ] , int n , int k ) {"}
{"text":"Sort array","code":"Arrays . sort ( a ) ;"}
{"text":"Minimum absolute difference","code":"int low = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i <= n - 2 ; ++ i ) low = Math . min ( low , a [ i + 1 ] - a [ i ] ) ;"}
{"text":"Maximum absolute difference","code":"int high = a [ n - 1 ] - a [ 0 ] ;"}
{"text":"Do binary search for k - th absolute difference","code":"while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( countPairs ( a , n , mid ) < k ) low = mid + 1 ; else high = mid ; } return low ; }"}
{"text":"Driver function to check the above functions","code":"public static void main ( String args [ ] ) { Scanner s = new Scanner ( System . in ) ; int k = 3 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = a . length ; System . out . println ( kthDiff ( a , n , k ) ) ; } }"}
{"text":"Java program to find smallest and second smallest elements","code":"import java . io . * ; class SecondSmallest {"}
{"text":"Function to print first smallest and second smallest elements","code":"static void print2Smallest ( int arr [ ] ) { int first , second , arr_size = arr . length ;"}
{"text":"There should be atleast two elements","code":"if ( arr_size < 2 ) { System . out . println ( \" \u2581 Invalid \u2581 Input \u2581 \" ) ; return ; } first = second = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) {"}
{"text":"If current element is smaller than first then update both first and second","code":"if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; }"}
{"text":"If arr [ i ] is in between first and second then update second","code":"else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MAX_VALUE ) System . out . println ( \" There \u2581 is \u2581 no \u2581 second \" + \" smallest \u2581 element \" ) ; else System . out . println ( \" The \u2581 smallest \u2581 element \u2581 is \u2581 \" + first + \" \u2581 and \u2581 second \u2581 Smallest \" + \" \u2581 element \u2581 is \u2581 \" + second ) ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; print2Smallest ( arr ) ; } }"}
{"text":"LCM of given range queries using Segment Tree","code":"class GFG { static final int MAX = 1000 ;"}
{"text":"allocate space for tree","code":"static int tree [ ] = new int [ 4 * MAX ] ;"}
{"text":"declaring the array globally","code":"static int arr [ ] = new int [ MAX ] ;"}
{"text":"Function to return gcd of a and b","code":"static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }"}
{"text":"utility function to find lcm","code":"static int lcm ( int a , int b ) { return a * b \/ gcd ( a , b ) ; }"}
{"text":"Function to build the segment tree Node starts beginning index of current subtree . start and end are indexes in arr [ ] which is global","code":"static void build ( int node , int start , int end ) {"}
{"text":"If there is only one element in current subarray","code":"if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) \/ 2 ;"}
{"text":"build left and right segments","code":"build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ;"}
{"text":"build the parent","code":"int left_lcm = tree [ 2 * node ] ; int right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; }"}
{"text":"Function to make queries for array range ) l , r ) . Node is index of root of current segment in segment tree ( Note that indexes in segment tree begin with 1 for simplicity ) . start and end are indexes of subarray covered by root of current segment .","code":"static int query ( int node , int start , int end , int l , int r ) {"}
{"text":"Completely outside the segment , returning 1 will not affect the lcm ;","code":"if ( end < l start > r ) { return 1 ; }"}
{"text":"completely inside the segment","code":"if ( l <= start && r >= end ) { return tree [ node ] ; }"}
{"text":"partially inside","code":"int mid = ( start + end ) \/ 2 ; int left_lcm = query ( 2 * node , start , mid , l , r ) ; int right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"initialize the array","code":"arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ;"}
{"text":"build the segment tree","code":"build ( 1 , 0 , 10 ) ;"}
{"text":"Now we can answer each query efficiently Print LCM of ( 2 , 5 )","code":"System . out . println ( query ( 1 , 0 , 10 , 2 , 5 ) ) ;"}
{"text":"Print LCM of ( 5 , 10 )","code":"System . out . println ( query ( 1 , 0 , 10 , 5 , 10 ) ) ;"}
{"text":"Print LCM of ( 0 , 10 )","code":"System . out . println ( query ( 1 , 0 , 10 , 0 , 10 ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG { static int M = 1000000007 ; static int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . length ( ) + 1 ] ; dp [ 0 ] = 1 ;"}
{"text":"check the first character of the string if it is ' * ' then 9 ways","code":"dp [ 1 ] = s . charAt ( 0 ) == ' * ' ? 9 : s . charAt ( 0 ) == '0' ? 0 : 1 ;"}
{"text":"traverse the string","code":"for ( int i = 1 ; i < s . length ( ) ; i ++ ) {"}
{"text":"If s [ i ] = = ' * ' there can be 9 possible values of *","code":"if ( s . charAt ( i ) == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ;"}
{"text":"If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 )","code":"if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ;"}
{"text":"If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 )","code":"else if ( s . charAt ( i - 1 ) == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ;"}
{"text":"If the previous digit is * then all 15 2 - digit characters can be formed","code":"else if ( s . charAt ( i - 1 ) == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else {"}
{"text":"taking the value from previous step","code":"dp [ i + 1 ] = s . charAt ( i ) != '0' ? dp [ i ] : 0 ;"}
{"text":"If previous character is 1 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] .","code":"if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ;"}
{"text":"If previous character is 2 and ith character is less than 6 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] .","code":"else if ( s . charAt ( i - 1 ) == '2' && s . charAt ( i ) <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ;"}
{"text":"If previous character is * then it will contain the above 2 cases","code":"else if ( s . charAt ( i - 1 ) == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s . charAt ( i ) <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . length ( ) ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \"12\" ; System . out . println ( waysOfDecoding ( s ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; public class GFG {"}
{"text":"Function to count the number of ways to divide the array into two subsets and such that the difference between their sums is equal to diff","code":"static int countSubset ( int [ ] arr , int n , int diff ) {"}
{"text":"Store the sum of the set S1","code":"int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum \/ 2 ;"}
{"text":"Initializing the matrix","code":"int t [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ;"}
{"text":"Number of ways to get sum using 0 elements is 0","code":"for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ;"}
{"text":"Number of ways to get sum 0 using i elements is 1","code":"for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ;"}
{"text":"Traverse the 2D array","code":"for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) {"}
{"text":"If the value is greater than the sum store the value of previous state","code":"if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } }"}
{"text":"Return the result","code":"return t [ n ] [ sum ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"int diff = 1 , n = 4 ; int arr [ ] = { 1 , 1 , 2 , 3 } ;"}
{"text":"Function Call","code":"System . out . print ( countSubset ( arr , n , diff ) ) ; } }"}
{"text":"Java program for above approach","code":"import java . util . * ; class GFG { static float [ ] [ ] dp = new float [ 105 ] [ 605 ] ;"}
{"text":"Function to calculate probability that the sum of numbers on N throws of dice lies between A and B","code":"static float find ( int N , int a , int b ) { float probability = 0.0f ;"}
{"text":"Base case","code":"for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( float ) ( 1.0 \/ 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] \/ 6 ; } } }"}
{"text":"Add the probability for all the numbers between a and b","code":"for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = find ( N , a , b ) ;"}
{"text":"Print the answer","code":"System . out . printf ( \" % .6f \" , probability ) ; } }"}
{"text":"Java code for max sum with adjacent levels not allowed","code":"import java . util . * ; public class Main {"}
{"text":"Tree node class for Binary Tree representation","code":"static class Node { int data ; Node left , right ; Node ( int item ) { data = item ; left = right = null ; } }"}
{"text":"Recursive function to find the maximum sum returned for a root node and its grandchildren","code":"public static int getSumAlternate ( Node root ) { if ( root == null ) return 0 ; int sum = root . data ; if ( root . left != null ) { sum += getSum ( root . left . left ) ; sum += getSum ( root . left . right ) ; } if ( root . right != null ) { sum += getSum ( root . right . left ) ; sum += getSum ( root . right . right ) ; } return sum ; }"}
{"text":"Returns maximum sum with adjacent levels not allowed . This function mainly uses getSumAlternate ( )","code":"public static int getSum ( Node root ) { if ( root == null ) return 0 ;"}
{"text":"We compute sum of alternate levels starting first level and from second level . And return maximum of two values .","code":"return Math . max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . right . left = new Node ( 4 ) ; root . right . left . right = new Node ( 5 ) ; root . right . left . right . left = new Node ( 6 ) ; System . out . println ( getSum ( root ) ) ; } }"}
{"text":"Java Program to get a subset with a with a sum provided by the user","code":"public class Subset_sum {"}
{"text":"Returns true if there exists a subset with given sum in arr [ ]","code":"static boolean isSubsetSum ( int arr [ ] , int n , int sum ) {"}
{"text":"The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ]","code":"boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) {"}
{"text":"A subset with sum 0 is always possible","code":"if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;"}
{"text":"If there exists no element no sum is possible","code":"else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 5 } ; int sum = 7 ; int n = arr . length ; if ( isSubsetSum ( arr , n , sum ) == true ) System . out . println ( \" There \u2581 exists \u2581 a \u2581 subset \u2581 with \" + \" given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 exists \u2581 with \" + \" given \u2581 sum \" ) ; } }"}
{"text":"java program to find maximum equilibrium sum .","code":"import java . io . * ; class GFG {"}
{"text":"Function to find maximum equilibrium sum .","code":"static int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }"}
{"text":"Java program to find maximum equilibrium sum .","code":"import java . io . * ; public class GFG {"}
{"text":"Function to find maximum equilibrium sum .","code":"static int findMaxSum ( int [ ] arr , int n ) {"}
{"text":"Array to store prefix sum .","code":"int [ ] preSum = new int [ n ] ;"}
{"text":"Array to store suffix sum .","code":"int [ ] suffSum = new int [ n ] ;"}
{"text":"Variable to store maximum sum .","code":"int ans = Integer . MIN_VALUE ;"}
{"text":"Calculate prefix sum .","code":"preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ;"}
{"text":"Calculate suffix sum and compare it with prefix sum . Update ans accordingly .","code":"suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }"}
{"text":"Driver Code","code":"static public void main ( String [ ] args ) { int [ ] arr = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }"}
{"text":"Java program to find maximum equilibrium sum .","code":"import java . lang . Math . * ; import java . util . stream . * ; class GFG {"}
{"text":"Function to find maximum equilibrium sum .","code":"static int findMaxSum ( int arr [ ] , int n ) { int sum = IntStream . of ( arr ) . sum ( ) ; int prefix_sum = 0 , res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = Math . max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . length ; System . out . print ( findMaxSum ( arr , n ) ) ; } }"}
{"text":"Java program to find Majority element in an array","code":"import java . io . * ; class GFG {"}
{"text":"Function to find Majority element in an array","code":"static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ;"}
{"text":"sentinels","code":"int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; }"}
{"text":"update maxCount if count of current element is greater","code":"if ( count > maxCount ) { maxCount = count ; index = i ; } }"}
{"text":"if maxCount is greater than n \/ 2 return the corresponding element","code":"if ( maxCount > n \/ 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( \" No \u2581 Majority \u2581 Element \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = arr . length ;"}
{"text":"Function calling","code":"findMajority ( arr , n ) ; } }"}
{"text":"Java program to demonstrate insert operation in binary search tree .","code":"import java . io . * ; class Node { int key ; int c = 0 ; Node left , right ; } class GFG { static int ma = 0 ;"}
{"text":"A utility function to create a new BST node","code":"static Node newNode ( int item ) { Node temp = new Node ( ) ; temp . key = item ; temp . c = 1 ; temp . left = temp . right = null ; return temp ; }"}
{"text":"A utility function to insert a new node with given key in BST","code":"static Node insert ( Node node , int key ) {"}
{"text":"If the tree is empty , return a new node","code":"if ( node == null ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; }"}
{"text":"Otherwise , recur down the tree","code":"if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ; else node . c ++ ;"}
{"text":"Find the max count","code":"ma = Math . max ( ma , node . c ) ;"}
{"text":"Return the ( unchanged ) node pointer","code":"return node ; }"}
{"text":"A utility function to do inorder traversal of BST","code":"static void inorder ( Node root , int s ) { if ( root != null ) { inorder ( root . left , s ) ; if ( root . c > ( s \/ 2 ) ) System . out . println ( root . key + \"NEW_LINE\"); inorder ( root . right , s ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 3 , 3 , 2 } ; int size = a . length ; Node root = null ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] ) ; }"}
{"text":"Function call","code":"if ( ma > ( size \/ 2 ) ) inorder ( root , size ) ; else System . out . println ( \"No majority elementNEW_LINE\"); } }"}
{"text":"Program for finding out majority element in an array","code":"class MajorityElement {"}
{"text":"Function to find the candidate for Majority","code":"int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; int i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; }"}
{"text":"Function to check if the candidate occurs more than n \/ 2 times","code":"boolean isMajority ( int a [ ] , int size , int cand ) { int i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( a [ i ] == cand ) count ++ ; } if ( count > size \/ 2 ) return true ; else return false ; }"}
{"text":"Function to print Majority Element","code":"void printMajority ( int a [ ] , int size ) {"}
{"text":"Find the candidate for Majority","code":"int cand = findCandidate ( a , size ) ;"}
{"text":"Print the candidate if it is Majority","code":"if ( isMajority ( a , size , cand ) ) System . out . println ( \" \u2581 \" + cand + \" \u2581 \" ) ; else System . out . println ( \" No \u2581 Majority \u2581 Element \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { MajorityElement majorelement = new MajorityElement ( ) ; int a [ ] = new int [ ] { 1 , 3 , 3 , 1 , 2 } ;"}
{"text":"Function call","code":"int size = a . length ; majorelement . printMajority ( a , size ) ; } }"}
{"text":"Program for finding out majority element in an array","code":"import java . util . HashMap ; class MajorityElement { private static void findMajority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length \/ 2 ) { System . out . println ( \" Majority \u2581 found \u2581 : - \u2581 \" + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( \" \u2581 No \u2581 Majority \u2581 element \" ) ; }"}
{"text":"Driver program to test the above functions","code":"public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ;"}
{"text":"Function calling","code":"findMajority ( a ) ; } }"}
{"text":"Java program to find Majority element in an array","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find Majority element in an array it returns - 1 if there is no majority element","code":"public static int majorityElement ( int [ ] arr , int n ) {"}
{"text":"Sort the array in O ( nlogn )","code":"Arrays . sort ( arr ) ; int count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"Increases the count if the same element occurs otherwise starts counting new element","code":"if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; }"}
{"text":"Sets maximum count and stores maximum occured element so far if maximum count becomes greater than n \/ 2 it breaks out setting the flag","code":"if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n \/ 2 ) ) { f = 1 ; break ; } } }"}
{"text":"Returns maximum occured element if there is no such element , returns - 1","code":"return ( f == 1 ? ele : - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = 7 ;"}
{"text":"Function calling","code":"System . out . println ( majorityElement ( arr , n ) ) ; } }"}
{"text":"A Dynamic Programming solution for subset sum problem","code":"class GFG {"}
{"text":"Returns true if there is a subset of set [ ] with sum equal to given sum","code":"static boolean isSubsetSum ( int set [ ] , int n , int sum ) {"}
{"text":"The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i","code":"boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ;"}
{"text":"If sum is 0 , then answer is true","code":"for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ;"}
{"text":"If sum is not 0 and set is empty , then answer is false","code":"for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ;"}
{"text":"Fill the subset table in bottom up manner","code":"for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } }"}
{"text":"uncomment this code to print table","code":"for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Check if possible subset with given sum is possible or not","code":"static int subsetSum ( int a [ ] , int n , int sum ) {"}
{"text":"Storing the value - 1 to the matrix","code":"int tab [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { tab [ i ] [ j ] = - 1 ; } }"}
{"text":"If the sum is zero it means we got our expected sum","code":"if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ;"}
{"text":"If the value is not - 1 it means it already call the function with the same value . it will save our from the repetition .","code":"if ( tab [ n - 1 ] [ sum ] != - 1 ) return tab [ n - 1 ] [ sum ] ;"}
{"text":"if the value of a [ n - 1 ] is greater than the sum . we call for the next value","code":"if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else {"}
{"text":"Here we do two calls because we don ' t \u2581 know \u2581 which \u2581 value \u2581 is \u2581 \u2581 full - fill \u2581 our \u2581 criteria \u2581 \u2581 that ' s why we doing two calls","code":"if ( subsetSum ( a , n - 1 , sum ) != 0 || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) != 0 ) { return tab [ n - 1 ] [ sum ] = 1 ; } else return tab [ n - 1 ] [ sum ] = 0 ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 5 ; int a [ ] = { 1 , 5 , 3 , 7 , 4 } ; int sum = 12 ; if ( subsetSum ( a , n , sum ) != 0 ) { System . out . println ( \"YESNEW_LINE\"); } else System . out . println ( \"NONEW_LINE\"); } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . Math ; class GFG {"}
{"text":"Function to implement fast exponentiation","code":"static int binpow ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = res * a ; a = a * a ; b \/= 2 ; } return res ; }"}
{"text":"Function to return the value for powers of 2","code":"static int find ( int x ) { if ( x == 0 ) return 0 ; int p = ( int ) ( Math . log ( x ) \/ Math . log ( 2 ) ) ; return binpow ( 2 , p + 1 ) - 1 ; }"}
{"text":"Function to convert N into binary","code":"static String getBinary ( int n ) {"}
{"text":"To store the binary representation","code":"String ans = \" \" ;"}
{"text":"Iterate each digit of n","code":"while ( n > 0 ) { int dig = n % 2 ; ans += dig ; n \/= 2 ; }"}
{"text":"Return binary representation","code":"return ans ; }"}
{"text":"Function to find difference in bits","code":"static int totalCountDifference ( int n ) {"}
{"text":"Get binary representation","code":"String ans = getBinary ( n ) ;"}
{"text":"total number of bit differences from 0 to N","code":"int req = 0 ;"}
{"text":"Iterate over each binary bit","code":"for ( int i = 0 ; i < ans . length ( ) ; i ++ ) {"}
{"text":"If current bit is '1' then add the count of current bit","code":"if ( ans . charAt ( i ) == '1' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given number","code":"int n = 5 ;"}
{"text":"Function Call","code":"System . out . print ( totalCountDifference ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; public class Main {"}
{"text":"Function to return the maximum length of the required prefix","code":"public static int Maximum_Length ( Vector < Integer > a ) {"}
{"text":"Array to store the frequency of each element of the array","code":"int [ ] counts = new int [ 11 ] ;"}
{"text":"Iterating for all the elements","code":"int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) {"}
{"text":"Update the frequency of the current element i . e . v","code":"counts [ a . get ( index ) ] += 1 ;"}
{"text":"Sorted positive values from counts array","code":"Vector < Integer > k = new Vector < Integer > ( ) ; for ( int i : counts ) if ( i != 0 ) k . add ( i ) ; Collections . sort ( k ) ;"}
{"text":"If current prefix satisfies the given conditions","code":"if ( k . size ( ) == 1 || ( k . get ( 0 ) == k . get ( k . size ( ) - 2 ) && k . get ( k . size ( ) - 1 ) - k . get ( k . size ( ) - 2 ) == 1 ) || ( k . get ( 0 ) == 1 && k . get ( 1 ) == k . get ( k . size ( ) - 1 ) ) ) ans = index ; }"}
{"text":"Return the maximum length","code":"return ans + 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Vector < Integer > a = new Vector < Integer > ( ) ; a . add ( 1 ) ; a . add ( 1 ) ; a . add ( 1 ) ; a . add ( 2 ) ; a . add ( 2 ) ; a . add ( 2 ) ; System . out . println ( Maximum_Length ( a ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"returns the gcd after all updates in the array","code":"static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text":"Function to calculate gcd of onine queries","code":"static void print_gcd_online ( int n , int m , int [ ] [ ] query , int [ ] arr ) {"}
{"text":"stores the gcd of the initial array elements","code":"int max_gcd = 0 ; int i = 0 ;"}
{"text":"calculates the gcd","code":"for ( i = 0 ; i < n ; i ++ ) max_gcd = gcd ( max_gcd , arr [ i ] ) ;"}
{"text":"performing online queries","code":"for ( i = 0 ; i < m ; i ++ ) {"}
{"text":"index is 1 based","code":"query [ i ] [ 0 ] -- ;"}
{"text":"divide the array element","code":"arr [ query [ i ] [ 0 ] ] \/= query [ i ] [ 1 ] ;"}
{"text":"calculates the current gcd","code":"max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ;"}
{"text":"print the gcd after each step","code":"System . out . println ( max_gcd ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; int m = 3 ; int [ ] [ ] query = new int [ m ] [ 2 ] ; int [ ] arr = new int [ ] { 36 , 24 , 72 } ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static final int MAX = 1000000 ;"}
{"text":"stores whether the number is prime or not","code":"static boolean [ ] prime = new boolean [ MAX + 1 ] ;"}
{"text":"stores the count of prime numbers less than or equal to the index","code":"static int [ ] sum = new int [ MAX + 1 ] ;"}
{"text":"create the sieve","code":"static void SieveOfEratosthenes ( ) {"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all the entries as true . A value in prime [ i ] will finally be false if ' i ' is Not a prime , else true .","code":"for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= MAX ; i ++ ) sum [ i ] = 0 ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } }"}
{"text":"stores the prefix sum of number of primes less than or equal to ' i '","code":"for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"create the sieve","code":"SieveOfEratosthenes ( ) ;"}
{"text":"' l ' and ' r ' are the lower and upper bounds of the range","code":"int l = 3 , r = 9 ;"}
{"text":"get the value of count","code":"int c = ( sum [ r ] - sum [ l - 1 ] ) ;"}
{"text":"display the count","code":"System . out . println ( \" Count : \u2581 \" + c ) ; } }"}
{"text":"Java Program to find the area of the circle inscribed within the rectangle which in turn is inscribed in a semicircle","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the area of the circle","code":"static float area ( float r ) {"}
{"text":"radius cannot be negative","code":"if ( r < 0 ) return - 1 ;"}
{"text":"area of the circle","code":"float area = ( float ) ( 3.14 * Math . pow ( r \/ ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( area ( a ) ) ; } }"}
{"text":"Java program to count almost prime numbers from 1 to n","code":"import java . io . * ; class GFG { static int N = 100005 ;"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"static boolean prime [ ] = new boolean [ N ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to count almost prime numbers from 1 to n","code":"static int almostPrimes ( int n ) {"}
{"text":"to store required answer","code":"int ans = 0 ;"}
{"text":"6 is first almost prime number","code":"for ( int i = 6 ; i <= n ; i ++ ) {"}
{"text":"to count prime factors","code":"int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) {"}
{"text":"if it is perfect square","code":"if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i \/ j ] ) c ++ ; } } }"}
{"text":"if I is almost prime number","code":"if ( c == 2 ) ans ++ ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 21 ; System . out . println ( almostPrimes ( n ) ) ; } }"}
{"text":"Java implementation of above approach Returns sum of digits of x","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Returns sum of digits of x","code":"static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x != 0 ) { ans += x % 10 ; x \/= 10 ; } return ans ; }"}
{"text":"Returns closest number to x in terms of 9 's.","code":"static int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } static int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int N = 35 ; System . out . print ( sumOfDigitsTwoParts ( N ) ) ; } }"}
{"text":"Java program to check for primality using Lucas - Lehmer series .","code":"class GFG {"}
{"text":"Function to check whether ( 2 ^ p - 1 ) is prime or not .","code":"static boolean isPrime ( int p ) {"}
{"text":"generate the number","code":"double checkNumber = Math . pow ( 2 , p ) - 1 ;"}
{"text":"First number of the series","code":"double nextval = 4 % checkNumber ;"}
{"text":"Generate the rest ( p - 2 ) terms of the series .","code":"for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;"}
{"text":"now if the ( p - 1 ) th term is 0 return true else false .","code":"return ( nextval == 0 ) ; }"}
{"text":"Driver Program","code":"public static void main ( String [ ] args ) {"}
{"text":"Check whether 2 ^ p - 1 is prime or not .","code":"int p = 7 ; double checkNumber = Math . pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) System . out . println ( ( int ) checkNumber + \" \u2581 is \u2581 Prime . \" ) ; else System . out . println ( ( int ) checkNumber + \" \u2581 is \u2581 not \u2581 Prime . \" ) ; } }"}
{"text":"Java program to print all sophie german  prime number till n .","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"function to detect prime number here we have used sieve method https : www . geeksforgeeks . org \/ sieve - of - eratosthenes \/ to detect prime number","code":"static void sieve ( int n , boolean prime [ ] ) { for ( int p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; } } } static void printSophieGermanNumber ( int n ) {"}
{"text":"We have made array till 2 * n + 1 so that we can check prime number till that and conclude about sophie german prime .","code":"boolean prime [ ] = new boolean [ 2 * n + 1 ] ; Arrays . fill ( prime , true ) ; sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i < n ; ++ i ) {"}
{"text":"checking every i whether it is sophie german prime or not .","code":"if ( prime [ i ] && prime [ 2 * i + 1 ] ) System . out . print ( i + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 25 ; printSophieGermanNumber ( n ) ; } }"}
{"text":"Java Program to interpolate using Bessel 's interpolation","code":"import java . text . * ; class GFG {"}
{"text":"calculating u mentioned in the formula","code":"static double ucal ( double u , int n ) { if ( n == 0 ) return 1 ; double temp = u ; for ( int i = 1 ; i <= n \/ 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n \/ 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; }"}
{"text":"calculating factorial of given number n","code":"static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Number of values given","code":"int n = 6 ; double x [ ] = { 25 , 26 , 27 , 28 , 29 , 30 } ;"}
{"text":"y [ ] [ ] is used for difference table with y [ ] [ 0 ] used for input","code":"double [ ] [ ] y = new double [ n ] [ n ] ; y [ 0 ] [ 0 ] = 4.000 ; y [ 1 ] [ 0 ] = 3.846 ; y [ 2 ] [ 0 ] = 3.704 ; y [ 3 ] [ 0 ] = 3.571 ; y [ 4 ] [ 0 ] = 3.448 ; y [ 5 ] [ 0 ] = 3.333 ;"}
{"text":"Calculating the central difference table","code":"for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ;"}
{"text":"Displaying the central difference table","code":"DecimalFormat df = new DecimalFormat ( \" # . # # # # # # # # \" ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) System . out . print ( y [ i ] [ j ] + \" TABSYMBOL \" ) ; System . out . println ( \" \" ) ; }"}
{"text":"value to interpolate at","code":"double value = 27.4 ;"}
{"text":"Initializing u and sum","code":"double sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) \/ 2 ;"}
{"text":"k is origin thats is f ( 0 )","code":"int k ;"}
{"text":"if ( ( n % 2 ) > 0 ) origin for odd","code":"k = n \/ 2 ; else"}
{"text":"k = n \/ 2 - 1 ; origin for even","code":"double u = ( value - x [ k ] ) \/ ( x [ 1 ] - x [ 0 ] ) ;"}
{"text":"Solving using bessel 's formula","code":"for ( int i = 1 ; i < n ; i ++ ) { if ( ( i % 2 ) > 0 ) sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) \/ fact ( i ) ; else sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ -- k ] [ i ] ) \/ ( fact ( i ) * 2 ) ) ; } System . out . printf ( \" Value \u2581 at \u2581 \" + value + \" \u2581 is \u2581 % .5f \" , sum ) ; } }"}
{"text":"A simple Java program to check if n - th Fibonacci number is multiple of 10.","code":"class Fibonacci { static int fibonacci ( int n ) { int a = 0 ; int b = 1 ; int c = 0 ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }"}
{"text":"Returns true if n - th Fibonacci number is multiple of 10.","code":"static boolean isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; }"}
{"text":"main function","code":"public static void main ( String [ ] args ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function which checks whether a number is a power of 2","code":"static boolean powerOf2 ( int n ) {"}
{"text":"base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )","code":"if ( n == 1 ) return true ;"}
{"text":"all other odd numbers are not powers of 2","code":"else if ( n % 2 != 0 n == 0 ) return false ;"}
{"text":"recursive function call","code":"return powerOf2 ( n \/ 2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"True","code":"int n = 64 ;"}
{"text":"False","code":"int m = 12 ; if ( powerOf2 ( n ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); if ( powerOf2 ( m ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); } }"}
{"text":"Java program to efficiently check for power for 2","code":"class Test {"}
{"text":"Method to check if x is power of 2","code":"static boolean isPowerOfTwo ( int x ) {"}
{"text":"First x in the below expression is for the case when x is 0","code":"return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { System . out . println ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; System . out . println ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }"}
{"text":"Java program of the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if x is power of 2","code":"static boolean isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { if ( isPowerofTwo ( 30 ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerofTwo ( 128 ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to find the nearest power of 2","code":"static int nextPowerOf2 ( int n ) {"}
{"text":"The number","code":"int p = 1 ;"}
{"text":"If already a power of 2","code":"if ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ) return n ;"}
{"text":"Find the next power of 2","code":"while ( p < n ) p <<= 1 ; return p ; }"}
{"text":"Function to find the memory used","code":"static int memoryUsed ( int arr [ ] , int n ) {"}
{"text":"Sum of array","code":"int sum = 0 ;"}
{"text":"Traverse and find the sum of array","code":"for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;"}
{"text":"Function call to find the nearest power of 2","code":"int nearest = nextPowerOf2 ( sum ) ; return nearest ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( memoryUsed ( arr , n ) ) ; } }"}
{"text":"Java program to toogle k - th bit of a number","code":"class Toggle { static int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }"}
{"text":"main function","code":"public static void main ( String [ ] args ) { int n = 5 , k = 1 ; System . out . println ( toggleKthBit ( n , k ) ) ; } }"}
{"text":"Java program to find smallest power of 2 greater than or equal to n","code":"import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ;"}
{"text":"First n in the below condition is for the case where n is 0","code":"if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 0 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to return the GCD of A and B","code":"static int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; }"}
{"text":"Function to return the LCM of A and B","code":"static int lcm ( int A , int B ) { return ( A * B ) \/ gcd ( A , B ) ; }"}
{"text":"Function to return the Kth element from the required set if it a multiple of A","code":"static int checkA ( int A , int B , int C , int K ) {"}
{"text":"Start and End for Binary Search","code":"int start = 1 ; int end = K ;"}
{"text":"If no answer found return - 1","code":"int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) \/ 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value \/ B - 1 : value \/ B ; int divC = ( value % C == 0 ) ? value \/ C - 1 : value \/ C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value \/ lcm ( A , B ) - 1 : value \/ lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value \/ lcm ( C , B ) - 1 : value \/ lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value \/ lcm ( A , C ) - 1 : value \/ lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value \/ lcm ( A , lcm ( B , C ) ) - 1 : value \/ lcm ( A , lcm ( B , C ) ) ;"}
{"text":"Inclusion and Exclusion","code":"int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; }"}
{"text":"Multiple should be smaller","code":"else if ( elem > ( K - 1 ) ) { end = mid - 1 ; }"}
{"text":"Multiple should be bigger","code":"else { start = mid + 1 ; } } return ans ; }"}
{"text":"Function to return the Kth element from the required set if it a multiple of B","code":"static int checkB ( int A , int B , int C , int K ) {"}
{"text":"Start and End for Binary Search","code":"int start = 1 ; int end = K ;"}
{"text":"If no answer found return - 1","code":"int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) \/ 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value \/ A - 1 : value \/ A ; int divC = ( value % C == 0 ) ? value \/ C - 1 : value \/ C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value \/ lcm ( A , B ) - 1 : value \/ lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value \/ lcm ( C , B ) - 1 : value \/ lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value \/ lcm ( A , C ) - 1 : value \/ lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value \/ lcm ( A , lcm ( B , C ) ) - 1 : value \/ lcm ( A , lcm ( B , C ) ) ;"}
{"text":"Inclusion and Exclusion","code":"int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; }"}
{"text":"Multiple should be smaller","code":"else if ( elem > ( K - 1 ) ) { end = mid - 1 ; }"}
{"text":"Multiple should be bigger","code":"else { start = mid + 1 ; } } return ans ; }"}
{"text":"Function to return the Kth element from the required set if it a multiple of C","code":"static int checkC ( int A , int B , int C , int K ) {"}
{"text":"Start and End for Binary Search","code":"int start = 1 ; int end = K ;"}
{"text":"If no answer found return - 1","code":"int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) \/ 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value \/ B - 1 : value \/ B ; int divA = ( value % A == 0 ) ? value \/ A - 1 : value \/ A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value \/ lcm ( A , B ) - 1 : value \/ lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value \/ lcm ( C , B ) - 1 : value \/ lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value \/ lcm ( A , C ) - 1 : value \/ lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value \/ lcm ( A , lcm ( B , C ) ) - 1 : value \/ lcm ( A , lcm ( B , C ) ) ;"}
{"text":"Inclusion and Exclusion","code":"int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; }"}
{"text":"Multiple should be smaller","code":"else if ( elem > ( K - 1 ) ) { end = mid - 1 ; }"}
{"text":"Multiple should be bigger","code":"else { start = mid + 1 ; } } return ans ; }"}
{"text":"Function to return the Kth element from the set of multiples of A , B and C","code":"static int findKthMultiple ( int A , int B , int C , int K ) {"}
{"text":"Apply binary search on the multiples of A","code":"int res = checkA ( A , B , C , K ) ;"}
{"text":"If the required element is not a multiple of A then the multiples of B and C need to be checked","code":"if ( res == - 1 ) res = checkB ( A , B , C , K ) ;"}
{"text":"If the required element is neither a multiple of A nor a multiple of B then the multiples of C need to be checked","code":"if ( res == - 1 ) res = checkC ( A , B , C , K ) ; return res ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int A = 2 , B = 4 , C = 5 , K = 5 ; System . out . println ( findKthMultiple ( A , B , C , K ) ) ; } }"}
{"text":"Java implementation to sort the array by using the variation of the Stalin sort","code":"import java . util . * ; class GFG {"}
{"text":"Function to sort the array","code":"static void variationStalinsort ( Vector < Integer > arr ) { int j = 0 ; while ( true ) { int moved = 0 ; for ( int i = 0 ; i < ( arr . size ( ) - 1 - j ) ; i ++ ) { if ( arr . get ( i ) > arr . get ( i + 1 ) ) {"}
{"text":"Iterator < Integer > index = arr . iterator ( ) ;","code":"int index ; int temp ; index = arr . get ( i ) ; temp = arr . get ( i + 1 ) ; arr . removeElement ( index ) ; arr . add ( i , temp ) ; arr . removeElement ( temp ) ; arr . add ( i + 1 , index ) ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } System . out . print ( arr ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 } ; Vector < Integer > arr1 = new Vector < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) arr1 . add ( arr [ i ] ) ;"}
{"text":"Function call","code":"variationStalinsort ( arr1 ) ; } }"}
{"text":"Java program for the above approach","code":"class Main {"}
{"text":"Function to print array element","code":"public static void printArray ( int arr [ ] , int N ) {"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Function to sort the array in O ( N )","code":"public static void sortArray ( int arr [ ] , int N ) {"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; ) {"}
{"text":"If the current element is at correct position","code":"if ( arr [ i ] == i + 1 ) { i ++ ; }"}
{"text":"Else swap the current element with it 's correct position","code":"else {"}
{"text":"Swap the value of arr [ i ] and arr [ arr [ i ] - 1 ]","code":"int temp1 = arr [ i ] ; int temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 3 , 4 } ; int N = arr . length ;"}
{"text":"Function call to sort the array","code":"sortArray ( arr , N ) ;"}
{"text":"Function call to print the array","code":"printArray ( arr , N ) ; } }"}
{"text":"Java implementation for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the maximum value","code":"static int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index ) {"}
{"text":"base condition","code":"if ( index >= value . length ) { return 0 ; }"}
{"text":"K elements already reduced to half of their weight","code":"if ( flag == K ) {"}
{"text":"Dont include item","code":"int skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; int full = 0 ;"}
{"text":"If weight of the item is less than or equal to the remaining weight then include the item","code":"if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; }"}
{"text":"Return the maximum of both cases","code":"return Math . max ( full , skip ) ; }"}
{"text":"If the weight reduction to half is possible","code":"else {"}
{"text":"Skip the item","code":"int skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; int full = 0 ; int half = 0 ;"}
{"text":"Include item with full weight if weight of the item is less than the remaining weight","code":"if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; }"}
{"text":"Include item with half weight if half weight of the item is less than the remaining weight","code":"if ( weight [ index ] \/ 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] \/ 2 , flag , K , index + 1 ) ; }"}
{"text":"Return the maximum of all 3 cases","code":"return Math . max ( full , Math . max ( skip , half ) ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) throws Exception { int value [ ] = { 17 , 20 , 10 , 15 } ; int weight [ ] = { 4 , 2 , 7 , 5 } ; int K = 1 ; int W = 4 ; System . out . println ( maximum ( value , weight , W , 0 , K , 0 ) ) ; } }"}
{"text":"Java program to find the size of the minimum dominating set of the tree","code":"import java . util . * ; class GFG { static final int N = 1005 ;"}
{"text":"Definition of a tree node","code":"static class Node { int data ; Node left , right ; } ;"}
{"text":"Helper function that allocates a new node","code":"static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = node . right = null ; return node ; }"}
{"text":"DP array to precompute and store the results","code":"static int [ ] [ ] [ ] dp = new int [ N ] [ 5 ] [ 5 ] ;"}
{"text":"minDominatingSettion to return the size of the minimum dominating set of the array","code":"static int minDominatingSet ( Node root , int covered , int compulsory ) {"}
{"text":"Base case","code":"if ( root == null ) return 0 ;"}
{"text":"Setting the compulsory value if needed","code":"if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ;"}
{"text":"Check if the answer is already computed","code":"if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) return dp [ root . data ] [ covered ] [ compulsory ] ;"}
{"text":"If it is compulsory to select the node","code":"if ( compulsory > 0 ) {"}
{"text":"Choose the node and set its children as covered","code":"return dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; }"}
{"text":"If it is covered","code":"if ( covered > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = Math . min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; }"}
{"text":"If the current node is neither covered nor needs to be selected compulsorily","code":"int ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; }"}
{"text":"Store the result","code":"return dp [ root . data ] [ covered ] [ compulsory ] = ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Initialising the DP array","code":"for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } }"}
{"text":"Constructing the tree","code":"Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 4 ) ; root . left . left . left = newNode ( 5 ) ; root . left . left . left . left = newNode ( 6 ) ; root . left . left . left . right = newNode ( 7 ) ; root . left . left . left . right . right = newNode ( 10 ) ; root . left . left . left . left . left = newNode ( 8 ) ; root . left . left . left . left . right = newNode ( 9 ) ; System . out . print ( minDominatingSet ( root , 0 , 0 ) + \"NEW_LINE\"); } }"}
{"text":"Java implementation of above approach","code":"class GFG { static int maxSum = 100 ; static int arrSize = 51 ;"}
{"text":"variable to store states of dp","code":"static int [ ] [ ] dp = new int [ arrSize ] [ maxSum ] ; static boolean [ ] [ ] visit = new boolean [ arrSize ] [ maxSum ] ;"}
{"text":"To find the number of subsets with sum equal to 0 Since S can be negative , we will maxSum to it to make it positive","code":"static int SubsetCnt ( int i , int s , int arr [ ] , int n ) {"}
{"text":"Base cases","code":"if ( i == n ) { if ( s == 0 ) { return 1 ; } else { return 0 ; } }"}
{"text":"Returns the value if a state is already solved","code":"if ( visit [ i ] [ s + arrSize ] ) { return dp [ i ] [ s + arrSize ] ; }"}
{"text":"If the state is not visited , then continue","code":"visit [ i ] [ s + arrSize ] = true ;"}
{"text":"Recurrence relation","code":"dp [ i ] [ s + arrSize ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ;"}
{"text":"Returning the value","code":"return dp [ i ] [ s + arrSize ] ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 , - 4 , - 4 } ; int n = arr . length ; System . out . println ( SubsetCnt ( 0 , 0 , arr , n ) ) ; } }"}
{"text":"Java program to find the number of Bit Strings of length N with K adjacent set bits","code":"class solution { static final int MAX = 1000 ;"}
{"text":"Function to find the number of Bit Strings of length N with K adjacent set bits","code":"static int waysToKAdjacentSetBits ( int dp [ ] [ ] [ ] , int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) {"}
{"text":"Base Case when we form bit string of length n","code":"if ( currentIndex == n ) {"}
{"text":"if f ( bit string ) = k , count this way","code":"if ( adjacentSetBits == k ) return 1 ; return 0 ; } if ( dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] != - 1 ) { return dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] ; } int noOfWays = 0 ;"}
{"text":"Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset","code":"if ( lastBit == 1 ) {"}
{"text":"set the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;"}
{"text":"unset the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( lastBit == 0 ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] = noOfWays ; return noOfWays ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 5 , k = 2 ;"}
{"text":"dp [ i ] [ j ] [ k ] represents bit strings of length i with f ( bit string ) = j and last bit as k","code":"int dp [ ] [ ] [ ] = new int [ MAX ] [ MAX ] [ 2 ] ;"}
{"text":"initialize the dp","code":"for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int k1 = 0 ; k1 < 2 ; k1 ++ ) dp [ i ] [ j ] [ k1 ] = - 1 ;"}
{"text":"total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )","code":"int totalWays = waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 0 ) ; System . out . print ( \" Number \u2581 of \u2581 ways \u2581 = \u2581 \" + totalWays + \"NEW_LINE\"); } }"}
{"text":"A space optimized based Java program to print the nth tetranacci number","code":"import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to print the N - th tetranacci number","code":"static void printTetra ( int n ) { if ( n < 0 ) return ;"}
{"text":"Initialize first four numbers to base cases","code":"int first = 0 , second = 1 ; int third = 1 , fourth = 2 ;"}
{"text":"declare a current variable","code":"int curr = 0 ; if ( n == 0 ) System . out . print ( first ) ; else if ( n == 1 n == 2 ) System . out . print ( second ) ; else if ( n == 3 ) System . out . print ( fourth ) ; else {"}
{"text":"Loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively","code":"for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } System . out . print ( curr ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; printTetra ( n ) ; } }"}
{"text":"Program to find n - th stair using step size 1 or 2 or 3.","code":"import java . lang . * ; import java . util . * ; public class GfG {"}
{"text":"A recursive function used by countWays","code":"public static int countWays ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }"}
{"text":"Driver function","code":"public static void main ( String argc [ ] ) { int n = 4 ; System . out . println ( countWays ( n ) ) ; } }"}
{"text":"A Java program to count number of ways to reach nth stair when","code":"import java . io . * ; class GFG {"}
{"text":"A recursive function used by countWays","code":"static int countWays ( int n ) {"}
{"text":"Declaring three variables and holding the ways for first three stairs","code":"int a = 1 , b = 2 , c = 4 ;"}
{"text":"Fourth variable","code":"int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ;"}
{"text":"Starting from 4 as already counted for 3 stairs","code":"for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countWays ( n ) ) ; } }"}
{"text":"initializing with 1 as sum 0 is always possible","code":"dp [ 0 ] = 1 ;"}
{"text":"loop to go through every element of the elements array","code":"for ( int i = 0 ; i < elements . length ; i ++ ) {"}
{"text":"to change the values of all possible sum values to 1","code":"for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } }"}
{"text":"if sum is possible then return 1","code":"if ( dp [ sum ] == 1 ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) throws Exception { int elements [ ] = { 6 , 2 , 5 } ; int sum = 7 ; if ( isPossible ( elements , sum ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text":"A naive recursive Java program to find maximum tasks .","code":"class GFG {"}
{"text":"Returns maximum amount of task that can be done till day n","code":"static int maxTasks ( int high [ ] , int low [ ] , int n ) {"}
{"text":"If n is less than equal to 0 , then no solution exists","code":"if ( n <= 0 ) return 0 ;"}
{"text":"Determines which task to choose on day n , then returns the maximum till that day","code":"return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; System . out . println ( maxTasks ( high , low , n ) ) ; } }"}
{"text":"function to find gcd of two numbers in O ( log ( min ( a , b ) ) )","code":"static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int nCr ( int n , int r ) {"}
{"text":"base case","code":"if ( r > n ) return 0 ;"}
{"text":"better time complexity for lesser r value","code":"if ( r > n - r ) C ( n , r ) = C ( n , n - r ) r = n - r ; int mod = 1000000007 ;"}
{"text":"array of elements from n - r + 1 to n","code":"int [ ] arr = new int [ r ] ; for ( int i = n - r + 1 ; i <= n ; i ++ ) { arr [ i + r - n - 1 ] = i ; } long ans = 1 ;"}
{"text":"for numbers from 1 to r find arr [ j ] such that gcd ( i , arr [ j ] ) > 1","code":"for ( int k = 1 ; k < r + 1 ; k ++ ) { int j = 0 , i = k ; while ( j < arr . length ) { int x = gcd ( i , arr [ j ] ) ; if ( x > 1 ) {"}
{"text":"if gcd > 1 , divide both by gcd","code":"arr [ j ] \/= x ; i \/= x ; } if ( i == 1 )"}
{"text":"if i becomes 1 , no need to search arr","code":"break ; j += 1 ; } }"}
{"text":"for ( int i : arr ) single pass to multiply the numerator","code":"ans = ( ans * i ) % mod ; return ( int ) ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + nCr ( n , r ) + \"NEW_LINE\"); } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the Kth character after X days","code":"static char FindKthChar ( String str , int K , int X ) {"}
{"text":"Variable to store the KthChar","code":"char ans = ' \u2581 ' ; int sum = 0 ;"}
{"text":"Traverse the string","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"Convert char into int","code":"int digit = ( int ) str . charAt ( i ) - 48 ;"}
{"text":"Calculate characters","code":"int range = ( int ) Math . pow ( digit , X ) ; sum += range ;"}
{"text":"If K is less than sum than ans = str [ i ]","code":"if ( K <= sum ) { ans = str . charAt ( i ) ; break ; } }"}
{"text":"Return answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"String str = \"123\" ; int K = 9 ; int X = 3 ;"}
{"text":"Function Call","code":"char ans = FindKthChar ( str , K , X ) ; System . out . println ( ans ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the count of valid pairs","code":"static int totalPairs ( String s1 , String s2 ) { int count = 0 ; int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ;"}
{"text":"Default Initialise both arrays 0 Store frequency of number of set bits for s1","code":"for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s1 . charAt ( i ) ) ; arr1 [ set_bits ] ++ ; }"}
{"text":"Store frequency of number of set bits for s2","code":"for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s2 . charAt ( i ) ) ; arr2 [ set_bits ] ++ ; }"}
{"text":"Calculate total pairs","code":"for ( int i = 1 ; i <= 6 ; i ++ ) { count += ( arr1 [ i ] * arr2 [ i ] ) ; }"}
{"text":"Return the count of valid pairs","code":"return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s1 = \" geeks \" ; String s2 = \" forgeeks \" ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }"}
{"text":"Java implementation to count substrings starting with character X and ending with character Y","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"function to count substrings starting with character X and ending with character Y","code":"static int countSubstr ( String str , int n , char x , char y ) {"}
{"text":"to store total count of required substrings","code":"int tot_count = 0 ;"}
{"text":"to store count of character ' x ' up to the point the string ' str ' has been traversed so far","code":"int count_x = 0 ;"}
{"text":"traverse ' str ' form left to right","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"if true , increment ' count _ x '","code":"if ( str . charAt ( i ) == x ) count_x ++ ;"}
{"text":"if true accumulate ' count _ x ' to ' tot _ count '","code":"if ( str . charAt ( i ) == y ) tot_count += count_x ; }"}
{"text":"required count","code":"return tot_count ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String str = \" abbcaceghcak \" ; int n = str . length ( ) ; char x = ' a ' , y = ' c ' ; System . out . print ( \" Count \u2581 = \u2581 \" + countSubstr ( str , n , x , y ) ) ; } }"}
{"text":"Java program to count no of words from given input string .","code":"public class GFG { static final int OUT = 0 ; static final int IN = 1 ;"}
{"text":"returns number of words in str","code":"static int countWords ( String str ) { int state = OUT ;"}
{"text":"word count","code":"int wc = 0 ; int i = 0 ;"}
{"text":"Scan all characters one by one","code":"while ( i < str . length ( ) ) {"}
{"text":"If next character is a separator , set the state as OUT","code":"if ( str . charAt ( i ) == ' \u2581 ' || str . charAt ( i ) == 'NEW_LINE' || str . charAt ( i ) == ' TABSYMBOL ' ) state = OUT ;"}
{"text":"If next character is not a word separator and state is OUT , then set the state as IN and increment word count","code":"else if ( state == OUT ) { state = IN ; ++ wc ; }"}
{"text":"Move to next character","code":"++ i ; } return wc ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String args [ ] ) { String str = \"One twothree four five \"; System . out . println ( \" No \u2581 of \u2581 words \u2581 : \u2581 \" + countWords ( str ) ) ; } }"}
{"text":"Java program to find nth Enneadecagonal number","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate Enneadecagonal number","code":"static int nthEnneadecagonal ( int n ) {"}
{"text":"Formula for finding nth Enneadecagonal number","code":"return ( 17 * n * n - 15 * n ) \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 6 ; System . out . print ( n + \" th \u2581 Enneadecagonal \u2581 number \u2581 : \" ) ; System . out . println ( nthEnneadecagonal ( n ) ) ; } }"}
{"text":"Java program to calculate area of a circumscribed circle - square","code":"import java . io . * ; class Gfg {"}
{"text":"Utility Function","code":"static float areacircumscribed ( float a ) { float PI = 3.14159265f ; return ( a * a * ( PI \/ 2 ) ) ; }"}
{"text":"Driver Function","code":"public static void main ( String arg [ ] ) { float a = 6 ; System . out . print ( \" Area \u2581 of \u2581 an \u2581 circumscribed \" + \" circle \u2581 is \u2581 : \" ) ; System . out . println ( areacircumscribed ( a ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the type of the item given out according to the given rules","code":"static int itemType ( int n ) {"}
{"text":"Stores the count of item given out at each step","code":"int count = 0 ; int day = 1 ;"}
{"text":"Iterate to find the Nth day present is given out","code":"while ( count + day * ( day + 1 ) \/ 2 < n ) {"}
{"text":"Find the number of presents given on day is day * ( day + 1 ) \/ 2","code":"count += day * ( day + 1 ) \/ 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) {"}
{"text":"Iterate over the type","code":"count += type ;"}
{"text":"Return the resultant type","code":"if ( count >= n ) { return type ; } } return 0 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( itemType ( N ) ) ; } }"}
{"text":"Java program to check Linked List is sorted in descending order or not","code":"class GFG {"}
{"text":"Linked list node","code":"static class Node { int data ; Node next ; } ;"}
{"text":"function to Check Linked List is sorted in descending order or not","code":"static boolean isSortedDesc ( Node head ) { if ( head == null ) return true ;"}
{"text":"Traverse the list till last node and return false if a node is smaller than or equal its next .","code":"for ( Node t = head ; t . next != null ; t = t . next ) if ( t . data <= t . next . data ) return false ; return true ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { Node head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program for the above approach","code":"public class GFG {"}
{"text":"Function to find the maximum length continuos segment of character c after flipping at most K characters","code":"static int maxLength ( String str , int n , char c , int k ) {"}
{"text":"Stores the maximum length","code":"int ans = - 1 ;"}
{"text":"Stores the count of char ' c '","code":"int cnt = 0 ;"}
{"text":"Start of window","code":"int left = 0 ; for ( int right = 0 ; right < n ; right ++ ) { if ( str . charAt ( right ) == c ) { cnt ++ ; }"}
{"text":"Remove the extra ' c ' from left","code":"while ( cnt > k ) { if ( str . charAt ( left ) == c ) { cnt -- ; }"}
{"text":"Increment the value of the left","code":"left ++ ; }"}
{"text":"Update the resultant maximum length of character ch","code":"ans = Math . max ( ans , right - left + 1 ) ; } return ans ; }"}
{"text":"Function to find the maximum length of consecutive 0 s or 1 s by flipping at most K characters of the string","code":"static int maxConsecutiveSegment ( String S , int K ) { int N = S . length ( ) ;"}
{"text":"Print the maximum of the maximum length of 0 s or 1 s","code":"return Math . max ( maxLength ( S , N , '0' , K ) , maxLength ( S , N , '1' , K ) ) ; }"}
{"text":"Driver Code","code":"int main ( ) { return 0 ; } public static void main ( String [ ] args ) { String S = \"1001\" ; int K = 1 ; System . out . println ( maxConsecutiveSegment ( S , K ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find minimum count of { 1 , 2 , 5 } valued coins required to make a change of all values in the range [ 1 , N ]","code":"static void find ( int N ) { int T , F , O ;"}
{"text":"Number of 5 valueds coins required","code":"F = ( int ) ( ( N - 4 ) \/ 5 ) ;"}
{"text":"Number of 1 valued coins required","code":"if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; }"}
{"text":"Number of 2 valued coins required","code":"T = ( int ) Math . floor ( ( N - 5 * F - O ) \/ 2 ) ; System . out . println ( \" Count \u2581 of \u2581 5 \u2581 valueds \u2581 coins : \u2581 \" + F ) ; System . out . println ( \" Count \u2581 of \u2581 2 \u2581 valueds \u2581 coins : \u2581 \" + T ) ; System . out . println ( \" Count \u2581 of \u2581 1 \u2581 valueds \u2581 coins : \u2581 \" + O ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int N = 8 ; find ( N ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to maximize count of 0 and 10 by replacing character ' ? ' to '0' or '1'","code":"static void findMaxOccurence ( char [ ] str , int N ) {"}
{"text":"Traverse the given String","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If current character is ' ? '","code":"if ( str [ i ] == ' ? ' ) {"}
{"text":"Replace str [ i ] to '0'","code":"str [ i ] = '0' ; } } System . out . print ( str ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given String","code":"String str = \"10?0?11\" ; int N = str . length ( ) ; findMaxOccurence ( str . toCharArray ( ) , N ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function checks if a given string is valid or not and prints the output","code":"public static void checkInfinite ( String s ) {"}
{"text":"Boolean flag variable to mark if given string is valid","code":"boolean flag = true ; int N = s . length ( ) ;"}
{"text":"Traverse the given string","code":"for ( int i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"If adjacent character differ by 1","code":"if ( s . charAt ( i ) == ( char ) ( ( int ) ( s . charAt ( i + 1 ) ) + 1 ) ) { continue ; }"}
{"text":"If character ' a ' is followed by 4","code":"else if ( s . charAt ( i ) == ' a ' && s . charAt ( i + 1 ) == ' z ' ) { continue ; }"}
{"text":"Else flip the flag and break from the loop","code":"else { flag = false ; break ; } }"}
{"text":"Output according to flag variable","code":"if ( ! flag ) System . out . print ( \" NO \" ) ; else System . out . print ( \" YES \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given string","code":"String s = \" ecbaz \" ;"}
{"text":"Function call","code":"checkInfinite ( s ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the minimum number of changes of lane required","code":"static int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) {"}
{"text":"If there is a barrier , then add very large value","code":"int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = ( int ) 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) {"}
{"text":"Add the minimum value to move forword with or without crossing barrier","code":"if ( val != i + 1 ) { dp [ i ] = Math . min ( dp [ i ] , Math . min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } }"}
{"text":"Return the minimum value of dp [ 0 ] , dp [ 1 ] and dp [ 2 ]","code":"return Math . min ( dp [ 0 ] , Math . min ( dp [ 1 ] , dp [ 2 ] ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int barrier [ ] = { 0 , 1 , 2 , 3 , 0 } ; int N = barrier . length ; System . out . print ( minChangeInLane ( barrier , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class Main {"}
{"text":"Function to count number of ways to get given sum groups","code":"public static void numWays ( int [ ] [ ] ratings , int queries [ ] [ ] , int n , int k ) {"}
{"text":"Initialise dp array","code":"int dp [ ] [ ] = new int [ n ] [ 10000 + 2 ] ;"}
{"text":"Mark all 1 st row values as 1 since the mat [ 0 ] [ i ] is all possible sums in first row","code":"for ( int i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ;"}
{"text":"Fix the ith row","code":"for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"Fix the sum","code":"for ( int sum = 0 ; sum <= 10000 ; sum ++ ) {"}
{"text":"Iterate through all values of ith row","code":"for ( int j = 0 ; j < k ; j ++ ) {"}
{"text":"If sum can be obtained","code":"if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } }"}
{"text":"Find the prefix sum of last row","code":"for ( int sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; }"}
{"text":"Traverse each query","code":"for ( int q = 0 ; q < queries . length ; q ++ ) { int a = queries [ q ] [ 0 ] ; int b = queries [ q ] [ 1 ] ;"}
{"text":"No of ways to form groups","code":"System . out . print ( dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given N batches and K students","code":"int N = 2 , K = 3 ;"}
{"text":"Given ratings","code":"int ratings [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ;"}
{"text":"Given Queries","code":"int queries [ ] [ ] = { { 6 , 6 } , { 1 , 6 } } ;"}
{"text":"Function Call","code":"numWays ( ratings , queries , N , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to count permutations with K inversions","code":"static void numberOfPermWithKInversion ( int N , int K ) {"}
{"text":"Store number of permutations with K inversions","code":"int [ ] [ ] dp = new int [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) {"}
{"text":"If N = 1 only 1 permutation with no inversion","code":"if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; }"}
{"text":"For K = 0 only 1 permutation with no inversion","code":"else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ;"}
{"text":"Otherwise Update each dp state as per the reccurrance relation formed","code":"else { int maxm = Math . max ( j - ( i - 1 ) ) ; dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ maxm , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } }"}
{"text":"Print final count","code":"System . out . println ( dp [ N % 2 ] [ K ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N and K","code":"int N = 3 , K = 2 ;"}
{"text":"Function Call","code":"numberOfPermWithKInversion ( N , K ) ; } }"}
{"text":"No of rows and columns","code":"class GFG { static final int N = 100 ; static int n , m ;"}
{"text":"Declaring the matrix of maximum 100 rows and 100 columns","code":"static int a [ ] [ ] = new int [ N ] [ N ] ;"}
{"text":"Variable visited is used to keep track of all the visited positions Variable dp is used to store maximum sum till current position","code":"static int dp [ ] [ ] = new int [ N ] [ N ] ; static int visited [ ] [ ] = new int [ N ] [ N ] ;"}
{"text":"For storing current sum","code":"static int current_sum = 0 ;"}
{"text":"For continuous update of maximum sum required","code":"static int total_sum = 0 ;"}
{"text":"Function to Input the matrix of size n * m","code":"static void inputMatrix ( ) { n = 3 ; m = 3 ; a [ 0 ] [ 0 ] = 500 ; a [ 0 ] [ 1 ] = 100 ; a [ 0 ] [ 2 ] = 230 ; a [ 1 ] [ 0 ] = 1000 ; a [ 1 ] [ 1 ] = 300 ; a [ 1 ] [ 2 ] = 100 ; a [ 2 ] [ 0 ] = 200 ; a [ 2 ] [ 1 ] = 1000 ; a [ 2 ] [ 2 ] = 200 ; }"}
{"text":"Function to calculate maximum sum of path","code":"static int maximum_sum_path ( int i , int j ) {"}
{"text":"Checking boundary condition","code":"if ( i == n - 1 && j == m - 1 ) return a [ i ] [ j ] ;"}
{"text":"Checking whether or not ( i , j ) is visited","code":"if ( visited [ i ] [ j ] != 0 ) return dp [ i ] [ j ] ;"}
{"text":"Marking ( i , j ) is visited","code":"visited [ i ] [ j ] = 1 ; int total_sum = 0 ;"}
{"text":"Checking whether the position hasn 't  visited the last row or the last column.  Making recursive call for all the possible  moves from the current cell and then adding the  maximum returned by the calls and updating it.","code":"if ( i < n - 1 & j < m - 1 ) { int current_sum = Math . max ( maximum_sum_path ( i , j + 1 ) , Math . max ( maximum_sum_path ( i + 1 , j + 1 ) , maximum_sum_path ( i + 1 , j ) ) ) ; total_sum = a [ i ] [ j ] + current_sum ; }"}
{"text":"Checking whether position has reached last row","code":"else if ( i == n - 1 ) total_sum = a [ i ] [ j ] + maximum_sum_path ( i , j + 1 ) ;"}
{"text":"If the position is in the last column","code":"else total_sum = a [ i ] [ j ] + maximum_sum_path ( i + 1 , j ) ;"}
{"text":"Updating the maximum sum till the current position in the dp","code":"dp [ i ] [ j ] = total_sum ;"}
{"text":"Returning the updated maximum value","code":"return total_sum ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { inputMatrix ( ) ;"}
{"text":"Calling the implemented function","code":"int maximum_sum = maximum_sum_path ( 0 , 0 ) ; System . out . println ( maximum_sum ) ; } }"}
{"text":"k is current index and col is previous color .","code":"class GFG { static int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ;"}
{"text":"base case","code":"if ( k == n ) return 0 ;"}
{"text":"check if color of this city is equal to prev visited city","code":"if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ;"}
{"text":"return max of both options","code":"return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A = - 5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = color . length ;"}
{"text":"Initially begin with color 0","code":"System . out . print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ; } }"}
{"text":"A simple recursive Java program to print the nth tetranacci numbers .","code":"class GFG {"}
{"text":"Function to return the N - th tetranacci number","code":"static int printTetraRec ( int n ) {"}
{"text":"base cases","code":"if ( n == 0 ) return 0 ;"}
{"text":"base cases","code":"if ( n == 1 n == 2 ) return 1 ;"}
{"text":"base cases","code":"if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; }"}
{"text":"function to print the Nth tetranacci number","code":"static void printTetra ( int n ) { System . out . println ( printTetraRec ( n ) + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; printTetra ( n ) ; } }"}
{"text":"Program to find SOP of all combination taken ( 1 to N ) at a time using brute force","code":"import java . io . * ; class GFG {"}
{"text":"to store sum of every combination","code":"static int sum = 0 ; static void Combination ( int [ ] a , int [ ] combi , int n , int r , int depth , int index ) {"}
{"text":"if we have reached sufficient depth","code":"if ( index == r ) {"}
{"text":"find the product of combination","code":"int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ;"}
{"text":"add the product into sum","code":"sum += product ; return ; }"}
{"text":"recursion to produce different combination","code":"for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } }"}
{"text":"function to print sum of products of all combination taken 1 - N at a time","code":"static void allCombination ( int [ ] a , int n ) { for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"creating temporary array for storing combination","code":"int [ ] combi = new int [ i ] ;"}
{"text":"call combination with r = i for combination taken i at a time","code":"Combination ( a , combi , n , i , 0 , 0 ) ;"}
{"text":"displaying sum","code":"System . out . print ( \" f ( \" + i + \" ) \u2581 - - > \u2581 \" + sum + \"NEW_LINE\"); sum = 0 ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 5 ; int [ ] a = new int [ n ] ;"}
{"text":"storing numbers from 1 - N in array","code":"for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ;"}
{"text":"calling allCombination","code":"allCombination ( a , n ) ; } }"}
{"text":"A DP based Java program to find maximum tasks .","code":"class GFG {"}
{"text":"Returns the maximum among the 2 numbers","code":"static int max ( int x , int y ) { return ( x > y ? x : y ) ; }"}
{"text":"Returns maximum amount of task that can be done till day n","code":"static int maxTasks ( int [ ] high , int [ ] low , int n ) {"}
{"text":"An array task_dp that stores the maximum task done","code":"int [ ] task_dp = new int [ n + 1 ] ;"}
{"text":"If n = 0 , no solution exists","code":"task_dp [ 0 ] = 0 ;"}
{"text":"If n = 1 , high effort task on that day will be the solution","code":"task_dp [ 1 ] = high [ 0 ] ;"}
{"text":"Fill the entire array determining which task to choose on day i","code":"for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = Math . max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; int [ ] high = { 3 , 6 , 8 , 7 , 6 } ; int [ ] low = { 1 , 5 , 4 , 5 , 3 } ; System . out . println ( maxTasks ( high , low , n ) ) ; } }"}
{"text":"A O ( n ) time and O ( 1 ) extra space solution to calculate the Permutation Coefficient","code":"import java . io . * ; class GFG { static int PermutationCoeff ( int n , int k ) { int Fn = 1 , Fk = 1 ;"}
{"text":"Compute n ! and ( n - k ) !","code":"for ( int i = 1 ; i <= n ; i ++ ) { Fn *= i ; if ( i == n - k ) Fk = Fn ; } int coeff = Fn \/ Fk ; return coeff ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 10 , k = 2 ; System . out . println ( \" Value \u2581 of \u2581 P ( \u2581 \" + n + \" , \" + k + \" ) \u2581 is \u2581 \" + PermutationCoeff ( n , k ) ) ; } }"}
{"text":"A dynamic programming based Java program for partition problem","code":"import java . io . * ; class Partition {"}
{"text":"Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false","code":"static boolean findPartition ( int arr [ ] , int n ) { int sum = 0 ; int i , j ;"}
{"text":"Calculate sum of all elements","code":"for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean part [ ] [ ] = new boolean [ sum \/ 2 + 1 ] [ n + 1 ] ;"}
{"text":"initialize top row as true","code":"for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ;"}
{"text":"initialize leftmost column , except part [ 0 ] [ 0 ] , as 0","code":"for ( i = 1 ; i <= sum \/ 2 ; i ++ ) part [ i ] [ 0 ] = false ;"}
{"text":"Fill the partition table in bottom up manner","code":"for ( i = 1 ; i <= sum \/ 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } }"}
{"text":"uncomment this part to print table","code":"return part [ sum \/ 2 ] [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = arr . length ;"}
{"text":"Function call","code":"if ( findPartition ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \" \" \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the minimum operations required to get the given string after appending m or n characters from the end to the front of the string in each operation","code":"static void minimumOperations ( String orig_str , int m , int n ) {"}
{"text":"Store the original string","code":"String orig = orig_str ;"}
{"text":"Stores the count of operations","code":"int turn = 1 ; int j = 1 ;"}
{"text":"Traverse the string","code":"for ( int i = 0 ; i < orig_str . length ( ) ; i ++ ) {"}
{"text":"Cut m letters from end","code":"String m_cut = orig_str . substring ( orig_str . length ( ) - m ) ; orig_str = orig_str . substring ( 0 , orig_str . length ( ) - m ) ;"}
{"text":"Add cut m letters to beginning","code":"orig_str = m_cut + orig_str ;"}
{"text":"Update j","code":"j = j + 1 ;"}
{"text":"Check if strings are the same","code":"if ( ! orig . equals ( orig_str ) ) { turn = turn + 1 ;"}
{"text":"Cut n letters from end","code":"String n_cut = orig_str . substring ( orig_str . length ( ) - n ) ; orig_str = orig_str . substring ( 0 , orig_str . length ( ) - n ) ;"}
{"text":"Add cut n letters to beginning","code":"orig_str = n_cut + orig_str ;"}
{"text":"Update j","code":"j = j + 1 ; }"}
{"text":"Check if strings are the same","code":"if ( orig . equals ( orig_str ) ) { break ; }"}
{"text":"Update the turn","code":"turn = turn + 1 ; } System . out . println ( turn ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given string S","code":"String S = \" GeeksforGeeks \" ; int X = 5 , Y = 3 ;"}
{"text":"Function Call","code":"minimumOperations ( S , X , Y ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Prints occurrences of txt [ ] in pat [ ]","code":"static int KMPSearch ( char [ ] pat , char [ ] txt ) { int M = pat . length ; int N = txt . length ;"}
{"text":"Create lps [ ] that will hold the longest prefix suffix values for pattern","code":"int lps [ ] = new int [ M ] ;"}
{"text":"Preprocess the pattern ( calculate lps [ ] array )","code":"computeLPSArray ( pat , M , lps ) ;"}
{"text":"Index for txt [ ] , index for pat [ ]","code":"int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j + 1 ; }"}
{"text":"Mismatch after j matches","code":"else if ( i < N && pat [ j ] != txt [ i ] ) {"}
{"text":"Do not match lps [ 0. . lps [ j - 1 ] ] characters , they will match anyway","code":"if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; }"}
{"text":"Fills lps [ ] for given pattern pat [ 0. . M - 1 ]","code":"static void computeLPSArray ( char [ ] pat , int M , int [ ] lps ) {"}
{"text":"Length of the previous longest prefix suffix","code":"int len = 0 ;"}
{"text":"lps [ 0 ] is always 0","code":"lps [ 0 ] = 0 ;"}
{"text":"The loop calculates lps [ i ] for i = 1 to M - 1","code":"int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; }"}
{"text":"( pat [ i ] != pat [ len ] )","code":"else {"}
{"text":"This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step .","code":"if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }"}
{"text":"Returns count of rotations to get the same String back","code":"static int countRotations ( String s ) {"}
{"text":"Form a String excluding the first character and concatenating the String at the end","code":"String s1 = s . substring ( 1 , s . length ( ) - 1 ) + s ;"}
{"text":"Convert the String to character array","code":"char [ ] pat = s . toCharArray ( ) ; char [ ] text = s1 . toCharArray ( ) ;"}
{"text":"Use the KMP search algorithm to find it in O ( N ) time","code":"return 1 + KMPSearch ( pat , text ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s1 = \" geeks \" ; System . out . print ( countRotations ( s1 ) ) ; } }"}
{"text":"Java program to implement DFS that accepts all string that do not end with \" THE \"","code":"import java . util . * ; class GFG {"}
{"text":"dfa tells the number associated with the present state","code":"static int dfa = 0 ;"}
{"text":"This function is for the starting state ( zeroth ) of DFA","code":"static void start ( char c ) {"}
{"text":"On receiving ' T ' or ' t ' goto first state ( 1 )","code":"if ( c == ' t ' c == ' T ' ) dfa = 1 ; }"}
{"text":"This function is for the first state of DFA","code":"static void state1 ( char c ) {"}
{"text":"On receiving ' T ' or ' t ' goto first state ( 1 )","code":"if ( c == ' t ' c == ' T ' ) dfa = 1 ;"}
{"text":"On receiving ' H ' or ' h ' goto second state ( 2 )","code":"else if ( c == ' h ' c == ' H ' ) dfa = 2 ;"}
{"text":"else goto starting state ( 0 )","code":"else dfa = 0 ; }"}
{"text":"This function is for the second state of DFA","code":"static void state2 ( char c ) {"}
{"text":"On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 )","code":"if ( c == ' e ' c == ' E ' ) dfa = 3 ; else dfa = 0 ; }"}
{"text":"This function is for the third state of DFA","code":"static void state3 ( char c ) {"}
{"text":"On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 )","code":"if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } static boolean isAccepted ( char str [ ] ) {"}
{"text":"store length of string","code":"int len = str . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { char str [ ] = \" forTHEgeeks \" . toCharArray ( ) ; if ( isAccepted ( str ) == true ) System . out . println ( \"ACCEPTEDNEW_LINE\"); else System . out . println ( \"NOT ACCEPTEDNEW_LINE\"); } }"}
{"text":"Java implementation of the above approach .","code":"import java . util . * ; class GFG { static int [ ] parent = new int [ 26 ] ;"}
{"text":"Function for find from Disjoint set algorithm","code":"static int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; }"}
{"text":"Function for the union from Disjoint set algorithm","code":"static void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } }"}
{"text":"Function to check if one String can be converted to another .","code":"static boolean convertible ( String s1 , String s2 ) {"}
{"text":"All the characters are checked whether it 's either not replaced or replaced  by a similar character using a map.","code":"HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ! mp . containsKey ( s1 . charAt ( i ) - ' a ' ) ) { mp . put ( s1 . charAt ( i ) - ' a ' , s2 . charAt ( i ) - ' a ' ) ; } else { if ( mp . get ( s1 . charAt ( i ) - ' a ' ) != s2 . charAt ( i ) - ' a ' ) return false ; } }"}
{"text":"To check if there are cycles . If yes , then they are not convertible . Else , they are convertible .","code":"for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( it . getKey ( ) == it . getValue ( ) ) continue ; else { if ( find ( it . getKey ( ) ) == find ( it . getValue ( ) ) ) return false ; else join ( it . getKey ( ) , it . getValue ( ) ) ; } } return true ; }"}
{"text":"Function to initialize parent array for union and find algorithm .","code":"static void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s1 , s2 ; s1 = \" abbcaa \" ; s2 = \" bccdbb \" ; initialize ( ) ; if ( convertible ( s1 , s2 ) ) System . out . print ( \" Yes \" + \"NEW_LINE\"); else System . out . print ( \" No \" + \"NEW_LINE\"); } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int SIZE = 26 ;"}
{"text":"Function to create Sieve to check primes","code":"static void SieveOfEratosthenes ( boolean [ ] prime , int p_size ) {"}
{"text":"false here indicates that it is not prime","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p , set them to non - prime","code":"for ( int i = p * 2 ; i < p_size ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to print the prime frequency characters in the order of their occurrence","code":"static void printChar ( String str , int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ;"}
{"text":"Function to create Sieve to check primes","code":"SieveOfEratosthenes ( prime , str . length ( ) + 1 ) ;"}
{"text":"To store the frequency of each of the character of the string","code":"int [ ] freq = new int [ SIZE ] ;"}
{"text":"Initialize all elements of freq [ ] to 0","code":"for ( int i = 0 ; i < SIZE ; i ++ ) freq [ i ] = 0 ;"}
{"text":"Update the frequency of each character","code":"for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Traverse str character by character","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If frequency of current character is prime","code":"if ( prime [ freq [ str . charAt ( i ) - ' a ' ] ] ) { System . out . print ( str . charAt ( i ) ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; } }"}
{"text":"Java code for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to check primes","code":"static boolean prime ( int n ) { if ( n <= 1 ) return false ; int max_div = ( int ) Math . floor ( Math . sqrt ( n ) ) ; for ( int i = 2 ; i < 1 + max_div ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void checkString ( String s ) {"}
{"text":"Counting the frequency of all character using Counter function","code":"Map < Character , Integer > freq = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! freq . containsKey ( s . charAt ( i ) ) ) freq . put ( s . charAt ( i ) , 0 ) ; freq . put ( s . charAt ( i ) , freq . get ( s . charAt ( i ) ) + 1 ) ; }"}
{"text":"Traversing string","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( prime ( freq . get ( s . charAt ( i ) ) ) ) System . out . print ( s . charAt ( i ) ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ;"}
{"text":"Passing string to checkString function","code":"checkString ( s ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int SIZE = 26 ;"}
{"text":"Function to print the even frequency characters in the order of their occurrence","code":"static void printChar ( String str , int n ) {"}
{"text":"To store the frequency of each of the character of the string","code":"int [ ] freq = new int [ SIZE ] ;"}
{"text":"Update the frequency of each character","code":"for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Traverse str character by character","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If frequency of current character is even","code":"if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 0 ) { System . out . print ( str . charAt ( i ) ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check alphanumeric equality of both strings","code":"static boolean CompareAlphanumeric ( char [ ] str1 , char [ ] str2 ) {"}
{"text":"variable declaration","code":"int i , j ; i = 0 ; j = 0 ;"}
{"text":"Length of first string","code":"int len1 = str1 . length ;"}
{"text":"Length of second string","code":"int len2 = str2 . length ;"}
{"text":"To check each and every characters of both string","code":"while ( i <= len1 && j <= len2 ) {"}
{"text":"If the current character of the first string is not an alphanumeric character , increase the pointer i","code":"while ( i < len1 && ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; }"}
{"text":"If the current character of the second string is not an alphanumeric character , increase the pointer j","code":"while ( j < len2 && ( ! ( ( str2 [ j ] >= ' a ' && str2 [ j ] <= ' z ' ) || ( str2 [ j ] >= ' A ' && str2 [ j ] <= ' Z ' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; }"}
{"text":"if all alphanumeric characters of both strings are same then return true","code":"if ( i == len1 && j == len2 ) { return true ; }"}
{"text":"if any alphanumeric characters of both strings are not same then return false","code":"else if ( str1 [ i ] != str2 [ j ] ) { return false ; }"}
{"text":"If current character matched , increase both pointers to check the next character","code":"else { i ++ ; j ++ ; } }"}
{"text":"If not same , then return false","code":"return false ; }"}
{"text":"Function to print Equal or Unequal if strings are same or not","code":"static void CompareAlphanumericUtil ( String str1 , String str2 ) { boolean res ;"}
{"text":"check alphanumeric equality of both strings","code":"res = CompareAlphanumeric ( str1 . toCharArray ( ) , str2 . toCharArray ( ) ) ;"}
{"text":"if both are alphanumeric equal , print Equal","code":"if ( res == true ) { System . out . println ( \" Equal \" ) ; }"}
{"text":"otherwise print Unequal","code":"else { System . out . println ( \" Unequal \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Ram , \u2581 Shyam \" ; str2 = \" \u2581 Ram \u2581 - \u2581 Shyam . \" ; CompareAlphanumericUtil ( str1 , str2 ) ; str1 = \" abc123\" ; str2 = \"123abc \" ; CompareAlphanumericUtil ( str1 , str2 ) ; } }"}
{"text":"Java program to find the sum of the addition of all possible subsets .","code":"class GFG {"}
{"text":"Function that answers all the queries","code":"static void solveQueries ( String str , int [ ] [ ] query ) {"}
{"text":"Length of the string","code":"int len = str . length ( ) ;"}
{"text":"Number of queries","code":"int Q = query . length ;"}
{"text":"Prefix array","code":"int [ ] [ ] pre = new int [ len ] [ 26 ] ;"}
{"text":"Iterate for all the characters","code":"for ( int i = 0 ; i < len ; i ++ ) {"}
{"text":"Increase the count of the character","code":"pre [ i ] [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Presum array for all 26 characters","code":"if ( i > 0 ) {"}
{"text":"Update the prefix array","code":"for ( int j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } }"}
{"text":"Answer every query","code":"for ( int i = 0 ; i < Q ; i ++ ) {"}
{"text":"Range","code":"int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int maxi = 0 ; char c = ' a ' ;"}
{"text":"Iterate for all characters","code":"for ( int j = 0 ; j < 26 ; j ++ ) {"}
{"text":"Times the lowercase character j occurs till r - th index","code":"int times = pre [ r ] [ j ] ;"}
{"text":"Subtract the times it occurred till ( l - 1 ) th index","code":"if ( l > 0 ) times -= pre [ l - 1 ] [ j ] ;"}
{"text":"Max times it occurs","code":"if ( times > maxi ) { maxi = times ; c = ( char ) ( ' a ' + j ) ; } }"}
{"text":"Print the answer","code":"System . out . println ( \" Query \" + ( i + 1 ) + \" : \u2581 \" + c ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" striver \" ; int [ ] [ ] query = { { 0 , 1 } , { 1 , 6 } , { 5 , 6 } } ; solveQueries ( str , query ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that return true if pre is a prefix of str","code":"static boolean startsWith ( String str , String pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 , j = 0 ;"}
{"text":"While there are characters to match","code":"while ( i < strLen && j < preLen ) {"}
{"text":"If characters differ at any position","code":"if ( str . charAt ( i ) != pre . charAt ( j ) ) return false ; i ++ ; j ++ ; }"}
{"text":"str starts with pre","code":"return true ; }"}
{"text":"Function that return true if suff is a suffix of str","code":"static boolean endsWith ( String str , String suff ) { int i = str . length ( ) - 1 ; int j = suff . length ( ) - 1 ;"}
{"text":"While there are characters to match","code":"while ( i >= 0 && j >= 0 ) {"}
{"text":"If characters differ at any position","code":"if ( str . charAt ( i ) != suff . charAt ( j ) ) return false ; i -- ; j -- ; }"}
{"text":"str ends with suff","code":"return true ; }"}
{"text":"Function that returns true if str = a + b or str = b + a","code":"static boolean checkString ( String str , String a , String b ) {"}
{"text":"str cannot be generated by concatenating a and b","code":"if ( str . length ( ) != a . length ( ) + b . length ( ) ) return false ;"}
{"text":"If str starts with a i . e . a is a prefix of str","code":"if ( startsWith ( str , a ) ) {"}
{"text":"Check if the rest of the characters are equal to b i . e . b is a suffix of str","code":"if ( endsWith ( str , b ) ) return true ; }"}
{"text":"If str starts with b i . e . b is a prefix of str","code":"if ( startsWith ( str , b ) ) {"}
{"text":"Check if the rest of the characters are equal to a i . e . a is a suffix of str","code":"if ( endsWith ( str , a ) ) return true ; } return false ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String str = \" GeeksforGeeks \" ; String a = \" Geeksfo \" ; String b = \" rGeeks \" ; if ( checkString ( str , a , b ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to print the odd frequency characters in the order of their occurrence","code":"public static void printChar ( String str , int n ) {"}
{"text":"To store the frequency of each of the character of the string","code":"int [ ] freq = new int [ 26 ] ;"}
{"text":"Update the frequency of each character","code":"for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Traverse str character by character","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If frequency of current character is odd","code":"if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the minimum number of operations required","code":"static int minOperations ( String str , int n ) {"}
{"text":"To store the indices of the last uppercase and the first lowercase character","code":"int i , lastUpper = - 1 , firstLower = - 1 ;"}
{"text":"Find the last uppercase character","code":"for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { lastUpper = i ; break ; } }"}
{"text":"Find the first lowercase character","code":"for ( i = 0 ; i < n ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { firstLower = i ; break ; } }"}
{"text":"If all the characters are either uppercase or lowercase","code":"if ( lastUpper == - 1 firstLower == - 1 ) return 0 ;"}
{"text":"Count of uppercase characters that appear after the first lowercase character","code":"int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { countUpper ++ ; } }"}
{"text":"Count of lowercase characters that appear before the last uppercase character","code":"int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { countLower ++ ; } }"}
{"text":"Return the minimum operations required","code":"return Math . min ( countLower , countUpper ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { String str = \" geEksFOrGEekS \" ; int n = str . length ( ) ; System . out . println ( minOperations ( str , n ) ) ; } }"}
{"text":"Java program to find the sum of the all betrothed numbers up to N","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the sum of the all betrothed numbers","code":"public static int Betrothed_Sum ( int n ) {"}
{"text":"To store the betrothed numbers","code":"Vector < Integer > Set = new Vector < Integer > ( ) ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) {"}
{"text":"Calculate sum of number_1 's divisors   1 is always a divisor","code":"int sum_divisor_1 = 1 ;"}
{"text":"i = 2 because we don 't   want to include   1 as a divisor.","code":"int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 \/ i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 \/ j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 && number_1 <= n && number_2 <= n ) { Set . add ( number_1 ) ; Set . add ( number_2 ) ; } } }"}
{"text":"Sum all betrothed numbers up to N","code":"int Summ = 0 ; for ( int i = 0 ; i < Set . size ( ) ; i ++ ) { if ( Set . get ( i ) <= n ) Summ += Set . get ( i ) ; } return Summ ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 78 ; System . out . println ( Betrothed_Sum ( n ) ) ; } }"}
{"text":"Java code to find the probability of rain on n + 1 - th day when previous day 's data is given","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the probability","code":"static float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ;"}
{"text":"count 1","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; }"}
{"text":"find probability","code":"m = count \/ n ; return m ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int a [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = a . length ; System . out . print ( rainDayProbability ( a , n ) ) ; } }"}
{"text":"Java program to calculate the following series","code":"import java . io . * ; class Maths {"}
{"text":"Function to calculate the following series","code":"static double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 \/ Math . pow ( i , i ) ; sums += ser ; } return sums ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 ; double res = Series ( n ) ; res = Math . round ( res * 100000.0 ) \/ 100000.0 ; System . out . println ( res ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class Main {"}
{"text":"Function to print the lexicographically the largest string obtained in process of obtaining a string containing first N lower case english alphabtes","code":"static String lexicographicallyMaximum ( String S , int N ) {"}
{"text":"Store the frequency of each character","code":"HashMap < Character , Integer > M = new HashMap < > ( ) ;"}
{"text":"Traverse the string S","code":"for ( int i = 0 ; i < N ; ++ i ) { if ( M . containsKey ( S . charAt ( i ) ) ) M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) + 1 ) ; else M . put ( S . charAt ( i ) , 1 ) ; }"}
{"text":"Stores the characters which are not appearing in S","code":"Vector < Character > V = new Vector < Character > ( ) ; for ( char i = ' a ' ; i < ( char ) ( ' a ' + Math . min ( N , 25 ) ) ; ++ i ) { if ( M . containsKey ( i ) == false ) { V . add ( i ) ; } }"}
{"text":"Stores the index of the largest character in the array V , that need to be replaced","code":"int j = V . size ( ) - 1 ;"}
{"text":"Traverse the string , S","code":"for ( int i = 0 ; i < N ; ++ i ) {"}
{"text":"If frequency of S [ i ] is greater than 1 or it is outside the range","code":"if ( S . charAt ( i ) >= ( ' a ' + Math . min ( N , 25 ) ) || ( M . containsKey ( S . charAt ( i ) ) && M . get ( S . charAt ( i ) ) > 1 ) ) { if ( V . get ( j ) < S . charAt ( i ) ) continue ;"}
{"text":"Decrement its frequency by 1","code":"M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) - 1 ) ;"}
{"text":"Update S [ i ]","code":"S = S . substring ( 0 , i ) + V . get ( j ) + S . substring ( i + 1 ) ;"}
{"text":"Decrement j by 1","code":"j -- ; } if ( j < 0 ) break ; } int l = 0 ;"}
{"text":"Traverse the string , S","code":"for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S . charAt ( i ) >= ( ' a ' + Math . min ( N , 25 ) ) || M . containsKey ( S . charAt ( i ) ) && M . get ( S . charAt ( i ) ) > 1 ) {"}
{"text":"Decrement its frequency by 1","code":"M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) - 1 ) ;"}
{"text":"Update S [ i ]","code":"S = S . substring ( 0 , i ) + V . get ( l ) + S . substring ( i + 1 ) ;"}
{"text":"Increment l by 1","code":"l ++ ; } }"}
{"text":"Return S","code":"return S ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"String S = \" abccefghh \" ; int N = S . length ( ) ;"}
{"text":"Function Call","code":"System . out . println ( lexicographicallyMaximum ( S , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"A Utility Function to check if a subarray can be palindromic by replacing less than half of the elements present in it","code":"static boolean isConsistingSubarrayUtil ( int arr [ ] , int n ) {"}
{"text":"Stores frequency of array elements","code":"TreeMap < Integer , Integer > mp = new TreeMap < Integer , Integer > ( ) ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; ++ i ) {"}
{"text":"Update frequency of each array element","code":"mp . put ( arr [ i ] , mp . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; }"}
{"text":"Iterator over the Map","code":"for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {"}
{"text":"If frequency of any element exceeds 1","code":"if ( it . getValue ( ) > 1 ) { return true ; } }"}
{"text":"If no repetition is found","code":"return false ; }"}
{"text":"Function to check and print if any subarray can be made palindromic by replacing less than half of its elements","code":"static void isConsistingSubarray ( int arr [ ] , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 1 } ;"}
{"text":"Size of array","code":"int N = arr . length ;"}
{"text":"Function Call","code":"isConsistingSubarray ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { static boolean [ ] isPrime ;"}
{"text":"Function to find all Fibonacci numbers up to Max","code":"static HashSet < Integer > createhashmap ( int Max ) {"}
{"text":"Store all Fibonacci numbers upto Max","code":"HashSet < Integer > hashmap = new HashSet < > ( ) ;"}
{"text":"Stores previous element of Fibonacci sequence","code":"int curr = 1 ;"}
{"text":"Stores previous element of Fibonacci sequence","code":"int prev = 0 ;"}
{"text":"Insert prev into hashmap","code":"hashmap . add ( prev ) ;"}
{"text":"Insert all the Fibonacci numbers up to Max","code":"while ( curr < Max ) {"}
{"text":"Insert curr into hashmap","code":"hashmap . add ( curr ) ;"}
{"text":"Stores curr into temp","code":"int temp = curr ;"}
{"text":"Update curr","code":"curr = curr + prev ;"}
{"text":"Update prev","code":"prev = temp ; } return hashmap ; }"}
{"text":"Function to find all Composite numbers up to Max","code":"static void SieveOfEratosthenes ( int Max ) {"}
{"text":"isPrime [ i ] : Stores if i is a prime number or not","code":"isPrime = new boolean [ Max ] ; Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ;"}
{"text":"Calculate all prime numbers up to Max using Sieve of Eratosthenes","code":"for ( int p = 2 ; p * p <= Max ; p ++ ) {"}
{"text":"If P is a prime number","code":"if ( isPrime [ p ] ) {"}
{"text":"Set all multiple of P as non - prime","code":"for ( int i = p * p ; i <= Max ; i += p ) {"}
{"text":"Update isPrime","code":"isPrime [ i ] = false ; } } } }"}
{"text":"Function to find the numbers which is both a composite and Fibonacci number","code":"static void cntFibonacciPrime ( int arr [ ] , int N ) {"}
{"text":"Stores the largest element of the array","code":"int Max = arr [ 0 ] ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"Update Max","code":"Max = Math . max ( Max , arr [ i ] ) ; }"}
{"text":"isPrim [ i ] check i is a prime number or not","code":"SieveOfEratosthenes ( Max ) ;"}
{"text":"Stores all the Fibonacci numbers","code":"HashSet < Integer > hashmap = createhashmap ( Max ) ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"current element is not a composite number","code":"if ( arr [ i ] == 1 ) continue ;"}
{"text":"If current element is a Fibonacci and composite number","code":"if ( ( hashmap . contains ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) {"}
{"text":"Print current element","code":"System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 } ; int N = arr . length ; cntFibonacciPrime ( arr , N ) ; } }"}
{"text":"Java program of the above approach","code":"import java . io . * ; import java . util . * ; import java . lang . * ; public class Main {"}
{"text":"Function to find the key of the given number","code":"static int key ( int N ) {"}
{"text":"Convert the integer to String","code":"String num = \" \" + N ; int ans = 0 ; int j = 0 ;"}
{"text":"Iterate the num - string to get the result","code":"for ( j = 0 ; j < num . length ( ) ; j ++ ) {"}
{"text":"Check if digit is even or odd","code":"if ( ( num . charAt ( j ) - 48 ) % 2 == 0 ) { int add = 0 ; int i ;"}
{"text":"Iterate until odd sum is obtained by adding consecutive digits","code":"for ( i = j ; j < num . length ( ) ; j ++ ) { add += num . charAt ( j ) - 48 ;"}
{"text":"Check if sum becomes odd","code":"if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= ( Math . pow ( 10 , digit ) ) ;"}
{"text":"Add the result in ans","code":"ans += add ; }"}
{"text":"Assign the digit index to num string","code":"i = j ; } else {"}
{"text":"If the number is odd","code":"int add = 0 ; int i ;"}
{"text":"Iterate until odd sum is obtained by adding consecutive digits","code":"for ( i = j ; j < num . length ( ) ; j ++ ) { add += num . charAt ( j ) - 48 ;"}
{"text":"Check if sum becomes even","code":"if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= ( Math . pow ( 10 , digit ) ) ;"}
{"text":"Add the result in ans","code":"ans += add ; }"}
{"text":"assign the digit index to main numstring","code":"i = j ; } }"}
{"text":"Check if all digits are visited or not","code":"if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num . charAt ( num . length ( ) - 1 ) - 48 ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 1667848271 ; System . out . print ( key ( N ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to search x in the given array","code":"static void sentinelSearch ( int arr [ ] , int n , int key ) {"}
{"text":"Last element of the array","code":"int last = arr [ n - 1 ] ;"}
{"text":"Element to be searched is placed at the last index","code":"arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ;"}
{"text":"Put the last element back","code":"arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) System . out . println ( key + \" \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" + i ) ; else System . out . println ( \" Element \u2581 Not \u2581 found \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 } ; int n = arr . length ; int key = 180 ; sentinelSearch ( arr , n , key ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate maximum possible middle value of the array after deleting exactly k elements","code":"static int maximum_middle_value ( int n , int k , int arr [ ] ) {"}
{"text":"Initialize answer as - 1","code":"int ans = - 1 ;"}
{"text":"Calculate range of elements that can give maximum possible middle value of the array since index of maximum possible middle value after deleting exactly k elements from array will lie in between low and high","code":"int low = ( n + 1 - k ) \/ 2 ; int high = ( n + 1 - k ) \/ 2 + k ;"}
{"text":"Find maximum element of the array in range low and high","code":"for ( int i = low ; i <= high ; i ++ ) {"}
{"text":"since indexing is 1 based so check element at index i - 1","code":"ans = Math . max ( ans , arr [ i - 1 ] ) ; }"}
{"text":"Return the maximum possible middle value of the array after deleting exactly k elements from the array","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr ) ) ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr1 ) ) ; } }"}
{"text":"Java program to illustrate recursive approach to ternary search","code":"class GFG {"}
{"text":"Function to perform Ternary Search","code":"static int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) {"}
{"text":"Find the mid1 and mid2","code":"int mid1 = l + ( r - l ) \/ 3 ; int mid2 = r - ( r - l ) \/ 3 ;"}
{"text":"Check if key is present at any mid","code":"if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }"}
{"text":"Since key is not present at mid , check in which region it is present then repeat the Search operation in that region","code":"if ( key < ar [ mid1 ] ) {"}
{"text":"The key lies in between l and mid1","code":"return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) {"}
{"text":"The key lies in between mid2 and r","code":"return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else {"}
{"text":"The key lies in between mid1 and mid2","code":"return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } }"}
{"text":"Key not found","code":"return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int l , r , p , key ;"}
{"text":"Get the array Sort the array if not sorted","code":"int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ;"}
{"text":"Starting index","code":"l = 0 ;"}
{"text":"length of array","code":"r = 9 ;"}
{"text":"Key to be searched in the array","code":"key = 5 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ;"}
{"text":"Key to be searched in the array","code":"key = 50 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ; } }"}
{"text":"Java program to find minimum points to be moved so that all points are on same side .","code":"import java . util . * ; class GFG {"}
{"text":"Structure to store the coordinates of a point .","code":"static class Point { int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } } ;"}
{"text":"Function to find the minimum number of points","code":"static int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Number of points on the left of Y - axis .","code":"if ( p [ i ] . x <= 0 ) a ++ ;"}
{"text":"Number of points on the right of Y - axis .","code":"else if ( p [ i ] . x >= 0 ) b ++ ;"}
{"text":"Number of points above X - axis .","code":"if ( p [ i ] . y >= 0 ) c ++ ;"}
{"text":"Number of points below X - axis .","code":"else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { Point p [ ] = { new Point ( 1 , 1 ) , new Point ( 2 , 2 ) , new Point ( - 1 , - 1 ) , new Point ( - 2 , 2 ) } ; int n = p . length ; System . out . println ( findmin ( p , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the maximum number of pair reductions possible on a given triplet","code":"static void maxOps ( int a , int b , int c ) {"}
{"text":"Convert them into an array","code":"int arr [ ] = { a , b , c } ;"}
{"text":"Stores count of operations","code":"int count = 0 ; while ( 1 != 0 ) {"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"If the first two array elements reduce to 0","code":"if ( arr [ 0 ] == 0 && arr [ 1 ] == 0 ) break ;"}
{"text":"Apply the operations","code":"arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ;"}
{"text":"Increment count","code":"count += 1 ; }"}
{"text":"Print the maximum count","code":"System . out . print ( count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given triplet","code":"int a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . lang . Character ; class GFG { static int MAX = 26 ; public static String getSortedString ( StringBuilder s , int n ) {"}
{"text":"To store the frequencies of the lowercase and the uppercase characters in the given string","code":"int [ ] lower = new int [ MAX ] ; int [ ] upper = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If current character is lowercase then increment its frequency in the lower [ ] array","code":"if ( Character . isLowerCase ( s . charAt ( i ) ) ) lower [ s . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Else increment in the upper [ ] array","code":"else if ( Character . isUpperCase ( s . charAt ( i ) ) ) upper [ s . charAt ( i ) - ' A ' ] ++ ; }"}
{"text":"Pointers that point to the smallest lowercase and the smallest uppercase characters respectively in the given string","code":"int i = 0 , j = 0 ; while ( i < MAX && lower [ i ] == 0 ) i ++ ; while ( j < MAX && upper [ j ] == 0 ) j ++ ;"}
{"text":"For every character in the given string","code":"for ( int k = 0 ; k < n ; k ++ ) {"}
{"text":"If the current character is lowercase then replace it with the smallest lowercase character available","code":"if ( Character . isLowerCase ( s . charAt ( k ) ) ) { while ( lower [ i ] == 0 ) i ++ ; s . setCharAt ( k , ( char ) ( i + ' a ' ) ) ;"}
{"text":"Decrement the frequency of the used character","code":"lower [ i ] -- ; }"}
{"text":"Else replace it with the smallest uppercase character available","code":"else if ( Character . isUpperCase ( s . charAt ( k ) ) ) { while ( upper [ j ] == 0 ) j ++ ; s . setCharAt ( k , ( char ) ( j + ' A ' ) ) ;"}
{"text":"Decrement the frequency of the used character","code":"upper [ j ] -- ; } }"}
{"text":"Return the sorted string","code":"return s . toString ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( \" gEeksfOrgEEkS \" ) ; int n = s . length ( ) ; System . out . println ( getSortedString ( s , n ) ) ; } }"}
{"text":"Java implementation to print the character and its frequency in order of its occurrence","code":"public class Char_frequency { static final int SIZE = 26 ;"}
{"text":"function to print the character and its frequency in order of its occurrence","code":"static void printCharWithFreq ( String str ) {"}
{"text":"size of the string ' str '","code":"int n = str . length ( ) ;"}
{"text":"' freq [ ] ' implemented as hash table","code":"int [ ] freq = new int [ SIZE ] ;"}
{"text":"accumulate frequency of each character in ' str '","code":"for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"traverse ' str ' from left to right","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"if frequency of character str . charAt ( i ) is not equal to 0","code":"if ( freq [ str . charAt ( i ) - ' a ' ] != 0 ) {"}
{"text":"print the character along with its frequency","code":"System . out . print ( str . charAt ( i ) ) ; System . out . print ( freq [ str . charAt ( i ) - ' a ' ] + \" \u2581 \" ) ;"}
{"text":"update frequency of str . charAt ( i ) to 0 so that the same character is not printed again","code":"freq [ str . charAt ( i ) - ' a ' ] = 0 ; } } }"}
{"text":"Driver program to test above","code":"public static void main ( String args [ ] ) { String str = \" geeksforgeeks \" ; printCharWithFreq ( str ) ; } }"}
{"text":"Java program to reverse a string s = input ( )","code":"public class ReverseWords { public static void main ( String [ ] args ) { String s [ ] = \" i \u2581 like \u2581 this \u2581 program \u2581 very \u2581 much \" . split ( \" \u2581 \" ) ; String ans = \" \" ; for ( int i = s . length - 1 ; i >= 0 ; i -- ) { ans += s [ i ] + \" \u2581 \" ; } System . out . println ( \" Reversed \u2581 String : \" ) ; System . out . println ( ans . substring ( 0 , ans . length ( ) - 1 ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to generate prime numbers using Sieve of Eratosthenes","code":"public static void SieveOfEratosthenes ( boolean [ ] prime , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is unchanged , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to segregate the primes and non - primes","code":"public static void segregatePrimeNonPrime ( boolean [ ] prime , int arr [ ] , int N ) {"}
{"text":"Generate all primes till 10 ^","code":"SieveOfEratosthenes ( prime , 10000000 ) ;"}
{"text":"Initialize left and right","code":"int left = 0 , right = N - 1 ;"}
{"text":"Traverse the array","code":"while ( left < right ) {"}
{"text":"Increment left while array element at left is prime","code":"while ( prime [ arr [ left ] ] ) left ++ ;"}
{"text":"Decrement right while array element at right is non - prime","code":"while ( ! prime [ arr [ right ] ] ) right -- ;"}
{"text":"If left < right , then swap arr [ left ] and arr [ right ]","code":"if ( left < right ) {"}
{"text":"Swap arr [ left ] and arr [ right ]","code":"int temp = arr [ left ] ; arr [ left ] = arr [ right ] ; arr [ right ] = temp ; left ++ ; right -- ; } }"}
{"text":"Print segregated array","code":"for ( int i = 0 ; i < N ; i ++ ) System . out . printf ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { boolean [ ] prime = new boolean [ 10000001 ] ; Arrays . fill ( prime , true ) ; int arr [ ] = { 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 } ; int N = arr . length ;"}
{"text":"Function Call","code":"segregatePrimeNonPrime ( prime , arr , N ) ; } }"}
{"text":"Java program to find height of full binary tree using preorder","code":"import java . io . * ; class GFG {"}
{"text":"function to return max of left subtree height or right subtree height","code":"static int findDepthRec ( String tree , int n , int index ) { if ( index >= n || tree . charAt ( index ) == ' l ' ) return 0 ;"}
{"text":"calc height of left subtree ( In preorder left subtree is processed before right )","code":"index ++ ; int left = findDepthRec ( tree , n , index ) ;"}
{"text":"calc height of right subtree","code":"index ++ ; int right = findDepthRec ( tree , n , index ) ; return Math . max ( left , right ) + 1 ; }"}
{"text":"Wrapper over findDepthRec ( )","code":"static int findDepth ( String tree , int n ) { int index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; }"}
{"text":"Driver Code","code":"static public void main ( String [ ] args ) { String tree = \" nlnnlll \" ; int n = tree . length ( ) ; System . out . println ( findDepth ( tree , n ) ) ; } }"}
{"text":"Java code to find the largest value smaller than or equal to N","code":"class GfG {"}
{"text":"Node structure","code":"static class Node { int key ; Node left , right ; }"}
{"text":"To create new BST Node","code":"static Node newNode ( int item ) { Node temp = new Node ( ) ; temp . key = item ; temp . left = null ; temp . right = null ; return temp ; }"}
{"text":"To insert a new node in BST","code":"static Node insert ( Node node , int key ) {"}
{"text":"if tree is empty return new node","code":"if ( node == null ) return newNode ( key ) ;"}
{"text":"if key is less then or greater then node value then recur down the tree","code":"if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ;"}
{"text":"return the ( unchanged ) node pointer","code":"return node ; }"}
{"text":"function to find max value less then N","code":"static int findMaxforN ( Node root , int N ) {"}
{"text":"Base cases","code":"if ( root == null ) return - 1 ; if ( root . key == N ) return N ;"}
{"text":"If root 's value is smaller, try in right  subtree","code":"else if ( root . key < N ) { int k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; }"}
{"text":"If root 's key is greater, return value  from left subtree.","code":"else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 ;"}
{"text":"creating following BST 5 \/ \\ 2 12 \/ \\ \/ \\ 1 3 9 21 \/ \\ 19 25","code":"Node root = null ; root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; System . out . println ( findMaxforN ( root , N ) ) ; } }"}
{"text":"Java program to find maximum element in the path between two Nodes of Binary Search Tree .","code":"class Solution { static class Node { Node left , right ; int data ; }"}
{"text":"Create and return a pointer of new Node .","code":"static Node createNode ( int x ) { Node p = new Node ( ) ; p . data = x ; p . left = p . right = null ; return p ; }"}
{"text":"Insert a new Node in Binary Search Tree .","code":"static void insertNode ( Node root , int x ) { Node p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } }"}
{"text":"Return the maximum element between a Node and its given ancestor .","code":"static int maxelpath ( Node q , int x ) { Node p = q ; int mx = - 1 ;"}
{"text":"Traversing the path between ansector and Node and finding maximum element .","code":"while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; }"}
{"text":"Return maximum element in the path between two given Node of BST .","code":"static int maximumElement ( Node root , int x , int y ) { Node p = root ;"}
{"text":"Finding the LCA of Node x and Node y","code":"while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) {"}
{"text":"Checking if both the Node lie on the left side of the parent p .","code":"if ( x < p . data && y < p . data ) p = p . left ;"}
{"text":"Checking if both the Node lie on the right side of the parent p .","code":"else if ( x > p . data && y > p . data ) p = p . right ; }"}
{"text":"Return the maximum of maximum elements occur in path from ancestor to both Node .","code":"return Math . max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = arr . length ;"}
{"text":"Creating the root of Binary Search Tree","code":"Node root = createNode ( arr [ 0 ] ) ;"}
{"text":"Inserting Nodes in Binary Search Tree","code":"for ( int i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; System . out . println ( maximumElement ( root , a , b ) ) ; } }"}
{"text":"Java program Insertion in Threaded Binary Search Tree .","code":"import java . util . * ; class solution { static class Node { Node left , right ; int info ;"}
{"text":"True if left pointer points to predecessor in Inorder Traversal","code":"boolean lthread ;"}
{"text":"True if right pointer points to successor in Inorder Traversal","code":"boolean rthread ; } ;"}
{"text":"Insert a Node in Binary Threaded Tree","code":"static Node insert ( Node root , int ikey ) {"}
{"text":"Searching for a Node with given value","code":"Node ptr = root ;"}
{"text":"Parent of key to be inserted","code":"Node par = null ; while ( ptr != null ) {"}
{"text":"If key already exists , return","code":"if ( ikey == ( ptr . info ) ) { System . out . printf ( \"Duplicate Key !NEW_LINE\"); return root ; }"}
{"text":"Update parent pointer","code":"par = ptr ;"}
{"text":"Moving on left subtree .","code":"if ( ikey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; }"}
{"text":"Moving on right subtree .","code":"else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } }"}
{"text":"Create a new node","code":"Node tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; }"}
{"text":"Returns inorder successor using rthread","code":"static Node inorderSuccessor ( Node ptr ) {"}
{"text":"If rthread is set , we can quickly find","code":"if ( ptr . rthread == true ) return ptr . right ;"}
{"text":"Else return leftmost child of right subtree","code":"ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; }"}
{"text":"Printing the threaded tree","code":"static void inorder ( Node root ) { if ( root == null ) System . out . printf ( \" Tree \u2581 is \u2581 empty \" ) ;"}
{"text":"Reach leftmost node","code":"Node ptr = root ; while ( ptr . lthread == false ) ptr = ptr . left ;"}
{"text":"One by one print successors","code":"while ( ptr != null ) { System . out . printf ( \" % d \u2581 \" , ptr . info ) ; ptr = inorderSuccessor ( ptr ) ; } }"}
{"text":"Driver Program","code":"public static void main ( String [ ] args ) { Node root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ; } }"}
{"text":"True if left pointer points to predecessor in Inorder Traversal","code":"boolean lthread ;"}
{"text":"True if right pointer points to predecessor in Inorder Traversal","code":"boolean rthread ; } ;"}
{"text":"Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node .","code":"Node caseA ( Node root , Node par , Node ptr ) {"}
{"text":"If Node to be deleted is root","code":"if ( par == null ) root = null ;"}
{"text":"If Node to be deleted is left of its parent","code":"else if ( ptr == par . left ) { par . lthread = true ; par . left = ptr . left ; } else { par . rthread = true ; par . right = ptr . right ; } return root ; }"}
{"text":"Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node .","code":"static Node caseB ( Node root , Node par , Node ptr ) { Node child ;"}
{"text":"Initialize child Node to be deleted has left child .","code":"if ( ptr . lthread == false ) child = ptr . left ;"}
{"text":"Node to be deleted has right child .","code":"else child = ptr . right ;"}
{"text":"Node to be deleted is root Node .","code":"if ( par == null ) root = child ;"}
{"text":"Node is left child of its parent .","code":"else if ( ptr == par . left ) par . left = child ; else par . right = child ;"}
{"text":"Find successor and predecessor","code":"Node s = inSucc ( ptr ) ; Node p = inPred ( ptr ) ;"}
{"text":"If ptr has left subtree .","code":"if ( ptr . lthread == false ) p . right = s ;"}
{"text":"If ptr has right subtree .","code":"else { if ( ptr . rthread == false ) s . left = p ; } return root ; }"}
{"text":"Complete Java program to demonstrate deletion in threaded BST","code":"import java . util . * ; class solution { static class Node { Node left , right ; int info ;"}
{"text":"True if left pointer points to predecessor in Inorder Traversal","code":"boolean lthread ;"}
{"text":"True if right pointer points to predecessor in Inorder Traversal","code":"boolean rthread ; } ;"}
{"text":"Insert a Node in Binary Threaded Tree","code":"static Node insert ( Node root , int ikey ) {"}
{"text":"Searching for a Node with given value","code":"Node ptr = root ;"}
{"text":"Parent of key to be inserted","code":"Node par = null ; while ( ptr != null ) {"}
{"text":"If key already exists , return","code":"if ( ikey == ( ptr . info ) ) { System . out . printf ( \"Duplicate Key !NEW_LINE\"); return root ; }"}
{"text":"Update parent pointer","code":"par = ptr ;"}
{"text":"Moving on left subtree .","code":"if ( ikey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; }"}
{"text":"Moving on right subtree .","code":"else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } }"}
{"text":"Create a new Node","code":"Node tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; }"}
{"text":"Returns inorder successor using left and right children ( Used in deletion )","code":"static Node inSucc ( Node ptr ) { if ( ptr . rthread == true ) return ptr . right ; ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; }"}
{"text":"Returns inorder successor using rthread ( Used in inorder )","code":"static Node inorderSuccessor ( Node ptr ) {"}
{"text":"If rthread is set , we can quickly find","code":"if ( ptr . rthread == true ) return ptr . right ;"}
{"text":"Else return leftmost child of right subtree","code":"ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; }"}
{"text":"Printing the threaded tree","code":"static void inorder ( Node root ) { if ( root == null ) System . out . printf ( \" Tree \u2581 is \u2581 empty \" ) ;"}
{"text":"Reach leftmost Node","code":"Node ptr = root ; while ( ptr . lthread == false ) ptr = ptr . left ;"}
{"text":"One by one print successors","code":"while ( ptr != null ) { System . out . printf ( \" % d \u2581 \" , ptr . info ) ; ptr = inorderSuccessor ( ptr ) ; } } static Node inPred ( Node ptr ) { if ( ptr . lthread == true ) return ptr . left ; ptr = ptr . left ; while ( ptr . rthread == false ) ptr = ptr . right ; return ptr ; }"}
{"text":"Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node .","code":"static Node caseA ( Node root , Node par , Node ptr ) {"}
{"text":"If Node to be deleted is root","code":"if ( par == null ) root = null ;"}
{"text":"If Node to be deleted is left of its parent","code":"else if ( ptr == par . left ) { par . lthread = true ; par . left = ptr . left ; } else { par . rthread = true ; par . right = ptr . right ; } return root ; }"}
{"text":"Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node .","code":"static Node caseB ( Node root , Node par , Node ptr ) { Node child ;"}
{"text":"Initialize child Node to be deleted has left child .","code":"if ( ptr . lthread == false ) child = ptr . left ;"}
{"text":"Node to be deleted has right child .","code":"else child = ptr . right ;"}
{"text":"Node to be deleted is root Node .","code":"if ( par == null ) root = child ;"}
{"text":"Node is left child of its parent .","code":"else if ( ptr == par . left ) par . left = child ; else par . right = child ;"}
{"text":"Find successor and predecessor","code":"Node s = inSucc ( ptr ) ; Node p = inPred ( ptr ) ;"}
{"text":"If ptr has left subtree .","code":"if ( ptr . lthread == false ) p . right = s ;"}
{"text":"If ptr has right subtree .","code":"else { if ( ptr . rthread == false ) s . left = p ; } return root ; }"}
{"text":"Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node .","code":"static Node caseC ( Node root , Node par , Node ptr ) {"}
{"text":"Find inorder successor and its parent .","code":"Node parsucc = ptr ; Node succ = ptr . right ;"}
{"text":"Find leftmost child of successor","code":"while ( succ . lthread == false ) { parsucc = succ ; succ = succ . left ; } ptr . info = succ . info ; if ( succ . lthread == true && succ . rthread == true ) root = caseA ( root , parsucc , succ ) ; else root = caseB ( root , parsucc , succ ) ; return root ; }"}
{"text":"Deletes a key from threaded BST with given root and returns new root of BST .","code":"static Node delThreadedBST ( Node root , int dkey ) {"}
{"text":"Initialize parent as null and ptrent Node as root .","code":"Node par = null , ptr = root ;"}
{"text":"Set true if key is found","code":"int found = 0 ;"}
{"text":"Search key in BST : find Node and its parent .","code":"while ( ptr != null ) { if ( dkey == ptr . info ) { found = 1 ; break ; } par = ptr ; if ( dkey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; } else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } } if ( found == 0 ) System . out . printf ( \"dkey not present in treeNEW_LINE\");"}
{"text":"Two Children","code":"else if ( ptr . lthread == false && ptr . rthread == false ) root = caseC ( root , par , ptr ) ;"}
{"text":"Only Left Child","code":"else if ( ptr . lthread == false ) root = caseB ( root , par , ptr ) ;"}
{"text":"Only Right Child","code":"else if ( ptr . rthread == false ) root = caseB ( root , par , ptr ) ;"}
{"text":"No child","code":"else root = caseA ( root , par , ptr ) ; return root ; }"}
{"text":"Driver Program","code":"public static void main ( String args [ ] ) { Node root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; root = delThreadedBST ( root , 20 ) ; inorder ( root ) ; } }"}
{"text":"Java program to find if a matrix is symmetric .","code":"import java . io . * ; public class GFG { static void checkHV ( int [ ] [ ] arr , int N , int M ) {"}
{"text":"Initializing as both horizontal and vertical symmetric .","code":"boolean horizontal = true ; boolean vertical = true ;"}
{"text":"Checking for Horizontal Symmetry . We compare first row with last row , second row with second last row and so on .","code":"for ( int i = 0 , k = N - 1 ; i < N \/ 2 ; i ++ , k -- ) {"}
{"text":"Checking each cell of a column .","code":"for ( int j = 0 ; j < M ; j ++ ) {"}
{"text":"check if every cell is identical","code":"if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } }"}
{"text":"Checking for Vertical Symmetry . We compare first column with last column , second xolumn with second last column and so on .","code":"for ( int i = 0 , k = M - 1 ; i < M \/ 2 ; i ++ , k -- ) {"}
{"text":"Checking each cell of a row .","code":"for ( int j = 0 ; j < N ; j ++ ) {"}
{"text":"check if every cell is identical","code":"if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) System . out . println ( \" NO \" ) ; else if ( horizontal && ! vertical ) System . out . println ( \" HORIZONTAL \" ) ; else if ( vertical && ! horizontal ) System . out . println ( \" VERTICAL \" ) ; else System . out . println ( \" BOTH \" ) ; }"}
{"text":"Driver Code","code":"static public void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; } }"}
{"text":"Java program to replace each each element with maximum of GCD of row or column .","code":"import java . io . * ; class GFG { static int R = 3 ; static int C = 4 ;"}
{"text":"returning the greatest common divisor of two number","code":"static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text":"Finding GCD of each row and column and replacing with each element with maximum of GCD of row or column .","code":"static void replacematrix ( int [ ] [ ] mat , int n , int m ) { int [ ] rgcd = new int [ R ] ; int [ ] cgcd = new int [ C ] ;"}
{"text":"Calculating GCD of each row and each column in O ( mn ) and store in arrays .","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } }"}
{"text":"Replacing matrix element","code":"for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rgcd [ i ] , cgcd [ j ] ) ; }"}
{"text":"Driver program","code":"static public void main ( String [ ] args ) { int [ ] [ ] m = { { 1 , 2 , 3 , 3 } , { 4 , 5 , 6 , 6 } , { 7 , 8 , 9 , 9 } , } ; replacematrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( m [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } } }"}
{"text":"Java program for addition of two matrices","code":"class GFG { static final int N = 4 ;"}
{"text":"This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ]","code":"static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; System . out . print ( \"Result matrix is NEW_LINE\"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text":"Java program for subtraction of matrices","code":"class GFG { static final int N = 4 ;"}
{"text":"This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ]","code":"static void subtract ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; System . out . print ( \"Result matrix is NEW_LINE\"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text":"Java program to check fixed point in an array using linear search","code":"class Main { static int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; }"}
{"text":"If no fixed point present then return - 1","code":"return - 1 ; }"}
{"text":"main function","code":"public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( \" Fixed \u2581 Point \u2581 is \u2581 \" + linearSearch ( arr , n ) ) ; } }"}
{"text":"Java program to check fixed point in an array using binary search","code":"class Main { static int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) {"}
{"text":"low + ( high - low ) \/ 2 ;","code":"int mid = ( low + high ) \/ 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; }"}
{"text":"Return - 1 if there is no Fixed Point","code":"return - 1 ; }"}
{"text":"main function","code":"public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( \" Fixed \u2581 Point \u2581 is \u2581 \" + binarySearch ( arr , 0 , n - 1 ) ) ; } }"}
{"text":"Java code to find maximum triplet sum","code":"import java . io . * ; class GFG { static int maxTripletSum ( int arr [ ] , int n ) {"}
{"text":"Initialize sum with INT_MIN","code":"int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }"}
{"text":"Driven code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . length ; System . out . println ( maxTripletSum ( arr , n ) ) ; } }"}
{"text":"Java code to find maximum triplet sum","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"This function assumes that there are at least three elements in arr [ ] .","code":"static int maxTripletSum ( int arr [ ] , int n ) {"}
{"text":"sort the given array","code":"Arrays . sort ( arr ) ;"}
{"text":"After sorting the array . Add last three element of the given array","code":"return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }"}
{"text":"Driven code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . length ; System . out . println ( maxTripletSum ( arr , n ) ) ; } }"}
{"text":"Java code to find maximum triplet sum","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"This function assumes that there are at least three elements in arr [ ] .","code":"static int maxTripletSum ( int arr [ ] , int n ) {"}
{"text":"Initialize Maximum , second maximum and third maximum element","code":"int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Update Maximum , second maximum and third maximum element","code":"if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; }"}
{"text":"Update second maximum and third maximum element","code":"else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; }"}
{"text":"Update third maximum element","code":"else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }"}
{"text":"Driven code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . length ; System . out . println ( maxTripletSum ( arr , n ) ) ; } }"}
{"text":"Java code for linearly searching x in arr [ ] . If x is present then return its location , otherwise return - 1","code":"class GFG { public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ;"}
{"text":"Function call","code":"int result = search ( arr , x ) ; if ( result == - 1 ) System . out . print ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) ; else System . out . print ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" + result ) ; } }"}
{"text":"Java program for linear search","code":"import java . io . * ; class GFG { public static void search ( int arr [ ] , int search_Element ) { int left = 0 ; int length = arr . length ; int right = length - 1 ; int position = - 1 ;"}
{"text":"run loop from 0 to right","code":"for ( left = 0 ; left <= right ; ) {"}
{"text":"if search_element is found with left variable","code":"if ( arr [ left ] == search_Element ) { position = left ; System . out . println ( \" Element \u2581 found \u2581 in \u2581 Array \u2581 at \u2581 \" + ( position + 1 ) + \" \u2581 Position \u2581 with \u2581 \" + ( left + 1 ) + \" \u2581 Attempt \" ) ; break ; }"}
{"text":"if search_element is found with right variable","code":"if ( arr [ right ] == search_Element ) { position = right ; System . out . println ( \" Element \u2581 found \u2581 in \u2581 Array \u2581 at \u2581 \" + ( position + 1 ) + \" \u2581 Position \u2581 with \u2581 \" + ( length - right ) + \" \u2581 Attempt \" ) ; break ; } left ++ ; right -- ; }"}
{"text":"if element not found","code":"if ( position == - 1 ) System . out . println ( \" Not \u2581 found \u2581 in \u2581 Array \u2581 with \u2581 \" + left + \" \u2581 Attempt \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ;"}
{"text":"Function call","code":"search ( arr , search_element ) ; } }"}
{"text":"Java implementation of Counting Sort","code":"class CountingSort {"}
{"text":"The main function that sort the given string arr [ ] in alphabetical order","code":"void sort ( char arr [ ] ) { int n = arr . length ;"}
{"text":"The output character array that will have sorted arr","code":"char output [ ] = new char [ n ] ;"}
{"text":"Create a count array to store count of inidividul characters and initialize count array as 0","code":"int count [ ] = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ;"}
{"text":"store count of each character","code":"for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ;"}
{"text":"Change count [ i ] so that count [ i ] now contains actual position of this character in output array","code":"for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ;"}
{"text":"Build the output character array To make it stable we are operating in reverse order .","code":"for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; }"}
{"text":"Copy the output array to arr , so that arr now contains sorted characters","code":"for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; }"}
{"text":"Driver method","code":"public static void main ( String args [ ] ) { CountingSort ob = new CountingSort ( ) ; char arr [ ] = { ' g ' , ' e ' , ' e ' , ' k ' , ' s ' , ' f ' , ' o ' , ' r ' , ' g ' , ' e ' , ' e ' , ' k ' , ' s ' } ; ob . sort ( arr ) ; System . out . print ( \" Sorted \u2581 character \u2581 array \u2581 is \u2581 \" ) ; for ( int i = 0 ; i < arr . length ; ++ i ) System . out . print ( arr [ i ] ) ; } }"}
{"text":"Counting sort which takes negative numbers as well","code":"import java . util . * ; class GFG {"}
{"text":"The function that sorts the given arr [ ]","code":"static void countSort ( int [ ] arr ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int range = max - min + 1 ; int count [ ] = new int [ range ] ; int output [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { count [ arr [ i ] - min ] ++ ; } for ( int i = 1 ; i < count . length ; i ++ ) { count [ i ] += count [ i - 1 ] ; } for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = output [ i ] ; } }"}
{"text":"function to print array","code":"static void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( \" \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 } ; countSort ( arr ) ; printArray ( arr ) ; } }"}
{"text":"JAVA Code for Dynamic Programming | Set 9 ( Binomial Coefficient )","code":"import java . util . * ; class GFG {"}
{"text":"Returns value of Binomial Coefficient C ( n , k )","code":"static int binomialCoeff ( int n , int k ) {"}
{"text":"Base Cases","code":"if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ;"}
{"text":"Recur","code":"return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . printf ( \" Value \u2581 of \u2581 C ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , binomialCoeff ( n , k ) ) ; } }"}
{"text":"JAVA Code for Dynamic Programming | Set 9 ( Binomial Coefficient )","code":"import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ;"}
{"text":"nC0 is 1","code":"C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"Compute next row of pascal triangle using the previous row","code":"for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . printf ( \" Value \u2581 of \u2581 C ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , binomialCoeff ( n , k ) ) ; } }"}
{"text":"pow ( base , exp , mod ) is used to find ( base ^ exp ) % mod fast -> O ( log ( exp ) )","code":"static long pow ( long b , long exp , long mod ) { long ret = 1 ; while ( exp > 0 ) { if ( ( exp & 1 ) > 0 ) ret = ( ret * b ) % mod ; b = ( b * b ) % mod ; exp >>= 1 ; } return ret ; }"}
{"text":"base case","code":"static int nCr ( int n , int r ) { if ( r > n ) return 0 ;"}
{"text":"C ( n , r ) = C ( n , n - r ) Complexity for this code is lesser for lower n - r","code":"if ( n - r > r ) r = n - r ;"}
{"text":"list to smallest prime factor of each number from 1 to n","code":"int [ ] SPF = new int [ n + 1 ] ;"}
{"text":"set smallest prime factor of each number as itself","code":"for ( int i = 1 ; i <= n ; i ++ ) SPF [ i ] = i ;"}
{"text":"set smallest prime factor of all even numbers as 2","code":"for ( int i = 4 ; i <= n ; i += 2 ) SPF [ i ] = 2 ; for ( int i = 3 ; i * i < n + 1 ; i += 2 ) {"}
{"text":"Check if i is prime","code":"if ( SPF [ i ] == i ) {"}
{"text":"All multiples of i are composite ( and divisible by i ) so add i to their prime factorization getpow ( j , i ) times","code":"for ( int j = i * i ; j < n + 1 ; j += i ) if ( SPF [ j ] == j ) { SPF [ j ] = i ; } } }"}
{"text":"Hash Map to store power of each prime in C ( n , r )","code":"Map < Integer , Integer > prime_pow = new HashMap < > ( ) ;"}
{"text":"For numerator count frequency of each prime factor","code":"for ( int i = r + 1 ; i < n + 1 ; i ++ ) { int t = i ;"}
{"text":"Recursive division to find prime factorization of i","code":"while ( t > 1 ) { prime_pow . put ( SPF [ t ] , prime_pow . getOrDefault ( SPF [ t ] , 0 ) + 1 ) ; t \/= SPF [ t ] ; } }"}
{"text":"For denominator subtract the power of each prime factor","code":"for ( int i = 1 ; i < n - r + 1 ; i ++ ) { int t = i ;"}
{"text":"Recursive division to find prime factorization of i","code":"while ( t > 1 ) { prime_pow . put ( SPF [ t ] , prime_pow . get ( SPF [ t ] ) - 1 ) ; t \/= SPF [ t ] ; } }"}
{"text":"long because mod is large and a % mod * b % mod can overflow int","code":"long ans = 1 , mod = 1000000007 ;"}
{"text":"use ( a * b ) % mod = ( a % mod * b % mod ) % mod","code":"for ( int i : prime_pow . keySet ( ) )"}
{"text":"pow ( base , exp , mod ) is used to find ( base ^ exp ) % mod fast","code":"ans = ( ans * pow ( i , prime_pow . get ( i ) , mod ) ) % mod ; return ( int ) ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + nCr ( n , r ) + \"NEW_LINE\"); } }"}
{"text":"JAVA program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find binomial coefficient","code":"static int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long inv [ ] = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ;"}
{"text":"Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007","code":"for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m \/ i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ;"}
{"text":"for 1 \/ ( r ! ) part","code":"for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; }"}
{"text":"for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part","code":"for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + binomialCoeff ( n , r ) + \"NEW_LINE\"); } }"}
{"text":"A Dynamic Programming based Java program to partition problem","code":"import java . io . * ; class GFG {"}
{"text":"Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false","code":"public static boolean findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ;"}
{"text":"Calculate sum of all elements","code":"for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean [ ] part = new boolean [ sum \/ 2 + 1 ] ;"}
{"text":"Initialze the part array as 0","code":"for ( i = 0 ; i <= sum \/ 2 ; i ++ ) { part [ i ] = false ; }"}
{"text":"Fill the partition table in bottom up manner","code":"for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"The element to be included in the sum cannot be greater than the sum","code":"for ( j = sum \/ 2 ; j >= arr [ i ] ; j -- ) {"}
{"text":"Check if sum - arr [ i ] could be formed from a subset using elements before index i","code":"if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum \/ 2 ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = 6 ;"}
{"text":"Function call","code":"if ( findPartiion ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" + \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 \" + \" two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }"}
{"text":"A recursive solution for subset sum problem","code":"class GFG {"}
{"text":"Returns true if there is a subset of set [ ] with sum equal to given sum","code":"static boolean isSubsetSum ( int set [ ] , int n , int sum ) {"}
{"text":"Base Cases","code":"if ( sum == 0 ) return true ; if ( n == 0 ) return false ;"}
{"text":"If last element is greater than sum , then ignore it","code":"if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ;"}
{"text":"else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element","code":"return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }"}
{"text":"A Dynamic Programming solution for subset sum problem","code":"class GFG {"}
{"text":"Returns true if there is a subset of set [ ] with sun equal to given sum","code":"static boolean isSubsetSum ( int set [ ] , int n , int sum ) {"}
{"text":"The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i","code":"boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ;"}
{"text":"If sum is 0 , then answer is true","code":"for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ;"}
{"text":"If sum is not 0 and set is empty , then answer is false","code":"for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ;"}
{"text":"Fill the subset table in botton up manner","code":"for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } }"}
{"text":"print table","code":"for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }"}
{"text":"A recursive Java program to print maximum number of A 's using  following four keys","code":"import java . io . * ; class GFG {"}
{"text":"A recursive function that returns the optimal length string for N keystrokes","code":"static int findoptimal ( int N ) {"}
{"text":"The optimal string length is N when N is smaller than 7","code":"if ( N <= 6 ) return N ;"}
{"text":"Initialize result","code":"int max = 0 ;"}
{"text":"TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way .","code":"int b ; for ( b = N - 3 ; b >= 1 ; b -- ) {"}
{"text":"If the breakpoint is s at b 'th  keystroke then the optimal string  would have length  (n-b-1)*screen[b-1];","code":"int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int N ;"}
{"text":"for the rest of the array we will rely on the previous entries to compute new ones","code":"for ( N = 1 ; N <= 20 ; N ++ ) System . out . println ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 keystrokes \u2581 is \u2581 \" + N + findoptimal ( N ) ) ; } }"}
{"text":"A Dynamic Programming based C program to find maximum number of A 's that can be printed using  four keys","code":"import java . io . * ; class GFG {"}
{"text":"this function returns the optimal length string for N keystrokes","code":"static int findoptimal ( int N ) {"}
{"text":"The optimal string length is N when N is smaller than 7","code":"if ( N <= 6 ) return N ;"}
{"text":"An array to store result of subproblems","code":"int screen [ ] = new int [ N ] ;"}
{"text":"To pick a breakpoint","code":"int b ;"}
{"text":"Initializing the optimal lengths array for uptil 6 input strokes","code":"int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ;"}
{"text":"Solve all subproblems in bottom manner","code":"for ( n = 7 ; n <= N ; n ++ ) {"}
{"text":"Initialize length of optimal string for n keystrokes","code":"screen [ n - 1 ] = 0 ;"}
{"text":"For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way .","code":"for ( b = n - 3 ; b >= 1 ; b -- ) {"}
{"text":"if the breakpoint is at b 'th keystroke then  the optimal string would  have length  (n-b-1)*screen[b-1];","code":"int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int N ;"}
{"text":"for the rest of the array we will rely on the previous entries to compute new ones","code":"for ( N = 1 ; N <= 20 ; N ++ ) System . out . println ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 keystrokes \u2581 is \u2581 \" + N + findoptimal ( N ) ) ; } }"}
{"text":"A Dynamic Programming based Java program to find maximum number of A 's that can be printed using four keys","code":"class GFG {"}
{"text":"This function returns the optimal length string for N keystrokes","code":"static int findoptimal ( int N ) {"}
{"text":"The optimal string length is N when N is smaller than 7","code":"if ( N <= 6 ) return N ;"}
{"text":"An array to store result of subproblems","code":"int [ ] screen = new int [ N ] ;"}
{"text":"To pick a breakpoint","code":"int b ;"}
{"text":"Initializing the optimal lengths array for uptil 6 input strokes .","code":"int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ;"}
{"text":"Solve all subproblems in bottom - up manner","code":"for ( n = 7 ; n <= N ; n ++ ) {"}
{"text":"for any keystroke n , we will need to choose between : - 1. pressing Ctrl - V once after copying the A ' s \u2581 obtained \u2581 by \u2581 n - 3 \u2581 keystrokes . \u2581 \u2581 2 . \u2581 pressing \u2581 Ctrl - V \u2581 twice \u2581 after \u2581 copying \u2581 the \u2581 A ' s obtained by n - 4 keystrokes . 3. pressing Ctrl - V thrice after copying the A 's  obtained by n-5 keystrokes.","code":"screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N ;"}
{"text":"for the rest of the array we will rely on the previous entries to compute new ones","code":"for ( N = 1 ; N <= 20 ; N ++ ) System . out . printf ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \" + \" %d keystrokes is %dNEW_LINE\", N , findoptimal ( N ) ) ; } }"}
{"text":"Function to calculate x raised to the power y","code":"static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y \/ 2 ) * power ( x , y \/ 2 ) ; else return x * power ( x , y \/ 2 ) * power ( x , y \/ 2 ) ; }"}
{"text":"Program to test function power","code":"public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . printf ( \" % d \" , power ( x , y ) ) ; } }"}
{"text":"Function to calculate x raised to the power y in O ( logn )","code":"static int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y \/ 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text":"Java code for extended version of power function that can work for float x and negative y","code":"class GFG { static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y \/ 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) \/ x ; } }"}
{"text":"Program to test function power","code":"public static void main ( String [ ] args ) { float x = 2 ; int y = - 3 ; System . out . printf ( \" % f \" , power ( x , y ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG { public static int power ( int x , int y ) {"}
{"text":"If x ^ 0 return 1","code":"if ( y == 0 ) return 1 ;"}
{"text":"If we need to find of 0 ^ y","code":"if ( x == 0 ) return 0 ;"}
{"text":"For all other cases","code":"return x * power ( x , y - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . println ( power ( x , y ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG { public static int power ( int x , int y ) {"}
{"text":"Math . pow ( ) is a function that return floating number","code":"return ( int ) Math . pow ( x , y ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . println ( power ( x , y ) ) ; } }"}
{"text":"Returns the square root of n . Note that the function","code":"static float squareRoot ( float n ) {"}
{"text":"We are using n itself as initial approximation This can definitely be improved","code":"float x = n ; float y = 1 ;"}
{"text":"e decides the accuracy level","code":"double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) \/ 2 ; y = n \/ x ; } return x ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int n = 50 ; System . out . printf ( \" Square \u2581 root \u2581 of \u2581 \" + n + \" \u2581 is \u2581 \" + squareRoot ( n ) ) ; } }"}
{"text":"Java program to find average of a stream of numbers","code":"class GFG {"}
{"text":"Returns the new average after including x","code":"static float getAvg ( float prev_avg , float x , int n ) { return ( prev_avg * n + x ) \/ ( n + 1 ) ; }"}
{"text":"Prints average of a stream of numbers","code":"static void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; System . out . printf ( \"Average of %d numbers is %f NEW_LINE\", i + 1, avg); } return ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }"}
{"text":"Java program to return Average of a stream of numbers","code":"class GFG { static int sum , n ;"}
{"text":"Returns the new average after including x","code":"static float getAvg ( int x ) { sum += x ; return ( ( ( float ) sum ) \/ ++ n ) ; }"}
{"text":"Prints average of a stream of numbers","code":"static void streamAvg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( ( int ) arr [ i ] ) ; System . out . println ( \" Average \u2581 of \u2581 \" + ( i + 1 ) + \" \u2581 numbers \u2581 is \u2581 \" + avg ) ; } return ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { float [ ] arr = new float [ ] { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }"}
{"text":"Program to calculate C ( n , k ) in java","code":"class BinomialCoefficient {"}
{"text":"Returns value of Binomial Coefficient C ( n , k )","code":"static int binomialCoeff ( int n , int k ) { int res = 1 ;"}
{"text":"Since C ( n , k ) = C ( n , n - k )","code":"if ( k > n - k ) k = n - k ;"}
{"text":"Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ]","code":"for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int n = 8 ; int k = 2 ; System . out . println ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + k + \" ) \u2581 \" + \" is \" + \" \u2581 \" + binomialCoeff ( n , k ) ) ; } }"}
{"text":"Program to print all prime factors","code":"import java . io . * ; import java . lang . Math ; class GFG {"}
{"text":"A function to print all prime factors of a given number n","code":"public static void primeFactors ( int n ) {"}
{"text":"Print the number of 2 s that divide n","code":"while ( n % 2 == 0 ) { System . out . print ( 2 + \" \u2581 \" ) ; n \/= 2 ; }"}
{"text":"n must be odd at this point . So we can skip one element ( Note i = i + 2 )","code":"for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) {"}
{"text":"While i divides n , print i and divide n","code":"while ( n % i == 0 ) { System . out . print ( i + \" \u2581 \" ) ; n \/= i ; } }"}
{"text":"This condition is to handle the case whien n is a prime number greater than 2","code":"if ( n > 2 ) System . out . print ( n ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 315 ; primeFactors ( n ) ; } }"}
{"text":"Java program to print all combination of size r in an array of size n","code":"import java . io . * ; class Combination {"}
{"text":"The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )","code":"static void printCombination ( int arr [ ] , int n , int r ) {"}
{"text":"A temporary array to store all combination one by one","code":"int data [ ] = new int [ r ] ;"}
{"text":"Print all combination using temprary array ' data [ ] '","code":"combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }"}
{"text":"arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed","code":"static void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) {"}
{"text":"Current combination is ready to be printed , print it","code":"if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; return ; }"}
{"text":"replace index with all possible elements . The condition \" end - i + 1 \u2581 > = \u2581 r - index \" makes sure that including one element at index will make a combination with remaining elements at remaining positions","code":"for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } }"}
{"text":"Driver function to check for above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }"}
{"text":"Java program to print all combination of size r in an array of size n","code":"import java . io . * ; class Combination {"}
{"text":"The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )","code":"static void printCombination ( int arr [ ] , int n , int r ) {"}
{"text":"A temporary array to store all combination one by one","code":"int data [ ] = new int [ r ] ;"}
{"text":"Print all combination using temprary array ' data [ ] '","code":"combinationUtil ( arr , n , r , 0 , data , 0 ) ; }"}
{"text":"arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed","code":"static void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) {"}
{"text":"Current combination is ready to be printed , print it","code":"if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; return ; }"}
{"text":"When no more elements are there to put in data [ ]","code":"if ( i >= n ) return ;"}
{"text":"current is included , put next at next location","code":"data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ;"}
{"text":"current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed )","code":"combinationUtil ( arr , n , r , index , data , i + 1 ) ; }"}
{"text":"Driver function to check for above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }"}
{"text":"Java Program to count all possible groups of size 2 or 3 that have sum as multiple of 3","code":"class FindGroups {"}
{"text":"Returns count of all possible groups that can be formed from elements of a [ ] .","code":"int findgroups ( int arr [ ] , int n ) {"}
{"text":"Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i","code":"int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ;"}
{"text":"To store the result","code":"int res = 0 ;"}
{"text":"Count elements with remainder 0 , 1 and 2","code":"for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ;"}
{"text":"Case 3. a : Count groups of size 2 from 0 remainder elements","code":"res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;"}
{"text":"Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder","code":"res += c [ 1 ] * c [ 2 ] ;"}
{"text":"Case 4. a : Count groups of size 3 with all 0 remainder elements","code":"res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) \/ 6 ;"}
{"text":"Case 4. b : Count groups of size 3 with all 1 remainder elements","code":"res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) \/ 6 ;"}
{"text":"Case 4. c : Count groups of size 3 with all 2 remainder elements","code":"res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) \/ 6 ) ;"}
{"text":"Case 4. c : Count groups of size 3 with different remainders","code":"res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;"}
{"text":"Return total count stored in res","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { FindGroups groups = new FindGroups ( ) ; int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = arr . length ; System . out . println ( \" Required \u2581 number \u2581 of \u2581 groups \u2581 are \u2581 \" + groups . findgroups ( arr , n ) ) ; } }"}
{"text":"Java program to find smallest power of 2 greater than or equal to n","code":"import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ;"}
{"text":"First n in the below condition is for the case where n is 0","code":"if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 0 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }"}
{"text":"Java program to find smallest power of 2 greater than or equal to n","code":"import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }"}
{"text":"Java program to find smallest power of 2 greater than or equal to n","code":"import java . io . * ; class GFG {"}
{"text":"Finds next power of two for n . If n itself is a power of two then returns n","code":"static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }"}
{"text":"Java code to Segregate 0 s and 1 s in an array","code":"class GFG {"}
{"text":"function to segregate 0 s and 1 s","code":"static void segregate0and1 ( int arr [ ] , int n ) {"}
{"text":"counts the no of zeros in arr","code":"int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; }"}
{"text":"loop fills the arr with 0 until count","code":"for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ;"}
{"text":"loop fills remaining arr space with 1","code":"for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; }"}
{"text":"function to print segregated array","code":"static void print ( int arr [ ] , int n ) { System . out . print ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"driver function","code":"public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int n = arr . length ; segregate0and1 ( arr , n ) ; print ( arr , n ) ; } }"}
{"text":"Function to put all 0 s on left and all 1 s on right","code":"void segregate0and1 ( int arr [ ] , int size ) {"}
{"text":"Initialize left and right indexes","code":"int left = 0 , right = size - 1 ; while ( left < right ) {"}
{"text":"Increment left index while we see 0 at left","code":"while ( arr [ left ] == 0 && left < right ) left ++ ;"}
{"text":"Decrement right index while we see 1 at right","code":"while ( arr [ right ] == 1 && left < right ) right -- ;"}
{"text":"If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ]","code":"if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }"}
{"text":"Driver Program to test above functions","code":"public static void main ( String [ ] args ) { Segregate seg = new Segregate ( ) ; int arr [ ] = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = arr . length ; seg . segregate0and1 ( arr , arr_size ) ; System . out . print ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" ) ; for ( i = 0 ; i < 6 ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Java code to segregate 0 and 1","code":"import java . util . * ; class GFG {"}
{"text":"* Method for segregation 0 and 1 given input array","code":"static void segregate0and1 ( int arr [ ] ) { int type0 = 0 ; int type1 = arr . length - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else { type0 ++ ; } } }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int [ ] array = { 0 , 1 , 0 , 1 , 1 , 1 } ; segregate0and1 ( array ) ; for ( int a : array ) { System . out . print ( a + \" \u2581 \" ) ; } } }"}
{"text":"Java program to check if we can make neighbors distinct .","code":"import java . io . * ; import java . util . HashMap ; import java . util . Map ; class GFG { static void distinctAdjacentElement ( int a [ ] , int n ) {"}
{"text":"map used to count the frequency of each element occurring in the array","code":"HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;"}
{"text":"In this loop we count the frequency of element through map m .","code":"for ( int i = 0 ; i < n ; ++ i ) { if ( m . containsKey ( a [ i ] ) ) { int x = m . get ( a [ i ] ) + 1 ; m . put ( a [ i ] , x ) ; } else { m . put ( a [ i ] , 1 ) ; } }"}
{"text":"mx store the frequency of element which occurs most in array .","code":"int mx = 0 ;"}
{"text":"In this loop we calculate the maximum frequency and store it in variable mx .","code":"for ( int i = 0 ; i < n ; ++ i ) if ( mx < m . get ( a [ i ] ) ) mx = m . get ( a [ i ] ) ;"}
{"text":"By swapping we can adjust array only when the frequency of the element which occurs most is less than or equal to ( n + 1 ) \/ 2 .","code":"if ( mx > ( n + 1 ) \/ 2 ) System . out . println ( \" NO \" ) ; else System . out . println ( \" YES \" ) ; }"}
{"text":"Driver program to test the above function","code":"public static void main ( String [ ] args ) { int a [ ] = { 7 , 7 , 7 , 7 } ; int n = 4 ; distinctAdjacentElement ( a , n ) ; } }"}
{"text":"Java program for the above approach","code":"class FindMaximum {"}
{"text":"For a given array arr [ ] , returns the maximum j - i such that arr [ j ] > arr [ i ]","code":"int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { FindMaximum max = new FindMaximum ( ) ; int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = arr . length ; int maxDiff = max . maxIndexDiff ( arr , n ) ; System . out . println ( maxDiff ) ; } }"}
{"text":"For a given array arr [ ] , calculates the maximum j a i such that arr [ j ] > arr [ i ]","code":"import java . util . * ; class GFG { public static void main ( String [ ] args ) { int [ ] v = { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . length ; int [ ] maxFromEnd = new int [ n + 1 ] ; Arrays . fill ( maxFromEnd , Integer . MIN_VALUE ) ;"}
{"text":"Create an array maxfromEnd","code":"for ( int i = v . length - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = Math . max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { int low = i + 1 , high = v . length - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) \/ 2 ; if ( v [ i ] <= maxFromEnd [ mid ] ) {"}
{"text":"We store this as current answer and look for further larger number to the right side","code":"ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } }"}
{"text":"Keeping a track of the maximum difference in indices","code":"result = Math . max ( result , ans - i ) ; } System . out . print ( result + \"NEW_LINE\"); } }"}
{"text":"Java implementation of the hashmap approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find maximum index difference","code":"static int maxIndexDiff ( ArrayList < Integer > arr , int n ) {"}
{"text":"Initilaise unordered_map","code":"Map < Integer , ArrayList < Integer > > hashmap = new HashMap < Integer , ArrayList < Integer > > ( ) ;"}
{"text":"Iterate from 0 to n - 1","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( hashmap . containsKey ( arr . get ( i ) ) ) { hashmap . get ( arr . get ( i ) ) . add ( i ) ; } else { hashmap . put ( arr . get ( i ) , new ArrayList < Integer > ( ) ) ; hashmap . get ( arr . get ( i ) ) . add ( i ) ; } }"}
{"text":"Sort arr","code":"Collections . sort ( arr ) ; int maxDiff = Integer . MIN_VALUE ; int temp = n ;"}
{"text":"Iterate from 0 to n - 1","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap . get ( arr . get ( i ) ) . get ( 0 ) ) { temp = hashmap . get ( arr . get ( i ) ) . get ( 0 ) ; } maxDiff = Math . max ( maxDiff , hashmap . get ( arr . get ( i ) ) . get ( hashmap . get ( arr . get ( i ) ) . size ( ) - 1 ) - temp ) ; } return maxDiff ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 9 ; ArrayList < Integer > arr = new ArrayList < Integer > ( Arrays . asList ( 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 ) ) ;"}
{"text":"Function Call","code":"int ans = maxIndexDiff ( arr , n ) ; System . out . println ( \" The \u2581 maxIndexDiff \u2581 is \u2581 : \u2581 \" + ans ) ; } }"}
{"text":"Java program to print sorted distinct elements .","code":"import java . io . * ; import java . util . * ; public class GFG { static void printRepeating ( Integer [ ] arr , int size ) {"}
{"text":"Create a set using array elements","code":"SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ;"}
{"text":"Print contents of the set .","code":"System . out . print ( s ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { Integer [ ] arr = { 1 , 3 , 2 , 2 , 1 } ; int n = arr . length ; printRepeating ( arr , n ) ; } }"}
{"text":"Java program to make an array same to another using minimum number of swap","code":"import java . io . * ; import java . util . * ;"}
{"text":"Function returns the minimum number of swaps required to sort the array This method is taken from below post www . geeksforgeeks . org \/ minimum - number - swaps - required - sort - array \/ https :","code":"class GFG { static int minSwapsToSort ( int arr [ ] , int n ) {"}
{"text":"Create an array of pairs where first element is array element and second element is position of first element","code":"ArrayList < ArrayList < Integer > > arrPos = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrPos . add ( new ArrayList < Integer > ( Arrays . asList ( arr [ i ] , i ) ) ) ; }"}
{"text":"Sort the array by array element values to get right position of every element as second element of pair .","code":"Collections . sort ( arrPos , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ;"}
{"text":"To keep track of visited elements . Initialize all elements as not visited or false .","code":"boolean [ ] vis = new boolean [ n ] ;"}
{"text":"Initialize result","code":"int ans = 0 ;"}
{"text":"Traverse array elements","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"already swapped and corrected or already present at correct pos","code":"if ( vis [ i ] || arrPos . get ( i ) . get ( 1 ) == i ) continue ;"}
{"text":"find out the number of node in this cycle and add in ans","code":"int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ;"}
{"text":"move to next node","code":"j = arrPos . get ( j ) . get ( 1 ) ; cycle_size ++ ; }"}
{"text":"Update answer by adding current cycle .","code":"ans += ( cycle_size - 1 ) ; }"}
{"text":"Return result","code":"return ans ; }"}
{"text":"method returns minimum number of swap to make array B same as array A","code":"static int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) {"}
{"text":"map to store position of elements in array B we basically store element to index mapping .","code":"Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( b [ i ] , i ) ; }"}
{"text":"now we 're storing position of array A elements  in array B.","code":"for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ;"}
{"text":"returing minimum swap for sorting in modified array B as final answer","code":"return minSwapsToSort ( b , n ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = a . length ; System . out . println ( minSwapToMakeArraySame ( a , b , n ) ) ; } }"}
{"text":"Java program to check for even or odd","code":"import java . io . * ; import java . util . * ; public class GFG {"}
{"text":"Function to find k - th missing element","code":"static int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; boolean flag = false ;"}
{"text":"interating over the array","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ;"}
{"text":"check if i - th and ( i + 1 ) - th element are not consecutive","code":"if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) {"}
{"text":"save their difference","code":"difference += ( a [ i + 1 ] - a [ i ] ) - 1 ;"}
{"text":"check for difference and given k","code":"if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } }"}
{"text":"if found","code":"if ( flag ) return ans ; else return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"Input array","code":"int [ ] a = { 1 , 5 , 11 , 19 } ;"}
{"text":"k - th missing element to be found in the array","code":"int k = 11 ; int n = a . length ;"}
{"text":"calling function to find missing element","code":"int missing = missingK ( a , k , n ) ; System . out . print ( missing ) ; } }"}
{"text":"Java program for above approach","code":"public class GFG {"}
{"text":"Function to find kth missing number","code":"static int missingK ( int [ ] arr , int k ) { int n = arr . length ; int l = 0 , u = n - 1 , mid ; while ( l <= u ) { mid = ( l + u ) \/ 2 ; int numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ;"}
{"text":"If the total missing number count is equal to k we can iterate backwards for the first missing number and that will be the answer .","code":"if ( numbers_less_than_mid == k ) {"}
{"text":"To further optimize we check if the previous element ' s \u2581 \u2581 missing \u2581 number \u2581 count \u2581 is \u2581 equal \u2581 \u2581 to \u2581 k . \u2581 Eg : \u2581 arr \u2581 = \u2581 [ 4,5,6,7,8 ] \u2581 \u2581 If \u2581 you \u2581 observe \u2581 in \u2581 the \u2581 example \u2581 array , \u2581 \u2581 the \u2581 total \u2581 count \u2581 of \u2581 missing \u2581 numbers \u2581 for \u2581 all \u2581 \u2581 the \u2581 indices \u2581 are \u2581 same , \u2581 and \u2581 we \u2581 are \u2581 \u2581 aiming \u2581 to \u2581 narrow \u2581 down \u2581 the \u2581 \u2581 search \u2581 window \u2581 and \u2581 achieve \u2581 O ( logn ) \u2581 \u2581 time \u2581 complexity \u2581 which \u2581 \u2581 otherwise \u2581 would ' ve been O ( n ) .","code":"if ( mid > 0 && ( arr [ mid - 1 ] - ( mid ) ) == k ) { u = mid - 1 ; continue ; }"}
{"text":"Else we return arr [ mid ] - 1.","code":"return arr [ mid ] - 1 ; }"}
{"text":"Here we appropriately narrow down the search window .","code":"if ( numbers_less_than_mid < k ) { l = mid + 1 ; } else if ( k < numbers_less_than_mid ) { u = mid - 1 ; } }"}
{"text":"In case the upper limit is - ve it means the missing number set is 1 , 2 , . . , k and hence we directly return k .","code":"if ( u < 0 ) return k ;"}
{"text":"Else we find the residual count of numbers which we 'd then add to  arr[u] and get the missing kth number.","code":"int less = arr [ u ] - ( u + 1 ) ; k -= less ;"}
{"text":"Return arr [ u ] + k","code":"return arr [ u ] + k ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 7 , 11 } ; int k = 5 ;"}
{"text":"Function Call","code":"System . out . println ( \" Missing \u2581 kth \u2581 number \u2581 = \u2581 \" + missingK ( arr , k ) ) ; } }"}
{"text":"Java program to rearrange nodes as alternate odd even nodes in a Singly Linked List","code":"import java . util . * ; class GFG {"}
{"text":"class node","code":"static class Node { int data ; Node next ; }"}
{"text":"A utility function to print linked list","code":"static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; node = node . next ; } System . out . println ( ) ; }"}
{"text":"Function to create newNode in a linkedlist","code":"static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }"}
{"text":"Function to insert at beginning","code":"static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; }"}
{"text":"Function to rearrange the odd and even nodes","code":"static void rearrangeOddEven ( Node head ) { Stack < Node > odd = new Stack < Node > ( ) ; Stack < Node > even = new Stack < Node > ( ) ; int i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) {"}
{"text":"Odd Value in Even Position Add pointer to current node in odd stack","code":"odd . push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) {"}
{"text":"Even Value in Odd Position Add pointer to current node in even stack","code":"even . push ( head ) ; } head = head . next ; i ++ ; } while ( odd . size ( ) > 0 && even . size ( ) > 0 ) {"}
{"text":"Swap Data at the top of two stacks","code":"int k = odd . peek ( ) . data ; odd . peek ( ) . data = even . peek ( ) . data ; even . peek ( ) . data = k ; odd . pop ( ) ; even . pop ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; System . out . println ( \" Linked \u2581 List : \" ) ; printList ( head ) ; rearrangeOddEven ( head ) ; System . out . println ( \" Linked \u2581 List \u2581 after \u2581 \" + \" Rearranging : \" ) ; printList ( head ) ; } }"}
{"text":"Java program to rearrange nodes as alternate odd even nodes in a Singly Linked List","code":"class GFG {"}
{"text":"Structure node","code":"static class Node { int data ; Node next ; } ;"}
{"text":"A utility function to print linked list","code":"static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; node = node . next ; } System . out . println ( ) ; }"}
{"text":"Function to create newNode in a linkedlist","code":"static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }"}
{"text":"Function to insert at beginning","code":"static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; }"}
{"text":"Function to rearrange the odd and even nodes","code":"static Node rearrange ( Node head ) {"}
{"text":"Step 1 : Segregate even and odd nodes Step 2 : Split odd and even lists Step 3 : Merge even list into odd list","code":"Node even ; Node temp , prev_temp ; Node i , j , k , l , ptr = null ;"}
{"text":"Step 1 : Segregate Odd and Even Nodes","code":"temp = ( head ) . next ; prev_temp = head ; while ( temp != null ) {"}
{"text":"Backup next pointer of temp","code":"Node x = temp . next ;"}
{"text":"If temp is odd move the node to beginning of list","code":"if ( temp . data % 2 != 0 ) { prev_temp . next = x ; temp . next = ( head ) ; ( head ) = temp ; } else { prev_temp = temp ; }"}
{"text":"Advance Temp Pointer","code":"temp = x ; }"}
{"text":"Step 2 Split the List into Odd and even","code":"temp = ( head ) . next ; prev_temp = ( head ) ; while ( temp != null && temp . data % 2 != 0 ) { prev_temp = temp ; temp = temp . next ; } even = temp ;"}
{"text":"End the odd List ( Make last node null )","code":"prev_temp . next = null ;"}
{"text":"Step 3 : Merge Even List into odd","code":"i = head ; j = even ; while ( j != null && i != null ) {"}
{"text":"While both lists are not exhausted Backup next pointers of i and j","code":"k = i . next ; l = j . next ; i . next = j ; j . next = k ;"}
{"text":"ptr points to the latest node added","code":"ptr = j ;"}
{"text":"Advance i and j pointers","code":"i = k ; j = l ; } if ( i == null ) {"}
{"text":"Odd list exhausts before even , append remainder of even list to odd .","code":"ptr . next = j ; }"}
{"text":"The case where even list exhausts before odd list is automatically handled since we merge the even list into the odd list","code":"return head ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; System . out . println ( \" Linked \u2581 List : \" ) ; printList ( head ) ; System . out . println ( \" Rearranged \u2581 List \" ) ; head = rearrange ( head ) ; printList ( head ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {"}
{"text":"Function to print the matrix","code":"static void print ( int mat [ ] [ ] ) {"}
{"text":"Iterate over the rows","code":"for ( int i = 0 ; i < mat . length ; i ++ ) {"}
{"text":"Iterate over the columns","code":"for ( int j = 0 ; j < mat [ 0 ] . length ; j ++ )"}
{"text":"Print the value","code":"System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"Function to perform the swapping of matrix elements in clockwise manner","code":"static void performSwap ( int mat [ ] [ ] , int i , int j ) { int N = mat . length ;"}
{"text":"Stores the last row","code":"int ei = N - 1 - i ;"}
{"text":"Stores the last column","code":"int ej = N - 1 - j ;"}
{"text":"Perform the swaps","code":"int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; }"}
{"text":"Function to rotate non - diagonal elements of the matrix K times in clockwise direction","code":"static void rotate ( int mat [ ] [ ] , int N , int K ) {"}
{"text":"Update K to K % 4","code":"K = K % 4 ;"}
{"text":"Iterate until K is positive","code":"while ( K -- > 0 ) {"}
{"text":"Iterate each up to N \/ 2 - th row","code":"for ( int i = 0 ; i < N \/ 2 ; i ++ ) {"}
{"text":"Iterate each column from i to N - i - 1","code":"for ( int j = i ; j < N - i - 1 ; j ++ ) {"}
{"text":"Check if the element at i , j is not a diagonal element","code":"if ( i != j && ( i + j ) != N - 1 ) {"}
{"text":"Perform the swapping","code":"performSwap ( mat , i , j ) ; } } } }"}
{"text":"Print the matrix","code":"print ( mat ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int K = 5 ; int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 6 , 7 , 8 , 9 } , { 11 , 12 , 13 , 14 } , { 16 , 17 , 18 , 19 } , } ; int N = mat . length ; rotate ( mat , N , K ) ; } }"}
{"text":"Java program to determine minimum number of rotations required to yield same string .","code":"import java . util . * ; class GFG {"}
{"text":"Returns count of rotations to get the same string back .","code":"static int findRotations ( String str ) {"}
{"text":"tmp is the concatenated string .","code":"String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"substring from i index of original string size .","code":"String substring = tmp . substring ( i , i + str . length ( ) ) ;"}
{"text":"if substring matches with original string then we will come out of the loop .","code":"if ( str . equals ( substring ) ) return i ; } return n ; }"}
{"text":"Driver Method","code":"public static void main ( String [ ] args ) { String str = \" aaaa \" ; System . out . println ( findRotations ( str ) ) ; } }"}
{"text":"Java implementation to find elements that are a power of two","code":"import java . util . * ; class GFG { static final int MAX = 10000 ;"}
{"text":"prefix [ i ] is going to store the number of elements which are a power of two till i ( including i ) .","code":"static int [ ] prefix = new int [ MAX + 1 ] ; static boolean isPowerOfTwo ( int x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; }"}
{"text":"Function to find the maximum range whose sum is divisible by M .","code":"static void computePrefix ( int n , int a [ ] ) {"}
{"text":"Calculate the prefix sum","code":"if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } }"}
{"text":"Function to return the number of elements which are a power of two in a subarray","code":"static int query ( int L , int R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] = { 3 , 8 , 5 , 2 , 5 , 10 } ; int N = A . length ; int Q = 2 ; computePrefix ( N , A ) ; System . out . println ( query ( 0 , 4 ) ) ; System . out . println ( query ( 3 , 5 ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to calculate the integral points inside a square","code":"static void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; } }"}
{"text":"Java implementation to find the next distinct digits number","code":"class GFG {"}
{"text":"Function to find the next distinct digits number","code":"static void findNextNumber ( int n ) { int h [ ] = new int [ 10 ] ; int i = 0 , msb = n , rem = 0 ; int next_num = - 1 , count = 0 ;"}
{"text":"Loop to find the distinct digits using hash array and the number of digits","code":"while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb \/= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ;"}
{"text":"Loop to find the most significant distinct digit of the next number","code":"for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } }"}
{"text":"Condition to check if the number is possible with the same number of digits count","code":"if ( next_num == - 1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } }"}
{"text":"Condition to check if the desired most siginificant distinct digit is found","code":"if ( next_num > 0 ) {"}
{"text":"Loop to find the minimum next digit which is not present in the number","code":"for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } }"}
{"text":"Computation of the number","code":"for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; }"}
{"text":"Condition to check if the number is greater than the given number","code":"if ( next_num > n ) System . out . print ( next_num + \"NEW_LINE\"); else System . out . print ( \"Not Possible NEW_LINE\"); } else { System . out . print ( \"Not Possible NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 2019 ; findNextNumber ( n ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is N","code":"static void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ;"}
{"text":"Iterate over the range [ 0 , N7 ]","code":"for ( C = 0 ; C < N \/ 7 ; C ++ ) {"}
{"text":"Iterate over the range [ 0 , N5 ]","code":"for ( B = 0 ; B < N \/ 5 ; B ++ ) {"}
{"text":"Find the value of A","code":"A = N - 7 * C - 5 * B ;"}
{"text":"If A is greater than or equal to 0 and divisible by 3","code":"if ( A >= 0 && A % 3 == 0 ) { System . out . print ( \" A \u2581 = \u2581 \" + A \/ 3 + \" , \u2581 B \u2581 = \u2581 \" + B + \" , \u2581 C \u2581 = \u2581 \" + C ) ; return ; } } }"}
{"text":"Otherwise , print - 1","code":"System . out . println ( - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 19 ; CalculateValues ( 19 ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum time to visit all the cities such that both the person never meets","code":"static void minimumTime ( int [ ] arr , int n ) {"}
{"text":"Initialize sum as 0","code":"int sum = 0 ;"}
{"text":"Find the maximum element","code":"int T = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Increment sum by arr [ i ]","code":"sum += arr [ i ] ; }"}
{"text":"Print maximum of 2 * T and sum","code":"System . out . println ( Math . max ( 2 * T , sum ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 8 , 3 } ; int N = arr . length ;"}
{"text":"Function Call","code":"minimumTime ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the lexicographically maximum string by reversing substrings having even numbers of 1 s","code":"static void lexicographicallyMax ( String s ) {"}
{"text":"Store size of string","code":"int n = s . length ( ) ;"}
{"text":"Traverse the string","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Count the number of 1 s","code":"int count = 0 ;"}
{"text":"Stores the starting index","code":"int beg = i ;"}
{"text":"Stores the end index","code":"int end = i ;"}
{"text":"Increment count , when 1 is encountered","code":"if ( s . charAt ( i ) == '1' ) count ++ ;"}
{"text":"Traverse the remaining string","code":"for ( int j = i + 1 ; j < n ; j ++ ) { if ( s . charAt ( j ) == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } }"}
{"text":"Reverse the string from starting and end index","code":"s = reverse ( s , beg , end + 1 ) ; }"}
{"text":"Printing the string","code":"System . out . println ( s ) ; } static String reverse ( String s , int beg , int end ) { StringBuilder x = new StringBuilder ( \" \" ) ; for ( int i = 0 ; i < beg ; i ++ ) x . append ( s . charAt ( i ) ) ; for ( int i = end - 1 ; i >= beg ; i -- ) x . append ( s . charAt ( i ) ) ; for ( int i = end ; i < s . length ( ) ; i ++ ) x . append ( s . charAt ( i ) ) ; return x . toString ( ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { String S = \"0101\" ; lexicographicallyMax ( S ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to count the maximum number of pairs from given array with sum K","code":"public static void maxPairs ( int [ ] nums , int k ) {"}
{"text":"Sort array in increasing order","code":"Arrays . sort ( nums ) ;"}
{"text":"Stores the final result","code":"int result = 0 ;"}
{"text":"Initialize the left and right pointers","code":"int start = 0 , end = nums . length - 1 ;"}
{"text":"Traverse array until start < end","code":"while ( start < end ) { if ( nums [ start ] + nums [ end ] > k )"}
{"text":"Decrement right by 1","code":"end -- ; else if ( nums [ start ] + nums [ end ] < k )"}
{"text":"Increment left by 1","code":"start ++ ;"}
{"text":"Increment result and left pointer by 1 and decrement right pointer by 1","code":"else { start ++ ; end -- ; result ++ ; } }"}
{"text":"Print the result","code":"System . out . println ( result ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int K = 5 ;"}
{"text":"Function Call","code":"maxPairs ( arr , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the maximum number of pairs with a sum K such that same element can 't be used twice","code":"public static void maxPairs ( int [ ] nums , int k ) {"}
{"text":"Initialize a hashmap","code":"Map < Integer , Integer > map = new HashMap < > ( ) ;"}
{"text":"Store the final result","code":"int result = 0 ;"}
{"text":"Iterate over the array nums [ ]","code":"for ( int i : nums ) {"}
{"text":"Decrement its frequency in map and increment the result by 1","code":"if ( map . containsKey ( i ) && map . get ( i ) > 0 ) { map . put ( i , map . get ( i ) - 1 ) ; result ++ ; }"}
{"text":"Increment its frequency by 1 if it is already present in map . Otherwise , set its frequency to 1","code":"else { map . put ( k - i , map . getOrDefault ( k - i , 0 ) + 1 ) ; } }"}
{"text":"Print the result","code":"System . out . println ( result ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int K = 5 ;"}
{"text":"Function Call","code":"maxPairs ( arr , K ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find indices of array elements whose removal makes the sum of odd and even indexed array elements equal","code":"static void removeIndicesToMakeSumEqual ( int [ ] arr ) {"}
{"text":"Stores size of array","code":"int N = arr . length ;"}
{"text":"Store prefix sum of odd index array elements","code":"int [ ] odd = new int [ N ] ;"}
{"text":"Store prefix sum of even index array elements","code":"int [ ] even = new int [ N ] ;"}
{"text":"Update even [ 0 ]","code":"even [ 0 ] = arr [ 0 ] ;"}
{"text":"Traverse the given array","code":"for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"Update odd [ i ]","code":"odd [ i ] = odd [ i - 1 ] ;"}
{"text":"Update even [ i ]","code":"even [ i ] = even [ i - 1 ] ;"}
{"text":"If the current index is an even number","code":"if ( i % 2 == 0 ) {"}
{"text":"Update even [ i ]","code":"even [ i ] += arr [ i ] ; }"}
{"text":"If the current index is an odd number","code":"else {"}
{"text":"Update odd [ i ]","code":"odd [ i ] += arr [ i ] ; } }"}
{"text":"Check if at least one index found or not that satisfies the condition","code":"boolean find = false ;"}
{"text":"Store odd indices sum by removing 0 - th index","code":"int p = odd [ N - 1 ] ;"}
{"text":"Store even indices sum by removing 0 - th index","code":"int q = even [ N - 1 ] - arr [ 0 ] ;"}
{"text":"If p and q are equal","code":"if ( p == q ) { System . out . print ( \"0 \u2581 \" ) ; find = true ; }"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"If i is an even number","code":"if ( i % 2 == 0 ) {"}
{"text":"Update p by removing the i - th element","code":"p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ;"}
{"text":"Update q by removing the i - th element","code":"q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else {"}
{"text":"Update q by removing the i - th element","code":"q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ;"}
{"text":"Update p by removing the i - th element","code":"p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; }"}
{"text":"If odd index values sum is equal to even index values sum","code":"if ( p == q ) {"}
{"text":"Set the find variable","code":"find = true ;"}
{"text":"Print the current index","code":"System . out . print ( i + \" \u2581 \" ) ; } }"}
{"text":"If no index found","code":"if ( ! find ) {"}
{"text":"Print not possible","code":"System . out . print ( - 1 ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to coutnt minimum array elements required to be removed to make an array bitonic","code":"static void min_element_removal ( int arr [ ] , int N ) {"}
{"text":"left [ i ] : Stores the length of LIS up to i - th index","code":"int left [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) left [ i ] = 1 ;"}
{"text":"right [ i ] : Stores the length of decreasing subsequence over the range [ i , N ]","code":"int right [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) right [ i ] = 1 ;"}
{"text":"Calculate the length of LIS up to i - th index","code":"for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"Traverse the array upto i - th index","code":"for ( int j = 0 ; j < i ; j ++ ) {"}
{"text":"If arr [ j ] is less than arr [ i ]","code":"if ( arr [ j ] < arr [ i ] ) {"}
{"text":"Update left [ i ]","code":"left [ i ] = Math . max ( left [ i ] , left [ j ] + 1 ) ; } } }"}
{"text":"Calculate the length of decreasing subsequence over the range [ i , N ]","code":"for ( int i = N - 2 ; i >= 0 ; i -- ) {"}
{"text":"Traverse right [ ] array","code":"for ( int j = N - 1 ; j > i ; j -- ) {"}
{"text":"If arr [ i ] is greater than arr [ j ]","code":"if ( arr [ i ] > arr [ j ] ) {"}
{"text":"Update right [ i ]","code":"right [ i ] = Math . max ( right [ i ] , right [ j ] + 1 ) ; } } }"}
{"text":"Stores length of the longest bitonic array","code":"int maxLen = 0 ;"}
{"text":"Traverse left [ ] and right [ ] array","code":"for ( int i = 1 ; i < N - 1 ; i ++ ) {"}
{"text":"Update maxLen","code":"maxLen = Math . max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } System . out . println ( N - maxLen ) ; }"}
{"text":"Function to print minimum removals required to make given array bitonic","code":"static void makeBitonic ( int arr [ ] , int N ) { if ( N == 1 ) { System . out . println ( \"0\" ) ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) System . out . println ( \"0\" ) ; else System . out . println ( \"1\" ) ; return ; } min_element_removal ( arr , N ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 } ; int N = arr . length ; makeBitonic ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together","code":"static void countSubarrays ( int A [ ] , int N ) {"}
{"text":"Stores the count of subarrays","code":"int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"If current element is different from the next array element","code":"if ( A [ i ] != A [ i + 1 ] ) {"}
{"text":"Increment count","code":"ans ++ ;"}
{"text":"Count the frequency of 1 s and 0 s","code":"for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) {"}
{"text":"Increment count","code":"ans ++ ; } } }"}
{"text":"Print the final count","code":"System . out . print ( ans + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = A . length ;"}
{"text":"Function Call","code":"countSubarrays ( A , N ) ; } }"}
{"text":"Java program of the above approach","code":"import java . util . * ; class GFG { static int maxN = 2002 ;"}
{"text":"lcount [ i ] [ j ] : Stores the count of i on left of index j","code":"static int [ ] [ ] lcount = new int [ maxN ] [ maxN ] ;"}
{"text":"rcount [ i ] [ j ] : Stores the count of i on right of index j","code":"static int [ ] [ ] rcount = new int [ maxN ] [ maxN ] ;"}
{"text":"Function to count unique elements on left and right of any index","code":"static void fill_counts ( int a [ ] , int n ) { int i , j ;"}
{"text":"Find the maximum array element","code":"int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) {"}
{"text":"Calculate prefix sum of counts of each value","code":"for ( j = 1 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; }"}
{"text":"Calculate suffix sum of counts of each value","code":"for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } }"}
{"text":"Function to count quadruples of the required type","code":"static int countSubsequence ( int a [ ] , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; System . out . print ( countSubsequence ( a , a . length ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to remove the outermost parentheses of every primitive substring from the given string","code":"static String removeOuterParentheses ( String S ) {"}
{"text":"Stores the resultant string","code":"String res = \" \" ;"}
{"text":"Stores the count of opened parentheses","code":"int count = 0 ;"}
{"text":"Traverse the string","code":"for ( int c = 0 ; c < S . length ( ) ; c ++ ) {"}
{"text":"If opening parenthesis is encountered and their count exceeds 0","code":"if ( S . charAt ( c ) == ' ( ' && count ++ > 0 )"}
{"text":"Include the character","code":"res += S . charAt ( c ) ;"}
{"text":"If closing parenthesis is encountered and their count is less than count of opening parentheses","code":"if ( S . charAt ( c ) == ' ) ' && count -- > 1 )"}
{"text":"Include the character","code":"res += S . charAt ( c ) ; }"}
{"text":"Return the resultant string","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" ( ( ) ( ) ) ( ( ) ) ( ) \" ; System . out . print ( removeOuterParentheses ( S ) ) ; } }"}
{"text":"Java implementation for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the longest subarray with increasing contiguous elements","code":"public static int maxiConsecutiveSubarray ( int arr [ ] , int N ) {"}
{"text":"Stores the length of required longest subarray","code":"int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"Stores the length of length of longest such subarray from ith index","code":"int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) {"}
{"text":"If consecutive elements are increasing and differ by 1","code":"if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; }"}
{"text":"Otherwise","code":"else { break ; } }"}
{"text":"Update the longest subarray obtained so far","code":"maxi = Math . max ( maxi , cnt ) ; i = j ; }"}
{"text":"Return the length obtained","code":"return maxi ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; System . out . println ( maxiConsecutiveSubarray ( arr , N ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG { static int N = 100005 ;"}
{"text":"Function to generate prime numbers using Sieve of Eratosthenes","code":"static void SieveOfEratosthenes ( boolean [ ] prime , int p_size ) {"}
{"text":"Set 0 and 1 as non - prime","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {"}
{"text":"If p is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Set all multiples of p as non - prime","code":"for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to find the digit sum of a given number","code":"static int digitSum ( int number ) {"}
{"text":"Stores the sum of digits","code":"int sum = 0 ; while ( number > 0 ) {"}
{"text":"Extract digits and add to the sum","code":"sum += ( number % 10 ) ; number \/= 10 ; }"}
{"text":"Return the sum of the digits","code":"return sum ; }"}
{"text":"Function to find the longest subsequence with sum of digits of each element equal to a composite number","code":"static void longestCompositeDigitSumSubsequence ( int [ ] arr , int n ) { int count = 0 ; boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Calculate sum of digits of current array element","code":"int res = digitSum ( arr [ i ] ) ;"}
{"text":"If sum of digits equal to 1","code":"if ( res == 1 ) { continue ; }"}
{"text":"If sum of digits is a prime","code":"if ( prime [ res ] == false ) { count ++ ; } } System . out . println ( count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 } ; int n = arr . length ;"}
{"text":"Function call","code":"longestCompositeDigitSumSubsequence ( arr , n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static int sum ;"}
{"text":"Structure of Binary Tree","code":"static class Node { int data ; Node left , right ; } ;"}
{"text":"Function to create a new node","code":"static Node newnode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = null ; temp . right = null ;"}
{"text":"Return the created node","code":"return temp ; }"}
{"text":"Function to insert a node in the tree","code":"static Node insert ( String s , int i , int N , Node root , Node temp ) { if ( i == N ) return temp ;"}
{"text":"Left insertion","code":"if ( s . charAt ( i ) == ' L ' ) root . left = insert ( s , i + 1 , N , root . left , temp ) ;"}
{"text":"Right insertion","code":"else root . right = insert ( s , i + 1 , N , root . right , temp ) ;"}
{"text":"Return the root node","code":"return root ; }"}
{"text":"Function to find sum of specially balanced nodes in the Tree","code":"static int SBTUtil ( Node root ) {"}
{"text":"Base Case","code":"if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return root . data ;"}
{"text":"Find the left subtree sum","code":"int left = SBTUtil ( root . left ) ;"}
{"text":"Find the right subtree sum","code":"int right = SBTUtil ( root . right ) ;"}
{"text":"Condition of specially balanced node","code":"if ( root . left != null && root . right != null ) {"}
{"text":"Condition of specially balanced node","code":"if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root . data ; } }"}
{"text":"Return the sum","code":"return left + right + root . data ; }"}
{"text":"Function to build the binary tree","code":"static Node build_tree ( int R , int N , String str [ ] , int values [ ] ) {"}
{"text":"Form root node of the tree","code":"Node root = newnode ( R ) ; int i ;"}
{"text":"Insert nodes into tree","code":"for ( i = 0 ; i < N - 1 ; i ++ ) { String s = str [ i ] ; int x = values [ i ] ;"}
{"text":"Create a new Node","code":"Node temp = newnode ( x ) ;"}
{"text":"Insert the node","code":"root = insert ( s , 0 , s . length ( ) , root , temp ) ; }"}
{"text":"Return the root of the Tree","code":"return root ; }"}
{"text":"Function to find the sum of specially balanced nodes","code":"static void speciallyBalancedNodes ( int R , int N , String str [ ] , int values [ ] ) {"}
{"text":"Build Tree","code":"Node root = build_tree ( R , N , str , values ) ;"}
{"text":"Stores the sum of specially balanced node","code":"sum = 0 ;"}
{"text":"Function Call","code":"SBTUtil ( root ) ;"}
{"text":"Print required sum","code":"System . out . print ( sum + \" \u2581 \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given nodes","code":"int N = 7 ;"}
{"text":"Given root","code":"int R = 12 ;"}
{"text":"Given path info of nodes from root","code":"String str [ ] = { \" L \" , \" R \" , \" RL \" , \" RR \" , \" RLL \" , \" RLR \" } ;"}
{"text":"Given node values","code":"int values [ ] = { 17 , 16 , 4 , 9 , 2 , 3 } ;"}
{"text":"Function Call","code":"speciallyBalancedNodes ( R , N , str , values ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the position of the pair that covers every pair in the array arr [ ] [ ]","code":"static void position ( int arr [ ] [ ] , int N ) {"}
{"text":"Stores the index of the resultant pair","code":"int pos = - 1 ;"}
{"text":"To count the occurences","code":"int count ;"}
{"text":"Iterate to check every pair","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Set count to 0","code":"count = 0 ; for ( int j = 0 ; j < N ; j ++ ) {"}
{"text":"Condition to checked for overlapping of pairs","code":"if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } }"}
{"text":"If that pair can cover all other pairs then store its position","code":"if ( count == N ) { pos = i ; } }"}
{"text":"If position not found","code":"if ( pos == - 1 ) { System . out . print ( pos ) ; }"}
{"text":"Otherwise","code":"else { System . out . print ( pos + 1 ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array of pairs","code":"int arr [ ] [ ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . length ;"}
{"text":"Function Call","code":"position ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the position of the pair that covers every pair in the array arr [ ] [ ]","code":"static void position ( int arr [ ] [ ] , int N ) {"}
{"text":"Position to store the index","code":"int pos = - 1 ;"}
{"text":"Stores the maximum second value","code":"int right = Integer . MIN_VALUE ;"}
{"text":"Stores the minimum first value","code":"int left = Integer . MAX_VALUE ;"}
{"text":"Iterate over the array of pairs","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update right maximum","code":"if ( arr [ i ] [ 1 ] > right ) { right = arr [ i ] [ 1 ] ; }"}
{"text":"Update left minimum","code":"if ( arr [ i ] [ 0 ] < left ) { left = arr [ i ] [ 0 ] ; } }"}
{"text":"Iterate over the array of pairs","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If any pair exists with value { left , right } then store it","code":"if ( arr [ i ] [ 0 ] == left && arr [ i ] [ 1 ] == right ) { pos = i + 1 ; } }"}
{"text":"Print the answer","code":"System . out . print ( pos + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array of pairs","code":"int arr [ ] [ ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . length ;"}
{"text":"Function Call","code":"position ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; import java . io . * ; import java . lang . Math ; class GFG {"}
{"text":"Function to minimize the count of operations to make str1 and str2 permutations of each other","code":"static int ctMinEdits ( String str1 , String str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ;"}
{"text":"Store the frequency of each character of str1","code":"int freq1 [ ] = new int [ 256 ] ; Arrays . fill ( freq1 , 0 ) ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 . charAt ( i ) ] ++ ; }"}
{"text":"Store the frequency of each character of str2","code":"int freq2 [ ] = new int [ 256 ] ; Arrays . fill ( freq2 , 0 ) ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 . charAt ( i ) ] ++ ; }"}
{"text":"Traverse the freq1 [ ] and freq2 [ ]","code":"for ( int i = 0 ; i < 256 ; i ++ ) {"}
{"text":"If frequency of character in str1 is greater than str2","code":"if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; }"}
{"text":"Otherwise","code":"else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } }"}
{"text":"Store sum of freq1 [ ]","code":"int sum1 = 0 ;"}
{"text":"Store sum of freq2 [ ]","code":"int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . max ( sum1 , sum2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( final String [ ] args ) { String str1 = \" geeksforgeeks \" ; String str2 = \" geeksforcoder \" ; System . out . println ( ctMinEdits ( str1 , str2 ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . io . * ; class GFG {"}
{"text":"Function to find the minimum number needed to be added so that the sum of the digits does not exceed K","code":"static void CountPairs ( int a [ ] , int b [ ] , int n ) {"}
{"text":"Stores the sum of element at each corresponding index","code":"int C [ ] = new int [ n ] ;"}
{"text":"Find the sum of each index of both array","code":"for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; }"}
{"text":"Stores frequency of each element present in sumArr map < int , int > freqCount ;","code":"HashMap < Integer , Integer > freqCount = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! freqCount . containsKey ( C [ i ] ) ) freqCount . put ( C [ i ] , 1 ) ; else freqCount . put ( C [ i ] , freqCount . get ( C [ i ] ) + 1 ) ; }"}
{"text":"Initialize number of pairs","code":"int NoOfPairs = 0 ; for ( Map . Entry < Integer , Integer > x : freqCount . entrySet ( ) ) { int y = x . getValue ( ) ;"}
{"text":"Add possible vaid pairs","code":"NoOfPairs = NoOfPairs + y * ( y - 1 ) \/ 2 ; }"}
{"text":"Return Number of Pairs","code":"System . out . println ( NoOfPairs ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given array arr [ ] and brr [ ]","code":"int arr [ ] = { 1 , 4 , 20 , 3 , 10 , 5 } ; int brr [ ] = { 9 , 6 , 1 , 7 , 11 , 6 } ;"}
{"text":"Size of given array","code":"int N = arr . length ;"}
{"text":"Function calling","code":"CountPairs ( arr , brr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the median change after removing elements from arr2 [ ]","code":"public static void medianChange ( List < Integer > arr1 , List < Integer > arr2 ) { int N = arr1 . size ( ) ;"}
{"text":"To store the median","code":"List < Integer > median = new ArrayList < > ( ) ;"}
{"text":"If N is odd","code":"if ( ( N & 1 ) != 0 ) median . add ( arr1 . get ( N \/ 2 ) * 1 ) ;"}
{"text":"If N is even","code":"else median . add ( ( arr1 . get ( N \/ 2 ) + arr1 . get ( ( N - 1 ) \/ 2 ) ) \/ 2 ) ; for ( int x = 0 ; x < arr2 . size ( ) ; x ++ ) {"}
{"text":"Find the current element in arr1","code":"int it = arr1 . indexOf ( arr2 . get ( x ) ) ;"}
{"text":"Erase the element","code":"arr1 . remove ( it ) ;"}
{"text":"Decrement N","code":"N -- ;"}
{"text":"If N is odd","code":"if ( ( N & 1 ) != 0 ) { median . add ( arr1 . get ( N \/ 2 ) * 1 ) ; }"}
{"text":"If N is even","code":"else { median . add ( ( arr1 . get ( N \/ 2 ) + arr1 . get ( ( N - 1 ) \/ 2 ) ) \/ 2 ) ; } }"}
{"text":"Print the corresponding difference of median","code":"for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { System . out . print ( median . get ( i + 1 ) - median . get ( i ) + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given arrays","code":"List < Integer > arr1 = new ArrayList < Integer > ( ) { { add ( 2 ) ; add ( 4 ) ; add ( 6 ) ; add ( 8 ) ; add ( 10 ) ; } } ; List < Integer > arr2 = new ArrayList < Integer > ( ) { { add ( 4 ) ; add ( 6 ) ; } } ;"}
{"text":"Function Call","code":"medianChange ( arr1 , arr2 ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"NFA variable that keeps track of the state while transaction .","code":"static int nfa = 1 ;"}
{"text":"This checks for invalid input .","code":"static int flag = 0 ;"}
{"text":"Function for the state Q2","code":"static void state1 ( char c ) {"}
{"text":"State transitions ' a ' takes to Q4 , and ' b ' and ' c ' remain at Q2","code":"if ( c == ' a ' ) nfa = 2 ; else if ( c == ' b ' c == ' c ' ) nfa = 1 ; else flag = 1 ; }"}
{"text":"Function for the state Q3","code":"static void state2 ( char c ) {"}
{"text":"State transitions ' a ' takes to Q3 , and ' b ' and ' c ' remain at Q4","code":"if ( c == ' a ' ) nfa = 3 ; else if ( c == ' b ' c == ' c ' ) nfa = 2 ; else flag = 1 ; }"}
{"text":"Function for the state Q4","code":"static void state3 ( char c ) {"}
{"text":"State transitions ' a ' takes to Q2 , and ' b ' and ' c ' remain at Q3","code":"if ( c == ' a ' ) nfa = 1 ; else if ( c == ' b ' c == ' c ' ) nfa = 3 ; else flag = 1 ; }"}
{"text":"Function for the state Q5","code":"static void state4 ( char c ) {"}
{"text":"State transitions ' b ' takes to Q6 , and ' a ' and ' c ' remain at Q5","code":"if ( c == ' b ' ) nfa = 5 ; else if ( c == ' a ' c == ' c ' ) nfa = 4 ; else flag = 1 ; }"}
{"text":"Function for the state Q6","code":"static void state5 ( char c ) {"}
{"text":"State transitions ' b ' takes to Q7 , and ' a ' and ' c ' remain at Q7","code":"if ( c == ' b ' ) nfa = 6 ; else if ( c == ' a ' c == ' c ' ) nfa = 5 ; else flag = 1 ; }"}
{"text":"Function for the state Q7","code":"static void state6 ( char c ) {"}
{"text":"State transitions ' b ' takes to Q5 , and ' a ' and ' c ' remain at Q7","code":"if ( c == ' b ' ) nfa = 4 ; else if ( c == ' a ' c == ' c ' ) nfa = 6 ; else flag = 1 ; }"}
{"text":"Function for the state Q8","code":"static void state7 ( char c ) {"}
{"text":"State transitions ' c ' takes to Q9 , and ' a ' and ' b ' remain at Q8","code":"if ( c == ' c ' ) nfa = 8 ; else if ( c == ' b ' c == ' a ' ) nfa = 7 ; else flag = 1 ; }"}
{"text":"Function for the state Q9","code":"static void state8 ( char c ) {"}
{"text":"State transitions ' c ' takes to Q10 , and ' a ' and ' b ' remain at Q9","code":"if ( c == ' c ' ) nfa = 9 ; else if ( c == ' b ' c == ' a ' ) nfa = 8 ; else flag = 1 ; }"}
{"text":"Function for the state Q10","code":"static void state9 ( char c ) {"}
{"text":"State transitions ' c ' takes to Q8 , and ' a ' and ' b ' remain at Q10","code":"if ( c == ' c ' ) nfa = 7 ; else if ( c == ' b ' c == ' a ' ) nfa = 9 ; else flag = 1 ; }"}
{"text":"Function to check for 3 a 's","code":"static boolean checkA ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s . charAt ( i ) ) ; else if ( nfa == 2 ) state2 ( s . charAt ( i ) ) ; else if ( nfa == 3 ) state3 ( s . charAt ( i ) ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } return false ; }"}
{"text":"Function to check for 3 b 's","code":"static boolean checkB ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s . charAt ( i ) ) ; else if ( nfa == 5 ) state5 ( s . charAt ( i ) ) ; else if ( nfa == 6 ) state6 ( s . charAt ( i ) ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } return false ; }"}
{"text":"Function to check for 3 c 's","code":"static boolean checkC ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s . charAt ( i ) ) ; else if ( nfa == 8 ) state8 ( s . charAt ( i ) ) ; else if ( nfa == 9 ) state9 ( s . charAt ( i ) ) ; } if ( nfa == 7 ) { return true ; } return false ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \" bbbca \" ; int x = 5 ;"}
{"text":"If any of the states is true , that is , if either the number of a ' s \u2581 or \u2581 number \u2581 of \u2581 b ' s or number of c 's  is a multiple of three, then the string is accepted","code":"if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { System . out . println ( \" ACCEPTED \" ) ; } else { if ( flag == 0 ) { System . out . println ( \" NOT \u2581 ACCEPTED \" ) ; } else { System . out . println ( \" INPUT \u2581 OUT \u2581 OF \u2581 DICTIONARY . \" ) ; } } } }"}
{"text":"Java Program to count positions such that all elements before it are greater","code":"class GFG {"}
{"text":"Function to count positions such that all elements before it are greater","code":"static int getPositionCount ( int a [ ] , int n ) {"}
{"text":"Count is initially 1 for the first element","code":"int count = 1 ;"}
{"text":"Initial Minimum","code":"int min = a [ 0 ] ;"}
{"text":"Traverse the array","code":"for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"If current element is new minimum","code":"if ( a [ i ] <= min ) {"}
{"text":"Update minimum","code":"min = a [ i ] ;"}
{"text":"Increment count","code":"count ++ ; } } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = a . length ; System . out . print ( getPositionCount ( a , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the maximum sum in a subarray of size k","code":"static int maxSum ( int arr [ ] , int n , int k ) {"}
{"text":"k must be greater","code":"if ( n < k ) { return - 1 ; }"}
{"text":"Compute sum of first window of size k","code":"int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ;"}
{"text":"Compute sums of remaining windows by removing first element of previous window and adding last element of current window .","code":"int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . max ( res , curr_sum ) ; } return res ; }"}
{"text":"Function to return the length of subarray Sum of all the subarray of this length is less than or equal to K","code":"static int solve ( int arr [ ] , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ;"}
{"text":"Binary search from l to r as all the array elements are positive so that the maximum subarray sum is monotonically increasing","code":"while ( l <= r ) { m = ( l + r ) \/ 2 ;"}
{"text":"Check if the subarray sum is greater than K or not","code":"if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ;"}
{"text":"Update the maximum length","code":"max_len = m ; } } return max_len ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 10 ; System . out . println ( solve ( arr , n , k ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int MAX = 100001 ; static int ROW = 10 ; static int COl = 3 ; static Vector < Integer > [ ] indices = new Vector [ MAX ] ;"}
{"text":"All possible solutions of the equation 1 \/ a + 1 \/ b + 1 \/ c = 1","code":"static int test [ ] [ ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ;"}
{"text":"Function to find the triplets","code":"static int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { indices [ i ] = new Vector < > ( ) ; }"}
{"text":"Storing indices of the elements","code":"for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . add ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ;"}
{"text":"Check if y can act as the middle element of triplet with the given solution of 1 \/ a + 1 \/ b + 1 \/ c = 1","code":"if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s \/ test [ j ] [ 0 ] ; int z = s \/ test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = - 1 ;"}
{"text":"Binary search to find the number of possible values of the first element","code":"while ( l <= r ) { int m = ( l + r ) \/ 2 ; if ( indices [ x ] . get ( m ) < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = - 1 ;"}
{"text":"Binary search to find the number of possible values of the third element","code":"while ( l <= r ) { int m = ( l + r ) \/ 2 ; if ( indices [ z ] . get ( m ) > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) {"}
{"text":"Contribution to the answer would be the multiplication of the possible values for the first and the third element","code":"answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int array [ ] = { 2 , 4 , 5 , 6 , 7 } ; int n = array . length ; System . out . println ( find_triplet ( array , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG { static int distinct ( int [ ] arr , int n ) { int count = 0 ;"}
{"text":"if array has only one element , return 1","code":"if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"For first element compare with only next element","code":"if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; }"}
{"text":"For remaining elements compare with both prev and next elements","code":"else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } }"}
{"text":"For last element compare with only prev element","code":"if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = arr . length ; System . out . println ( distinct ( arr , n ) ) ; } }"}
{"text":"java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {"}
{"text":"Function to check if an array is sorted or not","code":"static boolean isSorted ( int [ ] [ ] arr , int N ) {"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } }"}
{"text":"Return true","code":"return true ; }"}
{"text":"Function to check if it is possible to sort the array w . r . t . first element","code":"static String isPossibleToSort ( int [ ] [ ] arr , int N ) {"}
{"text":"Stores the ID of the first element","code":"int group = arr [ 0 ] [ 1 ] ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"If arr [ i ] . second is not equal to that of the group","code":"if ( arr [ i ] [ 1 ] != group ) { return \" Yes \" ; } }"}
{"text":"If array is sorted","code":"if ( isSorted ( arr , N ) ) { return \" Yes \" ; } else { return \" No \" ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 340000 , 2 } , { 45000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = arr . length ; System . out . print ( isPossibleToSort ( arr , N ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . lang . * ; import java . util . * ;"}
{"text":"Structure of a node","code":"class Node { Node left , right ; int data ; public Node ( int data ) { this . data = data ; left = null ; right = null ; } } class AlphaScore { Node root ; AlphaScore ( ) { root = null ; } static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ;"}
{"text":"Function to calculate and return the Alpha Score of the journey","code":"public static long getAlphaScore ( Node node ) {"}
{"text":"Traverse left subtree","code":"if ( node . left != null ) getAlphaScore ( node . left ) ;"}
{"text":"Calculate the alpha score of the current step","code":"sum = ( sum + node . data ) % mod ;"}
{"text":"Update alpha score of the journey","code":"total_sum = ( total_sum + sum ) % mod ;"}
{"text":"Traverse right subtree","code":"if ( node . right != null ) getAlphaScore ( node . right ) ;"}
{"text":"Return","code":"return total_sum ; }"}
{"text":"Function to construct a BST from the sorted array arr [ ]","code":"public static Node constructBST ( int [ ] arr , int start , int end , Node root ) { if ( start > end ) return null ; int mid = ( start + end ) \/ 2 ;"}
{"text":"Insert root","code":"if ( root == null ) root = new Node ( arr [ mid ] ) ;"}
{"text":"Construct left subtree","code":"root . left = constructBST ( arr , start , mid - 1 , root . left ) ;"}
{"text":"Construct right subtree","code":"root . right = constructBST ( arr , mid + 1 , end , root . right ) ;"}
{"text":"Return root","code":"return root ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 10 , 11 , 12 } ; int length = arr . length ;"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ; Node root = null ;"}
{"text":"Construct BST from the sorted array","code":"root = constructBST ( arr , 0 , length - 1 , root ) ; System . out . println ( getAlphaScore ( root ) ) ; } }"}
{"text":"Java program to sort an array in decreasing order of their frequency","code":"import java . util . * ; class GFG {"}
{"text":"Function that return the index upto all the array elements are updated .","code":"static int sortByFreq ( Integer [ ] arr , int n ) {"}
{"text":"Initialise maxE = - 1","code":"int maxE = - 1 ;"}
{"text":"Find the maximum element of arr [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) { maxE = Math . max ( maxE , arr [ i ] ) ; }"}
{"text":"Create frequency array freq [ ]","code":"int freq [ ] = new int [ maxE + 1 ] ;"}
{"text":"Update the frequency array as per the occurrence of element in arr [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; }"}
{"text":"Initialise cnt to 0","code":"int cnt = 0 ;"}
{"text":"Traversing freq [ ]","code":"for ( int i = 0 ; i <= maxE ; i ++ ) {"}
{"text":"If freq of an element is greater than 0 update the value of arr [ ] at index cnt & increment cnt","code":"if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } }"}
{"text":"Return cnt","code":"return cnt ; }"}
{"text":"Function that print array arr [ ] elements in sorted order","code":"static void printSortedArray ( Integer [ ] arr , int cnt ) {"}
{"text":"Traversing arr [ ] till index cnt","code":"for ( int i = 0 ; i < cnt ; i ++ ) {"}
{"text":"Find frequency of elements","code":"int frequency = arr [ i ] \/ 100000 ;"}
{"text":"Find value at index i","code":"int value = 100000 - ( arr [ i ] % 100000 ) ;"}
{"text":"Traversing till frequency to print value at index i","code":"for ( int j = 0 ; j < frequency ; j ++ ) { System . out . print ( value + \" \u2581 \" ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Integer arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ;"}
{"text":"Size of array arr [ ]","code":"int n = arr . length ;"}
{"text":"Function call to get cnt","code":"int cnt = sortByFreq ( arr , n ) ;"}
{"text":"Sort the arr [ ] in decreasing order","code":"Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;"}
{"text":"Function that prints elements in decreasing order","code":"printSortedArray ( arr , cnt ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check whether we can make n rectangles of equal area","code":"static boolean checkRectangles ( int [ ] arr , int n ) { boolean ans = true ;"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"Find the area of any one rectangle","code":"int area = arr [ 0 ] * arr [ 4 * n - 1 ] ;"}
{"text":"Check whether we have two equal sides for each rectangle and that area of each rectangle formed is the same","code":"for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) {"}
{"text":"Update the answer to false if any condition fails","code":"ans = false ; break ; } }"}
{"text":"If possible","code":"if ( ans ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the count of elements which are not in the correct position when sorted","code":"static int cntElements ( int arr [ ] , int n ) {"}
{"text":"To store a copy of the original array","code":"int copy_arr [ ] = new int [ n ] ;"}
{"text":"Copy the elements of the given array to the new array","code":"for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ;"}
{"text":"To store the required count","code":"int count = 0 ;"}
{"text":"Sort the original array","code":"Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If current element was not at the right position","code":"if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = arr . length ; System . out . println ( cntElements ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }"}
{"text":"Function to find the required pairs","code":"static void findPairs ( int arr [ ] , int n , int k , int d ) {"}
{"text":"There has to be atleast 2 * k elements","code":"if ( n < 2 * k ) { System . out . print ( - 1 ) ; return ; }"}
{"text":"To store the pairs","code":"Vector < pair > pairs = new Vector < pair > ( ) ;"}
{"text":"Sort the given array","code":"Arrays . sort ( arr ) ;"}
{"text":"For every possible pair","code":"for ( int i = 0 ; i < k ; i ++ ) {"}
{"text":"If the current pair is valid","code":"if ( arr [ n - k + i ] - arr [ i ] >= d ) {"}
{"text":"Insert it into the pair vector","code":"pair p = new pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . add ( p ) ; } }"}
{"text":"If k pairs are not possible","code":"if ( pairs . size ( ) < k ) { System . out . print ( - 1 ) ; return ; }"}
{"text":"Print the pairs","code":"for ( pair v : pairs ) { System . out . println ( \" ( \" + v . first + \" , \u2581 \" + v . second + \" ) \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = arr . length ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . Arrays ; import java . io . * ; class GFG {"}
{"text":"Function to return the count of pairs from arr [ ] with the given sum","code":"static int pairs_count ( int arr [ ] , int n , int sum ) {"}
{"text":"To store the count of pairs","code":"int ans = 0 ;"}
{"text":"Sort the given array","code":"Arrays . sort ( arr ) ;"}
{"text":"Take two pointers","code":"int i = 0 , j = n - 1 ; while ( i < j ) {"}
{"text":"If sum is greater","code":"if ( arr [ i ] + arr [ j ] < sum ) i ++ ;"}
{"text":"If sum is lesser","code":"else if ( arr [ i ] + arr [ j ] > sum ) j -- ;"}
{"text":"If sum is equal","code":"else {"}
{"text":"Find the frequency of arr [ i ]","code":"int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ;"}
{"text":"Find the frequency of arr [ j ]","code":"int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ;"}
{"text":"If arr [ i ] and arr [ j ] are same then remove the extra number counted","code":"if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) \/ 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } }"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 , 5 , - 1 } ; int n = arr . length ; int sum = 6 ; System . out . println ( pairs_count ( arr , n , sum ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"public class GFG { public static boolean check ( String str ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int sum = 0 ;"}
{"text":"for all the characters of the string","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"find the ascii value of the character","code":"int ascii = ( int ) str . charAt ( i ) ;"}
{"text":"check if if its a valid character , if not then return false","code":"if ( ascii < 96 ascii > 122 ) return false ;"}
{"text":"calculate sum of all the characters ascii values","code":"sum += ascii ;"}
{"text":"find minimum ascii value from the string","code":"if ( min > ascii ) min = ascii ;"}
{"text":"find maximum ascii value from the string","code":"if ( max < ascii ) max = ascii ; }"}
{"text":"To get the previous element of the minimum ASCII value","code":"min -= 1 ;"}
{"text":"take the expected sum from the above equation","code":"int eSum = ( ( max * ( max + 1 ) ) \/ 2 ) - ( ( min * ( min + 1 ) ) \/ 2 ) ;"}
{"text":"check if the expected sum is equals to the calculated sum or not","code":"return sum == eSum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"1 st example","code":"String str = \" dcef \" ; if ( check ( str ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;"}
{"text":"2 nd example","code":"String str1 = \" xyza \" ; if ( check ( str1 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the sum of minimum of all subarrays","code":"static int findKth ( int arr [ ] , int n , int k ) { HashSet < Integer > missing = new HashSet < > ( ) ; int count = 0 ;"}
{"text":"Insert all the elements in a set","code":"for ( int i = 0 ; i < n ; i ++ ) { missing . add ( arr [ i ] ) ; }"}
{"text":"Find the maximum and minimum element","code":"int maxm = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minm = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ;"}
{"text":"Traverse from the minimum to maximum element","code":"for ( int i = minm + 1 ; i < maxm ; i ++ ) {"}
{"text":"Check if \" i \" is missing","code":"if ( ! missing . contains ( i ) ) { count ++ ; }"}
{"text":"Check if it is kth missing","code":"if ( count == k ) { return i ; } }"}
{"text":"If no kth element is missing","code":"return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 10 , 9 , 4 } ; int n = arr . length ; int k = 5 ; System . out . println ( findKth ( arr , n , k ) ) ; } }"}
{"text":"Java program to sort linked list containing values from 1 to N","code":"import java . util . * ; class GFG {"}
{"text":"Link list node","code":"static class Node { int data ; Node next ; } ; static Node start ;"}
{"text":"Function to sort linked list","code":"static void sortList ( Node head ) { int startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } }"}
{"text":"Function to add a node at the beginning of Linked List","code":"static void push ( Node head_ref , int new_data ) {"}
{"text":"allocate node","code":"Node new_node = new Node ( ) ;"}
{"text":"put in the data","code":"new_node . data = new_data ;"}
{"text":"link the old list off the new node","code":"new_node . next = head_ref ;"}
{"text":"move the head to point to the new node","code":"head_ref = new_node ; start = head_ref ; }"}
{"text":"This function prints contents of linked list starting from the given node","code":"static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; node = node . next ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { start = null ;"}
{"text":"The constructed linked list is : 3 -> 5 -> 4 -> 6 -> 1 -> 2","code":"push ( start , 2 ) ; push ( start , 1 ) ; push ( start , 6 ) ; push ( start , 4 ) ; push ( start , 5 ) ; push ( start , 3 ) ; sortList ( start ) ; printList ( start ) ; } }"}
{"text":"Java program to recursively check Linked List is sorted in descending order or not","code":"class GfG {"}
{"text":"Linked list node","code":"static class Node { int data ; Node next ; }"}
{"text":"function to Check Linked List is sorted in descending order or not","code":"static boolean isSortedDesc ( Node head ) {"}
{"text":"Base cases","code":"if ( head == null head . next == null ) return true ;"}
{"text":"Check first two nodes and recursively check remaining .","code":"return ( head . data > head . next . data && isSortedDesc ( head . next ) ) ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; }"}
{"text":"Driver program to test above","code":"public static void main ( String [ ] args ) { Node head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to sort an array such that sum of product of alternate element is minimum .","code":"import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Vector ; class GFG { static int minSum ( int arr [ ] , int n ) {"}
{"text":"create evenArr [ ] and oddArr [ ]","code":"Vector < Integer > evenArr = new Vector < > ( ) ; Vector < Integer > oddArr = new Vector < > ( ) ;"}
{"text":"sort main array in ascending order","code":"Arrays . sort ( arr ) ;"}
{"text":"Put elements in oddArr [ ] and evenArr [ ] as per desired value .","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( i < n \/ 2 ) { oddArr . add ( arr [ i ] ) ; } else { evenArr . add ( arr [ i ] ) ; } }"}
{"text":"sort evenArr [ ] in descending order","code":"Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( evenArr , comparator ) ;"}
{"text":"merge both sub - array and calculate minimum sum of product of alternate elements","code":"int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; arr [ i ++ ] = oddArr . get ( j ) ; sum += evenArr . get ( j ) * oddArr . get ( j ) ; } return sum ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; System . out . println ( \" Minimum \u2581 required \u2581 sum \u2581 = \u2581 \" + minSum ( arr , n ) ) ; System . out . println ( \" Sorted \u2581 array \u2581 in \u2581 required \u2581 format \u2581 : \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } }"}
{"text":"Java implementation for the above approach","code":"class GFG {"}
{"text":"Function to calculate minimum time to print all characters in the string","code":"static void minTime ( String word ) { int ans = 0 ;"}
{"text":"Current element where the pointer is pointing","code":"int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) {"}
{"text":"Find index of that element","code":"int k = ( int ) word . charAt ( i ) - 97 ;"}
{"text":"Calculate absolute difference between pointer index and character index as clockwise distance","code":"int a = Math . abs ( curr - k ) ;"}
{"text":"Subtract clockwise time from 26 to get anti - clockwise time","code":"int b = 26 - Math . abs ( curr - k ) ;"}
{"text":"Add minimum of both times to the answer","code":"ans += Math . min ( a , b ) ;"}
{"text":"Add one unit time to print the character","code":"ans ++ ; curr = ( int ) word . charAt ( i ) - 97 ; }"}
{"text":"Print the final answer","code":"System . out . print ( ans ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given string word","code":"String str = \" zjpc \" ;"}
{"text":"Function call","code":"minTime ( str ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum number of steps required to reduce N to 1","code":"static int reduceToOne ( long N ) {"}
{"text":"Stores the number of steps required","code":"int cnt = 0 ; while ( N != 1 ) {"}
{"text":"If the value of N is equal to 2 or N is odd","code":"if ( N == 2 || ( N % 2 == 1 ) ) {"}
{"text":"Decrement N by 1","code":"N = N - 1 ;"}
{"text":"Increment cnt by 1","code":"cnt ++ ; }"}
{"text":"If N is even","code":"else if ( N % 2 == 0 ) {"}
{"text":"Update N","code":"N = N \/ ( N \/ 2 ) ;"}
{"text":"Increment cnt by 1","code":"cnt ++ ; } }"}
{"text":"Return the number of steps obtained","code":"return cnt ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { long N = 35 ; System . out . println ( reduceToOne ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum number of diamonds that can be gained in exactly K minutes","code":"static void maxDiamonds ( int A [ ] , int N , int K ) {"}
{"text":"Stores all the array elements","code":"PriorityQueue < Integer > pq = new PriorityQueue < > ( ( a , b ) -> b - a ) ;"}
{"text":"Push all the elements to the priority queue","code":"for ( int i = 0 ; i < N ; i ++ ) { pq . add ( A [ i ] ) ; }"}
{"text":"Stores the required result","code":"int ans = 0 ;"}
{"text":"Loop while the queue is not empty and K is positive","code":"while ( ! pq . isEmpty ( ) && K -- > 0 ) {"}
{"text":"Store the top element from the pq","code":"int top = pq . peek ( ) ;"}
{"text":"Pop it from the pq","code":"pq . remove ( ) ;"}
{"text":"Add it to the answer","code":"ans += top ;"}
{"text":"Divide it by 2 and push it back to the pq","code":"top = top \/ 2 ; pq . add ( top ) ; }"}
{"text":"Print the answer","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = A . length ; maxDiamonds ( A , N , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum cost to make A [ i ] multiple of B [ i ] or vice - versa for every array element","code":"static int MinimumCost ( int A [ ] , int B [ ] , int N ) {"}
{"text":"Stores the minimum cost","code":"int totalCost = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Case 1 : Update A [ i ]","code":"int mod_A = B [ i ] % A [ i ] ; int totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ;"}
{"text":"Case 2 : Update B [ i ]","code":"int mod_B = A [ i ] % B [ i ] ; int totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ;"}
{"text":"Add the minimum of the above two cases","code":"totalCost += Math . min ( totalCost_A , totalCost_B ) ; }"}
{"text":"Return the resultant cost","code":"return totalCost ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 3 , 6 , 3 } ; int B [ ] = { 4 , 8 , 13 } ; int N = A . length ; System . out . print ( MinimumCost ( A , B , N ) ) ; } }"}
{"text":"Java program of the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Print the largest number divisible by 50","code":"static void printLargestDivisible ( int arr [ ] , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) {"}
{"text":"Counting number of 0 s and 7 s","code":"if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; }"}
{"text":"If count of 7 is divisible by 50","code":"if ( count7 % 50 == 0 ) { while ( count7 != 0 ) { System . out . print ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { System . out . print ( 0 ) ; count0 -= 1 ; } }"}
{"text":"If count of 7 is less than 5","code":"else if ( count7 < 5 ) { if ( count0 == 0 ) System . out . print ( \" No \" ) ; else System . out . print ( \"0\" ) ; }"}
{"text":"If count of 7 is not divisible by 50","code":"else {"}
{"text":"Count of groups of 5 in which count of 7 s can be grouped","code":"count7 = count7 - count7 % 5 ; while ( count7 != 0 ) { System . out . print ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { System . out . print ( 0 ) ; count0 -= 1 ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 } ;"}
{"text":"Size of the array","code":"int N = arr . length ; printLargestDivisible ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array","code":"static int findMaxValByRearrArr ( int arr [ ] , int N ) {"}
{"text":"Sort the array in ascending order","code":"Arrays . sort ( arr ) ;"}
{"text":"Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements","code":"int res = 0 ;"}
{"text":"Generate all possible permutations of the array","code":"do {"}
{"text":"Stores sum of GCD ( arr [ i ] , i )","code":"int sum = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update sum","code":"sum += __gcd ( i + 1 , arr [ i ] ) ; }"}
{"text":"Update res","code":"res = Math . max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static boolean next_permutation ( int [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( findMaxValByRearrArr ( arr , N ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum count of elements required to be removed such that frequency of arr [ i ] equal to arr [ i ]","code":"public static int min_elements ( int arr [ ] , int N ) {"}
{"text":"Stores frequency of each element of the array","code":"Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update frequency of arr [ i ]","code":"mp . put ( arr [ i ] , mp . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; }"}
{"text":"Stores minimum count of removals","code":"int cntMinRem = 0 ;"}
{"text":"Traverse the map","code":"for ( int key : mp . keySet ( ) ) {"}
{"text":"Stores key value of the map","code":"int i = key ; int val = mp . get ( i ) ;"}
{"text":"If frequency of i is less than i","code":"if ( val < i ) {"}
{"text":"Update cntMinRem","code":"cntMinRem += val ; }"}
{"text":"If frequency of i is greater than i","code":"else if ( val > i ) {"}
{"text":"Update cntMinRem","code":"cntMinRem += ( val - i ) ; } } return cntMinRem ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 4 , 2 } ; System . out . println ( min_elements ( arr , arr . length ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if an array of equal elements with sum equal to the given array can be obtained or not","code":"static boolean CheckAllarrayEqual ( int [ ] arr , int N ) {"}
{"text":"Base case","code":"if ( N == 1 ) { return true ; }"}
{"text":"Stores sum of array elements","code":"int totalSum = arr [ 0 ] ;"}
{"text":"Stores second largest array element","code":"int secMax = Integer . MIN_VALUE ;"}
{"text":"Stores the largest array element","code":"int Max = arr [ 0 ] ;"}
{"text":"Traverse the array","code":"for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) {"}
{"text":"Update secMax","code":"secMax = Max ;"}
{"text":"Update Max","code":"Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) {"}
{"text":"Update secMax","code":"secMax = arr [ i ] ; }"}
{"text":"Update totalSum","code":"totalSum += arr [ i ] ; }"}
{"text":"If totalSum is less than secMax * ( N - 1 ) )","code":"if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; }"}
{"text":"If totalSum is not divisible by ( N - 1 )","code":"if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 6 , 2 , 2 , 2 } ; int N = arr . length ; if ( CheckAllarrayEqual ( arr , N ) ) { System . out . print ( \" YES \" ) ; } else { System . out . print ( \" NO \" ) ; } } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element","code":"static void Remove_one_element ( int arr [ ] , int n ) {"}
{"text":"Stores xor of odd and even indexed elements from the end","code":"int post_odd = 0 , post_even = 0 ;"}
{"text":"Stores xor of odd and even indexed elements from the start","code":"int curr_odd = 0 , curr_even = 0 ;"}
{"text":"Stores the required count","code":"int res = 0 ;"}
{"text":"Traverse the array in reverse","code":"for ( int i = n - 1 ; i >= 0 ; i -- ) {"}
{"text":"If i is odd","code":"if ( i % 2 != 0 ) post_odd ^= arr [ i ] ;"}
{"text":"If i is even","code":"else post_even ^= arr [ i ] ; }"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If i is odd","code":"if ( i % 2 != 0 ) post_odd ^= arr [ i ] ;"}
{"text":"If i is even","code":"else post_even ^= arr [ i ] ;"}
{"text":"Removing arr [ i ] , post_even stores XOR of odd indexed elements","code":"int X = curr_odd ^ post_even ;"}
{"text":"Removing arr [ i ] , post_odd stores XOR of even indexed elements","code":"int Y = curr_even ^ post_odd ;"}
{"text":"Check if they are equal","code":"if ( X == Y ) res ++ ;"}
{"text":"If i is odd , xor it with curr_odd","code":"if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ;"}
{"text":"If i is even , xor it with curr_even","code":"else curr_even ^= arr [ i ] ; }"}
{"text":"Finally print res","code":"System . out . println ( res ) ; }"}
{"text":"Drivers Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ;"}
{"text":"Given size","code":"int N = arr . length ;"}
{"text":"Function call","code":"Remove_one_element ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to count array indices whose removal makes sum of odd and even indexed elements equal","code":"static int cntIndexesToMakeBalance ( int arr [ ] , int n ) {"}
{"text":"If size of the array is 1","code":"if ( n == 1 ) { return 1 ; }"}
{"text":"If size of the array is 2","code":"if ( n == 2 ) return 0 ;"}
{"text":"Stores sum of even - indexed elements of the given array","code":"int sumEven = 0 ;"}
{"text":"Stores sum of odd - indexed elements of the given array","code":"int sumOdd = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If i is an even number","code":"if ( i % 2 == 0 ) {"}
{"text":"Update sumEven","code":"sumEven += arr [ i ] ; }"}
{"text":"If i is an odd number","code":"else {"}
{"text":"Update sumOdd","code":"sumOdd += arr [ i ] ; } }"}
{"text":"Stores sum of even - indexed array elements till i - th index","code":"int currOdd = 0 ;"}
{"text":"Stores sum of odd - indexed array elements till i - th index","code":"int currEven = arr [ 0 ] ;"}
{"text":"Stores count of indices whose removal makes sum of odd and even indexed elements equal","code":"int res = 0 ;"}
{"text":"Stores sum of even - indexed elements after removing the i - th element","code":"int newEvenSum = 0 ;"}
{"text":"Stores sum of odd - indexed elements after removing the i - th element","code":"int newOddSum = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 1 ; i < n - 1 ; i ++ ) {"}
{"text":"If i is an odd number","code":"if ( i % 2 != 0 ) {"}
{"text":"Update currOdd","code":"currOdd += arr [ i ] ;"}
{"text":"Update newEvenSum","code":"newEvenSum = currEven + sumOdd - currOdd ;"}
{"text":"Update newOddSum","code":"newOddSum = currOdd + sumEven - currEven - arr [ i ] ; }"}
{"text":"If i is an even number","code":"else {"}
{"text":"Update currEven","code":"currEven += arr [ i ] ;"}
{"text":"Update newOddSum","code":"newOddSum = currOdd + sumEven - currEven ;"}
{"text":"Update newEvenSum","code":"newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; }"}
{"text":"If newEvenSum is equal to newOddSum","code":"if ( newEvenSum == newOddSum ) {"}
{"text":"Increase the count","code":"res ++ ; } }"}
{"text":"If sum of even - indexed and odd - indexed elements is equal by removing the first element","code":"if ( sumOdd == sumEven - arr [ 0 ] ) {"}
{"text":"Increase the count","code":"res ++ ; }"}
{"text":"If length of the array is an odd number","code":"if ( n % 2 == 1 ) {"}
{"text":"If sum of even - indexed and odd - indexed elements is equal by removing the last element","code":"if ( sumOdd == sumEven - arr [ n - 1 ] ) {"}
{"text":"Increase the count","code":"res ++ ; } }"}
{"text":"If length of the array is an even number","code":"else {"}
{"text":"If sum of even - indexed and odd - indexed elements is equal by removing the last element","code":"if ( sumEven == sumOdd - arr [ n - 1 ] ) {"}
{"text":"Increase the count","code":"res ++ ; } } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( cntIndexesToMakeBalance ( arr , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the value of A and B whose sum is X and xor is Y","code":"static void findNums ( int X , int Y ) {"}
{"text":"Initialize the two numbers","code":"int A , B ;"}
{"text":"Case 1 : X < Y","code":"if ( X < Y ) { A = - 1 ; B = - 1 ; }"}
{"text":"Case 2 : X - Y is odd","code":"else if ( ( ( Math . abs ( X - Y ) ) & 1 ) != 0 ) { A = - 1 ; B = - 1 ; }"}
{"text":"Case 3 : If both Sum and XOR are equal","code":"else if ( X == Y ) { A = 0 ; B = Y ; }"}
{"text":"Case 4 : If above cases fails","code":"else {"}
{"text":"Update the value of A","code":"A = ( X - Y ) \/ 2 ;"}
{"text":"Check if A & Y value is 0","code":"if ( ( A & Y ) == 0 ) {"}
{"text":"If true , update B","code":"B = ( A + Y ) ; }"}
{"text":"Otherwise assign - 1 to A , - 1 to B","code":"else { A = - 1 ; B = - 1 ; } }"}
{"text":"Print the numbers A and B","code":"System . out . print ( A + \" \u2581 \" + B ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Sum and XOR of 2 numbers","code":"int X = 17 , Y = 13 ;"}
{"text":"Function Call","code":"findNums ( X , Y ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to check if given range have equal number of increasing as well as decreasing subarrays","code":"static void checkCount ( int A [ ] , int Q [ ] [ ] , int q ) {"}
{"text":"Traverse each query","code":"for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ;"}
{"text":"For 0 - based indexing","code":"L -- ; R -- ;"}
{"text":"Condition for same count of increasing & decreasing subarray","code":"if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 11 , 13 , 12 , 14 } ; int Q [ ] [ ] = { { 1 , 4 } , { 2 , 4 } } ; int q = Q . length ; checkCount ( arr , Q , q ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the mean of pair product array of arr [ ]","code":"static double pairProductMean ( int arr [ ] , int N ) {"}
{"text":"Store product of pairs","code":"Vector < Integer > pairArray = new Vector < > ( ) ;"}
{"text":"Generate all unordered pairs","code":"for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ;"}
{"text":"Store product of pairs","code":"pairArray . add ( pairProduct ) ; } }"}
{"text":"Size of pairArray","code":"int length = pairArray . size ( ) ;"}
{"text":"Store sum of pairArray","code":"float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray . get ( i ) ;"}
{"text":"Stores the mean of pairArray [ ]","code":"float mean ;"}
{"text":"Find mean of pairArray [ ]","code":"if ( length != 0 ) mean = sum \/ length ; else mean = 0 ;"}
{"text":"Return the resultant mean","code":"return mean ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ;"}
{"text":"Function Call","code":"System . out . format ( \" % .2f \" , pairProductMean ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the player who loses the game","code":"static void findPlayer ( String str [ ] , int n ) {"}
{"text":"Moves for the first player","code":"int move_first = 0 ;"}
{"text":"Moves for the second player","code":"int move_sec = 0 ;"}
{"text":"Iterate over array of Strings","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"Check if the first and last character are the same","code":"if ( str [ i ] . charAt ( 0 ) == str [ i ] . charAt ( str [ i ] . length ( ) - 1 ) ) {"}
{"text":"Check if String start and end with character '0'","code":"if ( str [ i ] . charAt ( 0 ) == 48 ) move_first ++ ; else move_sec ++ ; } }"}
{"text":"If first player have less moves","code":"if ( move_first <= move_sec ) { System . out . print ( \" Player \u2581 2 \u2581 wins \" ) ; } else { System . out . print ( \" Player \u2581 1 \u2581 wins \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array of Strings","code":"String str [ ] = { \"010\" , \"101\" } ; int N = str [ 0 ] . length ( ) ;"}
{"text":"Function Call","code":"findPlayer ( str , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the number greater than n whose Kth bit is set","code":"static int find_next ( int n , int k ) {"}
{"text":"Iterate from N + 1","code":"int M = n + 1 ; while ( true ) {"}
{"text":"Check if Kth bit is set or not","code":"if ( ( M & ( 1L << k ) ) > 0 ) break ;"}
{"text":"Increment M for next number","code":"M ++ ; }"}
{"text":"Return the minimum value","code":"return M ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N and K","code":"int N = 15 , K = 2 ;"}
{"text":"Function Call","code":"System . out . print ( find_next ( N , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the number greater than n whose Kth bit is set","code":"static int find_next ( int n , int k ) {"}
{"text":"Stores the resultant number","code":"int ans = 0 ;"}
{"text":"If Kth bit is not set","code":"if ( ( n & ( 1L << k ) ) == 0 ) { int cur = 0 ;"}
{"text":"cur will be the sum of all powers of 2 < k","code":"for ( int i = 0 ; i < k ; i ++ ) {"}
{"text":"If the current bit is set","code":"if ( ( n & ( 1L << i ) ) > 0 ) cur += 1L << i ; }"}
{"text":"Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set","code":"ans = ( int ) ( n - cur + ( 1L << k ) ) ; }"}
{"text":"If the kth bit is set","code":"else { int first_unset_bit = - 1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) {"}
{"text":"First unset bit position","code":"if ( ( n & ( 1L << i ) ) == 0 ) { first_unset_bit = i ; break ; }"}
{"text":"sum of bits that are set","code":"else cur += ( 1L << i ) ; }"}
{"text":"Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set","code":"ans = ( int ) ( n - cur + ( 1L << first_unset_bit ) ) ;"}
{"text":"If Kth bit became unset then set it again","code":"if ( ( ans & ( 1L << k ) ) == 0 ) ans += ( 1L << k ) ; }"}
{"text":"Return the resultant number","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 15 , K = 2 ;"}
{"text":"Print ans","code":"System . out . print ( find_next ( N , K ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG { static String largestString ( String num , int k ) {"}
{"text":"Final result String","code":"String ans = \" \" ; for ( char i : num . toCharArray ( ) ) {"}
{"text":"If the current char exceeds the character at the top of the stack","code":"while ( ans . length ( ) > 0 && ans . charAt ( ans . length ( ) - 1 ) < i && k > 0 ) {"}
{"text":"Remove from the end of the String","code":"ans = ans . substring ( 0 , ans . length ( ) - 1 ) ;"}
{"text":"Decrease k for the removal","code":"k -- ; }"}
{"text":"Insert current character","code":"ans += i ; }"}
{"text":"Perform remaining K deletions from the end of the String","code":"while ( ans . length ( ) > 0 && k -- > 0 ) { ans = ans . substring ( 0 , ans . length ( ) - 1 ) ; }"}
{"text":"Return the String","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" zyxedcba \" ; int k = 1 ; System . out . print ( largestString ( str , k ) + \"NEW_LINE\"); } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function that finds the maximum length of the sub - array that contains equal element on both halves of sub - array","code":"static void maxLengthSubArray ( int A [ ] , int N ) {"}
{"text":"To store continuous occurence of the element","code":"int forward [ ] = new int [ N ] ; int backward [ ] = new int [ N ] ;"}
{"text":"To store continuous forkward occurence","code":"for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; }"}
{"text":"To store continuous backward occurence","code":"for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; }"}
{"text":"To store the maximum length","code":"int ans = 0 ;"}
{"text":"Find maximum length","code":"for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . max ( ans , Math . min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; }"}
{"text":"Print the result","code":"System . out . println ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ;"}
{"text":"Size of the array","code":"int N = arr . length ;"}
{"text":"Function call","code":"maxLengthSubArray ( arr , N ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to find the minimum number of n digits divisible by all prime digits","code":"static void minNum ( int n ) { if ( n < 3 ) System . out . println ( - 1 ) ; else System . out . println ( 210 * ( ( int ) ( Math . pow ( 10 , n - 1 ) \/ 210 ) + 1 ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; minNum ( n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; @ SuppressWarnings ( \" unchecked \" ) class GFG {"}
{"text":"Function to return the minimum String of length d having the sum of digits s","code":"static String helper ( int d , int s ) {"}
{"text":"Return a String of length d","code":"StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < d ; i ++ ) { ans . append ( \"0\" ) ; } for ( int i = d - 1 ; i >= 0 ; i -- ) {"}
{"text":"Greedily put 9 's in the end","code":"if ( s >= 9 ) { ans . setCharAt ( i , '9' ) ; s -= 9 ; }"}
{"text":"Put remaining sum","code":"else { char c = ( char ) ( s + ( int ) '0' ) ; ans . setCharAt ( i , c ) ; s = 0 ; } } return ans . toString ( ) ; }"}
{"text":"Function to find the smallest number greater than Y whose sum of digits is X","code":"static String findMin ( int x , int Y ) {"}
{"text":"Convert number y to String","code":"String y = Integer . toString ( Y ) ; int n = y . length ( ) ; ArrayList p = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { p . add ( 0 ) ; }"}
{"text":"Maintain prefix sum of digits","code":"for ( int i = 0 ; i < n ; i ++ ) { p . add ( i , ( int ) ( ( int ) y . charAt ( i ) - ( int ) '0' ) ) ; if ( i > 0 ) { p . add ( i , ( int ) p . get ( i ) + ( int ) p . get ( i - 1 ) ) ; } }"}
{"text":"Iterate over Y from the back where k is current length of suffix","code":"for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) {"}
{"text":"Stores current digit","code":"int d = 0 ; if ( i >= 0 ) { d = ( int ) y . charAt ( i ) - ( int ) '0' ; }"}
{"text":"Increase current digit","code":"for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = j ;"}
{"text":"Sum upto current prefix","code":"if ( i > 0 ) { r += ( int ) p . get ( i - 1 ) ; }"}
{"text":"Return answer if remaining sum can be obtained in suffix","code":"if ( x - r >= 0 && x - r <= 9 * k ) {"}
{"text":"Find suffix of length k having sum of digits x - r","code":"String suf = helper ( k , x - r ) ; String pre = \" \" ; if ( i > 0 ) pre = y . substring ( 0 , i ) ;"}
{"text":"Append current character","code":"char cur = ( char ) ( j + ( int ) '0' ) ; pre += cur ;"}
{"text":"Return the result","code":"return pre + suf ; } } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] arg ) {"}
{"text":"Given number and sum","code":"int x = 18 ; int y = 99 ;"}
{"text":"Function call","code":"System . out . print ( findMin ( x , y ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to generate and return the largest number","code":"public static void largestNumber ( int n , int X , int Y ) { int maxm = Math . max ( X , Y ) ;"}
{"text":"Store the smaller in Y","code":"Y = X + Y - maxm ;"}
{"text":"Store the larger in X","code":"X = maxm ;"}
{"text":"Stores respective counts","code":"int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) {"}
{"text":"If N is divisible by Y","code":"if ( n % Y == 0 ) {"}
{"text":"Append X , N times to the answer","code":"Xs += n ;"}
{"text":"Reduce N to zero","code":"n = 0 ; } else {"}
{"text":"Reduce N by X","code":"n -= X ;"}
{"text":"Append Y , X times to the answer","code":"Ys += X ; } }"}
{"text":"If number can be formed","code":"if ( n == 0 ) { while ( Xs -- > 0 ) System . out . print ( X ) ; while ( Ys -- > 0 ) System . out . print ( Y ) ; }"}
{"text":"Otherwise","code":"else System . out . print ( \" - 1\" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . io . * ; class GFG { static int minChanges ( String str , int N ) { int res ; int count0 = 0 , count1 = 0 ;"}
{"text":"Traverse input string and store the count of 0","code":"for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count0 ++ ; } res = count0 ;"}
{"text":"Traverse the input string again to find minimum number of flips","code":"for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count0 -- ; if ( x == '1' ) count1 ++ ; res = Math . min ( res , count1 + count0 ) ; } return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 9 ; String str = \"000101001\" ; System . out . println ( minChanges ( str , N ) ) ; } }"}
{"text":"Java implementation of the missing number such that maximum absolute difference between adjacent element is minimum","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the missing number such that maximum absolute difference is minimum","code":"static int missingnumber ( int n , int arr [ ] ) { int mn = Integer . MAX_VALUE , mx = Integer . MIN_VALUE ;"}
{"text":"Loop to find the maximum and minimum adjacent element to missing number","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int res = ( mx + mn ) \/ 2 ; return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { - 1 , 10 , - 1 , 12 , - 1 } ;"}
{"text":"Function Call","code":"int res = missingnumber ( n , arr ) ; System . out . print ( res ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the length of the longest common substring of the string X and Y","code":"static int lcsubtr ( char a [ ] , char b [ ] , int length1 , int length2 ) {"}
{"text":"LCSuff [ i ] [ j ] stores the lengths of the longest common suffixes of substrings","code":"int dp [ ] [ ] = new int [ length1 + 1 ] [ length2 + 1 ] ; int max = 0 ;"}
{"text":"Itearate over strings A and B","code":"for ( int i = 0 ; i <= length1 ; ++ i ) { for ( int j = 0 ; j <= length2 ; ++ j ) {"}
{"text":"If first row or column","code":"if ( i == 0 j == 0 ) { dp [ i ] [ j ] = 0 ; }"}
{"text":"If matching is found","code":"else if ( a [ i - 1 ] == b [ j - 1 ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + 1 ; max = Math . max ( dp [ i ] [ j ] , max ) ; }"}
{"text":"Otherwise , if matching is not found","code":"else { dp [ i ] [ j ] = 0 ; } } }"}
{"text":"Finally , return the resultant maximum value LCS","code":"return max ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String m = \"0110\" ; String n = \"1101\" ; char m1 [ ] = m . toCharArray ( ) ; char m2 [ ] = n . toCharArray ( ) ;"}
{"text":"Function Call","code":"System . out . println ( lcsubtr ( m1 , m2 , m1 . length , m2 . length ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG { static int maxN = 20 ; static int maxSum = 50 ; static int minSum = 50 ; static int Base = 50 ;"}
{"text":"To store the states of DP","code":"static int [ ] [ ] dp = new int [ maxN ] [ maxSum + minSum ] ; static boolean [ ] [ ] v = new boolean [ maxN ] [ maxSum + minSum ] ;"}
{"text":"Function to find count of subsets with a given sum","code":"static int findCnt ( int [ ] arr , int i , int required_sum , int n ) {"}
{"text":"Base case","code":"if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; }"}
{"text":"If an already computed subproblem occurs","code":"if ( v [ i ] [ required_sum + Base ] ) return dp [ i ] [ required_sum + Base ] ;"}
{"text":"Set the state as solved","code":"v [ i ] [ required_sum + Base ] = true ;"}
{"text":"Recurrence relation","code":"dp [ i ] [ required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + Base ] ; }"}
{"text":"Function to count ways to split array into pair of subsets with difference K","code":"static void countSubsets ( int [ ] arr , int K , int n ) {"}
{"text":"Store the total sum of element of the array","code":"int sum = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Calculate sum of array elements","code":"sum += arr [ i ] ; }"}
{"text":"Store the required sum","code":"int S1 = ( sum + K ) \/ 2 ;"}
{"text":"Print the number of subsets with sum equal to S1","code":"System . out . print ( findCnt ( arr , 0 , S1 , n ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 2 , 3 } ; int N = arr . length ; int K = 1 ;"}
{"text":"Function Call","code":"countSubsets ( arr , K , N ) ; } }"}
{"text":"Java program for above approach","code":"class GFG { static float [ ] [ ] dp = new float [ 105 ] [ 605 ] ;"}
{"text":"Function to calculate the probability for the given sum to be equal to sum in N throws of dice","code":"static float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ;"}
{"text":"Base cases","code":"if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 \/ 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) \/ 6 ; return dp [ N ] [ sum ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0f ;"}
{"text":"Calculate probability of all sums from a to b","code":"for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ;"}
{"text":"Print the answer","code":"System . out . printf ( \" % .6f \" , probability ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . HashMap ; class GFG {"}
{"text":"Function to find the minimum number to steps to reduce N to 0","code":"static int count ( int n ) {"}
{"text":"Dictionary for storing the precomputed sum","code":"HashMap < Integer , Integer > dp = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Bases Cases","code":"dp . put ( 0 , 0 ) ; dp . put ( 1 , 1 ) ;"}
{"text":"Check if n is not in dp then only call the function so as to reduce no of recursive calls","code":"if ( ! dp . containsKey ( n ) ) dp . put ( n , 1 + Math . min ( n % 2 + count ( n \/ 2 ) , n % 3 + count ( n \/ 3 ) ) ) ;"}
{"text":"Return the answer","code":"return dp . get ( n ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given number N","code":"int N = 6 ;"}
{"text":"Function call","code":"System . out . println ( String . valueOf ( ( count ( N ) ) ) ) ; } }"}
{"text":"Java implementation to find the minimum number of operations required to change an array of all zeros such that every element is greater than the given array","code":"class GFG {"}
{"text":"Function to find the minimum number of operations required to change all the array of zeros such that every element is greater than the given array","code":"static void find_minimum_operations ( int n , int b [ ] , int k ) {"}
{"text":"Declaring the difference array of size N","code":"int d [ ] = new int [ n + 1 ] ;"}
{"text":"Number of operations","code":"int i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"First update the D [ i ] value with the previous value","code":"if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; }"}
{"text":"The index i has to be incremented","code":"if ( b [ i ] > d [ i ] ) {"}
{"text":"We have to perform ( b [ i ] - d [ i ] ) operations more","code":"operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ;"}
{"text":"Increment the range i to i + k by need","code":"d [ i ] += need ;"}
{"text":"Check if i + k is valid index","code":"if ( i + k <= n ) { d [ i + k ] -= need ; } } } System . out . println ( operations ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 5 ; int b [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ;"}
{"text":"Function Call","code":"find_minimum_operations ( n , b , k ) ; } }"}
{"text":"Java implementation to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell","code":"static int ways ( int [ ] [ ] arr , int K ) { int R = arr . length ; int C = arr [ 0 ] . length ; int [ ] [ ] preSum = new int [ R ] [ C ] ;"}
{"text":"Loop to find prefix sum of the given matrix","code":"for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } }"}
{"text":"dp ( r , c , 1 ) = 1 if preSum [ r ] else 0","code":"int [ ] [ ] [ ] dp = new int [ K + 1 ] [ R ] [ C ] ;"}
{"text":"Loop to iterate over the dp table of the given matrix","code":"for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) {"}
{"text":"Check if can cut horizontally at r1 , at least one apple in matrix ( r , c ) -> r1 , C - 1","code":"if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) {"}
{"text":"Check if we can cut vertically at c1 , at least one apple in matrix ( r , c ) -> R - 1 , c1","code":"if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ;"}
{"text":"Function Call","code":"System . out . println ( ways ( arr , k ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG { static int p = 1000000007 ;"}
{"text":"Iterative Function to calculate ( x ^ y ) % p in O ( log y )","code":"static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with result","code":"if ( y % 2 == 1 ) res = ( res * x ) % p ;"}
{"text":"y must be even now","code":"y = y >> 1 ; x = ( x * x ) % p ; } return res ; }"}
{"text":"Iterative Function to calculate ( nCr ) % p and save in f [ n ] [ r ]","code":"static void nCr ( int n , int p , int f [ ] [ ] , int m ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) {"}
{"text":"If j > i then C ( i , j ) = 0","code":"if ( j > i ) { f [ i ] [ j ] = 0 ; }"}
{"text":"If iis equal to j then C ( i , j ) = 1","code":"else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } }"}
{"text":"Function calculate the Final answer","code":"static void ProductOfSubsets ( int arr [ ] , int n , int m ) { int [ ] [ ] f = new int [ n + 1 ] [ 100 ] ; nCr ( n , p - 1 , f , m ) ; Arrays . sort ( arr ) ;"}
{"text":"Initialize ans","code":"long ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"x is count of occurence of arr [ i ] in different set such that index of arr [ i ] in those sets divides K completely .","code":"int x = 0 ; for ( int j = 1 ; j <= m ; j ++ ) {"}
{"text":"Finding the count of arr [ i ] by placing it at index which divides K completely","code":"if ( m % j == 0 ) {"}
{"text":"By Fermat 's theorem","code":"x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } System . out . print ( ans + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 7 , 9 , 3 } ; int K = 4 ; int N = arr . length ; ProductOfSubsets ( arr , N , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the number of ways to write N as sum of k non - negative integers","code":"static int countWays ( int n , int m ) {"}
{"text":"Initialise dp [ ] [ ] array","code":"int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;"}
{"text":"Only 1 way to choose the value with sum K","code":"for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; }"}
{"text":"Initialise sum","code":"int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ;"}
{"text":"Count the ways from previous states","code":"for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; }"}
{"text":"Update the sum","code":"dp [ i ] [ j ] = sum ; } }"}
{"text":"Return the final count of ways","code":"return dp [ m ] [ n ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 2 , K = 3 ;"}
{"text":"Function call","code":"System . out . print ( countWays ( N , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the number of ways to write N as sum of k non - negative integers","code":"static int countWays ( int n , int m ) {"}
{"text":"Initialise dp [ ] [ ] array","code":"int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;"}
{"text":"Fill the dp [ ] [ ] with sum = m","code":"for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } }"}
{"text":"Iterate the dp [ ] [ ] to fill the dp [ ] [ ] array","code":"for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) {"}
{"text":"Condition for first column","code":"if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; }"}
{"text":"Else fill the dp [ ] [ ] with sum till ( i , j )","code":"else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;"}
{"text":"If reach the end , then return the value","code":"if ( i == m && j == n ) { return dp [ i ] [ j ] ; }"}
{"text":"Update at current index","code":"dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Integer . MIN_VALUE ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 2 , K = 3 ;"}
{"text":"Function call","code":"System . out . print ( countWays ( N , K ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . HashMap ; import java . util . Vector ; class GFG {"}
{"text":"Function to pre - store primes","code":"public static void SieveOfEratosthenes ( int MAX , Vector < Integer > primes ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ;"}
{"text":"Sieve method to check if prime or not","code":"for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) {"}
{"text":"Multiples","code":"for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } }"}
{"text":"Pre - store all the primes","code":"for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . add ( i ) ; } }"}
{"text":"Function to find the intest subsequence","code":"public static int findLongest ( int [ ] A , int n ) {"}
{"text":"Hash map","code":"HashMap < Integer , Integer > mpp = new HashMap < > ( ) ; Vector < Integer > primes = new Vector < > ( ) ;"}
{"text":"Call the function to pre - store the primes","code":"SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int [ ] dp = new int [ n ] ;"}
{"text":"Initialize last element with 1 as that is the intest possible","code":"dp [ n - 1 ] = 1 ; mpp . put ( A [ n - 1 ] , n - 1 ) ;"}
{"text":"Iterate from the back and find the intest","code":"for ( int i = n - 2 ; i >= 0 ; i -- ) {"}
{"text":"Get the number","code":"int num = A [ i ] ;"}
{"text":"Initialize dp [ i ] as 1 as the element will only me in the subsequence .","code":"dp [ i ] = 1 ; int maxi = 0 ;"}
{"text":"Iterate in all the primes and multiply to get the next element","code":"for ( int it : primes ) {"}
{"text":"Next element if multiplied with it","code":"int xx = num * it ;"}
{"text":"If exceeds the last element then break","code":"if ( xx > A [ n - 1 ] ) break ;"}
{"text":"If the number is there in the array","code":"else if ( mpp . get ( xx ) != null && mpp . get ( xx ) != 0 ) {"}
{"text":"Get the maximum most element","code":"dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ mpp . get ( xx ) ] ) ; } }"}
{"text":"Hash the element","code":"mpp . put ( A [ i ] , i ) ; } int ans = 1 ;"}
{"text":"Find the intest","code":"for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 } ; int n = a . length ; System . out . println ( findLongest ( a , n ) ) ; } }"}
{"text":"Java program to find the number of Bit Strings of length N with K adjacent set bits","code":"import java . util . * ; class solution {"}
{"text":"Function to find the number of Bit Strings of length N with K adjacent set bits","code":"static int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) {"}
{"text":"Base Case when we form bit string of length n","code":"if ( currentIndex == n ) {"}
{"text":"if f ( bit string ) = k , count this way","code":"if ( adjacentSetBits == k ) return 1 ; return 0 ; } int noOfWays = 0 ;"}
{"text":"Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset","code":"if ( lastBit == 1 ) {"}
{"text":"set the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;"}
{"text":"unset the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( lastBit == 0 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 5 , k = 2 ;"}
{"text":"total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )","code":"int totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; System . out . println ( \" Number \u2581 of \u2581 ways \u2581 = \u2581 \" + totalWays ) ; } }"}
{"text":"Java Program to find sum of all combination takne ( 1 to N ) at a time using dynamic programming","code":"import java . util . * ; class GFG {"}
{"text":"find the postfix sum array","code":"static void postfix ( int a [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } }"}
{"text":"modify the array such that we don 't  have to compute the products which  are obtained before","code":"static void modify ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } }"}
{"text":"finding sum of all combination taken 1 to N at a time","code":"static void allCombination ( int a [ ] , int n ) { int sum = 0 ;"}
{"text":"sum taken 1 at time is simply sum of 1 - N","code":"for ( int i = 1 ; i <= n ; i ++ ) { sum += i ; } System . out . println ( \" f ( 1 ) \u2581 - - > \u2581 \" + sum ) ;"}
{"text":"for sum of products for all combination","code":"for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"finding postfix array","code":"postfix ( a , n - i + 1 ) ;"}
{"text":"sum of products taken i + 1 at a time","code":"sum = 0 ; for ( int j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } System . out . println ( \" f ( \" + ( i + 1 ) + \" ) \u2581 - - > \u2581 \" + sum ) ;"}
{"text":"modify the array for overlapping problem","code":"modify ( a , n ) ; } }"}
{"text":"Driver 's Code","code":"public static void main ( String [ ] args ) { int n = 5 ; int [ ] a = new int [ n ] ;"}
{"text":"storing numbers from 1 to N","code":"for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = i + 1 ; }"}
{"text":"calling allCombination","code":"allCombination ( a , n ) ; } }"}
{"text":"Program to find n - th stair using step size 1 or 2 or 3.","code":"import java . lang . * ; import java . util . * ; public class GfG {"}
{"text":"Returns count of ways to reach n - th stair using 1 or 2 or 3 steps .","code":"public static int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }"}
{"text":"Driver function","code":"public static void main ( String argc [ ] ) { int n = 4 ; System . out . println ( findStep ( n ) ) ; } }"}
{"text":"A recursive Java solution for partition problem","code":"import java . io . * ; class Partition {"}
{"text":"A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum","code":"static boolean isSubsetSum ( int arr [ ] , int n , int sum ) {"}
{"text":"Base Cases","code":"if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ;"}
{"text":"If last element is greater than sum , then ignore it","code":"if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ;"}
{"text":"else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element","code":"return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }"}
{"text":"Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false","code":"static boolean findPartition ( int arr [ ] , int n ) {"}
{"text":"Calculate sum of the elements in array","code":"int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;"}
{"text":"If sum is odd , there cannot be two subsets with equal sum","code":"if ( sum % 2 != 0 ) return false ;"}
{"text":"Find if there is subset with sum equal to half of total sum","code":"return isSubsetSum ( arr , n , sum \/ 2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = arr . length ;"}
{"text":"Function call","code":"if ( findPartition ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" + \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 \" + \" two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }"}
{"text":"A Dynamic Programming based Java program to partition problem","code":"import java . io . * ; class GFG {"}
{"text":"Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false","code":"public static boolean findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ;"}
{"text":"Calculate sum of all elements","code":"for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean [ ] part = new boolean [ sum \/ 2 + 1 ] ;"}
{"text":"Initialize the part array as 0","code":"for ( i = 0 ; i <= sum \/ 2 ; i ++ ) { part [ i ] = false ; }"}
{"text":"Fill the partition table in bottom up manner","code":"for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"The element to be included in the sum cannot be greater than the sum","code":"for ( j = sum \/ 2 ; j >= arr [ i ] ; j -- ) {"}
{"text":"Check if sum - arr [ i ] could be formed from a subset using elements before index i","code":"if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum \/ 2 ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = 6 ;"}
{"text":"Function call","code":"if ( findPartiion ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" + \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 \" + \" two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }"}
{"text":"JAVA program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find binomial coefficient","code":"static int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long inv [ ] = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ;"}
{"text":"Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007","code":"for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m \/ i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ;"}
{"text":"for 1 \/ ( r ! ) part","code":"for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; }"}
{"text":"for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part","code":"for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + binomialCoeff ( n , r ) + \"NEW_LINE\"); } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the gcd of two numbers","code":"public static int gcd ( int a , int b ) {"}
{"text":"Base case","code":"if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ;"}
{"text":"Recurse","code":"return gcd ( b , a % b ) ; }"}
{"text":"Function to print the answer","code":"static void printAnswer ( int x , int y ) {"}
{"text":"GCD of X and Y","code":"int val = gcd ( x , y ) ;"}
{"text":"If GCD is power of 2","code":"if ( ( val & ( val - 1 ) ) == 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given X and Y","code":"int x = 4 ; int y = 7 ;"}
{"text":"Function call","code":"printAnswer ( x , y ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to return the element in the rth row and cth column from the required matrix","code":"static int getElement ( int N , int r , int c ) {"}
{"text":"Condition for lower half of matrix","code":"if ( r > c ) return 0 ;"}
{"text":"Condition if element is in first row","code":"if ( r == 1 ) { return c ; }"}
{"text":"Starting element of AP in row r","code":"int a = ( r + 1 ) * ( int ) ( Math . pow ( 2 , ( r - 2 ) ) ) ;"}
{"text":"Common difference of AP in row r","code":"int d = ( int ) ( Math . pow ( 2 , ( r - 1 ) ) ) ;"}
{"text":"Position of element to find in AP in row r","code":"c = c - r ; int element = a + d * c ; return element ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 , R = 3 , C = 4 ; System . out . println ( getElement ( N , R , C ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {"}
{"text":"Function to insert X in N and return the minimum value string","code":"static String MinValue ( String number , int x ) {"}
{"text":"Variable to store length of string N","code":"int length = number . length ( ) ;"}
{"text":"Variable to denote the position where X must be added","code":"int position = length + 1 ;"}
{"text":"If the given string N represent a negative value","code":"if ( number . charAt ( 0 ) == ' - ' ) {"}
{"text":"X must be place at the last index where is greater than N [ i ]","code":"for ( int i = number . length ( ) - 1 ; i >= 1 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) < x ) { position = i ; } } } else {"}
{"text":"For positive numbers , X must be placed at the last index where it is smaller than N [ i ]","code":"for ( int i = number . length ( ) - 1 ; i >= 0 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) > x ) { position = i ; } } }"}
{"text":"Insert X at that position","code":"number = number . substring ( 0 , position ) + x + number . substring ( position , number . length ( ) ) ;"}
{"text":"return string","code":"return number . toString ( ) ; }"}
{"text":"Driver call","code":"public static void main ( String [ ] args ) {"}
{"text":"given input","code":"String number = \"89\" ; int x = 1 ;"}
{"text":"function call","code":"System . out . print ( MinValue ( number , x ) ) ; } }"}
{"text":"Java program for above approach","code":"class GFG {"}
{"text":"Function to check the binary number is divisible by K","code":"public static String divisibleByk ( String s , int n , int k ) {"}
{"text":"Array poweroftwo will store pow ( 2 , i ) % k","code":"int [ ] poweroftwo = new int [ n ] ;"}
{"text":"Initializing the first element in Array","code":"poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"Storing every pow ( 2 , i ) % k value in the array","code":"poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; }"}
{"text":"To store the remaining","code":"int rem = 0 ;"}
{"text":"Iterating till N","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If current bit is 1","code":"if ( s . charAt ( n - i - 1 ) == '1' ) {"}
{"text":"Updating rem","code":"rem += ( poweroftwo [ i ] ) ; rem %= k ; } }"}
{"text":"If completely divisible","code":"if ( rem == 0 ) { return \" Yes \" ; }"}
{"text":"If not Completely divisible","code":"else return \" No \" ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given Input","code":"String s = \"1010001\" ; int k = 9 ;"}
{"text":"length of string s","code":"int n = s . length ( ) ;"}
{"text":"Function Call","code":"System . out . println ( divisibleByk ( s , n , k ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum sum of count of 0 s in the left subString and count of 1 s in the right subString by splitting the String","code":"static int maxSumbySplittingString ( String str , int N ) {"}
{"text":"Stores count of 1 s the in binary String","code":"int cntOne = 0 ;"}
{"text":"Traverse the binary String","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If current character is '1'","code":"if ( str . charAt ( i ) == '1' ) {"}
{"text":"Update cntOne","code":"cntOne ++ ; } }"}
{"text":"Stores count of 0 s","code":"int zero = 0 ;"}
{"text":"Stores count of 1 s","code":"int one = 0 ;"}
{"text":"Stores maximum sum of count of 0 s and 1 s by splitting the String","code":"int res = 0 ;"}
{"text":"Traverse the binary String","code":"for ( int i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"If current character is '0'","code":"if ( str . charAt ( i ) == '0' ) {"}
{"text":"Update zero","code":"zero ++ ; }"}
{"text":"If current character is '1'","code":"else {"}
{"text":"Update one","code":"one ++ ; }"}
{"text":"Update res","code":"res = Math . max ( res , zero + cntOne - one ) ; } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \"00111\" ; int N = str . length ( ) ; System . out . print ( maxSumbySplittingString ( str , N ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the maximum count of pairs required to be removed such that subsequence of string does not contain any valid parenthesis","code":"static void cntBalancedParenthesis ( String s , int N ) {"}
{"text":"Stores count of pairs of balanced parenthesis","code":"int cntPairs = 0 ;"}
{"text":"Stores count of curly balanced parenthesis","code":"int cntCurly = 0 ;"}
{"text":"Stores count of small balanced parenthesis","code":"int cntSml = 0 ;"}
{"text":"Stores count of square balanced parenthesis","code":"int cntSqr = 0 ;"}
{"text":"Iterate over characters of the string","code":"for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' { ' ) {"}
{"text":"Update cntCurly","code":"cntCurly ++ ; } else if ( s . charAt ( i ) == ' ( ' ) {"}
{"text":"Update cntSml","code":"cntSml ++ ; } else if ( s . charAt ( i ) == ' [ ' ) {"}
{"text":"Update cntSqr","code":"cntSqr ++ ; } else if ( s . charAt ( i ) == ' } ' && cntCurly > 0 ) {"}
{"text":"Update cntCurly","code":"cntCurly -- ;"}
{"text":"Update cntPairs","code":"cntPairs ++ ; } else if ( s . charAt ( i ) == ' ) ' && cntSml > 0 ) {"}
{"text":"Update cntSml","code":"cntSml -- ;"}
{"text":"Update cntPairs","code":"cntPairs ++ ; } else if ( s . charAt ( i ) == ' ] ' && cntSqr > 0 ) {"}
{"text":"Update cntSml","code":"cntSqr -- ;"}
{"text":"Update cntPairs","code":"cntPairs ++ ; } } System . out . println ( cntPairs ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given String","code":"String s = \" { ( } ) \" ; int N = s . length ( ) ;"}
{"text":"Function call","code":"cntBalancedParenthesis ( s , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if there is arc intersection or not","code":"static int arcIntersection ( String S , int len ) { Stack < Character > stk = new Stack < > ( ) ;"}
{"text":"Traverse the String S","code":"for ( int i = 0 ; i < len ; i ++ ) {"}
{"text":"Insert all the elements in the stack one by one","code":"stk . push ( S . charAt ( i ) ) ; if ( stk . size ( ) >= 2 ) {"}
{"text":"Extract the top element","code":"char temp = stk . peek ( ) ;"}
{"text":"Pop out the top element","code":"stk . pop ( ) ;"}
{"text":"Check if the top element is same as the popped element","code":"if ( stk . peek ( ) == temp ) { stk . pop ( ) ; }"}
{"text":"Otherwise","code":"else { stk . add ( temp ) ; } } }"}
{"text":"If the stack is empty","code":"if ( stk . isEmpty ( ) ) return 1 ; return 0 ; }"}
{"text":"Function to check if there is arc intersection or not for the given array of Strings","code":"static void countString ( String arr [ ] , int N ) {"}
{"text":"Stores count of String not having arc intersection","code":"int count = 0 ;"}
{"text":"Iterate through array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Length of every String","code":"int len = arr [ i ] . length ( ) ;"}
{"text":"Function Call","code":"count += arcIntersection ( arr [ i ] , len ) ; }"}
{"text":"Print the desired count","code":"System . out . print ( count + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String arr [ ] = { \"0101\" , \"0011\" , \"0110\" } ; int N = arr . length ;"}
{"text":"Function Call","code":"countString ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function to convert the binary string into octal representation","code":"static String ConvertequivalentBase8 ( String S ) {"}
{"text":"Stores binary representation of the decimal value [ 0 - 7 ]","code":"HashMap < String , Character > mp = new HashMap < String , Character > ( ) ;"}
{"text":"Stores the decimal values of binary Strings [ 0 - 7 ]","code":"mp . put ( \"000\" , '0' ) ; mp . put ( \"001\" , '1' ) ; mp . put ( \"010\" , '2' ) ; mp . put ( \"011\" , '3' ) ; mp . put ( \"100\" , '4' ) ; mp . put ( \"101\" , '5' ) ; mp . put ( \"110\" , '6' ) ; mp . put ( \"111\" , '7' ) ;"}
{"text":"Stores length of S","code":"int N = S . length ( ) ; if ( N % 3 == 2 ) {"}
{"text":"Update S","code":"S = \"0\" + S ; } else if ( N % 3 == 1 ) {"}
{"text":"Update S","code":"S = \"00\" + S ; }"}
{"text":"Update N","code":"N = S . length ( ) ;"}
{"text":"Stores octal representation of the binary String","code":"String oct = \" \" ;"}
{"text":"Traverse the binary String","code":"for ( int i = 0 ; i < N ; i += 3 ) {"}
{"text":"Stores 3 consecutive characters of the binary String","code":"String temp = S . substring ( i , i + 3 ) ;"}
{"text":"Append octal representation of temp","code":"oct += mp . get ( temp ) ; } return oct ; }"}
{"text":"Function to check if binary String is divisible by 9 or not","code":"static String binString_div_9 ( String S , int N ) {"}
{"text":"Stores octal representation of S","code":"String oct = \" \" ; oct = ConvertequivalentBase8 ( S ) ;"}
{"text":"Stores sum of elements present at odd positions of oct","code":"int oddSum = 0 ;"}
{"text":"Stores sum of elements present at odd positions of oct","code":"int evenSum = 0 ;"}
{"text":"Stores length of oct","code":"int M = oct . length ( ) ;"}
{"text":"Traverse the String oct","code":"for ( int i = 0 ; i < M ; i += 2 )"}
{"text":"Update oddSum","code":"oddSum += ( oct . charAt ( i ) - '0' ) ;"}
{"text":"Traverse the String oct","code":"for ( int i = 1 ; i < M ; i += 2 ) {"}
{"text":"Update evenSum","code":"evenSum += ( oct . charAt ( i ) - '0' ) ; }"}
{"text":"Stores octal representation of 9","code":"int Oct_9 = 11 ;"}
{"text":"If absolute value of ( oddSum - evenSum ) is divisible by Oct_9","code":"if ( Math . abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return \" Yes \" ; } return \" No \" ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \"1010001\" ; int N = S . length ( ) ; System . out . println ( binString_div_9 ( S , N ) ) ; } }"}
{"text":"Java program to gather characters of a string in minimum cost","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to calculate the minimum cost","code":"static int min_cost ( String S ) {"}
{"text":"Stores the minimum cost","code":"int cost = 0 ;"}
{"text":"Stores the count of characters found","code":"int F = 0 ;"}
{"text":"Stores the count of blank spaces found","code":"int B = 0 ; int count = 0 ; for ( char c : S . toCharArray ( ) ) if ( c == ' \u2581 ' ) count ++ ;"}
{"text":"Stores the count of total characters","code":"int n = S . length ( ) - count ;"}
{"text":"If the count of characters is equal to 1","code":"if ( n == 1 ) return cost ;"}
{"text":"Iterate over the string","code":"for ( char in : S . toCharArray ( ) ) {"}
{"text":"Consider the previous character together with current character","code":"if ( in != ' \u2581 ' ) {"}
{"text":"If not together already","code":"if ( B != 0 ) {"}
{"text":"Add the cost to group them together","code":"cost += Math . min ( n - F , F ) * B ; B = 0 ; }"}
{"text":"Increase count of characters found","code":"F += 1 ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"Increase count of spaces found","code":"B += 1 ; } }"}
{"text":"Return the total cost obtained","code":"return cost ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" \u2581 @ $ \" ; System . out . println ( min_cost ( S ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that return true if the given character is a vowel","code":"static boolean isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; }"}
{"text":"Function to return the minimum cost to convert all the vowels of a string to a single one","code":"static int minCost ( String S ) {"}
{"text":"Stores count of respective vowels","code":"int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ;"}
{"text":"Iterate through the string","code":"for ( int i = 0 ; i < S . length ( ) ; i ++ ) {"}
{"text":"If a vowel is encountered","code":"if ( isVowel ( S . charAt ( i ) ) ) {"}
{"text":"Calculate the cost","code":"cA += Math . abs ( S . charAt ( i ) - ' a ' ) ; cE += Math . abs ( S . charAt ( i ) - ' e ' ) ; cI += Math . abs ( S . charAt ( i ) - ' i ' ) ; cO += Math . abs ( S . charAt ( i ) - ' o ' ) ; cU += Math . abs ( S . charAt ( i ) - ' u ' ) ; } }"}
{"text":"Return the minimum cost","code":"return Math . min ( Math . min ( Math . min ( Math . min ( cA , cE ) , cI ) , cO ) , cU ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String S = \" geeksforgeeks \" ; System . out . println ( minCost ( S ) ) ; } }"}
{"text":"Java program to generate a string whose substrings of length K concatenates to form given strings","code":"class GFG {"}
{"text":"Function to return the required required string","code":"public static void decode_String ( String str , int K ) { String ans = \" \" ;"}
{"text":"Iterate the given string","code":"for ( int i = 0 ; i < str . length ( ) ; i += K )"}
{"text":"Append the first character of every substring of length K","code":"ans += str . charAt ( i ) ;"}
{"text":"Consider all characters from the last substring","code":"for ( int i = str . length ( ) - ( K - 1 ) ; i < str . length ( ) ; i ++ ) ans += str . charAt ( i ) ; System . out . println ( ans ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int K = 3 ; String str = \" abcbcscsesesesd \" ; decode_String ( str , K ) ; } }"}
{"text":"Java program to find lexicographically smallest K - length substring containing maximum number of vowels","code":"class GFG {"}
{"text":"Function that prints the lexicographically smallest K - length substring containing maximum number of vowels","code":"static String maxVowelSubString ( String str , int K ) {"}
{"text":"Store the length of the string","code":"int N = str . length ( ) ;"}
{"text":"Initialize a prefix sum array","code":"int [ ] pref = new int [ N ] ;"}
{"text":"Loop through the string to create the prefix sum array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Store 1 at the index if it is a vowel","code":"if ( str . charAt ( i ) == ' a ' || str . charAt ( i ) == ' e ' || str . charAt ( i ) == ' i ' || str . charAt ( i ) == ' o ' || str . charAt ( i ) == ' u ' ) pref [ i ] = 1 ;"}
{"text":"Otherwise , store 0","code":"else pref [ i ] = 0 ;"}
{"text":"Process the prefix array","code":"if ( i != 0 ) pref [ i ] += pref [ i - 1 ] ; }"}
{"text":"Initialize the variable to store maximum count of vowels","code":"int maxCount = pref [ K - 1 ] ;"}
{"text":"Initialize the variable to store substring with maximum count of vowels","code":"String res = str . substring ( 0 , K ) ;"}
{"text":"Loop through the prefix array","code":"for ( int i = K ; i < N ; i ++ ) {"}
{"text":"Store the current count of vowels","code":"int currCount = pref [ i ] - pref [ i - K ] ;"}
{"text":"Update the result if current count is greater than maximum count","code":"if ( currCount > maxCount ) { maxCount = currCount ; res = str . substring ( i - K + 1 , i + 1 ) ; }"}
{"text":"Update lexicographically smallest substring if the current count is equal to the maximum count","code":"else if ( currCount == maxCount ) { String temp = str . substring ( i - K + 1 , i + 1 ) ; if ( temp . compareTo ( res ) < 0 ) res = temp ; } }"}
{"text":"Return the result","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" ceebbaceeffo \" ; int K = 3 ; System . out . print ( maxVowelSubString ( str , K ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to decode and print the original String","code":"static void decodeStr ( String str , int len ) {"}
{"text":"To store the decoded String","code":"char [ ] c = new char [ len ] ; int med , pos = 1 , k ;"}
{"text":"Getting the mid element","code":"if ( len % 2 == 1 ) med = len \/ 2 ; else med = len \/ 2 - 1 ;"}
{"text":"Storing the first element of the String at the median position","code":"c [ med ] = str . charAt ( 0 ) ;"}
{"text":"If the length is even then store the second element also","code":"if ( len % 2 == 0 ) c [ med + 1 ] = str . charAt ( 1 ) ;"}
{"text":"k represents the number of characters that are already stored in the c [ ]","code":"if ( len % 2 == 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str . charAt ( i ) ;"}
{"text":"If String length is odd","code":"if ( len % 2 == 1 ) c [ med + pos ] = str . charAt ( i + 1 ) ;"}
{"text":"If it is even","code":"else c [ med + pos + 1 ] = str . charAt ( i + 1 ) ; pos ++ ; }"}
{"text":"Print the decoded String","code":"for ( int i = 0 ; i < len ; i ++ ) System . out . print ( c [ i ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" ofrsgkeeeekgs \" ; int len = str . length ( ) ; decodeStr ( str , len ) ; } }"}
{"text":"Java program for the naive approach","code":"class GFG { static void findCount ( String s , int L , int R ) {"}
{"text":"Counter to count distinct char","code":"int distinct = 0 ;"}
{"text":"Initializing frequency array to count characters as the appear in subString S [ L : R ]","code":"int [ ] frequency = new int [ 26 ] ;"}
{"text":"Iterating over S [ L ] to S [ R ]","code":"for ( int i = L ; i <= R ; i ++ ) {"}
{"text":"Incrementing the count of s [ i ] character in frequency array","code":"frequency [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) {"}
{"text":"If frequency of any character is > 0 then increment the counter","code":"if ( frequency [ i ] > 0 ) distinct ++ ; } System . out . print ( distinct + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" geeksforgeeksisa \" + \" computerscienceportal \" ; int queries = 3 ; int Q [ ] [ ] = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; } }"}
{"text":"Java program to perform K operations upon the String and find the modified String","code":"class GFG {"}
{"text":"Function to perform K operations upon the String and find modified String","code":"static String ReverseComplement ( char [ ] s , int n , int k ) {"}
{"text":"Number of reverse operations","code":"int rev = ( k + 1 ) \/ 2 ;"}
{"text":"Number of complement operations","code":"int complement = k - rev ;"}
{"text":"If rev is odd parity","code":"if ( rev % 2 == 1 ) s = reverse ( s ) ;"}
{"text":"If complement is odd parity","code":"if ( complement % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Complementing each position","code":"if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } }"}
{"text":"Return the modified String","code":"return String . valueOf ( s ) ; } static char [ ] reverse ( char a [ ] ) { int i , n = a . length ; char t ; for ( i = 0 ; i < n \/ 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \"10011\" ; int k = 5 ; int n = str . length ( ) ;"}
{"text":"Function call","code":"System . out . print ( ReverseComplement ( str . toCharArray ( ) , n , k ) ) ; } }"}
{"text":"Java implementation to check that the permutation of the given String is K times repeated String","code":"class GFG {"}
{"text":"Function to check that permutation of the given String is a K times repeating String","code":"static boolean repeatingString ( String s , int n , int k ) {"}
{"text":"if length of String is not divisible by K","code":"if ( n % k != 0 ) { return false ; }"}
{"text":"Frequency Array","code":"int [ ] frequency = new int [ 123 ] ;"}
{"text":"Initially frequency of each character is 0","code":"for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; }"}
{"text":"Computing the frequency of each character in the String","code":"for ( int i = 0 ; i < n ; i ++ ) { frequency [ s . charAt ( i ) ] ++ ; } int repeat = n \/ k ;"}
{"text":"Loop to check that frequency of every character of the String is divisible by K","code":"for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \" abcdcba \" ; int n = s . length ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to find the last two digits of the number and print the complete number","code":"static void findPhoneNumber ( int n ) { int temp = n ; int sum = 0 ;"}
{"text":"Sum of the first eight digits of the number","code":"while ( temp != 0 ) { sum += temp % 10 ; temp = temp \/ 10 ; }"}
{"text":"if sum < 10 , then the two digits are '0' and the value of sum","code":"if ( sum < 10 ) System . out . print ( n + \"0\" + sum ) ;"}
{"text":"if sum > 10 , then the two digits are the value of sum","code":"else System . out . print ( n + \" \" + sum ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 98765432 ; findPhoneNumber ( n ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int maxN = 20 ; static int maxM = 64 ;"}
{"text":"Function to return the required count","code":"static int cntSplits ( String s ) {"}
{"text":"If the splitting is not possible","code":"if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return 0 ;"}
{"text":"To store the count of zeroes","code":"int c_zero = 0 ;"}
{"text":"Counting the number of zeroes","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) c_zero += ( s . charAt ( i ) == '0' ) ? 1 : 0 ;"}
{"text":"Return the final answer","code":"return ( int ) Math . pow ( 2 , c_zero - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \"10010\" ; System . out . println ( cntSplits ( s ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the number of substrings of same characters","code":"static void findNumbers ( String s ) {"}
{"text":"Size of the string","code":"int n = s . length ( ) ;"}
{"text":"Initialize count to 1","code":"int count = 1 ; int result = 0 ;"}
{"text":"Initialize left to 0 and right to 1 to traverse the string","code":"int left = 0 ; int right = 1 ; while ( right < n ) {"}
{"text":"Checking if consecutive characters are same and increment the count","code":"if ( s . charAt ( left ) == s . charAt ( right ) ) { count ++ ; }"}
{"text":"When we encounter a different characters","code":"else {"}
{"text":"Increment the result","code":"result += count * ( count + 1 ) \/ 2 ;"}
{"text":"To repeat the whole process set left equals right and count variable to 1","code":"left = right ; count = 1 ; } right ++ ; }"}
{"text":"Store the final value of result","code":"result += count * ( count + 1 ) \/ 2 ; System . out . println ( result ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" bbbcbb \" ; findNumbers ( s ) ; } }"}
{"text":"Java program for printing string with duplicate vowels","code":"import java . util . * ; class GFG {"}
{"text":"Function to check for the Vowel","code":"static boolean isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; }"}
{"text":"Function to get the resultant string with vowels duplicated","code":"static String duplicateVowels ( String str ) { int t = str . length ( ) ;"}
{"text":"Another string to store the resultant string","code":"String res = \" \" ;"}
{"text":"Loop to check for each character","code":"for ( int i = 0 ; i < t ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) res += str . charAt ( i ) ; res += str . charAt ( i ) ; } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" helloworld \" ;"}
{"text":"Print the original string","code":"System . out . println ( \" Original \u2581 String : \u2581 \" + str ) ; String res = duplicateVowels ( str ) ;"}
{"text":"Print the resultant string","code":"System . out . println ( \" String \u2581 with \u2581 Vowels \u2581 duplicated : \u2581 \" + res ) ; } }"}
{"text":"Java implementation of the approach","code":"public class GFG {"}
{"text":"Recursive function to convert string to integer","code":"static int stringToInt ( String str ) {"}
{"text":"If the number represented as a string contains only a single digit then returns its value","code":"if ( str . length ( ) == 1 ) return ( str . charAt ( 0 ) - '0' ) ;"}
{"text":"Recursive call for the sub - string starting at the second character","code":"double y = stringToInt ( str . substring ( 1 ) ) ;"}
{"text":"First digit of the number","code":"double x = str . charAt ( 0 ) - '0' ;"}
{"text":"First digit multiplied by the appropriate power of 10 and then add the recursive result For example , xy = ( ( x * 10 ) + y )","code":"x = x * Math . pow ( 10 , str . length ( ) - 1 ) + y ; return ( int ) ( x ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \"1235\" ; System . out . print ( stringToInt ( str ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int MAX = 26 ;"}
{"text":"Function to return the length of the longest sub - sequence with at least one common character in every string","code":"static int largestSubSeq ( String arr [ ] , int n ) {"}
{"text":"count [ 0 ] will store the number of strings which contain ' a ' , count [ 1 ] will store the number of strings which contain ' b ' and so on . .","code":"int [ ] count = new int [ MAX ] ;"}
{"text":"For every string","code":"for ( int i = 0 ; i < n ; i ++ ) { String str = arr [ i ] ;"}
{"text":"Hash array to set which character is present in the current string","code":"boolean [ ] hash = new boolean [ MAX ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str . charAt ( j ) - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) {"}
{"text":"If current character appears in the string then update its count","code":"if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String arr [ ] = { \" ab \" , \" bc \" , \" de \" } ; int n = arr . length ; System . out . println ( largestSubSeq ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that returns true if str is a palindrome","code":"static boolean isPalindrome ( String str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len \/ 2 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( len - 1 - i ) ) return false ; } return true ; }"}
{"text":"Function that returns true if the generated string is a palindrome","code":"static boolean createStringAndCheckPalindrome ( int N ) {"}
{"text":"sub contains N as a string","code":"String sub = \" \" + N , res_str = \" \" ; int sum = 0 ;"}
{"text":"Calculate the sum of the digits","code":"while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N \/ 10 ; }"}
{"text":"Repeat the substring until the length of the resultant string < sum","code":"while ( res_str . length ( ) < sum ) res_str += sub ;"}
{"text":"If length of the resultant string exceeded sum then take substring from 0 to sum - 1","code":"if ( res_str . length ( ) > sum ) res_str = res_str . substring ( 0 , sum ) ;"}
{"text":"If the generated string is a palindrome","code":"if ( isPalindrome ( res_str ) ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to minimize the length of string by removing occurrence of only one character","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum length","code":"static int minimumLength ( String s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ ] = new int [ 26 ] ;"}
{"text":"Count the frequency of each alphabet","code":"for ( int i = 0 ; i < n ; i ++ ) arr [ s . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Find the alphabets with maximum frequency","code":"for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ;"}
{"text":"Subtract the frequency of character from length of string","code":"return ( n - maxOcc ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" afddewqd \" ; System . out . println ( minimumLength ( str ) ) ; } }"}
{"text":"Java program to remove all the characters other then alphabets","code":"class GFG {"}
{"text":"function to remove characters and print new string","code":"static void removeSpecialCharacter ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"Finding the character whose ASCII value fall under this range","code":"if ( s . charAt ( i ) < ' A ' || s . charAt ( i ) > ' Z ' && s . charAt ( i ) < ' a ' || s . charAt ( i ) > ' z ' ) {"}
{"text":"erase function to erase the character","code":"s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } System . out . print ( s ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" $ Gee * k ; s . . fo , \u2581 r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; } }"}
{"text":"Java program to remove all the characters other then alphabets","code":"class GFG {"}
{"text":"function to remove characters and print new string","code":"static void removeSpecialCharacter ( String str ) { char [ ] s = str . toCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) {"}
{"text":"Store only valid characters","code":"if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } System . out . println ( String . valueOf ( s ) . substring ( 0 , j ) ) ; }"}
{"text":"driver code","code":"public static void main ( String [ ] args ) { String s = \" $ Gee * k ; s . . fo , \u2581 r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; } }"}
{"text":"Java program to find the first character that is repeated","code":"import java . io . * ; import java . util . * ; class GFG { static int findRepeatFirstN2 ( String s ) {"}
{"text":"this is O ( N ^ 2 ) method","code":"int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }"}
{"text":"Driver code","code":"static public void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == - 1 ) System . out . println ( \" Not \u2581 found \" ) ; else System . out . println ( str . charAt ( pos ) ) ; } }"}
{"text":"Java implementation to print the characters and frequencies in order of its occurrence","code":"import java . util . * ; class Gfg { public static void prCharWithFreq ( String s ) {"}
{"text":"Store all characters and their frequencies in dictionary","code":"Map < Character , Integer > d = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( d . containsKey ( s . charAt ( i ) ) ) { d . put ( s . charAt ( i ) , d . get ( s . charAt ( i ) ) + 1 ) ; } else { d . put ( s . charAt ( i ) , 1 ) ; } }"}
{"text":"Print characters and their frequencies in same order of their appearance","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"Print only if this character is not printed before","code":"if ( d . get ( s . charAt ( i ) ) != 0 ) { System . out . print ( s . charAt ( i ) ) ; System . out . print ( d . get ( s . charAt ( i ) ) + \" \u2581 \" ) ; d . put ( s . charAt ( i ) , 0 ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String S = \" geeksforgeeks \" ; prCharWithFreq ( S ) ; } }"}
{"text":"Java program to count number of possible strings with n characters .","code":"class GFG {"}
{"text":"Function to calculate number of strings","code":"static int possibleStrings ( int n , int r , int b , int g ) {"}
{"text":"Store factorial of numbers up to n for further computation","code":"int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ;"}
{"text":"Find the remaining values to be added","code":"int left = n - ( r + g + b ) ; int sum = 0 ;"}
{"text":"Make all possible combinations of R , B and G for the remaining value","code":"for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ;"}
{"text":"Compute permutation of each combination one by one and add them .","code":"sum = sum + fact [ n ] \/ ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } }"}
{"text":"Return total no . of strings \/ permutation","code":"return sum ; }"}
{"text":"Drivers code","code":"public static void main ( String [ ] args ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; System . out . println ( possibleStrings ( n , r , b , g ) ) ; } }"}
{"text":"Java program to find minimum number of characters to be removed to make two strings anagram .","code":"import java . util . * ; class GFG {"}
{"text":"function to calculate minimum numbers of characters to be removed to make two strings anagram","code":"static int remAnagram ( String str1 , String str2 ) {"}
{"text":"make hash array for both string and calculate frequency of each character","code":"int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ;"}
{"text":"count frequency of each character in first string","code":"for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"count frequency of each character in second string","code":"for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"traverse count arrays to find number of characters to be removed","code":"int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }"}
{"text":"Driver program to run the case","code":"public static void main ( String [ ] args ) { String str1 = \" bcadeh \" , str2 = \" hea \" ; System . out . println ( remAnagram ( str1 , str2 ) ) ; } }"}
{"text":"Java program to check if a string can be made valid by removing at most 1 character .","code":"public class GFG {"}
{"text":"Assuming only lower case characters","code":"static int CHARS = 26 ;"}
{"text":"To check a string S can be converted to a valid string by removing less than or equal to one character .","code":"static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ;"}
{"text":"freq [ ] : stores the frequency of each character of a string","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; }"}
{"text":"Find first character with non - zero frequency","code":"int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } }"}
{"text":"Find a character with frequency different from freq1 .","code":"int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } }"}
{"text":"If we find a third non - zero frequency or count of both frequencies become more than 1 , then return false","code":"for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ;"}
{"text":"} else If we find a third non - zero freq","code":"{ return false ; } }"}
{"text":"If counts of both frequencies is more than 1","code":"if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } }"}
{"text":"Return true if we reach here","code":"return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" abcbc \" ; if ( isValidString ( str ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java program to check if a string can be made valid by removing at most 1 character using hashmap .","code":"import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class AllCharsWithSameFrequencyWithOneVarAllowed {"}
{"text":"To check a string S can be converted to a variation string","code":"public static boolean checkForVariation ( String str ) { if ( str == null || str . isEmpty ( ) ) { return true ; } Map < Character , Integer > map = new HashMap < > ( ) ;"}
{"text":"Run loop form 0 to length of string","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) { map . put ( str . charAt ( i ) , map . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } Iterator < Integer > itr = map . values ( ) . iterator ( ) ;"}
{"text":"declaration of variables","code":"boolean first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; while ( itr . hasNext ( ) ) { int i = itr . next ( ) ;"}
{"text":"if first is true than countOfVal1 increase","code":"if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; }"}
{"text":"if second is true than countOfVal2 increase","code":"if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { System . out . println ( checkForVariation ( \" abcbc \" ) ) ; } }"}
{"text":"Java implementation for find pairs of complete strings .","code":"class GFG {"}
{"text":"Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ]","code":"static int countCompletePairs ( String set1 [ ] , String set2 [ ] , int n , int m ) { int result = 0 ;"}
{"text":"Consider all pairs of both strings","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"Create a concatenation of current pair","code":"String concat = set1 [ i ] + set2 [ j ] ;"}
{"text":"Compute frequencies of all characters in the concatenated String .","code":"int frequency [ ] = new int [ 26 ] ; for ( int k = 0 ; k < concat . length ( ) ; k ++ ) { frequency [ concat . charAt ( k ) - ' a ' ] ++ ; }"}
{"text":"If frequency of any character is not greater than 0 , then this pair is not complete .","code":"int k ; for ( k = 0 ; k < 26 ; k ++ ) { if ( frequency [ k ] < 1 ) { break ; } } if ( k == 26 ) { result ++ ; } } } return result ; }"}
{"text":"Driver code","code":"static public void main ( String [ ] args ) { String set1 [ ] = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; String set2 [ ] = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = set1 . length ; int m = set2 . length ; System . out . println ( countCompletePairs ( set1 , set2 , n , m ) ) ; } }"}
{"text":"Java program to find count of complete pairs","code":"class GFG {"}
{"text":"Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ]","code":"static int countCompletePairs ( String set1 [ ] , String set2 [ ] , int n , int m ) { int result = 0 ;"}
{"text":"con_s1 [ i ] is going to store an integer whose set bits represent presence \/ absence of characters in string set1 [ i ] . Similarly con_s2 [ i ] is going to store an integer whose set bits represent presence \/ absence of characters in string set2 [ i ]","code":"int [ ] con_s1 = new int [ n ] ; int [ ] con_s2 = new int [ m ] ;"}
{"text":"Process all strings in set1 [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"initializing all bits to 0","code":"con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) {"}
{"text":"Setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer .","code":"con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] . charAt ( j ) - ' a ' ) ) ; } }"}
{"text":"Process all strings in set2 [ ]","code":"for ( int i = 0 ; i < m ; i ++ ) {"}
{"text":"initializing all bits to 0","code":"con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) {"}
{"text":"setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer .","code":"con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] . charAt ( j ) - ' a ' ) ) ; } }"}
{"text":"assigning a variable whose all 26 ( 0. . 25 ) bits are set to 1","code":"long complete = ( 1 << 26 ) - 1 ;"}
{"text":"Now consider every pair of integer in con_s1 [ ] and con_s2 [ ] and check if the pair is complete .","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"if all bits are set , the strings are complete !","code":"if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String set1 [ ] = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; String set2 [ ] = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = set1 . length ; int m = set2 . length ; System . out . println ( countCompletePairs ( set1 , set2 , n , m ) ) ; } }"}
{"text":"Java program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to encode given string","code":"static String encodeString ( String str ) { HashMap < Character , Integer > map = new HashMap < > ( ) ; String res = \" \" ; int i = 0 ;"}
{"text":"for each character in given string","code":"char ch ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { ch = str . charAt ( j ) ;"}
{"text":"If the character is occurring for the first time , assign next unique number to that char","code":"if ( ! map . containsKey ( ch ) ) map . put ( ch , i ++ ) ;"}
{"text":"append the number associated with current character into the output string","code":"res += map . get ( ch ) ; } return res ; }"}
{"text":"Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary","code":"static void findMatchedWords ( String [ ] dict , String pattern ) {"}
{"text":"len is length of the pattern","code":"int len = pattern . length ( ) ;"}
{"text":"encode the string","code":"String hash = encodeString ( pattern ) ;"}
{"text":"for each word in the dictionary array","code":"for ( String word : dict ) {"}
{"text":"If size of pattern is same as size of current dictionary word and both pattern and the word has same hash , print the word","code":"if ( word . length ( ) == len && encodeString ( word ) . equals ( hash ) ) System . out . print ( word + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String [ ] dict = { \" abb \" , \" abc \" , \" xyz \" , \" xyy \" } ; String pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; } }"}
{"text":"Java program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary","code":"import java . util . * ; class GFG { static boolean check ( String pattern , String word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; int [ ] ch = new int [ 128 ] ; int Len = word . length ( ) ; for ( int i = 0 ; i < Len ; i ++ ) { if ( ch [ ( int ) pattern . charAt ( i ) ] == 0 ) { ch [ ( int ) pattern . charAt ( i ) ] = word . charAt ( i ) ; } else if ( ch [ ( int ) pattern . charAt ( i ) ] != word . charAt ( i ) ) { return false ; } } return true ; }"}
{"text":"Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary","code":"static void findMatchedWords ( HashSet < String > dict , String pattern ) {"}
{"text":"len is length of the pattern","code":"int Len = pattern . length ( ) ;"}
{"text":"For each word in the dictionary","code":"String result = \" \u2581 \" ; for ( String word : dict ) { if ( check ( pattern , word ) ) { result = word + \" \u2581 \" + result ; } } System . out . print ( result ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { HashSet < String > dict = new HashSet < String > ( ) ; dict . add ( \" abb \" ) ; dict . add ( \" abc \" ) ; dict . add ( \" xyz \" ) ; dict . add ( \" xyy \" ) ; String pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; } }"}
{"text":"Java program to count total number of words in the string","code":"class GFG {"}
{"text":"Function to count total number of words in the string","code":"public static int countWords ( String str ) {"}
{"text":"Check if the string is null or empty then return zero","code":"if ( str == null || str . isEmpty ( ) ) return 0 ; int wordCount = 0 ; boolean isWord = false ; int endOfLine = str . length ( ) - 1 ;"}
{"text":"Converting the given string into a character array","code":"char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) {"}
{"text":"Check if the character is a letter and index of character array doesn 't  equal to end of line that means, it is  a word and set isWord by true","code":"if ( Character . isLetter ( ch [ i ] ) && i != endOfLine ) isWord = true ;"}
{"text":"Check if the character is not a letter that means there is a space , then we increment the wordCount by one and set the isWord by false","code":"else if ( ! Character . isLetter ( ch [ i ] ) && isWord ) { wordCount ++ ; isWord = false ; }"}
{"text":"Check for the last word of the sentence and increment the wordCount by one","code":"else if ( Character . isLetter ( ch [ i ] ) && i == endOfLine ) wordCount ++ ; }"}
{"text":"Return the total number of words in the string","code":"return wordCount ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given String str","code":"String str = \"One twothree four five \";"}
{"text":"Print the result","code":"System . out . println ( \" No \u2581 of \u2581 words \u2581 : \u2581 \" + countWords ( str ) ) ; } }"}
{"text":"Java code to reverse a string","code":"class GFG {"}
{"text":"Reverse the string","code":"public static String [ ] RevString ( String [ ] s , int l ) {"}
{"text":"Check if number of words is even","code":"if ( l % 2 == 0 ) {"}
{"text":"Find the middle word","code":"int j = l \/ 2 ;"}
{"text":"Starting from the middle start swapping words at jth position and l - 1 - j position","code":"while ( j <= l - 1 ) { String temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } }"}
{"text":"Check if number of words is odd","code":"else {"}
{"text":"Find the middle word","code":"int j = ( l \/ 2 ) + 1 ;"}
{"text":"Starting from the middle start swapping the words at jth position and l - 1 - j position","code":"while ( j <= l - 1 ) { String temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } }"}
{"text":"Return the reversed sentence","code":"return s ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \" getting \u2581 good \u2581 at \u2581 coding \u2581 \" + \" needs \u2581 a \u2581 lot \u2581 of \u2581 practice \" ; String [ ] words = s . split ( \" \\\\ s \" ) ; words = RevString ( words , words . length ) ; s = String . join ( \" \u2581 \" , words ) ; System . out . println ( s ) ; } }"}
{"text":"Java program to print path from root to all nodes in a complete binary tree .","code":"import java . util . * ; class GFG {"}
{"text":"Function to print path of all the nodes nth node represent as given node kth node represents as left and right node","code":"static void printPath ( Vector < Integer > res , int nThNode , int kThNode ) {"}
{"text":"base condition if kth node value is greater then nth node then its means kth node is not valid so we not store it into the res simply we just return","code":"if ( kThNode > nThNode ) return ;"}
{"text":"Storing node into res","code":"res . add ( kThNode ) ;"}
{"text":"Print the path from root to node","code":"for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\");"}
{"text":"store left path of a tree So for left we will go node ( kThNode * 2 )","code":"printPath ( res , nThNode , kThNode * 2 ) ;"}
{"text":"right path of a tree and for right we will go node ( kThNode * 2 + 1 )","code":"printPath ( res , nThNode , kThNode * 2 + 1 ) ; res . remove ( res . size ( ) - 1 ) ; }"}
{"text":"Function to print path from root to all of the nodes","code":"static void printPathToCoverAllNodeUtil ( int nThNode ) {"}
{"text":"res is for store the path from root to particulate node","code":"Vector < Integer > res = new Vector < Integer > ( ) ;"}
{"text":"Print path from root to all node . third argument 1 because of we have to consider root node is 1","code":"printPath ( res , nThNode , 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given Node","code":"int nThNode = 7 ;"}
{"text":"Print path from root to all node .","code":"printPathToCoverAllNodeUtil ( nThNode ) ; } }"}
{"text":"Java code to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"A utility function to get the middle index of given range .","code":"static int getMid ( int s , int e ) { return s + ( e - s ) \/ 2 ; }"}
{"text":"Function that return true if num is armstrong else return false","code":"static boolean isArmstrong ( int x ) { int n = String . valueOf ( x ) . length ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp \/= 10 ; } if ( sum1 == x ) return true ; return false ; }"}
{"text":"A recursive function to get the sum of values in the given range of the array . The following are parameters for this function . st . Pointer to segment tree node . Index of current node in the segment tree . ss & se . Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r . Starting and ending indexes of range query","code":"static int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) {"}
{"text":"If segment of this node is completely part of given range , then return the max of segment .","code":"if ( l <= ss && r >= se ) return st [ node ] ;"}
{"text":"If segment of this node does not belong to given range","code":"if ( se < l ss > r ) return - 1 ;"}
{"text":"If segment of this node is partially the part of given range","code":"int mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; }"}
{"text":"A recursive function to update the nodes which have the given the index in their range . The following are parameters st , ss and se are same as defined above index . index of the element to be updated .","code":"static void updateValue ( int arr [ ] , int [ ] st , int ss , int se , int index , int value , int node ) { if ( index < ss index > se ) { System . out . print ( \" Invalid \u2581 Input \" + \"NEW_LINE\"); return ; } if ( ss == se ) {"}
{"text":"update value in array and in segment tree","code":"arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = - 1 ; } else { int mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 1 ) ; st [ node ] = Math . max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; }"}
{"text":"Return max of elements in range from index l ( query start ) to r ( query end ) .","code":"static int getMax ( int [ ] st , int n , int l , int r ) {"}
{"text":"Check for erroneous input values","code":"if ( l < 0 r > n - 1 l > r ) { System . out . printf ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }"}
{"text":"A recursive function that constructs Segment Tree for array [ ss . . se ] . si is index of current node in segment tree st","code":"static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) {"}
{"text":"If there is one element in array , store it in current node of segment tree and return","code":"if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = - 1 ; return st [ si ] ; }"}
{"text":"If there are more than one elements , then recur for left and right subtrees and store the max of values in this node","code":"int mid = getMid ( ss , se ) ; st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 1 ) ) ; return st [ si ] ; }"}
{"text":"Function to cona segment tree from given array . This function allocates memory for segment tree .","code":"static int [ ] constructST ( int arr [ ] , int n ) {"}
{"text":"Height of segment tree","code":"int x = ( int ) ( Math . ceil ( Math . log ( n ) ) ) ;"}
{"text":"Maximum size of segment tree","code":"int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ;"}
{"text":"Allocate memory","code":"int [ ] st = new int [ max_size ] ;"}
{"text":"Fill the allocated memory st","code":"constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;"}
{"text":"Return the constructed segment tree","code":"return st ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 192 , 113 , 535 , 7 , 19 , 111 } ; int n = arr . length ;"}
{"text":"Build segment tree from given array","code":"int [ ] st = constructST ( arr , n ) ;"}
{"text":"Print max of values in array from index 1 to 3","code":"System . out . print ( \" Maximum \u2581 armstrong \u2581 \" + \" number \u2581 in \u2581 given \u2581 range \u2581 = \u2581 \" + getMax ( st , n , 1 , 3 ) + \"NEW_LINE\");"}
{"text":"Update : set arr [ 1 ] = 153 and update corresponding segment tree nodes .","code":"updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ;"}
{"text":"Find max after the value is updated","code":"System . out . print ( \" Updated \u2581 Maximum \u2581 armstrong \u2581 \" + \" number \u2581 in \u2581 given \u2581 range \u2581 = \u2581 \" + getMax ( st , n , 1 , 3 ) + \"NEW_LINE\"); } }"}
{"text":"Java program to implement the above problem","code":"class GFG {"}
{"text":"Function to find the maximum number of regions on a plane","code":"static void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) \/ 2 + 1 ;"}
{"text":"print the maximum number of regions","code":"System . out . println ( num ) ; ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; maxRegions ( n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if the jigsaw Puzzle is solveable or not","code":"static void checkSolveable ( int n , int m ) {"}
{"text":"Base Case","code":"if ( n == 1 m == 1 ) System . out . print ( \" YES \" ) ;"}
{"text":"By placing the blank tabs as a chain","code":"else if ( m == 2 && n == 2 ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the GCD of two numbers a and b","code":"static int GCD ( int a , int b ) {"}
{"text":"Base Case","code":"if ( b == 0 ) return a ;"}
{"text":"Recursively find the GCD","code":"else return GCD ( b , a % b ) ; }"}
{"text":"Function to check if ( x , y ) can be reached from ( 1 , 0 ) from given moves","code":"static void check ( int x , int y ) {"}
{"text":"If GCD is 1 , then print \" Yes \"","code":"if ( GCD ( x , y ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given X and Y","code":"int X = 2 , Y = 7 ;"}
{"text":"Function call","code":"check ( X , Y ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG { static final int size = 1000001 ;"}
{"text":"Seieve of Erotosthenes to compute all primes","code":"static void seiveOfEratosthenes ( int [ ] prime ) { prime [ 0 ] = 1 ; prime [ 1 ] = 0 ; for ( int i = 2 ; i * i < 1000001 ; i ++ ) {"}
{"text":"If prime","code":"if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < 1000001 ; j += i ) {"}
{"text":"Mark all its multiples as non - prime","code":"prime [ j ] = 1 ; } } } }"}
{"text":"Function to find the probability of Euler 's Totient Function in a given range","code":"static float probabiltyEuler ( int [ ] prime , int L , int R , int M ) { int [ ] arr = new int [ size ] ; int [ ] eulerTotient = new int [ size ] ; int count = 0 ;"}
{"text":"Initializing two arrays with values from L to R for Euler 's totient","code":"for ( int i = L ; i <= R ; i ++ ) {"}
{"text":"Indexing from 0","code":"eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( int i = 2 ; i < 1000001 ; i ++ ) {"}
{"text":"If the current number is prime","code":"if ( prime [ i ] == 0 ) {"}
{"text":"Checking if i is prime factor of numbers in range L to R","code":"for ( int j = ( L \/ i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) {"}
{"text":"Update all the numbers which has prime factor i","code":"eulerTotient [ j - L ] = eulerTotient [ j - L ] \/ i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] \/= i ; } } } } }"}
{"text":"If number in range has a prime factor > Math . sqrt ( number )","code":"for ( int i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] \/ arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( int i = L ; i <= R ; i ++ ) {"}
{"text":"Count those which are divisible by M","code":"if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } }"}
{"text":"Return the result","code":"return ( float ) ( 1.0 * count \/ ( R + 1 - L ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] prime = new int [ size ] ; seiveOfEratosthenes ( prime ) ; int L = 1 , R = 7 , M = 3 ; System . out . print ( probabiltyEuler ( prime , L , R , M ) ) ; } }"}
{"text":"Java implementation to find the Largest Odd Divisior Game to check which player wins","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the Largest Odd Divisior Game to check which player wins","code":"public static void findWinner ( int n , int k ) { int cnt = 0 ;"}
{"text":"Check if n == 1 then player 2 will win","code":"if ( n == 1 ) System . out . println ( \" No \" ) ;"}
{"text":"Check if n == 2 or n is odd","code":"else if ( ( n & 1 ) != 0 n == 2 ) System . out . println ( \" Yes \" ) ; else { int tmp = n ; int val = 1 ;"}
{"text":"While n is greater than k and divisible by 2 keep incrementing tha val","code":"while ( tmp > k && tmp % 2 == 0 ) { tmp \/= 2 ; val *= 2 ; }"}
{"text":"Loop to find greatest odd divisor","code":"for ( int i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp \/= i ; } } if ( tmp > 1 ) cnt ++ ;"}
{"text":"Check if n is a power of 2","code":"if ( val == n ) System . out . println ( \" No \" ) ; else if ( n \/ tmp == 2 && cnt == 1 ) System . out . println ( \" No \" ) ;"}
{"text":"Check if cnt is not one then player 1 wins","code":"else System . out . println ( \" Yes \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 1 , k = 1 ; findWinner ( n , k ) ; } }"}
{"text":"Java program of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to print numbers upto N which are both pentagonal as well as hexagonal numbers","code":"static void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; i < n ; i ++ ) {"}
{"text":"Calculate i - th pentagonal number","code":"pn = i * ( 3 * i - 1 ) \/ 2 ; if ( pn > n ) break ;"}
{"text":"Check if the pentagonal number pn is hexagonal or not","code":"double seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) \/ 4 ; if ( seqNum == ( long ) seqNum ) System . out . print ( pn + \" , \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { long N = 1000000 ; pen_hex ( N ) ; } }"}
{"text":"Java implementation to check if row - major order traversal of matrix is palindrome or not","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if row - major order traversal of the matrix is is palindrome","code":"static boolean isPal ( int a [ ] [ ] , int n , int m ) {"}
{"text":"Loop to check if the matrix is matrix is palindrome or not","code":"for ( int i = 0 ; i < n \/ 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 3 ; int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { System . out . print ( \" YES \" + \"NEW_LINE\"); } else { System . out . print ( \" NO \" + \"NEW_LINE\"); } } }"}
{"text":"Java program to find the smallest number whose sum of digits is also N","code":"class GFG {"}
{"text":"Function to get sum of digits","code":"static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n \/ 10 ; } return sum ; }"}
{"text":"Function to find the smallest number whose sum of digits is also N","code":"static void smallestNumber ( int N ) { int i = 1 ; while ( 1 != 0 ) {"}
{"text":"Checking if number has sum of digits = N","code":"if ( getSum ( i ) == N ) { System . out . print ( i ) ; break ; } i ++ ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 10 ; smallestNumber ( N ) ; } }"}
{"text":"Java implementation to check if N is a Rare number","code":"class GFG {"}
{"text":"Iterative function to reverse digits of num","code":"static int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num \/ 10 ; } return rev_num ; }"}
{"text":"Function to check if N is perfect square","code":"static boolean isPerfectSquare ( double x ) {"}
{"text":"Find floating point value of square root of x .","code":"double sr = Math . sqrt ( x ) ;"}
{"text":"If square root is an integer","code":"return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }"}
{"text":"Function to check if N is an Rare number","code":"static boolean isRare ( int N ) {"}
{"text":"Find reverse of N","code":"int reverseN = reversDigits ( N ) ;"}
{"text":"Number should be non - palindromic","code":"if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 65 ; if ( isRare ( n ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }"}
{"text":"Java program to count the elements in the range [ L , R ] whose prime factors are only 2 and 3.","code":"import java . util . * ; class GFG {"}
{"text":"Function which will calculate the elements in the given range","code":"static void calc_ans ( int l , int r ) { Vector < Integer > power2 = new Vector < Integer > ( ) , power3 = new Vector < Integer > ( ) ;"}
{"text":"Store the current power of 2","code":"int mul2 = 1 ; while ( mul2 <= r ) { power2 . add ( mul2 ) ; mul2 *= 2 ; }"}
{"text":"Store the current power of 3","code":"int mul3 = 1 ; while ( mul3 <= r ) { power3 . add ( mul3 ) ; mul3 *= 3 ; }"}
{"text":"power23 [ ] will store pairwise product of elements of power2 and power3 that are <= r","code":"Vector < Integer > power23 = new Vector < Integer > ( ) ; for ( int x = 0 ; x < power2 . size ( ) ; x ++ ) { for ( int y = 0 ; y < power3 . size ( ) ; y ++ ) { int mul = power2 . get ( x ) * power3 . get ( y ) ; if ( mul == 1 ) continue ;"}
{"text":"Insert in power23 ] [ ] only if mul <= r","code":"if ( mul <= r ) power23 . add ( mul ) ; } }"}
{"text":"Store the required answer","code":"int ans = 0 ; for ( int x : power23 ) { if ( x >= l && x <= r ) ans ++ ; }"}
{"text":"Print the result","code":"System . out . print ( ans + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int l = 1 , r = 10 ; calc_ans ( l , r ) ; } }"}
{"text":"Java implementation to count of K length subsequence whose product is even","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate nCr","code":"static int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) \/ ( fact ( r ) * fact ( n - r ) ) ; }"}
{"text":"Returns factorial of n","code":"static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }"}
{"text":"Function for finding number of K length subsequences whose product is even number","code":"static int countSubsequences ( int arr [ ] , int n , int k ) { int countOdd = 0 ;"}
{"text":"Counting odd numbers in the array","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 2 , 4 } ; int K = 1 ; int N = arr . length ; System . out . println ( countSubsequences ( arr , N , K ) ) ; } }"}
{"text":"Java Program to find the first digit of X in base Y","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the first digit of X in base Y","code":"static void first_digit ( int x , int y ) {"}
{"text":"calculating number of digits of x in base y","code":"int length = ( int ) ( Math . log ( x ) \/ Math . log ( y ) + 1 ) ;"}
{"text":"finding first digit of x in base y","code":"int first_digit = ( int ) ( x \/ Math . pow ( y , length - 1 ) ) ; System . out . println ( first_digit ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to check if a number is a Curzon number or not","code":"static void checkIfCurzonNumber ( long N ) { double powerTerm , productTerm ;"}
{"text":"Find 2 ^ N + 1","code":"powerTerm = Math . pow ( 2 , N ) + 1 ;"}
{"text":"Find 2 * N + 1","code":"productTerm = 2 * N + 1 ;"}
{"text":"Check for divisibility","code":"if ( powerTerm % productTerm == 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { long N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to return the count of minimum numbers ending with 7 required such that the sum of these numbers is n","code":"static int minCount ( int n ) {"}
{"text":"hasharr [ i ] will store the minimum numbers ending with 7 so that it sums to number ending with digit i","code":"int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ;"}
{"text":"Its always possible to write numbers > 69 to write as numbers ending with 7","code":"if ( n > 69 ) return hasharr [ n % 10 ] ; else {"}
{"text":"If the number is atleast equal to the sum of minimum numbers ending with 7","code":"if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 38 ; System . out . println ( minCount ( n ) ) ; } }"}
{"text":"Java implementation to print the modified binary triangle pattern","code":"import java . io . * ; class GFG {"}
{"text":"Function to print the modified binary pattern","code":"static void modifiedBinaryPattern ( int n ) {"}
{"text":"Loop to traverse the rows","code":"for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"Loop to traverse the numbers in each row","code":"for ( int j = 1 ; j <= i ; j ++ ) {"}
{"text":"Check if j is 1 or i In either case print 1","code":"if ( j == 1 j == i ) System . out . print ( 1 ) ;"}
{"text":"Else print 0","code":"else System . out . print ( 0 ) ; }"}
{"text":"Change the cursor to next line after each row","code":"System . out . println ( ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 7 ;"}
{"text":"Function call","code":"modifiedBinaryPattern ( n ) ; } }"}
{"text":"Java program to find the real and imaginary parts of a Complex Number","code":"class GFG {"}
{"text":"Function to find real and imaginary parts of a complex number","code":"static void findRealAndImag ( String s ) {"}
{"text":"string length stored in variable l","code":"int l = s . length ( ) ;"}
{"text":"variable for the index of the separator","code":"int i ;"}
{"text":"Storing the index of ' + '","code":"if ( s . indexOf ( ' + ' ) != - 1 ) { i = s . indexOf ( ' + ' ) ; }"}
{"text":"else storing the index of ' - '","code":"else { i = s . indexOf ( ' - ' ) ; }"}
{"text":"Finding the real part of the complex number","code":"String real = s . substring ( 0 , i ) ;"}
{"text":"Finding the imaginary part of the complex number","code":"String imaginary = s . substring ( i + 1 , l - 1 ) ; System . out . println ( \" Real \u2581 part : \u2581 \" + real ) ; System . out . println ( \" Imaginary \u2581 part : \u2581 \" + imaginary ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \"3 + 4i \" ; findRealAndImag ( s ) ; } }"}
{"text":"Java implementation to find distinct powers of N that add upto K","code":"class GFG {"}
{"text":"Function to return the highest power of N not exceeding K","code":"static int highestPower ( int n , int k ) { int i = 0 ; int a = ( int ) Math . pow ( n , i ) ;"}
{"text":"Loop to find the highest power less than K","code":"while ( a <= k ) { i += 1 ; a = ( int ) Math . pow ( n , i ) ; } return i - 1 ; }"}
{"text":"Initializing the PowerArray with all 0 's.","code":"static int b [ ] = new int [ 50 ] ;"}
{"text":"Function to print the distinct powers of N that add upto K","code":"static int PowerArray ( int n , int k ) { while ( k > 0 ) {"}
{"text":"Getting the highest power of n before k","code":"int t = highestPower ( n , k ) ;"}
{"text":"To check if the power is being used twice or not","code":"if ( b [ t ] > 0 ) {"}
{"text":"Print - 1 if power is being used twice","code":"System . out . print ( - 1 ) ; return 0 ; } else"}
{"text":"If the power is not visited , then mark the power as visited","code":"b [ t ] = 1 ;"}
{"text":"Decrementing the value of K","code":"k -= Math . pow ( n , t ) ; }"}
{"text":"Printing the powers of N that sum up to K","code":"for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { System . out . print ( i + \" , \u2581 \" ) ; } } return 0 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; } }"}
{"text":"Java program to find sum of elements in an array having composite frequency","code":"import java . util . * ; class GFG { static final int N = 10005 ;"}
{"text":"Function to create Sieve to check primes","code":"static void SieveOfEratosthenes ( Vector < Boolean > composite ) { for ( int i = 0 ; i < N ; i ++ ) { composite . add ( i , false ) ; } for ( int p = 2 ; p * p < N ; p ++ ) {"}
{"text":"If composite [ p ] is not changed , then it is a prime","code":"if ( ! composite . get ( p ) ) {"}
{"text":"Update all multiples of p , set them to composite","code":"for ( int i = p * 2 ; i < N ; i += p ) { composite . add ( i , true ) ; } } } }"}
{"text":"Function to return the sum of elements in an array having composite frequency","code":"static int sumOfElements ( int arr [ ] , int n ) { Vector < Boolean > composite = new Vector < Boolean > ( ) ; for ( int i = 0 ; i < N ; i ++ ) composite . add ( false ) ; SieveOfEratosthenes ( composite ) ;"}
{"text":"Map is used to store element frequencies","code":"HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; }"}
{"text":"To store sum","code":"int sum = 0 ;"}
{"text":"Traverse the map using iterators","code":"for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {"}
{"text":"Count the number of elements having composite frequencies","code":"if ( composite . get ( it . getValue ( ) ) ) { sum += ( it . getKey ( ) ) ; } } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 } ; int n = arr . length ;"}
{"text":"Function call","code":"System . out . print ( sumOfElements ( arr , n ) ) ; } }"}
{"text":"Java program to removes all odd frequency elements from an Array","code":"import java . util . * ; class GFG {"}
{"text":"Function that removes the elements which have odd frequencies in the array","code":"static void remove ( int arr [ ] , int n ) {"}
{"text":"Create a map to store the frequency of each element","code":"HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } }"}
{"text":"Remove the elements which have odd frequencies","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If the element has odd frequency then skip","code":"if ( ( mp . containsKey ( arr [ i ] ) && mp . get ( arr [ i ] ) % 2 == 1 ) ) continue ; System . out . print ( arr [ i ] + \" , \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = arr . length ;"}
{"text":"Function call","code":"remove ( arr , n ) ; } }"}
{"text":"Java implementation of to maximize the first element of the array such that average of the array remains constant","code":"import java . util . * ; class GFG {"}
{"text":"Maximum value of the first array element that can be attained","code":"static void getmax ( int arr [ ] , int n , int x ) {"}
{"text":"Variable to store the sum","code":"int s = 0 ;"}
{"text":"Loop to find the sum of array","code":"for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; }"}
{"text":"Desired maximum value","code":"System . out . print ( Math . min ( s , x ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = arr . length ; getmax ( arr , arr_size , x ) ; } }"}
{"text":"Java program to illustrate the above problem","code":"class GFG {"}
{"text":"function to get the minimum length of the shorter side of the triangle","code":"static void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ;"}
{"text":"traversing through each points on the plane","code":"int i = 0 ; while ( n != 0 && i < x . length ) {"}
{"text":"if sum of a points is greater than the previous one , the maximum gets replaced","code":"if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; }"}
{"text":"print the length","code":"System . out . println ( \" Length \u2581 - > \u2581 \" + answer ) ; System . out . println ( \" Path \u2581 - > \u2581 \" + \" ( \u2581 1 , \u2581 \" + answer + \" \u2581 ) \" + \" and \u2581 ( \u2581 \" + answer + \" , \u2581 1 \u2581 ) \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"initialize the number of points","code":"int n = 4 ;"}
{"text":"points on the plane","code":"int x [ ] = new int [ ] { 1 , 4 , 2 , 1 } ; int y [ ] = new int [ ] { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; } }"}
{"text":"Java program to find intersection rectangle of given two rectangles .","code":"class GFG {"}
{"text":"function to find intersection rectangle of given two rectangles .","code":"static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) {"}
{"text":"gives bottom - left point of intersection rectangle","code":"int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ;"}
{"text":"gives top - right point of intersection rectangle","code":"int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ;"}
{"text":"no intersection","code":"if ( x5 > x6 y5 > y6 ) { System . out . println ( \" No \u2581 intersection \" ) ; return ; } System . out . print ( \" ( \" + x5 + \" , \u2581 \" + y5 + \" ) \u2581 \" ) ; System . out . print ( \" ( \" + x6 + \" , \u2581 \" + y6 + \" ) \u2581 \" ) ;"}
{"text":"gives top - left point of intersection rectangle","code":"int x7 = x5 ; int y7 = y6 ; System . out . print ( \" ( \" + x7 + \" , \u2581 \" + y7 + \" ) \u2581 \" ) ;"}
{"text":"gives bottom - right point of intersection rectangle","code":"int x8 = x6 ; int y8 = y5 ; System . out . print ( \" ( \" + x8 + \" , \u2581 \" + y8 + \" ) \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"bottom - left and top - right corners of first rectangle","code":"int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ;"}
{"text":"bottom - left and top - right corners of first rectangle","code":"int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ;"}
{"text":"function call","code":"FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } }"}
{"text":"Java program to find corner points of a rectangle using given length and middle points .","code":"class GFG {"}
{"text":"Structure to represent a co - ordinate point","code":"static class Point { float x , y ; Point ( ) { x = y = 0 ; } Point ( float a , float b ) { x = a ; y = b ; } } ;"}
{"text":"This function receives two points and length of the side of rectangle and prints the 4 corner points of the rectangle","code":"static void printCorners ( Point p , Point q , float l ) { Point a = new Point ( ) , b = new Point ( ) , c = new Point ( ) , d = new Point ( ) ;"}
{"text":"horizontal rectangle","code":"if ( p . x == q . x ) { a . x = ( float ) ( p . x - ( l \/ 2.0 ) ) ; a . y = p . y ; d . x = ( float ) ( p . x + ( l \/ 2.0 ) ) ; d . y = p . y ; b . x = ( float ) ( q . x - ( l \/ 2.0 ) ) ; b . y = q . y ; c . x = ( float ) ( q . x + ( l \/ 2.0 ) ) ; c . y = q . y ; }"}
{"text":"vertical rectangle","code":"else if ( p . y == q . y ) { a . y = ( float ) ( p . y - ( l \/ 2.0 ) ) ; a . x = p . x ; d . y = ( float ) ( p . y + ( l \/ 2.0 ) ) ; d . x = p . x ; b . y = ( float ) ( q . y - ( l \/ 2.0 ) ) ; b . x = q . x ; c . y = ( float ) ( q . y + ( l \/ 2.0 ) ) ; c . x = q . x ; }"}
{"text":"slanted rectangle","code":"else {"}
{"text":"calculate slope of the side","code":"float m = ( p . x - q . x ) \/ ( q . y - p . y ) ;"}
{"text":"calculate displacements along axes","code":"float dx = ( float ) ( ( l \/ Math . sqrt ( 1 + ( m * m ) ) ) * 0.5 ) ; float dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } System . out . print ( ( int ) a . x + \" , \u2581 \" + ( int ) a . y + \" NEW_LINE\" + ( int ) b . x + \" , \u2581 \" + ( int ) b . y + \"NEW_LINE\" + ( int ) c . x + \" , \u2581 \" + ( int ) c . y + \" NEW_LINE\" + ( int ) d . x + \" , \u2581 \" + ( int ) d . y + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Point p1 = new Point ( 1 , 0 ) , q1 = new Point ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; Point p = new Point ( 1 , 1 ) , q = new Point ( - 1 , - 1 ) ; printCorners ( p , q , ( float ) ( 2 * Math . sqrt ( 2 ) ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the minimum cost to modify the array according to the given criteria","code":"public static int minimumCost ( int arr [ ] , int N , int X , int Y ) {"}
{"text":"Count of wrong positioned odd and even elements","code":"int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Odd Count","code":"if ( ( arr [ i ] & 1 ) > 0 && ( i % 2 == 0 ) ) { odd_count ++ ; }"}
{"text":"Even Count","code":"if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) > 0 ) { even_count ++ ; } }"}
{"text":"Swapping Cost","code":"int cost1 = X * Math . min ( odd_count , even_count ) ;"}
{"text":"Decrementing cost after swapping","code":"int cost2 = Y * ( Math . max ( odd_count , even_count ) - Math . min ( odd_count , even_count ) ) ;"}
{"text":"Only decrementing cost","code":"int cost3 = ( odd_count + even_count ) * Y ;"}
{"text":"Return the minimum cost of the two cases","code":"return Math . min ( cost1 + cost2 , cost3 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = arr . length ; System . out . println ( minimumCost ( arr , N , X , Y ) ) ; } }"}
{"text":"package whatever do not write package name here","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum product of the minimum and maximum among all the possible subarrays","code":"static int findMinMax ( int [ ] a ) {"}
{"text":"Stores resultant minimum product","code":"int min_val = 1000000000 ;"}
{"text":"Traverse the given array arr [ ]","code":"for ( int i = 1 ; i < a . length ; ++ i ) {"}
{"text":"Min of product of all two pair of consecutive elements","code":"min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; }"}
{"text":"Return the resultant value","code":"return min_val ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; System . out . println ( findMinMax ( arr ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class GFG { static int sum ;"}
{"text":"Structure of Tree","code":"static class TreeNode { int data ; TreeNode left ; TreeNode right ;"}
{"text":"Constructor","code":"TreeNode ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } ;"}
{"text":"Function to add the node to the sum below the target node","code":"static void kDistanceDownSum ( TreeNode root , int k ) {"}
{"text":"Base Case","code":"if ( root == null k < 0 ) return ;"}
{"text":"If Kth distant node is reached","code":"if ( k == 0 ) { sum += root . data ; return ; }"}
{"text":"Recur for the left and the right subtrees","code":"kDistanceDownSum ( root . left , k - 1 ) ; kDistanceDownSum ( root . right , k - 1 ) ; }"}
{"text":"Function to find the K distant nodes from target node , it returns - 1 if target node is not present in tree","code":"static int kDistanceSum ( TreeNode root , int target , int k ) {"}
{"text":"Base Case 1","code":"if ( root == null ) return - 1 ;"}
{"text":"If target is same as root .","code":"if ( root . data == target ) { kDistanceDownSum ( root . left , k - 1 ) ; return 0 ; }"}
{"text":"Recurr for the left subtree","code":"int dl = - 1 ;"}
{"text":"Tree is BST so reduce the search space","code":"if ( target < root . data ) { dl = kDistanceSum ( root . left , target , k ) ; }"}
{"text":"Check if target node was found in left subtree","code":"if ( dl != - 1 ) {"}
{"text":"If root is at distance k from the target","code":"if ( dl + 1 == k ) sum += root . data ;"}
{"text":"Node less than target will be present in left","code":"return - 1 ; }"}
{"text":"When node is not present in the left subtree","code":"int dr = - 1 ; if ( target > root . data ) { dr = kDistanceSum ( root . right , target , k ) ; } if ( dr != - 1 ) {"}
{"text":"If Kth distant node is reached","code":"if ( dr + 1 == k ) sum += root . data ;"}
{"text":"Node less than target at k distance maybe present in the left tree","code":"else kDistanceDownSum ( root . left , k - dr - 2 ) ; return 1 + dr ; }"}
{"text":"If target was not present in the left nor in right subtree","code":"return - 1 ; }"}
{"text":"Function to insert a node in BST","code":"static TreeNode insertNode ( int data , TreeNode root ) {"}
{"text":"If root is null","code":"if ( root == null ) { TreeNode node = new TreeNode ( data ) ; return node ; }"}
{"text":"Insert the data in right half","code":"else if ( data > root . data ) { root . right = insertNode ( data , root . right ) ; }"}
{"text":"Insert the data in left half","code":"else if ( data <= root . data ) { root . left = insertNode ( data , root . left ) ; }"}
{"text":"Return the root node","code":"return root ; }"}
{"text":"Function to find the sum of K distant nodes from the target node having value less than target node","code":"static void findSum ( TreeNode root , int target , int K ) {"}
{"text":"Stores the sum of nodes having values < target at K distance","code":"sum = 0 ; kDistanceSum ( root , target , K ) ;"}
{"text":"Print the resultant sum","code":"System . out . print ( sum ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { TreeNode root = null ; int N = 11 ; int tree [ ] = { 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 } ;"}
{"text":"Create the Tree","code":"for ( int i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } int target = 7 ; int K = 2 ; findSum ( root , target , K ) ; } }"}
{"text":"Java Program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the type of the item given out according to the given rules","code":"static int itemType ( int n ) {"}
{"text":"Stores the count of item given out at each step","code":"int count = 0 ;"}
{"text":"Iterate over the days from 1","code":"for ( int day = 1 ; ; day ++ ) {"}
{"text":"Iterate over type of item on that day","code":"for ( int type = day ; type > 0 ; type -- ) { count += type ;"}
{"text":"Count of items given out should exceed n","code":"if ( count >= n ) return type ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( itemType ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to print the sum of array elements that are equidistant from two consecutive powers of 2","code":"static int FindSum ( int [ ] arr , int N ) {"}
{"text":"Stores the resultant sum of the array elements","code":"int res = 0 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Stores the power of 2 of the number arr [ i ]","code":"int power = ( int ) ( Math . log ( arr [ i ] ) \/ Math . log ( 2 ) ) ;"}
{"text":"Stores the number which is power of 2 and lesser than or equal to arr [ i ]","code":"int LesserValue = ( int ) Math . pow ( 2 , power ) ;"}
{"text":"Stores the number which is power of 2 and greater than or equal to arr [ i ]","code":"int LargerValue = ( int ) Math . pow ( 2 , power + 1 ) ;"}
{"text":"If arr [ i ] - LesserValue is the same as LargerValue - arr [ i ]","code":"if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) {"}
{"text":"Increment res by arr [ i ]","code":"res += arr [ i ] ; } }"}
{"text":"Return the resultant sum res","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 10 , 24 , 17 , 3 , 8 } ; int N = arr . length ; System . out . println ( FindSum ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to find the person who will finish last","code":"static void findLast ( int mat [ ] [ ] ) { int m = 3 ; int n = 3 ;"}
{"text":"To keep track of rows and columns having 1","code":"Set < Integer > rows = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i ] [ j ] > 0 ) ) { rows . add ( i ) ; cols . add ( j ) ; } } }"}
{"text":"Available rows and columns","code":"int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ;"}
{"text":"Minimum number of choices we have","code":"int choices = Math . min ( avRows , avCols ) ;"}
{"text":"If number of choices are odd","code":"if ( ( choices & 1 ) != 0 )"}
{"text":"P1 will finish last","code":"System . out . println ( \" P1\" ) ;"}
{"text":"Otherwise , P2 will finish last","code":"else System . out . println ( \" P2\" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; } }"}
{"text":"\/ Java program for the above approach","code":"import java . io . * ; import java . lang . * ; class GFG { static final int MOD = 1000000007 ;"}
{"text":"Function to find the sum of first N natural numbers represented in binary representation","code":"static void sumOfBinaryNumbers ( int n ) {"}
{"text":"Stores the resultant sum","code":"int ans = 0 ; int one = 1 ;"}
{"text":"Iterate until the value of N is greater than 0","code":"while ( true ) {"}
{"text":"If N is less than 2","code":"if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; }"}
{"text":"Store the MSB position of N","code":"int x = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ; int cur = 0 ; int add = ( int ) ( Math . pow ( 2 , ( x - 1 ) ) ) ;"}
{"text":"Iterate in the range [ 1 , x ] and add the contribution of the numbers from 1 to ( 2 ^ x - 1 )","code":"for ( int i = 1 ; i <= x ; i ++ ) {"}
{"text":"Update the value of the cur and add","code":"cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; }"}
{"text":"Add the cur to ans","code":"ans = ( ans + cur ) % MOD ;"}
{"text":"Store the remaining numbers","code":"int rem = n - ( int ) ( Math . pow ( 2 , x ) ) + 1 ;"}
{"text":"Add the contribution by MSB by the remaining numbers","code":"int p = ( int ) Math . pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ;"}
{"text":"The next iteration will be repeated for 2 ^ x - 1","code":"n = rem - 1 ; }"}
{"text":"Print the result","code":"System . out . println ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the Fibonacci number which is nearest to N","code":"static void nearestFibonacci ( int num ) {"}
{"text":"Base Case","code":"if ( num == 0 ) { System . out . print ( 0 ) ; return ; }"}
{"text":"Initialize the first & second terms of the Fibonacci series","code":"int first = 0 , second = 1 ;"}
{"text":"Store the third term","code":"int third = first + second ;"}
{"text":"Iterate until the third term is less than or equal to num","code":"while ( third <= num ) {"}
{"text":"Update the first","code":"first = second ;"}
{"text":"Update the second","code":"second = third ;"}
{"text":"Update the third","code":"third = first + second ; }"}
{"text":"Store the Fibonacci number having smaller difference with N","code":"int ans = ( Math . abs ( third - num ) >= Math . abs ( second - num ) ) ? second : third ;"}
{"text":"Print the result","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 17 ; nearestFibonacci ( N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to check if the maximum prefix array of ans [ ] is equal to array arr [ ]","code":"static boolean checkPermutation ( int ans [ ] , int a [ ] , int n ) {"}
{"text":"Initialize a variable , Max","code":"int Max = Integer . MIN_VALUE ;"}
{"text":"Traverse the array , ans [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Store the maximum value upto index i","code":"Max = Math . max ( Max , ans [ i ] ) ;"}
{"text":"If it is not equal to a [ i ] , then return false","code":"if ( Max != a [ i ] ) return false ; }"}
{"text":"Otherwise return false","code":"return true ; }"}
{"text":"Function to find the permutation of the array whose prefix maximum array is same as the given array a [ ]","code":"static void findPermutation ( int a [ ] , int n ) {"}
{"text":"Stores the required permutation","code":"int ans [ ] = new int [ n ] ;"}
{"text":"Stores the index of first occurrence of elements","code":"HashMap < Integer , Integer > um = new HashMap < > ( ) ;"}
{"text":"Traverse the array a [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If a [ i ] is not present in um , then store it in um","code":"if ( ! um . containsKey ( a [ i ] ) ) {"}
{"text":"Update the ans [ i ] to a [ i ]","code":"ans [ i ] = a [ i ] ; um . put ( a [ i ] , i ) ; } }"}
{"text":"Stores the unvisited numbers","code":"ArrayList < Integer > v = new ArrayList < > ( ) ; int j = 0 ;"}
{"text":"Fill the array , v [ ]","code":"for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"Store the index","code":"if ( ! um . containsKey ( i ) ) { v . add ( i ) ; } }"}
{"text":"Traverse the array , ans [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Fill v [ j ] at places where ans [ i ] is 0","code":"if ( ans [ i ] == 0 ) { ans [ i ] = v . get ( j ) ; j ++ ; } }"}
{"text":"Check if the current permutation maximum prefix array is same as the given array a [ ]","code":"if ( checkPermutation ( ans , a , n ) ) {"}
{"text":"If true , the print the permutation","code":"for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Otherwise , print - 1","code":"else System . out . println ( \" - 1\" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = arr . length ;"}
{"text":"Function Call","code":"findPermutation ( arr , N ) ; } }"}
{"text":"package whatever do not write package name here","code":"import java . io . * ; import java . util . Map ; import java . util . HashMap ; class GFG {"}
{"text":"Function to count the number of required pairs for every array element","code":"public static void countEqualElementPairs ( int arr [ ] , int N ) {"}
{"text":"Initialize a map","code":"HashMap < Integer , Integer > map = new HashMap < > ( ) ;"}
{"text":"Update the frequency of every element","code":"for ( int i = 0 ; i < N ; i ++ ) { Integer k = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , ( k == null ) ? 1 : k + 1 ) ; }"}
{"text":"Stores the count of pairs","code":"int total = 0 ;"}
{"text":"Traverse the map","code":"for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) {"}
{"text":"Count the number of ways to select pairs consisting of equal elements only","code":"total += ( e . getValue ( ) * ( e . getValue ( ) - 1 ) ) \/ 2 ; }"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Print the count for every array element","code":"System . out . print ( total - ( map . get ( arr [ i ] ) - 1 ) + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ;"}
{"text":"Size of the array","code":"int N = 5 ; countEqualElementPairs ( arr , N ) ; } }"}
{"text":"Java program to find the count of natural octal numbers upto N digits","code":"public class GFG {"}
{"text":"Function to return the count of natural octal numbers upto N digits","code":"static int count ( int N ) { int sum = 0 ;"}
{"text":"Loop to iterate from 1 to N and calculating number of octal numbers for every ' i ' th digit .","code":"for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( count ( N ) ) ; } }"}
{"text":"Java program to find all the palindromic divisors of a number","code":"import java . util . * ; class GFG {"}
{"text":"Function to check is num is palindromic or not","code":"static boolean isPalindrome ( int n ) {"}
{"text":"Convert n to String str","code":"String str = String . valueOf ( n ) ;"}
{"text":"Starting and ending index of String str","code":"int s = 0 , e = str . length ( ) - 1 ; while ( s < e ) {"}
{"text":"If char at s and e are not equals then return false","code":"if ( str . charAt ( s ) != str . charAt ( e ) ) { return false ; } s ++ ; e -- ; } return true ; }"}
{"text":"Function to find palindromic divisors","code":"static void palindromicDivisors ( int n ) {"}
{"text":"To sore the palindromic divisors of number n","code":"Vector < Integer > PalindromDivisors = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) {"}
{"text":"If n is divisible by i","code":"if ( n % i == 0 ) {"}
{"text":"Check if number is a perfect square","code":"if ( n \/ i == i ) {"}
{"text":"Check divisor is palindromic , then store it","code":"if ( isPalindrome ( i ) ) { PalindromDivisors . add ( i ) ; } } else {"}
{"text":"Check if divisors are palindrome","code":"if ( isPalindrome ( i ) ) { PalindromDivisors . add ( i ) ; }"}
{"text":"Check if n \/ divisors is palindromic or not","code":"if ( isPalindrome ( n \/ i ) ) { PalindromDivisors . add ( n \/ i ) ; } } } }"}
{"text":"Print all palindromic divisors in sorted order","code":"Collections . sort ( PalindromDivisors ) ; for ( int i = 0 ; i < PalindromDivisors . size ( ) ; i ++ ) { System . out . print ( PalindromDivisors . get ( i ) + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 66 ;"}
{"text":"Function call to find all palindromic divisors","code":"palindromicDivisors ( n ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the minimum deletions to get minimum OR","code":"static int findMinDel ( int [ ] arr , int n ) {"}
{"text":"To store the minimum element","code":"int min_num = Integer . MAX_VALUE ;"}
{"text":"Find the minimum element from the array","code":"for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ;"}
{"text":"To store the frequency of the minimum element","code":"int cnt = 0 ;"}
{"text":"Find the frequency of the minimum element","code":"for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ;"}
{"text":"Return the final answer","code":"return n - cnt ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 2 } ; int n = arr . length ; System . out . print ( findMinDel ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the required count","code":"static int cntSubArr ( int [ ] arr , int n ) {"}
{"text":"To store the final answer","code":"int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"To store the GCD starting from index ' i '","code":"int curr_gcd = 0 ;"}
{"text":"Loop to find the gcd of each subarray from arr [ i ] to arr [ i ... n - 1 ]","code":"for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ;"}
{"text":"Increment the count if curr_gcd = 1","code":"ans += ( curr_gcd == 1 ) ? 1 : 0 ; } }"}
{"text":"Return the final answer","code":"return ans ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( cntSubArr ( arr , n ) ) ; } }"}
{"text":"Java program to display first N Prime numbers","code":"class GFG {"}
{"text":"Function to print first N prime numbers","code":"static void print_primes_till_N ( int N ) {"}
{"text":"Declare the variables","code":"int i , j , flag ;"}
{"text":"Print display message","code":"System . out . println ( \" Prime \u2581 numbers \u2581 between \u2581 1 \u2581 and \u2581 \" + N + \" \u2581 are : \" ) ;"}
{"text":"Traverse each number from 1 to N with the help of for loop","code":"for ( i = 1 ; i <= N ; i ++ ) {"}
{"text":"Skip 0 and 1 as they are neither prime nor composite","code":"if ( i == 1 i == 0 ) continue ;"}
{"text":"flag variable to tell if i is prime or not","code":"flag = 1 ; for ( j = 2 ; j <= i \/ 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } }"}
{"text":"flag = 1 means i is prime and flag = 0 means i is not prime","code":"if ( flag == 1 ) System . out . print ( i + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 100 ; print_primes_till_N ( N ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int MAX = 32 ;"}
{"text":"Function to find X according to the given conditions","code":"static int findX ( int A , int B ) { int X = 0 ;"}
{"text":"int can have 32 bits","code":"for ( int bit = 0 ; bit < MAX ; bit ++ ) {"}
{"text":"Temporary ith bit","code":"int tempBit = 1 << bit ;"}
{"text":"Compute ith bit of X according to given conditions Expression below is the direct conclusion from the illustration we had taken earlier","code":"int bitOfX = A & B & tempBit ;"}
{"text":"Add the ith bit of X to X","code":"X += bitOfX ; } return X ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A = 11 , B = 13 ; System . out . println ( findX ( A , B ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the count of subsets with the maximum mean","code":"static int cntSubSets ( int arr [ ] , int n ) {"}
{"text":"Maximum value from the array","code":"int maxVal = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;"}
{"text":"To store the number of times maximum element appears in the array","code":"int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; }"}
{"text":"Return the count of valid subsets","code":"return ( int ) ( Math . pow ( 2 , cnt ) - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = arr . length ; System . out . println ( cntSubSets ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the probability of getting the maximum pair sum when a random pair is chosen from the given array","code":"static float findProb ( int arr [ ] , int n ) {"}
{"text":"Initialize the maximum sum , its count and the count of total pairs","code":"long maxSum = Integer . MIN_VALUE , maxCount = 0 , totalPairs = 0 ;"}
{"text":"For every single pair","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {"}
{"text":"Get the sum of the current pair","code":"int sum = arr [ i ] + arr [ j ] ;"}
{"text":"If the sum is equal to the current maximum sum so far","code":"if ( sum == maxSum ) {"}
{"text":"Increment its count","code":"maxCount ++ ; }"}
{"text":"If the sum is greater than the current maximum","code":"else if ( sum > maxSum ) {"}
{"text":"Update the current maximum and re - initialize the count to 1","code":"maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } }"}
{"text":"Find the required probability","code":"float prob = ( float ) maxCount \/ ( float ) totalPairs ; return prob ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = arr . length ; System . out . println ( findProb ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text":"Function to return the count of common factors of a and b such that all the elements are co - prime to one another","code":"static int maxCommonFactors ( int a , int b ) {"}
{"text":"GCD of a and b","code":"int __gcd = gcd ( a , b ) ;"}
{"text":"Include 1 initially","code":"int ans = 1 ;"}
{"text":"Find all the prime factors of the gcd","code":"for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd \/= i ; } }"}
{"text":"If gcd is prime","code":"if ( __gcd != 1 ) ans ++ ;"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 12 , b = 18 ; System . out . println ( maxCommonFactors ( a , b ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ;"}
{"text":"Function to return the day number of the year for the given date","code":"static int dayOfYear ( String date ) {"}
{"text":"Extract the year , month and the day from the date string","code":"int year = Integer . parseInt ( date . substring ( 0 , 4 ) ) ; int month = Integer . parseInt ( date . substring ( 5 , 7 ) ) ; int day = Integer . parseInt ( date . substring ( 8 ) ) ;"}
{"text":"If current year is a leap year and the date given is after the 28 th of February then it must include the 29 th February","code":"if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; }"}
{"text":"Add the days in the previous months","code":"while ( -- month > 0 ) { day = day + days [ month - 1 ] ; } return day ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String date = \"2019-01-09\" ; System . out . println ( dayOfYear ( date ) ) ; } }"}
{"text":"Java program to find number of cells in the table contains X","code":"class GFG {"}
{"text":"Function to find number of cells in the table contains X","code":"public static int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x \/ i <= n ) ans ++ ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 6 , x = 12 ;"}
{"text":"Function call","code":"System . out . println ( Cells ( n , x ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; import java . lang . Math ; import java . io . * ; class GFG {"}
{"text":"Function to return the smallest power of 4 greater than or equal to n","code":"static int nextPowerOfFour ( int n ) { int x = ( int ) Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ;"}
{"text":"If n is itself is a power of 4 then return n","code":"if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . pow ( x , 4 ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) throws java . lang . Exception { int n = 122 ; System . out . println ( nextPowerOfFour ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the minimum operations required","code":"static int minOperations ( int x , int y , int p , int q ) {"}
{"text":"Not possible","code":"if ( y % x != 0 ) return - 1 ; int d = y \/ x ;"}
{"text":"To store the greatest power of p that divides d","code":"int a = 0 ;"}
{"text":"While divible by p","code":"while ( d % p == 0 ) { d \/= p ; a ++ ; }"}
{"text":"To store the greatest power of q that divides d","code":"int b = 0 ;"}
{"text":"While divible by q","code":"while ( d % q == 0 ) { d \/= q ; b ++ ; }"}
{"text":"If d > 1","code":"if ( d != 1 ) return - 1 ;"}
{"text":"Since , d = p ^ a * q ^ b","code":"return ( a + b ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; System . out . println ( minOperations ( x , y , p , q ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate NC4","code":"static int nCr ( int n ) {"}
{"text":"Base case to calculate NC4","code":"if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer \/= 24 ; return answer ; }"}
{"text":"Function to return the count of required quadruples using Inclusion Exclusion","code":"static int countQuadruples ( int N , int K ) {"}
{"text":"Effective N","code":"int M = N \/ K ; int answer = nCr ( M ) ;"}
{"text":"Iterate over 2 to M","code":"for ( int i = 2 ; i < M ; i ++ ) { int j = i ;"}
{"text":"Number of divisors of i till M","code":"int temp2 = M \/ i ;"}
{"text":"Count stores the number of prime divisors occurring exactly once","code":"int count = 0 ;"}
{"text":"To prevent repetition of prime divisors","code":"int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j \/= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= Math . sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j \/= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; }"}
{"text":"If repetition of prime divisors present ignore this number","code":"if ( check == 1 ) continue ; else {"}
{"text":"If prime divisor count is odd subtract it from answer else add","code":"if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( countQuadruples ( N , K ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to return the required number X","code":"static int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) \/ ( d - c ) ; return X ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 4 , d = 5 ; System . out . println ( getX ( a , b , c , d ) ) ; } }"}
{"text":"Java code for above approach","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to check if a character is vowel or consonent","code":"static boolean isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; }"}
{"text":"Function to calculate factorial of a number","code":"static long fact ( long n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; }"}
{"text":"Calculating no of ways for arranging vowels","code":"static long only_vowels ( HashMap < Character , Integer > freq ) { long denom = 1 ; long cnt_vwl = 0 ;"}
{"text":"Iterate the map and count the number of vowels and calculate no of ways to arrange vowels","code":"for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { if ( isVowel ( itr . getKey ( ) ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt_vwl += itr . getValue ( ) ; } } return fact ( cnt_vwl ) \/ denom ; }"}
{"text":"Calculating no of ways to arrange the given word such that all vowels come together","code":"static long all_vowels_together ( HashMap < Character , Integer > freq ) {"}
{"text":"Calculate no of ways to arrange vowels","code":"long vow = only_vowels ( freq ) ;"}
{"text":"To store denominator of fraction","code":"long denom = 1 ;"}
{"text":"Count of consonents","code":"long cnt_cnst = 0 ; for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { if ( ! isVowel ( itr . getKey ( ) ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt_cnst += itr . getValue ( ) ; } }"}
{"text":"Calculate the number of ways to arrange the word such that all vowels come together","code":"long ans = fact ( cnt_cnst + 1 ) \/ denom ; return ( ans * vow ) ; }"}
{"text":"To calculate total number of permutations","code":"static long total_permutations ( HashMap < Character , Integer > freq ) {"}
{"text":"To store length of the given word","code":"long cnt = 0 ;"}
{"text":"Denominator of fraction","code":"long denom = 1 ; for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt += itr . getValue ( ) ; }"}
{"text":"Return total number of permutations of the given word","code":"return fact ( cnt ) \/ denom ; }"}
{"text":"Function to calculate number of permutations such that no vowels come together","code":"static long no_vowels_together ( String word ) {"}
{"text":"To store frequency of character","code":"HashMap < Character , Integer > freq = new HashMap < > ( ) ;"}
{"text":"Count frequency of all characters","code":"for ( int i = 0 ; i < word . length ( ) ; i ++ ) { char ch = Character . toLowerCase ( word . charAt ( i ) ) ; if ( freq . containsKey ( ch ) ) { freq . put ( ch , freq . get ( ch ) + 1 ) ; } else { freq . put ( ch , 1 ) ; } }"}
{"text":"Calculate total number of permutations","code":"long total = total_permutations ( freq ) ;"}
{"text":"Calculate total number of permutations such that all vowels come together","code":"long vwl_tgthr = all_vowels_together ( freq ) ;"}
{"text":"Subtract vwl_tgthr from total to get the result","code":"long res = total - vwl_tgthr ;"}
{"text":"Return the result","code":"return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String word = \" allahabad \" ; long ans = no_vowels_together ( word ) ; System . out . println ( ans ) ; word = \" geeksforgeeks \" ; ans = no_vowels_together ( word ) ; System . out . println ( ans ) ; word = \" abcd \" ; ans = no_vowels_together ( word ) ; System . out . println ( ans ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the number of men initially","code":"static int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) \/ d ; return Men ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int D = 5 , m = 4 , d = 4 ; System . out . println ( numberOfMen ( D , m , d ) ) ; } }"}
{"text":"Java program area of triangle formed by the axes of co - ordinates and a given straight line","code":"import java . io . * ; class GFG {"}
{"text":"Function to find area","code":"static double area ( double a , double b , double c ) { double d = Math . abs ( ( c * c ) \/ ( 2 * a * b ) ) ; return d ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double a = - 2 , b = 4 , c = 3 ; System . out . println ( area ( a , b , c ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the vector containing the answer","code":"static ArrayList < Integer > addToArrayForm ( ArrayList < Integer > A , int K ) {"}
{"text":"ArrayList v is to store each digits sum and ArrayList ans is to store the answer","code":"ArrayList < Integer > v = new ArrayList < Integer > ( ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ;"}
{"text":"No carry in the beginning","code":"int rem = 0 ; int i = 0 ;"}
{"text":"Start loop from the end and take element one by one","code":"for ( i = A . size ( ) - 1 ; i >= 0 ; i -- ) {"}
{"text":"Array index and last digit of number","code":"int my = A . get ( i ) + K % 10 + rem ; if ( my > 9 ) {"}
{"text":"Maintain carry of summation","code":"rem = 1 ;"}
{"text":"Push the digit value into the array","code":"v . add ( my % 10 ) ; } else { v . add ( my ) ; rem = 0 ; } K = K \/ 10 ; }"}
{"text":"K value is greater then 0","code":"while ( K > 0 ) {"}
{"text":"Push digits of K one by one in the array","code":"int my = K % 10 + rem ; v . add ( my % 10 ) ;"}
{"text":"Also maintain carry with summation","code":"if ( my \/ 10 > 0 ) rem = 1 ; else rem = 0 ; K = K \/ 10 ; } if ( rem > 0 ) v . add ( rem ) ;"}
{"text":"Reverse the elements of vector v and store it in vector ans","code":"for ( int j = v . size ( ) - 1 ; j >= 0 ; j -- ) ans . add ( v . get ( j ) ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; A . add ( 2 ) ; A . add ( 7 ) ; A . add ( 4 ) ; int K = 181 ; ArrayList < Integer > ans = addToArrayForm ( A , K ) ;"}
{"text":"Print the answer","code":"for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int MAX = 100005 ;"}
{"text":"Function to return maximum sum of a sub - array","code":"static int kadaneAlgorithm ( int [ ] ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . max ( maxSum , sum ) ; } return maxSum ; }"}
{"text":"Function to return maximum value of function F","code":"static int maxFunction ( int [ ] arr , int n ) { int [ ] b = new int [ MAX ] ; int [ ] c = new int [ MAX ] ;"}
{"text":"Compute arrays B [ ] and C [ ]","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 1 ) { b [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } }"}
{"text":"Find maximum sum sub - array of both of the arrays and take maximum among them","code":"int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 4 , 7 } ; int n = arr . length ; System . out . println ( maxFunction ( arr , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to find the element","code":"static int findThirdDigit ( int n ) {"}
{"text":"if n < 3","code":"if ( n < 3 ) return 0 ;"}
{"text":"If n is even return 6 If n is odd return 1","code":"return ( n & 1 ) > 0 ? 1 : 6 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 7 ; System . out . println ( findThirdDigit ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the probability of A winning","code":"static double getProbability ( int a , int b , int c , int d ) {"}
{"text":"p and q store the values of fractions a \/ b and c \/ d","code":"double p = ( double ) a \/ ( double ) b ; double q = ( double ) c \/ ( double ) d ;"}
{"text":"To store the winning probability of A","code":"double ans = p * ( 1 \/ ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 10 , d = 11 ; System . out . printf ( \" % .5f \" , getProbability ( a , b , c , d ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if n is palindrome","code":"static boolean isPalindrome ( int n ) {"}
{"text":"Find the appropriate divisor to extract the leading digit","code":"int divisor = 1 ; while ( n \/ divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n \/ divisor ; int trailing = n % 10 ;"}
{"text":"If first and last digits are not same then return false","code":"if ( leading != trailing ) return false ;"}
{"text":"Removing the leading and trailing digits from the number","code":"n = ( n % divisor ) \/ 10 ;"}
{"text":"Reducing divisor by a factor of 2 as 2 digits are dropped","code":"divisor = divisor \/ 100 ; } return true ; }"}
{"text":"Function to find the largest palindromic number","code":"static int largestPalindrome ( int [ ] A , int n ) { int currentMax = - 1 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If a palindrome larger than the currentMax is found","code":"if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; }"}
{"text":"Return the largest palindromic number from the array","code":"return currentMax ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int [ ] A = { 1 , 232 , 54545 , 999991 } ; int n = A . length ;"}
{"text":"print required answer","code":"System . out . println ( largestPalindrome ( A , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class OddPosition {"}
{"text":"Function to return the final element","code":"public static long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( getFinalElement ( N ) ) ; } }"}
{"text":"Java program to find sum of elements in an array having prime frequency","code":"import java . util . * ; class GFG {"}
{"text":"Function to create Sieve to check primes","code":"static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) {"}
{"text":"False here indicates that it is not prime","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p , set them to non - prime","code":"for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to return the sum of elements in an array having prime frequency","code":"static int sumOfElements ( int arr [ ] , int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , n + 1 ) ; int i , j ;"}
{"text":"Map is used to store element frequencies","code":"HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; else m . put ( arr [ i ] , 1 ) ; } int sum = 0 ;"}
{"text":"Traverse the map","code":"for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) { int key = entry . getKey ( ) ; int value = entry . getValue ( ) ;"}
{"text":"Count the number of elements having prime frequencies","code":"if ( prime [ value ] ) { sum += ( key ) ; } } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = arr . length ; System . out . println ( sumOfElements ( arr , n ) ) ; } }"}
{"text":"Java program to find the sum of all odd length palindromic numbers within the given range","code":"class GFG {"}
{"text":"Function that returns true if the given number is a palindrome","code":"static boolean isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ;"}
{"text":"Here we are generating a new number ( reverse_num ) * by reversing the digits of original input number","code":"temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp \/= 10 ; }"}
{"text":"If the original input number ( num ) is equal to * to its reverse ( reverse_num ) then its palindrome * else it is not .","code":"if ( reverse_num == num ) { return true ; } return false ; }"}
{"text":"Function that returns true if the given number is of odd length","code":"static boolean isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num \/= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; }"}
{"text":"Function to return the sum of all odd length palindromic numbers within the given range","code":"static long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) {"}
{"text":"if number is palindrome and of odd length","code":"if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int L = 110 , R = 1130 ; System . out . println ( sumOfAllPalindrome ( L , R ) ) ; } }"}
{"text":"Java program to calculate the no . of ways to arrange the word having vowels together","code":"import java . util . * ; class GFG {"}
{"text":"Factorial of a number","code":"static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; }"}
{"text":"Calculating ways for arranging consonants","code":"static int waysOfConsonants ( int size1 , int [ ] freq ) { int ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) {"}
{"text":"Ignore vowels","code":"if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans \/ fact ( freq [ i ] ) ; } return ans ; }"}
{"text":"Calculating ways for arranging vowels","code":"static int waysOfVowels ( int size2 , int [ ] freq ) { return fact ( size2 ) \/ ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; }"}
{"text":"Function to count total no . of ways","code":"static int countWays ( String str ) { int [ ] freq = new int [ 200 ] ; for ( int i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Count vowels and consonant","code":"int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != ' a ' && str . charAt ( i ) != ' e ' && str . charAt ( i ) != ' i ' && str . charAt ( i ) != ' o ' && str . charAt ( i ) != ' u ' ) consonant ++ ; else vowel ++ ; }"}
{"text":"Total no . of ways","code":"return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; System . out . println ( countWays ( str ) ) ; } }"}
{"text":"Java Program to find alternate sum of Fibonacci numbers","code":"public class GFG {"}
{"text":"Computes value of first fibonacci numbers and stores their alternate sum","code":"static double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ;"}
{"text":"Initialize result","code":"double sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ;"}
{"text":"Add remaining terms","code":"for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;"}
{"text":"For even terms","code":"if ( i % 2 == 0 ) sum -= fibo [ i ] ;"}
{"text":"For odd terms","code":"else sum += fibo [ i ] ; }"}
{"text":"Return the alternating sum","code":"return sum ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"Get n","code":"int n = 8 ;"}
{"text":"Find the alternating sum","code":"System . out . println ( \" Alternating \u2581 Fibonacci \u2581 Sum \u2581 upto \u2581 \" + n + \" \u2581 terms : \u2581 \" + calculateAlternateSum ( n ) ) ; } }"}
{"text":"Java Program to find Nth term","code":"class GFG {"}
{"text":"Function that will return nth term","code":"static int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Get n","code":"int n = 9 ;"}
{"text":"Get the value","code":"System . out . println ( getValue ( n ) ) ;"}
{"text":"Get n","code":"n = 1025 ;"}
{"text":"Get the value","code":"System . out . println ( getValue ( n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . io . * ; import java . util . * ; public class GFG {"}
{"text":"Function that traverses digits in a number and modifies frequency count array","code":"static void countDigits ( double val , long [ ] arr ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val \/ 10 ; } return ; } static void countFrequency ( int x , int n ) {"}
{"text":"Array to keep count of digits","code":"long [ ] freq_count = new long [ 10 ] ;"}
{"text":"Traversing through x ^ 1 to x ^ n","code":"for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"For power function , both its parameters are to be in double","code":"double val = Math . pow ( ( double ) x , ( double ) i ) ;"}
{"text":"calling countDigits function on x ^ i","code":"countDigits ( val , freq_count ) ; }"}
{"text":"Printing count of digits 0 - 9","code":"for ( int i = 0 ; i <= 9 ; i ++ ) { System . out . print ( freq_count [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; } }"}
{"text":"Java program to find the number of values of b such that a = b + ( a ^ b )","code":"import java . io . * ; class GFG {"}
{"text":"function to return the number of solutions","code":"static int countSolutions ( int a ) { int count = 0 ;"}
{"text":"check for every possible value","code":"for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }"}
{"text":"Java program to find the number of values of b such that a = b + ( a ^ b )","code":"import java . io . * ; class GFG {"}
{"text":"function to return the number of solutions","code":"static int countSolutions ( int a ) { int count = Integer . bitCount ( a ) ; count = ( int ) Math . pow ( 2 , count ) ; return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }"}
{"text":"Java program to calculate the sum of area of all possible squares that comes inside the rectangle","code":"class GFG {"}
{"text":"Function to calculate the sum of area of all possible squares that comes inside the rectangle","code":"static int calculateAreaSum ( int l , int b ) { int size = 1 ;"}
{"text":"Square with max size possible","code":"int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) {"}
{"text":"calculate total square of a given size","code":"int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ;"}
{"text":"calculate area of squares of a particular size","code":"int area = totalSquares * size * size ;"}
{"text":"total area","code":"totalArea += area ;"}
{"text":"increment size","code":"size ++ ; } return totalArea ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int l = 4 , b = 3 ; System . out . println ( calculateAreaSum ( l , b ) ) ; } }"}
{"text":"function to calculate the value of hyperfactorial","code":"class GFG { static long boost_hyperfactorial ( long num ) {"}
{"text":"initialise the val to 1","code":"long val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * ( long ) Math . pow ( i , i ) ; }"}
{"text":"returns the hyperfactorial of a number","code":"return val ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int num = 5 ; System . out . println ( boost_hyperfactorial ( num ) ) ; } }"}
{"text":"Java program to find the hyperfactorial of a number using boost libraries","code":"import java . io . * ; class GFG {"}
{"text":"function to calculate the value of hyperfactorial","code":"static int boost_hyperfactorial ( int num ) {"}
{"text":"initialise the val to 1","code":"int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) {"}
{"text":"1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . .","code":"val *= i ; } }"}
{"text":"returns the hyperfactorial of a number","code":"return val ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( boost_hyperfactorial ( num ) ) ; } }"}
{"text":"Java code to subtract one from a given number","code":"import java . io . * ; class GFG { static int subtractOne ( int x ) { int m = 1 ;"}
{"text":"Flip all the set bits until we find a 1","code":"while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; }"}
{"text":"flip the rightmost 1 bit","code":"x = x ^ m ; return x ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { System . out . println ( subtractOne ( 13 ) ) ; } }"}
{"text":"Java program to find mean vector of given matrix","code":"import java . io . * ; class GFG { static int rows = 3 ; static int cols = 3 ;"}
{"text":"Function to find mean vector","code":"static void meanVector ( int mat [ ] [ ] ) { System . out . print ( \" [ \u2581 \" ) ;"}
{"text":"loop to traverse each column","code":"for ( int i = 0 ; i < rows ; i ++ ) {"}
{"text":"to calculate mean of each row","code":"double mean = 0.00 ;"}
{"text":"to store sum of elements of a column","code":"int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum \/ rows ; System . out . print ( ( int ) mean + \" \u2581 \" ) ; } System . out . print ( \" ] \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; } }"}
{"text":"Java code to check if a number is a hoax number or not .","code":"import java . io . * ; import java . util . * ; public class GFG {"}
{"text":"Function to find distinct prime factors of given number n","code":"static List < Integer > primeFactors ( int n ) { List < Integer > res = new ArrayList < Integer > ( ) ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n \/ 2 ; res . add ( 2 ) ; }"}
{"text":"n is odd at this point , since it is no longer divisible by 2. So we can test only for the odd numbers , whether they are factors of n","code":"for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) {"}
{"text":"Check if i is prime factor","code":"if ( n % i == 0 ) { while ( n % i == 0 ) n = n \/ i ; res . add ( i ) ; } }"}
{"text":"This condition is to handle the case when n is a prime number greater than 2","code":"if ( n > 2 ) res . add ( n ) ; return res ; }"}
{"text":"Function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained","code":"static boolean isHoax ( int n ) {"}
{"text":"Distinct prime factors of n are being stored in vector pf","code":"List < Integer > pf = primeFactors ( n ) ;"}
{"text":"If n is a prime number , it cannot be a hoax number","code":"if ( pf . get ( 0 ) == n ) return false ;"}
{"text":"Finding sum of digits of distinct prime factors of the number n","code":"int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) {"}
{"text":"Finding sum of digits in current prime factor pf [ i ] .","code":"int pf_sum ; for ( pf_sum = 0 ; pf . get ( i ) > 0 ; pf_sum += pf . get ( i ) % 10 , pf . set ( i , pf . get ( i ) \/ 10 ) ) ; all_pf_sum += pf_sum ; }"}
{"text":"Finding sum of digits of number n","code":"int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n \/= 10 ) ;"}
{"text":"Comparing the two calculated sums","code":"return sum_n == all_pf_sum ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 84 ; if ( isHoax ( n ) ) System . out . print ( \"A Hoax NumberNEW_LINE\"); else System . out . print ( \"Not a Hoax NumberNEW_LINE\"); } }"}
{"text":"Java program to find out Lucas - Lehmer series .","code":"import java . util . * ; class GFG {"}
{"text":"Function to find out first n terms ( considering 4 as 0 th term ) of Lucas - Lehmer series .","code":"static void LucasLehmer ( int n ) {"}
{"text":"the 0 th term of the series is 4.","code":"long current_val = 4 ;"}
{"text":"create an array to store the terms .","code":"ArrayList < Long > series = new ArrayList < > ( ) ;"}
{"text":"compute each term and add it to the array .","code":"series . add ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . add ( current_val ) ; }"}
{"text":"print out the terms one by one .","code":"for ( int i = 0 ; i <= n ; i ++ ) { System . out . println ( \" Term \u2581 \" + i + \" : \u2581 \" + series . get ( i ) ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 5 ; LucasLehmer ( n ) ; } }"}
{"text":"Java program to find modular inverse of all numbers from 1 to n using naive method","code":"import java . io . * ; class GFG {"}
{"text":"A naive method to find modular multiplicative inverse of ' a ' under modulo ' prime '","code":"static int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; } static void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( modInverse ( i , prime ) + \" \u2581 \" ) ; }"}
{"text":"Driver Program","code":"public static void main ( String args [ ] ) { int n = 10 , prime = 17 ; printModIverses ( n , prime ) ; } }"}
{"text":"Java to find min operations required to convert into charming number","code":"class GFG {"}
{"text":"function for minimum operation","code":"static int minOp ( int num ) {"}
{"text":"remainder and operations count","code":"int rem ; int count = 0 ;"}
{"text":"count digits not equal to 3 or 8","code":"while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num \/= 10 ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int num = 234198 ; System . out . print ( \" Minimum \u2581 Operations \u2581 = \" + minOp ( num ) ) ; } }"}
{"text":"Java program to find the number with maximum digit sum .","code":"import java . io . * ; class GFG {"}
{"text":"function to calculate the sum of digits of a number .","code":"static int sumOfDigits ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a \/= 10 ; } return sum ; }"}
{"text":"Returns the maximum number with maximum sum of digits .","code":"static int findMax ( int x ) {"}
{"text":"initializing b as 1 and initial max sum to be of n","code":"int b = 1 , ans = x ;"}
{"text":"iterates from right to left in a digit","code":"while ( x != 0 ) {"}
{"text":"while iterating this is the number from from right to left","code":"int cur = ( x - 1 ) * b + ( b - 1 ) ;"}
{"text":"calls the function to check if sum of cur is more then of ans","code":"if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ;"}
{"text":"reduces the number to one unit less","code":"x \/= 10 ; b *= 10 ; } return ans ; }"}
{"text":"driver program","code":"public static void main ( String [ ] args ) { int n = 521 ; System . out . println ( findMax ( n ) ) ; } }"}
{"text":"Java program to find IQR of a data set","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to give index of the median","code":"static int median ( int a [ ] , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) \/ 2 - 1 ; return n + l ; }"}
{"text":"Function to calculate IQR","code":"static int IQR ( int [ ] a , int n ) { Arrays . sort ( a ) ;"}
{"text":"Index of median of entire data","code":"int mid_index = median ( a , 0 , n ) ;"}
{"text":"Median of first half","code":"int Q1 = a [ median ( a , 0 , mid_index ) ] ;"}
{"text":"Median of second half","code":"int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ;"}
{"text":"IQR calculation","code":"return ( Q3 - Q1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] a = { 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 } ; int n = a . length ; System . out . println ( IQR ( a , n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if n is palindrome","code":"static boolean isPalindrome ( int n ) {"}
{"text":"Find the appropriate divisor to extract the leading digit","code":"int divisor = 1 ; while ( n \/ divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n \/ divisor ; int trailing = n % 10 ;"}
{"text":"If first and last digits are not same then return false","code":"if ( leading != trailing ) return false ;"}
{"text":"Removing the leading and trailing digits from the number","code":"n = ( n % divisor ) \/ 10 ;"}
{"text":"Reducing divisor by a factor of 2 as 2 digits are dropped","code":"divisor = divisor \/ 100 ; } return true ; }"}
{"text":"Function to find the largest palindromic number","code":"static int largestPalindrome ( int [ ] A , int n ) {"}
{"text":"Sort the array","code":"Arrays . sort ( A ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) {"}
{"text":"If number is palindrome","code":"if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; }"}
{"text":"If no palindromic number found","code":"return - 1 ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int [ ] A = { 1 , 232 , 54545 , 999991 } ; int n = A . length ;"}
{"text":"print required answer","code":"System . out . println ( largestPalindrome ( A , n ) ) ; } }"}
{"text":"Java program to find the sum of all the integers below N which are multiples of either A or B","code":"import java . io . * ; class GFG {"}
{"text":"Function to return the sum of all the integers below N which are multiples of either A or B","code":"static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ )"}
{"text":"If i is a multiple of a or b","code":"if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 , a = 3 , b = 5 ; System . out . println ( findSum ( n , a , b ) ) ; } }"}
{"text":"Driver code","code":"class GFG { static int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } public static void main ( String [ ] args ) { System . out . printf ( \" % d \" , subtractOne ( 13 ) ) ; } }"}
{"text":"Pell Number Series using Recursion in JAVA","code":"class PellNumber {"}
{"text":"calculate n - th Pell number","code":"public static int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }"}
{"text":"driver function","code":"public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( pell ( n ) ) ; } }"}
{"text":"Java program to find LCM of array without using GCD .","code":"import java . util . Vector ; class GFG {"}
{"text":"Returns LCM of arr [ 0. . n - 1 ]","code":"static long LCM ( int arr [ ] , int n ) {"}
{"text":"Find the maximum value in arr [ ]","code":"int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_num < arr [ i ] ) { max_num = arr [ i ] ; } }"}
{"text":"Initialize result","code":"long res = 1 ;"}
{"text":"Find all factors that are present in two or more array elements . int x = 2 ; Current factor .","code":"while ( x <= max_num ) {"}
{"text":"To store indexes of all array elements that are divisible by x .","code":"Vector < Integer > indexes = new Vector < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % x == 0 ) { indexes . add ( indexes . size ( ) , j ) ; } }"}
{"text":"If there are 2 or more array elements that are divisible by x .","code":"if ( indexes . size ( ) >= 2 ) {"}
{"text":"Reduce all array elements divisible by x .","code":"for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) { arr [ indexes . get ( j ) ] = arr [ indexes . get ( j ) ] \/ x ; } res = res * x ; } else { x ++ ; } }"}
{"text":"Then multiply all reduced array elements","code":"for ( int i = 0 ; i < n ; i ++ ) { res = res * arr [ i ] ; } return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = arr . length ; System . out . println ( LCM ( arr , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . lang . Math ; public class Main {"}
{"text":"Function to find politeness","code":"static int politness ( int n ) { int count = 0 ;"}
{"text":"sqrt ( 2 * n ) as max length will be when the sum starts from 1 which follows the equation n ^ 2 - n - ( 2 * sum ) = 0","code":"for ( int i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a \/= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a \/= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 90 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; n = 15 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; } }"}
{"text":"Java program to implement Goldbach 's conjecture","code":"import java . util . * ; class GFG { static int MAX = 10000 ;"}
{"text":"Array to store all prime less than and equal to 10 ^ 6","code":"static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;"}
{"text":"Utility function for Sieve of Sundaram","code":"static void sieveSundaram ( ) {"}
{"text":"In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half This array is used to separate numbers of the form i + j + 2 * i * j from others where 1 <= i <= j","code":"boolean [ ] marked = new boolean [ MAX \/ 2 + 100 ] ;"}
{"text":"Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1","code":"for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) \/ 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX \/ 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ;"}
{"text":"Since 2 is a prime number","code":"primes . add ( 2 ) ;"}
{"text":"Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for ( int i = 1 ; i <= MAX \/ 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; }"}
{"text":"Function to perform Goldbach 's conjecture","code":"static void findPrimes ( int n ) {"}
{"text":"Return if number is not even or less than 3","code":"if ( n <= 2 n % 2 != 0 ) { System . out . println ( \" Invalid \u2581 Input \u2581 \" ) ; return ; }"}
{"text":"Check only upto half of number","code":"for ( int i = 0 ; primes . get ( i ) <= n \/ 2 ; i ++ ) {"}
{"text":"find difference by subtracting current prime from n","code":"int diff = n - primes . get ( i ) ;"}
{"text":"Search if the difference is also a prime number","code":"if ( primes . contains ( diff ) ) {"}
{"text":"Express as a sum of primes","code":"System . out . println ( primes . get ( i ) + \" \u2581 + \u2581 \" + diff + \" \u2581 = \u2581 \" + n ) ; return ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Finding all prime numbers before limit","code":"sieveSundaram ( ) ;"}
{"text":"Express number as a sum of two primes","code":"findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; } }"}
{"text":"JAVA Program to print kth prime factor","code":"import java . io . * ; import java . math . * ; class GFG {"}
{"text":"A function to generate prime factors of a given number n and return k - th prime factor","code":"static int kPrimeFactor ( int n , int k ) {"}
{"text":"Find the number of 2 's that  divide k","code":"while ( n % 2 == 0 ) { k -- ; n = n \/ 2 ; if ( k == 0 ) return 2 ; }"}
{"text":"n must be odd at this point . So we can skip one element ( Note i = i + 2 )","code":"for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) {"}
{"text":"While i divides n , store i and divide n","code":"while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n \/ i ; } }"}
{"text":"This condition is to handle the case where n is a prime number greater than 2","code":"if ( n > 2 && k == 1 ) return n ; return - 1 ; }"}
{"text":"Driver Program","code":"public static void main ( String args [ ] ) { int n = 12 , k = 3 ; System . out . println ( kPrimeFactor ( n , k ) ) ; n = 14 ; k = 3 ; System . out . println ( kPrimeFactor ( n , k ) ) ; } }"}
{"text":"Java program to find k - th prime factor using Sieve Of Eratosthenes . This program is efficient when we have a range of numbers .","code":"class GFG { static int MAX = 10001 ;"}
{"text":"Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if MAX is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7","code":"static void sieveOfEratosthenes ( int [ ] s ) {"}
{"text":"Create a boolean array \" prime [ 0 . . MAX ] \" and initialize all entries in it as false .","code":"boolean [ ] prime = new boolean [ MAX + 1 ] ;"}
{"text":"Initializing smallest factor equal to 2 for all the even numbers","code":"for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ;"}
{"text":"For odd numbers less then equal to n","code":"for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) {"}
{"text":"s ( i ) for a prime is the number itself","code":"s [ i ] = i ;"}
{"text":"For all multiples of current prime number","code":"for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ;"}
{"text":"i is the smallest prime factor for number \" i * j \" .","code":"s [ i * j ] = i ; } } } } }"}
{"text":"Function to generate prime factors and return its k - th prime factor . s [ i ] stores least prime factor of i .","code":"static int kPrimeFactor ( int n , int k , int [ ] s ) {"}
{"text":"Keep dividing n by least prime factor while either n is not 1 or count of prime factors is not k .","code":"while ( n > 1 ) { if ( k == 1 ) return s [ n ] ;"}
{"text":"To keep track of count of prime factors","code":"k -- ;"}
{"text":"Divide n to find next prime factor","code":"n \/= s [ n ] ; } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"s [ i ] is going to store prime factor of i .","code":"int [ ] s = new int [ MAX + 1 ] ; sieveOfEratosthenes ( s ) ; int n = 12 , k = 3 ; System . out . println ( kPrimeFactor ( n , k , s ) ) ; n = 14 ; k = 3 ; System . out . println ( kPrimeFactor ( n , k , s ) ) ; } }"}
{"text":"Java program to find sum of divisors of all the divisors of a natural number .","code":"import java . util . HashMap ; class GFG {"}
{"text":"Returns sum of divisors of all the divisors of n","code":"public static int sumDivisorsOfDivisors ( int n ) {"}
{"text":"Calculating powers of prime factors and storing them in a map mp [ ] .","code":"HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n \/= j ; count ++ ; } if ( count != 0 ) mp . put ( j , count ) ; }"}
{"text":"If n is a prime number","code":"if ( n != 1 ) mp . put ( n , 1 ) ;"}
{"text":"For each prime factor , calculating ( p ^ ( a + 1 ) - 1 ) \/ ( p - 1 ) and adding it to answer .","code":"int ans = 1 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . getValue ( ) + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . getKey ( ) ; } ans *= sum ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumDivisorsOfDivisors ( n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to return nearest prime number","code":"static int prime ( int n ) {"}
{"text":"All prime numbers are odd except two","code":"if ( n % 2 != 0 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > Math . sqrt ( i ) ) return i ; }"}
{"text":"It will only be executed when n is 3","code":"return 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 17 ; System . out . print ( prime ( n ) ) ; } }"}
{"text":"Java program to find repeating sequence in a fraction","code":"import java . util . * ; class GFG {"}
{"text":"This function returns repeating sequence of a fraction . If repeating sequence doesn 't  exits, then returns empty String","code":"static String fractionToDecimal ( int numr , int denr ) {"}
{"text":"Initialize result","code":"String res = \" \" ;"}
{"text":"Create a map to store already seen remainders . Remainder is used as key and its position in result is stored as value . Note that we need position for cases like 1 \/ 6. In this case , the recurring sequence doesn 't  start from first remainder.","code":"HashMap < Integer , Integer > mp = new HashMap < > ( ) ; mp . clear ( ) ;"}
{"text":"Find first remainder","code":"int rem = numr % denr ;"}
{"text":"Keep finding remainder until either remainder becomes 0 or repeats","code":"while ( ( rem != 0 ) && ( ! mp . containsKey ( rem ) ) ) {"}
{"text":"Store this remainder","code":"mp . put ( rem , res . length ( ) ) ;"}
{"text":"Multiply remainder with 10","code":"rem = rem * 10 ;"}
{"text":"Append rem \/ denr to result","code":"int res_part = rem \/ denr ; res += String . valueOf ( res_part ) ;"}
{"text":"Update remainder","code":"rem = rem % denr ; } if ( rem == 0 ) return \" \" ; else if ( mp . containsKey ( rem ) ) return res . substring ( mp . get ( rem ) ) ; return \" \" ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int numr = 50 , denr = 22 ; String res = fractionToDecimal ( numr , denr ) ; if ( res == \" \" ) System . out . print ( \" No \u2581 recurring \u2581 sequence \" ) ; else System . out . print ( \" Recurring \u2581 sequence \u2581 is \u2581 \" + res ) ; } }"}
{"text":"Java program to count numbers from 1 to n with 0 as a digit","code":"import java . io . * ; class GFG {"}
{"text":"Returns 1 if x has 0 , else 0","code":"static int has0 ( int x ) {"}
{"text":"Traverse through all digits of x to check if it has 0.","code":"while ( x != 0 ) {"}
{"text":"If current digit is 0 , return true","code":"if ( x % 10 == 0 ) return 1 ; x \/= 10 ; } return 0 ; }"}
{"text":"Returns count of numbers from 1 to n with 0 as digit","code":"static int getCount ( int n ) {"}
{"text":"Initialize count of numbers having 0 as digit","code":"int count = 0 ;"}
{"text":"Traverse through all numbers and for every number check if it has 0.","code":"for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { int n = 107 ; System . out . println ( \" Count \u2581 of \u2581 numbers \u2581 from \u2581 1\" + \" \u2581 to \u2581 \" + n + \" \u2581 is \u2581 \" + getCount ( n ) ) ; } }"}
{"text":"A Simple Java program to check if square root of a number under modulo p exists or not","code":"class GFG {"}
{"text":"Returns true if square root of n under modulo p exists","code":"static boolean squareRootExists ( int n , int p ) { n = n % p ;"}
{"text":"One by one check all numbers from 2 to p - 1","code":"for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }"}
{"text":"Driver program to test","code":"public static void main ( String [ ] args ) { int p = 7 ; int n = 2 ; if ( squareRootExists ( n , p ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java program to find largest x such that p * x divides n !","code":"import java . io . * ; class GFG {"}
{"text":"Function that returns largest power of p that divides n !","code":"static int Largestpower ( int n , int p ) {"}
{"text":"Initialize result","code":"int ans = 0 ;"}
{"text":"Calculate x = n \/ p + n \/ ( p ^ 2 ) + n \/ ( p ^ 3 ) + ... .","code":"while ( n > 0 ) { n \/= p ; ans += n ; } return ans ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int n = 10 ; int p = 3 ; System . out . println ( \" \u2581 The \u2581 largest \u2581 power \u2581 of \u2581 \" + p + \" \u2581 that \u2581 divides \u2581 \" + n + \" ! \u2581 is \u2581 \" + Largestpower ( n , p ) ) ; } }"}
{"text":"Java program to find factorial of given number","code":"class Factorial { int factorial ( int n ) {"}
{"text":"single line to find factorial","code":"return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { Factorial obj = new Factorial ( ) ; int num = 5 ; System . out . println ( \" Factorial \u2581 of \u2581 \" + num + \" \u2581 is \u2581 \" + obj . factorial ( num ) ) ; } }"}
{"text":"Function to get the bit at the ith position","code":"static boolean getBit ( int num , int i ) {"}
{"text":"Return true if the bit is set . Otherwise return false","code":"return ( ( num & ( 1 << i ) ) != 0 ) ; }"}
{"text":"Function to clear the ith bit of the given number N","code":"static int clearBit ( int num , int i ) {"}
{"text":"Create the mask for the ith bit unset","code":"int mask = ~ ( 1 << i ) ;"}
{"text":"Return the update value","code":"return num & mask ; }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given arr1 [ ]","code":"int [ ] arr1 = { 1 , 2 , 3 } ;"}
{"text":"Given arr2 [ ]","code":"int [ ] arr2 = { 1 , 2 , 3 } ;"}
{"text":"Size of arr1 [ ]","code":"int N = arr1 . length ;"}
{"text":"Size of arr2 [ ]","code":"int M = arr2 . length ;"}
{"text":"Function Call","code":"Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; }"}
{"text":"Function to compute the AND sum for each element of an array","code":"static void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) {"}
{"text":"Declaring an array of size 32 for storing the count of each bit","code":"int [ ] frequency = new int [ 32 ] ;"}
{"text":"Traverse the array arr2 [ ] and store the count of a bit in frequency array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Current bit position","code":"int bit_position = 0 ; int num = arr1 [ i ] ;"}
{"text":"While num is greater than 0","code":"while ( num != 0 ) {"}
{"text":"Checks if ith bit is set or not","code":"if ( ( num & 1 ) != 0 ) {"}
{"text":"Increment the count of bit by one","code":"frequency [ bit_position ] += 1 ; }"}
{"text":"Increment the bit position by one","code":"bit_position += 1 ;"}
{"text":"Right shift the num by one","code":"num >>= 1 ; } }"}
{"text":"Traverse in the arr2 [ ]","code":"for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ;"}
{"text":"Store the ith bit value","code":"int value_at_that_bit = 1 ;"}
{"text":"Total required sum","code":"int bitwise_AND_sum = 0 ;"}
{"text":"Traverse in the range [ 0 , 31 ]","code":"for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) {"}
{"text":"Checks if current bit is set","code":"if ( ( num & 1 ) != 0 ) {"}
{"text":"Increment the bitwise sum by frequency [ bit_position ] * value_at_that_bit ;","code":"bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; }"}
{"text":"Right shift num by one","code":"num >>= 1 ;"}
{"text":"Left shift vale_at_that_bit by one","code":"value_at_that_bit <<= 1 ; }"}
{"text":"Print the sum obtained for ith number in arr1 [ ]","code":"System . out . print ( bitwise_AND_sum + \" \u2581 \" ) ; } } }"}
{"text":"Java program to unset the rightmost set bit","code":"import java . util . * ; class GFG {"}
{"text":"Unsets the rightmost set bit of n and returns the result","code":"static void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) {"}
{"text":"Checking whether bit position is set or not","code":"if ( ( n >> bit ) % 2 > 0 ) {"}
{"text":"If bit position is found set , we flip this bit by xoring given number and number with bit position set","code":"n = n ^ ( 1 << bit ) ; break ; } } System . out . print ( \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \" ) ; System . out . print ( \" \u2581 rightmost \u2581 set \u2581 bit \u2581 \" + n ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 12 ; FlipBits ( N ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]","code":"static int bitwiseAndOdd ( int n ) {"}
{"text":"Initialize result to 1","code":"int result = 1 ;"}
{"text":"Starting from 3 , bitwise AND all the odd integers less than or equal to n","code":"for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]","code":"static int bitwiseAndOdd ( int n ) { return 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }"}
{"text":"Java implementation to reverse bits of a number","code":"class GFG {"}
{"text":"function to reverse bits of a number","code":"public static int reverseBits ( int n ) { int rev = 0 ;"}
{"text":"traversing bits of ' n ' from the right","code":"while ( n > 0 ) {"}
{"text":"bitwise left shift ' rev ' by 1","code":"rev <<= 1 ;"}
{"text":"if current bit is '1'","code":"if ( ( int ) ( n & 1 ) == 1 ) rev ^= 1 ;"}
{"text":"bitwise right shift ' n ' by 1","code":"n >>= 1 ; }"}
{"text":"required number","code":"return rev ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( reverseBits ( n ) ) ; } }"}
{"text":"Java Program to count number of ways to split array into two groups such that each group has equal XOR value","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Return the count number of ways to split array into two groups such that each group has equal XOR value .","code":"static int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ;"}
{"text":"We can split only if XOR is 0. Since XOR of all is 0 , we can consider all subsets as one group .","code":"if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; System . out . println ( countgroup ( a , n ) ) ; } }"}
{"text":"Java program to extract k bits from a given position .","code":"class GFG {"}
{"text":"Function to extract k bits from p position and returns the extracted value as integer","code":"static int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int number = 171 , k = 5 , p = 2 ; System . out . println ( \" The \u2581 extracted \u2581 number \u2581 is \u2581 \" + bitExtracted ( number , k , p ) ) ; } }"}
{"text":"Java program to find maximum number by swapping extreme bits .","code":"class GFG { static int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ;"}
{"text":"Traverse bits from both extremes","code":"int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) {"}
{"text":"Obtaining i - th and j - th bits","code":"int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ;"}
{"text":"Swapping the bits if lesser significant is greater than higher significant bit and accordingly modifying the number","code":"if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }"}
{"text":"Driver code","code":"static public void main ( String [ ] args ) { int num = 4 ; System . out . println ( findMax ( num ) ) ; } }"}
{"text":"Java implementation to efficiently check whether n is a multiple of 4 or not","code":"class GFG {"}
{"text":"method to check whether ' n ' is a multiple of 4 or not","code":"static boolean isAMultipleOf4 ( int n ) {"}
{"text":"if true , then ' n ' is a multiple of 4","code":"if ( ( n & 3 ) == 0 ) return true ;"}
{"text":"else ' n ' is not a multiple of 4","code":"return false ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( isAMultipleOf4 ( n ) ? \" Yes \" : \" No \" ) ; } }"}
{"text":"Java Simple solution to calculate square without using * and pow ( )","code":"import java . io . * ; class GFG { public static int square ( int n ) {"}
{"text":"handle negative input","code":"if ( n < 0 ) n = - n ;"}
{"text":"Initialize result","code":"int res = n ;"}
{"text":"Add n to res n - 1 times","code":"for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { for ( int n = 1 ; n <= 5 ; n ++ ) System . out . println ( \" n \u2581 = \u2581 \" + n + \" , \u2581 n ^ 2 \u2581 = \u2581 \" + square ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; import java . util . * ; class GFG { static int PointInKSquares ( int n , int a [ ] , int k ) { Arrays . sort ( a ) ; return a [ n - k ] ; }"}
{"text":"Driver Program to test above function","code":"public static void main ( String [ ] args ) { int k = 2 ; int [ ] a = { 1 , 2 , 3 , 4 } ; int n = a . length ; int x = PointInKSquares ( n , a , k ) ; System . out . println ( \" ( \" + x + \" , \u2581 \" + x + \" ) \" ) ; } }"}
{"text":"Java program to calculate the number of n digit stepping numbers .","code":"class GFG {"}
{"text":"function that calculates the answer","code":"static long answer ( int n ) {"}
{"text":"dp [ j ] stores count of i digit stepping numbers ending with digit j .","code":"int [ ] dp = new int [ 10 ] ;"}
{"text":"To store result of length i - 1 before updating dp [ j ] for length i .","code":"int [ ] prev = new int [ 10 ] ;"}
{"text":"if n is 1 then answer will be 10.","code":"if ( n == 1 ) return 10 ;"}
{"text":"Initialize values for count of digits equal to 1.","code":"for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ;"}
{"text":"Compute values for count of digits more than 1.","code":"for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) {"}
{"text":"If ending digit is 0","code":"if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ;"}
{"text":"If ending digit is 9","code":"else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ;"}
{"text":"For other digits .","code":"else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } }"}
{"text":"stores the final answer","code":"long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( answer ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG1 { static int MAX = 100000 ;"}
{"text":"To store first N Catalan numbers","code":"static long catalan [ ] = new long [ MAX ] ;"}
{"text":"Function to find first n Catalan numbers","code":"static void catalanDP ( long n ) {"}
{"text":"Initialize first two values in table","code":"catalan [ 0 ] = catalan [ 1 ] = 1 ;"}
{"text":"Filong entries in catalan [ ] using recursive formula","code":"for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } }"}
{"text":"Function to return the minimum changes required","code":"static int CatalanSequence ( int arr [ ] , int n ) {"}
{"text":"Find first n Catalan Numbers","code":"catalanDP ( n ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ;"}
{"text":"a and b are first two Catalan Sequence numbers","code":"int a = 1 , b = 1 ; int c ;"}
{"text":"Insert first n catalan elements to set","code":"s . add ( a ) ; if ( n >= 2 ) { s . add ( b ) ; } for ( int i = 2 ; i < n ; i ++ ) { s . add ( ( int ) catalan [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If catalan element is present in the array then remove it from set","code":"if ( s . contains ( arr [ i ] ) ) { s . remove ( arr [ i ] ) ; } }"}
{"text":"Return the remaining number of elements in the set","code":"return s . size ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 5 , 41 } ; int n = arr . length ; System . out . print ( CatalanSequence ( arr , n ) ) ; } }"}
{"text":"Java implementation to find the sum of all the composite numbers from odd indices of the given array","code":"class GFG {"}
{"text":"Function to check for composite numbers","code":"static int composite ( int n ) { int flag = 0 ; int c = 0 ;"}
{"text":"Check if the factors are greater than 2","code":"for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } }"}
{"text":"Check if the number is composite or not","code":"if ( c >= 3 ) flag = 1 ; return flag ; }"}
{"text":"Function to print the sum of all composite numbers in the array","code":"static void odd_indices ( int arr [ ] , int n ) { int sum = 0 ;"}
{"text":"Iterate for odd indices in the array","code":"for ( int k = 0 ; k < n ; k += 2 ) { int check = composite ( arr [ k ] ) ;"}
{"text":"Check if the number is composite then add it to sum","code":"if ( check == 1 ) sum += arr [ k ] ; }"}
{"text":"return the sum","code":"System . out . print ( sum + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 13 , 5 , 8 , 16 , 25 } ; int n = arr . length ; odd_indices ( arr , n ) ; } }"}
{"text":"JAVA Code for Queries on count of points lie inside a circle","code":"import java . util . * ; class GFG {"}
{"text":"Computing the x ^ 2 + y ^ 2 for each given points and sorting them .","code":"public static void preprocess ( int p [ ] , int x [ ] , int y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( p ) ; }"}
{"text":"Return count of points lie inside or on circumference of circle using binary search on p [ 0. . n - 1 ]","code":"public static int query ( int p [ ] , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) \/ 2 ; double tp = Math . sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = Math . sqrt ( p [ start ] ) ; double tp2 = Math . sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int x [ ] = { 1 , 2 , 3 , - 1 , 4 } ; int y [ ] = { 1 , 2 , 3 , - 1 , 4 } ; int n = x . length ;"}
{"text":"Compute distances of all points and keep the distances sorted so that query can work in O ( logn ) using Binary Search .","code":"int p [ ] = new int [ n ] ; preprocess ( p , x , y , n ) ;"}
{"text":"Print number of points in a circle of radius 3.","code":"System . out . println ( query ( p , n , 3 ) ) ;"}
{"text":"Print number of points in a circle of radius 32.","code":"System . out . println ( query ( p , n , 32 ) ) ; } }"}
{"text":"Java program to Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices","code":"import java . util . * ; class GFG {"}
{"text":"function to find total number of ways","code":"static int find_Numb_ways ( int n ) {"}
{"text":"No of odd indices in n - digit number","code":"int odd_indices = n \/ 2 ;"}
{"text":"No of even indices in n - digit number","code":"int even_indices = ( n \/ 2 ) + ( n % 2 ) ;"}
{"text":"No of ways of arranging prime number digits in odd indices","code":"int arr_odd = ( int ) Math . pow ( 4 , odd_indices ) ;"}
{"text":"No of ways of arranging odd number digits in even indices","code":"int arr_even = ( int ) Math . pow ( 5 , even_indices ) ;"}
{"text":"returning the total number of ways","code":"return arr_odd * arr_even ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( find_Numb_ways ( n ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if the array is spirally sorted or not","code":"static boolean isSpiralSorted ( int [ ] arr , int n ) {"}
{"text":"Stores start index of the array","code":"int start = 0 ;"}
{"text":"Stores end index of an array","code":"int end = n - 1 ; while ( start < end ) {"}
{"text":"If arr [ start ] greater than arr [ end ]","code":"if ( arr [ start ] > arr [ end ] ) { return false ; }"}
{"text":"Update start","code":"start ++ ;"}
{"text":"If arr [ end ] greater than arr [ start ]","code":"if ( arr [ end ] > arr [ start ] ) { return false ; }"}
{"text":"Update end","code":"end -- ; } return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = arr . length ;"}
{"text":"Function Call","code":"if ( isSpiralSorted ( arr , N ) != false ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to print all strings that can be typed using keys of a single row in a QWERTY Keyboard","code":"static void findWordsSameRow ( List < String > arr ) {"}
{"text":"Stores row number of all possible character of the strings","code":"Map < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; mp . put ( ' q ' , 1 ) ; mp . put ( ' w ' , 1 ) ; mp . put ( ' e ' , 1 ) ; mp . put ( ' r ' , 1 ) ; mp . put ( ' t ' , 1 ) ; mp . put ( ' y ' , 1 ) ; mp . put ( ' u ' , 1 ) ; mp . put ( ' i ' , 1 ) ; mp . put ( ' o ' , 1 ) ; mp . put ( ' p ' , 1 ) ; mp . put ( ' a ' , 2 ) ; mp . put ( ' s ' , 2 ) ; mp . put ( ' d ' , 2 ) ; mp . put ( ' f ' , 2 ) ; mp . put ( ' g ' , 2 ) ; mp . put ( ' h ' , 2 ) ; mp . put ( ' j ' , 2 ) ; mp . put ( ' k ' , 2 ) ; mp . put ( ' l ' , 2 ) ; mp . put ( ' z ' , 3 ) ; mp . put ( ' x ' , 3 ) ; mp . put ( ' c ' , 3 ) ; mp . put ( ' v ' , 3 ) ; mp . put ( ' b ' , 3 ) ; mp . put ( ' n ' , 3 ) ; mp . put ( ' m ' , 3 ) ;"}
{"text":"Traverse the array","code":"for ( String word : arr ) {"}
{"text":"If current string is not an empty string","code":"if ( word . length ( ) != 0 ) {"}
{"text":"Sets true \/ false if a string can be typed using keys of a single row or not","code":"boolean flag = true ;"}
{"text":"Stores row number of the first character of current string","code":"int rowNum = mp . get ( Character . toLowerCase ( word . charAt ( 0 ) ) ) ;"}
{"text":"Stores length of word","code":"int M = word . length ( ) ;"}
{"text":"Traverse current string","code":"for ( int i = 1 ; i < M ; i ++ ) {"}
{"text":"If current character can 't be  typed using keys of rowNum only","code":"if ( mp . get ( Character . toLowerCase ( word . charAt ( i ) ) ) != rowNum ) {"}
{"text":"Update flag","code":"flag = false ; break ; } }"}
{"text":"If current string can be typed using keys from rowNum only","code":"if ( flag ) {"}
{"text":"Print the string","code":"System . out . print ( word + \" \u2581 \" ) ; } } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { List < String > words = Arrays . asList ( \" Yeti \" , \" Had \" , \" GFG \" , \" comment \" ) ; findWordsSameRow ( words ) ; } }"}
{"text":"Java program of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the count of the subsequence of given type","code":"static int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ;"}
{"text":"Stores the count of quadruples","code":"int answer = 0 ;"}
{"text":"Generate all possible combinations of quadruples","code":"for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) {"}
{"text":"Check if 1 st element is equal to 3 rd element","code":"if ( a [ j ] == a [ l ] &&"}
{"text":"Check if 2 nd element is equal to 4 th element","code":"a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; System . out . print ( countSubsequece ( a , 7 ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the character repeats with minimum distance","code":"static char minDistChar ( char [ ] s ) { int n = s . length ;"}
{"text":"Stores the first and last index","code":"int [ ] first = new int [ 26 ] ; int [ ] last = new int [ 26 ] ;"}
{"text":"Initialize with - 1","code":"for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; }"}
{"text":"Get the values of last and first occurence","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Update the first index","code":"if ( first [ s [ i ] - ' a ' ] == - 1 ) { first [ s [ i ] - ' a ' ] = i ; }"}
{"text":"Update the last index","code":"last [ s [ i ] - ' a ' ] = i ; }"}
{"text":"Initialize min","code":"int min = Integer . MAX_VALUE ; char ans = '1' ;"}
{"text":"Get the minimum","code":"for ( int i = 0 ; i < 26 ; i ++ ) {"}
{"text":"Values must not be same","code":"if ( last [ i ] == first [ i ] ) continue ;"}
{"text":"Update the minimum distance","code":"if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = ( char ) ( i + ' a ' ) ; } }"}
{"text":"return ans","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ;"}
{"text":"Function Call","code":"System . out . print ( minDistChar ( str . toCharArray ( ) ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int n = 3 ; static class Pair { int first , second ; Pair ( int a , int b ) { first = a ; second = b ; } }"}
{"text":"Function to return the minimum steps required to reach the end of the matrix","code":"static int minSteps ( int arr [ ] [ ] ) {"}
{"text":"Array to determine whether a cell has been visited before","code":"boolean v [ ] [ ] = new boolean [ n ] [ n ] ;"}
{"text":"Queue for bfs","code":"Queue < Pair > q = new LinkedList < Pair > ( ) ;"}
{"text":"Initializing queue","code":"q . add ( new Pair ( 0 , 0 ) ) ;"}
{"text":"To store the depth of search","code":"int depth = 0 ;"}
{"text":"BFS algorithm","code":"while ( q . size ( ) != 0 ) {"}
{"text":"Current queue size","code":"int x = q . size ( ) ; while ( x -- > 0 ) {"}
{"text":"Top - most element of queue","code":"Pair y = q . peek ( ) ;"}
{"text":"To store index of cell for simplicity","code":"int i = y . first , j = y . second ; q . remove ( ) ;"}
{"text":"Base case","code":"if ( v [ i ] [ j ] ) continue ;"}
{"text":"If we reach ( n - 1 , n - 1 )","code":"if ( i == n - 1 && j == n - 1 ) return depth ;"}
{"text":"Marking the cell visited","code":"v [ i ] [ j ] = true ;"}
{"text":"Pushing the adjacent cells in the queue that can be visited from the current cell","code":"if ( i + arr [ i ] [ j ] < n ) q . add ( new Pair ( i + arr [ i ] [ j ] , j ) ) ; if ( j + arr [ i ] [ j ] < n ) q . add ( new Pair ( i , j + arr [ i ] [ j ] ) ) ; } depth ++ ; } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; System . out . println ( minSteps ( arr ) ) ; } }"}
{"text":"A Java program to find largest gap between two elements in an array .","code":"import java . io . * ; class GFG {"}
{"text":"function to solve the given problem","code":"static int solve ( int [ ] a , int n ) { int max1 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }"}
{"text":"Driver Code","code":"static public void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , - 4 , - 10 , 22 } ; int size = arr . length ; System . out . println ( \" Largest \u2581 gap \u2581 is \u2581 : \u2581 \" + solve ( arr , size ) ) ; } }"}
{"text":"A Java program to find largest gap between two elements in an array .","code":"import java . io . * ; class GFG {"}
{"text":"function to solve the given problem","code":"static int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ;"}
{"text":"finding maximum and minimum of an array","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , 4 , - 10 } ; int size = arr . length ; System . out . println ( \" Largest \u2581 gap \u2581 is \u2581 : \u2581 \" + solve ( arr , size ) ) ; } }"}
{"text":"Java Program for removing characters from reversed string where vowels are present in original string","code":"class GFG {"}
{"text":"Function for replacing the string","code":"static void replaceOriginal ( String s , int n ) {"}
{"text":"initialize a string of length n","code":"char r [ ] = new char [ n ] ;"}
{"text":"Traverse through all characters of string","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"assign the value to string r from last index of string s","code":"r [ i ] = s . charAt ( n - 1 - i ) ;"}
{"text":"if s [ i ] is a consonant then print r [ i ]","code":"if ( s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( \" \" ) ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ; int n = s . length ( ) ; replaceOriginal ( s , n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find if given Strings are same or not","code":"static boolean sameStrings ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ;"}
{"text":"Base Condition","code":"if ( N != M ) { return false ; }"}
{"text":"Stores frequency of characters of the String str1 and str2","code":"int [ ] a = new int [ 256 ] ; int [ ] b = new int [ 256 ] ;"}
{"text":"Traverse Strings str1 & str2 and store frequencies in a [ ] and b [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) { a [ str1 . charAt ( i ) - ' a ' ] ++ ; b [ str2 . charAt ( i ) - ' a ' ] ++ ; }"}
{"text":"Check if both Strings have same characters or not","code":"int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; }"}
{"text":"If a character is present in one String and is not in another String , return false","code":"else { return false ; } }"}
{"text":"Sort the array a [ ] and b [ ]","code":"Arrays . sort ( a ) ; Arrays . sort ( b ) ;"}
{"text":"Check arrays a and b contain the same frequency or not","code":"for ( i = 0 ; i < 256 ; i ++ ) {"}
{"text":"If the frequencies are not the same after sorting","code":"if ( a [ i ] != b [ i ] ) return false ; }"}
{"text":"At this point , str1 can be converted to str2","code":"return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S1 = \" cabbba \" , S2 = \" abbccc \" ; if ( sameStrings ( S1 , S2 ) ) System . out . print ( \" YES \" + \"NEW_LINE\"); else System . out . print ( \" \u2581 NO \" + \"NEW_LINE\"); } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum number operations","code":"public static int solution ( int A , int B , int C ) { int arr [ ] = new int [ 3 ] ;"}
{"text":"Insert the three numbers in array","code":"arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ;"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"Case 2","code":"if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) \/ 2 ) ;"}
{"text":"Case 1","code":"else return ( arr [ 0 ] + arr [ 1 ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given A , B , C","code":"int A = 8 , B = 1 , C = 5 ;"}
{"text":"Function call","code":"System . out . println ( solution ( A , B , C ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the index of the key in arr [ l . . h ] if the key is present otherwise return - 1","code":"static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) \/ 2 ; if ( arr [ mid ] == key ) return mid ;"}
{"text":"The tricky case , just update left and right","code":"if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { l ++ ; h -- ; return search ( arr , l , h , key ) ; }"}
{"text":"If arr [ l ... mid ] is sorted","code":"else if ( arr [ l ] <= arr [ mid ] ) {"}
{"text":"As this subarray is sorted , we can quickly check if key lies in any of the halves","code":"if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;"}
{"text":"If key does not lie in the first half subarray then divide the other half into two subarrays such that we can quickly check if key lies in the other half","code":"else return search ( arr , mid + 1 , h , key ) ; }"}
{"text":"If arr [ l . . mid ] first subarray is not sorted then arr [ mid ... h ] must be sorted subarray","code":"else if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = arr . length ; int key = 3 ; System . out . println ( search ( arr , 0 , n - 1 , key ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . Collections ; import java . util . Vector ; class GFG {"}
{"text":"Function to return the sorted string","code":"public static String getSortedString ( StringBuilder s , int n ) {"}
{"text":"Vectors to store the lowercase and uppercase characters","code":"Vector < Character > v1 = new Vector < > ( ) ; Vector < Character > v2 = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) >= ' a ' && s . charAt ( i ) <= ' z ' ) v1 . add ( s . charAt ( i ) ) ; if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' z ' ) v2 . add ( s . charAt ( i ) ) ; }"}
{"text":"Sort both the vectors","code":"Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) {"}
{"text":"If current character is lowercase then pick the lowercase character from the sorted list","code":"if ( s . charAt ( k ) > = ' a ' && s . charAt ( k ) <= ' z ' ) { s . setCharAt ( k , v1 . elementAt ( i ) ) ; ++ i ; }"}
{"text":"Else pick the uppercase character","code":"else if ( s . charAt ( k ) > = ' A ' && s . charAt ( k ) <= ' Z ' ) { s . setCharAt ( k , v2 . elementAt ( j ) ) ; ++ j ; } }"}
{"text":"Return the sorted string","code":"return s . toString ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( \" gEeksfOrgEEkS \" ) ; int n = s . length ( ) ; System . out . println ( getSortedString ( s , n ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GfG {"}
{"text":"Function to check if the condition holds","code":"static boolean check ( char s [ ] ) {"}
{"text":"Get the length of the string","code":"int l = s . length ;"}
{"text":"sort the given string","code":"Arrays . sort ( s ) ;"}
{"text":"Iterate for every index and check for the condition","code":"for ( int i = 1 ; i < l ; i ++ ) {"}
{"text":"If are not consecutive","code":"if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"1 st example","code":"String str = \" dcef \" ; if ( check ( str . toCharArray ( ) ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;"}
{"text":"2 nd example","code":"String str1 = \" xyza \" ; if ( check ( str1 . toCharArray ( ) ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java code to find minimum number of elements such that their sum is greater than sum of remaining elements of the array .","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find minimum elements needed","code":"static int minElements ( int arr [ ] , int n ) {"}
{"text":"Calculating HALF of array sum","code":"int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum \/ 2 ;"}
{"text":"Sort the array in ascending order and start traversing array from the ascending sort in descending order .","code":"Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ;"}
{"text":"Current sum greater than sum","code":"if ( curr_sum > halfSum ) return res ; } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 7 , 1 } ; int n = arr . length ; System . out . println ( minElements ( arr , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if its possible to make all array elements equal or not","code":"static void arrayElementEqual ( int arr [ ] , int N ) {"}
{"text":"Stores the sum of the array","code":"int sum = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; }"}
{"text":"If sum is divisible by N","code":"if ( sum % N == 0 ) { System . out . print ( \" Yes \" ) ; }"}
{"text":"Otherwise , not possible to make all array elements equal","code":"else { System . out . print ( \" No \" + \"NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 1 , 5 , 6 , 4 } ;"}
{"text":"Size of the array","code":"int N = arr . length ; arrayElementEqual ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array","code":"static int findMaxValByRearrArr ( int arr [ ] , int N ) {"}
{"text":"Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements","code":"int res = 0 ;"}
{"text":"Update res","code":"res = ( N * ( N + 1 ) ) \/ 2 ; return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( findMaxValByRearrArr ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum sided polygon that can be inscribed","code":"static int MaximumSides ( int n ) {"}
{"text":"Base Case","code":"if ( n < 4 ) return - 1 ;"}
{"text":"Return n \/ 2 if n is even Otherwise , return - 1","code":"return n % 2 == 0 ? n \/ 2 : - 1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N","code":"int N = 8 ;"}
{"text":"Function Call","code":"System . out . print ( MaximumSides ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the mean of pair product array of arr [ ]","code":"static float pairProductMean ( int arr [ ] , int N ) {"}
{"text":"Initializing suffix sum array","code":"int suffixSumArray [ ] = new int [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ;"}
{"text":"Build suffix sum array","code":"for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; }"}
{"text":"Size of pairProductArray","code":"int length = ( N * ( N - 1 ) ) \/ 2 ;"}
{"text":"Stores sum of pairProductArray","code":"float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; }"}
{"text":"Store the mean","code":"float mean ;"}
{"text":"Find mean of pairProductArray","code":"if ( length != 0 ) mean = res \/ length ; else mean = 0 ;"}
{"text":"Return the resultant mean","code":"return mean ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ;"}
{"text":"Function call","code":"System . out . format ( \" % .2f \" , pairProductMean ( arr , N ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the value of Binomial Coefficient C ( n , k )","code":"static int ncr ( int n , int k ) { int res = 1 ;"}
{"text":"Since C ( n , k ) = C ( n , n - k )","code":"if ( k > n - k ) k = n - k ;"}
{"text":"Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ]","code":"for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Function to find the minimum count of paths from top left to bottom right by placing K 1 s in the matrix","code":"static int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else {"}
{"text":"Count of ways without 1 s","code":"answer = ncr ( N + M - 2 , N - 1 ) ;"}
{"text":"Count of paths from starting point to mid point","code":"int X = ( N - 1 ) \/ 2 + ( M - 1 ) \/ 2 ; int Y = ( N - 1 ) \/ 2 ; int midCount = ncr ( X , Y ) ;"}
{"text":"Count of paths from mid point to end point","code":"X = ( ( N - 1 ) - ( N - 1 ) \/ 2 ) + ( ( M - 1 ) - ( M - 1 ) \/ 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) \/ 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 3 ; int M = 3 ; int K = 1 ; System . out . print ( countPath ( N , M , K ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }"}
{"text":"Function to find maximum count of operations","code":"static int find_max ( Vector < pair > v , int n ) {"}
{"text":"Initialize count by 0","code":"int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ;"}
{"text":"Iterate over remaining pairs","code":"for ( int i = 1 ; i < n - 1 ; i ++ ) {"}
{"text":"Check if first operation is applicable","code":"if ( v . get ( i - 1 ) . first < ( v . get ( i ) . first - v . get ( i ) . second ) ) count ++ ;"}
{"text":"Check if 2 nd operation is applicable","code":"else if ( v . get ( i + 1 ) . first > ( v . get ( i ) . first + v . get ( i ) . second ) ) { count ++ ; v . get ( i ) . first = v . get ( i ) . first + v . get ( i ) . second ; }"}
{"text":"Otherwise","code":"else continue ; }"}
{"text":"Return the count of operations","code":"return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 ; Vector < pair > v = new Vector < > ( ) ; v . add ( new pair ( 10 , 20 ) ) ; v . add ( new pair ( 15 , 10 ) ) ; v . add ( new pair ( 20 , 16 ) ) ; System . out . print ( find_max ( v , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to find the number of substrings that can be formed using given characters","code":"public static void numberofsubstrings ( String str , int k , char charArray [ ] ) { int N = str . length ( ) ;"}
{"text":"Boolean array for storing the available characters","code":"int available [ ] = new int [ 26 ] ; Arrays . fill ( available , 0 ) ;"}
{"text":"Mark indices of all available characters as 1","code":"for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; }"}
{"text":"Initialize lastPos as - 1","code":"int lastPos = - 1 ;"}
{"text":"Initialize ans with the total no of possible substrings","code":"int ans = ( N * ( N + 1 ) ) \/ 2 ;"}
{"text":"Traverse the string from left to right","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If the current character is not present in B","code":"if ( available [ str . charAt ( i ) - ' a ' ] == 0 ) {"}
{"text":"Subtract the total possible substrings","code":"ans -= ( ( i - lastPos ) * ( N - i ) ) ;"}
{"text":"Update the value of lastpos to current index","code":"lastPos = i ; } }"}
{"text":"Print the final answer","code":"System . out . println ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given String","code":"String str = \" abcb \" ; int k = 2 ;"}
{"text":"Given character array","code":"char [ ] charArray = { ' a ' , ' b ' } ;"}
{"text":"Function Call","code":"numberofsubstrings ( str , k , charArray ) ; } }"}
{"text":"Java implementation of above approach","code":"class GFG {"}
{"text":"Function to return minimum cost to reach destination","code":"static int minCost ( int N , int P , int Q ) {"}
{"text":"Initialize cost to 0","code":"int cost = 0 ;"}
{"text":"going backwards until we reach initial position","code":"while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N \/ 2 ;"}
{"text":"if 2 * X jump is better than X + 1","code":"if ( temp * P > Q ) cost += Q ;"}
{"text":"if X + 1 jump is better","code":"else cost += P * temp ; N \/= 2 ; } }"}
{"text":"return cost","code":"return cost ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int N = 9 , P = 5 , Q = 1 ; System . out . println ( minCost ( N , P , Q ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find number of ways to reach from node 1 to 1 again , after moving exactly K edges","code":"static void numberOfWays ( int n , int k ) {"}
{"text":"Initialize a dp [ ] array , where dp [ i ] stores number of ways to reach at a i node","code":"int [ ] dp = new int [ 1000 ] ;"}
{"text":"Initialize the dp array with 0","code":"for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; }"}
{"text":"Base Case","code":"dp [ 0 ] = 1 ;"}
{"text":"Iterate for the number of edges moved","code":"for ( int i = 1 ; i <= k ; i ++ ) {"}
{"text":"Sum will store number of ways to reach all the nodes","code":"int numWays = 0 ;"}
{"text":"Iterate for every possible state for the current step","code":"for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; }"}
{"text":"Update the value of the dp array after travelling each edge","code":"for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } }"}
{"text":"Print dp [ 0 ] as the answer","code":"System . out . println ( dp [ 0 ] + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given Input","code":"int N = 5 , K = 3 ;"}
{"text":"Function Call","code":"numberOfWays ( N , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG { static int M = 1000000007 ; static int waysOfDecoding ( String s ) { long first = 1 , second = s . charAt ( 0 ) == ' * ' ? 9 : s . charAt ( 0 ) == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { long temp = second ;"}
{"text":"If s [ i ] = = ' * ' there can be 9 possible values of *","code":"if ( s . charAt ( i ) == ' * ' ) { second = 9 * second ;"}
{"text":"If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 )","code":"if ( s . charAt ( i - 1 ) == '1' ) second = ( second + 9 * first ) % M ;"}
{"text":"If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 )","code":"else if ( s . charAt ( i - 1 ) == '2' ) second = ( second + 6 * first ) % M ;"}
{"text":"If the previous digit is * then all 15 2 - digit characters can be formed","code":"else if ( s . charAt ( i - 1 ) == ' * ' ) second = ( second + 15 * first ) % M ; }"}
{"text":"If s [ i ] != ' * '","code":"else { second = s . charAt ( i ) != '0' ? second : 0 ;"}
{"text":"Adding first in second if s [ i - 1 ] = 1","code":"if ( s . charAt ( i - 1 ) == '1' ) second = ( second + first ) % M ;"}
{"text":"Adding first in second if s [ i - 1 ] = = 2 and s [ i ] <= '6'","code":"else if ( s . charAt ( i - 1 ) == '2' && s . charAt ( i ) <= '6' ) second = ( second + first ) % M ;"}
{"text":"if s [ i - 1 ] == ' * ' the union of above 2 cases has to be done","code":"else if ( s . charAt ( i - 1 ) == ' * ' ) second = ( second + ( s . charAt ( i ) <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" * \" ; System . out . println ( waysOfDecoding ( s ) ) ; } }"}
{"text":"Java program for above approach","code":"class GFG {"}
{"text":"Function to calculate minimum cost of buying least X chocolates","code":"static int findMinCost ( int [ ] [ ] arr , int X , int n , int i ) {"}
{"text":"Base Case","code":"if ( X <= 0 ) return 0 ; if ( i >= n ) return Integer . MAX_VALUE ;"}
{"text":"Include the i - th box","code":"int inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Integer . MAX_VALUE ) inc += arr [ i ] [ 1 ] ;"}
{"text":"Exclude the i - th box","code":"int exc = findMinCost ( arr , X , n , i + 1 ) ;"}
{"text":"Return the minimum of the above two cases","code":"return Math . min ( inc , exc ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array and value of X","code":"int [ ] [ ] arr = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ;"}
{"text":"Store the size of the array","code":"int n = arr . length ; int ans = findMinCost ( arr , X , n , 0 ) ;"}
{"text":"Print the answer","code":"if ( ans != Integer . MAX_VALUE ) System . out . println ( ans ) ; else System . out . println ( - 1 ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the probability for the given sum to be equal to sum in N throws of dice","code":"static double find ( int N , int sum ) {"}
{"text":"Base cases","code":"if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 \/ 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) \/ 6 ; return s ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ;"}
{"text":"Print the answer","code":"System . out . format ( \" % .6f \" , probability ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the minimum number to steps to reduce N to 0","code":"static int minDays ( int n ) {"}
{"text":"Base case","code":"if ( n < 1 ) return n ;"}
{"text":"Recursive Call to count the minimum steps needed","code":"int cnt = 1 + Math . min ( n % 2 + minDays ( n \/ 2 ) , n % 3 + minDays ( n \/ 3 ) ) ;"}
{"text":"Return the answer","code":"return cnt ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Number N","code":"int N = 6 ;"}
{"text":"Function Call","code":"System . out . print ( minDays ( N ) ) ; } }"}
