{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find minimum sum after deletion","code":"static int minSum ( int A [ ] , int N ) {"}
{"text":"Stores frequency of array elements","code":"HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int sum = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Calculate sum","code":"sum += A [ i ] ;"}
{"text":"Update frequency of the current element","code":"if ( mp . containsKey ( A [ i ] ) ) { mp . put ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; } else { mp . put ( A [ i ] , 1 ) ; } }"}
{"text":"Stores the minimum sum required","code":"int minSum = Integer . MAX_VALUE ;"}
{"text":"Traverse map","code":"for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {"}
{"text":"Find the minimum sum obtained","code":"minSum = Math . min ( minSum , sum - ( it . getKey ( ) * it . getValue ( ) ) ) ; }"}
{"text":"Return minimum sum","code":"return minSum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input array","code":"int arr [ ] = { 4 , 5 , 6 , 6 } ;"}
{"text":"Size of array","code":"int N = arr . length ; System . out . print ( minSum ( arr , N ) + \"NEW_LINE\"); } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate maximum difference between adjacent elements excluding every array element once","code":"static void maxAdjacent ( int [ ] arr , int N ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ;"}
{"text":"Traverse the array","code":"for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ;"}
{"text":"Stores the maximum diff","code":"int maxi = Integer . MIN_VALUE ;"}
{"text":"Check for maximum adjacent element","code":"for ( int j = 1 ; j < N ; j ++ ) {"}
{"text":"Exclude current element","code":"if ( i == j ) continue ;"}
{"text":"Update maximum difference","code":"maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ;"}
{"text":"Update previous value","code":"prev = arr [ j ] ; }"}
{"text":"Append the result into a vector","code":"res . add ( maxi ) ; }"}
{"text":"Print the result","code":"for ( int x : res ) { System . out . print ( x + \" \u2581 \" ) ; } System . out . println ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the size of the array if the array initially contains a single element","code":"static int findSize ( int N ) {"}
{"text":"Base case","code":"if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N \/ 2 ) + 1 ;"}
{"text":"P \/ 2 -> findSize ( N \/ 2 ) P % 2 -> 1 P \/ 2 -> findSize ( N \/ 2 )","code":"return Size ; }"}
{"text":"Function to return the count of 1 s in the range [ L , R ]","code":"static int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; }"}
{"text":"Base Case","code":"if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N \/ 2 ; int Siz_M = findSize ( M ) ;"}
{"text":"PART 1 -> N \/ 2 [ 1 , Siz_M ]","code":"if ( L <= Siz_M ) {"}
{"text":"Update the right end point of the range to min ( Siz_M , R )","code":"ret += CountOnes ( N \/ 2 , L , Math . min ( Siz_M , R ) ) ; }"}
{"text":"PART 2 -> N % 2 [ SizM + 1 , Siz_M + 1 ]","code":"if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; }"}
{"text":"PART 3 -> N \/ 2 [ SizM + 2 , 2 * Siz_M - 1 ] Same as PART 1 Property of Symmetricity Shift the coordinates according to PART 1 Subtract ( Siz_M + 1 ) from both L , R","code":"if ( Siz_M + 1 < R ) { ret += CountOnes ( N \/ 2 , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input","code":"int N = 7 , L = 2 , R = 5 ;"}
{"text":"Counts the number of 1 's in  the range [L, R]","code":"System . out . println ( CountOnes ( N , L , R ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to check if number is prime or not","code":"static boolean prime ( int n ) {"}
{"text":"As 1 is neither prime nor composite return false","code":"if ( n == 1 ) return false ;"}
{"text":"Check if it is divided by any number then it is not prime , return false","code":"for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; }"}
{"text":"Check if n is not divided by any number then it is prime and hence return true","code":"return true ; }"}
{"text":"Function to find the pair ( a , b ) such that sum is N & LCM is minimum","code":"static void minDivisior ( int n ) {"}
{"text":"Check if the number is prime","code":"if ( prime ( n ) ) { System . out . print ( 1 + \" \u2581 \" + ( n - 1 ) ) ; }"}
{"text":"Now , if it is not prime then find the least divisior","code":"else { for ( int i = 2 ; i * i <= n ; i ++ ) {"}
{"text":"Check if divides n then it is a factor","code":"if ( n % i == 0 ) {"}
{"text":"Required output is a = n \/ i & b = n \/ i * ( n - 1 )","code":"System . out . print ( n \/ i + \" \u2581 \" + ( n \/ i * ( i - 1 ) ) ) ; break ; } } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 ;"}
{"text":"Function call","code":"minDivisior ( N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"To store Landau 's function of the number","code":"static int Landau = Integer . MIN_VALUE ;"}
{"text":"Function to return gcd of 2 numbers","code":"static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text":"Function to return LCM of two numbers","code":"static int lcm ( int a , int b ) { return ( a * b ) \/ gcd ( a , b ) ; }"}
{"text":"Function to find max lcm value among all representations of n","code":"static void findLCM ( Vector < Integer > arr ) { int nth_lcm = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr . get ( i ) ) ;"}
{"text":"Calculate Landau 's value","code":"Landau = Math . max ( Landau , nth_lcm ) ; }"}
{"text":"Recursive function to find different ways in which n can be written as sum of atleast one positive integers","code":"static void findWays ( Vector < Integer > arr , int i , int n ) {"}
{"text":"Check if sum becomes n , consider this representation","code":"if ( n == 0 ) findLCM ( arr ) ;"}
{"text":"Start from previous element in the representation till n","code":"for ( int j = i ; j <= n ; j ++ ) {"}
{"text":"Include current element from representation","code":"arr . add ( j ) ;"}
{"text":"Call function again with reduced sum","code":"findWays ( arr , j , n - j ) ;"}
{"text":"Backtrack - remove current element from representation","code":"arr . remove ( arr . size ( ) - 1 ) ; } }"}
{"text":"Function to find the Landau 's function","code":"static void Landau_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ;"}
{"text":"Using recurrence find different ways in which n can be written as a sum of atleast one + ve integers","code":"findWays ( arr , 1 , n ) ;"}
{"text":"Print the result","code":"System . out . print ( Landau ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N","code":"int N = 4 ;"}
{"text":"Function call","code":"Landau_function ( N ) ; } }"}
{"text":"Java implementation to check the following expression for an integer N is valid or not","code":"class GFG {"}
{"text":"Function to check if a number holds the condition ( N - 1 ) ! % N = N - 1","code":"static boolean isPrime ( int n ) {"}
{"text":"Corner cases","code":"if ( n == 1 ) return true ; if ( n <= 3 ) return true ;"}
{"text":"Number divisible by 2 or 3 are not prime","code":"if ( n % 2 == 0 n % 3 == 0 ) return false ;"}
{"text":"Iterate from 5 and keep checking for prime","code":"for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }"}
{"text":"Function to check the expression for the value N","code":"static void checkExpression ( int n ) { if ( isPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 3 ; checkExpression ( N ) ; } }"}
{"text":"Java implementation to check if it is possible to split array into K subsets with odd sum","code":"class GFG {"}
{"text":"Function to check if array can be split in required K subsets","code":"static boolean checkArray ( int n , int k , int arr [ ] ) {"}
{"text":"Store count of odd numbers","code":"int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Check if element is odd","code":"if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; }"}
{"text":"Check if split is possible","code":"if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = arr . length ; int k = 4 ; if ( checkArray ( n , k , arr ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java implementation to compute the sum of division of all the possible pairs for the given array","code":"class GFG {"}
{"text":"Function to compute the sum","code":"static long func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ ] = new double [ 100005 ] ; int temp ;"}
{"text":"Counting frequency of each term and finding maximum among it","code":"for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; }"}
{"text":"Making cumulative frequency","code":"for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ;"}
{"text":"Taking the ceil value","code":"double cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . min ( maxx , ( int ) ( Math . ceil ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ;"}
{"text":"nos . in [ ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans","code":"ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } }"}
{"text":"Return the final result","code":"return ( long ) ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( func ( arr , n ) + \"NEW_LINE\"); } }"}
{"text":"Java program to find the count of elements to be inserted to make Array sum twice the XOR of Array","code":"class GFG {"}
{"text":"Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array","code":"static void insert_element ( int a [ ] , int n ) {"}
{"text":"Variable to store the Xor of all the elements","code":"int Xor = 0 ;"}
{"text":"Variable to store the sum of all elements","code":"int Sum = 0 ;"}
{"text":"Loop to find the Xor and the sum of the array","code":"for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; }"}
{"text":"If sum = 2 * Xor","code":"if ( Sum == 2 * Xor ) {"}
{"text":"No need to insert more elements","code":"System . out . println ( \"0\" ) ; return ; }"}
{"text":"We insert one more element which is Sum","code":"if ( Xor == 0 ) { System . out . println ( \"1\" ) ; System . out . println ( Sum ) ; return ; }"}
{"text":"We insert two more elements Sum + Xor and Xor .","code":"int num1 = Sum + Xor ; int num2 = Xor ;"}
{"text":"Print the number of elements inserted in the array","code":"System . out . print ( \"2\" ) ;"}
{"text":"Print the elements that are inserted in the array","code":"System . out . println ( num1 + \" \u2581 \" + num2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; insert_element ( a , n ) ; } }"}
{"text":"Java program to check if roots of a quadratic equation are reciprocal of each other or not","code":"class GFG {"}
{"text":"Function to check if the roots of a quadratic equation are reciprocal of each other or not","code":"static void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function check whether x is a perfect square or not","code":"static boolean isPerfectSquare ( double x ) {"}
{"text":"Find floating point value of square root of x .","code":"double sr = Math . sqrt ( x ) ;"}
{"text":"If square root is an integer","code":"return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }"}
{"text":"Function to check Sunny Number","code":"static void checkSunnyNumber ( int N ) {"}
{"text":"Check if ( N + 1 ) is a perfect square or not","code":"if ( isPerfectSquare ( N + 1 ) ) { System . out . println ( \" Yes \" ) ; }"}
{"text":"If ( N + 1 ) is not a perfect square","code":"else { System . out . println ( \" No \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Number","code":"int N = 8 ;"}
{"text":"Function call","code":"checkSunnyNumber ( N ) ; } }"}
{"text":"Java program to count the numbers which can convert N to 1 using the given operation","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to count the numbers which can convert N to 1 using the given operation","code":"static int countValues ( int n ) { int answer = 0 ;"}
{"text":"Iterate through all the integers","code":"for ( int i = 2 ; i <= n ; i ++ ) { int k = n ;"}
{"text":"Check if N can be converted to 1","code":"while ( k >= i ) { if ( k % i == 0 ) k \/= i ; else k -= i ; }"}
{"text":"Incrementing the count if it can be converted","code":"if ( k == 1 ) answer ++ ; } return answer ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }"}
{"text":"Java program to find K numbers with sum equal to N and the sum of their squares maximized","code":"class GFG {"}
{"text":"Function that prints the required K numbers","code":"static void printKNumbers ( int N , int K ) {"}
{"text":"Print 1 , K - 1 times","code":"for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + \" \u2581 \" ) ;"}
{"text":"Print ( N - K + 1 )","code":"System . out . print ( N - K + 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; } }"}
{"text":"Java implementation to find N 'th stepping natural Number","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the Nth stepping natural number","code":"static int NthSmallest ( int K ) {"}
{"text":"Declare the queue","code":"Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ;"}
{"text":"Enqueue 1 , 2 , ... , 9 in this order","code":"for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ;"}
{"text":"Perform K operation on queue","code":"for ( int i = 1 ; i <= K ; i ++ ) {"}
{"text":"Get the ith Stepping number","code":"x = Q . peek ( ) ;"}
{"text":"Perform Dequeue from the Queue","code":"Q . remove ( ) ;"}
{"text":"If x mod 10 is not equal to 0","code":"if ( x % 10 != 0 ) {"}
{"text":"then Enqueue 10 x + ( x mod 10 ) - 1","code":"Q . add ( x * 10 + x % 10 - 1 ) ; }"}
{"text":"Enqueue 10 x + ( x mod 10 )","code":"Q . add ( x * 10 + x % 10 ) ;"}
{"text":"If x mod 10 is not equal to 9","code":"if ( x % 10 != 9 ) {"}
{"text":"then Enqueue 10 x + ( x mod 10 ) + 1","code":"Q . add ( x * 10 + x % 10 + 1 ) ; } }"}
{"text":"Return the dequeued number of the K - th operation as the Nth stepping number","code":"return x ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"initialise K","code":"int N = 16 ; System . out . print ( NthSmallest ( N ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the Least number","code":"static int nearest ( int n ) {"}
{"text":"Get the perfect square before and after N","code":"int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ;"}
{"text":"Check which is nearest to N","code":"int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ;"}
{"text":"return the result","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( nearest ( n ) ) ; n = 16 ; System . out . println ( nearest ( n ) ) ; n = 18 ; System . out . println ( nearest ( n ) ) ; } }"}
{"text":"Java program to calculate the value of pi up to n decimal places","code":"class GFG {"}
{"text":"Function that prints the value of pi upto N decimal places","code":"static void printValueOfPi ( int N ) {"}
{"text":"Find value of pi upto using acos ( ) function","code":"double pi = 2 * Math . acos ( 0.0 ) ;"}
{"text":"Print value of pi upto N decimal places","code":"System . out . println ( pi ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 ;"}
{"text":"Function that prints the value of pi","code":"printValueOfPi ( N ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to convert decimal number n to its binary representation stored as an array arr [ ]","code":"static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n \/= 2 ; } }"}
{"text":"Function to convert the number represented as a binary array arr [ ] into its decimal equivalent","code":"static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }"}
{"text":"Function to return the updated integer after flipping the kth bit","code":"static int getNum ( int n , int k ) {"}
{"text":"Number of bits in n","code":"int l = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) + 1 ;"}
{"text":"Find the binary representation of n","code":"int a [ ] = new int [ l ] ; decBinary ( a , n ) ;"}
{"text":"The number of bits in n are less than k","code":"if ( k > l ) return n ;"}
{"text":"Flip the kth bit","code":"a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ;"}
{"text":"Return the decimal equivalent of the number","code":"return binaryDec ( a , l ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 56 ; int k = 2 ; System . out . println ( getNum ( n , k ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ;"}
{"text":"Declare result array globally","code":"static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ;"}
{"text":"Function to precompute the product of factorials upto MAX","code":"static void preCompute ( ) {"}
{"text":"Initialize base condition if n = 0 then factorial of 0 is equal to 1 and answer for n = 0 is 1","code":"fact [ 0 ] = 1 ; result [ 0 ] = 1 ;"}
{"text":"Iterate loop from 1 to MAX","code":"for ( int i = 1 ; i <= MAX ; i ++ ) {"}
{"text":"factorial ( i ) = factorial ( i - 1 ) * i","code":"fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ;"}
{"text":"Result for current n is equal to result [ i - 1 ] multiplied by the factorial of i","code":"result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } }"}
{"text":"Function to perform the queries","code":"static void performQueries ( int q [ ] , int n ) {"}
{"text":"Precomputing the result till MAX","code":"preCompute ( ) ;"}
{"text":"Perform queries","code":"for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }"}
{"text":"Java program to find nth term divisible by a , b or c","code":"class GFG {"}
{"text":"Function to return gcd of a and b","code":"static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }"}
{"text":"Function to return the count of integers from the range [ 1 , num ] which are divisible by either a , b or c","code":"static long divTermCount ( long a , long b , long c , long num ) {"}
{"text":"Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c","code":"return ( ( num \/ a ) + ( num \/ b ) + ( num \/ c ) - ( num \/ ( ( a * b ) \/ gcd ( a , b ) ) ) - ( num \/ ( ( c * b ) \/ gcd ( c , b ) ) ) - ( num \/ ( ( a * c ) \/ gcd ( a , c ) ) ) + ( num \/ ( ( a * b * c ) \/ gcd ( gcd ( a , b ) , c ) ) ) ) ; }"}
{"text":"Function for binary search to find the nth term divisible by a , b or c","code":"static long findNthTerm ( int a , int b , int c , long n ) {"}
{"text":"Set low to 1 and high to LONG_MAX","code":"long low = 1 , high = Long . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) \/ 2 ;"}
{"text":"If the current term is less than n then we need to increase low to mid + 1","code":"if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; }"}
{"text":"If current term is greater than equal to n then high = mid","code":"else { high = mid ; } } return low ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 5 , n = 100 ; System . out . println ( findNthTerm ( a , b , c , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that checks whether given angle can be created using any 3 sides","code":"static double calculate_angle ( int n , int i , int j , int k ) {"}
{"text":"Initialize x and y","code":"int x , y ;"}
{"text":"Calculate the number of vertices between i and j , j and k","code":"if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ;"}
{"text":"Calculate the angle subtended at the circumference","code":"double ang1 = ( 180 * x ) \/ n ; double ang2 = ( 180 * y ) \/ n ;"}
{"text":"Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees","code":"double ans = 180 - ang1 - ang2 ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }"}
{"text":"Java implementation of above approach .","code":"class GFG {"}
{"text":"Function that will find loss","code":"static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) \/ ( 100 * 100 - P * P ) ; System . out . println ( \" Loss \u2581 = \u2581 \" + loss ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int SP = 2400 , P = 30 ;"}
{"text":"Calling Function","code":"Loss ( SP , P ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int MAXN = 1000001 ;"}
{"text":"Stores smallest prime factor for every number","code":"static int [ ] spf = new int [ MAXN ] ;"}
{"text":"Hash to store prime factors count","code":"static int [ ] hash1 = new int [ MAXN ] ;"}
{"text":"Function to calculate SPF ( Smallest Prime Factor ) for every number till MAXN","code":"static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ )"}
{"text":"Marking smallest prime factor for every number to be itself","code":"spf [ i ] = i ;"}
{"text":"Separately marking spf for every even number as 2","code":"for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ;"}
{"text":"Checking if i is prime","code":"for ( int i = 3 ; i * i < MAXN ; i ++ ) {"}
{"text":"Marking SPF for all numbers divisible by i","code":"if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i )"}
{"text":"Marking spf [ j ] if it is not previously marked","code":"if ( spf [ j ] == j ) spf [ j ] = i ; } } }"}
{"text":"Function to store the prime factors after dividing by the smallest prime factor at every step","code":"static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) {"}
{"text":"Storing the count of prime factors in hash","code":"hash1 [ spf [ x ] ] ++ ; x = x \/ spf [ x ] ; } while ( x % temp == 0 ) x = x \/ temp ; } }"}
{"text":"Function that returns true if there are no common prime factors between x and other numbers of the array","code":"static boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ;"}
{"text":"Checking whether it common prime factor with other numbers","code":"if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x \/ temp ; } return true ; }"}
{"text":"Function that returns true if there is an element in the array which is coprime with all the other elements of the array","code":"static boolean hasValidNum ( int [ ] arr , int n ) {"}
{"text":"Using sieve for generating prime factors","code":"sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ;"}
{"text":"Checking the common prime factors with other numbers","code":"for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of the approach","code":"class GfG {"}
{"text":"Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph","code":"static int countWays ( int N ) {"}
{"text":"Total number of edges","code":"int E = ( N * ( N - 1 ) ) \/ 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Initialize the matrix with 0","code":"static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) {"}
{"text":"0 C0 = 1","code":"l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) {"}
{"text":"Set every nCr = 1 where r = 0","code":"l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) {"}
{"text":"Value for the current cell of Pascal 's triangle","code":"l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } }"}
{"text":"Function to return the value of nCr","code":"static int nCr ( int n , int r ) {"}
{"text":"Return nCr","code":"return l [ n ] [ r ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Build the Pascal 's triangle","code":"initialize ( ) ; int n = 8 ; int r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the minimum required absolute difference","code":"static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG { static boolean check ( int s ) {"}
{"text":"creating a frequency array","code":"int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) {"}
{"text":"Finding the last digit of the number","code":"r = s % 10 ;"}
{"text":"Dividing the number by 10 to eliminate last digit","code":"s = ( int ) ( s \/ 10 ) ;"}
{"text":"counting frequency of each digit","code":"freq [ r ] += 1 ; } int xor__ = 0 ;"}
{"text":"checking if the xor of all frequency is zero or not","code":"for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( \"YesNEW_LINE\"); else System . out . println ( \"NoNEW_LINE\"); } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function to print N lines","code":"static void printLines ( int n , int k ) {"}
{"text":"Iterate N times to print N lines","code":"for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + \" \u2581 \" + k * ( 6 * i + 2 ) + \" \u2581 \" + k * ( 6 * i + 3 ) + \" \u2581 \" + k * ( 6 * i + 5 ) ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 2 , k = 2 ; printLines ( n , k ) ; } }"}
{"text":"Java program to find sum of first n terms","code":"import java . util . * ; class GFG { static int calculateSum ( int n ) {"}
{"text":"Sn = n * ( 4 * n * n + 6 * n - 1 ) \/ 3","code":"return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"number of terms to be included in sum","code":"int n = 4 ;"}
{"text":"find the Sn","code":"System . out . println ( \" Sum \u2581 = \u2581 \" + calculateSum ( n ) ) ; } }"}
{"text":"Java program to count the number of special strings of a given length N","code":"import java . util . * ; class GFG { static final int mod = 1000000007 ;"}
{"text":"Function to return count of special Strings","code":"static int count_special ( int n ) {"}
{"text":"Stores the answer for a particular value of n","code":"int [ ] fib = new int [ n + 1 ] ;"}
{"text":"For n = 0 we have empty String","code":"fib [ 0 ] = 1 ;"}
{"text":"For n = 1 we have 2 special Strings","code":"fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) {"}
{"text":"Calculate count of special String of length i","code":"fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; }"}
{"text":"fib [ n ] stores the count of special Strings of length n","code":"return fib [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Initialise n","code":"int n = 3 ; System . out . print ( count_special ( n ) + \"NEW_LINE\"); } }"}
{"text":"Java implementation of the above approach","code":"import java . io . * ; class GFG { static int mod = 1000000000 ;"}
{"text":"Find the number of ways to reach the end","code":"static int ways ( int i , int arr [ ] , int n ) {"}
{"text":"Base case","code":"if ( i == n - 1 ) return 1 ; int sum = 0 ;"}
{"text":"Recursive structure","code":"for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( 0 , arr , n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ;"}
{"text":"find the number of ways to reach the end","code":"static int ways ( int arr [ ] , int n ) {"}
{"text":"dp to store value","code":"int dp [ ] = new int [ n + 1 ] ;"}
{"text":"base case","code":"dp [ n - 1 ] = 1 ;"}
{"text":"Bottom up dp structure","code":"for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ;"}
{"text":"F [ i ] is dependent of F [ i + 1 ] to F [ i + k ]","code":"for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } }"}
{"text":"Return value of dp [ 0 ]","code":"return dp [ 0 ] % mod ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( arr , n ) % mod ) ; } }"}
{"text":"Java program to get minimum cost to sort strings by reversal operation","code":"class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }"}
{"text":"Returns the count of odd and even subsequences","code":"static pair countSum ( int arr [ ] , int n ) { int result = 0 ;"}
{"text":"Variables to store the count of even subsequences and odd subsequences","code":"int count_odd , count_even ;"}
{"text":"Initialising count_even and count_odd to 0 since as there is no subsequence before the iteration with even or odd count .","code":"count_odd = 0 ; count_even = 0 ;"}
{"text":"Find sum of all subsequences with even count and odd count and storing them as we iterate .","code":"for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"if the number is even","code":"if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; }"}
{"text":"if the number is odd","code":"else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ;"}
{"text":"Calling the function","code":"pair ans = countSum ( arr , n ) ; System . out . print ( \" EvenSum \u2581 = \u2581 \" + ans . first ) ; System . out . print ( \" \u2581 OddSum \u2581 = \u2581 \" + ans . second ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int MAX = 10 ;"}
{"text":"Function to convert a number into vector","code":"static Vector < Integer > numToVec ( int N ) { Vector < Integer > digit = new Vector < Integer > ( ) ;"}
{"text":"Push all the digits of N from the end one by one to the vector","code":"while ( N != 0 ) { digit . add ( N % 10 ) ; N = N \/ 10 ; }"}
{"text":"If the original number was 0","code":"if ( digit . size ( ) == 0 ) digit . add ( 0 ) ;"}
{"text":"Reverse the vector elements","code":"Collections . reverse ( digit ) ;"}
{"text":"Return the required vector","code":"return digit ; }"}
{"text":"Function to return the count of B length integers which are less than C and they contain digits from set A [ ] only","code":"static int solve ( Vector < Integer > A , int B , int C ) { Vector < Integer > digit = new Vector < Integer > ( ) ; int d , d2 ;"}
{"text":"Convert number to digit array","code":"digit = numToVec ( C ) ; d = A . size ( ) ;"}
{"text":"Case 1 : No such number possible as the generated numbers will always be greater than C","code":"if ( B > digit . size ( ) d == 0 ) return 0 ;"}
{"text":"Case 2 : All integers of length B are valid as they all are less than C","code":"else if ( B < digit . size ( ) ) {"}
{"text":"contain 0","code":"if ( A . get ( 0 ) == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return ( int ) Math . pow ( d , B ) ; }"}
{"text":"Case 3","code":"else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ;"}
{"text":"Update the lower [ ] array such that lower [ i ] stores the count of elements in A [ ] which are less than i","code":"for ( int i = 0 ; i < d ; i ++ ) lower [ A . get ( i ) + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit . get ( i - 1 ) ] ; dp [ i ] = dp [ i - 1 ] * d ;"}
{"text":"For first index we can 't use 0","code":"if ( i == 1 && A . get ( 0 ) == 0 && B != 1 ) d2 = d2 - 1 ;"}
{"text":"Whether ( i - 1 ) digit of generated number can be equal to ( i - 1 ) digit of C","code":"if ( flag ) dp [ i ] += d2 ;"}
{"text":"Is digit [ i - 1 ] present in A ?","code":"flag = ( flag & ( lower [ digit . get ( i - 1 ) + 1 ] == lower [ digit . get ( i - 1 ) ] + 1 ) ) ; } return dp [ B ] ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Integer arr [ ] = { 0 , 1 , 2 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int N = 2 ; int k = 21 ; System . out . println ( solve ( A , N , k ) ) ; } }"}
{"text":"Java program to count the number of paths with weight W in a K - ary tree","code":"class GFG {"}
{"text":"Function to return the number of ways having weight as wt in K - ary tree","code":"public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) {"}
{"text":"Return 0 if weight becomes less than zero","code":"if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) {"}
{"text":"Return one only if the current path has included edge weight of atleast M","code":"if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) {"}
{"text":"If the current edge weight is greater than or equal to M , set used as true","code":"if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int W = 3 , K = 3 , M = 2 ; int [ ] [ ] dp = new int [ W + 1 ] [ 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( solve ( dp , W , K , M , 0 ) + \"NEW_LINE\"); } }"}
{"text":"Java implementation of above approach","code":"class GFG {"}
{"text":"Function to find the number of partitions of N","code":"static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ;"}
{"text":"Base case","code":"p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) \/ 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) \/ 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( partitions ( N ) ) ; } }"}
{"text":"Java program to find longest increasing path in a matrix .","code":"import java . util . * ; class GFG {"}
{"text":"Return the length of LIP in 2D matrix","code":"static int LIP ( int dp [ ] [ ] , int mat [ ] [ ] , int n , int m , int x , int y ) {"}
{"text":"If value not calculated yet .","code":"if ( dp [ x ] [ y ] < 0 ) { int result = 0 ;"}
{"text":"If reach bottom left cell , return 1.","code":"if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ;"}
{"text":"If reach the corner of the matrix .","code":"if ( x == n - 1 y == m - 1 ) result = 1 ;"}
{"text":"If value greater than below cell .","code":"if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ;"}
{"text":"If value greater than left cell .","code":"if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; }"}
{"text":"Wrapper function","code":"static int wrapper ( int mat [ ] [ ] , int n , int m ) { int dp [ ] [ ] = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; System . out . println ( wrapper ( mat , n , m ) ) ; } }"}
{"text":"Java program to count total number of paths from a point to origin","code":"import java . io . * ; class GFG {"}
{"text":"Recursive function to count number of paths","code":"static int countPaths ( int n , int m ) {"}
{"text":"If we reach bottom or top left , we are have only one way to reach ( 0 , 0 )","code":"if ( n == 0 m == 0 ) return 1 ;"}
{"text":"Else count sum of both ways","code":"return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" + countPaths ( n , m ) ) ; } }"}
{"text":"Java program to solve Gold Mine problem","code":"import java . util . Arrays ; class GFG { static final int MAX = 100 ;"}
{"text":"Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down","code":"static int getMaxGold ( int gold [ ] [ ] , int m , int n ) {"}
{"text":"Create a table for storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row","code":"int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) {"}
{"text":"Gold collected on going to the cell on the right ( -> )","code":"int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ;"}
{"text":"Gold collected on going to the cell to right up ( \/ )","code":"int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ;"}
{"text":"Gold collected on going to the cell to right down ( \\ )","code":"int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ;"}
{"text":"Max gold collected from taking either of the above 3 paths","code":"goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } }"}
{"text":"The max amount of gold collected will be the max value in first column of all rows","code":"int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }"}
{"text":"driver code","code":"public static void main ( String arg [ ] ) { int gold [ ] [ ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; System . out . print ( getMaxGold ( gold , m , n ) ) ; } }"}
{"text":"Java program to find minimum adjustment cost of an array","code":"import java . io . * ; import java . util . * ; class GFG { public static int M = 100 ;"}
{"text":"Function to find minimum adjustment cost of an array","code":"static int minAdjustmentCost ( int A [ ] , int n , int target ) {"}
{"text":"dp [ i ] [ j ] stores minimal adjustment cost on changing A [ i ] to j","code":"int [ ] [ ] dp = new int [ n ] [ M + 1 ] ;"}
{"text":"handle first element of array separately","code":"for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ;"}
{"text":"do for rest elements of the array","code":"for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"replace A [ i ] to j and calculate minimal adjustment cost dp [ i ] [ j ]","code":"for ( int j = 0 ; j <= M ; j ++ ) {"}
{"text":"initialize minimal adjustment cost to INT_MAX","code":"dp [ i ] [ j ] = Integer . MAX_VALUE ;"}
{"text":"consider all k such that k >= max ( j - target , 0 ) and k <= min ( M , j + target ) and take minimum","code":"int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } }"}
{"text":"return minimum value from last row of dp table","code":"int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = arr . length ; int target = 10 ; System . out . println ( \" Minimum \u2581 adjustment \u2581 cost \u2581 is \u2581 \" + minAdjustmentCost ( arr , n , target ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the number of triplets from the range [ L , R ] having sum of two numbers from the triplet equal to the third number","code":"static int totalCombination ( int L , int R ) {"}
{"text":"Stores the total number of triplets","code":"int count = 0 ;"}
{"text":"Find the difference of the range","code":"int K = R - L ;"}
{"text":"Case 1 : If triplets can 't  be formed, then return 0","code":"if ( K < L ) return 0 ;"}
{"text":"Otherwise","code":"int ans = K - L ;"}
{"text":"Update the total number of triplets","code":"count = ( ( ans + 1 ) * ( ans + 2 ) ) \/ 2 ;"}
{"text":"Return the count","code":"return count ; }"}
{"text":"Driven Code","code":"public static void main ( String [ ] args ) { int L = 2 , R = 6 ; System . out . print ( totalCombination ( L , R ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Satisfying the given conditions","code":"static void printArrays ( int n ) {"}
{"text":"Declare the two arrays A and B","code":"ArrayList < Integer > A = new ArrayList < Integer > ( ) ; ArrayList < Integer > B = new ArrayList < Integer > ( ) ;"}
{"text":"Iterate from range [ 1 , 2 * n ]","code":"for ( int i = 1 ; i <= 2 * n ; i ++ ) {"}
{"text":"Assign consecutive numbers to same indices of the two arrays","code":"if ( i % 2 == 0 ) A . add ( i ) ; else B . add ( i ) ; }"}
{"text":"Print the first array","code":"System . out . print ( \" { \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( A . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , \u2581 \" ) ; } System . out . print ( \" }NEW_LINE\");"}
{"text":"Print the second array , B","code":"System . out . print ( \" { \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( B . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , \u2581 \" ) ; } System . out . print ( \" \u2581 } \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 5 ;"}
{"text":"Function Call","code":"printArrays ( N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to flip bits of A and B which are set bits in A and B","code":"static void flipBitsOfAandB ( int A , int B ) {"}
{"text":"Iterater all possible bits of A and B","code":"for ( int i = 0 ; i < 32 ; i ++ ) {"}
{"text":"If ith bit is set in both A and B","code":"if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) {"}
{"text":"Clear i - th bit of A","code":"A = A ^ ( 1 << i ) ;"}
{"text":"Clear i - th bit of B","code":"B = B ^ ( 1 << i ) ; } }"}
{"text":"Print A and B","code":"System . out . print ( A + \" \u2581 \" + B ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; } }"}
{"text":"Java implementation to find count of distinct pair sum between two 1 to N value Arrays","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the distinct sums","code":"static int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the number of substrings consists of 0 , 1 , and 2","code":"public static int countSubstrings ( String str ) {"}
{"text":"Initialize frequency array of size 3","code":"int [ ] freq = new int [ 3 ] ;"}
{"text":"Stores the resultant count","code":"int count = 0 ; int i = 0 ;"}
{"text":"Traversing string str","code":"for ( int j = 0 ; j < str . length ( ) ; j ++ ) {"}
{"text":"Update frequency array","code":"freq [ str . charAt ( j ) - '0' ] ++ ;"}
{"text":"If all the characters are present counting number of substrings possible","code":"while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charAt ( i ++ ) - '0' ] -- ; }"}
{"text":"Update number of substrings","code":"count += i ; }"}
{"text":"Return the number of substrings","code":"return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \"00021\" ; System . out . println ( countSubstrings ( str ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum number of flips to make all three pairs of consecutive characters different","code":"static int minFlips ( String str ) {"}
{"text":"Stores resultant count of pairs","code":"int count = 0 ;"}
{"text":"Base Case","code":"if ( str . length ( ) <= 2 ) { return 0 ; }"}
{"text":"Iterate over the range [ 0 , N - 2 ]","code":"for ( int i = 0 ; i < str . length ( ) - 2 {"}
{"text":"If the consecutive 3 numbers are the same then increment the count and the counter","code":"if ( str . charAt ( i ) == str . charAt ( i + 1 ) && str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) { i = i + 3 ; count ++ ; } else { i ++ ; } }"}
{"text":"Return the answer","code":"return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \"0011101\" ; System . out . println ( minFlips ( S ) ) ; } }"}
{"text":"Java program for above approach","code":"import java . awt . * ; import java . util . * ; class GFG {"}
{"text":"Function to convert Decimal to Hex","code":"static String convertToHex ( int num ) { StringBuilder temp = new StringBuilder ( ) ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp . append ( c ) ; num = num \/ 16 ; } return temp . toString ( ) ; }"}
{"text":"Function to encrypt the string","code":"static String encryptString ( String S , int N ) { StringBuilder ans = new StringBuilder ( ) ;"}
{"text":"Iterate the characters of the string","code":"for ( int i = 0 ; i < N ; i ++ ) { char ch = S . charAt ( i ) ; int count = 0 ; String hex ;"}
{"text":"Iterate until S [ i ] is equal to ch","code":"while ( i < N && S . charAt ( i ) == ch ) {"}
{"text":"Update count and i","code":"count ++ ; i ++ ; }"}
{"text":"Decrement i by 1","code":"i -- ;"}
{"text":"Convert count to hexadecimal representation","code":"hex = convertToHex ( count ) ;"}
{"text":"Append the character","code":"ans . append ( ch ) ;"}
{"text":"Append the characters frequency in hexadecimal representation","code":"ans . append ( hex ) ; }"}
{"text":"Reverse the obtained answer","code":"ans . reverse ( ) ;"}
{"text":"Return required answer","code":"return ans . toString ( ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"String S = \" abc \" ; int N = S . length ( ) ;"}
{"text":"Function Call","code":"System . out . println ( encryptString ( S , N ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate and return the value of Binomial Coefficient C ( n , k )","code":"static int binomialCoeff ( int n , int k ) { int res = 1 ;"}
{"text":"Since C ( n , k ) = C ( n , n - k )","code":"if ( k > n - k ) k = n - k ;"}
{"text":"Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ]","code":"for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Function to return the count of binary Strings of length N such that frequency of 1 ' s \u2581 exceed \u2581 that \u2581 of \u2581 0' s","code":"static int countOfString ( int N ) {"}
{"text":"Count of N - length binary Strings","code":"int Stotal = ( int ) Math . pow ( 2 , N ) ;"}
{"text":"Count of N - length binary Strings having equal count of 0 ' s \u2581 and \u2581 1' s","code":"int Sequal = 0 ;"}
{"text":"For even length Strings","code":"if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N \/ 2 ) ; int S1 = ( Stotal - Sequal ) \/ 2 ; return S1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( countOfString ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to remove all occurrences of a character in the string","code":"static String removeCharRecursive ( String str , char X ) {"}
{"text":"Base Case","code":"if ( str . length ( ) == 0 ) { return \" \" ; }"}
{"text":"Check the first character of the given string","code":"if ( str . charAt ( 0 ) == X ) {"}
{"text":"Pass the rest of the string to recursion Function call","code":"return removeCharRecursive ( str . substring ( 1 ) , X ) ; }"}
{"text":"Add the first character of str and string from recursion","code":"return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given String","code":"String str = \" geeksforgeeks \" ;"}
{"text":"Given character","code":"char X = ' e ' ;"}
{"text":"Function call","code":"str = removeCharRecursive ( str , X ) ; System . out . println ( str ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function checks whether given time is correct","code":"static boolean isValid ( char a1 , char a2 , String str , int flag ) { char v1 , v2 ;"}
{"text":"To check minute value of time","code":"if ( flag == 0 ) { v1 = str . charAt ( 4 ) ; v2 = str . charAt ( 3 ) ; } else {"}
{"text":"To check hour value of time","code":"v1 = str . charAt ( 1 ) ; v2 = str . charAt ( 0 ) ; }"}
{"text":"Changes in value is not allowed at position where ' ? ' is not present","code":"if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; }"}
{"text":"Function checks whether the absolute difference between hour and minute value is within [ L , R ]","code":"static boolean inRange ( int hh , int mm , int L , int R ) { int a = Math . abs ( hh - mm ) ;"}
{"text":"Checks if the difference is outside the give range","code":"if ( a < L a > R ) return false ; return true ; }"}
{"text":"Displays time in proper 24 - hour format","code":"static void displayTime ( int hh , int mm ) { if ( hh > 10 ) System . out . print ( hh + \" : \" ) ; else if ( hh < 10 ) System . out . print ( \"0\" + hh + \" : \" ) ; if ( mm > 10 ) System . out . println ( mm ) ; else if ( mm < 10 ) System . out . println ( \"0\" + mm ) ; }"}
{"text":"Function find the desired value of time whose difference lies in the range [ L , R ]","code":"static void maximumTimeWithDifferenceInRange ( String str , int L , int R ) { int i = 0 , j = 0 ; int h1 , h2 , m1 , m2 ;"}
{"text":"Decrease hour value from 23 to 0","code":"for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i \/ 10 ;"}
{"text":"Check if the hour value is valid if not valid then no need to change minute value , since time will still remain in valid , to check hour value flag is set to 1.","code":"if ( ! isValid ( ( char ) h1 , ( char ) h2 , str , 1 ) ) { continue ; }"}
{"text":"Decrease minute value from 59 to 0","code":"for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j \/ 10 ;"}
{"text":"Check if the minute value is valid , if not valid then skip the current iteration , to check ' minute ' value flag is set to 0.","code":"if ( ! isValid ( ( char ) m1 , ( char ) m2 , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else System . out . println ( \" - 1\" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input time","code":"String timeValue = \" ? ? : ? ? \" ;"}
{"text":"Difference range","code":"int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check String str can be split a String into even length palindromic subStrings","code":"static boolean check ( String s , int n ) {"}
{"text":"Initialize a stack","code":"Stack < Character > st = new Stack < Character > ( ) ;"}
{"text":"Iterate the String","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If the i - th character is same as that at the top of the stack then pop the top element","code":"if ( ! st . isEmpty ( ) && st . peek ( ) == s . charAt ( i ) ) st . pop ( ) ;"}
{"text":"Else push the current charactor into the stack","code":"else st . add ( s . charAt ( i ) ) ; }"}
{"text":"If the stack is empty , then even palindromic subStrings are possible","code":"if ( st . isEmpty ( ) ) { return true ; }"}
{"text":"Else not - possible","code":"else { return false ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given String","code":"String str = \" aanncddc \" ; int n = str . length ( ) ;"}
{"text":"Function Call","code":"if ( check ( str , n ) ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static void findNumOfValidWords ( Vector < String > w , Vector < String > p ) {"}
{"text":"To store the frequency of String after bitmasking","code":"HashMap < Integer , Integer > m = new HashMap < > ( ) ;"}
{"text":"To store result for each string in arr2 [ ]","code":"Vector < Integer > res = new Vector < > ( ) ;"}
{"text":"Traverse the arr1 [ ] and bitmask each string in it","code":"for ( String s : w ) { int val = 0 ;"}
{"text":"Bitmasking for each String s","code":"for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; }"}
{"text":"Update the frequency of String with it 's bitmasking value","code":"if ( m . containsKey ( val ) ) m . put ( val , m . get ( val ) + 1 ) ; else m . put ( val , 1 ) ; }"}
{"text":"Traverse the arr2 [ ]","code":"for ( String s : p ) { int val = 0 ;"}
{"text":"Bitmasking for each String s","code":"for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s . charAt ( 0 ) - ' a ' ; int count = 0 ; while ( temp != 0 ) {"}
{"text":"Check if temp is present in an unordered_map or not","code":"if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . containsKey ( temp ) ) { count += m . get ( temp ) ; } }"}
{"text":"Check for next set bit","code":"temp = ( temp - 1 ) & val ; }"}
{"text":"Push the count for current String in resultant array","code":"res . add ( count ) ; }"}
{"text":"Print the count for each String","code":"for ( int it : res ) { System . out . println ( it ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { Vector < String > arr1 = new Vector < > ( ) ; arr1 . add ( \" aaaa \" ) ; arr1 . add ( \" asas \" ) ; arr1 . add ( \" able \" ) ; arr1 . add ( \" ability \" ) ; arr1 . add ( \" actt \" ) ; arr1 . add ( \" actor \" ) ; arr1 . add ( \" access \" ) ; Vector < String > arr2 = new Vector < > ( ) ; arr2 . add ( \" aboveyz \" ) ; arr2 . add ( \" abrodyz \" ) ; arr2 . add ( \" absolute \" ) ; arr2 . add ( \" absoryz \" ) ; arr2 . add ( \" actresz \" ) ; arr2 . add ( \" gaswxyz \" ) ;"}
{"text":"Function call","code":"findNumOfValidWords ( arr1 , arr2 ) ; } }"}
{"text":"Java implementation to maximize the value of the decimal equivalent given in the binary form","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the binary number","code":"static void flip ( String s ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) {"}
{"text":"Check if the current number is 0","code":"if ( sb . charAt ( i ) == '0' ) {"}
{"text":"Find the continuous 0 s","code":"while ( sb . charAt ( i ) == '0' ) {"}
{"text":"Replace initially occurring 0 with 1","code":"sb . setCharAt ( i , '1' ) ; i ++ ; }"}
{"text":"Break out of loop if 1 occurs","code":"break ; } } System . out . println ( sb . toString ( ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \"100010001\" ; flip ( s ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the original string after converting it back from camelCase","code":"static void getOrgString ( String s ) {"}
{"text":"Print the first character as it is","code":"System . out . print ( s . charAt ( 0 ) ) ;"}
{"text":"Traverse the rest of the characters one by one","code":"int i = 1 ; while ( i < s . length ( ) ) {"}
{"text":"If current character is uppercase print space followed by the current character in lowercase","code":"if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) System . out . print ( \" \u2581 \" + Character . toLowerCase ( s . charAt ( i ) ) ) ;"}
{"text":"Else print the current character","code":"else System . out . print ( s . charAt ( i ) ) ; i ++ ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" ILoveGeeksForGeeks \" ; getOrgString ( s ) ; } }"}
{"text":"Java program to find the occurrences of character x in the infinite repeated string upto length n","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to count the character ' a '","code":"static int countChar ( String str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) count ++ ;"}
{"text":"atleast k repetition are required","code":"int repetitions = n \/ str . length ( ) ; count = count * repetitions ;"}
{"text":"if n is not the multiple of the string size check for the remaining repeating character .","code":"for ( int i = 0 ; i < n % str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) count ++ ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String str = \" abcac \" ; System . out . println ( countChar ( str , ' a ' ) ) ; } }"}
{"text":"Java program to count frequencies of array items having small values .","code":"class GFG { static void countFreq ( int arr [ ] , int n , int limit ) {"}
{"text":"Create an array to store counts . The size of array is limit + 1 and all values are initially 0","code":"int [ ] count = new int [ limit + 1 ] ;"}
{"text":"Traverse through array elements and count frequencies ( assuming that elements are limited by limit )","code":"for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( i + \" \u2581 \" + count [ i ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = arr . length ; int limit = 10 ; countFreq ( arr , n , limit ) ; } }"}
{"text":"Program to check if the binary string contains m consecutive 1 ' s \u2581 or \u2581 0' s","code":"import java . io . * ; class GFG {"}
{"text":"Function that checks if the binary string contains m consecutive 1 ' s \u2581 or \u2581 0' s","code":"static boolean check ( String s , int m ) {"}
{"text":"length of binary string","code":"int l = s . length ( ) ;"}
{"text":"counts zeros","code":"int c1 = 0 ;"}
{"text":"counts 1 's","code":"int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ;"}
{"text":"count consecutive 0 's","code":"c1 ++ ; } else { c1 = 0 ;"}
{"text":"count consecutive 1 's","code":"c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }"}
{"text":"Drivers Code","code":"public static void main ( String [ ] args ) { String s = \"001001\" ; int m = 2 ;"}
{"text":"function call","code":"if ( check ( s , m ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text":"Java implementation to find product of digits of elements at k - th level","code":"class GFG {"}
{"text":"Function to find product of digits of elements at k - th level","code":"static int productAtKthLevel ( String tree , int k ) { int level = - 1 ;"}
{"text":"Initialize result","code":"int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"increasing level number","code":"if ( tree . charAt ( i ) == ' ( ' ) level ++ ;"}
{"text":"decreasing level number","code":"else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else {"}
{"text":"check if current level is the desired level or not","code":"if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } }"}
{"text":"required product","code":"return product ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { String tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; System . out . println ( productAtKthLevel ( tree , k ) ) ; } }"}
{"text":"Java code to form string after removing duplicates from rows and columns .","code":"class GFG {"}
{"text":"Function to check duplicates in row and column","code":"static void findDuplciates ( String [ ] a , int n , int m ) {"}
{"text":"Create an array isPresent and initialize all entries of it as false . The value of isPresent [ i , j ] is going to be true if s [ i , j ] is present in its row or column .","code":"boolean [ ] [ ] isPresent = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { isPresent [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"Checking every row for duplicates of a [ i , j ]","code":"for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ k ] . charAt ( j ) && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } }"}
{"text":"Checking every column for duplicate characters","code":"for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ i ] . charAt ( k ) && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ )"}
{"text":"If the character is unique in its row and column","code":"if ( isPresent [ i ] [ j ] == false ) System . out . print ( a [ i ] . charAt ( j ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 2 , m = 2 ;"}
{"text":"character array","code":"String [ ] a = new String [ ] { \" zx \" , \" xz \" } ;"}
{"text":"Calling function","code":"findDuplciates ( a , n , m ) ; } }"}
{"text":"Java program to check if a given ISBN isvalid or not","code":"class GFG { static boolean isValidISBN ( String isbn ) {"}
{"text":"length must be 10","code":"int n = isbn . length ( ) ; if ( n != 10 ) return false ;"}
{"text":"Computing weighted sum of first 9 digits","code":"int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; }"}
{"text":"Checking last digit .","code":"char last = isbn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ;"}
{"text":"If last digit is ' X ' , add 10 to sum , else add its value","code":"sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ;"}
{"text":"Return true if weighted sum of digits is divisible by 11.","code":"return ( sum % 11 == 0 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String isbn = \"007462542X \" ; if ( isValidISBN ( isbn ) ) System . out . print ( \" Valid \" ) ; else System . out . print ( \" Invalid \" ) ; } }"}
{"text":"Java program to reverse order of vowels","code":"class GFG {"}
{"text":"utility function to check for vowel","code":"static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; }"}
{"text":"Function to reverse order of vowels","code":"static String reverseVowel ( String str1 ) { int j = 0 ;"}
{"text":"Storing the vowels separately","code":"char [ ] str = str1 . toCharArray ( ) ; String vowel = \" \" ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { j ++ ; vowel += str [ i ] ; } }"}
{"text":"Placing the vowels in the reverse order in the string","code":"for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { str [ i ] = vowel . charAt ( -- j ) ; } } return String . valueOf ( str ) ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { String str = \" hello \u2581 world \" ; System . out . println ( reverseVowel ( str ) ) ; } }"}
{"text":"Java program to find the string which contain the first character of each word of another string .","code":"class GFG {"}
{"text":"Function to find string which has first character of each word .","code":"static String firstLetterWord ( String str ) { String result = \" \" ;"}
{"text":"Traverse the string .","code":"boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"If it is space , set v as true .","code":"if ( str . charAt ( i ) == ' \u2581 ' ) { v = true ; }"}
{"text":"Else check if v is true or not . If true , copy character in output string and set v as false .","code":"else if ( str . charAt ( i ) != ' \u2581 ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeks \u2581 for \u2581 geeks \" ; System . out . println ( firstLetterWord ( str ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . Arrays ; class GFG { static int ans = 0 ;"}
{"text":"Function for dfs . i , j == > Current cell indexes vis == > To mark visited cells ans == > Result z == > Current count 0 s visited z_count == > Total 0 s present","code":"static void dfs ( int i , int j , int [ ] [ ] grid , boolean [ ] [ ] vis , int z , int z_count ) { int n = grid . length , m = grid [ 0 ] . length ;"}
{"text":"Mark the block as visited","code":"vis [ i ] [ j ] = true ; if ( grid [ i ] [ j ] == 0 )"}
{"text":"update the count","code":"z ++ ;"}
{"text":"If end block reached","code":"if ( grid [ i ] [ j ] == 2 ) {"}
{"text":"If path covered all the non - obstacle blocks","code":"if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = false ; return ; }"}
{"text":"Up","code":"if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != - 1 ) dfs ( i - 1 , j , grid , vis , z , z_count ) ;"}
{"text":"Down","code":"if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != - 1 ) dfs ( i + 1 , j , grid , vis , z , z_count ) ;"}
{"text":"Left","code":"if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != - 1 ) dfs ( i , j - 1 , grid , vis , z , z_count ) ;"}
{"text":"Right","code":"if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != - 1 ) dfs ( i , j + 1 , grid , vis , z , z_count ) ;"}
{"text":"Unmark the block ( unvisited )","code":"vis [ i ] [ j ] = false ; }"}
{"text":"Function to return the count of the unique paths","code":"static int uniquePaths ( int [ ] [ ] grid ) {"}
{"text":"int z_count = 0 ; Total 0 s present","code":"int n = grid . length , m = grid [ 0 ] . length ; boolean [ ] [ ] vis = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( vis [ i ] , false ) ; } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) {"}
{"text":"Count non - obstacle blocks","code":"if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) {"}
{"text":"Starting position","code":"x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] [ ] grid = { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , - 1 } } ; System . out . println ( uniquePaths ( grid ) ) ; } }"}
{"text":"Java Program to find the number of unordered pairs ( x , y ) which satisfy the given equation for the array","code":"import java . util . Arrays ; class GFG {"}
{"text":"Return the number of unordered pairs satisfying the conditions","code":"static int numPairs ( int a [ ] , int n ) { int ans , i , index ;"}
{"text":"ans stores the number of unordered pairs","code":"ans = 0 ;"}
{"text":"Making each value of array to positive","code":"for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ;"}
{"text":"Sort the array","code":"Arrays . sort ( a ) ;"}
{"text":"For each index calculating the right boundary for the unordered pairs","code":"for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; }"}
{"text":"Return the final result","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 3 , 6 } ; int n = a . length ; System . out . println ( numPairs ( a , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the area of a square","code":"static int areaOfSquare ( int S ) {"}
{"text":"Use above formula","code":"int area = S * S ; return area ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Side of square","code":"int S = 5 ;"}
{"text":"Function call","code":"System . out . println ( areaOfSquare ( S ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG { static int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) \/ 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Number of circles","code":"int x = 3 ;"}
{"text":"Number of straight lines","code":"int y = 4 ;"}
{"text":"Function Call","code":"System . out . print ( maxPointOfIntersection ( x , y ) ) ; } }"}
{"text":"Java program to find nth Icosihenagonal number","code":"class GFG {"}
{"text":"Function to find Icosihenagonal number","code":"static int Icosihenagonal_num ( int n ) {"}
{"text":"Formula to calculate nth Icosihenagonal number","code":"return ( 19 * n * n - 17 * n ) \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Icosihenagonal_num ( n ) + \"NEW_LINE\"); n = 10 ; System . out . print ( Icosihenagonal_num ( n ) + \"NEW_LINE\"); } }"}
{"text":"Java implementation of the approach","code":"class GFG { static double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ;"}
{"text":"For all vertices","code":"for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ;"}
{"text":"Calculate value of A using shoelace formula","code":"double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ;"}
{"text":"Calculating coordinates of centroid of polygon","code":"ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) \/ ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) \/ ( 6 * signedArea ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Coordinate of the vertices","code":"double vp [ ] [ ] = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; double [ ] ans = find_Centroid ( vp ) ; System . out . println ( ans [ 0 ] + \" \u2581 \" + ans [ 1 ] ) ; } }"}
{"text":"java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int d = 10 ; double a ;"}
{"text":"according to formula derived above","code":"a = ( double ) ( 360 - ( 6 * d ) ) \/ 4 ;"}
{"text":"print all the angles","code":"System . out . print ( a + \" , \u2581 \" + ( a + d ) + \" , \u2581 \" + ( a + ( 2 * d ) ) + \" , \u2581 \" + ( a + ( 3 * d ) ) ) ; } }"}
{"text":"Java program to find the Distance between two parallel Planes in 3 D .","code":"import java . io . * ; import java . lang . Math ; class GFG {"}
{"text":"Function to find distance","code":"static void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 \/ a2 == b1 \/ b2 && b1 \/ b2 == c1 \/ c2 ) { x1 = y1 = 0 ; z1 = - d1 \/ c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) \/ ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( \" Perpendicular \u2581 distance \u2581 is \u2581 \" + d ) ; } else System . out . println ( \" Planes \u2581 are \u2581 not \u2581 parallel \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float a1 = 1 ; float b1 = 2 ; float c1 = - 1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = - 3 ; float d2 = - 4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate factorial","code":"static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }"}
{"text":"Function to count number of ways to make 2 necklace having exactly N \/ 2 beads if each bead is considered different","code":"static long numOfNecklace ( int N ) {"}
{"text":"Number of ways to choose N \/ 2 beads from N beads","code":"long ans = factorial ( N ) \/ ( factorial ( N \/ 2 ) * factorial ( N \/ 2 ) ) ;"}
{"text":"Number of ways to permute N \/ 2 beads","code":"ans = ans * factorial ( N \/ 2 - 1 ) ; ans = ans * factorial ( N \/ 2 - 1 ) ;"}
{"text":"Divide ans by 2 to remove repetitions","code":"ans \/= 2 ;"}
{"text":"Return ans","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"int N = 4 ;"}
{"text":"Function Call","code":"System . out . println ( numOfNecklace ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to check if S is divisible by D while changing S to ( S + S % D )","code":"static String isDivisibleByDivisor ( int S , int D ) {"}
{"text":"V ( 0 ) = S % D","code":"S %= D ;"}
{"text":"Stores the encountered values","code":"Set < Integer > hashMap = new HashSet < > ( ) ; hashMap . add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) {"}
{"text":"V ( i ) = ( V ( i - 1 ) + V ( i - 1 ) % D ) % D","code":"S += ( S % D ) ; S %= D ;"}
{"text":"Check if the value has already been encountered","code":"if ( hashMap . contains ( S ) ) {"}
{"text":"Edge Case","code":"if ( S == 0 ) { return \" Yes \" ; } return \" No \" ; }"}
{"text":"Otherwise , insert it into the hashmap","code":"else hashMap . add ( S ) ; } return \" Yes \" ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int S = 3 , D = 6 ; System . out . println ( isDivisibleByDivisor ( S , D ) ) ; } }"}
{"text":"Java program for above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 )","code":"static void minimumSteps ( int x , int y ) {"}
{"text":"Store the required result","code":"int cnt = 0 ;"}
{"text":"Iterate while both x and y are not equal to 0","code":"while ( x != 0 && y != 0 ) {"}
{"text":"If x is greater than y","code":"if ( x > y ) {"}
{"text":"Update count and value of x","code":"cnt += x \/ y ; x %= y ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"Update count and value of y","code":"cnt += y \/ x ; y %= x ; } } cnt -- ;"}
{"text":"If both x and y > 1","code":"if ( x > 1 y > 1 ) cnt = - 1 ;"}
{"text":"Print the result","code":"System . out . println ( cnt ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given X and Y","code":"int x = 3 , y = 1 ; minimumSteps ( x , y ) ; } }"}
{"text":"Java implementation of above approach .","code":"import java . util . Stack ; class GFG {"}
{"text":"Function to check if A [ ] is Stack Sortable or Not .","code":"static boolean check ( int A [ ] , int N ) {"}
{"text":"Stack S","code":"Stack < Integer > S = new Stack < Integer > ( ) ;"}
{"text":"Pointer to the end value of array B .","code":"int B_end = 0 ;"}
{"text":"Traversing each element of A [ ] from starting Checking if there is a valid operation that can be performed .","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If the stack is not empty","code":"if ( ! S . empty ( ) ) {"}
{"text":"Top of the Stack .","code":"int top = S . peek ( ) ;"}
{"text":"If the top of the stack is Equal to B_end + 1 , we will pop it And increment B_end by 1.","code":"while ( top == B_end + 1 ) {"}
{"text":"if current top is equal to B_end + 1 , we will increment B_end to B_end + 1","code":"B_end = B_end + 1 ;"}
{"text":"Pop the top element .","code":"S . pop ( ) ;"}
{"text":"If the stack is empty We cannot further perfom this operation . Therefore break","code":"if ( S . empty ( ) ) { break ; }"}
{"text":"Current Top","code":"top = S . peek ( ) ; }"}
{"text":"If stack is empty Push the Current element","code":"if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . peek ( ) ;"}
{"text":"If the Current element of the array A [ ] if smaller than the top of the stack We can push it in the Stack .","code":"if ( A [ i ] < top ) { S . push ( A [ i ] ) ;"}
{"text":"Else We cannot sort the array Using any valid operations .","code":"} else {"}
{"text":"Not Stack Sortable","code":"return false ; } } } else {"}
{"text":"If the stack is empty push the current element in the stack .","code":"S . push ( A [ i ] ) ; } }"}
{"text":"Stack Sortable","code":"return true ; }"}
{"text":"Driver 's Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = A . length ; if ( check ( A , N ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java Code to count minimum reversal for making an expression balanced .","code":"import java . util . Stack ; public class GFG {"}
{"text":"Method count minimum reversal for making an expression balanced . Returns - 1 if expression cannot be balanced","code":"static int countMinReversals ( String expr ) { int len = expr . length ( ) ;"}
{"text":"length of expression must be even to make it balanced by using reversals .","code":"if ( len % 2 != 0 ) return - 1 ;"}
{"text":"After this loop , stack contains unbalanced part of expression , i . e . , expression of the form \" } } . . } { { . . { \"","code":"Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == ' } ' && ! s . empty ( ) ) { if ( s . peek ( ) == ' { ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; }"}
{"text":"Length of the reduced expression red_len = ( m + n )","code":"int red_len = s . size ( ) ;"}
{"text":"count opening brackets at the end of stack","code":"int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == ' { ' ) { s . pop ( ) ; n ++ ; }"}
{"text":"return ceil ( m \/ 2 ) + ceil ( n \/ 2 ) which is actually equal to ( m + n ) \/ 2 + n % 2 when m + n is even .","code":"return ( red_len \/ 2 + n % 2 ) ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }"}
{"text":"Java Code to count minimum reversal for making an expression balanced .","code":"import java . util . * ; public class GFG {"}
{"text":"Method count minimum reversal for making an expression balanced . Returns - 1 if expression cannot be balanced","code":"static int countMinReversals ( String expr ) { int len = expr . length ( ) ; int ans ;"}
{"text":"Expressions of odd lengths cannot be balanced","code":"if ( len % 2 != 0 ) { return - 1 ; } int left_brace = 0 , right_brace = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = expr . charAt ( i ) ;"}
{"text":"If we find a left bracket then we simply increment the left bracket","code":"if ( ch == ' { ' ) { left_brace ++ ; }"}
{"text":"Else if left bracket is 0 then we find unbalanced right bracket and increment right bracket or if the expression is balanced then we decrement left","code":"else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ( int ) ( Math . ceil ( ( 0.0 + left_brace ) \/ 2 ) + Math . ceil ( ( 0.0 + right_brace ) \/ 2 ) ) ; return ans ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }"}
{"text":"Java program to print minimum number that can be formed from a given sequence of Is and Ds","code":"class GFG {"}
{"text":"Prints the minimum number that can be formed from input sequence of I ' s \u2581 and \u2581 D ' s","code":"static void PrintMinNumberForPattern ( String arr ) {"}
{"text":"Initialize current_max ( to make sure that we don 't use repeated character","code":"int curr_max = 0 ;"}
{"text":"Initialize last_entry ( Keeps track for last printed digit )","code":"int last_entry = 0 ; int j ;"}
{"text":"Iterate over input array","code":"for ( int i = 0 ; i < arr . length ( ) ; i ++ ) {"}
{"text":"Initialize ' noOfNextD ' to get count of next D 's available","code":"int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case ' I ' :"}
{"text":"If letter is ' I ' Calculate number of next consecutive D 's  available","code":"j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ;"}
{"text":"If ' I ' is first letter , print incremented sequence from 1","code":"System . out . print ( \" \u2581 \" + ++ last_entry ) ; System . out . print ( \" \u2581 \" + curr_max ) ;"}
{"text":"Set max digit reached","code":"last_entry = curr_max ; } else {"}
{"text":"If not first letter Get next digit to print","code":"curr_max = curr_max + noOfNextD + 1 ;"}
{"text":"Print digit for I","code":"last_entry = curr_max ; System . out . print ( \" \u2581 \" + last_entry ) ; }"}
{"text":"For all next consecutive ' D ' print decremented sequence","code":"for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( \" \u2581 \" + -- last_entry ) ; i ++ ; } break ;"}
{"text":"If letter is ' D '","code":"case ' D ' : if ( i == 0 ) {"}
{"text":"If ' D ' is first letter in sequence Find number of Next D 's available","code":"j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; }"}
{"text":"Calculate first digit to print based on number of consecutive D 's","code":"curr_max = noOfNextD + 2 ;"}
{"text":"Print twice for the first time","code":"System . out . print ( \" \u2581 \" + curr_max + \" \u2581 \" + ( curr_max - 1 ) ) ;"}
{"text":"Store last entry","code":"last_entry = curr_max - 1 ; } else {"}
{"text":"If current ' D ' is not first letter Decrement last_entry","code":"System . out . print ( \" \u2581 \" + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } System . out . println ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }"}
{"text":"Java program to print minimum number that can be formed from a given sequence of Is and Ds","code":"import java . io . * ; import java . util . * ; public class GFG { static void printLeast ( String arr ) {"}
{"text":"min_avail represents the minimum number which is still available for inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector","code":"int min_avail = 1 , pos_of_I = 0 ;"}
{"text":"vector to store the output","code":"ArrayList < Integer > al = new ArrayList < > ( ) ;"}
{"text":"cover the base cases","code":"if ( arr . charAt ( 0 ) == ' I ' ) { al . add ( 1 ) ; al . add ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { al . add ( 2 ) ; al . add ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; }"}
{"text":"Traverse rest of the input","code":"for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr . charAt ( i ) == ' I ' ) { al . add ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { al . add ( al . get ( i ) ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) al . set ( j , al . get ( j ) + 1 ) ; min_avail ++ ; } }"}
{"text":"print the number","code":"for ( int i = 0 ; i < al . size ( ) ; i ++ ) System . out . print ( al . get ( i ) + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { printLeast ( \" IDID \" ) ; printLeast ( \" I \" ) ; printLeast ( \" DD \" ) ; printLeast ( \" II \" ) ; printLeast ( \" DIDI \" ) ; printLeast ( \" IIDDD \" ) ; printLeast ( \" DDIDDIID \" ) ; } }"}
{"text":"Java program to print minimum number that can be formed from a given sequence of Is and Ds","code":"import java . util . Stack ; class GFG {"}
{"text":"Function to decode the given sequence to construct minimum number without repeated digits","code":"static void PrintMinNumberForPattern ( String seq ) {"}
{"text":"result store output string","code":"String result = \" \" ;"}
{"text":"create an empty stack of integers","code":"Stack < Integer > stk = new Stack < Integer > ( ) ;"}
{"text":"run n + 1 times where n is length of input sequence","code":"for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) {"}
{"text":"push number i + 1 into the stack","code":"stk . push ( i + 1 ) ;"}
{"text":"if all characters of the input sequence are processed or current character is ' I ' ( increasing )","code":"if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) {"}
{"text":"run till stack is empty","code":"while ( ! stk . empty ( ) ) {"}
{"text":"remove top element from the stack and add it to solution","code":"result += String . valueOf ( stk . peek ( ) ) ; result += \" \u2581 \" ; stk . pop ( ) ; } } } System . out . println ( result ) ; }"}
{"text":"main function","code":"public static void main ( String [ ] args ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }"}
{"text":"Java program of above approach","code":"import java . io . IOException ; public class Test {"}
{"text":"Returns minimum number made from given sequence without repeating digits","code":"static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return \" - 1\" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ;"}
{"text":"The loop runs for each input character as well as one additional time for assigning rank to each remaining characters","code":"for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) throws IOException { String inputs [ ] = { \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" } ; for ( String input : inputs ) { System . out . println ( getMinNumberForPattern ( input ) ) ; } } }"}
{"text":"Java implementation of above approach","code":"import java . io . * ; class SmallPrime {"}
{"text":"function to check prime","code":"static boolean isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n \/ 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) { return true ; } else { return false ; } }"}
{"text":"Function to generate smallest possible number with given digits","code":"static void findMinNum ( int arr [ ] , int n ) {"}
{"text":"Declare a hash array of size 10 and initialize all the elements to zero","code":"int first = 0 , last = 0 , num , rev , i ; int hash [ ] = new int [ 10 ] ;"}
{"text":"store the number of occurrences of the digits in the given array into the hash table","code":"for ( i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; }"}
{"text":"Traverse the hash in ascending order to print the required number","code":"System . out . print ( \" Minimum \u2581 number : \u2581 \" ) ; for ( i = 0 ; i <= 9 ; i ++ ) {"}
{"text":"Print the number of times a digits occurs","code":"for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } System . out . println ( ) ; System . out . println ( ) ;"}
{"text":"extracting the first digit","code":"for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } }"}
{"text":"extracting the last digit","code":"for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ;"}
{"text":"printing the prime combinations","code":"System . out . print ( \" Prime \u2581 combinations : \u2581 \" ) ; if ( isPrime ( num ) && isPrime ( rev ) ) { System . out . println ( num + \" \u2581 \" + rev ) ; } else if ( isPrime ( num ) ) { System . out . println ( num ) ; } else if ( isPrime ( rev ) ) { System . out . println ( rev ) ; } else { System . out . println ( \" No \u2581 combinations \u2581 exist \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { SmallPrime smallprime = new SmallPrime ( ) ; int arr [ ] = { 1 , 2 , 4 , 7 , 8 } ; smallprime . findMinNum ( arr , 5 ) ; } }"}
{"text":"Java program to find possible non transitive triplets btw L and R","code":"class GFG {"}
{"text":"Function to return gcd of a and b","code":"static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text":"function to check for gcd","code":"static boolean coprime ( int a , int b ) {"}
{"text":"a and b are coprime if their gcd is 1.","code":"return ( gcd ( a , b ) == 1 ) ; }"}
{"text":"Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt","code":"static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ;"}
{"text":"Generate and check for all possible triplets between L and R","code":"for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) {"}
{"text":"if we find any such triplets set flag to true","code":"if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } }"}
{"text":"flag = True indicates that a pair exists between L and R","code":"if ( flag == true ) { System . out . println ( \" ( \" + possibleA + \" , \u2581 \" + possibleB + \" , \u2581 \" + possibleC + \" ) \" + \" \u2581 is \u2581 one \u2581 such \u2581 possible \u2581 triplet \u2581 \" + \" between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } else { System . out . println ( \" No \u2581 Such \u2581 Triplet \u2581 exists \" + \" between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int L , R ;"}
{"text":"finding possible Triplet between 2 and 10","code":"L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ;"}
{"text":"finding possible Triplet between 23 and 46","code":"L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }"}
{"text":"Java program to determine if A and B can be reached starting from 1 , 1 following the given steps .","code":"class GFG {"}
{"text":"function to check is it is possible to reach A and B starting from 1 and 1","code":"static boolean possibleToReach ( int a , int b ) {"}
{"text":"find the cuberoot of the number","code":"int c = ( int ) Math . cbrt ( a * b ) ;"}
{"text":"divide the number by cuberoot","code":"int re1 = a \/ c ; int re2 = b \/ c ;"}
{"text":"if it is a perfect cuberoot and divides a and b","code":"if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) System . out . println ( \" yes \" ) ; else System . out . println ( \" no \" ) ; } }"}
{"text":"Java program to check whether a number is undulating or not","code":"import java . util . * ; class GFG { public static boolean isUndulating ( String n ) {"}
{"text":"Considering the definition with restriction that there should be at least 3 digits","code":"if ( n . length ( ) <= 2 ) return false ;"}
{"text":"Check if all alternate digits are same or not .","code":"for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) return false ; return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String n = \"1212121\" ; if ( isUndulating ( n ) == true ) System . out . println ( \" yes \" ) ; else System . out . println ( \" no \" ) ; } }"}
{"text":"Java program to calculate the following series","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the following series","code":"static int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 ; int res = Series ( n ) ; System . out . println ( res ) ; } }"}
{"text":"Efficient Java program to count numbers with last digit as k in given range .","code":"import java . util . * ; import java . lang . * ; public class GfG {"}
{"text":"Returns count of numbers with k as last digit .","code":"public static int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * ( int ) Math . ceil ( low \/ 10.0 ) ; int mhigh = 10 * ( int ) Math . floor ( high \/ 10.0 ) ; int count = ( mhigh - mlow ) \/ 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; }"}
{"text":"driver function","code":"public static void main ( String argc [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }"}
{"text":"Java program to find sum of numbers divisible by 6 in a given range .","code":"import java . io . * ; class GFG {"}
{"text":"function to calculate the sum of all numbers divisible by 6 in range L - R . .","code":"static int sum ( int L , int R ) {"}
{"text":"no of multiples of 6 upto r","code":"int p = R \/ 6 ;"}
{"text":"no of multiples of 6 upto l - 1","code":"int q = ( L - 1 ) \/ 6 ;"}
{"text":"summation of all multiples of 6 upto r","code":"int sumR = 3 * ( p * ( p + 1 ) ) ;"}
{"text":"summation of all multiples of 6 upto l - 1","code":"int sumL = ( q * ( q + 1 ) ) * 3 ;"}
{"text":"returns the answer","code":"return sumR - sumL ; }"}
{"text":"driver program","code":"public static void main ( String [ ] args ) { int L = 1 , R = 20 ; System . out . println ( sum ( L , R ) ) ; } }"}
{"text":"Java program to find the largest smaller number by swapping one digit .","code":"class GFG {"}
{"text":"Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s .","code":"static String prevNum ( String str ) { int len = str . length ( ) ; int index = - 1 ;"}
{"text":"Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4.","code":"for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) > str . charAt ( i + 1 ) ) { index = i ; break ; } }"}
{"text":"We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr [ index ] which is smaller than arr [ index ]","code":"int smallGreatDgt = - 1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str . charAt ( i ) < str . charAt ( index ) ) { if ( smallGreatDgt == - 1 ) { smallGreatDgt = i ; } else if ( str . charAt ( i ) >= str . charAt ( smallGreatDgt ) ) { smallGreatDgt = i ; } } }"}
{"text":"If index is - 1 i . e . digits are in increasing order .","code":"if ( index == - 1 ) { return \" - 1\" ; }"}
{"text":"Swap both values","code":"if ( smallGreatDgt != - 1 ) { str = swap ( str , index , smallGreatDgt ) ; return str ; } return \" - 1\" ; } static String swap ( String str , int i , int j ) { char ch [ ] = str . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \"34125\" ; System . out . println ( prevNum ( str ) ) ; } }"}
{"text":"Java program to find sign value of a polynomial","code":"class GFG {"}
{"text":"returns value of poly [ 0 ] x ( n - 1 ) + poly [ 1 ] x ( n - 2 ) + . . + poly [ n - 1 ]","code":"static int horner ( int poly [ ] , int n , int x ) {"}
{"text":"Initialize result","code":"int result = poly [ 0 ] ;"}
{"text":"Evaluate value of polynomial using Horner 's method","code":"for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }"}
{"text":"Returns sign value of polynomial","code":"static int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Let us evaluate value of 2 x3 - 6 x2 + 2 x - 1 for x = 3","code":"int poly [ ] = { 2 , - 6 , 2 , - 1 } ; int x = 3 ; int n = poly . length ; System . out . print ( \" Sign \u2581 of \u2581 polynomial \u2581 is \u2581 \" + findSign ( poly , n , x ) ) ; } }"}
{"text":"Java program to find minimum number to insert in array so their sum is prime","code":"class GFG { static int MAX = 100005 ;"}
{"text":"Array to store primes","code":"static boolean [ ] isPrime = new boolean [ MAX ] ;"}
{"text":"function to calculate primes using sieve of eratosthenes","code":"static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } }"}
{"text":"Find prime number greater than a number","code":"static int findPrime ( int n ) { int num = n + 1 ;"}
{"text":"To return prime number greater than n","code":"while ( num > 0 ) {"}
{"text":"check if num is prime","code":"if ( ! isPrime [ num ] ) return num ;"}
{"text":"increment num","code":"num = num + 1 ; } return 0 ; }"}
{"text":"To find number to be added so sum of array is prime","code":"static int minNumber ( int arr [ ] , int n ) {"}
{"text":"call sieveOfEratostheneses to calculate primes","code":"sieveOfEratostheneses ( ) ; int sum = 0 ;"}
{"text":"To find sum of array elements","code":"for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ;"}
{"text":"To find prime number greater then sum","code":"int num = findPrime ( sum ) ;"}
{"text":"Return difference of sum and num","code":"return num - sum ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }"}
{"text":"Simple Java program to compute sum of subarray elements","code":"class GFG {"}
{"text":"Computes sum all sub - array","code":"public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ;"}
{"text":"Pick starting point","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Pick ending point","code":"temp = 0 ; for ( int j = i ; j < n ; j ++ ) {"}
{"text":"sum subarray between current starting and ending points","code":"temp += arr [ j ] ; result += temp ; } } return result ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( \" Sum \u2581 of \u2581 SubArray \u2581 : \u2581 \" + SubArraySum ( arr , n ) ) ; } }"}
{"text":"Java program to find highest power of 2 smaller than or equal to n .","code":"import java . io . * ; class GFG { static int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }"}
{"text":"Java program to rearrange characters in a string so that no two adjacent characters are same .","code":"import java . io . * ; import java . util . * ; class KeyComparator implements Comparator < Key > {"}
{"text":"Overriding compare ( ) method of Comparator","code":"public int compare ( Key k1 , Key k2 ) { if ( k1 . freq < k2 . freq ) return 1 ; else if ( k1 . freq > k2 . freq ) return - 1 ; return 0 ; } } class Key {"}
{"text":"store frequency of character","code":"int freq ; char ch ; Key ( int val , char c ) { freq = val ; ch = c ; } } class GFG { static int MAX_CHAR = 26 ;"}
{"text":"Function to rearrange character of a string so that no char repeat twice","code":"static void rearrangeString ( String str ) { int n = str . length ( ) ;"}
{"text":"Store frequencies of all characters in string","code":"int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Insert all characters with their frequencies into a priority_queue","code":"PriorityQueue < Key > pq = new PriorityQueue < > ( new KeyComparator ( ) ) ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] > 0 ) pq . add ( new Key ( count [ val ] , c ) ) ; }"}
{"text":"' str ' that will store resultant value","code":"str = \" \" ;"}
{"text":"work as the previous visited element initial previous element be . ( ' # ' and it ' s \u2581 frequency \u2581 ' - 1 ' )","code":"Key prev = new Key ( - 1 , ' # ' ) ;"}
{"text":"traverse queue","code":"while ( pq . size ( ) != 0 ) {"}
{"text":"pop top element from queue and add it to string .","code":"Key k = pq . peek ( ) ; pq . poll ( ) ; str = str + k . ch ;"}
{"text":"If frequency of previous character is less than zero that means it is useless , we need not to push it","code":"if ( prev . freq > 0 ) pq . add ( prev ) ;"}
{"text":"make current character as the previous ' char ' decrease frequency by ' one '","code":"( k . freq ) -- ; prev = k ; }"}
{"text":"If length of the resultant string and original string is not same then string is not valid","code":"if ( n != str . length ( ) ) System . out . println ( \" \u2581 Not \u2581 valid \u2581 String \u2581 \" ) ;"}
{"text":"valid string","code":"else System . out . println ( str ) ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String args [ ] ) { String str = \" bbbaa \" ; rearrangeString ( str ) ; } }"}
{"text":"Java program to find ( a ^ b ) mod m for a large ' a '","code":"public class GFG {"}
{"text":"utility function to calculate a % m","code":"static int aModM ( String s , int mod ) { int number = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"( s [ i ] - '0' ) gives the digit value and form the number","code":"number = ( number * 10 ) ; int x = Character . getNumericValue ( s . charAt ( i ) ) ; number = number + x ; number %= mod ; } return number ; }"}
{"text":"Returns find ( a ^ b ) % m","code":"static int ApowBmodM ( String a , int b , int m ) {"}
{"text":"Find a % m","code":"int ans = aModM ( a , m ) ; int mul = ans ;"}
{"text":"now multiply ans by b - 1 times and take mod with m","code":"for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String a = \"987584345091051645734583954832576\" ; int b = 3 , m = 11 ; System . out . println ( ApowBmodM ( a , b , m ) ) ; } }"}
{"text":"Java program for implementation of Lagrange 's Interpolation","code":"import java . util . * ; class GFG {"}
{"text":"To represent a data point corresponding to x and y = f ( x )","code":"static class Data { int x , y ; public Data ( int x , int y ) { super ( ) ; this . x = x ; this . y = y ; } } ;"}
{"text":"function to interpolate the given data points using Lagrange 's formula xi corresponds to the new data point whose value is to be obtained n represents the number of known data points","code":"static double interpolate ( Data f [ ] , int xi , int n ) {"}
{"text":"double result = 0 ; Initialize result","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Compute individual terms of above formula","code":"double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) \/ ( f [ i ] . x - f [ j ] . x ) ; }"}
{"text":"Add current term to result","code":"result += term ; } return result ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"creating an array of 4 known data points","code":"Data f [ ] = { new Data ( 0 , 2 ) , new Data ( 1 , 3 ) , new Data ( 2 , 12 ) , new Data ( 5 , 147 ) } ;"}
{"text":"Using the interpolate function to obtain a data point corresponding to x = 3","code":"System . out . print ( \" Value \u2581 of \u2581 f ( 3 ) \u2581 is \u2581 : \u2581 \" + ( int ) interpolate ( f , 3 , 4 ) ) ; } }"}
{"text":"Java program to print primes smaller than n using Sieve of Sundaram .","code":"import java . util . Arrays ; class GFG {"}
{"text":"Prints all prime numbers smaller","code":"static int SieveOfSundaram ( int n ) {"}
{"text":"In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than n , we reduce n to half","code":"int nNew = ( n - 1 ) \/ 2 ;"}
{"text":"This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j","code":"boolean marked [ ] = new boolean [ nNew + 1 ] ;"}
{"text":"Initialize all elements as not marked","code":"Arrays . fill ( marked , false ) ;"}
{"text":"Main logic of Sundaram . Mark all numbers of the form i + j + 2 ij as true where 1 <= i <= j","code":"for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ;"}
{"text":"Since 2 is a prime number","code":"if ( n > 2 ) System . out . print ( 2 + \" \u2581 \" ) ;"}
{"text":"Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + \" \u2581 \" ) ; return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 20 ; SieveOfSundaram ( n ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to construct an array with each element equal to XOR of all array elements except the element at the same index","code":"static void constructArray ( int A [ ] , int N , int K ) {"}
{"text":"Original array","code":"int B [ ] = new int [ N ] ;"}
{"text":"Stores Bitwise XOR of array","code":"int totalXOR = A [ 0 ] ^ K ;"}
{"text":"Calculate XOR of all array elements","code":"for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ;"}
{"text":"Print the original array B [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = A . length ;"}
{"text":"Function Call","code":"constructArray ( A , N , K ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the extra element in B [ ]","code":"static int extraElement ( int A [ ] , int B [ ] , int n ) {"}
{"text":"To store the result","code":"int ans = 0 ;"}
{"text":"Find the XOR of all the element of array A [ ] and array B [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = A . length ; System . out . println ( extraElement ( A , B , n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"class GFG {"}
{"text":"Function to calculate hamming distance","code":"static int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n1 = 9 , n2 = 14 ; System . out . println ( hammingDistance ( n1 , n2 ) ) ; } }"}
{"text":"JAVA program to print all bitwise subsets of N ( Naive approach )","code":"class GFG {"}
{"text":"function to find bitwise subsets Naive approach","code":"static void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) System . out . print ( i + \" \u2581 \" ) ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }"}
{"text":"Java program to find MSB number for given n .","code":"class GFG { static int setBitNumber ( int n ) {"}
{"text":"To find the position of the most significant set bit","code":"int k = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ;"}
{"text":"To return the the value of the number with set bit at k - th position","code":"return 1 << k ; }"}
{"text":"Driver code","code":"public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } }"}
{"text":"A sorting based solution to find the minimum number of subsets of a set such that every subset contains distinct elements .","code":"import java . util . * ; import java . lang . * ; public class GfG {"}
{"text":"Function to count subsets such that all subsets have distinct elements .","code":"public static int subset ( int ar [ ] , int n ) {"}
{"text":"Take input and initialize res = 0","code":"int res = 0 ;"}
{"text":"Sort the array","code":"Arrays . sort ( ar ) ;"}
{"text":"Traverse the input array and find maximum frequency","code":"for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ;"}
{"text":"For each number find its repetition \/ frequency","code":"for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; }"}
{"text":"Update res","code":"res = Math . max ( res , count ) ; } return res ; }"}
{"text":"Driver function","code":"public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }"}
{"text":"A hashing based solution to find the minimum number of subsets of a set such that every subset contains distinct elements .","code":"import java . util . HashMap ; import java . util . Map ; class GFG {"}
{"text":"Function to count subsets such that all subsets have distinct elements .","code":"static int subset ( int arr [ ] , int n ) {"}
{"text":"Traverse the input array and store frequencies of elements","code":"HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ;"}
{"text":"Find the maximum value in map .","code":"int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( subset ( arr , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {"}
{"text":"Store perfect squares less than or equal to N","code":"static ArrayList < Integer > psquare = new ArrayList < > ( ) ;"}
{"text":"Utility function to calculate perfect squares less than or equal to N","code":"static void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . add ( i * i ) ; }"}
{"text":"Function to find the number of ways to represent a number as sum of perfect squares","code":"static int countWays ( int index , int target ) {"}
{"text":"Handle the base cases","code":"if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ;"}
{"text":"Include the i - th index element","code":"int inc = countWays ( index , target - psquare . get ( index ) ) ;"}
{"text":"Exclude the i - th index element","code":"int exc = countWays ( index - 1 , target ) ;"}
{"text":"Return the result","code":"return inc + exc ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"int N = 9 ;"}
{"text":"Precalculate perfect squares <= N","code":"calcPsquare ( N ) ;"}
{"text":"Function Call","code":"System . out . print ( countWays ( psquare . size ( ) - 1 , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }"}
{"text":"Structure of a binary tree node","code":"static class TreeNode { int data , size ; TreeNode left ; TreeNode right ; } ;"}
{"text":"Function that allocates a new node with the given data and null to its left and right pointers","code":"static TreeNode newNode ( int data ) { TreeNode Node = new TreeNode ( ) ; Node . data = data ; Node . left = null ; Node . right = null ;"}
{"text":"Return newly created node","code":"return ( Node ) ; }"}
{"text":"Function to count the number of nodes in the left and right subtrees","code":"static pair sumofsubtree ( TreeNode root ) {"}
{"text":"Initialize a pair that stores the pair { number of nodes , depth }","code":"pair p = new pair ( 1 , 0 ) ;"}
{"text":"Finding the number of nodes in the left subtree","code":"if ( root . left != null ) { pair ptemp = sumofsubtree ( root . left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; }"}
{"text":"Find the number of nodes in the right subtree","code":"if ( root . right != null ) { pair ptemp = sumofsubtree ( root . right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; }"}
{"text":"Filling up size field","code":"root . size = p . first ; return p ; }"}
{"text":"Stores the sum of distances of all nodes from the given node","code":"static int sum = 0 ;"}
{"text":"Function to find the total distance","code":"static void distance ( TreeNode root , int target , int distancesum , int n ) {"}
{"text":"If target node matches with the current node","code":"if ( root . data == target ) { sum = distancesum ; }"}
{"text":"If root . left is not null","code":"if ( root . left != null ) {"}
{"text":"Update sum","code":"int tempsum = distancesum - root . left . size + ( n - root . left . size ) ;"}
{"text":"Recur for the left subtree","code":"distance ( root . left , target , tempsum , n ) ; }"}
{"text":"If root . right is not null","code":"if ( root . right != null ) {"}
{"text":"Apply the formula given in the approach","code":"int tempsum = distancesum - root . right . size + ( n - root . right . size ) ;"}
{"text":"Recur for the right subtree","code":"distance ( root . right , target , tempsum , n ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input tree","code":"TreeNode root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 7 ) ; root . left . left . left = newNode ( 8 ) ; root . left . left . right = newNode ( 9 ) ; int target = 3 ; pair p = sumofsubtree ( root ) ;"}
{"text":"Total number of nodes","code":"int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ;"}
{"text":"Print the sum of distances","code":"System . out . print ( sum + \"NEW_LINE\"); } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Reverse array","code":"static int [ ] reverse ( int a [ ] ) { int i , n = a . length , t ; for ( i = 0 ; i < n \/ 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; }"}
{"text":"Function to rearrange array such that sum of similar indexed elements does not exceed K","code":"static void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) {"}
{"text":"Sort the array B [ ] in descending order","code":"Arrays . sort ( B ) ; B = reverse ( B ) ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If condition fails","code":"if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { System . out . print ( \" - 1\" + \"NEW_LINE\"); } else {"}
{"text":"Print the array","code":"for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + \" \u2581 \" ) ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given arrays","code":"int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = A . length ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix","code":"static void countRows ( int [ ] [ ] mat ) {"}
{"text":"Stores the matrix dimensions","code":"int n = mat . length ; int m = mat [ 0 ] . length ;"}
{"text":"To store the result","code":"int count = 0 ;"}
{"text":"Stores the total sum of the matrix elements","code":"int totalSum = 0 ;"}
{"text":"Calculate the total sum","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { totalSum += mat [ i ] [ j ] ; } }"}
{"text":"Traverse to check for each row","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Stores the sum of elements of the current row","code":"int currSum = 0 ;"}
{"text":"Calculate the sum of elements of the current row","code":"for ( int j = 0 ; j < m ; j ++ ) { currSum += mat [ i ] [ j ] ; }"}
{"text":"If sum of current row exceeds the sum of rest of the matrix","code":"if ( currSum > totalSum - currSum )"}
{"text":"Increase count","code":"count ++ ; }"}
{"text":"Print the result","code":"System . out . println ( count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given matrix","code":"int [ ] [ ] mat = { { 2 , - 1 , 5 } , { - 3 , 0 , - 2 } , { 5 , 1 , 2 } } ;"}
{"text":"Function Call","code":"countRows ( mat ) ; } }"}
{"text":"Sorting based Java implementation to check whether the array contains a set of contiguous integers","code":"import java . util . * ; class GFG {"}
{"text":"function to check whether the array contains a set of contiguous integers","code":"static boolean areElementsContiguous ( int arr [ ] , int n ) {"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"After sorting , check if current element is either same as previous or is one more .","code":"for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation to check whether the array contains a set of contiguous integers","code":"import java . util . * ; class GFG {"}
{"text":"function to check whether the array contains a set of contiguous integers","code":"static boolean areElementsContiguous ( int arr [ ] , int n ) {"}
{"text":"Find maximum and minimum elements .","code":"int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ;"}
{"text":"There should be at least m elements in aaray to make them contiguous .","code":"if ( m > n ) return false ;"}
{"text":"Create a visited array and initialize false .","code":"boolean visited [ ] = new boolean [ n ] ;"}
{"text":"Mark elements as true .","code":"for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ;"}
{"text":"If any element is not marked , all elements are not contiguous .","code":"for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation to check whether the array contains a set of contiguous integers","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to check whether the array contains a set of contiguous integers","code":"static Boolean areElementsContiguous ( int arr [ ] , int n ) {"}
{"text":"Storing elements of ' arr [ ] ' in a hash table ' us '","code":"HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ;"}
{"text":"As arr [ 0 ] is present in ' us '","code":"int count = 1 ;"}
{"text":"Starting with previous smaller element of arr [ 0 ]","code":"int curr_ele = arr [ 0 ] - 1 ;"}
{"text":"If ' curr _ ele ' is present in ' us '","code":"while ( us . contains ( curr_ele ) == true ) {"}
{"text":"increment count","code":"count ++ ;"}
{"text":"update 'curr_ele\"","code":"curr_ele -- ; }"}
{"text":"Starting with next greater element of arr [ 0 ]","code":"curr_ele = arr [ 0 ] + 1 ;"}
{"text":"If ' curr _ ele ' is present in ' us '","code":"while ( us . contains ( curr_ele ) == true ) {"}
{"text":"increment count","code":"count ++ ;"}
{"text":"update 'curr_ele\"","code":"curr_ele ++ ; }"}
{"text":"Returns true if array contains a set of contiguous integers else returns false","code":"return ( count == ( us . size ( ) ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to find longest subarray with k or less distinct elements .","code":"import java . util . * ; class GFG {"}
{"text":"function to print the longest sub - array","code":"static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"mark the element visited","code":"freq [ a [ i ] ] ++ ;"}
{"text":"if its visited first time , then increase the counter of distinct elements by 1","code":"if ( freq [ a [ i ] ] == 1 ) now ++ ;"}
{"text":"When the counter of distinct elements increases from k , then reduce it to k","code":"while ( now > k ) {"}
{"text":"from the left , reduce the number of time of visit","code":"freq [ a [ l ] ] -- ;"}
{"text":"if the reduced visited time element is not present in further segment then decrease the count of distinct elements","code":"if ( freq [ a [ l ] ] == 0 ) now -- ;"}
{"text":"increase the subsegment mark","code":"l ++ ; }"}
{"text":"check length of longest sub - segment when greater then previous best then change it","code":"if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } }"}
{"text":"print the longest sub - segment","code":"for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . length ; int k = 3 ; longest ( a , n , k ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Stack ; class GFG { static class Pair { int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } }"}
{"text":"Function that returns true if any k segments overlap at any point","code":"static boolean kOverlap ( ArrayList < Pair > pairs , int k ) {"}
{"text":"Vector to store the starting point and the ending point","code":"ArrayList < Pair > vec = new ArrayList < > ( ) ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) {"}
{"text":"Starting points are marked by - 1 and ending points by + 1","code":"vec . add ( new Pair ( pairs . get ( i ) . first , - 1 ) ) ; vec . add ( new Pair ( pairs . get ( i ) . second , + 1 ) ) ; }"}
{"text":"Sort the vector by first element","code":"Collections . sort ( vec , new Comparator < Pair > ( ) {"}
{"text":"Comparator to sort the vector of pairs","code":"public int compare ( Pair a , Pair b ) { if ( a . first != b . first ) return a . first - b . first ; return ( a . second - b . second ) ; } } ) ;"}
{"text":"Stack to store the overlaps","code":"Stack < Pair > st = new Stack < > ( ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) {"}
{"text":"Get the current element","code":"Pair cur = vec . get ( i ) ;"}
{"text":"If it is the starting point","code":"if ( cur . second == - 1 ) {"}
{"text":"Push it in the stack","code":"st . push ( cur ) ; }"}
{"text":"It is the ending point","code":"else {"}
{"text":"Pop an element from stack","code":"st . pop ( ) ; }"}
{"text":"If more than k ranges overlap","code":"if ( st . size ( ) >= k ) { return true ; } } return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { ArrayList < Pair > pairs = new ArrayList < > ( ) ; pairs . add ( new Pair ( 1 , 3 ) ) ; pairs . add ( new Pair ( 2 , 4 ) ) ; pairs . add ( new Pair ( 3 , 5 ) ) ; pairs . add ( new Pair ( 7 , 10 ) ) ; int n = pairs . size ( ) , k = 3 ; if ( kOverlap ( pairs , k ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to finds out smallest range that includes elements from each of the given sorted lists .","code":"class GFG { static final int N = 5 ;"}
{"text":"array for storing the current index of list i","code":"static int ptr [ ] = new int [ 501 ] ;"}
{"text":"This function takes an k sorted lists in the form of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists .","code":"static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ;"}
{"text":"initializing to 0 index ;","code":"for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) {"}
{"text":"for maintaining the index of list containing the minimum element","code":"minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ;"}
{"text":"iterating over all the list","code":"for ( i = 0 ; i < k ; i ++ ) {"}
{"text":"if every element of list [ i ] is traversed then break the loop","code":"if ( ptr [ i ] == n ) { flag = 1 ; break ; }"}
{"text":"find minimum value among all the list elements pointing by the ptr [ ] array","code":"if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) {"}
{"text":"update the index of the list","code":"minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; }"}
{"text":"find maximum value among all the list elements pointing by the ptr [ ] array","code":"if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } }"}
{"text":"if any list exhaust we will not get any better answer , so break the while loop","code":"if ( flag == 1 ) { break ; } ptr [ minind ] ++ ;"}
{"text":"updating the minrange","code":"if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( \"The smallest range is [%d, %d]NEW_LINE\", minel, maxel); }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = arr . length ; findSmallestRange ( arr , N , k ) ; } }"}
{"text":"Java Program to find the largest such that d = a + b + c","code":"import java . io . * ; import java . util . Arrays ; class GFG {"}
{"text":"function to find largest d","code":"static int findLargestd ( int [ ] S , int n ) { boolean found = false ;"}
{"text":"sort the array in ascending order","code":"Arrays . sort ( S ) ;"}
{"text":"iterating from backwards to find the required largest d","code":"for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) {"}
{"text":"since all four a , b , c , d should be distinct","code":"if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ;"}
{"text":"if the current combination of j , k , l in the set is equal to S [ i ] return this value as this would be the largest d since we are iterating in descending order","code":"if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] S = new int [ ] { 2 , 3 , 5 , 7 , 12 } ; int n = S . length ; int ans = findLargestd ( S , n ) ; if ( ans == Integer . MAX_VALUE ) System . out . println ( \" No \u2581 Solution \" ) ; else System . out . println ( \" Largest \u2581 d \u2581 such \u2581 that \u2581 \" + \" a \u2581 + \u2581 \" + \" b \u2581 + \u2581 c \u2581 = \u2581 d \u2581 is \u2581 \" + ans ) ; } }"}
{"text":"A hashing based Java program to find largest d such that a + b + c = d .","code":"import java . util . HashMap ; import java . lang . Math ;"}
{"text":"To store and retrieve indices pair i & j","code":"class Indexes { int i , j ; Indexes ( int i , int j ) { this . i = i ; this . j = j ; } int getI ( ) { return i ; } int getJ ( ) { return j ; } } class GFG {"}
{"text":"The function finds four elements with given sum X","code":"static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ;"}
{"text":"Store sums ( a + b ) of all pairs ( a , b ) in a hash table","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ;"}
{"text":"Traverse through all pairs and find ( d - c ) is present in hash table","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ;"}
{"text":"If d - c is present in hash table ,","code":"if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ;"}
{"text":"Making sure that all elements are distinct array elements and an element is not considered more than once .","code":"if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = arr . length ; int res = findFourElements ( arr , n ) ; if ( res == Integer . MIN_VALUE ) System . out . println ( \" No \u2581 Solution \" ) ; else System . out . println ( res ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . Arrays ; public class GFG {"}
{"text":"Function to count maximum number of elements that can be selected","code":"static int CountMaximum ( int arr [ ] , int n , int k ) {"}
{"text":"Sorting the array","code":"Arrays . sort ( arr ) ; int sum = 0 , count = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Add the current element to the sum","code":"sum += arr [ i ] ;"}
{"text":"If sum exceeds k","code":"if ( sum > k ) break ;"}
{"text":"Increment count","code":"count ++ ; }"}
{"text":"Returning the count","code":"return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ;"}
{"text":"Function call","code":"System . out . println ( CountMaximum ( arr , n , k ) ) ; } }"}
{"text":"Java program to rotate an array by d elements","code":"class RotateArray {"}
{"text":"Function to left Rotate arr [ ] of size n by 1","code":"void leftRotatebyOne ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; }"}
{"text":"Function to left rotate arr [ ] of size n by d","code":"void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; }"}
{"text":"utility function to print an array","code":"void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { RotateArray rotate = new RotateArray ( ) ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; rotate . leftRotate ( arr , 2 , 7 ) ; rotate . printArray ( arr , 7 ) ; } }"}
{"text":"Java program to sort the array in a given index range","code":"import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to sort the elements of the array from index a to index b","code":"static void partSort ( int [ ] arr , int N , int a , int b ) {"}
{"text":"Variables to store start and end of the index range","code":"int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ;"}
{"text":"Temporary array","code":"int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; }"}
{"text":"Sort the temporary array","code":"Arrays . sort ( temp ) ;"}
{"text":"Modifying original array with temporary array elements","code":"j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; }"}
{"text":"Print the modified array","code":"for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ;"}
{"text":"length of the array","code":"int N = arr . length ; partSort ( arr , N , a , b ) ; } }"}
{"text":"Java implementation to sort the rows of matrix in descending order followed by sorting the columns in ascending order","code":"import java . util . * ; class GFG { static int MAX_SIZE = 10 ;"}
{"text":"function to sort each row of the matrix according to the order specified by descending .","code":"static void sortByRow ( int [ ] [ ] mat , int n , boolean descending ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) { int t = i ; for ( int p = 0 ; p < n ; p ++ ) { for ( int j = p + 1 ; j < n ; j ++ ) { if ( mat [ t ] [ p ] < mat [ t ] [ j ] ) { temp = mat [ t ] [ p ] ; mat [ t ] [ p ] = mat [ t ] [ j ] ; mat [ t ] [ j ] = temp ; } } } } else Arrays . sort ( mat [ i ] ) ; } }"}
{"text":"function to find transpose of the matrix","code":"static void transpose ( int mat [ ] [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {"}
{"text":"swapping element at index ( i , j ) by element at index ( j , i )","code":"temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } }"}
{"text":"function to sort the matrix row - wise and column - wise","code":"static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) {"}
{"text":"sort rows of mat [ ] [ ] in descending order","code":"sortByRow ( mat , n , true ) ;"}
{"text":"get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) ;"}
{"text":"again sort rows of mat [ ] [ ] in ascending order .","code":"sortByRow ( mat , n , false ) ;"}
{"text":"again get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) ; }"}
{"text":"function to print the matrix","code":"static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 3 ; int [ ] [ ] mat = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . println ( \" Original \u2581 Matrix : \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . println ( \" \" \u2581 + \u2581 \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }"}
{"text":"Java program to push zeroes to back of array","code":"import java . io . * ; class PushZero {"}
{"text":"Function which pushes all zeros to end of an array .","code":"static void pushZerosToEnd ( int arr [ ] , int n ) {"}
{"text":"Count of non - zero elements","code":"int count = 0 ;"}
{"text":"Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element","code":"for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 )"}
{"text":"here count is","code":"arr [ count ++ ] = arr [ i ] ;"}
{"text":"incremented Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end .","code":"while ( count < n ) arr [ count ++ ] = 0 ; }"}
{"text":"Driver function to check for above functions","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; pushZerosToEnd ( arr , n ) ; System . out . println ( \" Array \u2581 after \u2581 pushing \u2581 zeros \u2581 to \u2581 the \u2581 back : \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Java implementation to move all zeroes at the end of array","code":"import java . io . * ; class GFG {"}
{"text":"function to move all zeroes at the end of array","code":"static void moveZerosToEnd ( int arr [ ] , int n ) {"}
{"text":"Count of non - zero elements","code":"int count = 0 ; int temp ;"}
{"text":"Traverse the array . If arr [ i ] is non - zero , then swap the element at index ' count ' with the element at index ' i '","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } }"}
{"text":"function to print the array elements","code":"static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver program to test above","code":"public static void main ( String args [ ] ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; System . out . print ( \" Original \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; System . out . print ( \" Modified array : \"); printArray ( arr , n ) ; } }"}
{"text":"Java implementation to rearrange the array elements after modification","code":"class GFG {"}
{"text":"function which pushes all zeros to end of an array .","code":"static void pushZerosToEnd ( int arr [ ] , int n ) {"}
{"text":"Count of non - zero elements","code":"int count = 0 ;"}
{"text":"Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element","code":"for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 )"}
{"text":"here count is incremented","code":"arr [ count ++ ] = arr [ i ] ;"}
{"text":"Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end .","code":"while ( count < n ) arr [ count ++ ] = 0 ; }"}
{"text":"function to rearrange the array elements after modification","code":"static void modifyAndRearrangeArr ( int arr [ ] , int n ) {"}
{"text":"if ' arr [ ] ' contains a single element only","code":"if ( n == 1 ) return ;"}
{"text":"traverse the array","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"if true , perform the required modification","code":"if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) {"}
{"text":"double current index value","code":"arr [ i ] = 2 * arr [ i ] ;"}
{"text":"put 0 in the next index","code":"arr [ i + 1 ] = 0 ;"}
{"text":"increment by 1 so as to move two indexes ahead during loop iteration","code":"i ++ ; } }"}
{"text":"push all the zeros at the end of ' arr [ ] '","code":"pushZerosToEnd ( arr , n ) ; }"}
{"text":"function to print the array elements","code":"static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver program to test above","code":"public static void main ( String [ ] args ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = arr . length ; System . out . print ( \" Original \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; System . out . print ( \" Modified \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; } }"}
{"text":"Function For Swaping Two Element Of An Array","code":"public static void swap ( int [ ] A , int i , int j ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; }"}
{"text":"shift all zero to left side of an array","code":"static void shiftAllZeroToLeft ( int array [ ] , int n ) {"}
{"text":"Maintain last index with positive value","code":"int lastSeenNonZero = 0 ; for ( int index = 0 ; index < n ; index ++ ) {"}
{"text":"If Element is non - zero","code":"if ( array [ index ] != 0 ) {"}
{"text":"swap current index , with lastSeen non - zero","code":"swap ( array , array [ index ] , array [ lastSeenNonZero ] ) ;"}
{"text":"next element will be last seen non - zero","code":"lastSeenNonZero ++ ; } } } }"}
{"text":"Java program to Rearrange positive and negative numbers in a array","code":"import java . io . * ; class GFG {"}
{"text":"A utility function to print an array of size n","code":"static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Function to Rearrange positive and negative numbers in a array","code":"static void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ;"}
{"text":"if current element is positive do nothing","code":"if ( key > 0 ) continue ;"}
{"text":"if current element is negative , shift positive elements of arr [ 0. . i - 1 ] , to one position to their right","code":"j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; }"}
{"text":"Put negative element at its right position","code":"arr [ j + 1 ] = key ; } }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int n = arr . length ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; } }"}
{"text":"Java program to Rearrange positive and negative numbers in a array","code":"class GFG {"}
{"text":"Function to print an array","code":"static void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( A [ i ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; ; }"}
{"text":"Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space .","code":"static void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } }"}
{"text":"Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ]","code":"static void merge ( int arr [ ] , int l , int m , int r ) {"}
{"text":"Initial index of 1 st subarray","code":"int i = l ;"}
{"text":"Initial index of IInd","code":"int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ;"}
{"text":"arr [ i . . m ] is positive","code":"while ( j <= r && arr [ j ] < 0 ) j ++ ;"}
{"text":"arr [ j . . r ] is positive reverse positive part of left sub - array ( arr [ i . . m ] )","code":"reverse ( arr , i , m ) ;"}
{"text":"reverse negative part of right sub - array ( arr [ m + 1. . j - 1 ] )","code":"reverse ( arr , m + 1 , j - 1 ) ;"}
{"text":"reverse arr [ i . . j - 1 ]","code":"reverse ( arr , i , j - 1 ) ; }"}
{"text":"Function to Rearrange positive and negative numbers in a array","code":"static void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) {"}
{"text":"Same as ( l + r ) \/ 2 , but avoids overflow for large l and h","code":"int m = l + ( r - l ) \/ 2 ;"}
{"text":"Sort first and second halves","code":"RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_size = arr . length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . io . * ; class GFG { public static void RearrangePosNeg ( int arr [ ] ) { int i = 0 ; int j = arr . length - 1 ; while ( true ) {"}
{"text":"Loop until arr [ i ] < 0 and still inside the array","code":"while ( arr [ i ] < 0 && i < arr . length ) i ++ ;"}
{"text":"Loop until arr [ j ] > 0 and still inside the array","code":"while ( arr [ j ] > 0 && j >= 0 ) j -- ;"}
{"text":"if i is less than j","code":"if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; RearrangePosNeg ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the winner of the game played based on given conditions","code":"static void winner ( int arr [ ] , int N ) {"}
{"text":"A wins if size of array is odd","code":"if ( N % 2 == 1 ) { System . out . print ( \" A \" ) ; }"}
{"text":"Otherwise , B wins","code":"else { System . out . print ( \" B \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input array","code":"int arr [ ] = { 24 , 45 , 45 , 24 } ;"}
{"text":"Size of the array","code":"int N = arr . length ; winner ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static int sz = 20 ; static int sqr = ( int ) ( Math . sqrt ( sz ) ) + 1 ;"}
{"text":"Function to sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all possible values of X and Y , where Y is less than or equal to Math . sqrt ( N ) .","code":"static void precomputeExpressionForAllVal ( int arr [ ] , int N , int dp [ ] [ ] ) {"}
{"text":"Iterate over all possible values of X","code":"for ( int i = N - 1 ; i >= 0 ; i -- ) {"}
{"text":"Precompute for all possible values of an expression such that y <= Math . sqrt ( N )","code":"for ( int j = 1 ; j <= Math . sqrt ( N ) ; j ++ ) {"}
{"text":"If i + j less than N","code":"if ( i + j < N ) {"}
{"text":"Update dp [ i ] [ j ]","code":"dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] ; } else {"}
{"text":"Update dp [ i ] [ j ]","code":"dp [ i ] [ j ] = arr [ i ] ; } } } }"}
{"text":"Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries","code":"static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) {"}
{"text":"dp [ x ] [ y ] : Stores sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ...","code":"int [ ] [ ] dp = new int [ sz ] [ sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ;"}
{"text":"Traverse the query array , Q [ ] [ ]","code":"for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ;"}
{"text":"If y is less than or equal to Math . sqrt ( N )","code":"if ( y <= Math . sqrt ( N ) ) { System . out . print ( dp [ x ] [ y ] + \" \u2581 \" ) ; continue ; }"}
{"text":"Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ...","code":"int sum = 0 ;"}
{"text":"Traverse the array , arr [ ]","code":"while ( x < N ) {"}
{"text":"Update sum","code":"sum += arr [ x ] ;"}
{"text":"Update x","code":"x += y ; } System . out . print ( sum + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }"}
{"text":"Java program to find all elements in array which have at - least two greater elements itself .","code":"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) {"}
{"text":"Pick elements one by one and count greater elements . If count is more than 2 , print that element .","code":"for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }"}
{"text":"Sorting based Java program to find all elements in array which have atleast two greater elements itself .","code":"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }"}
{"text":"Java program to find all elements in array which have atleast two greater elements itself .","code":"import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If current element is smaller than first then update both first and second","code":"if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; }"}
{"text":"If arr [ i ] is in between first and second then update second","code":"else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the minimum number of operations required to make the array non - increasing","code":"public static int getMinOps ( int [ ] arr ) {"}
{"text":"Stores the count of required operations","code":"int res = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) {"}
{"text":"If arr [ i ] > arr [ i + 1 ] , no increments required . Otherwise , add their difference to the answer","code":"res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; }"}
{"text":"Return the result res","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 1 , 2 } ; System . out . println ( getMinOps ( arr ) ) ; } }"}
{"text":"function that returns smallest elements missing in a sorted array .","code":"int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) \/ 2 ;"}
{"text":"Left half has all elements from 0 to mid","code":"if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }"}
{"text":"Driver program to test the above function","code":"public static void main ( String [ ] args ) { SmallestMissing small = new SmallestMissing ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . length ; System . out . println ( \" First \u2581 Missing \u2581 element \u2581 is \u2581 : \u2581 \" + small . findFirstMissing ( arr , 0 , n - 1 ) ) ; } }"}
{"text":"Java Program for above approach","code":"import java . io . * ; class GFG {"}
{"text":"Program to find missing element","code":"int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) \/ 2 ;"}
{"text":"* Index matches with value at that index , means missing element cannot be upto that point","code":"if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; }"}
{"text":"Program to find Smallest Missing in Sorted Array","code":"int findSmallestMissinginSortedArray ( int [ ] arr ) {"}
{"text":"Check if 0 is missing in the array","code":"if ( arr [ 0 ] != 0 ) return 0 ;"}
{"text":"Check is all numbers 0 to n - 1 are prsent in array","code":"if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; }"}
{"text":"Driver program to test the above function","code":"public static void main ( String [ ] args ) { GFG small = new GFG ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ;"}
{"text":"Function Call","code":"System . out . println ( \" First \u2581 Missing \u2581 element \u2581 is \u2581 : \u2581 \" + small . findSmallestMissinginSortedArray ( arr ) ) ; } }"}
{"text":"Function to return max sum such that no two elements are adjacent","code":"int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) {"}
{"text":"current max excluding i","code":"excl_new = ( incl > excl ) ? incl : excl ;"}
{"text":"current max including i","code":"incl = excl + arr [ i ] ; excl = excl_new ; }"}
{"text":"return max of incl and excl","code":"return ( ( incl > excl ) ? incl : excl ) ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { MaximumSum sum = new MaximumSum ( ) ; int arr [ ] = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; System . out . println ( sum . FindMaxSum ( arr , arr . length ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static final int N = 7 ;"}
{"text":"Function for counting minimum number of changes","code":"static int countChanges ( int matrix [ ] [ ] , int n , int m ) {"}
{"text":"Distance of elements from ( 0 , 0 ) will is i range [ 0 , n + m - 2 ]","code":"int dist = n + m - 1 ;"}
{"text":"Store frequencies of [ 0 , 9 ] at distance i","code":"int [ ] [ ] freq = new int [ dist ] [ 10 ] ;"}
{"text":"Initialize frequencies as 0","code":"for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; }"}
{"text":"Count frequencies of [ 0 , 9 ]","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"Increment frequency of value matrix [ i ] [ j ] at distance i + j","code":"freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist \/ 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ;"}
{"text":"Find value with max frequency and count total cells at distance i from front end and rear end","code":"for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; }"}
{"text":"Change all values to the value with max frequency","code":"min_changes_sum += ( total_values - maximum ) ; }"}
{"text":"Return the answer","code":"return min_changes_sum ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given matrix","code":"int mat [ ] [ ] = { { 1 , 2 } , { 3 , 5 } } ;"}
{"text":"Function call","code":"System . out . print ( countChanges ( mat , 2 , 2 ) ) ; } }"}
{"text":"Java program to do range minimum query using sparse table","code":"import java . io . * ; class GFG { static int MAX = 500 ;"}
{"text":"lookup [ i ] [ j ] is going to store minimum value in arr [ i . . j ] . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple .","code":"static int [ ] [ ] lookup = new int [ MAX ] [ MAX ] ;"}
{"text":"Fills lookup array lookup [ ] [ ] in bottom up manner .","code":"static void buildSparseTable ( int arr [ ] , int n ) {"}
{"text":"Initialize M for the intervals with length 1","code":"for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ;"}
{"text":"Compute values from smaller to bigger intervals","code":"for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) {"}
{"text":"Compute minimum value for all intervals with size 2 ^ j","code":"for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) {"}
{"text":"For arr [ 2 ] [ 10 ] , we compare arr [ lookup [ 0 ] [ 7 ] ] and arr [ lookup [ 3 ] [ 10 ] ]","code":"if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } }"}
{"text":"Returns minimum of arr [ L . . R ]","code":"static int query ( int L , int R ) {"}
{"text":"Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3","code":"int j = ( int ) Math . log ( R - L + 1 ) ;"}
{"text":"Compute minimum of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we compare arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,","code":"if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . println ( query ( 0 , 4 ) ) ; System . out . println ( query ( 4 , 7 ) ) ; System . out . println ( query ( 7 , 8 ) ) ; } }"}
{"text":"Java program to do range minimum query using sparse table","code":"import java . util . * ; class GFG { static final int MAX = 500 ;"}
{"text":"lookup [ i ] [ j ] is going to store GCD of arr [ i . . j ] . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple .","code":"static int [ ] [ ] table = new int [ MAX ] [ MAX ] ;"}
{"text":"it builds sparse table .","code":"static void buildSparseTable ( int arr [ ] , int n ) {"}
{"text":"GCD of single element is element itself","code":"for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ;"}
{"text":"Build sparse table","code":"for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; }"}
{"text":"Returns GCD of arr [ L . . R ]","code":"static int query ( int L , int R ) {"}
{"text":"Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3","code":"int j = ( int ) Math . log ( R - L + 1 ) ;"}
{"text":"Compute GCD of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we find GCD of arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,","code":"return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . print ( query ( 0 , 2 ) + \"NEW_LINE\"); System . out . print ( query ( 1 , 3 ) + \"NEW_LINE\"); System . out . print ( query ( 4 , 5 ) + \"NEW_LINE\"); } }"}
{"text":"Java program to find lexicographically minimum value after k swaps .","code":"class GFG {"}
{"text":"Modifies arr [ 0. . n - 1 ] to lexicographically smallest with k swaps .","code":"static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) {"}
{"text":"Set the position where we want to put the smallest integer","code":"int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) {"}
{"text":"If we exceed the Max swaps then terminate the loop","code":"if ( j - i > k ) break ;"}
{"text":"Find the minimum value from i + 1 to max k or n","code":"if ( arr [ j ] < arr [ pos ] ) pos = j ; }"}
{"text":"Swap the elements from Minimum position we found till now to the i index","code":"int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; }"}
{"text":"Set the final value after swapping pos - i elements","code":"k -= pos - i ; } }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = arr . length ; int k = 3 ;"}
{"text":"Function calling","code":"minimizeWithKSwaps ( arr , n , k ) ;"}
{"text":"Print the final Array","code":"for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Java program to find maximum average subarray of given length .","code":"import java . io . * ; class GFG {"}
{"text":"Returns beginning index of maximum average subarray of length ' k '","code":"static int findMaxAverage ( int [ ] arr , int n , int k ) {"}
{"text":"Check if ' k ' is valid","code":"if ( k > n ) return - 1 ;"}
{"text":"Create and fill array to store cumulative sum . csum [ i ] stores sum of arr [ 0 ] to arr [ i ]","code":"int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;"}
{"text":"Initialize max_sm as sum of first subarray","code":"int max_sum = csum [ k - 1 ] , max_end = k - 1 ;"}
{"text":"Find sum of other subarrays and update max_sum if required .","code":"for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } }"}
{"text":"Return starting index","code":"return max_end - k + 1 ; }"}
{"text":"Driver Code","code":"static public void main ( String [ ] args ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( \" The \u2581 maximum \u2581 \" + \" average \u2581 subarray \u2581 of \u2581 length \u2581 \" + k + \" \u2581 begins \u2581 at \u2581 index \u2581 \" + findMaxAverage ( arr , n , k ) ) ; } }"}
{"text":"Java program to find maximum average subarray of given length .","code":"import java . io . * ; class GFG {"}
{"text":"Returns beginning index of maximum average subarray of length ' k '","code":"static int findMaxAverage ( int arr [ ] , int n , int k ) {"}
{"text":"Check if ' k ' is valid","code":"if ( k > n ) return - 1 ;"}
{"text":"Compute sum of first ' k ' elements","code":"int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ;"}
{"text":"Compute sum of remaining subarrays","code":"for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } }"}
{"text":"Return starting index","code":"return max_end - k + 1 ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( \" The \u2581 maximum \u2581 average \" + \" \u2581 subarray \u2581 of \u2581 length \u2581 \" + k + \" \u2581 begins \u2581 at \u2581 index \u2581 \" + findMaxAverage ( arr , n , k ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG { static class R { int x , y ; public R ( int x , int y ) { this . x = x ; this . y = y ; } }"}
{"text":"Stores the minimum score for each states as map < pair < pos , myturn > , ans >","code":"static HashMap < R , Integer > m = new HashMap < > ( ) ;"}
{"text":"Function to find the minimum score after choosing element from array","code":"public static int findMinimum ( int [ ] arr , int N , int pos , int turn ) {"}
{"text":"Return the stored state","code":"R x = new R ( pos , turn ) ; if ( m . containsKey ( x ) ) { return m . get ( x ) ; }"}
{"text":"Base Case","code":"if ( pos >= N - 1 ) { return 0 ; }"}
{"text":"Player A 's turn","code":"if ( turn == 0 ) {"}
{"text":"Find the minimum score","code":"int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ;"}
{"text":"Store the current state","code":"R v = new R ( pos , turn ) ; m . put ( v , ans ) ;"}
{"text":"Return the result","code":"return ans ; }"}
{"text":"Player B 's turn","code":"if ( turn != 0 ) {"}
{"text":"Find minimum score","code":"int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ;"}
{"text":"Store the current state","code":"R v = new R ( pos , turn ) ; m . put ( v , ans ) ;"}
{"text":"Return the result","code":"return ans ; } return 0 ; }"}
{"text":"Function that finds the minimum penality after choosing element from the given binary array","code":"public static int countPenality ( int [ ] arr , int N ) {"}
{"text":"Starting position of choosing element from array","code":"int pos = 0 ;"}
{"text":"0 denotes player A turn 1 denotes player B turn","code":"int turn = 0 ;"}
{"text":"Function Call","code":"return findMinimum ( arr , N , pos , turn ) + 1 ; }"}
{"text":"Function to print the answer","code":"public static void printAnswer ( int [ ] arr , int N ) {"}
{"text":"Minimum penalty","code":"int a = countPenality ( arr , N ) ;"}
{"text":"Calculate sum of all arr elements","code":"int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; }"}
{"text":"Print the minimum score","code":"System . out . println ( a ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = 8 ; printAnswer ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG { static int MAX = 1000001 ; static int prime [ ] = new int [ MAX ] ;"}
{"text":"Function to find the prime numbers","code":"static void SieveOfEratosthenes ( ) {"}
{"text":"Create a boolean array prime [ ] and initialize all entries it as true A value in prime [ i ] will finally be false if i is Not a prime","code":"Arrays . fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {"}
{"text":"Check if prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == 1 ) {"}
{"text":"Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked","code":"for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } }"}
{"text":"Function to get the middle index from corner indexes","code":"static int getMid ( int s , int e ) { return s + ( e - s ) \/ 2 ; }"}
{"text":"Function to get the sum of values in the given range of the array","code":"static int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) {"}
{"text":"If segment of this node is a part of given range , then return the sum of the segment","code":"if ( qs <= ss && qe >= se ) return st [ si ] ;"}
{"text":"If segment of this node is outside the given range","code":"if ( se < qs ss > qe ) return 0 ;"}
{"text":"If a part of this segment overlaps with the given range","code":"int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; }"}
{"text":"Function to update the nodes which have the given index in their range","code":"static void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) {"}
{"text":"If the input index lies outside the range of this segment","code":"if ( i < ss i > se ) return ;"}
{"text":"If the input index is in range of this node , then update the value of the node and its children","code":"st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }"}
{"text":"Function to update a value in input array and segment tree","code":"static void updateValue ( int arr [ ] , int [ ] st , int n , int i , int new_val ) {"}
{"text":"Check for erroneous input index","code":"if ( i < 0 i > n - 1 ) { System . out . print ( \" - 1\" ) ; return ; }"}
{"text":"Get the difference between new value and old value","code":"int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ;"}
{"text":"Update the value in array","code":"arr [ i ] = new_val ;"}
{"text":"Update the values of nodes in segment tree only if either previous value or new value or both are prime","code":"if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) {"}
{"text":"If only new value is prime","code":"if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ;"}
{"text":"If only new value is prime","code":"else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ;"}
{"text":"If both are prime","code":"else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } }"}
{"text":"Return sum of elements in range from index qs ( query start ) to qe ( query end ) . It mainly uses getSumUtil ( )","code":"static int getSum ( int [ ] st , int n , int qs , int qe ) {"}
{"text":"Check for erroneous input values","code":"if ( qs < 0 qe > n - 1 qs > qe ) { System . out . println ( \" - 1\" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; }"}
{"text":"Function that constructs Segment Tree","code":"static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) {"}
{"text":"If there is one element in array , store it in current node of segment tree and return","code":"if ( ss == se ) {"}
{"text":"Only add those elements in segment tree which are prime","code":"if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; }"}
{"text":"If there are more than one elements , then recur for left and right subtrees and store the sum of values in this node","code":"int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; }"}
{"text":"Function to construct segment tree from given array","code":"static int [ ] constructST ( int arr [ ] , int n ) {"}
{"text":"Height of segment tree","code":"int x = ( int ) ( Math . ceil ( Math . log ( n ) \/ Math . log ( 2 ) ) ) ;"}
{"text":"Maximum size of segment tree","code":"int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ;"}
{"text":"Allocate memory","code":"int [ ] st = new int [ max_size ] ;"}
{"text":"Fill the allocated memory st","code":"constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;"}
{"text":"Return the constructed segment tree","code":"return st ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = arr . length ; int Q [ ] [ ] = { { 1 , 1 , 3 } , { 2 , 1 , 10 } , { 1 , 1 , 3 } } ;"}
{"text":"Function call","code":"SieveOfEratosthenes ( ) ;"}
{"text":"Build segment tree from given array","code":"int [ ] st = constructST ( arr , n ) ;"}
{"text":"Print sum of values in array from index 1 to 3","code":"System . out . println ( getSum ( st , n , 1 , 3 ) ) ;"}
{"text":"Update : set arr [ 1 ] = 10 and update corresponding segment tree nodes","code":"updateValue ( arr , st , n , 1 , 10 ) ;"}
{"text":"Find sum after the value is updated","code":"System . out . println ( getSum ( st , n , 1 , 3 ) ) ; } }"}
{"text":"Java Program to Count the number of ways to construct the target String","code":"import java . util . * ; class GFG { static int mod = 1000000007 ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static int calculate ( int pos , int prev , String s , Vector < Integer > index ) {"}
{"text":"base case","code":"if ( pos == s . length ( ) ) return 1 ;"}
{"text":"If current subproblem has been solved , use the value","code":"if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ;"}
{"text":"search through all the indiced at which the current character occurs . For each index greater than prev , take the index and move to the next position , and add to the answer .","code":"int answer = 0 ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( index . get ( i ) . compareTo ( prev ) >= 0 ) { answer = ( answer % mod + calculate ( pos + 1 , index . get ( i ) , s , index ) % mod ) % mod ; } }"}
{"text":"Store and return the solution for this subproblem","code":"return dp [ pos ] [ prev ] = answer ; } static int countWays ( Vector < String > a , String s ) { int n = a . size ( ) ;"}
{"text":"preprocess the Strings by storing for each character of every String , the index of their occurrence we will use a common list for all because of only the index matter in the String from which the character was picked","code":"Vector < Integer > [ ] index = new Vector [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . length ( ) ; j ++ ) {"}
{"text":"we are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just for ease of implementation","code":"index [ a . get ( i ) . charAt ( j ) - ' a ' ] . add ( j + 1 ) ; } }"}
{"text":"initialise dp table . - 1 represents that the subproblem hasn 't been solved","code":"for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { Vector < String > A = new Vector < String > ( ) ; A . add ( \" adc \" ) ; A . add ( \" aec \" ) ; A . add ( \" erg \" ) ; String S = \" ac \" ; System . out . print ( countWays ( A , S ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static final int MAX = 100005 ; static final int MOD = 1000000007 ;"}
{"text":"To store the states of the dp","code":"static int [ ] [ ] [ ] dp = new int [ MAX ] [ 101 ] [ 2 ] ;"}
{"text":"Function to return the count of numbers from the range [ 0 , n ] whose digit sum is a multiple of k using bottom - up dp","code":"static int countNum ( int idx , int sum , int tight , Vector < Integer > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ;"}
{"text":"The digit in this index can only be from [ 0 , num [ idx ] ]","code":"if ( tight == 0 ) { limit = num . get ( idx ) ; }"}
{"text":"The digit in this index can be anything from [ 0 , 9 ]","code":"else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) {"}
{"text":"new_tight is the flag value for the next position","code":"int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; }"}
{"text":"res can 't be negative","code":"if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; }"}
{"text":"Function to process the String to a vector of digits from MSD to LSD","code":"static Vector < Integer > process ( String s ) { Vector < Integer > num = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . add ( s . charAt ( i ) - '0' ) ; } return num ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"For large input number n","code":"String n = \"98765432109876543210\" ;"}
{"text":"Total number of digits in n","code":"int len = n . length ( ) ; int k = 58 ;"}
{"text":"Clean dp table","code":"for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } }"}
{"text":"Process the String to a vector of digits from MSD to LSD","code":"Vector < Integer > num = process ( n ) ; System . out . print ( countNum ( 0 , 0 , 0 , num , len , k ) ) ; } }"}
{"text":"Java implementation to find the number of Subsequences with Even and Odd Sum","code":"import java . util . * ; import java . lang . * ; class GFG { public static int [ ] countSum ( int arr [ ] , int n ) { int result = 0 ;"}
{"text":"Arrays to store the count of even subsequences and odd subsequences","code":"int [ ] countODD = new int [ n + 1 ] ; int [ ] countEVEN = new int [ n + 1 ] ;"}
{"text":"Initialising countEVEN [ 0 ] and countODD [ 0 ] to 0 since as there is no subsequence before the iteration with even or odd count .","code":"countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ;"}
{"text":"Here countODD [ i ] denotes count of odd subsequences till i","code":"for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"if the number is even","code":"if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; }"}
{"text":"if the number is odd","code":"else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } int [ ] ans = new int [ 2 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 2 , 3 } ; int n = 4 ; int [ ] ans = countSum ( arr , n ) ; System . out . println ( \" EvenSum \u2581 = \u2581 \" + ans [ 0 ] ) ; System . out . println ( \" OddSum \u2581 = \u2581 \" + ans [ 1 ] ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG { static int maxN = 31 ; static int maxW = 31 ;"}
{"text":"3D array to store states of DP","code":"static int dp [ ] [ ] [ ] = new int [ maxN ] [ maxW ] [ maxW ] ;"}
{"text":"w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on","code":"static int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) {"}
{"text":"Base case","code":"if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ;"}
{"text":"Variables to store the result of three parts of recurrence relation","code":"int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ;"}
{"text":"Store the state in the 3D array","code":"dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input array","code":"int arr [ ] = { 8 , 2 , 3 } ;"}
{"text":"Initializing the array with - 1","code":"for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxW ; j ++ ) for ( int k = 0 ; k < maxW ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ;"}
{"text":"Number of elements in the array","code":"int n = arr . length ;"}
{"text":"Capacity of knapsacks","code":"int w1 = 10 , w2 = 3 ;"}
{"text":"Function to be called","code":"System . out . println ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ; } }"}
{"text":"Java program to find sum of Bit - wise AND of all submatrices","code":"import java . util . * ; class GFG { static int n = 3 ;"}
{"text":"Function to find prefix - count for each row from right to left","code":"static void findPrefixCount ( int p_arr [ ] [ ] , boolean set_bit [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( set_bit [ i ] [ j ] ) ? 1 : 0 ; } } } static class pair { int first , second ; pair ( ) { } pair ( int a , int b ) { first = a ; second = b ; } }"}
{"text":"Function to find the number of submatrices with all 1 s","code":"static int matrixAllOne ( boolean set_bit [ ] [ ] ) {"}
{"text":"Array to store required prefix count of 1 s from right to left for boolean array","code":"int p_arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) p_arr [ i ] [ j ] = 0 ; findPrefixCount ( p_arr , set_bit ) ;"}
{"text":"Variable to store the final answer","code":"int ans = 0 ;"}
{"text":"For each index of a column , determine the number of sub - matrices starting from that index and has all 1 s","code":"for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ;"}
{"text":"Stack to store elements and the count of the numbers they popped First part of pair is value of inserted element Second part is count of the number of elements pushed before with a greater value","code":"Stack < pair > q = new Stack < pair > ( ) ;"}
{"text":"variable to store the number of submatrices with all 1 s","code":"int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 && q . peek ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . peek ( ) . second + 1 ) * ( q . peek ( ) . first - p_arr [ i ] [ j ] ) ; c += q . peek ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( new pair ( p_arr [ i ] [ j ] , c ) ) ; i -- ; } } return ans ; }"}
{"text":"Function to find sum of Bitwise - OR of all submatrices","code":"static int sumAndMatrix ( int arr [ ] [ ] ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) {"}
{"text":"matrix to store the status of ith bit of each element of matrix arr","code":"boolean set_bit [ ] [ ] = new boolean [ n ] [ n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; System . out . println ( sumAndMatrix ( arr ) ) ; } }"}
{"text":"Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed","code":"import java . io . * ; class GFG { static int CountWays ( int n ) {"}
{"text":"noOfWays [ i ] will store count for last 3 values before i .","code":"int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ;"}
{"text":"Loop till \" n + 1\" to compute value for \" n \"","code":"for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] ="}
{"text":"number of ways if first run is 1","code":"noOfWays [ 3 - 1 ]"}
{"text":"number of ways if first run is 2 and second run is 1","code":"+ noOfWays [ 3 - 3 ] ;"}
{"text":"Remember last 3 values","code":"noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; public class Main { static class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int MAX = 105 , q = 0 ; static int [ ] prime = new int [ MAX ] ; static void sieve ( ) { for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = 1 ; } } }"}
{"text":"Depth First Search","code":"static void dfs ( int i , int j , int k , int n , int m , int [ ] [ ] mappedMatrix , int [ ] [ ] mark , pair [ ] ans ) {"}
{"text":"Return if cell contain non prime number or obstacle , or going out of matrix or already visited the cell or already found the lexicographical largest path","code":"if ( ( mappedMatrix [ i ] [ j ] == 0 ? true : false ) || ( i > n ? true : false ) || ( j > m ? true : false ) || ( mark [ i ] [ j ] != 0 ? true : false ) || ( q != 0 ? true : false ) ) return ;"}
{"text":"Marking cell is already visited","code":"mark [ i ] [ j ] = 1 ;"}
{"text":"Storing the lexicographical largest path index","code":"ans [ k ] = new pair ( i , j ) ;"}
{"text":"If reached the end of the matrix","code":"if ( i == n && j == m ) {"}
{"text":"Updating the final number of steps in lexicographical largest path","code":"( q ) = k ; return ; }"}
{"text":"Moving diagonal ( trying lexicographical largest path )","code":"dfs ( i + 1 , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ;"}
{"text":"Moving cell right to current cell","code":"dfs ( i + 1 , j , k + 1 , n , m , mappedMatrix , mark , ans ) ;"}
{"text":"Moving cell down to current cell .","code":"dfs ( i , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; }"}
{"text":"Print lexicographical largest prime path","code":"static void lexicographicalPath ( int n , int m , int [ ] [ ] mappedMatrix ) {"}
{"text":"To count the number of step in lexicographical largest prime path","code":"int q = 0 ;"}
{"text":"To store the lexicographical largest prime path index","code":"pair [ ] ans = new pair [ MAX ] ;"}
{"text":"To mark if the cell is already traversed or not","code":"int [ ] [ ] mark = new int [ MAX ] [ MAX ] ;"}
{"text":"Traversing by DFS","code":"dfs ( 1 , 1 , 1 , n , m , mappedMatrix , mark , ans ) ; int [ ] [ ] anss = { { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 3 , 3 } } ;"}
{"text":"Printing the lexicographical largest prime path","code":"for ( int i = 0 ; i < 4 ; i ++ ) System . out . println ( anss [ i ] [ 0 ] + \" \u2581 \" + anss [ i ] [ 1 ] ) ; }"}
{"text":"Return the number of prime path in ther matrix .","code":"static void countPrimePath ( int [ ] [ ] mappedMatrix , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 1 ] = 1 ;"}
{"text":"For each cell","code":"for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) {"}
{"text":"If on the top row or leftmost column , there is no path there .","code":"if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ;"}
{"text":"If non prime number","code":"if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } System . out . println ( dp [ n ] [ m ] ) ; }"}
{"text":"Finding the matrix mapping by considering non prime number as obstacle and prime number be valid path .","code":"static void preprocessMatrix ( int [ ] [ ] mappedMatrix , int [ ] [ ] a , int n , int m ) {"}
{"text":"Sieve","code":"sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"If prime","code":"if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ;"}
{"text":"If non prime","code":"else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; int m = 3 ; int [ ] [ ] a = { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int [ ] [ ] mappedMatrix = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { mappedMatrix [ i ] [ j ] = 0 ; } } preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; } }"}
{"text":"A Dynamic Programming solution for subset sum problem + maximal subset value .","code":"class sumofSub {"}
{"text":"Returns size of maximum sized subset if there is a subset of set [ ] with sun equal to given sum . It returns - 1 if there is no subset with given sum .","code":"static int isSubsetSum ( int set [ ] , int n , int sum ) {"}
{"text":"The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i","code":"boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; int count [ ] [ ] = new int [ sum + 1 ] [ n + 1 ] ;"}
{"text":"If sum is 0 , then answer is true","code":"for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; }"}
{"text":"If sum is not 0 and set is empty , then answer is false","code":"for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; }"}
{"text":"Fill the subset table in bottom up manner","code":"for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String args [ ] ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = set . length ; System . out . println ( isSubsetSum ( set , n , sum ) ) ; } }"}
{"text":"Java program to find all LCS of two strings in sorted order .","code":"class GFG { static int MAX = 100 ;"}
{"text":"length of lcs","code":"static int lcslen = 0 ;"}
{"text":"dp matrix to store result of sub calls for lcs","code":"static int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;"}
{"text":"A memoization based function that returns LCS of str1 [ i . . len1 - 1 ] and str2 [ j . . len2 - 1 ]","code":"static int lcs ( String str1 , String str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i ] [ j ] ;"}
{"text":"base condition","code":"if ( i == len1 j == len2 ) return ret = 0 ;"}
{"text":"if lcs has been computed","code":"if ( ret != - 1 ) return ret ; ret = 0 ;"}
{"text":"if characters are same return previous + 1 else max of two sequences after removing i ' th \u2581 and \u2581 j ' th char one by one","code":"if ( str1 . charAt ( i ) == str2 . charAt ( j ) ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; }"}
{"text":"Function to print all routes common sub - sequences of length lcslen","code":"static void printAll ( String str1 , String str2 , int len1 , int len2 , char [ ] data , int indx1 , int indx2 , int currlcs ) {"}
{"text":"if currlcs is equal to lcslen then print it","code":"if ( currlcs == lcslen ) { data [ currlcs ] = ' \\0' ; System . out . println ( new String ( data ) ) ; return ; }"}
{"text":"if we are done with all the characters of both string","code":"if ( indx1 == len1 indx2 == len2 ) return ;"}
{"text":"here we have to print all sub - sequences lexicographically , that ' s \u2581 why \u2581 we \u2581 start \u2581 from \u2581 ' a ' to ' z ' if this character is  present in both of them then append it in data[] and same  remaining part","code":"for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) {"}
{"text":"done is a flag to tell that we have printed all the subsequences corresponding to current character","code":"boolean done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) {"}
{"text":"if character ch is present in str1 then check if it is present in str2","code":"if ( ch == str1 . charAt ( i ) ) { for ( int j = indx2 ; j < len2 ; j ++ ) {"}
{"text":"if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub - sequenece","code":"if ( ch == str2 . charAt ( j ) && dp [ i ] [ j ] == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } }"}
{"text":"If we found LCS beginning with current character .","code":"if ( done ) break ; } } }"}
{"text":"This function prints all LCS of str1 and str2 in lexicographic order .","code":"static void prinlAllLCSSorted ( String str1 , String str2 ) {"}
{"text":"Find lengths of both strings","code":"int len1 = str1 . length ( ) , len2 = str2 . length ( ) ;"}
{"text":"Find length of LCS","code":"for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ;"}
{"text":"Print all LCS using recursive backtracking data [ ] is used to store individual LCS .","code":"char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str1 = \" abcabcaa \" , str2 = \" acbacba \" ; prinlAllLCSSorted ( str1 , str2 ) ; } }"}
{"text":"Program to check for majority element in a sorted array","code":"import java . io . * ; class Majority { static boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ;"}
{"text":"get last index according to n ( even or odd )","code":"last_index = ( n % 2 == 0 ) ? n \/ 2 : n \/ 2 + 1 ;"}
{"text":"search for first occurrence of x in arr [ ]","code":"for ( i = 0 ; i < last_index ; i ++ ) {"}
{"text":"check if x is present and is present more than n \/ 2 times","code":"if ( arr [ i ] == x && arr [ i + n \/ 2 ] == x ) return true ; } return false ; }"}
{"text":"Driver function to check for above functions","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . length ; int x = 4 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + \" \u2581 appears \u2581 more \u2581 than \u2581 \" + n \/ 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; else System . out . println ( x + \" \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 \" + n \/ 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; } }"}
{"text":"Java Program to check for majority element in a sorted array","code":"import java . io . * ; class Majority {"}
{"text":"If x is present in arr [ low ... high ] then returns the index of first occurrence of x , otherwise returns - 1","code":"static int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) \/ 2 ;"}
{"text":"Check if arr [ mid ] is the first occurrence of x . arr [ mid ] is first occurrence if x is one of the following is true : ( i ) mid == 0 and arr [ mid ] = = x ( ii ) arr [ mid - 1 ] < x and arr [ mid ] == x","code":"if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }"}
{"text":"This function returns true if the x is present more than n \/ 2 times in arr [ ] of size n","code":"static boolean isMajority ( int arr [ ] , int n , int x ) {"}
{"text":"Find the index of first occurrence of x in arr [ ]","code":"int i = _binarySearch ( arr , 0 , n - 1 , x ) ;"}
{"text":"If element is not present at all , return false","code":"if ( i == - 1 ) return false ;"}
{"text":"check if the element is present more than n \/ 2 times","code":"if ( ( ( i + n \/ 2 ) <= ( n - 1 ) ) && arr [ i + n \/ 2 ] == x ) return true ; else return false ; }"}
{"text":"Driver function to check for above functions","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + \" \u2581 appears \u2581 more \u2581 than \u2581 \" + n \/ 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; else System . out . println ( x + \" \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 \" + n \/ 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) System . out . printf ( \" % d \u2581 appears \u2581 more \u2581 than \u2581 % d \u2581 \" + \" times \u2581 in \u2581 arr [ ] \" , x , n \/ 2 ) ; else System . out . printf ( \" % d \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 \" + \" than \u2581 % d \u2581 times \u2581 in \u2581 \" + \" arr [ ] \" , x , n \/ 2 ) ; } }"}
{"text":"A Dynamic Programming solution for Rod cutting problem","code":"class RodCutting {"}
{"text":"Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces","code":"static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ;"}
{"text":"Build the table val [ ] in bottom up manner and return the last entry from the table","code":"for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + cutRod ( arr , size ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to check if the arr [ ] can be converted to target [ ] by replacing any element in arr [ ] by the sum of arr [ ]","code":"public static boolean isPossible ( int [ ] target ) {"}
{"text":"Store the maximum element","code":"int max = 0 ;"}
{"text":"Store the index of the maximum element","code":"int index = 0 ;"}
{"text":"Traverse the array target [ ]","code":"for ( int i = 0 ; i < target . length ; i ++ ) {"}
{"text":"If current element is greater than max","code":"if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } }"}
{"text":"If max element is 1","code":"if ( max == 1 ) return true ;"}
{"text":"Traverse the array , target [ ]","code":"for ( int i = 0 ; i < target . length ; i ++ ) {"}
{"text":"If current index is not equal to maximum element index","code":"if ( i != index ) {"}
{"text":"Update max","code":"max -= target [ i ] ;"}
{"text":"If max is less than or equal to 0 ,","code":"if ( max <= 0 ) return false ; } }"}
{"text":"Update the maximum element","code":"target [ index ] = max ;"}
{"text":"Recursively call the function","code":"return isPossible ( target ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] target = { 9 , 3 , 5 } ; boolean res = isPossible ( target ) ; if ( res ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function returns nCr i . e . Binomial Coefficient","code":"static int nCr ( int n , int r ) {"}
{"text":"Initialize res with 1","code":"int res = 1 ;"}
{"text":"Since C ( n , r ) = C ( n , n - r )","code":"if ( r > n - r ) r = n - r ;"}
{"text":"Evaluating expression","code":"for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( nCr ( n + m , k ) ) ; } }"}
{"text":"Java program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if N can be obtained or not","code":"static void Is_possible ( long N ) { long C = 0 ; long D = 0 ;"}
{"text":"Count and remove trailing zeroes","code":"while ( N % 10 == 0 ) { N = N \/ 10 ; C += 1 ; }"}
{"text":"Check if remaining N is a power of 2","code":"if ( Math . pow ( 2 , ( long ) ( Math . log ( N ) \/ ( Math . log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . log ( N ) \/ ( Math . log ( 2 ) ) ) ;"}
{"text":"To check the condition to prlong YES or NO","code":"if ( C >= D ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } else System . out . print ( \" NO \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { long N = 2000000000000L ; Is_possible ( N ) ; } }"}
{"text":"Java program to find N - th term in the series","code":"class GFG {"}
{"text":"Function to find N - th term in the series","code":"static void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 ; findNthTerm ( N ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Iterative function to reverse digits of num","code":"static int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num \/ 10 ; }"}
{"text":"Return the reversed num","code":"return rev_num ; }"}
{"text":"Function to calculate sum of reverse all proper divisors","code":"static int divSum ( int num ) {"}
{"text":"Final result of summation of divisors","code":"int result = 0 ;"}
{"text":"Find all divisors of num","code":"for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) {"}
{"text":"If ' i ' is divisor of ' num '","code":"if ( num % i == 0 ) {"}
{"text":"If both divisors are same then add it only once else add both","code":"if ( i == ( num \/ i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num \/ i ) ) ; } }"}
{"text":"Add 1 to the result as 1 is also a divisor","code":"return ( result + 1 ) ; }"}
{"text":"Function to check if N is anti - perfect or not","code":"static boolean isAntiPerfect ( int n ) { return divSum ( n ) == n ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Number N","code":"int N = 244 ;"}
{"text":"Function Call","code":"if ( isAntiPerfect ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java implementation to print the N terms of the series whose three terms are given","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the series","code":"static void printSeries ( int n , int a , int b , int c ) { int d ;"}
{"text":"Generate the ith term and print it","code":"if ( n == 1 ) { System . out . print ( a + \" \u2581 \" ) ; return ; } if ( n == 2 ) { System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" ) ; return ; } System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" + c + \" \u2581 \" ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; System . out . print ( d + \" \u2581 \" ) ; a = b ; b = c ; c = d ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ;"}
{"text":"Function Call","code":"printSeries ( N , a , b , c ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to find diameter of BIT with N + 1 nodes","code":"static int diameter ( int n ) {"}
{"text":"L is size of subtree just before subtree in which N lies","code":"int L , H , templen ; L = 1 ;"}
{"text":"H is the height of subtree just before subtree in which N lies","code":"H = 0 ;"}
{"text":"Base Cases","code":"if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; }"}
{"text":"Size of subtree are power of 2","code":"while ( L * 2 <= n ) { L *= 2 ; H ++ ; }"}
{"text":"3 Cases as explained in Approach","code":"if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L \/ 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( diameter ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to find whether a ^ b is greater or c ^ d","code":"static void compareValues ( int a , int b , int c , int d ) {"}
{"text":"Find b * log ( a )","code":"double log1 = Math . log10 ( a ) ; double num1 = log1 * b ;"}
{"text":"Find d * log ( c )","code":"double log2 = Math . log10 ( c ) ; double num2 = log2 * d ;"}
{"text":"Compare both values","code":"if ( num1 > num2 ) System . out . println ( a + \" ^ \" + b ) ; else System . out . println ( c + \" ^ \" + d ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; } }"}
{"text":"Java program for above approach","code":"import java . util . * ; class GFG { static int MAX = 100005 ;"}
{"text":"Find all prime numbers","code":"static Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ;"}
{"text":"Store all prime numbers","code":"for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; }"}
{"text":"Function to check if a digit is odd prime or not","code":"static boolean is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; }"}
{"text":"Function to find sum","code":"static int find_Sum ( int n ) {"}
{"text":"To store required answer","code":"int sum = 0 ;"}
{"text":"Get all prime numbers","code":"Vector < Integer > v = addPrimes ( ) ;"}
{"text":"Traverse through all the prime numbers","code":"for ( int i = 0 ; i < v . size ( ) && n > 0 ; i ++ ) {"}
{"text":"Flag stores 1 if a number does not contain any odd primes","code":"int flag = 1 ; int a = v . get ( i ) ;"}
{"text":"Find all digits of a number","code":"while ( a != 0 ) { int d = a % 10 ; a = a \/ 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } }"}
{"text":"If number does not contain any odd primes","code":"if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } }"}
{"text":"Return the required answer","code":"return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 7 ;"}
{"text":"Function call","code":"System . out . println ( find_Sum ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"returns the max element","code":"static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; }"}
{"text":"Function to return the count of primes in the given array","code":"static int primeCount ( int arr [ ] , int n ) {"}
{"text":"Find maximum value in the array","code":"int max_val = max_element ( arr ) ;"}
{"text":"USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ;"}
{"text":"Remaining part of SIEVE","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } }"}
{"text":"Find all primes in arr [ ]","code":"int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; }"}
{"text":"Function to generate the prefix array","code":"static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) {"}
{"text":"Fill the prefix array","code":"pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ;"}
{"text":"Prefix array of arr [ ]","code":"int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ;"}
{"text":"Count of primes in the prefix array","code":"System . out . println ( primeCount ( pre , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . lang . Math ; class GFG {"}
{"text":"Function to return the required value that must be added to x so that it is at least y percent of n","code":"static int minValue ( int n , int x , int y ) {"}
{"text":"Required value","code":"float val = ( y * n ) \/ 100 ;"}
{"text":"If x is already >= y percent of n","code":"if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 , x = 2 , y = 40 ; System . out . println ( minValue ( n , x , y ) ) ; } }"}
{"text":"Java program to check if given number is a factorial prime","code":"class GFG {"}
{"text":"Utility function to check if a number is prime or not","code":"static boolean isPrime ( long n ) {"}
{"text":"Corner cases","code":"if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }"}
{"text":"Function that returns true if n is a factorial prime","code":"static boolean isFactorialPrime ( long n ) {"}
{"text":"If n is not prime then return false","code":"if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) {"}
{"text":"Calculate factorial","code":"fact = fact * i ;"}
{"text":"If n is a factorial prime","code":"if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; }"}
{"text":"n is not a factorial prime","code":"return false ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 23 ; if ( isFactorialPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to find number of ways in which n boys and n girls can sit alternatively sound a round table .","code":"import java . io . * ; class GFG {"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Get n","code":"long n = 5 ;"}
{"text":"find fac1 = ( n - 1 ) !","code":"long fac1 = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ;"}
{"text":"Find fac2 = n !","code":"long fac2 = fac1 * n ;"}
{"text":"Find total number of ways","code":"long totalWays = fac1 * fac2 ;"}
{"text":"Print the total number of ways","code":"System . out . println ( totalWays ) ; } }"}
{"text":"Java program to check Euclid Number","code":"import java . util . * ; class GFG { static final int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ;"}
{"text":"Function to get the prime numbers","code":"static void SieveOfEratosthenes ( ) {"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } }"}
{"text":"store all prime numbers to vector ' arr '","code":"for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; }"}
{"text":"Function to check the number for Euclid Number","code":"static boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) {"}
{"text":"Multiply next prime number and check if product + 1 = n holds or not","code":"product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Get the prime numbers","code":"SieveOfEratosthenes ( ) ;"}
{"text":"Get n","code":"long n = 31 ;"}
{"text":"Check if n is Euclid Number","code":"if ( isEuclid ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ;"}
{"text":"Get n","code":"n = 42 ;"}
{"text":"Check if n is Euclid Number","code":"if ( isEuclid ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function to find the next perfect cube","code":"static int nextPerfectCube ( int N ) { int nextN = ( int ) Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 35 ; System . out . print ( nextPerfectCube ( n ) ) ; } }"}
{"text":"Java program to find sum of prime divisors of N","code":"class GFG {"}
{"text":"Function to check if the number is prime or not .","code":"static boolean isPrime ( int n ) {"}
{"text":"Corner cases","code":"if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }"}
{"text":"Function to find sum of prime divisors of N","code":"static int SumOfPrimeDivisors ( int n ) { int sum = 0 ;"}
{"text":"Return type of sqrt function if float","code":"int root_n = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) {"}
{"text":"Both factors are same","code":"if ( i == n \/ i && isPrime ( i ) ) { sum += i ; } else {"}
{"text":"Both factors are not same ( i and n \/ i )","code":"if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n \/ i ) ) { sum += ( n \/ i ) ; } } } } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 60 ; System . out . println ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + SumOfPrimeDivisors ( n ) ) ; } }"}
{"text":"Java Program position of n among the numbers made of 2 , 3 , 5 & 7","code":"class GFG { static int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) {"}
{"text":"If number is 2 then it is on the position pos * 2 + 1","code":"case '2' : pos = pos * 4 + 1 ; break ;"}
{"text":"If number is 3 then it is on the position pos * 2 + 2","code":"case '3' : pos = pos * 4 + 2 ; break ;"}
{"text":"If number is 5 then it is on the position pos * 2 + 3","code":"case '5' : pos = pos * 4 + 3 ; break ;"}
{"text":"If number is 7 then it is on the position pos * 2 + 4","code":"case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String n = \"777\" ; System . out . println ( findpos ( n ) ) ; } }"}
{"text":"Java program to find a non transitive co - prime triplets between L and R","code":"import java . io . * ; class GFG {"}
{"text":"Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt","code":"static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ;"}
{"text":"Case 1 : Less than 3 numbers between L and R","code":"if ( numbersInRange < 3 ) { flag = false ; }"}
{"text":"Case 2 : More than 3 numbers between L and R","code":"else if ( numbersInRange > 3 ) { flag = true ;"}
{"text":"triplets should always be of form ( 2 k , 2 k + 1 , 2 k + 2 )","code":"if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else {"}
{"text":"Case 3.1 : Exactly 3 numbers in range of form ( 2 k , 2 k + 1 , 2 k + 2 )","code":"if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else {"}
{"text":"Case 3.2 : Exactly 3 numbers in range of form ( 2 k - 1 , 2 k , 2 k + 1 )","code":"flag = false ; } }"}
{"text":"flag = True indicates that a pair exists between L and R","code":"if ( flag == true ) { System . out . println ( \" ( \" + possibleA + \" , \u2581 \" + possibleB + \" , \u2581 \" + possibleC + \" ) \" + \" \u2581 is \u2581 one \u2581 such \u2581 possible \" + \" \u2581 triplet \u2581 between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } else { System . out . println ( \" No \u2581 Such \u2581 Triplet \" + \" \u2581 exists \u2581 between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int L , R ;"}
{"text":"finding possible Triplet between 2 and 10","code":"L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ;"}
{"text":"finding possible Triplet between 23 and 46","code":"L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }"}
{"text":"Java Implementation of above method","code":"import java . lang . * ; class GFG { static final int mod = 1000000007 ;"}
{"text":"Finding number of possible number with n digits excluding a particular digit","code":"static int digitNumber ( long n ) {"}
{"text":"Checking if number of digits is zero","code":"if ( n == 0 ) return 1 ;"}
{"text":"Checking if number of digits is one","code":"if ( n == 1 ) return 9 ;"}
{"text":"Checking if number of digits is odd","code":"if ( n % 2 != 0 ) {"}
{"text":"Calling digitNumber function with ( digit - 1 ) \/ 2 digits","code":"int temp = digitNumber ( ( n - 1 ) \/ 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else {"}
{"text":"Calling digitNumber function with n \/ 2 digits","code":"int temp = digitNumber ( n \/ 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) {"}
{"text":"Calling digitNumber function Checking if excluding digit is zero or non - zero","code":"if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; }"}
{"text":"Driver function to run above program","code":"public static void main ( String [ ] args ) {"}
{"text":"Initializing variables","code":"int d = 9 ; int n = 3 ; System . out . println ( countExcluding ( n , d ) ) ; } }"}
{"text":"Java program to check if given number is Emirp or not .","code":"import java . io . * ; class Emirp {"}
{"text":"Returns true if n is prime . Else false .","code":"public static boolean isPrime ( int n ) {"}
{"text":"Corner case","code":"if ( n <= 1 ) return false ;"}
{"text":"Check from 2 to n - 1","code":"for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }"}
{"text":"Function will check whether number is Emirp or not","code":"public static boolean isEmirp ( int n ) {"}
{"text":"Check if n is prime","code":"if ( isPrime ( n ) == false ) return false ;"}
{"text":"Find reverse of n","code":"int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n \/= 10 ; }"}
{"text":"If both Original and Reverse are Prime , then it is an Emirp number","code":"return isPrime ( rev ) ; }"}
{"text":"Driver Function","code":"public static void main ( String args [ ] ) throws IOException {"}
{"text":"Input number","code":"int n = 13 ; if ( isEmirp ( n ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java code to convert radian to degree","code":"import java . io . * ; class GFG {"}
{"text":"Function for convertion","code":"static double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 \/ pi ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { double radian = 5.0 ; double degree = Convert ( radian ) ; System . out . println ( \" degree \u2581 = \u2581 \" + degree ) ; } }"}
{"text":"Java program to find trace of matrix formed by adding Row - major and Column - major order of same matrix","code":"import java . io . * ; public class GFG {"}
{"text":"Return sum of first n integers of an AP","code":"static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) \/ 2 ; }"}
{"text":"Return the trace of sum of row - major matrix and column - major matrix","code":"static int trace ( int n , int m ) {"}
{"text":"Finding nth element in AP in case of Row major matrix .","code":"int an = 1 + ( n - 1 ) * ( m + 1 ) ;"}
{"text":"Finding sum of first n integers of AP in case of Row major matrix","code":"int rowmajorSum = sn ( n , an ) ;"}
{"text":"Finding nth element in AP in case of Row major matrix","code":"an = 1 + ( n - 1 ) * ( n + 1 ) ;"}
{"text":"Finding sum of first n integers of AP in case of Column major matrix","code":"int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; }"}
{"text":"Driven Program","code":"static public void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }"}
{"text":"Java code for Maximum of smallest possible area that can get with exactly k cut of given rectangular","code":"class GFG {"}
{"text":"Utility Function","code":"static void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( \" Not \u2581 possible \" ) ; else { int result ;"}
{"text":"for the 1 st case","code":"if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n \/ ( k + 1 ) ) , n * ( m \/ ( k + 1 ) ) ) ; }"}
{"text":"for the second case","code":"else { result = Math . max ( m \/ ( k - n + 2 ) , n \/ ( k - m + 2 ) ) ; }"}
{"text":"print final result","code":"System . out . println ( result ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; } }"}
{"text":"Java program to find the area of a square","code":"class GFG {"}
{"text":"function to find the area","code":"static int area_fun ( int side ) { int area = side * side ; return area ; }"}
{"text":"Driver code","code":"public static void main ( String arg [ ] ) { int side = 4 ; int area = area_fun ( side ) ; System . out . println ( area ) ; } }"}
{"text":"A Java program to count number of ways to express N as sum of consecutive numbers .","code":"public class SumConsecutiveNumber {"}
{"text":"Utility method to compute number of ways in which N can be represented as sum of consecutive number","code":"static int countConsecutive ( int N ) {"}
{"text":"constraint on values of L gives us the time Complexity as O ( N ^ 0.5 )","code":"int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) \/ 2 ) \/ ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }"}
{"text":"Driver code to test above function","code":"public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countConsecutive ( N ) ) ; N = 10 ; System . out . println ( countConsecutive ( N ) ) ; } }"}
{"text":"Java program to check if a number is Authomorphic","code":"class Test {"}
{"text":"Function to check Automorphic number","code":"static boolean isAutomorphic ( int N ) {"}
{"text":"Store the square","code":"int sq = N * N ;"}
{"text":"Start Comparing digits","code":"while ( N > 0 ) {"}
{"text":"Return false , if any digit of N doesn ' t \u2581 \u2581 match \u2581 with \u2581 its \u2581 square ' s digits from last","code":"if ( N % 10 != sq % 10 ) return false ;"}
{"text":"Reduce N and square","code":"N \/= 10 ; sq \/= 10 ; } return true ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( isAutomorphic ( N ) ? \" Automorphic \" : \" Not \u2581 Automorphic \" ) ; } }"}
{"text":"Java program to find integer having maximum number of prime factor in first N natural numbers","code":"import java . util . Vector ; public class GFG {"}
{"text":"Return smallest number having maximum prime factors .","code":"static int maxPrimefactorNum ( int N ) {"}
{"text":"default value of boolean is false","code":"boolean arr [ ] = new boolean [ N + 5 ] ;"}
{"text":"Sieve of eratosthenes","code":"for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } }"}
{"text":"Storing prime numbers .","code":"Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } }"}
{"text":"Generating number having maximum prime factors .","code":"int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }"}
{"text":"Java program to find highest power of 2 smaller than or equal to n .","code":"import java . io . * ; class GFG { static int highestPowerof2 ( int x ) {"}
{"text":"check for the set bits","code":"x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ;"}
{"text":"Then we remove all but the top bit by xor ' ing \u2581 the \u2581 \u2581 string \u2581 of \u2581 1' s with that string of 1 ' s \u2581 shifted \u2581 one \u2581 to \u2581 \u2581 the \u2581 left , \u2581 and \u2581 we \u2581 end \u2581 up \u2581 with \u2581 just \u2581 the \u2581 one \u2581 top \u2581 bit \u2581 \u2581 followed \u2581 by \u2581 0' s .","code":"return x ^ ( x >> 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }"}
{"text":"JAVA program to find sum of all divisors of a natural number","code":"import java . math . * ; class GFG {"}
{"text":"Function to calculate sum of all proper divisors num -- > given natural number","code":"static int divSum ( int num ) {"}
{"text":"Final result of summation of divisors","code":"int result = 0 ;"}
{"text":"find all divisors which divides ' num '","code":"for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) {"}
{"text":"if ' i ' is divisor of ' num '","code":"if ( num % i == 0 ) {"}
{"text":"if both divisors are same then add it only once else add both","code":"if ( i == ( num \/ i ) ) result += i ; else result += ( i + num \/ i ) ; } }"}
{"text":"Add 1 to the result as 1 is also a divisor","code":"return ( result + 1 ) ; }"}
{"text":"Driver program to run the case","code":"public static void main ( String [ ] args ) { int num = 36 ; System . out . println ( divSum ( num ) ) ; } }"}
{"text":"An efficient Java program to find square root under modulo p when p is 7 , 11 , 19 , 23 , 31 , ... etc .","code":"public class GFG {"}
{"text":"Utility function to do modular exponentiation . It returns ( x ^ y ) % p .","code":"static int power ( int x , int y , int p ) {"}
{"text":"int res = 1 ; Initialize result x = x % p ; Update x if it is more than or equal to p","code":"while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with result","code":"if ( y % 2 == 1 ) res = ( res * x ) % p ;"}
{"text":"y must be even now y = y >> 1 ; y = y \/ 2","code":"x = ( x * x ) % p ; } return res ; }"}
{"text":"Returns true if square root of n under modulo p exists Assumption : p is of the form 3 * i + 4 where i >= 1","code":"static void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { System . out . print ( \" Invalid \u2581 Input \" ) ; return ; }"}
{"text":"Try \" + ( n ^ ( ( p \u2581 + \u2581 1 ) \/ 4 ) ) \"","code":"n = n % p ; int x = power ( n , ( p + 1 ) \/ 4 , p ) ; if ( ( x * x ) % p == n ) { System . out . print ( \" Square \u2581 root \u2581 is \u2581 \" + x ) ; return ; }"}
{"text":"Try \" - ( n \u2581 ^ \u2581 ( ( p \u2581 + \u2581 1 ) \/ 4 ) ) \"","code":"x = p - x ; if ( ( x * x ) % p == n ) { System . out . print ( \" Square \u2581 root \u2581 is \u2581 \" + x ) ; return ; }"}
{"text":"If none of the above two work , then square root doesn 't exist","code":"System . out . print ( \" Square \u2581 root \u2581 doesn ' t \u2581 exist \u2581 \" ) ; }"}
{"text":"Driver program to test","code":"static public void main ( String [ ] args ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; } }"}
{"text":"Java program Miller - Rabin primality test","code":"import java . io . * ; import java . math . * ; class GFG {"}
{"text":"Utility function to do modular exponentiation . It returns ( x ^ y ) % p","code":"static int power ( int x , int y , int p ) {"}
{"text":"Initialize result","code":"int res = 1 ;"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p ; while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with result","code":"if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;"}
{"text":"y must be even now y = y >> 1 ; y = y \/ 2","code":"x = ( x * x ) % p ; } return res ; }"}
{"text":"This function is called for all k trials . It returns false if n is composite and returns false if n is probably prime . d is an odd number such that d * 2 < sup > r < \/ sup > = n - 1 for some r >= 1","code":"static boolean miillerTest ( int d , int n ) {"}
{"text":"Pick a random number in [ 2. . n - 2 ] Corner cases make sure that n > 4","code":"int a = 2 + ( int ) ( Math . random ( ) % ( n - 4 ) ) ;"}
{"text":"Compute a ^ d % n","code":"int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ;"}
{"text":"Keep squaring x while one of the following doesn 't happen  (i) d does not reach n-1  (ii) (x^2) % n is not 1  (iii) (x^2) % n is not n-1","code":"while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; }"}
{"text":"Return composite","code":"return false ; }"}
{"text":"It returns false if n is composite and returns true if n is probably prime . k is an input parameter that determines accuracy level . Higher value of k indicates more accuracy .","code":"static boolean isPrime ( int n , int k ) {"}
{"text":"Corner cases","code":"if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ;"}
{"text":"Find r such that n = 2 ^ d * r + 1 for some r >= 1","code":"int d = n - 1 ; while ( d % 2 == 0 ) d \/= 2 ;"}
{"text":"Iterate given nber of ' k ' times","code":"for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { int k = 4 ; System . out . println ( \" All \u2581 primes \u2581 smaller \u2581 \" + \" than \u2581 100 : \u2581 \" ) ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) System . out . print ( n + \" \u2581 \" ) ; } }"}
{"text":"Java program to find length of the longest consecutive 1 s in binary representation of a number .","code":"class MaxConsecutiveOnes {"}
{"text":"Function to find length of the longest consecutive 1 s in binary representation of a number","code":"private static int maxConsecutiveOnes ( int x ) {"}
{"text":"Initialize result","code":"int count = 0 ;"}
{"text":"Count the number of iterations to reach x = 0.","code":"while ( x != 0 ) {"}
{"text":"This operation reduces length of every sequence of 1 s by one .","code":"x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String strings [ ] ) { System . out . println ( maxConsecutiveOnes ( 14 ) ) ; System . out . println ( maxConsecutiveOnes ( 222 ) ) ; } }"}
{"text":"Java Program to subtract two Number without using arithmetic operator","code":"import java . io . * ; class GFG { static int subtract ( int x , int y ) {"}
{"text":"Iterate till there is no carry","code":"while ( y != 0 ) {"}
{"text":"borrow contains common set bits of y and unset bits of x","code":"int borrow = ( ~ x ) & y ;"}
{"text":"Subtraction of bits of x and y where at least one of the bits is not set","code":"x = x ^ y ;"}
{"text":"Borrow is shifted by one so that subtracting it from x gives the required sum","code":"y = borrow << 1 ; } return x ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . println ( \" x \u2581 - \u2581 y \u2581 is \u2581 \" + subtract ( x , y ) ) ; } }"}
{"text":"Java Program to subtract two Number without using arithmetic operator Recursive implementation .","code":"class GFG { static int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . printf ( \" x \u2581 - \u2581 y \u2581 is \u2581 % d \" , subtract ( x , y ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to add an edge in the tree","code":"static void addEdge ( Vector < Integer > v [ ] , int x , int y ) { v [ x ] . add ( y ) ; v [ y ] . add ( x ) ; }"}
{"text":"DFS to find the Kth ancestor of every node","code":"static void dfs ( Vector < Integer > tree [ ] , Vector < Integer > temp , int ancestor [ ] , int u , int parent , int k ) {"}
{"text":"Pushing current node in the vector","code":"temp . add ( u ) ;"}
{"text":"Traverse its neighbors","code":"for ( int i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . remove ( temp . size ( ) - 1 ) ;"}
{"text":"If K ancestors are not found for current node","code":"if ( temp . size ( ) < k ) { ancestor [ u ] = - 1 ; } else {"}
{"text":"Add the Kth ancestor for the node","code":"ancestor [ u ] = temp . get ( temp . size ( ) - k ) ; } }"}
{"text":"Function to find Kth ancestor of each node","code":"static void KthAncestor ( int N , int K , int E , int edges [ ] [ ] ) {"}
{"text":"Building the tree","code":"@ SuppressWarnings ( \" unchecked \" ) Vector < Integer > [ ] tree = new Vector [ N + 1 ] ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; }"}
{"text":"Stores all parents of a node","code":"Vector < Integer > temp = new Vector < Integer > ( ) ;"}
{"text":"Store Kth ancestor of all nodes","code":"int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ;"}
{"text":"Print the ancestors","code":"for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( ancestor [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N and K","code":"int N = 9 ; int K = 2 ;"}
{"text":"Given edges of n - ary tree","code":"int E = 8 ; int edges [ ] [ ] = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ;"}
{"text":"Function call","code":"KthAncestor ( N , K , E , edges ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to build a segment tree","code":"static void build ( Vector < Integer > sum , Vector < Integer > a , int l , int r , int rt ) {"}
{"text":"Check for base case","code":"if ( l == r ) { sum . set ( rt , a . get ( l - 1 ) ) ; return ; }"}
{"text":"Find mid point","code":"int m = ( l + r ) >> 1 ;"}
{"text":"Recursively build the segment tree","code":"build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; }"}
{"text":"Function for push down operation on the segment tree","code":"static void pushDown ( Vector < Integer > sum , Vector < Integer > add , int rt , int ln , int rn ) { if ( add . get ( rt ) != 0 ) { add . set ( rt << 1 , add . get ( rt ) ) ; add . set ( rt << 1 | 1 , add . get ( rt ) ) ; sum . set ( rt << 1 , sum . get ( rt << 1 ) + add . get ( rt ) * ln ) ; sum . set ( rt << 1 | 1 , sum . get ( rt << 1 1 ) + add . get ( rt ) * rn ) ; add . set ( rt , 0 ) ; } }"}
{"text":"Function to update the segment tree","code":"static void update ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int C , int l , int r , int rt ) {"}
{"text":"Complete overlap","code":"if ( L <= l && r <= R ) { sum . set ( rt , sum . get ( rt ) + C * ( r - l + 1 ) ) ; add . set ( rt , add . get ( rt ) + C ) ; return ; }"}
{"text":"Find mid","code":"int m = ( l + r ) >> 1 ;"}
{"text":"Perform push down operation on segment tree","code":"pushDown ( sum , add , rt , m - l + 1 , r - m ) ;"}
{"text":"Recursively update the segment tree","code":"if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } }"}
{"text":"Function to process the query","code":"static int query ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int l , int r , int rt ) {"}
{"text":"Base case","code":"if ( L <= l && r <= R ) { return sum . get ( rt ) ; }"}
{"text":"Find mid","code":"int m = ( l + r ) >> 1 ;"}
{"text":"Perform push down operation on segment tree","code":"pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ;"}
{"text":"Recursively calculate the result of the query","code":"if ( L <= m ) { ans += query ( sum , add , L , R , l , m , rt << 1 ) ; } if ( R > m ) { ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; }"}
{"text":"Return the result","code":"return ans ; }"}
{"text":"Function to count the numbers which are greater than the given query","code":"static void sequenceMaintenance ( int n , int q , Vector < Integer > a , Vector < Integer > b , int m ) {"}
{"text":"Sort the input array","code":"Collections . sort ( a ) ;"}
{"text":"Create segment tree of size 4 * n","code":"Vector < Integer > sum = new Vector < Integer > ( ) ; Vector < Integer > ad = new Vector < Integer > ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . add ( 0 ) ; ad . add ( 0 ) ; }"}
{"text":"Build the segment tree","code":"build ( sum , a , 1 , n , 1 ) ;"}
{"text":"Iterate over the queries","code":"for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b . get ( i ) ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . add ( 0 ) ; } else {"}
{"text":"Store result in array","code":"ans . add ( n - pos + 1 ) ;"}
{"text":"Update the elements in the given range","code":"update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } }"}
{"text":"Print the result of queries","code":"for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 ; int Q = 3 ; int M = 1 ; Vector < Integer > arr = new Vector < Integer > ( ) ; arr . add ( 1 ) ; arr . add ( 2 ) ; arr . add ( 3 ) ; arr . add ( 4 ) ; Vector < Integer > query = new Vector < Integer > ( ) ; query . add ( 4 ) ; query . add ( 3 ) ; query . add ( 1 ) ;"}
{"text":"Function call","code":"sequenceMaintenance ( N , Q , arr , query , M ) ; } }"}
{"text":"Java Program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Recursive function to return gcd of a and b","code":"static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }"}
{"text":"Function to find the final array length by replacing coprime pair with 1","code":"static boolean hasCoprimePair ( int [ ] arr , int n ) {"}
{"text":"Iterate over all pairs of element","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {"}
{"text":"Check if gcd is 1","code":"if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } }"}
{"text":"If no coprime pair found return false","code":"return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; int [ ] arr = { 6 , 9 , 15 } ;"}
{"text":"Check if atleast one coprime pair exists in the array","code":"if ( hasCoprimePair ( arr , n ) ) { System . out . print ( 1 + \"NEW_LINE\"); }"}
{"text":"If no such pair exists","code":"else { System . out . print ( n + \"NEW_LINE\"); } } }"}
{"text":"Java Program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to return the required number of ways","code":"static int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 0 ; b < n ; b ++ ) { int c = n - ( a + b ) ;"}
{"text":"Check if a , b , c can form a triangle","code":"if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } }"}
{"text":"Return number of ways","code":"return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( Numberofways ( n ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the count of pair","code":"static void countPairs ( int N , int [ ] arr ) { int count = 0 ;"}
{"text":"Iterate over all the elements of the array","code":"for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) {"}
{"text":"Increment the count","code":"count ++ ; } }"}
{"text":"Print the result","code":"System . out . println ( count \/ 2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 } ; int N = arr . length ; countPairs ( N , arr ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; public class GFG {"}
{"text":"Function to return the max Length of Fibonacci subsequence","code":"static int LongestFibSubseq ( int A [ ] , int n ) {"}
{"text":"Store all array elements in a hash table","code":"TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ;"}
{"text":"check until next fib element is found","code":"while ( S . contains ( y ) && ( y != S . last ( ) ) ) {"}
{"text":"next element of fib subseq","code":"int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . length ; System . out . print ( LongestFibSubseq ( A , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . Arrays ; public class GFG {"}
{"text":"Function to count maximum number of elements that can be selected","code":"static int CountMaximum ( int arr [ ] , int n , int k ) {"}
{"text":"Sorting the array","code":"Arrays . sort ( arr ) ; int sum = 0 , count = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Add the current element to the sum","code":"sum += arr [ i ] ;"}
{"text":"If sum exceeds k","code":"if ( sum > k ) break ;"}
{"text":"Increment count","code":"count ++ ; }"}
{"text":"Returning the count","code":"return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ;"}
{"text":"Function call","code":"System . out . println ( CountMaximum ( arr , n , k ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find number of candy types","code":"public static int num_candyTypes ( int [ ] candies ) {"}
{"text":"Declare a hashset to store candies","code":"Dictionary < Integer , Integer > s = new Hashtable < Integer , Integer > ( ) ;"}
{"text":"Traverse the given array and inserts element into set","code":"for ( int i = 0 ; i < candies . length ; i ++ ) { s . put ( candies [ i ] , 1 ) ; }"}
{"text":"Return the result","code":"return s . size ( ) ; }"}
{"text":"Function to find maximum number of types of candies a person can eat","code":"public static void distribute_candies ( int [ ] candies ) {"}
{"text":"Store the number of candies allowed to eat","code":"int allowed = candies . length \/ 2 ;"}
{"text":"Store the number of candy types","code":"int types = num_candyTypes ( candies ) ;"}
{"text":"Return the result","code":"if ( types < allowed ) System . out . println ( types ) ; else System . out . println ( allowed ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"int candies [ ] = { 4 , 4 , 5 , 5 , 3 , 3 } ;"}
{"text":"Function Call","code":"distribute_candies ( candies ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle","code":"static double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI \/ 180 ) ) ) ) ; double q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI \/ 180 ) ) ) ) ; return new double [ ] { p , q } ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; System . out . printf ( \" % .2f \" + \" \u2581 \" + \" % .2f \" , ans [ 0 ] , ans [ 1 ] ) ; } }"}
{"text":"Java program to count the set bits after taking XOR with a number K","code":"class GFG {"}
{"text":"Function to get no of set bits in binary representation of positive integer n","code":"static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }"}
{"text":"Function to store EVEN and odd variable","code":"static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ;"}
{"text":"Store the count of even and odd set bit","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Count the set bit using in built function","code":"int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ;"}
{"text":"Count of set - bit of K","code":"y = __builtin_popcount ( K ) ;"}
{"text":"If y is odd then , count of even and odd set bit will be interchanged","code":"if ( ( y & 1 ) != 0 ) { System . out . println ( \" Even \u2581 = \u2581 \" + odd + \" , \u2581 Odd \u2581 = \u2581 \" + even ) ; }"}
{"text":"Else it will remain same as the original array","code":"else { System . out . println ( \" Even \u2581 = \u2581 \" + even + \" , \u2581 Odd \u2581 = \u2581 \" + odd ) ; } }"}
{"text":"Driver 's Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ;"}
{"text":"Function call to count even and odd","code":"countEvenOdd ( arr , n , K ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int N = 6 ; int Even = N \/ 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing","code":"public static Integer longestSubSequence ( int [ ] [ ] A , int N , int ind , int lastf , int lasts ) { ind = ( ind > 0 ? ind : 0 ) ; lastf = ( lastf > 0 ? lastf : Integer . MIN_VALUE ) ; lasts = ( lasts > 0 ? lasts : Integer . MAX_VALUE ) ;"}
{"text":"Base case","code":"if ( ind == N ) return 0 ;"}
{"text":"Not include the current pair in the longest subsequence","code":"int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ;"}
{"text":"Including the current pair in the longest subsequence","code":"if ( A [ ind ] [ 0 ] > lastf && A [ ind ] [ 1 ] < lasts ) ans = Math . max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) ; return ans ; }"}
{"text":"Function","code":"public static int longestSubSequence ( int [ ] [ ] A , int N ) { return longestSubSequence ( A , N , 0 , 0 , 0 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given Input","code":"int [ ] [ ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . length ;"}
{"text":"Function Call","code":"System . out . println ( longestSubSequence ( A , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the number of triplets whose Bitwise AND is 0.","code":"static int countTriplets ( int [ ] A ) {"}
{"text":"Stores the count of triplets having bitwise AND equal to 0","code":"int cnt = 0 ;"}
{"text":"Stores frequencies of all possible A [ i ] & A [ j ]","code":"HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Traverse the array","code":"for ( int a : A )"}
{"text":"Update frequency of Bitwise AND of all array elements with a","code":"for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; }"}
{"text":"Traverse the array","code":"for ( int a : A )"}
{"text":"Iterate the map","code":"for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) )"}
{"text":"If bitwise AND of triplet is zero , increment cnt","code":"if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ;"}
{"text":"Return the number of triplets whose Bitwise AND is 0.","code":"return cnt ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input Array","code":"int [ ] A = { 2 , 1 , 3 } ;"}
{"text":"Function Call","code":"System . out . print ( countTriplets ( A ) ) ; } }"}
{"text":"Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed","code":"import java . util . Arrays ; class GfG { static int CountWays ( int n ) {"}
{"text":"noOfWays [ i ] will store count for value i . 3 extra values are to take care of cornser case n = 0","code":"int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ;"}
{"text":"Loop till \" n + 1\" to compute value for \" n \"","code":"for ( int i = 3 ; i < n + 1 ; i ++ ) {"}
{"text":"number of ways if first run is 1","code":"noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }"}
{"text":"Create row and col to traverse rows and columns","code":"int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ;"}
{"text":"Variable to determine the movement r = right , l = left , d = down , u = upper","code":"char move = ' r ' ;"}
{"text":"Array for matrix","code":"int matrix [ ] [ ] = new int [ size ] [ size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) {"}
{"text":"Assign the value","code":"matrix [ row ] [ col ] = i ;"}
{"text":"switch - case to determine the next index","code":"switch ( move ) {"}
{"text":"If right , go right","code":"case ' r ' : col += 1 ; break ;"}
{"text":"if left , go left","code":"case ' l ' : col -= 1 ; break ;"}
{"text":"if up , go up","code":"case ' u ' : row -= 1 ; break ;"}
{"text":"if down , go down","code":"case ' d ' : row += 1 ; break ; }"}
{"text":"Check if the matrix has reached array boundary","code":"if ( i == boundary ) {"}
{"text":"Add the left size for the next boundary","code":"boundary += sizeLeft ;"}
{"text":"If 2 rotations has been made , decrease the size left by 1","code":"if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; }"}
{"text":"switch - case to rotate the movement","code":"switch ( move ) {"}
{"text":"if right , rotate to down","code":"case ' r ' : move = ' d ' ; break ;"}
{"text":"if down , rotate to left","code":"case ' d ' : move = ' l ' ; break ;"}
{"text":"if left , rotate to up","code":"case ' l ' : move = ' u ' ; break ;"}
{"text":"if up , rotate to right","code":"case ' u ' : move = ' r ' ; break ; } } }"}
{"text":"Print the matrix","code":"for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; System . out . print ( ( n < 10 ) ? ( n + \" \u2581 \" ) : ( n + \" \u2581 \" ) ) ; } System . out . println ( ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Get the size of size","code":"int size = 5 ;"}
{"text":"Print the Spiral Pattern","code":"printSpiral ( size ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class GFG {"}
{"text":"Function to check if player A wins the game or not","code":"static void findWinner ( String a , int n ) {"}
{"text":"Stores size of the groups of 0 s","code":"Vector < Integer > v = new Vector < Integer > ( ) ;"}
{"text":"Stores size of the group of 0 s","code":"int c = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Increment c by 1 if a [ i ] is 0","code":"if ( a . charAt ( i ) == '0' ) { c ++ ; }"}
{"text":"Otherwise , push the size in array and reset c to 0","code":"else { if ( c != 0 ) v . add ( c ) ; c = 0 ; } } if ( c != 0 ) v . add ( c ) ;"}
{"text":"If there is no substring of odd length consisting only of 0 s","code":"if ( v . size ( ) == 0 ) { System . out . print ( \" Player \u2581 B \" ) ; return ; }"}
{"text":"If there is only 1 substring of odd length consisting only of 0 s","code":"if ( v . size ( ) == 1 ) { if ( ( v . get ( 0 ) & 1 ) != 0 ) System . out . print ( \" Player \u2581 A \" ) ;"}
{"text":"Otherwise","code":"else System . out . print ( \" Player \u2581 B \" ) ; return ; }"}
{"text":"Stores the size of the largest and second largest substrings of 0 s","code":"int first = Integer . MIN_VALUE ; int second = Integer . MIN_VALUE ;"}
{"text":"Traverse the array v [ ]","code":"for ( int i = 0 ; i < v . size ( ) ; i ++ ) {"}
{"text":"If current element is greater than first , then update both first and second","code":"if ( a . charAt ( i ) > first ) { second = first ; first = a . charAt ( i ) ; }"}
{"text":"If arr [ i ] is in between first and second , then update second","code":"else if ( a . charAt ( i ) > second && a . charAt ( i ) != first ) second = a . charAt ( i ) ; }"}
{"text":"If the condition is satisfied","code":"if ( ( first & 1 ) != 0 && ( first + 1 ) \/ 2 > second ) System . out . print ( \" Player \u2581 A \" ) ; else System . out . print ( \" Player \u2581 B \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String S = \"1100011\" ; int N = S . length ( ) ; findWinner ( S , N ) ; } }"}
{"text":"Java program to check whether the string is K palindrome or not","code":"import java . util . * ; class GFG {"}
{"text":"Function to check whether the string is K palindrome or not","code":"static boolean can_Construct ( String S , int K ) {"}
{"text":"Map to frequency of character","code":"Map < Character , Integer > m = new HashMap < > ( ) ; int p = 0 ;"}
{"text":"Check when k is given as same as length of string","code":"if ( S . length ( ) == K ) return true ;"}
{"text":"Storing the frequency of every character in map","code":"for ( int i = 0 ; i < S . length ( ) ; i ++ ) m . put ( S . charAt ( i ) , m . getOrDefault ( S . charAt ( i ) , 0 ) + 1 ) ;"}
{"text":"If K is greater than size of then return false","code":"if ( K > S . length ( ) ) return false ; else {"}
{"text":"Check that number of character having the odd frequency","code":"for ( Integer h : m . values ( ) ) { if ( h % 2 != 0 ) p = p + 1 ; } }"}
{"text":"If k is less than number of odd frequency character then it is again false otherwise true","code":"if ( K < p ) return false ; return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" annabelle \" ; int K = 4 ; if ( can_Construct ( S , K ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"A Java Program to find the longest common prefix","code":"class GFG {"}
{"text":"Function to compare two strings ignoring their cases","code":"static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ;"}
{"text":"Convert to lowercase using toLowerCase function","code":"str1 = str1 . toLowerCase ( ) ; str2 = str2 . toLowerCase ( ) ;"}
{"text":"Comparing both using inbuilt function","code":"int x = str1 . compareTo ( str2 ) ;"}
{"text":"if strings are equal , return true otherwise false","code":"return x == 0 ; }"}
{"text":"Function to print the same or not same if strings are equal or not equal","code":"static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) System . out . println ( \" Same \" ) ; else System . out . println ( \" Not \u2581 Same \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text":"Java Program to print Step Pattern","code":"import java . util . * ; class solution {"}
{"text":"function to print the steps","code":"static void steps ( String str , int n ) {"}
{"text":"declare a flag","code":"boolean flag = false ; int x = 0 ;"}
{"text":"traverse through all the characters in the string","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"if the x value is 0. . then we must increment till n ... set flag to true","code":"if ( x == 0 ) flag = true ;"}
{"text":"if the x value is n - 1 then we must decrement till 0 ... set flag as false","code":"if ( x == n - 1 ) flag = false ;"}
{"text":"print x * s","code":"for ( int j = 0 ; j < x ; j ++ ) System . out . print ( \" * \" ) ; System . out . print ( str . charAt ( i ) + \"NEW_LINE\");"}
{"text":"checking whether to increment or decrement x","code":"if ( flag == true ) x ++ ; else x -- ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"Get the String and the number n","code":"int n = 4 ; String str = \" GeeksForGeeks \" ; System . out . println ( \" String : \u2581 \" + str ) ; System . out . println ( \" Max \u2581 Length \u2581 of \u2581 Steps : \u2581 \" + n ) ;"}
{"text":"calling the function","code":"steps ( str , n ) ; } }"}
{"text":"Java program to count frequencies of array items","code":"import java . util . * ; class GFG { static void countFreq ( int arr [ ] , int n ) {"}
{"text":"Mark all array elements as not visited","code":"boolean [ ] visited = new boolean [ n ] ;"}
{"text":"Traverse through array elements and count frequencies","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Skip this element if already processed","code":"if ( visited [ i ] == true ) continue ;"}
{"text":"Count frequency","code":"int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } System . out . println ( arr [ i ] + \" \u2581 \" + count ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = arr . length ; countFreq ( arr , n ) ; } }"}
{"text":"Java implementation to check whether given binary number is evenly divisible by 2 ^ k or not","code":"class GFG {"}
{"text":"function to check whether given binary number is evenly divisible by 2 ^ k or not","code":"static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ;"}
{"text":"count of number of 0 from last","code":"for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ;"}
{"text":"if count = k , number is evenly divisible , so returns true else false","code":"return ( c == k ) ; }"}
{"text":"Driver program to test above","code":"public static void main ( String args [ ] ) {"}
{"text":"first example","code":"String str1 = \"10101100\" ; int k = 2 ; if ( isDivisible ( str1 , k ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;"}
{"text":"Second example","code":"String str2 = \"111010100\" ; k = 2 ; if ( isDivisible ( str2 , k ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to Check if any anagram of a string is palindrome or not","code":"public class GFG { static final int NO_OF_CHARS = 256 ;"}
{"text":"function to check whether characters of a string can form a palindrome","code":"static boolean canFormPalindrome ( String str ) {"}
{"text":"Create a count array and initialize all values as 0","code":"int [ ] count = new int [ NO_OF_CHARS ] ;"}
{"text":"For each character in input strings , increment count in the corresponding count array","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ;"}
{"text":"Count odd occurring characters","code":"int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; }"}
{"text":"Return true if odd count is 0 or 1 ,","code":"return true ; }"}
{"text":"Driver program to test to print printDups","code":"public static void main ( String args [ ] ) { System . out . println ( canFormPalindrome ( \" geeksforgeeks \" ) ? \" Yes \" : \" No \" ) ; System . out . println ( canFormPalindrome ( \" geeksogeeks \" ) ? \" Yes \" : \" No \" ) ; } }"}
{"text":"Java program to check if a given string is a valid integer","code":"import java . io . * ; public class GFG {"}
{"text":"Returns true if s is a number else false","code":"static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ; return true ; }"}
{"text":"Driver code","code":"static public void main ( String [ ] args ) {"}
{"text":"Saving the input in a string","code":"String str = \"6790\" ;"}
{"text":"Function returns 1 if all elements are in range '0 \u2581 - \u2581 9'","code":"if ( isNumber ( str ) ) System . out . println ( \" Integer \" ) ;"}
{"text":"Function returns 0 if the input is not an integer","code":"else System . out . println ( \" String \" ) ; } }"}
{"text":"Java program to reverse a string using recursion","code":"class StringReverse {"}
{"text":"Function to print reverse of the passed string","code":"void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { String str = \" Geeks \u2581 for \u2581 Geeks \" ; StringReverse obj = new StringReverse ( ) ; obj . reverse ( str ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Stores the count of distinct colors in box1","code":"static int box1 = 0 ;"}
{"text":"Stores the count of distinct colors in box2","code":"static int box2 = 0 ; static int [ ] fact = new int [ 11 ] ;"}
{"text":"Function to calculate the required probability","code":"public static double getProbability ( int [ ] balls ) {"}
{"text":"Calculate factorial from [ 1 , 10 ]","code":"factorial ( 10 ) ;"}
{"text":"Assign all distinct balls to second box","code":"box2 = balls . length ;"}
{"text":"Total number of balls","code":"int K = 0 ;"}
{"text":"Calculate total number of balls","code":"for ( int i = 0 ; i < balls . length ; i ++ ) K += balls [ i ] ;"}
{"text":"If K is an odd number","code":"if ( K % 2 == 1 ) return 0 ;"}
{"text":"Total ways of distributing the balls in two equal halves","code":"long all = comb ( K , K \/ 2 ) ;"}
{"text":"Required number of ways","code":"long validPermutations = validPermutations ( K \/ 2 , balls , 0 , 0 ) ;"}
{"text":"Return the required probability","code":"return ( double ) validPermutations \/ all ; }"}
{"text":"Function to calculate total number of possible distributions which satisfies the given conditions","code":"static long validPermutations ( int n , int [ ] balls , int usedBalls , int i ) {"}
{"text":"If used balls is equal to K \/ 2","code":"if ( usedBalls == n ) {"}
{"text":"If box1 is equal to box2","code":"return box1 == box2 ? 1 : 0 ; }"}
{"text":"Base condition","code":"if ( i >= balls . length ) return 0 ;"}
{"text":"Stores the number of ways of distributing remaining balls without including the current balls in box1","code":"long res = validPermutations ( n , balls , usedBalls , i + 1 ) ;"}
{"text":"Increment box1 by one","code":"box1 ++ ;"}
{"text":"Iterate over the range [ 1 , balls [ i ] ]","code":"for ( int j = 1 ; j <= balls [ i ] ; j ++ ) {"}
{"text":"If all the balls goes to box1 , then decrease box2 by one","code":"if ( j == balls [ i ] ) box2 -- ;"}
{"text":"Total number of ways of selecting j balls","code":"long combinations = comb ( balls [ i ] , j ) ;"}
{"text":"Increment res by total number of valid ways of distributing the remaining balls","code":"res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 ) ; }"}
{"text":"Decrement box1 by one","code":"box1 -- ;"}
{"text":"Increment box2 by 1","code":"box2 ++ ; return res ; }"}
{"text":"Function to calculate factorial of N","code":"static void factorial ( int N ) {"}
{"text":"Base Case","code":"fact [ 0 ] = 1 ;"}
{"text":"Iterate over the range [ 1 , N ]","code":"for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; }"}
{"text":"Function to calculate NcR","code":"static long comb ( int n , int r ) { long res = fact [ n ] \/ fact [ r ] ; res \/= fact [ n - r ] ; return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 1 } ; int N = 4 ;"}
{"text":"Print the result","code":"System . out . println ( getProbability ( arr ) ) ; } }"}
{"text":"Java Program to find the area of a regular polygon with given radius","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the area of a regular polygon","code":"static double polyarea ( double n , double r ) {"}
{"text":"Side and radius cannot be negative","code":"if ( r < 0 && n < 0 ) return - 1 ;"}
{"text":"Area degree converted to radians","code":"double A = ( ( r * r * n ) * Math . sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) \/ 2 ; return A ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float r = 9 , n = 6 ; System . out . println ( polyarea ( n , r ) ) ; } }"}
{"text":"Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal","code":"class GFG { static void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { Map < Integer , Integer > weight_at_x = new HashMap < Integer , Integer > ( ) ; int max_x = ( int ) - 2e3 , min_x = ( int ) 2e3 ;"}
{"text":"Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates","code":"for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = Math . max ( max_x , new_x ) ; min_x = Math . min ( min_x , new_x ) ;"}
{"text":"storing weight sum upto x - y point","code":"if ( weight_at_x . containsKey ( new_x ) ) { weight_at_x . put ( new_x , weight_at_x . get ( new_x ) + w [ i ] ) ; } else { weight_at_x . put ( new_x , w [ i ] ) ; } } Vector < Integer > sum_till = new Vector < > ( ) ; sum_till . add ( 0 ) ;"}
{"text":"Finding prefix sum","code":"for ( int s = min_x ; s <= max_x ; s ++ ) { if ( weight_at_x . get ( s ) == null ) sum_till . add ( sum_till . lastElement ( ) ) ; else sum_till . add ( sum_till . lastElement ( ) + weight_at_x . get ( s ) ) ; } int total_sum = sum_till . lastElement ( ) ; int partition_possible = 0 ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till . get ( i ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ;"}
{"text":"Line passes through i , so it neither falls left nor right .","code":"if ( sum_till . get ( i - 1 ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ; } System . out . printf ( partition_possible == 1 ? \"YES \" \u2581 : \u2581 \" NO \"); }"}
{"text":"Driven code","code":"public static void main ( String [ ] args ) { int n = 3 ; int x [ ] = { - 1 , - 2 , 1 } ; int y [ ] = { 1 , 1 , - 1 } ; int w [ ] = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; } }"}
{"text":"Java program find slope of perpendicular line","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the Slope of other line","code":"static double findPCSlope ( double m ) { return - 1.0 \/ m ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double m = 2.0 ; System . out . println ( findPCSlope ( m ) ) ; } }"}
{"text":"Java Program to find area of segment of a circle","code":"class GFG { static float pi = 3.14159f ; static float"}
{"text":"Function to find area of segment","code":"area_of_segment ( float radius , float angle ) {"}
{"text":"Calculating area of sector","code":"float area_of_sector = pi * ( radius * radius ) * ( angle \/ 360 ) ;"}
{"text":"Calculating area of triangle","code":"float area_of_triangle = ( float ) 1 \/ 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) \/ 180 ) ; return area_of_sector - area_of_triangle ; }"}
{"text":"Driver Function","code":"public static void main ( String [ ] args ) { float radius = 10.0f , angle = 90.0f ; System . out . println ( \" Area \u2581 of \u2581 minor \u2581 segment \u2581 = \u2581 \" + area_of_segment ( radius , angle ) ) ; System . out . println ( \" Area \u2581 of \u2581 major \u2581 segment \u2581 = \u2581 \" + area_of_segment ( radius , ( 360 - angle ) ) ) ; } }"}
{"text":"Java program to find Area of a Sector","code":"class GFG { static void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( \" Angle \u2581 not \u2581 possible \" ) ;"}
{"text":"Calculating area of the sector","code":"else { double sector = ( ( 22 * radius * radius ) \/ 7 ) * ( angle \/ 360 ) ; System . out . println ( sector ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class Main { static int gcd ( int a , int b ) {"}
{"text":"Everything divides 0","code":"if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }"}
{"text":"Function to calculate total number of prime factor with their prime factor","code":"static HashMap < Integer , Integer > PrimeFactor ( int N ) { HashMap < Integer , Integer > primef = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Iterate while the number is even","code":"while ( N % 2 == 0 ) { if ( primef . containsKey ( 2 ) ) { primef . put ( 2 , primef . get ( 2 ) + 1 ) ; } else { primef . put ( 2 , 1 ) ; }"}
{"text":"Reduce to half","code":"N = N \/ 2 ; }"}
{"text":"Iterate up to sqrt ( N )","code":"for ( int i = 3 ; i <= Math . sqrt ( N ) ; i ++ ) {"}
{"text":"Iterate while N has factors of i","code":"while ( N % i == 0 ) { if ( primef . containsKey ( i ) ) { primef . put ( i , primef . get ( i ) + 1 ) ; } else { primef . put ( i , 1 ) ; }"}
{"text":"Removing one factor of i","code":"N = N \/ 2 ; } } if ( N > 2 ) { primef . put ( N , 1 ) ; } return primef ; }"}
{"text":"Function to count the number of factors","code":"static int CountToMakeEqual ( int X , int Y ) {"}
{"text":"Find the GCD","code":"int gcdofXY = gcd ( X , Y ) ;"}
{"text":"Find multiples left in X and Y","code":"int newX = Y \/ gcdofXY ; int newY = X \/ gcdofXY ;"}
{"text":"Find prime factor of multiple left in X and Y","code":"HashMap < Integer , Integer > primeX = PrimeFactor ( newX ) ; HashMap < Integer , Integer > primeY = PrimeFactor ( newY ) ;"}
{"text":"Initialize ans","code":"int ans = 0 ;"}
{"text":"Check if it possible to obtain X or not","code":"for ( Map . Entry keys : primeX . entrySet ( ) ) { if ( X % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeX . get ( keys . getKey ( ) ) ; }"}
{"text":"Check if it possible to obtain Y or not","code":"for ( Map . Entry keys : primeY . entrySet ( ) ) { if ( Y % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeY . get ( keys . getKey ( ) ) ; }"}
{"text":"Return main ans","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"int X = 36 ; int Y = 48 ;"}
{"text":"Function Call","code":"int ans = CountToMakeEqual ( X , Y ) ; System . out . println ( ans ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Stores the details of the Segment","code":"static class Node { int L , R , V ; Node ( int L , int R , int V ) { this . L = L ; this . R = R ; this . V = V ; } }"}
{"text":"Function to check whether the graph is bipartite or not","code":"static boolean check ( ArrayList < Integer > Adj [ ] , int Src , int N , boolean visited [ ] ) { int color [ ] = new int [ N ] ;"}
{"text":"Mark source node as visited","code":"visited [ Src ] = true ; ArrayDeque < Integer > q = new ArrayDeque < > ( ) ;"}
{"text":"Push the source vertex in queue","code":"q . addLast ( Src ) ; while ( ! q . isEmpty ( ) ) {"}
{"text":"Get the front of the queue","code":"int u = q . removeFirst ( ) ;"}
{"text":"Assign the color to the popped node","code":"int Col = color [ u ] ;"}
{"text":"Traverse the adjacency list of the node u","code":"for ( int x : Adj [ u ] ) {"}
{"text":"If any node is visited & a different colors has been assigned , then return false","code":"if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) {"}
{"text":"Set visited [ x ]","code":"visited [ x ] = true ;"}
{"text":"Push the node x into the queue","code":"q . addLast ( x ) ;"}
{"text":"Update color of node","code":"color [ x ] = 1 - Col ; } } }"}
{"text":"If the graph is bipartite","code":"return true ; }"}
{"text":"Function to add an edge between the nodes u and v","code":"static void addEdge ( ArrayList < Integer > Adj [ ] , int u , int v ) { Adj [ u ] . add ( v ) ; Adj [ v ] . add ( u ) ; }"}
{"text":"Function to check if the assignment of direction can be possible to all the segments , such that they do not intersect after a long period of time","code":"static void isPossible ( Node Arr [ ] , int N ) {"}
{"text":"Stores the adjacency list of the created graph","code":"@ SuppressWarnings ( \" unchecked \" ) ArrayList < Integer > [ ] Adj = ( ArrayList < Integer > [ ] ) new ArrayList [ N ] ;"}
{"text":"Initialize","code":"for ( int i = 0 ; i < N ; i ++ ) Adj [ i ] = new ArrayList < > ( ) ;"}
{"text":"Generate all possible pairs","code":"for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) {"}
{"text":"If segments do not overlap","code":"if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; }"}
{"text":"Otherwise , the segments overlap","code":"else { if ( Arr [ i ] . V == Arr [ j ] . V ) {"}
{"text":"If both segments have same speed , then add an edge","code":"addEdge ( Adj , i , j ) ; } } } }"}
{"text":"Keep the track of visited nodes","code":"boolean visited [ ] = new boolean [ N ] ;"}
{"text":"Iterate for all possible nodes","code":"for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . size ( ) > 0 ) {"}
{"text":"Check whether graph is bipartite or not","code":"if ( check ( Adj , i , N , visited ) == false ) { System . out . println ( \" No \" ) ; return ; } } }"}
{"text":"If the graph is bipartite","code":"System . out . println ( \" Yes \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { Node arr [ ] = { new Node ( 5 , 7 , 2 ) , new Node ( 4 , 6 , 1 ) , new Node ( 1 , 5 , 2 ) , new Node ( 6 , 5 , 1 ) } ; int N = arr . length ; isPossible ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG { public static void lexNumbers ( int n ) { List < Integer > sol = new ArrayList < > ( ) ; dfs ( 1 , n , sol ) ; System . out . println ( sol ) ; } public static void dfs ( int temp , int n , List < Integer > sol ) { if ( temp > n ) return ; sol . add ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }"}
{"text":"Java program to find the minimum number of swaps required to sort the given array","code":"import java . io . * ; import java . util . * ; class GfG {"}
{"text":"Function to find minimum swaps","code":"static int minimumSwaps ( int [ ] arr ) {"}
{"text":"Initialise count variable","code":"int count = 0 ; int i = 0 ; while ( i < arr . length ) {"}
{"text":"If current element is not at the right position","code":"if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ;"}
{"text":"Swap current element with correct position of that element","code":"temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } }"}
{"text":"Increment for next index when current element is at correct position","code":"i ++ ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ;"}
{"text":"Function to find minimum swaps","code":"System . out . println ( minimumSwaps ( arr ) ) ; } }"}
{"text":"Java program to merge K sorted doubly linked list in sorted order","code":"class GFG {"}
{"text":"A linked list node","code":"static class Node { int data ; Node next ; Node prev ; } ;"}
{"text":"Given a reference ( pointer to pointer ) to the head Of a DLL and an int , appends a new node at the end","code":"static Node append ( Node head_ref , int new_data ) {"}
{"text":"Allocate node","code":"Node new_node = new Node ( ) ; Node last = head_ref ;"}
{"text":"Put in the data","code":"new_node . data = new_data ;"}
{"text":"This new node is going to be the last node , so make next of it as null","code":"new_node . next = null ;"}
{"text":"If the Linked List is empty , then make the new node as head","code":"if ( head_ref == null ) { new_node . prev = null ; head_ref = new_node ; return head_ref ; }"}
{"text":"Else traverse till the last node","code":"while ( last . next != null ) last = last . next ;"}
{"text":"Change the next of last node","code":"last . next = new_node ;"}
{"text":"Make last node as previous of new node","code":"new_node . prev = last ; return head_ref ; }"}
{"text":"Function to print the list","code":"static void printList ( Node node ) { Node last ;"}
{"text":"Run while loop unless node becomes null","code":"while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; last = node ; node = node . next ; } }"}
{"text":"Function to merge two sorted doubly linked lists","code":"static Node mergeList ( Node p , Node q ) { Node s = null ;"}
{"text":"If any of the list is empty","code":"if ( p == null q == null ) { return ( p == null ? q : p ) ; }"}
{"text":"Comparison the data of two linked list","code":"if ( p . data < q . data ) { p . prev = s ; s = p ; p = p . next ; } else { q . prev = s ; s = q ; q = q . next ; }"}
{"text":"Store head pointer before merge the list","code":"Node head = s ; while ( p != null && q != null ) { if ( p . data < q . data ) {"}
{"text":"Changing of pointer between Two list for merging","code":"s . next = p ; p . prev = s ; s = s . next ; p = p . next ; } else {"}
{"text":"Changing of pointer between Two list for merging","code":"s . next = q ; q . prev = s ; s = s . next ; q = q . next ; } }"}
{"text":"Condition to check if any anyone list not end","code":"if ( p == null ) { s . next = q ; q . prev = s ; } if ( q == null ) { s . next = p ; p . prev = s ; }"}
{"text":"Return head pointer of merged list","code":"return head ; }"}
{"text":"Function to merge all sorted linked list in sorted order","code":"static Node mergeAllList ( Node head [ ] , int k ) { Node finalList = null ; for ( int i = 0 ; i < k ; i ++ ) {"}
{"text":"Function call to merge two sorted doubly linked list at a time","code":"finalList = mergeList ( finalList , head [ i ] ) ; }"}
{"text":"Return final sorted doubly linked list","code":"return finalList ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int k = 3 ; Node head [ ] = new Node [ k ] ;"}
{"text":"Loop to initialize all the lists to empty","code":"for ( int i = 0 ; i < k ; i ++ ) { head [ i ] = null ; }"}
{"text":"Create first doubly linked List List1 . 1 <= > 5 <= > 9","code":"head [ 0 ] = append ( head [ 0 ] , 1 ) ; head [ 0 ] = append ( head [ 0 ] , 5 ) ; head [ 0 ] = append ( head [ 0 ] , 9 ) ;"}
{"text":"Create second doubly linked List List2 . 2 <= > 3 <= > 7 <= > 12","code":"head [ 1 ] = append ( head [ 1 ] , 2 ) ; head [ 1 ] = append ( head [ 1 ] , 3 ) ; head [ 1 ] = append ( head [ 1 ] , 7 ) ; head [ 1 ] = append ( head [ 1 ] , 12 ) ;"}
{"text":"Create third doubly linked List List3 . 8 <= > 11 <= > 13 <= > 18","code":"head [ 2 ] = append ( head [ 2 ] , 8 ) ; head [ 2 ] = append ( head [ 2 ] , 11 ) ; head [ 2 ] = append ( head [ 2 ] , 13 ) ; head [ 2 ] = append ( head [ 2 ] , 18 ) ;"}
{"text":"Function call to merge all sorted doubly linked lists in sorted order","code":"Node finalList = mergeAllList ( head , k ) ;"}
{"text":"Print final sorted list","code":"printList ( finalList ) ; } }"}
{"text":"Recursive Java program to sort an array using selection sort","code":"class Test {"}
{"text":"Return minimum index","code":"static int minIndex ( int a [ ] , int i , int j ) { if ( i == j ) return i ;"}
{"text":"Find minimum of remaining elements","code":"int k = minIndex ( a , i + 1 , j ) ;"}
{"text":"Return minimum of current and remaining .","code":"return ( a [ i ] < a [ k ] ) ? i : k ; }"}
{"text":"Recursive selection sort . n is size of a [ ] and index is index of starting element .","code":"static void recurSelectionSort ( int a [ ] , int n , int index ) {"}
{"text":"Return when starting and size are same","code":"if ( index == n ) return ;"}
{"text":"calling minimum index function for minimum index","code":"int k = minIndex ( a , index , n - 1 ) ;"}
{"text":"Swapping when index nd minimum index are not same","code":"if ( k != index ) {"}
{"text":"swap","code":"int temp = a [ k ] ; a [ k ] = a [ index ] ; a [ index ] = temp ; }"}
{"text":"Recursively calling selection sort function","code":"recurSelectionSort ( a , n , index + 1 ) ; }"}
{"text":"Driver method","code":"public static void main ( String args [ ] ) { int arr [ ] = { 3 , 1 , 5 , 2 , 7 , 0 } ;"}
{"text":"Calling function","code":"recurSelectionSort ( arr , arr . length , 0 ) ;"}
{"text":"printing sorted array","code":"for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Recursive Java program for insertion sort","code":"import java . util . Arrays ; public class GFG {"}
{"text":"Recursive function to sort an array using insertion sort","code":"static void insertionSortRecursive ( int arr [ ] , int n ) {"}
{"text":"Base case","code":"if ( n <= 1 ) return ;"}
{"text":"Sort first n - 1 elements","code":"insertionSortRecursive ( arr , n - 1 ) ;"}
{"text":"Insert last element at its correct position in sorted array .","code":"int last = arr [ n - 1 ] ; int j = n - 2 ;"}
{"text":"Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position","code":"while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }"}
{"text":"Driver Method","code":"public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; insertionSortRecursive ( arr , arr . length ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }"}
{"text":"Java program for recursive implementation of Bubble sort","code":"import java . util . Arrays ; public class GFG {"}
{"text":"A function to implement bubble sort","code":"static void bubbleSort ( int arr [ ] , int n ) {"}
{"text":"Base case","code":"if ( n == 1 ) return ;"}
{"text":"One pass of bubble sort . After this pass , the largest element is moved ( or bubbled ) to end .","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) {"}
{"text":"swap arr [ i ] , arr [ i + 1 ]","code":"int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; }"}
{"text":"Largest element is fixed , recur for remaining array","code":"bubbleSort ( arr , n - 1 ) ; }"}
{"text":"Driver Method","code":"public static void main ( String [ ] args ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; bubbleSort ( arr , arr . length ) ; System . out . println ( \" Sorted \u2581 array \u2581 : \u2581 \" ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }"}
{"text":"package whatever do not write package name here","code":"import java . io . * ; import java . util . * ; class GFG { static int maxSumAfterPartition ( int arr [ ] , int n ) {"}
{"text":"Stores the positive elements","code":"ArrayList < Integer > pos = new ArrayList < Integer > ( ) ;"}
{"text":"Stores the negative elements","code":"ArrayList < Integer > neg = new ArrayList < Integer > ( ) ;"}
{"text":"Stores the count of 0 s","code":"int zero = 0 ;"}
{"text":"Sum of all positive numbers","code":"int pos_sum = 0 ;"}
{"text":"Sum of all negative numbers","code":"int neg_sum = 0 ;"}
{"text":"Iterate over the array","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . add ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . add ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } }"}
{"text":"Stores the difference","code":"int ans = 0 ;"}
{"text":"Sort the positive numbers in ascending order","code":"Collections . sort ( pos ) ;"}
{"text":"Sort the negative numbers in decreasing order","code":"Collections . sort ( neg ) ;"}
{"text":"Case 1 : Include both positive and negative numbers","code":"if ( pos . size ( ) > 0 && neg . size ( ) > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . size ( ) > 0 ) { if ( zero > 0 ) {"}
{"text":"Put all numbers in subset A and one 0 in subset B","code":"ans = ( pos_sum ) ; } else {"}
{"text":"Put all numbers in subset A except the smallest positive number which is put in B","code":"ans = ( pos_sum - 2 * pos . get ( 0 ) ) ; } } else { if ( zero > 0 ) {"}
{"text":"Put all numbers in subset B and one 0 in subset A","code":"ans = ( - 1 * neg_sum ) ; } else {"}
{"text":"Place the largest negative number in subset A and remaining in B","code":"ans = ( neg . get ( 0 ) - ( neg_sum - neg . get ( 0 ) ) ) ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , - 5 , - 7 } ; int n = 5 ; System . out . println ( maxSumAfterPartition ( arr , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the bitwise OR of array elements","code":"static int MaxXOR ( int arr [ ] , int N ) {"}
{"text":"Stores the resultant maximum value of Bitwise XOR","code":"int res = 0 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; }"}
{"text":"Return the maximum value res","code":"return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 } ; int N = arr . length ; System . out . println ( MaxXOR ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to count the number of elements common in both the arrays","code":"static int countEqual ( int A [ ] , int B [ ] , int N ) {"}
{"text":"Used to traverse array A [ ] and B [ ] from the front and the back","code":"int first = 0 ; int second = N - 1 ;"}
{"text":"Stores the count of numbers common in both array","code":"int count = 0 ; while ( first < N && second >= 0 ) {"}
{"text":"If A [ first ] is less than B [ second ]","code":"if ( A [ first ] < B [ second ] ) {"}
{"text":"Increment the value of first","code":"first ++ ; }"}
{"text":"IF B [ second ] is less than A [ first ]","code":"else if ( B [ second ] < A [ first ] ) {"}
{"text":"Decrement the value of second","code":"second -- ; }"}
{"text":"A [ first ] is equal to B [ second ]","code":"else {"}
{"text":"Increment the value of count","code":"count ++ ;"}
{"text":"Increment the value of first","code":"first ++ ;"}
{"text":"Decrement the value of second","code":"second -- ; } }"}
{"text":"Return the value of count","code":"return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 } ; int B [ ] = { 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 } ; int N = A . length ; System . out . println ( countEqual ( A , B , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG { static int [ ] arr = new int [ 100005 ] ;"}
{"text":"Function to check if the number N is palindrome or not","code":"static boolean isPalindrome ( int N ) {"}
{"text":"Store the value of N","code":"int temp = N ;"}
{"text":"Store the reverse of number N","code":"int res = 0 ;"}
{"text":"Reverse temp and store in res","code":"while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp \/= 10 ; }"}
{"text":"If N is the same as res , then return true","code":"if ( res == N ) { return true ; } else { return false ; } }"}
{"text":"Function to find the sum of the digits of the number N","code":"static int sumOfDigits ( int N ) {"}
{"text":"Stores the sum of the digits","code":"int sum = 0 ; while ( N != 0 ) {"}
{"text":"Add the last digit of the number N to the sum","code":"sum += N % 10 ;"}
{"text":"Remove the last digit from N","code":"N \/= 10 ; }"}
{"text":"Return the resultant sum","code":"return sum ; }"}
{"text":"Function to check if N is prime or not","code":"static boolean isPrime ( int n ) {"}
{"text":"If i is 1 or 0 , then return false","code":"if ( n <= 1 ) { return false ; }"}
{"text":"Check if i is divisible by any number in the range [ 2 , n \/ 2 ]","code":"for ( int i = 2 ; i <= n \/ 2 ; ++ i ) {"}
{"text":"If n is divisible by i","code":"if ( n % i == 0 ) return false ; } return true ; }"}
{"text":"Function to precompute all the numbers till 10 ^ 5 that are palindromic and whose sum of digits is prime numbers","code":"static void precompute ( ) {"}
{"text":"Iterate over the range 1 to 10 ^ 5","code":"for ( int i = 1 ; i <= 100000 ; i ++ ) {"}
{"text":"If i is a palindrome number","code":"if ( isPalindrome ( i ) ) {"}
{"text":"Stores the sum of the digits in i","code":"int sum = sumOfDigits ( i ) ;"}
{"text":"If the sum of digits in i is a prime number","code":"if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; }"}
{"text":"Find the prefix sum of arr [ ]","code":"for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } }"}
{"text":"Function to count all the numbers in the given ranges that are palindromic and the sum of digits is prime numbers","code":"static void countNumbers ( int [ ] [ ] Q , int N ) {"}
{"text":"Function Call to precompute all the numbers till 10 ^ 5","code":"precompute ( ) ;"}
{"text":"Traverse the given queries Q [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Print the result for each query","code":"System . out . println ( ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] [ ] Q = { { 5 , 9 } , { 1 , 101 } } ; int N = Q . length ;"}
{"text":"Function Call","code":"countNumbers ( Q , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate sum digits of n","code":"static int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n \/= 10 ; } return res ; }"}
{"text":"Function to find the smallest possible integer satisfying the given condition","code":"static int smallestNumber ( int n , int s ) {"}
{"text":"If the sum of digits is already smaller than S","code":"if ( sum ( n ) <= s ) { return n ; }"}
{"text":"Initialize variables","code":"int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) {"}
{"text":"Finding last kth digit","code":"int digit = ( ans \/ k ) % 10 ;"}
{"text":"Add remaining to make digit 0","code":"int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ;"}
{"text":"If sum of digits does not exceed S","code":"if ( sum ( ans ) <= s ) { break ; }"}
{"text":"Update k","code":"k *= 10 ; } return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N and S","code":"int N = 3 , S = 2 ;"}
{"text":"Function call","code":"System . out . println ( smallestNumber ( N , S ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum number number of required subsequences","code":"static int maxSubsequences ( int arr [ ] , int n ) {"}
{"text":"HashMap to store number of arrows available with height of arrow as key","code":"HashMap < Integer , Integer > map = new HashMap < > ( ) ;"}
{"text":"Stores the maximum count of possible subsequences","code":"int maxCount = 0 ;"}
{"text":"Stores the count of possible subsequences","code":"int count ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Check if i - th element can be part of any of the previous subsequence","code":"if ( map . containsKey ( arr [ i ] ) ) {"}
{"text":"Count of subsequences possible with arr [ i ] as the next element","code":"count = map . get ( arr [ i ] ) ;"}
{"text":"If more than one such subsequence exists","code":"if ( count > 1 ) {"}
{"text":"Include arr [ i ] in a subsequence","code":"map . put ( arr [ i ] , count - 1 ) ; }"}
{"text":"Otherwise","code":"else map . remove ( arr [ i ] ) ;"}
{"text":"Increase count of subsequence possible with arr [ i ] - 1 as the next element","code":"if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } else {"}
{"text":"Start a new subsequence","code":"maxCount ++ ;"}
{"text":"Increase count of subsequence possible with arr [ i ] - 1 as the next element","code":"if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } }"}
{"text":"Return the answer","code":"return maxCount ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { 4 , 5 , 2 , 1 , 4 } ; System . out . println ( maxSubsequences ( arr , n ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"class GFG {"}
{"text":"Function to remove first and last occurrence of a given character from the given String","code":"static String removeOcc ( String s , char ch ) {"}
{"text":"Traverse the given String from the beginning","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"If ch is found","code":"if ( s . charAt ( i ) == ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } }"}
{"text":"Traverse the given String from the end","code":"for ( int i = s . length ( ) - 1 ; i > - 1 ; i -- ) {"}
{"text":"If ch is found","code":"if ( s . charAt ( i ) == ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } return s ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \" hello \u2581 world \" ; char ch = ' l ' ; System . out . print ( removeOcc ( s , ch ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class GFG {"}
{"text":"Function that finds the minimum steps to reach either 0 or N for given increasing and decreasing arrays","code":"public static void minSteps ( int N , int [ ] increasing , int [ ] decreasing ) {"}
{"text":"Initialize variable to find the minimum element","code":"int min = Integer . MAX_VALUE ;"}
{"text":"Find minimum element in increasing [ ] array","code":"for ( int i : increasing ) { if ( min > i ) min = i ; }"}
{"text":"Initialize variable to find the maximum element","code":"int max = Integer . MIN_VALUE ;"}
{"text":"Find maximum element in decreasing [ ] array","code":"for ( int i : decreasing ) { if ( max < i ) max = i ; }"}
{"text":"Find the minimum steps","code":"int minSteps = Math . max ( max , N - min ) ;"}
{"text":"Print the minimum steps","code":"System . out . println ( minSteps ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N","code":"int N = 7 ;"}
{"text":"Given increasing and decreasing array","code":"int increasing [ ] = { 3 , 5 } ; int decreasing [ ] = { 6 } ;"}
{"text":"Function call","code":"minSteps ( N , increasing , decreasing ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum number of swaps","code":"static void solve ( int P [ ] , int n ) {"}
{"text":"New array to convert to 1 - based indexing","code":"int arr [ ] = new int [ n + 1 ] ; arr [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ;"}
{"text":"Keeps count of swaps","code":"int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"Check if it is an ' X ' position","code":"if ( arr [ i ] == i ) { int t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } }"}
{"text":"Corner Case","code":"if ( arr [ n ] == n ) {"}
{"text":"Swap","code":"int t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; }"}
{"text":"Print the minimum swaps","code":"System . out . println ( cnt ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Number N","code":"int N = 9 ;"}
{"text":"Given Permutation of N numbers","code":"int P [ ] = new int [ ] { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ;"}
{"text":"Function Call","code":"solve ( P , N ) ; } }"}
{"text":"Java program to find the number of interesting primes up to N .","code":"import java . util . * ; class GFG {"}
{"text":"Function to find all prime numbers","code":"static void SieveOfEratosthenes ( int n , HashSet < Integer > allPrimes ) {"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries as true . A value in prime [ i ] will finally be false if i is Not a prime .","code":"boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p greater than or equal to the square of it","code":"for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } }"}
{"text":"Store all prime numbers","code":"for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . add ( p ) ; }"}
{"text":"Function to check if a number is perfect square or not","code":"static int countInterestingPrimes ( int n ) {"}
{"text":"To store all primes","code":"HashSet < Integer > allPrimes = new HashSet < Integer > ( ) ; SieveOfEratosthenes ( n , allPrimes ) ;"}
{"text":"To store all interseting primes","code":"HashSet < Integer > intersetingPrimes = new HashSet < Integer > ( ) ; Vector < Integer > squares = new Vector < Integer > ( ) , quadruples = new Vector < Integer > ( ) ;"}
{"text":"Store all perfect squares","code":"for ( int i = 1 ; i * i <= n ; i ++ ) { squares . add ( i * i ) ; }"}
{"text":"Store all perfect quadruples","code":"for ( int i = 1 ; i * i * i * i <= n ; i ++ ) { quadruples . add ( i * i * i * i ) ; }"}
{"text":"Store all interseting primes","code":"for ( int a : squares ) { for ( int b : quadruples ) { if ( allPrimes . contains ( a + b ) ) intersetingPrimes . add ( a + b ) ; } }"}
{"text":"Return count of interseting primes","code":"return intersetingPrimes . size ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countInterestingPrimes ( N ) ) ; } }"}
{"text":"Java code to check if the array is wave array","code":"public class GFG {"}
{"text":"Function to check if array is wave array arr : input array n : size of array","code":"static boolean isWaveArray ( int arr [ ] , int n ) { boolean result = true ;"}
{"text":"Check the wave form * If arr [ 1 ] is greater than left and right * Same pattern will be followed by whole * elements , else reverse pattern * will be followed by array elements","code":"if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } }"}
{"text":"Check for last element","code":"if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } }"}
{"text":"Check for last element","code":"if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"Array","code":"int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = arr . length ; if ( isWaveArray ( arr , n ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java Program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to count number of sequences satisfying the given criteria","code":"static void countPossiblities ( int arr [ ] , int n ) {"}
{"text":"Stores the index of the last occurrence of the element","code":"int [ ] lastOccur = new int [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = - 1 ; }"}
{"text":"Initialize an array to store the number of different sequences that are possible of length i","code":"int [ ] dp = new int [ n + 1 ] ;"}
{"text":"Base Case","code":"dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ;"}
{"text":"If no operation is applied on ith element","code":"dp [ i ] = dp [ i - 1 ] ;"}
{"text":"If operation is applied on ith element","code":"if ( lastOccur [ curEle ] != - 1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; }"}
{"text":"Update the last occurrence of curEle","code":"lastOccur [ curEle ] = i ; }"}
{"text":"Finally , print the answer","code":"System . out . println ( dp [ n ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int N = arr . length ; countPossiblities ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to print the maximum sum","code":"static void maxSum ( int [ ] [ ] arr , int n , int m ) {"}
{"text":"Dp table","code":"int [ ] [ ] dp = new int [ n ] [ m + 1 ] ;"}
{"text":"Initializing dp array with 0 s","code":"for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } }"}
{"text":"Base case","code":"dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ;"}
{"text":"Traverse each column","code":"for ( int j = m - 2 ; j >= 0 ; j -- ) {"}
{"text":"Update answer for both rows","code":"for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } }"}
{"text":"Print the maximum sum","code":"System . out . println ( Math . max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int [ ] [ ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ;"}
{"text":"Number of Columns","code":"int N = arr [ 0 ] . length ;"}
{"text":"Function calls","code":"maxSum ( arr , 2 , N ) ; } }"}
{"text":"Java code for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row","code":"static void maxSum ( int [ ] [ ] arr , int n ) {"}
{"text":"Initialize variables","code":"int r1 = 0 , r2 = 0 ;"}
{"text":"Traverse each column","code":"for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; }"}
{"text":"Print answer","code":"System . out . println ( Math . max ( r1 , r2 ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int [ ] [ ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ;"}
{"text":"Numberof columns","code":"int n = arr [ 0 ] . length ; maxSum ( arr , n ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int mx = ( int ) 1e6 ; static int [ ] fact = new int [ ( int ) mx + 1 ] ;"}
{"text":"Function to calculate the factorials up to a number","code":"static void Calculate_factorial ( ) { fact [ 0 ] = 1 ;"}
{"text":"Calculate the factorial","code":"for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } }"}
{"text":"Function to find power ( a , b )","code":"static int UniModal_per ( int a , int b ) { int res = 1 ;"}
{"text":"Iterate until b exists","code":"while ( b > 0 ) {"}
{"text":"If b is divisible by 2","code":"if ( b % 2 != 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ;"}
{"text":"Decrease the value of b","code":"b \/= 2 ; }"}
{"text":"Return the answer","code":"return res ; }"}
{"text":"Function that counts the unimodal and non - unimodal permutations of a given integer N","code":"static void countPermutations ( int n ) {"}
{"text":"Function Call for finding factorials up to N","code":"Calculate_factorial ( ) ;"}
{"text":"Function to count unimodal permutations","code":"int uni_modal = UniModal_per ( 2 , n - 1 ) ;"}
{"text":"Non - unimodal permutation is N ! - unimodal permutations","code":"int nonuni_modal = fact [ n ] - uni_modal ; System . out . print ( uni_modal + \" \u2581 \" + nonuni_modal ) ; return ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Number N","code":"int N = 4 ;"}
{"text":"Function Call","code":"countPermutations ( N ) ; } }"}
{"text":"Java program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle","code":"import java . io . * ; class GFG { static void longestSubseq ( String s , int length ) {"}
{"text":"Prefix array to store the occurences of '1' and '0'","code":"int [ ] ones = new int [ length + 1 ] ; int [ ] zeroes = new int [ length + 1 ] ;"}
{"text":"Iterate over the length of the string","code":"for ( int i = 0 ; i < length ; i ++ ) {"}
{"text":"If current character is '1'","code":"if ( s . charAt ( i ) == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; }"}
{"text":"If current character is '0'","code":"else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = Integer . MIN_VALUE ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) {"}
{"text":"Add '1' available for the first string","code":"x += ones [ i ] ;"}
{"text":"Add '0' available for the second string","code":"x += ( zeroes [ j ] - zeroes [ i ] ) ;"}
{"text":"Add '1' available for the third string","code":"x += ( ones [ length ] - ones [ j ] ) ;"}
{"text":"Update answer","code":"answer = Math . max ( answer , x ) ; x = 0 ; } }"}
{"text":"Print the final result","code":"System . out . println ( answer ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \"10010010111100101\" ; int length = s . length ( ) ; longestSubseq ( s , length ) ; } }"}
{"text":"Java implementation to find the largest square in the matrix such that it contains atmost K 1 's","code":"class GFG { static int MAX = 100 ;"}
{"text":"Function to calculate the largest square with atmost K 1 s for Q queries","code":"static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {"}
{"text":"Loop to solve for each query","code":"for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ;"}
{"text":"Traversing the each sub square and counting total","code":"for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ;"}
{"text":"Breaks when exceeds the maximum count","code":"if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + \"NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
{"text":"Java implementation to find the largest square in the matrix such that it contains atmost K 1 's","code":"import java . util . * ; class GFG { static int MAX = 100 ;"}
{"text":"Function to find the largest square in the matrix such that it contains atmost K 1 's","code":"static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int [ ] [ ] countDP = new int [ R ] [ C ] ;"}
{"text":"Precomputing the countDP prefix sum of the matrix","code":"countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ;"}
{"text":"Loop to solve Queries","code":"for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ;"}
{"text":"Calculating the maximum possible distance of the centre from edge","code":"int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ;"}
{"text":"Calculating the number of 1 s in the submatrix","code":"int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + \"NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the minimum cost to connect the given ropes","code":"static int MinCost ( int arr [ ] , int n ) {"}
{"text":"dp [ i ] [ j ] = minimum cost in range ( i , j ) sum [ i ] [ j ] = sum of range ( i , j )","code":"int [ ] [ ] dp = new int [ n + 5 ] [ n + 5 ] ; int [ ] [ ] sum = new int [ n + 5 ] [ n + 5 ] ;"}
{"text":"Initializing the sum table memset ( sum , 0 , sizeof ( 0 ) ) ;","code":"for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } }"}
{"text":"Computing minimum cost for all the possible interval ( i , j ) Left range","code":"for ( int i = n - 1 ; i >= 0 ; i -- ) {"}
{"text":"Right range","code":"for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ;"}
{"text":"No cost for a single rope","code":"if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = arr . length ; System . out . println ( MinCost ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to recursively fill the dp array","code":"static int f ( int i , int state , int A [ ] , int dp [ ] [ ] , int N ) { if ( i >= N ) return 0 ;"}
{"text":"If f ( i , state ) is already calculated then return the value","code":"else if ( dp [ i ] [ state ] != - 1 ) { return dp [ i ] [ state ] ; }"}
{"text":"Calculate f ( i , state ) according to the recurrence relation and store in dp [ ] [ ]","code":"else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } }"}
{"text":"Function that calls the resucrsive function to fill the dp array and then returns the result","code":"static int maxLenSeq ( int A [ ] , int N ) { int i , j , tmp , y , ans ;"}
{"text":"dp [ ] [ ] array for storing result of f ( i , 1 ) and f ( 1 , 2 )","code":"int dp [ ] [ ] = new int [ 1000 ] [ 3 ] ;"}
{"text":"Populating the array dp [ ] with - 1","code":"for ( i = 0 ; i < 1000 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) dp [ i ] [ j ] = - 1 ;"}
{"text":"Make sure that longest UD and DU sequence starting at each index is calculated","code":"for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; }"}
{"text":"Assume the answer to be - 1 This value will only increase","code":"ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) {"}
{"text":"y is the length of the longest UD sequence starting at i","code":"y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 ) ;"}
{"text":"If length is even then add an integer and then a DU sequence starting at i + y","code":"else if ( y % 2 == 0 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; }"}
{"text":"If length is odd then add an integer and then a UD sequence starting at i + y","code":"else if ( y % 2 == 1 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] = { 1 , 10 , 3 , 20 , 25 , 24 } ; int n = A . length ; System . out . println ( maxLenSeq ( A , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class Test {"}
{"text":"Recursive function to return gcd of a and b","code":"static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text":"Function to return the maximized gcd after removing a single element from the given array","code":"static int MaxGCD ( int a [ ] , int n ) {"}
{"text":"Prefix and Suffix arrays","code":"int Prefix [ ] = new int [ n + 2 ] ; int Suffix [ ] = new int [ n + 2 ] ;"}
{"text":"Single state dynamic programming relation for storing gcd of first i elements from the left in Prefix [ i ]","code":"Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; }"}
{"text":"Initializing Suffix array","code":"Suffix [ n ] = a [ n - 1 ] ;"}
{"text":"Single state dynamic programming relation for storing gcd of all the elements having greater than or equal to i in Suffix [ i ]","code":"for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; }"}
{"text":"If first or last element of the array has to be removed","code":"int ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ;"}
{"text":"If any other element is replaced","code":"for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; }"}
{"text":"Return the maximized gcd","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 14 , 17 , 28 , 70 } ; int n = a . length ; System . out . println ( MaxGCD ( a , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . Arrays ; class GFG { static int right = 2 ; static int left = 4 ; static int [ ] [ ] dp = new int [ left ] [ right ] ;"}
{"text":"Function to find the maximum subarray sum with flips starting from index i","code":"static int findSubarraySum ( int ind , int flips , int n , int [ ] a , int k ) {"}
{"text":"If the number of flips have exceeded","code":"if ( flips > k ) return ( int ) ( - 1e9 ) ;"}
{"text":"Complete traversal","code":"if ( ind == n ) return 0 ;"}
{"text":"If the state has previously been visited","code":"if ( dp [ ind ] [ flips ] != - 1 ) return dp [ ind ] [ flips ] ;"}
{"text":"Initially","code":"int ans = 0 ;"}
{"text":"Use Kadane 's algorithm and call two states","code":"ans = Math . max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ;"}
{"text":"Memoize the answer and return it","code":"return dp [ ind ] [ flips ] = ans ; }"}
{"text":"Utility function to call flips from index and return the answer","code":"static int findMaxSubarraySum ( int [ ] a , int n , int k ) {"}
{"text":"Create DP array int dp [ n , k + 1 ] ;","code":"for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i ] [ j ] = - 1 ; int ans = ( int ) ( - 1e9 ) ;"}
{"text":"Iterate and call recursive function from every index to get the maximum subarray sum","code":"for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ;"}
{"text":"corner case","code":"if ( ans == 0 && k == 0 ) return Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] a = { - 1 , - 2 , - 100 , - 10 } ; int n = a . length ; int k = 1 ; System . out . println ( findMaxSubarraySum ( a , n , k ) ) ; } }"}
{"text":"Java program to Find the sum of first N odd Fibonacci numbers","code":"import java . io . * ; class GFG { static int mod = 1000000007 ;"}
{"text":"Function to calculate sum of first N odd Fibonacci numbers","code":"static int sumOddFibonacci ( int n ) { int Sum [ ] = new int [ n + 1 ] ;"}
{"text":"base values","code":"Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( sumOddFibonacci ( n ) ) ; }"}
{"text":"Java implementation of the above approach","code":"public class GFG { static long fun ( int marks [ ] , int n ) {"}
{"text":"Initializing one tablet for each student","code":"long dp [ ] = new long [ n ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"if left adjacent is having higher marks review and change all the dp values assigned before until assigned dp values are found wrong according to given constrains","code":"if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } }"}
{"text":"if right adjacent is having higher marks add one in dp of left adjacent and assign to right one","code":"else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"n number of students","code":"int n = 6 ;"}
{"text":"marks of students","code":"int marks [ ] = { 1 , 4 , 5 , 2 , 2 , 1 } ;"}
{"text":"solution of problem","code":"System . out . println ( fun ( marks , n ) ) ; } }"}
{"text":"Java program to reach N - th stair by taking a maximum of K leap","code":"class GFG { static int solve ( int N , int K ) {"}
{"text":"elements of combo [ ] stores the no . of possible ways to reach it by all combinations of k leaps or less","code":"int [ ] combo ; combo = new int [ 50 ] ;"}
{"text":"assuming leap 0 exist and assigning its value to 1 for calculation","code":"combo [ 0 ] = 1 ;"}
{"text":"loop to iterate over all possible leaps upto k ;","code":"for ( int i = 1 ; i <= K ; i ++ ) {"}
{"text":"in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less","code":"for ( int j = 0 ; j <= N ; j ++ ) {"}
{"text":"if the leap is not more than the i - j","code":"if ( j >= i ) {"}
{"text":"calculate the value and store in combo [ j ] to reuse it for next leap calculation for the jth stair","code":"combo [ j ] += combo [ j - i ] ; } } }"}
{"text":"returns the no of possible number of leaps to reach the top of building of n stairs","code":"return combo [ N ] ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"N i the no of total stairs K is the value of the greatest leap","code":"int N = 29 ; int K = 5 ; System . out . println ( solve ( N , K ) ) ; solve ( N , K ) ; } }"}
{"text":"Java implementation to find LIS in circular way","code":"class Test {"}
{"text":"Utility method to find LIS using Dynamic programming","code":"static int computeLIS ( int circBuff [ ] , int start , int end , int n ) { int LIS [ ] = new int [ n + end - start ] ;"}
{"text":"Initialize LIS values for all indexes","code":"for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ;"}
{"text":"Compute optimized LIS values in bottom up manner","code":"for ( int i = start + 1 ; i < end ; i ++ )"}
{"text":"Set j on the basis of current window i . e . first element of the current window","code":"for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ;"}
{"text":"Pick maximum of all LIS values","code":"int res = Integer . MIN_VALUE ; for ( int i = start ; i < end ; i ++ ) res = Math . max ( res , LIS [ i ] ) ; return res ; }"}
{"text":"Function to find Longest Increasing subsequence in Circular manner","code":"static int LICS ( int arr [ ] , int n ) {"}
{"text":"Make a copy of given array by appending same array elements to itself","code":"int circBuff [ ] = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ;"}
{"text":"Perform LIS for each window of size n","code":"int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; }"}
{"text":"Driver method","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 } ; System . out . println ( \" Length \u2581 of \u2581 LICS \u2581 is \u2581 \" + LICS ( arr , arr . length ) ) ; } }"}
{"text":"Java Program for above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"utility min","code":"static int min ( int a , int b ) { return a < b ? a : b ; }"}
{"text":"Function for binomial Coefficient","code":"static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ;"}
{"text":"Constructing Pascal 's Triangle","code":"for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" Number \u2581 of \u2581 Paths : \u2581 \" + binomialCoeff ( n + m , n ) ) ; } }"}
{"text":"A Java Program to find length of the Longest Common Increasing Subsequence ( LCIS )","code":"import java . io . * ; class GFG {"}
{"text":"Returns the length and the LCIS of two arrays arr1 [ 0. . n - 1 ] and arr2 [ 0. . m - 1 ]","code":"static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) {"}
{"text":"table [ j ] is going to store length of LCIS ending with arr2 [ j ] . We initialize it as 0 ,","code":"int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ;"}
{"text":"Traverse all elements of arr1 [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Initialize current length of LCIS","code":"int current = 0 ;"}
{"text":"For each element of arr1 [ ] , trvarse all elements of arr2 [ ] .","code":"for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"If both the array have same elements . Note that we don 't  break the loop here.","code":"if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ;"}
{"text":"Now seek for previous smaller common element for current element of arr1","code":"if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } }"}
{"text":"The maximum value in table [ ] is out result","code":"int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = arr1 . length ; int m = arr2 . length ; System . out . println ( \" Length \u2581 of \u2581 LCIS \u2581 is \u2581 \" + LCIS ( arr1 , n , arr2 , m ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to get the length of the longest common prefix by rearranging the Strings","code":"static int longComPre ( String arr [ ] , int N ) {"}
{"text":"freq [ i ] [ j ] : stores the frequency of a character ( = j ) in a String arr [ i ]","code":"int [ ] [ ] freq = new int [ N ] [ 256 ] ;"}
{"text":"Traverse the given array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Stores length of current String","code":"int M = arr [ i ] . length ( ) ;"}
{"text":"Traverse current String of the given array","code":"for ( int j = 0 ; j < M ; j ++ ) {"}
{"text":"Update the value of freq [ i ] [ arr [ i ] [ j ] ]","code":"freq [ i ] [ arr [ i ] . charAt ( j ) ] ++ ; } }"}
{"text":"Stores the length of longest common prefix","code":"int maxLen = 0 ;"}
{"text":"Count the minimum frequency of each character in in all the Strings of arr [ ]","code":"for ( int j = 0 ; j < 256 ; j ++ ) {"}
{"text":"Stores minimum value in each row of freq [ ] [ ]","code":"int minRowVal = Integer . MAX_VALUE ;"}
{"text":"Calculate minimum frequency of current character in all the Strings .","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update minRowVal","code":"minRowVal = Math . min ( minRowVal , freq [ i ] [ j ] ) ; }"}
{"text":"Update maxLen","code":"maxLen += minRowVal ; } return maxLen ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String arr [ ] = { \" aabdc \" , \" abcd \" , \" aacd \" } ; int N = 3 ; System . out . print ( longComPre ( arr , N ) ) ; } }"}
{"text":"Java program to remove characters from a String that appears exactly K times","code":"import java . util . * ; class GFG { static int MAX_CHAR = 26 ;"}
{"text":"Function to reduce the String by removing the characters which appears exactly k times","code":"static String removeChars ( char arr [ ] , int k ) {"}
{"text":"Hash table initialised to 0","code":"int [ ] hash = new int [ MAX_CHAR ] ;"}
{"text":"Increment the frequency of the character","code":"int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ;"}
{"text":"To store answer","code":"String ans = \" \" ;"}
{"text":"Next index in reduced string","code":"for ( int i = 0 ; i < n ; ++ i ) {"}
{"text":"Append the characters which appears exactly k times","code":"if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { char str [ ] = \" geeksforgeeks \" . toCharArray ( ) ; int k = 2 ;"}
{"text":"Function call","code":"System . out . print ( removeChars ( str , k ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that prints the segments","code":"static void sub_segments ( String str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . substring ( x , x + n ) ;"}
{"text":"New array for every iteration","code":"List < Character > arr = new ArrayList < Character > ( ) ; for ( char y : newlist . toCharArray ( ) ) {"}
{"text":"Check if the character is in the array","code":"if ( ! arr . contains ( y ) ) arr . add ( y ) ; } for ( char y : arr ) System . out . print ( y ) ; System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeksgfg \" ; int n = 4 ; sub_segments ( str , n ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; import java . io . * ; class GFG {"}
{"text":"Static function declared to find the encrypted string","code":"public static void findWord ( String c , int n ) { int co = 0 , i ;"}
{"text":"Character array to store the encrypted string","code":"char s [ ] = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n \/ 2 ) co ++ ; else co = n - i ;"}
{"text":"after ' z ' , it should go to a .","code":"if ( ( c . charAt ( i ) + co ) <= 122 ) s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co ) ; else s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co - 26 ) ; }"}
{"text":"storing the character array in the string .","code":"String str = Arrays . toString ( s ) ; System . out . println ( str ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String s = \" abcd \" ; findWord ( s , s . length ( ) ) ; } }"}
{"text":"Function to compare two strings ignoring their cases","code":"class GFG { static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ;"}
{"text":"length of first string","code":"int len1 = str1 . length ( ) ;"}
{"text":"length of second string","code":"int len2 = str2 . length ( ) ;"}
{"text":"if length is not same simply return false since both string can not be same if length is not equal","code":"if ( len1 != len2 ) return false ;"}
{"text":"loop to match one by one all characters of both string","code":"while ( i < len1 ) {"}
{"text":"if current characters of both string are same , increase value of i to compare next character","code":"if ( str1 . charAt ( i ) == str2 . charAt ( i ) ) { i ++ ; }"}
{"text":"if any character of first string is some special character or numeric character and not same as corresponding character of second string then return false","code":"else if ( ! ( ( str1 . charAt ( i ) >= ' a ' && str1 . charAt ( i ) <= ' z ' ) || ( str1 . charAt ( i ) >= ' A ' && str1 . charAt ( i ) <= ' Z ' ) ) ) { return false ; }"}
{"text":"do the same for second string","code":"else if ( ! ( ( str2 . charAt ( i ) >= ' a ' && str2 . charAt ( i ) <= ' z ' ) || ( str2 . charAt ( i ) >= ' A ' && str2 . charAt ( i ) <= ' Z ' ) ) ) { return false ; }"}
{"text":"this block of code will be executed if characters of both strings are of different cases","code":"else {"}
{"text":"compare characters by ASCII value","code":"if ( str1 . charAt ( i ) >= ' a ' && str1 . charAt ( i ) <= ' z ' ) { if ( str1 . charAt ( i ) - 32 != str2 . charAt ( i ) ) return false ; } else if ( str1 . charAt ( i ) >= ' A ' && str1 . charAt ( i ) <= ' Z ' ) { if ( str1 . charAt ( i ) + 32 != str2 . charAt ( i ) ) return false ; }"}
{"text":"if characters matched , increase the value of i to compare next char","code":"i ++ ;"}
{"text":"if all characters of the first string are matched with corresponding characters of the second string , then return true","code":"return true ;"}
{"text":"Function to print the same or not same if strings are equal or not equal","code":"static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) System . out . println ( \" Same \" ) ; else System . out . println ( \" Not \u2581 Same \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the maximized value of A","code":"static String maxValue ( char [ ] a , char [ ] b ) {"}
{"text":"Sort digits in ascending order","code":"Arrays . sort ( b ) ; int n = a . length ; int m = b . length ;"}
{"text":"j points to largest digit in B","code":"int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If all the digits of b have been used","code":"if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ;"}
{"text":"Current digit has been used","code":"j -- ; } }"}
{"text":"Return the maximized value","code":"return String . valueOf ( a ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String a = \"1234\" ; String b = \"4321\" ; System . out . print ( maxValue ( a . toCharArray ( ) , b . toCharArray ( ) ) ) ; } }"}
{"text":"Java program for above approach","code":"class GfG {"}
{"text":"Function to check if all of the digits in a number and it 's product with q  are unequal or not","code":"static boolean checkIfUnequal ( int n , int q ) {"}
{"text":"convert first number into string","code":"String s1 = Integer . toString ( n ) ; int a [ ] = new int [ 26 ] ;"}
{"text":"Insert elements from 1 st number to hash","code":"for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) a [ s1 . charAt ( i ) - '0' ] ++ ;"}
{"text":"Calculate corresponding product","code":"int prod = n * q ;"}
{"text":"Convert the product to string","code":"String s2 = Integer . toString ( prod ) ;"}
{"text":"Using the hash check if any digit of product matches with the digits of input number","code":"for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) {"}
{"text":"If yes , return false","code":"if ( a [ s2 . charAt ( i ) - '0' ] > 0 ) return false ; }"}
{"text":"else , return true","code":"return true ; }"}
{"text":"Function to count numbers in the range [ l , r ] such that all of the digits of the number and it 's product with q are unequal","code":"static int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) {"}
{"text":"check for every number between l and r","code":"if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int l = 10 , r = 12 , q = 2 ;"}
{"text":"Function Call","code":"System . out . println ( countInRange ( l , r , q ) ) ; } }"}
{"text":"Java program to check if we can rearrange a string such that it has alternate 0 s and 1 s .","code":"import java . lang . Math ; public class GfG {"}
{"text":"function to check the binary string","code":"public static boolean is_possible ( String s ) {"}
{"text":"length of string","code":"int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) {"}
{"text":"count zero 's","code":"if ( s . charAt ( i ) == '0' ) zero ++ ;"}
{"text":"count one 's","code":"else one ++ ; }"}
{"text":"if length is even","code":"if ( l % 2 == 0 ) return ( one == zero ) ;"}
{"text":"if length is odd","code":"else return ( Math . abs ( one - zero ) == 1 ) ; } public static void main ( String [ ] args ) { String s = \"100110\" ; if ( is_possible ( s ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to count frequencies of array items","code":"class GFG { static int limit = 255 ; static void countFreq ( String str ) {"}
{"text":"Create an array to store counts . The size of array is limit + 1 and all values are initially 0","code":"int [ ] count = new int [ limit + 1 ] ;"}
{"text":"Traverse through string characters and count frequencies","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( ( char ) i + \" \u2581 \" + count [ i ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" GeeksforGeeks \" ; countFreq ( str ) ; } }"}
{"text":"Java program to count the set bits after taking XOR with a number K","code":"class GFG {"}
{"text":"Function to get no of set bits in binary representation of positive integer n","code":"static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }"}
{"text":"Function to store EVEN and odd variable","code":"static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ;"}
{"text":"Store the count of even and odd set bit","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Count the set bit using in built function","code":"int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ;"}
{"text":"Count of set - bit of K","code":"y = __builtin_popcount ( K ) ;"}
{"text":"If y is odd then , count of even and odd set bit will be interchanged","code":"if ( ( y & 1 ) != 0 ) { System . out . println ( \" Even \u2581 = \u2581 \" + odd + \" , \u2581 Odd \u2581 = \u2581 \" + even ) ; }"}
{"text":"Else it will remain same as the original array","code":"else { System . out . println ( \" Even \u2581 = \u2581 \" + even + \" , \u2581 Odd \u2581 = \u2581 \" + odd ) ; } }"}
{"text":"Driver 's Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ;"}
{"text":"Function call to count even and odd","code":"countEvenOdd ( arr , n , K ) ; } }"}
{"text":"Java program to convert given sentence to camel case .","code":"import java . io . * ; class GFG {"}
{"text":"Function to remove spaces and convert into camel case","code":"static String convert ( String s ) { int n = s . length ( ) ; String s1 = \" \" ; s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"check for spaces in the sentence","code":"if ( s . charAt ( i ) == ' \u2581 ' && i < n ) {"}
{"text":"conversion into upper case","code":"s1 = s1 + \" \u2581 \" + Character . toLowerCase ( s . charAt ( i + 1 ) ) ; i ++ ; }"}
{"text":"If not space , copy character","code":"else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ; }"}
{"text":"return string to main","code":"return s1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" I \u2581 get \u2581 intern \u2581 at \u2581 geeksforgeeks \" ; System . out . println ( convert ( str ) ) ; } }"}
{"text":"Java code to transform string","code":"import java . io . * ; class Gfg {"}
{"text":"Function to change character 's case","code":"public static String change_case ( String a ) { String temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ;"}
{"text":"If character is lowercase change to uppercase","code":"if ( ch >= ' a ' && ch <= ' z ' ) ch = ( char ) ( 65 + ( int ) ( ch - ' a ' ) ) ;"}
{"text":"If character is uppercase change to lowercase","code":"else if ( ch >= ' A ' && ch <= ' Z ' ) ch = ( char ) ( 97 + ( int ) ( ch - ' A ' ) ) ; temp += ch ; } return temp ; }"}
{"text":"Function to delete vowels","code":"public static String delete_vowels ( String a ) { String temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ;"}
{"text":"If character is consonant","code":"if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' && ch != ' A ' && ch != ' E ' && ch != ' O ' && ch != ' U ' && ch != ' I ' ) temp += ch ; } return temp ; }"}
{"text":"Function to insert \" # \"","code":"public static String insert_hash ( String a ) { String temp = \" \" ; int l = a . length ( ) ; char hash = ' # ' ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ;"}
{"text":"If character is not special character","code":"if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) temp = temp + hash + ch ; else temp = temp + ch ; } return temp ; }"}
{"text":"Function to transform string","code":"public static void transformString ( String a ) { String b = delete_vowels ( a ) ; String c = change_case ( b ) ; String d = insert_hash ( c ) ; System . out . println ( d ) ; }"}
{"text":"Driver function","code":"public static void main ( String args [ ] ) { String a = \" SunshinE ! ! \" ;"}
{"text":"Calling function","code":"transformString ( a ) ; } }"}
{"text":"Java program for above approach","code":"class GFG {"}
{"text":"Iterative function to reverse digits of num","code":"static int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num \/ 10 ; } return rev_num ; }"}
{"text":"Function to calculate sum of all proper divisors num -- > given natural number","code":"static int properDivSum ( int num ) {"}
{"text":"Final result of summation of divisors","code":"int result = 0 ;"}
{"text":"find all divisors which divides ' num '","code":"for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) {"}
{"text":"if ' i ' is divisor of ' num '","code":"if ( num % i == 0 ) {"}
{"text":"if both divisors are same then add it only once else add both","code":"if ( i == ( num \/ i ) ) result += i ; else result += ( i + num \/ i ) ; } }"}
{"text":"Add 1 to the result as 1 is also a divisor","code":"return ( result + 1 ) ; } static boolean isTcefrep ( int n ) { return properDivSum ( n ) == reverse ( n ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Number N","code":"int N = 6 ;"}
{"text":"Function Call","code":"if ( isTcefrep ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"java program to find n - th number containing only 3 and 5.","code":"public class GFG { static String findNthNo ( int n ) { String res = \" \" ; while ( n >= 1 ) {"}
{"text":"If n is odd , append 3 and move to parent","code":"if ( ( n & 1 ) == 1 ) { res = res + \"3\" ; n = ( n - 1 ) \/ 2 ; }"}
{"text":"If n is even , append 5 and move to parent","code":"else { res = res + \"5\" ; n = ( n - 2 ) \/ 2 ; } }"}
{"text":"Reverse res and return .","code":"StringBuilder sb = new StringBuilder ( res ) ; sb . reverse ( ) ; return new String ( sb ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 5 ; System . out . print ( findNthNo ( n ) ) ; } }"}
{"text":"Java program to find n - th non - square number .","code":"import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"function to find the nth Non - Square Number","code":"static int findNthNonSquare ( int n ) {"}
{"text":"conversion from int to long double is necessary in order to preserve decimal places after square root .","code":"double x = ( double ) n ;"}
{"text":"calculating the result","code":"double ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return ( int ) ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"initializing the term number","code":"int n = 16 ;"}
{"text":"Print the result","code":"System . out . print ( \" The \u2581 \" + n + \" th \u2581 Non - Square \u2581 number \u2581 is \u2581 \" ) ; System . out . print ( findNthNonSquare ( n ) ) ; } }"}
{"text":"Efficient Java program to find sum of series with alternate signed square AP sums .","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"function to calculate series sum","code":"static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) \/ ( 2 * n - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; System . out . println ( seiresSum ( n , a ) ) ; } }"}
{"text":"Java program to find nth number that contains the digit k or divisible by k .","code":"import java . io . * ; class GFG {"}
{"text":"Function for checking if digit k is in n or not","code":"public static boolean checkdigit ( int n , int k ) { while ( n != 0 ) {"}
{"text":"finding remainder","code":"int rem = n % 10 ;"}
{"text":"if digit found","code":"if ( rem == k ) return true ; n = n \/ 10 ; } return false ; }"}
{"text":"Function for finding nth number","code":"public static int findNthNumber ( int n , int k ) {"}
{"text":"since k is the first which satisfy th criteria , so consider it in count making count = 1 and starting from i = k + 1","code":"for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) {"}
{"text":"checking that the number contain k digit or divisible by k","code":"if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( findNthNumber ( n , k ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { public static int find_permutations ( Vector < Integer > arr ) { int cnt = 0 ; int max_ind = - 1 , min_ind = 10000000 ; int n = arr . size ( ) ; HashMap < Integer , Integer > index_of = new HashMap < > ( ) ;"}
{"text":"Save index of numbers of the array","code":"for ( int i = 0 ; i < n ; i ++ ) { index_of . put ( arr . get ( i ) , i + 1 ) ; } for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"Update min and max index with the current index and check if it 's a valid permutation","code":"max_ind = Math . max ( max_ind , index_of . get ( i ) ) ; min_ind = Math . min ( min_ind , index_of . get ( i ) ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { Vector < Integer > nums = new Vector < Integer > ( ) ; nums . add ( 2 ) ; nums . add ( 3 ) ; nums . add ( 1 ) ; nums . add ( 5 ) ; nums . add ( 4 ) ; System . out . print ( find_permutations ( nums ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Recursive function to return gcd","code":"static int calgcd ( int a , int b ) { if ( b == 0 ) return a ; return calgcd ( b , a % b ) ; }"}
{"text":"Function to return the count of the required integers","code":"static int getCount ( int [ ] a , int n ) {"}
{"text":"To store the gcd of the array elements","code":"int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ;"}
{"text":"To store the count of factors of the found gcd","code":"int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) {"}
{"text":"If g is a perfect square","code":"if ( i * i == gcd ) cnt ++ ;"}
{"text":"Factors appear in pairs","code":"else cnt += 2 ; } } return cnt ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] a = { 4 , 16 , 1024 , 48 } ; int n = a . length ; System . out . println ( getCount ( a , n ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum cost of removing characters to make the string unique","code":"public static int delCost ( String s , int [ ] cost ) {"}
{"text":"stores the visited character","code":"boolean visited [ ] = new boolean [ s . length ( ) ] ;"}
{"text":"stores the answer","code":"int ans = 0 ;"}
{"text":"traverse the string","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"if already visited","code":"if ( visited [ i ] ) { continue ; }"}
{"text":"Stores the maximum cost of removing a particular character","code":"int maxDel = 0 ;"}
{"text":"Store the total deletion cost of a particular character","code":"int totalCost = 0 ;"}
{"text":"Mark the current character visited","code":"visited [ i ] = true ;"}
{"text":"Traverse the indices of the string [ i , N - 1 ]","code":"for ( int j = i ; j < s . length ( ) ; j ++ ) {"}
{"text":"If any duplicate is found","code":"if ( s . charAt ( i ) == s . charAt ( j ) ) {"}
{"text":"Update the maximum cost and total cost","code":"maxDel = Math . max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ;"}
{"text":"Mark the current character visited","code":"visited [ j ] = true ; } }"}
{"text":"Keep the character with maximum cost and delete the rest","code":"ans += totalCost - maxDel ; }"}
{"text":"return the minimum cost","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"input string","code":"String s = \" AAABBB \" ;"}
{"text":"input array","code":"int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ;"}
{"text":"function call","code":"System . out . println ( delCost ( s , cost ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find triplets such that replacing them with their XOR make all array elements equal","code":"static void checkXOR ( int arr [ ] , int N ) {"}
{"text":"If N is even","code":"if ( N % 2 == 0 ) {"}
{"text":"Calculate xor of array elements","code":"int xro = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update xor","code":"xro ^= arr [ i ] ; }"}
{"text":"If xor is not equal to 0","code":"if ( xro != 0 ) { System . out . println ( - 1 ) ; return ; }"}
{"text":"Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal","code":"for ( int i = 0 ; i < N - 3 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( i + 2 ) ) ; }"}
{"text":"Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]","code":"for ( int i = 0 ; i < N - 3 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( N - 1 ) ) ; } } else {"}
{"text":"Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal","code":"for ( int i = 0 ; i < N - 2 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( i + 2 ) ) ; }"}
{"text":"Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]","code":"for ( int i = 0 ; i < N - 2 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( N - 1 ) ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 4 , 2 , 1 , 7 , 2 } ;"}
{"text":"Size of array","code":"int N = arr . length ;"}
{"text":"Function call","code":"checkXOR ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find minimum count of operations required to make all array elements even","code":"static int make_array_element_even ( int arr [ ] , int N ) {"}
{"text":"Stores minimum count of replacements to make all array elements even","code":"int res = 0 ;"}
{"text":"Stores the count of odd continuous numbers","code":"int odd_cont_seg = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If arr [ i ] is an odd number","code":"if ( arr [ i ] % 2 == 1 ) {"}
{"text":"Update odd_cont_seg","code":"odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) {"}
{"text":"If odd_cont_seg is even","code":"if ( odd_cont_seg % 2 == 0 ) {"}
{"text":"Update res","code":"res += odd_cont_seg \/ 2 ; } else {"}
{"text":"Update res","code":"res += ( odd_cont_seg \/ 2 ) + 2 ; }"}
{"text":"Reset odd_cont_seg = 0","code":"odd_cont_seg = 0 ; } } }"}
{"text":"If odd_cont_seg exceeds 0","code":"if ( odd_cont_seg > 0 ) {"}
{"text":"If odd_cont_seg is even","code":"if ( odd_cont_seg % 2 == 0 ) {"}
{"text":"Update res","code":"res += odd_cont_seg \/ 2 ; } else {"}
{"text":"Update res","code":"res += odd_cont_seg \/ 2 + 2 ; } }"}
{"text":"Print the result","code":"return res ; }"}
{"text":"Drivers Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 11 , 6 } ; int N = arr . length ; System . out . print ( make_array_element_even ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find K for which there are exactly K array elements greater than or equal to K","code":"public static int zvalue ( int [ ] nums ) {"}
{"text":"Finding the largest array element","code":"int m = max_element ( nums ) ; int cnt = 0 ;"}
{"text":"Possible values of K","code":"for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ;"}
{"text":"Traverse the array","code":"for ( int j = 0 ; j < nums . length ; j ++ ) {"}
{"text":"If current array element is greater than or equal to i","code":"if ( nums [ j ] >= i ) cnt ++ ; }"}
{"text":"If i array elements are greater than or equal to i","code":"if ( cnt == i ) return i ; }"}
{"text":"Otherwise","code":"return - 1 ; }"}
{"text":"To find maximum Element","code":"public static int max_element ( int [ ] nums ) { int max = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; i ++ ) max = Math . max ( max , nums [ i ] ) ; return max ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int [ ] nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; System . out . println ( zvalue ( nums ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . lang . * ; import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the lexicographically smallest anagram of string which contains another string","code":"static String [ ] lexico_smallest ( String s1 , String s2 ) {"}
{"text":"Initializing the map and set","code":"Map < Character , Integer > M = new HashMap < > ( ) ; Set < Character > S = new TreeSet < > ( ) ;"}
{"text":"Iterating over s1","code":"for ( int i = 0 ; i <= s1 . length ( ) - 1 ; ++ i ) {"}
{"text":"Storing the frequency of characters present in s1","code":"if ( ! M . containsKey ( s1 . charAt ( i ) ) ) M . put ( s1 . charAt ( i ) , 1 ) ; else M . replace ( s1 . charAt ( i ) , M . get ( s1 . charAt ( i ) ) + 1 ) ;"}
{"text":"Storing the distinct characters present in s1","code":"S . add ( s1 . charAt ( i ) ) ; }"}
{"text":"Decreasing the frequency of characters from M that are already present in s2","code":"for ( int i = 0 ; i <= s2 . length ( ) - 1 ; ++ i ) { if ( M . containsKey ( s2 . charAt ( i ) ) ) M . replace ( s2 . charAt ( i ) , M . get ( s2 . charAt ( i ) ) - 1 ) ; } char c = s2 . charAt ( 0 ) ; int index = 0 ; String res = \" \" ;"}
{"text":"Traversing alphabets in sorted order","code":"Iterator < Character > it = S . iterator ( ) ; while ( it . hasNext ( ) ) { char x = it . next ( ) ;"}
{"text":"If current character of set is not equal to current character of s2","code":"if ( x != c ) { for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } } else {"}
{"text":"If element is equal to current character of s2","code":"int j = 0 ; index = res . length ( ) ;"}
{"text":"Checking for second distinct character in s2","code":"while ( s2 . charAt ( j ) == x ) { j ++ ; }"}
{"text":"s2 [ j ] will store second distinct character","code":"if ( s2 . charAt ( j ) < c ) { res += s2 ; for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } index += M . get ( x ) ; res += s2 ; } } } String pr [ ] = { res , index + \" \" } ; return pr ; }"}
{"text":"Return the answer","code":"return pr ; }"}
{"text":"Function to find the lexicographically largest anagram of string which contains another string","code":"static String lexico_largest ( String s1 , String s2 ) {"}
{"text":"Getting the lexicographically smallest anagram","code":"String pr [ ] = lexico_smallest ( s1 , s2 ) ;"}
{"text":"d1 stores the prefix","code":"String d1 = \" \" ; for ( int i = Integer . valueOf ( pr [ 1 ] ) - 1 ; i >= 0 ; i -- ) { d1 += pr [ 0 ] . charAt ( i ) ; }"}
{"text":"d2 stores the suffix","code":"String d2 = \" \" ; for ( int i = pr [ 0 ] . length ( ) - 1 ; i >= Integer . valueOf ( pr [ 1 ] ) + s2 . length ( ) ; -- i ) { d2 += pr [ 0 ] . charAt ( i ) ; } String res = d2 + s2 + d1 ;"}
{"text":"Return the result","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given two strings","code":"String s1 = \" ethgakagmenpgs \" ; String s2 = \" geeks \" ;"}
{"text":"Function Calls","code":"System . out . println ( lexico_smallest ( s1 , s2 ) [ 0 ] ) ; System . out . println ( lexico_largest ( s1 , s2 ) ) ; } }"}
{"text":"Java implementation for the above approach","code":"import java . util . * ; class GFG { static int sz = ( int ) 1e5 ;"}
{"text":"Adjacency list to represent the tree","code":"static Vector < Integer > [ ] tree = new Vector [ sz ] ;"}
{"text":"Number of vertices","code":"static int n ;"}
{"text":"Mark visited \/ unvisited vertices","code":"static boolean [ ] vis = new boolean [ sz ] ;"}
{"text":"Stores the subtree size of the corresponding nodes","code":"static int [ ] subtreeSize = new int [ sz ] ;"}
{"text":"Function to create an edge between two vertices","code":"static void addEdge ( int a , int b ) {"}
{"text":"Add a to b 's list","code":"tree [ a ] . add ( b ) ;"}
{"text":"Add b to a 's list","code":"tree [ b ] . add ( a ) ; }"}
{"text":"Function to perform DFS","code":"static void dfs ( int x ) {"}
{"text":"Mark the vertex visited","code":"vis [ x ] = true ;"}
{"text":"Include the node in the subtree","code":"subtreeSize [ x ] = 1 ;"}
{"text":"Traverse all its children","code":"for ( int i : tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } }"}
{"text":"Function to print the required number of paths","code":"static void countPairs ( int a , int b ) { int sub = Math . min ( subtreeSize [ a ] , subtreeSize [ b ] ) ; System . out . print ( sub * ( n - sub ) + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Number of vertices","code":"n = 6 ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ;"}
{"text":"Calling modified dfs function","code":"dfs ( 0 ) ;"}
{"text":"Count pairs of vertices in the tree","code":"countPairs ( 1 , 3 ) ; countPairs ( 0 , 2 ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the count of desired permutations","code":"static int findPermutation ( Set < Integer > arr , int N ) { int pos = arr . size ( ) + 1 ;"}
{"text":"Base case","code":"if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) {"}
{"text":"If i has not been inserted","code":"if ( ! arr . contains ( i ) ) {"}
{"text":"Backtrack","code":"if ( i % pos == 0 pos % i == 0 ) {"}
{"text":"Insert i","code":"arr . add ( i ) ;"}
{"text":"Recur to find valid permutations","code":"res += findPermutation ( arr , N ) ;"}
{"text":"Remove i","code":"arr . remove ( i ) ; } } }"}
{"text":"Return the final count","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 5 ; Set < Integer > arr = new HashSet < Integer > ( ) ; System . out . print ( findPermutation ( arr , N ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr [ ]","code":"static void solve ( int arr [ ] , int n , int X , int Y ) {"}
{"text":"Store the difference","code":"int diff = Y - X ;"}
{"text":"Iterate over the array","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } }"}
{"text":"If diff reduced to 0","code":"if ( diff == 0 ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 9 , 10 } ; int n = arr . length ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { static final int maxN = 100001 ;"}
{"text":"Adjacency List to store the graph","code":"@ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ maxN ] ;"}
{"text":"Stores the height of each node","code":"static int [ ] height = new int [ maxN ] ;"}
{"text":"Stores the maximum distance of a node from its ancestors","code":"static int [ ] dist = new int [ maxN ] ;"}
{"text":"Function to add edge between two vertices","code":"static void addEdge ( int u , int v ) {"}
{"text":"Insert edge from u to v","code":"adj [ u ] . add ( v ) ;"}
{"text":"Insert edge from v to u","code":"adj [ v ] . add ( u ) ; }"}
{"text":"Function to calculate height of each Node","code":"static void dfs1 ( int cur , int par ) {"}
{"text":"Iterate in the adjacency list of the current node","code":"for ( int u : adj [ cur ] ) { if ( u != par ) {"}
{"text":"Dfs for child node","code":"dfs1 ( u , cur ) ;"}
{"text":"Calculate height of nodes","code":"height [ cur ] = Math . max ( height [ cur ] , height [ u ] ) ; } }"}
{"text":"Increase height","code":"height [ cur ] += 1 ; }"}
{"text":"Function to calculate the maximum distance of a node from its ancestor","code":"static void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ;"}
{"text":"Iterate in the adjacency list of the current node","code":"for ( int u : adj [ cur ] ) { if ( u != par ) {"}
{"text":"Find two children with maximum heights","code":"if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; for ( int u : adj [ cur ] ) { if ( u != par ) {"}
{"text":"Calculate the maximum distance with ancestor for every node","code":"sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + Math . max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + Math . max ( 1 + max1 , dist [ cur ] ) ;"}
{"text":"Calculating for children","code":"dfs2 ( u , cur ) ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 6 ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 5 , 6 ) ;"}
{"text":"Calculate height of nodes of the tree","code":"dfs1 ( 1 , 0 ) ;"}
{"text":"Calculate the maximum distance with ancestors","code":"dfs2 ( 1 , 0 ) ;"}
{"text":"Print the maximum of the two distances from each node","code":"for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ( Math . max ( dist [ i ] , height [ i ] ) - 1 ) + \" \u2581 \" ) ; } }"}
{"text":"Java program to find middle of three distinct numbers","code":"import java . util . * ; class Middle {"}
{"text":"Function to find the middle of three number","code":"public static int middleOfThree ( int a , int b , int c ) {"}
{"text":"Checking for b","code":"if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;"}
{"text":"Checking for a","code":"else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }"}
{"text":"driver code","code":"public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }"}
{"text":"Java program for implementation of selection sort","code":"import java . util . * ; class GFG {"}
{"text":"Function to implement the selection sort","code":"static void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ;"}
{"text":"One by one move boundary of unsorted subarray","code":"for ( i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"Find the minimum element in unsorted array","code":"min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ;"}
{"text":"Swap the found minimum element with the first element","code":"int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } }"}
{"text":"Function to print an array","code":"static void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = arr . length ;"}
{"text":"Function Call","code":"selectionSort ( arr , n ) ; System . out . print ( \"Sorted array: NEW_LINE\");"}
{"text":"Print the array","code":"printArray ( arr , n ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { static boolean checkStr1CanConStr2 ( String str1 , String str2 ) {"}
{"text":"Stores length of str1","code":"int N = str1 . length ( ) ;"}
{"text":"Stores length of str2","code":"int M = str2 . length ( ) ;"}
{"text":"Stores distinct characters of str1","code":"HashSet < Integer > st1 = new HashSet < > ( ) ;"}
{"text":"Stores distinct characters of str2","code":"HashSet < Integer > st2 = new HashSet < > ( ) ;"}
{"text":"Stores frequency of each character of str1","code":"int hash1 [ ] = new int [ 256 ] ;"}
{"text":"Traverse the String str1","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update frequency of str1 [ i ]","code":"hash1 [ str1 . charAt ( i ) ] ++ ; }"}
{"text":"Traverse the String str1","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Insert str1 [ i ] into st1","code":"st1 . add ( ( int ) str1 . charAt ( i ) ) ; }"}
{"text":"Traverse the String str2","code":"for ( int i = 0 ; i < M ; i ++ ) {"}
{"text":"Insert str1 [ i ] into st1","code":"st2 . add ( ( int ) str2 . charAt ( i ) ) ; }"}
{"text":"If distinct characters in str1 and str2 are not same","code":"if ( ! st1 . equals ( st2 ) ) { return false ; }"}
{"text":"Stores frequency of each character of str2","code":"int hash2 [ ] = new int [ 256 ] ;"}
{"text":"Traverse the String str2","code":"for ( int i = 0 ; i < M ; i ++ ) {"}
{"text":"Update frequency of str2 [ i ]","code":"hash2 [ str2 . charAt ( i ) ] ++ ; }"}
{"text":"Sort hash1 [ ] array","code":"Arrays . sort ( hash1 ) ;"}
{"text":"Sort hash2 [ ] array","code":"Arrays . sort ( hash2 ) ;"}
{"text":"Traverse hash1 [ ] and hash2 [ ]","code":"for ( int i = 0 ; i < 256 ; i ++ ) {"}
{"text":"If hash1 [ i ] not equal to hash2 [ i ]","code":"if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str1 = \" xyyzzlll \" ; String str2 = \" yllzzxxx \" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { System . out . print ( \" True \" ) ; } else { System . out . print ( \" False \" ) ; } } }"}
{"text":"Java program to sort the array in a given index range","code":"import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to sort the elements of the array from index a to index b","code":"static void partSort ( int [ ] arr , int N , int a , int b ) {"}
{"text":"Variables to store start and end of the index range","code":"int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ;"}
{"text":"Sort the subarray from arr [ l ] to arr [ r ]","code":"Arrays . sort ( arr , l , r + 1 ) ;"}
{"text":"Print the modified array","code":"for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }"}
{"text":"A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0.","code":"class shortest_path { static int INF = Integer . MAX_VALUE , N = 4 ;"}
{"text":"A recursive function to find the shortest path from source ' s ' to destination ' d ' . This function returns the smallest possible cost to reach station N - 1 from station 0.","code":"static int minCost ( int cost [ ] [ ] ) {"}
{"text":"dist [ i ] stores minimum cost to reach station i from station 0.","code":"int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ;"}
{"text":"Go through every station and check if using it as an intermediate station gives better path","code":"for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; System . out . println ( \" The \u2581 Minimum \u2581 cost \u2581 to \u2581 reach \u2581 station \u2581 \" + N + \" \u2581 is \u2581 \" + minCost ( cost ) ) ; } }"}
{"text":"Java Program to find number of cycles of length k in a graph with n nodes .","code":"public class GFG {"}
{"text":"Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes","code":"static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) \/ n ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 4 , k = 2 ; System . out . println ( numOfways ( n , k ) ) ; } }"}
{"text":"Java program to find largest and smallest characters in a string .","code":"public class GFG {"}
{"text":"function that return the largest alphabet .","code":"static char largest_alphabet ( String a , int n ) {"}
{"text":"initializing max alphabet to ' a '","code":"char max = ' A ' ;"}
{"text":"find largest alphabet","code":"for ( int i = 0 ; i < n ; i ++ ) if ( a . charAt ( i ) > max ) max = a . charAt ( i ) ;"}
{"text":"returning largest element","code":"return max ; }"}
{"text":"function that return the smallest alphabet","code":"static char smallest_alphabet ( String a , int n ) {"}
{"text":"initializing smallest alphabet to ' z '","code":"char min = ' z ' ;"}
{"text":"find smallest alphabet","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a . charAt ( i ) < min ) min = a . charAt ( i ) ;"}
{"text":"returning smallest alphabet","code":"return min ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Input String","code":"String a = \" GeEksforGeeks \" ;"}
{"text":"Calculating size of the string","code":"int size = a . length ( ) ;"}
{"text":"calling functions and print returned value","code":"System . out . print ( \" Largest \u2581 and \u2581 smallest \u2581 alphabet \u2581 is \u2581 : \u2581 \" ) ; System . out . print ( largest_alphabet ( a , size ) + \" \u2581 and \u2581 \" ) ; System . out . println ( smallest_alphabet ( a , size ) ) ; } }"}
{"text":"Java program to get largest palindrome changing atmost K digits","code":"import java . text . ParseException ; class GFG {"}
{"text":"Returns maximum possible palindrome using k changes","code":"static String maximumPalinUsingKChanges ( String str , int k ) { char palin [ ] = str . toCharArray ( ) ; String ans = \" \" ;"}
{"text":"Initialize l and r by leftmost and rightmost ends","code":"int l = 0 ; int r = str . length ( ) - 1 ;"}
{"text":"First try to make String palindrome","code":"while ( l < r ) {"}
{"text":"Replace left and right character by maximum of both","code":"if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; }"}
{"text":"If k is negative then we can 't make  String palindrome","code":"if ( k < 0 ) { return \" Not \u2581 possible \" ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) {"}
{"text":"At mid character , if K > 0 then change it to 9","code":"if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } }"}
{"text":"If character at lth ( same as rth ) is less than 9","code":"if ( palin [ l ] < '9' ) {"}
{"text":"If none of them is changed in the previous loop then subtract 2 from K and convert both to 9","code":"if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; }"}
{"text":"If one of them is changed in the previous loop then subtract 1 from K ( 1 more is subtracted already ) and make them 9","code":"else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < palin . length ; i ++ ) ans += palin [ i ] ; return ans ; }"}
{"text":"Driver code to test above methods","code":"public static void main ( String [ ] args ) throws ParseException { String str = \"43435\" ; int k = 3 ; System . out . println ( maximumPalinUsingKChanges ( str , k ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the number of triplets whose Bitwise AND is 0.","code":"static int countTriplets ( int [ ] A ) {"}
{"text":"Stores the count of triplets having bitwise AND equal to 0","code":"int cnt = 0 ;"}
{"text":"Stores frequencies of all possible A [ i ] & A [ j ]","code":"HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Traverse the array","code":"for ( int a : A )"}
{"text":"Update frequency of Bitwise AND of all array elements with a","code":"for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; }"}
{"text":"Traverse the array","code":"for ( int a : A )"}
{"text":"Iterate the map","code":"for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) )"}
{"text":"If bitwise AND of triplet is zero , increment cnt","code":"if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ;"}
{"text":"Return the number of triplets whose Bitwise AND is 0.","code":"return cnt ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input Array","code":"int [ ] A = { 2 , 1 , 3 } ;"}
{"text":"Function Call","code":"System . out . print ( countTriplets ( A ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; public class Main { static int min ;"}
{"text":"Recursive function to calculate minimum adjacent pairs with different parity","code":"static void parity ( List < Integer > even , List < Integer > odd , List < Integer > v , int i ) {"}
{"text":"If all the numbers are placed","code":"if ( i == v . size ( ) || even . size ( ) == 0 && odd . size ( ) == 0 ) { int count = 0 ; for ( int j = 0 ; j < v . size ( ) - 1 ; j ++ ) { if ( v . get ( j ) % 2 != v . get ( j + 1 ) % 2 ) count ++ ; } if ( count < min ) min = count ; return ; }"}
{"text":"If replacement is not required","code":"if ( v . get ( i ) != - 1 ) parity ( even , odd , v , i + 1 ) ;"}
{"text":"If replacement is required","code":"else { if ( even . size ( ) != 0 ) { int x = even . get ( even . size ( ) - 1 ) ; even . remove ( even . size ( ) - 1 ) ; v . set ( i , x ) ; parity ( even , odd , v , i + 1 ) ;"}
{"text":"Backtracking","code":"even . add ( x ) ; } if ( odd . size ( ) != 0 ) { int x = odd . get ( odd . size ( ) - 1 ) ; odd . remove ( odd . size ( ) - 1 ) ; v . set ( i , x ) ; parity ( even , odd , v , i + 1 ) ;"}
{"text":"Backtracking","code":"odd . add ( x ) ; } } }"}
{"text":"Function to display the minimum number of adjacent elements with different parity","code":"static void minDiffParity ( List < Integer > v , int n ) {"}
{"text":"Store no of even numbers not present in the array","code":"List < Integer > even = new ArrayList < Integer > ( ) ;"}
{"text":"Store no of odd numbers not present in the array","code":"List < Integer > odd = new ArrayList < Integer > ( ) ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( m . containsKey ( i ) ) { m . replace ( i , 1 ) ; } else { m . put ( i , 1 ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) {"}
{"text":"Erase exisiting numbers","code":"if ( v . get ( i ) != - 1 ) m . remove ( v . get ( i ) ) ; }"}
{"text":"Store non - exisiting even and odd numbers","code":"for ( Map . Entry < Integer , Integer > i : m . entrySet ( ) ) { if ( i . getKey ( ) % 2 == 0 ) { even . add ( i . getKey ( ) ) ; } else { odd . add ( i . getKey ( ) ) ; } } min = 1000 ; parity ( even , odd , v , 0 ) ; System . out . println ( min ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 8 ; List < Integer > v = new ArrayList < Integer > ( ) ; v . add ( 2 ) ; v . add ( 1 ) ; v . add ( 4 ) ; v . add ( - 1 ) ; v . add ( - 1 ) ; v . add ( 6 ) ; v . add ( - 1 ) ; v . add ( 8 ) ; minDiffParity ( v , n ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int MAX = 100005 ; static Vector < Vector < Integer > > adjacent = new Vector < Vector < Integer > > ( ) ; static boolean visited [ ] = new boolean [ MAX ] ;"}
{"text":"To store the required nodes","code":"static int startnode , endnode , thirdnode ; static int maxi = - 1 , N ;"}
{"text":"Parent array to retrace the nodes","code":"static int parent [ ] = new int [ MAX ] ;"}
{"text":"Visited array to prevent DFS in direction on Diameter path","code":"static boolean vis [ ] = new boolean [ MAX ] ;"}
{"text":"DFS function to find the startnode","code":"static void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } }"}
{"text":"DFS function to find the endnode of diameter and maintain the parent array","code":"static void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; parent [ adjacent . get ( u ) . get ( i ) ] = u ; dfs1 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } }"}
{"text":"DFS function to find the end node of the Longest Branch to Diameter","code":"static void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] && ! vis [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs2 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } }"}
{"text":"Function to find the required nodes","code":"static void findNodes ( ) {"}
{"text":"To find start node of diameter","code":"dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ;"}
{"text":"To find end node of diameter","code":"dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ;"}
{"text":"x is the end node of diameter","code":"int x = endnode ; vis [ startnode ] = true ;"}
{"text":"Mark all the nodes on diameter using back tracking","code":"while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ;"}
{"text":"Find the end node of longest branch to diameter","code":"for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) adjacent . add ( new Vector < Integer > ( ) ) ; N = 4 ; adjacent . get ( 1 ) . add ( 2 ) ; adjacent . get ( 2 ) . add ( 1 ) ; adjacent . get ( 1 ) . add ( 3 ) ; adjacent . get ( 3 ) . add ( 1 ) ; adjacent . get ( 1 ) . add ( 4 ) ; adjacent . get ( 4 ) . add ( 1 ) ; findNodes ( ) ; System . out . print ( \" ( \" + startnode + \" , \u2581 \" + endnode + \" , \u2581 \" + thirdnode + \" ) \" ) ; } }"}
{"text":"Java program to find percentage increase in the volume of the sphere if radius is increased by a given percentage","code":"import java . io . * ; class GFG { static void newvol ( double x ) { System . out . print ( \" percentage \u2581 increase \u2581 in \u2581 the \" + \" \u2581 volume \u2581 of \u2581 the \u2581 sphere \u2581 is \u2581 \" + ( Math . pow ( x , 3 ) \/ 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) \/ 100 ) + \" % \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double x = 10 ; newvol ( x ) ; } }"}
{"text":"Java program to find the length chord of the circle whose radius and the angle subtended at the centre is also given","code":"class GFG {"}
{"text":"Function to find the length of the chord","code":"static void length_of_chord ( double r , double x ) { System . out . println ( \" The \u2581 length \u2581 of \u2581 the \u2581 chord \" + \" \u2581 of \u2581 the \u2581 circle \u2581 is \u2581 \" + 2 * r * Math . sin ( x * ( 3.14 \/ 180 ) ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; } }"}
{"text":"Java Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the area of the square","code":"static float area ( float a ) {"}
{"text":"a cannot be negative","code":"if ( a < 0 ) return - 1 ;"}
{"text":"area of the square","code":"float area = ( float ) Math . sqrt ( a ) \/ 6 ; return area ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float a = 10 ; System . out . println ( area ( a ) ) ; } }"}
{"text":"Java program to find the longest rod that can fit in a cuboid","code":"class GFG {"}
{"text":"Function to find the length","code":"static double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ;"}
{"text":"temporary variable to hold the intermediate result","code":"temp = length * length + breadth * breadth + height * height ;"}
{"text":"length of longest rod is calculated using square root function","code":"result = Math . sqrt ( temp ) ; return result ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int length = 12 , breadth = 9 , height = 8 ;"}
{"text":"calling longestRodInCuboid ( ) function to get the length of longest rod","code":"System . out . println ( ( int ) longestRodInCuboid ( length , breadth , height ) ) ; } }"}
{"text":"Java program to Check whether a given point lies inside or on the rectangle or not","code":"class GFG {"}
{"text":"function to Check whether a given point lies inside or on the rectangle or not","code":"static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) System . out . println ( \" Given \u2581 point \u2581 lies \u2581 \" + \" inside \u2581 the \u2581 rectangle \" ) ; else System . out . println ( \" Given \u2581 point \u2581 does \u2581 not \u2581 \" + \" lie \u2581 on \u2581 the \u2581 rectangle \" ) ; } }"}
{"text":"Java code to Maximize volume of cuboid with given sum of sides","code":"class GFG {"}
{"text":"Return the maximum volume .","code":"static int maxvolume ( int s ) { int maxvalue = 0 ;"}
{"text":"for length","code":"for ( int i = 1 ; i <= s - 2 ; i ++ ) {"}
{"text":"for breadth","code":"for ( int j = 1 ; j <= s - 1 ; j ++ ) {"}
{"text":"for height","code":"int k = s - i - j ;"}
{"text":"calculating maximum volume .","code":"maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { int s = 8 ; System . out . println ( maxvolume ( s ) ) ; } }"}
{"text":"Java code to Maximize volume of cuboid with given sum of sides","code":"import java . io . * ; class GFG {"}
{"text":"Return the maximum volume .","code":"static int maxvolume ( int s ) {"}
{"text":"finding length","code":"int length = s \/ 3 ; s -= length ;"}
{"text":"finding breadth","code":"int breadth = s \/ 2 ;"}
{"text":"finding height","code":"int height = s - breadth ; return length * breadth * height ; }"}
{"text":"Driven Program","code":"public static void main ( String [ ] args ) { int s = 8 ; System . out . println ( maxvolume ( s ) ) ; } }"}
{"text":"Java program to find area of a Hexagon","code":"class GFG {"}
{"text":"Create a function for calculating the area of the hexagon .","code":"public static double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) \/ 2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Length of a side","code":"double s = 4 ; System . out . print ( \" Area : \u2581 \" + hexagonArea ( s ) ) ; } }"}
{"text":"Java program for finding maximum squares that can fit in right angle isosceles triangle","code":"public class GFG {"}
{"text":"function for finding max squares","code":"static int maxSquare ( int b , int m ) {"}
{"text":"return in O ( 1 ) with derived formula","code":"return ( b \/ m - 1 ) * ( b \/ m ) \/ 2 ; }"}
{"text":"driver program","code":"public static void main ( String args [ ] ) { int b = 10 , m = 2 ; System . out . println ( maxSquare ( b , m ) ) ; } }"}
{"text":"Java program to check existence of right triangle .","code":"class GFG {"}
{"text":"Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1.","code":"static void findRightAngle ( double A , double H ) {"}
{"text":"Descriminant of the equation","code":"double D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) {"}
{"text":"applying the linear equation formula to find both the roots","code":"double root1 = ( H * H + Math . sqrt ( D ) ) \/ 2 ; double root2 = ( H * H - Math . sqrt ( D ) ) \/ 2 ; double a = Math . sqrt ( root1 ) ; double b = Math . sqrt ( root2 ) ; if ( b >= a ) System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" + H ) ; else System . out . print ( b + \" \u2581 \" + a + \" \u2581 \" + H ) ; } else System . out . print ( \" - 1\" ) ; }"}
{"text":"Driver code","code":"public static void main ( String arg [ ] ) { findRightAngle ( 6 , 5 ) ; } }"}
{"text":"Java program to count number of 2 x 2 squares in a right isosceles triangle","code":"class Squares { public static int numberOfSquares ( int base ) {"}
{"text":"removing the extra part we would always need","code":"base = ( base - 2 ) ;"}
{"text":"Since each square has base of length of 2","code":"base = Math . floorDiv ( base , 2 ) ; return base * ( base + 1 ) \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int base = 8 ; System . out . println ( numberOfSquares ( base ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the Bitwise OR of Bitwise AND of all possible subarrays after performing the every query","code":"static void performQuery ( int arr [ ] , int Q [ ] [ ] ) {"}
{"text":"Traversing each pair of the query","code":"for ( int i = 0 ; i < Q . length ; i ++ ) {"}
{"text":"Stores the Bitwise OR","code":"int or = 0 ;"}
{"text":"Updating the array","code":"int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ;"}
{"text":"Find the Bitwise OR of new updated array","code":"for ( int j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; }"}
{"text":"Print the ans","code":"System . out . print ( or + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int Q [ ] [ ] = { { 1 , 4 } , { 3 , 0 } } ; performQuery ( arr , Q ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to form the smallest number possible","code":"static int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ;"}
{"text":"Array to mark the remainders counted already","code":"int [ ] v = new int [ k ] ; Arrays . fill ( v , 0 ) ; v [ m ] = 1 ;"}
{"text":"Iterate over the range","code":"while ( 1 != 0 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ;"}
{"text":"If that remainder is already found , return - 1","code":"if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int d = 1 ; int k = 41 ; System . out . println ( smallest ( k , d ) ) ; } }"}
{"text":"java code to find vertices in a fibonacci cube graph of order n","code":"public class GFG {"}
{"text":"function to find fibonacci number","code":"static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }"}
{"text":"function for finding number of vertices in fibonacci cube graph","code":"static int findVertices ( int n ) {"}
{"text":"return fibonacci number for f ( n + 2 )","code":"return fib ( n + 2 ) ; } public static void main ( String args [ ] ) {"}
{"text":"Driver code","code":"int n = 3 ; System . out . println ( findVertices ( n ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to check if it is possible to modify the array such that there is no common factor between array elements except 1","code":"static void checkCommonDivisor ( int [ ] arr , int N , int X ) {"}
{"text":"Stores GCD of the array","code":"int G = 0 ;"}
{"text":"Calculate GCD of the array","code":"for ( int i = 0 ; i < N ; i ++ ) { G = gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) {"}
{"text":"If the current divisor is smaller than X","code":"while ( G % divisor == 0 ) {"}
{"text":"Divide GCD by the current divisor","code":"G = G \/ divisor ; } }"}
{"text":"If possible","code":"if ( G <= X ) { System . out . println ( \" Yes \" ) ;"}
{"text":"Print the modified array","code":"for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ( arr [ i ] \/ copy_G ) + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Otherwise","code":"else System . out . println ( \" No \" ) ; }"}
{"text":"Calculating gcd","code":"static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int [ ] arr = { 6 , 15 , 6 } ; int X = 6 ;"}
{"text":"Size of the array","code":"int N = arr . length ; checkCommonDivisor ( arr , N , X ) ; } }"}
{"text":"Create row and col to traverse rows and columns","code":"public class GFG { public static void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ;"}
{"text":"Variable to determine the movement r = right , l = left , d = down , u = upper","code":"char move = ' r ' ;"}
{"text":"Array for matrix","code":"int matrix [ ] [ ] = new int [ size ] [ size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) {"}
{"text":"Assign the value","code":"matrix [ row ] [ col ] = i ;"}
{"text":"switch - case to determine the next index","code":"switch ( move ) {"}
{"text":"If right , go right","code":"case ' r ' : col += 1 ; break ;"}
{"text":"if left , go left","code":"case ' l ' : col -= 1 ; break ;"}
{"text":"if up , go up","code":"case ' u ' : row -= 1 ; break ;"}
{"text":"if down , go down","code":"case ' d ' : row += 1 ; break ; }"}
{"text":"Check if the matrix has reached array boundary","code":"if ( i == boundary ) {"}
{"text":"Add the left size for the next boundary","code":"boundary += sizeLeft ;"}
{"text":"If 2 rotations has been made , decrease the size left by 1","code":"if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; }"}
{"text":"switch - case to rotate the movement","code":"switch ( move ) {"}
{"text":"if right , rotate to down","code":"case ' r ' : move = ' d ' ; break ;"}
{"text":"if down , rotate to left","code":"case ' d ' : move = ' l ' ; break ;"}
{"text":"if left , rotate to up","code":"case ' l ' : move = ' u ' ; break ;"}
{"text":"if up , rotate to right","code":"case ' u ' : move = ' r ' ; break ; } } }"}
{"text":"Print the matrix","code":"for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; System . out . print ( ( n < 10 ) ? ( n + \" \u2581 \" ) : ( n + \" \u2581 \" ) ) ; } System . out . println ( ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Get the size of size","code":"int size = 5 ;"}
{"text":"Print the Spiral Pattern","code":"printSpiral ( size ) ; } }"}
{"text":"Java implementation to sort the biotonic doubly linked list","code":"class GFG {"}
{"text":"a node of the doubly linked list","code":"static class Node { int data ; Node next ; Node prev ; }"}
{"text":"Function to reverse a Doubly Linked List","code":"static Node reverse ( Node head_ref ) { Node temp = null ; Node current = head_ref ;"}
{"text":"swap next and prev for all nodes of doubly linked list","code":"while ( current != null ) { temp = current . prev ; current . prev = current . next ; current . next = temp ; current = current . prev ; }"}
{"text":"Before changing head , check for the cases like empty list and list with only one node","code":"if ( temp != null ) head_ref = temp . prev ; return head_ref ; }"}
{"text":"Function to merge two sorted doubly linked lists","code":"static Node merge ( Node first , Node second ) {"}
{"text":"If first linked list is empty","code":"if ( first == null ) return second ;"}
{"text":"If second linked list is empty","code":"if ( second == null ) return first ;"}
{"text":"Pick the smaller value","code":"if ( first . data < second . data ) { first . next = merge ( first . next , second ) ; first . next . prev = first ; first . prev = null ; return first ; } else { second . next = merge ( first , second . next ) ; second . next . prev = second ; second . prev = null ; return second ; } }"}
{"text":"function to sort a biotonic doubly linked list","code":"static Node sort ( Node head ) {"}
{"text":"if list is empty or if it contains a single node only","code":"if ( head == null head . next == null ) return head ; Node current = head . next ; while ( current != null ) {"}
{"text":"if true , then ' current ' is the first node which is smaller than its previous node","code":"if ( current . data < current . prev . data ) break ;"}
{"text":"move to the next node","code":"current = current . next ; }"}
{"text":"if true , then list is already sorted","code":"if ( current == null ) return head ;"}
{"text":"spilt into two lists , one starting with ' head ' and other starting with ' current '","code":"current . prev . next = null ; current . prev = null ;"}
{"text":"reverse the list starting with ' current '","code":"current = reverse ( current ) ;"}
{"text":"merge the two lists and return the final merged doubly linked list","code":"return merge ( head , current ) ; }"}
{"text":"Function to insert a node at the beginning of the Doubly Linked List","code":"static Node push ( Node head_ref , int new_data ) {"}
{"text":"allocate node","code":"Node new_node = new Node ( ) ;"}
{"text":"put in the data","code":"new_node . data = new_data ;"}
{"text":"since we are adding at the beginning , prev is always null","code":"new_node . prev = null ;"}
{"text":"link the old list off the new node","code":"new_node . next = ( head_ref ) ;"}
{"text":"change prev of head node to new node","code":"if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ;"}
{"text":"move the head to point to the new node","code":"( head_ref ) = new_node ; return head_ref ; }"}
{"text":"Function to print nodes in a given doubly linked list","code":"static void printList ( Node head ) {"}
{"text":"if list is empty","code":"if ( head == null ) System . out . println ( \" Doubly \u2581 Linked \u2581 list \u2581 empty \" ) ; while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; head = head . next ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { Node head = null ;"}
{"text":"Create the doubly linked list : 2 < .5 < .7 < .12 < .10 < .6 < .4 < .1","code":"head = push ( head , 1 ) ; head = push ( head , 4 ) ; head = push ( head , 6 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 7 ) ; head = push ( head , 5 ) ; head = push ( head , 2 ) ; System . out . println ( \" Original \u2581 Doubly \u2581 linked \u2581 list : n \" ) ; printList ( head ) ;"}
{"text":"sort the biotonic DLL","code":"head = sort ( head ) ; System . out . println ( \" Doubly linked list after sorting : n \"); printList ( head ) ; } }"}
{"text":"Java program to arrange consonants and vowels nodes in a linked list","code":"class GfG {"}
{"text":"A linked list node","code":"static class Node { char data ; Node next ; }"}
{"text":"Function to add new node to the List","code":"static Node newNode ( char key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }"}
{"text":"utility function to print linked list","code":"static void printlist ( Node head ) { if ( head == null ) { System . out . println ( \" Empty \u2581 List \" ) ; return ; } while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; if ( head . next != null ) System . out . print ( \" - > \u2581 \" ) ; head = head . next ; } System . out . println ( ) ; }"}
{"text":"utility function for checking vowel","code":"static boolean isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; }"}
{"text":"function to arrange consonants and vowels nodes","code":"static Node arrange ( Node head ) { Node newHead = head ;"}
{"text":"for keep track of vowel","code":"Node latestVowel ; Node curr = head ;"}
{"text":"list is empty","code":"if ( head == null ) return null ;"}
{"text":"We need to discover the first vowel in the list . It is going to be the returned head , and also the initial latestVowel .","code":"if ( isVowel ( head . data ) == true )"}
{"text":"first element is a vowel . It will also be the new head and the initial latestVowel ;","code":"latestVowel = head ; else {"}
{"text":"First element is not a vowel . Iterate through the list until we find a vowel . Note that curr points to the element * before * the element with the vowel .","code":"while ( curr . next != null && ! isVowel ( curr . next . data ) ) curr = curr . next ;"}
{"text":"This is an edge case where there are only consonants in the list .","code":"if ( curr . next == null ) return head ;"}
{"text":"Set the initial latestVowel and the new head to the vowel item that we found . Relink the chain of consonants after that vowel item : old_head_consonant -> consonant1 -> consonant2 -> vowel -> rest_of_list becomes vowel -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list","code":"latestVowel = newHead = curr . next ; curr . next = curr . next . next ; latestVowel . next = head ; }"}
{"text":"Now traverse the list . Curr is always the item * before * the one we are checking , so that we can use it to re - link .","code":"while ( curr != null && curr . next != null ) { if ( isVowel ( curr . next . data ) == true ) {"}
{"text":"The next discovered item is a vowel","code":"if ( curr == latestVowel ) {"}
{"text":"If it comes directly after the previous vowel , we don 't need to  move items around, just mark the  new latestVowel and advance curr.","code":"latestVowel = curr = curr . next ; } else {"}
{"text":"But if it comes after an intervening chain of consonants , we need to chain the newly discovered vowel right after the old vowel . Curr is not changed as after the re - linking it will have a new next , that has not been checked yet , and we always keep curr at one before the next to check .","code":"Node temp = latestVowel . next ;"}
{"text":"Chain in new vowel","code":"latestVowel . next = curr . next ;"}
{"text":"Advance latestVowel","code":"latestVowel = latestVowel . next ;"}
{"text":"Remove found vowel from previous place","code":"curr . next = curr . next . next ;"}
{"text":"Re - link chain of consonants after latestVowel","code":"latestVowel . next = temp ; } } else {"}
{"text":"No vowel in the next element , advance curr .","code":"curr = curr . next ; } } return newHead ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Node head = newNode ( ' a ' ) ; head . next = newNode ( ' b ' ) ; head . next . next = newNode ( ' c ' ) ; head . next . next . next = newNode ( ' e ' ) ; head . next . next . next . next = newNode ( ' d ' ) ; head . next . next . next . next . next = newNode ( ' o ' ) ; head . next . next . next . next . next . next = newNode ( ' x ' ) ; head . next . next . next . next . next . next . next = newNode ( ' i ' ) ; System . out . println ( \" Linked \u2581 list \u2581 before \u2581 : \u2581 \" ) ; printlist ( head ) ; head = arrange ( head ) ; System . out . println ( \" Linked \u2581 list \u2581 after \u2581 : \" ) ; printlist ( head ) ; } }"}
{"text":"Java Program for finding K - th largest Node using O ( 1 ) extra memory and reverse Morris traversal .","code":"class GfG {"}
{"text":"Node structure","code":"static class Node { int data ; Node left , right ; }"}
{"text":"helper function to create a new Node","code":"static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . right = null ; temp . left = null ; return temp ; } static Node KthLargestUsingMorrisTraversal ( Node root , int k ) { Node curr = root ; Node Klargest = null ;"}
{"text":"count variable to keep count of visited Nodes","code":"int count = 0 ; while ( curr != null ) {"}
{"text":"if right child is NULL","code":"if ( curr . right == null ) {"}
{"text":"first increment count and check if count = k","code":"if ( ++ count == k ) Klargest = curr ;"}
{"text":"otherwise move to the left child","code":"curr = curr . left ; } else {"}
{"text":"find inorder successor of current Node","code":"Node succ = curr . right ; while ( succ . left != null && succ . left != curr ) succ = succ . left ; if ( succ . left == null ) {"}
{"text":"set left child of successor to the current Node","code":"succ . left = curr ;"}
{"text":"move current to its right","code":"curr = curr . right ; }"}
{"text":"restoring the tree back to original binary search tree removing threaded links","code":"else { succ . left = null ; if ( ++ count == k ) Klargest = curr ;"}
{"text":"move current to its left child","code":"curr = curr . left ; } } } return Klargest ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Constructed binary tree is 4 \/ \\ 2 7 \/ \\ \/ \\ 1 3 6 10","code":"Node root = newNode ( 4 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 10 ) ; System . out . println ( \" Finding \u2581 K - th \u2581 largest \u2581 Node \u2581 in \u2581 BST \u2581 : \u2581 \" + KthLargestUsingMorrisTraversal ( root , 2 ) . data ) ; } }"}
{"text":"Java implementation to sort the rows of matrix in ascending order followed by sorting the columns in descending order","code":"import java . util . Arrays ; import java . util . Collections ; class GFG { static int MAX_SIZE = 10 ;"}
{"text":"function to sort each row of the matrix according to the order specified by ascending .","code":"static void sortByRow ( Integer mat [ ] [ ] , int n , boolean ascending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ascending ) Arrays . sort ( mat [ i ] ) ; else Arrays . sort ( mat [ i ] , Collections . reverseOrder ( ) ) ; } }"}
{"text":"function to find transpose of the matrix","code":"static void transpose ( Integer mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) {"}
{"text":"swapping element at index ( i , j ) by element at index ( j , i )","code":"int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } }"}
{"text":"function to sort the matrix row - wise and column - wise","code":"static void sortMatRowAndColWise ( Integer mat [ ] [ ] , int n ) {"}
{"text":"sort rows of mat [ ] [ ]","code":"sortByRow ( mat , n , true ) ;"}
{"text":"get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) ;"}
{"text":"again sort rows of mat [ ] [ ] in descending order .","code":"sortByRow ( mat , n , false ) ;"}
{"text":"again get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) ; }"}
{"text":"function to print the matrix","code":"static void printMat ( Integer mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; Integer mat [ ] [ ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . print ( \"Original Matrix:NEW_LINE\"); printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . print ( \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }"}
{"text":"Java implementation to sort the matrix row - wise and column - wise","code":"import java . util . Arrays ; class GFG { static final int MAX_SIZE = 10 ;"}
{"text":"function to sort each row of the matrix","code":"static void sortByRow ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ )"}
{"text":"sorting row number ' i '","code":"Arrays . sort ( mat [ i ] ) ; }"}
{"text":"function to find transpose of the matrix","code":"static void transpose ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) {"}
{"text":"swapping element at index ( i , j ) by element at index ( j , i )","code":"int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } }"}
{"text":"function to sort the matrix row - wise and column - wise","code":"static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) {"}
{"text":"sort rows of mat [ ] [ ]","code":"sortByRow ( mat , n ) ;"}
{"text":"get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) ;"}
{"text":"again sort rows of mat [ ] [ ]","code":"sortByRow ( mat , n ) ;"}
{"text":"again get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) ; }"}
{"text":"function to print the matrix","code":"static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 4 , 1 , 3 } , { 9 , 6 , 8 } , { 5 , 2 , 7 } } ; int n = 3 ; System . out . print ( \"Original Matrix:NEW_LINE\"); printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . print ( \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }"}
{"text":"Java program to print Magic square of Doubly even order","code":"import java . io . * ; class GFG {"}
{"text":"Function for calculating Magic square","code":"static void doublyEven ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; int i , j ;"}
{"text":"filling matrix with its count value starting from 1 ;","code":"for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ;"}
{"text":"change value of Array elements at fix location as per rule ( n * n + 1 ) - arr [ i ] [ j ] Top Left corner of Matrix ( order ( n \/ 4 ) * ( n \/ 4 ) )","code":"for ( i = 0 ; i < n \/ 4 ; i ++ ) for ( j = 0 ; j < n \/ 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;"}
{"text":"Top Right corner of Matrix ( order ( n \/ 4 ) * ( n \/ 4 ) )","code":"for ( i = 0 ; i < n \/ 4 ; i ++ ) for ( j = 3 * ( n \/ 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;"}
{"text":"Bottom Left corner of Matrix ( order ( n \/ 4 ) * ( n \/ 4 ) )","code":"for ( i = 3 * n \/ 4 ; i < n ; i ++ ) for ( j = 0 ; j < n \/ 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;"}
{"text":"Bottom Right corner of Matrix ( order ( n \/ 4 ) * ( n \/ 4 ) )","code":"for ( i = 3 * n \/ 4 ; i < n ; i ++ ) for ( j = 3 * n \/ 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;"}
{"text":"Centre of Matrix ( order ( n \/ 2 ) * ( n \/ 2 ) )","code":"for ( i = n \/ 4 ; i < 3 * n \/ 4 ; i ++ ) for ( j = n \/ 4 ; j < 3 * n \/ 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;"}
{"text":"Printing the magic - square","code":"for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"driver program","code":"public static void main ( String [ ] args ) { int n = 8 ;"}
{"text":"Function call","code":"doublyEven ( n ) ; } }"}
{"text":"Java code to find the Kronecker Product of two matrices and stores it as matrix C","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B","code":"static int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ;"}
{"text":"Function to computes the Kronecker Product of two matrices","code":"static void Kroneckerproduct ( int A [ ] [ ] , int B [ ] [ ] ) { int [ ] [ ] C = new int [ rowa * rowb ] [ cola * colb ] ;"}
{"text":"i loops till rowa","code":"for ( int i = 0 ; i < rowa ; i ++ ) {"}
{"text":"k loops till rowb","code":"for ( int k = 0 ; k < rowb ; k ++ ) {"}
{"text":"j loops till cola","code":"for ( int j = 0 ; j < cola ; j ++ ) {"}
{"text":"l loops till colb","code":"for ( int l = 0 ; l < colb ; l ++ ) {"}
{"text":"Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C","code":"C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; System . out . print ( C [ i + l + 1 ] [ j + k + 1 ] + \" \u2581 \" ) ; } } System . out . println ( ) ; } } }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } ; int B [ ] [ ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; } }"}
{"text":"Java Program to check for a lower triangular matrix .","code":"import java . io . * ; class Lower_triangular { int N = 4 ;"}
{"text":"Function to check matrix is in lower triangular form or not .","code":"boolean isLowerTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }"}
{"text":"Driver function .","code":"public static void main ( String args [ ] ) { Lower_triangular ob = new Lower_triangular ( ) ; int mat [ ] [ ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ;"}
{"text":"Function call","code":"if ( ob . isLowerTriangularMatrix ( mat ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java Program to check upper triangular matrix .","code":"import java . util . * ; import java . lang . * ; public class GfG { private static final int N = 4 ;"}
{"text":"Function to check matrix is in upper triangular form or not .","code":"public static Boolean isUpperTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }"}
{"text":"driver function","code":"public static void main ( String argc [ ] ) { int [ ] [ ] mat = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to compute number of sets in a binary matrix .","code":"class GFG {"}
{"text":"no of columns","code":"static final int m = 3 ;"}
{"text":"no of rows","code":"static final int n = 2 ;"}
{"text":"function to calculate the number of non empty sets of cell","code":"static long countSets ( int a [ ] [ ] ) {"}
{"text":"stores the final answer","code":"long res = 0 ;"}
{"text":"traverses row - wise","code":"for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; }"}
{"text":"traverses column wise","code":"for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; }"}
{"text":"at the end subtract n * m as no of single sets have been added twice .","code":"return res - ( n * m ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 0 , 1 } , { 0 , 1 , 0 } } ; System . out . print ( countSets ( a ) ) ; } }"}
{"text":"Simple java code for check a matrix is symmetric or not .","code":"import java . io . * ; class GFG { static int MAX = 100 ;"}
{"text":"Fills transpose of mat [ N ] [ N ] in tr [ N ] [ N ]","code":"static void transpose ( int mat [ ] [ ] , int tr [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; }"}
{"text":"Returns true if mat [ N ] [ N ] is symmetric , else false","code":"static boolean isSymmetric ( int mat [ ] [ ] , int N ) { int tr [ ] [ ] = new int [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Efficient Java code for check a matrix is symmetric or no","code":"import java . io . * ; class GFG { static int MAX = 100 ;"}
{"text":"Returns true if mat [ N ] [ N ] is symmetric , else false","code":"static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text":"Java program to find trace and normal of given matrix","code":"import java . io . * ; class GFG {"}
{"text":"Size of given matrix","code":"static int MAX = 100 ;"}
{"text":"Returns Normal of a matrix of size n x n","code":"static int findNormal ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return ( int ) Math . sqrt ( sum ) ; }"}
{"text":"Returns trace of a matrix of size n x n","code":"static int findTrace ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; }"}
{"text":"Driven source","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; System . out . println ( \" Trace \u2581 of \u2581 Matrix \u2581 = \u2581 \" + findTrace ( mat , 5 ) ) ; System . out . println ( \" Normal \u2581 of \u2581 Matrix \u2581 = \u2581 \" + findNormal ( mat , 5 ) ) ; } }"}
{"text":"Java program to find maximum possible determinant of 0 \/ n matrix .","code":"import java . io . * ; public class GFG {"}
{"text":"Function for maximum determinant","code":"static int maxDet ( int n ) { return ( 2 * n * n * n ) ; }"}
{"text":"Function to print resulatant matrix","code":"void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) {"}
{"text":"three position where 0 appears","code":"if ( i == 0 && j == 2 ) System . out . print ( \"0 \u2581 \" ) ; else if ( i == 1 && j == 0 ) System . out . print ( \"0 \u2581 \" ) ; else if ( i == 2 && j == 1 ) System . out . print ( \"0 \u2581 \" ) ;"}
{"text":"position where n appears","code":"else System . out . print ( n + \" \u2581 \" ) ; } System . out . println ( \" \" ) ; } }"}
{"text":"Driver code","code":"static public void main ( String [ ] args ) { int n = 15 ; GFG geeks = new GFG ( ) ; System . out . println ( \" Maximum \u2581 Determinant \u2581 = \u2581 \" + maxDet ( n ) ) ; System . out . println ( \" Resultant \u2581 Matrix \u2581 : \" ) ; geeks . resMatrix ( n ) ; } }"}
{"text":"Java implementation of Naive method to count of negative numbers in M [ n ] [ m ]","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ;"}
{"text":"Follow the path shown using arrows above","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ;"}
{"text":"no more negative numbers in this row","code":"else break ; } } return count ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( countNegative ( M , 3 , 4 ) ) ; } }"}
{"text":"Java implementation of Efficient method to count of negative numbers in M [ n ] [ m ]","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function to count negative number","code":"static int countNegative ( int M [ ] [ ] , int n , int m ) {"}
{"text":"initialize result","code":"int count = 0 ;"}
{"text":"Start with top right corner","code":"int i = 0 ; int j = m - 1 ;"}
{"text":"Follow the path shown using arrows above","code":"while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) {"}
{"text":"j is the index of the last negative number in this row . So there must be ( j + 1 )","code":"count += j + 1 ;"}
{"text":"negative numbers in this row .","code":"i += 1 ; }"}
{"text":"move to the left and see if we can find a negative number there","code":"else j -= 1 ; } return count ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( countNegative ( M , 3 , 4 ) ) ; } }"}
{"text":"Java implementation of More efficient method to count number of negative numbers in row - column sorted matrix M [ n ] [ m ]","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Recursive binary search to get last negative value in a row between a start and an end","code":"static int getLastNegativeIndex ( int array [ ] , int start , int end ) {"}
{"text":"Base case","code":"if ( start == end ) { return start ; }"}
{"text":"Get the mid for binary search","code":"int mid = start + ( end - start ) \/ 2 ;"}
{"text":"If current element is negative","code":"if ( array [ mid ] < 0 ) {"}
{"text":"If it is the rightmost negative element in the current row","code":"if ( mid + 1 < array . length && array [ mid + 1 ] >= 0 ) { return mid ; }"}
{"text":"Check in the right half of the array","code":"return getLastNegativeIndex ( array , mid + 1 , end ) ; } else {"}
{"text":"Check in the left half of the array","code":"return getLastNegativeIndex ( array , start , mid - 1 ) ; } }"}
{"text":"Function to return the count of negative numbers in the given matrix","code":"static int countNegative ( int M [ ] [ ] , int n , int m ) {"}
{"text":"Initialize result","code":"int count = 0 ;"}
{"text":"To store the index of the rightmost negative element in the row under consideration","code":"int nextEnd = m - 1 ;"}
{"text":"Iterate over all rows of the matrix","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If the first element of the current row is positive then there will be no negatives in the matrix below or after it","code":"if ( M [ i ] [ 0 ] >= 0 ) { break ; }"}
{"text":"Run binary search only until the index of last negative Integer in the above row","code":"nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd ) ; count += nextEnd + 1 ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; int r = M . length ; int c = M [ 0 ] . length ; System . out . println ( countNegative ( M , r , c ) ) ; } }"}
{"text":"A Naive method to find maximum value of mat1 [ d ] [ e ] - ma [ a ] [ b ] such that d > a and e > b","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b .","code":"static int findMaxValue ( int N , int mat [ ] [ ] ) {"}
{"text":"stores maximum value","code":"int maxValue = Integer . MIN_VALUE ;"}
{"text":"Consider all possible pairs mat [ a ] [ b ] and mat1 [ d ] [ e ]","code":"for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( \" Maximum \u2581 Value \u2581 is \u2581 \" + findMaxValue ( N , mat ) ) ; } }"}
{"text":"An efficient method to find maximum value of mat1 [ d ] - ma [ a ] [ b ] such that c > a and d > b","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b .","code":"static int findMaxValue ( int N , int mat [ ] [ ] ) {"}
{"text":"stores maximum value","code":"int maxValue = Integer . MIN_VALUE ;"}
{"text":"maxArr [ i ] [ j ] stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 )","code":"int maxArr [ ] [ ] = new int [ N ] [ N ] ;"}
{"text":"last element of maxArr will be same 's as of  the input matrix","code":"maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;"}
{"text":"preprocess last row Initialize max","code":"int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; }"}
{"text":"preprocess last column Initialize max","code":"maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; }"}
{"text":"preprocess rest of the matrix from bottom","code":"for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) {"}
{"text":"Update maxValue","code":"if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ;"}
{"text":"set maxArr ( i , j )","code":"maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( \" Maximum \u2581 Value \u2581 is \u2581 \" + findMaxValue ( N , mat ) ) ; } }"}
{"text":"A Java program to Print all elements in sorted order from row and column wise sorted matrix","code":"class GFG { static final int INF = Integer . MAX_VALUE ; static final int N = 4 ;"}
{"text":"A utility function to youngify a Young Tableau . This is different from standard youngify . It assumes that the value at mat [ 0 ] [ 0 ] is infinite .","code":"static void youngify ( int mat [ ] [ ] , int i , int j ) {"}
{"text":"Find the values at down and right sides of mat [ i ] [ j ]","code":"int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ;"}
{"text":"If mat [ i ] [ j ] is the down right corner element , return","code":"if ( downVal == INF && rightVal == INF ) { return ; }"}
{"text":"Move the smaller of two values ( downVal and rightVal ) to mat [ i ] [ j ] and recur for smaller value","code":"if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } }"}
{"text":"A utility function to extract minimum element from Young tableau","code":"static int extractMin ( int mat [ ] [ ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; }"}
{"text":"This function uses extractMin ( ) to print elements in sorted order","code":"static void printSorted ( int mat [ ] [ ] ) { System . out . println ( \" Elements \u2581 of \u2581 matrix \u2581 in \u2581 sorted \u2581 order \u2581 n \" ) ; for ( int i = 0 ; i < N * N ; i ++ ) { System . out . print ( extractMin ( mat ) + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; printSorted ( mat ) ; } }"}
{"text":"A simple Java program to find sum of all subsquares of size k x k","code":"class GFG {"}
{"text":"Size of given matrix","code":"static final int n = 5 ;"}
{"text":"A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n","code":"static void printSumSimple ( int mat [ ] [ ] , int k ) {"}
{"text":"k must be smaller than or equal to n","code":"if ( k > n ) return ;"}
{"text":"row number of first cell in current sub - square of size k x k","code":"for ( int i = 0 ; i < n - k + 1 ; i ++ ) {"}
{"text":"column of first cell in current sub - square of size k x k","code":"for ( int j = 0 ; j < n - k + 1 ; j ++ ) {"}
{"text":"Calculate and print sum of current sub - square","code":"int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + \" \u2581 \" ) ; }"}
{"text":"Line separator for sub - squares starting with next row","code":"System . out . println ( ) ; } }"}
{"text":"Driver Program to test above function","code":"public static void main ( String arg [ ] ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } } ; int k = 3 ; printSumSimple ( mat , k ) ; } }"}
{"text":"An efficient Java program to find sum of all subsquares of size k x k","code":"import java . io . * ; class GFG {"}
{"text":"Size of given matrix","code":"static int n = 5 ;"}
{"text":"A O ( n ^ 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n","code":"static void printSumTricky ( int mat [ ] [ ] , int k ) {"}
{"text":"k must be smaller than or equal to n","code":"if ( k > n ) return ;"}
{"text":"1 : PREPROCESSING To store sums of all strips of size k x 1","code":"int stripSum [ ] [ ] = new int [ n ] [ n ] ;"}
{"text":"Go column by column","code":"for ( int j = 0 ; j < n ; j ++ ) {"}
{"text":"Calculate sum of first k x 1 rectangle in this column","code":"int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ;"}
{"text":"Calculate sum of remaining rectangles","code":"for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } }"}
{"text":"2 : CALCULATE SUM of Sub - Squares using stripSum [ ] [ ]","code":"for ( int i = 0 ; i < n - k + 1 ; i ++ ) {"}
{"text":"Calculate and print sum of first subsquare in this row","code":"int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + \" \u2581 \" ) ;"}
{"text":"Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip","code":"for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + \" \u2581 \" ) ; } System . out . println ( ) ; } }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; } }"}
{"text":"Java Program to find transpose of a matrix","code":"class GFG { static final int M = 3 ; static final int N = 4 ;"}
{"text":"This function stores transpose of A [ ] [ ] in B [ ] [ ]","code":"static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ ] [ ] = new int [ N ] [ M ] , i , j ; transpose ( A , B ) ; System . out . print ( \"Result matrix is NEW_LINE\"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) System . out . print ( B [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text":"Java Program to find transpose of a matrix","code":"class GFG { static final int N = 4 ;"}
{"text":"Finds transpose of A [ ] [ ] in - place","code":"static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; System . out . print ( \"Modified matrix is NEW_LINE\"); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) System . out . print ( A [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text":"A Naive Recursive Java program to count paths with exactly ' k ' coins","code":"class GFG { static final int R = 3 ; static final int C = 3 ;"}
{"text":"Recursive function to count paths with sum k from ( 0 , 0 ) to ( m , n )","code":"static int pathCountRec ( int mat [ ] [ ] , int m , int n , int k ) {"}
{"text":"Base cases","code":"if ( m < 0 n < 0 ) { return 0 ; } if ( m == 0 && n == 0 && ( k == mat [ m ] [ n ] ) ) { return 1 ; }"}
{"text":"( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )","code":"return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; }"}
{"text":"A wrapper over pathCountRec ( )","code":"static int pathCount ( int mat [ ] [ ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int k = 12 ; int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; System . out . println ( pathCount ( mat , k ) ) ; } }"}
{"text":"A Dynamic Programming based JAVA program to count paths with exactly ' k ' coins","code":"class GFG { static final int R = 3 ; static final int C = 3 ; static final int MAX_K = 100 ; static int [ ] [ ] [ ] dp = new int [ R ] [ C ] [ MAX_K ] ; static int pathCountDPRecDP ( int [ ] [ ] mat , int m , int n , int k ) {"}
{"text":"Base cases","code":"if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ;"}
{"text":"If this subproblem is already solved","code":"if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ;"}
{"text":"( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )","code":"dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; }"}
{"text":"This function mainly initializes dp [ ] [ ] [ ] and calls pathCountDPRecDP ( )","code":"static int pathCountDP ( int [ ] [ ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; }"}
{"text":"Driver Program to test above functions","code":"public static void main ( String [ ] args ) { int k = 12 ; int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 4 , 6 , 5 } , new int [ ] { 3 , 2 , 1 } } ; System . out . println ( pathCountDP ( mat , k ) ) ; } }"}
{"text":"Java implementation to sort the given matrix","code":"import java . io . * ; import java . util . * ; class GFG { static int SIZE = 10 ;"}
{"text":"function to sort the given matrix","code":"static void sortMat ( int mat [ ] [ ] , int n ) {"}
{"text":"temporary matrix of size n ^ 2","code":"int temp [ ] = new int [ n * n ] ; int k = 0 ;"}
{"text":"copy the elements of matrix one by one into temp [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i ] [ j ] ;"}
{"text":"sort temp [ ]","code":"Arrays . sort ( temp ) ;"}
{"text":"copy the elements of temp [ ] one by one in mat [ ] [ ]","code":"k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = temp [ k ++ ] ; }"}
{"text":"function to print the given matrix","code":"static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"Driver program to test above","code":"public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int n = 3 ; System . out . println ( \" Original \u2581 Matrix : \" ) ; printMat ( mat , n ) ; sortMat ( mat , n ) ; System . out . println ( \" Matrix \u2581 After \u2581 Sorting : \" ) ; printMat ( mat , n ) ; } }"}
{"text":"Java program for implementation of Selection Sort","code":"class SelectionSort {"}
{"text":"sort function","code":"void sort ( int arr [ ] ) { int n = arr . length ;"}
{"text":"One by one move boundary of unsorted subarray","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"Find the minimum element in unsorted array","code":"int min_idx = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ;"}
{"text":"Swap the found minimum element with the first element","code":"int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } }"}
{"text":"Prints the array","code":"void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver code to test above","code":"public static void main ( String args [ ] ) { SelectionSort ob = new SelectionSort ( ) ; int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; ob . sort ( arr ) ; System . out . println ( \" Sorted \u2581 array \" ) ; ob . printArray ( arr ) ; } }"}
{"text":"Optimized java implementation of Bubble sort","code":"import java . io . * ; class GFG {"}
{"text":"An optimized version of Bubble Sort","code":"static void bubbleSort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) {"}
{"text":"swap arr [ j ] and arr [ j + 1 ]","code":"temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } }"}
{"text":"IF no two elements were swapped by inner loop , then break","code":"if ( swapped == false ) break ; } }"}
{"text":"Function to print an array","code":"static void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = arr . length ; bubbleSort ( arr , n ) ; System . out . println ( \" Sorted \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; } }"}
{"text":"Java program to find k closest elements to a given value","code":"class KClosest {"}
{"text":"Function to find the cross over point ( the point before which elements are smaller than or equal to x and after which greater than x )","code":"int findCrossOver ( int arr [ ] , int low , int high , int x ) {"}
{"text":"Base cases x is greater than all","code":"if ( arr [ high ] <= x ) return high ;"}
{"text":"x is smaller than all","code":"if ( arr [ low ] > x ) return low ;"}
{"text":"Find the middle point","code":"int mid = ( low + high ) \/ 2 ;"}
{"text":"If x is same as middle element , then return mid","code":"if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ;"}
{"text":"If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ]","code":"if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; }"}
{"text":"This function prints k closest elements to x in arr [ ] . n is the number of elements in arr [ ]","code":"void printKclosest ( int arr [ ] , int x , int k , int n ) {"}
{"text":"Find the crossover point","code":"int l = findCrossOver ( arr , 0 , n - 1 , x ) ;"}
{"text":"Right index to search","code":"int r = l + 1 ;"}
{"text":"To keep track of count of elements already printed","code":"int count = 0 ;"}
{"text":"If x is present in arr [ ] , then reduce left index Assumption : all elements in arr [ ] are distinct","code":"if ( arr [ l ] == x ) l -- ;"}
{"text":"Compare elements on left and right of crossover point to find the k closest elements","code":"while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) System . out . print ( arr [ l -- ] + \" \u2581 \" ) ; else System . out . print ( arr [ r ++ ] + \" \u2581 \" ) ; count ++ ; }"}
{"text":"If there are no more elements on right side , then print left elements","code":"while ( count < k && l >= 0 ) { System . out . print ( arr [ l -- ] + \" \u2581 \" ) ; count ++ ; }"}
{"text":"If there are no more elements on left side , then print right elements","code":"while ( count < k && r < n ) { System . out . print ( arr [ r ++ ] + \" \u2581 \" ) ; count ++ ; } }"}
{"text":"Driver program to check above functions","code":"public static void main ( String args [ ] ) { KClosest ob = new KClosest ( ) ; int arr [ ] = { 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 } ; int n = arr . length ; int x = 35 , k = 4 ; ob . printKclosest ( arr , x , 4 , n ) ; } }"}
{"text":"Java program to sort link list using insertion sort","code":"public class LinkedlistIS { node head ; node sorted ; class node { int val ; node next ; public node ( int val ) { this . val = val ; } }"}
{"text":"A utility function to insert a node at the beginning of linked list","code":"void push ( int val ) {"}
{"text":"allocate node","code":"node newnode = new node ( val ) ;"}
{"text":"link the old list off the new node","code":"newnode . next = head ;"}
{"text":"move the head to point to the new node","code":"head = newnode ; }"}
{"text":"function to sort a singly linked list using insertion sort","code":"void insertionSort ( node headref ) {"}
{"text":"Initialize sorted linked list","code":"sorted = null ; node current = headref ;"}
{"text":"Traverse the given linked list and insert every node to sorted","code":"while ( current != null ) {"}
{"text":"Store next for next iteration","code":"node next = current . next ;"}
{"text":"insert current in sorted linked list","code":"sortedInsert ( current ) ;"}
{"text":"Update current","code":"current = next ; }"}
{"text":"Update head_ref to point to sorted linked list","code":"head = sorted ; }"}
{"text":"* function to insert a new_node in a list . Note that * this function expects a pointer to head_ref as this * can modify the head of the input linked list * ( similar to push ( ) )","code":"void sortedInsert ( node newnode ) {"}
{"text":"Special case for the head end","code":"if ( sorted == null sorted . val >= newnode . val ) { newnode . next = sorted ; sorted = newnode ; } else { node current = sorted ;"}
{"text":"Locate the node before the point of insertion","code":"while ( current . next != null && current . next . val < newnode . val ) { current = current . next ; } newnode . next = current . next ; current . next = newnode ; } }"}
{"text":"Function to print linked list","code":"void printlist ( node head ) { while ( head != null ) { System . out . print ( head . val + \" \u2581 \" ) ; head = head . next ; } }"}
{"text":"Driver program to test above functions","code":"public static void main ( String [ ] args ) { LinkedlistIS list = new LinkedlistIS ( ) ; list . push ( 5 ) ; list . push ( 20 ) ; list . push ( 4 ) ; list . push ( 3 ) ; list . push ( 30 ) ; System . out . println ( \" Linked \u2581 List \u2581 before \u2581 Sorting . . \" ) ; list . printlist ( list . head ) ; list . insertionSort ( list . head ) ; System . out . println ( \" LinkedList After sorting \"); list . printlist ( list . head ) ; } }"}
{"text":"Dynamic Programming Java implementation of Coin Change problem","code":"public static int count ( int S [ ] , int m , int n ) {"}
{"text":"table [ i ] will be storing the number of solutions for value i . We need n + 1 rows as the table is constructed in bottom up manner using the base case ( n = 0 )","code":"int table [ ] = new int [ n + 1 ] ;"}
{"text":"Base case ( If given value is 0 )","code":"table [ 0 ] = 1 ;"}
{"text":"Pick all coins one by one and update the table [ ] values after the index greater than or equal to the value of the picked coin","code":"for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }"}
{"text":"Java program using memoization","code":"import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] dp = new int [ 100 ] [ 100 ] ;"}
{"text":"Function for matrix chain multiplication","code":"static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , n ) ) ; } }"}
{"text":"Dynamic Programming Java implementation of Matrix Chain Multiplication . See the Cormen book for details of the following algorithm","code":"class MatrixChainMultiplication {"}
{"text":"Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n","code":"static int MatrixChainOrder ( int p [ ] , int n ) {"}
{"text":"For simplicity of the program , one extra row and one extra column are allocated in m [ ] [ ] . 0 th row and 0 th column of m [ ] [ ] are not used","code":"int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ;"}
{"text":"cost is zero when multiplying one matrix .","code":"for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ;"}
{"text":"L is chain length .","code":"for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) {"}
{"text":"q = cost \/ scalar multiplications","code":"q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , size ) ) ; } }"}
{"text":"A Naive recursive solution for Rod cutting problem","code":"class RodCutting {"}
{"text":"Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces","code":"static int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = Integer . MIN_VALUE ;"}
{"text":"Recursively cut the rod in different pieces and compare different configurations","code":"for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + cutRod ( arr , size ) ) ; } }"}
{"text":"A Dynamic Programming solution for Rod cutting problem","code":"class RodCutting {"}
{"text":"Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces","code":"static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ;"}
{"text":"Build the table val [ ] in bottom up manner and return the last entry from the table","code":"for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }"}
{"text":"Driver program to test above functions","code":"public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + cutRod ( arr , size ) ) ; } }"}
{"text":"function to multiply two numbers x and y","code":"static int multiply ( int x , int y ) {"}
{"text":"0 multiplied with anything gives 0","code":"if ( y == 0 ) return 0 ;"}
{"text":"Add x one by one","code":"if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;"}
{"text":"the case where y is negative","code":"if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { System . out . print ( \"NEW_LINE\" + multiply(5, -11)); } }"}
{"text":"Java program to print all primes smaller than or equal to n using Sieve of Eratosthenes","code":"class SieveOfEratosthenes { void sieveOfEratosthenes ( int n ) {"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } }"}
{"text":"Print all prime numbers","code":"for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) System . out . print ( i + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 30 ; System . out . print ( \" Following \u2581 are \u2581 the \u2581 prime \u2581 numbers \u2581 \" ) ; System . out . println ( \" smaller \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 \" + n ) ; SieveOfEratosthenes g = new SieveOfEratosthenes ( ) ; g . sieveOfEratosthenes ( n ) ; } }"}
{"text":"Java code for Pascal 's Triangle","code":"import java . io . * ; class GFG {"}
{"text":"binomialCoeff","code":"static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Function to print first n lines of Pascal 's Triangle","code":"static void printPascal ( int n ) {"}
{"text":"Iterate through every line and print entries in it","code":"for ( int line = 0 ; line < n ; line ++ ) {"}
{"text":"Every line has number of integers equal to line number","code":"for ( int i = 0 ; i <= line ; i ++ ) System . out . print ( binomialCoeff ( line , i ) + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 7 ; printPascal ( n ) ; } }"}
{"text":"java program for Pascal 's Triangle","code":"import java . io . * ; class GFG {"}
{"text":"A O ( n ^ 2 ) time and O ( n ^ 2 ) extra space method for Pascal 's Triangle","code":"public static void printPascal ( int n ) {"}
{"text":"An auxiliary array to store generated pascal triangle values","code":"int [ ] [ ] arr = new int [ n ] [ n ] ;"}
{"text":"Iterate through every line and print integer ( s ) in it","code":"for ( int line = 0 ; line < n ; line ++ ) {"}
{"text":"Every line has number of integers equal to line number","code":"for ( int i = 0 ; i <= line ; i ++ ) {"}
{"text":"First and last values in every row are 1","code":"if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ;"}
{"text":"Other values are sum of values just above and left of above","code":"else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( \" \" ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; }"}
{"text":"Java program for Pascal ' s \u2581 Triangle \u2581 A \u2581 O ( n ^ 2 ) \u2581 time \u2581 and \u2581 O ( 1 ) \u2581 extra \u2581 space \u2581 method \u2581 for \u2581 Pascal ' s Triangle","code":"import java . io . * ; class GFG { public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) {"}
{"text":"used to represent C ( line , i )","code":"int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) {"}
{"text":"The first value in a line is always 1","code":"System . out . print ( C + \" \u2581 \" ) ; C = C * ( line - i ) \/ i ; } System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; } }"}
{"text":"Java Program to add two numbers without using arithmetic operator","code":"import java . io . * ; class GFG { static int Add ( int x , int y ) {"}
{"text":"Iterate till there is no carry","code":"while ( y != 0 ) {"}
{"text":"carry now contains common set bits of x and y","code":"int carry = x & y ;"}
{"text":"Sum of bits of x and y where at least one of the bits is not set","code":"x = x ^ y ;"}
{"text":"Carry is shifted by one so that adding it to x gives the required sum","code":"y = carry << 1 ; } return x ; }"}
{"text":"Driver code","code":"public static void main ( String arg [ ] ) { System . out . println ( Add ( 15 , 32 ) ) ; } }"}
{"text":"Java code for Compute modulus division by a power - of - 2 - number","code":"class GFG {"}
{"text":"This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 ,","code":"static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 6 ;"}
{"text":"d must be a power of 2","code":"int d = 4 ; System . out . println ( n + \" \u2581 moduo \u2581 \" + d + \" \u2581 is \u2581 \" + getModulo ( n , d ) ) ; } }"}
{"text":"Java program to Count set bits in an integer","code":"import java . io . * ; class countSetBits {"}
{"text":"Function to get no of set bits in binary representation of positive integer n","code":"static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }"}
{"text":"driver program","code":"public static void main ( String args [ ] ) { int i = 9 ; System . out . println ( countSetBits ( i ) ) ; } }"}
{"text":"Java implementation for recursive approach to find the number of set bits using Brian Kernighan Algorithm","code":"import java . io . * ; class GFG {"}
{"text":"recursive function to count set bits","code":"public static int countSetBits ( int n ) {"}
{"text":"base case","code":"if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) {"}
{"text":"get value from user","code":"int n = 9 ;"}
{"text":"function calling","code":"System . out . println ( countSetBits ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Lookup table","code":"static int [ ] BitsSetTable256 = new int [ 256 ] ;"}
{"text":"Function to initialise the lookup table","code":"public static void initialize ( ) {"}
{"text":"To initially generate the table algorithmically","code":"BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i \/ 2 ] ; } }"}
{"text":"Function to return the count of set bits in n","code":"public static int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Initialise the lookup table","code":"initialize ( ) ; int n = 9 ; System . out . print ( countSetBits ( n ) ) ; } }"}
{"text":"java program to demonstrate __builtin_popcount ( )","code":"import java . io . * ; class GFG {"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { System . out . println ( Integer . bitCount ( 4 ) ) ; System . out . println ( Integer . bitCount ( 15 ) ) ; } }"}
{"text":"Java program to count set bits by pre - storing count set bits in nibbles .","code":"class GFG { static int [ ] num_to_bits = new int [ ] { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ;"}
{"text":"Recursively get nibble of a given number and map them in the array","code":"static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ;"}
{"text":"Find last nibble","code":"nibble = num & 0xf ;"}
{"text":"Use pre - stored values to find count in last nibble plus recursively add remaining nibbles .","code":"return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int num = 31 ; System . out . println ( countSetBitsRec ( num ) ) ; } }"}
{"text":"Check each bit in a number is set or not and return the total count of the set bits .","code":"static int countSetBits ( int N ) { int count = 0 ;"}
{"text":"( 1 << i ) = pow ( 2 , i )","code":"for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countSetBits ( N ) ) ; } }"}
{"text":"Java program to find parity of an integer","code":"import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; class GFG {"}
{"text":"Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity","code":"static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }"}
{"text":"Driver program to test getParity ( )","code":"public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( \" Parity \u2581 of \u2581 no \u2581 \" + n + \" \u2581 = \u2581 \" + ( getParity ( n ) ? \" odd \" : \" even \" ) ) ; } }"}
{"text":"Java Program to find whether a no is power of two","code":"class GFG {"}
{"text":"Function to check if x is power of 2","code":"static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( int ) ( Math . ceil ( ( Math . log ( n ) \/ Math . log ( 2 ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( n ) \/ Math . log ( 2 ) ) ) ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to find whether a no is power of two","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if x is power of 2","code":"static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n \/ 2 ; } return true ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function which checks whether a number is a power of 2","code":"static boolean powerOf2 ( int n ) {"}
{"text":"base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )","code":"if ( n == 1 ) return true ;"}
{"text":"all other odd numbers are not powers of 2","code":"else if ( n % 2 != 0 n == 0 ) return false ;"}
{"text":"recursive function call","code":"return powerOf2 ( n \/ 2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"True","code":"int n = 64 ;"}
{"text":"False","code":"int m = 12 ; if ( powerOf2 ( n ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); if ( powerOf2 ( m ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); } }"}
{"text":"Java program to efficiently check for power for 2","code":"class Test {"}
{"text":"Method to check if x is power of 2","code":"static boolean isPowerOfTwo ( int x ) {"}
{"text":"First x in the below expression is for the case when x is 0","code":"return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) { System . out . println ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; System . out . println ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }"}
{"text":"Java program to find the maximum repeating number","code":"import java . io . * ; class MaxRepeating {"}
{"text":"Returns maximum repeating element in arr [ 0. . n - 1 ] . The array elements are in range from 0 to k - 1","code":"static int maxRepeating ( int arr [ ] , int n , int k ) {"}
{"text":"Iterate though input array , for every element arr [ i ] , increment arr [ arr [ i ] % k ] by k","code":"for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ;"}
{"text":"Find index of the maximum repeating element","code":"int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } }"}
{"text":"Return index of the maximum element","code":"return result ; }"}
{"text":"Driver function to check for above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = arr . length ; int k = 8 ; System . out . println ( \" Maximum \u2581 repeating \u2581 element \u2581 is : \u2581 \" + maxRepeating ( arr , n , k ) ) ; } }"}
{"text":"Java Program to solve range query on array whose each element is XOR of index value and previous element .","code":"import java . io . * ; class GFG {"}
{"text":"function return derived formula value .","code":"static int fun ( int x ) { int y = ( x \/ 4 ) * 4 ;"}
{"text":"finding xor value of range [ y ... x ]","code":"int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; }"}
{"text":"function to solve query for l and r .","code":"static int query ( int x ) {"}
{"text":"if l or r is 0.","code":"if ( x == 0 ) return 0 ; int k = ( x + 1 ) \/ 2 ;"}
{"text":"finding x is divisible by 2 or not .","code":"return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } static void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) System . out . println ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) ) ; }"}
{"text":"Driven Program","code":"public static void main ( String [ ] args ) { int q = 3 ; int [ ] l = { 2 , 2 , 5 } ; int [ ] r = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; } }"}
{"text":"Java code Queries on XOR of greatest odd divisor of the range","code":"import java . io . * ; class GFG {"}
{"text":"Precompute the prefix XOR of greatest odd divisor","code":"static void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) {"}
{"text":"Finding the Greatest Odd divisor","code":"for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] \/= 2 ; preXOR [ i ] = arr [ i ] ; }"}
{"text":"Finding prefix XOR","code":"for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; }"}
{"text":"Return XOR of the range","code":"static int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; }"}
{"text":"Driven Program","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 } ; int n = arr . length ; int preXOR [ ] = new int [ n ] ; prefixXOR ( arr , preXOR , n ) ; System . out . println ( query ( preXOR , 0 , 2 ) ) ; System . out . println ( query ( preXOR , 1 , 2 ) ) ; } }"}
{"text":"Java code to find minimum number of swaps to sort a binary array","code":"class gfg {"}
{"text":"Function to find minimum swaps to sort an array of 0 s and 1 s .","code":"static int findMinSwaps ( int arr [ ] , int n ) {"}
{"text":"Array to store count of zeroes","code":"int noOfZeroes [ ] = new int [ n ] ; int i , count = 0 ;"}
{"text":"Count number of zeroes on right side of every one .","code":"noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; }"}
{"text":"Count total number of swaps by adding number of zeroes on right side of every one .","code":"for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int ar [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( findMinSwaps ( ar , ar . length ) ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( minswaps ( arr , 9 ) ) ; } }"}
{"text":"Recursive approach to check if an Array is sorted or not","code":"class GFG {"}
{"text":"Function that returns true if array is sorted in non - decreasing order .","code":"static boolean arraySortedOrNot ( int arr [ ] , int n ) {"}
{"text":"Array has one or no element","code":"if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ )"}
{"text":"Unsorted pair found","code":"if ( arr [ i - 1 ] > arr [ i ] ) return false ;"}
{"text":"No unsorted pair found","code":"return true ; }"}
{"text":"driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . length ; if ( arraySortedOrNot ( arr , n ) ) System . out . print ( \"YesNEW_LINE\"); else System . out . print ( \"NoNEW_LINE\"); } }"}
{"text":"Java program to find two odd occurring elements","code":"import java . util . * ; class Main {"}
{"text":"Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times .","code":"static void printTwoOdd ( int arr [ ] , int size ) {"}
{"text":"Will hold XOR of two odd occurring elements","code":"int xor2 = arr [ 0 ] ;"}
{"text":"Will have only single set bit of xor2","code":"int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ;"}
{"text":"Get the xor of all elements in arr [ ] . The xor will basically be xor of two odd occurring elements","code":"for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ;"}
{"text":"Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get","code":"set_bit_no = xor2 & ~ ( xor2 - 1 ) ;"}
{"text":"Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0.","code":"for ( i = 0 ; i < size ; i ++ ) {"}
{"text":"XOR of first set is finally going to hold one odd occurring number x","code":"if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ;"}
{"text":"XOR of second set is finally going to hold the other odd occurring number y","code":"else y = y ^ arr [ i ] ; } System . out . println ( \" The \u2581 two \u2581 ODD \u2581 elements \u2581 are \u2581 \" + x + \" \u2581 & \u2581 \" + y ) ; }"}
{"text":"main function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ; } }"}
{"text":"Java program to find a pair with the given difference","code":"import java . io . * ; class PairDifference {"}
{"text":"The function assumes that the array is sorted","code":"static boolean findPair ( int arr [ ] , int n ) { int size = arr . length ;"}
{"text":"Initialize positions of two elements","code":"int i = 0 , j = 1 ;"}
{"text":"Search for a pair","code":"while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { System . out . print ( \" Pair \u2581 Found : \u2581 \" + \" ( \u2581 \" + arr [ i ] + \" , \u2581 \" + arr [ j ] + \" \u2581 ) \" ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } System . out . print ( \" No \u2581 such \u2581 pair \" ) ; return false ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int n = 60 ; findPair ( arr , n ) ; } }"}
{"text":"Java program to find k maximum elements of array in original order","code":"import java . util . Arrays ; import java . util . Collections ; public class GfG {"}
{"text":"Function to print m Maximum elements","code":"public static void printMax ( int arr [ ] , int k , int n ) {"}
{"text":"Array to store the copy of the original array","code":"Integer [ ] brr = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ;"}
{"text":"Sorting the array in descending order","code":"Arrays . sort ( brr , Collections . reverseOrder ( ) ) ;"}
{"text":"Traversing through original array and printing all those elements that are in first k of sorted array . goo . gl \/ uj5RCD Please refer https : for details of Arrays . binarySearch ( )","code":"for ( int i = 0 ; i < n ; ++ i ) if ( Arrays . binarySearch ( brr , arr [ i ] , Collections . reverseOrder ( ) ) >= 0 && Arrays . binarySearch ( brr , arr [ i ] , Collections . reverseOrder ( ) ) < k ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = arr . length ; int k = 3 ; printMax ( arr , k , n ) ; } }"}
{"text":"Java for printing smallest n number in order","code":"import java . util . * ; class GFG {"}
{"text":"Function to print smallest n numbers","code":"static void printSmall ( int arr [ ] , int asize , int n ) {"}
{"text":"Make copy of array","code":"int [ ] copy_arr = Arrays . copyOf ( arr , asize ) ;"}
{"text":"Sort copy array","code":"Arrays . sort ( copy_arr ) ;"}
{"text":"For each arr [ i ] find whether it is a part of n - smallest with binary search","code":"for ( int i = 0 ; i < asize ; ++ i ) { if ( Arrays . binarySearch ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . length ; int n = 5 ; printSmall ( arr , asize , n ) ; } }"}
{"text":"Java program to check if a given array can form arithmetic progression","code":"import java . util . Arrays ; class GFG {"}
{"text":"Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression","code":"static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ;"}
{"text":"Sort array","code":"Arrays . sort ( arr ) ;"}
{"text":"After sorting , difference between consecutive elements must be same .","code":"int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }"}
{"text":"driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = arr . length ; if ( checkIsAP ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java Code to find no . of Ways of choosing a pair with maximum difference","code":"import java . util . * ; class GFG { static int countPairs ( int a [ ] , int n ) {"}
{"text":"To find minimum and maximum of the array","code":"int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; }"}
{"text":"to find the count of minimum and maximum elements","code":"int c1 = 0 ;"}
{"text":"Count variables","code":"int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; }"}
{"text":"condition for all elements equal","code":"if ( mn == mx ) return n * ( n - 1 ) \/ 2 ; else return c1 * c2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = a . length ; System . out . print ( countPairs ( a , n ) ) ; } }"}
{"text":"Java code to rearrange linked list in place","code":"class Geeks { static class Node { int data ; Node next ; }"}
{"text":"function for rearranging a linked list with high and low value .","code":"static Node rearrange ( Node head ) {"}
{"text":"Base case .","code":"if ( head == null ) return null ;"}
{"text":"two pointer variable .","code":"Node prev = head , curr = head . next ; while ( curr != null ) {"}
{"text":"swap function for swapping data .","code":"if ( prev . data > curr . data ) { int t = prev . data ; prev . data = curr . data ; curr . data = t ; }"}
{"text":"swap function for swapping data .","code":"if ( curr . next != null && curr . next . data > curr . data ) { int t = curr . next . data ; curr . next . data = curr . data ; curr . data = t ; } prev = curr . next ; if ( curr . next == null ) break ; curr = curr . next . next ; } return head ; }"}
{"text":"function to insert a Node in the linked list at the beginning .","code":"static Node push ( Node head , int k ) { Node tem = new Node ( ) ; tem . data = k ; tem . next = head ; head = tem ; return head ; }"}
{"text":"function to display Node of linked list .","code":"static void display ( Node head ) { Node curr = head ; while ( curr != null ) { System . out . printf ( \" % d \u2581 \" , curr . data ) ; curr = curr . next ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { Node head = null ;"}
{"text":"let create a linked list . 9 . 6 . 8 . 3 . 7","code":"head = push ( head , 7 ) ; head = push ( head , 3 ) ; head = push ( head , 8 ) ; head = push ( head , 6 ) ; head = push ( head , 9 ) ; head = rearrange ( head ) ; display ( head ) ; } }"}
{"text":"Java implementation","code":"import java . io . * ;"}
{"text":"Creating the structure for node","code":"class Node { int data ; Node next ; Node ( int key ) { data = key ; next = null ; } }"}
{"text":"Function to print the list","code":"void printlist ( Node head ) { while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; if ( head . next != null ) { System . out . print ( \" - > \" ) ; } head = head . next ; } System . out . println ( ) ; }"}
{"text":"Function to rearrange","code":"void rearrange ( Node head ) { if ( head != null ) { left = head ; reorderListUtil ( left ) ; } } void reorderListUtil ( Node right ) { if ( right == null ) { return ; } reorderListUtil ( right . next ) ;"}
{"text":"we set left = null , when we reach stop condition , so no processing required after that","code":"if ( left == null ) { return ; }"}
{"text":"Stop condition : odd case : left = right , even case : left . next = right","code":"if ( left != right && left . next != right ) { Node temp = left . next ; left . next = right ; right . next = temp ; left = temp ; }"}
{"text":"stop condition , set null to left nodes","code":"else { if ( left . next == right ) {"}
{"text":"even case","code":"left . next . next = null ; left = null ; } else {"}
{"text":"odd case","code":"left . next = null ; left = null ; } } }"}
{"text":"Drivers Code","code":"public static void main ( String [ ] args ) { Node head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 3 ) ; head . next . next . next = new Node ( 4 ) ; head . next . next . next . next = new Node ( 5 ) ; GFG gfg = new GFG ( ) ;"}
{"text":"Print original list","code":"gfg . printlist ( head ) ;"}
{"text":"Modify the list","code":"gfg . rearrange ( head ) ;"}
{"text":"Print modified list","code":"gfg . printlist ( head ) ; } }"}
{"text":"Java program to subtract smaller valued list from larger valued list and return result as a list .","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList {"}
{"text":"head of list","code":"static Node head ; boolean borrow ;"}
{"text":"Node Class","code":"static class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } }"}
{"text":"A utility function to get length of linked list","code":"int getLength ( Node node ) { int size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; }"}
{"text":"A Utility that padds zeros in front of the Node , with the given diff","code":"Node paddZeros ( Node sNode , int diff ) { if ( sNode == null ) return null ; Node zHead = new Node ( 0 ) ; diff -- ; Node temp = zHead ; while ( ( diff -- ) != 0 ) { temp . next = new Node ( 0 ) ; temp = temp . next ; } temp . next = sNode ; return zHead ; }"}
{"text":"Subtract LinkedList Helper is a recursive function , move till the last Node , and subtract the digits and create the Node and return the Node . If d1 < d2 , we borrow the number from previous digit .","code":"Node subtractLinkedListHelper ( Node l1 , Node l2 ) { if ( l1 == null && l2 == null && borrow == false ) return null ; Node previous = subtractLinkedListHelper ( ( l1 != null ) ? l1 . next : null , ( l2 != null ) ? l2 . next : null ) ; int d1 = l1 . data ; int d2 = l2 . data ; int sub = 0 ;"}
{"text":"if you have given the value value to next digit then reduce the d1 by 1","code":"if ( borrow ) { d1 -- ; borrow = false ; }"}
{"text":"If d1 < d2 , then borrow the number from previous digit . Add 10 to d1 and set borrow = true ;","code":"if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; }"}
{"text":"subtract the digits","code":"sub = d1 - d2 ;"}
{"text":"Create a Node with sub value","code":"Node current = new Node ( sub ) ;"}
{"text":"Set the Next pointer as Previous","code":"current . next = previous ; return current ; }"}
{"text":"This API subtracts two linked lists and returns the linked list which shall have the subtracted result .","code":"Node subtractLinkedList ( Node l1 , Node l2 ) {"}
{"text":"Base Case .","code":"if ( l1 == null && l2 == null ) return null ;"}
{"text":"In either of the case , get the lengths of both Linked list .","code":"int len1 = getLength ( l1 ) ; int len2 = getLength ( l2 ) ; Node lNode = null , sNode = null ; Node temp1 = l1 ; Node temp2 = l2 ;"}
{"text":"If lengths differ , calculate the smaller Node and padd zeros for smaller Node and ensure both larger Node and smaller Node has equal length .","code":"if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , Math . abs ( len1 - len2 ) ) ; } else {"}
{"text":"If both list lengths are equal , then calculate the larger and smaller list . If 5 - 6 - 7 & 5 - 6 - 8 are linked list , then walk through linked list at last Node as 7 < 8 , larger Node is 5 - 6 - 8 and smaller Node is 5 - 6 - 7.","code":"while ( l1 != null && l2 != null ) { if ( l1 . data != l2 . data ) { lNode = l1 . data > l2 . data ? temp1 : temp2 ; sNode = l1 . data > l2 . data ? temp2 : temp1 ; break ; } l1 = l1 . next ; l2 = l2 . next ; } }"}
{"text":"After calculating larger and smaller Node , call subtractLinkedListHelper which returns the subtracted linked list .","code":"borrow = false ; return subtractLinkedListHelper ( lNode , sNode ) ; }"}
{"text":"function to display the linked list","code":"static void printList ( Node head ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } }"}
{"text":"Driver program to test above","code":"public static void main ( String [ ] args ) { Node head = new Node ( 1 ) ; head . next = new Node ( 0 ) ; head . next . next = new Node ( 0 ) ; Node head2 = new Node ( 1 ) ; LinkedList ob = new LinkedList ( ) ; Node result = ob . subtractLinkedList ( head , head2 ) ; printList ( result ) ; } }"}
{"text":"Java implementation to insert node at the middle of the linked list","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList {"}
{"text":"head of list","code":"static Node head ;"}
{"text":"Node Class","code":"static class Node { int data ; Node next ;"}
{"text":"Constructor to create a new node","code":"Node ( int d ) { data = d ; next = null ; } }"}
{"text":"function to insert node at the middle of the linked list","code":"static void insertAtMid ( int x ) {"}
{"text":"if list is empty","code":"if ( head == null ) head = new Node ( x ) ; else {"}
{"text":"get a new node","code":"Node newNode = new Node ( x ) ; Node ptr = head ; int len = 0 ;"}
{"text":"calculate length of the linked list , i . e , the number of nodes","code":"while ( ptr != null ) { len ++ ; ptr = ptr . next ; }"}
{"text":"' count ' the number of nodes after which the new node is to be inserted","code":"int count = ( ( len % 2 ) == 0 ) ? ( len \/ 2 ) : ( len + 1 ) \/ 2 ; ptr = head ;"}
{"text":"' ptr ' points to the node after which the new node is to be inserted","code":"while ( count -- > 1 ) ptr = ptr . next ;"}
{"text":"insert the ' newNode ' and adjust the required links","code":"newNode . next = ptr . next ; ptr . next = newNode ; } }"}
{"text":"function to display the linked list","code":"static void display ( ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } }"}
{"text":"Driver program to test above","code":"public static void main ( String [ ] args ) {"}
{"text":"Creating the list 1.2 . 4.5","code":"head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; System . out . println ( \" Linked \u2581 list \u2581 before \u2581 \" + \" insertion : \u2581 \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; System . out . println ( \" Linked list after \" + \u2581 \" insertion : \"); display ( ) ; } }"}
{"text":"Java implementation to insert node at the middle of the linked list","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList {"}
{"text":"head of list","code":"static Node head ;"}
{"text":"Node Class","code":"static class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } }"}
{"text":"function to insert node at the middle of the linked list","code":"static void insertAtMid ( int x ) {"}
{"text":"if list is empty","code":"if ( head == null ) head = new Node ( x ) ; else {"}
{"text":"get a new node","code":"Node newNode = new Node ( x ) ;"}
{"text":"assign values to the slow and fast pointers","code":"Node slow = head ; Node fast = head . next ; while ( fast != null && fast . next != null ) {"}
{"text":"move slow pointer to next node","code":"slow = slow . next ;"}
{"text":"move fast pointer two nodes at a time","code":"fast = fast . next . next ; }"}
{"text":"insert the ' newNode ' and adjust the required links","code":"newNode . next = slow . next ; slow . next = newNode ; } }"}
{"text":"function to display the linked list","code":"static void display ( ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } }"}
{"text":"Driver program to test above","code":"public static void main ( String [ ] args ) {"}
{"text":"Creating the list 1.2 . 4.5","code":"head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; System . out . println ( \" Linked \u2581 list \u2581 before \" + \" \u2581 insertion : \u2581 \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; System . out . println ( \" Linked list after \" + \u2581 \" insertion : \"); display ( ) ; } }"}
{"text":"Java implementation for insertion Sort on a doubly linked list","code":"class Solution {"}
{"text":"Node of a doubly linked list","code":"static class Node { int data ; Node prev , next ; } ;"}
{"text":"function to create and return a new node of a doubly linked list","code":"static Node getNode ( int data ) {"}
{"text":"allocate node","code":"Node newNode = new Node ( ) ;"}
{"text":"put in the data","code":"newNode . data = data ; newNode . prev = newNode . next = null ; return newNode ; }"}
{"text":"function to insert a new node in sorted way in a sorted doubly linked list","code":"static Node sortedInsert ( Node head_ref , Node newNode ) { Node current ;"}
{"text":"if list is empty","code":"if ( head_ref == null ) head_ref = newNode ;"}
{"text":"if the node is to be inserted at the beginning of the doubly linked list","code":"else if ( ( head_ref ) . data >= newNode . data ) { newNode . next = head_ref ; newNode . next . prev = newNode ; head_ref = newNode ; } else { current = head_ref ;"}
{"text":"locate the node after which the new node is to be inserted","code":"while ( current . next != null && current . next . data < newNode . data ) current = current . next ;"}
{"text":"Make the appropriate links \/","code":"newNode . next = current . next ;"}
{"text":"if the new node is not inserted at the end of the list","code":"if ( current . next != null ) newNode . next . prev = newNode ; current . next = newNode ; newNode . prev = current ; } return head_ref ; }"}
{"text":"function to sort a doubly linked list using insertion sort","code":"static Node insertionSort ( Node head_ref ) {"}
{"text":"Initialize ' sorted ' - a sorted doubly linked list","code":"Node sorted = null ;"}
{"text":"Traverse the given doubly linked list and insert every node to ' sorted '","code":"Node current = head_ref ; while ( current != null ) {"}
{"text":"Store next for next iteration","code":"Node next = current . next ;"}
{"text":"removing all the links so as to create ' current ' as a new node for insertion","code":"current . prev = current . next = null ;"}
{"text":"insert current in ' sorted ' doubly linked list","code":"sorted = sortedInsert ( sorted , current ) ;"}
{"text":"Update current","code":"current = next ; }"}
{"text":"Update head_ref to point to sorted doubly linked list","code":"head_ref = sorted ; return head_ref ; }"}
{"text":"function to print the doubly linked list","code":"static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; head = head . next ; } }"}
{"text":"function to insert a node at the beginning of the doubly linked list","code":"static Node push ( Node head_ref , int new_data ) {"}
{"text":"allocate node \/","code":"Node new_node = new Node ( ) ;"}
{"text":"put in the data \/","code":"new_node . data = new_data ;"}
{"text":"Make next of new node as head and previous as null \/","code":"new_node . next = ( head_ref ) ; new_node . prev = null ;"}
{"text":"change prev of head node to new node \/","code":"if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ;"}
{"text":"move the head to point to the new node \/","code":"( head_ref ) = new_node ; return head_ref ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"start with the empty doubly linked list \/","code":"Node head = null ;"}
{"text":"insert the following data","code":"head = push ( head , 9 ) ; head = push ( head , 3 ) ; head = push ( head , 5 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 8 ) ; System . out . println ( \"Doubly Linked List Before SortingNEW_LINE\"); printList ( head ) ; head = insertionSort ( head ) ; System . out . println ( \" Doubly Linked List After Sorting \"); printList ( head ) ; } }"}
{"text":"Java program to print all possible rotations of the given array","code":"class GFG {"}
{"text":"Global declaration of array","code":"static int arr [ ] = new int [ 10000 ] ;"}
{"text":"Function to reverse array between indices s and e","code":"public static void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } }"}
{"text":"Function to generate all possible rotations of array","code":"public static void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; System . out . print ( \" [ \" ) ; for ( int j = 0 ; j < 4 ; j ++ ) { System . out . print ( arr [ j ] + \" , \u2581 \" ) ; } System . out . print ( \" ] \" ) ; } } }"}
{"text":"Java program to find Bitwise OR of two equal halves of an array after performing K right circular shifts","code":"import java . util . * ; class GFG { static int MAX = 100005 ;"}
{"text":"Array for storing the segment tree","code":"static int [ ] seg = new int [ 4 * MAX ] ;"}
{"text":"Function to build the segment tree","code":"static void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) \/ 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } }"}
{"text":"Function to return the OR of elements in the range [ l , r ]","code":"static int query ( int node , int l , int r , int start , int end , int a [ ] ) {"}
{"text":"Check for out of bound condition","code":"if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ;"}
{"text":"Find middle of the range","code":"int mid = ( l + r ) \/ 2 ;"}
{"text":"Recurse for all the elements in array","code":"return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; }"}
{"text":"Function to find the OR sum","code":"static void orsum ( int a [ ] , int n , int q , int k [ ] ) {"}
{"text":"Function to build the segment Tree","code":"build ( 1 , 0 , n - 1 , a ) ;"}
{"text":"Loop to handle q queries","code":"for ( int j = 0 ; j < q ; j ++ ) {"}
{"text":"Effective number of right circular shifts","code":"int i = k [ j ] % ( n \/ 2 ) ;"}
{"text":"OR of second half of the array [ n \/ 2 - i , n - 1 - i ]","code":"int sec = query ( 1 , 0 , n - 1 , n \/ 2 - i , n - i - 1 , a ) ;"}
{"text":"OR of first half of the array [ n - i , n - 1 ] OR [ 0 , n \/ 2 - 1 - i ]","code":"int first = ( query ( 1 , 0 , n - 1 , 0 , n \/ 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ;"}
{"text":"Print final answer to the query","code":"System . out . print ( temp + \"NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = a . length ; int q = 2 ; int k [ ] = { 4 , 2 } ; orsum ( a , n , q , k ) ; } }"}
{"text":"Java program of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that prints maximum equal elements","code":"static void maximumEqual ( int a [ ] , int b [ ] , int n ) {"}
{"text":"Vector to store the index of elements of array b","code":"int store [ ] = new int [ ( int ) 1e5 ] ;"}
{"text":"Storing the positions of array B","code":"for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; }"}
{"text":"frequency array to keep count of elements with similar difference in distances","code":"int ans [ ] = new int [ ( int ) 1e5 ] ;"}
{"text":"Iterate through all element in arr1 [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Calculate number of shift required to make current element equal","code":"int d = Math . abs ( store [ a [ i ] ] - ( i + 1 ) ) ;"}
{"text":"If d is less than 0","code":"if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; }"}
{"text":"Store the frequency of current diff","code":"ans [ d ] ++ ; } int finalans = 0 ;"}
{"text":"Compute the maximum frequency stored","code":"for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = Math . max ( finalans , ans [ i ] ) ;"}
{"text":"Printing the maximum number of equal elements","code":"System . out . print ( finalans + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given two arrays","code":"int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = A . length ;"}
{"text":"Function Call","code":"maximumEqual ( A , B , size ) ; } }"}
{"text":"Java Implementation of Right Rotation of an Array K number of times","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class Array_Rotation {"}
{"text":"Function to rightRotate array","code":"static void RightRotate ( int a [ ] , int n , int k ) {"}
{"text":"If rotation is greater than size of array","code":"k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) {"}
{"text":"Printing rightmost kth elements","code":"System . out . print ( a [ n + i - k ] + \" \u2581 \" ) ; } else {"}
{"text":"Prints array after ' k ' elements","code":"System . out . print ( a [ i - k ] + \" \u2581 \" ) ; } } System . out . println ( ) ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = Array . length ; int K = 2 ; RightRotate ( Array , N , K ) ; } }"}
{"text":"Java implementation for restoring original sort in rotated sorted array","code":"class GFG {"}
{"text":"Function to restore the Original Sort","code":"static void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) {"}
{"text":"In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one .","code":"reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } } static void reverse ( int [ ] arr , int i , int j ) { int temp ; while ( i < j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } }"}
{"text":"Function to print the Array","code":"static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . length ; restoreSortedArray ( arr , n - 1 ) ; printArray ( arr , n ) ; } }"}
{"text":"Java implementation for restoring original sort in rotated sorted array using binary search","code":"import java . util . * ; class GFG {"}
{"text":"Function to find start index of array","code":"static int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) \/ 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } }"}
{"text":"Function to restore the Original Sort","code":"static void restoreSortedArray ( int arr [ ] , int n ) {"}
{"text":"array is already sorted","code":"if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ;"}
{"text":"In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one .","code":"Arrays . sort ( arr , 0 , start ) ; Arrays . sort ( arr , start , n ) ; Arrays . sort ( arr ) ; }"}
{"text":"Function to print the Array","code":"static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; } }"}
{"text":"Java program for Left Rotation and Right Rotation of a String","code":"import java . util . * ; import java . io . * ; class GFG {"}
{"text":"function that rotates s towards left by d","code":"static String leftrotate ( String str , int d ) { String ans = str . substring ( d ) + str . substring ( 0 , d ) ; return ans ; }"}
{"text":"function that rotates s towards right by d","code":"static String rightrotate ( String str , int d ) { return leftrotate ( str , str . length ( ) - d ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String str1 = \" GeeksforGeeks \" ; System . out . println ( leftrotate ( str1 , 2 ) ) ; String str2 = \" GeeksforGeeks \" ; System . out . println ( rightrotate ( str2 , 2 ) ) ; } }"}
{"text":"Java program to illustrate inserting a Node in a Cicular Doubly Linked list in begging , end and middle","code":"class GFG {"}
{"text":"Structure of a Node","code":"static class Node { int data ; Node next ; Node prev ; } ;"}
{"text":"Function to insert a node at the end","code":"static Node insertNode ( Node start , int value ) {"}
{"text":"If the list is empty , create a single node circular and doubly list","code":"if ( start == null ) { Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = new_node . prev = new_node ; start = new_node ; return new_node ; }"}
{"text":"Find last node \/","code":"Node last = ( start ) . prev ;"}
{"text":"Create Node dynamically","code":"Node new_node = new Node ( ) ; new_node . data = value ;"}
{"text":"Start is going to be next of new_node","code":"new_node . next = start ;"}
{"text":"Make new node previous of start","code":"( start ) . prev = new_node ;"}
{"text":"Make last preivous of new node","code":"new_node . prev = last ;"}
{"text":"Make new node next of old last","code":"last . next = new_node ; return start ; }"}
{"text":"Function to display the circular doubly linked list","code":"static void displayList ( Node start ) { Node temp = start ; while ( temp . next != start ) { System . out . printf ( \" % d \u2581 \" , temp . data ) ; temp = temp . next ; } System . out . printf ( \" % d \u2581 \" , temp . data ) ; }"}
{"text":"Function to search the particular element from the list","code":"static int searchList ( Node start , int search ) {"}
{"text":"Declare the temp variable","code":"Node temp = start ;"}
{"text":"Declare other control variable for the searching","code":"int count = 0 , flag = 0 , value ;"}
{"text":"If start is null return - 1","code":"if ( temp == null ) return - 1 ; else {"}
{"text":"Move the temp pointer until , temp . next doesn 't move  start address (Circular Fashion)","code":"while ( temp . next != start ) {"}
{"text":"Increment count for location","code":"count ++ ;"}
{"text":"If it is found raise the flag and break the loop","code":"if ( temp . data == search ) { flag = 1 ; count -- ; break ; }"}
{"text":"Increment temp pointer","code":"temp = temp . next ; }"}
{"text":"Check whether last element in the list content the value if contain , raise a flag and increment count","code":"if ( temp . data == search ) { count ++ ; flag = 1 ; }"}
{"text":"If flag is true , then element found , else not","code":"if ( flag == 1 ) System . out . println ( \" \" + search \u2581 + \" found at location \"+ count); else System . out . println ( \" \" + search \u2581 + \" not found \"); } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"Start with the empty list \/","code":"Node start = null ;"}
{"text":"Insert 4. So linked list becomes 4. null","code":"start = insertNode ( start , 4 ) ;"}
{"text":"Insert 5. So linked list becomes 4.5","code":"start = insertNode ( start , 5 ) ;"}
{"text":"Insert 7. So linked list becomes 4.5 . 7","code":"start = insertNode ( start , 7 ) ;"}
{"text":"Insert 8. So linked list becomes 4.5 . 7.8","code":"start = insertNode ( start , 8 ) ;"}
{"text":"Insert 6. So linked list becomes 4.5 . 7.8 . 6","code":"start = insertNode ( start , 6 ) ; System . out . printf ( \" Created \u2581 circular \u2581 doubly \u2581 linked \u2581 list \u2581 is : \u2581 \" ) ; displayList ( start ) ; searchList ( start , 5 ) ; } }"}
{"text":"Java implementation to revesre a doubly circular linked list","code":"class GFG {"}
{"text":"structure of a node of linked list","code":"static class Node { int data ; Node next , prev ; } ;"}
{"text":"function to create and return a new node","code":"static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; return newNode ; }"}
{"text":"Function to insert at the end","code":"static Node insertEnd ( Node head , Node new_node ) {"}
{"text":"If the list is empty , create a single node circular and doubly list","code":"if ( head == null ) { new_node . next = new_node . prev = new_node ; head = new_node ; return head ; }"}
{"text":"Find last node \/","code":"Node last = ( head ) . prev ;"}
{"text":"Start is going to be next of new_node","code":"new_node . next = head ;"}
{"text":"Make new node previous of start","code":"( head ) . prev = new_node ;"}
{"text":"Make last preivous of new node","code":"new_node . prev = last ;"}
{"text":"Make new node next of old last","code":"last . next = new_node ; return head ; }"}
{"text":"Uitlity function to revesre a doubly circular linked list","code":"static Node reverse ( Node head ) { if ( head == null ) return null ;"}
{"text":"Initialize a new head pointer","code":"Node new_head = null ;"}
{"text":"get pointer to the the last node","code":"Node last = head . prev ;"}
{"text":"set ' curr ' to last node","code":"Node curr = last , prev ;"}
{"text":"traverse list in backward direction","code":"while ( curr . prev != last ) { prev = curr . prev ;"}
{"text":"insert ' curr ' at the end of the list starting with the ' new _ head ' pointer","code":"new_head = insertEnd ( new_head , curr ) ; curr = prev ; } new_head = insertEnd ( new_head , curr ) ;"}
{"text":"head pointer of the reversed list","code":"return new_head ; }"}
{"text":"function to display a doubly circular list in forward and backward direction","code":"static void display ( Node head ) { if ( head == null ) return ; Node temp = head ; System . out . print ( \" Forward \u2581 direction : \u2581 \" ) ; while ( temp . next != head ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } System . out . print ( temp . data + \" \u2581 \" ) ; Node last = head . prev ; temp = last ; System . out . print ( \" Backward direction : \"); while ( temp . prev != last ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . prev ; } System . out . print ( temp . data + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { Node head = null ; head = insertEnd ( head , getNode ( 1 ) ) ; head = insertEnd ( head , getNode ( 2 ) ) ; head = insertEnd ( head , getNode ( 3 ) ) ; head = insertEnd ( head , getNode ( 4 ) ) ; head = insertEnd ( head , getNode ( 5 ) ) ; System . out . print ( \"Current list:NEW_LINE\"); display ( head ) ; head = reverse ( head ) ; System . out . print ( \" Reversed list : \"); display ( head ) ; } }"}
{"text":"Naive Java implementation to find LCA in a tree .","code":"import java . io . * ; import java . util . * ; class GFG { static int MAXN = 1001 ;"}
{"text":"stores depth for each node","code":"static int [ ] depth = new int [ MAXN ] ;"}
{"text":"stores first parent for each node","code":"static int [ ] parent = new int [ MAXN ] ; @ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ MAXN ] ; static { for ( int i = 0 ; i < MAXN ; i ++ ) adj [ i ] = new Vector < > ( ) ; } static void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static void dfs ( int cur , int prev ) {"}
{"text":"marking parent for each node","code":"parent [ cur ] = prev ;"}
{"text":"marking depth for each node","code":"depth [ cur ] = depth [ prev ] + 1 ;"}
{"text":"propogating marking down the tree","code":"for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] . elementAt ( i ) != prev ) dfs ( adj [ cur ] . elementAt ( i ) , cur ) ; } static void preprocess ( ) {"}
{"text":"a dummy node","code":"depth [ 0 ] = - 1 ;"}
{"text":"precalclating 1 ) depth . 2 ) parent . for each node","code":"dfs ( 1 , 0 ) ; }"}
{"text":"Time Complexity : O ( Height of tree ) recursively jumps one node above till both the nodes become equal","code":"static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int temp = u ; u = v ; v = temp ; } v = parent [ v ] ; return LCANaive ( u , v ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"adding edges to the tree","code":"addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; System . out . println ( \" LCA ( 11,8 ) \u2581 : \u2581 \" + LCANaive ( 11 , 8 ) ) ; System . out . println ( \" LCA ( 3,13 ) \u2581 : \u2581 \" + LCANaive ( 3 , 13 ) ) ; } }"}
{"text":"Java program to find LCA using Sqrt decomposition","code":"import java . util . * ; class GFG { static final int MAXN = 1001 ;"}
{"text":"block size = Math . sqrt ( height )","code":"static int block_sz ;"}
{"text":"stores depth for each node","code":"static int [ ] depth = new int [ MAXN ] ;"}
{"text":"stores first parent for each node","code":"static int [ ] parent = new int [ MAXN ] ;"}
{"text":"stores first ancestor in previous block","code":"static int [ ] jump_parent = new int [ MAXN ] ; static Vector < Integer > [ ] adj = new Vector [ MAXN ] ; static void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int t = u ; u = v ; v = t ; } v = parent [ v ] ; return LCANaive ( u , v ) ; }"}
{"text":"precalculating the required parameters associated with every node","code":"static void dfs ( int cur , int prev ) {"}
{"text":"marking depth of cur node","code":"depth [ cur ] = depth [ prev ] + 1 ;"}
{"text":"marking parent of cur node","code":"parent [ cur ] = prev ;"}
{"text":"making jump_parent of cur node","code":"if ( depth [ cur ] % block_sz == 0 )"}
{"text":"if it is first node of the block then its jump_parent is its cur parent","code":"jump_parent [ cur ] = parent [ cur ] ; else"}
{"text":"if it is not the first node of this block then its jump_parent is jump_parent of its parent","code":"jump_parent [ cur ] = jump_parent [ prev ] ;"}
{"text":"propogating the marking down the subtree","code":"for ( int i = 0 ; i < adj [ cur ] . size ( ) ; ++ i ) if ( adj [ cur ] . get ( i ) != prev ) dfs ( adj [ cur ] . get ( i ) , cur ) ; }"}
{"text":"using sqrt decomposition trick","code":"static int LCASQRT ( int u , int v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) {"}
{"text":"maintaining depth [ v ] > depth [ u ]","code":"int t = u ; u = v ; v = t ; }"}
{"text":"climb to its jump parent","code":"v = jump_parent [ v ] ; }"}
{"text":"u and v have same jump_parent","code":"return LCANaive ( u , v ) ; } static void preprocess ( int height ) { block_sz = ( int ) Math . sqrt ( height ) ; depth [ 0 ] = - 1 ;"}
{"text":"precalclating 1 ) depth . 2 ) parent . 3 ) jump_parent for each node","code":"dfs ( 1 , 0 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ;"}
{"text":"adding edges to the tree","code":"addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ;"}
{"text":"here we are directly taking height = 4 according to the given tree but we can pre - calculate height = max depth in one more dfs","code":"int height = 4 ; preprocess ( height ) ; System . out . print ( \" LCA ( 11,8 ) \u2581 : \u2581 \" + LCASQRT ( 11 , 8 ) + \"NEW_LINE\"); System . out . print ( \" LCA ( 3,13 ) \u2581 : \u2581 \" + LCASQRT ( 3 , 13 ) + \"NEW_LINE\"); } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 3 ;"}
{"text":"Formula for number of trails for N consecutive heads","code":"System . out . print ( Math . pow ( 2 , N + 1 ) - 2 ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ;"}
{"text":"Function to return the count of numbers which are divisible by both A and B in the range [ 1 , N ] in constant time","code":"class GFG { static int countOfNum ( int n , int a , int b ) { int cnt_of_a , cnt_of_b , cnt_of_ab , sum ;"}
{"text":"Compute the count of numbers divisible by A in the range [ 1 , N ]","code":"cnt_of_a = n \/ a ;"}
{"text":"Compute the count of numbers divisible by B in the range [ 1 , N ]","code":"cnt_of_b = n \/ b ;"}
{"text":"Adding the counts which are divisible by A and B","code":"sum = cnt_of_b + cnt_of_a ;"}
{"text":"The above value might contain repeated values which are divisible by both A and B . Therefore , the count of numbers which are divisible by both A and B are found","code":"cnt_of_ab = n \/ ( a * b ) ;"}
{"text":"The count computed above is subtracted to compute the final count","code":"sum = sum - cnt_of_ab ; return sum ; }"}
{"text":"Function to return the sum of numbers which are divisible by both A and B in the range [ 1 , N ]","code":"static int sumOfNum ( int n , int a , int b ) { int i ; int sum = 0 ;"}
{"text":"Set to store the numbers so that the numbers are not repeated","code":"Set < Integer > ans = new HashSet < Integer > ( ) ;"}
{"text":"For loop to find the numbers which are divisible by A and insert them into the set","code":"for ( i = a ; i <= n ; i = i + a ) { ans . add ( i ) ; }"}
{"text":"For loop to find the numbers which are divisible by A and insert them into the set","code":"for ( i = b ; i <= n ; i = i + b ) { ans . add ( i ) ; }"}
{"text":"For loop to iterate through the set and find the sum","code":"for ( Integer it : ans ) { sum = sum + it ; } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 88 ; int A = 11 ; int B = 8 ; int count = countOfNum ( N , A , B ) ; int sumofnum = sumOfNum ( N , A , B ) ; System . out . print ( sumofnum % count ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the value of the given expression","code":"static double get ( double L , double R ) {"}
{"text":"Value of the first term","code":"double x = 1.0 \/ L ;"}
{"text":"Value of the last term","code":"double y = 1.0 \/ ( R + 1.0 ) ; return ( x - y ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int L = 6 , R = 12 ;"}
{"text":"Get the result","code":"double ans = get ( L , R ) ; System . out . printf ( \" % .2f \" , ans ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; import java . util . * ; class GFG { static int MAX = 100000 ;"}
{"text":"To store the pre - computed integers","code":"static ArrayList < Integer > v = new ArrayList < Integer > ( ) ; public static int upper_bound ( ArrayList < Integer > ar , int k ) { int s = 0 ; int e = ar . size ( ) ; while ( s != e ) { int mid = s + e >> 1 ; if ( ar . get ( mid ) <= k ) { s = mid + 1 ; } else { e = mid ; } } if ( s == ar . size ( ) ) { return - 1 ; } return s ; }"}
{"text":"Function that returns true if the binary representation of x contains consecutive 1 s","code":"static int consecutiveOnes ( int x ) {"}
{"text":"To store the previous bit","code":"int p = 0 ; while ( x > 0 ) {"}
{"text":"Check whether the previous bit and the current bit are both 1","code":"if ( x % 2 == 1 && p == 1 ) { return 1 ; }"}
{"text":"Update previous bit","code":"p = x % 2 ;"}
{"text":"Go to the next bit","code":"x \/= 2 ; } return 0 ; }"}
{"text":"Function to pre - compute the valid numbers from 0 to MAX","code":"static void preCompute ( ) {"}
{"text":"Store all the numbers which do not have consecutive 1 s","code":"for ( int i = 0 ; i <= MAX ; i ++ ) { if ( consecutiveOnes ( i ) == 0 ) { v . add ( i ) ; } } }"}
{"text":"Function to return the minimum number greater than n which does not contain consecutive 1 s","code":"static int nextValid ( int n ) {"}
{"text":"Search for the next greater element with no consecutive 1 s","code":"int it = upper_bound ( v , n ) ; int val = v . get ( it ) ; return val ; }"}
{"text":"Function to perform the queries","code":"static void performQueries ( int queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( nextValid ( queries [ i ] ) ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int queries [ ] = { 4 , 6 } ; int q = queries . length ;"}
{"text":"Pre - compute the numbers","code":"preCompute ( ) ;"}
{"text":"Perform the queries","code":"performQueries ( queries , q ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the number of operations required","code":"static int changeToOnes ( String str ) {"}
{"text":"ctr will store the number of consecutive ones at the end of the given binary string","code":"int i , l , ctr = 0 ; l = str . length ( ) ;"}
{"text":"Loop to find number of 1 s at the end of the string","code":"for ( i = l - 1 ; i >= 0 ; i -- ) {"}
{"text":"If the current character is 1","code":"if ( str . charAt ( i ) == '1' ) ctr ++ ;"}
{"text":"If we encounter the first 0 from the LSB position then we 'll break the loop","code":"else break ; }"}
{"text":"Number of operations required is ( l - ctr )","code":"return l - ctr ; }"}
{"text":"Function to remove leading zeroes from the string","code":"static String removeZeroesFromFront ( String str ) { String s ; int i = 0 ;"}
{"text":"Loop until s [ i ] becomes not equal to 1","code":"while ( i < str . length ( ) && str . charAt ( i ) == '0' ) i ++ ;"}
{"text":"If we reach the end of the string , it means that string contains only 0 's","code":"if ( i == str . length ( ) ) s = \"0\" ;"}
{"text":"Return the string without leading zeros","code":"else s = str . substring ( i , str . length ( ) - i ) ; return s ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \"10010111\" ;"}
{"text":"Removing the leading zeroes","code":"str = removeZeroesFromFront ( str ) ; System . out . println ( changeToOnes ( str ) ) ; } }"}
{"text":"Java Implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the minimum deletions required","code":"static int MinDeletion ( int a [ ] , int n ) {"}
{"text":"To store the frequency of the array elements","code":"Map < Integer , Integer > mp = new HashMap < > ( ) ;"}
{"text":"Store frequency of each element","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } }"}
{"text":"To store the minimum deletions required","code":"int ans = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) {"}
{"text":"Value","code":"int x = i . getKey ( ) ;"}
{"text":"It 's frequency","code":"int frequency = i . getValue ( ) ;"}
{"text":"If number less than or equal to it 's frequency","code":"if ( x <= frequency ) {"}
{"text":"Delete extra occurrences","code":"ans += ( frequency - x ) ; }"}
{"text":"Delete every occurrence of x","code":"else ans += frequency ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = a . length ; System . out . println ( MinDeletion ( a , n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find maximum number of ABs","code":"static int maxCountAB ( String s [ ] , int n ) {"}
{"text":"variable A , B , AB for count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively .","code":"int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String S = s [ i ] ; int L = S . length ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) {"}
{"text":"' AB ' is already present in string before concatenate them","code":"if ( S . charAt ( j ) == ' A ' && S . charAt ( j + 1 ) == ' B ' ) { ans ++ ; } }"}
{"text":"count of strings that begins with ' B ' and ends with 'A","code":"if ( S . charAt ( 0 ) == ' B ' && S . charAt ( L - 1 ) == ' A ' ) BA ++ ;"}
{"text":"count of strings that begins with ' B ' but does not end with ' A '","code":"else if ( S . charAt ( 0 ) == ' B ' ) B ++ ;"}
{"text":"count of strings that ends with ' A ' but not end with ' B '","code":"else if ( S . charAt ( L - 1 ) == ' A ' ) A ++ ; }"}
{"text":"updating the value of ans and add extra count of ' AB '","code":"if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s [ ] = { \" ABCA \" , \" BOOK \" , \" BAND \" } ; int n = s . length ; System . out . println ( maxCountAB ( s , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the minimum number of operations required","code":"static int MinOperations ( int n , int x , int [ ] arr ) {"}
{"text":"To store total operations required","code":"int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) {"}
{"text":"First make all elements equal to x which are currenctly greater","code":"if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } }"}
{"text":"Left scan the array","code":"for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ;"}
{"text":"Update the current element such that neighbouring sum is < x","code":"if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = arr . length ; System . out . println ( MinOperations ( N , X , arr ) ) ; } }"}
{"text":"Java implementation of the approach","code":"public class GFG {"}
{"text":"Function to print the required numbers","code":"static void findNumbers ( int arr [ ] , int n ) {"}
{"text":"Sum of first n natural numbers","code":"int sumN = ( n * ( n + 1 ) ) \/ 2 ;"}
{"text":"Sum of squares of first n natural numbers","code":"int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 ;"}
{"text":"To store the sum and sum of squares of the array elements","code":"int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) \/ ( sum - sumN ) ) + sumN - sum ) \/ 2 ; int A = sum - sumN + B ; System . out . println ( \" A \u2581 = \u2581 \" + A + \" B = \" + B); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = arr . length ; findNumbers ( arr , n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to find the whether the string temp starts with str or not","code":"static boolean is_prefix ( String temp , String str ) {"}
{"text":"Base Case","code":"if ( temp . length ( ) < str . length ( ) ) return false ; else {"}
{"text":"Check for the corresponding characters in temp & str","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != temp . charAt ( i ) ) return false ; } return true ; } }"}
{"text":"Function to find lexicographic smallest string consisting of the string str as prefix","code":"static String lexicographicallyString ( String [ ] input , int n , String str ) {"}
{"text":"Sort the given array string arr [ ]","code":"Arrays . sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = input [ i ] ;"}
{"text":"If the i - th string contains given string as a prefix , then print the result","code":"if ( is_prefix ( temp , str ) ) { return temp ; } }"}
{"text":"If no string exists then return \" - 1\"","code":"return \" - 1\" ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { String [ ] arr = { \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" } ; String S = \" app \" ; int N = 5 ; System . out . println ( lexicographicallyString ( arr , N , S ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class GFG {"}
{"text":"Function to rearrange the array","code":"static void Rearrange ( int arr [ ] , int K , int N ) {"}
{"text":"Stores the rearranged array","code":"int ans [ ] = new int [ N + 1 ] ;"}
{"text":"Stores whether the arrangement is possible or not","code":"int f = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = - 1 ; }"}
{"text":"Update K with the position of K","code":"for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == K ) { K = i ; break ; } }"}
{"text":"Stores all elements lesser than and greater than in vector smaller and greater respectively","code":"Vector < Integer > smaller = new Vector < Integer > ( ) ; Vector < Integer > greater = new Vector < Integer > ( ) ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If arr [ i ] is less than arr [ K ]","code":"if ( arr [ i ] < arr [ K ] ) smaller . add ( arr [ i ] ) ;"}
{"text":"Else","code":"else if ( arr [ i ] > arr [ K ] ) greater . add ( arr [ i ] ) ; } int low = 0 , high = N - 1 ;"}
{"text":"Iterate unil low is less than or equal to high","code":"while ( low <= high ) {"}
{"text":"Stores mid point","code":"int mid = ( low + high ) \/ 2 ;"}
{"text":"If mid is equal to K","code":"if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; }"}
{"text":"If mid is less than K","code":"else if ( mid < K ) { if ( smaller . size ( ) == 0 ) { break ; } ans [ mid ] = smaller . lastElement ( ) ; smaller . remove ( smaller . size ( ) - 1 ) ; low = mid + 1 ; }"}
{"text":"If mid is greater than K","code":"else { if ( greater . size ( ) == 0 ) { break ; } ans [ mid ] = greater . lastElement ( ) ; greater . remove ( greater . size ( ) - 1 ) ; high = mid - 1 ; } }"}
{"text":"If f is - 1","code":"if ( f == - 1 ) { System . out . println ( - 1 ) ; return ; }"}
{"text":"Iterate in the range [ 1 , N ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If ans [ i ] is equal to - 1","code":"if ( ans [ i ] == - 1 ) { if ( smaller . size ( ) > 0 ) { ans [ i ] = smaller . lastElement ( ) ; smaller . remove ( smaller . size ( ) - 1 ) ; } else if ( greater . size ( ) > 0 ) { ans [ i ] = greater . lastElement ( ) ; greater . remove ( greater . size ( ) - 1 ) ; } } }"}
{"text":"Print the rearranged array","code":"for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ans [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"Input","code":"int arr [ ] = { 10 , 7 , 2 , 5 , 3 , 8 } ; int K = 7 ; int N = arr . length ;"}
{"text":"Function Call","code":"Rearrange ( arr , K , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find minimum value of K such that the first person gets at least ( N \/ ( M + 1 ) ) candies","code":"static void minimumK ( ArrayList < Integer > arr , int M , int N ) {"}
{"text":"Find the minimum required value of candies for the first person","code":"int good = ( int ) ( ( N * 1.0 ) \/ ( ( M + 1 ) * 1.0 ) ) + 1 ;"}
{"text":"Iterate K from [ 1 , n ]","code":"for ( int i = 1 ; i <= N ; i ++ ) { int K = i ;"}
{"text":"Total number of candies","code":"int candies = N ;"}
{"text":"Candies taken by Person 1","code":"int taken = 0 ; while ( candies > 0 ) {"}
{"text":"Candies taken by 1 st person is minimum of K and candies left","code":"taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int j = 0 ; j < M ; j ++ ) {"}
{"text":"Amount consumed by the person j","code":"int consume = ( arr . get ( j ) * candies ) \/ 100 ;"}
{"text":"Update the number of candies","code":"candies -= consume ; } }"}
{"text":"Good share of candies achieved","code":"if ( taken >= good ) { System . out . print ( i ) ; return ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 13 , M = 1 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; arr . add ( 50 ) ; minimumK ( arr , M , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if the value of mid gives at least ( N \/ ( M + 1 ) ) candies or not","code":"static boolean check ( int K , int n , int m , ArrayList < Integer > arr , int good_share ) { int candies = n , taken = 0 ; while ( candies > 0 ) {"}
{"text":"Candies taken by 1 st person is minimum of K and candies left","code":"taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ;"}
{"text":"Traverse the given array","code":"for ( int j = 0 ; j < m ; j ++ ) {"}
{"text":"Amount consumed by person j","code":"int consume = ( arr . get ( j ) * candies ) \/ 100 ;"}
{"text":"Update the count of candies","code":"candies -= consume ; } }"}
{"text":"Check if person 1 gets the good share of candies","code":"return ( taken >= good_share ) ; }"}
{"text":"Function to find minimum value of K such that the first person gets at least ( N \/ ( M + 1 ) ) candies","code":"static void minimumK ( ArrayList < Integer > arr , int N , int M ) {"}
{"text":"Find the minimum required value of candies for the first person","code":"int good_share = ( int ) Math . ceil ( ( N * 1.0 ) \/ ( ( M + 1 ) * 1.0 ) ) ; int lo = 1 , hi = N ;"}
{"text":"Iterate until low is less than or equal to mid","code":"while ( lo < hi ) {"}
{"text":"Find the value of mid","code":"int mid = ( lo + hi ) \/ 2 ;"}
{"text":"Check for mid , whether it can be the possible value of K or not","code":"if ( check ( mid , N , M , arr , good_share ) ) {"}
{"text":"Update the value of hi","code":"hi = mid ; }"}
{"text":"Otherwise , update the value of lo","code":"else { lo = mid + 1 ; } }"}
{"text":"Print the resultant minimum value of K","code":"System . out . print ( hi ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 13 , M = 1 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; arr . add ( 50 ) ; minimumK ( arr , N , M ) ; } }"}
{"text":"Java program for above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate time taken to travel the path","code":"static void calcTotalTime ( String path ) {"}
{"text":"Stores total time","code":"int time = 0 ;"}
{"text":"Initial position","code":"int x = 0 , y = 0 ;"}
{"text":"Stores visited segments","code":"Set < String > s = new HashSet < > ( ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { int p = x ; int q = y ; if ( path . charAt ( i ) == ' N ' ) y ++ ; else if ( path . charAt ( i ) == ' S ' ) y -- ; else if ( path . charAt ( i ) == ' E ' ) x ++ ; else if ( path . charAt ( i ) == ' W ' ) x -- ;"}
{"text":"Check whether segment is present in the set","code":"String o = ( p + x ) + \" \u2581 \" + ( q + y ) ; if ( ! s . contains ( o ) ) {"}
{"text":"Increment the value of time by 2","code":"time += 2 ;"}
{"text":"Insert segment into the set","code":"s . add ( o ) ; } else time += 1 ; }"}
{"text":"Print the value of time","code":"System . out . println ( time ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String path = \" NSE \" ; calcTotalTime ( path ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to calculate the cost required to make all array elements equal to 1","code":"static int findCost ( int [ ] A , int N ) {"}
{"text":"Stores the total cost","code":"int totalCost = 0 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If current element is 0","code":"if ( A [ i ] == 0 ) {"}
{"text":"Convert 0 to 1","code":"A [ i ] = 1 ;"}
{"text":"Add the cost","code":"totalCost += i ; } }"}
{"text":"Return the total cost","code":"return totalCost ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = arr . length ; System . out . println ( findCost ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the peak index for the given array","code":"public static int peakIndex ( int [ ] arr ) { int N = arr . length ;"}
{"text":"Base Case","code":"if ( arr . length < 3 ) return - 1 ; int i = 0 ;"}
{"text":"Check for strictly increasing array","code":"while ( i + 1 < N ) {"}
{"text":"If the strictly increasing condition is violated , then break","code":"if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return - 1 ;"}
{"text":"Stores the value of i , which is a potential peak index","code":"int ans = i ;"}
{"text":"Second traversal , for strictly decreasing array","code":"while ( i < N - 1 ) {"}
{"text":"When the strictly decreasing condition is violated , then break","code":"if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; }"}
{"text":"If i = N - 1 , it means that ans is the peak index","code":"if ( i == N - 1 ) return ans ;"}
{"text":"Otherwise , peak index doesn 't exist","code":"return - 1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 0 } ; System . out . println ( peakIndex ( arr ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if the array has 2 elements whose sum is equal to the given value","code":"static void hasArrayTwoPairs ( int nums [ ] , int n , int target ) {"}
{"text":"Sort the array in increasing order","code":"Arrays . sort ( nums ) ;"}
{"text":"Traverse the array , nums [ ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Store the required number to be found","code":"int x = target - nums [ i ] ;"}
{"text":"Perform binary search","code":"int low = 0 , high = n - 1 ; while ( low <= high ) {"}
{"text":"Store the mid value","code":"int mid = low + ( ( high - low ) \/ 2 ) ;"}
{"text":"If nums [ mid ] is greater than x , then update high to mid - 1","code":"if ( nums [ mid ] > x ) { high = mid - 1 ; }"}
{"text":"If nums [ mid ] is less than x , then update low to mid + 1","code":"else if ( nums [ mid ] < x ) { low = mid + 1 ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"If mid is equal i , check mid - 1 and mid + 1","code":"if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { System . out . print ( nums [ i ] + \" , \u2581 \" ) ; System . out . print ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { System . out . print ( nums [ i ] + \" , \u2581 \" ) ; System . out . print ( nums [ mid + 1 ] ) ; return ; } break ; }"}
{"text":"Otherwise , print the pair and return","code":"else { System . out . print ( nums [ i ] + \" , \u2581 \" ) ; System . out . print ( nums [ mid ] ) ; return ; } } } }"}
{"text":"If no such pair is found , then print - 1","code":"System . out . print ( - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 0 , - 1 , 2 , - 3 , 1 } ; int X = - 2 ; int N = A . length ;"}
{"text":"Function Call","code":"hasArrayTwoPairs ( A , N , X ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the divisor of N closest to the target","code":"static void findClosest ( int N , int target ) { int closest = - 1 ; int diff = Integer . MAX_VALUE ;"}
{"text":"Iterate till square root of N","code":"for ( int i = 1 ; i <= ( int ) Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) {"}
{"text":"Check if divisors are equal","code":"if ( N \/ i == i ) {"}
{"text":"Check if i is the closest","code":"if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } } else {"}
{"text":"Check if i is the closest","code":"if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; }"}
{"text":"Check if n \/ i is the closest","code":"if ( Math . abs ( target - N \/ i ) < diff ) { diff = Math . abs ( target - N \/ i ) ; closest = N \/ i ; } } } }"}
{"text":"Print the closest value","code":"System . out . println ( closest ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N & X","code":"int N = 16 , X = 5 ;"}
{"text":"Function Call","code":"findClosest ( N , X ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the minimum power of A and B greater than N","code":"static int power ( int A , int N ) {"}
{"text":"Stores the power of A which is greater than N","code":"int count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) {"}
{"text":"Increment count by 1","code":"count ++ ;"}
{"text":"Divide N by A","code":"N \/= A ; } return count ; }"}
{"text":"Function to find a pair ( a , b ) such that A ^ a + B ^ b = N","code":"static void Pairs ( int N , int A , int B ) { int powerA , powerB ;"}
{"text":"Calculate the minimum power of A greater than N","code":"powerA = power ( A , N ) ;"}
{"text":"Calculate the minimum power of B greater than N","code":"powerB = power ( B , N ) ;"}
{"text":"Make copy of A and B","code":"int intialB = B , intialA = A ;"}
{"text":"Traverse for every pair ( i , j )","code":"A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) {"}
{"text":"Check if B ^ j + A ^ i = N To overcome the overflow problem use B = N - A rather than B + A = N","code":"if ( B == N - A ) { System . out . println ( i + \" \u2581 \" + j ) ; return ; }"}
{"text":"Increment power B by 1","code":"B *= intialB ; }"}
{"text":"Increment power A by 1","code":"A *= intialA ; }"}
{"text":"Finally print - 1 if no pair is found","code":"System . out . println ( \" - 1\" ) ; return ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given A , B and N","code":"int N = 106 , A = 3 , B = 5 ;"}
{"text":"Function Call","code":"Pairs ( N , A , B ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the non - multiples till k","code":"public static int findNonMultiples ( int [ ] arr , int n , int k ) {"}
{"text":"Stores all unique multiples","code":"Set < Integer > multiples = new HashSet < Integer > ( ) ;"}
{"text":"Iterate the array","code":"for ( int i = 0 ; i < n ; ++ i ) {"}
{"text":"For finding duplicates only once","code":"if ( ! multiples . contains ( arr [ i ] ) ) {"}
{"text":"Inserting all multiples into the set","code":"for ( int j = 1 ; j <= k \/ arr [ i ] ; j ++ ) { multiples . add ( arr [ i ] * j ) ; } } }"}
{"text":"Returning only the count of numbers that are not divisible by any of the array elements","code":"return k - multiples . size ( ) ; }"}
{"text":"Function to count the total values in the range [ L , R ]","code":"public static int countValues ( int [ ] arr , int N , int L , int R ) {"}
{"text":"Count all values in the range using exclusion principle","code":"return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int N = arr . length ; int L = 1 ; int R = 20 ;"}
{"text":"Function Call","code":"System . out . println ( countValues ( arr , N , L , R ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum number of coins to be collected per hour to empty N piles in H hours","code":"static void minCollectingSpeed ( int [ ] piles , int H ) {"}
{"text":"Stores the minimum coins to be removed per hour","code":"int ans = - 1 ; int low = 1 , high ;"}
{"text":"Find the maximum array element","code":"high = Arrays . stream ( piles ) . max ( ) . getAsInt ( ) ;"}
{"text":"Perform Binary Search","code":"while ( low <= high ) {"}
{"text":"Store the mid value of the range in K","code":"int K = low + ( high - low ) \/ 2 ; int time = 0 ;"}
{"text":"Find the total time taken to empty N piles by removing K coins per hour","code":"for ( int ai : piles ) { time += ( ai + K - 1 ) \/ K ; }"}
{"text":"If total time does not exceed H","code":"if ( time <= H ) { ans = K ; high = K - 1 ; }"}
{"text":"Otherwise","code":"else { low = K + 1 ; } }"}
{"text":"Print the required result","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"static public void main ( String args [ ] ) { int [ ] arr = { 3 , 6 , 7 , 11 } ; int H = 8 ;"}
{"text":"Function Call","code":"minCollectingSpeed ( arr , H ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count distinct pairs in array whose sum equal to K","code":"static int cntDisPairs ( int arr [ ] , int N , int K ) {"}
{"text":"Stores count of distinct pairs whose sum equal to K","code":"int cntPairs = 0 ;"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"Stores index of the left pointer","code":"int i = 0 ;"}
{"text":"Stores index of the right pointer","code":"int j = N - 1 ;"}
{"text":"Calculate count of distinct pairs whose sum equal to K","code":"while ( i < j ) {"}
{"text":"If sum of current pair is equal to K","code":"if ( arr [ i ] + arr [ j ] == K ) {"}
{"text":"Remove consecutive duplicate array elements","code":"while ( i < j && arr [ i ] == arr [ i + 1 ] ) {"}
{"text":"Update i","code":"i ++ ; }"}
{"text":"Remove consecutive duplicate array elements","code":"while ( i < j && arr [ j ] == arr [ j - 1 ] ) {"}
{"text":"Update j","code":"j -- ; }"}
{"text":"Update cntPairs","code":"cntPairs += 1 ;"}
{"text":"Update i","code":"i ++ ;"}
{"text":"Update j","code":"j -- ; }"}
{"text":"if sum of current pair less than K","code":"else if ( arr [ i ] + arr [ j ] < K ) {"}
{"text":"Update i","code":"i ++ ; } else {"}
{"text":"Update j","code":"j -- ; } } return cntPairs ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . length ; int K = 13 ; System . out . print ( cntDisPairs ( arr , N , K ) ) ; }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count distinct pairs in array whose sum equal to K","code":"static int cntDisPairs ( int arr [ ] , int N , int K ) {"}
{"text":"Stores count of distinct pairs whose sum equal to K","code":"int cntPairs = 0 ;"}
{"text":"Store frequency of each distinct element of the array","code":"HashMap < Integer , Integer > cntFre = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update frequency of arr [ i ]","code":"if ( cntFre . containsKey ( arr [ i ] ) ) cntFre . put ( arr [ i ] , cntFre . get ( arr [ i ] ) + 1 ) ; else cntFre . put ( arr [ i ] , 1 ) ; }"}
{"text":"Traverse the map","code":"for ( Map . Entry < Integer , Integer > it : cntFre . entrySet ( ) ) {"}
{"text":"Stores key value of the map","code":"int i = it . getKey ( ) ;"}
{"text":"If i is the half of K","code":"if ( 2 * i == K ) {"}
{"text":"If frequency of i greater than 1","code":"if ( cntFre . get ( i ) > 1 ) cntPairs += 2 ; } else { if ( cntFre . containsKey ( K - i ) ) {"}
{"text":"Update cntPairs","code":"cntPairs += 1 ; } } }"}
{"text":"Update cntPairs","code":"cntPairs = cntPairs \/ 2 ; return cntPairs ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . length ; int K = 13 ; System . out . print ( cntDisPairs ( arr , N , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the length of the longest subsequence such that no two adjacent elements are equal","code":"static void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { for ( int i = 0 ; i < Q ; i ++ ) {"}
{"text":"Replace element at index x with y","code":"int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ;"}
{"text":"Since x is 1 - indexed , decrement x by 1","code":"arr [ x - 1 ] = y ;"}
{"text":"Keep track of number of elements in subsequence","code":"int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) {"}
{"text":"If previous element is not same as current element","code":"if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } }"}
{"text":"Print the desired count","code":"System . out . print ( count + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . length ; int Q = 2 ; int Queries [ ] [ ] = { { 1 , 3 } , { 4 , 2 } } ;"}
{"text":"Function Call","code":"longestSubsequence ( N , Q , arr , Queries ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { int count = 1 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"If previous element is not same as current element","code":"if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } }"}
{"text":"Traverse the queries","code":"for ( int i = 0 ; i < Q ; i ++ ) {"}
{"text":"Replace element at index x with y","code":"int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ;"}
{"text":"Recalculate for index x","code":"if ( x > 1 ) {"}
{"text":"Subtract contribution of element at index x","code":"if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; }"}
{"text":"Add contribution of y","code":"if ( arr [ x - 2 ] != y ) { count += 1 ; } }"}
{"text":"Recalculate for index x + 1","code":"if ( x < N ) {"}
{"text":"Subtract contribution of element at index x + 1","code":"if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; }"}
{"text":"Adds contribution of y","code":"if ( y != arr [ x ] ) { count += 1 ; } } System . out . print ( count + \" \u2581 \" ) ;"}
{"text":"Replace the element","code":"arr [ x - 1 ] = y ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . length ; int Q = 2 ; int Queries [ ] [ ] = { { 1 , 3 } , { 4 , 2 } } ;"}
{"text":"Function Call","code":"longestSubsequence ( N , Q , arr , Queries ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find sum of differences of indices of occurrences of each unique array element","code":"static void sum ( int arr [ ] , int n ) {"}
{"text":"Stores indices of each array element","code":"HashMap < Integer , Vector < Integer > > mp = new HashMap < > ( ) ;"}
{"text":"Store the indices","code":"for ( int i = 0 ; i < n ; i ++ ) { Vector < Integer > v = new Vector < > ( ) ; v . add ( i ) ; if ( mp . containsKey ( arr [ i ] ) ) v . addAll ( mp . get ( arr [ i ] ) ) ; mp . put ( arr [ i ] , v ) ; }"}
{"text":"Stores the sums","code":"int [ ] ans = new int [ n ] ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Find sum for each element","code":"int sum = 0 ;"}
{"text":"Iterate over the Map","code":"for ( int it : mp . get ( arr [ i ] ) ) {"}
{"text":"Calculate sum of occurrences of arr [ i ]","code":"sum += Math . abs ( it - i ) ; }"}
{"text":"Store sum for current element","code":"ans [ i ] = sum ; }"}
{"text":"Print answer for each element","code":"for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + \" \u2581 \" ) ; } return ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ;"}
{"text":"Given size","code":"int n = arr . length ;"}
{"text":"Function call","code":"sum ( arr , n ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to convert vowels into uppercase","code":"static void conVowUpp ( char [ ] str ) {"}
{"text":"Stores the length of str","code":"int N = str . length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { char c = Character . toUpperCase ( str [ i ] ) ; str [ i ] = c ; } } for ( char c : str ) System . out . print ( c ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" eutopia \" ; conVowUpp ( str . toCharArray ( ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Stores the frequency of each type of chocolate","code":"static HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; static int N , P ;"}
{"text":"Function to check if chocolates can be eaten for ' mid ' no . of days","code":"static boolean helper ( int mid ) { int cnt = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int temp = i . getValue ( ) ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } }"}
{"text":"If cnt exceeds N , return true","code":"return cnt >= N ; }"}
{"text":"Function to find the maximum number of days for which chocolates can be eaten","code":"static int findMaximumDays ( int arr [ ] ) {"}
{"text":"Store the frequency of each type of chocolate","code":"for ( int i = 0 ; i < P ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } }"}
{"text":"Initialize start and end with 0 and P respectively","code":"int start = 0 , end = P , ans = 0 ; while ( start <= end ) {"}
{"text":"Calculate mid","code":"int mid = start + ( ( end - start ) \/ 2 ) ;"}
{"text":"Check if chocolates can be distributed for mid days","code":"if ( mid != 0 && helper ( mid ) ) { ans = mid ;"}
{"text":"Check if chocolates can be distributed for more than mid consecutive days","code":"start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { N = 3 ; P = 10 ; int arr [ ] = { 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 } ;"}
{"text":"Function call","code":"System . out . print ( findMaximumDays ( arr ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function that counts the subarrays having sum modulo k equal to the length of subarray","code":"static void countSubarrays ( int a [ ] , int n , int k ) {"}
{"text":"Stores the count of subarrays","code":"int ans = 0 ;"}
{"text":"Stores prefix sum of the array","code":"ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ;"}
{"text":"Calculate prefix sum array","code":"for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ;"}
{"text":"Generate all the subarrays","code":"for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) {"}
{"text":"Check if this subarray is a valid subarray or not","code":"if ( ( pref . get ( j ) - pref . get ( i - 1 ) + k ) % k == j - i + 1 ) { ans ++ ; } } }"}
{"text":"Total count of subarrays","code":"System . out . println ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) throws java . lang . Exception {"}
{"text":"Given arr [ ]","code":"int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ;"}
{"text":"Size of the array","code":"int N = arr . length ;"}
{"text":"Given K","code":"int K = 4 ;"}
{"text":"Function call","code":"countSubarrays ( arr , N , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function that counts the subarrays having sum modulo k equal to the length of subarray","code":"static void countSubarrays ( int a [ ] , int n , int k ) {"}
{"text":"Stores the count of ( pref [ i ] - i ) % k","code":"HashMap < Integer , Integer > cnt = new HashMap < > ( ) ;"}
{"text":"Stores the count of subarray","code":"long ans = 0 ;"}
{"text":"Stores prefix sum of the array","code":"ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ;"}
{"text":"Find prefix sum array","code":"for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ;"}
{"text":"Base Condition","code":"cnt . put ( 0 , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"Remove the index at present after K indices from the current index","code":"int remIdx = i - k ; if ( remIdx >= 0 ) { if ( cnt . containsKey ( ( pref . get ( remIdx ) - remIdx % k + k ) % k ) ) cnt . put ( ( pref . get ( remIdx ) - remIdx % k + k ) % k , cnt . get ( ( pref . get ( remIdx ) - remIdx % k + k ) % k ) - 1 ) ; else cnt . put ( ( pref . get ( remIdx ) - remIdx % k + k ) % k , - 1 ) ; }"}
{"text":"Update the answer for subarrays ending at the i - th index","code":"if ( cnt . containsKey ( ( pref . get ( i ) - i % k + k ) % k ) ) ans += cnt . get ( ( pref . get ( i ) - i % k + k ) % k ) ;"}
{"text":"Add the calculated value of current index to count","code":"if ( cnt . containsKey ( ( pref . get ( i ) - i % k + k ) % k ) ) cnt . put ( ( pref . get ( i ) - i % k + k ) % k , cnt . get ( ( pref . get ( i ) - i % k + k ) % k ) + 1 ) ; else cnt . put ( ( pref . get ( i ) - i % k + k ) % k , 1 ) ; }"}
{"text":"Print the count of subarrays","code":"System . out . println ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) throws java . lang . Exception {"}
{"text":"Given arr [ ]","code":"int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ;"}
{"text":"Size of the array","code":"int N = arr . length ;"}
{"text":"Given K","code":"int K = 4 ;"}
{"text":"Function call","code":"countSubarrays ( arr , N , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if the substring of length K has equal 0 and 1","code":"static boolean check ( String s , int k ) { int n = s . length ( ) ;"}
{"text":"Traverse the String","code":"for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) {"}
{"text":"Check if every K - th character is the same or not","code":"if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } } int c = 0 ;"}
{"text":"Traverse subString of length K","code":"for ( int i = 0 ; i < k ; i ++ ) {"}
{"text":"If current character is 0","code":"if ( s . charAt ( i ) == '0' )"}
{"text":"Increment count","code":"c ++ ;"}
{"text":"Otherwise","code":"else"}
{"text":"Decrement count","code":"c -- ; }"}
{"text":"Check for equal 0 s and 1 s","code":"if ( c == 0 ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \"101010\" ; int k = 2 ; if ( check ( s , k ) ) System . out . print ( \" Yes \" + \"NEW_LINE\"); else System . out . print ( \" No \" + \"NEW_LINE\"); } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if the freq of any character is divisible by N","code":"static boolean isSame ( String str , int n ) {"}
{"text":"Stores the frequency of characters","code":"HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( mp . containsKey ( str . charAt ( i ) - ' a ' ) ) { mp . put ( str . charAt ( i ) - ' a ' , mp . get ( str . charAt ( i ) - ' a ' ) + 1 ) ; } else { mp . put ( str . charAt ( i ) - ' a ' , 1 ) ; } } for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {"}
{"text":"If frequency of a character is not divisible by n","code":"if ( ( it . getValue ( ) ) >= n ) { return true ; } }"}
{"text":"If no character has frequency at least N","code":"return false ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" ccabcba \" ; int n = 4 ;"}
{"text":"Function Call","code":"if ( isSame ( str , n ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . lang . * ; class GFG { static final double eps = 1e-6 ;"}
{"text":"Given function","code":"static double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; }"}
{"text":"Function to find the root of the given non - decreasing Function","code":"static double findRoot ( double a , double b , double c , double low , double high ) { double x = - 1 ;"}
{"text":"To get the minimum possible answer for the root","code":"while ( Math . abs ( high - low ) > eps ) {"}
{"text":"Find mid","code":"x = ( low + high ) \/ 2 ;"}
{"text":"Search in [ low , x ]","code":"if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; }"}
{"text":"Search in [ x , high ]","code":"else { low = x ; } }"}
{"text":"Return the required answer","code":"return x ; }"}
{"text":"Function to find the roots of the given equation within range [ a , b ]","code":"static void solve ( double a , double b , double c , double A , double B ) {"}
{"text":"If root doesn 't exists","code":"if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { System . out . println ( \" No \u2581 solution \" ) ; }"}
{"text":"Else find the root upto 4 decimal places","code":"else { System . out . format ( \" % .4f \" , findRoot ( a , b , c , A , B ) ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given range","code":"double a = 2 , b = - 3 , c = - 2 , A = 0 , B = 3 ;"}
{"text":"Function call","code":"solve ( a , b , c , A , B ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function check if mid can be median index of the difference array","code":"static boolean possible ( long mid , int [ ] a ) {"}
{"text":"Size of the array","code":"long n = a . length ;"}
{"text":"Total possible no of pair possible","code":"long total = ( n * ( n - 1 ) ) \/ 2 ;"}
{"text":"The index of the element in the difference of all pairs from the array","code":"long need = ( total + 1 ) \/ 2 ; long count = 0 ; long start = 0 , end = 1 ;"}
{"text":"Count the number of pairs having difference <= mid","code":"while ( end < n ) { if ( a [ ( int ) end ] - a [ ( int ) start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } }"}
{"text":"If the difference between end and first element is less then or equal to mid","code":"if ( end == n && start < end && a [ ( int ) end - 1 ] - a [ ( int ) start ] <= mid ) { long t = end - start - 1 ; count += ( t * ( t + 1 ) \/ 2 ) ; }"}
{"text":"Checking for the no of element less than or equal to mid is greater than median or not","code":"if ( count >= need ) return true ; else return false ; }"}
{"text":"Function to calculate the median of differences of all pairs from the array","code":"static long findMedian ( int [ ] a ) {"}
{"text":"Size of the array","code":"long n = a . length ;"}
{"text":"Initialising the low and high","code":"long low = 0 , high = a [ ( int ) n - 1 ] - a [ 0 ] ;"}
{"text":"Binary search","code":"while ( low <= high ) {"}
{"text":"Calculate mid","code":"long mid = ( low + high ) \/ 2 ;"}
{"text":"If mid can be the median of the array","code":"if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; }"}
{"text":"Returning the median of the differences of pairs from the array","code":"return high + 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] a = { 1 , 7 , 5 , 2 } ; Arrays . sort ( a ) ; System . out . println ( findMedian ( a ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find strings from A [ ] having all strings in B [ ] as subsequence","code":"static void UniversalSubset ( List < String > A , List < String > B ) {"}
{"text":"Calculate respective sizes","code":"int n1 = A . size ( ) ; int n2 = B . size ( ) ;"}
{"text":"Stores the answer","code":"List < String > res = new ArrayList < > ( ) ;"}
{"text":"Stores the frequency of each character in strings of A [ ]","code":"int [ ] [ ] A_fre = new int [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; }"}
{"text":"Compute the frequencies of characters of all strings","code":"for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A . get ( i ) . length ( ) ; j ++ ) { A_fre [ i ] [ A . get ( i ) . charAt ( j ) - ' a ' ] ++ ; } }"}
{"text":"Stores the frequency of each character in strings of B [ ] each character of a string in B [ ]","code":"int [ ] B_fre = new int [ 26 ] ; for ( int i = 0 ; i < n2 ; i ++ ) { int [ ] arr = new int [ 26 ] ; for ( int j = 0 ; j < B . get ( i ) . length ( ) ; j ++ ) { arr [ B . get ( i ) . charAt ( j ) - ' a ' ] ++ ; B_fre [ B . get ( i ) . charAt ( j ) - ' a ' ] = Math . max ( B_fre [ B . get ( i ) . charAt ( j ) - ' a ' ] , arr [ B . get ( i ) . charAt ( j ) - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) {"}
{"text":"If the frequency of a character in B [ ] exceeds that in A [ ]","code":"if ( A_fre [ i ] [ j ] < B_fre [ j ] ) {"}
{"text":"A string exists in B [ ] which is not a proper subset of A [ i ]","code":"flag = 1 ; break ; } }"}
{"text":"If all strings in B [ ] are proper subset of A [ ]","code":"if ( flag == 0 )"}
{"text":"Push the string in resultant vector","code":"res . add ( A . get ( i ) ) ; }"}
{"text":"If any string is found","code":"if ( res . size ( ) != 0 ) {"}
{"text":"Print those strings","code":"for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res . get ( i ) . length ( ) ; j ++ ) System . out . print ( res . get ( i ) . charAt ( j ) ) ; } System . out . print ( \" \u2581 \" ) ; }"}
{"text":"Otherwise","code":"else System . out . print ( \" - 1\" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { List < String > A = Arrays . asList ( \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" ) ; List < String > B = Arrays . asList ( \" geek \" , \" ee \" ) ; UniversalSubset ( A , B ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum distance pair where one is the multiple of the other","code":"public static void findPair ( int a [ ] , int n ) {"}
{"text":"Initialize the variables","code":"int min_dist = Integer . MAX_VALUE ; int index_a = - 1 , index_b = - 1 ;"}
{"text":"Iterate for all the elements","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Loop to make pairs","code":"for ( int j = i + 1 ; j < n ; j ++ ) {"}
{"text":"Check for minimum distance","code":"if ( j - i < min_dist ) {"}
{"text":"Check if one is a multiple of other","code":"if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) {"}
{"text":"Update the distance","code":"min_dist = j - i ;"}
{"text":"Store indexes","code":"index_a = i ; index_b = j ; } } } }"}
{"text":"If no such pair exists","code":"if ( index_a == - 1 ) { System . out . println ( \" - 1\" ) ; }"}
{"text":"Print the answer","code":"else { System . out . print ( \" ( \" + a [ index_a ] + \" , \u2581 \" + a [ index_b ] + \" ) \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = a . length ;"}
{"text":"Function Call","code":"findPair ( a , n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to print all numbers in the range [ L , R ] having digits in strictly increasing order","code":"static void printNum ( int L , int R ) {"}
{"text":"Iterate over the range","code":"for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ;"}
{"text":"Iterate over the digits","code":"while ( temp > 0 ) {"}
{"text":"Check if the current digit is >= the previous digit","code":"if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp \/= 10 ; }"}
{"text":"If the digits are in ascending order","code":"if ( flag == 0 ) System . out . print ( i + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given range L and R","code":"int L = 10 , R = 15 ;"}
{"text":"Function call","code":"printNum ( L , R ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to find the missing element","code":"static int findMissing ( int arr [ ] , int left , int right , int diff ) {"}
{"text":"Fix left and right boundary for binary search","code":"if ( right <= left ) return 0 ;"}
{"text":"Find index of middle element","code":"int mid = left + ( right - left ) \/ 2 ;"}
{"text":"Check if the element just after the middle element is missing","code":"if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ;"}
{"text":"Check if the element just before mid is missing","code":"if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ;"}
{"text":"Check if the elements till mid follow the AP , then recur for right half","code":"if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ;"}
{"text":"Else recur for left half","code":"return findMissing ( arr , left , mid - 1 , diff ) ; }"}
{"text":"Function to find the missing element in AP series","code":"static int missingElement ( int arr [ ] , int n ) {"}
{"text":"Sort the array arr [ ]","code":"Arrays . sort ( arr ) ;"}
{"text":"Calculate Common Difference","code":"int diff = ( arr [ n - 1 ] - arr [ 0 ] ) \/ n ;"}
{"text":"Binary search for the missing","code":"return findMissing ( arr , 0 , n - 1 , diff ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = new int [ ] { 2 , 8 , 6 , 10 } ; int n = arr . length ;"}
{"text":"Function Call","code":"System . out . println ( missingElement ( arr , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to calculate x raised to the power y in O ( logn )","code":"static int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y \/ 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text":"Function to find the Kth root of the number N using BS","code":"static int nthRootSearch ( int low , int high , int N , int K ) {"}
{"text":"If the range is still valid","code":"if ( low <= high ) {"}
{"text":"Find the mid - value of range","code":"int mid = ( low + high ) \/ 2 ;"}
{"text":"Base Case","code":"if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; }"}
{"text":"Condition to check if the left search space is useless","code":"else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; }"}
{"text":"Driver Code","code":"public static void main ( String s [ ] ) {"}
{"text":"Given N and K","code":"int N = 16 , K = 4 ;"}
{"text":"Function Call","code":"System . out . println ( nthRootSearch ( 0 , N , N , K ) ) ; } }"}
{"text":"Java program to print count of subsets S such that Math . min ( S ) + Math . max ( S ) < K","code":"import java . util . * ; class GFG {"}
{"text":"Function that return the count of subset such that Math . min ( S ) + Math . max ( S ) < K","code":"static int get_subset_count ( int arr [ ] , int K , int N ) {"}
{"text":"Sorting the array","code":"Arrays . sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ;"}
{"text":"ans stores total number of subsets","code":"int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) {"}
{"text":"Add all possible subsets between i and j","code":"ans += 1 << ( right - left ) ; left ++ ; } else {"}
{"text":"Decrease the sum","code":"right -- ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = arr . length ; System . out . print ( get_subset_count ( arr , K , N ) ) ; } }"}
{"text":"Java program to find the minimum of maximum difference between adjacent elements after at most K insertions","code":"import java . util . * ; class GFG { static int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = Integer . MIN_VALUE ;"}
{"text":"Calculate the maximum adjacent difference","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . max ( max_adj_dif , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ;"}
{"text":"If the maximum adjacent difference is already zero","code":"if ( max_adj_dif == 0 ) return 0 ;"}
{"text":"best and worst specifies range of the maximum adjacent difference","code":"int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) \/ 2 ;"}
{"text":"To store the no of insertions required for respective values of mid","code":"required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) \/ mid ; }"}
{"text":"If the number of insertions required exceeds K","code":"if ( required > k ) best = mid + 1 ;"}
{"text":"Otherwise","code":"else worst = mid ; } return worst ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = arr . length ; int k = 7 ; System . out . println ( minMaxDiff ( arr , n , k ) ) ; } }"}
{"text":"Java implementation to check if the minimum element in the array is greater than or equal to half of every other elements","code":"import java . util . * ; class GFG {"}
{"text":"Function to Check if the minimum element in the array is greater than or equal to half of every other elements","code":"static void checkMin ( int arr [ ] , int len ) {"}
{"text":"Initialise the variables to store smallest and second smallest","code":"int smallest = Integer . MAX_VALUE ; int secondSmallest = Integer . MAX_VALUE ; for ( int i = 0 ; i < len ; i ++ ) {"}
{"text":"Check if current element is smaller than smallest , the current smallest will become secondSmallest and current element will be the new smallest","code":"if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; }"}
{"text":"Check if current element is smaller than secondSmallest simply update the latter","code":"else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int len = arr . length ; checkMin ( arr , len ) ; } }"}
{"text":"Java program to find minimum and maximum fibonacci number in given array","code":"import java . util . * ; class GFG {"}
{"text":"Function to create hash table to check Fibonacci numbers","code":"static void createHash ( HashSet < Integer > hash , int maxElement ) {"}
{"text":"Insert initial two numbers in the hash table","code":"int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) {"}
{"text":"Sum of previous two numbers","code":"int temp = curr + prev ; hash . add ( temp ) ;"}
{"text":"Update the variable each time","code":"prev = curr ; curr = temp ; } }"}
{"text":"Function to find minimum and maximum fibonacci number in given array","code":"static void fibonacci ( int arr [ ] , int n ) {"}
{"text":"Find maximum value in the array","code":"int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;"}
{"text":"Creating a set containing all Fibonacci numbers up to maximum value in the array","code":"HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , max_val ) ;"}
{"text":"For storing the Minimum and Maximum Fibonacci number","code":"int minimum = Integer . MAX_VALUE ; int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Check if current element is a fibonacci number","code":"if ( hash . contains ( arr [ i ] ) ) {"}
{"text":"Update the maximum and minimum accordingly","code":"minimum = Math . min ( minimum , arr [ i ] ) ; maximum = Math . max ( maximum , arr [ i ] ) ; } } System . out . print ( minimum + \" , \u2581 \" + maximum + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fibonacci ( arr , n ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that returns true if there is a subString of length len with <= k unique characters","code":"static boolean isValidLen ( String s , int len , int k ) {"}
{"text":"Size of the String","code":"int n = s . length ( ) ;"}
{"text":"Map to store the characters and their frequency","code":"Map < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; int right = 0 ;"}
{"text":"Update the map for the first subString","code":"while ( right < len ) { if ( mp . containsKey ( s . charAt ( right ) ) ) { mp . put ( s . charAt ( right ) , mp . get ( s . charAt ( right ) ) + 1 ) ; } else { mp . put ( s . charAt ( right ) , 1 ) ; } right ++ ; } if ( mp . size ( ) <= k ) return true ;"}
{"text":"Check for the rest of the subStrings","code":"while ( right < n ) {"}
{"text":"Add the new character","code":"if ( mp . containsKey ( s . charAt ( right ) ) ) { mp . put ( s . charAt ( right ) , mp . get ( s . charAt ( right ) ) + 1 ) ; } else { mp . put ( s . charAt ( right ) , 1 ) ; }"}
{"text":"Remove the first character of the previous window","code":"if ( mp . containsKey ( s . charAt ( right - len ) ) ) { mp . put ( s . charAt ( right - len ) , mp . get ( s . charAt ( right - len ) ) - 1 ) ; }"}
{"text":"Update the map","code":"if ( mp . get ( s . charAt ( right - len ) ) == 0 ) mp . remove ( s . charAt ( right - len ) ) ; if ( mp . size ( ) <= k ) return true ; right ++ ; } return mp . size ( ) <= k ; }"}
{"text":"Function to return the length of the longest subString which has K unique characters","code":"static int maxLenSubStr ( String s , int k ) {"}
{"text":"Check if the complete String contains K unique characters","code":"Set < Character > uni = new HashSet < Character > ( ) ; for ( Character x : s . toCharArray ( ) ) uni . add ( x ) ; if ( uni . size ( ) < k ) return - 1 ;"}
{"text":"Size of the String","code":"int n = s . length ( ) ;"}
{"text":"Apply binary search","code":"int lo = - 1 , hi = n + 1 ; while ( hi - lo > 1 ) { int mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" aabacbebebe \" ; int k = 3 ; System . out . print ( maxLenSubStr ( s , k ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that returns true if it is possible to make a square with side equal to l","code":"static boolean isSquarePossible ( int arr [ ] , int n , int l ) {"}
{"text":"To store the count of elements greater than or equal to l","code":"int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Increment the count","code":"if ( arr [ i ] >= l ) cnt ++ ;"}
{"text":"If the count becomes greater than or equal to l","code":"if ( cnt >= l ) return true ; } return false ; }"}
{"text":"Function to return the maximum area of the square that can be obtained","code":"static int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) \/ 2 ) ;"}
{"text":"If square is possible with side length m","code":"if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; }"}
{"text":"Try to find a square with smaller side length","code":"else r = m - 1 ; }"}
{"text":"Return the area","code":"return ( len * len ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int n = arr . length ; System . out . println ( maxArea ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to insert the names and check whether they appear for the first time","code":"static void insertNames ( String arr [ ] , int n ) {"}
{"text":"To store the names of the employees","code":"HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If current name is appearing for the first time","code":"if ( ! set . contains ( arr [ i ] ) ) { System . out . print ( \"NoNEW_LINE\"); set . add ( arr [ i ] ) ; } else { System . out . print ( \"YesNEW_LINE\"); } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String arr [ ] = { \" geeks \" , \" for \" , \" geeks \" } ; int n = arr . length ; insertNames ( arr , n ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the count of elements in arr [ ] which are less than the given key","code":"static int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ;"}
{"text":"Modified binary search","code":"while ( l <= r ) { int m = ( l + r ) \/ 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; }"}
{"text":"Function to return the count of elements in arr [ ] which are greater than the given key","code":"static int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ;"}
{"text":"Modified binary search","code":"while ( l <= r ) { int m = ( l + r ) \/ 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; }"}
{"text":"Function to return the count of the required triplets","code":"static int countTriplets ( int n , int a [ ] , int b [ ] , int c [ ] ) {"}
{"text":"Sort all three arrays","code":"Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; int count = 0 ;"}
{"text":"Iterate for all the elements of array B","code":"for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ;"}
{"text":"Count of elements in A [ ] which are less than the chosen element from B [ ]","code":"int low = countLessThan ( a , n , current ) ;"}
{"text":"Count of elements in C [ ] which are greater than the chosen element from B [ ]","code":"int high = countGreaterThan ( c , n , current ) ;"}
{"text":"Update the count","code":"count += ( low * high ) ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = a . length ; System . out . println ( countTriplets ( size , a , b , c ) ) ; } }"}
{"text":"Java code to calculate the minimum cost to make the given parentheses balanced","code":"import java . io . * ; class GFG { static int costToBalance ( String s ) { if ( s . length ( ) == 0 ) System . out . println ( 0 ) ;"}
{"text":"To store absolute count of balanced and unbalanced parenthesis","code":"int ans = 0 ;"}
{"text":"o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ' ) '","code":"int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) o ++ ; if ( s . charAt ( i ) == ' ) ' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String s ; s = \" ) ) ) ( ( ( \" ; System . out . println ( costToBalance ( s ) ) ; s = \" ) ) ( ( \" ; System . out . println ( costToBalance ( s ) ) ; } }"}
{"text":"java program to find middle of three distinct numbers","code":"import java . util . * ; class Middle {"}
{"text":"Function to find the middle of three number","code":"public static int middleOfThree ( int a , int b , int c ) {"}
{"text":"x is positive if a is greater than b . x is negative if b is greater than a .","code":"int x = a - b ;"}
{"text":"Similar to x","code":"int y = b - c ;"}
{"text":"Similar to x and y .","code":"int z = a - c ;"}
{"text":"Checking if b is middle ( x and y both are positive )","code":"if ( x * y > 0 ) return b ;"}
{"text":"Checking if c is middle ( x and z both are positive )","code":"else if ( x * z > 0 ) return c ; else return a ; }"}
{"text":"driver code","code":"public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }"}
{"text":"Java program to find missing 4 elements in an array of size N where elements are in range from 1 to N + 4.","code":"class Missing4 {"}
{"text":"Finds missing 4 numbers in O ( N ) time and O ( 1 ) auxiliary space .","code":"public static void missing4 ( int [ ] arr ) {"}
{"text":"To keep track of 4 possible numbers greater than length of input array In Java , helper is automatically initialized as 0.","code":"int [ ] helper = new int [ 4 ] ;"}
{"text":"Traverse the input array and mark visited elements either by marking them as negative in arr [ ] or in helper [ ] .","code":"for ( int i = 0 ; i < arr . length ; i ++ ) { int temp = Math . abs ( arr [ i ] ) ;"}
{"text":"If element is smaller than or equal to length , mark its presence in arr [ ]","code":"if ( temp <= arr . length ) arr [ temp - 1 ] *= ( - 1 ) ;"}
{"text":"Mark presence in helper [ ]","code":"else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } }"}
{"text":"Print all those elements whose presence is not marked .","code":"for ( int i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) System . out . print ( i + 1 + \" \u2581 \" ) ; for ( int i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) System . out . print ( arr . length + i + 1 + \" \u2581 \" ) ; return ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 } ; missing4 ( arr ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function that finds the middle the lexicographical smallest sequence","code":"static void lexiMiddleSmallest ( int K , int N ) {"}
{"text":"If K is even","code":"if ( K % 2 == 0 ) {"}
{"text":"First element is K \/ 2","code":"System . out . print ( K \/ 2 + \" \u2581 \" ) ;"}
{"text":"Remaining elements of the sequence are all integer K","code":"for ( int i = 0 ; i < N - 1 ; ++ i ) { System . out . print ( K + \" \u2581 \" ) ; } System . out . println ( ) ; return ; }"}
{"text":"Stores the sequence when K is odd","code":"ArrayList < Integer > a = new ArrayList < Integer > ( ) ;"}
{"text":"Iterate over the range [ 0 , N \/ 2 ]","code":"for ( int i = 0 ; i < N \/ 2 ; ++ i ) {"}
{"text":"Check if the sequence ends with in 1 or not","code":"if ( a . get ( a . size ( ) - 1 ) == 1 ) {"}
{"text":"Remove the sequence ending in 1","code":"a . remove ( a . size ( ) - 1 ) ; }"}
{"text":"If it doesn 't end in 1","code":"else {"}
{"text":"Decrement by 1","code":"int t = a . get ( a . size ( ) - 1 ) - 1 ; a . set ( a . get ( a . size ( ) - 1 ) , t ) ;"}
{"text":"Insert K to the sequence till its size is N","code":"while ( a . size ( ) < N ) { a . add ( K ) ; } } }"}
{"text":"Print the sequence stored in the vector","code":"for ( int i : a ) { System . out . print ( i + \" \u2581 \" ) ; } System . out . println ( ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0","code":"static void findLastElement ( int arr [ ] , int N ) {"}
{"text":"Sort the given array in ascending order","code":"Arrays . sort ( arr ) ; int i = 0 ;"}
{"text":"Traverse the array","code":"for ( i = 1 ; i < N ; i ++ ) {"}
{"text":"If difference between adjacent elements is not equal to 0 or 2","code":"if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { System . out . println ( \" - 1\" ) ; return ; } }"}
{"text":"If operations can be performed","code":"System . out . println ( arr [ N - 1 ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = arr . length ; findLastElement ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count maximum subsets into which the given array can be split such that it satisfies the given condition","code":"static void maxDivisions ( Integer arr [ ] , int N , int X ) {"}
{"text":"Sort the array in decreasing order","code":"Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;"}
{"text":"Stores count of subsets possible","code":"int maxSub = 0 ;"}
{"text":"Stores count of elements in current subset","code":"int size = 0 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update size","code":"size ++ ;"}
{"text":"If product of the smallest element present in the current subset and size of current subset is >= K","code":"if ( arr [ i ] * size >= X ) {"}
{"text":"Update maxSub","code":"maxSub ++ ;"}
{"text":"Update size","code":"size = 0 ; } } System . out . print ( maxSub + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"Integer arr [ ] = { 1 , 3 , 3 , 7 } ;"}
{"text":"Size of the array","code":"int N = arr . length ;"}
{"text":"Given value of X","code":"int X = 3 ; maxDivisions ( arr , N , X ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find maximum possible sum of second minimums in each quadruple","code":"public static void maxPossibleSum ( int [ ] arr , int N ) {"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) {"}
{"text":"Add the second minimum","code":"sum += arr [ j ] ; j -= 3 ; }"}
{"text":"Print maximum possible sum","code":"System . out . println ( sum ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int [ ] arr = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ;"}
{"text":"Size of the array","code":"int N = arr . length ; maxPossibleSum ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to sort an array using insertion sort","code":"static void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ;"}
{"text":"Move elements of arr [ 0. . i - 1 ] , that are greater than key to one position ahead of their current position","code":"while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }"}
{"text":"Function to print an array of size N","code":"static void printArray ( int arr [ ] , int n ) { int i ;"}
{"text":"Print the array","code":"for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int N = arr . length ;"}
{"text":"Function Call","code":"insertionSort ( arr , N ) ; printArray ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the count required pairs","code":"static void getPairs ( int arr [ ] , int N , int K ) {"}
{"text":"Stores count of pairs","code":"int count = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) {"}
{"text":"Check if the condition is satisfied or not","code":"if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } System . out . print ( count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = arr . length ; int K = 2 ;"}
{"text":"Function Call","code":"getPairs ( arr , N , K ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to merge two sorted arrays","code":"static int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) {"}
{"text":"i : index to left subarray","code":"int i = l ;"}
{"text":"j : index to right subarray","code":"int j = m + 1 ;"}
{"text":"Stores count of pairs that satisfy the given condition","code":"int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { boolean found = false ;"}
{"text":"Traverse to check for the valid conditions","code":"while ( j <= r ) {"}
{"text":"If condition satisfies","code":"if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; }"}
{"text":"All elements in the right side of the left subarray also satisfies","code":"if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } }"}
{"text":"Sort the two given arrays and store in the resultant array","code":"int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; }"}
{"text":"Elements which are left in the left subarray","code":"while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ;"}
{"text":"Elements which are left in the right subarray","code":"while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ;"}
{"text":"Return the count obtained","code":"return cnt ; }"}
{"text":"Function to partition array into two halves","code":"static int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) {"}
{"text":"Same as ( l + r ) \/ 2 , but avoids overflow for large l and h","code":"int m = ( l + r ) \/ 2 ;"}
{"text":"Sort first and second halves","code":"cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ;"}
{"text":"Call the merging function","code":"cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; }"}
{"text":"Function to print the count of required pairs using Merge Sort","code":"static void mergeSort ( int arr [ ] , int N , int K ) { int temp [ ] = new int [ N ] ; System . out . print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = arr . length ; int K = 2 ;"}
{"text":"Function Call","code":"mergeSort ( arr , N , K ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to count minimum consecutive removals of elements of the same type","code":"static void minRemovals ( int [ ] A , int N ) {"}
{"text":"Sort the array","code":"Arrays . sort ( A ) ;"}
{"text":"Stores the maximum element present in the array","code":"int mx = A [ N - 1 ] ;"}
{"text":"Stores sum of the array","code":"int sum = 1 ;"}
{"text":"Calculate sum of the array","code":"for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { System . out . println ( 0 ) ; } else { System . out . println ( 2 * mx - sum ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] A = { 3 , 3 , 2 } ; int N = A . length ;"}
{"text":"Function call","code":"minRemovals ( A , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to rearrange the array a [ ] such that none of the array elements is same as its index","code":"static void rearrangeArray ( int a [ ] , int n ) {"}
{"text":"Sort the array","code":"Arrays . sort ( a ) ;"}
{"text":"Traverse the indices [ 0 , N - 2 ] of the given array","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"Check if the current element is equal to its index","code":"if ( a [ i ] == i + 1 ) {"}
{"text":"If found to be true , swap current element with the next element","code":"int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } }"}
{"text":"Check if the last element is same as its index","code":"if ( a [ n - 1 ] == n ) {"}
{"text":"If found to be true , swap current element with the previous element","code":"int temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; }"}
{"text":"Print the modified array","code":"for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = arr . length ;"}
{"text":"Function Call","code":"rearrangeArray ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . io . * ; import java . lang . Math ; class GFG {"}
{"text":"Function that counts the minimum moves required to covert arr [ ] to brr [ ]","code":"static int minOperations ( int arr1 [ ] , int arr2 [ ] , int i , int j ) {"}
{"text":"Base Case","code":"if ( arr1 . equals ( arr2 ) ) return 0 ; if ( i >= arr1 . length j >= arr2 . length ) return 0 ;"}
{"text":"If arr [ i ] < arr [ j ]","code":"if ( arr1 [ i ] < arr2 [ j ] )"}
{"text":"Include the current element","code":"return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 ) ;"}
{"text":"Otherwise , excluding the current element","code":"return Math . max ( minOperations ( arr1 , arr2 , i , j + 1 ) , minOperations ( arr1 , arr2 , i + 1 , j ) ) ; }"}
{"text":"Function that counts the minimum moves required to sort the array","code":"static void minOperationsUtil ( int [ ] arr ) { int brr [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) brr [ i ] = arr [ i ] ; Arrays . sort ( brr ) ;"}
{"text":"If both the arrays are equal","code":"if ( arr . equals ( brr ) )"}
{"text":"No moves required","code":"System . out . print ( \"0\" ) ;"}
{"text":"Otherwise","code":"else"}
{"text":"Print minimum operations required","code":"System . out . println ( minOperations ( arr , brr , 0 , 0 ) ) ; }"}
{"text":"Driver code","code":"public static void main ( final String [ ] args ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; minOperationsUtil ( arr ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if str1 can be transformed to t by sorting subStrings","code":"static void canTransform ( String s , String t ) { int n = s . length ( ) ;"}
{"text":"Occur [ i ] stores the indices of char ( ' a ' + i ) in String s","code":"Vector < Integer > occur [ ] = new Vector [ 26 ] ; for ( int i = 0 ; i < occur . length ; i ++ ) occur [ i ] = new Vector < Integer > ( ) ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( s . charAt ( x ) - ' a ' ) ; occur [ ch ] . add ( x ) ; }"}
{"text":"idx [ i ] stores the next available index of char ( ' a ' + i ) in occur [ i ]","code":"int [ ] idx = new int [ 26 ] ; boolean poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( t . charAt ( x ) - ' a ' ) ;"}
{"text":"If this char is not available anymore","code":"if ( idx [ ch ] >= occur [ ch ] . size ( ) ) {"}
{"text":"Conversion not possible","code":"poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) {"}
{"text":"If one of the smaller characters is available and occurs before","code":"if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] . get ( idx [ small ] ) < occur [ ch ] . get ( idx [ ch ] ) ) {"}
{"text":"Conversion not possible","code":"poss = false ; break ; } } idx [ ch ] ++ ; }"}
{"text":"Print the answer","code":"if ( poss ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s , t ; s = \" hdecb \" ; t = \" cdheb \" ; canTransform ( s , t ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to count inversion count of the string","code":"static int inversionCount ( String s ) {"}
{"text":"For storing frequency","code":"int [ ] freq = new int [ 26 ] ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ;"}
{"text":"Add all the characters which are less than the ith character before i .","code":"for ( int j = 0 ; j < ( int ) ( s . charAt ( i ) - ' a ' ) ; j ++ )"}
{"text":"Adding the count to inversion count","code":"temp += freq [ j ] ; inv += ( i - temp ) ;"}
{"text":"Updating the character in the frequency array","code":"freq [ s . charAt ( i ) - ' a ' ] ++ ; } return inv ; }"}
{"text":"Function to check whether any of the string have a repeated character","code":"static boolean haveRepeated ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; for ( char i : S1 . toCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; for ( char i : S2 . toCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } return false ; }"}
{"text":"Function to check whether the string S1 and S2 can be made equal by reversing sub strings of same size in both strings","code":"static void checkToMakeEqual ( String S1 , String S2 ) {"}
{"text":"Frequency array to check whether both string have same character or not","code":"int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) {"}
{"text":"Adding the frequency ;","code":"freq [ S1 . charAt ( i ) - ' a ' ] ++ ; } boolean flag = false ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 . charAt ( i ) - ' a ' ] == 0 ) {"}
{"text":"If the character is not in S1","code":"flag = true ; break ; }"}
{"text":"Decrementing the frequency","code":"freq [ S2 . charAt ( i ) - ' a ' ] -- ; } if ( flag == true ) {"}
{"text":"If both string doesnot have same characters or not","code":"System . out . println ( \" No \" ) ; return ; }"}
{"text":"Finding inversion count of both strings","code":"int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) {"}
{"text":"If inversion count is same , or have same parity or if any of the string have a repeated character then the answer is Yes else No","code":"System . out . println ( \" Yes \" ) ; } else System . out . println ( \" No \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S1 = \" abbca \" , S2 = \" acabb \" ; checkToMakeEqual ( S1 , S2 ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to Sort a Bitonic array in constant space","code":"static void sortArr ( int a [ ] , int n ) { int i , k ;"}
{"text":"Initialize the value of k","code":"k = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ; k = ( int ) Math . pow ( 2 , k ) ;"}
{"text":"In each iteration compare elements k distance apart and swap if they are not in order","code":"while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { int tmp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = tmp ; }"}
{"text":"k is reduced to half after every iteration","code":"k = k \/ 2 ; }"}
{"text":"Print the array elements","code":"for ( i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = arr . length ;"}
{"text":"Function call","code":"sortArr ( arr , n ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function that prints the maximum sum possible","code":"static void maximumSum ( int arr [ ] , int n , int k ) {"}
{"text":"Find elements in each group","code":"int elt = n \/ k ; int sum = 0 ;"}
{"text":"Sort all elements in non - descending order","code":"Arrays . sort ( arr ) ; int count = 0 ; int i = n - 1 ;"}
{"text":"Add K largest elements","code":"while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ;"}
{"text":"For sum of minimum elements from each subset","code":"while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; }"}
{"text":"Printing the maximum sum","code":"System . out . println ( sum ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = Arr . length ; maximumSum ( Arr , size , K ) ; } }"}
{"text":"Java program to find the minimum possible sum of the smallest elements from K subsequences","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to find the minimum sum","code":"static int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ;"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"Calculate sum of smallest K elements","code":"for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ;"}
{"text":"Return the sum","code":"return minsum ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = arr . length ; System . out . print ( findMinSum ( arr , K , L , length ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the Kth smallest element in Unsorted Array","code":"static int findKthSmallest ( int [ ] arr , int n , int k ) {"}
{"text":"Initialize the max Element as 0","code":"int max = 0 ;"}
{"text":"Iterate arr [ ] and find the maximum element in it","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; }"}
{"text":"Frequency array to store the frequencies","code":"int [ ] counter = new int [ max + 1 ] ;"}
{"text":"Counter variable","code":"int smallest = 0 ;"}
{"text":"Counting the frequencies","code":"for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; }"}
{"text":"Iterate through the freq [ ]","code":"for ( int num = 1 ; num <= max ; num ++ ) {"}
{"text":"Check if num is present in the array","code":"if ( counter [ num ] > 0 ) {"}
{"text":"Increment the counter with the frequency of num","code":"smallest += counter [ num ] ; }"}
{"text":"Checking if we have reached the Kth smallest element","code":"if ( smallest >= k ) {"}
{"text":"Return the Kth smallest element","code":"return num ; } } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int [ ] arr = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = arr . length ; int K = 5 ;"}
{"text":"Function call","code":"System . out . print ( findKthSmallest ( arr , N , K ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to print all the numbers up to n in lexicographical order","code":"static void lexNumbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( String . valueOf ( i ) ) ; } Collections . sort ( s ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( Integer . valueOf ( s . get ( i ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + \" \u2581 \" ) ; }"}
{"text":"Driver Program","code":"public static void main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }"}
{"text":"Java implementation to print row of matrix in ascending or descending order alternatively","code":"class GFG { static int N = 4 ; static void func ( int a [ ] [ ] ) { int i , j , k ;"}
{"text":"Iterate matrix rowwise","code":"for ( i = 0 ; i < N ; i ++ ) {"}
{"text":"Sort even rows in ascending order","code":"if ( i % 2 == 0 ) { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) {"}
{"text":"Compare adjacent elements","code":"if ( a [ i ] [ j ] > a [ i ] [ k ] ) {"}
{"text":"Swap adjacent element","code":"int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } }"}
{"text":"Sort even rows in descending order","code":"else { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) {"}
{"text":"Compare adjacent elements","code":"if ( a [ i ] [ j ] < a [ i ] [ k ] ) {"}
{"text":"Swap adjacent element","code":"int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } }"}
{"text":"Printing the final Output","code":"for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { System . out . print ( a [ i ] [ j ] + \" \u2581 \" ) ; } System . out . print ( \"NEW_LINE\"); } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] [ ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; } }"}
{"text":"Java Program to find weight of minimum spanning tree in a complete graph where edges have weight either 0 or 1","code":"import java . util . * ; class GFG {"}
{"text":"To store the edges of the given graph","code":"static HashMap < Integer , Integer > [ ] g = new HashMap [ 200005 ] ; static HashSet < Integer > s = new HashSet < > ( ) ; static HashSet < Integer > ns = new HashSet < > ( ) ;"}
{"text":"A utility function to perform DFS Traversal","code":"static void dfs ( int x ) { Vector < Integer > v = new Vector < > ( ) ; v . clear ( ) ; ns . clear ( ) ;"}
{"text":"Check those vertices which are stored in the set","code":"for ( int it : s ) {"}
{"text":"Vertices are included if the weight of edge is 0","code":"if ( g [ x ] . get ( it ) != null ) { v . add ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } }"}
{"text":"A utility function to find the weight of Minimum Spanning Tree","code":"static void weightOfMST ( int N ) {"}
{"text":"To count the connected components","code":"int cnt = 0 ;"}
{"text":"Inserting the initial vertices in the set","code":"for ( int i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } Vector < Integer > qt = new Vector < > ( ) ; for ( int t : s ) qt . add ( t ) ;"}
{"text":"Traversing vertices stored in the set and Run DFS Traversal for each vertices","code":"while ( ! qt . isEmpty ( ) ) {"}
{"text":"Incrementing the zero weight connected components","code":"++ cnt ; int t = qt . get ( 0 ) ; qt . remove ( 0 ) ;"}
{"text":"DFS Traversal for every vertex remove","code":"dfs ( t ) ; } System . out . print ( cnt - 4 ) ; }"}
{"text":"Driver 's Code","code":"public static void main ( String [ ] args ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Insert edges","code":"for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] . put ( v , 1 ) ; g [ v ] . put ( u , 1 ) ; }"}
{"text":"Function call find the weight of Minimum Spanning Tree","code":"weightOfMST ( N ) ; } }"}
{"text":"Java program to count number of distinct pairs possible from the two arrays such that element selected from one array is always greater than the one selected from the other array","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the count of pairs","code":"static int countPairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] A = { 30 , 28 , 45 , 22 } ; int [ ] B = { 35 , 25 , 22 , 48 } ; System . out . print ( countPairs ( A , B ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int max_element ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; }"}
{"text":"Function to return the maximum mod value for any pair from the array","code":"static int maxMod ( int arr [ ] , int n ) { int maxVal = max_element ( arr , n ) ; int secondMax = 0 ;"}
{"text":"Find the second maximum element from the array","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = arr . length ; System . out . println ( maxMod ( arr , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to that returns true if it possible to choose the elements","code":"static boolean isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) {"}
{"text":"If elements can 't be chosen","code":"if ( x > n y > m ) return false ;"}
{"text":"Sort both the arrays","code":"Arrays . sort ( A ) ; Arrays . sort ( B ) ;"}
{"text":"If xth smallest element of A [ ] is smaller than the yth greatest element of B [ ]","code":"if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = A . length ; int m = B . length ; ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"C # program to minimum changes required in an array for k distinct elements .","code":"import java . util . * ; class GFG { static int MAX = 100005 ;"}
{"text":"Function to minimum changes required in an array for k distinct elements .","code":"static int Min_Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ;"}
{"text":"Store the frequency of each element","code":"Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ;"}
{"text":"Store the frequency of elements","code":"for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; }"}
{"text":"Sort frequencies in descending order","code":"Arrays . sort ( freq , Collections . reverseOrder ( ) ) ;"}
{"text":"To store the required answer","code":"int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ;"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = arr . length ; int k = 2 ; System . out . println ( Min_Replace ( arr , n , k ) ) ; } }"}
{"text":"Java program to find maximum number of elements without overlapping in a line","code":"import java . util . * ; class GFG {"}
{"text":"Function to find maximum number of elements without overlapping in a line","code":"static int Segment ( int x [ ] , int l [ ] , int n ) {"}
{"text":"If n = 1 , then answer is one","code":"if ( n == 1 ) return 1 ;"}
{"text":"We can always make 1 st element to cover left segment and nth the right segment","code":"int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) {"}
{"text":"If left segment for ith element doesn 't overlap with i - 1 th  element then do left","code":"if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ;"}
{"text":"else try towards right if possible","code":"else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) {"}
{"text":"update x [ i ] to right endpoint of segment covered by it","code":"x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } }"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = x . length ;"}
{"text":"Function call","code":"System . out . println ( Segment ( x , l , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimized sum","code":"static int MinimizeleftOverSum ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . add ( a [ i ] ) ; else v2 . add ( a [ i ] ) ; }"}
{"text":"If more odd elements","code":"if ( v1 . size ( ) > v2 . size ( ) ) {"}
{"text":"Sort the elements","code":"Collections . sort ( v1 ) ; Collections . sort ( v2 ) ;"}
{"text":"Left - over elements","code":"int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ;"}
{"text":"Find the sum of leftover elements","code":"while ( i < x ) { sum += v1 . get ( i ++ ) ; }"}
{"text":"Return the sum","code":"return sum ; }"}
{"text":"If more even elements","code":"else if ( v2 . size ( ) > v1 . size ( ) ) {"}
{"text":"Sort the elements","code":"Collections . sort ( v1 ) ; Collections . sort ( v2 ) ;"}
{"text":"Left - over elements","code":"int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ;"}
{"text":"Find the sum of leftover elements","code":"while ( i < x ) { sum += v2 . get ( i ++ ) ; }"}
{"text":"Return the sum","code":"return sum ; }"}
{"text":"If same elements","code":"else return 0 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = a . length ; System . out . println ( MinimizeleftOverSum ( a , n ) ) ; } }"}
{"text":"JAVA program to convert the given string","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum number of operations to convert the given string","code":"static void minOperation ( String S , int N , int K ) {"}
{"text":"Check if N is divisible by K","code":"if ( N % K != 0 ) { System . out . println ( \" Not \u2581 Possible \" ) ; } else {"}
{"text":"Array to store frequency of characters in given string","code":"int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ ( S . charAt ( i ) - 97 ) ] ++ ; } int E = N \/ K ; Vector < Integer > greaterE = new Vector < > ( ) ; Vector < Integer > lessE = new Vector < > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) {"}
{"text":"Two arrays with number of operations required","code":"if ( count [ i ] < E ) lessE . add ( E - count [ i ] ) ; else greaterE . add ( count [ i ] - E ) ; } Collections . sort ( greaterE ) ; Collections . sort ( lessE ) ; int mi = Integer . MAX_VALUE ; for ( int i = 0 ; i <= K ; i ++ ) {"}
{"text":"Checking for all possibility","code":"int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE . get ( j ) ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE . get ( j ) ; mi = Math . min ( mi , Math . max ( step1 , step2 ) ) ; } } System . out . println ( mi ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" accb \" ; int N = S . length ( ) ; int K = 2 ; minOperation ( S , N , K ) ; } }"}
{"text":"Java program to find minimum range increments to sort an array","code":"import java . io . * ; class GFG {"}
{"text":"Function to find minimum range increments to sort an array","code":"static int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) {"}
{"text":"If current element is found greater than last element Increment all terms in range i + 1 to n - 1","code":"if ( arr [ i ] > mn ) moves += arr [ i ] - mn ;"}
{"text":"mn = arr [ i ] ; Minimum in range i to n - 1","code":"} return moves ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = arr . length ; System . out . println ( minMovesToSort ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static boolean prime [ ] = new boolean [ 100005 ] ; static void SieveOfEratosthenes ( int n ) { Arrays . fill ( prime , true ) ;"}
{"text":"false here indicates that it is not prime","code":"prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p , set them to non - prime","code":"for ( int i = p * 2 ; i < n ; i += p ) { prime [ i ] = false ; } } } }"}
{"text":"Function that sorts all the prime numbers from the array in descending","code":"static void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ;"}
{"text":"this vector will contain prime numbers to sort","code":"Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"if the element is prime","code":"if ( prime [ arr [ i ] ] ) { v . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( v , comparator ) ; int j = 0 ;"}
{"text":"update the array elements","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { arr [ i ] = v . get ( j ++ ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 2 , 6 , 100 , 17 } ; int n = arr . length ; sortPrimes ( arr , n ) ;"}
{"text":"print the results .","code":"for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } }"}
{"text":"Java Program to divide the array into N pairs such that maximum pair is minimized","code":"import java . io . * ; import java . util . Arrays ; class GFG { static void findOptimalPairs ( int arr [ ] , int N ) { Arrays . sort ( arr ) ;"}
{"text":"After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element","code":"for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) System . out . print ( \" ( \" + arr [ i ] + \" , \u2581 \" + arr [ j ] + \" ) \" + \" \u2581 \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = arr . length ; findOptimalPairs ( arr , N ) ; } }"}
{"text":"Java program to implement simple approach to sort an array according to count of set bits .","code":"import java . io . * ; class GFG {"}
{"text":"a utility function that returns total set bits count in an integer","code":"static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }"}
{"text":"Function to simultaneously sort both arrays using insertion sort ( https : www . geeksforgeeks . org \/ insertion - sort \/ )","code":"static void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"use 2 keys because we need to sort both arrays simultaneously","code":"int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ;"}
{"text":"Move elements of arr [ 0. . i - 1 ] and aux [ 0. . i - 1 ] , such that elements of aux [ 0. . i - 1 ] are greater than key1 , to one position ahead of their current position","code":"while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } }"}
{"text":"Function to sort according to bit count using an auxiliary array","code":"static void sortBySetBitCount ( int arr [ ] , int n ) {"}
{"text":"Create an array and store count of set bits in it .","code":"int aux [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ;"}
{"text":"Sort arr [ ] according to values in aux [ ]","code":"insertionSort ( arr , aux , n ) ; }"}
{"text":"Utility function to print an array","code":"static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }"}
{"text":"Java program to sort an array according to count of set bits using std :: sort ( )","code":"import java . util . * ; class GFG {"}
{"text":"a utility function that returns total set bits count in an integer","code":"static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }"}
{"text":"Function to sort according to bit count . This function assumes that there are 32 bits in an integer .","code":"static void sortBySetBitCount ( int arr [ ] , int n ) { Vector < Integer > [ ] count = new Vector [ 32 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = new Vector < Integer > ( ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . add ( arr [ i ] ) ; }"}
{"text":"Used as an index in final sorted array","code":"int j = 0 ;"}
{"text":"Traverse through all bit counts ( Note that we sort array in decreasing order )","code":"for ( int i = 31 ; i >= 0 ; i -- ) { Vector < Integer > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . size ( ) ; p ++ ) arr [ j ++ ] = v1 . get ( p ) ; } }"}
{"text":"Utility function to print an array","code":"static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find lexicographically smallest String having number of 1 s greater than number of 0 s","code":"static void generateString ( int k1 , int k2 , char [ ] s ) {"}
{"text":"C1s And C0s stores the count of 1 s and 0 s at every position","code":"int C1s = 0 , C0s = 0 ; int flag = 0 ; Vector < Integer > pos = new Vector < Integer > ( ) ;"}
{"text":"Traverse the String S","code":"for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ;"}
{"text":"If the position is not divisible by k1 and k2","code":"if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . add ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) {"}
{"text":"If C0s >= C1s and pos [ ] is empty then the String can 't  be formed","code":"if ( pos . size ( ) == 0 ) { System . out . print ( - 1 ) ; flag = 1 ; break ; }"}
{"text":"If pos [ ] is not empty then flip the bit of last position present in pos [ ]","code":"else { int k = pos . get ( pos . size ( ) - 1 ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . remove ( pos . size ( ) - 1 ) ; } } }"}
{"text":"Print the result","code":"if ( flag == 0 ) { System . out . print ( s ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int K1 = 2 , K2 = 4 ; String S = \"11000100\" ; generateString ( K1 , K2 , S . toCharArray ( ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the pair ( X , Y ) such that X xor Y = N and the count of set bits in X and Y is less than count of set bit in N","code":"static void maximizeProduct ( int N ) {"}
{"text":"Stores MSB ( Most Significant Bit )","code":"int MSB = ( int ) ( Math . log ( N ) \/ Math . log ( 2 ) ) ;"}
{"text":"Stores the value of X","code":"int X = 1 << MSB ;"}
{"text":"Stores the value of Y","code":"int Y = N - ( 1 << MSB ) ;"}
{"text":"Traversing over all bits of N","code":"for ( int i = 0 ; i < MSB ; i ++ ) {"}
{"text":"If ith bit of N is 0","code":"if ( ( N & ( 1 << i ) ) == 0 ) {"}
{"text":"Set ith bit of X to 1","code":"X += 1 << i ;"}
{"text":"Set ith bit of Y to 1","code":"Y += 1 << i ; } }"}
{"text":"Print Answer","code":"System . out . println ( X + \" \u2581 \" + Y ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 45 ; maximizeProduct ( N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if the number is valid","code":"static boolean check ( int num ) {"}
{"text":"Sum of digits of num","code":"int sm = 0 ;"}
{"text":"Squared number","code":"int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num \/= 10 ; }"}
{"text":"Sum of digits of ( num * num )","code":"int sm2 = 0 ; while ( num2 > 0 ) { sm2 += num2 % 10 ; num2 \/= 10 ; } return ( ( sm * sm ) == sm2 ) ; }"}
{"text":"Function to convert a String to an integer","code":"static int convert ( String s ) { int val = 0 ; s = reverse ( s ) ; int cur = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { val += ( s . charAt ( i ) - '0' ) * cur ; cur *= 10 ; } return val ; }"}
{"text":"Function to generate all possible Strings of length len","code":"static void generate ( String s , int len , HashSet < Integer > uniq ) {"}
{"text":"Desired String","code":"if ( s . length ( ) == len ) {"}
{"text":"Take only valid numbers","code":"if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; }"}
{"text":"Recurse for all possible digits","code":"for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + ( char ) ( i + '0' ) , len , uniq ) ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; }"}
{"text":"Function to calculate unique numbers in range [ L , R ]","code":"static int totalNumbers ( int L , int R ) {"}
{"text":"Initialize a variable to store the answer","code":"int ans = 0 ;"}
{"text":"Calculate the maximum possible length","code":"int max_len = ( int ) ( Math . log10 ( R ) + 1 ) ;"}
{"text":"Set to store distinct valid numbers","code":"HashSet < Integer > uniq = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) {"}
{"text":"Generate all possible Strings of length i","code":"generate ( \" \" , i , uniq ) ; }"}
{"text":"Iterate the set to get the count of valid numbers in the range [ L , R ]","code":"for ( int x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int L = 22 , R = 22 ; System . out . print ( totalNumbers ( L , R ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end","code":"static void convertXintoY ( int X , int Y ) {"}
{"text":"Iterate until Y is at least X","code":"while ( Y > X ) {"}
{"text":"If Y is even","code":"if ( Y % 2 == 0 ) Y \/= 2 ;"}
{"text":"If the last digit of Y is 1","code":"else if ( Y % 10 == 1 ) Y \/= 10 ;"}
{"text":"Otherwise","code":"else break ; }"}
{"text":"Check if X is equal to Y","code":"if ( X == Y ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings","code":"static void generateString ( int K ) {"}
{"text":"Stores the resultant string","code":"String s = \" \" ;"}
{"text":"Iterate through all the characters","code":"for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ;"}
{"text":"Inner Loop for making pairs and adding them into string","code":"for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } }"}
{"text":"Adding first character so that substring consisting of the last the first alphabet is present","code":"s += ( char ) ( 97 ) ;"}
{"text":"Print the resultant string","code":"System . out . println ( s ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int K = 4 ; generateString ( K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the quadratic equation from the given sum and products of roots","code":"public static void findEquation ( int S , int M ) {"}
{"text":"Print the coefficients","code":"System . out . println ( \"1 \u2581 \" + ( ( - 1 ) * S ) + \" \u2581 \" + M ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the minimum number of pairs of adjacent elements required to be replaced by their sum to make all array elements equal","code":"static int minSteps ( ArrayList < Integer > a , int n ) {"}
{"text":"Stores the prefix sum of the array","code":"int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a . get ( 0 ) ;"}
{"text":"Calculate the prefix sum array","code":"for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a . get ( i ) ;"}
{"text":"Stores the maximum number of subarrays into which the array can be split","code":"int mx = - 1 ;"}
{"text":"Iterate over all possible sums","code":"for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ;"}
{"text":"Traverse the array","code":"while ( i < n ) { sum += a . get ( i ) ;"}
{"text":"If the sum is equal to the current prefix sum","code":"if ( sum == subgroupsum ) {"}
{"text":"Increment count of groups by 1","code":"grp_count += 1 ; sum = 0 ; }"}
{"text":"Otherwise discard this subgroup sum","code":"else if ( sum > subgroupsum ) { grp_count = - 1 ; break ; } i += 1 ; }"}
{"text":"Update the maximum this of subarrays","code":"if ( grp_count > mx ) mx = grp_count ; }"}
{"text":"Return the minimum number of operations","code":"return n - mx ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; A . add ( 1 ) ; A . add ( 2 ) ; A . add ( 3 ) ; A . add ( 2 ) ; A . add ( 1 ) ; A . add ( 3 ) ; int N = A . size ( ) ;"}
{"text":"Function Call","code":"System . out . print ( minSteps ( A , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the most frequent character after replacing X with either '0' or '1' according as per the given conditions","code":"public static void maxOccuringCharacter ( String s ) {"}
{"text":"Store the count of 0 s and 1 s in the string S","code":"int count0 = 0 , count1 = 0 ;"}
{"text":"Count the frequency of 0 and 1","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"If the character is 1","code":"if ( s . charAt ( i ) == '1' ) { count1 ++ ; }"}
{"text":"If the character is 0","code":"else if ( s . charAt ( i ) == '0' ) { count0 ++ ; } }"}
{"text":"Stores first occurence of 1","code":"int prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { prev = i ; break ; } }"}
{"text":"Traverse the string to count the number of X between two consecutive 1 s","code":"for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) {"}
{"text":"If the current character is not X","code":"if ( s . charAt ( i ) != ' X ' ) {"}
{"text":"If the current character is 1 , add the number of Xs to count1 and set prev to i","code":"if ( s . charAt ( i ) == '1' ) { count1 += i - prev - 1 ; prev = i ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"Find next occurence of 1 in the string","code":"boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '1' ) { flag = false ; prev = j ; break ; } }"}
{"text":"If it is found , set i to prev","code":"if ( ! flag ) { i = prev ; }"}
{"text":"Otherwise , break out of the loop","code":"else { i = s . length ( ) ; } } } }"}
{"text":"Store the first occurence of 0","code":"prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { prev = i ; break ; } }"}
{"text":"Repeat the same procedure to count the number of X between two consecutive 0 s","code":"for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) {"}
{"text":"If the current character is not X","code":"if ( s . charAt ( i ) != ' X ' ) {"}
{"text":"If the current character is 0","code":"if ( s . charAt ( i ) == '0' ) {"}
{"text":"Add the count of Xs to count0","code":"count0 += i - prev - 1 ;"}
{"text":"Set prev to i","code":"prev = i ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"Find the next occurence of 0 in the string","code":"boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '0' ) { prev = j ; flag = false ; break ; } }"}
{"text":"If it is found , set i to prev","code":"if ( ! flag ) { i = prev ; }"}
{"text":"Otherwise , break out of the loop","code":"else { i = s . length ( ) ; } } } }"}
{"text":"Count number of X present in the starting of the string as XXXX1 ...","code":"if ( s . charAt ( 0 ) == ' X ' ) {"}
{"text":"Store the count of X","code":"int count = 0 ; int i = 0 ; while ( s . charAt ( i ) == ' X ' ) { count ++ ; i ++ ; }"}
{"text":"Increment count1 by count if the condition is satisfied","code":"if ( s . charAt ( i ) == '1' ) { count1 += count ; } }"}
{"text":"Count the number of X present in the ending of the string as ... XXXX0","code":"if ( s . charAt ( s . length ( ) - 1 ) == ' X ' ) {"}
{"text":"Store the count of X","code":"int count = 0 ; int i = s . length ( ) - 1 ; while ( s . charAt ( i ) == ' X ' ) { count ++ ; i -- ; }"}
{"text":"Increment count0 by count if the condition is satisfied","code":"if ( s . charAt ( i ) == '0' ) { count0 += count ; } }"}
{"text":"If count of 1 is equal to count of 0 , print X","code":"if ( count0 == count1 ) { System . out . println ( \" X \" ) ; }"}
{"text":"Otherwise , if count of 1 is greater than count of 0","code":"else if ( count0 > count1 ) { System . out . println ( 0 ) ; }"}
{"text":"Otherwise , print 0","code":"else System . out . println ( 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" XX10XX10XXX1XX \" ; maxOccuringCharacter ( S ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the maximum number of sheets possible by given operations","code":"static int maxSheets ( int A , int B ) { int area = A * B ;"}
{"text":"Initial count of sheets","code":"int count = 1 ;"}
{"text":"Keep dividing the sheets into half","code":"while ( area % 2 == 0 ) {"}
{"text":"Reduce area by half","code":"area \/= 2 ;"}
{"text":"Increase count by twice","code":"count *= 2 ; } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int A = 5 , B = 10 ; System . out . println ( maxSheets ( A , B ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum moves required to reach origin from ( a , b )","code":"static void findMinMoves ( int a , int b ) {"}
{"text":"Stores the minimum number of moves","code":"int ans = 0 ;"}
{"text":"Check if the absolute difference is 1 or 0","code":"if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else {"}
{"text":"Store the minimum of a , b","code":"int k = Math . min ( a , b ) ;"}
{"text":"Store the maximum of a , b","code":"int j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; }"}
{"text":"Print the answer","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given co - ordinates","code":"int a = 3 , b = 5 ;"}
{"text":"Function Call","code":"findMinMoves ( a , b ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to count maximum even sum pairs in the given range","code":"static long cntEvenSumPairs ( long X , long Y ) {"}
{"text":"Stores the count of even numbers between 1 to X","code":"long cntXEvenNums = X \/ 2 ;"}
{"text":"Stores the count of odd numbers between 1 to X","code":"long cntXOddNums = ( X + 1 ) \/ 2 ;"}
{"text":"Stores the count of even numbers between 1 to Y","code":"long cntYEvenNums = Y \/ 2 ;"}
{"text":"Stores the count of odd numbers between 1 to Y","code":"long cntYOddNums = ( Y + 1 ) \/ 2 ;"}
{"text":"Stores the count of pairs having even sum","code":"long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ;"}
{"text":"Retuens the count of pairs having even sum","code":"return cntPairs ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { long X = 2 ; long Y = 3 ; System . out . println ( cntEvenSumPairs ( X , Y ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate minimum number of moves to make the sequence a Fibonacci series","code":"static int minMoves ( int [ ] arr ) { int N = arr . length ;"}
{"text":"If number of elements is less than 3","code":"if ( N <= 2 ) return 0 ;"}
{"text":"Initialize the value of the result","code":"int ans = Integer . MAX_VALUE ;"}
{"text":"Try all permutations of the first two elements","code":"for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) {"}
{"text":"Value of first element after operation","code":"int num1 = arr [ 0 ] + i ;"}
{"text":"Value of second element after operation","code":"int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ;"}
{"text":"Calculate number of moves for rest of the elements of the array","code":"for ( int idx = 2 ; idx < N ; idx ++ ) {"}
{"text":"Element at idx index","code":"int num = num1 + num2 ;"}
{"text":"If it is not possible to change the element in atmost one move","code":"if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ;"}
{"text":"Otherwise","code":"else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; }"}
{"text":"Update the answer","code":"if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } }"}
{"text":"Return the answer","code":"if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 9 , 17 , 27 } ; System . out . print ( minMoves ( arr ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries","code":"static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) {"}
{"text":"Iterate over each query","code":"for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ;"}
{"text":"Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ...","code":"int sum = 0 ;"}
{"text":"Traverse the array and calculate the sum of the expression","code":"while ( x < N ) {"}
{"text":"Update sum","code":"sum += arr [ x ] ;"}
{"text":"Update x","code":"x += y ; } System . out . print ( sum + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values","code":"static int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int X = 5 , Y = 2 ; System . out . print ( findBitwiseORGivenXORAND ( X , Y ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class solution {"}
{"text":"Function to return GCD of two numbers a and b","code":"static int GCD ( int a , int b ) {"}
{"text":"Base Case","code":"if ( b == 0 ) return a ;"}
{"text":"Recursively Find the GCD","code":"return GCD ( b , a % b ) ; }"}
{"text":"Function to check of B can be reaced from A with a jump of K elements in the circular queue","code":"static void canReach ( int N , int A , int B , int K ) {"}
{"text":"Find GCD of N and K","code":"int gcd = GCD ( N , K ) ;"}
{"text":"If A - B is divisible by gcd then print Yes","code":"if ( Math . abs ( A - B ) % gcd == 0 ) { System . out . println ( \" Yes \" ) ; }"}
{"text":"Otherwise","code":"else { System . out . println ( \" No \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int N = 5 , A = 2 , B = 1 , K = 2 ;"}
{"text":"Function Call","code":"canReach ( N , A , B , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that counts the subarrays with sum of its elements as its length","code":"static void countOfSubarray ( int arr [ ] , int N ) {"}
{"text":"Store count of elements upto current element with length i","code":"Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Stores the final count of subarray","code":"int answer = 0 ;"}
{"text":"Stores the prefix sum","code":"int sum = 0 ;"}
{"text":"If size of subarray is 1","code":"if ( mp . get ( 1 ) != null ) mp . put ( 1 , mp . get ( 1 ) + 1 ) ; else mp . put ( 1 , 1 ) ;"}
{"text":"Iterate the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Find the sum","code":"sum += arr [ i ] ; if ( mp . get ( sum - i ) != null ) answer += mp . get ( sum - i ) ;"}
{"text":"Update frequency in map","code":"if ( mp . get ( sum - i ) != null ) mp . put ( sum - i , mp . get ( sum - i ) + 1 ) ; else mp . put ( sum - i , 1 ) ; }"}
{"text":"Print the total count","code":"System . out . print ( answer ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 } ;"}
{"text":"Size of array","code":"int N = arr . length ;"}
{"text":"Function Call","code":"countOfSubarray ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to split the first N natural numbers into two sets having minimum absolute difference of their sums","code":"static int minAbsDiff ( int N ) {"}
{"text":"Stores the sum of elements of set1","code":"int sumSet1 = 0 ;"}
{"text":"Stores the sum of elements of set2","code":"int sumSet2 = 0 ;"}
{"text":"Traverse first N natural numbers","code":"for ( int i = N ; i > 0 ; i -- ) {"}
{"text":"Check if sum of elements of set1 is less than or equal to sum of elements of set2","code":"if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( minAbsDiff ( N ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if N contains digits 0 , 1 , 2 , 5 , 8 only","code":"static boolean checkDigits ( int n ) {"}
{"text":"Extract digits of N","code":"do { int r = n % 10 ;"}
{"text":"Return false if any of these digits are present","code":"if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n \/= 10 ; } while ( n != 0 ) ; return true ; }"}
{"text":"Function to check if N is prime or not","code":"static boolean isPrime ( int n ) { if ( n <= 1 ) return false ;"}
{"text":"Check for all factors","code":"for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }"}
{"text":"Function to check if n is prime in all the desired forms","code":"static boolean isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 101 ; if ( isAllPrime ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the minimum cost required to generate a balanced bracket sequence","code":"static void minCost ( String str , int a , int b ) {"}
{"text":"Stores the count of unbalanced open brackets","code":"int openUnbalanced = 0 ;"}
{"text":"Stores the count of unbalanced closed brackets","code":"int closedUnbalanced = 0 ;"}
{"text":"Stores the count of open brackets","code":"int openCount = 0 ;"}
{"text":"Stores the count of closed brackets","code":"int closedCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"If open brace is encountered","code":"if ( str . charAt ( i ) == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"If no unbalanced open brackets are present","code":"if ( openUnbalanced == 0 )"}
{"text":"Increase count of unbalanced closed brackets","code":"closedUnbalanced ++ ;"}
{"text":"Otherwise","code":"else"}
{"text":"Reduce count of unbalanced open brackets","code":"openUnbalanced -- ;"}
{"text":"Increase count of closed brackets","code":"closedCount ++ ; } }"}
{"text":"Calculate lower bound of minimum cost","code":"int result = a * ( Math . abs ( openCount - closedCount ) ) ;"}
{"text":"Reduce excess open or closed brackets to prevent counting them twice","code":"if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ;"}
{"text":"Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of String","code":"result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ;"}
{"text":"Print the result","code":"System . out . print ( result + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" ) ) ( ) ( ( ) ( ) ( \" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the number of all permutations such that sum of K numbers in range is even","code":"public static void countEvenSum ( int low , int high , int k ) {"}
{"text":"Find total count of even and odd number in given range","code":"int even_count = high \/ 2 - ( low - 1 ) \/ 2 ; int odd_count = ( high + 1 ) \/ 2 - low \/ 2 ; long even_sum = 1 ; long odd_sum = 0 ;"}
{"text":"Iterate loop k times and update even_sum & odd_sum using previous values","code":"for ( int i = 0 ; i < k ; i ++ ) {"}
{"text":"Update the prev_even and odd_sum","code":"long prev_even = even_sum ; long prev_odd = odd_sum ;"}
{"text":"Even sum","code":"even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ;"}
{"text":"Odd sum","code":"odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; }"}
{"text":"Return even_sum","code":"System . out . println ( even_sum ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given ranges","code":"int low = 4 ; int high = 5 ;"}
{"text":"Length of permutation","code":"int K = 3 ;"}
{"text":"Function call","code":"countEvenSum ( low , high , K ) ; } }"}
{"text":"Java Program to implement the above approach","code":"class GFG {"}
{"text":"Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal","code":"public static void count ( int n , int k ) { long count = ( long ) ( Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ) ;"}
{"text":"Print the answer","code":"System . out . print ( count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 2 , k = 1 ; count ( n , k ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the sum of largest divisors of numbers in range 1 to N not divisible by prime number P","code":"static int func ( int N , int P ) {"}
{"text":"Total sum upto N","code":"int sumUptoN = ( N * ( N + 1 ) \/ 2 ) ; int sumOfMultiplesOfP ;"}
{"text":"If no multiple of P exist up to N","code":"if ( N < P ) { return sumUptoN ; }"}
{"text":"If only P itself is in the range from 1 to N","code":"else if ( ( N \/ P ) == 1 ) { return sumUptoN - P + 1 ; }"}
{"text":"Sum of those that are divisible by P","code":"sumOfMultiplesOfP = ( ( N \/ P ) * ( 2 * P + ( N \/ P - 1 ) * P ) ) \/ 2 ;"}
{"text":"Recursively function call to find the sum for N \/ P","code":"return ( sumUptoN + func ( N \/ P , P ) - sumOfMultiplesOfP ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N and P","code":"int N = 10 , P = 5 ;"}
{"text":"Function call","code":"System . out . println ( func ( N , P ) ) ; } }"}
{"text":"Java program to implement the approach","code":"class GFG {"}
{"text":"Function to find the right shifts required for each element to reach its sorted array position in A [ ]","code":"public static void findShifts ( int [ ] A , int N ) {"}
{"text":"Stores required number of shifts for each element","code":"int [ ] shift = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If the element is at sorted position","code":"if ( i == A [ i ] - 1 ) shift [ i ] = 0 ;"}
{"text":"Otherwise","code":"else"}
{"text":"Calculate right shift","code":"shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; }"}
{"text":"Print the respective shifts","code":"for ( int i = 0 ; i < N ; i ++ ) System . out . print ( shift [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = arr . length ; findShifts ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"public class Main {"}
{"text":"Function to construct matrix with diagonal sum equal to matrix sum","code":"public static void constructmatrix ( int N ) { boolean check = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {"}
{"text":"If diagonal position","code":"if ( i == j ) { System . out . print ( \"1 \u2581 \" ) ; } else if ( check ) {"}
{"text":"Positive element","code":"System . out . print ( \"2 \u2581 \" ) ; check = false ; } else {"}
{"text":"Negative element","code":"System . out . print ( \" - 2 \u2581 \" ) ; check = true ; } } System . out . println ( ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 5 ; constructmatrix ( 5 ) ; } }"}
{"text":"Java Program to implement the above approach","code":"class GFG {"}
{"text":"Function to calculate and return the minimum number of times a number with unit digit X needs to be added to get a sum N","code":"static int check ( int unit_digit , int X ) { int times , digit ;"}
{"text":"Calculate the number of additions required to get unit digit of N","code":"for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; }"}
{"text":"If unit digit of N cannot be obtained","code":"return - 1 ; }"}
{"text":"Function to return the minimum number required to represent N","code":"static int getNum ( int N , int X ) { int unit_digit ;"}
{"text":"Stores unit digit of N","code":"unit_digit = N % 10 ;"}
{"text":"Stores minimum addition of X required to obtain unit digit of N","code":"int times = check ( unit_digit , X ) ;"}
{"text":"If unit digit of N cannot be obtained","code":"if ( times == - 1 ) return times ;"}
{"text":"Otherwise","code":"else {"}
{"text":"If N is greater than or equal to ( X * times )","code":"if ( N >= ( times * X ) )"}
{"text":"Minimum count of numbers that needed to represent N","code":"return times ;"}
{"text":"Representation not possible","code":"else return - 1 ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 58 , X = 7 ; System . out . println ( getNum ( N , X ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the minimum number of Points required to cover a grid","code":"static int minPoints ( int n , int m ) { int ans = 0 ;"}
{"text":"If number of block is even","code":"if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) \/ 2 ) + 1 ; } else { ans = ( n * m ) \/ 2 ; }"}
{"text":"Return the minimum points","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given size of grid","code":"int N = 5 , M = 7 ;"}
{"text":"Function Call","code":"System . out . print ( minPoints ( N , M ) ) ; } }"}
{"text":"Java code for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the largest lexicographical String with given constraints .","code":"static String getLargestString ( String s , int k ) {"}
{"text":"Vector containing frequency of each character .","code":"int [ ] frequency_array = new int [ 26 ] ;"}
{"text":"Assigning frequency","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) { frequency_array [ s . charAt ( i ) - ' a ' ] ++ ; }"}
{"text":"Empty String of String class type","code":"String ans = \" \" ;"}
{"text":"Loop to iterate over maximum priority first .","code":"for ( int i = 25 ; i >= 0 {"}
{"text":"If frequency is greater than or equal to k .","code":"if ( frequency_array [ i ] > k ) {"}
{"text":"Temporary variable to operate in - place of k .","code":"int temp = k ; String st = String . valueOf ( ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) {"}
{"text":"Concatenating with the resultant String ans .","code":"ans += st ; temp -- ; } frequency_array [ i ] -= k ;"}
{"text":"Handling k case by adjusting with just smaller priority element .","code":"int j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; }"}
{"text":"Condition to verify if index j does have frequency greater than 0 ;","code":"if ( frequency_array [ j ] > 0 && j >= 0 ) { String str = String . valueOf ( ( char ) ( j + ' a ' ) ) ; ans += str ; frequency_array [ j ] -= 1 ; } else {"}
{"text":"If no such element is found than String can not be processed further .","code":"break ; } }"}
{"text":"If frequency is greater than 0 and less than k .","code":"else if ( frequency_array [ i ] > 0 ) {"}
{"text":"Here we don 't need to fix K  consecutive element criteria.","code":"int temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; String st = String . valueOf ( ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } }"}
{"text":"Otherwise check for next possible element .","code":"else { i -- ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String S = \" xxxxzza \" ; int k = 3 ; System . out . print ( getLargestString ( S , k ) ) ; } }"}
{"text":"Java implementation to find the minimum operations make all elements equal using the second array","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum operations required to make all elements of the array equal","code":"static int minOperations ( int a [ ] , int b [ ] , int n ) {"}
{"text":"Minimum element of A [ ]","code":"int minA = Arrays . stream ( a ) . min ( ) . getAsInt ( ) ;"}
{"text":"Traverse through all final values","code":"for ( int x = minA ; x >= 0 ; x -- ) {"}
{"text":"Variable indicating whether all elements can be converted to x or not","code":"boolean check = true ;"}
{"text":"Total operations","code":"int operations = 0 ;"}
{"text":"Traverse through all array elements","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) \/ b [ i ] ; }"}
{"text":"All elements can 't  be converted to x","code":"else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 5 ; int A [ ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ ] = { 2 , 2 , 1 , 3 , 5 } ; System . out . print ( minOperations ( A , B , N ) ) ; } }"}
{"text":"Java implementation to find the largest value of a + b satisfying the given condition","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the maximum sum of a + b satisfying the given condition","code":"static int getLargestSum ( int N ) {"}
{"text":"Initialize max_sum","code":"int max_sum = 0 ;"}
{"text":"Consider all the possible pairs","code":"for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) {"}
{"text":"Check if the product is divisible by the sum","code":"if ( i * j % ( i + j ) == 0 )"}
{"text":"Storing the maximum sum in the max_sum variable","code":"max_sum = Math . max ( max_sum , i + j ) ; } }"}
{"text":"Return the max_sum value","code":"return max_sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum ) ; } }"}
{"text":"Java implementation to find the maximum sum of the array by multiplying the prefix and suffix of the array by - 1","code":"class GFG {"}
{"text":"Kadane 's algorithm to find  the maximum subarray sum","code":"static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ;"}
{"text":"Loop to find the maximum subarray array sum in the given array","code":"for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }"}
{"text":"Function to find the maximum sum of the array by multiplying the prefix and suffix by - 1","code":"static int maxSum ( int a [ ] , int n ) {"}
{"text":"Total intital sum","code":"int S = 0 ; int i ;"}
{"text":"Loop to find the maximum sum of the array","code":"for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ;"}
{"text":"Maximum value","code":"return 2 * X - S ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { - 1 , - 2 , - 3 } ; int n = a . length ; int max_sum = maxSum ( a , n ) ; System . out . print ( max_sum ) ; } }"}
{"text":"Java program to find the number of interesting primes up to N","code":"class GFG {"}
{"text":"Function to check if a number is prime or not","code":"static boolean isPrime ( int n ) { int flag = 1 ;"}
{"text":"If n is divisible by any number between 2 and Math . sqrt ( n ) , it is not prime","code":"for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; }"}
{"text":"Function to check if a number is perfect square or not","code":"static boolean isPerfectSquare ( int x ) {"}
{"text":"Find floating point value of square root of x .","code":"double sr = Math . sqrt ( x ) ;"}
{"text":"If square root is an integer","code":"return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }"}
{"text":"Function to find the number of interesting primes less than equal to N .","code":"static int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) {"}
{"text":"Check whether the number is prime or not","code":"if ( isPrime ( i ) ) {"}
{"text":"Iterate for values of b","code":"for ( int j = 1 ; j * j * j * j <= i ; j ++ ) {"}
{"text":"Check condition for a","code":"if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } }"}
{"text":"Return the required answer","code":"return answer ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countInterestingPrimes ( N ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to convert decimal number n to its binary representation stored as an array arr [ ]","code":"static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n \/= 2 ; } }"}
{"text":"Function to convert the number represented as a binary array arr [ ] into its decimal equivalent","code":"static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }"}
{"text":"Function to return the maximized number by flipping atmost k bits","code":"static int maxNum ( int n , int k ) {"}
{"text":"Number of bits in n","code":"int l = ( int ) ( Math . log ( n ) \/ Math . log ( 2 ) ) + 1 ;"}
{"text":"Find the binary representation of n","code":"int a [ ] = new int [ l ] ; decBinary ( a , n ) ;"}
{"text":"To count the number of 0 s flipped","code":"int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } }"}
{"text":"Return the decimal equivalent of the maximized number","code":"return binaryDec ( a , l ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 4 , k = 1 ; System . out . println ( maxNum ( n , k ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to find the required subsequence","code":"static void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) {"}
{"text":"Current element cannot be a part of the required subsequence","code":"if ( sum < arr [ i ] ) arr [ i ] = - 1 ;"}
{"text":"Include current element in the required subsequence So update the sum","code":"else sum -= arr [ i ] ; }"}
{"text":"Print the elements of the required subsequence","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If the current element was included in the subsequence","code":"if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = arr . length ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int MAX = 26 ;"}
{"text":"Function to return the maximum valued alphabet","code":"static char maxAlpha ( String str , int len ) {"}
{"text":"To store the first and the last occurrence of all the characters","code":"int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ;"}
{"text":"Set the first and the last occurrence of all the characters to - 1","code":"for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; }"}
{"text":"Update the occurrences of the characters","code":"for ( int i = 0 ; i < len ; i ++ ) { int index = ( str . charAt ( i ) - ' a ' ) ;"}
{"text":"Only set the first occurrence if it hasn 't already been set","code":"if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; }"}
{"text":"To store the result","code":"int ans = - 1 , maxVal = - 1 ;"}
{"text":"For every alphabet","code":"for ( int i = 0 ; i < MAX ; i ++ ) {"}
{"text":"If current alphabet doesn 't appear  in the given String","code":"if ( first [ i ] == - 1 ) continue ;"}
{"text":"If the current character has the highest value so far","code":"if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" abbba \" ; int len = str . length ( ) ; System . out . print ( maxAlpha ( str , len ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int MAX = 100001 ;"}
{"text":"Function to perform queries to find number of distinct elements from a given index till last index in an array","code":"static void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int [ ] check = new int [ MAX ] ; int [ ] idx = new int [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) {"}
{"text":"Check if current element already visited or not","code":"if ( check [ a [ i ] ] == 0 ) {"}
{"text":"If not visited store current counter and increment it and mark check as 1","code":"idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else {"}
{"text":"Otherwise if visited simply store current counter","code":"idx [ i ] = cnt - 1 ; } }"}
{"text":"Perform queries","code":"for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; System . out . print ( idx [ m ] + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = a . length ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = queries . length ; find_distinct ( a , n , q , queries ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG { static int MAX = 24 ;"}
{"text":"Function to return the count of operations required","code":"static int countOp ( int x ) {"}
{"text":"To store the powers of 2","code":"int arr [ ] = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ;"}
{"text":"Temporary variable to store x","code":"int temp = x ; boolean flag = true ;"}
{"text":"To store the index of smaller number larger than x","code":"int ans = 0 ;"}
{"text":"To store the count of operations","code":"int operations = 0 ; boolean flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ;"}
{"text":"Stores the index of number in the form of 2 ^ n - 1","code":"if ( arr [ i ] > x ) { ans = i ; break ; } }"}
{"text":"If x is already in the form 2 ^ n - 1 then no operation is required","code":"if ( flag2 ) return 0 ; while ( flag ) {"}
{"text":"If number is less than x increase the index","code":"if ( arr [ ans ] < x ) ans ++ ; operations ++ ;"}
{"text":"Calculate all the values ( x xor 2 ^ n - 1 ) for all possible n","code":"for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) {"}
{"text":"Only take value which is closer to the number","code":"if ( take > temp ) temp = take ; } }"}
{"text":"If number is in the form of 2 ^ n - 1 then break","code":"if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; }"}
{"text":"Return the count of operations required to obtain the number","code":"return operations ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x = 39 ; System . out . println ( countOp ( x ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to return the minimum operations required","code":"static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ;"}
{"text":"Count the frequency of each element","code":"int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; }"}
{"text":"Maximum element from the array","code":"maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) {"}
{"text":"Find all the multiples of i","code":"for ( int j = i * 2 ; j <= maxi ; j = j + i ) {"}
{"text":"Delete the multiples","code":"freq [ j ] = 0 ; }"}
{"text":"Increment the operations","code":"result ++ ; } } return result ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return minimum GCD among all subarrays","code":"static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } static int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ;"}
{"text":"Minimum GCD among all sub - arrays will be the GCD of all the elements of the array","code":"for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; }"}
{"text":"Function to return minimum LCM among all subarrays","code":"static int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ;"}
{"text":"Minimum LCM among all sub - arrays will be the minimum element from the array","code":"for ( int i = 1 ; i < n ; i ++ ) minLCM = Math . min ( minLCM , arr [ i ] ) ; return minLCM ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 66 , 14 , 521 } ; int n = arr . length ; System . out . println ( \" LCM \u2581 = \u2581 \" + minLCM ( arr , n ) + \" \u2581 GCD \u2581 = \u2581 \" + minGCD ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that returns the modified lexicographically smallest String after performing minimum number of given operations","code":"static String formStringMinOperations ( char [ ] s ) {"}
{"text":"Stores the initial frequencies of characters 0 s , 1 s and 2 s","code":"int count [ ] = new int [ 3 ] ; for ( char c : s ) { count [ ( int ) c - 48 ] += 1 ; }"}
{"text":"Stores number of processed characters upto that point of each type","code":"int processed [ ] = new int [ 3 ] ;"}
{"text":"Required number of characters of each type","code":"int reqd = ( int ) s . length \/ 3 ; for ( int i = 0 ; i < s . length ; i ++ ) {"}
{"text":"If the current type has already reqd number of characters , no need to perform any operation","code":"if ( count [ s [ i ] - '0' ] == reqd ) { continue ; }"}
{"text":"Process all 3 cases","code":"if ( s [ i ] == '0' && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) {"}
{"text":"Check for 1 first","code":"if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 0 ] -- ; }"}
{"text":"Else 2","code":"else if ( count [ 2 ] < reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 0 ] -- ; } }"}
{"text":"Here we need to check processed [ 1 ] only for 2 since 0 is less than 1 and we can replace it anytime","code":"if ( s [ i ] == '1' && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 1 ] -- ; } }"}
{"text":"Here we can replace 2 with 0 and 1 anytime","code":"if ( s [ i ] == '2' && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 2 ] -- ; } }"}
{"text":"keep count of processed characters of each type","code":"processed [ s [ i ] - '0' ] ++ ; } return String . valueOf ( s ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \"011200\" ; System . out . println ( formStringMinOperations ( s . toCharArray ( ) ) ) ; } }"}
{"text":"Java Program to find the minimum number of adjacent swaps to arrange similar items together","code":"import java . util . * ; class solution {"}
{"text":"Function to find minimum swaps","code":"static int findMinimumAdjacentSwaps ( int arr [ ] , int N ) {"}
{"text":"visited array to check if value is seen already","code":"boolean [ ] visited = new boolean [ N + 1 ] ; int minimumSwaps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) {"}
{"text":"If the arr [ i ] is seen first time","code":"if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ;"}
{"text":"stores the number of swaps required to find the correct position of current element 's partner","code":"int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) {"}
{"text":"Increment count only if the current element has not been visited yet ( if is visited , means it has already been placed at its correct position )","code":"if ( visited [ arr [ j ] ] == false ) count ++ ;"}
{"text":"If current element 's partner is found","code":"else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = arr . length ; N \/= 2 ; System . out . println ( findMinimumAdjacentSwaps ( arr , N ) ) ; } }"}
{"text":"JAVA program to print the largest palindromic number by permuting digits of a number","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if a number can be permuted to form a palindrome number","code":"static boolean possibility ( HashMap < Integer , Integer > m , int length , String s ) {"}
{"text":"counts the occurrence of number which is odd","code":"int countodd = 0 ; for ( int i = 0 ; i < length ; i ++ ) {"}
{"text":"if occurrence is odd","code":"if ( m . get ( s . charAt ( i ) - '0' ) % 2 == 1 ) countodd ++ ;"}
{"text":"if number exceeds 1","code":"if ( countodd > 1 ) return false ; } return true ; }"}
{"text":"function to print the largest palindromic number by permuting digits of a number","code":"static void largestPalindrome ( String s ) {"}
{"text":"String length","code":"int l = s . length ( ) ;"}
{"text":"map that marks the occurrence of a number","code":"HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < l ; i ++ ) if ( m . containsKey ( s . charAt ( i ) - '0' ) ) m . put ( s . charAt ( i ) - '0' , m . get ( s . charAt ( i ) - '0' ) + 1 ) ; else m . put ( s . charAt ( i ) - '0' , 1 ) ;"}
{"text":"check the possibility of a palindromic number","code":"if ( possibility ( m , l , s ) == false ) { System . out . print ( \" Palindrome \u2581 cannot \u2581 be \u2581 formed \" ) ; return ; }"}
{"text":"String array that stores the largest permuted palindromic number","code":"char [ ] largest = new char [ l ] ;"}
{"text":"pointer of front","code":"int front = 0 ;"}
{"text":"greedily start from 9 to 0 and place the greater number in front and odd in the middle","code":"for ( int i = 9 ; i >= 0 ; i -- ) {"}
{"text":"if the occurrence of number is odd","code":"if ( m . containsKey ( i ) && m . get ( i ) % 2 == 1 ) {"}
{"text":"place one odd occurring number in the middle","code":"largest [ l \/ 2 ] = ( char ) ( i + 48 ) ;"}
{"text":"decrease the count","code":"m . put ( i , m . get ( i ) - 1 ) ;"}
{"text":"place the rest of numbers greedily","code":"while ( m . get ( i ) > 0 ) { largest [ front ] = ( char ) ( i + 48 ) ; largest [ l - front - 1 ] = ( char ) ( i + 48 ) ; m . put ( i , m . get ( i ) - 2 ) ; front ++ ; } } else {"}
{"text":"if all numbers occur even times , then place greedily","code":"while ( m . containsKey ( i ) && m . get ( i ) > 0 ) {"}
{"text":"place greedily at front","code":"largest [ front ] = ( char ) ( i + 48 ) ; largest [ l - front - 1 ] = ( char ) ( i + 48 ) ;"}
{"text":"2 numbers are placed , so decrease the count","code":"m . put ( i , m . get ( i ) - 2 ) ;"}
{"text":"increase placing position","code":"front ++ ; } } }"}
{"text":"print the largest String thus formed","code":"for ( int i = 0 ; i < l ; i ++ ) System . out . print ( largest [ i ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \"313551\" ; largestPalindrome ( s ) ; } }"}
{"text":"Java program to count swaps required to balance string","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate swaps required","code":"public static long swapCount ( String s ) {"}
{"text":"Keep track of ' [ '","code":"Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == ' [ ' ) pos . add ( i ) ;"}
{"text":"To count number of encountered ' [ '","code":"int count = 0 ;"}
{"text":"To track position of next ' [ ' in pos","code":"int p = 0 ;"}
{"text":"To store result","code":"long sum = 0 ; char [ ] S = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) {"}
{"text":"Increment count and move p to next position","code":"if ( S [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( S [ i ] == ' ] ' ) -- count ;"}
{"text":"We have encountered an unbalanced part of string","code":"if ( count < 0 ) {"}
{"text":"Increment sum by number of swaps required i . e . position of next ' [ ' - current position","code":"sum += pos . get ( p ) - i ; char temp = S [ i ] ; S [ i ] = S [ pos . get ( p ) ] ; S [ pos . get ( p ) ] = temp ; ++ p ;"}
{"text":"Reset count to 1","code":"count = 1 ; } } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" [ ] ] [ ] [ \" ; System . out . println ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; System . out . println ( swapCount ( s ) ) ; } }"}
{"text":"Java program to divide a board into m * n squares","code":"import java . util . Arrays ; import java . util . Collections ; class GFG {"}
{"text":"method returns minimum cost to break board into m * n squares","code":"static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ;"}
{"text":"sort the horizontal cost in reverse order","code":"Arrays . sort ( X , Collections . reverseOrder ( ) ) ;"}
{"text":"sort the vertical cost in reverse order","code":"Arrays . sort ( Y , Collections . reverseOrder ( ) ) ;"}
{"text":"initialize current width as 1","code":"int hzntl = 1 , vert = 1 ;"}
{"text":"loop until one or both cost array are processed","code":"int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ;"}
{"text":"increase current horizontal part count by 1","code":"hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ;"}
{"text":"increase current vertical part count by 1","code":"vert ++ ; j ++ ; } }"}
{"text":"loop for horizontal array , if remains","code":"int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ;"}
{"text":"loop for vertical array , if remains","code":"total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }"}
{"text":"Driver program","code":"public static void main ( String arg [ ] ) { int m = 6 , n = 4 ; Integer X [ ] = { 2 , 1 , 3 , 1 , 4 } ; Integer Y [ ] = { 4 , 1 , 2 } ; System . out . print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the minimum of the three numbers","code":"static int getMin ( int x , int y , int z ) { return Math . min ( Math . min ( x , y ) , z ) ; }"}
{"text":"Function to find the minimum number operations required to convert String str1 to str2 using the operations","code":"static int editDistance ( String str1 , String str2 , int m , int n ) {"}
{"text":"Stores the results of subproblems","code":"int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;"}
{"text":"Fill dp [ ] [ ] in bottom up manner","code":"for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) {"}
{"text":"If str1 is empty , then insert all characters of String str2","code":"if ( i == 0 )"}
{"text":"Minimum operations is j","code":"dp [ i ] [ j ] = j ;"}
{"text":"If str2 is empty , then remove all characters of String str2","code":"else if ( j == 0 )"}
{"text":"Minimum operations is i","code":"dp [ i ] [ j ] = i ;"}
{"text":"If the last characters are same , then ignore last character","code":"else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;"}
{"text":"If the last character is different , then find the minimum","code":"else {"}
{"text":"Perform one of the insert , remove and the replace","code":"dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } }"}
{"text":"Return the minimum number of steps required","code":"return dp [ m ] [ n ] ; }"}
{"text":"Function to find the minimum number of steps to modify the String such that first half and second half becomes the same","code":"static void minimumSteps ( String S , int N ) {"}
{"text":"Stores the minimum number of operations required","code":"int ans = Integer . MAX_VALUE ;"}
{"text":"Traverse the given String S","code":"for ( int i = 1 ; i < N ; i ++ ) { String S1 = S . substring ( 0 , i ) ; String S2 = S . substring ( i ) ;"}
{"text":"Find the minimum operations","code":"int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ;"}
{"text":"Update the ans","code":"ans = Math . min ( ans , count ) ; }"}
{"text":"Print the result","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" aabb \" ; int N = S . length ( ) ; minimumSteps ( S , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the minimum number of operations to reduce N to 2 by dividing N by 5 or decrementing by 3","code":"static int minimumOperations ( int N ) {"}
{"text":"Initialize the dp array","code":"int [ ] dp = new int [ N + 1 ] ; int i ;"}
{"text":"Initialize the array dp [ ]","code":"for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = ( int ) 1e9 ; }"}
{"text":"For N = 2 number of operations needed is zero","code":"dp [ 2 ] = 0 ;"}
{"text":"Iterating over the range [ 1 , N ]","code":"for ( i = 2 ; i <= N ; i ++ ) {"}
{"text":"If it 's not possible to  create current N","code":"if ( dp [ i ] == ( int ) 1e9 ) continue ;"}
{"text":"Multiply with 5","code":"if ( i * 5 <= N ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; }"}
{"text":"Adding the value 3","code":"if ( i + 3 <= N ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } }"}
{"text":"Checking if not possible to make the number as 2","code":"if ( dp [ N ] == 1e9 ) return - 1 ;"}
{"text":"Return the minimum number of operations","code":"return dp [ N ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( minimumOperations ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the maximum profit with transaction fee","code":"static int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ;"}
{"text":"Traversing the stocks for each day","code":"for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ;"}
{"text":"Update buy and sell","code":"buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; }"}
{"text":"Return the maximum profit","code":"return Math . max ( sell , buy ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Input","code":"int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = arr . length ; int transactionFee = 2 ;"}
{"text":"Function Call","code":"System . out . println ( MaxProfit ( arr , n , transactionFee ) ) ; } }"}
{"text":"Java program for tha above approach","code":"import java . util . * ; class GFG {"}
{"text":"Stores the maximum path sum from the cell ( 1 , 1 ) to ( N , M )","code":"static int start [ ] [ ] = new int [ 3 ] [ 3 ] ;"}
{"text":"Stores the maximum path sum from the cell ( j , j ) to ( N , M )","code":"static int ending [ ] [ ] = new int [ 3 ] [ 3 ] ;"}
{"text":"Function to find the maximum path sum from the cell ( 1 , 1 ) to ( N , M )","code":"static void calculateStart ( int n , int m ) {"}
{"text":"Traverse the first row","code":"for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; }"}
{"text":"Traverse the first column","code":"for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; }"}
{"text":"Traverse the matrix","code":"for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) {"}
{"text":"Update the value of start [ i ] [ j ]","code":"start [ i ] [ j ] += Math . max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } }"}
{"text":"Function to find the maximum path sum from the cell ( j , j ) to ( N , M )","code":"static void calculateEnd ( int n , int m ) {"}
{"text":"Traverse the last row","code":"for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; }"}
{"text":"Traverse the last column","code":"for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; }"}
{"text":"Traverse the matrix","code":"for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) {"}
{"text":"Update the value of ending [ i ] [ j ]","code":"ending [ i ] [ j ] += Math . max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } }"}
{"text":"Function to find the maximum path sum from the top - left to the bottom right cell such that path contains one of the cells in the array coordinates [ ] [ ]","code":"static void maximumPathSum ( int mat [ ] [ ] , int n , int m , int q , int coordinates [ ] [ ] ) {"}
{"text":"Initialize the start and the end matrices","code":"for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } }"}
{"text":"Calculate the start matrix","code":"calculateStart ( n , m ) ;"}
{"text":"Calculate the end matrix","code":"calculateEnd ( n , m ) ;"}
{"text":"Stores the maximum path sum","code":"int ans = 0 ;"}
{"text":"Traverse the coordinates","code":"for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ;"}
{"text":"Update the value of ans","code":"ans = Math . max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; }"}
{"text":"Print the resultant maximum sum path value","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int N = 3 ; int M = 3 ; int Q = 2 ; int coordinates [ ] [ ] = { { 1 , 2 } , { 2 , 2 } } ; maximumPathSum ( mat , N , M , Q , coordinates ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the length of the longest subset of an array of strings with at most A 0 s and B 1 s","code":"static int MaxSubsetlength ( String arr [ ] , int A , int B ) {"}
{"text":"Initialize a 2D array with its entries as 0","code":"int dp [ ] [ ] = new int [ A + 1 ] [ B + 1 ] ;"}
{"text":"Traverse the given array","code":"for ( String str : arr ) {"}
{"text":"Store the count of 0 s and 1 s in the current string","code":"int zeros = 0 , ones = 0 ; for ( char ch : str . toCharArray ( ) ) { if ( ch == '0' ) zeros ++ ; else ones ++ ; }"}
{"text":"Iterate in the range [ A , zeros ]","code":"for ( int i = A ; i >= zeros ; i -- )"}
{"text":"Iterate in the range [ B , ones ]","code":"for ( int j = B ; j >= ones ; j -- )"}
{"text":"Update the value of dp [ i ] [ j ]","code":"dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; }"}
{"text":"Print the result","code":"return dp [ A ] [ B ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String arr [ ] = { \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" } ; int A = 5 , B = 3 ; System . out . println ( MaxSubsetlength ( arr , A , B ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to count ways to select N distinct pairs of candies with different colours","code":"static int numOfWays ( int a [ ] [ ] , int n , int i , HashSet < Integer > blue ) {"}
{"text":"If n pairs are selected","code":"if ( i == n ) return 1 ;"}
{"text":"Stores count of ways to select the i - th pair","code":"int count = 0 ;"}
{"text":"Iterate over the range [ 0 , n ]","code":"for ( int j = 0 ; j < n ; j ++ ) {"}
{"text":"If pair ( i , j ) is not included","code":"if ( a [ i ] [ j ] == 1 && ! blue . contains ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . remove ( j ) ; } } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; HashSet < Integer > mpp = new HashSet < > ( ) ; System . out . println ( ( numOfWays ( mat , n , 0 , mpp ) ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the minimum cost to reach the end of an array","code":"static void minCost ( int arr [ ] , int n ) {"}
{"text":"Base Case : When N < 3","code":"if ( n < 3 ) { System . out . println ( arr [ 0 ] ) ; return ; }"}
{"text":"Store the results in table","code":"int dp [ ] = new int [ n ] ;"}
{"text":"Initialize base cases","code":"dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ;"}
{"text":"Iterate over the range [ 2 , N - 2 ] to construct the dp array","code":"for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ;"}
{"text":"Handle case for the last index , i . e . N - 1","code":"dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ;"}
{"text":"Print the answer","code":"System . out . println ( dp [ n - 1 ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = arr . length ; minCost ( arr , N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { static int M = 1000000007 ;"}
{"text":"Function to find the value of power ( X , Y ) in O ( log Y )","code":"static int power ( int X , int Y ) {"}
{"text":"Stores power ( X , Y )","code":"int res = 1 ;"}
{"text":"Update X","code":"X = X % M ;"}
{"text":"Base Case","code":"if ( X == 0 ) return 0 ;"}
{"text":"Calculate power ( X , Y )","code":"while ( Y > 0 ) {"}
{"text":"If Y is an odd number","code":"if ( ( Y & 1 ) != 0 ) {"}
{"text":"Update res","code":"res = ( res * X ) % M ; }"}
{"text":"Update Y","code":"Y = Y >> 1 ;"}
{"text":"Update X","code":"X = ( X * X ) % M ; } return res ; }"}
{"text":"Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"static int findValue ( int n ) {"}
{"text":"Stores binary representation of n","code":"int X = 0 ;"}
{"text":"Stores power of 10","code":"int pow_10 = 1 ;"}
{"text":"Calculate the binary representation of n","code":"while ( n != 0 ) {"}
{"text":"If n is an odd number","code":"if ( ( n & 1 ) != 0 ) {"}
{"text":"Update X","code":"X += pow_10 ; }"}
{"text":"Update pow_10","code":"pow_10 *= 10 ;"}
{"text":"Update n","code":"n \/= 2 ; }"}
{"text":"Double the value of X","code":"X = ( X * 2 ) % M ;"}
{"text":"Stores the value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"int res = power ( 2 , X ) ; return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( findValue ( n ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG { static final long M = 1000000007 ;"}
{"text":"Function to find the value of power ( X , Y ) in O ( log Y )","code":"static long power ( long X , long Y ) {"}
{"text":"Stores power ( X , Y )","code":"long res = 1 ;"}
{"text":"Update X","code":"X = X % M ;"}
{"text":"Base Case","code":"if ( X == 0 ) return 0 ;"}
{"text":"Calculate power ( X , Y )","code":"while ( Y > 0 ) {"}
{"text":"If Y is an odd number","code":"if ( Y % 2 == 1 ) {"}
{"text":"Update res","code":"res = ( res * X ) % M ; }"}
{"text":"Update Y","code":"Y = Y >> 1 ;"}
{"text":"Update X","code":"X = ( X * X ) % M ; } return res ; }"}
{"text":"Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"static long findValue ( int N ) {"}
{"text":"dp [ N ] * dp [ N ] : Stores value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"long [ ] dp = new long [ N + 1 ] ;"}
{"text":"Base Case","code":"dp [ 1 ] = 2 ; dp [ 2 ] = 1024 ;"}
{"text":"Iterate over the range [ 3 , N ]","code":"for ( int i = 3 ; i <= N ; i ++ ) {"}
{"text":"Stores rightmost bit of i","code":"int y = ( i & ( - i ) ) ;"}
{"text":"Stores the value of ( i - y )","code":"int x = i - y ;"}
{"text":"If x is power of 2","code":"if ( x == 0 ) {"}
{"text":"Update dp [ i ]","code":"dp [ i ] = power ( dp [ i \/ 2 ] , 10 ) ; } else {"}
{"text":"Update dp [ i ]","code":"dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; } } return ( dp [ N ] * dp [ N ] ) % M ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 150 ; System . out . print ( findValue ( n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the number of ways to get the sum N with throw of dice","code":"static int findWays ( int N ) {"}
{"text":"Base Case","code":"if ( N == 0 ) { return 1 ; }"}
{"text":"Stores the count of total number of ways to get sum N","code":"int cnt = 0 ;"}
{"text":"Recur for all 6 states","code":"for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } }"}
{"text":"Return answer","code":"return cnt ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 ;"}
{"text":"Function call","code":"System . out . print ( findWays ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Utility function to check array can be partition to 3 subsequences of equal sum or not","code":"static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) {"}
{"text":"Base Case","code":"if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else {"}
{"text":"When element at index j is added to sm1","code":"int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ;"}
{"text":"When element at index j is added to sm2","code":"int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ;"}
{"text":"When element at index j is added to sm3","code":"int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ;"}
{"text":"Return maximum value among all above 3 recursive call","code":"return Math . max ( Math . max ( l , m ) , r ) ; } }"}
{"text":"Function to check array can be partition to 3 subsequences of equal sum or not","code":"static void checkEqualSum ( int arr [ ] , int N ) {"}
{"text":"Initialise 3 sums to 0","code":"int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ;"}
{"text":"Function Call","code":"if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ;"}
{"text":"Function Call","code":"checkEqualSum ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static HashMap < String , Integer > dp = new HashMap < String , Integer > ( ) ;"}
{"text":"Function to check array can be partition into sum of 3 equal","code":"static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { String s = String . valueOf ( sm1 ) + \" _ \" + String . valueOf ( sm2 ) + String . valueOf ( j ) ;"}
{"text":"Base Case","code":"if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; }"}
{"text":"If value at particular index is not - 1 then return value at that index which ensure no more further calls","code":"if ( dp . containsKey ( s ) ) return dp . get ( s ) ; else {"}
{"text":"When element at index j is added to sm1","code":"int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ;"}
{"text":"When element at index j is added to sm2","code":"int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ;"}
{"text":"When element at index j is added to sm3","code":"int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ;"}
{"text":"Update the current state and return that value","code":"dp . put ( s , Math . max ( Math . max ( l , m ) , r ) ) ; return dp . get ( s ) ; } }"}
{"text":"Function to check array can be partition to 3 subsequences of equal sum or not","code":"static void checkEqualSum ( int arr [ ] , int N ) {"}
{"text":"Initialise 3 sums to 0","code":"int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ;"}
{"text":"Function Call","code":"if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ;"}
{"text":"Function Call","code":"checkEqualSum ( arr , N ) ; } }"}
{"text":"Java program to find the smallest index in the array in the range [ L , R ] which does not contain X","code":"class GFG {"}
{"text":"Precompute the index of next different element in the array for every array element","code":"static void precompute ( int nextpos [ ] , int arr [ ] , int N ) {"}
{"text":"Default value","code":"nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) {"}
{"text":"Compute nextpos [ i ] using nextpos [ i + 1 ]","code":"if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } }"}
{"text":"Function to return the smallest index","code":"static void findIndex ( int query [ ] [ ] , int arr [ ] , int N , int Q ) {"}
{"text":"nextpos [ i ] will store the next position p where arr [ p ] != arr [ i ]","code":"int [ ] nextpos = new int [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = - 1 ;"}
{"text":"If X is not present at l","code":"if ( arr [ l ] != x ) ans = l ;"}
{"text":"Otherwise","code":"else {"}
{"text":"Find the index which stores a value different from X","code":"int d = nextpos [ l ] ;"}
{"text":"If that index is within the range","code":"if ( d <= r ) ans = d ; } System . out . print ( ans + \"NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ ] [ ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; } }"}
{"text":"Java program for above approach","code":"class GFG { static long mod = 10000000007L ;"}
{"text":"Function to count number of ways to convert string S to string T by performing K cyclic shifts","code":"static long countWays ( String s , String t , int k ) {"}
{"text":"Calculate length of string","code":"int n = s . length ( ) ;"}
{"text":"' a ' is no of good cyclic shifts ' b ' is no of bad cyclic shifts","code":"int a = 0 , b = 0 ;"}
{"text":"Iterate in the string","code":"for ( int i = 0 ; i < n ; i ++ ) { String p = s . substring ( i , n - i ) + s . substring ( 0 , i ) ;"}
{"text":"Precompute the number of good and bad cyclic shifts","code":"if ( p == t ) a ++ ; else b ++ ; }"}
{"text":"dp2 [ i ] to store the no of ways to get to a bad shift in i moves","code":"long dp1 [ ] = new long [ k + 1 ] ; long dp2 [ ] = new long [ k + 1 ] ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; }"}
{"text":"Calculate good and bad shifts","code":"for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; }"}
{"text":"Return the required number of ways","code":"return dp1 [ k ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Strings","code":"String S = \" ab \" , T = \" ab \" ;"}
{"text":"Given K shifts required","code":"int K = 2 ;"}
{"text":"Function Call","code":"System . out . print ( countWays ( S , T , K ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to find minimum operations","code":"static int minOperation ( int k ) {"}
{"text":"dp is initialised to store the steps","code":"int dp [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ;"}
{"text":"For all even numbers","code":"if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i \/ 2 ] + 1 ) ; } } return dp [ k ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int K = 12 ; System . out . print ( minOperation ( K ) ) ; } }"}
{"text":"Java implementation for the above mentioned recursive approach","code":"class GFG {"}
{"text":"Function to find the maximum subset sum","code":"static int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; }"}
{"text":"Ignore the current element","code":"int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ;"}
{"text":"including element in partition 1","code":"ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ;"}
{"text":"including element in partition 2","code":"ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"size of the array","code":"int n = 4 ; int a [ ] = { 1 , 2 , 3 , 6 } ; System . out . println ( maxSum ( 0 , 0 , a , 0 , n ) ) ; } }"}
{"text":"Java implementation for the above mentioned Dynamic Programming approach","code":"class GFG { final static int INT_MIN = Integer . MIN_VALUE ;"}
{"text":"Function to find the maximum subset sum","code":"static int maxSum ( int a [ ] , int n ) {"}
{"text":"sum of all elements","code":"int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ;"}
{"text":"bottom up lookup table ;","code":"int dp [ ] [ ] = new int [ n + 1 ] [ limit ] ;"}
{"text":"initialising dp table with INT_MIN where , INT_MIN means no solution","code":"for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; }"}
{"text":"Case when diff is 0","code":"dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) {"}
{"text":"Putting ith element in g0","code":"if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ;"}
{"text":"Putting ith element in g1","code":"if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ;"}
{"text":"Ignoring ith element","code":"if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 4 ; int [ ] a = { 1 , 2 , 3 , 6 } ; System . out . println ( maxSum ( a , n ) ) ; } }"}
{"text":"Java program to count the different possible string form by replacing two same characters with one","code":"class GFG {"}
{"text":"Array to find the fibonacci sequence","code":"static int fib [ ] = new int [ 100005 ] ;"}
{"text":"Function to find the fibonacci sequence","code":"static void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }"}
{"text":"Function to count all possible strings","code":"static int countString ( String str ) {"}
{"text":"Initialize ans = 1","code":"int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) {"}
{"text":"If two consecutive char are same increase cnt","code":"if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) { cnt ++ ; }"}
{"text":"Else multiply the fib [ cnt ] to ans and initialize ans to 1","code":"else { ans = ans * fib [ cnt ] ; cnt = 1 ; } }"}
{"text":"If str = abcdeeee , then for last \" eeee \" the count munst be updated","code":"ans = ans * fib [ cnt ] ;"}
{"text":"Return the total count","code":"return ans ; }"}
{"text":"Driver 's Code","code":"public static void main ( String [ ] args ) { String str = \" abdllldefkkkk \" ;"}
{"text":"Function to precompute all the fibonacci number","code":"computeFibonacci ( ) ;"}
{"text":"Function call to find the count","code":"System . out . println ( countString ( str ) ) ; } }"}
{"text":"Java program to find the first N terms of Golomb Sequence","code":"import java . util . * ; class GFG { static int MAX = 1000 ;"}
{"text":"Function to print the Golomb Sequence","code":"static void printGolombSequence ( int N ) {"}
{"text":"Initialise the array","code":"int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) arr [ i ] = 0 ;"}
{"text":"Initialise the cnt to 0","code":"int cnt = 0 ;"}
{"text":"First and second element of Golomb Sequence is 0 , 1","code":"arr [ 0 ] = 0 ; arr [ 1 ] = 1 ;"}
{"text":"Map to store the count of current element in Golomb Sequence","code":"Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Store the count of 2","code":"M . put ( 2 , 2 ) ;"}
{"text":"Iterate over 2 to N","code":"for ( int i = 2 ; i <= N ; i ++ ) {"}
{"text":"If cnt is equals to 0 then we have new number for Golomb Sequence 1 2 2 3 3 4 4 4 5 5 5 which is 1 + previous element","code":"if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M . get ( arr [ i ] ) ; cnt -- ; }"}
{"text":"Else the current element is the previous element in this Sequence","code":"else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; }"}
{"text":"Map the current index to current value in arr [ ]","code":"M . put ( i , arr [ i ] ) ; }"}
{"text":"Print the Golomb Sequence","code":"for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int N = 11 ; printGolombSequence ( N ) ; } }"}
{"text":"Java implementation to find the number the number of ways to reach Nth stair by taking 1 , 2 step at a time and 3 Steps at a time exactly once .","code":"class GFG {"}
{"text":"Function to find the number the number of ways to reach Nth stair","code":"static int number_of_ways ( int n ) {"}
{"text":"Array including number of ways that includes 3","code":"int [ ] includes_3 = new int [ n + 1 ] ;"}
{"text":"Array including number of ways that doesn 't includes 3","code":"int [ ] not_includes_3 = new int [ n + 1 ] ;"}
{"text":"Initially to reach 3 stairs by taking 3 steps can be reached by 1 way","code":"includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ;"}
{"text":"Loop to find the number the number of ways to reach Nth stair","code":"for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( number_of_ways ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int MAX = 100000 ;"}
{"text":"Map to store the divisor count","code":"static int [ ] divisors = new int [ MAX ] ;"}
{"text":"Function to generate the divisors of all the array elements","code":"static void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n \/ i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n \/ i ] ++ ; } } } }"}
{"text":"Function to find the maximum number of multiples in an array before it","code":"static int findMaxMultiples ( int [ ] arr , int n ) {"}
{"text":"To store the maximum divisor count","code":"int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Update ans if more number of divisors are found","code":"ans = Math . max ( divisors [ arr [ i ] ] , ans ) ;"}
{"text":"Generating all the divisors of the next element of the array","code":"generateDivisors ( arr [ i ] ) ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = arr . length ; System . out . print ( findMaxMultiples ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static int n = 3 ; static int maxV = 20 ;"}
{"text":"3d array to store states of dp","code":"static int [ ] [ ] [ ] dp = new int [ n ] [ n ] [ maxV ] ;"}
{"text":"Array to determine whether a state has been solved before","code":"static int [ ] [ ] [ ] v = new int [ n ] [ n ] [ maxV ] ;"}
{"text":"Function to return the count of required paths","code":"static int countWays ( int i , int j , int x , int arr [ ] [ ] ) {"}
{"text":"Base cases","code":"if ( i == n j == n ) { return 0 ; } x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) { return 0 ; } if ( i == n - 1 && j == n - 1 ) { return 1 ; }"}
{"text":"If a state has been solved before it won 't be evaluated again","code":"if ( v [ i ] [ j ] [ x ] == 1 ) { return dp [ i ] [ j ] [ x ] ; } v [ i ] [ j ] [ x ] = 1 ;"}
{"text":"Recurrence relation","code":"dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; System . out . println ( countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG { static int N = 3 ;"}
{"text":"Function to return the maximum sum","code":"static int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ ] ) {"}
{"text":"Base case","code":"if ( ind == n ) return 0 ;"}
{"text":"Already visited","code":"if ( dp [ ind ] [ kon ] != - 1 ) return dp [ ind ] [ kon ] ; int ans = ( int ) ( - 1e9 + 5 ) ;"}
{"text":"If the element has been taken from first array in previous step","code":"if ( kon == 0 ) { ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; }"}
{"text":"If the element has been taken from second array in previous step","code":"else if ( kon == 1 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; }"}
{"text":"If the element has been taken from third array in previous step","code":"else if ( kon == 2 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 6 , 8 , 2 , 7 , 4 , 2 , 7 } ; int b [ ] = { 7 , 8 , 5 , 8 , 6 , 3 , 5 } ; int c [ ] = { 8 , 3 , 2 , 6 , 8 , 4 , 1 } ; int n = a . length ; int dp [ ] [ ] = new int [ n ] [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }"}
{"text":"Pick element from first array","code":"int x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ;"}
{"text":"Pick element from second array","code":"int y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ;"}
{"text":"Pick element from third array","code":"int z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ;"}
{"text":"Print the maximum of them","code":"System . out . println ( Math . max ( x , Math . max ( y , z ) ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static int mod = 1000000007 ;"}
{"text":"Function to return no of ways to build a binary string of length N such that 0 s always occur in groups of size K","code":"static int noOfBinaryStrings ( int N , int k ) { int dp [ ] = new int [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 4 ; int K = 2 ; System . out . println ( noOfBinaryStrings ( N , K ) ) ; } }"}
{"text":"Java program to find number of ways to pair people in party","code":"class GFG {"}
{"text":"Function to find number of ways to pair people in party","code":"static int findWaysToPair ( int p ) {"}
{"text":"To store count of number of ways .","code":"int dp [ ] = new int [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ;"}
{"text":"Using the recurrence defined find count for different values of p .","code":"for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int p = 3 ; System . out . println ( findWaysToPair ( p ) ) ; } }"}
{"text":"A simple recursive implementation for counting ways to reach a score using 1 and 2 with consecutive 2 allowed","code":"import java . io . * ; class GFG { static int CountWays ( int n ) {"}
{"text":"base cases","code":"if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; }"}
{"text":"For cases n > 2","code":"return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }"}
{"text":"Java program to check if the number is weird or not","code":"import java . util . * ; class GFG {"}
{"text":"code to find all the factors of the number excluding the number itself","code":"static ArrayList < Integer > factors ( int n ) {"}
{"text":"ArrayList to store the factors","code":"ArrayList < Integer > v = new ArrayList < Integer > ( ) ; v . add ( 1 ) ;"}
{"text":"note that this loop runs till sqrt ( n )","code":"for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) {"}
{"text":"if the value of i is a factor","code":"if ( n % i == 0 ) { v . add ( i ) ;"}
{"text":"condition to check the divisor is not the number itself","code":"if ( n \/ i != i ) { v . add ( n \/ i ) ; } } }"}
{"text":"return the ArrayList","code":"return v ; }"}
{"text":"Function to check if the number is abundant or not","code":"static boolean checkAbundant ( int n ) { ArrayList < Integer > v ; int sum = 0 ;"}
{"text":"find the divisors using function","code":"v = factors ( n ) ;"}
{"text":"sum all the factors","code":"for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v . get ( i ) ; }"}
{"text":"check for abundant or not","code":"if ( sum > n ) return true ; else return false ; }"}
{"text":"Function to check if the number is semi - perfect or not","code":"static boolean checkSemiPerfect ( int n ) { ArrayList < Integer > v ;"}
{"text":"find the divisors","code":"v = factors ( n ) ;"}
{"text":"sorting the ArrayList","code":"Collections . sort ( v ) ; int r = v . size ( ) ;"}
{"text":"subset to check if no is semiperfect","code":"boolean subset [ ] [ ] = new boolean [ r + 1 ] [ n + 1 ] ;"}
{"text":"initialising 1 st column to true","code":"for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ;"}
{"text":"initialing 1 st row except zero position to 0","code":"for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ;"}
{"text":"loop to find whether the number is semiperfect","code":"for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) {"}
{"text":"calculation to check if the number can be made by summation of divisors","code":"if ( j < v . get ( i - 1 ) ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v . get ( i - 1 ) ] ; } } }"}
{"text":"if not possible to make the number by any combination of divisors","code":"if ( ( subset [ r ] [ n ] ) == false ) return false ; else return true ; }"}
{"text":"Function to check for weird or not","code":"static boolean checkweird ( int n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 70 ; if ( checkweird ( n ) ) System . out . println ( \" Weird \u2581 Number \" ) ; else System . out . println ( \" Not \u2581 Weird \u2581 Number \" ) ; } }"}
{"text":"Java program to print largest contiguous array sum when array is created after concatenating a small array k times .","code":"import java . io . * ; class GFG {"}
{"text":"Returns sum of maximum sum subarray created after concatenating a [ 0. . n - 1 ] k times .","code":"static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) {"}
{"text":"This is where it differs from Kadane 's algorithm. We use modular  arithmetic to find next element.","code":"max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }"}
{"text":"Driver program to test maxSubArraySum","code":"public static void main ( String [ ] args ) { int a [ ] = { 10 , 20 , - 30 , - 1 } ; int n = a . length ; int k = 3 ; System . out . println ( \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" + maxSubArraySumRepeated ( a , n , k ) ) ; } }"}
{"text":"Java implementation to find the longest increasing odd even subsequence","code":"import java . util . * ; import java . lang . * ; public class GfG {"}
{"text":"function to find the longest increasing odd even subsequence","code":"public static int longOddEvenIncSeq ( int arr [ ] , int n ) {"}
{"text":"lioes [ i ] stores longest increasing odd even subsequence ending at arr [ i ]","code":"int [ ] lioes = new int [ n ] ;"}
{"text":"to store the length of longest increasing odd even subsequence","code":"int maxLen = 0 ;"}
{"text":"Initialize LIOES values for all indexes","code":"for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ;"}
{"text":"Compute optimized LIOES values in bottom up manner","code":"for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ;"}
{"text":"Pick maximum of all LIOES values","code":"for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;"}
{"text":"required maximum length","code":"return maxLen ; }"}
{"text":"driver function","code":"public static void main ( String argc [ ] ) { int [ ] arr = new int [ ] { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = 10 ; System . out . println ( \" Longest \u2581 Increasing \u2581 Odd \" + \" \u2581 Even \u2581 Subsequence : \u2581 \" + longOddEvenIncSeq ( arr , n ) ) ; } }"}
{"text":"Java program to get maximum and minimum values of an expression","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Utility method to check whether a character is operator or not","code":"static boolean isOperator ( char op ) { return ( op == ' + ' op == ' * ' ) ; }"}
{"text":"method prints minimum and maximum value obtainable from an expression","code":"static void printMinAndMaxValueOfExp ( String exp ) { Vector < Integer > num = new Vector < Integer > ( ) ; Vector < Character > opr = new Vector < Character > ( ) ; String tmp = \" \" ;"}
{"text":"store operator and numbers in different vectors","code":"for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp . charAt ( i ) ) ) { opr . add ( exp . charAt ( i ) ) ; num . add ( Integer . parseInt ( tmp ) ) ; tmp = \" \" ; } else { tmp += exp . charAt ( i ) ; } }"}
{"text":"storing last number in vector","code":"num . add ( Integer . parseInt ( tmp ) ) ; int len = num . size ( ) ; int [ ] [ ] minVal = new int [ len ] [ len ] ; int [ ] [ ] maxVal = new int [ len ] [ len ] ;"}
{"text":"initializing minval and maxval 2D array","code":"for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = Integer . MAX_VALUE ; maxVal [ i ] [ j ] = 0 ;"}
{"text":"initializing main diagonal by num values","code":"if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num . get ( i ) ; } }"}
{"text":"looping similar to matrix chain multiplication and updating both 2D arrays","code":"for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ;"}
{"text":"if current operator is ' + ' , updating tmp variable by addition","code":"if ( opr . get ( k ) == ' + ' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; }"}
{"text":"if current operator is ' * ' , updating tmp variable by multiplication","code":"else if ( opr . get ( k ) == ' * ' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; }"}
{"text":"updating array values by tmp variables","code":"if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } }"}
{"text":"last element of first row will store the result","code":"System . out . print ( \" Minimum \u2581 value \u2581 : \u2581 \" + minVal [ 0 ] [ len - 1 ] + \" , \u2581 Maximum \u2581 value \u2581 : \u2581 \" + maxVal [ 0 ] [ len - 1 ] ) ; }"}
{"text":"Driver code to test above methods","code":"public static void main ( String [ ] args ) { String expression = \"1 + 2*3 + 4*5\" ; printMinAndMaxValueOfExp ( expression ) ; } }"}
{"text":"A naive recursive implementation that simply follows the above optimal substructure property","code":"class MatrixChainMultiplication {"}
{"text":"Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n","code":"static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ;"}
{"text":"place parenthesis at different places between first and last matrix , recursively calculate count of multiplications for each parenthesis placement and return the minimum count","code":"for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; }"}
{"text":"Return minimum count","code":"return min ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , 1 , n - 1 ) ) ; } }"}
{"text":"Java program using memoization","code":"import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] dp = new int [ 100 ] [ 100 ] ;"}
{"text":"Function for matrix chain multiplication","code":"static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , n ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to flip bits of A and B which are set in both of them","code":"static void flipBitsOfAandB ( int A , int B ) {"}
{"text":"Clear the bits of A which are set in both A and B","code":"A = A ^ ( A & B ) ;"}
{"text":"Clear the bits of B which are set in both A and B","code":"B = B ^ ( A & B ) ;"}
{"text":"Print updated A and B","code":"System . out . print ( A + \" \u2581 \" + B ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate and return the hamming distance between all consecutive numbers from 0 to N","code":"static int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n \/ i > 0 ) { sum = sum + n \/ i ; i = i * 2 ; } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 9 ; System . out . println ( TotalHammingDistance ( N ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG { static final int m = 1000000007 ;"}
{"text":"Function to find the sum of all divisors of all numbers from 1 to N","code":"static void solve ( long n ) {"}
{"text":"Stores the sum","code":"long s = 0 ; for ( int l = 1 ; l <= n ; ) {"}
{"text":"Marks the last point of occurence with same count","code":"int r = ( int ) ( n \/ Math . floor ( n \/ l ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) \/ 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) \/ 2 ) % m ; int p = ( int ) ( ( n \/ l ) % m ) ;"}
{"text":"Calculate the sum","code":"s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; }"}
{"text":"Return the result","code":"System . out . print ( ( s + m ) % m ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { long n = 12 ; solve ( n ) ; } }"}
{"text":"Java program to find minimum time required to split a stick of N length into unit pieces","code":"import java . lang . * ; class GFG {"}
{"text":"Function to return the minimum time required to split stick of N into length into unit pieces","code":"static int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ;"}
{"text":"Return the minimum unit of time required","code":"return ( int ) Math . ceil ( Math . log ( N ) \/ Math . log ( 2 ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 100 ; System . out . print ( min_time_to_cut ( N ) ) ; } }"}
{"text":"Java implementation to count of distinct pair sum between two Array with values 1 to N","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the distinct sums","code":"static int findDistinctSums ( int n ) {"}
{"text":"Set to store distinct sums","code":"HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) {"}
{"text":"Inserting every sum","code":"s . add ( i + j ) ; } }"}
{"text":"Returning distinct sums","code":"return s . size ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } }"}
{"text":"Java program to print the triangle separated pattern using star and slash character","code":"class GFG {"}
{"text":"Function to print pattern recursively","code":"static int printPattern ( int i , int j , int n ) {"}
{"text":"Base Case","code":"if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; }"}
{"text":"Conditions to print slash","code":"if ( j == i j == n - 1 - i ) {"}
{"text":"Condition to print forword slash","code":"if ( i == n - 1 - j ) { System . out . print ( \" \/ \" ) ; }"}
{"text":"Condition to print backward slash","code":"else { System . out . print ( \" \\ \\\" ) ; } }"}
{"text":"Else print ' * '","code":"else { System . out . print ( \" * \" ) ; }"}
{"text":"Recursive call for rows","code":"if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } System . out . println ( ) ;"}
{"text":"Recursive call for changing the rows","code":"return printPattern ( i + 1 , 0 , n ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 9 ;"}
{"text":"Function Call","code":"printPattern ( 0 , 0 , N ) ; } }"}
{"text":"Java implementation for pattern searching in an array using Z - Algorithm","code":"import java . io . * ; import java . util . * ; class GfG {"}
{"text":"Function to calculate Z - Array","code":"private static int [ ] zArray ( int arr [ ] ) { int z [ ] ; int n = arr . length ; z = new int [ n ] ; int r = 0 , l = 0 ;"}
{"text":"Loop to calculate Z - Array","code":"for ( int k = 1 ; k < n ; k ++ ) {"}
{"text":"Outside the Z - box","code":"if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; }"}
{"text":"Inside Z - box","code":"else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; }"}
{"text":"Helper function to merge two arrays and create a single array","code":"private static int [ ] mergeArray ( int A [ ] , int B [ ] ) { int n = A . length ; int m = B . length ; int z [ ] ;"}
{"text":"Array to store merged array","code":"int c [ ] = new int [ n + m + 1 ] ;"}
{"text":"Copying array B","code":"for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ;"}
{"text":"Adding a separator","code":"c [ m ] = Integer . MAX_VALUE ;"}
{"text":"Copying array A","code":"for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ;"}
{"text":"Calling Z - function","code":"z = zArray ( c ) ; return z ; }"}
{"text":"Function to help compute the Z array","code":"private static void findZArray ( int A [ ] , int B [ ] , int n ) { int flag = 0 ; int z [ ] ; z = mergeArray ( A , B ) ;"}
{"text":"Printing indexes where array B occur","code":"for ( int i = 0 ; i < z . length ; i ++ ) { if ( z [ i ] == n ) { System . out . print ( ( i - n - 1 ) + \" \u2581 \" ) ; flag = 1 ; } } if ( flag == 0 ) { System . out . println ( \" Not \u2581 Found \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 3 , 2 , 3 , 2 } ; int B [ ] = { 2 , 3 } ; int n = B . length ; findZArray ( A , B , n ) ; } }"}
{"text":"Java implementation of the approach","code":"class GfG {"}
{"text":"Function to return the count of repetitions of string a to generate string b","code":"static int getCount ( String a , String b ) {"}
{"text":"If b cannot be generated by repeating a","code":"if ( b . length ( ) % a . length ( ) != 0 ) return - 1 ; int count = b . length ( ) \/ a . length ( ) ;"}
{"text":"Repeat a count number of times","code":"String str = \" \" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . equals ( b ) ) return count ; return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String a = \" geeks \" ; String b = \" geeksgeeks \" ; System . out . println ( getCount ( a , b ) ) ; } }"}
{"text":"JAVA program to Check if a given String can be formed from another String using given constraints","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if S2 can be formed of S1","code":"static boolean check ( String S1 , String S2 ) {"}
{"text":"length of Strings","code":"int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ;"}
{"text":"hash - table to store count","code":"HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;"}
{"text":"store count of each character","code":"for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . containsKey ( ( int ) S1 . charAt ( i ) ) ) { mp . put ( ( int ) S1 . charAt ( i ) , mp . get ( ( int ) S1 . charAt ( i ) ) + 1 ) ; } else { mp . put ( ( int ) S1 . charAt ( i ) , 1 ) ; } }"}
{"text":"traverse and check for every character","code":"for ( int i = 0 ; i < n2 ; i ++ ) {"}
{"text":"if the character of s2 is present in s1","code":"if ( mp . containsKey ( ( int ) S2 . charAt ( i ) ) ) { mp . put ( ( int ) S2 . charAt ( i ) , mp . get ( ( int ) S2 . charAt ( i ) ) - 1 ) ; }"}
{"text":"if the character of s2 is not present in S1 , then check if previous two ASCII characters are present in S1","code":"else if ( mp . containsKey ( S2 . charAt ( i ) - 1 ) && mp . containsKey ( S2 . charAt ( i ) - 2 ) ) { mp . put ( ( S2 . charAt ( i ) - 1 ) , mp . get ( S2 . charAt ( i ) - 1 ) - 1 ) ; mp . put ( ( S2 . charAt ( i ) - 2 ) , mp . get ( S2 . charAt ( i ) - 2 ) - 1 ) ; } else { return false ; } } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S1 = \" abbat \" ; String S2 = \" cat \" ;"}
{"text":"Calling function to check","code":"if ( check ( S1 , S2 ) ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } }"}
{"text":"Java program to calculate number of times the pattern occurred in given string","code":"public class GFG {"}
{"text":"Returns count of occurrences of \"1(0 + ) 1\" int str .","code":"static int countPattern ( String str ) { int len = str . length ( ) ; boolean oneSeen = false ;"}
{"text":"int count = 0 ; Initialize result","code":"for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ;"}
{"text":"Check if encountered '1' forms a valid pattern as specified","code":"if ( getChar == '1' && oneSeen == true ) { if ( str . charAt ( i - 1 ) == '0' ) count ++ ; }"}
{"text":"if 1 encountered for first time set oneSeen to 1","code":"if ( getChar == '1' && oneSeen == false ) oneSeen = true ;"}
{"text":"Check if there is any other character other than '0' or '1' . If so then set oneSeen to 0 to search again for new pattern","code":"if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false ; } return count ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { String str = \"100001abc101\" ; System . out . println ( countPattern ( str ) ) ; } }"}
{"text":"Java program for the above approach","code":"public class GFG {"}
{"text":"Function to check if it possible to make all the strings equal to the string T","code":"static String checkIfPossible ( int N , String [ ] arr , String T ) {"}
{"text":"Stores the frequency of all the strings in the array arr [ ]","code":"int [ ] freqS = new int [ 256 ] ;"}
{"text":"Stores the frequency of the string T","code":"int [ ] freqT = new int [ 256 ] ;"}
{"text":"Iterate over the characters of the string T","code":"for ( char ch : T . toCharArray ( ) ) { freqT [ ch - ' a ' ] ++ ; }"}
{"text":"Iterate in the range [ 0 , N - 1 ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Iterate over the characters of the string arr [ i ]","code":"for ( char ch : arr [ i ] . toCharArray ( ) ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) {"}
{"text":"If freqT [ i ] is 0 and freqS [ i ] is not 0","code":"if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return \" No \" ; }"}
{"text":"If freqS [ i ] is 0 and freqT [ i ] is not 0","code":"else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return \" No \" ; }"}
{"text":"If freqS [ i ] is not freqT [ i ] * N","code":"else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return \" No \" ; } }"}
{"text":"Otherwise , return \" Yes \"","code":"return \" Yes \" ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String [ ] arr = { \" abc \" , \" abb \" , \" acc \" } ; String T = \" abc \" ; int N = arr . length ; System . out . println ( checkIfPossible ( N , arr , T ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . Stack ; class GFG {"}
{"text":"Function to find the number of the groups of 1 s only in the binary string","code":"static int groupsOfOnes ( String S , int N ) {"}
{"text":"Stores number of groups of 1 s","code":"int count = 0 ;"}
{"text":"Initialization of the stack","code":"Stack < Integer > st = new Stack < > ( ) ;"}
{"text":"Traverse the string S","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If S [ i ] is '1'","code":"if ( S . charAt ( i ) == '1' ) st . push ( 1 ) ;"}
{"text":"Otherwise","code":"else {"}
{"text":"If st is empty","code":"if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } }"}
{"text":"If st is not empty","code":"if ( ! st . empty ( ) ) count ++ ;"}
{"text":"Return answer","code":"return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input","code":"String S = \"100110111\" ; int N = S . length ( ) ;"}
{"text":"Function call","code":"System . out . println ( groupsOfOnes ( S , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class Main {"}
{"text":"Function to print all palindromic strings of length 3 that can be formed using characters of string S","code":"static void generatePalindrome ( String S ) {"}
{"text":"Stores the count of character","code":"HashMap < Character , Integer > Hash = new HashMap < > ( ) ;"}
{"text":"Traverse the string S","code":"for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( Hash . containsKey ( S . charAt ( i ) ) ) Hash . put ( S . charAt ( i ) , Hash . get ( S . charAt ( i ) ) + 1 ) ; else Hash . put ( S . charAt ( i ) , 1 ) ; }"}
{"text":"Stores all palindromic strings","code":"TreeSet < String > st = new TreeSet < String > ( ) ;"}
{"text":"Iterate over the charchaters over the range [ ' a ' , ' z ' ]","code":"for ( char i = ' a ' ; i <= ' z ' ; i ++ ) {"}
{"text":"If Hash [ ch ] is equal to 2","code":"if ( Hash . containsKey ( i ) && Hash . get ( i ) == 2 ) {"}
{"text":"Iterate over the characters over the range [ ' a ' , ' z ' ]","code":"for ( char j = ' a ' ; j <= ' z ' ; j ++ ) {"}
{"text":"Stores all the palindromic string","code":"String s = \" \" ; if ( Hash . containsKey ( j ) && i != j ) { s += i ; s += j ; s += i ;"}
{"text":"Push the s into the set st","code":"st . add ( s ) ; } } }"}
{"text":"If Hash [ i ] is greater than or equal to 3","code":"if ( Hash . containsKey ( i ) && Hash . get ( i ) >= 3 ) {"}
{"text":"Iterate over charchaters over the range [ ' a ' , ' z ' ]","code":"for ( char j = ' a ' ; j <= ' z ' ; j ++ ) {"}
{"text":"Stores all the palindromic string","code":"String s = \" \" ;"}
{"text":"If Hash [ j ] is positive","code":"if ( Hash . containsKey ( j ) ) { s += i ; s += j ; s += i ;"}
{"text":"Push s into the set st","code":"st . add ( s ) ; } } } }"}
{"text":"Iterate over the set","code":"for ( String ans : st ) { System . out . println ( ans ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String S = \" ddabdac \" ; generatePalindrome ( S ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {"}
{"text":"Function to count occurrences of the string Y in the string S for every occurrence of X in S","code":"static void countOccurrences ( String S , String X , String Y ) {"}
{"text":"Stores the count of occurrences of X","code":"int count = 0 ;"}
{"text":"Stores the lengths of the three strings","code":"int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ;"}
{"text":"Traverse the string S","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If the current substring is Y , then increment the value of count by 1","code":"if ( S . substring ( i , Math . min ( N , i + B ) ) . equals ( Y ) ) count ++ ;"}
{"text":"If the current substring is X , then print the count","code":"if ( S . substring ( i , Math . min ( N , i + A ) ) . equals ( X ) ) System . out . print ( count + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" abcdefdefabc \" ; String X = \" abc \" ; String Y = \" def \" ; countOccurrences ( S , X , Y ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find whether the given String is Accepted by the DFA","code":"static void DFA ( String str , int N ) {"}
{"text":"If n <= 1 , then print No","code":"if ( N <= 1 ) { System . out . print ( \" No \" ) ; return ; }"}
{"text":"To count the matched characters","code":"int count = 0 ;"}
{"text":"Check if the first character is C","code":"if ( str . charAt ( 0 ) == ' C ' ) { count ++ ;"}
{"text":"Traverse the rest of String","code":"for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"If character is A or B , increment count by 1","code":"if ( str . charAt ( i ) == ' A ' || str . charAt ( i ) == ' B ' ) count ++ ; else break ; } } else {"}
{"text":"If the first character is not C , print - 1","code":"System . out . print ( \" No \" ) ; return ; }"}
{"text":"If all characters matches","code":"if ( count == N ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str = \" CAABBAAB \" ; int N = str . length ( ) ; DFA ( str , N ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the maximum and minimum number of digits to be removed to make str divisible by 3","code":"static void minMaxDigits ( String str , int N ) {"}
{"text":"Convert the string into array of digits","code":"int arr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str . charAt ( i ) - '0' ) % 3 ;"}
{"text":"Count of 0 s , 1 s , and 2 s","code":"int zero = 0 , one = 0 , two = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; }"}
{"text":"Find the sum of digits % 3","code":"int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; }"}
{"text":"Cases to find minimum number of digits to be removed","code":"if ( sum == 0 ) { System . out . print ( 0 + \" \u2581 \" ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) System . out . print ( 1 + \" \u2581 \" ) ; else if ( two > 1 && N > 2 ) System . out . print ( 2 + \" \u2581 \" ) ; else System . out . print ( - 1 + \" \u2581 \" ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) System . out . print ( 1 + \" \u2581 \" ) ; else if ( one > 1 && N > 2 ) System . out . print ( 2 + \" \u2581 \" ) ; else System . out . print ( - 1 + \" \u2581 \" ) ; }"}
{"text":"Cases to find maximum number of digits to be removed","code":"if ( zero > 0 ) System . out . print ( N - 1 + \" \u2581 \" ) ; else if ( one > 0 && two > 0 ) System . out . print ( N - 2 + \" \u2581 \" ) ; else if ( one > 2 two > 2 ) System . out . print ( N - 3 + \" \u2581 \" ) ; else System . out . print ( - 1 + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \"12345\" ; int N = str . length ( ) ;"}
{"text":"Function Call","code":"minMaxDigits ( str , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum number of changes to make the String K - periodic and palindrome","code":"static int findMinimumChanges ( int N , int K , char [ ] S ) {"}
{"text":"Initialize ans with 0","code":"int ans = 0 ;"}
{"text":"Iterate from 0 to ( K + 1 ) \/ 2","code":"for ( int i = 0 ; i < ( K + 1 ) \/ 2 ; i ++ ) {"}
{"text":"Store frequency of character","code":"HashMap < Character , Integer > mp = new HashMap < > ( ) ;"}
{"text":"Iterate through all indices , i , i + K , i + 2 k ... . and store the frequency of character","code":"for ( int j = i ; j < N ; j += K ) {"}
{"text":"Increase the frequency of current character","code":"if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } }"}
{"text":"Iterate through all indices K - i , 2 K - i , 3 K - i ... . and store the frequency of character","code":"for ( int j = N - i - 1 ; j >= 0 ; j -= K ) {"}
{"text":"If K is odd & i is samw as K \/ 2 , break the loop","code":"if ( K % 2 == 1 && i == K \/ 2 ) break ;"}
{"text":"Increase the frequency of current character","code":"if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } }"}
{"text":"Find the maximum frequency of a character among all visited characters","code":"int curr_max = Integer . MIN_VALUE ; for ( Map . Entry < Character , Integer > p : mp . entrySet ( ) ) { curr_max = Math . max ( curr_max , p . getValue ( ) ) ; }"}
{"text":"If K is odd and i is same as K \/ 2 then , only N \/ K characters is visited","code":"if ( ( K % 2 == 1 ) && i == K \/ 2 ) ans += ( N \/ K - curr_max ) ;"}
{"text":"Otherwise N \/ K * 2 characters has visited","code":"else ans += ( N \/ K * 2 - curr_max ) ; }"}
{"text":"Return the result","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" aabbcbbcb \" ; int N = S . length ( ) ; int K = 3 ;"}
{"text":"Function Call","code":"System . out . print ( findMinimumChanges ( N , K , S . toCharArray ( ) ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if any index contains more than K active characters","code":"static String checkString ( String s , int K ) { int n = s . length ( ) ;"}
{"text":"Store the last occurrence of each character in the map .","code":"Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( s . charAt ( i ) , i ) ; } int cnt = 0 , f = 0 ;"}
{"text":"Stores the active characters","code":"Set < Character > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Insert the character","code":"st . add ( s . charAt ( i ) ) ;"}
{"text":"If the size of set exceeds K","code":"if ( st . size ( ) > K ) { f = 1 ; break ; }"}
{"text":"Remove the character from set if i is the last index of the current character","code":"if ( mp . get ( s . charAt ( i ) ) == i ) st . remove ( s . charAt ( i ) ) ; } return ( f == 1 ? \" Yes \" : \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" aabbcdca \" ; int k = 2 ; System . out . println ( checkString ( s , k ) ) ; } }"}
{"text":"Java implementation to count the number of strings in the array whose distinct characters is less than or equal to M","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the strings whose distinct characters count is less than M","code":"public static void distinct ( String [ ] S , int M ) { int count = 0 ;"}
{"text":"Loop to iterate over all the strings of the array","code":"for ( int i = 0 ; i < S . length ; i ++ ) {"}
{"text":"Distinct characters in the String with the help of set","code":"Set < Character > set = new HashSet < > ( ) ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( ! set . contains ( S [ i ] . charAt ( j ) ) ) set . add ( S [ i ] . charAt ( j ) ) ; } int c = set . size ( ) ;"}
{"text":"Checking if its less than or equal to M","code":"if ( c <= M ) count += 1 ; } System . out . println ( count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S [ ] = { \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" } ; int M = 7 ; distinct ( S , M ) ; } }"}
{"text":"Java program to remove the characters having odd frequencies in the string","code":"import java . util . * ; class GFG {"}
{"text":"Function to remove the characters which have odd frequencies in the string","code":"static String removeOddFrequencyCharacters ( String s ) {"}
{"text":"Create a map to store the frequency of each character","code":"HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char p = s . charAt ( i ) ; Integer count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . put ( p , 1 ) ; } else m . put ( p , count + 1 ) ; }"}
{"text":"To store the new string","code":"String new_string = \" \" ;"}
{"text":"Remove the characters which have odd frequencies","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"If the character has odd frequency then skip","code":"if ( ( m . get ( s . charAt ( i ) ) & 1 ) == 1 ) continue ;"}
{"text":"Else concatenate the character to the new string","code":"new_string += s . charAt ( i ) ; }"}
{"text":"Return the modified string","code":"return new_string ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ;"}
{"text":"Remove the characters which have odd frequencies","code":"str = removeOddFrequencyCharacters ( str ) ; System . out . print ( str ) ; } }"}
{"text":"Java implementation to find product of elements at k - th level","code":"class GFG { static int i ;"}
{"text":"Recursive Function to find product of elements at k - th level","code":"static int productAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) {"}
{"text":"if subtree is null , just like if root == null","code":"if ( tree . charAt ( i ) == ' ) ' ) return 1 ; int product = 1 ;"}
{"text":"Consider only level k node to be part of the product","code":"if ( level == k ) product = tree . charAt ( i ) - '0' ;"}
{"text":"Recur for Left Subtree","code":"++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ;"}
{"text":"Recur for Right Subtree","code":"++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ;"}
{"text":"Taking care of ' ) ' after left and right subtree","code":"++ i ; return product * leftproduct * rightproduct ; } return Integer . MIN_VALUE ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) \" + \" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; i = 0 ; System . out . print ( productAtKthLevel ( tree , k , 0 ) ) ; } }"}
{"text":"Java program to print the most occurring character in an array of Strings","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the most occurring character","code":"static void findMostOccurringChar ( Vector < String > str ) {"}
{"text":"Creating a hash of size 26","code":"int [ ] hash = new int [ 26 ] ;"}
{"text":"For loop to iterate through every String of the array","code":"for ( int i = 0 ; i < str . size ( ) ; i ++ ) {"}
{"text":"For loop to iterate through every character of the String","code":"for ( int j = 0 ; j < str . get ( i ) . length ( ) ; j ++ ) {"}
{"text":"Incrementing the count of the character in the hash","code":"hash [ str . get ( i ) . charAt ( j ) - 97 ] ++ ; } }"}
{"text":"Finding the character with the maximum count","code":"int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } System . out . print ( ( char ) ( max + 97 ) + \"NEW_LINE\"); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Declaring Vector of String type","code":"Vector < String > str = new Vector < String > ( ) ; str . add ( \" animal \" ) ; str . add ( \" zebra \" ) ; str . add ( \" lion \" ) ; str . add ( \" giraffe \" ) ; findMostOccurringChar ( str ) ; } }"}
{"text":"Java implementation of the approach","code":"public class GFG {"}
{"text":"Function that returns true if num is palindrome","code":"public static boolean isPalindrome ( float num ) {"}
{"text":"Convert the given floating point number into a string","code":"String s = String . valueOf ( num ) ;"}
{"text":"Pointers pointing to the first and the last character of the string","code":"int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) {"}
{"text":"Not a palindrome","code":"if ( s . charAt ( low ) != s . charAt ( high ) ) return false ;"}
{"text":"Update the pointers","code":"low ++ ; high -- ; } return true ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { float n = 123.321f ; if ( isPalindrome ( n ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { final static int MAX = 26 ;"}
{"text":"Function to return the maximum number of times str1 can appear as a non - overlapping substring in str2","code":"static int maxSubStr ( char [ ] str1 , int len1 , char [ ] str2 , int len2 ) {"}
{"text":"str1 cannot never be substring of str2","code":"if ( len1 > len2 ) return 0 ;"}
{"text":"Store the frequency of the characters of str1","code":"int freq1 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ i ] = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ;"}
{"text":"Store the frequency of the characters of str2","code":"int freq2 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ i ] = 0 ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ;"}
{"text":"To store the required count of substrings","code":"int minPoss = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX ; i ++ ) {"}
{"text":"Current character doesn 't appear in str1","code":"if ( freq1 [ i ] == 0 ) continue ;"}
{"text":"Frequency of the current character in str1 is greater than its frequency in str2","code":"if ( freq1 [ i ] > freq2 [ i ] ) return 0 ;"}
{"text":"Update the count of possible substrings","code":"minPoss = Math . min ( minPoss , freq2 [ i ] \/ freq1 [ i ] ) ; } return minPoss ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str1 = \" geeks \" , str2 = \" gskefrgoekees \" ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; System . out . println ( maxSubStr ( str1 . toCharArray ( ) , len1 , str2 . toCharArray ( ) , len2 ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the number of ways to insert the bracket pairs","code":"static int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) \/ 12 ; return ways ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" ab \" ; int n = str . length ( ) ; System . out . println ( cntWays ( str , n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . * ; class GFG {"}
{"text":"Set to store all the Strings from the given array","code":"static Set < String > uSet = new HashSet < String > ( ) ;"}
{"text":"To store the required count","code":"static int minCnt = Integer . MAX_VALUE ;"}
{"text":"Recursive function to find the count of subStrings that can be splitted starting from the index start such that all the subStrings are present in the map","code":"static void findSubStr ( String str , int cnt , int start ) {"}
{"text":"All the chosen subStrings are present in the map","code":"if ( start == str . length ( ) ) {"}
{"text":"Update the minimum count of subStrings","code":"minCnt = Math . min ( cnt , minCnt ) ; }"}
{"text":"Starting from the subStrings of length 1 that start with the given index","code":"for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) {"}
{"text":"Get the subString","code":"String subStr = str . substring ( start , start + len ) ;"}
{"text":"If the subString is present in the set","code":"if ( uSet . contains ( subStr ) ) {"}
{"text":"Recursive call for the rest of the String","code":"findSubStr ( str , cnt + 1 , start + len ) ; } } }"}
{"text":"Function that inserts all the Strings from the given array in a set and calls the recursive function to find the minimum count of subStrings str can be splitted into that satisfy the given condition","code":"static void findMinSubStr ( String arr [ ] , int n , String str ) {"}
{"text":"Insert all the Strings from the given array in a set","code":"for ( int i = 0 ; i < n ; i ++ ) uSet . add ( arr [ i ] ) ;"}
{"text":"Find the required count","code":"findSubStr ( str , 0 , 0 ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String str = \"123456\" ; String arr [ ] = { \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" } ; int n = arr . length ; findMinSubStr ( arr , n , str ) ; System . out . print ( minCnt ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the count of required substrings","code":"static int countSubStr ( String s , int n ) { int c1 = 0 , c2 = 0 ;"}
{"text":"For every index of the string","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If the substring starting at the current index is \" geeks \"","code":"if ( i < n - 5 && \" geeks \" . equals ( s . substring ( i , i + 5 ) ) ) { c1 ++ ; }"}
{"text":"If the substring is \" for \"","code":"if ( i < n - 3 && \" for \" . equals ( s . substring ( i , i + 3 ) ) ) { c2 = c2 + c1 ; } } return c2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" geeksforgeeksisforgeeks \" ; int n = s . length ( ) ; System . out . println ( countSubStr ( s , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; public class Main { public static void main ( String [ ] args ) {"}
{"text":"Defining the string","code":"String string = \" { [ ( ) ] } [ ] \" ;"}
{"text":"Storing opening braces in list lst1","code":"char [ ] lst1 = { ' { ' , ' ( ' , ' [ ' } ;"}
{"text":"Storing closing braces in list lst2","code":"char [ ] lst2 = { ' } ' , ' ) ' , ' ] ' } ;"}
{"text":"Creating an empty list lst","code":"Vector < Character > lst = new Vector < Character > ( ) ;"}
{"text":"Creating dictionary to map closing braces to opening ones","code":"HashMap < Character , Character > Dict = new HashMap < > ( ) ; Dict . put ( ' ) ' , ' ( ' ) ; Dict . put ( ' } ' , ' { ' ) ; Dict . put ( ' ] ' , ' [ ' ) ; int a = 0 , b = 0 , c = 0 ;"}
{"text":"If first position of string contain any closing braces return 1","code":"if ( Arrays . asList ( lst2 ) . contains ( string . charAt ( 0 ) ) ) { System . out . println ( 1 ) ; } else { int k = 0 ;"}
{"text":"If characters of string are opening braces then append them in a list","code":"for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( Arrays . asList ( lst1 ) . contains ( string . charAt ( i ) ) ) { lst . add ( string . charAt ( i ) ) ; k = i + 2 ; } else {"}
{"text":"When size of list is 0 and new closing braces is encountered then print its index starting from 1","code":"if ( lst . size ( ) == 0 && Arrays . asList ( lst2 ) . contains ( string . charAt ( i ) ) ) { System . out . println ( ( i + 1 ) ) ; c = 1 ; break ; } else {"}
{"text":"As we encounter closing braces we map them with theircorresponding opening braces using dictionary and check if it is same as last opened braces ( last element in list ) if yes then we delete that elememt from list","code":"if ( lst . size ( ) > 0 && Dict . get ( string . charAt ( i ) ) == lst . get ( lst . size ( ) - 1 ) ) { lst . remove ( lst . size ( ) - 1 ) ; } else {"}
{"text":"Otherwise we return the index ( starting from 1 ) at which nesting is found wrong","code":"a = 1 ; break ; } } } }"}
{"text":"At end if the list is empty it means the string is perfectly nested","code":"if ( lst . size ( ) == 0 && c == 0 ) { System . out . println ( 0 ) ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { System . out . println ( k ) ; } } } }"}
{"text":"Java implementation of the above approach :","code":"public class GFG { static final int MAX = 26 ;"}
{"text":"Function to return the encrypted string","code":"static String encryptStr ( String str , int n , int x ) {"}
{"text":"Reduce x because rotation of length 26 is unnecessary","code":"x = x % MAX ; char arr [ ] = str . toCharArray ( ) ;"}
{"text":"calculate the frequency of characters","code":"int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If the frequency of current character is even then increment it by x","code":"if ( freq [ arr [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( arr [ i ] - ' a ' + x ) % MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; }"}
{"text":"Else decrement it by x","code":"else { int pos = ( arr [ i ] - ' a ' - x ) ; if ( pos < 0 ) pos += MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } }"}
{"text":"Return the count","code":"return String . valueOf ( arr ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" abcda \" ; int n = s . length ( ) ; int x = 3 ; System . out . println ( encryptStr ( s , n , x ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that returns true if it is possible to rearrange the characters of the string such that no two consecutive characters are same","code":"static boolean isPossible ( char [ ] str ) {"}
{"text":"To store the frequency of each of the character","code":"Map < Character , Integer > freq = new HashMap < > ( ) ;"}
{"text":"To store the maximum frequency so far","code":"int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } }"}
{"text":"If possible","code":"if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; if ( isPossible ( str . toCharArray ( ) ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to print the uncommon characters in the given string in sorted order","code":"static void printUncommon ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) {"}
{"text":"Converting character to ASCII code","code":"int ch = ( str1 . charAt ( i ) ) - ' a ' ;"}
{"text":"Bit operation","code":"a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) {"}
{"text":"Converting character to ASCII code","code":"int ch = ( str2 . charAt ( i ) ) - ' a ' ;"}
{"text":"Bit operation","code":"a2 = a2 | ( 1 << ch ) ; }"}
{"text":"XOR operation leaves only uncommon characters in the ans variable","code":"int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } ans = ans \/ 2 ; i ++ ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str1 = \" geeksforgeeks \" ; String str2 = \" geeksquiz \" ; printUncommon ( str1 , str2 ) ; } }"}
{"text":"Java program to find minimum number of reversals required to balance an expression","code":"class GFG {"}
{"text":"Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced .","code":"static int countMinReversals ( String expr ) { int len = expr . length ( ) ;"}
{"text":"length of expression must be even to make it balanced by using reversals .","code":"if ( len % 2 != 0 ) return - 1 ;"}
{"text":"To store number of reversals required .","code":"int ans = 0 ; int i ;"}
{"text":"To store number of unbalanced opening brackets .","code":"int open = 0 ;"}
{"text":"To store number of unbalanced closing brackets .","code":"int close = 0 ; for ( i = 0 ; i < len ; i ++ ) {"}
{"text":"If current bracket is open then increment open count .","code":"if ( expr . charAt ( i ) == ' { ' ) open ++ ;"}
{"text":"If current bracket is close , check if it balances opening bracket . If yes then decrement count of unbalanced opening bracket else increment count of closing bracket .","code":"else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close \/ 2 ) + ( open \/ 2 ) ;"}
{"text":"For the case : \" } { \" or when one closing and one opening bracket remains for pairing , then both need to be reversed .","code":"close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GfG {"}
{"text":"Function to return the total number of valid pairs","code":"static int totalPairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ;"}
{"text":"Count total number of even and odd ascii values for string s1","code":"for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( int ) s1 . charAt ( i ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ;"}
{"text":"Count total number of even and odd ascii values for string s2","code":"for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ( int ) s2 . charAt ( i ) % 2 != 0 ) a2 ++ ; else b2 ++ ; }"}
{"text":"Return total valid pairs","code":"return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s1 = \" geeks \" , s2 = \" for \" ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }"}
{"text":"Java program to find the number of occurrences of prefix which occurs maximum no . of time","code":"class GFG {"}
{"text":"Function to return the count of the required prefix","code":"static int prefixOccurrences ( String str ) { char c = str . charAt ( 0 ) ; int countc = 0 ;"}
{"text":"Find the frequency of first character of string","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String str = \" abbcdabbcd \" ; System . out . println ( prefixOccurrences ( str ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the minimum operations of the given type required to convert string s to string t","code":"static int minOperations ( String s , String t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Characters are already equal","code":"if ( s . charAt ( i ) == t . charAt ( i ) ) continue ;"}
{"text":"Increment count of 0 s","code":"if ( s . charAt ( i ) == '0' ) ct0 ++ ;"}
{"text":"Increment count of 1 s","code":"else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String s = \"010\" , t = \"101\" ; int n = s . length ( ) ; System . out . println ( minOperations ( s , t , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the decrypted string","code":"static String decryptString ( String str , int n ) {"}
{"text":"Initial jump will be 1","code":"int i = 0 , jump = 1 ; String decryptedStr = \" \" ; while ( i < n ) { decryptedStr += str . charAt ( i ) ; i += jump ;"}
{"text":"Increment jump by 1 with every character","code":"jump ++ ; } return decryptedStr ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeeeekkkksssss \" ; int n = str . length ( ) ; System . out . println ( decryptString ( str , n ) ) ; } }"}
{"text":"Java program to find which bit sequence to be flipped","code":"class GfG {"}
{"text":"Function to check which bit is to be flipped","code":"static char bitToBeFlipped ( String s ) {"}
{"text":"variable to store first and last character of string","code":"char last = s . charAt ( s . length ( ) - 1 ) ; char first = s . charAt ( 0 ) ;"}
{"text":"Check if first and last characters are equal , if yes , then return the character which is not at last","code":"if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } }"}
{"text":"else return last","code":"else if ( last != first ) { return last ; } return last ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \"1101011000\" ; System . out . println ( bitToBeFlipped ( s ) ) ; } }"}
{"text":"Java program to find Sum and product of Prime Frequencies of Characters in a String","code":"import java . util . * ; class GFG {"}
{"text":"Function to create Sieve to check primes","code":"static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) {"}
{"text":"false here indicates that it is not prime","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p , set them to non - prime","code":"for ( int i = p * 2 ; i < p_size ; i += p ) { prime [ i ] = false ; } } } }"}
{"text":"Function to find the sum of prime frequencies of the characters of the given string","code":"static void sumProdOfPrimeFreq ( char [ ] s ) { boolean [ ] prime = new boolean [ s . length + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , s . length + 1 ) ; int i , j ;"}
{"text":"map is used to store character frequencies","code":"Map < Character , Integer > mp = new HashMap < > ( ) ; for ( i = 0 ; i < s . length ; i ++ ) { mp . put ( s [ i ] , mp . get ( s [ i ] ) == null ? 1 : mp . get ( s [ i ] ) + 1 ) ; } int sum = 0 , product = 1 ;"}
{"text":"Traverse the map","code":"for ( Map . Entry < Character , Integer > it : mp . entrySet ( ) ) {"}
{"text":"If the frequency is prime","code":"if ( prime [ it . getValue ( ) ] ) { sum += it . getValue ( ) ; product *= it . getValue ( ) ; } } System . out . print ( \" Sum \u2581 = \u2581 \" + sum ) ; System . out . println ( \" Product = \" + product); }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ; sumProdOfPrimeFreq ( s . toCharArray ( ) ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . util . HashMap ; class GFG {"}
{"text":"Function that checks if the frequency of character are a factor or multiple of each other","code":"public static boolean multipleOrFactor ( String s1 , String s2 ) {"}
{"text":"map store frequency of each character","code":"HashMap < Character , Integer > m1 = new HashMap < > ( ) ; HashMap < Character , Integer > m2 = new HashMap < > ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( m1 . containsKey ( s1 . charAt ( i ) ) ) { int x = m1 . get ( s1 . charAt ( i ) ) ; m1 . put ( s1 . charAt ( i ) , ++ x ) ; } else m1 . put ( s1 . charAt ( i ) , 1 ) ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( m2 . containsKey ( s2 . charAt ( i ) ) ) { int x = m2 . get ( s2 . charAt ( i ) ) ; m2 . put ( s2 . charAt ( i ) , ++ x ) ; } else m2 . put ( s2 . charAt ( i ) , 1 ) ; } for ( HashMap . Entry < Character , Integer > entry : m1 . entrySet ( ) ) {"}
{"text":"if any frequency is 0 , then continue as condition is satisfied","code":"if ( ! m2 . containsKey ( entry . getKey ( ) ) ) continue ;"}
{"text":"if factor or multiple , then condition satisfied","code":"if ( m2 . get ( entry . getKey ( ) ) != null && ( m2 . get ( entry . getKey ( ) ) % entry . getValue ( ) == 0 || entry . getValue ( ) % m2 . get ( entry . getKey ( ) ) == 0 ) ) continue ;"}
{"text":"if condition not satisfied","code":"else return false ; } return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s1 = \" geeksforgeeks \" , s2 = \" geeks \" ; if ( multipleOrFactor ( s1 , s2 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function that removes the characters which have even frequencies in the string","code":"static void solve ( String s ) {"}
{"text":"create a map to store the frequency of each character","code":"HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; }"}
{"text":"to store the new string","code":"String new_string = \" \" ;"}
{"text":"remove the characters which have even frequencies","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"if the character has even frequency then skip","code":"if ( m . get ( s . charAt ( i ) ) % 2 == 0 ) continue ;"}
{"text":"else concatenate the character to the new string","code":"new_string = new_string + s . charAt ( i ) ; }"}
{"text":"display the modified string","code":"System . out . println ( new_string ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String s = \" aabbbddeeecc \" ;"}
{"text":"remove the characters which have even frequencies","code":"solve ( s ) ; } }"}
{"text":"Java implementation to remove all the palindromic words from the given sentence","code":"class GFG {"}
{"text":"function to check if ' str ' is palindrome","code":"static boolean isPalindrome ( String str ) { int i = 0 , j = str . length ( ) - 1 ;"}
{"text":"traversing from both the ends","code":"while ( i < j ) {"}
{"text":"not palindrome","code":"if ( str . charAt ( i ++ ) != str . charAt ( j -- ) ) return false ; }"}
{"text":"palindrome","code":"return true ; }"}
{"text":"function to remove all the palindromic words from the given sentence","code":"static String removePalinWords ( String str ) {"}
{"text":"' final _ str ' to store the final string and ' word ' to one by one store each word of ' str '","code":"String final_str = \" \" , word = \" \" ;"}
{"text":"add space at the end of ' str '","code":"str = str + \" \u2581 \" ; int n = str . length ( ) ;"}
{"text":"traversing ' str '","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"accumulating characters of the current word","code":"if ( str . charAt ( i ) != ' \u2581 ' ) word = word + str . charAt ( i ) ; else {"}
{"text":"if ' word ' is not palindrome then a add it to ' final _ str '","code":"if ( ! ( isPalindrome ( word ) ) ) final_str += word + \" \u2581 \" ;"}
{"text":"reset","code":"word = \" \" ; } }"}
{"text":"required final string","code":"return final_str ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" Text \u2581 contains \u2581 malayalam \u2581 and \u2581 level \u2581 words \" ; System . out . print ( removePalinWords ( str ) ) ; } }"}
{"text":"Java program to find the sum of elements present in all subsequences","code":"import java . io . * ; class GFG {"}
{"text":"Returns numeric value of a subsequence of s . The subsequence to be picked is decided using bit pattern of num ( We pick all those digits for which there is a set bit in num )","code":"static int findSubSequence ( String s , int num ) {"}
{"text":"Initialize the result","code":"int res = 0 ;"}
{"text":"till n != 0","code":"int i = 0 ; while ( num > 0 ) {"}
{"text":"if i - th bit is set then add this number","code":"if ( ( num & 1 ) == 1 ) res += s . charAt ( i ) - '0' ; i ++ ;"}
{"text":"right shift i","code":"num = num >> 1 ; } return res ; }"}
{"text":"function to find combined sum of all individual subsequence sum","code":"static int combinedSum ( String s ) {"}
{"text":"length of String","code":"int n = s . length ( ) ;"}
{"text":"stores the combined","code":"int c_sum = 0 ;"}
{"text":"2 ^ n - 1 subsequences","code":"int range = ( 1 << n ) - 1 ;"}
{"text":"loop for all subsequences","code":"for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ;"}
{"text":"returns the combined sum","code":"return c_sum ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { String s = \"123\" ; System . out . println ( combinedSum ( s ) ) ; } }"}
{"text":"Java Program to find the subsequence with each character occurring at least k times in string s","code":"class GFG { static final int MAX_CHAR = 26 ;"}
{"text":"Function to find the subsequence","code":"static void findSubsequence ( String str , int k ) {"}
{"text":"Taking an extra array to keep record for character count in s","code":"int a [ ] = new int [ MAX_CHAR ] ;"}
{"text":"Counting occurrences of all characters in str [ ]","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) a [ str . charAt ( i ) - ' a ' ] ++ ;"}
{"text":"Printing characters with count >= k in same order as they appear in str .","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( a [ str . charAt ( i ) - ' a ' ] >= k ) System . out . print ( str . charAt ( i ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int k = 2 ; findSubsequence ( \" geeksforgeeks \" , k ) ; } }"}
{"text":"Java program to convert a sentence to gOOGLE cASE .","code":"class GFG { static String convert ( String str ) {"}
{"text":"empty strings","code":"String w = \" \" , z = \" \" ;"}
{"text":"convert input string to upper case","code":"str = str . toUpperCase ( ) + \" \u2581 \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"checki if character is not a space and adding it to string w","code":"char ch = str . charAt ( i ) ; if ( ch != ' \u2581 ' ) w = w + ch ; else {"}
{"text":"converting first character to lower case and subsequent initial letter of another word to lower case","code":"z = z + ( Character . toLowerCase ( w . charAt ( 0 ) ) ) + w . substring ( 1 ) + \" \u2581 \" ; w = \" \" ; } } return z ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" I \u2581 got \u2581 intern \u2581 at \u2581 geeksforgeeks \" ; System . out . println ( convert ( str ) ) ; } }"}
{"text":"JAVA Program to Encrypt String with product of number of vowels and consonants in subString of size k","code":"class GFG {"}
{"text":"isVowel ( ) is a function that returns true for a vowel and false otherwise .","code":"static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; }"}
{"text":"function to Encrypt the String","code":"static String encryptString ( char [ ] s , int n , int k ) {"}
{"text":"cv to count vowel cc to count consonants","code":"int [ ] cv = new int [ n ] ; int [ ] cc = new int [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ;"}
{"text":"Counting prefix count of vowel and prefix count of consonants","code":"for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 1 : 0 ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 0 : 1 ) ; } String ans = \" \" ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += String . valueOf ( prod ) ;"}
{"text":"generating the encrypted String .","code":"for ( int i = k ; i < s . length ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += String . valueOf ( prod ) ; } return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; System . out . print ( encryptString ( s . toCharArray ( ) , n , k ) + \"NEW_LINE\"); } }"}
{"text":"Java program to count the number of occurrence of a word in the given string","code":"import java . io . * ; class GFG { static int countOccurrences ( String str , String word ) {"}
{"text":"split the string by spaces in a","code":"String a [ ] = str . split ( \" \u2581 \" ) ;"}
{"text":"search for pattern in a","code":"int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) {"}
{"text":"if match found increase count","code":"if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String str = \" GeeksforGeeks \u2581 A \u2581 computer \u2581 science \u2581 portal \u2581 for \u2581 geeks \u2581 \" ; String word = \" portal \" ; System . out . println ( countOccurrences ( str , word ) ) ; } }"}
{"text":"Java program to print initials of a name","code":"class initials { static void printInitials ( String name ) { if ( name . length ( ) == 0 ) return ;"}
{"text":"split the string using ' space ' and print the first character of every word","code":"String words [ ] = name . split ( \" \u2581 \" ) ; for ( String word : words ) { System . out . print ( Character . toUpperCase ( word . charAt ( 0 ) ) + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String name = \" prabhat \u2581 kumar \u2581 singh \" ; printInitials ( name ) ; } }"}
{"text":"Java program to print all permutations with respect to cases","code":"public class PermuteString {"}
{"text":"Function to generate permutations","code":"static void permute ( String input ) { int n = input . length ( ) ;"}
{"text":"Number of permutations is 2 ^ n","code":"int max = 1 << n ;"}
{"text":"Converting string to lower case","code":"input = input . toLowerCase ( ) ;"}
{"text":"Using all subsequences and permuting them","code":"for ( int i = 0 ; i < max ; i ++ ) { char combination [ ] = input . toCharArray ( ) ;"}
{"text":"If j - th bit is set , we convert it to upper case","code":"for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = ( char ) ( combination [ j ] - 32 ) ; }"}
{"text":"Printing current combination","code":"System . out . print ( combination ) ; System . out . print ( \" \u2581 \" ) ; } }"}
{"text":"Driver Program to test above function","code":"public static void main ( String [ ] args ) { permute ( \" ABC \" ) ; } }"}
{"text":"Java program for above implementation","code":"public class GFG {"}
{"text":"Method to print the string","code":"static void printString ( String str , char ch , int count ) { int occ = 0 , i ;"}
{"text":"If given count is 0 print the given string and return","code":"if ( count == 0 ) { System . out . println ( str ) ; return ; }"}
{"text":"Start traversing the string","code":"for ( i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"Increment occ if current char is equal to given character","code":"if ( str . charAt ( i ) == ch ) occ ++ ;"}
{"text":"Break the loop if given character has been occurred given no . of times","code":"if ( occ == count ) break ; }"}
{"text":"Print the string after the occurrence of given character given no . of times","code":"if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ;"}
{"text":"Otherwise string is empty","code":"else System . out . println ( \" Empty \u2581 string \" ) ; }"}
{"text":"Driver Method","code":"public static void main ( String [ ] args ) { String str = \" geeks \u2581 for \u2581 geeks \" ; printString ( str , ' e ' , 2 ) ; } }"}
{"text":"Java program to reverse order of vowels","code":"class GFG {"}
{"text":"utility function to check for vowel","code":"static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; }"}
{"text":"Function to reverse order of vowels","code":"static String reverseVowel ( String str ) {"}
{"text":"Start two indexes from two corners and move toward each other","code":"int i = 0 ; int j = str . length ( ) - 1 ; char [ ] str1 = str . toCharArray ( ) ; while ( i < j ) { if ( ! isVowel ( str1 [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str1 [ j ] ) ) { j -- ; continue ; }"}
{"text":"swapping","code":"char t = str1 [ i ] ; str1 [ i ] = str1 [ j ] ; str1 [ j ] = t ; i ++ ; j -- ; } String str2 = String . copyValueOf ( str1 ) ; return str2 ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { String str = \" hello \u2581 world \" ; System . out . println ( reverseVowel ( str ) ) ; } }"}
{"text":"Java program to count minimum palindromic subsequences to be removed to make an string empty .","code":"import java . io . * ; class GFG {"}
{"text":"A function to check if a string str is palindrome","code":"static boolean isPalindrome ( String str ) {"}
{"text":"Start from leftmost and rightmost corners of str","code":"int l = 0 ; int h = str . length ( ) - 1 ;"}
{"text":"Keep comparing characters while they are same","code":"while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }"}
{"text":"Returns count of minimum palindromic subseuqnces to be removed to make string empty","code":"static int minRemovals ( String str ) {"}
{"text":"If string is empty","code":"if ( str . charAt ( 0 ) == '') return 0 ;"}
{"text":"If string is palindrome","code":"if ( isPalindrome ( str ) ) return 1 ;"}
{"text":"If string is not palindrome","code":"return 2 ; }"}
{"text":"Driver code to test above","code":"public static void main ( String [ ] args ) { System . out . println ( minRemovals ( \"010010\" ) ) ; System . out . println ( minRemovals ( \"0100101\" ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Iterative function to calculate ( x ^ y ) % p in O ( log y )","code":"static int power ( int x , int y , int p ) {"}
{"text":"Initialize result","code":"int res = 1 ;"}
{"text":"Update x if it is >= p","code":"x = x % p ; while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with result","code":"if ( y % 2 == 1 ) res = ( res * x ) % p ;"}
{"text":"y must be even now y = y \/ 2","code":"y = y >> 1 ; x = ( x * x ) % p ; } return res ; }"}
{"text":"Function to return XXX ... . . ( N times ) % M","code":"static int findModuloByM ( int X , int N , int M ) {"}
{"text":"Return the mod by M of smaller numbers","code":"if ( N < 6 ) {"}
{"text":"Creating a string of N X 's","code":"String temp = \" \" ; for ( int i = 0 ; i < N ; i ++ ) temp = temp + ( char ) ( X + 48 ) ;"}
{"text":"Converting the string to int and calculating the modulo","code":"int res = Integer . parseInt ( temp ) % M ; return res ; }"}
{"text":"Checking the parity of N","code":"if ( N % 2 == 0 ) {"}
{"text":"Dividing the number into equal half","code":"int half = findModuloByM ( X , N \/ 2 , M ) % M ;"}
{"text":"Utilizing the formula for even N","code":"int res = ( half * power ( 10 , N \/ 2 , M ) + half ) % M ; return res ; } else {"}
{"text":"Dividing the number into equal half","code":"int half = findModuloByM ( X , N \/ 2 , M ) % M ;"}
{"text":"Utilizing the formula for odd N","code":"int res = ( half * power ( 10 , N \/ 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int X = 6 , N = 14 , M = 9 ;"}
{"text":"Print XXX ... ( N times ) % M","code":"System . out . println ( findModuloByM ( X , N , M ) ) ; } }"}
{"text":"Java approach for the above approach","code":"class GFG {"}
{"text":"Structure of the circle","code":"static class circle { double x ; double y ; double r ; public circle ( int x , int y , int r ) { this . x = x ; this . y = y ; this . r = r ; } }"}
{"text":"Utility function to check if given circles satisfy required criteria","code":"static boolean check ( circle C [ ] ) {"}
{"text":"Stores the distance between the centres of C1 and C2","code":"double C1C2 = Math . sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ;"}
{"text":"Stores the status if the given given criteria is satisfied or not","code":"boolean flag = false ;"}
{"text":"If C1C2 is less than the sum of the radii of the first 2 circles","code":"if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) {"}
{"text":"If C3 is the midpoint of the centres at C1 and C2","code":"if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) {"}
{"text":"Mark flag true","code":"flag = true ; } }"}
{"text":"Return flag","code":"return flag ; }"}
{"text":"Function to check if the given circles satisfy required criteria","code":"static boolean IsFairTriplet ( circle c [ ] ) { boolean f = false ;"}
{"text":"Check for the current combination of circles","code":"f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ;"}
{"text":"Check for the next combination","code":"f |= check ( c ) ; } return f ; } static void swap ( circle circle1 , circle circle2 ) { circle temp = circle1 ; circle1 = circle2 ; circle2 = temp ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { circle C [ ] = new circle [ 3 ] ; C [ 0 ] = new circle ( 0 , 0 , 8 ) ; C [ 1 ] = new circle ( 0 , 10 , 6 ) ; C [ 2 ] = new circle ( 0 , 5 , 5 ) ; if ( IsFairTriplet ( C ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the eccentricity of a hyperbola","code":"static double eccHyperbola ( double A , double B ) {"}
{"text":"Stores the squared ratio of major axis to minor axis","code":"double r = ( double ) B * B \/ A * A ;"}
{"text":"Increment r by 1","code":"r += 1 ;"}
{"text":"Return the square root of r","code":"return Math . sqrt ( r ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { double A = 3.0 , B = 2.0 ; System . out . print ( eccHyperbola ( A , B ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the area of cyclic quadrilateral","code":"static float calculateArea ( float A , float B , float C , float D ) {"}
{"text":"Stores the value of half of the perimeter","code":"float S = ( A + B + C + D ) \/ 2 ;"}
{"text":"Stores area of cyclic quadrilateral","code":"float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ;"}
{"text":"Return the resultant area","code":"return area ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; System . out . println ( calculateArea ( A , B , C , D ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to calculate ratio of a triangle inscribed in an ellipse to the triangle on the auxiliary circle","code":"static void triangleArea ( int a , int b ) {"}
{"text":"Stores the ratio of the semi - major to semi - minor axes","code":"double ratio = ( double ) b \/ a ;"}
{"text":"Print the ratio","code":"System . out . println ( ratio ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static class pair { float first , second ; pair ( float first , float second ) { this . first = first ; this . second = second ; } }"}
{"text":"Function to calculate the distance between a pair of points","code":"static float distance ( int m , int n , int p , int q ) { return ( float ) Math . sqrt ( Math . pow ( n - m , 2 ) + Math . pow ( q - p , 2 ) * 1.0 ) ; }"}
{"text":"Function to calculate the coordinates of the excenters of a triangle","code":"static void Excenters ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) {"}
{"text":"Length of the sides of the triangle","code":"float a = distance ( x2 , x3 , y2 , y3 ) ; float b = distance ( x3 , x1 , y3 , y1 ) ; float c = distance ( x1 , x2 , y1 , y2 ) ;"}
{"text":"Stores the coordinates of the excenters of the triangle","code":"pair [ ] excenter = new pair [ 4 ] ;"}
{"text":"For I1","code":"excenter [ 1 ] = new pair ( ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) \/ ( - a + b + c ) , ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) \/ ( - a + b + c ) ) ;"}
{"text":"For I2","code":"excenter [ 2 ] = new pair ( ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) \/ ( a - b + c ) , ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) \/ ( a - b + c ) ) ;"}
{"text":"For I3","code":"excenter [ 3 ] = new pair ( ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) \/ ( a + b - c ) , ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) \/ ( a + b - c ) ) ;"}
{"text":"Print the excenters of the triangle","code":"for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( ( int ) excenter [ i ] . first + \" \u2581 \" + ( int ) excenter [ i ] . second ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate height of the trapezoid","code":"static void findHeight ( float p1 , float p2 , float b , float c ) { float a = Math . max ( p1 , p2 ) - Math . min ( p1 , p2 ) ;"}
{"text":"Apply Heron 's formula","code":"float s = ( a + b + c ) \/ 2 ;"}
{"text":"Calculate the area","code":"float area = ( int ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;"}
{"text":"Calculate height of trapezoid","code":"float height = ( area * 2 ) \/ a ;"}
{"text":"Print the height","code":"System . out . print ( \" Height \u2581 is : \u2581 \" + height ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given a , b , p1 and p2","code":"float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; } }"}
{"text":"Java program to find nth icositetragonal number","code":"import java . util . * ; class GFG {"}
{"text":"Function to find icositetragonal number","code":"static int Icositetragonal_num ( int n ) {"}
{"text":"Formula to calculate nth icositetragonal number","code":"return ( 22 * n * n - 20 * n ) \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( Icositetragonal_num ( n ) ) ; n = 10 ; System . out . println ( Icositetragonal_num ( n ) ) ; } }"}
{"text":"Java Program to find the rea of the circle inscribed in a trapezoid having non - parallel sides m , n","code":"class GFG {"}
{"text":"Function to find area of circle inscribed in a trapezoid having non - parallel sides m , n","code":"static double area_of_circle ( int m , int n ) {"}
{"text":"radius of circle by the formula i . e . root ( m * n ) \/ 2 area of circle = ( 3.141 ) * ( R * * 2 )","code":"int square_of_radius = ( m * n ) \/ 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; int m = 30 ; System . out . println ( area_of_circle ( m , n ) ) ; } }"}
{"text":"Java implementation to find the area of the equilateral triangle inscribed in a circle of radius R","code":"class GFG {"}
{"text":"Function to find the area of equilateral triangle inscribed in a circle of radius R","code":"static double area ( int R ) {"}
{"text":"Base and Height of equilateral triangle","code":"double base = 1.732 * R ; double height = ( 1.5 ) * R ;"}
{"text":"Area using Base and Height","code":"double area = 0.5 * base * height ; return area ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int R = 7 ; System . out . println ( area ( R ) ) ; } }"}
{"text":"Java Program to find the biggest circle which can be inscribed within the semicircle","code":"class GFG {"}
{"text":"Function to find the area of the circle","code":"static float circlearea ( float R ) {"}
{"text":"Radius cannot be negative","code":"if ( R < 0 ) return - 1 ;"}
{"text":"Area of the largest circle","code":"float a = ( float ) ( ( 3.14 * R * R ) \/ 4 ) ; return a ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float R = 2 ; System . out . println ( circlearea ( R ) ) ; } }"}
{"text":"Java program to Number of pairs of lines having integer intersection points","code":"class GFG {"}
{"text":"Count number of pairs of lines having integer intersection point","code":"static int countPairs ( int [ ] P , int [ ] Q , int N , int M ) {"}
{"text":"Initialize arrays to store counts","code":"int [ ] A = new int [ 2 ] , B = new int [ 2 ] ;"}
{"text":"Count number of odd and even Pi","code":"for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ;"}
{"text":"Count number of odd and even Qi","code":"for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ;"}
{"text":"Return the count of pairs","code":"return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] P = { 1 , 3 , 2 } ; int [ ] Q = { 3 , 0 } ; int N = P . length ; int M = Q . length ; System . out . print ( countPairs ( P , Q , N , M ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to count maximum number of intersections possible","code":"static int countIntersections ( int n ) { return n * ( n - 1 ) \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntersections ( n ) ) ; } }"}
{"text":"Java implementation of above approach","code":"public class GFG { static double PI = 3.14159 ;"}
{"text":"Function to return the area of triangle BCD","code":"static double areaOfTriangle ( float d ) {"}
{"text":"Using Golden ratio","code":"float c = ( float ) ( 1.618 * d ) ; float s = ( d + c + c ) \/ 2 ;"}
{"text":"Calculate area of triangle BCD","code":"double area = Math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ;"}
{"text":"Return area of all 5 triangle are same","code":"return 5 * area ; }"}
{"text":"Function to return the area of regular pentagon","code":"static double areaOfRegPentagon ( float d ) {"}
{"text":"Calculate the area of regular pentagon using above formula","code":"double cal = 4 * Math . tan ( PI \/ 5 ) ; double area = ( 5 * d * d ) \/ cal ;"}
{"text":"Return area of regular pentagon","code":"return area ; }"}
{"text":"Function to return the area of pentagram","code":"static double areaOfPentagram ( float d ) {"}
{"text":"Area of a pentagram is equal to the area of regular pentagon and five times the area of Triangle","code":"return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float d = 5 ; System . out . println ( areaOfPentagram ( d ) ) ; } }"}
{"text":"Java program to find the angle subtended by the chord to the centre of the circle when the angle subtended by another equal chord of a congruent circle is given","code":"import java . io . * ; class GFG { static void anglequichord ( int z ) { System . out . println ( \" The \u2581 angle \u2581 is \u2581 \" + z + \" \u2581 degrees \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int z = 48 ; anglequichord ( z ) ; } }"}
{"text":"Java program to convert the digits of a number to its ASCII values","code":"import java . util . * ; class GFG {"}
{"text":"Function to convert digits of N to respective ASCII values","code":"static void convertToASCII ( int N ) { String num = Integer . toString ( N ) ; for ( char ch : num . toCharArray ( ) ) { System . out . print ( ch + \" \u2581 ( \" + ( int ) ch + \")NEW_LINE\"); } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 36 ; convertToASCII ( N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to form product array with O ( n ) time and O ( 1 ) space","code":"static void productExceptSelf ( int arr [ ] , int N ) {"}
{"text":"Stores the product of array","code":"int product = 1 ;"}
{"text":"Stores the count of zeros","code":"int z = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If arr [ i ] is not zero","code":"if ( arr [ i ] != 0 ) product *= arr [ i ] ;"}
{"text":"If arr [ i ] is zero then increment count of z by 1","code":"if ( arr [ i ] == 0 ) z += 1 ; }"}
{"text":"Stores the absolute value of the product","code":"int a = Math . abs ( product ) ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If Z is equal to 1","code":"if ( z == 1 ) {"}
{"text":"If arr [ i ] is not zero","code":"if ( arr [ i ] != 0 ) arr [ i ] = 0 ;"}
{"text":"Else","code":"else arr [ i ] = product ; continue ; }"}
{"text":"If count of 0 s at least 2","code":"else if ( z > 1 ) {"}
{"text":"Assign arr [ i ] = 0","code":"arr [ i ] = 0 ; continue ; }"}
{"text":"Store absolute value of arr [ i ]","code":"int b = Math . abs ( arr [ i ] ) ;"}
{"text":"Find the value of a \/ b","code":"int curr = ( int ) Math . round ( Math . exp ( Math . log ( a ) - Math . log ( b ) ) ) ;"}
{"text":"If arr [ i ] and product both are less than zero","code":"if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ;"}
{"text":"If arr [ i ] and product both are greater than zero","code":"else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ;"}
{"text":"Else","code":"else arr [ i ] = - 1 * curr ; }"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int N = arr . length ;"}
{"text":"Function Call","code":"productExceptSelf ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to count of subarrays made up of single digit integers only","code":"static void singleDigitSubarrayCount ( int arr [ ] , int N ) {"}
{"text":"Stores count of subarrays","code":"int res = 0 ;"}
{"text":"Stores the count of consecutive single digit numbers in the array","code":"int count = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) {"}
{"text":"Increment size of block by 1","code":"count ++ ;"}
{"text":"Increment res by count","code":"res += count ; } else {"}
{"text":"Assign count = 0","code":"count = 0 ; } } System . out . print ( res ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ;"}
{"text":"Size of the array","code":"int N = arr . length ; singleDigitSubarrayCount ( arr , N ) ; } }"}
{"text":"Java program of the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if the number N can be expressed as sum of 2 or more consecutive numbers or not","code":"static int isPossible ( int N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; }"}
{"text":"Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers","code":"static void countElements ( int N ) {"}
{"text":"Stores the required count","code":"int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } System . out . println ( count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 15 ; countElements ( N ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers","code":"static void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ;"}
{"text":"Count powers of 2 up to N","code":"while ( Cur_Ele <= N ) {"}
{"text":"Increment count","code":"Count ++ ;"}
{"text":"Update current power of 2","code":"Cur_Ele = Cur_Ele * 2 ; } System . out . print ( N - Count ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 15 ; countElements ( N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate maximum difference between adjacent elements excluding every array element once","code":"static void maxAdjacent ( int [ ] arr , int N ) { Vector < Integer > res = new Vector < Integer > ( ) ; int arr_max = Integer . MIN_VALUE ;"}
{"text":"Compute maximum adjacent difference for whole array","code":"for ( int i = 1 ; i < N ; i ++ ) { arr_max = Math . max ( arr_max , Math . abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ;"}
{"text":"Store the maximum between arr_max and curr_max","code":"int ans = Math . max ( curr_max , arr_max ) ;"}
{"text":"Append the result into a vector","code":"res . add ( ans ) ; }"}
{"text":"Print the result","code":"for ( int x : res ) System . out . print ( x + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to find min operations to make even and odd count equal","code":"static int minimumIncrement ( int arr [ ] , int N ) {"}
{"text":"Odd size will never make odd and even counts equal","code":"if ( N % 2 != 0 ) { System . out . println ( \" - 1\" ) ; System . exit ( 0 ) ; }"}
{"text":"Stores the count of even numbers in the array arr [ ]","code":"int cntEven = 0 ;"}
{"text":"Stores count of odd numbers in the array arr [ ]","code":"int cntOdd = 0 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If arr [ i ] is an even number","code":"if ( arr [ i ] % 2 == 0 ) {"}
{"text":"Update cntEven","code":"cntEven += 1 ; } }"}
{"text":"Odd numbers in arr [ ]","code":"cntOdd = N - cntEven ;"}
{"text":"Return absolute difference divided by 2","code":"return Math . abs ( cntEven - cntOdd ) \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = arr . length ;"}
{"text":"Function call","code":"System . out . println ( minimumIncrement ( arr , N ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find count the ways to construct an array , B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 and product of elements of B [ ] is even","code":"static void cntWaysConsArray ( int A [ ] , int N ) {"}
{"text":"Stores count of arrays B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1","code":"int total = 1 ;"}
{"text":"Stores count of arrays B [ ] whose product of elements is not even","code":"int oddArray = 1 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update total","code":"total = total * 3 ;"}
{"text":"If A [ i ] is an even number","code":"if ( A [ i ] % 2 == 0 ) {"}
{"text":"Update oddArray","code":"oddArray *= 2 ; } }"}
{"text":"Print 3 ^ N - 2 ^ X","code":"System . out . println ( total - oddArray ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 } ; int N = A . length ; cntWaysConsArray ( A , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to count the numbers in the range [ 1 , N ] whose rightmost set bit is K","code":"static void countNumberHavingKthBitSet ( int N , int K ) {"}
{"text":"Stores the number whose rightmost set bit is K","code":"int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) {"}
{"text":"Numbers whose rightmost set bit is i","code":"int numbers_rightmost_bit_i = ( N + 1 ) \/ 2 ;"}
{"text":"Subtracting the number whose rightmost set bit is i , from N","code":"N -= numbers_rightmost_bit_i ;"}
{"text":"Since i = k , then the number whose rightmost set bit is K is stored","code":"if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } System . out . println ( numbers_rightmost_setbit_K ) ; }"}
{"text":"Driver Code","code":"static public void main ( String args [ ] ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count set bits in binary representation of number N","code":"static int countSetBits ( int N ) { int count = 0 ;"}
{"text":"Count set bits in N","code":"while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; }"}
{"text":"Return the final count","code":"return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 ; int bits = countSetBits ( N ) ;"}
{"text":"Print odd Binomial coefficients","code":"System . out . println ( \" Odd \u2581 \" + \" : \u2581 \" + ( int ) ( Math . pow ( 2 , bits ) ) ) ;"}
{"text":"Print even Binomial coefficients","code":"System . out . println ( \" Even \u2581 \" + \" : \u2581 \" + ( N + 1 - ( int ) ( Math . pow ( 2 , bits ) ) ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the minimum number of replacements required to make all array elements even","code":"static void minMoves ( int arr [ ] , int N ) {"}
{"text":"Stores the count of odd elements","code":"int odd_element_cnt = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Increase count of odd elements","code":"if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } }"}
{"text":"Store number of replacements required","code":"int moves = ( odd_element_cnt ) \/ 2 ;"}
{"text":"Two extra moves will be required to make the last odd element even","code":"if ( odd_element_cnt % 2 != 0 ) moves += 2 ;"}
{"text":"Print the minimum replacements","code":"System . out . print ( moves ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = arr . length ;"}
{"text":"Function call","code":"minMoves ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to partition squares of N natural number in two subset","code":"static void minimumSubsetDifference ( int N ) {"}
{"text":"Store the count of blocks of size 8","code":"int blockOfSize8 = N \/ 8 ;"}
{"text":"Partition of block of 8 element","code":"String str = \" ABBABAAB \" ;"}
{"text":"Store the minimum subset difference","code":"int subsetDifference = 0 ;"}
{"text":"Partition of N elements to minimize their subset sum difference","code":"String partition = \" \" ; while ( blockOfSize8 -- > 0 ) { partition += str ; }"}
{"text":"Store elements of subset A and B","code":"int A [ ] = new int [ N ] ; int B [ ] = new int [ N ] ; int x = 0 , y = 0 ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If element is of type A","code":"if ( partition . charAt ( i ) == ' A ' ) { A [ x ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; }"}
{"text":"If the element is of type B","code":"else { B [ y ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } }"}
{"text":"Print the minimum subset difference","code":"System . out . println ( subsetDifference ) ;"}
{"text":"Print the first subset","code":"for ( int i = 0 ; i < x ; i ++ ) System . out . print ( A [ i ] + \" \u2581 \" ) ; System . out . println ( ) ;"}
{"text":"Print the second subset","code":"for ( int i = 0 ; i < y ; i ++ ) System . out . print ( B [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 8 ;"}
{"text":"Function Call","code":"minimumSubsetDifference ( N ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the largest number X such that it divides P but is not divisible by Q","code":"static void findTheGreatestX ( int P , int Q ) {"}
{"text":"Stores the frequency count of of all Prime Factors","code":"HashMap < Integer , Integer > divisiors = new HashMap < > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q \/= i ;"}
{"text":"Increment the frequency of the current prime factor","code":"if ( divisiors . containsKey ( i ) ) { divisiors . put ( i , divisiors . get ( i ) + 1 ) ; } else { divisiors . put ( i , 1 ) ; } } }"}
{"text":"If Q is a prime factor","code":"if ( Q > 1 ) if ( divisiors . containsKey ( Q ) ) { divisiors . put ( Q , divisiors . get ( Q ) + 1 ) ; } else { divisiors . put ( Q , 1 ) ; }"}
{"text":"Stores the desired result","code":"int ans = 0 ;"}
{"text":"Iterate through all divisors of Q","code":"for ( Map . Entry < Integer , Integer > i : divisiors . entrySet ( ) ) { int frequency = i . getValue ( ) ; int temp = P ;"}
{"text":"Stores the frequency count of current prime divisor on dividing P","code":"int cur = 0 ; while ( temp % i . getKey ( ) == 0 ) { temp \/= i . getKey ( ) ;"}
{"text":"Count the frequency of the current prime factor","code":"cur ++ ; }"}
{"text":"If cur is less than frequency then P is the final result","code":"if ( cur < frequency ) { ans = P ; break ; } temp = P ;"}
{"text":"Iterate to get temporary answer","code":"for ( int j = cur ; j >= frequency ; j -- ) { temp \/= i . getKey ( ) ; }"}
{"text":"Update current answer","code":"ans = Math . max ( temp , ans ) ; }"}
{"text":"Print the desired result","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given P and Q","code":"int P = 10 , Q = 4 ;"}
{"text":"Function Call","code":"findTheGreatestX ( P , Q ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if there is any row where number of unique elements are greater than 1","code":"static String checkRearrangements ( int [ ] [ ] mat , int N , int M ) {"}
{"text":"Iterate over the matrix","code":"for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) { return \" Yes \" ; } } } return \" No \" ; }"}
{"text":"Function to check if it is possible to rearrange mat [ ] [ ] such that XOR of its first column is non - zero","code":"static String nonZeroXor ( int [ ] [ ] mat , int N , int M ) { int res = 0 ;"}
{"text":"Find bitwise XOR of the first column of mat [ ] [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i ] [ 0 ] ; }"}
{"text":"If bitwise XOR of the first column of mat [ ] [ ] is non - zero","code":"if ( res != 0 ) return \" Yes \" ;"}
{"text":"Otherwise check rearrangements","code":"else return checkRearrangements ( mat , N , M ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Matrix mat [ ] [ ]","code":"int [ ] [ ] mat = { { 1 , 1 , 2 } , { 2 , 2 , 2 } , { 3 , 3 , 3 } } ; int N = mat . length ; int M = mat [ 0 ] . length ;"}
{"text":"Function Call","code":"System . out . print ( nonZeroXor ( mat , N , M ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG { static final int size_int = 32 ;"}
{"text":"Function to maximize the value for the given function and the array elements","code":"static int functionMax ( int arr [ ] , int n ) {"}
{"text":"Vector array to maintain which bit is set for which integer in the given array by saving index of that integer","code":"Vector < Integer > [ ] setBit = new Vector [ 32 + 1 ] ; for ( int i = 0 ; i < setBit . length ; i ++ ) setBit [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) {"}
{"text":"Check if j - th bit is set for i - th integer","code":"if ( ( arr [ i ] & ( 1 << j ) ) > 0 )"}
{"text":"Push the index of that integer in setBit [ j ]","code":"setBit [ j ] . add ( i ) ; } }"}
{"text":"Find the element having highest significant set bit unset in other elements","code":"for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) {"}
{"text":"Place that integer at 0 - th index","code":"swap ( arr , 0 , setBit [ i ] . get ( 0 ) ) ; break ; } }"}
{"text":"Store the maximum AND value","code":"int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; }"}
{"text":"Return the answer","code":"return maxAnd ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = arr . length ;"}
{"text":"Function call","code":"System . out . print ( functionMax ( arr , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function returns nCr i . e . Binomial Coefficient","code":"static int nCr ( int n , int r ) {"}
{"text":"Initialize res with 1","code":"int res = 1 ;"}
{"text":"Since C ( n , r ) = C ( n , n - r )","code":"if ( r > n - r ) r = n - r ;"}
{"text":"Evaluating expression","code":"for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Function to calculate and return the sum of the products","code":"static int solve ( int n , int m , int k ) {"}
{"text":"Initialize sum to 0","code":"int sum = 0 ;"}
{"text":"Traverse from 0 to k","code":"for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( solve ( n , m , k ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to return a ^ n","code":"static int powerOptimised ( int a , int n ) {"}
{"text":"Stores final answer","code":"int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ;"}
{"text":"Check if current LSB is set","code":"if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ;"}
{"text":"Right shift","code":"n = n >> 1 ; } return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a = 3 , n = 5 ; System . out . print ( powerOptimised ( a , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the integer M such that gcd ( N , M ) is maximum","code":"static int findMaximumGcd ( int n ) {"}
{"text":"Initialize a variable","code":"int max_gcd = 1 ;"}
{"text":"Find all the divisors of N and return the maximum divisor","code":"for ( int i = 1 ; i * i <= n ; i ++ ) {"}
{"text":"Check if i is divisible by N","code":"if ( n % i == 0 ) {"}
{"text":"Update max_gcd","code":"if ( i > max_gcd ) max_gcd = i ; if ( ( n \/ i != i ) && ( n \/ i != n ) && ( ( n \/ i ) > max_gcd ) ) max_gcd = n \/ i ; } }"}
{"text":"Return the maximum value","code":"return max_gcd ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given Number","code":"int N = 10 ;"}
{"text":"Function Call","code":"System . out . print ( findMaximumGcd ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static final int x = 2000021 ;"}
{"text":"For storing smallest prime factor","code":"static int [ ] v = new int [ x ] ;"}
{"text":"Function consmallest prime factor array","code":"static void sieve ( ) { v [ 1 ] = 1 ;"}
{"text":"Mark smallest prime factor for every number to be itself .","code":"for ( int i = 2 ; i < x ; i ++ ) v [ i ] = i ;"}
{"text":"Separately mark spf for every even number as 2","code":"for ( int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( int i = 3 ; i * i < x ; i ++ ) {"}
{"text":"Check if i is prime","code":"if ( v [ i ] == i ) {"}
{"text":"Mark SPF for all numbers divisible by i","code":"for ( int j = i * i ; j < x ; j += i ) {"}
{"text":"Mark spf [ j ] if it is not previously marked","code":"if ( v [ j ] == j ) { v [ j ] = i ; } } } } }"}
{"text":"Function for counts total number of prime factors","code":"static int prime_factors ( int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; while ( n != 1 ) { s . add ( v [ n ] ) ; n = n \/ v [ n ] ; } return s . size ( ) ; }"}
{"text":"Function to print elements of sets of K consecutive elements having K prime factors","code":"static void distinctPrimes ( int m , int k ) {"}
{"text":"To store the result","code":"Vector < Integer > result = new Vector < Integer > ( ) ; for ( int i = 14 ; i < m + k ; i ++ ) {"}
{"text":"Count number of prime factors of number","code":"long count = prime_factors ( i ) ;"}
{"text":"If number has exactly K factors push in result [ ]","code":"if ( count == k ) { result . add ( i ) ; } } int p = result . size ( ) ; for ( int index = 0 ; index < p - 1 ; index ++ ) { long element = result . get ( index ) ; int count = 1 , z = index ;"}
{"text":"Iterate till we get K consecutive elements in result [ ]","code":"while ( z < p - 1 && count <= k && result . get ( z ) + 1 == result . get ( z + 1 ) ) {"}
{"text":"Count sequence until K","code":"count ++ ; z ++ ; }"}
{"text":"Print the element if count >= K","code":"if ( count >= k ) System . out . print ( element + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"To construct spf [ ]","code":"sieve ( ) ;"}
{"text":"Given N and K","code":"int N = 1000 , K = 3 ;"}
{"text":"Function call","code":"distinctPrimes ( N , K ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to multiply Complex Numbers with just three multiplications","code":"static void print_product ( int a , int b , int c , int d ) {"}
{"text":"Find value of prod1 , prod2 and prod3","code":"int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ;"}
{"text":"Real Part","code":"int real = prod1 - prod2 ;"}
{"text":"Imaginary Part","code":"int imag = prod3 - ( prod1 + prod2 ) ;"}
{"text":"Print the result","code":"System . out . println ( real + \" \u2581 + \u2581 \" + imag + \" i \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given four numbers","code":"int a = 2 ; int b = 3 ; int c = 4 ; int d = 5 ;"}
{"text":"Function call","code":"print_product ( a , b , c , d ) ; } }"}
{"text":"Java implementation for the above approach","code":"class GFG {"}
{"text":"Function to check if a number is an Insolite numbers","code":"static boolean isInsolite ( int n ) { int N = n ;"}
{"text":"To store sum of squares of digits","code":"int sum = 0 ;"}
{"text":"To store product of squares of digits","code":"int product = 1 ; while ( n != 0 ) {"}
{"text":"extracting digit","code":"int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n \/ 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 111 ;"}
{"text":"Function Call","code":"if ( isInsolite ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java implementation to check if a number is Superabundant","code":"class GFG {"}
{"text":"Function to calculate the sum of all divisors of a given number","code":"static int sigma ( int n ) { if ( n == 1 ) return 1 ;"}
{"text":"Sum of divisors","code":"int result = 0 ;"}
{"text":"Find all divisors which divides ' num '","code":"for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) {"}
{"text":"If ' i ' is divisor of ' n '","code":"if ( n % i == 0 ) {"}
{"text":"If both divisors are same then add it once else add both","code":"if ( i == ( n \/ i ) ) result += i ; else result += ( i + n \/ i ) ; } }"}
{"text":"Add 1 and n to result as above loop considers proper divisors greater than 1.","code":"return ( result + n + 1 ) ; }"}
{"text":"Function to check if N is a superabundant number","code":"static boolean isSuperabundant ( int N ) {"}
{"text":"To check all numbers from 1 to N","code":"for ( double i = 1 ; i < N ; i ++ ) { double x = sigma ( ( int ) ( i ) ) \/ i ; double y = sigma ( ( int ) ( N ) ) \/ ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 ; if ( isSuperabundant ( N ) ) System . out . print ( \"YesNEW_LINE\"); else System . out . print ( \"NoNEW_LINE\"); } }"}
{"text":"Java implementation for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the N - th icosikaipentagon number","code":"static boolean isDNum ( int n ) {"}
{"text":"Number should be greater than 3","code":"if ( n < 4 ) return false ; int numerator = 0 , hcf = 0 ;"}
{"text":"Check every k in range 2 to n - 1","code":"for ( int k = 2 ; k <= n ; k ++ ) { numerator = ( int ) ( Math . pow ( k , n - 2 ) - k ) ; hcf = __gcd ( n , k ) ; }"}
{"text":"Condition for D - Number","code":"if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 15 ; boolean a = isDNum ( n ) ; if ( a ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to find prime divisors of all numbers from 1 to N","code":"static int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) {"}
{"text":"if the number is prime","code":"if ( SumOfPrimeDivisors [ i ] == 1 ) {"}
{"text":"add this prime to all it 's multiples","code":"for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }"}
{"text":"Function to check Ruth - Aaron number","code":"static boolean RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 714 ; if ( RuthAaronNumber ( N ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }"}
{"text":"Java program to maximize the sum of absolute differences between adjacent elements","code":"import java . util . * ; class GFG {"}
{"text":"Function for maximising the sum","code":"static int maxAdjacentDifference ( int N , int K ) {"}
{"text":"Difference is 0 when only one element is present in array","code":"if ( N == 1 ) { return 0 ; }"}
{"text":"Difference is K when two elements are present in array","code":"if ( N == 2 ) { return K ; }"}
{"text":"Otherwise","code":"return 2 * K ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 6 ; int K = 11 ; System . out . print ( maxAdjacentDifference ( N , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG { static final int mod = 1000000007 ;"}
{"text":"Functions returns sum of numbers from 1 to n","code":"public static int linearSum ( int n ) { return ( n * ( n + 1 ) \/ 2 ) % mod ; }"}
{"text":"Functions returns sum of numbers from a + 1 to b","code":"public static int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; }"}
{"text":"Function returns total sum of divisors","code":"public static int totalSum ( int n ) {"}
{"text":"Stores total sum","code":"int result = 0 ; int i = 1 ;"}
{"text":"Finding numbers and its occurence","code":"while ( true ) {"}
{"text":"Sum of product of each number and its occurence","code":"result += rangeSum ( n \/ i , n \/ ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n \/ ( n \/ ( i + 1 ) ) ; } return result ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( totalSum ( N ) ) ; N = 12 ; System . out . println ( totalSum ( N ) ) ; } }"}
{"text":"Java implementation to check if N is a Nontrivial undulant number","code":"class GFG {"}
{"text":"Function to check if a string is double string or not","code":"static boolean isDouble ( int num ) { String s = Integer . toString ( num ) ; int l = s . length ( ) ;"}
{"text":"a and b should not be equal","code":"if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ;"}
{"text":"Condition to check if length is odd make length even","code":"if ( l % 2 == 1 ) { s = s + s . charAt ( 1 ) ; l ++ ; }"}
{"text":"First half of s","code":"String s1 = s . substring ( 0 , l \/ 2 ) ;"}
{"text":"Second half of s","code":"String s2 = s . substring ( l \/ 2 ) ;"}
{"text":"Double string if first and last half are equal","code":"return s1 . equals ( s2 ) ; }"}
{"text":"Function to check if N is an Nontrivial undulant number","code":"static boolean isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 121 ; if ( isNontrivialUndulant ( n ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the nth Megagon Number","code":"static int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( MegagonNum ( n ) ) ; } }"}
{"text":"Java implementation to find the product of all the pairs from the given array","code":"import java . util . * ; class GFG { static final int mod = 1000000007 ;"}
{"text":"Function to return the product of the elements of all possible pairs from the array","code":"static int productPairs ( int arr [ ] , int n ) {"}
{"text":"To store the required product","code":"int product = 1 ;"}
{"text":"Nested loop to calculate all possible pairs","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {"}
{"text":"Multiply the product of the elements of the current pair","code":"product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } }"}
{"text":"Return the final result","code":"return product % mod ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( productPairs ( arr , n ) ) ; } }"}
{"text":"Java implementation to Find the product of all the pairs from the given array","code":"import java . util . * ; class GFG { static final int mod = 1000000007 ;"}
{"text":"Function to calculate ( x ^ y ) % 1000000007","code":"static int power ( int x , int y ) { int p = 1000000007 ;"}
{"text":"Initialize result","code":"int res = 1 ;"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p ; while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with result","code":"if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; }"}
{"text":"Return the final result","code":"return res ; }"}
{"text":"Function to return the product of the elements of all possible pairs from the array","code":"static int productPairs ( int arr [ ] , int n ) {"}
{"text":"To store the required product","code":"int product = 1 ;"}
{"text":"Iterate for every element of the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Each element appears ( 2 * n ) times","code":"product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( productPairs ( arr , n ) ) ; } }"}
{"text":"Java program to construct array that cube sum of all element is a perfect square","code":"import java . util . * ; class GFG {"}
{"text":"Function to create and print the array","code":"static void constructArray ( int N ) { int arr [ ] = new int [ N ] ;"}
{"text":"Initialise the array of size N","code":"for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; }"}
{"text":"Print the array","code":"for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" , \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 6 ; constructArray ( N ) ; } }"}
{"text":"Java implementation to count all subsequence whose product is Composite number","code":"import java . util . * ; class GFG {"}
{"text":"Function to check whether a number is prime or not","code":"static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }"}
{"text":"Function to find number of subsequences whose product is a composite number","code":"static int countSubsequences ( int arr [ ] , int n ) {"}
{"text":"Find total non empty subsequence","code":"int totalSubsequence = ( int ) ( Math . pow ( 2 , n ) - 1 ) ; int countPrime = 0 , countOnes = 0 ;"}
{"text":"Find count of prime number and ones","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ;"}
{"text":"Calculate the non empty one subsequence","code":"int onesSequence = ( int ) ( Math . pow ( 2 , countOnes ) - 1 ) ;"}
{"text":"Find count of composite subsequence","code":"compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 2 } ; int n = arr . length ; System . out . print ( countSubsequences ( arr , n ) ) ; } }"}
{"text":"Java implementation to check if a number can be expressed as sum of K consecutive integer","code":"class GFG {"}
{"text":"Function to check if a number can be expressed as the sum of k consecutive","code":"static void checksum ( int n , int k ) {"}
{"text":"Finding the first term of AP","code":"float first_term = ( float ) ( ( ( 2 * n ) \/ k + ( 1 - k ) ) \/ 2.0 ) ;"}
{"text":"Checking if first term is an integer","code":"if ( first_term - ( int ) ( first_term ) == 0 ) {"}
{"text":"Loop to print the K consecutive integers","code":"for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { System . out . print ( i + \" \u2581 \" ) ; } } else System . out . print ( \" - 1\" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 33 , k = 6 ; checksum ( n , k ) ; } }"}
{"text":"Java implementation to represent N as sum of K even numbers","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the representation","code":"static void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ;"}
{"text":"N must be greater than equal to 2 * K and must be even","code":"if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { System . out . print ( \"2 \u2581 \" ) ; } System . out . println ( check ) ; } else { System . out . println ( \" - 1\" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; } }"}
{"text":"Java program to find the number of contiguous subarrays including the element at every index of the array of size N","code":"import java . util . Scanner ; class contiguous_subarrays {"}
{"text":"Function to find the number of subarrays including the element at every index of the array","code":"public static int [ ] calculateWays ( int n ) { int x = 0 ;"}
{"text":"Creating an array of size N","code":"int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ;"}
{"text":"The loop is iterated till half the length of the array","code":"for ( int i = 0 ; i < n \/ 2 ; i ++ ) {"}
{"text":"Condition to avoid overwriting the middle element for the array with even length .","code":"if ( n % 2 == 0 && i == n \/ 2 ) break ;"}
{"text":"Computing the number of subarrays","code":"x = n * ( i + 1 ) - ( i + 1 ) * i ;"}
{"text":"The ith element from the beginning and the ending have the same number of possible subarray","code":"v [ i ] = x ; v [ n - i - 1 ] = x ; } return v ; }"}
{"text":"Function to print the vector","code":"public static void printArray ( int [ ] v ) { for ( int i = 0 ; i < v . length ; i ++ ) System . out . print ( v [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int [ ] v ; v = calculateWays ( 4 ) ; printArray ( v ) ; } }"}
{"text":"Java program to find the smallest number greater than or equal to X and divisible by Y","code":"class GFG { static final int MAXN = 10000000 ;"}
{"text":"Function that returns the sum of digits of a number","code":"static int sumOfDigits ( int n ) {"}
{"text":"Initialize variable to store the sum","code":"int sum = 0 ; while ( n > 0 ) {"}
{"text":"Add the last digit of the number","code":"sum += n % 10 ;"}
{"text":"Remove the last digit from the number","code":"n \/= 10 ; } return sum ; }"}
{"text":"Function that returns the smallest number greater than or equal to X and divisible by Y","code":"static int smallestNum ( int X , int Y ) {"}
{"text":"Initialize result variable","code":"int res = - 1 ;"}
{"text":"Loop through numbers greater than equal to X","code":"for ( int i = X ; i < MAXN ; i ++ ) {"}
{"text":"Calculate sum of digits","code":"int sum_of_digit = sumOfDigits ( i ) ;"}
{"text":"Check if sum of digits is divisible by Y","code":"if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int X = 5923 , Y = 13 ; System . out . print ( smallestNum ( X , Y ) ) ; } }"}
{"text":"Java program to count the numbers which can convert N to 1 using the given operation","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the numbers which can convert N to 1 using the given operation","code":"static int countValues ( int N ) { Vector < Integer > div = new Vector < > ( ) ;"}
{"text":"Store all the divisors of N","code":"for ( int i = 2 ; i * i <= N ; i ++ ) {"}
{"text":"If i is a divisor","code":"if ( N % i == 0 ) { div . add ( i ) ;"}
{"text":"If i is not equal to N \/ i","code":"if ( N != i * i ) { div . add ( N \/ i ) ; } } } int answer = 0 ;"}
{"text":"Iterate through all the divisors of N - 1 and count them in answer","code":"for ( int i = 1 ; i * i <= N - 1 ; i ++ ) {"}
{"text":"Check if N - 1 is a divisor or not","code":"if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } }"}
{"text":"Iterate through all divisors and check for N mod d = 1 or ( N - 1 ) mod d = 0","code":"for ( int d : div ) { int K = N ; while ( K % d == 0 ) K \/= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }"}
{"text":"Java implementation to find the maximum possible prime divisor of a number can have N divisors","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum possible prime divisors of a number can have with N divisors","code":"static void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ;"}
{"text":"Number of time number divided by 2","code":"while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n \/ 2 ; }"}
{"text":"Divide by other prime numbers","code":"for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n \/ i ; } }"}
{"text":"If the last number of also prime then also include it","code":"if ( n > 2 ) { max_possible_prime ++ ; } System . out . print ( max_possible_prime + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 4 ;"}
{"text":"Function Call","code":"findMaxPrimeDivisor ( n ) ; } }"}
{"text":"Java program to count ways to express a number as sum of two numbers .","code":"class GFG {"}
{"text":"Function returns the count of ways express a number as sum of two numbers .","code":"static int CountWays ( int n ) { int ans = ( n - 1 ) \/ 2 ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 8 ; System . out . print ( CountWays ( N ) ) ; } }"}
{"text":"Java program to find the max - size to which an array can be divided into 2 equal parts such that one part contains unique elements while another contains similar elements","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the max - size to which an array can be divided into 2 equal parts","code":"static void Solve ( int arr [ ] , int size , int n ) { int [ ] v = new int [ n + 1 ] ;"}
{"text":"Array to find the frequency of each element of array","code":"for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ;"}
{"text":"Find the index maximum frequency element present in array arr [ ]","code":"int max1 = - 1 , mx = - 1 ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] > mx ) { mx = v [ i ] ; max1 = i ; } }"}
{"text":"Find total unique elements present in array arr [ ]","code":"int cnt = 0 ; for ( int i : v ) { if ( i == 0 ) ++ cnt ; } int diff1 = n + 1 - cnt ;"}
{"text":"Find the Max - Size to which an array arr [ ] can be splitted","code":"int max_size = Math . max ( Math . min ( v [ max1 ] - 1 , diff1 ) , Math . min ( v [ max1 ] , diff1 - 1 ) ) ; System . out . println ( \" Maximum \u2581 size \u2581 is : \u2581 \" + max_size ) ;"}
{"text":"Find the first array containing same elements","code":"System . out . println ( \" First \u2581 Array \u2581 is \" ) ; for ( int i = 0 ; i < max_size ; i ++ ) { System . out . print ( max1 + \" \u2581 \" ) ; v [ max1 ] -= 1 ; } System . out . println ( ) ;"}
{"text":"Find the second array containing unique elements","code":"System . out . println ( \" The \u2581 Second \u2581 Array \u2581 Is \u2581 : \" ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { System . out . print ( i + \" \u2581 \" ) ; max_size -- ; } if ( max_size < 1 ) break ; } System . out . println ( ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"initialise n","code":"int n = 7 ;"}
{"text":"array declaration","code":"int arr [ ] = new int [ ] { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ;"}
{"text":"size of array","code":"int size = arr . length ; Solve ( arr , size , n ) ; } }"}
{"text":"Java program to find sum of xor of all unordered triplets of the array","code":"class GFG {"}
{"text":"Iterative Function to calculate ( x ^ y ) % p in O ( log y )","code":"static int power ( int x , int y , int p ) {"}
{"text":"Initialize result","code":"int res = 1 ;"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p ; while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with result","code":"if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;"}
{"text":"y must be even now y = y >> 1 ; y = y \/ 2","code":"x = ( x * x ) % p ; } return res ; }"}
{"text":"Returns n ^ ( - 1 ) mod p","code":"static int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; }"}
{"text":"Returns nCr % p using Fermat 's little theorem.","code":"static int nCrModPFermat ( int n , int r , int p ) {"}
{"text":"Base case","code":"if ( r == 0 ) return 1 ; if ( n < r ) return 0 ;"}
{"text":"Fill factorial array so that we can find all factorial of r , n and n - r","code":"int fac [ ] = new int [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }"}
{"text":"Function returns sum of xor of all unordered triplets of the array","code":"static int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ;"}
{"text":"Iterating over the bits","code":"for ( int k = 0 ; k < 32 ; k ++ ) {"}
{"text":"Number of elements whith k 'th bit  1 and 0 respectively","code":"int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Checking if k 'th bit is 1","code":"if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; }"}
{"text":"Adding this bit 's part to the answer","code":"answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; int A [ ] = { 3 , 5 , 2 , 18 , 7 } ; System . out . println ( SumOfXor ( A , n ) ) ; } }"}
{"text":"Java implementation to find the probability of not getting two consecutive heads together when N coins are tossed","code":"class GFG { public static float round ( float var , int digit ) { float value = ( int ) ( var * Math . pow ( 10 , digit ) + .5 ) ; return ( float ) value \/ ( float ) Math . pow ( 10 , digit ) ; }"}
{"text":"Function to compute the N - th Fibonacci number in the sequence where a = 2 and b = 3","code":"public static int probability ( int N ) {"}
{"text":"The first two numbers in the sequence are initialized","code":"int a = 2 ; int b = 3 ;"}
{"text":"Base cases","code":"if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else {"}
{"text":"Loop to compute the fibonacci sequence based on the first two initialized numbers","code":"for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } }"}
{"text":"Function to find the probability of not getting two consecutive heads when N coins are tossed","code":"public static float operations ( int N ) {"}
{"text":"Computing the number of favourable cases","code":"int x = probability ( N ) ;"}
{"text":"Computing the number of all possible outcomes for N tosses","code":"int y = ( int ) Math . pow ( 2 , N ) ; return round ( ( float ) x \/ ( float ) y , 2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( ( operations ( N ) ) ) ; } }"}
{"text":"Java program to check if the concatenation of two numbers is a perfect cube or not","code":"class GFG {"}
{"text":"Function to check if a number is a perfect Cube or not","code":"static boolean isPerfectCube ( int x ) { long cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }"}
{"text":"Function to check if concatenation of two numbers is a perfect cube or not","code":"static void checkCube ( int a , int b ) {"}
{"text":"Convert numbers to string using to_string ( )","code":"String s1 = Integer . toString ( a ) ; String s2 = Integer . toString ( b ) ;"}
{"text":"Concatenate the numbers and convert it into integer","code":"int c = Integer . parseInt ( s1 + s2 ) ;"}
{"text":"Check if concatenated value is perfect cube or not","code":"if ( isPerfectCube ( c ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the largest sum","code":"static int largest_sum ( int arr [ ] , int n ) {"}
{"text":"Variable to store the largest sum","code":"int maximum = - 1 ;"}
{"text":"Map to store the frequencies of each element","code":"HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Store the Frequencies","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } }"}
{"text":"Loop to combine duplicate elements and update the sum in the map","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If j is a duplicate element","code":"if ( m . get ( arr [ i ] ) > 1 ) { if ( m . containsKey ( 2 * arr [ i ] ) ) {"}
{"text":"Update the frequency of 2 * j","code":"m . put ( 2 * arr [ i ] , m . get ( 2 * arr [ i ] ) + m . get ( arr [ i ] ) \/ 2 ) ; } else { m . put ( 2 * arr [ i ] , m . get ( arr [ i ] ) \/ 2 ) ; }"}
{"text":"If the new sum is greater than maximum value , Update the maximum","code":"if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } }"}
{"text":"Returns the largest sum","code":"return maximum ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = arr . length ;"}
{"text":"Function Calling","code":"System . out . println ( largest_sum ( arr , n ) ) ; } }"}
{"text":"Java program of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if it is possible to make x and y can become 0 at same time","code":"static void canBeReduced ( int x , int y ) { int maxi = Math . max ( x , y ) ; int mini = Math . min ( x , y ) ;"}
{"text":"Check the given conditions","code":"if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) System . out . print ( \" YES \" + \"NEW_LINE\"); else System . out . print ( \" NO \" + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int x = 6 , y = 9 ;"}
{"text":"Function Call","code":"canBeReduced ( x , y ) ; } }"}
{"text":"Java program to check if the given number is prime using Wheel Factorization Method","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if a given number x is prime or not","code":"static void isPrime ( int N ) { boolean isPrime = true ;"}
{"text":"The Wheel for checking prime number","code":"int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ;"}
{"text":"Base Case","code":"if ( N < 2 ) { isPrime = false ; }"}
{"text":"Check for the number taken as basis","code":"if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; }"}
{"text":"Check for Wheel Here i , acts as the layer of the wheel","code":"for ( int i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) {"}
{"text":"Check for the list of Sieve in arr [ ]","code":"for ( int c : arr ) {"}
{"text":"If number is greater than sqrt ( N ) break","code":"if ( c > Math . sqrt ( N ) ) { break ; }"}
{"text":"Check if N is a multiple of prime number in the wheel","code":"else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } }"}
{"text":"If at any iteration isPrime is false , break from the loop","code":"if ( ! isPrime ) break ; } } if ( isPrime ) System . out . println ( \" Prime \u2581 Number \" ) ; else System . out . println ( \" Not \u2581 a \u2581 Prime \u2581 Number \" ) ; }"}
{"text":"Driver 's Code","code":"public static void main ( String args [ ] ) { int N = 121 ;"}
{"text":"Function call for primality check","code":"isPrime ( N ) ; } }"}
{"text":"Java implementation to find all Pairs possible from the given Array","code":"class GFG {"}
{"text":"Function to print all possible pairs from the array","code":"static void printPairs ( int arr [ ] , int n ) {"}
{"text":"Nested loop for all possible pairs","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( \" ( \" + arr [ i ] + \" , \u2581 \" + arr [ j ] + \" ) \" + \" , \u2581 \" ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 } ; int n = arr . length ; printPairs ( arr , n ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the Least number","code":"static int nearest ( int n ) {"}
{"text":"Get the perfect cube before and after N","code":"int prevCube = ( int ) Math . cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ;"}
{"text":"Check which is nearest to N","code":"int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ;"}
{"text":"return the result","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 25 ; System . out . println ( nearest ( n ) ) ; n = 27 ; System . out . println ( nearest ( n ) ) ; n = 40 ; System . out . println ( nearest ( n ) ) ; } }"}
{"text":"Java program to check if one circle lies inside another circle or not .","code":"import java . io . * ; class GFG { static void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( int ) Math . sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) { System . out . println ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" + \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 with \u2581 \" + \" touching \u2581 each \u2581 other \u2581 \" + \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \u2581 \" ) ; } else if ( distSq + r2 < r1 ) { System . out . println ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" + \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 without \" + \" \u2581 touching \u2581 each \u2581 other \u2581 \" + \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \" ) ; } else { System . out . println ( \" The \u2581 smaller \u2581 does \u2581 not \u2581 lies \u2581 inside \" + \" \u2581 the \u2581 bigger \u2581 circle \u2581 completely . \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; } }"}
{"text":"Java program to find the length of the direct common tangent between two circles which intersect each other","code":"class GFG {"}
{"text":"Function to find the length of the direct common tangent","code":"static void lengtang ( double r1 , double r2 , double d ) { System . out . println ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \" + \" \u2581 common \u2581 tangent \u2581 is \u2581 \" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; } }"}
{"text":"Java program to find radius of the circle when the width and height of an arc is given","code":"class GFG {"}
{"text":"Function to find the radius","code":"static void rad ( double d , double h ) { System . out . println ( \" The \u2581 radius \u2581 of \u2581 the \u2581 circle \u2581 is \u2581 \" + ( ( d * d ) \/ ( 8 * h ) + h \/ 2 ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double d = 4 , h = 1 ; rad ( d , h ) ; } }"}
{"text":"Java program to find the shortest distance from chord to the centre of circle","code":"class GFG {"}
{"text":"Function to find the shortest distance","code":"static void shortdis ( double r , double d ) { System . out . println ( \" The \u2581 shortest \u2581 distance \u2581 \" + \" from \u2581 the \u2581 chord \u2581 to \u2581 centre \u2581 \" + ( Math . sqrt ( ( r * r ) - ( ( d * d ) \/ 4 ) ) ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; } }"}
{"text":"Java program to find the length of the direct common tangent between two circles which donot touch each other","code":"class GFG {"}
{"text":"Function to find the length of the direct common tangent","code":"static void lengtang ( double r1 , double r2 , double d ) { System . out . println ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \" + \" \u2581 common \u2581 tangent \u2581 is \u2581 \" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; } }"}
{"text":"Java Program to find the the biggest square which can be inscribed within the equilateral triangle","code":"class GFG {"}
{"text":"Function to find the side of the square","code":"static double square ( double a ) {"}
{"text":"the side cannot be negative","code":"if ( a < 0 ) return - 1 ;"}
{"text":"side of the square","code":"double x = 0.464 * a ; return x ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { double a = 5 ; System . out . println ( square ( a ) ) ; } }"}
{"text":"Java Program to find the apothem of a regular polygon with given side length","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the apothem of a regular polygon","code":"double polyapothem ( double n , double a ) {"}
{"text":"Side and side length cannot be negative","code":"if ( a < 0 && n < 0 ) return - 1 ;"}
{"text":"Degree converted to radians","code":"return ( a \/ ( 2 * java . lang . Math . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { double a = 9 , n = 6 ; GFG g = new GFG ( ) ; System . out . println ( g . polyapothem ( n , a ) ) ; } }"}
{"text":"Java Program to find the area of a regular polygon with given side length","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the area of a regular polygon","code":"static float polyarea ( float n , float a ) {"}
{"text":"Side and side length cannot be negative","code":"if ( a < 0 && n < 0 ) return - 1 ;"}
{"text":"Area degree converted to radians","code":"float A = ( a * a * n ) \/ ( float ) ( 4 * Math . tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) ; return A ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float a = 9 , n = 6 ; System . out . println ( polyarea ( n , a ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . lang . Math ; import java . io . * ; class GFG {"}
{"text":"Function to calculate the side of the polygon circumscribed in a circle","code":"static double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 \/ n ; theta_in_radians = theta * 3.14 \/ 180 ; return 2 * r * Math . sin ( theta_in_radians \/ 2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Total sides of the polygon","code":"double n = 3 ;"}
{"text":"Radius of the circumscribing circle","code":"double r = 5 ; System . out . println ( calculateSide ( n , r ) ) ; } }"}
{"text":"Java Program to find the biggest right circular cylinder that can be fit within a frustum","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the biggest right circular cylinder","code":"static float cyl ( float r , float R , float h ) {"}
{"text":"radii and height cannot be negative","code":"if ( h < 0 && r < 0 && R < 0 ) return - 1 ;"}
{"text":"radius of right circular cylinder","code":"float r1 = r ;"}
{"text":"height of right circular cylinder","code":"float h1 = h ;"}
{"text":"volume of right circular cylinder","code":"float V = ( float ) ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float r = 7 , R = 11 , h = 6 ; System . out . print ( cyl ( r , R , h ) ) ; } }"}
{"text":"Java program to find the perimeter of a regular polygon","code":"class GFG {"}
{"text":"Function to calculate the perimeter","code":"static double Perimeter ( double s , int n ) { double perimeter = 1 ;"}
{"text":"Calculate Perimeter","code":"perimeter = n * s ; return perimeter ; }"}
{"text":"Driver method","code":"public static void main ( String [ ] args ) {"}
{"text":"Get the number of sides","code":"int n = 5 ;"}
{"text":"Get the length of side","code":"double s = 2.5 , peri ;"}
{"text":"find perimeter","code":"peri = Perimeter ( s , n ) ; System . out . println ( \" Perimeter \u2581 of \u2581 Regular \u2581 Polygon \" + \" \u2581 with \u2581 \" + n + \" \u2581 sides \u2581 of \u2581 length \u2581 \" + s + \" \u2581 = \u2581 \" + peri ) ; } }"}
{"text":"Java Program to find the biggest rhombus which can be inscribed within the rectangle","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the area of the biggest rhombus","code":"static float rhombusarea ( float l , float b ) {"}
{"text":"the length and breadth cannot be negative","code":"if ( l < 0 b < 0 ) return - 1 ;"}
{"text":"area of the rhombus","code":"return ( l * b ) \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float l = 16 , b = 6 ; System . out . println ( rhombusarea ( l , b ) ) ; } }"}
{"text":"Java program to Check if a point lies on or inside a rectangle | Set - 2","code":"class GFG {"}
{"text":"function to find if given point lies inside a given rectangle or not .","code":"static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"bottom - left and top - right corners of rectangle","code":"int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ;"}
{"text":"given point","code":"int x = 1 , y = 5 ;"}
{"text":"function call","code":"if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to find the Perpendicular ( shortest ) distance between a point and a Plane in 3 D .","code":"import java . io . * ; class GFG {"}
{"text":"Function to find distance","code":"static void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . sqrt ( a * a + b * b + c * c ) ; System . out . println ( \" Perpendicular \u2581 distance \u2581 \" + \" is \u2581 \" + d \/ e ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float x1 = 4 ; float y1 = - 4 ; float z1 = 3 ; float a = 2 ; float b = - 2 ; float c = 5 ; float d = 8 ;"}
{"text":"Function call","code":"shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; } }"}
{"text":"Java program to find the volume of the triangular prism","code":"import java . io . * ; class GFG {"}
{"text":"function to find the Volume of triangular prism","code":"static float findVolume ( float l , float b , float h ) {"}
{"text":"formula to find Volume","code":"float volume = ( l * b * h ) \/ 2 ; return volume ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float l = 18 , b = 12 , h = 9 ;"}
{"text":"function calling","code":"System . out . println ( \" Volume \u2581 of \u2581 triangular \u2581 prism : \u2581 \" + findVolume ( l , b , h ) ) ; } }"}
{"text":"A simple program to find if given 4 values can represent 4 sides of rectangle","code":"class GFG {"}
{"text":"Function to check if the given integers value make a rectangle","code":"static boolean isRectangle ( int a , int b , int c , int d ) {"}
{"text":"Square is also a rectangle","code":"if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to find the midpoint of a line","code":"import java . io . * ; class GFG {"}
{"text":"function to find the midpoint of a line","code":"static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) \/ 2 + \" \u2581 , \u2581 \" + ( y1 + y2 ) \/ 2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x1 = - 1 , y1 = 2 ; int x2 = 3 , y2 = - 6 ; midpoint ( x1 , x2 , y1 , y2 ) ; } }"}
{"text":"Java program to calculate length of an arc","code":"public class Arc {"}
{"text":"function to calculate arc length","code":"static double arcLength ( double diameter , double angle ) { double pi = 22.0 \/ 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( \" Angle \u2581 cannot \" + \" \u2581 be \u2581 formed \" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle \/ 360.0 ) ; return arc ; } }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; System . out . println ( arc_len ) ; } }"}
{"text":"Java program to check if a line touches or intersects or outside a circle .","code":"import java . io . * ; class GFG { static void checkCollision ( int a , int b , int c , int x , int y , int radius ) {"}
{"text":"Finding the distance of line from center .","code":"double dist = ( Math . abs ( a * x + b * y + c ) ) \/ Math . sqrt ( a * a + b * b ) ;"}
{"text":"Checking if the distance is less than , greater than or equal to radius .","code":"if ( radius == dist ) System . out . println ( \" Touch \" ) ; else if ( radius > dist ) System . out . println ( \" Intersect \" ) ; else System . out . println ( \" Outside \" ) ; }"}
{"text":"Driven Program","code":"public static void main ( String [ ] args ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; } }"}
{"text":"Java program to evaluate area of a polygon usingshoelace formula","code":"import java . io . * ; import java . math . * ; class GFG {"}
{"text":"( X [ i ] , Y [ i ] ) are coordinates of i 'th point.","code":"static double polygonArea ( double X [ ] , double Y [ ] , int n ) {"}
{"text":"Initialize area","code":"double area = 0.0 ;"}
{"text":"Calculate value of shoelace formula","code":"int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;"}
{"text":"j is previous vertex to i","code":"j = i ; }"}
{"text":"Return absolute value","code":"return Math . abs ( area \/ 2.0 ) ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = X . length ; System . out . println ( polygonArea ( X , Y , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function top get LSB value of v","code":"static int chk ( int n ) {"}
{"text":"Binary conversion","code":"Vector < Integer > v = new Vector < Integer > ( ) ; while ( n != 0 ) { v . add ( n % 2 ) ; n = n \/ 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . get ( i ) == 1 ) { return ( int ) Math . pow ( 2 , i ) ; } } return 0 ; }"}
{"text":"Function to find the sum of LSBs of all possible pairs of the given array","code":"static void sumOfLSB ( int arr [ ] , int N ) {"}
{"text":"Stores the LSB of array elements","code":"Vector < Integer > lsb_arr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Storing the LSB values","code":"lsb_arr . add ( chk ( arr [ i ] ) ) ; }"}
{"text":"Sort the array lab_arr [ ]","code":"Collections . sort ( lsb_arr ) ; int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i += 2 ) {"}
{"text":"Taking pairwise sum to get the maximum sum of LSB","code":"ans += ( lsb_arr . get ( i + 1 ) ) ; }"}
{"text":"Print the result","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ;"}
{"text":"Function Call","code":"sumOfLSB ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find count of subsequences having odd bitwise AND value","code":"static int countSubsequences ( int arr [ ] , int N ) {"}
{"text":"Stores count of odd elements","code":"int odd = 0 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If x is odd increment count","code":"if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; }"}
{"text":"Return Answer","code":"return ( 1 << odd ) - 1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 3 ; int arr [ ] = { 1 , 3 , 3 } ;"}
{"text":"Function Call","code":"System . out . println ( countSubsequences ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the number of pairs ( i , j ) such that abs ( a [ i ] - a [ j ] ) is at least the minimum of ( a [ i ] , a [ j ] )","code":"static int getPairsCount ( int arr [ ] , int n ) {"}
{"text":"Stores the resultant count of pairs","code":"int count = 0 ;"}
{"text":"Iterate over the range [ 0 , n ]","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Iterate from arr [ i ] - ( i % arr [ i ] ) till n with an increment of arr [ i ]","code":"for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) {"}
{"text":"Count the possible pairs","code":"if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } }"}
{"text":"Return the total count","code":"return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = arr . length ; System . out . println ( getPairsCount ( arr , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if N can be changed to 1 or not .","code":"static void check ( int N ) { int twos = 0 , fives = 0 ;"}
{"text":"Count the number of 2 in the prime factorisation of N","code":"while ( N % 2 == 0 ) { N \/= 2 ; twos ++ ; }"}
{"text":"Count the number of 5 in the prime factorisation of N","code":"while ( N % 5 == 0 ) { N \/= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { System . out . println ( 2 * fives - twos ) ; } else { System . out . println ( - 1 ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 50 ; check ( N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the sum of elements in a given range of an infinite array","code":"static void rangeSum ( int arr [ ] , int N , int L , int R ) {"}
{"text":"Stores the sum of array elements from L to R","code":"int sum = 0 ;"}
{"text":"Traverse from L to R","code":"for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; }"}
{"text":"Print the resultant sum","code":"System . out . println ( sum ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . length ; rangeSum ( arr , N , L , R ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the sum of elements in a given range of an infinite array","code":"static void rangeSum ( int arr [ ] , int N , int L , int R ) {"}
{"text":"Stores the prefix sum","code":"int prefix [ ] = new int [ N + 1 ] ; prefix [ 0 ] = 0 ;"}
{"text":"Calculate the prefix sum","code":"for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; }"}
{"text":"Stores the sum of elements from 1 to L - 1","code":"int leftsum = ( ( L - 1 ) \/ N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ;"}
{"text":"Stores the sum of elements from 1 to R","code":"int rightsum = ( R \/ N ) * prefix [ N ] + prefix [ R % N ] ;"}
{"text":"Print the resultant sum","code":"System . out . print ( rightsum - leftsum ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . length ; rangeSum ( arr , N , L , R ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find exponential factorial of a given number","code":"static int ExpoFactorial ( int N ) {"}
{"text":"Stores the exponetial factor of N","code":"int res = 1 ; int mod = 1000000007 ;"}
{"text":"Iterare over the range [ 2 , N ]","code":"for ( int i = 2 ; i < N + 1 ; i ++ )"}
{"text":"Update res","code":"res = ( int ) Math . pow ( i , res ) % mod ;"}
{"text":"Return res","code":"return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input","code":"int N = 4 ;"}
{"text":"Function call","code":"System . out . println ( ( ExpoFactorial ( N ) ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find contiguous subarray with maximum sum if array is repeated K times","code":"static int maxSubArraySumRepeated ( int [ ] arr , int N , int K ) {"}
{"text":"Store the sum of the array arr [ ]","code":"int sum = 0 ;"}
{"text":"Traverse the array and find sum","code":"for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ;"}
{"text":"Store the answer","code":"int ans = arr [ 0 ] ;"}
{"text":"If K = 1","code":"if ( K == 1 ) {"}
{"text":"Apply Kadane algorithm to find sum","code":"for ( int i = 1 ; i < N ; i ++ ) { curr = Math . max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . max ( ans , curr ) ; }"}
{"text":"Return the answer","code":"return ans ; }"}
{"text":"Stores the twice repeated array","code":"ArrayList < Integer > V = new ArrayList < Integer > ( ) ;"}
{"text":"Traverse the range [ 0 , 2 * N ]","code":"for ( int i = 0 ; i < 2 * N ; i ++ ) { V . add ( arr [ i % N ] ) ; }"}
{"text":"Stores the maximum suffix sum","code":"int maxSuf = V . get ( 0 ) ;"}
{"text":"Stores the maximum prefix sum","code":"int maxPref = V . get ( 2 * N - 1 ) ; curr = V . get ( 0 ) ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V . get ( i ) ; maxPref = Math . max ( maxPref , curr ) ; } curr = V . get ( 2 * N - 1 ) ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V . get ( i ) ; maxSuf = Math . max ( maxSuf , curr ) ; } curr = V . get ( 0 ) ;"}
{"text":"Apply Kadane algorithm for 2 repetition of the array","code":"for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = Math . max ( V . get ( i ) , curr + V . get ( i ) ) ; ans = Math . max ( ans , curr ) ; }"}
{"text":"If the sum of the array is greater than 0","code":"if ( sum > 0 ) { int temp = sum * ( K - 2 ) ; ans = Math . max ( ans , Math . max ( temp + maxPref , temp + maxSuf ) ) ; }"}
{"text":"Return the answer","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given Input","code":"int [ ] arr = { 10 , 20 , - 30 , - 1 , 40 } ; int N = arr . length ; int K = 10 ;"}
{"text":"Function Call","code":"System . out . print ( maxSubArraySumRepeated ( arr , N , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find count of subarrays which have max element greater than twice maximum of all other elements","code":"public static void countSubarray ( int arr [ ] , int n ) {"}
{"text":"Stores the count of subarrays","code":"int count = 0 ;"}
{"text":"Generate all possible subarrays","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) {"}
{"text":"Stores the maximum element of the subarray","code":"int mxSubarray = 0 ;"}
{"text":"Stores the maximum of all other elements","code":"int mxOther = 0 ;"}
{"text":"Find the maximum element in the subarray [ i , j ]","code":"for ( int k = i ; k <= j ; k ++ ) { mxSubarray = Math . max ( mxSubarray , arr [ k ] ) ; }"}
{"text":"Find the maximum of all other elements","code":"for ( int k = 0 ; k < i ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; }"}
{"text":"If the maximum of subarray is greater than twice the maximum of other elements","code":"if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } }"}
{"text":"Print the maximum value obtained","code":"System . out . println ( count ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . length ; countSubarray ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find count of subarrays which have max element greater than twice maximum of all other elements","code":"static void countSubarray ( int [ ] arr , int n ) { int L = 0 , R = 0 ;"}
{"text":"Stores the maximum element of the array","code":"int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , arr [ i ] ) ;"}
{"text":"Traverse the given array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If the value of 2 * arr [ i ] is greater than mx","code":"if ( arr [ i ] * 2 > mx ) {"}
{"text":"Update the value of L and break out of loop","code":"L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) {"}
{"text":"If the value 2 * arr [ i ] is greater than mx","code":"if ( arr [ i ] * 2 > mx ) {"}
{"text":"Update the value of R and break out of loop","code":"R = i ; break ; } }"}
{"text":"Print the final answer","code":"System . out . println ( ( L + 1 ) * ( n - R ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . length ; countSubarray ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Utility function to check for primality of a number X by checking whether X has any factors other than 1 and itself .","code":"static boolean isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ )"}
{"text":"Factor found","code":"if ( X % i == 0 ) return false ; return true ; }"}
{"text":"Function to print primes just less than and just greater than of each element in an array","code":"static void printPrimes ( int A [ ] , int N ) {"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Traverse for finding prime just less than A [ i ]","code":"for ( int j = A [ i ] - 1 ; ; j -- ) {"}
{"text":"Prime just less than A [ i ] found","code":"if ( isPrime ( j ) ) { System . out . print ( j + \" \u2581 \" ) ; break ; } }"}
{"text":"Traverse for finding prime just greater than A [ i ]","code":"for ( int j = A [ i ] + 1 ; ; j ++ ) {"}
{"text":"Prime just greater than A [ i ] found","code":"if ( isPrime ( j ) ) { System . out . print ( j + \" \u2581 \" ) ; break ; } } System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input","code":"int A [ ] = { 17 , 28 } ; int N = A . length ;"}
{"text":"Function call","code":"printPrimes ( A , N ) ; } }"}
{"text":"Java program for the above approach","code":"public class GFG_JAVA {"}
{"text":"Function to find the Kth smallest element that contains A [ i ] exactly B [ i ] times","code":"static int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ;"}
{"text":"Traverse the given array","code":"for ( int i = 0 ; i < N ; i ++ ) { M = Math . max ( A [ i ] , M ) ; }"}
{"text":"Stores the frequency of every elements","code":"int freq [ ] = new int [ M + 1 ] ;"}
{"text":"Traverse the given array","code":"for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; }"}
{"text":"Initialize a variable to store the prefix sums","code":"int sum = 0 ;"}
{"text":"Iterate over the range [ 0 , M ]","code":"for ( int i = 0 ; i <= M ; i ++ ) {"}
{"text":"Increment sum by freq [ i ]","code":"sum += freq [ i ] ;"}
{"text":"If sum is greater than or equal to K","code":"if ( sum >= K ) {"}
{"text":"Return the current element as answer","code":"return i ; } }"}
{"text":"Return - 1","code":"return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args )"}
{"text":"{ Given Input","code":"int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = A . length ; int K = 4 ;"}
{"text":"Function call","code":"System . out . println ( KthSmallest ( A , B , N , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"public class GFG {"}
{"text":"Function to find the Bitwise OR of Bitwise AND of all subarrays","code":"static void findbitwiseOR ( int [ ] a , int n ) {"}
{"text":"Stores the required result","code":"int res = 0 ;"}
{"text":"Generate all the subarrays","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Store the current element","code":"int curr_sub_array = a [ i ] ;"}
{"text":"Find the Bitwise OR","code":"res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) {"}
{"text":"Update the result","code":"curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } }"}
{"text":"Print the result","code":"System . out . println ( res ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 } ; int N = A . length ; findbitwiseOR ( A , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the Bitwise OR of Bitwise AND of all consecutive subsets of the array","code":"static void findbitwiseOR ( int [ ] a , int n ) {"}
{"text":"Stores the required result","code":"int res = 0 ;"}
{"text":"Traverse the given array","code":"for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ;"}
{"text":"Print the result","code":"System . out . println ( res ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 } ; int N = A . length ; findbitwiseOR ( A , N ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to check if the sum of the digits of N is strictly greater than the product of the digits of N or not","code":"static void check ( int n ) {"}
{"text":"Stores the sum and the product of the digits of N","code":"int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) {"}
{"text":"Stores the last digit if N","code":"int rem ; rem = n % 10 ;"}
{"text":"Increment the value of sumOfDigits","code":"sumOfDigit += rem ;"}
{"text":"Update the prodOfDigit","code":"prodOfDigit *= rem ;"}
{"text":"Divide N by 10","code":"n \/= 10 ; }"}
{"text":"Print the result","code":"if ( sumOfDigit > prodOfDigit ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 1234 ; check ( N ) ; } }"}
{"text":"Java approach for the above approach","code":"class GFG {"}
{"text":"Print all distinct even & odd prefix Bitwise XORs from 1 to N","code":"static void evenOddBitwiseXOR ( int N ) { System . out . print ( \" Even : \u2581 \" + 0 + \" \u2581 \" ) ;"}
{"text":"Print the even number","code":"for ( int i = 4 ; i <= N ; i = i + 4 ) { System . out . print ( i + \" \u2581 \" ) ; } System . out . print ( \"NEW_LINE\"); System . out . print ( \" Odd : \u2581 \" + 1 + \" \u2581 \" ) ;"}
{"text":"Print the odd number","code":"for ( int i = 4 ; i <= N ; i = i + 4 ) { System . out . print ( i - 1 + \" \u2581 \" ) ; } if ( N % 4 == 2 ) System . out . print ( N + 1 ) ; else if ( N % 4 == 3 ) System . out . print ( N ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; } }"}
{"text":"java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to lexicographic largest permutation possible by a swap that is smaller than given array","code":"static void findPermutation ( int [ ] arr ) { int N = arr . length ; int i = N - 2 ;"}
{"text":"Find the index of first element such that arr [ i ] > arr [ i + 1 ]","code":"while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ;"}
{"text":"If the array is sorted in increasing order","code":"if ( i == - 1 ) { System . out . print ( \" - 1\" ) ; return ; } int j = N - 1 ;"}
{"text":"Find the index of first element which is smaller than arr [ i ]","code":"while ( j > i && arr [ j ] >= arr [ i ] ) j -- ;"}
{"text":"If arr [ j ] = = arr [ j - 1 ]","code":"while ( j > i && arr [ j ] == arr [ j - 1 ] ) {"}
{"text":"Decrement j","code":"j -- ; }"}
{"text":"Swap the element","code":"int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ;"}
{"text":"Print the array arr [ ]","code":"for ( int it : arr ) { System . out . print ( it + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the smallest prime factor of all the numbers using Sieve Of Eratosthenes","code":"static void sieveOfEratosthenes ( int N , int s [ ] ) {"}
{"text":"Stores whether any number is prime or not","code":"boolean [ ] prime = new boolean [ N + 1 ] ;"}
{"text":"Initialize smallest factor as 2 for all the even numbers","code":"for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ;"}
{"text":"Iterate over the range [ 3 , N ]","code":"for ( int i = 3 ; i <= N ; i += 2 ) {"}
{"text":"If i is prime","code":"if ( prime [ i ] == false ) { s [ i ] = i ;"}
{"text":"Iterate all multiples of i","code":"for ( int j = i ; j * i <= N ; j += 2 ) {"}
{"text":"i is the smallest prime factor of i * j","code":"if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }"}
{"text":"Function to find the absolute difference between the count of odd and even factors of N","code":"static void findDifference ( int N ) {"}
{"text":"Stores the smallest prime factor of i","code":"int [ ] s = new int [ N + 1 ] ;"}
{"text":"Fill values in s [ ] using sieve of eratosthenes","code":"sieveOfEratosthenes ( N , s ) ;"}
{"text":"Stores the total number of factors and the total number of odd and even factors","code":"int total = 1 , odd = 1 , even = 0 ;"}
{"text":"Store the current prime factor of the number N","code":"int curr = s [ N ] ;"}
{"text":"Store the power of current prime factor","code":"int cnt = 1 ;"}
{"text":"Loop while N is greater than 1","code":"while ( N > 1 ) { N \/= s [ N ] ;"}
{"text":"If N also has smallest prime factor as curr , then increment cnt by 1","code":"if ( curr == s [ N ] ) { cnt ++ ; continue ; }"}
{"text":"Update only total number of factors if curr is 2","code":"if ( curr == 2 ) { total = total * ( cnt + 1 ) ; }"}
{"text":"Update total number of factors and total number of odd factors","code":"else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; }"}
{"text":"Update current prime factor as s [ N ] and count as 1","code":"curr = s [ N ] ; cnt = 1 ; }"}
{"text":"Calculate the number of even factors","code":"even = total - odd ;"}
{"text":"Print the difference","code":"System . out . print ( Math . abs ( even - odd ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 12 ; findDifference ( N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the median of a group of data with given mean and mode","code":"static void findMedian ( int Mean , int Mode ) {"}
{"text":"Calculate the median","code":"double Median = ( 2 * Mean + Mode ) \/ 3.0 ;"}
{"text":"Print the median","code":"System . out . print ( ( int ) Median ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to calculate magnitude of a 3 dimensional vector","code":"private static double vectorMagnitude ( int x , int y , int z ) {"}
{"text":"Stores the sum of squares of coordinates of a vector","code":"int sum = x * x + y * y + z * z ;"}
{"text":"Return the magnitude","code":"return Math . sqrt ( sum ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x = 1 ; int y = 2 ; int z = 3 ; System . out . print ( vectorMagnitude ( x , y , z ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find prodcut of a Mersenne number with another number","code":"static long multiplyByMersenne ( long N , long M ) {"}
{"text":"Stores the power of 2 of integer M + 1","code":"long x = ( int ) ( Math . log ( M + 1 ) \/ Math . log ( 2 ) ) ;"}
{"text":"Return the product","code":"return ( ( N << x ) - N ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { long N = 4 ; long M = 15 ; System . out . print ( multiplyByMersenne ( N , M ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find nearest perfect square of num","code":"static int perfectSquare ( int num ) {"}
{"text":"Calculate square root of num","code":"int sr = ( int ) ( Math . sqrt ( num ) ) ;"}
{"text":"Calculate perfect square","code":"int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ;"}
{"text":"Find the nearest perfect square","code":"if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } }"}
{"text":"Function to find the power of 2 nearest to the number num","code":"static int powerOfTwo ( int num ) {"}
{"text":"Calculate log base 2 of num","code":"int lg = ( int ) ( Math . log ( num ) \/ Math . log ( 2 ) ) ;"}
{"text":"Highest power of 2 which is <= num","code":"int p = ( int ) ( Math . pow ( 2 , lg ) ) ; return p ; }"}
{"text":"Function to find the nearest perfect square and the nearest power of 2 of every array element whose occurrence is 1","code":"static void uniqueElement ( int arr [ ] , int N ) { boolean ans = true ;"}
{"text":"Stores frequency of array elements","code":"HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Traverse the array and update frequency of current array element","code":"for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } }"}
{"text":"Traverse the map freq","code":"for ( Map . Entry < Integer , Integer > el : freq . entrySet ( ) ) {"}
{"text":"If the frequency is 1","code":"if ( el . getValue ( ) == 1 ) { ans = false ;"}
{"text":"Find nearest perfect square","code":"int ps = perfectSquare ( el . getKey ( ) ) ;"}
{"text":"Print the nearest power of 2","code":"System . out . print ( powerOfTwo ( ps ) + \" \u2581 \" ) ; } }"}
{"text":"If the any does not contain any non - repeating elements","code":"if ( ans ) System . out . print ( \" - 1\" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 11 , 4 , 3 , 4 } ; int N = arr . length ; uniqueElement ( arr , N ) ; } }"}
{"text":"Java program of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to partition the array into two non - empty subarrays which satisfies the given condition","code":"static void partitionArray ( int a [ ] , int n ) {"}
{"text":"Stores the suffix min array","code":"int min [ ] = new int [ n ] ;"}
{"text":"Stores the minimum of a suffix","code":"int mini = Integer . MAX_VALUE ;"}
{"text":"Traverse the array in reverse","code":"for ( int i = n - 1 ; i >= 0 ; i -- ) {"}
{"text":"Update minimum","code":"mini = Math . min ( mini , a [ i ] ) ;"}
{"text":"Store the minimum","code":"min [ i ] = mini ; }"}
{"text":"Stores the maximum value of a prefix","code":"int maxi = Integer . MIN_VALUE ;"}
{"text":"Stores the index of the partition","code":"int ind = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"Update max","code":"maxi = Math . max ( maxi , a [ i ] ) ;"}
{"text":"If max is less than min [ i + 1 ]","code":"if ( maxi < min [ i + 1 ] ) {"}
{"text":"Store the index of partition","code":"ind = i ;"}
{"text":"break","code":"break ; } }"}
{"text":"If ind is not - 1","code":"if ( ind != - 1 ) {"}
{"text":"Print the first subarray","code":"for ( int i = 0 ; i <= ind ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; System . out . println ( ) ;"}
{"text":"Print the second subarray","code":"for ( int i = ind + 1 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; }"}
{"text":"Otherwise","code":"else System . out . println ( \" Impossible \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = arr . length ; partitionArray ( arr , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count all prime factors of a given number","code":"static int countPrimeFactors ( int n ) { int count = 0 ;"}
{"text":"Count the number of 2 s that divides n","code":"while ( n % 2 == 0 ) { n = n \/ 2 ; count ++ ; }"}
{"text":"Since n is odd at this point , skip one element","code":"for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i = i + 2 ) {"}
{"text":"While i divides n , count i and divide n","code":"while ( n % i == 0 ) { n = n \/ i ; count ++ ; } }"}
{"text":"If n is a prime number greater than 2","code":"if ( n > 2 ) count ++ ; return ( count ) ; }"}
{"text":"Function to find the sum of first n nearly prime numbers","code":"static int findSum ( int n ) {"}
{"text":"Store the required sum","code":"int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) {"}
{"text":"Add this number if it is satisfies the condition","code":"if ( countPrimeFactors ( num ) == 2 ) { sum += num ;"}
{"text":"Increment count of nearly prime numbers","code":"i ++ ; } } return sum ; }"}
{"text":"Function to check if N can be represented as sum of K different positive integers out of which at least K - 1 of them are nearly prime","code":"static void check ( int n , int k ) {"}
{"text":"Store the sum of first K - 1 nearly prime numbers","code":"int s = findSum ( k - 1 ) ;"}
{"text":"If sum is greater than or equal to n","code":"if ( s >= n ) System . out . print ( \" No \" ) ;"}
{"text":"Otherwise , print Yes","code":"else System . out . print ( \" Yes \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 100 , k = 6 ; check ( n , k ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate GCD of a and b using Euclidean Algorithm","code":"static int gcd ( int a , int b ) {"}
{"text":"Iterate until b is non - zero","code":"while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; }"}
{"text":"Return the GCD","code":"return a ; }"}
{"text":"Function to count the number of ways N can be expressed as x ^ y","code":"static int countNumberOfWays ( int n ) {"}
{"text":"Base Case","code":"if ( n == 1 ) return - 1 ;"}
{"text":"Stores the gcd of powers","code":"int g = 0 ; int power = 0 ;"}
{"text":"Calculate the degree of 2 in N","code":"while ( n % 2 == 0 ) { power ++ ; n \/= 2 ; } g = gcd ( g , power ) ;"}
{"text":"Calculate the degree of prime numbers in N","code":"for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { power = 0 ;"}
{"text":"Calculate the degree of prime ' i ' in N","code":"while ( n % i == 0 ) { power ++ ; n \/= i ; } g = gcd ( g , power ) ; }"}
{"text":"If N is a prime , g becomes 1.","code":"if ( n > 2 ) g = gcd ( g , 1 ) ;"}
{"text":"Stores the number of ways to represent N as x ^ y","code":"int ways = 1 ;"}
{"text":"Find the number of Factors of g","code":"power = 0 ; while ( g % 2 == 0 ) { g \/= 2 ; power ++ ; }"}
{"text":"Update the count of ways","code":"ways *= ( power + 1 ) ;"}
{"text":"Iterate to find rest of the prime numbers","code":"for ( int i = 3 ; i <= ( int ) Math . sqrt ( g ) ; i += 2 ) { power = 0 ;"}
{"text":"Find the power of i","code":"while ( g % i == 0 ) { power ++ ; g \/= i ; }"}
{"text":"Update the count of ways","code":"ways *= ( power + 1 ) ; }"}
{"text":"If g is prime","code":"if ( g > 2 ) ways *= 2 ;"}
{"text":"Return the total number of ways","code":"return ways ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 64 ; System . out . print ( countNumberOfWays ( N ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to return the lowest power of 2 close to given positive number","code":"static int powOfPositive ( int n ) {"}
{"text":"Floor function is used to determine the value close to the number","code":"int pos = ( int ) Math . floor ( ( Math . log ( n ) \/ Math . log ( 2 ) ) ) ; return ( int ) Math . pow ( 2 , pos ) ; }"}
{"text":"Function to return the lowest power of 2 close to given negative number","code":"static int powOfNegative ( int n ) {"}
{"text":"Ceil function is used for negative numbers as - 1 > - 4. It would be opposite to positive numbers where 1 < 4","code":"int pos = ( int ) Math . ceil ( ( Math . log ( n ) \/ Math . log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . pow ( 2 , pos ) ) ; }"}
{"text":"Function to find the highest power of 2","code":"static void highestPowerOf2 ( int n ) {"}
{"text":"To check if the given number is positive or negative","code":"if ( n > 0 ) { System . out . println ( powOfPositive ( n ) ) ; } else {"}
{"text":"If the number is negative , then the ceil of the positive number is calculated and negative sign is added","code":"n = - n ; System . out . println ( powOfNegative ( n ) ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = - 24 ; highestPowerOf2 ( n ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . lang . * ; class GFG {"}
{"text":"Function to find number of cards needed","code":"public static int noOfCards ( int n ) { return n * ( 3 * n + 1 ) \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( noOfCards ( n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function for finding the smallest possible number after swapping the digits any number of times","code":"static String smallestPoss ( String s , int n ) {"}
{"text":"Variable to store the final answer","code":"String ans = \" \" ;"}
{"text":"Array to store the count of occurrence of each digit","code":"int arr [ ] = new int [ 10 ] ;"}
{"text":"Loop to calculate the number of occurrences of every digit","code":"for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - 48 ] ++ ; }"}
{"text":"Loop to get smallest number","code":"for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + String . valueOf ( i ) ; }"}
{"text":"Returning the answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 15 ; String K = \"325343273113434\" ; System . out . print ( smallestPoss ( K , N ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to count the number of sub - arrays with sum strictly greater than the remaining elements of array","code":"static int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ;"}
{"text":"For loop for beginning point of a subarray","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"For loop for ending point of the subarray","code":"for ( int j = i ; j < n ; j ++ ) {"}
{"text":"Initialise subarray_sum and remaining_sum to 0","code":"subarray_sum = 0 ; remaining_sum = 0 ;"}
{"text":"For loop to calculate the sum of generated subarray","code":"for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; }"}
{"text":"For loop to calculate the sum remaining array element","code":"for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; }"}
{"text":"Checking for condition when subarray sum is strictly greater than remaining sum of array element","code":"if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG { static int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ;"}
{"text":"Calculating total sum of given array","code":"for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; }"}
{"text":"For loop for beginning point of a subarray","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"initialise subarray_sum to 0","code":"subarray_sum = 0 ;"}
{"text":"For loop for calculating subarray_sum and remaining_sum","code":"for ( int j = i ; j < n ; j ++ ) {"}
{"text":"Calculating subarray_sum and corresponding remaining_sum","code":"subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ;"}
{"text":"Checking for the condition when subarray sum is strictly greater than the remaining sum of the array element","code":"if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the maximized XOR after removing an element from the array","code":"static int maxXOR ( int arr [ ] , int n ) {"}
{"text":"Find XOR of the complete array","code":"int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ;"}
{"text":"To store the final answer","code":"int ans = 0 ;"}
{"text":"Iterating through the array to find the final answer","code":"for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ;"}
{"text":"Return the final answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 3 } ; int n = arr . length ; System . out . println ( maxXOR ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that returns true if num contains at least one digit that divides k","code":"static boolean digitDividesK ( int num , int k ) { while ( num != 0 ) {"}
{"text":"Get the last digit","code":"int d = num % 10 ;"}
{"text":"If the digit is non - zero and it divides k","code":"if ( d != 0 && k % d == 0 ) return true ;"}
{"text":"Remove the last digit","code":"num = num \/ 10 ; }"}
{"text":"There is no digit in num that divides k","code":"return false ; }"}
{"text":"Function to return the required count of elements from the given range which contain at least one digit that divides k","code":"static int findCount ( int l , int r , int k ) {"}
{"text":"To store the result","code":"int count = 0 ;"}
{"text":"For every number from the range","code":"for ( int i = l ; i <= r ; i ++ ) {"}
{"text":"If any digit of the current number divides k","code":"if ( digitDividesK ( i , k ) ) count ++ ; } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int l = 20 , r = 35 ; int k = 45 ; System . out . println ( findCount ( l , r , k ) ) ; } }"}
{"text":"Java implementation for the above approach","code":"class GFG {"}
{"text":"Function to check if the given number is a factorial of any number","code":"static boolean isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n \/= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 24 ; boolean ans = isFactorial ( n ) ; if ( ans == true ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }"}
{"text":"Java implementation of the above approach","code":"class GFG {"}
{"text":"Function to return the LCM of two numbers","code":"static int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) \/ GCD ; }"}
{"text":"Function to return the minimum LCM after removing a single element from the given array","code":"static int MinLCM ( int a [ ] , int n ) {"}
{"text":"Prefix and Suffix arrays","code":"int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ;"}
{"text":"Single state dynamic programming relation for storing LCM of first i elements from the left in Prefix [ i ]","code":"Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; }"}
{"text":"Initializing Suffix array","code":"Suffix [ n ] = a [ n - 1 ] ;"}
{"text":"Single state dynamic programming relation for storing LCM of all the elements having index greater than or equal to i in Suffix [ i ]","code":"for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; }"}
{"text":"If first or last element of the array has to be removed","code":"int ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ;"}
{"text":"If any other element is replaced","code":"for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; }"}
{"text":"Return the minimum LCM","code":"return ans ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = a . length ; System . out . println ( MinLCM ( a , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the count of coloured 0 s in an n - level hexagon","code":"static int count ( int n ) { return n * ( 3 * n - 1 ) \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( count ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the minimum required value","code":"static int findMinValue ( int arr [ ] , int n ) {"}
{"text":"Find the sum of the array elements","code":"long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;"}
{"text":"Return the required value","code":"return ( ( int ) ( sum \/ n ) + 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . print ( findMinValue ( arr , n ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG { static final int MOD = 1000000007 ;"}
{"text":"Function to return ( m ! % MOD )","code":"static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( modFact ( n , m ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ;"}
{"text":"Function to return ( 2 ^ P % mod )","code":"static long power ( int p ) { long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; }"}
{"text":"Function to return the sum of squares of subsets","code":"static long subset_square_sum ( int A [ ] ) { int n = A . length ; long ans = 0 ;"}
{"text":"Sqauaring the elements and adding it to ans","code":"for ( int i : A ) { ans += ( 1 * i * i ) % mod ; ans %= mod ; } return ( 1 * ans * power ( n - 1 ) ) % mod ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] = { 3 , 7 } ; System . out . println ( subset_square_sum ( A ) ) ; } }"}
{"text":"Java program to find the number of pairs such that gcd equals to 1","code":"class GFG { static int N = 100050 ; static int [ ] lpf = new int [ N ] ; static int [ ] mobius = new int [ N ] ;"}
{"text":"Function to calculate least prime factor of each number","code":"static void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ )"}
{"text":"If it is a prime number","code":"if ( lpf [ i ] == 0 ) for ( int j = i ; j < N ; j += i )"}
{"text":"For all multiples which are not visited yet .","code":"if ( lpf [ j ] == 0 ) lpf [ j ] = i ; }"}
{"text":"Function to find the value of Mobius function for all the numbers from 1 to n","code":"static void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) {"}
{"text":"If number is one","code":"if ( i == 1 ) mobius [ i ] = 1 ; else {"}
{"text":"If number has a squared prime factor","code":"if ( lpf [ i \/ lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ;"}
{"text":"Multiply - 1 with the previous number","code":"else mobius [ i ] = - 1 * mobius [ i \/ lpf [ i ] ] ; } } }"}
{"text":"Function to find the number of pairs such that gcd equals to 1","code":"static int gcd_pairs ( int a [ ] , int n ) {"}
{"text":"To store maximum number","code":"int maxi = 0 ;"}
{"text":"To store frequency of each number","code":"int [ ] fre = new int [ N ] ;"}
{"text":"Find frequency and maximum number","code":"for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ;"}
{"text":"To store number of pairs with gcd equals to 1","code":"int ans = 0 ;"}
{"text":"Traverse through the all possible elements","code":"for ( int i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) \/ 2 * mobius [ i ] ; }"}
{"text":"Return the number of pairs","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . length ;"}
{"text":"Function call","code":"System . out . print ( gcd_pairs ( a , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to compare x ^ y and y ^ x","code":"static void compareVal ( int x , int y ) {"}
{"text":"Storing values OF x ^ y AND y ^ x","code":"double a = y * Math . log ( x ) ; double b = x * Math . log ( y ) ;"}
{"text":"Comparing values","code":"if ( a > b ) System . out . print ( x + \" ^ \" + y + \" \u2581 > \u2581 \" + y + \" ^ \" + x ) ; else if ( a < b ) System . out . print ( x + \" ^ \" + y + \" \u2581 < \u2581 \" + y + \" ^ \" + x ) ; else if ( a == b ) System . out . print ( x + \" ^ \" + y + \" \u2581 = \u2581 \" + y + \" ^ \" + x ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x = 4 , y = 5 ; compareVal ( x , y ) ; } }"}
{"text":"Java program to find zigzag sequence","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function to print first n zigzag numbers","code":"static void ZigZag ( int n ) {"}
{"text":"To store factorial and n 'th zig zag number","code":"long [ ] fact = new long [ n + 1 ] ; long [ ] zig = new long [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) zig [ i ] = 0 ;"}
{"text":"Initialize factorial upto n","code":"fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ;"}
{"text":"Set first two zig zag numbers","code":"zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; System . out . print ( \" zig \u2581 zag \u2581 numbers : \u2581 \" ) ;"}
{"text":"Print first two zig zag number","code":"System . out . print ( zig [ 0 ] + \" \u2581 \" + zig [ 1 ] + \" \u2581 \" ) ;"}
{"text":"Print the rest zig zag numbers","code":"for ( int i = 2 ; i < n ; i ++ ) { long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) {"}
{"text":"Binomial ( n , k ) * a ( k ) * a ( n - k )","code":"sum += ( fact [ i - 1 ] \/ ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; }"}
{"text":"Store the value","code":"zig [ i ] = sum \/ 2 ;"}
{"text":"Print the number","code":"System . out . print ( sum \/ 2 + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) throws java . lang . Exception { int n = 10 ;"}
{"text":"Function call","code":"ZigZag ( n ) ; } }"}
{"text":"Java program to demonstrate Gijswijt 's sequence","code":"import java . util . * ; class GFG {"}
{"text":"if the sequence is a ( 1 ) a ( 2 ) a ( 3 ) . . a ( n - 1 ) check if the sequence can be represented as x * ( y ^ k ) find the largest value of k","code":"static int find_count ( Vector < Integer > ele ) {"}
{"text":"count","code":"int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) {"}
{"text":"pattern of elements of size i from the end of sequence","code":"Vector < Integer > p = new Vector < Integer > ( ) ;"}
{"text":"count","code":"int c = 0 ;"}
{"text":"extract the pattern in a reverse order","code":"for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) { p . add ( ele . get ( j ) ) ; } int j = ele . size ( ) - 1 , k = 0 ;"}
{"text":"check how many times the pattern is repeated","code":"while ( j >= 0 ) {"}
{"text":"if the element dosent match","code":"if ( ele . get ( j ) != p . get ( k ) ) { break ; } j -- ; k ++ ;"}
{"text":"if the end of pattern is reached set value of k = 0 and increase the count","code":"if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = Math . max ( count , c ) ; }"}
{"text":"return the max count","code":"return count ; }"}
{"text":"print first n terms of Gijswijt 's sequence","code":"static void solve ( int n ) {"}
{"text":"set the count","code":"int count = 1 ;"}
{"text":"stoes the element","code":"Vector < Integer > ele = new Vector < Integer > ( ) ;"}
{"text":"print the first n terms of the sequence","code":"for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( count + \" , \u2581 \" ) ;"}
{"text":"push the element","code":"ele . add ( count ) ;"}
{"text":"find the count for next number","code":"count = find_count ( ele ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; solve ( n ) ; } }"}
{"text":"Java program to find N terms of the sequence","code":"import java . util . * ; class GFG {"}
{"text":"Stores the Wedderburn Etherington numbers","code":"static HashMap < Integer , Integer > store = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Function to return the nth Wedderburn Etherington numbers","code":"static int Wedderburn ( int n ) {"}
{"text":"Base case","code":"if ( n <= 2 ) return store . get ( n ) ;"}
{"text":"If n is even n = 2 x","code":"else if ( n % 2 == 0 ) {"}
{"text":"get x","code":"int x = n \/ 2 , ans = 0 ;"}
{"text":"a ( 2 x ) = a ( 1 ) a ( 2 x - 1 ) + a ( 2 ) a ( 2 x - 2 ) + ... + a ( x - 1 ) a ( x + 1 )","code":"for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; }"}
{"text":"a ( x ) ( a ( x ) + 1 ) \/ 2","code":"ans += ( store . get ( x ) * ( store . get ( x ) + 1 ) ) \/ 2 ;"}
{"text":"Store the ans","code":"store . put ( n , ans ) ;"}
{"text":"Return the required answer","code":"return ans ; } else {"}
{"text":"If n is odd","code":"int x = ( n + 1 ) \/ 2 , ans = 0 ;"}
{"text":"a ( 2 x - 1 ) = a ( 1 ) a ( 2 x - 2 ) + a ( 2 ) a ( 2 x - 3 ) + ... + a ( x - 1 ) a ( x ) ,","code":"for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; }"}
{"text":"Store the ans","code":"store . put ( n , ans ) ;"}
{"text":"Return the required answer","code":"return ans ; } }"}
{"text":"Function to print first N Wedderburn Etherington numbers","code":"static void Wedderburn_Etherington ( int n ) {"}
{"text":"Store first 3 numbers","code":"store . put ( 0 , 0 ) ; store . put ( 1 , 1 ) ; store . put ( 2 , 1 ) ;"}
{"text":"Print N terms","code":"for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( Wedderburn ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ;"}
{"text":"function call","code":"Wedderburn_Etherington ( n ) ; } }"}
{"text":"Java program to maximum value after merging all elements in the array","code":"import java . io . * ; class GFG {"}
{"text":"Function to maximum value after merging all elements in the array","code":"static int Max_sum ( int a [ ] , int n ) {"}
{"text":"To check if positive and negative elements present or not","code":"int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Check for positive integer","code":"if ( a [ i ] > 0 ) pos = 1 ;"}
{"text":"Check for negative integer","code":"else if ( a [ i ] < 0 ) neg = 1 ;"}
{"text":"If both positive and negative elements are present","code":"if ( ( pos == 1 ) && ( neg == 1 ) ) break ; }"}
{"text":"To store maximum value possible","code":"int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) {"}
{"text":"To find minimum value","code":"int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; }"}
{"text":"Remove minimum element","code":"sum -= 2 * mini ; } else if ( neg == 1 ) {"}
{"text":"Replace with absolute values","code":"for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ;"}
{"text":"To find minimum value","code":"int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; }"}
{"text":"Remove minimum element","code":"sum -= 2 * mini ; }"}
{"text":"Return the required sum","code":"return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] a = { 1 , 3 , 5 , - 2 , - 6 } ; int n = a . length ;"}
{"text":"Function call","code":"System . out . println ( Max_sum ( a , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Recursive function to convert n to its binary equivalent","code":"static void decimalToBinary ( int n ) {"}
{"text":"Base case","code":"if ( n == 0 ) { System . out . print ( \"0\" ) ; return ; }"}
{"text":"Recursive call","code":"decimalToBinary ( n \/ 2 ) ; System . out . print ( n % 2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 13 ; decimalToBinary ( n ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to find A , B and C","code":"static void MinimumValue ( int x , int y ) {"}
{"text":"Keep minimum number in x","code":"if ( x > y ) { int temp = x ; x = y ; y = temp ; }"}
{"text":"Find the numbers","code":"int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" + c ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x = 123 , y = 13 ;"}
{"text":"Function call","code":"MinimumValue ( x , y ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that returns true if A can be converted to B with the given operations","code":"static boolean canConvert ( int a , int b ) { while ( b > a ) {"}
{"text":"If the current number ends with 1","code":"if ( b % 10 == 1 ) { b \/= 10 ; continue ; }"}
{"text":"If the current number is divisible by 2","code":"if ( b % 2 == 0 ) { b \/= 2 ; continue ; }"}
{"text":"If above two conditions fail","code":"return false ; }"}
{"text":"If it is possible to convert A to B","code":"if ( b == a ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program to count unique rectangles in a chessboard","code":"class Rectangle {"}
{"text":"Function to count distinct rectangles","code":"static int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) \/ 2 ; return a ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 4 ; System . out . print ( count ( n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to return the number of days required","code":"static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) \/ ( a + b ) ; return Days ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 10 , b = 20 , n = 5 ; System . out . println ( numberOfDays ( a , b , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the average of x and y using bit operations","code":"static int getAverage ( int x , int y ) {"}
{"text":"Calculate the average Floor value of ( x + y ) \/ 2","code":"int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int x = 10 , y = 9 ; System . out . print ( getAverage ( x , y ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to find the smallest index such that there are no 0 or 1 to its right","code":"static int smallestIndex ( int [ ] a , int n ) {"}
{"text":"Initially","code":"int right1 = 0 , right0 = 0 ;"}
{"text":"Traverse in the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Check if array element is 1","code":"if ( a [ i ] == 1 ) right1 = i ;"}
{"text":"a [ i ] = 0","code":"else right0 = i ; }"}
{"text":"Return minimum of both","code":"return Math . min ( right1 , right0 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] a = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = a . length ; System . out . println ( smallestIndex ( a , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the count of squares that can be visited by king in m moves","code":"static int countSquares ( int r , int c , int m ) {"}
{"text":"To store the count of squares","code":"int squares = 0 ;"}
{"text":"Check all squares of the chessboard","code":"for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) {"}
{"text":"Check if square ( i , j ) is at a distance <= m units from king 's current position","code":"if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } }"}
{"text":"Return count of squares","code":"return squares ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int r = 4 , c = 4 , m = 1 ; System . out . print ( countSquares ( r , c , m ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the count of quadruples","code":"static int countQuadruples ( int a [ ] , int n ) {"}
{"text":"Hash table to count the number of occurrences","code":"HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Traverse and increment the count","code":"for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } int count = 0 ;"}
{"text":"Run two nested loop for second and third element","code":"for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) {"}
{"text":"If they are same","code":"if ( j == k ) continue ;"}
{"text":"Initially decrease the count","code":"mp . put ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . put ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ;"}
{"text":"Find the first element using common difference","code":"int first = a [ j ] - ( a [ k ] - a [ j ] ) ;"}
{"text":"Find the fourth element using GP y ^ 2 = x * z property","code":"int fourth = ( a [ k ] * a [ k ] ) \/ a [ j ] ;"}
{"text":"If it is an integer","code":"if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) {"}
{"text":"If not equal","code":"if ( a [ j ] != a [ k ] ) { if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; }"}
{"text":"Same elements","code":"else if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; }"}
{"text":"Later increase the value for future calculations","code":"if ( mp . containsKey ( a [ j ] ) ) { mp . put ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . put ( a [ j ] , 1 ) ; } if ( mp . containsKey ( a [ k ] ) ) { mp . put ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . put ( a [ k ] , 1 ) ; } } } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = a . length ; System . out . print ( countQuadruples ( a , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the count of required numbers","code":"static int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; }"}
{"text":"Count of numbers present in given range","code":"int totalnumbers = R - L + 1 ;"}
{"text":"Number of groups of 9 elements starting from L","code":"int factor9 = totalnumbers \/ 9 ;"}
{"text":"Left over elements not covered in factor 9","code":"int rem = totalnumbers % 9 ;"}
{"text":"One Number in each group of 9","code":"int ans = factor9 ;"}
{"text":"To check if any number in rem satisfy the property","code":"for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int L = 10 ; int R = 22 ; int K = 3 ; System . out . println ( countNumbers ( L , R , K ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the sum of even elements after updating value at given index","code":"static int EvenSum ( int [ ] A , int index , int value ) {"}
{"text":"Add given value to A [ index ]","code":"A [ index ] = A [ index ] + value ;"}
{"text":"To store the sum of even elements","code":"int sum = 0 ; for ( int i = 0 ; i < A . length ; i ++ )"}
{"text":"If current element is even","code":"if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; return sum ; }"}
{"text":"Function to print the result for every query","code":"static void BalanceArray ( int [ ] A , int [ ] [ ] Q ) {"}
{"text":"Resultant vector that stores the result for every query","code":"int [ ] ANS = new int [ Q . length ] ; int i , sum ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ;"}
{"text":"Get sum of even elements after updating value at given index","code":"sum = EvenSum ( A , index , value ) ;"}
{"text":"Store sum for each query","code":"ANS [ i ] = sum ; }"}
{"text":"Print the result for every query","code":"for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 } ; int [ ] [ ] Q = { { 0 , 1 } , { 1 , - 3 } , { 0 , - 4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to print the result for every query","code":"static void BalanceArray ( int [ ] A , int [ ] [ ] Q ) { int [ ] ANS = new int [ A . length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ )"}
{"text":"If current element is even","code":"if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ;"}
{"text":"If element is even then remove it from sum","code":"if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ;"}
{"text":"If the value becomes even after updating","code":"if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ;"}
{"text":"Store sum for each query","code":"ANS [ i ] = sum ; }"}
{"text":"Print the result for every query","code":"for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 } ; int [ ] [ ] Q = { { 0 , 1 } , { 1 , - 3 } , { 0 , - 4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; } }"}
{"text":"Java program for implementation of the above program","code":"class GFG {"}
{"text":"Function that calculates number of Hamiltonian cycle","code":"static int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ;"}
{"text":"Calculating factorial","code":"int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 5 ; int Number = Cycles ( N ) ; System . out . println ( \" Hamiltonian \u2581 cycles \u2581 = \u2581 \" + Number ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that returns true if n contains digit m exactly k times","code":"static boolean digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n \/= 10 ; } return cnt == k ; }"}
{"text":"Function to return the smallest integer > n with digit m occurring exactly k times","code":"static int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 111 , m = 2 , k = 2 ; System . out . println ( findInt ( n , m , k ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the count of odd numbers in the array","code":"static int countOdd ( int [ ] arr , int n ) {"}
{"text":"Variable to count odd numbers","code":"int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Odd number","code":"if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; }"}
{"text":"Function to return the count of valid pairs","code":"static int countValidPairs ( int [ ] arr , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) \/ 2 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( countValidPairs ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the gcd of two numbers","code":"static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }"}
{"text":"Function to return the lcm of aint the elements of the array","code":"static int lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ;"}
{"text":"To calculate lcm of two numbers multiply them and divide the result by gcd of both the numbers","code":"for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) \/ gcd ( lcm , arr [ i ] ) ;"}
{"text":"Return the LCM of the array elements","code":"return lcm ; }"}
{"text":"Function to return the smaintest perfect cube divisible by aint the elements of arr [ ]","code":"static int minPerfectCube ( int arr [ ] , int n ) { int minPerfectCube ;"}
{"text":"LCM of all the elements of arr [ ]","code":"int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm \/= 2 ; }"}
{"text":"If 2 divides lcm cnt number of times","code":"if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ;"}
{"text":"Check aint the numbers that divide lcm","code":"while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm \/= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; }"}
{"text":"Return the answer","code":"return minPerfectCube ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . length ; System . out . println ( minPerfectCube ( arr , n ) ) ; } }"}
{"text":"Java program to check if given number is strong prime","code":"class GFG {"}
{"text":"Utility function to check if a number is prime or not","code":"static boolean isPrime ( int n ) {"}
{"text":"Corner cases","code":"if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }"}
{"text":"Function that returns true if n is a strong prime","code":"static boolean isStrongPrime ( int n ) {"}
{"text":"If n is not a prime number or n is the first prime then return false","code":"if ( ! isPrime ( n ) n == 2 ) return false ;"}
{"text":"Initialize previous_prime to n - 1 and next_prime to n + 1","code":"int previous_prime = n - 1 ; int next_prime = n + 1 ;"}
{"text":"Find next prime number","code":"while ( ! isPrime ( next_prime ) ) next_prime ++ ;"}
{"text":"Find previous prime number","code":"while ( ! isPrime ( previous_prime ) ) previous_prime -- ;"}
{"text":"Arithmetic mean","code":"int mean = ( previous_prime + next_prime ) \/ 2 ;"}
{"text":"If n is a strong prime","code":"if ( n > mean ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 11 ; if ( isStrongPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java Program to count the number of digits that can be removed such that number is divisible by 10 ^ K","code":"public class GFG {"}
{"text":"function to return the required number of digits to be removed","code":"static int countDigitsToBeRemoved ( int N , int K ) {"}
{"text":"Converting the given number into string","code":"String s = Integer . toString ( N ) ;"}
{"text":"variable to store number of digits to be removed","code":"int res = 0 ;"}
{"text":"variable to denote if atleast one zero has been found","code":"int f_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s . charAt ( i ) == '0' ) {"}
{"text":"zero found","code":"f_zero = 1 ; K -- ; } else res ++ ; }"}
{"text":"return size - 1 if K is not zero and atleast one zero is present , otherwise result","code":"if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . length ( ) - 1 ; return - 1 ; }"}
{"text":"Driver Code to test above function","code":"public static void main ( String [ ] args ) { int N = 10904025 ; int K = 2 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; N = 1000 ; K = 5 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; N = 23985 ; K = 2 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; } }"}
{"text":"Java program to find the sum of the given series","code":"import java . util . Scanner ; public class HelloWorld {"}
{"text":"Function to return the sum of the series","code":"public static float getSum ( int a , int n ) {"}
{"text":"variable to store the answer","code":"float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) {"}
{"text":"Math . pow ( x , y ) returns x ^ y","code":"sum += ( i \/ Math . pow ( a , i ) ) ; } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 3 , n = 3 ;"}
{"text":"Print the sum of the series","code":"System . out . println ( getSum ( a , n ) ) ; } }"}
{"text":"Java Program to check Unusual number","code":"class GFG {"}
{"text":"Utility function to find largest prime factor of a number","code":"static int largestPrimeFactor ( int n ) {"}
{"text":"Initialize the maximum prime factor variable with the lowest one","code":"int max = - 1 ;"}
{"text":"Print the number of 2 s that divide n","code":"while ( n % 2 == 0 ) { max = 2 ;"}
{"text":"n >>= 1 ; equivalent to n \/= 2","code":"}"}
{"text":"n must be odd at this point , thus skip the even numbers and iterate only for odd integers","code":"for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n \/ i ; } }"}
{"text":"This condition is to handle the case when n is a prime number greater than 2","code":"if ( n > 2 ) max = n ; return max ; }"}
{"text":"Function to check Unusual number","code":"static boolean checkUnusual ( int n ) {"}
{"text":"Get the largest Prime Factor of the number","code":"int factor = largestPrimeFactor ( n ) ;"}
{"text":"Check if largest prime factor is greater than sqrt ( n )","code":"if ( factor > Math . sqrt ( n ) ) { return true ; } else { return false ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 14 ; if ( checkUnusual ( n ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java Program to find whether half - array reducible to 0","code":"public class GFG {"}
{"text":"Function to print the desired result after computation","code":"static void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ ] = new int [ m + 1 ] ; int i ; for ( i = 0 ; i < frequencyHash . length ; i ++ ) frequencyHash [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n \/ 2 ) break ; } if ( i <= m ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = arr . length ; int m = 7 ; isHalfReducible ( arr , n , m ) ; } }"}
{"text":"Java program to check if the given number is Ore number","code":"import java . util . * ; class GFG { static Vector < Integer > arr = new Vector < Integer > ( ) ;"}
{"text":"Function that returns harmonic mean .","code":"static void generateDivisors ( int n ) {"}
{"text":"Note that this loop runs till square root","code":"for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {"}
{"text":"If divisors are equal , store ' i '","code":"if ( n \/ i == i ) arr . add ( i ) ;"}
{"text":"else Otherwise store ' i ' and ' n \/ i ' both","code":"{ arr . add ( i ) ; arr . add ( n \/ i ) ; } } } }"}
{"text":"Utility function to calculate harmonic mean of the divisors","code":"static double harmonicMean ( int n ) { generateDivisors ( n ) ;"}
{"text":"Declare sum variables and initialize with zero .","code":"double sum = 0.0 ; int len = arr . size ( ) ;"}
{"text":"calculate denominator","code":"for ( int i = 0 ; i < len ; i ++ ) sum = sum + n \/ arr . get ( i ) ; sum = sum \/ n ;"}
{"text":"Calculate harmonic mean and return","code":"return arr . size ( ) \/ sum ; }"}
{"text":"Function to check if a number is Ore number","code":"static boolean isOreNumber ( int n ) {"}
{"text":"Calculate Harmonic mean of divisors of n","code":"double mean = harmonicMean ( n ) ;"}
{"text":"Check if Harmonic mean is an Integer or not","code":"if ( mean - Math . floor ( mean ) == 0 ) return true ; else return false ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 28 ; if ( isOreNumber ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text":"Java program to check Euclid Number","code":"import java . util . * ; class GFG { static int MAX = 10000 ; static HashSet < Integer > s = new HashSet < Integer > ( ) ;"}
{"text":"Function to generate the Prime numbers and store their products","code":"static void SieveOfEratosthenes ( ) {"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } }"}
{"text":"store prefix product of prime numbers to unordered_set ' s '","code":"int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) {"}
{"text":"update product by multiplying next prime","code":"product = product * p ;"}
{"text":"insert ' produc + 1' to set","code":"s . add ( product + 1 ) ; } } }"}
{"text":"Function to check the number for Euclid Number","code":"static boolean isEuclid ( int n ) {"}
{"text":"Check if number exist in unordered set or not If exist , return true","code":"if ( s . contains ( n ) ) return true ; else return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Get the prime numbers","code":"SieveOfEratosthenes ( ) ;"}
{"text":"Get n","code":"int n = 31 ;"}
{"text":"Check if n is Euclid Number","code":"if ( isEuclid ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;"}
{"text":"Get n","code":"n = 42 ;"}
{"text":"Check if n is Euclid Number","code":"if ( isEuclid ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"JAVA program to check if a number is Wagstaff prime or not","code":"class GFG {"}
{"text":"Function to check if a number is prime or not","code":"static boolean isPrime ( int n ) {"}
{"text":"Corner cases","code":"if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }"}
{"text":"Utility function to check power of two","code":"static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }"}
{"text":"Driver Program","code":"public static void main ( String [ ] args ) { int n = 43 ;"}
{"text":"Check if number is prime and of the form ( 2 ^ q + 1 ) \/ 3","code":"if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java Program to find the area of the square inscribed within the circle which in turn is inscribed in a hexagon","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the area of the square","code":"static float area ( float a ) {"}
{"text":"side of hexagon cannot be negative","code":"if ( a < 0 ) return - 1 ;"}
{"text":"area of the square","code":"float area = ( float ) Math . pow ( ( a * Math . sqrt ( 3 ) ) \/ ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( area ( a ) ) ; } }"}
{"text":"Java program to find the N - th term of the series : 1 , 6 , 17 , 34 , 56 , 86 , 121 , 162 , ... . .","code":"public class GFG {"}
{"text":"calculate Nth term of series","code":"static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) - 4 * n + 2 ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }"}
{"text":"Java program to find sum of first n terms","code":"public class GFG {"}
{"text":"Function to calculate the sum","code":"static int calculateSum ( int n ) { return n * ( n + 1 ) \/ 2 + ( int ) Math . pow ( ( n * ( n + 1 ) \/ 2 ) , 2 ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) {"}
{"text":"number of terms to be included in the sum","code":"int n = 3 ;"}
{"text":"find the Sum","code":"System . out . println ( \" Sum \u2581 = \u2581 \" + calculateSum ( n ) ) ; } }"}
{"text":"Java code to check if arrays are permutations of eah other","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if arrays are permutations of each other .","code":"static boolean arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ;"}
{"text":"Calculating sum and multiply of first array","code":"for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; }"}
{"text":"Calculating sum and multiply of second array","code":"for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; }"}
{"text":"If sum and mul of both arrays are equal , return true , else return false .","code":"return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = a . length ; int m = b . length ; if ( arePermutations ( a , b , n , m ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of above approach","code":"public class GFG {"}
{"text":"Function to find the B start to C","code":"static int Race ( int B , int C ) { int result = 0 ;"}
{"text":"When B completed it 's 100 meter  then Completed meters by C is","code":"result = ( ( C * 100 ) \/ B ) ; return 100 - result ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int B = 10 ; int C = 28 ;"}
{"text":"When A completed it 's 100 meter  Then completed meters of B and C is","code":"B = 100 - B ; C = 100 - C ; System . out . println ( Race ( B , C ) + \" \u2581 meters \" ) ; } }"}
{"text":"Java implementation of above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the time","code":"static float Time ( float arr [ ] , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 \/ arr [ i ] ; fill = fill - ( 1 \/ ( float ) Emptypipe ) ; return 1 \/ fill ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = arr . length ; System . out . println ( ( int ) ( Time ( arr , n , Emptypipe ) ) + \" \u2581 Hours \" ) ; } }"}
{"text":"Java program to check if Decimal representation of an Octal number is divisible by 7 or not","code":"import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {"}
{"text":"Function to check Divisibility","code":"static int check ( int n ) { int sum = 0 ;"}
{"text":"Sum of all individual digits","code":"while ( n != 0 ) { sum += n % 10 ; n = n \/ 10 ; }"}
{"text":"Condition","code":"if ( sum % 7 == 0 ) return 1 ; else return 0 ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Octal number","code":"int n = 25 ; String s = ( check ( n ) == 1 ) ? \" YES \" : \" NO \" ; System . out . println ( s ) ; } }"}
{"text":"Java program to find sum of prime divisors of N","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to check if the number is prime or not .","code":"static boolean isPrime ( int n ) {"}
{"text":"Corner cases","code":"if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }"}
{"text":"function to find sum of prime divisors of N","code":"static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 60 ; System . out . print ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + SumOfPrimeDivisors ( n ) + \"NEW_LINE\"); } }"}
{"text":"Java program to find prime divisors of all numbers from 1 to n","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"function to find prime divisors of all numbers from 1 to n","code":"static int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) {"}
{"text":"if the number is prime","code":"if ( SumOfPrimeDivisors [ i ] == 0 ) {"}
{"text":"add this prime to all it 's multiples","code":"for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int N = 60 ; System . out . print ( \" Sum \u2581 of \u2581 prime \u2581 \" + \" divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + Sum ( N ) + \"NEW_LINE\"); } }"}
{"text":"Java program to find ( a ^ b ) % m for b very large .","code":"import java . io . * ; class GFG {"}
{"text":"Function to find power","code":"static long power ( long x , long y , long p ) {"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p ; while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with the result","code":"if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ;"}
{"text":"y must be even now y = y >> 1 ; y = y \/ 2","code":"x = ( x * x ) % p ; } return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { long a = 3 ;"}
{"text":"String input as b is very large","code":"String b = \"100000000000000000000000000\" ; long remainderB = 0 ; long MOD = 1000000007 ;"}
{"text":"Reduce the number B to a small number using Fermat Little","code":"for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b . charAt ( i ) - '0' ) % ( MOD - 1 ) ; System . out . println ( power ( a , remainderB , MOD ) ) ; } }"}
{"text":"Java program to find square of these large numbers","code":"class GFG {"}
{"text":"Function to find the square of 333. . .333 , 666. . .666 and 999. . .999","code":"static String find_Square_369 ( String num ) { char a , b , c , d ;"}
{"text":"if the number is 333. . .333","code":"if ( num . charAt ( 0 ) == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; }"}
{"text":"if the number is 666. . .666","code":"else if ( num . charAt ( 0 ) == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; }"}
{"text":"if the number is 999. . .999","code":"else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; }"}
{"text":"variable for hold result","code":"String result = \" \" ;"}
{"text":"find the no of digit","code":"int size = num . length ( ) ;"}
{"text":"add size - 1 time a in result","code":"for ( int i = 1 ; i < size ; i ++ ) result += a ;"}
{"text":"add one time b in result","code":"result += b ;"}
{"text":"add size - 1 time c in result","code":"for ( int i = 1 ; i < size ; i ++ ) result += c ;"}
{"text":"add one time d in result","code":"result += d ;"}
{"text":"return result","code":"return result ; }"}
{"text":"Drivers code","code":"public static void main ( String [ ] args ) { String num_3 , num_6 , num_9 ; num_3 = \"3333\" ; num_6 = \"6666\" ; num_9 = \"9999\" ; String result = \" \" ;"}
{"text":"find square of 33. .33","code":"result = find_Square_369 ( num_3 ) ; System . out . println ( \" Square \u2581 of \u2581 \" + num_3 + \" \u2581 is \u2581 : \u2581 \" + result ) ;"}
{"text":"find square of 66. .66","code":"result = find_Square_369 ( num_6 ) ; System . out . println ( \" Square \u2581 of \u2581 \" + num_9 + \" \u2581 is \u2581 : \u2581 \" + result ) ;"}
{"text":"find square of 66. .66","code":"result = find_Square_369 ( num_9 ) ; System . out . println ( \" Square \u2581 of \u2581 \" + num_9 + \" \u2581 is \u2581 : \u2581 \" + result ) ; } }"}
{"text":"Java code to find number of ways to multiply n elements with an associative operation","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the required factorial","code":"static int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }"}
{"text":"Function to find nCr","code":"static int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) \/ ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; }"}
{"text":"function to find the number of ways","code":"static int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( solve ( n ) ) ; } }"}
{"text":"Java program to find Pythagorean Triplet of given sum .","code":"class GFG { static void pythagoreanTriplet ( int n ) {"}
{"text":"Considering triplets in sorted order . The value of first element in sorted triplet can be at - most n \/ 3.","code":"for ( int i = 1 ; i <= n \/ 3 ; i ++ ) {"}
{"text":"The value of second element must be less than equal to n \/ 2","code":"for ( int j = i + 1 ; j <= n \/ 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + \" , \u2581 \" + j + \" , \u2581 \" + k ) ; return ; } } } System . out . print ( \" No \u2581 Triplet \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String arg [ ] ) { int n = 12 ; pythagoreanTriplet ( n ) ; } }"}
{"text":"Java program to print terms of binomial series and also calculate sum of series .","code":"import java . io . * ; class GFG {"}
{"text":"function to calculate factorial of a number","code":"static int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }"}
{"text":"function to print the series","code":"static void series ( int A , int X , int n ) {"}
{"text":"calculating the value of n !","code":"int nFact = factorial ( n ) ;"}
{"text":"loop to display the series","code":"for ( int i = 0 ; i < n + 1 ; i ++ ) {"}
{"text":"For calculating the value of nCr","code":"int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ;"}
{"text":"calculating the value of A to the power k and X to the power k","code":"int aPow = ( int ) Math . pow ( A , n - i ) ; int xPow = ( int ) Math . pow ( X , i ) ;"}
{"text":"display the series","code":"System . out . print ( ( nFact * aPow * xPow ) \/ ( niFact * iFact ) + \" \u2581 \" ) ; } }"}
{"text":"main function started","code":"public static void main ( String [ ] args ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }"}
{"text":"Java program to find sum of series with alternate signed square AP sums .","code":"import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"function to calculate series sum","code":"static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; System . out . println ( seiresSum ( n , a ) ) ; } }"}
{"text":"Java program to find power of a prime number ' r ' in n !","code":"class GFG {"}
{"text":"Function to return power of a no . ' r ' in factorial of n","code":"static int power ( int n , int r ) {"}
{"text":"Keep dividing n by powers of ' r ' and update count","code":"int count = 0 ; for ( int i = r ; ( n \/ i ) >= 1 ; i = i * r ) count += n \/ i ; return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 6 , r = 3 ; System . out . print ( power ( n , r ) ) ; } }"}
{"text":"Java program to find average of sum of first n odd natural numbers .","code":"import java . io . * ; class GFG {"}
{"text":"Returns the Avg of first n odd numbers","code":"static int avg_of_odd_num ( int n ) {"}
{"text":"sum of first n odd number","code":"int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ;"}
{"text":"Average of first n odd numbers","code":"return sum \/ n ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 20 ; avg_of_odd_num ( n ) ; System . out . println ( avg_of_odd_num ( n ) ) ; } }"}
{"text":"java Program to find the average of sum of first n odd numbers","code":"import java . io . * ; class GFG {"}
{"text":"Return the average of sum of first n odd numbers","code":"static int avg_of_odd_num ( int n ) { return n ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( avg_of_odd_num ( n ) ) ; } }"}
{"text":"Java Implementation for Fibonacci triangle","code":"import java . io . * ; class GFG {"}
{"text":"function to fill Fibonacci Numbers in f [ ]","code":"static void fib ( int f [ ] , int N ) {"}
{"text":"1 st and 2 nd number of the series are 1 and 1","code":"f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ )"}
{"text":"Add the previous 2 numbers in the series and store it","code":"f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } static void fiboTriangle ( int n ) {"}
{"text":"Fill Fibonacci numbers in f [ ] using fib ( ) . We need N = n * ( n + 1 ) \/ 2 Fibonacci numbers to make a triangle of height n","code":"int N = n * ( n + 1 ) \/ 2 ; int f [ ] = new int [ N + 1 ] ; fib ( f , N ) ;"}
{"text":"To store next Fibonacci Number to print","code":"int fiboNum = 1 ;"}
{"text":"for loop to keep track of number of lines","code":"for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"For loop to keep track of numbers in each line","code":"for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( f [ fiboNum ++ ] + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 5 ; fiboTriangle ( n ) ; } }"}
{"text":"Program to find average of odd numbers till a given odd number .","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the average of odd numbers","code":"static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) {"}
{"text":"count odd numbers","code":"count ++ ;"}
{"text":"store the sum of odd numbers","code":"sum += n ; n = n - 2 ; } return sum \/ count ; }"}
{"text":"driver function","code":"public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }"}
{"text":"Program to find average of odd numbers till a given odd number .","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the average of odd numbers","code":"static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return ( n + 1 ) \/ 2 ; }"}
{"text":"driver function","code":"public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }"}
{"text":"JAVA program to find max between two Rational numbers","code":"class GFG { static class Rational { int nume , deno ; public Rational ( int nume , int deno ) { this . nume = nume ; this . deno = deno ; } } ;"}
{"text":"Get lcm of two number 's","code":"static int lcm ( int a , int b ) { return ( a * b ) \/ ( __gcd ( a , b ) ) ; }"}
{"text":"Get max rational number","code":"static Rational maxRational ( Rational first , Rational sec ) {"}
{"text":"Find the LCM of first . denominator and sec . denominator","code":"int k = lcm ( first . deno , sec . deno ) ;"}
{"text":"Declare nume1 and nume2 for get the value of first numerator and second numerator","code":"int nume1 = first . nume ; int nume2 = sec . nume ; nume1 *= k \/ ( first . deno ) ; nume2 *= k \/ ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { Rational first = new Rational ( 3 , 2 ) ; Rational sec = new Rational ( 3 , 4 ) ; Rational res = maxRational ( first , sec ) ; System . out . print ( res . nume + \" \/ \" + res . deno ) ; } }"}
{"text":"Java Program to print trinomial triangle .","code":"import java . util . * ; import java . lang . * ; public class GfG {"}
{"text":"Function to find the trinomial triangle value .","code":"public static int TrinomialValue ( int n , int k ) {"}
{"text":"base case","code":"if ( n == 0 && k == 0 ) return 1 ;"}
{"text":"base case","code":"if ( k < - n k > n ) return 0 ;"}
{"text":"recursive step .","code":"return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; }"}
{"text":"Function to print Trinomial Triangle of height n .","code":"public static void printTrinomial ( int n ) {"}
{"text":"printing n rows .","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"printing first half of triangle","code":"for ( int j = - i ; j <= 0 ; j ++ ) System . out . print ( TrinomialValue ( i , j ) + \" \u2581 \" ) ;"}
{"text":"printing second half of triangle .","code":"for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( TrinomialValue ( i , j ) + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"driver function","code":"public static void main ( String argc [ ] ) { int n = 4 ; printTrinomial ( n ) ; } }"}
{"text":"Java Program to print trinomial triangle .","code":"import java . util . * ; import java . lang . * ; public class GfG { private static final int MAX = 10 ;"}
{"text":"Function to find the trinomial triangle value .","code":"public static int TrinomialValue ( int dp [ ] [ ] , int n , int k ) {"}
{"text":"Using property of trinomial triangle .","code":"if ( k < 0 ) k = - k ;"}
{"text":"If value already calculated , return that .","code":"if ( dp [ n ] [ k ] != 0 ) return dp [ n ] [ k ] ;"}
{"text":"base case","code":"if ( n == 0 && k == 0 ) return 1 ;"}
{"text":"base case","code":"if ( k < - n k > n ) return 0 ;"}
{"text":"recursive step and storing the value .","code":"return ( dp [ n ] [ k ] = TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) ; }"}
{"text":"Function to print Trinomial Triangle of height n .","code":"public static void printTrinomial ( int n ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;"}
{"text":"printing n rows .","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"printing first half of triangle","code":"for ( int j = - i ; j <= 0 ; j ++ ) System . out . print ( TrinomialValue ( dp , i , j ) + \" \u2581 \" ) ;"}
{"text":"printing second half of triangle .","code":"for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( TrinomialValue ( dp , i , j ) + \" \u2581 \" ) ; System . out . println ( ) ; } }"}
{"text":"driver function","code":"public static void main ( String argc [ ] ) { int n = 4 ; printTrinomial ( n ) ; } }"}
{"text":"Java implementation to find sum of largest prime factor of each number less than equal to n","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"function to find sum of largest prime factorof each number less than equal to n","code":"static int sumOfLargePrimeFactor ( int n ) {"}
{"text":"Create an integer array \" prime [ 0 . . n ] \" and initialize all entries of it as 0. A value in prime [ i ] will finally be 0 if ' i ' is a prime , else it will contain the largest prime factor of ' i ' .","code":"int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n \/ 2 ; for ( int p = 2 ; p <= max ; p ++ ) {"}
{"text":"If prime [ p ] is '0' , then it is a prime number","code":"if ( prime [ p ] == 0 ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } }"}
{"text":"Sum up the largest prime factor of all the numbers","code":"for ( int p = 2 ; p <= n ; p ++ ) {"}
{"text":"if ' p ' is a non - prime number then prime [ p ] gives its largesr prime factor","code":"if ( prime [ p ] != 0 ) sum += prime [ p ] ;"}
{"text":"' p ' is a prime number","code":"else sum += p ; }"}
{"text":"required sum","code":"return sum ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { int n = 12 ; System . out . println ( \" Sum \u2581 = \u2581 \" + sumOfLargePrimeFactor ( n ) ) ; } }"}
{"text":"Java program to find sum of multiples of a number up to N efficiently","code":"class GFG {"}
{"text":"Function for calculating sum of multiples of a upto N","code":"static int calculate_sum ( int a , int N ) {"}
{"text":"Number of multiples","code":"int m = N \/ a ;"}
{"text":"sum of first m natural numbers","code":"int sum = m * ( m + 1 ) \/ 2 ;"}
{"text":"sum of multiples","code":"int ans = a * sum ; return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 7 , N = 49 ; System . out . println ( \" Sum \u2581 of \u2581 multiples \u2581 of \u2581 \" + a + \" \u2581 up \u2581 to \u2581 \" + N + \" \u2581 = \u2581 \" + calculate_sum ( a , N ) ) ; } }"}
{"text":"Java program to find whether a number is power of 2 or not","code":"import java . util . * ; class GFG {"}
{"text":"returns 1 when str is power of 2 return 0 when str is not a power of 2","code":"static int isPowerOf2 ( String s ) { char [ ] str = s . toCharArray ( ) ; int len_str = s . length ( ) ;"}
{"text":"sum stores the intermediate dividend while dividing .","code":"int num = 0 ;"}
{"text":"if the input is \"1\" then return 0 because 2 ^ k = 1 where k >= 1 and here k = 0","code":"if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ;"}
{"text":"Divide the number until it gets reduced to 1 if we are successfully able to reduce the number to 1 it means input string is power of two if in between an odd number appears at the end it means string is not divisible by two hence not a power of 2.","code":"while ( len_str != 1 str [ len_str - 1 ] != '1' ) {"}
{"text":"if the last digit is odd then string is not divisible by 2 hence not a power of two return 0.","code":"if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ;"}
{"text":"divide the whole string by 2. i is used to track index in current number . j is used to track index for next iteration .","code":"int j = 0 ; for ( int i = 0 ; i < len_str ; i ++ ) { num = num * 10 + ( int ) str [ i ] - ( int ) '0' ;"}
{"text":"if num < 2 then we have to take another digit to the right of A [ i ] to make it bigger than A [ i ] . E . g . 214 \/ 2 -- > 107","code":"if ( num < 2 ) {"}
{"text":"if it 's not the first index. E.g 214  then we have to include 0.","code":"if ( i != 0 ) str [ j ++ ] = '0' ;"}
{"text":"for eg . \"124\" we will not write 064 so if it is the first index just ignore","code":"continue ; } str [ j ++ ] = ( char ) ( ( int ) ( num \/ 2 ) + ( int ) '0' ) ; num = ( num ) - ( num \/ 2 ) * 2 ; } str [ j ] = ' \\0' ;"}
{"text":"After every division by 2 the length of string is changed .","code":"len_str = j ; }"}
{"text":"if the string reaches to 1 then the str is a power of 2.","code":"return 1 ; }"}
{"text":"Driver code .","code":"public static void main ( String [ ] args ) { String str1 = \"124684622466842024680246842024662202000002\" ; String str2 = \"1\" ; String str3 = \"128\" ; System . out . println ( isPowerOf2 ( str1 ) + \"NEW_LINE\"+isPowerOf2(str2) +NEW_LINE\"NEW_LINE\"+isPowerOf2(str3)); } }"}
{"text":"Java program to find whether a number is power of 2 or not","code":"class GfG {"}
{"text":"Function to check whether a number is power of 2 or not","code":"static long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { long num = 549755813888L ; System . out . println ( ispowerof2 ( num ) ) ; } }"}
{"text":"A simple Java program to count divisors in array multiplication .","code":"class GFG {"}
{"text":"To count number of factors in a number","code":"static int counDivisors ( int X ) {"}
{"text":"Initialize count with 0","code":"int count = 0 ;"}
{"text":"Increment count for every factor of the given number X .","code":"for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } }"}
{"text":"Return number of factors","code":"return count ; }"}
{"text":"Returns number of divisors in array multiplication","code":"static int countDivisorsMult ( int arr [ ] , int n ) {"}
{"text":"Multipliying all elements of the given array .","code":"int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ;"}
{"text":"Calling function which count number of factors of the number","code":"return counDivisors ( mul ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( countDivisorsMult ( arr , n ) ) ; } }"}
{"text":"Java program to count divisors in array multiplication .","code":"import java . io . * ; import java . util . * ; class GFG { static void SieveOfEratosthenes ( int largest , ArrayList < Integer > prime ) {"}
{"text":"Create a boolean array \" isPrime [ 0 . . n ] \" and initialize all entries it as true . A value in isPrime [ i ] will finally be false if i is Not a isPrime , else true .","code":"boolean [ ] isPrime = new boolean [ largest + 1 ] ; Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) {"}
{"text":"If isPrime [ p ] is not changed , then it is a isPrime","code":"if ( isPrime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } }"}
{"text":"Print all isPrime numbers","code":"for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . add ( p ) ; }"}
{"text":"Returns number of divisors in array multiplication","code":"static long countDivisorsMult ( int [ ] arr , int n ) {"}
{"text":"Find all prime numbers smaller than the largest element .","code":"int largest = 0 ; for ( int a : arr ) { largest = Math . max ( largest , a ) ; } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; SieveOfEratosthenes ( largest , prime ) ;"}
{"text":"Find counts of occurrences of each prime factor","code":"Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime . get ( j ) == 0 ) { arr [ i ] \/= prime . get ( j ) ; if ( mp . containsKey ( prime . get ( j ) ) ) { mp . put ( prime . get ( j ) , mp . get ( prime . get ( j ) ) + 1 ) ; } else { mp . put ( prime . get ( j ) , 1 ) ; } } } if ( arr [ i ] != 1 ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } }"}
{"text":"Compute count of all divisors using counts prime factors .","code":"long res = 1 ; for ( int it : mp . keySet ( ) ) res *= ( mp . get ( it ) + 1L ) ; return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( countDivisorsMult ( arr , n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class solution {"}
{"text":"Function to generate prime numbers in the given range [ L , R ]","code":"static void findPrimeNos ( int L , int R , Map < Integer , Integer > M , int K ) {"}
{"text":"Store all value in the range","code":"for ( int i = L ; i <= R ; i ++ ) { if ( M . get ( i ) != null ) M . put ( i , M . get ( i ) + 1 ) ; else M . put ( i , 1 ) ; }"}
{"text":"Erase 1 as its non - prime","code":"if ( M . get ( 1 ) != null ) { M . remove ( 1 ) ; }"}
{"text":"Perform Sieve of Eratosthenes","code":"for ( int i = 2 ; i <= Math . sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) {"}
{"text":"Find current multiple","code":"if ( M . get ( i * multiple ) != null ) {"}
{"text":"Erase as it is a non - prime","code":"M . remove ( i * multiple ) ; }"}
{"text":"Increment multiple","code":"multiple ++ ; } }"}
{"text":"Traverse the Map M","code":"for ( Map . Entry < Integer , Integer > entry : M . entrySet ( ) ) {"}
{"text":"If it . first & ( it . first + K ) is prime then print this pair","code":"if ( M . get ( entry . getKey ( ) + K ) != null ) { System . out . print ( \" ( \" + entry . getKey ( ) + \" , \u2581 \" + ( entry . getKey ( ) + K ) + \" ) \u2581 \" ) ; } } }"}
{"text":"Function to print all the prime pairs in the given range that differs by K","code":"static void getPrimePairs ( int L , int R , int K ) { Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Generate all prime number","code":"findPrimeNos ( L , R , M , K ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given range","code":"int L = 1 , R = 19 ;"}
{"text":"Given K","code":"int K = 6 ;"}
{"text":"Function Call","code":"getPrimePairs ( L , R , K ) ; } }"}
{"text":"Java program to find N - th Enneacontahexagon Number","code":"class GFG {"}
{"text":"Function to find the nth Enneacontahexagon Number","code":"static int enneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) \/ 2 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( enneacontahexagonNum ( n ) ) ; } }"}
{"text":"Java code to Find two Composite Numbers such that there difference is N","code":"class GFG {"}
{"text":"Function to find the two composite numbers","code":"static void find_composite_nos ( int n ) { System . out . println ( 9 * n + \" \u2581 \" + 8 * n ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 4 ; find_composite_nos ( n ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to find number of unordered pairs","code":"static int freqPairs ( int arr [ ] , int n ) {"}
{"text":"Maximum element from the array","code":"int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;"}
{"text":"Array to store the frequency of each element","code":"int freq [ ] = new int [ max + 1 ] ;"}
{"text":"Stores the number of unordered pairs","code":"int count = 0 ;"}
{"text":"Store the frequency of each element","code":"for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; }"}
{"text":"Find the number of unordered pairs","code":"for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) {"}
{"text":"If the number j divisible by ith element is present in the array","code":"if ( freq [ j ] >= 1 ) { count += freq [ j ] ; } }"}
{"text":"If the ith element of the array has frequency more than one","code":"if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = arr . length ; System . out . println ( freqPairs ( arr , n ) ) ; } }"}
{"text":"Java program to find Nth term of the series : 1 + 2 + 6 + 15 + 31 + 56 + ...","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"calculate Nth term of given series","code":"static double Nth_Term ( int n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) \/ 6 ; }"}
{"text":"Driver code","code":"static public void main ( String args [ ] ) { int N = 8 ; System . out . println ( Nth_Term ( N ) ) ; } }"}
{"text":"Java program to find n - th number in a series made of digits 3 and 5","code":"class FindNth {"}
{"text":"Function to find n - th number in series made of 3 and 5","code":"static int printNthElement ( int n ) {"}
{"text":"create an array of size ( n + 1 )","code":"int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) {"}
{"text":"If i is odd","code":"if ( i % 2 != 0 ) arr [ i ] = arr [ i \/ 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i \/ 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }"}
{"text":"main function","code":"public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( printNthElement ( n ) ) ; } }"}
{"text":"Class to calculate Nth term of series","code":"import java . io . * ; class Nth { public int nthTerm ( int N ) {"}
{"text":"By using above formula","code":"return ( N * ( ( N \/ 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } }"}
{"text":"Main class for main method","code":"class GFG { public static void main ( String [ ] args ) {"}
{"text":"get the value of N","code":"int N = 5 ;"}
{"text":"create object of Class Nth","code":"Nth a = new Nth ( ) ;"}
{"text":"Calculate and print the Nth term","code":"System . out . println ( \" Nth \u2581 term \u2581 for \u2581 N \u2581 = \u2581 \" + N + \" \u2581 : \u2581 \" + a . nthTerm ( N ) ) ; } }"}
{"text":"Java program to print terms of binomial series and also calculate sum of series .","code":"import java . io . * ; class GFG {"}
{"text":"function to print the series","code":"static void series ( int A , int X , int n ) {"}
{"text":"Calculating and printing first term","code":"int term = ( int ) Math . pow ( A , n ) ; System . out . print ( term + \" \u2581 \" ) ;"}
{"text":"Computing and printing remaining terms","code":"for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"Find current term using previous terms We increment power of X by 1 , decrement power of A by 1 and compute nCi using previous term by multiplying previous term with ( n - i + 1 ) \/ i","code":"term = term * X * ( n - i + 1 ) \/ ( i * A ) ; System . out . print ( term + \" \u2581 \" ) ; } }"}
{"text":"main function started","code":"public static void main ( String [ ] args ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }"}
{"text":"Java program to check whether the number is divisible by 8 or not using bitwise operator","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"function to check number is div by 8 or not using bitwise operator","code":"static boolean Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 16 ; if ( Div_by_8 ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text":"Program to find average of even numbers till a given even number .","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the average of even numbers","code":"static int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) {"}
{"text":"count even numbers","code":"count ++ ;"}
{"text":"store the sum of even numbers","code":"sum += n ; n = n - 2 ; } return sum \/ count ; }"}
{"text":"driver function","code":"public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( averageEven ( n ) ) ; } }"}
{"text":"Program to find average of even numbers till a given even number .","code":"import java . io . * ; class GFG {"}
{"text":"Function to calculate the average of even numbers","code":"static int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return ( n + 2 ) \/ 2 ; }"}
{"text":"driver function","code":"public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( averageEven ( n ) ) ; } }"}
{"text":"java program to find the Largest Coprime Divisor","code":"import java . io . * ; class GFG {"}
{"text":"Recursive function to return gcd of a and b","code":"static int gcd ( int a , int b ) {"}
{"text":"Everything divides 0","code":"if ( a == 0 b == 0 ) return 0 ;"}
{"text":"base case","code":"if ( a == b ) return a ;"}
{"text":"a is greater","code":"if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }"}
{"text":"function to find largest coprime divisor","code":"static int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x \/ gcd ( x , y ) ; } return x ; }"}
{"text":"divisor code","code":"public static void main ( String [ ] args ) { int x = 15 ; int y = 3 ; System . out . println ( cpFact ( x , y ) ) ; x = 14 ; y = 28 ; System . out . println ( cpFact ( x , y ) ) ; x = 7 ; y = 3 ; System . out . println ( cpFact ( x , y ) ) ; } }"}
{"text":"Simple Java program to count numbers with last digit as k in given range .","code":"import java . util . * ; import java . lang . * ; public class GfG {"}
{"text":"Returns count of numbers with k as last digit .","code":"public static int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }"}
{"text":"driver function","code":"public static void main ( String args [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }"}
{"text":"JAVA Code for Taxicab Numbers","code":"import java . util . * ; class GFG { public static void printTaxicab2 ( int N ) {"}
{"text":"Starting from 1 , check every number if it is Taxicab until count reaches N .","code":"int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ;"}
{"text":"Try all possible pairs ( j , k ) whose cube sums can be i .","code":"for ( int j = 1 ; j <= Math . pow ( i , 1.0 \/ 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . pow ( i , 1.0 \/ 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ;"}
{"text":"Taxicab ( 2 ) found","code":"if ( int_count == 2 ) { count ++ ; System . out . println ( count + \" \u2581 \" + i ) ; } i ++ ; } }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int N = 5 ; printTaxicab2 ( N ) ; } }"}
{"text":"\/ An optimized method based Java program to check if a number is Composite or not .","code":"import java . io . * ; class Composite { static boolean isComposite ( int n ) {"}
{"text":"Corner cases","code":"if ( n <= 1 ) System . out . println ( \" False \" ) ; if ( n <= 3 ) System . out . println ( \" False \" ) ;"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }"}
{"text":"Driver Program to test above function","code":"public static void main ( String args [ ] ) { System . out . println ( isComposite ( 11 ) ? \" true \" : \" false \" ) ; System . out . println ( isComposite ( 15 ) ? \" true \" : \" false \" ) ; } }"}
{"text":"Java program to find minimum number to insert in array so their sum is prime","code":"class GFG {"}
{"text":"function to check if a number is prime or not","code":"static boolean isPrime ( int n ) {"}
{"text":"Corner case","code":"if ( n <= 1 ) return false ;"}
{"text":"Check from 2 to n - 1","code":"for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }"}
{"text":"Find prime number greater than a number","code":"static int findPrime ( int n ) { int num = n + 1 ;"}
{"text":"find prime greater than n","code":"while ( num > 0 ) {"}
{"text":"check if num is prime","code":"if ( isPrime ( num ) ) return num ;"}
{"text":"increment num","code":"num = num + 1 ; } return 0 ; }"}
{"text":"To find number to be added so sum of array is prime","code":"static int minNumber ( int arr [ ] , int n ) { int sum = 0 ;"}
{"text":"To find sum of array elements","code":"for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;"}
{"text":"if sum is already prime return 0","code":"if ( isPrime ( sum ) ) return 0 ;"}
{"text":"To find prime number greater than sum","code":"int num = findPrime ( sum ) ;"}
{"text":"Return difference of sum and num","code":"return num - sum ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }"}
{"text":"Java program to find sum of proper divisor of factorial of a number","code":"import java . io . * ; import java . util . * ; public class Division {"}
{"text":"function to calculate factorial","code":"static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }"}
{"text":"function to calculate sum of divisor","code":"static int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; }"}
{"text":"Returns sum of divisors of n !","code":"static int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; }"}
{"text":"driver program","code":"public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( sumFactDiv ( n ) ) ; } }"}
{"text":"Java program to find sum of divisors in n !","code":"import java . util . * ; class GFG {"}
{"text":"allPrimes [ ] stores all prime numbers less than or equal to n .","code":"static ArrayList < Integer > allPrimes = new ArrayList < Integer > ( ) ;"}
{"text":"Fills above vector allPrimes [ ] for a given n","code":"static void sieve ( int n ) {"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true .","code":"boolean [ ] prime = new boolean [ n + 1 ] ;"}
{"text":"Loop to update prime [ ]","code":"for ( int p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == false ) {"}
{"text":"Update all multiples of p","code":"for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } }"}
{"text":"Store primes in the vector allPrimes","code":"for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) allPrimes . add ( p ) ; }"}
{"text":"Function to find all result of factorial number","code":"static int factorialDivisors ( int n ) {"}
{"text":"Initialize result","code":"int result = 1 ;"}
{"text":"find exponents of all primes which divides n and less than n","code":"for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) {"}
{"text":"Current divisor","code":"int p = allPrimes . get ( i ) ;"}
{"text":"Find the highest power ( stored in exp ) ' \u2581 \u2581 of \u2581 allPrimes [ i ] \u2581 that \u2581 divides \u2581 n \u2581 using \u2581 \u2581 Legendre ' s formula .","code":"int exp = 0 ; while ( p <= n ) { exp = exp + ( n \/ p ) ; p = p * allPrimes . get ( i ) ; }"}
{"text":"Using the divisor function to calculate the sum","code":"result = result * ( ( int ) Math . pow ( allPrimes . get ( i ) , exp + 1 ) - 1 ) \/ ( allPrimes . get ( i ) - 1 ) ; }"}
{"text":"return total divisors","code":"return result ; }"}
{"text":"Driver program to run the cases","code":"public static void main ( String [ ] args ) { System . out . println ( factorialDivisors ( 4 ) ) ; } }"}
{"text":"Java program to check if a number is pandigital in given base .","code":"import java . util . * ; class GFG {"}
{"text":"Return true if n is pandigit else return false .","code":"static boolean checkPandigital ( int b , String n ) {"}
{"text":"Checking length is less than base","code":"if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ;"}
{"text":"Traversing each digit of the number .","code":"for ( int i = 0 ; i < n . length ( ) ; i ++ ) {"}
{"text":"If digit is integer","code":"if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ;"}
{"text":"If digit is alphabet","code":"else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; }"}
{"text":"Checking hash array , if any index is unmarked .","code":"for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int b = 13 ; String n = \"1298450376ABC \" ; if ( checkPandigital ( b , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation to convert a number m to n using minimum number of given operations","code":"class ConvertNum {"}
{"text":"function to find minimum number of given operations to convert m to n","code":"static int convert ( int m , int n ) { if ( m == n ) return 0 ;"}
{"text":"only way is to do - 1 ( m - n ) times","code":"if ( m > n ) return m - n ;"}
{"text":"not possible","code":"if ( m <= 0 && n > 0 ) return - 1 ;"}
{"text":"n is greater and n is odd","code":"if ( n % 2 == 1 )"}
{"text":"perform ' - 1' on m ( or + 1 on n )","code":"return 1 + convert ( m , n + 1 ) ;"}
{"text":"n is even","code":"else"}
{"text":"perform ' * 2' on m ( or n \/ 2 on n )","code":"return 1 + convert ( m , n \/ 2 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int m = 3 , n = 11 ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 \" + \" operations \u2581 : \u2581 \" + convert ( m , n ) ) ; } }"}
{"text":"Java program to find Seed of a number","code":"import java . util . * ; class GFg { static int MAX = 10000 ; static int [ ] prodDig = new int [ MAX ] ;"}
{"text":"Stores product of digits of x in prodDig [ x ]","code":"static int getDigitProduct ( int x ) {"}
{"text":"If x has single digit","code":"if ( x < 10 ) return x ;"}
{"text":"If digit product is already computed","code":"if ( prodDig [ x ] != 0 ) return prodDig [ x ] ;"}
{"text":"If digit product is not computed before .","code":"int prod = ( x % 10 ) * getDigitProduct ( x \/ 10 ) ; return ( prodDig [ x ] = prod ) ; }"}
{"text":"Prints all seeds of n","code":"static void findSeed ( int n ) {"}
{"text":"Find all seeds using prodDig [ ]","code":"List < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= n \/ 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . add ( i ) ;"}
{"text":"If there was no seed","code":"if ( res . size ( ) == 0 ) { System . out . println ( \" NO \u2581 seed \u2581 exists \" ) ; return ; }"}
{"text":"Print seeds","code":"for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + \" \u2581 \" ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 138 ; findSeed ( n ) ; } }"}
{"text":"Java program to find integer having maximum number of prime factor in first N natural numbers .","code":"import java . util . Arrays ; public class GFG {"}
{"text":"Return smallest number having maximum prime factors .","code":"static int maxPrimefactorNum ( int N ) { int arr [ ] = new int [ N + 5 ] ; Arrays . fill ( arr , 0 ) ;"}
{"text":"Sieve of eratosthenes method to count number of prime factors .","code":"for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( int j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ;"}
{"text":"Finding number having maximum number of prime factor .","code":"for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }"}
{"text":"Efficient Java program to compute sum of subarray elements","code":"class GFG {"}
{"text":"function compute sum all sub - array","code":"public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 ;"}
{"text":"computing sum of subarray using formula","code":"for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ;"}
{"text":"return all subarray sum","code":"return result ; }"}
{"text":"Driver program to test above function","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( \" Sum \u2581 of \u2581 SubArray \u2581 \" + SubArraySum ( arr , n ) ) ; } }"}
{"text":"Java program to find highest power of 2 smaller than or equal to n .","code":"class GFG { static int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) {"}
{"text":"If i is a power of 2","code":"if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 10 ; System . out . print ( highestPowerof2 ( n ) ) ; } }"}
{"text":"Java program to find pairs that can represent the given number as sum of two cubes","code":"import java . io . * ; class GFG {"}
{"text":"Function to find pairs that can represent the given number as sum of two cubes","code":"static void findPairs ( int n ) {"}
{"text":"find cube root of n","code":"int cubeRoot = ( int ) Math . pow ( n , 1.0 \/ 3.0 ) ;"}
{"text":"create a array of size of size ' cubeRoot '","code":"int cube [ ] = new int [ cubeRoot + 1 ] ;"}
{"text":"for index i , cube [ i ] will contain i ^ 3","code":"for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ;"}
{"text":"Find all pairs in above sorted array cube [ ] whose sum is equal to n","code":"int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { System . out . println ( \" ( \" + l + \" , \u2581 \" + r + \" ) \" ) ; l ++ ; r -- ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 20683 ; findPairs ( n ) ; } }"}
{"text":"Java program to find pairs that can represent the given number as sum of two cubes","code":"import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }"}
{"text":"Function to find pairs that can represent the given number as sum of two cubes","code":"static void findPairs ( int n ) {"}
{"text":"find cube root of n","code":"int cubeRoot = ( int ) Math . pow ( n , 1.0 \/ 3.0 ) ;"}
{"text":"create an empty map","code":"HashMap < Integer , pair > s = new HashMap < Integer , pair > ( ) ;"}
{"text":"Consider all pairs such with values less than cuberoot","code":"for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) {"}
{"text":"find sum of current pair ( x , y )","code":"int sum = x * x * x + y * y * y ;"}
{"text":"do nothing if sum is not equal to given number","code":"if ( sum != n ) continue ;"}
{"text":"if sum is seen before , we found two pairs","code":"if ( s . containsKey ( sum ) ) { System . out . print ( \" ( \" + s . get ( sum ) . first + \" , \u2581 \" + s . get ( sum ) . second + \" ) \u2581 and \u2581 ( \" + x + \" , \u2581 \" + y + \" ) \" + \"NEW_LINE\"); } else"}
{"text":"if sum is seen for the first time","code":"s . put ( sum , new pair ( x , y ) ) ; } } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 13832 ; findPairs ( n ) ; } }"}
{"text":"Java program to find the minimum difference between any two terms of two tables","code":"import java . io . * ; class GFG {"}
{"text":"Utility function to find GCD of a and b","code":"static int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; }"}
{"text":"Returns minimum difference between any two terms of shifted tables of ' a ' and ' b ' . ' x ' is shift in table of ' a ' and ' y ' is shift in table of ' b ' .","code":"static int findMinDiff ( int a , int b , int x , int y ) {"}
{"text":"Calculate gcd of a nd b","code":"int g = gcd ( a , b ) ;"}
{"text":"Calculate difference between x and y","code":"int diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a = 20 , b = 52 , x = 5 , y = 7 ; System . out . println ( findMinDiff ( a , b , x , y ) ) ; } }"}
{"text":"A O ( sqrt ( n ) ) java program that prints all divisors in sorted order","code":"import java . util . Vector ; class Test {"}
{"text":"method to print the divisors","code":"static void printDivisors ( int n ) {"}
{"text":"Vector to store half of the divisors","code":"Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {"}
{"text":"check if divisors are equal","code":"if ( n \/ i == i ) System . out . printf ( \" % d \u2581 \" , i ) ; else { System . out . printf ( \" % d \u2581 \" , i ) ;"}
{"text":"push the second divisor in the vector","code":"v . add ( n \/ i ) ; } } }"}
{"text":"The vector will be printed in reverse","code":"for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( \" % d \u2581 \" , v . get ( i ) ) ; }"}
{"text":"Driver method","code":"public static void main ( String args [ ] ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; } }"}
{"text":"A O ( sqrt ( n ) ) program that prints all divisors in sorted order","code":"import java . lang . Math ; class GFG {"}
{"text":"Function to print the divisors","code":"public static void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) System . out . print ( i + \" \u2581 \" ) ; } if ( i - ( n \/ i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) System . out . print ( n \/ i + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; } }"}
{"text":"Java implementation of Naive method to print all divisors","code":"class Test {"}
{"text":"method to print the divisors","code":"static void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) System . out . print ( i + \" \u2581 \" ) ; }"}
{"text":"Driver method","code":"public static void main ( String args [ ] ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; ; } }"}
{"text":"A Better ( than Naive ) Solution to find all divisors","code":"class Test {"}
{"text":"method to print the divisors","code":"static void printDivisors ( int n ) {"}
{"text":"Note that this loop runs till square root","code":"for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {"}
{"text":"If divisors are equal , print only one","code":"if ( n \/ i == i ) System . out . print ( \" \u2581 \" + i ) ;"}
{"text":"else Otherwise print both","code":"System . out . print ( i + \" \u2581 \" + n \/ i + \" \u2581 \" ) ; } } }"}
{"text":"Driver method","code":"public static void main ( String args [ ] ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; ; } }"}
{"text":"Java program for implementation of Sieve of Atkin","code":"class GFG { static int SieveOfAtkin ( int limit ) {"}
{"text":"2 and 3 are known to be prime","code":"if ( limit > 2 ) System . out . print ( 2 + \" \u2581 \" ) ; if ( limit > 3 ) System . out . print ( 3 + \" \u2581 \" ) ;"}
{"text":"Initialise the sieve array with false values","code":"boolean sieve [ ] = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ;"}
{"text":"Mark sieve [ n ] is true if one of the following is true : a ) n = ( 4 * x * x ) + ( y * y ) has odd number of solutions , i . e . , there exist odd number of distinct pairs ( x , y ) that satisfy the equation and n % 12 = 1 or n % 12 = 5. b ) n = ( 3 * x * x ) + ( y * y ) has odd number of solutions and n % 12 = 7 c ) n = ( 3 * x * x ) - ( y * y ) has odd number of solutions , x > y and n % 12 = 11","code":"for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) {"}
{"text":"Main part of Sieve of Atkin","code":"int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } }"}
{"text":"Mark all multiples of squares as non - prime","code":"for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } }"}
{"text":"Print primes using sieve [ ]","code":"for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) System . out . print ( a + \" \u2581 \" ) ; return 0 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int limit = 20 ; SieveOfAtkin ( limit ) ; } }"}
{"text":"Java program to check if a point lies inside a circle or not","code":"class GFG { static boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) {"}
{"text":"Compare radius of circle with distance of its center from given point","code":"if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }"}
{"text":"Driver Program to test above function","code":"public static void main ( String arg [ ] ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) System . out . print ( \" Inside \" ) ; else System . out . print ( \" Outside \" ) ; } }"}
{"text":"Java program to evaluate all possible values of a expression","code":"import java . util . * ; class GFG {"}
{"text":"Utility function to evaluate a simple expression with one operator only .","code":"static int eval ( int a , char op , int b ) { if ( op == ' + ' ) { return a + b ; } if ( op == ' - ' ) { return a - b ; } if ( op == ' * ' ) { return a * b ; } return Integer . MAX_VALUE ; }"}
{"text":"This function evaluates all possible values and returns a list of evaluated values .","code":"static Vector < Integer > evaluateAll ( String expr , int low , int high ) {"}
{"text":"To store result ( all possible evaluations of given expression ' expr ' )","code":"Vector < Integer > res = new Vector < Integer > ( ) ;"}
{"text":"If there is only one character , it must be a digit ( or operand ) , return it .","code":"if ( low == high ) { res . add ( expr . charAt ( low ) - '0' ) ; return res ; }"}
{"text":"If there are only three characters , middle one must be operator and corner ones must be operand","code":"if ( low == ( high - 2 ) ) { int num = eval ( expr . charAt ( low ) - '0' , expr . charAt ( low + 1 ) , expr . charAt ( low + 2 ) - '0' ) ; res . add ( num ) ; return res ; }"}
{"text":"every i refers to an operator","code":"for ( int i = low + 1 ; i <= high ; i += 2 ) {"}
{"text":"l refers to all the possible values in the left of operator ' expr [ i ] '","code":"Vector < Integer > l = evaluateAll ( expr , low , i - 1 ) ;"}
{"text":"r refers to all the possible values in the right of operator ' expr [ i ] '","code":"Vector < Integer > r = evaluateAll ( expr , i + 1 , high ) ;"}
{"text":"Take above evaluated all possible values in left side of ' i '","code":"for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) {"}
{"text":"Take above evaluated all possible values in right side of ' i '","code":"for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) {"}
{"text":"Calculate value for every pair and add the value to result .","code":"int val = eval ( l . get ( s1 ) , expr . charAt ( i ) , r . get ( s2 ) ) ; res . add ( val ) ; } } } return res ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { String expr = \"1*2 + 3*4\" ; int len = expr . length ( ) ; Vector < Integer > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . println ( ans . get ( i ) ) ; } } }"}
{"text":"Java program to check if a given number is lucky","code":"class GFG {"}
{"text":"This function returns true if n is lucky","code":"static boolean isLucky ( int n ) {"}
{"text":"Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not .","code":"boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ;"}
{"text":"Traverse through all digits of given number","code":"while ( n > 0 ) {"}
{"text":"Find the last digit","code":"int digit = n % 10 ;"}
{"text":"If digit is already seen , return false","code":"if ( arr [ digit ] ) return false ;"}
{"text":"Mark this digit as seen","code":"arr [ digit ] = true ;"}
{"text":"Remove the last digit from number","code":"n = n \/ 10 ; } return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) if ( isLucky ( arr [ i ] ) ) System . out . print ( arr [ i ] + \" is Lucky NEW_LINE\"); else System . out . print ( arr [ i ] + \" is not Lucky NEW_LINE\"); } }"}
{"text":"Java program to print squares of first ' n ' natural numbers without using * , \/ and -","code":"import java . io . * ; class GFG { static void printSquares ( int n ) {"}
{"text":"Initialize ' square ' and first odd number","code":"int square = 0 , odd = 1 ;"}
{"text":"Calculate and print squares","code":"for ( int x = 0 ; x < n ; x ++ ) {"}
{"text":"Print square","code":"System . out . print ( square + \" \u2581 \" ) ;"}
{"text":"Update ' square ' and ' odd '","code":"square = square + odd ; odd = odd + 2 ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 5 ; printSquares ( n ) ; } }"}
{"text":"Recursive function to reverse digits of num","code":"class GFG { static int rev_num = 0 ; static int base_pos = 1 ; static int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num \/ 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int num = 4562 ; System . out . println ( reversDigits ( num ) ) ; } }"}
{"text":"Java program that find the minimum possible maximum","code":"import java . util . * ; class GFG {"}
{"text":"Recursive function that find the minimum value after exclusive - OR","code":"static int RecursiveFunction ( ArrayList < Integer > ref , int bit ) {"}
{"text":"Condition if ref size is zero or bit is negative then return 0","code":"if ( ref . size ( ) == 0 bit < 0 ) return 0 ; ArrayList < Integer > curr_on = new ArrayList < > ( ) ; ArrayList < Integer > curr_off = new ArrayList < > ( ) ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) {"}
{"text":"Condition if current bit is off then push current value in curr_off vector","code":"if ( ( ( ref . get ( i ) >> bit ) & 1 ) == 0 ) curr_off . add ( ref . get ( i ) ) ;"}
{"text":"Condition if current bit is on then push current value in curr_on vector","code":"else curr_on . add ( ref . get ( i ) ) ; }"}
{"text":"Condition if curr_off is empty then call recursive function on curr_on vector","code":"if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ;"}
{"text":"Condition if curr_on is empty then call recursive function on curr_off vector","code":"if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ;"}
{"text":"Return the minimum of curr_off and curr_on and add power of 2 of current bit","code":"return Math . min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; }"}
{"text":"Function that print the minimum value after exclusive - OR","code":"static void PrintMinimum ( int a [ ] , int n ) { ArrayList < Integer > v = new ArrayList < > ( ) ;"}
{"text":"Pushing values in vector","code":"for ( int i = 0 ; i < n ; i ++ ) v . add ( a [ i ] ) ;"}
{"text":"Printing answer","code":"System . out . println ( RecursiveFunction ( v , 30 ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int size = arr . length ; PrintMinimum ( arr , size ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to return the count of elements which are equal to the XOR of the next two elements","code":"static int cntElements ( int arr [ ] , int n ) {"}
{"text":"To store the required count","code":"int cnt = 0 ;"}
{"text":"For every element of the array such that it has at least two elements appearing after it in the array","code":"for ( int i = 0 ; i < n - 2 ; i ++ ) {"}
{"text":"If current element is equal to the XOR of the next two elements in the array","code":"if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = arr . length ; System . out . println ( cntElements ( arr , n ) ) ; } }"}
{"text":"Java program to find Number of triplets in array having subarray xor equal","code":"class GFG {"}
{"text":"Function to return the count","code":"static int xor_triplet ( int arr [ ] , int n ) {"}
{"text":"Initialise result","code":"int ans = 0 ;"}
{"text":"Pick 1 st element of the triplet","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Pick 2 nd element of the triplet","code":"for ( int j = i + 1 ; j < n ; j ++ ) {"}
{"text":"Pick 3 rd element of the triplet","code":"for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ;"}
{"text":"Taking xor in the first subarray","code":"for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; }"}
{"text":"Taking xor in the second subarray","code":"for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; }"}
{"text":"If both xor is equal","code":"if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ;"}
{"text":"Function Calling","code":"System . out . println ( xor_triplet ( arr , n ) ) ; } }"}
{"text":"Java trie based program to find the Number of triplets in array having subarray xor equal","code":"class GFG {"}
{"text":"maximum number of bits in an integer <= 1e9","code":"static int lg = 31 ;"}
{"text":"Structure of a Trie Node","code":"static class TrieNode {"}
{"text":"[ 0 ] index is bit 0 and [ 1 ] index is bit 1","code":"TrieNode children [ ] ;"}
{"text":"Sum of indexes inserted at at a node","code":"int sum_of_indexes ;"}
{"text":"Number of indexes inserted at a node","code":"int number_of_indexes ;"}
{"text":"Constructor to initialize a newly created node","code":"TrieNode ( ) { children = new TrieNode [ 2 ] ; this . children [ 0 ] = null ; this . children [ 1 ] = null ; this . sum_of_indexes = 0 ; this . number_of_indexes = 0 ; } } ;"}
{"text":"Function to insert curr_xor into the trie","code":"static void insert ( TrieNode node , int num , int index ) {"}
{"text":"Iterate from the 31 st bit to the 0 th bit of curr_xor number","code":"for ( int bits = lg ; bits >= 0 ; bits -- ) {"}
{"text":"Check if the current bit is set or not","code":"int curr_bit = ( num >> bits ) & 1 ;"}
{"text":"If this node isn 't already  present in the trie structure  insert it into the trie.","code":"if ( node . children [ curr_bit ] == null ) { node . children [ curr_bit ] = new TrieNode ( ) ; } node = node . children [ curr_bit ] ; }"}
{"text":"Increase the sum of indexes by the current index value","code":"node . sum_of_indexes += index ;"}
{"text":"Increase the number of indexes by 1","code":"node . number_of_indexes ++ ; }"}
{"text":"Function to check if curr_xor is present in trie or not","code":"static int query ( TrieNode node , int num , int index ) {"}
{"text":"Iterate from the 31 st bit to the 0 th bit of curr_xor number","code":"for ( int bits = lg ; bits >= 0 ; bits -- ) {"}
{"text":"Check if the current bit is set or not","code":"int curr_bit = ( num >> bits ) & 1 ;"}
{"text":"If this node isn 't already  present in the trie structure  that means no sub array till  current index has 0 xor so  return 0","code":"if ( node . children [ curr_bit ] == null ) { return 0 ; } node = node . children [ curr_bit ] ; }"}
{"text":"Calculate the number of index inserted at final node","code":"int sz = node . number_of_indexes ;"}
{"text":"Calculate the sum of index inserted at final node","code":"int sum = node . sum_of_indexes ; int ans = ( sz * index ) - ( sum ) ; return ans ; }"}
{"text":"Function to return the count of valid triplets","code":"static int no_of_triplets ( int arr [ ] , int n ) {"}
{"text":"To store cumulative xor","code":"int curr_xor = 0 ; int number_of_triplets = 0 ;"}
{"text":"The root of the trie","code":"TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ;"}
{"text":"Insert the curr_xor in the trie","code":"insert ( root , curr_xor , i ) ;"}
{"text":"Update the cumulative xor","code":"curr_xor ^= x ;"}
{"text":"Check if the cumulative xor is present in the trie or not if present then add ( sz * index ) - sum","code":"number_of_triplets += query ( root , curr_xor , i ) ; } return number_of_triplets ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given array","code":"int arr [ ] = { 5 , 2 , 7 } ; int n = arr . length ; System . out . println ( no_of_triplets ( arr , n ) ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG { static final int N = 100005 ; static int n , k ;"}
{"text":"Adjacency list","code":"@ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] al = new Vector [ N ] ; static long Ideal_pair ; static long [ ] bit = new long [ N ] ; static boolean [ ] root_node = new boolean [ N ] ;"}
{"text":"bit : bit array i and j are starting and ending index INCLUSIVE","code":"static long bit_q ( int i , int j ) { long sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; }"}
{"text":"bit : bit array n : size of bit array i is the index to be updated diff is ( new_val - old_val )","code":"static void bit_up ( int i , long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } }"}
{"text":"DFS function to find ideal pairs","code":"static void dfs ( int node ) { Ideal_pair += bit_q ( Math . max ( 1 , node - k ) , Math . min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( int i = 0 ; i < al [ node ] . size ( ) ; i ++ ) dfs ( al [ node ] . get ( i ) ) ; bit_up ( node , - 1 ) ; }"}
{"text":"Function for initialisation","code":"static void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } }"}
{"text":"Function to add an edge","code":"static void Add_Edge ( int x , int y ) { al [ x ] . add ( y ) ; root_node [ y ] = false ; }"}
{"text":"Function to find number of ideal pairs","code":"static long Idealpairs ( ) {"}
{"text":"Find root of the tree","code":"int r = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { n = 6 ; k = 3 ; for ( int i = 0 ; i < al . length ; i ++ ) al [ i ] = new Vector < Integer > ( ) ; initialise ( ) ;"}
{"text":"Add edges","code":"Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ;"}
{"text":"Function call","code":"System . out . print ( Idealpairs ( ) ) ; } }"}
{"text":"Java program to print all bitwise subsets of N ( Efficient approach )","code":"class GFG {"}
{"text":"function to find bitwise subsets Efficient approach","code":"static void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) System . out . print ( i + \" \u2581 \" ) ; System . out . print ( \" \u2581 0 \u2581 \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }"}
{"text":"Java program to check if a number is divisible by 17 or not using bitwise operator .","code":"class GFG {"}
{"text":"function to check recursively if the number is divisible by 17 or not","code":"static boolean isDivisibleby17 ( int n ) {"}
{"text":"if n = 0 or n = 17 then yes","code":"if ( n == 0 n == 17 ) return true ;"}
{"text":"if n is less then 17 , not divisible by 17","code":"if ( n < 17 ) return false ;"}
{"text":"reducing the number by floor ( n \/ 16 ) - n % 16","code":"return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }"}
{"text":"driver function","code":"public static void main ( String [ ] args ) { int n = 35 ; if ( isDivisibleby17 ( n ) == true ) System . out . printf ( \" % d \u2581 is \u2581 divisible \u2581 by \u2581 17\" , n ) ; else System . out . printf ( \" % d \u2581 is \u2581 not \u2581 divisible \u2581 by \u2581 17\" , n ) ; } }"}
{"text":"java program to find largest number smaller than equal to n with m set bits then m - 1 0 bits .","code":"public class GFG {"}
{"text":"Returns largest number with m set bits then m - 1 0 bits .","code":"static long answer ( long n ) {"}
{"text":"Start with 2 bits .","code":"long m = 2 ;"}
{"text":"initial answer is 1 which meets the given condition","code":"long ans = 1 ; long r = 1 ;"}
{"text":"check for all numbers","code":"while ( r < n ) {"}
{"text":"compute the number","code":"r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ;"}
{"text":"if less then N","code":"if ( r < n ) ans = r ;"}
{"text":"increment m to get the next number","code":"m ++ ; } return ans ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { long n = 7 ; System . out . println ( answer ( n ) ) ; } }"}
{"text":"Simple Java program to find MSB number for given n .","code":"import java . io . * ; class GFG { static int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n \/ 2 ; while ( n != 0 ) { n = n \/ 2 ; msb ++ ; } return ( 1 << msb ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 0 ; System . out . println ( setBitNumber ( n ) ) ; } }"}
{"text":"Java program to find MSB number for given n .","code":"class GFG { static int setBitNumber ( int n ) {"}
{"text":"Suppose n is 273 ( binary is 100010001 ) . It does following 100010001 | 010001000 = 110011001","code":"n |= n >> 1 ;"}
{"text":"This makes sure 4 bits ( From MSB and including MSB ) are set . It does following 110011001 | 001100110 = 111111111","code":"n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;"}
{"text":"Increment n by 1 so that there is only one set bit which is just before original MSB . n now becomes 1000000000","code":"n = n + 1 ;"}
{"text":"Return original MSB after shifting . n now becomes 100000000","code":"return ( n >> 1 ) ; }"}
{"text":"Driver code","code":"public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } }"}
{"text":"Simple Java code for counting trailing zeros in binary representation of a number","code":"import java . io . * ; class GFG { public static int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { System . out . println ( countTrailingZero ( 11 ) ) ; } }"}
{"text":"Java code for counting trailing zeros in binary representation of a number","code":"import java . io . * ; class GFG { static int countTrailingZero ( int x ) {"}
{"text":"Map a bit value mod 37 to its position","code":"int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ;"}
{"text":"Only difference between ( x and - x ) is the value of signed magnitude ( leftmostbit ) negative numbers signed bit is 1","code":"return lookup [ ( - x & x ) % 37 ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { System . out . println ( countTrailingZero ( 48 ) ) ; } }"}
{"text":"Java program to evaluate ceil ( 7 n \/ 8 ) without using * and","code":"import java . io . * ; class GFG { static int multiplyBySevenByEight ( int n ) {"}
{"text":"Note the inner bracket here . This is needed because precedence of ' - ' operator is higher than ' < < '","code":"return ( n - ( n >> 3 ) ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( multiplyBySevenByEight ( n ) ) ; } }"}
{"text":"Java program to evaluate 7 n \/ 8 without using * and \/","code":"import java . io . * ; class GFG { static int multiplyBySevenByEight ( int n ) {"}
{"text":"Step 1 ) First multiply number by 7 i . e . 7 n = ( n << 3 ) - n * Step 2 ) Divide result by 8","code":"return ( ( n << 3 ) - n ) >> 3 ; }"}
{"text":"Driver program","code":"public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( multiplyBySevenByEight ( n ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class Main {"}
{"text":"Function to find the maximum size of group of palindrome numbers having difference between maximum and minimum element at most K","code":"static int countNumbers ( int L , int R , int K ) {"}
{"text":"Stores the all the palindromic numbers in the range [ L , R ]","code":"ArrayList < Integer > list = new ArrayList < > ( ) ;"}
{"text":"Traverse over the range [ L , R ]","code":"for ( int i = L ; i <= R ; i ++ ) {"}
{"text":"If i is a palindrome","code":"if ( isPalindrome ( i ) ) {"}
{"text":"Append the number in the list","code":"list . add ( i ) ; } }"}
{"text":"Stores count of maximum palindromic numbers","code":"int count = 0 ;"}
{"text":"Iterate each element in the list","code":"for ( int i = 0 ; i < list . size ( ) ; i ++ ) {"}
{"text":"Calculate rightmost index in the list < current element + K","code":"int right_index = search ( list , list . get ( i ) + K - 1 ) ;"}
{"text":"Check if there is rightmost index from the current index","code":"if ( right_index != - 1 ) count = Math . max ( count , right_index - i + 1 ) ; }"}
{"text":"Return the count","code":"return count ; }"}
{"text":"Function to search the rightmost index of given number","code":"static int search ( ArrayList < Integer > list , int num ) { int low = 0 , high = list . size ( ) - 1 ;"}
{"text":"Store the rightmost index","code":"int ans = - 1 ; while ( low <= high ) {"}
{"text":"Calculate the mid","code":"int mid = low + ( high - low ) \/ 2 ;"}
{"text":"If given number <= num","code":"if ( list . get ( mid ) <= num ) {"}
{"text":"Assign ans = mid","code":"ans = mid ;"}
{"text":"Update low","code":"low = mid + 1 ; } else"}
{"text":"Update high","code":"high = mid - 1 ; }"}
{"text":"return ans","code":"return ans ; }"}
{"text":"Function to check if the given number is palindrome or not","code":"static boolean isPalindrome ( int n ) { int rev = 0 ; int temp = n ;"}
{"text":"Generate reverse of the given number","code":"while ( n > 0 ) { rev = rev * 10 + n % 10 ; n \/= 10 ; }"}
{"text":"If n is a palindrome","code":"return rev == temp ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int L = 98 , R = 112 ; int K = 13 ; System . out . print ( countNumbers ( L , R , K ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; public class GFG {"}
{"text":"Function to find the maximum sum by subtracting same value from all elements of a Subarray","code":"public static int findMaximumSum ( int [ ] a , int n ) {"}
{"text":"Stores previous smaller element","code":"int prev_smaller [ ] = findPrevious ( a , n ) ;"}
{"text":"Stores next smaller element","code":"int next_smaller [ ] = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Calculate contribution of each element","code":"max_value = Math . max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; }"}
{"text":"Return answer","code":"return max_value ; }"}
{"text":"Function to generate previous smaller element for each array element","code":"public static int [ ] findPrevious ( int [ ] a , int n ) { int ps [ ] = new int [ n ] ;"}
{"text":"The first element has no previous smaller","code":"ps [ 0 ] = - 1 ;"}
{"text":"Stack to keep track of elements that have occurred previously","code":"Stack < Integer > stack = new Stack < > ( ) ;"}
{"text":"Push the first index","code":"stack . push ( 0 ) ; for ( int i = 1 ; i < a . length ; i ++ ) {"}
{"text":"Pop all the elements until the previous element is smaller than current element","code":"while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ;"}
{"text":"Store the previous smaller element","code":"ps [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : - 1 ;"}
{"text":"Push the index of the current element","code":"stack . push ( i ) ; }"}
{"text":"Return the array","code":"return ps ; }"}
{"text":"Function to generate next smaller element for each array element","code":"public static int [ ] findNext ( int [ ] a , int n ) { int ns [ ] = new int [ n ] ; ns [ n - 1 ] = n ;"}
{"text":"Stack to keep track of elements that have occurring next","code":"Stack < Integer > stack = new Stack < > ( ) ; stack . push ( n - 1 ) ;"}
{"text":"Iterate in reverse order for calculating next smaller","code":"for ( int i = n - 2 ; i >= 0 ; i -- ) {"}
{"text":"Pop all the elements until the next element is smaller than current element","code":"while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ;"}
{"text":"Store the next smaller element","code":"ns [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : a . length ;"}
{"text":"Push the index of the current element","code":"stack . push ( i ) ; }"}
{"text":"Return the array","code":"return ns ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { int n = 3 ; int a [ ] = { 80 , 48 , 82 } ; System . out . println ( findMaximumSum ( a , n ) ) ; } }"}
{"text":"This function returns true if contents of arr1 [ ] and arr2 [ ] are same , otherwise false .","code":"import java . util . * ; class GFG { static boolean compare ( int [ ] arr1 , int [ ] arr2 ) { for ( int i = 0 ; i < 256 ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }"}
{"text":"This function search for all permutations of pat [ ] in txt [ ]","code":"static boolean search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ;"}
{"text":"countP [ ] : Store count of all characters of pattern countTW [ ] : Store count of current window of text","code":"int [ ] countP = new int [ 256 ] ; int [ ] countTW = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) { countP [ i ] = 0 ; countTW [ i ] = 0 ; } for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat . charAt ( i ) ] ) ++ ; ( countTW [ txt . charAt ( i ) ] ) ++ ; }"}
{"text":"Traverse through remaining characters of pattern","code":"for ( int i = M ; i < N ; i ++ ) {"}
{"text":"Compare counts of current window of text with counts of pattern [ ]","code":"if ( compare ( countP , countTW ) ) return true ;"}
{"text":"Add current character to current window","code":"( countTW [ txt . charAt ( i ) ] ) ++ ;"}
{"text":"Remove the first character of previous window","code":"countTW [ txt . charAt ( i - M ) ] -- ; }"}
{"text":"Check for the last window in text","code":"if ( compare ( countP , countTW ) ) return true ; return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String txt = \" BACDGABCDA \" ; String pat = \" ABCD \" ; if ( search ( pat , txt ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" NO \" ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the maximized median","code":"static double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ;"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"If size is even","code":"if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size \/ 2 ) - 1 ] + arr [ size \/ 2 ] ) \/ 2 ; return median ; }"}
{"text":"If size is odd","code":"double median1 = arr [ size \/ 2 ] ; return median1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 3 , 4 , 2 } ; int n = arr . length ; int k = 2 ; System . out . print ( ( int ) getMaxMedian ( arr , n , k ) ) ; } }"}
{"text":"Java program to print three numbers in sorted order using max function","code":"class GFG { static void printSorted ( int a , int b , int c ) {"}
{"text":"Find maximum element","code":"int get_max = Math . max ( a , Math . max ( b , c ) ) ;"}
{"text":"Find minimum element","code":"int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + \" \u2581 \" + get_mid + \" \u2581 \" + get_max ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; } }"}
{"text":"iterative implementation","code":"import java . io . * ; class GFG { static int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) \/ 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; }"}
{"text":"Function to sort an array a [ ] of size ' n '","code":"static void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ;"}
{"text":"find location where selected should be inseretd","code":"loc = binarySearch ( a , selected , 0 , j ) ;"}
{"text":"Move all elements after location to create space","code":"while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = a . length , i ; insertionSort ( a , n ) ; System . out . println ( \" Sorted \u2581 array : \" ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; } }"}
{"text":"Java program for implementation of Insertion Sort","code":"class InsertionSort {"}
{"text":"Function to sort array using insertion sort","code":"void sort ( int arr [ ] ) { int n = arr . length ; for ( int i = 1 ; i < n ; ++ i ) { int key = arr [ i ] ; int j = i - 1 ;"}
{"text":"Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position","code":"while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }"}
{"text":"A utility function to print array of size n","code":"static void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver method","code":"public static void main ( String args [ ] ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; InsertionSort ob = new InsertionSort ( ) ; ob . sort ( arr ) ; printArray ( arr ) ; } }"}
{"text":"Importing HashMap class","code":"import java . util . HashMap ; class GFG {"}
{"text":"Function to calculate total number of valid permutations","code":"static int validPermutations ( String str ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ;"}
{"text":"Creating count which is equal to the Total number of characters present and ans that will store the number of unique permutations","code":"int count = str . length ( ) , ans = 0 ;"}
{"text":"Storing frequency of each character present in the string","code":"for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m . put ( str . charAt ( i ) , m . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) {"}
{"text":"Adding count of characters by excluding characters equal to current char","code":"ans += count - m . get ( str . charAt ( i ) ) ;"}
{"text":"Reduce the frequency of the current character and count by 1 , so that it cannot interfere with the calculations of the same elements present to the right of it .","code":"m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) - 1 ) ; count -- ; }"}
{"text":"Return ans + 1 ( Because the given string is also a unique permutation )","code":"return ans + 1 ; } public static void main ( String [ ] args ) { String str = \" sstt \" ; System . out . println ( validPermutations ( str ) ) ; } }"}
{"text":"Java program to count total number of paths from a point to origin","code":"import java . io . * ; class GFG {"}
{"text":"DP based function to count number of paths","code":"static int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;"}
{"text":"Fill entries in bottommost row and leftmost columns","code":"for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ;"}
{"text":"Fill DP in bottom up manner","code":"for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" + countPaths ( n , m ) ) ; } }"}
{"text":"Recursive JAVA program for coin change problem .","code":"import java . util . * ; class GFG {"}
{"text":"Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n","code":"static int count ( int S [ ] , int m , int n ) {"}
{"text":"If n is 0 then there is 1 solution ( do not include any coin )","code":"if ( n == 0 ) return 1 ;"}
{"text":"If n is less than 0 then no solution exists","code":"if ( n < 0 ) return 0 ;"}
{"text":"If there are no coins and n is greater than 0 , then no solution exist","code":"if ( m <= 0 && n >= 1 ) return 0 ;"}
{"text":"count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ]","code":"return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 } ; int m = arr . length ; System . out . println ( count ( arr , m , 4 ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static int coinchange ( int [ ] a , int v , int n , int [ ] [ ] dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != - 1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) {"}
{"text":"Either Pick this coin or not","code":"return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; }"}
{"text":"else We have no option but to leave this coin","code":"return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int tc = 1 ; while ( tc != 0 ) { int n , v ; n = 3 ; v = 4 ; int [ ] a = { 1 , 2 , 3 } ; int [ ] [ ] dp = new int [ n + 1 ] [ v + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; int res = coinchange ( a , v , n , dp ) ; System . out . println ( res ) ; tc -- ; } } }"}
{"text":"Function to compare two Strings ignoring their cases","code":"class GFG { static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ;"}
{"text":"Convert to lowercase using toUpperCase function","code":"str1 = str1 . toUpperCase ( ) ; str2 = str2 . toUpperCase ( ) ;"}
{"text":"Comparing both using inbuilt function","code":"int x = str1 . compareTo ( str2 ) ;"}
{"text":"if Strings are equal , return true otherwise false","code":"if ( x != 0 ) { return false ; } else { return true ; } }"}
{"text":"Function to print the same or not same if Strings are equal or not equal","code":"static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { System . out . println ( \" Same \" ) ; } else { System . out . println ( \" Not \u2581 Same \" ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to return the converted string after replacing every consonant sequence with its length","code":"static String replaceConsonants ( String str ) {"}
{"text":"To store the resultant string","code":"String res = \" \" ; int i = 0 , count = 0 ;"}
{"text":"Checking each character for consonant sequence","code":"while ( i < str . length ( ) ) {"}
{"text":"Count the length of consonants sequence","code":"if ( str . charAt ( i ) != ' a ' && str . charAt ( i ) != ' e ' && str . charAt ( i ) != ' i ' && str . charAt ( i ) != ' o ' && str . charAt ( i ) != ' u ' ) { i ++ ; count ++ ; } else {"}
{"text":"Add the length in the string","code":"if ( count > 0 ) res += count ;"}
{"text":"Add the vowel","code":"res += str . charAt ( i ) ; i ++ ; count = 0 ; } }"}
{"text":"Check for the last consonant sequence in the string","code":"if ( count > 0 ) res += count ;"}
{"text":"Return the resultant string","code":"return res ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" abcdeiop \" ; System . out . println ( replaceConsonants ( str ) ) ; } }"}
{"text":"Java Program to Encrypt String with product of number of vowels and consonants in every substring of size k","code":"class GFG {"}
{"text":"isVowel ( ) is a function that returns true for a vowel and false otherwise .","code":"static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; }"}
{"text":"function to Encrypt the dtring","code":"static String encryptString ( String s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; String ans = \" \" ;"}
{"text":"for each substring","code":"for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ;"}
{"text":"substring of size k","code":"for ( int r = l ; r <= l + k - 1 ; r ++ ) {"}
{"text":"counting number of vowels and consonants","code":"if ( isVowel ( s . charAt ( r ) ) == true ) { countVowels ++ ; } else { countConsonants ++ ; } }"}
{"text":"append product to answer .","code":"ans += String . valueOf ( countVowels * countConsonants ) ; } return ans ; }"}
{"text":"Driven Program","code":"static public void main ( String [ ] args ) { String s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encryptString ( s , n , k ) ) ; } }"}
{"text":"Java implementation of the above approach","code":"class GFG { private static StringBuilder charBuffer = new StringBuilder ( ) ; public static String processWords ( String input ) {"}
{"text":"we are splitting the input based on spaces ( s ) + : this regular expression will handle scenarios where we have words separated by multiple spaces","code":"String s [ ] = input . split ( \" ( \\\\ s ) + \" ) ; for ( String values : s ) {"}
{"text":"charAt ( 0 ) will pick only the first character from the string and append to buffer","code":"charBuffer . append ( values . charAt ( 0 ) ) ; } return charBuffer . toString ( ) ; }"}
{"text":"main function","code":"public static void main ( String [ ] args ) { String input = \" geeks \u2581 forgeeks \u2581 geeksfor \u2581 geeks \" ; System . out . println ( processWords ( input ) ) ; } }"}
{"text":"Java program to Generate all binary string without consecutive 1 's of size K","code":"import java . util . * ; import java . lang . * ; public class BinaryS {"}
{"text":"Array conversion to String --","code":"public static String toString ( char [ ] a ) { String string = new String ( a ) ; return string ; } static void generate ( int k , char [ ] ch , int n ) {"}
{"text":"Base Condition when we reached at the end of Array * *","code":"if ( n == k ) {"}
{"text":"Printing the Generated String * * Return to the previous case *","code":"System . out . print ( toString ( ch ) + \" \u2581 \" ) ; return ; }"}
{"text":"If the first Character is Zero then adding * *","code":"if ( ch [ n - 1 ] == '0' ) { ch [ n ] = '0' ; generate ( k , ch , n + 1 ) ; ch [ n ] = '1' ; generate ( k , ch , n + 1 ) ; }"}
{"text":"If the Character is One then add Zero to next * *","code":"if ( ch [ n - 1 ] == '1' ) { ch [ n ] = '0' ;"}
{"text":"Calling Recursively for the next value of Array","code":"generate ( k , ch , n + 1 ) ; } } static void fun ( int k ) { if ( k <= 0 ) { return ; } char [ ] ch = new char [ k ] ;"}
{"text":"Initializing first character to Zero","code":"ch [ 0 ] = '0' ;"}
{"text":"Generating Strings starting with Zero --","code":"generate ( k , ch , 1 ) ;"}
{"text":"Initialized first Character to one --","code":"ch [ 0 ] = '1' ; generate ( k , ch , 1 ) ; } public static void main ( String args [ ] ) { int k = 3 ;"}
{"text":"Calling function fun with argument k","code":"fun ( k ) ;"}
{"text":"This code is Contributed by Praveen Tiwari","code":"} }"}
{"text":"Java Program to find the biggest right circular cylinder that can be fit within a cube","code":"import java . io . * ; class GFG {"}
{"text":"Function to find the biggest right circular cylinder","code":"static float findVolume ( float a ) {"}
{"text":"side cannot be negative","code":"if ( a < 0 ) return - 1 ;"}
{"text":"radius of right circular cylinder","code":"float r = a \/ 2 ;"}
{"text":"height of right circular cylinder","code":"float h = a ;"}
{"text":"volume of right circular cylinder","code":"float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { float a = 5 ; System . out . print ( findVolume ( a ) ) ; } }"}
{"text":"Java Program for volume of Pyramid .","code":"import java . util . * ; import java . lang . * ; class GfG {"}
{"text":"Function to find the volume of triangular pyramid","code":"public static float volumeTriangular ( int a , int b , int h ) { float vol = ( float ) ( 0.1666 ) * a * b * h ; return vol ; }"}
{"text":"Function to find the volume of square pyramid","code":"public static float volumeSquare ( int b , int h ) { float vol = ( float ) ( 0.33 ) * b * b * h ; return vol ; }"}
{"text":"Function to find the volume of pentagonal pyramid","code":"public static float volumePentagonal ( int a , int b , int h ) { float vol = ( float ) ( 0.83 ) * a * b * h ; return vol ; }"}
{"text":"Function to find the volume of hexagonal pyramid","code":"public static float volumeHexagonal ( int a , int b , int h ) { float vol = ( float ) a * b * h ; return vol ; }"}
{"text":"Driver Code","code":"public static void main ( String argc [ ] ) { int b = 4 , h = 9 , a = 4 ; System . out . println ( \" Volume \u2581 of \u2581 triangular \" + \" \u2581 base \u2581 pyramid \u2581 is \u2581 \" + volumeTriangular ( a , b , h ) ) ; System . out . println ( \" Volume \u2581 of \u2581 square \u2581 base \" + \" \u2581 pyramid \u2581 is \u2581 \" + volumeSquare ( b , h ) ) ; System . out . println ( \" Volume \u2581 of \u2581 pentagonal \" + \" \u2581 base \u2581 pyramid \u2581 is \u2581 \" + volumePentagonal ( a , b , h ) ) ; System . out . println ( \" Volume \u2581 of \u2581 Hexagonal \" + \" \u2581 base \u2581 pyramid \u2581 is \u2581 \" + volumeHexagonal ( a , b , h ) ) ; } }"}
{"text":"Java program to calculate area of a trapezoid","code":"import java . io . * ; class GFG {"}
{"text":"Function for the area","code":"static double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) \/ 2 ) * h ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; System . out . println ( \" Area \u2581 is : \u2581 \" + area ) ; } }"}
{"text":"Java function to find number of diagonals in n sided convex polygon","code":"public class Diagonals { static int numberOfDiagonals ( int n ) { return n * ( n - 3 ) \/ 2 ; }"}
{"text":"driver code to test above function","code":"public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( n + \" \u2581 sided \u2581 convex \u2581 polygon \u2581 have \u2581 \" ) ; System . out . println ( numberOfDiagonals ( n ) + \" \u2581 diagonals \" ) ; } }"}
{"text":"Java implementation to find area of largest Rectangle without hole within a given Rectangle","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the maximum area such that it does not contains any hole","code":"static void maximumArea ( int l , int b , int x , int y ) {"}
{"text":"Area for all the possible positions of the cut","code":"int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ;"}
{"text":"Find the maximum area among the above rectangles","code":"System . out . print ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ;"}
{"text":"Function call","code":"maximumArea ( L , B , X , Y ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; public class GFG {"}
{"text":"Function to find the minimum cost of removing characters to make the string unique","code":"static int delCost ( String s , int [ ] cost ) {"}
{"text":"Store the minimum cost required","code":"int ans = 0 ;"}
{"text":"Create a dictionary to store the maximum cost of removal a character","code":"HashMap < Character , Integer > forMax = new HashMap < > ( ) ;"}
{"text":"Create a dictionary to store the total deletion cost of a character","code":"HashMap < Character , Integer > forTot = new HashMap < > ( ) ;"}
{"text":"Traverse the string , S","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"Keep track of maximum cost of each character","code":"if ( ! forMax . containsKey ( s . charAt ( i ) ) ) { forMax . put ( s . charAt ( i ) , cost [ i ] ) ; } else {"}
{"text":"Update the maximum deletion cost","code":"forMax . put ( s . charAt ( i ) , Math . max ( cost [ i ] , forMax . get ( s . charAt ( i ) ) ) ) ; }"}
{"text":"Keep track of the total cost of each character","code":"if ( ! forTot . containsKey ( s . charAt ( i ) ) ) { forTot . put ( s . charAt ( i ) , cost [ i ] ) ; } else {"}
{"text":"Update the total deletion cost","code":"forTot . put ( s . charAt ( i ) , forTot . get ( s . charAt ( i ) ) + cost [ i ] ) ; } }"}
{"text":"Traverse through all the unique characters","code":"for ( Map . Entry < Character , Integer > i : forMax . entrySet ( ) ) {"}
{"text":"Keep the maximum cost character and delete the rest","code":"ans += forTot . get ( i . getKey ( ) ) - i . getValue ( ) ; }"}
{"text":"Return the answer","code":"return ans ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given string","code":"String s = \" AAABBB \" ;"}
{"text":"Given cost array","code":"int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ;"}
{"text":"Function Call","code":"System . out . println ( delCost ( s , cost ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Define macros","code":"static final int MAX = 10000 ; static Vector < Integer > [ ] divisors = new Vector [ MAX + 1 ] ;"}
{"text":"Stores divisors for all numbers in the vector divisors","code":"static void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) {"}
{"text":"i is the divisor and j is the multiple","code":"divisors [ j ] . add ( i ) ; } } }"}
{"text":"Function to compare the closeness of the given target","code":"static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }"}
{"text":"Function to find the element closest to target in divisors vector","code":"static int findClosest ( Vector < Integer > array , int n , int target ) { Integer [ ] arr = array . toArray ( new Integer [ array . size ( ) ] ) ;"}
{"text":"Corner cases","code":"if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ;"}
{"text":"Perform binary search","code":"int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) \/ 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ;"}
{"text":"Check if target is less than the array element then search in left half","code":"if ( target < arr [ mid ] ) {"}
{"text":"Check if target is greater than previous to mid , return closest of two","code":"if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ;"}
{"text":"Repeat for left half","code":"j = mid ; }"}
{"text":"Check if target is greater than mid","code":"else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ;"}
{"text":"Update i","code":"i = mid + 1 ; } }"}
{"text":"Only single element left after search","code":"return arr [ mid ] ; }"}
{"text":"Function to print the divisor of N closest to X","code":"static void printClosest ( int N , int X ) {"}
{"text":"Function call to calculate and stores divisors of all numbers in a vector","code":"computeDivisors ( ) ;"}
{"text":"Stores the closest value to target","code":"int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ;"}
{"text":"Print the answer","code":"System . out . print ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given N & X","code":"int N = 16 , X = 5 ; for ( int i = 0 ; i < divisors . length ; i ++ ) divisors [ i ] = new Vector < Integer > ( ) ;"}
{"text":"Function Call","code":"printClosest ( N , X ) ; } }"}
{"text":"Java program for the above approach","code":"import java . io . Console ; import java . util . HashMap ; import java . util . Map ; class GFG {"}
{"text":"Function to count maximum matched elements from the arrays A [ ] and B [ ]","code":"static int maxMatch ( int [ ] A , int [ ] B ) {"}
{"text":"Stores position of elements of array A [ ] in the array B [ ]","code":"HashMap < Integer , Integer > Aindex = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Keep track of difference between the indices","code":"HashMap < Integer , Integer > diff = new HashMap < Integer , Integer > ( ) ;"}
{"text":"Traverse the array A [ ]","code":"for ( int i = 0 ; i < A . length ; i ++ ) { Aindex . put ( A [ i ] , i ) ; }"}
{"text":"Traverse the array B [ ]","code":"for ( int i = 0 ; i < B . length ; i ++ ) {"}
{"text":"If difference is negative , add N to it","code":"if ( i - Aindex . get ( B [ i ] ) < 0 ) { if ( ! diff . containsKey ( A . length + i - Aindex . get ( B [ i ] ) ) ) { diff . put ( A . length + i - Aindex . get ( B [ i ] ) , 1 ) ; } else { diff . put ( A . length + i - Aindex . get ( B [ i ] ) , diff . get ( A . length + i - Aindex . get ( B [ i ] ) ) + 1 ) ; } }"}
{"text":"Keep track of the number of shifts required to place elements at same indices","code":"else { if ( ! diff . containsKey ( i - Aindex . get ( B [ i ] ) ) ) { diff . put ( i - Aindex . get ( B [ i ] ) , 1 ) ; } else { diff . put ( i - Aindex . get ( B [ i ] ) , diff . get ( i - Aindex . get ( B [ i ] ) ) + 1 ) ; } } }"}
{"text":"Return the max matches","code":"int max = 0 ; for ( Map . Entry < Integer , Integer > ele : diff . entrySet ( ) ) { if ( ele . getValue ( ) > max ) { max = ele . getValue ( ) ; } } return max ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] A = { 5 , 3 , 7 , 9 , 8 } ; int [ ] B = { 8 , 7 , 3 , 5 , 9 } ;"}
{"text":"Returns the count of matched elements","code":"System . out . println ( maxMatch ( A , B ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; import java . util . * ; class GFG { static int N = 9 ;"}
{"text":"Function to check if all elements of the board [ ] [ ] array store value in the range [ 1 , 9 ]","code":"static boolean isinRange ( int [ ] [ ] board ) {"}
{"text":"Traverse board [ ] [ ] array","code":"for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {"}
{"text":"Check if board [ i ] [ j ] lies in the range","code":"if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; }"}
{"text":"Function to check if the solution of sudoku puzzle is valid or not","code":"static boolean isValidSudoku ( int board [ ] [ ] ) {"}
{"text":"Check if all elements of board [ ] [ ] stores value in the range [ 1 , 9 ]","code":"if ( isinRange ( board ) == false ) { return false ; }"}
{"text":"Stores unique value from 1 to N","code":"boolean [ ] unique = new boolean [ N + 1 ] ;"}
{"text":"Traverse each row of the given array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Initialize unique [ ] array to false","code":"Arrays . fill ( unique , false ) ;"}
{"text":"Traverse each column of current row","code":"for ( int j = 0 ; j < N ; j ++ ) {"}
{"text":"Stores the value of board [ i ] [ j ]","code":"int Z = board [ i ] [ j ] ;"}
{"text":"Check if current row stores duplicate value","code":"if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } }"}
{"text":"Traverse each column of the given array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Initialize unique [ ] array to false","code":"Arrays . fill ( unique , false ) ;"}
{"text":"Traverse each row of current column","code":"for ( int j = 0 ; j < N ; j ++ ) {"}
{"text":"Stores the value of board [ j ] [ i ]","code":"int Z = board [ j ] [ i ] ;"}
{"text":"Check if current column stores duplicate value","code":"if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } }"}
{"text":"Traverse each block of size 3 * 3 in board [ ] [ ] array","code":"for ( int i = 0 ; i < N - 2 ; i += 3 ) {"}
{"text":"j stores first column of each 3 * 3 block","code":"for ( int j = 0 ; j < N - 2 ; j += 3 ) {"}
{"text":"Initialize unique [ ] array to false","code":"Arrays . fill ( unique , false ) ;"}
{"text":"Traverse current block","code":"for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) {"}
{"text":"Stores row number of current block","code":"int X = i + k ;"}
{"text":"Stores column number of current block","code":"int Y = j + l ;"}
{"text":"Stores the value of board [ X ] [ Y ]","code":"int Z = board [ X ] [ Y ] ;"}
{"text":"Check if current block stores duplicate value","code":"if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } }"}
{"text":"If all conditions satisfied","code":"return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int [ ] [ ] board = { { 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 } , { 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 } , { 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 } , { 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 } , { 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 } , { 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 } , { 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 } , { 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 } , { 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 } } ; if ( isValidSudoku ( board ) ) { System . out . println ( \" Valid \" ) ; } else { System . out . println ( \" Not \u2581 Valid \" ) ; } } }"}
{"text":"Java program for the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if a number is Palindrome or not here i is the starting index and j is the last index of the subarray","code":"public static boolean palindrome ( int [ ] a , int i , int j ) { while ( i < j ) {"}
{"text":"If the integer at i is not equal to j then the subarray is not palindrome","code":"if ( a [ i ] != a [ j ] ) return false ;"}
{"text":"Otherwise","code":"i ++ ; j -- ; }"}
{"text":"all a [ i ] is equal to a [ j ] then the subarray is palindrome","code":"return true ; }"}
{"text":"Function to find a subarray whose concatenation forms a palindrome and return its starting index","code":"static int findSubArray ( int [ ] arr , int k ) { int n = arr . length ;"}
{"text":"Iterating over subarray of length k and checking if that subarray is palindrome","code":"for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; }"}
{"text":"If no subarray is palindrome","code":"return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 1 , 3 } ; int k = 4 ; int ans = findSubArray ( arr , k ) ; if ( ans == - 1 ) System . out . print ( - 1 + \"NEW_LINE\"); else { for ( int i = ans ; i < ans + k ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }"}
{"text":"Java program for the above approach","code":"import java . awt . Point ; import java . util . HashSet ; class GFG {"}
{"text":"Function to check if the man crosses previous visited coordinate or not","code":"static void isCrossed ( String path ) { if ( path . length ( ) == 0 ) return ;"}
{"text":"Stores the count of crossed vertex","code":"boolean ans = false ;"}
{"text":"Stores ( x , y ) coordinates","code":"HashSet < Point > set = new HashSet < Point > ( ) ;"}
{"text":"The coordinates for the origin","code":"int x = 0 , y = 0 ; set . add ( new Point ( x , y ) ) ;"}
{"text":"Iterate over the String","code":"for ( int i = 0 ; i < path . length ( ) ; i ++ ) {"}
{"text":"Condition to increment X or Y co - ordinates respectively","code":"if ( path . charAt ( i ) == ' N ' ) set . add ( new Point ( x , y ++ ) ) ; if ( path . charAt ( i ) == ' S ' ) set . add ( new Point ( x , y -- ) ) ; if ( path . charAt ( i ) == ' E ' ) set . add ( new Point ( x ++ , y ) ) ; if ( path . charAt ( i ) == ' W ' ) set . add ( new Point ( x -- , y ) ) ;"}
{"text":"Check if ( x , y ) is already visited","code":"if ( set . contains ( new Point ( x , y ) ) ) { ans = true ; break ; } }"}
{"text":"Print the result","code":"if ( ans ) System . out . print ( \" Crossed \" ) ; else System . out . print ( \" Not \u2581 Crossed \" ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given String","code":"String path = \" NESW \" ;"}
{"text":"Function Call","code":"isCrossed ( path ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the maximum width of the tree using level order traversal","code":"static int maxWidth ( int N , int M , ArrayList < Integer > cost , ArrayList < ArrayList < Integer > > s ) {"}
{"text":"Store the edges of the tree","code":"ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { adj . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { adj . get ( s . get ( i ) . get ( 0 ) ) . add ( s . get ( i ) . get ( 1 ) ) ; }"}
{"text":"Stores maximum width of the tree","code":"int result = 0 ;"}
{"text":"Stores the nodes of each level","code":"Queue < Integer > q = new LinkedList < > ( ) ;"}
{"text":"Insert root node","code":"q . add ( 0 ) ;"}
{"text":"Perform level order traversal on the tree","code":"while ( q . size ( ) != 0 ) {"}
{"text":"Stores the size of the queue","code":"int count = q . size ( ) ;"}
{"text":"Update maximum width","code":"result = Math . max ( count , result ) ;"}
{"text":"Push the nodes of the next level and pop the elements of the current level","code":"while ( count -- > 0 ) {"}
{"text":"Get element from the front the Queue","code":"int temp = q . remove ( ) ;"}
{"text":"Push all nodes of the next level .","code":"for ( int i = 0 ; i < adj . get ( temp ) . size ( ) ; i ++ ) { q . add ( adj . get ( temp ) . get ( i ) ) ; } } }"}
{"text":"Return the result .","code":"return result ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 11 , M = 10 ; ArrayList < ArrayList < Integer > > edges = new ArrayList < ArrayList < Integer > > ( ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 1 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 2 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 3 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 1 , 4 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 1 , 5 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 3 , 6 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 4 , 7 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 10 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 8 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 9 ) ) ) ; ArrayList < Integer > cost = new ArrayList < Integer > ( Arrays . asList ( 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 ) ) ;"}
{"text":"Constructed tree is : 1 \/ | \\ 2 - 1 3 \/ \\ \\ 4 5 8 \/ \/ | \\ 2 6 12 7","code":"System . out . println ( maxWidth ( N , M , cost , edges ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { static final int MAX = 10000000 ;"}
{"text":"Stores if an index is a prime \/ non - prime value","code":"static boolean [ ] isPrime = new boolean [ MAX + 1 ] ;"}
{"text":"Stores the prime","code":"static Vector < Integer > primes = new Vector < Integer > ( ) ;"}
{"text":"Function to generate all prime numbers","code":"static void SieveOfEratosthenes ( ) { Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {"}
{"text":"If current element is prime","code":"if ( isPrime [ p ] == true ) {"}
{"text":"Set all its multiples non - prime","code":"for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } }"}
{"text":"Store all prime numbers","code":"for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . add ( p ) ; }"}
{"text":"Function to find the closest prime to a particular number","code":"static int prime_search ( Vector < Integer > primes , int diff ) {"}
{"text":"Applying binary search on primes vector","code":"int low = 0 ; int high = primes . size ( ) - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) \/ 2 ;"}
{"text":"If the prime added makes the elements equal","code":"if ( primes . get ( mid ) == diff ) {"}
{"text":"Return this as the closest prime","code":"return primes . get ( mid ) ; }"}
{"text":"If the array remains non - decreasing","code":"else if ( primes . get ( mid ) < diff ) {"}
{"text":"Search for a bigger prime number","code":"low = mid + 1 ; }"}
{"text":"Otherwise","code":"else { res = primes . get ( mid ) ;"}
{"text":"Check if a smaller prime can make array non - decreasing or not","code":"high = mid - 1 ; } }"}
{"text":"Return closest number","code":"return res ; }"}
{"text":"Function to find the minimum cost","code":"static int minCost ( int arr [ ] , int n ) {"}
{"text":"Find all primes","code":"SieveOfEratosthenes ( ) ;"}
{"text":"Store the result","code":"int res = 0 ;"}
{"text":"Iterate over the array","code":"for ( int i = 1 ; i < n ; i ++ ) {"}
{"text":"Current element is less than the previous element","code":"if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ;"}
{"text":"Find the closest prime which makes the array non decreasing","code":"int closest_prime = prime_search ( primes , diff ) ;"}
{"text":"Add to overall cost","code":"res += closest_prime ;"}
{"text":"Update current element","code":"arr [ i ] += closest_prime ; } }"}
{"text":"Return the minimum cost","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ;"}
{"text":"Function call","code":"System . out . print ( minCost ( arr , n ) ) ; } }"}
{"text":"Java implementation for the above approach","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to return ways to split a string into three parts with the equal number of 0","code":"static int count ( String s ) {"}
{"text":"Store total count of 0 s","code":"int cnt = 0 ;"}
{"text":"Count total no . of 0 s character in given string","code":"for ( char c : s . toCharArray ( ) ) { cnt += c == '0' ? 1 : 0 ; }"}
{"text":"If total count of 0 character is not divisible by 3","code":"if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt \/ 3 , sum = 0 ;"}
{"text":"Initialize map to store frequency of k","code":"Map < Integer , Integer > map = new HashMap < > ( ) ;"}
{"text":"Traverse string to find ways to split string","code":"for ( int i = 0 ; i < s . length ( ) ; i ++ ) {"}
{"text":"Increment count if 0 appears","code":"sum += s . charAt ( i ) == '0' ? 1 : 0 ;"}
{"text":"Increment result if sum equal to 2 * k and k exists in map","code":"if ( sum == 2 * k && map . containsKey ( k ) && i < s . length ( ) - 1 && i > 0 ) { res += map . get ( k ) ; }"}
{"text":"Insert sum in map","code":"map . put ( sum , map . getOrDefault ( sum , 0 ) + 1 ) ; }"}
{"text":"Return result","code":"return res ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given string","code":"String str = \"01010\" ;"}
{"text":"Function call","code":"System . out . println ( count ( str ) ) ; } }"}
{"text":"Java program for above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the number of ways to split","code":"static int splitstring ( String s ) { int n = s . length ( ) ;"}
{"text":"Calculating the total number of zeros","code":"int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s . charAt ( i ) == '0' ) zeros ++ ;"}
{"text":"Case1 If total count of zeros is not divisible by 3","code":"if ( zeros % 3 != 0 ) return 0 ;"}
{"text":"Case2 if total count of zeros is zero","code":"if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) \/ 2 ;"}
{"text":"Number of zeros in each substring","code":"int zerosInEachSubstring = zeros \/ 3 ;"}
{"text":"Initialising zero to the number of ways for first and second cut","code":"int waysOfFirstCut = 0 ; int waysOfSecondCut = 0 ;"}
{"text":"Initializing the count","code":"int count = 0 ;"}
{"text":"Traversing from the beginning","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Incrementing the count if the element is '0'","code":"if ( s . charAt ( i ) == '0' ) count ++ ;"}
{"text":"Incrementing the ways for the 1 st cut if count is equal to zeros required in each substring","code":"if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ;"}
{"text":"Incrementing the ways for the 2 nd cut if count is equal to 2 * ( zeros required in each substring )","code":"else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; }"}
{"text":"Total number of ways to split is multiplication of ways for the 1 st and 2 nd cut","code":"return waysOfFirstCut * waysOfSecondCut ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { String s = \"01010\" ;"}
{"text":"Function Call","code":"System . out . println ( \" The \u2581 number \u2581 of \u2581 \" + \" ways \u2581 to \u2581 split \u2581 is \u2581 \" + splitstring ( s ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if it is possible to transform start to end","code":"static boolean canTransform ( String str1 , String str2 ) { String s1 = \" \" ; String s2 = \" \" ;"}
{"text":"Check the sequence of A , B in both Strings str1 and str2","code":"for ( char c : str1 . toCharArray ( ) ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 . toCharArray ( ) ) { if ( c != ' C ' ) { s2 += c ; } }"}
{"text":"If both the Strings are not equal","code":"if ( ! s1 . equals ( s2 ) ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ;"}
{"text":"Traverse the Strings","code":"while ( i < n && j < n ) { if ( str1 . charAt ( i ) == ' C ' ) { i ++ ; } else if ( str2 . charAt ( j ) == ' C ' ) { j ++ ; }"}
{"text":"Check for indexes of A and B","code":"else { if ( ( str1 . charAt ( i ) == ' A ' && i < j ) || ( str1 . charAt ( i ) == ' B ' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String str1 = \" BCCABCBCA \" ; String str2 = \" CBACCBBAC \" ;"}
{"text":"Function Call","code":"if ( canTransform ( str1 , str2 ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return the length of the longest subString having equal number of vowel and consonant","code":"static int maxsubStringLength ( char [ ] S , int N ) { int arr [ ] = new int [ N ] ;"}
{"text":"Generate the array","code":"for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ;"}
{"text":"Initialize variable to store result","code":"int maxLen = 0 ;"}
{"text":"Stores the sum of subarray","code":"int curr_sum = 0 ;"}
{"text":"Map to store indices of the sum","code":"HashMap < Integer , Integer > hash = new HashMap < > ( ) ;"}
{"text":"Loop through the array","code":"for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ;"}
{"text":"If sum is 0","code":"if ( curr_sum == 0 )"}
{"text":"Count of vowels and consonants are equal","code":"maxLen = Math . max ( maxLen , i + 1 ) ;"}
{"text":"Update the maximum length of subString in HashMap","code":"if ( hash . containsKey ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ;"}
{"text":"Store the index of the sum","code":"else hash . put ( curr_sum , i ) ; }"}
{"text":"Return the maximum length of required subString","code":"return maxLen ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \" geeksforgeeks \" ; int n = S . length ( ) ; System . out . print ( maxsubStringLength ( S . toCharArray ( ) , n ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int [ ] [ ] mat = new int [ 1001 ] [ 1001 ] ; static int r , c , x , y ;"}
{"text":"Stores the accessible directions","code":"static int dx [ ] = { 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 } ; static int dy [ ] = { 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 } ;"}
{"text":"Function to find the minimum distance from a given cell to all other cells in the matrix","code":"static void FindMinimumDistance ( ) {"}
{"text":"Stores the accessible cells from current cell","code":"Queue < pair > q = new LinkedList < > ( ) ;"}
{"text":"Insert pair ( x , y )","code":"q . add ( new pair ( x , y ) ) ; mat [ x ] [ y ] = 0 ;"}
{"text":"Iterate untill queue is empty","code":"while ( ! q . isEmpty ( ) ) {"}
{"text":"Extract the pair","code":"x = q . peek ( ) . first ; y = q . peek ( ) . second ;"}
{"text":"Pop them","code":"q . remove ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ;"}
{"text":"Checking boundary condition","code":"if ( a < 0 a >= r b >= c b < 0 ) continue ;"}
{"text":"If the cell is not visited","code":"if ( mat [ a ] [ b ] == 0 ) {"}
{"text":"Assign the minimum distance","code":"mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ;"}
{"text":"Insert the traversed neighbour into the queue","code":"q . add ( new pair ( a , b ) ) ; } } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { r = 5 ; c = 5 ; x = 1 ; y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ;"}
{"text":"Print the required distances","code":"for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; } System . out . println ( ) ; } } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function that returns the minimum number of flips to convert the s into a concatenation of K - length sub - string","code":"public static int minOperations ( String S , int K ) {"}
{"text":"Stores the result","code":"int ans = 0 ;"}
{"text":"Iterate through string index","code":"for ( int i = 0 ; i < K ; i ++ ) {"}
{"text":"Stores count of 0 s & 1 s","code":"int zero = 0 , one = 0 ;"}
{"text":"Iterate making K jumps","code":"for ( int j = i ; j < S . length ( ) ; j += K ) {"}
{"text":"Count 0 's","code":"if ( S . charAt ( j ) == '0' ) zero ++ ;"}
{"text":"Count 1 's","code":"else one ++ ; }"}
{"text":"Add minimum flips for index i","code":"ans += Math . min ( zero , one ) ; }"}
{"text":"Return minimum number of flips","code":"return ans ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) { String S = \"110100101\" ; int K = 3 ; System . out . println ( minOperations ( S , K ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to get the missing element","code":"static int missingElement ( int arr [ ] , int n ) {"}
{"text":"For maximum Element in the array","code":"int max_ele = arr [ 0 ] ;"}
{"text":"For minimum Element in the array","code":"int min_ele = arr [ 0 ] ;"}
{"text":"For xor of all elements","code":"int x = 0 ;"}
{"text":"Common difference of AP series","code":"int d ;"}
{"text":"find maximum and minimum element","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; }"}
{"text":"Calculating common difference","code":"d = ( max_ele - min_ele ) \/ n ;"}
{"text":"Calculate the XOR of all elements","code":"for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; }"}
{"text":"Perform XOR with actual AP series resultant x will be the ans","code":"for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; }"}
{"text":"Return the missing element","code":"return x ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array","code":"int arr [ ] = new int [ ] { 12 , 3 , 6 , 15 , 18 } ; int n = arr . length ;"}
{"text":"Function Call","code":"int element = missingElement ( arr , n ) ;"}
{"text":"Print the missing element","code":"System . out . print ( element ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to prints kth sub - string","code":"static void Printksubstring ( String str , int n , int k ) {"}
{"text":"Total sub - strings possible","code":"int total = ( n * ( n + 1 ) ) \/ 2 ;"}
{"text":"If k is greater than total number of sub - strings","code":"if ( k > total ) { System . out . printf ( \"-1NEW_LINE\"); return ; }"}
{"text":"To store number of sub - strings starting with ith character of the string","code":"int substring [ ] = new int [ n + 1 ] ; substring [ 0 ] = 0 ;"}
{"text":"Compute the values","code":"int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) {"}
{"text":"substring [ i - 1 ] is added to store the cumulative sum","code":"substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; }"}
{"text":"Binary search to find the starting index of the kth sub - string","code":"int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) \/ 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) { l = m + 1 ; } else { start = m ; break ; } }"}
{"text":"To store the ending index of the kth sub - string","code":"int end = n - ( substring [ start ] - k ) ;"}
{"text":"Print the sub - string","code":"for ( int i = start - 1 ; i < end ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" abc \" ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; } }"}
{"text":"Java program to find the lower insertion point of an element in a sorted array","code":"public class AQES {"}
{"text":"Function to return the lower insertion point of an element in a sorted array","code":"static int LowerInsertionPoint ( int arr [ ] , int n , int X ) {"}
{"text":"Base cases","code":"if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; }"}
{"text":"Final check for the remaining elements which are < X","code":"while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = arr . length ; int X = 4 ; System . out . println ( LowerInsertionPoint ( arr , n , X ) ) ; } }"}
{"text":"Java Program to count the number of positions with same address in row major and column major order","code":"import java . io . * ; class GFG {"}
{"text":"Returns count of required positions","code":"static int getCount ( int M , int N ) { int count = 0 ;"}
{"text":"horizontal 1D array","code":"if ( M == 1 ) return N ;"}
{"text":"vertical 1D array","code":"if ( N == 1 ) return M ; if ( N > M ) {"}
{"text":"iterating for all possible i","code":"for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ;"}
{"text":"checking if j is integer","code":"if ( numerator % denominator == 0 ) { int j = numerator \/ denominator ;"}
{"text":"checking if j lies b \/ w 1 to N","code":"if ( j >= 1 && j <= N ) count ++ ; } } } else {"}
{"text":"iterating for all possible j","code":"for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ;"}
{"text":"checking if i is integer","code":"if ( numerator % denominator == 0 ) { int i = numerator \/ denominator ;"}
{"text":"checking if i lies b \/ w 1 to M","code":"if ( i >= 1 && i <= M ) count ++ ; } } } return count ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int M = 3 , N = 5 ; System . out . println ( getCount ( M , N ) ) ; } }"}
{"text":"Java program to make array sorted","code":"class GFG {"}
{"text":"Function to check whether there is any swappable element present to make the first array sorted","code":"static boolean swapElement ( int [ ] arr1 , int [ ] arr2 , int n ) {"}
{"text":"wrongIdx is the index of the element which is making the first array unsorted","code":"int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } int maximum = Integer . MIN_VALUE ; int maxIdx = - 1 ; boolean res = false ;"}
{"text":"Find the maximum element which satisfies the above mentioned neighboring conditions","code":"for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } }"}
{"text":"if res is true then swap the element and make the first array sorted","code":"if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; } static void swap ( int [ ] a , int wrongIdx , int [ ] b , int maxIdx ) { int c = a [ wrongIdx ] ; a [ wrongIdx ] = b [ maxIdx ] ; b [ maxIdx ] = c ; }"}
{"text":"Function to print the sorted array if elements are swapped .","code":"static void getSortedArray ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr1 [ i ] + \" \u2581 \" ) ; } } else { System . out . println ( \" Not \u2581 Possible \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 3 , 7 , 4 , 10 } ; int arr2 [ ] = { 2 , 1 , 6 , 8 , 9 } ; int n = arr1 . length ; getSortedArray ( arr1 , arr2 , n ) ; } }"}
{"text":"Java program to find middle of three distinct numbers","code":"import java . util . * ; class Middle {"}
{"text":"Function to find the middle of three number","code":"public static int middleOfThree ( int a , int b , int c ) {"}
{"text":"Compare each three number to find middle number . Enter only if a > b","code":"if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else {"}
{"text":"Decided a is not greater than b .","code":"if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }"}
{"text":"driver code","code":"public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . util . Arrays ; class GFG {"}
{"text":"Function to find the transpose of the matrix mat [ ]","code":"static int [ ] [ ] transpose ( int [ ] [ ] mat , int row , int col ) {"}
{"text":"Stores the transpose of matrix mat [ ] [ ]","code":"int [ ] [ ] tr = new int [ col ] [ row ] ;"}
{"text":"Traverse each row of the matrix","code":"for ( int i = 0 ; i < row ; i ++ ) {"}
{"text":"Traverse each column of the matrix","code":"for ( int j = 0 ; j < col ; j ++ ) {"}
{"text":"Transpose matrix elements","code":"tr [ j ] [ i ] = mat [ i ] [ j ] ; } } return tr ; }"}
{"text":"Function to sort the given matrix in row wise manner","code":"static void RowWiseSort ( int [ ] [ ] B ) {"}
{"text":"Traverse the row","code":"for ( int i = 0 ; i < ( int ) B . length ; i ++ ) {"}
{"text":"Row - Wise Sorting","code":"Arrays . sort ( B [ i ] ) ; } }"}
{"text":"Function to print the matrix in column wise sorted manner","code":"static void sortCol ( int [ ] [ ] mat , int N , int M ) {"}
{"text":"Function call to find transpose of the the matrix mat [ ] [ ]","code":"int [ ] [ ] B = transpose ( mat , N , M ) ;"}
{"text":"Sorting the matrix row - wise","code":"RowWiseSort ( B ) ;"}
{"text":"Calculate transpose of B [ ] [ ]","code":"mat = transpose ( B , M , N ) ;"}
{"text":"Print the matrix mat [ ] [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; } System . out . println ( ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input","code":"int [ ] [ ] mat = { { 1 , 6 , 10 } , { 8 , 5 , 9 } , { 9 , 4 , 15 } , { 7 , 3 , 60 } } ; int N = mat . length ; int M = mat [ 0 ] . length ;"}
{"text":"Function call to print the matrix in column wise sorted manner","code":"sortCol ( mat , N , M ) ; } }"}
{"text":"Java program for the above approach","code":"import java . lang . * ; import java . util . * ; class GFG {"}
{"text":"Function to find the largest area when a series of horizontal & vertical bars are removed","code":"static void largestArea ( int N , int M , int [ ] H , int [ ] V ) {"}
{"text":"Stores all bars","code":"Set < Integer > s1 = new HashSet < > ( ) ; Set < Integer > s2 = new HashSet < > ( ) ;"}
{"text":"Insert horizontal bars","code":"for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . add ( i ) ;"}
{"text":"Insert vertictal bars","code":"for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . add ( i ) ;"}
{"text":"Remove horizontal separators from s1","code":"for ( int i = 0 ; i < H . length ; i ++ ) { s1 . remove ( H [ i ] ) ; }"}
{"text":"Remove vertical separators from s2","code":"for ( int i = 0 ; i < V . length ; i ++ ) { s2 . remove ( V [ i ] ) ; }"}
{"text":"Stores left out horizontal and vertical separators","code":"int [ ] list1 = new int [ s1 . size ( ) ] ; int [ ] list2 = new int [ s2 . size ( ) ] ; int i = 0 ; Iterator it1 = s1 . iterator ( ) ; while ( it1 . hasNext ( ) ) { list1 [ i ++ ] = ( int ) it1 . next ( ) ; } i = 0 ; Iterator it2 = s2 . iterator ( ) ; while ( it2 . hasNext ( ) ) { list2 [ i ++ ] = ( int ) it2 . next ( ) ; }"}
{"text":"Sort both list in ascending order","code":"Arrays . sort ( list1 ) ; Arrays . sort ( list2 ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ;"}
{"text":"Find maximum difference of neighbors of list1","code":"for ( int j = 0 ; j < list1 . length ; j ++ ) { maxH = Math . max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; }"}
{"text":"Find max difference of neighbors of list2","code":"for ( int j = 0 ; j < list2 . length ; j ++ ) { maxV = Math . max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; }"}
{"text":"Print largest volume","code":"System . out . println ( maxV * maxH ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given value of N & M","code":"int N = 3 , M = 3 ;"}
{"text":"Given arrays","code":"int [ ] H = { 2 } ; int [ ] V = { 2 } ;"}
{"text":"Function call to find the largest area when a series of horizontal & vertical bars are removed","code":"largestArea ( N , M , H , V ) ; } }"}
{"text":"Java program of the above approach","code":"import java . io . * ; class GFG {"}
{"text":"Function to check if array , A [ ] can be converted into sorted array by swapping ( A [ i ] , A [ j ] ) if B [ i ] not equal to B [ j ]","code":"static boolean checkifSorted ( int A [ ] , int B [ ] , int N ) {"}
{"text":"Stores if array A [ ] is sorted in descending order or not","code":"boolean flag = false ;"}
{"text":"Traverse the array A [ ]","code":"for ( int i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"If A [ i ] is greater than A [ i + 1 ]","code":"if ( A [ i ] > A [ i + 1 ] ) {"}
{"text":"Update flag","code":"flag = true ; break ; } }"}
{"text":"If array is sorted in ascending order","code":"if ( ! flag ) { return true ; }"}
{"text":"count = 2 : Check if 0 s and 1 s both present in the B [ ]","code":"int count = 0 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If current element is 0","code":"if ( B [ i ] == 0 ) {"}
{"text":"Update count","code":"count ++ ; break ; } }"}
{"text":"Traverse the array B [ ]","code":"for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"If current element is 1","code":"if ( B [ i ] == 1 ) { count ++ ; break ; } }"}
{"text":"If both 0 s and 1 s are present in the array","code":"if ( count == 2 ) { return true ; } return false ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Input array A [ ]","code":"int A [ ] = { 3 , 1 , 2 } ;"}
{"text":"Input array B [ ]","code":"int B [ ] = { 0 , 1 , 1 } ; int N = A . length ;"}
{"text":"Function call","code":"boolean check = checkifSorted ( A , B , N ) ;"}
{"text":"If true , print YES","code":"if ( check ) { System . out . println ( \" YES \" ) ; }"}
{"text":"Else print NO","code":"else { System . out . println ( \" NO \" ) ; } } }"}
{"text":"Java program for above approach","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to find the minimum number of steps to make A > B","code":"static int minSteps ( StringBuilder A , StringBuilder B , int M , int N ) { if ( A . charAt ( 0 ) > B . charAt ( 0 ) ) return 0 ; if ( B . charAt ( 0 ) > A . charAt ( 0 ) ) { return 1 ; }"}
{"text":"If all character are same and M <= N","code":"if ( M <= N && A . charAt ( 0 ) == B . charAt ( 0 ) && count ( A , A . charAt ( 0 ) ) == M && count ( B , B . charAt ( 0 ) ) == N ) return - 1 ;"}
{"text":"If there lies any character in B which is greater than B [ 0 ]","code":"for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) > B . charAt ( 0 ) ) return 1 ; }"}
{"text":"If there lies any character in A which is smaller than A [ 0 ]","code":"for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) < A . charAt ( 0 ) ) return 1 ; }"}
{"text":"If there lies a character which is in A and greater than A [ 0 ]","code":"for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) > A . charAt ( 0 ) ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } }"}
{"text":"If there lies a character which is in B and less than B [ 0 ]","code":"for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) < B . charAt ( 0 ) ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } }"}
{"text":"Otherwise","code":"return 0 ; } static int count ( StringBuilder a , char c ) { int count = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) if ( a . charAt ( i ) == c ) count ++ ; return count ; } static void swap ( StringBuilder s1 , int index1 , StringBuilder s2 , int index2 ) { char c = s1 . charAt ( index1 ) ; s1 . setCharAt ( index1 , s2 . charAt ( index2 ) ) ; s2 . setCharAt ( index2 , c ) ; }"}
{"text":"Driver function","code":"public static void main ( String [ ] args ) { StringBuilder A = new StringBuilder ( \" adsfd \" ) ; StringBuilder B = new StringBuilder ( \" dffff \" ) ; int M = A . length ( ) ; int N = B . length ( ) ; System . out . println ( minSteps ( A , B , M , N ) ) ; } }"}
{"text":"Java algorithm for above approach","code":"import java . util . * ; class GFG {"}
{"text":"Pair class which will store element of array with its index","code":"public static class Pair { int val ; int idx ; Pair ( int val , int idx ) { this . val = val ; this . idx = idx ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int n = 5 ; int [ ] arr = { 4 , 7 , 2 , 3 , 9 } ; System . out . println ( minOperations ( arr , n ) ) ; }"}
{"text":"Function to find minimum number of operation required so that array becomes meaningful","code":"public static int minOperations ( int [ ] arr , int n ) {"}
{"text":"Initializing array of Pair type which can be used to sort arr with respect to its values","code":"Pair [ ] num = new Pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { num [ i ] = new Pair ( arr [ i ] , i ) ; }"}
{"text":"Sorting array num on the basis of value","code":"Arrays . sort ( num , ( Pair a , Pair b ) -> a . val - b . val ) ;"}
{"text":"Initializing variables used to find maximum length of increasing streak in index","code":"int res = 1 ; int streak = 1 ; int prev = num [ 0 ] . idx ; for ( int i = 1 ; i < n ; i ++ ) { if ( prev < num [ i ] . idx ) { res ++ ;"}
{"text":"Updating streak","code":"streak = Math . max ( res , streak ) ; } else res = 1 ; prev = num [ i ] . idx ; }"}
{"text":"Returning number of elements left except streak","code":"return n - streak ; } }"}
{"text":"Java program for above approach","code":"import java . util . * ; import java . lang . * ; class GFG { static final int maxN = 201 ;"}
{"text":"Variables which represent the size of the array","code":"static int n1 , n2 , n3 ;"}
{"text":"Stores the results","code":"static int [ ] [ ] [ ] dp = new int [ maxN ] [ maxN ] [ maxN ] ;"}
{"text":"Function to return the maximum possible sum","code":"static int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) {"}
{"text":"Stores the count of arrays processed","code":"int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ;"}
{"text":"If more than two arrays have been processed","code":"if ( cnt >= 2 ) return 0 ;"}
{"text":"If an already computed subproblem occurred","code":"if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ;"}
{"text":"Explore all the possible pairs","code":"if ( i < n1 && j < n2 )"}
{"text":"Recursive function call","code":"ans = Math . max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ;"}
{"text":"Memoize the maximum","code":"dp [ i ] [ j ] [ k ] = ans ;"}
{"text":"Returning the value","code":"return dp [ i ] [ j ] [ k ] ; } static void reverse ( int [ ] tmp ) { int i , k , t ; int n = tmp . length ; for ( i = 0 ; i < n \/ 2 ; i ++ ) { t = tmp [ i ] ; tmp [ i ] = tmp [ n - i - 1 ] ; tmp [ n - i - 1 ] = t ; } }"}
{"text":"Function to return the maximum sum of products of pairs possible","code":"static int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) {"}
{"text":"Initialising the dp array to - 1","code":"for ( int i = 0 ; i < dp . length ; i ++ ) for ( int j = 0 ; j < dp [ 0 ] . length ; j ++ ) for ( int k = 0 ; k < dp [ j ] [ 0 ] . length ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ;"}
{"text":"Sort the arrays in descending order","code":"Arrays . sort ( arr1 ) ; reverse ( arr1 ) ; Arrays . sort ( arr2 ) ; reverse ( arr2 ) ; Arrays . sort ( arr3 ) ; reverse ( arr3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { n1 = 2 ; int arr1 [ ] = { 3 , 5 } ; n2 = 2 ; int arr2 [ ] = { 2 , 1 } ; n3 = 3 ; int arr3 [ ] = { 4 , 3 , 5 } ; System . out . println ( maxProductSum ( arr1 , arr2 , arr3 ) ) ; } }"}
{"text":"Java program to implement the the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to find lexicographically largest triplet that forms a triangle in the given array","code":"static void findTriplet ( int arr [ ] , int N ) {"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ; int flag = 0 , i ;"}
{"text":"Iterate from the end of the array","code":"for ( i = N - 1 ; i - 2 >= 0 ; i -- ) {"}
{"text":"If the triplet forms a triangle","code":"if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } }"}
{"text":"If triplet found","code":"if ( flag != 0 ) {"}
{"text":"Print the triplet","code":"System . out . println ( arr [ i - 2 ] + \" \u2581 \" + arr [ i - 1 ] + \" \u2581 \" + arr [ i ] ) ; }"}
{"text":"Otherwise","code":"else { System . out . println ( - 1 ) ; } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = arr . length ; findTriplet ( arr , N ) ; } }"}
{"text":"Java program for the above","code":"import java . util . Arrays ; class GFG {"}
{"text":"Function to return the count of all pairs having minimal absolute difference","code":"static int numberofpairs ( int [ ] arr , int N ) {"}
{"text":"Stores the count of pairs","code":"int answer = 0 ;"}
{"text":"Sort the array","code":"Arrays . sort ( arr ) ;"}
{"text":"Stores the minimum difference between adjacent pairs","code":"int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ )"}
{"text":"Update the minimum difference between pairs","code":"minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff )"}
{"text":"Increase count of pairs with difference equal to that of minimum difference","code":"answer ++ ; }"}
{"text":"Return the final count","code":"return answer ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given array arr [ ]","code":"int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = arr . length ;"}
{"text":"Function Call","code":"System . out . print ( numberofpairs ( arr , N ) ) ; } }"}
{"text":"Java Program to implement the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Initialise maximum possible length of subsequence","code":"static int max_length = 0 ;"}
{"text":"Store elements to compare max_length with its size and change the value of max_length accordingly","code":"static Vector < Integer > store = new Vector < Integer > ( ) ;"}
{"text":"Store the elements of the longest subsequence","code":"static Vector < Integer > ans = new Vector < Integer > ( ) ;"}
{"text":"Function to find the length of longest subsequence","code":"static void find_max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) {"}
{"text":"Update max_length","code":"max_length = store . size ( ) ;"}
{"text":"Store the subsequence elements","code":"ans = store ; } } for ( int i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) {"}
{"text":"Recursively proceed with obtained sum","code":"find_max_length ( arr , i , sum , k ) ;"}
{"text":"poping elements from back of vector store","code":"store . remove ( store . size ( ) - 1 ) ; }"}
{"text":"if sum > 0 then we don 't  required thatsubsequence  so return and continue  with earlier elements","code":"else return ; } return ; } static int longestSubsequence ( int [ ] arr , int n , int k ) {"}
{"text":"Sort the given array","code":"Arrays . sort ( arr ) ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"If max_length is already greater than or equal than remaining length","code":"if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { - 3 , 0 , 1 , 1 , 2 } ; int n = arr . length ; int k = 1 ; System . out . print ( longestSubsequence ( arr , n , k ) ) ; } }"}
{"text":"Java implementation to sort decreasing permutation of N using triple swaps","code":"class GFG {"}
{"text":"Function to sort array","code":"static void sortArray ( int A [ ] , int N ) {"}
{"text":"The three indices that has to be chosen","code":"int x = 0 , y = 0 , z = 0 ;"}
{"text":"Check if possible to sort array","code":"if ( N % 4 == 0 N % 4 == 1 ) {"}
{"text":"Swapping to bring element at required position Bringing at least one element at correct position","code":"for ( int i = 0 ; i < N \/ 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; }"}
{"text":"Tracing changes in array","code":"A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; }"}
{"text":"Print the sorted array","code":"System . out . print ( \" Sorted \u2581 Array : \u2581 \" ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + \" \u2581 \" ) ; }"}
{"text":"If not possible to sort","code":"else { System . out . print ( \" - 1\" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = A . length ; sortArray ( A , N ) ; } }"}
{"text":"Java implementation of the approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to return K such that changing all elements greater than K to K will make array sum N otherwise return - 1","code":"static int findK ( int arr [ ] , int size , int N ) {"}
{"text":"Sorting the array in increasing order","code":"Arrays . sort ( arr ) ; int temp_sum = 0 ;"}
{"text":"Loop through all the elements of the array","code":"for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ;"}
{"text":"Checking if sum of array equals N","code":"if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 10 , 4 , 8 } ; int size = arr . length ; int N = 16 ; System . out . print ( findK ( arr , size , N ) ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function that returns true if there exists a triplet with sum x","code":"static boolean existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) {"}
{"text":"Sorting arrays such that a [ ] represents smallest array","code":"if ( l2 <= l1 && l2 <= l3 ) { swap ( l2 , l1 ) ; swap ( a , b ) ; } else if ( l3 <= l1 && l3 <= l2 ) { swap ( l3 , l1 ) ; swap ( a , c ) ; }"}
{"text":"Iterating the smallest array","code":"for ( int i = 0 ; i < l1 ; i ++ ) {"}
{"text":"Two pointers on second and third array","code":"int j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) {"}
{"text":"If a valid triplet is found","code":"if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = a . length ; int l2 = b . length ; int l3 = c . length ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Utility function to print the contents of an array","code":"public static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] ) ; }"}
{"text":"A comparison function that return negative if ' AB ' is smaller than ' BA ' when we concatenate two numbers ' A ' and ' B ' For example , it will return negative value if we pass 12 and 24 as arguments . This function will be used during sort","code":"public static int compare ( int num1 , int num2 ) {"}
{"text":"Convert first number to string format","code":"String A = Integer . toString ( num1 ) ;"}
{"text":"Convert second number to string format","code":"String B = Integer . toString ( num2 ) ;"}
{"text":"Check if ' AB ' is smaller or ' BA ' and return integer value","code":"return ( A + B ) . compareTo ( B + A ) ; }"}
{"text":"Function to print the arrangement with the smallest value","code":"public static void printSmallest ( int N , int [ ] arr ) {"}
{"text":"Sort using compare function which is defined above","code":"for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } }"}
{"text":"Print the sorted array","code":"printArr ( arr , N ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 2 , 9 , 21 , 1 } ; int N = arr . length ; printSmallest ( N , arr ) ; } }"}
{"text":"Java program for modifying Selection Sort so that it becomes stable .","code":"class GFG { static void stableSelectionSort ( int [ ] a , int n ) {"}
{"text":"Iterate through array elements","code":"for ( int i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"Find minimum element from arr [ i ] to arr [ n - 1 ] .","code":"int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ;"}
{"text":"Move minimum element at current i .","code":"int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int [ ] a = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = a . length ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; } }"}
{"text":"Java program to check whether permutation of two arrays satisfy the condition a [ i ] + b [ i ] >= k .","code":"import java . util . * ; class GFG {"}
{"text":"Check whether any permutation exists which satisfy the condition .","code":"static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) {"}
{"text":"Sort the array a [ ] in decreasing order .","code":"Arrays . sort ( a , Collections . reverseOrder ( ) ) ;"}
{"text":"Sort the array b [ ] in increasing order .","code":"Arrays . sort ( b ) ;"}
{"text":"Checking condition on each index .","code":"for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { Integer a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = a . length ; if ( isPossible ( a , b , n , k ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"}
{"text":"Java program to implement simple approach to sort an array according to count of set bits .","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to count setbits","code":"static int setBitCount ( int num ) { int count = 0 ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) count ++ ; num >>= 1 ; } return count ; }"}
{"text":"Function to sort By SetBitCount","code":"static void sortBySetBitCount ( int [ ] arr , int n ) { ArrayList < ArrayList < Integer > > count = new ArrayList < ArrayList < Integer > > ( ) ;"}
{"text":"Iterate over all values and insert into multimap","code":"for ( int i = 0 ; i < n ; ++ i ) { count . add ( new ArrayList < Integer > ( Arrays . asList ( ( - 1 ) * setBitCount ( arr [ i ] ) , arr [ i ] ) ) ) ; } Collections . sort ( count , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ; for ( int i = 0 ; i < count . size ( ) ; i ++ ) { System . out . print ( count . get ( i ) . get ( 1 ) + \" \u2581 \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; } }"}
{"text":"Java program for the above approach","code":"public class GFG {"}
{"text":"Function to check if it is possible to reach the end of the binary string using the given jumps","code":"static int canReach ( String s , int L , int R ) {"}
{"text":"Stores the DP states","code":"int dp [ ] = new int [ s . length ( ) ] ;"}
{"text":"Initial state","code":"dp [ 0 ] = 1 ;"}
{"text":"Stores count of indices from which it is possible to reach index i","code":"int pre = 0 ;"}
{"text":"Traverse the given string","code":"for ( int i = 1 ; i < s . length ( ) ; i ++ ) {"}
{"text":"Update the values of pre accordingly","code":"if ( i >= L ) { pre += dp [ i - L ] ; }"}
{"text":"If the jump size is out of the range [ L , R ]","code":"if ( i > R ) { pre -= dp [ i - R - 1 ] ; } if ( pre > 0 && s . charAt ( i ) == '0' ) dp [ i ] = 1 ; else dp [ i ] = 0 ; }"}
{"text":"Return answer","code":"return dp [ s . length ( ) - 1 ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S = \"01101110\" ; int L = 2 , R = 3 ; if ( canReach ( S , L , R ) == 1 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"}
{"text":"Java program for the above approach","code":"public class GFG {"}
{"text":"Recursive function to find all the possible breaking of arrays into subarrays and find the maximum Bitwise XOR","code":"static int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) {"}
{"text":"If the value of N is 0","code":"if ( N == 0 ) return xrr ^ orr ;"}
{"text":"Stores the result if the new group is formed with the first element as arr [ i ]","code":"int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ;"}
{"text":"Stores if the result if the arr [ i ] is included in the last group","code":"int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ;"}
{"text":"Returns the maximum of x and y","code":"return Math . max ( x , y ) ; }"}
{"text":"Function to find the maximum possible Bitwise XOR of all possible values of the array after breaking the arrays into subarrays","code":"static int maximumXOR ( int arr [ ] , int N ) {"}
{"text":"Return the result","code":"return maxXORUtil ( arr , N , 0 , 0 ) ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 } ; int N = arr . length ; System . out . println ( maximumXOR ( arr , N ) ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . lang . * ; import java . io . * ; import java . util . * ; class GFG { static int N = 100000 + 5 ;"}
{"text":"Keep track of visited nodes","code":"static int visited [ ] = new int [ N ] ;"}
{"text":"Function to construct a tree such that there are no two adjacent nodes with the same weight","code":"static void construct_tree ( int weights [ ] , int n ) { int minimum = Arrays . stream ( weights ) . min ( ) . getAsInt ( ) ; int maximum = Arrays . stream ( weights ) . max ( ) . getAsInt ( ) ;"}
{"text":"If minimum and maximum elements are equal , i . e . array contains one distinct element","code":"if ( minimum == maximum ) {"}
{"text":"Tree cannot be constructed","code":"System . out . println ( \" No \" ) ; return ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"Tree can be constructed","code":"System . out . println ( \" Yes \" ) ; }"}
{"text":"Choose weights [ 0 ] as root","code":"int root = weights [ 0 ] ;"}
{"text":"First Node is visited","code":"visited [ 1 ] = 1 ;"}
{"text":"Traverse the array","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Otherwise , make an edge","code":"if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { System . out . println ( 1 + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" ) ;"}
{"text":"Mark this node as visited","code":"visited [ i + 1 ] = 1 ; } }"}
{"text":"Find a weight not same as the root & make edges with that node","code":"int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } }"}
{"text":"Join non - roots with remaining nodes","code":"for ( int i = 0 ; i < n ; i ++ ) {"}
{"text":"Check if current node ' s \u2581 weight \u2581 \u2581 is \u2581 same \u2581 as \u2581 root \u2581 node ' s weight and if it is not visited or not","code":"if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { System . out . println ( notroot + \" \u2581 \" + ( i + 1 ) ) ; visited [ i + 1 ] = 1 ; } } }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = weights . length ;"}
{"text":"Function Call","code":"construct_tree ( weights , N ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; import java . lang . * ; class GFG {"}
{"text":"Function to find minimum cost to convert given string into string of K length same substring","code":"static void minCost ( String s , int k ) {"}
{"text":"Stores length of string","code":"int n = s . length ( ) ;"}
{"text":"Stores the minimum cost","code":"int ans = 0 ;"}
{"text":"Traverse left substring of k length","code":"for ( int i = 0 ; i < k ; i ++ ) {"}
{"text":"Stores the frequency","code":"int [ ] a = new int [ 26 ] ; for ( int j = i ; j < n ; j += k ) { a [ s . charAt ( j ) - ' a ' ] ++ ; }"}
{"text":"Stores minimum cost for sequence of S [ i ] % k indices","code":"int min_cost = Integer . MAX_VALUE ;"}
{"text":"Check for optimal character","code":"for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ;"}
{"text":"Find sum of distance ' a ' + ch from character S [ i ] % k indices","code":"for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += Math . abs ( ch - tr ) * a [ tr ] ;"}
{"text":"Choose minimum cost for each index i","code":"min_cost = Math . min ( min_cost , cost ) ; }"}
{"text":"Increment ans","code":"ans += min_cost ; }"}
{"text":"Print minimum cost to convert string","code":"System . out . println ( ans ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given string S","code":"String S = \" abcdefabc \" ; int K = 3 ;"}
{"text":"Function Call","code":"minCost ( S , K ) ; } }"}
{"text":"Java program to implement the above approach","code":"import java . io . * ; import java . util . * ; class GFG {"}
{"text":"Function to split the first N natural numbers into two sets having minimum absolute difference of their sums","code":"static int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( minAbsDiff ( N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG { static final int N = 10000 ;"}
{"text":"Adjacency list to store edges","code":"@ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ N ] ; static int used [ ] = new int [ N ] ; static int max_matching ;"}
{"text":"Add an edge between U and V in tree","code":"static void AddEdge ( int u , int v ) {"}
{"text":"Edge from u to v","code":"adj [ u ] . add ( v ) ;"}
{"text":"Edge from V to U","code":"adj [ v ] . add ( u ) ; }"}
{"text":"Function that finds the maximum matching of the DFS","code":"static void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) {"}
{"text":"Go further as we are not allowed to go towards its parent","code":"if ( adj [ u ] . get ( i ) != p ) { Matching_dfs ( adj [ u ] . get ( i ) , u ) ; } }"}
{"text":"If U and its parent P is not taken then we must take & mark them as taken","code":"if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) {"}
{"text":"Increment size of edge set","code":"max_matching ++ ; used [ u ] = used [ p ] = 1 ; } }"}
{"text":"Function to find the maximum matching in a graph","code":"static void maxMatching ( ) {"}
{"text":"Taking 1 as a root of the tree","code":"Matching_dfs ( 1 , 0 ) ;"}
{"text":"Print maximum Matching","code":"System . out . print ( max_matching + \"NEW_LINE\"); }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ;"}
{"text":"Joining edge between two nodes in tree","code":"AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ;"}
{"text":"Function call","code":"maxMatching ( ) ; } }"}
{"text":"Java program to implement the above approach","code":"class GFG {"}
{"text":"Function to calculate and return the minimum cost required to swap two arrays","code":"static int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; }"}
{"text":"Return the total minimum cost","code":"return mini * ( 2 * N - 1 ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int N = 3 ; int [ ] A = { 1 , 4 , 2 } ; int [ ] B = { 10 , 6 , 12 } ; System . out . print ( getMinCost ( A , B , N ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the values stored in vector arr","code":"static void printVector ( ArrayList < Integer > arr ) { if ( arr . size ( ) != 1 ) {"}
{"text":"Traverse the vector arr","code":"for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { System . out . print ( arr . get ( i ) + \" \u2581 \" ) ; } System . out . println ( ) ; } }"}
{"text":"Recursive function to print different ways in which N can be written as a sum of at 2 or more positive integers","code":"static void findWays ( ArrayList < Integer > arr , int i , int n ) {"}
{"text":"If n is zero then print this ways of breaking numbers","code":"if ( n == 0 ) printVector ( arr ) ;"}
{"text":"Start from previous element in the representation till n","code":"for ( int j = i ; j <= n ; j ++ ) {"}
{"text":"Include current element from representation","code":"arr . add ( j ) ;"}
{"text":"Call function again with reduced sum","code":"findWays ( arr , j , n - j ) ;"}
{"text":"Backtrack to remove current element from representation","code":"arr . remove ( arr . size ( ) - 1 ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given sum N","code":"int n = 4 ;"}
{"text":"To store the representation of breaking N","code":"ArrayList < Integer > arr = new ArrayList < Integer > ( ) ;"}
{"text":"Function call","code":"findWays ( arr , 1 , n ) ; } }"}
{"text":"Java program for rearrange array to generate maximum decreasing subsequences","code":"import java . util . HashMap ; import java . util . Map ; public class Main {"}
{"text":"Function to count maximum subsequence","code":"public static void Maximum_subsequence ( int [ ] A , int N ) {"}
{"text":"Stores the frequency of array elements","code":"HashMap < Integer , Integer > frequency = new HashMap < > ( ) ;"}
{"text":"Stores maximum frequency","code":"int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Update frequency of A [ i ]","code":"if ( frequency . containsKey ( A [ i ] ) ) { frequency . replace ( A [ i ] , frequency . get ( A [ i ] ) + 1 ) ; } else { frequency . put ( A [ i ] , 1 ) ; } } for ( Map . Entry it : frequency . entrySet ( ) ) {"}
{"text":"Update maximum subsequences","code":"if ( ( int ) it . getValue ( ) > max_freq ) { max_freq = ( int ) it . getValue ( ) ; } }"}
{"text":"Print the result","code":"System . out . println ( max_freq ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = arr . length ; Maximum_subsequence ( arr , N ) ; } }"}
{"text":"Java program for the above problem","code":"import java . util . * ; class GFG {"}
{"text":"Function to print the arrangement of characters","code":"public static void DivideString ( String s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ;"}
{"text":"Stores frequency of characters","code":"int [ ] fr = new int [ 26 ] ; char [ ] ans = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { fr [ s . charAt ( i ) - ' a ' ] ++ ; } char ch = ' a ' , ch1 = ' a ' ; for ( i = 0 ; i < 26 ; i ++ ) {"}
{"text":"Count the character having frequency K","code":"if ( fr [ i ] == k ) { c ++ ; }"}
{"text":"Count the character having frequency greater than K and not equal to 2 K","code":"if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = ( char ) ( i + ' a ' ) ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = ( char ) ( i + ' a ' ) ; } } for ( i = 0 ; i < n ; i ++ ) ans [ i ] = '1' ; HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"Case 1","code":"if ( fr [ s . charAt ( i ) - ' a ' ] == k ) { if ( mp . containsKey ( s . charAt ( i ) ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c \/ 2 ) ) { ans [ i ] = '2' ; no ++ ; mp . replace ( s . charAt ( i ) , 1 ) ; } } } }"}
{"text":"Case 2","code":"if ( ( c % 2 == 1 ) && ( c1 > 0 ) ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } }"}
{"text":"Case 3","code":"if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s . charAt ( i ) - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } System . out . println ( ans ) ; } else {"}
{"text":"If all cases fail","code":"System . out . println ( \" NO \" ) ; } }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String S = \" abbbccc \" ; int N = S . length ( ) ; int K = 1 ; DivideString ( S , N , K ) ; } }"}
{"text":"Java implementation to check if two items can be selected from two different categories without exceeding the total price","code":"import java . util . * ; class GFG {"}
{"text":"Function to check if two items can be selected from two different categories without exceeding the total price","code":"static String check ( int S , int prices [ ] , int type [ ] , int n ) {"}
{"text":"Loop to choose two different pairs using two nested loops","code":"for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) {"}
{"text":"Condition to check if the price of these two elements is less than S","code":"if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return \" Yes \" ; } } } } return \" No \" ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ;"}
{"text":"Function Call","code":"System . out . print ( check ( S , prices , type , n ) ) ; } }"}
{"text":"Java implementation to find the largest value of a + b satisfying the given condition","code":"class GFG {"}
{"text":"Function to return the maximum sum of a + b satisfying the given condition","code":"static int getLargestSum ( int N ) {"}
{"text":"Initialize max_sum","code":"int max_sum = 0 ;"}
{"text":"Consider all possible pairs and check the sum divides product property","code":"for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) {"}
{"text":"To find the largest factor k","code":"int k = N \/ j ; int a = k * i ; int b = k * j ;"}
{"text":"Check if the product is divisible by the sum","code":"if ( a <= N && b <= N && a * b % ( a + b ) == 0 )"}
{"text":"Storing the maximum sum in the max_sum variable","code":"max_sum = Math . max ( max_sum , a + b ) ; } }"}
{"text":"Return the max_sum value","code":"return max_sum ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum + \"NEW_LINE\"); } }"}
{"text":"Java implementation of the approach","code":"class GFG {"}
{"text":"Function to return the encrypted String","code":"static String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = \" \" ; while ( i < n ) {"}
{"text":"Number of times the current character will be repeated","code":"cnt = i + 1 ;"}
{"text":"Repeat the current character in the encrypted String","code":"while ( cnt -- > 0 ) encryptedStr += str . charAt ( i ) ; i ++ ; } return encryptedStr ; }"}
{"text":"Driver code","code":"public static void main ( String [ ] args ) { String str = \" geeks \" ; int n = str . length ( ) ; System . out . println ( encryptString ( str , n ) ) ; } }"}
{"text":"Java program to find the minimum difference .","code":"import java . util . * ; class GFG {"}
{"text":"Function to return required minimum difference","code":"static int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ;"}
{"text":"finding minimum and maximum values","code":"for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; }"}
{"text":"returning minimum possible difference","code":"return Math . max ( 0 , mx - mn - 2 * x ) ; }"}
{"text":"Driver program","code":"public static void main ( String [ ] args ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ;"}
{"text":"function to return the answer","code":"System . out . println ( minDiff ( n , x , A ) ) ; } }"}
{"text":"Java Program to count swaps required to balance string","code":"public class BalanceParan { static long swapCount ( String s ) { char [ ] chars = s . toCharArray ( ) ;"}
{"text":"stores total number of Left and Right brackets encountered","code":"int countLeft = 0 , countRight = 0 ;"}
{"text":"swap stores the number of swaps required imbalance maintains the number of imbalance pair","code":"int swap = 0 , imbalance = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == ' [ ' ) {"}
{"text":"increment count of Left bracket","code":"countLeft ++ ; if ( imbalance > 0 ) {"}
{"text":"swaps count is last swap count + total number imbalanced brackets","code":"swap += imbalance ;"}
{"text":"imbalance decremented by 1 as it solved only one imbalance of Left and Right","code":"imbalance -- ; } } else if ( chars [ i ] == ' ] ' ) {"}
{"text":"increment count of Right bracket","code":"countRight ++ ;"}
{"text":"imbalance is reset to current difference between Left and Right brackets","code":"imbalance = ( countRight - countLeft ) ; } } return swap ; }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { String s = \" [ ] ] [ ] [ \" ; System . out . println ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; System . out . println ( swapCount ( s ) ) ; } }"}
{"text":"Java program for the above approach","code":"class GFG {"}
{"text":"Function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing","code":"public static void longestSubSequence ( int [ ] [ ] A , int N ) {"}
{"text":"dp [ i ] : Stores the longest subsequence upto i","code":"int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) {"}
{"text":"Base case","code":"dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) {"}
{"text":"When the conditions hold","code":"if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } }"}
{"text":"Finally , print the required answer","code":"System . out . println ( dp [ N - 1 ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String args [ ] ) {"}
{"text":"Given Input","code":"int [ ] [ ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . length ;"}
{"text":"Function Call","code":"longestSubSequence ( A , N ) ; } }"}
{"text":"Java Program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the total number of ways to have sum N","code":"static int findWays ( int N , int dp [ ] ) {"}
{"text":"Base Case","code":"if ( N == 0 ) { return 1 ; }"}
{"text":"Return already stored result","code":"if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ;"}
{"text":"Recur for all 6 states","code":"for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } }"}
{"text":"Return the result","code":"return dp [ N ] = cnt ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given sum N","code":"int N = 4 ;"}
{"text":"Initialize the dp array","code":"int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ;"}
{"text":"Function Call","code":"System . out . print ( findWays ( N , dp ) ) ; } }"}
{"text":"Java program for the above approach","code":"import java . util . * ; class GFG {"}
{"text":"Function to calculate the total number of ways to have sum N","code":"static void findWays ( int N ) {"}
{"text":"Initialize dp array","code":"int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ;"}
{"text":"Iterate over all the possible intermediate values to reach N","code":"for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ;"}
{"text":"Calculate the sum for all 6 faces","code":"for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } }"}
{"text":"Print the total number of ways","code":"System . out . print ( dp [ N ] ) ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) {"}
{"text":"Given sum N","code":"int N = 4 ;"}
{"text":"Function call","code":"findWays ( N ) ; } }"}
{"text":"Java implementation to split the String into minimum number of parts such that each part is also present in the another String","code":"import java . util . * ; class GFG { static int INF = ( int ) ( 1e9 + 9 ) ;"}
{"text":"Node of Trie","code":"static class TrieNode { TrieNode [ ] child = new TrieNode [ 26 ] ; } ;"}
{"text":"Function to insert a node in the Trie Data Structure","code":"static void insert ( int idx , String s , TrieNode root ) { TrieNode temp = root ; for ( int i = idx ; i < s . length ( ) ; i ++ ) {"}
{"text":"Inserting every character from idx till end to String into trie","code":"if ( temp . child [ s . charAt ( i ) - ' a ' ] == null )"}
{"text":"If there is no edge corresponding to the ith character , then make a new node","code":"temp . child [ s . charAt ( i ) - ' a ' ] = new TrieNode ( ) ; temp = temp . child [ s . charAt ( i ) - ' a ' ] ; } }"}
{"text":"Function to find the minimum number of parts such that each part is present into another String","code":"static int minCuts ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ;"}
{"text":"Making a new trie","code":"TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) {"}
{"text":"Inserting every subString of S2 in trie","code":"insert ( i , S2 , root ) ; }"}
{"text":"Creating dp array and init it with infinity","code":"int [ ] dp = new int [ n1 + 1 ] ; Arrays . fill ( dp , INF ) ;"}
{"text":"Base Case","code":"dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) {"}
{"text":"Starting the cut from ith character taking temporary node pointer for checking whether the subString [ i , j ) is present in trie of not","code":"TrieNode temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 . charAt ( j - 1 ) - ' a ' ] == null )"}
{"text":"If the jth character is not in trie we 'll break","code":"break ;"}
{"text":"Updating the the ending of jth character with dp [ i ] + 1","code":"dp [ j ] = Math . min ( dp [ j ] , dp [ i ] + 1 ) ;"}
{"text":"Descending the trie pointer","code":"temp = temp . child [ S1 . charAt ( j - 1 ) - ' a ' ] ; } }"}
{"text":"Answer not possible","code":"if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; }"}
{"text":"Driver Code","code":"public static void main ( String [ ] args ) { String S1 = \" abcdab \" ; String S2 = \" dabc \" ; System . out . print ( minCuts ( S1 , S2 ) ) ; } }"}
{"text":"Java implementation to find the largest square in the matrix such that it contains atmost K 1 's","code":"import java . util . * ; class GFG {"}
{"text":"Function to find the largest square in the matrix such that it contains atmost K 1 's","code":"static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ;"}
{"text":"Precomputation of the countDP prefix sum of the matrix","code":"countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ;"}
{"text":"Loop to solve each query","code":"for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ;"}
{"text":"Binary Search to the side which have atmost in K 1 's in square","code":"while ( l <= u ) { int mid = ( l + u ) \/ 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ;"}
{"text":"Count total number of 1 s in the sub square considered","code":"int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ;"}
{"text":"If the count is less than or equals to the maximum move to right half","code":"if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } System . out . println ( ans ) ; } }"}
{"text":"Driver code","code":"public static void main ( String args [ ] ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
