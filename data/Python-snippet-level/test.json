{"text":"Function to find minimum sum after deletion","code":"def minSum ( A , N ) : NEW_LINE"}
{"text":"Stores frequency of array elements","code":"mp = { } NEW_LINE sum = 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Calculate sum","code":"sum += A [ i ] NEW_LINE"}
{"text":"Update frequency of the current element","code":"if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT"}
{"text":"Stores the minimum sum required","code":"minSum = float ( ' inf ' ) NEW_LINE"}
{"text":"Traverse map","code":"for it in mp : NEW_LINE"}
{"text":"Find the minimum sum obtained","code":"minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE"}
{"text":"Return minimum sum","code":"return minSum NEW_LINE"}
{"text":"Input array","code":"arr = [ 4 , 5 , 6 , 6 ] NEW_LINE"}
{"text":"Size of array","code":"N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE"}
{"text":"Function to calculate maximum difference between adjacent elements excluding every array element once","code":"def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE DEDENT"}
{"text":"Traverse the array","code":"for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE DEDENT"}
{"text":"Stores the maximum diff","code":"maxi = - 1 * float ( ' inf ' ) NEW_LINE"}
{"text":"Check for maximum adjacent element","code":"for j in range ( 1 , N ) : NEW_LINE"}
{"text":"Exclude current element","code":"if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"pdate maximum difference","code":"maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE"}
{"text":"Update previous value","code":"prev = arr [ j ] NEW_LINE"}
{"text":"Append the result into a vector","code":"res . append ( maxi ) NEW_LINE"}
{"text":"Print the result","code":"for x in res : NEW_LINE INDENT print ( x , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE"}
{"text":"Function to find the size of the array if the array initially contains a single element","code":"def findSize ( N ) : NEW_LINE"}
{"text":"Base case","code":"if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N \/\/ 2 ) + 1 NEW_LINE"}
{"text":"P \/ 2 -> findSize ( N 2 ) P % 2 -> 1 P \/ 2 -> findSize ( N \/ 2 )","code":"return Size NEW_LINE"}
{"text":"Function to return the count of 1 s in the range [ L , R ]","code":"def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT"}
{"text":"Base Case","code":"if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N \/\/ 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE"}
{"text":"PART 1 -> N \/ 2 [ 1 , Siz_M ]","code":"if ( L <= Siz_M ) : NEW_LINE"}
{"text":"Update the right end point of the range to min ( Siz_M , R )","code":"ret += CountOnes ( N \/\/ 2 , L , min ( Siz_M , R ) ) NEW_LINE"}
{"text":"PART 2 -> N % 2 [ SizM + 1 , Siz_M + 1 ]","code":"if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT"}
{"text":"PART 3 -> N \/ 2 [ SizM + 2 , 2 * Siz_M - 1 ] Same as PART 1 Property of Symmetricity Shift the coordinates according to PART 1 Subtract ( Siz_M + 1 ) from both L , R","code":"if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N \/\/ 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Input","code":"N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE"}
{"text":"Counts the number of 1 's in  the range [L, R]","code":"print ( CountOnes ( N , L , R ) ) NEW_LINE"}
{"text":"Function to check if number is prime or not","code":"def prime ( n ) : NEW_LINE"}
{"text":"As 1 is neither prime nor composite return false","code":"if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Check if it is divided by any number then it is not prime , return false","code":"for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Check if n is not divided by any number then it is prime and hence return true","code":"return True NEW_LINE"}
{"text":"Function to find the pair ( a , b ) such that sum is N & LCM is minimum","code":"def minDivisior ( n ) : NEW_LINE"}
{"text":"Check if the number is prime","code":"if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT"}
{"text":"Now , if it is not prime then find the least divisior","code":"else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Check if divides n then it is a factor","code":"if ( n % i == 0 ) : NEW_LINE"}
{"text":"Required output is a = n \/ i & b = n \/ i * ( n - 1 )","code":"print ( n \/\/ i , n \/\/ i * ( i - 1 ) ) NEW_LINE break NEW_LINE"}
{"text":"Driver Code","code":"N = 4 NEW_LINE"}
{"text":"Function call","code":"minDivisior ( N ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"To store Landau 's function of the number","code":"Landau = - sys . maxsize - 1 NEW_LINE"}
{"text":"Function to return gcd of 2 numbers","code":"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT"}
{"text":"Function to return LCM of two numbers","code":"def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/\/ gcd ( a , b ) NEW_LINE DEDENT"}
{"text":"Function to find max lcm value among all representations of n","code":"def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Calculate Landau 's value","code":"Landau = max ( Landau , nth_lcm ) NEW_LINE"}
{"text":"Recursive function to find different ways in which n can be written as sum of atleast one positive integers","code":"def findWays ( arr , i , n ) : NEW_LINE"}
{"text":"Check if sum becomes n , consider this representation","code":"if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT"}
{"text":"Start from previous element in the representation till n","code":"for j in range ( i , n + 1 ) : NEW_LINE"}
{"text":"Include current element from representation","code":"arr . append ( j ) NEW_LINE"}
{"text":"Call function again with reduced sum","code":"findWays ( arr , j , n - j ) NEW_LINE"}
{"text":"Backtrack - remove current element from representation","code":"arr . pop ( ) NEW_LINE"}
{"text":"Function to find the Landau 's function","code":"def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE DEDENT"}
{"text":"Using recurrence find different ways in which n can be written as a sum of atleast one + ve integers","code":"findWays ( arr , 1 , n ) NEW_LINE"}
{"text":"Print the result","code":"print ( Landau ) NEW_LINE"}
{"text":"Given N","code":"N = 4 NEW_LINE"}
{"text":"Function call","code":"Landau_function ( N ) NEW_LINE"}
{"text":"Function to check if a number holds the condition ( N - 1 ) ! % N = N - 1","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"Number divisible by 2 or 3 are not prime","code":"if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Iterate from 5 and keep checking for prime","code":"i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE"}
{"text":"Function to check the expression for the value N","code":"def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT"}
{"text":"Function to check if array can be split in required K subsets","code":"def checkArray ( n , k , arr ) : NEW_LINE"}
{"text":"Store count of odd numbers","code":"cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Check if element is odd","code":"if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT"}
{"text":"Check if split is possible","code":"if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 program to compute the sum of division of all the possible pairs for the given array","code":"from math import * NEW_LINE"}
{"text":"Function to compute the sum","code":"def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE DEDENT"}
{"text":"Counting frequency of each term and finding maximum among it","code":"for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT"}
{"text":"Making cumulative frequency","code":"for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE DEDENT DEDENT"}
{"text":"Taking the ceil value","code":"cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE DEDENT"}
{"text":"nos . in [ ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans","code":"ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE"}
{"text":"Return the final result","code":"return int ( ans ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array","code":"def insert_element ( a , n ) : NEW_LINE"}
{"text":"Variable to store the Xor of all the elements","code":"Xor = 0 NEW_LINE"}
{"text":"Variable to store the sum of all elements","code":"Sum = 0 NEW_LINE"}
{"text":"Loop to find the Xor and the sum of the array","code":"for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT"}
{"text":"If sum = 2 * Xor","code":"if ( Sum == 2 * Xor ) : NEW_LINE"}
{"text":"No need to insert more elements","code":"print ( 0 ) NEW_LINE return NEW_LINE"}
{"text":"We insert one more element which is Sum","code":"if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"We insert two more elements Sum + Xor and Xor .","code":"num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE"}
{"text":"Print the number of elements inserted in the array","code":"print ( 2 ) NEW_LINE"}
{"text":"Print the elements that are inserted in the array","code":"print ( num1 , num2 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT"}
{"text":"Function to check if the roots of a quadratic equation are reciprocal of each other or not","code":"def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from math import * NEW_LINE"}
{"text":"Function check whether x is a perfect square or not","code":"def isPerfectSquare ( x ) : NEW_LINE"}
{"text":"Find floating point value of square root of x .","code":"sr = sqrt ( x ) NEW_LINE"}
{"text":"If square root is an integer","code":"return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE"}
{"text":"Function to check Sunny Number","code":"def checkSunnyNumber ( N ) : NEW_LINE"}
{"text":"Check if ( N + 1 ) is a perfect square or not","code":"if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"}
{"text":"If ( N + 1 ) is not a perfect square","code":"else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Number","code":"N = 8 NEW_LINE"}
{"text":"Function call","code":"checkSunnyNumber ( N ) NEW_LINE"}
{"text":"Function to count the numbers which can convert N to 1 using the given operation","code":"def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT"}
{"text":"Iterate through all the integers","code":"for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE DEDENT"}
{"text":"Check if N can be converted to 1","code":"while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k \/\/= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT"}
{"text":"Incrementing the count if it can be converted","code":"if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT return answer NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT"}
{"text":"Function that prints the required K numbers","code":"def printKNumbers ( N , K ) : NEW_LINE"}
{"text":"Print 1 , K - 1 times","code":"for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"text":"Print ( N - K + 1 )","code":"print ( N - K + 1 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT"}
{"text":"Function to find the Nth stepping natural number","code":"def NthSmallest ( K ) : NEW_LINE"}
{"text":"Declare the queue","code":"Q = [ ] NEW_LINE"}
{"text":"Enqueue 1 , 2 , ... , 9 in this order","code":"for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT"}
{"text":"Perform K operation on queue","code":"for i in range ( 1 , K + 1 ) : NEW_LINE"}
{"text":"Get the ith Stepping number","code":"x = Q [ 0 ] NEW_LINE"}
{"text":"Perform Dequeue from the Queue","code":"Q . remove ( Q [ 0 ] ) NEW_LINE"}
{"text":"If x mod 10 is not equal to 0","code":"if ( x % 10 != 0 ) : NEW_LINE"}
{"text":"then Enqueue 10 x + ( x mod 10 ) - 1","code":"Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE"}
{"text":"Enqueue 10 x + ( x mod 10 )","code":"Q . append ( x * 10 + x % 10 ) NEW_LINE"}
{"text":"If x mod 10 is not equal to 9","code":"if ( x % 10 != 9 ) : NEW_LINE"}
{"text":"then Enqueue 10 x + ( x mod 10 ) + 1","code":"Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE"}
{"text":"Return the dequeued number of the K - th operation as the Nth stepping number","code":"return x NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"initialise K","code":"N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"from math import sqrt NEW_LINE"}
{"text":"Function to return the Least number","code":"def nearest ( n ) : NEW_LINE"}
{"text":"Get the perfect square before and after N","code":"prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE"}
{"text":"Check which is nearest to N","code":"ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE"}
{"text":"return the result","code":"return ans ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 program to calculate the value of pi up to n decimal places","code":"from math import acos NEW_LINE"}
{"text":"Function that prints the value of pi upto N decimal places","code":"def printValueOfPi ( N ) : NEW_LINE"}
{"text":"Find value of pi upto using acos ( ) function","code":"b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE"}
{"text":"Print value of pi upto N decimal places","code":"print ( pi ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 43 ; NEW_LINE DEDENT"}
{"text":"Function that prints the value of pi","code":"printValueOfPi ( N ) ; NEW_LINE"}
{"text":"Python implementation of the approach","code":"import math NEW_LINE"}
{"text":"Function to convert decimal number n to its binary representation stored as an array arr [ ]","code":"def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT DEDENT"}
{"text":"Function to convert the number represented as a binary array arr [ ] its decimal equivalent","code":"def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"}
{"text":"Function to concatenate the binary numbers and return the decimal result","code":"def getNum ( n , k ) : NEW_LINE"}
{"text":"Number of bits in both the numbers","code":"l = int ( math . log2 ( n ) ) + 1 NEW_LINE"}
{"text":"Convert the bits in both the gers to the arrays a [ ] and b [ ]","code":"a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE"}
{"text":"The number of bits in n are less than k","code":"if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT"}
{"text":"Flip the kth bit","code":"if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT"}
{"text":"Return the decimal equivalent of the number","code":"return binaryDec ( a , l ) NEW_LINE"}
{"text":"Driver code","code":"n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE"}
{"text":"Declare result array globally","code":"result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE"}
{"text":"Function to precompute the product of factorials upto MAX","code":"def preCompute ( ) : NEW_LINE"}
{"text":"Initialize base condition if n = 0 then factorial of 0 is equal to 1 and answer for n = 0 is 1","code":"fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE"}
{"text":"Iterate loop from 1 to MAX","code":"for i in range ( 1 , MAX + 1 ) : NEW_LINE"}
{"text":"factorial ( i ) = factorial ( i - 1 ) * i","code":"fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE"}
{"text":"Result for current n is equal to result [ i - 1 ] multiplied by the factorial of i","code":"result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE"}
{"text":"Function to perform the queries","code":"def performQueries ( q , n ) : NEW_LINE"}
{"text":"Precomputing the result tiMAX","code":"preCompute ( ) NEW_LINE"}
{"text":"Perform queries","code":"for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE"}
{"text":"Python3 program to find nth term divisible by a , b or c","code":"import sys NEW_LINE"}
{"text":"Function to return gcd of a and b","code":"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT"}
{"text":"Function to return the count of integers from the range [ 1 , num ] which are divisible by either a , b or c","code":"def divTermCount ( a , b , c , num ) : NEW_LINE"}
{"text":"Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c","code":"return ( ( num \/ a ) + ( num \/ b ) + ( num \/ c ) - ( num \/ ( ( a * b ) \/ gcd ( a , b ) ) ) - ( num \/ ( ( c * b ) \/ gcd ( c , b ) ) ) - ( num \/ ( ( a * c ) \/ gcd ( a , c ) ) ) + ( num \/ ( ( a * b * c ) \/ gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE"}
{"text":"Function for binary search to find the nth term divisible by a , b or c","code":"def findNthTerm ( a , b , c , n ) : NEW_LINE"}
{"text":"Set low to 1 and high to LONG_MAX","code":"low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) \/ 2 ; NEW_LINE DEDENT"}
{"text":"If the current term is less than n then we need to increase low to mid + 1","code":"if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT"}
{"text":"If current term is greater than equal to n then high = mid","code":"else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT return int ( low ) ; NEW_LINE"}
{"text":"Driver code","code":"a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE"}
{"text":"Function that checks whether given angle can be created using any 3 sides","code":"def calculate_angle ( n , i , j , k ) : NEW_LINE"}
{"text":"Initialize x and y","code":"x , y = 0 , 0 NEW_LINE"}
{"text":"Calculate the number of vertices between i and j , j and k","code":"if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT"}
{"text":"Calculate the angle subtended at the circumference","code":"ang1 = ( 180 * x ) \/\/ n NEW_LINE ang2 = ( 180 * y ) \/\/ n NEW_LINE"}
{"text":"Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees","code":"ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE"}
{"text":"Driver code","code":"n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE"}
{"text":"Function that will find loss","code":"def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) \/ ( 100 * 100 - P * P ) ) NEW_LINE print ( \" Loss \u2581 = \" , round ( loss , 3 ) ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE DEDENT"}
{"text":"Calling Function","code":"Loss ( SP , P ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"MAXN = 1000001 NEW_LINE"}
{"text":"Stores smallest prime factor for every number","code":"spf = [ i for i in range ( MAXN ) ] NEW_LINE"}
{"text":"Hash to store prime factors count","code":"hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE"}
{"text":"Function to calculate SPF ( SmallestPrime Factor ) for every number till MAXN","code":"def sieve ( ) : NEW_LINE"}
{"text":"Separately marking spf for every even number as 2","code":"for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT"}
{"text":"Checking if i is prime","code":"for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"text":"Marking SPF for all numbers divisible by i","code":"if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE DEDENT"}
{"text":"Marking spf [ j ] if it is not previously marked","code":"if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT"}
{"text":"Function to store the prime factors after dividing by the smallest prime factor at every step","code":"def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE DEDENT DEDENT"}
{"text":"Storing the count of prime factors in hash","code":"hash1 [ spf [ x ] ] += 1 NEW_LINE x = x \/\/ spf [ x ] NEW_LINE while ( x % temp == 0 ) : NEW_LINE x = x \/\/ temp NEW_LINE"}
{"text":"Function that returns true if there are no common prime factors between x and other numbers of the array","code":"def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE DEDENT DEDENT"}
{"text":"Checking whether it common prime factor with other numbers","code":"if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x \/\/ temp NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Function that returns true if there is an element in the array which is coprime with all the other elements of the array","code":"def hasValidNum ( arr , n ) : NEW_LINE"}
{"text":"Using sieve for generating prime factors","code":"sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT"}
{"text":"Checking the common prime factors with other numbers","code":"for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE"}
{"text":"Driver code","code":"arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph","code":"def countWays ( N ) : NEW_LINE"}
{"text":"Total number of edges","code":"E = ( N * ( N - 1 ) ) \/ 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT"}
{"text":"Initialize the matrix with 0","code":"l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE"}
{"text":"0 C0 = 1","code":"l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE"}
{"text":"Set every nCr = 1 where r = 0","code":"l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE"}
{"text":"Value for the current cell of Pascal 's triangle","code":"l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE"}
{"text":"Function to return the value of nCr","code":"def nCr ( n , r ) : NEW_LINE"}
{"text":"Return nCr","code":"return l [ n ] [ r ] NEW_LINE"}
{"text":"Build the Pascal 's triangle","code":"initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE"}
{"text":"Function to return the minimum required absolute difference","code":"def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT"}
{"text":"Python implementation of the above approach","code":"def check ( s ) : NEW_LINE"}
{"text":"creating a frequency array","code":"freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE"}
{"text":"Finding the last digit of the number","code":"r = s % 10 NEW_LINE"}
{"text":"Dividing the number by 10 to eliminate last digit","code":"s = s \/\/ 10 NEW_LINE"}
{"text":"counting frequency of each digit","code":"freq [ r ] += 1 NEW_LINE xor = 0 NEW_LINE"}
{"text":"checking if the xor of all frequency is zero or not","code":"for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to print N lines","code":"def printLines ( n , k ) : NEW_LINE"}
{"text":"Iterate N times to print N lines","code":"for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT"}
{"text":"Python program to find sum of n terms of the series","code":"def calculateSum ( n ) : NEW_LINE"}
{"text":"Sn = n * ( 4 * n * n + 6 * n - 1 ) \/ 3","code":"return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE"}
{"text":"number of terms for the sum","code":"n = 4 NEW_LINE"}
{"text":"find the Sn","code":"print ( \" Sum \u2581 = \" , calculateSum ( n ) ) NEW_LINE"}
{"text":"Python3 program to count the number of special strings of a given length N","code":"mod = 1000000007 NEW_LINE"}
{"text":"Function to return count of special strings","code":"def count_special ( n ) : NEW_LINE"}
{"text":"Stores the answer for a particular value of n","code":"fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE"}
{"text":"For n = 0 we have empty string","code":"fib [ 0 ] = 1 NEW_LINE"}
{"text":"For n = 1 we have 2 special strings","code":"fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE"}
{"text":"Calculate count of special string of length i","code":"fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE"}
{"text":"fib [ n ] stores the count of special strings of length n","code":"return fib [ n ] NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Initialise n","code":"n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE"}
{"text":"Python3 implementation of the above approach","code":"mod = 1e9 + 7 ; NEW_LINE"}
{"text":"Find the number of ways to reach the end","code":"def ways ( i , arr , n ) : NEW_LINE"}
{"text":"Base case","code":"if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE"}
{"text":"Recursive structure","code":"for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 implementation of above approach","code":"mod = 10 ** 9 + 7 NEW_LINE"}
{"text":"find the number of ways to reach the end","code":"def ways ( arr , n ) : NEW_LINE"}
{"text":"dp to store value","code":"dp = [ 0 ] * ( n + 1 ) NEW_LINE"}
{"text":"base case","code":"dp [ n - 1 ] = 1 NEW_LINE"}
{"text":"Bottom up dp structure","code":"for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE DEDENT"}
{"text":"F [ i ] is dependent of F [ i + 1 ] to F [ i + k ]","code":"j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT"}
{"text":"Return value of dp [ 0 ]","code":"return dp [ 0 ] % mod NEW_LINE"}
{"text":"Driver code","code":"arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE"}
{"text":"Returns the count of odd and even subsequences","code":"def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT"}
{"text":"Initialising count_even and count_odd to 0 since as there is no subsequence before the iteration with even or odd count .","code":"count_odd = 0 NEW_LINE count_even = 0 NEW_LINE"}
{"text":"Find sum of all subsequences with even count and odd count and storing them as we iterate .","code":"for i in range ( 1 , n + 1 ) : NEW_LINE"}
{"text":"if the number is even","code":"if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT"}
{"text":"if the number is odd","code":"else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT return ( count_even , count_odd ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE"}
{"text":"Calling the function","code":"count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum \u2581 = \u2581 \" , count_even , \" \u2581 OddSum \u2581 = \u2581 \" , count_odd ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"MAX = 10 NEW_LINE"}
{"text":"Function to convert a number into vector","code":"def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE DEDENT"}
{"text":"Push all the digits of N from the end one by one to the vector","code":"while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N \/\/ 10 NEW_LINE DEDENT"}
{"text":"If the original number was 0","code":"if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT"}
{"text":"Reverse the vector elements","code":"digit = digit [ : : - 1 ] NEW_LINE"}
{"text":"Return the required vector","code":"return digit NEW_LINE"}
{"text":"Function to return the count of B length integers which are less than C and they contain digits from set A [ ] only","code":"def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE DEDENT"}
{"text":"Convert number to digit array","code":"digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE"}
{"text":"Case 1 : No such number possible as the generated numbers will always be greater than C","code":"if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Case 2 : All integers of length B are valid as they all are less than C","code":"elif ( B < len ( digit ) ) : NEW_LINE"}
{"text":"contain 0","code":"if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT"}
{"text":"Case 3","code":"else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE DEDENT"}
{"text":"Update the lower [ ] array such that lower [ i ] stores the count of elements in A [ ] which are less than i","code":"for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE DEDENT"}
{"text":"For first index we can 't use 0","code":"if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT"}
{"text":"Whether ( i - 1 ) digit of generated number can be equal to ( i - 1 ) digit of C","code":"if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT"}
{"text":"Is digit [ i - 1 ] present in A ?","code":"flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE return dp [ B ] NEW_LINE"}
{"text":"Driver code","code":"A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE"}
{"text":"Python 3 program to count the number of paths with weight W in a K - ary tree","code":"import numpy as np NEW_LINE"}
{"text":"Function to return the number of ways having weight as wt in K - ary tree","code":"def solve ( dp , wt , K , M , used ) : NEW_LINE"}
{"text":"Return 0 if weight becomes less than zero","code":"if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE"}
{"text":"Return one only if the current path has included edge weight of atleast M","code":"if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE return dp [ wt ] [ used ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE"}
{"text":"If the current edge weight is greater than or equal to M , set used as true","code":"if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT"}
{"text":"Function to find the number of partitions of N","code":"def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT"}
{"text":"Base case","code":"p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) \/ 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) \/\/ 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to find longest increasing path in a matrix .","code":"MAX = 20 NEW_LINE"}
{"text":"Return the length of LIP in 2D matrix","code":"def LIP ( dp , mat , n , m , x , y ) : NEW_LINE"}
{"text":"If value not calculated yet .","code":"if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT"}
{"text":"If reach bottom left cell , return 1.","code":"if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT"}
{"text":"If reach the corner of the matrix .","code":"if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT"}
{"text":"If value greater than below cell .","code":"if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT"}
{"text":"If value greater than left cell .","code":"if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE return dp [ x ] [ y ] NEW_LINE"}
{"text":"Wrapper function","code":"def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE"}
{"text":"Recursive function to count number of paths","code":"def countPaths ( n , m ) : NEW_LINE"}
{"text":"If we reach bottom or top left , we are have only one way to reach ( 0 , 0 )","code":"if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Else count sum of both ways","code":"return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE"}
{"text":"Driver Code","code":"n = 3 NEW_LINE m = 2 NEW_LINE print ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" , countPaths ( n , m ) ) NEW_LINE"}
{"text":"Python program to solve Gold Mine problem","code":"MAX = 100 NEW_LINE"}
{"text":"Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down","code":"def getMaxGold ( gold , m , n ) : NEW_LINE"}
{"text":"Create a table for storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row","code":"goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE DEDENT"}
{"text":"Gold collected on going to the cell on the right ( -> )","code":"if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT"}
{"text":"Gold collected on going to the cell to right up ( \/ )","code":"if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT"}
{"text":"Gold collected on going to the cell to right down ( \\ )","code":"if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT"}
{"text":"Max gold collected from taking either of the above 3 paths","code":"goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE"}
{"text":"The max amount of gold collected will be the max value in first column of all rows","code":"res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Driver code","code":"gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE"}
{"text":"Python3 program to find minimum adjustment cost of an array","code":"M = 100 NEW_LINE"}
{"text":"Function to find minimum adjustment cost of an array","code":"def minAdjustmentCost ( A , n , target ) : NEW_LINE"}
{"text":"dp [ i ] [ j ] stores minimal adjustment cost on changing A [ i ] to j","code":"dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE"}
{"text":"handle first element of array separately","code":"for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT"}
{"text":"do for rest elements of the array","code":"for i in range ( 1 , n ) : NEW_LINE"}
{"text":"replace A [ i ] to j and calculate minimal adjustment cost dp [ i ] [ j ]","code":"for j in range ( M + 1 ) : NEW_LINE"}
{"text":"initialize minimal adjustment cost to INT_MAX","code":"dp [ i ] [ j ] = 100000000 NEW_LINE"}
{"text":"consider all k such that k >= max ( j - target , 0 ) and k <= min ( M , j + target ) and take minimum","code":"for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT"}
{"text":"return minimum value from last row of dp table","code":"res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( \" Minimum \u2581 adjustment \u2581 cost \u2581 is \" , minAdjustmentCost ( arr , n , target ) , sep = ' \u2581 ' ) NEW_LINE"}
{"text":"Function to find the number of triplets from the range [ L , R ] having sum of two numbers from the triplet equal to the third number","code":"def totalCombination ( L , R ) : NEW_LINE"}
{"text":"Stores the total number of triplets","code":"count = 0 NEW_LINE"}
{"text":"Find the difference of the range","code":"K = R - L NEW_LINE"}
{"text":"Case 1 : If triplets can 't  be formed, then return 0","code":"if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Otherwise","code":"ans = K - L NEW_LINE"}
{"text":"Update the total number of triplets","code":"count = ( ( ans + 1 ) * ( ans + 2 ) ) \/\/ 2 NEW_LINE"}
{"text":"Return the count","code":"return count NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT"}
{"text":"Function to generate two arrays satisfying the given conditions","code":"def printArrays ( n ) : NEW_LINE"}
{"text":"Declare the two arrays A and B","code":"A , B = [ ] , [ ] ; NEW_LINE"}
{"text":"Iterate from range [ 1 , 2 * n ]","code":"for i in range ( 1 , 2 * n + 1 ) : NEW_LINE"}
{"text":"Assign consecutive numbers to same indices of the two arrays","code":"if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT"}
{"text":"Print the first array","code":"print ( \" { \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \u2581 \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT print ( \" } \" ) ; NEW_LINE"}
{"text":"Print the second array , B","code":"print ( \" { \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \" , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT print ( \" \u2581 } \" , end = \" \" ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE DEDENT"}
{"text":"Function Call","code":"printArrays ( N ) ; NEW_LINE"}
{"text":"Function to flip bits of A and B which are set in both of them","code":"def flipBitsOfAandB ( A , B ) : NEW_LINE"}
{"text":"Iterate all possible bits of A and B","code":"for i in range ( 0 , 32 ) : NEW_LINE"}
{"text":"If ith bit is set in both A and B","code":"if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE"}
{"text":"Clear i - th bit of A","code":"A = A ^ ( 1 << i ) NEW_LINE"}
{"text":"Clear i - th bit of B","code":"B = B ^ ( 1 << i ) NEW_LINE"}
{"text":"Print A and B","code":"print ( A , B ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT"}
{"text":"Function to find the distinct sums","code":"def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE"}
{"text":"Function to count the number of substrings consists of 0 , 1 , and 2","code":"def countSubstrings ( str ) : NEW_LINE"}
{"text":"Initialize frequency array of size 3","code":"freq = [ 0 ] * 3 NEW_LINE"}
{"text":"Stores the resultant count","code":"count = 0 NEW_LINE i = 0 NEW_LINE"}
{"text":"Traversing string str","code":"for j in range ( 0 , len ( str ) ) : NEW_LINE"}
{"text":"Update frequency array","code":"freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE"}
{"text":"If all the characters are present counting number of substrings possible","code":"while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT"}
{"text":"Update number of substrings","code":"count += i NEW_LINE"}
{"text":"Return the number of substrings","code":"return count NEW_LINE"}
{"text":"Driver Code","code":"str = \"00021\" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE"}
{"text":"Function to find the minimum number of flips to make all three pairs of consecutive characters different","code":"def minFlips ( st ) : NEW_LINE"}
{"text":"Stores resultant count of pairs","code":"count = 0 NEW_LINE"}
{"text":"Base Case","code":"if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Iterate over the range [ 0 , N - 2 ]","code":"for i in range ( len ( st ) - 2 ) : NEW_LINE"}
{"text":"If the consecutive 3 numbers are the same then increment the count and the counter","code":"if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT"}
{"text":"Return the answer","code":"return count NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"0011101\" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT"}
{"text":"Function to convert Decimal to Hex","code":"def convertToHex ( num ) : NEW_LINE INDENT temp = \" \" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num \/\/ 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT"}
{"text":"Function to encrypt the string","code":"def encryptString ( S , N ) : NEW_LINE INDENT ans = \" \" NEW_LINE DEDENT"}
{"text":"Iterate the characters of the string","code":"for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE DEDENT"}
{"text":"Iterate until S [ i ] is equal to ch","code":"while ( i < N and S [ i ] == ch ) : NEW_LINE"}
{"text":"Update count and i","code":"count += 1 NEW_LINE i += 1 NEW_LINE"}
{"text":"Decrement i by 1","code":"i -= 1 NEW_LINE"}
{"text":"Convert count to hexadecimal representation","code":"hex = convertToHex ( count ) NEW_LINE"}
{"text":"Append the character","code":"ans += ch NEW_LINE"}
{"text":"Append the characters frequency in hexadecimal representation","code":"ans += hex NEW_LINE"}
{"text":"Reverse the obtained answer","code":"ans = ans [ : : - 1 ] NEW_LINE"}
{"text":"Return required answer","code":"return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Input","code":"S = \" abc \" NEW_LINE N = len ( S ) NEW_LINE"}
{"text":"Function Call","code":"print ( encryptString ( S , N ) ) NEW_LINE"}
{"text":"Function to calculate and return the value of Binomial Coefficient C ( n , k )","code":"def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT"}
{"text":"Since C ( n , k ) = C ( n , n - k )","code":"if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT"}
{"text":"Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ]","code":"for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Function to return the count of binary strings of length N such that frequency of 1 ' s \u2581 exceed \u2581 that \u2581 of \u2581 0' s","code":"def countOfString ( N ) : NEW_LINE"}
{"text":"Count of N - length binary strings","code":"Stotal = pow ( 2 , N ) NEW_LINE"}
{"text":"Count of N - length binary strings having equal count of 0 ' s \u2581 and \u2581 1' s","code":"Sequal = 0 NEW_LINE"}
{"text":"For even length strings","code":"if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N \/\/ 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) \/\/ 2 NEW_LINE return S1 NEW_LINE"}
{"text":"Driver Code","code":"N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE"}
{"text":"Function to remove all occurrences of a character in the string","code":"def removeCharRecursive ( str , X ) : NEW_LINE"}
{"text":"Base Case","code":"if ( len ( str ) == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT"}
{"text":"Check the first character of the given string","code":"if ( str [ 0 ] == X ) : NEW_LINE"}
{"text":"Pass the rest of the string to recursion Function call","code":"return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE"}
{"text":"Add the first character of str and string from recursion","code":"return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE"}
{"text":"Given String","code":"str = \" geeksforgeeks \" NEW_LINE"}
{"text":"Given character","code":"X = ' e ' NEW_LINE"}
{"text":"Function call","code":"str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE"}
{"text":"Function checks whether given time is correct","code":"def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE DEDENT"}
{"text":"To check minute value of time","code":"if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE"}
{"text":"To check hour value of time","code":"v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE"}
{"text":"Changes in value is not allowed at position where ' ? ' is not present","code":"if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Function checks whether the absolute difference between hour and minute value is within [ L , R ]","code":"def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE DEDENT"}
{"text":"Checks if the difference is outside the give range","code":"if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Displays time in proper 24 - hour format","code":"def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = \" : \" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( \"0\" , hh , end = \" : \" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( \"0\" , mm ) NEW_LINE DEDENT DEDENT"}
{"text":"Function find the desired value of time whose difference lies in the range [ L , R ]","code":"def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE DEDENT"}
{"text":"Decrease hour value from 23 to 0","code":"for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i \/\/ 10 NEW_LINE DEDENT"}
{"text":"Check if the hour value is valid if not valid then no need to change minute value , since time will still remain in valid , to check hour value flag is set to 1.","code":"if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"Decrease minute value from 59 to 0","code":"for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j \/\/ 10 NEW_LINE DEDENT"}
{"text":"Check if the minute value is valid , if not valid then skip the current iteration , to check ' minute ' value flag is set to 0.","code":"if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE displayTime ( i , j ) NEW_LINE else : NEW_LINE print ( - 1 ) NEW_LINE"}
{"text":"Input time","code":"timeValue = \" ? ? : ? ? \" NEW_LINE"}
{"text":"Difference range","code":"L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE"}
{"text":"Function to check string str can be split a string into even length palindromic substrings","code":"def check ( s , n ) : NEW_LINE"}
{"text":"Initialize a stack","code":"st = [ ] NEW_LINE"}
{"text":"Iterate the string","code":"for i in range ( n ) : NEW_LINE"}
{"text":"If the i - th character is same as that at the top of the stack then pop the top element","code":"if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT"}
{"text":"Else push the current charactor into the stack","code":"else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT"}
{"text":"If the stack is empty , then even palindromic substrings are possible","code":"if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT"}
{"text":"Else not - possible","code":"else : NEW_LINE INDENT return False ; NEW_LINE DEDENT"}
{"text":"Given string","code":"str = \" aanncddc \" ; NEW_LINE n = len ( str ) NEW_LINE"}
{"text":"Function Call","code":"if ( check ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"from collections import defaultdict NEW_LINE def findNumOfValidWords ( w , p ) : NEW_LINE"}
{"text":"To store the frequency of string after bitmasking","code":"m = defaultdict ( int ) NEW_LINE"}
{"text":"To store result for each string in arr2 [ ]","code":"res = [ ] NEW_LINE"}
{"text":"Traverse the arr1 [ ] and bitmask each string in it","code":"for s in w : NEW_LINE INDENT val = 0 NEW_LINE DEDENT"}
{"text":"Bitmasking for each string s","code":"for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT"}
{"text":"Update the frequency of string with it 's bitmasking value","code":"m [ val ] += 1 NEW_LINE"}
{"text":"Traverse the arr2 [ ]","code":"for s in p : NEW_LINE INDENT val = 0 NEW_LINE DEDENT"}
{"text":"Bitmasking for each string s","code":"for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT temp = val NEW_LINE first = ord ( s [ 0 ] ) - ord ( ' a ' ) NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE"}
{"text":"Check if temp is present in an unordered_map or not","code":"if ( ( ( temp >> first ) & 1 ) == 1 ) : NEW_LINE INDENT if ( temp in m ) : NEW_LINE INDENT count += m [ temp ] NEW_LINE DEDENT DEDENT"}
{"text":"Check for next set bit","code":"temp = ( temp - 1 ) & val NEW_LINE"}
{"text":"Push the count for current string in resultant array","code":"res . append ( count ) NEW_LINE"}
{"text":"Print the count for each string","code":"for it in res : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ \" aaaa \" , \" asas \" , \" able \" , \" ability \" , \" actt \" , \" actor \" , \" access \" ] NEW_LINE arr2 = [ \" aboveyz \" , \" abrodyz \" , \" absolute \" , \" absoryz \" , \" actresz \" , \" gaswxyz \" ] NEW_LINE DEDENT"}
{"text":"Function call","code":"findNumOfValidWords ( arr1 , arr2 ) NEW_LINE"}
{"text":"Function to print the binary number","code":"def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE DEDENT"}
{"text":"Check if the current number is 0","code":"if ( s [ i ] == '0' ) : NEW_LINE"}
{"text":"Find the continuous 0 s","code":"while ( s [ i ] == '0' ) : NEW_LINE"}
{"text":"Replace initially occurring 0 with 1","code":"s [ i ] = '1' NEW_LINE i += 1 NEW_LINE s = ' ' . join ( map ( str , s ) ) NEW_LINE"}
{"text":"return the string and break the loop","code":"return s NEW_LINE"}
{"text":"Driver code","code":"s = \"100010001\" NEW_LINE print ( flip ( s ) ) NEW_LINE"}
{"text":"Function to return the original string after converting it back from camelCase","code":"def getOrgString ( s ) : NEW_LINE"}
{"text":"Print the first character as it is","code":"print ( s [ 0 ] , end = \" \" ) NEW_LINE"}
{"text":"Traverse the rest of the characters one by one","code":"i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE"}
{"text":"If current character is uppercase prspace followed by the current character in lowercase","code":"if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( \" \u2581 \" , s [ i ] . lower ( ) , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Else print the current character","code":"else : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"Driver code","code":"s = \" ILoveGeeksForGeeks \" NEW_LINE getOrgString ( s ) NEW_LINE"}
{"text":"Function to count the character 'a","code":"' NEW_LINE def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE DEDENT"}
{"text":"atleast k repetition are required","code":"repetitions = n \/\/ len ( str ) NEW_LINE count = count * repetitions NEW_LINE"}
{"text":"if n is not the multiple of the string size check for the remaining repeating character .","code":"l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE"}
{"text":"Driver code","code":"str = \" abcac \" NEW_LINE print ( countChar ( str , ' a ' ) ) NEW_LINE"}
{"text":"Python3 program to count frequencies of array items having small values .","code":"def countFreq ( arr , n , limit ) : NEW_LINE"}
{"text":"Create an array to store counts . The size of array is limit + 1 and all values are initially 0","code":"count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE"}
{"text":"Traverse through array elements and count frequencies ( assuming that elements are limited by limit )","code":"for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 10 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE"}
{"text":"Function that checks if the binary string contains m consecutive 1 ' s \u2581 or \u2581 0' s","code":"def check ( s , m ) : NEW_LINE"}
{"text":"length of binary string","code":"l = len ( s ) ; NEW_LINE"}
{"text":"counts zeros","code":"c1 = 0 ; NEW_LINE"}
{"text":"counts 1 's","code":"c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE DEDENT DEDENT"}
{"text":"count consecutive 0 's","code":"c1 = c1 + 1 ; NEW_LINE else : NEW_LINE c1 = 0 ; NEW_LINE"}
{"text":"count consecutive 1 's","code":"c2 = c2 + 1 ; NEW_LINE if ( c1 == m or c2 == m ) : NEW_LINE return True ; NEW_LINE return False ; NEW_LINE"}
{"text":"Driver Code","code":"s = \"001001\" ; NEW_LINE m = 2 ; NEW_LINE"}
{"text":"function call","code":"if ( check ( s , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"text":"Function to find product of digits of elements at k - th level","code":"def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE DEDENT"}
{"text":"Initialize result","code":"product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE"}
{"text":"increasing level number","code":"if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT"}
{"text":"decreasing level number","code":"elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE"}
{"text":"check if current level is the desired level or not","code":"if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT"}
{"text":"required product","code":"return product NEW_LINE"}
{"text":"Driver program","code":"tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" NEW_LINE k = 2 NEW_LINE print ( productAtKthLevel ( tree , k ) ) NEW_LINE"}
{"text":"Function to check duplicates in row and column","code":"def findDuplicates ( a , n , m ) : NEW_LINE"}
{"text":"Create an array isPresent and initialize all entries of it as false . The value of isPresent [ i ] [ j ] is going to be true if s [ i ] [ j ] is present in its row or column .","code":"isPresent = [ [ False for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT"}
{"text":"Checking every row for duplicates of a [ i ] [ j ]","code":"for k in range ( n ) : NEW_LINE INDENT if i != k and a [ i ] [ j ] == a [ k ] [ j ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT"}
{"text":"Checking every row for duplicates of a [ i ] [ j ]","code":"for k in range ( m ) : NEW_LINE INDENT if j != k and a [ i ] [ j ] == a [ i ] [ k ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE for j in range ( m ) : NEW_LINE"}
{"text":"If the character is unique in its row and column","code":"if not isPresent [ i ] [ j ] : NEW_LINE INDENT print ( a [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE DEDENT"}
{"text":"character array","code":"a = [ \" zx \" , \" xz \" ] NEW_LINE"}
{"text":"Calling function","code":"findDuplicates ( a , n , m ) NEW_LINE"}
{"text":"Python code to check if a given ISBN is valid or not .","code":"def isValidISBN ( isbn ) : NEW_LINE"}
{"text":"check for length","code":"if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Computing weighted sum of first 9 digits","code":"_sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Checking last digit","code":"if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"If last digit is ' X ' , add 10 to sum , else add its value .","code":"_sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE"}
{"text":"Return true if weighted sum of digits is divisible by 11","code":"return ( _sum % 11 == 0 ) NEW_LINE"}
{"text":"Driver Code","code":"isbn = \"007462542X \" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT"}
{"text":"utility function to check for vowel","code":"def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT"}
{"text":"Function to reverse order of vowels","code":"def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE DEDENT"}
{"text":"Storing the vowels separately","code":"for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Placing the vowels in the reverse order in the string","code":"for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello \u2581 world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT"}
{"text":"Function to find string which has first character of each word .","code":"def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE DEDENT"}
{"text":"Traverse the string .","code":"v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE"}
{"text":"If it is space , set v as true .","code":"if ( str [ i ] == ' \u2581 ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT"}
{"text":"Else check if v is true or not . If true , copy character in output string and set v as false .","code":"elif ( str [ i ] != ' \u2581 ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT return result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks \u2581 for \u2581 geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"}
{"text":"Function for dfs . i , j == > Current cell indexes vis == > To mark visited cells ans == > Result z == > Current count 0 s visited z_count == > Total 0 s present","code":"def dfs ( i , j , grid , vis , ans , z , z_count ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE DEDENT"}
{"text":"Mark the block as visited","code":"vis [ i ] [ j ] = 1 NEW_LINE if ( grid [ i ] [ j ] == 0 ) : NEW_LINE"}
{"text":"Update the count","code":"z += 1 NEW_LINE"}
{"text":"If end block reached","code":"if ( grid [ i ] [ j ] == 2 ) : NEW_LINE"}
{"text":"If path covered all the non - obstacle blocks","code":"if ( z == z_count ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE"}
{"text":"Up","code":"if ( i >= 1 and not vis [ i - 1 ] [ j ] and grid [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i - 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT"}
{"text":"Down","code":"if ( i < n - 1 and not vis [ i + 1 ] [ j ] and grid [ i + 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i + 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT"}
{"text":"Left","code":"if ( j >= 1 and not vis [ i ] [ j - 1 ] and grid [ i ] [ j - 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j - 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT"}
{"text":"Right","code":"if ( j < m - 1 and not vis [ i ] [ j + 1 ] and grid [ i ] [ j + 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j + 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT"}
{"text":"Unmark the block ( unvisited )","code":"vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE"}
{"text":"Function to return the count of the unique paths","code":"def uniquePaths ( grid ) : NEW_LINE"}
{"text":"Total 0 s present","code":"z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT"}
{"text":"Count non - obstacle blocks","code":"if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE"}
{"text":"Starting position","code":"x = i NEW_LINE y = j NEW_LINE grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] NEW_LINE print ( uniquePaths ( grid ) ) NEW_LINE DEDENT"}
{"text":"Return the number of unordered pairs satisfying the conditions","code":"def numPairs ( a , n ) : NEW_LINE"}
{"text":"ans stores the number of unordered pairs","code":"ans = 0 NEW_LINE"}
{"text":"Making each value of array to positive","code":"for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT"}
{"text":"Sort the array","code":"a . sort ( ) NEW_LINE"}
{"text":"For each index calculating the right boundary for the unordered pairs","code":"for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT"}
{"text":"Return the final result","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"a = [ 3 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( numPairs ( a , n ) ) NEW_LINE"}
{"text":"Function to find the area of a square","code":"def areaOfSquare ( S ) : NEW_LINE"}
{"text":"Use above formula","code":"area = S * S NEW_LINE return area NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Side of square","code":"S = 5 NEW_LINE"}
{"text":"Function call","code":"print ( areaOfSquare ( S ) ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) \/\/ 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT"}
{"text":"Number of circles","code":"x = 3 NEW_LINE"}
{"text":"Number of straight lines","code":"y = 4 NEW_LINE"}
{"text":"Function Call","code":"print ( maxPointOfIntersection ( x , y ) ) NEW_LINE"}
{"text":"Function to find icosihenagonal number","code":"def Icosihenagonal_num ( n ) : NEW_LINE"}
{"text":"Formula to calculate nth icosihenagonal number","code":"return ( 19 * n * n - 17 * n ) \/ 2 NEW_LINE"}
{"text":"Driver Code","code":"n = 3 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE DEDENT"}
{"text":"For all vertices","code":"for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE DEDENT"}
{"text":"Calculate value of A using shoelace formula","code":"A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE"}
{"text":"Calculating coordinates of centroid of polygon","code":"ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) \/ ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) \/ ( 6 * signedArea ) NEW_LINE return ans NEW_LINE"}
{"text":"Coordinate of the vertices","code":"vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( round ( ans [ 0 ] , 12 ) , ans [ 1 ] ) NEW_LINE"}
{"text":"Driver code","code":"d = 10 NEW_LINE a = 0.0 NEW_LINE"}
{"text":"according to formula derived above","code":"a = ( 360 - ( 6 * d ) ) \/ 4 NEW_LINE"}
{"text":"print all the angles","code":"print ( a , \" , \" , a + d , \" , \" , a + 2 * d , \" , \" , a + 3 * d , sep = ' \u2581 ' ) NEW_LINE"}
{"text":"Python program to find the Distance between two parallel Planes in 3 D .","code":"import math NEW_LINE"}
{"text":"Function to find distance","code":"def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 \/ a2 == b1 \/ b2 and b1 \/ b2 == c1 \/ c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 \/ c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) \/ ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( \" Perpendicular \u2581 distance \u2581 is \" ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Planes \u2581 are \u2581 not \u2581 parallel \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"a1 = 1 NEW_LINE b1 = 2 NEW_LINE c1 = - 1 NEW_LINE d1 = 1 NEW_LINE a2 = 3 NEW_LINE b2 = 6 NEW_LINE c2 = - 3 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) NEW_LINE"}
{"text":"Function to calculate factorial","code":"def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT"}
{"text":"Function to count number of ways to make 2 necklace having exactly N \/ 2 beads if each bead is considered different","code":"def numOfNecklace ( N ) : NEW_LINE"}
{"text":"Number of ways to choose N \/ 2 beads from N beads","code":"ans = factorial ( N ) \/\/ ( factorial ( N \/\/ 2 ) * factorial ( N \/\/ 2 ) ) NEW_LINE"}
{"text":"Number of ways to permute N \/ 2 beads","code":"ans = ans * factorial ( N \/\/ 2 - 1 ) NEW_LINE ans = ans * factorial ( N \/\/ 2 - 1 ) NEW_LINE"}
{"text":"Divide ans by 2 to remove repetitions","code":"ans \/\/= 2 NEW_LINE"}
{"text":"Return ans","code":"return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Input","code":"N = 4 NEW_LINE"}
{"text":"Function Call","code":"print ( numOfNecklace ( N ) ) NEW_LINE"}
{"text":"Function to check if S is divisible by D while changing S to ( S + S % D )","code":"def isDivisibleByDivisor ( S , D ) : NEW_LINE"}
{"text":"V ( 0 ) = S % D","code":"S %= D NEW_LINE"}
{"text":"Stores the encountered values","code":"hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE"}
{"text":"V ( i ) = ( V ( i - 1 ) + V ( i - 1 ) % D ) % D","code":"S += ( S % D ) NEW_LINE S %= D NEW_LINE"}
{"text":"Check if the value has already been encountered","code":"if ( S in hashMap ) : NEW_LINE"}
{"text":"Edge Case","code":"if ( S == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE"}
{"text":"Otherwise , insert it into the hashmap","code":"else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT return \" Yes \" NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 3 NEW_LINE D = 6 NEW_LINE print ( isDivisibleByDivisor ( S , D ) ) NEW_LINE DEDENT"}
{"text":"Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 )","code":"def minimumSteps ( x , y ) : NEW_LINE"}
{"text":"Store the required result","code":"cnt = 0 NEW_LINE"}
{"text":"Iterate while both x and y are not equal to 0","code":"while ( x != 0 and y != 0 ) : NEW_LINE"}
{"text":"If x is greater than y","code":"if ( x > y ) : NEW_LINE"}
{"text":"Update count and value of x","code":"cnt += x \/ y NEW_LINE x %= y NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Update count and value of y","code":"cnt += y \/ x NEW_LINE y %= x NEW_LINE cnt -= 1 NEW_LINE"}
{"text":"If both x and y > 1","code":"if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT"}
{"text":"Print the result","code":"print ( int ( cnt ) ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given X and Y","code":"x = 3 NEW_LINE y = 1 NEW_LINE minimumSteps ( x , y ) NEW_LINE"}
{"text":"Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced .","code":"def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE DEDENT"}
{"text":"length of expression must be even to make it balanced by using reversals .","code":"if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"After this loop , stack contains unbalanced part of expression , i . e . , expression of the form \" . . . . \"","code":"s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Length of the reduced expression red_len = ( m + n )","code":"red_len = len ( s ) NEW_LINE"}
{"text":"count opening brackets at the end of stack","code":"n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT"}
{"text":"return ceil ( m \/ 2 ) + ceil ( n \/ 2 ) which is actually equal to ( m + n ) \/ 2 + n % 2 when m + n is even .","code":"return ( red_len \/\/ 2 + n % 2 ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT expr = \" } } { { \" NEW_LINE print ( countMinReversals ( expr . strip ( ) ) ) NEW_LINE DEDENT"}
{"text":"Prints the minimum number that can be formed from input sequence of I ' s \u2581 and \u2581 D ' s","code":"def PrintMinNumberForPattern ( arr ) : NEW_LINE"}
{"text":"Initialize current_max ( to make sure that we don 't use repeated character","code":"curr_max = 0 NEW_LINE"}
{"text":"Initialize last_entry ( Keeps track for last printed digit )","code":"last_entry = 0 NEW_LINE i = 0 NEW_LINE"}
{"text":"Iterate over input array","code":"while i < len ( arr ) : NEW_LINE"}
{"text":"Initialize ' noOfNextD ' to get count of next D 's available","code":"noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE"}
{"text":"If letter is ' I ' Calculate number of next consecutive D 's  available","code":"j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE DEDENT"}
{"text":"If ' I ' is first letter , print incremented sequence from 1","code":"print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE"}
{"text":"Set max digit reached","code":"last_entry = curr_max NEW_LINE else : NEW_LINE"}
{"text":"If not first letter Get next digit to print","code":"curr_max += noOfNextD + 1 NEW_LINE"}
{"text":"Print digit for I","code":"last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE"}
{"text":"For all next consecutive ' D ' print decremented sequence","code":"for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT"}
{"text":"If letter is 'D","code":"elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE DEDENT"}
{"text":"If ' D ' is first letter in sequence Find number of Next D 's available","code":"j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT"}
{"text":"Calculate first digit to print based on number of consecutive D 's","code":"curr_max = noOfNextD + 2 NEW_LINE"}
{"text":"Print twice for the first time","code":"print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE"}
{"text":"Store last entry","code":"last_entry = curr_max - 1 NEW_LINE else : NEW_LINE"}
{"text":"If current ' D ' is not first letter Decrement last_entry","code":"print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE i += 1 NEW_LINE print ( ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT"}
{"text":"Python3 program to print minimum number that can be formed from a given sequence of Is and Ds","code":"def printLeast ( arr ) : NEW_LINE"}
{"text":"min_avail represents the minimum number which is still available for inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector","code":"min_avail = 1 NEW_LINE pos_of_I = 0 NEW_LINE"}
{"text":"Vector to store the output","code":"v = [ ] NEW_LINE"}
{"text":"Cover the base cases","code":"if ( arr [ 0 ] == ' I ' ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( 2 ) NEW_LINE v . append ( 1 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 0 NEW_LINE DEDENT"}
{"text":"Traverse rest of the input","code":"for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT v . append ( min_avail ) NEW_LINE min_avail += 1 NEW_LINE pos_of_I = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE for j in range ( pos_of_I , i + 1 ) : NEW_LINE INDENT v [ j ] += 1 NEW_LINE DEDENT min_avail += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Print the number","code":"print ( * v , sep = ' \u2581 ' ) NEW_LINE"}
{"text":"Driver code","code":"printLeast ( \" IDID \" ) NEW_LINE printLeast ( \" I \" ) NEW_LINE printLeast ( \" DD \" ) NEW_LINE printLeast ( \" II \" ) NEW_LINE printLeast ( \" DIDI \" ) NEW_LINE printLeast ( \" IIDDD \" ) NEW_LINE printLeast ( \" DDIDDIID \" ) NEW_LINE"}
{"text":"Function to decode the given sequence to construct minimum number without repeated digits","code":"def PrintMinNumberForPattern ( Strr ) : NEW_LINE"}
{"text":"String for storing result","code":"res = ' ' NEW_LINE"}
{"text":"Take a List to work as Stack","code":"stack = [ ] NEW_LINE"}
{"text":"run n + 1 times where n is length of input sequence , As length of result string is always 1 greater","code":"for i in range ( len ( Strr ) + 1 ) : NEW_LINE"}
{"text":"Push number i + 1 into the stack","code":"stack . append ( i + 1 ) NEW_LINE"}
{"text":"If all characters of the input sequence are processed or current character is 'I","code":"if ( i == len ( Strr ) or Strr [ i ] == ' I ' ) : NEW_LINE"}
{"text":"Run While Loop Untill stack is empty","code":"while len ( stack ) > 0 : NEW_LINE"}
{"text":"pop the element on top of stack And store it in result String","code":"res += str ( stack . pop ( ) ) NEW_LINE res += ' \u2581 ' NEW_LINE print ( res ) NEW_LINE"}
{"text":"Driver Code","code":"PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE"}
{"text":"Returns minimum number made from given sequence without repeating digits","code":"def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE DEDENT"}
{"text":"The loop runs for each input character as well as one additional time for assigning rank to remaining characters","code":"for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inputs = [ \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" ] NEW_LINE for Input in inputs : NEW_LINE INDENT print ( * ( getMinNumberForPattern ( Input ) ) ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 implementation of above approach","code":"import math as mt NEW_LINE"}
{"text":"function to check prime","code":"def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n \/\/ 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT"}
{"text":"Function to generate smallest possible number with given digits","code":"def findMinNum ( arr , n ) : NEW_LINE"}
{"text":"Declare a Hash array of size 10 and initialize all the elements to zero","code":"first , last = 0 , 0 NEW_LINE Hash = [ 0 for i in range ( 10 ) ] NEW_LINE"}
{"text":"store the number of occurrences of the digits in the given array into the Hash table","code":"for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"Traverse the Hash in ascending order to print the required number","code":"print ( \" Minimum \u2581 number : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE"}
{"text":"Print the number of times a digits occurs","code":"for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"extracting the first digit","code":"for i in range ( 10 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"extracting the last digit","code":"for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT num = first * 10 + last NEW_LINE rev = last * 10 + first NEW_LINE"}
{"text":"printing the prime combinations","code":"print ( \" Prime \u2581 combinations : \u2581 \" , end = \" \" ) NEW_LINE if ( isPrime ( num ) and isPrime ( rev ) ) : NEW_LINE INDENT print ( num , \" \u2581 \" , rev ) NEW_LINE DEDENT elif ( isPrime ( num ) ) : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT elif ( isPrime ( rev ) ) : NEW_LINE INDENT print ( rev ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 combinations \u2581 exist \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"arr = [ 1 , 2 , 4 , 7 , 8 ] NEW_LINE findMinNum ( arr , 5 ) NEW_LINE"}
{"text":"Function to return gcd of a and b","code":"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT"}
{"text":"function to check for gcd","code":"def coprime ( a , b ) : NEW_LINE"}
{"text":"a and b are coprime if their gcd is 1.","code":"return ( gcd ( a , b ) == 1 ) ; NEW_LINE"}
{"text":"Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt","code":"def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE DEDENT"}
{"text":"Generate and check for all possible triplets between L and R","code":"for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , R + 1 ) : NEW_LINE DEDENT DEDENT"}
{"text":"if we find any such triplets set flag to true","code":"if ( coprime ( a , b ) and coprime ( b , c ) and coprime ( a , c ) == False ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = a ; NEW_LINE possibleB = b ; NEW_LINE possibleC = c ; NEW_LINE break ; NEW_LINE DEDENT"}
{"text":"flag = True indicates that a pair exists between L and R","code":"if ( flag == True ) : NEW_LINE INDENT print ( \" ( \" , possibleA , \" , \" , possibleB , \" , \" , possibleC , \" ) \u2581 is \u2581 one \u2581 such \" , \" possible \u2581 triplet \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Such \u2581 Triplet \u2581 exists \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT"}
{"text":"finding possible Triplet between 2 and 10","code":"L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE"}
{"text":"finding possible Triplet between 23 and 46","code":"L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE"}
{"text":"Python 3 program to determine if A and B can be reached starting from 1 , 1 following the given steps .","code":"import numpy as np NEW_LINE"}
{"text":"function to check is it is possible to reach A and B starting from 1 and 1","code":"def possibleToReach ( a , b ) : NEW_LINE"}
{"text":"find the cuberoot of the number","code":"c = np . cbrt ( a * b ) NEW_LINE"}
{"text":"divide the number by cuberoot","code":"re1 = a \/\/ c NEW_LINE re2 = b \/\/ c NEW_LINE"}
{"text":"if it is a perfect cuberoot and divides a and b","code":"if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 60 NEW_LINE B = 450 NEW_LINE if ( possibleToReach ( A , B ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 program to check whether a number is undulating or not","code":"def isUndulating ( n ) : NEW_LINE"}
{"text":"Considering the definition with restriction that there should be at least 3 digits","code":"if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Check if all alternate digits are same or not .","code":"for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Driver Code","code":"n = \"1212121\" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to calculate the following series","code":"def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 3 NEW_LINE res = Series ( n ) NEW_LINE print ( res ) NEW_LINE"}
{"text":"Efficient python program to count numbers with last digit as k in given range .","code":"import math NEW_LINE"}
{"text":"Returns count of numbers with k as last digit .","code":"def counLastDigitK ( low , high , k ) : NEW_LINE INDENT mlow = 10 * math . ceil ( low \/ 10.0 ) NEW_LINE mhigh = 10 * int ( high \/ 10.0 ) NEW_LINE count = ( mhigh - mlow ) \/ 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 <= k and ( low % 10 ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE"}
{"text":"function to calculate the sum of all numbers divisible by 6 in range L - R . .","code":"sdef sumDivisible ( L , R ) : NEW_LINE"}
{"text":"no of multiples of 6 upto r","code":"p = int ( R \/ 6 ) NEW_LINE"}
{"text":"no of multiples of 6 upto l - 1","code":"q = int ( ( L - 1 ) \/ 6 ) NEW_LINE"}
{"text":"summation of all multiples of 6 upto r","code":"sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE"}
{"text":"summation of all multiples of 6 upto l - 1","code":"sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE"}
{"text":"returns the answer","code":"return sumR - sumL NEW_LINE"}
{"text":"driver code","code":"L = 1 NEW_LINE R = 20 NEW_LINE print ( sumDivisible ( L , R ) ) NEW_LINE"}
{"text":"Python3 program to find the largest smaller number by swapping one digit .","code":"import sys NEW_LINE"}
{"text":"Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s .","code":"def prevNum ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE DEDENT"}
{"text":"Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4.","code":"for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if int ( string [ i ] ) > int ( string [ i + 1 ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr [ index ] which is smaller than arr [ index ]","code":"smallGreatDgt = - 1 NEW_LINE for i in range ( n - 1 , index , - 1 ) : NEW_LINE INDENT if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT DEDENT"}
{"text":"If index is - 1 i . e . digits are in increasing order .","code":"if index == - 1 : NEW_LINE INDENT return \" \" . join ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Swap both values","code":"( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] ) NEW_LINE return \" \" . join ( string ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n_str = \"34125\" NEW_LINE ans = prevNum ( list ( n_str ) , len ( n_str ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"text":"returns value of poly [ 0 ] x ( n - 1 ) + poly [ 1 ] x ( n - 2 ) + . . + poly [ n - 1 ]","code":"def horner ( poly , n , x ) : NEW_LINE"}
{"text":"Initialize result","code":"result = poly [ 0 ] ; NEW_LINE"}
{"text":"Evaluate value of polynomial using Horner 's method","code":"for i in range ( 1 , n ) : NEW_LINE INDENT result = ( result * x + poly [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE"}
{"text":"Returns sign value of polynomial","code":"def findSign ( poly , n , x ) : NEW_LINE INDENT result = horner ( poly , n , x ) ; NEW_LINE if ( result > 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( result < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Let us evaluate value of 2 x3 - 6 x2 + 2 x - 1 for x = 3","code":"poly = [ 2 , - 6 , 2 , - 1 ] ; NEW_LINE x = 3 ; NEW_LINE n = len ( poly ) ; NEW_LINE print ( \" Sign \u2581 of \u2581 polynomial \u2581 is \u2581 \" , findSign ( poly , n , x ) ) ; NEW_LINE"}
{"text":"Python3 program to find minimum number to insert in array so their sum is prime","code":"isPrime = [ 1 ] * 100005 NEW_LINE"}
{"text":"function to calculate prime using sieve of eratosthenes","code":"def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT"}
{"text":"Find prime number greater than a number","code":"def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE DEDENT"}
{"text":"find prime greater than n","code":"while ( num ) : NEW_LINE"}
{"text":"check if num is prime","code":"if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT"}
{"text":"Increment num","code":"num += 1 NEW_LINE return 0 NEW_LINE"}
{"text":"To find number to be added so sum of array is prime","code":"def minNumber ( arr ) : NEW_LINE"}
{"text":"call sieveOfEratostheneses to calculate primes","code":"sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE"}
{"text":"To find sum of array elements","code":"for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT"}
{"text":"If sum is already prime return 0","code":"if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"To find prime number greater than sum","code":"num = findPrime ( s ) NEW_LINE"}
{"text":"Return difference of sum and num","code":"return num - s NEW_LINE"}
{"text":"Driver code","code":"arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE"}
{"text":"Computes sum all sub - array","code":"def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE DEDENT"}
{"text":"Pick starting point","code":"for i in range ( 0 , n ) : NEW_LINE"}
{"text":"Pick ending point","code":"temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE"}
{"text":"sum subarray between current starting and ending points","code":"temp += arr [ j ] NEW_LINE result += temp NEW_LINE return result NEW_LINE"}
{"text":"driver program","code":"arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum \u2581 of \u2581 SubArray \u2581 : \" , SubArraySum ( arr , n ) ) NEW_LINE"}
{"text":"Python3 program to find highest power of 2 smaller than or equal to n .","code":"import math NEW_LINE def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE"}
{"text":"Python program to find ( a ^ b ) mod m for a large 'a","code":"' NEW_LINE"}
{"text":"utility function to calculate a % m","code":"def aModM ( s , mod ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE DEDENT"}
{"text":"convert string s [ i ] to integer which gives the digit value and form the number","code":"number = ( number * 10 + int ( s [ i ] ) ) NEW_LINE number = number % m NEW_LINE return number NEW_LINE"}
{"text":"Returns find ( a ^ b ) % m","code":"def ApowBmodM ( a , b , m ) : NEW_LINE"}
{"text":"Find a % m","code":"ans = aModM ( a , m ) NEW_LINE mul = ans NEW_LINE"}
{"text":"now multiply ans by b - 1 times and take mod with m","code":"for i in range ( 1 , b ) : NEW_LINE INDENT ans = ( ans * mul ) % m NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver program to run the case","code":"a = \"987584345091051645734583954832576\" NEW_LINE b , m = 3 , 11 NEW_LINE print ApowBmodM ( a , b , m ) NEW_LINE"}
{"text":"To represent a data point corresponding to x and y = f ( x )","code":"class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT"}
{"text":"function to interpolate the given data points using Lagrange 's formula xi -> corresponds to the new data point whose value is to be obtained n -> represents the number of known data points","code":"def interpolate ( f : list , xi : int , n : int ) -> float : NEW_LINE"}
{"text":"Initialize result","code":"result = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Compute individual terms of above formula","code":"term = f [ i ] . y NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT term = term * ( xi - f [ j ] . x ) \/ ( f [ i ] . x - f [ j ] . x ) NEW_LINE DEDENT DEDENT"}
{"text":"Add current term to result","code":"result += term NEW_LINE return result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"creating an array of 4 known data points","code":"f = [ Data ( 0 , 2 ) , Data ( 1 , 3 ) , Data ( 2 , 12 ) , Data ( 5 , 147 ) ] NEW_LINE"}
{"text":"Using the interpolate function to obtain a data point corresponding to x = 3","code":"print ( \" Value \u2581 of \u2581 f ( 3 ) \u2581 is \u2581 : \" , interpolate ( f , 3 , 4 ) ) NEW_LINE"}
{"text":"Prints all prime numbers smaller","code":"def SieveOfSundaram ( n ) : NEW_LINE"}
{"text":"In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than n , we reduce n to half","code":"nNew = int ( ( n - 1 ) \/ 2 ) ; NEW_LINE"}
{"text":"This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j Initialize all elements as not marked","code":"marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE"}
{"text":"Main logic of Sundaram . Mark all numbers of the form i + j + 2 ij as true where 1 <= i <= j","code":"for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Since 2 is a prime number","code":"if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"text":"Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE"}
{"text":"Function to construct an array with each element equal to XOR of all array elements except the element at the same index","code":"def constructArray ( A , N , K ) : NEW_LINE"}
{"text":"Original array","code":"B = [ 0 ] * N ; NEW_LINE"}
{"text":"Stores Bitwise XOR of array","code":"totalXOR = A [ 0 ] ^ K ; NEW_LINE"}
{"text":"Calculate XOR of all array elements","code":"for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT"}
{"text":"Print the original array B","code":"for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 13 , 14 , 10 , 6 ] ; NEW_LINE K = 2 ; NEW_LINE N = len ( A ) ; NEW_LINE DEDENT"}
{"text":"Function Call","code":"constructArray ( A , N , K ) ; NEW_LINE"}
{"text":"Function to return the extra element in B [ ]","code":"def extraElement ( A , B , n ) : NEW_LINE"}
{"text":"To store the result","code":"ans = 0 ; NEW_LINE"}
{"text":"Find the XOR of all the element of array A [ ] and array B [ ]","code":"for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE"}
{"text":"Driver code","code":"A = [ 10 , 15 , 5 ] ; NEW_LINE B = [ 10 , 100 , 15 , 5 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( extraElement ( A , B , n ) ) ; NEW_LINE"}
{"text":"Function to calculate hamming distance","code":"def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 9 NEW_LINE n2 = 14 NEW_LINE print ( hammingDistance ( 9 , 14 ) ) NEW_LINE DEDENT"}
{"text":"function to find bitwise subsets Naive approach","code":"def printSubsets ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n & i ) == i ) : NEW_LINE INDENT print ( i , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Driver code","code":"n = 9 NEW_LINE printSubsets ( n ) NEW_LINE"}
{"text":"Python program to find MSB number for given n .","code":"import math NEW_LINE def setBitNumber ( n ) : NEW_LINE"}
{"text":"To find the position of the most significant set bit","code":"k = int ( math . log ( n , 2 ) ) NEW_LINE"}
{"text":"To return the value of the number with set bit at k - th position","code":"return 1 << k NEW_LINE"}
{"text":"Driver code","code":"n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"}
{"text":"function to count subsets such that all subsets have distinct elements .","code":"def subset ( ar , n ) : NEW_LINE"}
{"text":"take input and initialize res = 0","code":"res = 0 NEW_LINE"}
{"text":"sort the array","code":"ar . sort ( ) NEW_LINE"}
{"text":"traverse the input array and find maximum frequency","code":"for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT"}
{"text":"for each number find its repetition \/ frequency","code":"for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"text":"update res","code":"res = max ( res , count ) NEW_LINE return res NEW_LINE"}
{"text":"Driver code","code":"ar = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( subset ( ar , n ) ) NEW_LINE"}
{"text":"Function to count subsets such that all subsets have distinct elements .","code":"def subset ( arr , n ) : NEW_LINE"}
{"text":"Traverse the input array and store frequencies of elements","code":"mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"Find the maximum value in map .","code":"res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subset ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"''Store perfect squares less than or equal to N","code":"psquare = [ ] NEW_LINE"}
{"text":"''Utility function to calculate perfect squares less than or equal to N","code":"def calcPsquare ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT psquare . append ( i * i ) NEW_LINE DEDENT DEDENT"}
{"text":"''Function to find the number of ways to represent a number as sum of perfect squares","code":"def countWays ( index , target ) : NEW_LINE"}
{"text":"'' Handle the base cases","code":"if ( target == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( index < 0 or target < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"'' Include the i-th index element","code":"inc = countWays ( index , target - psquare [ index ] ) NEW_LINE"}
{"text":"'' Exclude the i-th index element","code":"exc = countWays ( index - 1 , target ) NEW_LINE"}
{"text":"'' Return the result","code":"return inc + exc NEW_LINE"}
{"text":"''Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"'' Given Input","code":"N = 9 NEW_LINE"}
{"text":"'' Precalculate perfect  squares <= N","code":"calcPsquare ( N ) NEW_LINE"}
{"text":"'' Function Call","code":"print ( countWays ( len ( psquare ) - 1 , N ) ) NEW_LINE"}
{"text":"''Stores the sum of distances of all nodes from the given node","code":"sum = 0 NEW_LINE"}
{"text":"''Structure of a binary tree node","code":"class TreeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . size = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT"}
{"text":"''Function to count the number of nodes in the left and right subtrees","code":"def sumofsubtree ( root ) : NEW_LINE"}
{"text":"'' Initialize a pair that stores  the pair {number of nodes, depth}","code":"p = [ 1 , 0 ] NEW_LINE"}
{"text":"'' Finding the number of nodes  in the left subtree","code":"if ( root . left ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . left ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT"}
{"text":"'' Find the number of nodes  in the right subtree","code":"if ( root . right ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . right ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT"}
{"text":"'' Filling up size field","code":"root . size = p [ 0 ] NEW_LINE return p NEW_LINE"}
{"text":"''Function to find the total distance","code":"def distance ( root , target , distancesum , n ) : NEW_LINE INDENT global sum NEW_LINE DEDENT"}
{"text":"'' If target node matches with  the current node","code":"if ( root . data == target ) : NEW_LINE INDENT sum = distancesum NEW_LINE DEDENT"}
{"text":"'' If root.left is not null","code":"if ( root . left ) : NEW_LINE"}
{"text":"'' Update sum","code":"tempsum = ( distancesum - root . left . size + ( n - root . left . size ) ) NEW_LINE"}
{"text":"'' Recur for the left subtree","code":"distance ( root . left , target , tempsum , n ) NEW_LINE"}
{"text":"'' If root.right is not null","code":"if ( root . right ) : NEW_LINE"}
{"text":"'' Apply the formula given  in the approach","code":"tempsum = ( distancesum - root . right . size + ( n - root . right . size ) ) NEW_LINE"}
{"text":"'' Recur for the right subtree","code":"distance ( root . right , target , tempsum , n ) NEW_LINE"}
{"text":"''Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"'' Input tree","code":"root = TreeNode ( 1 ) NEW_LINE root . left = TreeNode ( 2 ) NEW_LINE root . right = TreeNode ( 3 ) NEW_LINE root . left . left = TreeNode ( 4 ) NEW_LINE root . left . right = TreeNode ( 5 ) NEW_LINE root . right . left = TreeNode ( 6 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE root . left . left . left = TreeNode ( 8 ) NEW_LINE root . left . left . right = TreeNode ( 9 ) NEW_LINE target = 3 NEW_LINE p = sumofsubtree ( root ) NEW_LINE"}
{"text":"'' Total number of nodes","code":"totalnodes = p [ 0 ] NEW_LINE distance ( root , target , p [ 1 ] , totalnodes ) NEW_LINE"}
{"text":"'' Print the sum of distances","code":"print ( sum ) NEW_LINE"}
{"text":"''Function to rearrange array such that sum of similar indexed elements does not exceed K","code":"def rearrangeArray ( A , B , N , K ) : NEW_LINE"}
{"text":"'' Sort the array B[]  in descending order","code":"B . sort ( reverse = True ) NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"'' If condition fails","code":"if ( A [ i ] + B [ i ] > K ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if ( flag == False ) : NEW_LINE print ( \" - 1\" ) NEW_LINE else : NEW_LINE"}
{"text":"'' Print the array","code":"for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"''Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"'' Given arrays","code":"A = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE K = 5 ; NEW_LINE rearrangeArray ( A , B , N , K ) NEW_LINE"}
{"text":"''Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix","code":"def countRows ( mat ) : NEW_LINE"}
{"text":"'' Stores the matrix dimensions","code":"n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE"}
{"text":"'' To store the result","code":"count = 0 NEW_LINE"}
{"text":"'' Stores the total sum of  the matrix elements","code":"totalSum = 0 NEW_LINE"}
{"text":"'' Calculate the total sum","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT totalSum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT"}
{"text":"'' Traverse to check for each row","code":"for i in range ( n ) : NEW_LINE"}
{"text":"'' Stores the sum of elements  of the current row","code":"currSum = 0 NEW_LINE"}
{"text":"'' Calculate the sum of elements  of the current row","code":"for j in range ( m ) : NEW_LINE INDENT currSum += mat [ i ] [ j ] NEW_LINE DEDENT"}
{"text":"'' If sum of current row exceeds  the sum of rest of the matrix","code":"if ( currSum > totalSum - currSum ) : NEW_LINE"}
{"text":"'' Increase count","code":"count += 1 NEW_LINE"}
{"text":"'' Print the result","code":"print ( count ) NEW_LINE"}
{"text":"''Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"'' Given matrix","code":"mat = [ [ 2 , - 1 , 5 ] , [ - 3 , 0 , - 2 ] , [ 5 , 1 , 2 ] ] NEW_LINE"}
{"text":"'' Function call","code":"countRows ( mat ) NEW_LINE"}
{"text":"function to check whether the array contains a set of contiguous integers","code":"def areElementsContiguous ( arr , n ) : NEW_LINE"}
{"text":"Sort the array","code":"arr . sort ( ) NEW_LINE"}
{"text":"After sorting , check if current element is either same as previous or is one more .","code":"for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE"}
{"text":"Driver code","code":"arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"}
{"text":"function to check whether the array contains a set of contiguous integers","code":"def areElementsContiguous ( arr , n ) : NEW_LINE"}
{"text":"Find maximum and minimum elements .","code":"max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE"}
{"text":"There should be at least m elements in array to make them contiguous .","code":"if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Create a visited array and initialize fals","code":"visited = [ 0 ] * m NEW_LINE"}
{"text":"Mark elements as true .","code":"for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT"}
{"text":"If any element is not marked , all elements are not contiguous .","code":"for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Driver program","code":"arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to check whether the array contains a set of contiguous integers","code":"def areElementsContiguous ( arr ) : NEW_LINE"}
{"text":"Storing elements of ' arr [ ] ' in a hash table 'us","code":"us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE"}
{"text":"As arr [ 0 ] is present in 'us","code":"count = 1 NEW_LINE"}
{"text":"Starting with previous smaller element of arr [ 0 ]","code":"curr_ele = arr [ 0 ] - 1 NEW_LINE"}
{"text":"If ' curr _ ele ' is present in 'us","code":"while curr_ele in us : NEW_LINE"}
{"text":"Increment count","code":"count += 1 NEW_LINE"}
{"text":"Update 'curr_ele\"","code":"curr_ele -= 1 NEW_LINE"}
{"text":"Starting with next greater element of arr [ 0 ]","code":"curr_ele = arr [ 0 ] + 1 NEW_LINE"}
{"text":"If ' curr _ ele ' is present in 'us","code":"while curr_ele in us : NEW_LINE"}
{"text":"Increment count","code":"count += 1 NEW_LINE"}
{"text":"Update 'curr_ele\"","code":"curr_ele += 1 NEW_LINE"}
{"text":"Returns true if array contains a set of contiguous integers else returns false","code":"return ( count == len ( us ) ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"}
{"text":"function to print the longest sub - array","code":"import collections NEW_LINE def longest ( a , n , k ) : NEW_LINE INDENT freq = collections . defaultdict ( int ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE DEDENT"}
{"text":"mark the element visited","code":"freq [ a [ i ] ] += 1 NEW_LINE"}
{"text":"if its visited first time , then increase the counter of distinct elements by 1","code":"if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT"}
{"text":"When the counter of distinct elements increases from k , then reduce it to k","code":"while ( now > k ) : NEW_LINE"}
{"text":"from the left , reduce the number of time of visit","code":"freq [ a [ l ] ] -= 1 NEW_LINE"}
{"text":"if the reduced visited time element is not present in further segment then decrease the count of distinct elements","code":"if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT"}
{"text":"increase the subsegment mark","code":"l += 1 NEW_LINE"}
{"text":"check length of longest sub - segment when greater then previous best then change it","code":"if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT"}
{"text":"print the longest sub - segment","code":"for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE longest ( a , n , k ) NEW_LINE DEDENT"}
{"text":"Function that returns true if any k segments overlap at any point","code":"def kOverlap ( pairs : list , k ) : NEW_LINE"}
{"text":"Vector to store the starting point and the ending point","code":"vec = list ( ) NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE"}
{"text":"Starting points are marked by - 1 and ending points by + 1","code":"vec . append ( ( pairs [ 0 ] , - 1 ) ) NEW_LINE vec . append ( ( pairs [ 1 ] , 1 ) ) NEW_LINE"}
{"text":"Sort the vector by first element","code":"vec . sort ( key = lambda a : a [ 0 ] ) NEW_LINE"}
{"text":"Stack to store the overlaps","code":"st = list ( ) NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE"}
{"text":"Get the current element","code":"cur = vec [ i ] NEW_LINE"}
{"text":"If it is the starting point","code":"if cur [ 1 ] == - 1 : NEW_LINE"}
{"text":"Push it in the stack","code":"st . append ( cur ) NEW_LINE"}
{"text":"It is the ending point","code":"else : NEW_LINE"}
{"text":"Pop an element from stack","code":"st . pop ( ) NEW_LINE"}
{"text":"If more than k ranges overlap","code":"if len ( st ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT pairs = list ( ) NEW_LINE pairs . append ( ( 1 , 3 ) ) NEW_LINE pairs . append ( ( 2 , 4 ) ) NEW_LINE pairs . append ( ( 3 , 5 ) ) NEW_LINE pairs . append ( ( 7 , 10 ) ) NEW_LINE n = len ( pairs ) NEW_LINE k = 3 NEW_LINE if kOverlap ( pairs , k ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 program to finds out smallest range that includes elements from each of the given sorted lists .","code":"N = 5 NEW_LINE"}
{"text":"array for storing the current index of list i","code":"ptr = [ 0 for i in range ( 501 ) ] NEW_LINE"}
{"text":"This function takes an k sorted lists in the form of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists .","code":"def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE DEDENT"}
{"text":"initializing to 0 index","code":"for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT minrange = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE"}
{"text":"for maintaining the index of list containing the minimum element","code":"minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE"}
{"text":"iterating over all the list","code":"for i in range ( k ) : NEW_LINE"}
{"text":"if every element of list [ i ] is traversed then break the loop","code":"if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT"}
{"text":"find minimum value among all the list elements pointing by the ptr [ ] array","code":"if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE"}
{"text":"update the index of the list","code":"minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE"}
{"text":"find maximum value among all the list elements pointing by the ptr [ ] array","code":"if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT"}
{"text":"if any list exhaust we will not get any better answer , so break the while loop","code":"if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE"}
{"text":"updating the minrange","code":"if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT print ( \" The \u2581 smallest \u2581 range \u2581 is \u2581 [ \" , minel , maxel , \" ] \" ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ [ 4 , 7 , 9 , 12 , 15 ] , [ 0 , 8 , 10 , 14 , 20 ] , [ 6 , 12 , 16 , 30 , 50 ] ] NEW_LINE k = len ( arr ) NEW_LINE findSmallestRange ( arr , N , k ) NEW_LINE"}
{"text":"function to find largest d","code":"def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE DEDENT"}
{"text":"sort the array in ascending order","code":"S . sort ( ) NEW_LINE"}
{"text":"iterating from backwards to find the required largest d","code":"for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE DEDENT"}
{"text":"since all four a , b , c , d should be distinct","code":"if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"if the current combination of j , k , l in the set is equal to S [ i ] return this value as this would be the largest d since we are iterating in descending order","code":"if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT if ( found == False ) : NEW_LINE return - 1 NEW_LINE"}
{"text":"Driver Code","code":"S = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( S ) NEW_LINE ans = findLargestd ( S , n ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( \" No \u2581 Solution \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Largest \u2581 d \u2581 such \u2581 that \u2581 a \u2581 + \u2581 b \u2581 + \" , \" c \u2581 = \u2581 d \u2581 is \" , ans ) NEW_LINE DEDENT"}
{"text":"The function finds four elements with given sum X","code":"def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE DEDENT"}
{"text":"Store sums ( a + b ) of all pairs ( a , b ) in a hash table","code":"for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT"}
{"text":"Traverse through all pairs and find ( d - c ) is present in hash table","code":"d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT"}
{"text":"If d - c is present in hash table ,","code":"if abs_diff in mp . keys ( ) : NEW_LINE"}
{"text":"Making sure that all elements are distinct array elements and an element is not considered more than once .","code":"p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT return d NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE res = findFourElements ( arr , n ) NEW_LINE if ( res == - 10 ** 9 ) : NEW_LINE INDENT print ( \" No \u2581 Solution . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"}
{"text":"Function to count maximum number of elements that can be selected","code":"def CountMaximum ( arr , n , k ) : NEW_LINE"}
{"text":"Sort he array","code":"arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( 0 , n ) : NEW_LINE"}
{"text":"Add current element to the sum","code":"Sum += arr [ i ] NEW_LINE"}
{"text":"IF sum exceeds k","code":"if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Increment count","code":"count += 1 NEW_LINE"}
{"text":"Return the count","code":"return count NEW_LINE"}
{"text":"Driver code","code":"arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE"}
{"text":"Function call","code":"print ( CountMaximum ( arr , n , k ) ) NEW_LINE"}
{"text":"Function to left Rotate arr [ ] of size n by 1","code":"def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT"}
{"text":"Function to left rotate arr [ ] of size n by d","code":"def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT"}
{"text":"utility function to print an array","code":"def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % \u2581 d \" % arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver program to test above functions","code":"arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE"}
{"text":"Function to sort the elements of the array from index a to index b","code":"def partSort ( arr , N , a , b ) : NEW_LINE"}
{"text":"Variables to store start and end of the index range","code":"l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE"}
{"text":"Temporary array","code":"temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT"}
{"text":"Sort the temporary array","code":"temp . sort ( reverse = False ) NEW_LINE"}
{"text":"Modifying original array with temporary array elements","code":"j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT"}
{"text":"Print the modified array","code":"for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE DEDENT"}
{"text":"length of the array","code":"N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE"}
{"text":"Python 3 implementation to sort the rows of matrix in descending order followed by sorting the columns in ascending order","code":"MAX_SIZE = 10 NEW_LINE"}
{"text":"function to sort each row of the matrix according to the order specified by descending .","code":"def sortByRow ( mat , n , descending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( descending == True ) : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"function to find transpose of the matrix","code":"def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT DEDENT"}
{"text":"swapping element at index ( i , j ) by element at index ( j , i )","code":"mat [ i ] [ j ] , mat [ j ] [ i ] = mat [ j ] [ i ] , mat [ i ] [ j ] NEW_LINE"}
{"text":"function to sort the matrix row - wise and column - wise","code":"def sortMatRowAndColWise ( mat , n ) : NEW_LINE"}
{"text":"sort rows of mat [ ] [ ] in descending order","code":"sortByRow ( mat , n , True ) NEW_LINE"}
{"text":"get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) NEW_LINE"}
{"text":"again sort rows of mat [ ] [ ] in ascending order .","code":"sortByRow ( mat , n , False ) NEW_LINE"}
{"text":"again get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) ; NEW_LINE"}
{"text":"function to print the matrix","code":"def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( \" Original \u2581 Matrix : \u2581 \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix \u2581 After \u2581 Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE DEDENT"}
{"text":"Function which pushes all zeros to end of an array .","code":"def pushZerosToEnd ( arr , n ) : NEW_LINE"}
{"text":"Count of non - zero elements","code":"count = 0 NEW_LINE"}
{"text":"Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element","code":"for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE DEDENT"}
{"text":"here count is incremented","code":"arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE"}
{"text":"Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end .","code":"while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT"}
{"text":"Driver code","code":"arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array \u2581 after \u2581 pushing \u2581 all \u2581 zeros \u2581 to \u2581 end \u2581 of \u2581 array : \" ) NEW_LINE print ( arr ) NEW_LINE"}
{"text":"function to move all zeroes at the end of array","code":"def moveZerosToEnd ( arr , n ) : NEW_LINE"}
{"text":"Count of non - zero elements","code":"count = 0 ; NEW_LINE"}
{"text":"Traverse the array . If arr [ i ] is non - zero , then swap the element at index ' count ' with the element at index 'i","code":"for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT"}
{"text":"function to print the array elements","code":"def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver program to test above","code":"arr = [ 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Original \u2581 array : \" , end = \" \u2581 \" ) NEW_LINE printArray ( arr , n ) NEW_LINE moveZerosToEnd ( arr , n ) NEW_LINE print ( \" Modified array : \" , \u2581 end = \"   \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"text":"function which pushes all zeros to end of an array .","code":"def pushZerosToEnd ( arr , n ) : NEW_LINE"}
{"text":"Count of non - zero elements","code":"count = 0 NEW_LINE"}
{"text":"Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element","code":"for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE DEDENT"}
{"text":"here count is incremented","code":"arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE"}
{"text":"Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end .","code":"while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT"}
{"text":"function to rearrange the array elements after modification","code":"def modifyAndRearrangeArr ( ar , n ) : NEW_LINE"}
{"text":"if ' arr [ ] ' contains a single element only","code":"if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"traverse the array","code":"for i in range ( 0 , n - 1 ) : NEW_LINE"}
{"text":"if true , perform the required modification","code":"if ( arr [ i ] != 0 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE"}
{"text":"double current index value","code":"arr [ i ] = 2 * arr [ i ] NEW_LINE"}
{"text":"put 0 in the next index","code":"arr [ i + 1 ] = 0 NEW_LINE"}
{"text":"increment by 1 so as to move two indexes ahead during loop iteration","code":"i += 1 NEW_LINE"}
{"text":"push all the zeros at the end of 'arr[]","code":"pushZerosToEnd ( arr , n ) NEW_LINE"}
{"text":"function to print the array elements","code":"def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver program to test above","code":"arr = [ 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Original \u2581 array : \" , end = \" \u2581 \" ) NEW_LINE printArray ( arr , n ) NEW_LINE modifyAndRearrangeArr ( arr , n ) NEW_LINE print ( \" Modified array : \" , end = \"   \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"text":"shift all zero to left side of an array","code":"def shiftAllZeroToLeft ( arr , n ) : NEW_LINE"}
{"text":"Maintain last index with positive value","code":"lastSeenNonZero = 0 NEW_LINE for index in range ( 0 , n ) : NEW_LINE"}
{"text":"If Element is non - zero","code":"if ( array [ index ] != 0 ) : NEW_LINE"}
{"text":"swap current index , with lastSeen non - zero","code":"array [ index ] , array [ lastSeenNonZero ] = array [ lastSeenNonZero ] , array [ index ] NEW_LINE"}
{"text":"next element will be last seen non - zero","code":"lastSeenNonZero += 1 NEW_LINE"}
{"text":"A utility function to print an array of size n","code":"def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Function to Rearrange positive and negative numbers in a array","code":"def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"if current element is positive do nothing","code":"if ( key > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"if current element is negative , shift positive elements of arr [ 0. . i - 1 ] , to one position to their right","code":"j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT"}
{"text":"Put negative element at its right position","code":"arr [ j + 1 ] = key NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT"}
{"text":"Function to print an array","code":"def printArray ( A , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( A [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space .","code":"def reverse ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE l , r = l + 1 , r - 1 NEW_LINE reverse ( arr , l , r ) NEW_LINE DEDENT DEDENT"}
{"text":"Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ]","code":"def merge ( arr , l , m , r ) : NEW_LINE"}
{"text":"Initial index of 1 st subarray","code":"i = l NEW_LINE"}
{"text":"Initial index of IInd","code":"j = m + 1 NEW_LINE while i <= m and arr [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT"}
{"text":"arr [ i . . m ] is positive","code":"while j <= r and arr [ j ] < 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT"}
{"text":"arr [ j . . r ] is positive reverse positive part of left sub - array ( arr [ i . . m ] )","code":"reverse ( arr , i , m ) NEW_LINE"}
{"text":"reverse negative part of right sub - array ( arr [ m + 1. . j - 1 ] )","code":"reverse ( arr , m + 1 , j - 1 ) NEW_LINE"}
{"text":"reverse arr [ i . . j - 1 ]","code":"reverse ( arr , i , j - 1 ) NEW_LINE"}
{"text":"Function to Rearrange positive and negative numbers in a array","code":"def RearrangePosNeg ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE DEDENT"}
{"text":"Same as ( l + r ) \/ 2 , but avoids overflow for large l and h","code":"m = l + ( r - l ) \/\/ 2 NEW_LINE"}
{"text":"Sort first and second halves","code":"RearrangePosNeg ( arr , l , m ) NEW_LINE RearrangePosNeg ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE RearrangePosNeg ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT"}
{"text":"Python implementation of the above approach","code":"def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( True ) : NEW_LINE DEDENT"}
{"text":"Loop until arr [ i ] < 0 and still inside the array","code":"while ( arr [ i ] < 0 and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT"}
{"text":"Loop until arr [ j ] > 0 and still inside the array","code":"while ( arr [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT"}
{"text":"if i is less than j","code":"if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE print ( * arr ) NEW_LINE"}
{"text":"Function to find the winner of the game played based on given conditions","code":"def winner ( arr , N ) : NEW_LINE"}
{"text":"A wins if size of array is odd","code":"if ( N % 2 == 1 ) : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT"}
{"text":"Otherwise , B wins","code":"else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Input array","code":"arr = [ 24 , 45 , 45 , 24 ] NEW_LINE"}
{"text":"Size of the array","code":"N = len ( arr ) NEW_LINE winner ( arr , N ) NEW_LINE"}
{"text":"python program for the above approach","code":"import math NEW_LINE sz = 20 NEW_LINE sqr = int ( math . sqrt ( sz ) ) + 1 NEW_LINE"}
{"text":"Function to sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all possible values of X and Y , where Y is less than or equal to sqrt ( N ) .","code":"def precomputeExpressionForAllVal ( arr , N , dp ) : NEW_LINE"}
{"text":"Iterate over all possible values of X","code":"for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE"}
{"text":"Precompute for all possible values of an expression such that y <= sqrt ( N )","code":"for j in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE"}
{"text":"If i + j less than N","code":"if ( i + j < N ) : NEW_LINE"}
{"text":"Update dp [ i ] [ j ]","code":"dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] NEW_LINE else : NEW_LINE"}
{"text":"Update dp [ i ] [ j ]","code":"dp [ i ] [ j ] = arr [ i ] NEW_LINE"}
{"text":"Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries","code":"def querySum ( arr , N , Q , M ) : NEW_LINE"}
{"text":"dp [ x ] [ y ] : Stores sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ...","code":"dp = [ [ 0 for x in range ( sz ) ] for x in range ( sqr ) ] NEW_LINE precomputeExpressionForAllVal ( arr , N , dp ) NEW_LINE"}
{"text":"Traverse the query array , Q [ ] [ ]","code":"for i in range ( 0 , M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE DEDENT"}
{"text":"If y is less than or equal to sqrt ( N )","code":"if ( y <= math . sqrt ( N ) ) : NEW_LINE INDENT print ( dp [ x ] [ y ] ) NEW_LINE continue NEW_LINE DEDENT"}
{"text":"Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ...","code":"sum = 0 NEW_LINE"}
{"text":"Traverse the array , arr [ ]","code":"while ( x < N ) : NEW_LINE"}
{"text":"Update sum","code":"sum += arr [ x ] NEW_LINE"}
{"text":"Update x","code":"x += y NEW_LINE print ( sum ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 7 , 5 , 4 ] NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q [ 0 ] ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE"}
{"text":"Python3 program to find all elements in array which have at - least two greater elements itself .","code":"def findElements ( arr , n ) : NEW_LINE"}
{"text":"Pick elements one by one and count greater elements . If count is more than 2 , print that element .","code":"for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"text":"Sorting based Python 3 program to find all elements in array which have atleast two greater elements itself .","code":"def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driven source","code":"arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"text":"Python3 program to find all elements in array which have atleast two greater elements itself .","code":"import sys NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE DEDENT"}
{"text":"If current element is smaller than first then update both first and second","code":"if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT"}
{"text":"If arr [ i ] is in between first and second then update second","code":"elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"text":"Function to find the minimum number of operations required to make the array non - increasing","code":"def getMinOps ( arr ) : NEW_LINE"}
{"text":"Stores the count of required operations","code":"res = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE"}
{"text":"If arr [ i ] > arr [ i + 1 ] , no increments required . Otherwise , add their difference to the answer","code":"res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) NEW_LINE"}
{"text":"Return the result res","code":"return res NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 1 , 3 , 4 , 1 , 2 ] NEW_LINE print ( getMinOps ( arr ) ) NEW_LINE"}
{"text":"function that returns smallest elements missing in a sorted array .","code":"def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) \/ 2 ) NEW_LINE DEDENT"}
{"text":"Left half has all elements from 0 to mid","code":"if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE"}
{"text":"driver program to test above function","code":"arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest \u2581 missing \u2581 element \u2581 is \" , findFirstMissing ( arr , 0 , n - 1 ) ) NEW_LINE"}
{"text":"Function to find missing element","code":"def findFirstMissing ( arr , start , end , first ) : NEW_LINE INDENT if ( start < end ) : NEW_LINE INDENT mid = int ( ( start + end ) \/ 2 ) NEW_LINE DEDENT DEDENT"}
{"text":"Index matches with value at that index , means missing element cannot be upto that point","code":"if ( arr [ mid ] != mid + first ) : NEW_LINE INDENT return findFirstMissing ( arr , start , mid , first ) NEW_LINE DEDENT else : NEW_LINE INDENT return findFirstMissing ( arr , mid + 1 , end , first ) NEW_LINE DEDENT return start + first NEW_LINE"}
{"text":"Function to find Smallest Missing in Sorted Array","code":"def findSmallestMissinginSortedArray ( arr ) : NEW_LINE"}
{"text":"Check if 0 is missing in the array","code":"if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Check is all numbers 0 to n - 1 are prsent in array","code":"if ( arr [ - 1 ] == len ( arr ) - 1 ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE return findFirstMissing ( arr , 0 , len ( arr ) - 1 , first ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE"}
{"text":"Function Call","code":"print ( \" First \u2581 Missing \u2581 element \u2581 is \u2581 : \" , findSmallestMissinginSortedArray ( arr ) ) NEW_LINE"}
{"text":"Function to return max sum such that no two elements are adjacent","code":"def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE DEDENT"}
{"text":"Current max excluding i ( No ternary in Python )","code":"new_excl = excl if excl > incl else incl NEW_LINE"}
{"text":"Current max including i","code":"incl = excl + i NEW_LINE excl = new_excl NEW_LINE"}
{"text":"return max of incl and excl","code":"return ( excl if excl > incl else incl ) NEW_LINE"}
{"text":"Driver program to test above function","code":"arr = [ 5 , 5 , 10 , 100 , 10 , 5 ] NEW_LINE print find_max_sum ( arr ) NEW_LINE"}
{"text":"Function for counting minimum number of changes","code":"def countChanges ( matrix , n , m ) : NEW_LINE"}
{"text":"Distance of elements from ( 0 , 0 ) will is i range [ 0 , n + m - 2 ]","code":"dist = n + m - 1 NEW_LINE"}
{"text":"Store frequencies of [ 0 , 9 ] at distance i Initialize all with zero","code":"freq = [ [ 0 ] * 10 for i in range ( dist ) ] NEW_LINE"}
{"text":"Count frequencies of [ 0 , 9 ]","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT"}
{"text":"Increment frequency of value matrix [ i ] [ j ] at distance i + j","code":"freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE min_changes_sum = 0 NEW_LINE for i in range ( dist \/\/ 2 ) : NEW_LINE maximum = 0 NEW_LINE total_values = 0 NEW_LINE"}
{"text":"Find value with max frequency and count total cells at distance i from front end and rear end","code":"for j in range ( 10 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT"}
{"text":"Change all values to the value with max frequency","code":"min_changes_sum += ( total_values - maximum ) NEW_LINE"}
{"text":"Return the answer","code":"return min_changes_sum NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given matrix","code":"mat = [ [ 1 , 2 ] , [ 3 , 5 ] ] NEW_LINE"}
{"text":"Function call","code":"print ( countChanges ( mat , 2 , 2 ) ) NEW_LINE"}
{"text":"Python3 program to do range minimum query using sparse table","code":"import math NEW_LINE"}
{"text":"Fills lookup array lookup [ ] [ ] in bottom up manner .","code":"def buildSparseTable ( arr , n ) : NEW_LINE"}
{"text":"Initialize M for the intervals with length 1","code":"for i in range ( 0 , n ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE"}
{"text":"Compute values from smaller to bigger intervals","code":"while ( 1 << j ) <= n : NEW_LINE"}
{"text":"Compute minimum value for all intervals with size 2 ^ j","code":"i = 0 NEW_LINE while ( i + ( 1 << j ) - 1 ) < n : NEW_LINE"}
{"text":"For arr [ 2 ] [ 10 ] , we compare arr [ lookup [ 0 ] [ 7 ] ] and arr [ lookup [ 3 ] [ 10 ] ]","code":"if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE"}
{"text":"Returns minimum of arr [ L . . R ]","code":"def query ( L , R ) : NEW_LINE"}
{"text":"Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3","code":"j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE"}
{"text":"Compute minimum of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we compare arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,","code":"if lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] : NEW_LINE INDENT return lookup [ L ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return lookup [ R - ( 1 << j ) + 1 ] [ j ] NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE lookup = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 4 , 7 ) ) NEW_LINE print ( query ( 7 , 8 ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to do range minimum query using sparse table","code":"import math NEW_LINE"}
{"text":"Fills lookup array lookup [ ] [ ] in bottom up manner .","code":"def buildSparseTable ( arr , n ) : NEW_LINE"}
{"text":"GCD of single element is element itself","code":"for i in range ( 0 , n ) : NEW_LINE INDENT table [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT"}
{"text":"Build sparse table","code":"j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - ( 1 << j ) : NEW_LINE INDENT table [ i ] [ j ] = math . gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT"}
{"text":"Returns minimum of arr [ L . . R ]","code":"def query ( L , R ) : NEW_LINE"}
{"text":"Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3","code":"j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE"}
{"text":"Compute GCD of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we find GCD of arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,","code":"return math . gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE table = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 2 ) ) NEW_LINE print ( query ( 1 , 3 ) ) NEW_LINE print ( query ( 4 , 5 ) ) NEW_LINE DEDENT"}
{"text":"Modifies arr [ 0. . n - 1 ] to lexicographically smallest with k swaps .","code":"def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE DEDENT"}
{"text":"Set the position where we we want to put the smallest integer","code":"pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE"}
{"text":"If we exceed the Max swaps then terminate the loop","code":"if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Find the minimum value from i + 1 to max ( k or n )","code":"if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT"}
{"text":"Swap the elements from Minimum position we found till now to the i index","code":"for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT"}
{"text":"Set the final value after swapping pos - i elements","code":"k -= pos - i NEW_LINE"}
{"text":"Driver Code","code":"n , k = 5 , 3 NEW_LINE arr = [ 7 , 6 , 9 , 2 , 1 ] NEW_LINE"}
{"text":"Print the final Array","code":"for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Returns beginning index of maximum average subarray of length k","code":"def findMaxAverage ( arr , n , k ) : NEW_LINE"}
{"text":"Check if ' k ' is valid","code":"if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Create and fill array to store cumulative sum . csum [ i ] stores sum of arr [ 0 ] to arr [ i ]","code":"csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT"}
{"text":"Initialize max_sm as sum of first subarray","code":"max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE"}
{"text":"Find sum of other subarrays and update max_sum if required .","code":"for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT"}
{"text":"Return starting index","code":"return max_end - k + 1 NEW_LINE"}
{"text":"Driver program","code":"arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( \" The \u2581 maximum \u2581 average \u2581 subarray \u2581 of \u2581 length \" , k , \" begins \u2581 at \u2581 index \" , findMaxAverage ( arr , n , k ) ) NEW_LINE"}
{"text":"Returns beginning index of maximum average subarray of length k","code":"def findMaxAverage ( arr , n , k ) : NEW_LINE"}
{"text":"Check if ' k ' is valid","code":"if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Compute sum of first ' k ' elements","code":"sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE"}
{"text":"Compute sum of remaining subarrays","code":"for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT"}
{"text":"Return starting index","code":"return max_end - k + 1 NEW_LINE"}
{"text":"Driver program","code":"arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( \" The \u2581 maximum \u2581 average \u2581 subarray \u2581 of \u2581 length \" , k , \" begins \u2581 at \u2581 index \" , findMaxAverage ( arr , n , k ) ) NEW_LINE"}
{"text":"Stores the minimum score for each states as map < pair < pos , myturn > , ans >","code":"m = dict ( ) NEW_LINE"}
{"text":"Function to find the minimum score after choosing element from array","code":"def findMinimum ( a , n , pos , myturn ) : NEW_LINE"}
{"text":"Return the stored state","code":"if ( pos , myturn ) in m : NEW_LINE INDENT return m [ ( pos , myturn ) ] ; NEW_LINE DEDENT"}
{"text":"Base Case","code":"if ( pos >= n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Player A 's turn","code":"if ( not myturn ) : NEW_LINE"}
{"text":"Find the minimum score","code":"ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , not myturn ) + a [ pos ] + a [ pos + 1 ] ) ; NEW_LINE"}
{"text":"Store the current state","code":"m [ ( pos , myturn ) ] = ans ; NEW_LINE"}
{"text":"Return the result","code":"return ans ; NEW_LINE"}
{"text":"Player B 's turn","code":"if ( myturn ) : NEW_LINE"}
{"text":"Find minimum score","code":"ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) , findMinimum ( a , n , pos + 2 , not myturn ) ) ; NEW_LINE"}
{"text":"Store the current state","code":"m [ ( pos , myturn ) ] = ans ; NEW_LINE"}
{"text":"Return the result","code":"return ans ; NEW_LINE return 0 ; NEW_LINE"}
{"text":"Function that finds the minimum penality after choosing element from the given binary array","code":"def countPenality ( arr , N ) : NEW_LINE"}
{"text":"Starting position of choosing element from array","code":"pos = 0 ; NEW_LINE"}
{"text":"0 denotes player A turn 1 denotes player B turn","code":"turn = False ; NEW_LINE"}
{"text":"Function Call","code":"return findMinimum ( arr , N , pos , turn ) + 1 ; NEW_LINE"}
{"text":"Print the answer for player A and B","code":"def printAnswer ( arr , N ) : NEW_LINE"}
{"text":"Minimum penalty","code":"a = countPenality ( arr , N ) ; NEW_LINE"}
{"text":"Calculate sum of all arr elements","code":"sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT"}
{"text":"Print the minimum score","code":"print ( a ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printAnswer ( arr , N ) ; NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE MAX = 1000001 NEW_LINE"}
{"text":"Create a boolean array prime [ ] and initialize all entires it as true A value in prime [ i ] will finally be false if i is Not a prime","code":"prime = [ True ] * MAX NEW_LINE"}
{"text":"Function to find prime numbers","code":"def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE DEDENT"}
{"text":"Check if prime [ p ] is not changed , then it is a prime","code":"if prime [ p ] == True : NEW_LINE"}
{"text":"Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked","code":"for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"Function to get the middle index from corner indexes","code":"def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"Function to get the sum of values in the given range of the array","code":"def getSumUtil ( st , ss , se , qs , qe , si ) : NEW_LINE"}
{"text":"If segment of this node is a part of given range , then return the sum of the segment","code":"if qs <= ss and qe >= se : NEW_LINE INDENT return st [ si ] NEW_LINE DEDENT"}
{"text":"If segment of this node is outside the given range","code":"if se < qs or ss > qe : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"If a part of this segment overlaps with the given range","code":"mid = getMid ( ss , se ) NEW_LINE return ( getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ) NEW_LINE"}
{"text":"Function to update the nodes which have the given index in their range","code":"def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE"}
{"text":"If the input index lies outside the range of this segment","code":"if i < ss or i > se : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"If the input index is in range of this node , then update the value of the node and its children","code":"st [ si ] = st [ si ] + diff NEW_LINE if se != ss : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT"}
{"text":"Function to update a value in input array and segment tree","code":"def updateValue ( arr , st , n , i , new_val ) : NEW_LINE"}
{"text":"Check for errorneous imput index","code":"if i < 0 or i > n - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Get the difference between new value and old value","code":"diff = new_val - arr [ i ] NEW_LINE prev_val = arr [ i ] NEW_LINE"}
{"text":"Update the value in array","code":"arr [ i ] = new_val NEW_LINE"}
{"text":"Update the values of nodes in segment tree only if either previous value or new value or both are prime","code":"if prime [ new_val ] or prime [ prev_val ] : NEW_LINE"}
{"text":"If only new value is prime","code":"if not prime [ prev_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) NEW_LINE DEDENT"}
{"text":"If only old value is prime","code":"elif not prime [ new_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) NEW_LINE DEDENT"}
{"text":"If both are prime","code":"else : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT"}
{"text":"Return sum of elements in range from index qs ( query start ) to qe ( query end ) . It mainly uses getSumUtil ( )","code":"def getSum ( st , n , qs , qe ) : NEW_LINE"}
{"text":"Check for erroneous input values","code":"if qs < 0 or qe > n - 1 or qs > qe : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) NEW_LINE"}
{"text":"Function that constructs the Segment Tree","code":"def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE"}
{"text":"If there is one element in array , store it in current node of segment tree and return","code":"if ss == se : NEW_LINE"}
{"text":"Only add those elements in segment tree which are prime","code":"if prime [ arr [ ss ] ] : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE"}
{"text":"If there are more than one elements , then recur for left and right subtrees and store the sum of values in this node","code":"mid = getMid ( ss , se ) NEW_LINE st [ si ] = ( constructSTUtil ( arr , ss , mid , st , 2 * si + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , 2 * si + 2 ) ) NEW_LINE return st [ si ] NEW_LINE"}
{"text":"Function to construct segment tree from given array","code":"def constructST ( arr , n ) : NEW_LINE"}
{"text":"Height of segment tree","code":"x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE"}
{"text":"Maximum size of segment tree","code":"max_size = 2 * int ( pow ( 2 , x ) ) - 1 NEW_LINE"}
{"text":"Allocate memory","code":"st = [ 0 ] * max_size NEW_LINE"}
{"text":"Fill the allocated memory st","code":"constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE"}
{"text":"Return the constructed segment tree","code":"return st NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 3 , 5 , 7 , 9 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE Q = [ [ 1 , 1 , 3 ] , [ 2 , 1 , 10 ] , [ 1 , 1 , 3 ] ] NEW_LINE"}
{"text":"Function call","code":"SieveOfEratosthenes ( ) NEW_LINE"}
{"text":"Build segment tree from given array","code":"st = constructST ( arr , n ) NEW_LINE"}
{"text":"Print sum of values in array from index 1 to 3","code":"print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE"}
{"text":"Update : set arr [ 1 ] = 10 and update corresponding segment tree nodes","code":"updateValue ( arr , st , n , 1 , 10 ) NEW_LINE"}
{"text":"Find sum after value is updated","code":"print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE"}
{"text":"Python 3 Program to Count the number of ways to construct the target string","code":"mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE"}
{"text":"base case","code":"if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"If current subproblem has been solved , use the value","code":"if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT"}
{"text":"current character","code":"c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE"}
{"text":"search through all the indiced at which the current character occurs . For each index greater than prev , take the index and move to the next position , and add to the answer .","code":"answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE"}
{"text":"Store and return the solution for this subproblem","code":"return dp [ pos ] [ prev ] NEW_LINE def countWays ( a , s ) : NEW_LINE n = len ( a ) NEW_LINE"}
{"text":"preprocess the strings by storing for each character of every string , the index of their occurrence we will use a common list for all because of only the index matter in the string from which the character was picked","code":"index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE DEDENT"}
{"text":"we are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just for ease of implementation","code":"index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE"}
{"text":"initialise dp table . - 1 represents that the subproblem hasn 't been solve","code":"return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"}
{"text":"Python 3 implementation of the approach","code":"MAX = 10005 NEW_LINE MOD = 1000000007 NEW_LINE"}
{"text":"Function to return the count of numbers from the range [ 0 , n ] whose digit sum is a multiple of k using bottom - up dp","code":"def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE DEDENT"}
{"text":"The digit in this index can only be from [ 0 , num [ idx ] ]","code":"if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT"}
{"text":"The digit in this index can be anything from [ 0 , 9 ]","code":"else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE"}
{"text":"new_tight is the flag value for the next position","code":"new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE"}
{"text":"res can 't be negative","code":"if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE"}
{"text":"Function to process the string to a vector of digits from MSD to LSD","code":"def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"For large input number n","code":"n = \"98765432109876543210\" NEW_LINE"}
{"text":"Total number of digits in n","code":"len1 = len ( n ) NEW_LINE k = 58 NEW_LINE"}
{"text":"To store the states of the dp","code":"dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ] NEW_LINE"}
{"text":"Process the string to a vector of digits from MSD to LSD","code":"num = process ( n ) NEW_LINE print ( countNum ( 0 , 0 , 0 , num , len1 , k ) ) NEW_LINE"}
{"text":"w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on","code":"def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE"}
{"text":"Base case","code":"if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT"}
{"text":"Variables to store the result of three parts of recurrence relation","code":"fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE"}
{"text":"Store the state in the 3D array","code":"dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Input array","code":"arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE"}
{"text":"3D array to store states of DP","code":"dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE"}
{"text":"Number of elements in the array","code":"n = len ( arr ) NEW_LINE"}
{"text":"Capacity of knapsacks","code":"w1 , w2 = 10 , 3 NEW_LINE"}
{"text":"Function to be called","code":"print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE"}
{"text":"Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed","code":"def CountWays ( n ) : NEW_LINE"}
{"text":"noOfWays [ i ] will store count for last 3 values before i .","code":"noOfWays = [ 0 ] * ( n + 1 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE"}
{"text":"Loop till \" n + 1\" to compute value for \" n \"","code":"for i in range ( 3 , n + 1 ) : NEW_LINE"}
{"text":"number of ways if first run is 1","code":"noOfWays [ i ] = noOfWays [ 3 - 1 ] NEW_LINE"}
{"text":"number of ways if first run is 2 and second run is 1","code":"+ noOfWays [ 3 - 3 ] NEW_LINE"}
{"text":"Remember last 3 values","code":"noOfWays [ 0 ] = noOfWays [ 1 ] NEW_LINE noOfWays [ 1 ] = noOfWays [ 2 ] NEW_LINE noOfWays [ 2 ] = noOfWays [ i ] NEW_LINE return noOfWays [ n ] NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of above approach","code":"MAX = 105 NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Depth First Search","code":"def dfs ( i , j , k , q , n , m ) : NEW_LINE"}
{"text":"Return if cell contain non prime number or obstacle , or going out of matrix or already visited the cell or already found the lexicographical largest path","code":"if ( mappedMatrix [ i ] [ j ] == 0 or i > n or j > m or mark [ i ] [ j ] or q != 0 ) : NEW_LINE INDENT return q ; NEW_LINE DEDENT"}
{"text":"marking cell is already visited","code":"mark [ i ] [ j ] = 1 ; NEW_LINE"}
{"text":"storing the lexicographical largest path index","code":"ans [ k ] = [ i , j ] NEW_LINE"}
{"text":"if reached the end of the matrix","code":"if ( i == n and j == m ) : NEW_LINE"}
{"text":"updating the final number of steps in lexicographical largest path","code":"q = k ; NEW_LINE return q ; NEW_LINE"}
{"text":"moving diagonal ( trying lexicographical largest path )","code":"q = dfs ( i + 1 , j + 1 , k + 1 , q , n , m ) ; NEW_LINE"}
{"text":"moving cell right to current cell","code":"q = dfs ( i + 1 , j , k + 1 , q , n , m ) ; NEW_LINE"}
{"text":"moving cell down to current cell .","code":"q = dfs ( i , j + 1 , k + 1 , q , n , m ) ; NEW_LINE return q NEW_LINE"}
{"text":"Print lexicographical largest prime path","code":"def lexicographicalPath ( n , m ) : NEW_LINE"}
{"text":"To count the number of step in lexicographical largest prime path","code":"q = 0 ; NEW_LINE global ans , mark NEW_LINE"}
{"text":"To store the lexicographical largest prime path index","code":"ans = [ [ 0 , 0 ] for i in range ( MAX ) ] NEW_LINE"}
{"text":"To mark if the cell is already traversed or not","code":"mark = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE"}
{"text":"traversing by DFS","code":"q = dfs ( 1 , 1 , 1 , q , n , m ) ; NEW_LINE"}
{"text":"printing the lexicographical largest prime path","code":"for i in range ( 1 , q + 1 ) : NEW_LINE INDENT print ( str ( ans [ i ] [ 0 ] ) + ' \u2581 ' + str ( ans [ i ] [ 1 ] ) ) NEW_LINE DEDENT"}
{"text":"Return the number of prime path in ther matrix .","code":"def countPrimePath ( n , m ) : NEW_LINE INDENT global dp NEW_LINE dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE DEDENT"}
{"text":"for each cell","code":"for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE DEDENT"}
{"text":"If on the top row or leftmost column , there is no path there .","code":"if ( i == 1 and j == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; NEW_LINE"}
{"text":"If non prime number","code":"if ( mappedMatrix [ i ] [ j ] == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT print ( dp [ n ] [ m ] ) NEW_LINE"}
{"text":"Finding the matrix mapping by considering non prime number as obstacle and prime number be valid path .","code":"def preprocessMatrix ( a , n , m ) : NEW_LINE INDENT global prime NEW_LINE prime = [ 0 for i in range ( MAX ) ] NEW_LINE DEDENT"}
{"text":"Sieve","code":"sieve ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT"}
{"text":"If prime","code":"if ( prime [ a [ i ] [ j ] ] == 0 ) : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; NEW_LINE DEDENT"}
{"text":"if non prime","code":"else : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 2 , 3 , 7 ] , [ 5 , 4 , 2 ] , [ 3 , 7 , 11 ] ] ; NEW_LINE mappedMatrix = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE preprocessMatrix ( a , n , m ) ; NEW_LINE countPrimePath ( n , m ) ; NEW_LINE lexicographicalPath ( n , m ) ; NEW_LINE DEDENT"}
{"text":"A Dynamic Programming solution for subset sum problem + maximal subset value . Returns size of maximum sized subset if there is a subset of set [ ] with sun equal to given sum . It returns - 1 if there is no subset with given sum .","code":"def isSubsetSum ( arr , n , sum ) : NEW_LINE"}
{"text":"The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i","code":"subset = [ [ False for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE count = [ [ 0 for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE"}
{"text":"If sum is 0 , then answer is true","code":"for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE count [ 0 ] [ i ] = 0 NEW_LINE DEDENT"}
{"text":"If sum is not 0 and set is empty , then answer is false","code":"for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE count [ i ] [ 0 ] = - 1 NEW_LINE DEDENT"}
{"text":"Fill the subset table in bottom up manner","code":"for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE count [ i ] [ j ] = count [ i ] [ j - 1 ] NEW_LINE if ( i >= arr [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE if ( subset [ i ] [ j ] ) : NEW_LINE INDENT count [ i ] [ j ] = ( max ( count [ i ] [ j - 1 ] , count [ i - arr [ j - 1 ] ] [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count [ sum ] [ n ] NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 10 ] NEW_LINE sum = 20 NEW_LINE n = 4 NEW_LINE print ( isSubsetSum ( arr , n , sum ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to find all LCS of two strings in sorted order .","code":"MAX = 100 NEW_LINE lcslen = 0 NEW_LINE"}
{"text":"dp matrix to store result of sub calls for lcs","code":"dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE"}
{"text":"A memoization based function that returns LCS of str1 [ i . . len1 - 1 ] and str2 [ j . . len2 - 1 ]","code":"def lcs ( str1 , str2 , len1 , len2 , i , j ) : NEW_LINE"}
{"text":"base condition","code":"if ( i == len1 or j == len2 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT"}
{"text":"if lcs has been computed","code":"if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ret = 0 NEW_LINE"}
{"text":"if characters are same return previous + 1 else max of two sequences after removing i ' th \u2581 and \u2581 j ' th char one by one","code":"if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ret NEW_LINE return ret NEW_LINE"}
{"text":"Function to prall routes common sub - sequences of length lcslen","code":"def printAll ( str1 , str2 , len1 , len2 , data , indx1 , indx2 , currlcs ) : NEW_LINE"}
{"text":"if currlcs is equal to lcslen then prit","code":"if ( currlcs == lcslen ) : NEW_LINE INDENT print ( \" \" . join ( data [ : currlcs ] ) ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"if we are done with all the characters of both string","code":"if ( indx1 == len1 or indx2 == len2 ) : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"here we have to prall sub - sequences lexicographically , that ' s \u2581 why \u2581 we \u2581 start \u2581 from \u2581 ' a ' to ' z ' if this character is  present in both of them then append it in data[] and same  remaining part","code":"for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE"}
{"text":"done is a flag to tell that we have printed all the subsequences corresponding to current character","code":"done = False NEW_LINE for i in range ( indx1 , len1 ) : NEW_LINE"}
{"text":"if character ch is present in str1 then check if it is present in str2","code":"if ( chr ( ch ) == str1 [ i ] ) : NEW_LINE for j in range ( indx2 , len2 ) : NEW_LINE"}
{"text":"if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub - sequenece","code":"if ( chr ( ch ) == str2 [ j ] and dp [ i ] [ j ] == lcslen - currlcs ) : NEW_LINE data [ currlcs ] = chr ( ch ) NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) NEW_LINE done = True NEW_LINE break NEW_LINE"}
{"text":"If we found LCS beginning with current character .","code":"if ( done ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"This function prints all LCS of str1 and str2 in lexicographic order .","code":"def prinlAllLCSSorted ( str1 , str2 ) : NEW_LINE INDENT global lcslen NEW_LINE DEDENT"}
{"text":"Find lengths of both strings","code":"len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE"}
{"text":"Find length of LCS","code":"lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) NEW_LINE"}
{"text":"Prall LCS using recursive backtracking data [ ] is used to store individual LCS .","code":"data = [ ' a ' for i in range ( MAX ) ] NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) NEW_LINE"}
{"text":"Driver program to run the case","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abcabcaa \" NEW_LINE str2 = \" acbacba \" NEW_LINE prinlAllLCSSorted ( str1 , str2 ) NEW_LINE DEDENT"}
{"text":"Python3 Program to check for majority element in a sorted array","code":"def isMajority ( arr , n , x ) : NEW_LINE"}
{"text":"get last index according to n ( even or odd )","code":"last_index = ( n \/\/ 2 + 1 ) if n % 2 == 0 else ( n \/\/ 2 ) NEW_LINE"}
{"text":"search for first occurrence of x in arr [ ]","code":"for i in range ( last_index ) : NEW_LINE"}
{"text":"check if x is present and is present more than n \/ 2 times","code":"if arr [ i ] == x and arr [ i + n \/\/ 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Driver program to check above function","code":"arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( \" % \u2581 d \u2581 appears \u2581 more \u2581 than \u2581 % \u2581 d \u2581 times \u2581 in \u2581 arr [ ] \" % ( x , n \/\/ 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" % \u2581 d \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 % \u2581 d \u2581 times \u2581 in \u2581 arr [ ] \" % ( x , n \/\/ 2 ) ) NEW_LINE DEDENT"}
{"text":"If x is present in arr [ low ... high ] then returns the index of first occurrence of x , otherwise returns - 1","code":"def _binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 NEW_LINE DEDENT DEDENT"}
{"text":"Check if arr [ mid ] is the first occurrence of x . arr [ mid ] is first occurrence if x is one of the following is true : ( i ) mid == 0 and arr [ mid ] = = x ( ii ) arr [ mid - 1 ] < x and arr [ mid ] == x","code":"if ( mid == 0 or x > arr [ mid - 1 ] ) and ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif x > arr [ mid ] : NEW_LINE INDENT return _binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return _binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT return - 1 NEW_LINE"}
{"text":"This function returns true if the x is present more than n \/ 2 times in arr [ ] of size n","code":"def isMajority ( arr , n , x ) : NEW_LINE"}
{"text":"Find the index of first occurrence of x in arr [ ]","code":"i = _binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE"}
{"text":"If element is not present at all , return false","code":"if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"check if the element is present more than n \/ 2 times","code":"if ( ( i + n \/\/ 2 ) <= ( n - 1 ) ) and arr [ i + n \/\/ 2 ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE if ( isMajorityElement ( arr , n , x ) ) : NEW_LINE INDENT print ( x , \" \u2581 appears \u2581 more \u2581 than \u2581 \" , n \/\/ 2 , \" \u2581 times \u2581 in \u2581 arr [ ] \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , \" \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \" , n \/\/ 2 , \" \u2581 times \u2581 in \u2581 arr [ ] \" ) NEW_LINE DEDENT DEDENT"}
{"text":"A Dynamic Programming solution for Rod cutting problem","code":"INT_MIN = - 32767 NEW_LINE"}
{"text":"Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces","code":"def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE DEDENT"}
{"text":"Build the table val [ ] in bottom up manner and return the last entry from the table","code":"for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE"}
{"text":"Driver program to test above functions","code":"arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + str ( cutRod ( arr , size ) ) ) NEW_LINE"}
{"text":"Function to check if the arr [ ] can be converted to target [ ] by replacing any element in arr [ ] by the sum of arr [ ]","code":"def isPossible ( target ) : NEW_LINE"}
{"text":"Store the maximum element","code":"INDENT max = 0 NEW_LINE DEDENT"}
{"text":"Store the index of the maximum element","code":"INDENT index = 0 NEW_LINE DEDENT"}
{"text":"Traverse the array target [ ]","code":"INDENT for i in range ( len ( target ) ) : NEW_LINE DEDENT"}
{"text":"If current element is greater than max","code":"if ( max < target [ i ] ) : NEW_LINE max = target [ i ] NEW_LINE index = i NEW_LINE"}
{"text":"If max element is 1","code":"INDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT"}
{"text":"Traverse the array , target [ ]","code":"INDENT for i in range ( len ( target ) ) : NEW_LINE DEDENT"}
{"text":"If current index is not equal to maximum element index","code":"if ( i != index ) : NEW_LINE"}
{"text":"Update max","code":"max -= target [ i ] NEW_LINE"}
{"text":"If max is less than or equal to 0 ,","code":"if ( max <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Update the maximum element","code":"INDENT target [ index ] = max NEW_LINE DEDENT"}
{"text":"Recursively call the function","code":"INDENT return isPossible ( target ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"target = [ 9 , 3 , 5 ] NEW_LINE res = isPossible ( target ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Function returns nCr i . e . Binomial Coefficient","code":"def nCr ( n , r ) : NEW_LINE"}
{"text":"Initialize res with 1","code":"res = 1 NEW_LINE"}
{"text":"Since C ( n , r ) = C ( n , n - r )","code":"if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT"}
{"text":"Evaluating expression","code":"for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/\/= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 NEW_LINE print ( nCr ( n + m , k ) ) NEW_LINE DEDENT"}
{"text":"Python Program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20","code":"import math NEW_LINE"}
{"text":"Function to check if N can be obtained or not","code":"def Is_possible ( N ) : NEW_LINE INDENT C = 0 NEW_LINE D = 0 NEW_LINE DEDENT"}
{"text":"Count and remove trailing zeroes","code":"while ( N % 10 == 0 ) : NEW_LINE INDENT N = N \/ 10 NEW_LINE C += 1 NEW_LINE DEDENT"}
{"text":"Check if remaining N is a power of 2","code":"if ( math . log ( N , 2 ) - int ( math . log ( N , 2 ) ) == 0 ) : NEW_LINE INDENT D = int ( math . log ( N , 2 ) ) NEW_LINE DEDENT"}
{"text":"To check the condition to print YES or NO","code":"if ( C >= D ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE print ( \" NO \" ) NEW_LINE"}
{"text":"Driver Program","code":"N = 2000000000000 NEW_LINE Is_possible ( N ) NEW_LINE"}
{"text":"Function to find N - th term in the series","code":"def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE"}
{"text":"Iterative function to reverse digits of num","code":"def rev ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num \/\/ 10 NEW_LINE DEDENT DEDENT"}
{"text":"Return the reversed num","code":"return rev_num NEW_LINE"}
{"text":"Function to calculate sum of reverse all proper divisors","code":"def divSum ( num ) : NEW_LINE"}
{"text":"Final result of summation of divisors","code":"result = 0 NEW_LINE"}
{"text":"Find all divisors of num","code":"for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE"}
{"text":"If ' i ' is divisor of 'num","code":"' NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE DEDENT"}
{"text":"If both divisors are same then add it only once else add both","code":"if ( i == ( num \/ i ) ) : NEW_LINE INDENT result += rev ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT result += ( rev ( i ) + rev ( num \/ i ) ) NEW_LINE DEDENT"}
{"text":"Add 1 to the result as 1 is also a divisor","code":"return ( result + 1 ) NEW_LINE"}
{"text":"Function to check if N is anti - perfect or not","code":"def isAntiPerfect ( n ) : NEW_LINE INDENT return divSum ( n ) == n NEW_LINE DEDENT"}
{"text":"Given Number N","code":"N = 244 NEW_LINE"}
{"text":"Function Call","code":"if ( isAntiPerfect ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to print the series","code":"def printSeries ( n , a , b , c ) : NEW_LINE"}
{"text":"Generate the ith term and print it","code":"if ( n == 1 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( a , b , end = \" \u2581 \" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( a , b , c , end = \" \u2581 \" ) ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = a + b + c ; NEW_LINE print ( d , end = \" \u2581 \" ) ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE c = d ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 7 ; a = 1 ; b = 3 ; NEW_LINE c = 4 ; NEW_LINE"}
{"text":"Function Call","code":"printSeries ( N , a , b , c ) ; NEW_LINE"}
{"text":"Function to find diameter of BIT with N + 1 nodes","code":"def diameter ( n ) : NEW_LINE"}
{"text":"L is size of subtree just before subtree in which N lies","code":"L , H , templen = 0 , 0 , 0 ; NEW_LINE L = 1 ; NEW_LINE"}
{"text":"H is the height of subtree just before subtree in which N lies","code":"H = 0 ; NEW_LINE"}
{"text":"Base Cases","code":"if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT"}
{"text":"Size of subtree are power of 2","code":"while ( L * 2 <= n ) : NEW_LINE INDENT L *= 2 ; NEW_LINE H += 1 ; NEW_LINE DEDENT"}
{"text":"3 Cases as explained in Approach","code":"if ( n >= L * 2 - 1 ) : NEW_LINE INDENT return 2 * H + 1 ; NEW_LINE DEDENT elif ( n >= L + ( L \/ 2 ) - 1 ) : NEW_LINE INDENT return 2 * H ; NEW_LINE DEDENT return 2 * H - 1 ; NEW_LINE"}
{"text":"Driver Code","code":"n = 15 ; NEW_LINE print ( diameter ( n ) ) ; NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"import math NEW_LINE"}
{"text":"Function to find whether a ^ b is greater or c ^ d","code":"def compareValues ( a , b , c , d ) : NEW_LINE"}
{"text":"Find b * log ( a )","code":"log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE"}
{"text":"Find d * log ( c )","code":"log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE"}
{"text":"Compare both values","code":"if num1 > num2 : NEW_LINE INDENT print ( a , ' ^ ' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , ' ^ ' , d ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"a = 8 NEW_LINE b = 29 NEW_LINE c = 60 NEW_LINE d = 59 NEW_LINE compareValues ( a , b , c , d ) NEW_LINE"}
{"text":"Python3 program for above approach","code":"MAX = 100005 NEW_LINE"}
{"text":"Find all prime numbers","code":"def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE DEDENT"}
{"text":"Store all prime numbers","code":"for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE"}
{"text":"Function to check if a digit is odd prime or not","code":"def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT"}
{"text":"Function to find sum","code":"def find_Sum ( n ) : NEW_LINE"}
{"text":"To store required answer","code":"Sum = 0 NEW_LINE"}
{"text":"Get all prime numbers","code":"v = addPrimes ( ) NEW_LINE"}
{"text":"Traverse through all the prime numbers","code":"for i in range ( len ( v ) ) : NEW_LINE"}
{"text":"Flag stores 1 if a number does not contain any odd primes","code":"flag = 1 NEW_LINE a = v [ i ] NEW_LINE"}
{"text":"Find all digits of a number","code":"while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a \/\/ 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"If number does not contain any odd primes","code":"if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Return the required answer","code":"return Sum NEW_LINE"}
{"text":"Driver code","code":"n = 7 NEW_LINE"}
{"text":"Function call","code":"print ( find_Sum ( n ) ) NEW_LINE"}
{"text":"Function to return the count of primes in the given array","code":"def primeCount ( arr , n ) : NEW_LINE"}
{"text":"Find maximum value in the array","code":"max_val = max ( arr ) NEW_LINE"}
{"text":"USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be False if i is Not a prime , else True .","code":"prime = [ True ] * ( max_val + 1 ) NEW_LINE"}
{"text":"Remaining part of SIEVE","code":"prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if prime [ p ] == True : NEW_LINE"}
{"text":"Update all multiples of p","code":"for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"Find all primes in arr [ ]","code":"count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE"}
{"text":"Function to generate the prefix array","code":"def getPrefixArray ( arr , n , pre ) : NEW_LINE"}
{"text":"Fill the prefix array","code":"pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT"}
{"text":"Prefix array of arr [ ]","code":"pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE"}
{"text":"Count of primes in the prefix array","code":"print ( primeCount ( pre , n ) ) NEW_LINE"}
{"text":"Python implementation of the approach","code":"import math NEW_LINE"}
{"text":"Function to return the required value that must be added to x so that it is at least y percent of n","code":"def minValue ( n , x , y ) : NEW_LINE"}
{"text":"Required value","code":"val = ( y * n ) \/ 100 NEW_LINE"}
{"text":"If x is already >= y percent of n","code":"if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 10 ; x = 2 ; y = 40 NEW_LINE print ( minValue ( n , x , y ) ) NEW_LINE"}
{"text":"Python3 program to check if given number is a factorial prime","code":"from math import sqrt NEW_LINE"}
{"text":"Utility function to check if a number is prime or not","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Function that returns true if n is a factorial prime","code":"def isFactorialPrime ( n ) : NEW_LINE"}
{"text":"If n is not prime then return false","code":"if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE"}
{"text":"Calculate factorial","code":"fact = fact * i NEW_LINE"}
{"text":"If n is a factorial prime","code":"if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"n is not a factorial prime","code":"return False NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Get n","code":"n = 5 NEW_LINE"}
{"text":"find fac1 = ( n - 1 ) !","code":"fac1 = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE DEDENT"}
{"text":"Find fac2 = n !","code":"fac2 = fac1 * n NEW_LINE"}
{"text":"Find total number of ways","code":"totalWays = fac1 * fac2 NEW_LINE"}
{"text":"Print the total number of ways","code":"print ( totalWays ) NEW_LINE"}
{"text":"Python 3 program to check Euclid Number","code":"MAX = 10000 NEW_LINE arr = [ ] NEW_LINE"}
{"text":"Function to generate prime numbers","code":"def SieveOfEratosthenes ( ) : NEW_LINE"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == True ) : NEW_LINE"}
{"text":"Update all multiples of p","code":"for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"store all prime numbers to vector 'arr","code":"' NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Function to check the number for Euclid Number","code":"def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE DEDENT"}
{"text":"Multiply next prime number and check if product + 1 = n holds or not","code":"product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE return False NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Get the prime numbers","code":"SieveOfEratosthenes ( ) NEW_LINE"}
{"text":"Get n","code":"n = 31 NEW_LINE"}
{"text":"Check if n is Euclid Number","code":"if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Get n","code":"n = 42 NEW_LINE"}
{"text":"Check if n is Euclid Number","code":"if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Python 3 implementation of above approach","code":"from math import * NEW_LINE"}
{"text":"Function to find the next perfect cube","code":"def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 \/ 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to find sum of prime divisors of N","code":"import math NEW_LINE"}
{"text":"Function to check if the number is prime or not .","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE"}
{"text":"function to find sum of prime divisors of N","code":"def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE DEDENT"}
{"text":"return type of sqrt function if float","code":"root_n = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root_n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT"}
{"text":"both factors are same","code":"if ( i == ( int ) ( n \/ i ) and isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE"}
{"text":"both factors are not same ( i and n \/ i )","code":"if ( isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT if ( isPrime ( ( int ) ( n \/ i ) ) ) : NEW_LINE INDENT Sum += ( int ) ( n \/ i ) NEW_LINE DEDENT return Sum NEW_LINE"}
{"text":"Driver code","code":"n = 60 NEW_LINE print ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \" , SumOfPrimeDivisors ( n ) ) NEW_LINE"}
{"text":"Program position of n among the numbers made of 2 , 3 , 5 & 7","code":"def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE DEDENT"}
{"text":"If number is 2 then it is on the position pos * 2 + 1","code":"if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT"}
{"text":"If number is 3 then it is on the position pos * 2 + 2","code":"elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT"}
{"text":"If number is 5 then it is on the position pos * 2 + 3","code":"elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT"}
{"text":"If number is 7 then it is on the position pos * 2 + 4","code":"elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT return pos NEW_LINE"}
{"text":"Driver code","code":"n = \"777\" NEW_LINE print ( findpos ( n ) ) NEW_LINE"}
{"text":"Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt","code":"def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE DEDENT"}
{"text":"Case 1 : Less than 3 numbers between L and R","code":"if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT"}
{"text":"Case 2 : More than 3 numbers between L and R","code":"elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE DEDENT"}
{"text":"triplets should always be of form ( 2 k , 2 k + 1 , 2 k + 2 )","code":"if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE else : NEW_LINE"}
{"text":"Case 3.1 : Exactly 3 numbers in range of form ( 2 k , 2 k + 1 , 2 k + 2 )","code":"if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Case 3.2 : Exactly 3 numbers in range of form ( 2 k - 1 , 2 k , 2 k + 1 )","code":"flag = False ; NEW_LINE"}
{"text":"flag = True indicates that a pair exists between L and R","code":"if ( flag == True ) : NEW_LINE INDENT print ( \" ( \" , possibleA , \" , \" , possibleB , \" , \" , possibleC , \" ) \u2581 is \u2581 one \u2581 such \" , \" possible \u2581 triplet \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Such \u2581 Triplet \u2581 exists \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT"}
{"text":"finding possible Triplet between 2 and 10","code":"L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE"}
{"text":"finding possible Triplet between 23 and 46","code":"L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE"}
{"text":"Python Implementation of above method","code":"mod = 1000000007 NEW_LINE"}
{"text":"Finding number of possible number with n digits excluding a particular digit","code":"def digitNumber ( n ) : NEW_LINE"}
{"text":"Checking if number of digits is zero","code":"if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Checking if number of digits is one","code":"if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT"}
{"text":"Checking if number of digits is odd","code":"if ( n % 2 != 0 ) : NEW_LINE"}
{"text":"Calling digitNumber function with ( digit - 1 ) \/ 2 digits","code":"temp = digitNumber ( ( n - 1 ) \/\/ 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE else : NEW_LINE"}
{"text":"Calling digitNumber function with n \/ 2 digits","code":"temp = digitNumber ( n \/\/ 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE def countExcluding ( n , d ) : NEW_LINE"}
{"text":"Calling digitNumber function Checking if excluding digit is zero or non - zero","code":"if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT"}
{"text":"Initializing variables","code":"d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE"}
{"text":"Returns true if n is prime . Else false .","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner case","code":"if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Check from 2 to n - 1","code":"for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Function will check whether number is Emirp or not","code":"def isEmirp ( n ) : NEW_LINE"}
{"text":"Check if n is prime","code":"n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Find reverse of n","code":"rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n \/ 10 ) NEW_LINE DEDENT"}
{"text":"If both Original and Reverse are Prime , then it is an Emirp number","code":"return isPrime ( rev ) NEW_LINE"}
{"text":"Input number","code":"n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function for convertion","code":"def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 \/ pi ) NEW_LINE return degree NEW_LINE DEDENT"}
{"text":"Driver Code","code":"radian = 5 NEW_LINE print ( \" degree \u2581 = \" , ( Convert ( radian ) ) ) NEW_LINE"}
{"text":"Return sum of first n integers of an AP","code":"def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) \/ 2 ; NEW_LINE DEDENT"}
{"text":"Return the trace of sum of row - major matrix and column - major matrix","code":"def trace ( n , m ) : NEW_LINE"}
{"text":"Finding nth element in AP in case of Row major matrix .","code":"an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE"}
{"text":"Finding sum of first n integers of AP in case of Row major matrix","code":"rowmajorSum = sn ( n , an ) ; NEW_LINE"}
{"text":"Finding nth element in AP in case of Row major matrix","code":"an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE"}
{"text":"Finding sum of first n integers of AP in case of Column major matrix","code":"colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE"}
{"text":"Driver Code","code":"N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE"}
{"text":"Utility Function","code":"def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) NEW_LINE DEDENT else : NEW_LINE DEDENT"}
{"text":"for the 1 st case","code":"if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n \/ ( k + 1 ) ) , n * ( m \/ ( k + 1 ) ) ) ; NEW_LINE DEDENT"}
{"text":"for the second case","code":"else : NEW_LINE INDENT result = max ( m \/ ( k - n + 2 ) , n \/ ( k - m + 2 ) ) ; NEW_LINE DEDENT"}
{"text":"print final result","code":"print ( result ) NEW_LINE"}
{"text":"driver code","code":"n = 3 NEW_LINE m = 4 NEW_LINE k = 1 NEW_LINE max_area ( n , m , k ) NEW_LINE"}
{"text":"function to find the area","code":"def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT"}
{"text":"Driver program","code":"side = 4 NEW_LINE area = area_fun ( side ) NEW_LINE print ( area ) NEW_LINE"}
{"text":"Utility method to compute number of ways in which N can be represented as sum of consecutive number","code":"def countConsecutive ( N ) : NEW_LINE"}
{"text":"constraint on values of L gives us the time Complexity as O ( N ^ 0.5 )","code":"count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) \/ 2 ) \/ ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE"}
{"text":"Driver code","code":"N = 15 NEW_LINE print countConsecutive ( N ) NEW_LINE N = 10 NEW_LINE print countConsecutive ( N ) NEW_LINE"}
{"text":"Function to check Automorphic number","code":"def isAutomorphic ( N ) : NEW_LINE"}
{"text":"Store the square","code":"sq = N * N NEW_LINE"}
{"text":"Start Comparing digits","code":"while ( N > 0 ) : NEW_LINE"}
{"text":"Return false , if any digit of N doesn ' t \u2581 \u2581 match \u2581 with \u2581 its \u2581 square ' s digits from last","code":"if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Reduce N and square","code":"N \/= 10 NEW_LINE sq \/= 10 NEW_LINE return True NEW_LINE"}
{"text":"Driver code","code":"N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print \" Automorphic \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Not \u2581 Automorphic \" NEW_LINE DEDENT"}
{"text":"Return smallest number having maximum prime factors .","code":"def maxPrimefactorNum ( N ) : NEW_LINE"}
{"text":"default value of boolean is false","code":"arr = [ True ] * ( N + 5 ) ; NEW_LINE"}
{"text":"Sieve of eratosthenes","code":"i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT"}
{"text":"Storing prime numbers .","code":"prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Generating number having maximum prime factors .","code":"i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE"}
{"text":"Driver Code","code":"N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE"}
{"text":"PYTHON program to find sum of all divisors of a natural number","code":"import math NEW_LINE"}
{"text":"Function to calculate sum of all proper divisors num -- > given natural number","code":"def divSum ( num ) : NEW_LINE"}
{"text":"Final result of summation of divisors","code":"result = 0 NEW_LINE"}
{"text":"find all divisors which divides 'num","code":"' NEW_LINE INDENT i = 2 NEW_LINE while i <= ( math . sqrt ( num ) ) : NEW_LINE DEDENT"}
{"text":"if ' i ' is divisor of 'num","code":"' NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE DEDENT"}
{"text":"if both divisors are same then add it only once else add both","code":"if ( i == ( num \/ i ) ) : NEW_LINE INDENT result = result + i ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + num \/ i ) ; NEW_LINE DEDENT i = i + 1 NEW_LINE"}
{"text":"Add 1 to the result as 1 is also a divisor","code":"return ( result + 1 ) ; NEW_LINE"}
{"text":"Driver program to run the case","code":"num = 36 NEW_LINE print ( divSum ( num ) ) NEW_LINE"}
{"text":"Utility function to do modular exponentiation . It returns ( x ^ y ) % p .","code":"def power ( x , y , p ) : NEW_LINE"}
{"text":"res = 1 Initialize result x = x % p Update x if it is more than or equal to p","code":"while ( y > 0 ) : NEW_LINE"}
{"text":"If y is odd , multiply x with result","code":"if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT"}
{"text":"y must be even now y = y >> 1 y = y \/ 2","code":"x = ( x * x ) % p NEW_LINE return res NEW_LINE"}
{"text":"Returns true if square root of n under modulo p exists . Assumption : p is of the form 3 * i + 4 where i >= 1","code":"def squareRoot ( n , p ) : NEW_LINE INDENT if ( p % 4 != 3 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return NEW_LINE DEDENT DEDENT"}
{"text":"Try \" + ( n ^ ( ( p \u2581 + \u2581 1 ) \/ 4 ) ) \"","code":"n = n % p NEW_LINE x = power ( n , ( p + 1 ) \/\/ 4 , p ) NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( \" Square \u2581 root \u2581 is \u2581 \" , x ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Try \" - ( n \u2581 ^ \u2581 ( ( p \u2581 + \u2581 1 ) \/ 4 ) ) \"","code":"x = p - x NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( \" Square \u2581 root \u2581 is \u2581 \" , x ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"If none of the above two work , then square root doesn 't exist","code":"print ( \" Square \u2581 root \u2581 doesn ' t \u2581 exist \u2581 \" ) NEW_LINE"}
{"text":"Driver Code","code":"p = 7 NEW_LINE n = 2 NEW_LINE squareRoot ( n , p ) NEW_LINE"}
{"text":"Python3 program Miller - Rabin primality test","code":"import random NEW_LINE"}
{"text":"Utility function to do modular exponentiation . It returns ( x ^ y ) % p","code":"def power ( x , y , p ) : NEW_LINE"}
{"text":"Initialize result","code":"res = 1 ; NEW_LINE"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE"}
{"text":"If y is odd , multiply x with result","code":"if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT"}
{"text":"y must be even now y = y >> 1 ; y = y \/ 2","code":"x = ( x * x ) % p ; NEW_LINE return res ; NEW_LINE"}
{"text":"This function is called for all k trials . It returns false if n is composite and returns false if n is probably prime . d is an odd number such that d * 2 < sup > r < \/ sup > = n - 1 for some r >= 1","code":"def miillerTest ( d , n ) : NEW_LINE"}
{"text":"Pick a random number in [ 2. . n - 2 ] Corner cases make sure that n > 4","code":"a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE"}
{"text":"Compute a ^ d % n","code":"x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT"}
{"text":"Keep squaring x while one of the following doesn 't  happen  (i) d does not reach n-1  (ii) (x^2) % n is not 1  (iii) (x^2) % n is not n-1","code":"while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT"}
{"text":"Return composite","code":"return False ; NEW_LINE"}
{"text":"It returns false if n is composite and returns true if n is probably prime . k is an input parameter that determines accuracy level . Higher value of k indicates more accuracy .","code":"def isPrime ( n , k ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT"}
{"text":"Find r such that n = 2 ^ d * r + 1 for some r >= 1","code":"d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d \/\/= 2 ; NEW_LINE DEDENT"}
{"text":"Iterate given nber of ' k ' times","code":"for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE"}
{"text":"Driver Code Number of iterations","code":"k = 4 ; NEW_LINE print ( \" All \u2581 primes \u2581 smaller \u2581 than \u2581 100 : \u2581 \" ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Function to find length of the longest consecutive 1 s in binary representation of a number","code":"def maxConsecutiveOnes ( x ) : NEW_LINE"}
{"text":"Initialize result","code":"count = 0 NEW_LINE"}
{"text":"Count the number of iterations to reach x = 0.","code":"while ( x != 0 ) : NEW_LINE"}
{"text":"This operation reduces length of every sequence of 1 s by one .","code":"x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE return count NEW_LINE"}
{"text":"Driver code","code":"print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE"}
{"text":"Python program to Subtract two numbers without using arithmetic operators","code":"def subtract ( x , y ) : NEW_LINE"}
{"text":"Iterate till there is no carry","code":"while ( y != 0 ) : NEW_LINE"}
{"text":"borrow contains common set bits of y and unset bits of x","code":"borrow = ( ~ x ) & y NEW_LINE"}
{"text":"Subtraction of bits of x and y where at least one of the bits is not set","code":"x = x ^ y NEW_LINE"}
{"text":"Borrow is shifted by one so that subtracting it from x gives the required sum","code":"y = borrow << 1 NEW_LINE return x NEW_LINE"}
{"text":"Driver Code","code":"x = 29 NEW_LINE y = 13 NEW_LINE print ( \" x \u2581 - \u2581 y \u2581 is \" , subtract ( x , y ) ) NEW_LINE"}
{"text":"Python Program to subtract two Number without using arithmetic operator Recursive implementation .","code":"def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT"}
{"text":"Driver program","code":"x = 29 NEW_LINE y = 13 NEW_LINE print ( \" x \u2581 - \u2581 y \u2581 is \" , subtract ( x , y ) ) NEW_LINE"}
{"text":"Function to add an edge in the tree","code":"def addEdge ( v , x , y ) : NEW_LINE INDENT v [ x ] . append ( y ) NEW_LINE v [ y ] . append ( x ) NEW_LINE DEDENT"}
{"text":"DFS to find the Kth ancestor of every node","code":"def dfs ( tree , temp , ancestor , u , parent , k ) : NEW_LINE"}
{"text":"Pushing current node in the vector","code":"temp . append ( u ) NEW_LINE"}
{"text":"Traverse its neighbors","code":"for i in tree [ u ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( tree , temp , ancestor , i , u , k ) NEW_LINE DEDENT temp . pop ( ) NEW_LINE"}
{"text":"If K ancestors are not found for current node","code":"if ( len ( temp ) < k ) : NEW_LINE INDENT ancestor [ u ] = - 1 NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Add the Kth ancestor for the node","code":"ancestor [ u ] = temp [ len ( temp ) - k ] NEW_LINE"}
{"text":"Function to find Kth ancestor of each node","code":"def KthAncestor ( N , K , E , edges ) : NEW_LINE"}
{"text":"Building the tree","code":"tree = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT"}
{"text":"Stores all parents of a node","code":"temp = [ ] NEW_LINE"}
{"text":"Store Kth ancestor of all nodes","code":"ancestor = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( tree , temp , ancestor , 1 , 0 , K ) NEW_LINE"}
{"text":"Print the ancestors","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ancestor [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given N and K","code":"N = 9 NEW_LINE K = 2 NEW_LINE"}
{"text":"Given edges of n - ary tree","code":"E = 8 NEW_LINE edges = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 7 ] , [ 3 , 8 ] , [ 3 , 9 ] ] NEW_LINE"}
{"text":"Function call","code":"KthAncestor ( N , K , E , edges ) NEW_LINE"}
{"text":"Function to build a segment tree","code":"def build ( sum , a , l , r , rt ) : NEW_LINE"}
{"text":"Check for base case","code":"if ( l == r ) : NEW_LINE INDENT sum [ rt ] = a [ l - 1 ] NEW_LINE return NEW_LINE DEDENT"}
{"text":"Find mid point","code":"m = ( l + r ) >> 1 NEW_LINE"}
{"text":"Recursively build the segment tree","code":"build ( sum , a , l , m , rt << 1 ) NEW_LINE build ( sum , a , m + 1 , r , rt << 1 1 ) NEW_LINE"}
{"text":"Function for push down operation on the segment tree","code":"def pushDown ( sum , add , rt , ln , rn ) : NEW_LINE INDENT if ( add [ rt ] ) : NEW_LINE INDENT add [ rt << 1 ] += add [ rt ] NEW_LINE add [ rt << 1 1 ] += add [ rt ] NEW_LINE sum [ rt << 1 ] += add [ rt ] * ln NEW_LINE sum [ rt << 1 1 ] += add [ rt ] * rn NEW_LINE add [ rt ] = 0 NEW_LINE DEDENT DEDENT"}
{"text":"Function to update the segment tree","code":"def update ( sum , add , L , R , C , l , r , rt ) : NEW_LINE"}
{"text":"Complete overlap","code":"if ( L <= l and r <= R ) : NEW_LINE INDENT sum [ rt ] += C * ( r - l + 1 ) NEW_LINE add [ rt ] += C NEW_LINE return NEW_LINE DEDENT"}
{"text":"Find mid","code":"m = ( l + r ) >> 1 NEW_LINE"}
{"text":"Perform push down operation on segment tree","code":"pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE"}
{"text":"Recursively update the segment tree","code":"if ( L <= m ) : NEW_LINE INDENT update ( sum , add , L , R , C , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT"}
{"text":"Function to process the queryy","code":"def queryy ( sum , add , L , R , l , r , rt ) : NEW_LINE"}
{"text":"Base case","code":"if ( L <= l and r <= R ) : NEW_LINE INDENT return sum [ rt ] NEW_LINE DEDENT"}
{"text":"Find mid","code":"m = ( l + r ) >> 1 NEW_LINE"}
{"text":"Perform push down operation on segment tree","code":"pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE ans = 0 NEW_LINE"}
{"text":"Recursively calculate the result of the queryy","code":"if ( L <= m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , m + 1 , r , ( rt << 1 1 ) ) NEW_LINE DEDENT"}
{"text":"Return the result","code":"return ans NEW_LINE"}
{"text":"Function to count the numbers which are greater than the given queryy","code":"def sequenceMaintenance ( n , q , a , b , m ) : NEW_LINE"}
{"text":"Sort the input array","code":"a = sorted ( a ) NEW_LINE"}
{"text":"Create segment tree of size 4 * n vector < int > sum , add , ans","code":"sum = [ 0 ] * ( 4 * n ) NEW_LINE add = [ 0 ] * ( 4 * n ) NEW_LINE ans = [ ] NEW_LINE"}
{"text":"Build the segment tree","code":"build ( sum , a , 1 , n , 1 ) NEW_LINE"}
{"text":"Iterate over the queries","code":"for i in range ( q ) : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE pos = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( queryy ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) : NEW_LINE INDENT r = m - 1 NEW_LINE pos = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE DEDENT"}
{"text":"Store result in array","code":"ans . append ( n - pos + 1 ) NEW_LINE"}
{"text":"Update the elements in the given range","code":"update ( sum , add , pos , n , - m , 1 , n , 1 ) NEW_LINE"}
{"text":"Print the result of queries","code":"for i in ans : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE Q = 3 NEW_LINE M = 1 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE query = [ 4 , 3 , 1 ] NEW_LINE DEDENT"}
{"text":"Function call","code":"sequenceMaintenance ( N , Q , arr , query , M ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to find the final array length by replacing coprime pair with 1","code":"def hasCoprimePair ( arr , n ) : NEW_LINE"}
{"text":"Iterate over all pairs of element","code":"for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT"}
{"text":"Check if gcd is 1","code":"if ( math . gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"If no coprime pair found return false","code":"return False NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE arr = [ 6 , 9 , 15 ] NEW_LINE DEDENT"}
{"text":"Check if atleast one coprime pair exists in the array","code":"if ( hasCoprimePair ( arr , n ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT"}
{"text":"If no such pair exists","code":"else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT"}
{"text":"Function to return the required number of ways","code":"def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Check if a , b , c can form a triangle","code":"if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Return number of ways","code":"return count ; NEW_LINE"}
{"text":"Driver code","code":"n = 15 NEW_LINE print ( Numberofways ( n ) ) NEW_LINE"}
{"text":"Function to print the count of pair","code":"def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT"}
{"text":"Iterate over all the elements of the array","code":"for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE DEDENT"}
{"text":"Increment the count","code":"count += 1 NEW_LINE"}
{"text":"Print the result","code":"print ( count \/\/ 2 ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( N , arr ) NEW_LINE DEDENT"}
{"text":"Function to return the max Length of Fibonacci subsequence","code":"def LongestFibSubseq ( A , n ) : NEW_LINE"}
{"text":"Store all array elements in a hash table","code":"S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE DEDENT DEDENT"}
{"text":"check until next fib element is found","code":"while y in S : NEW_LINE"}
{"text":"next element of fib subseq","code":"z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE return maxLen if maxLen >= 3 else 0 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT"}
{"text":"Function to count maximum number of elements that can be selected","code":"def CountMaximum ( arr , n , k ) : NEW_LINE"}
{"text":"Sort he array","code":"arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( 0 , n ) : NEW_LINE"}
{"text":"Add current element to the sum","code":"Sum += arr [ i ] NEW_LINE"}
{"text":"IF sum exceeds k","code":"if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Increment count","code":"count += 1 NEW_LINE"}
{"text":"Return the count","code":"return count NEW_LINE"}
{"text":"Driver code","code":"arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE"}
{"text":"Function call","code":"print ( CountMaximum ( arr , n , k ) ) NEW_LINE"}
{"text":"Function to find number of candy types","code":"def num_candyTypes ( candies ) : NEW_LINE"}
{"text":"Declare a hashset to store candies","code":"s = set ( ) NEW_LINE"}
{"text":"Traverse the given array and inserts element into set","code":"for i in range ( len ( candies ) ) : NEW_LINE INDENT s . add ( candies [ i ] ) NEW_LINE DEDENT"}
{"text":"Return the result","code":"return len ( s ) NEW_LINE"}
{"text":"Function to find maximum number of types of candies a person can eat","code":"def distribute_candies ( candies ) : NEW_LINE"}
{"text":"Store the number of candies allowed to eat","code":"allowed = len ( candies ) \/ 2 NEW_LINE"}
{"text":"Store the number of candy types","code":"types = num_candyTypes ( candies ) NEW_LINE"}
{"text":"Return the result","code":"if ( types < allowed ) : NEW_LINE INDENT print ( int ( types ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( allowed ) ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Input","code":"candies = [ 4 , 4 , 5 , 5 , 3 , 3 ] NEW_LINE"}
{"text":"Function Call","code":"distribute_candies ( candies ) NEW_LINE"}
{"text":"Python Program to implement the above approach","code":"import math NEW_LINE"}
{"text":"Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle","code":"def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT"}
{"text":"Driver Code","code":"A = 6 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonals ( A , theta ) NEW_LINE print ( round ( ans [ 0 ] , 2 ) , round ( ans [ 1 ] , 2 ) ) NEW_LINE"}
{"text":"Function to store EVEN and odd variable","code":"def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE DEDENT"}
{"text":"Store the count of even and odd set bit","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Count the set bit using in built function","code":"x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT"}
{"text":"Count of set - bit of K","code":"y = bin ( K ) . count ( '1' ) ; NEW_LINE"}
{"text":"If y is odd then , count of even and odd set bit will be interchanged","code":"if ( y & 1 ) : NEW_LINE INDENT print ( \" Even \u2581 = \" , odd , \" , \u2581 Odd \u2581 = \" , even ) ; NEW_LINE DEDENT"}
{"text":"Else it will remain same as the original array","code":"else : NEW_LINE INDENT print ( \" Even \u2581 = \" , even , \" , \u2581 Odd \u2581 = \" , odd ) ; NEW_LINE DEDENT"}
{"text":"Driver 's Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE DEDENT"}
{"text":"Function call to count even and odd","code":"countEvenOdd ( arr , n , K ) ; NEW_LINE"}
{"text":"Driver code","code":"N = 6 NEW_LINE Even = N \/\/ 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE"}
{"text":"Python 3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing","code":"def longestSubSequence ( A , N , ind = 0 , lastf = - sys . maxsize - 1 , lasts = sys . maxsize ) : NEW_LINE"}
{"text":"Base case","code":"if ( ind == N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Not include the current pair in the longest subsequence","code":"ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) NEW_LINE"}
{"text":"Including the current pair in the longest subsequence","code":"if ( A [ ind ] [ 0 ] > lastf and A [ ind ] [ 1 ] < lasts ) : NEW_LINE INDENT ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given Input","code":"A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE"}
{"text":"Function Call","code":"print ( longestSubSequence ( A , N ) ) NEW_LINE"}
{"text":"Function to find the number of triplets whose Bitwise AND is 0.","code":"def countTriplets ( A ) : NEW_LINE"}
{"text":"Stores the count of triplets having bitwise AND equal to 0","code":"cnt = 0 ; NEW_LINE"}
{"text":"Stores frequencies of all possible A [ i ] & A [ j ]","code":"tuples = { } ; NEW_LINE"}
{"text":"Traverse the array","code":"for a in A : NEW_LINE"}
{"text":"Update frequency of Bitwise AND of all array elements with a","code":"for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Traverse the array","code":"for a in A : NEW_LINE"}
{"text":"Iterate the map","code":"for t in tuples : NEW_LINE"}
{"text":"If bitwise AND of triplet is zero , increment cnt","code":"if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT"}
{"text":"Return the number of triplets whose Bitwise AND is 0.","code":"return cnt ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Input Array","code":"A = [ 2 , 1 , 3 ] ; NEW_LINE"}
{"text":"Function Call","code":"print ( countTriplets ( A ) ) ; NEW_LINE"}
{"text":"Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed","code":"def CountWays ( n ) : NEW_LINE"}
{"text":"noOfWays [ i ] will store count for value i . 3 extra values are to take care of corner case n = 0","code":"noOfWays = [ 0 ] * ( n + 3 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE"}
{"text":"Loop till \" n + 1\" to compute value for \" n \"","code":"for i in range ( 3 , n + 1 ) : NEW_LINE"}
{"text":"number of ways if first run is 1 + number of ways if first run is 2 and second run is 1","code":"noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] NEW_LINE return noOfWays [ n ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to check if player A wins the game or not","code":"def findWinner ( a , n ) : NEW_LINE"}
{"text":"Stores size of the groups of 0 s","code":"v = [ ] NEW_LINE"}
{"text":"Stores size of the group of 0 s","code":"c = 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( 0 , n ) : NEW_LINE"}
{"text":"Increment c by 1 if a [ i ] is 0","code":"if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT"}
{"text":"Otherwise , push the size in array and reset c to 0","code":"else : NEW_LINE INDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT c = 0 NEW_LINE DEDENT if ( c != 0 ) : NEW_LINE v . append ( c ) NEW_LINE"}
{"text":"If there is no substring of odd length consisting only of 0 s","code":"if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( \" Player \u2581 B \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"If there is only 1 substring of odd length consisting only of 0 s","code":"if ( len ( v ) == 1 ) : NEW_LINE INDENT if ( ( v [ 0 ] & 1 ) != 0 ) : NEW_LINE INDENT print ( \" Player \u2581 A \" , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT print ( \" Player \u2581 B \" , end = \" \" ) NEW_LINE DEDENT return NEW_LINE"}
{"text":"Stores the size of the largest and second largest substrings of 0 s","code":"first = sys . minsize NEW_LINE second = sys . minsize NEW_LINE"}
{"text":"Traverse the array v [ ]","code":"for i in range ( len ( v ) ) : NEW_LINE"}
{"text":"If current element is greater than first , then update both first and second","code":"if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT"}
{"text":"If arr [ i ] is in between first and second , then update second","code":"elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT"}
{"text":"If the condition is satisfied","code":"if ( ( ( first & 1 ) != 0 ) and ( first + 1 ) \/\/ 2 > second ) : NEW_LINE INDENT print ( \" Player \u2581 A \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Player \u2581 B \" , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"S = \"1100011\" NEW_LINE N = len ( S ) NEW_LINE findWinner ( S , N ) NEW_LINE"}
{"text":"Function to check whether the is K palindrome or not","code":"def can_Construct ( S , K ) : NEW_LINE"}
{"text":"map to frequency of character","code":"m = dict ( ) NEW_LINE p = 0 NEW_LINE"}
{"text":"Check when k is given as same as length of string","code":"if ( len ( S ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"Storing the frequency of every character in map","code":"for i in S : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT"}
{"text":"If K is greater than size of then return false","code":"if ( K > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Check that number of character having the odd frequency","code":"for h in m : NEW_LINE INDENT if ( m [ h ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT"}
{"text":"If k is less than number of odd frequency character then it is again false otherwise true","code":"if ( K < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" annabelle \" NEW_LINE K = 4 NEW_LINE if ( can_Construct ( S , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to compare two strings ignoring their cases","code":"def equalIgnoreCase ( str1 , str2 ) : NEW_LINE"}
{"text":"Convert to lower case","code":"str1 = str1 . lower ( ) ; NEW_LINE str2 = str2 . lower ( ) ; NEW_LINE"}
{"text":"Comparing both","code":"x = str1 == str2 ; NEW_LINE"}
{"text":"if strings are equal , return true otherwise false","code":"return x ; NEW_LINE"}
{"text":"Function to print the same or not same if strings are equal or not equal","code":"def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Same \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" Geeks \" ; NEW_LINE str2 = \" geeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = \" Geek \" ; NEW_LINE str2 = \" geeksforgeeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT"}
{"text":"Python3 program to print Step Pattern","code":"import math as mt NEW_LINE"}
{"text":"function to print the steps","code":"def steps ( string , n ) : NEW_LINE"}
{"text":"declare a flag","code":"flag = False NEW_LINE x = 0 NEW_LINE"}
{"text":"traverse through all the characters in the string","code":"for i in range ( len ( string ) ) : NEW_LINE"}
{"text":"if the x value is 0. . then we must increment till n ... set flag to true","code":"if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT"}
{"text":"if the x value is n - 1 then we must decrement till 0 ... set flag as false","code":"if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT"}
{"text":"print x * s","code":"for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE"}
{"text":"checking whether to increment or decrement x","code":"if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT"}
{"text":"Get the String and the number n","code":"n = 4 NEW_LINE string = \" GeeksForGeeks \" NEW_LINE print ( \" String : \u2581 \" , string ) NEW_LINE print ( \" Max \u2581 Length \u2581 of \u2581 Steps : \u2581 \" , n ) NEW_LINE"}
{"text":"calling the function","code":"steps ( string , n ) NEW_LINE"}
{"text":"Python program to count frequencies of array items","code":"def countFreq ( arr , n ) : NEW_LINE"}
{"text":"mark all array elements as not visited","code":"visited = [ False for i in range ( n ) ] NEW_LINE"}
{"text":"Traverse through array elements and count frequencies","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Skip this element if already processed","code":"if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"count frequency","code":"count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE"}
{"text":"Driver code","code":"a = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE"}
{"text":"function to check whether given binary number is evenly divisible by 2 ^ k or not","code":"def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE DEDENT"}
{"text":"count of number of 0 from last","code":"for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT"}
{"text":"if count = k , number is evenly divisible , so returns true else false","code":"return ( c == k ) NEW_LINE"}
{"text":"first example","code":"str1 = \"10101100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Second example","code":"str2 = \"111010100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python program to Check if any anagram of a string is palindrome or not","code":"NO_OF_CHARS = 256 NEW_LINE"}
{"text":"function to check whether characters of a string can form a palindrome","code":"def canFormPalindrome ( string ) : NEW_LINE"}
{"text":"Create a count array and initialize all values as 0","code":"count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE"}
{"text":"For each character in input strings , increment count in the corresponding count array","code":"for i in string : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT"}
{"text":"Count odd occurring characters","code":"odd = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Return true if odd count is 0 or 1 ,","code":"return True NEW_LINE"}
{"text":"Driver program to test to print printDups","code":"if ( canFormPalindrome ( \" geeksforgeeks \" ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT if ( canFormPalindrome ( \" geeksogeeks \" ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" NO \" NEW_LINE DEDENT"}
{"text":"This function Returns true if s is a number else false","code":"def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) != True : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Store the input in a str variable","code":"str = \"6790\" NEW_LINE"}
{"text":"Function returns 1 if all elements are in range '0 \u2581 - \u2581 9'","code":"if isNumber ( str ) : NEW_LINE INDENT print ( \" Integer \" ) NEW_LINE DEDENT"}
{"text":"Function returns 0 if the input is not an integer","code":"else : NEW_LINE INDENT print ( \" String \" ) NEW_LINE DEDENT"}
{"text":"Function to print reverse of the passed string","code":"def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = ' ' ) NEW_LINE DEDENT"}
{"text":"Driver program to test above function","code":"string = \" Geeks \u2581 for \u2581 Geeks \" NEW_LINE reverse ( string ) NEW_LINE"}
{"text":"Stores the count of distinct colors in box1","code":"box1 = 0 NEW_LINE"}
{"text":"Stores the count of distinct colors in box2","code":"box2 = 0 NEW_LINE fact = [ 0 for i in range ( 11 ) ] NEW_LINE"}
{"text":"Function to calculate the required probability","code":"def getProbability ( balls ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE DEDENT"}
{"text":"Calculate factorial from [ 1 , 10 ]","code":"factorial ( 10 ) NEW_LINE"}
{"text":"Assign all distinct balls to second box","code":"box2 = len ( balls ) NEW_LINE"}
{"text":"Total number of balls","code":"K = 0 NEW_LINE"}
{"text":"Calculate total number of balls","code":"for i in range ( len ( balls ) ) : NEW_LINE INDENT K += balls [ i ] NEW_LINE DEDENT"}
{"text":"If K is an odd number","code":"if ( K % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Total ways of distributing the balls in two equal halves","code":"all = comb ( K , K \/\/ 2 ) NEW_LINE"}
{"text":"Required number of ways","code":"validPermutation = validPermutations ( K \/\/ 2 , balls , 0 , 0 ) NEW_LINE"}
{"text":"Return the required probability","code":"return validPermutation \/ all NEW_LINE"}
{"text":"Function to calculate total number of possible distributions which satisfies the given conditions","code":"def validPermutations ( n , balls , usedBalls , i ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE DEDENT"}
{"text":"If used balls is equal to K \/ 2","code":"if ( usedBalls == n ) : NEW_LINE"}
{"text":"If box1 is equal to box2","code":"if ( box1 == box2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Base condition","code":"if ( i >= len ( balls ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Stores the number of ways of distributing remaining balls without including the current balls in box1","code":"res = validPermutations ( n , balls , usedBalls , i + 1 ) NEW_LINE"}
{"text":"Increment box1 by one","code":"box1 += 1 NEW_LINE"}
{"text":"Iterate over the range [ 1 , balls [ i ] ]","code":"for j in range ( 1 , balls [ i ] + 1 ) : NEW_LINE"}
{"text":"If all the balls goes to box1 , then decrease box2 by one","code":"if ( j == balls [ i ] ) : NEW_LINE INDENT box2 -= 1 NEW_LINE DEDENT"}
{"text":"Total number of ways of selecting j balls","code":"combinations = comb ( balls [ i ] , j ) NEW_LINE"}
{"text":"Increment res by total number of valid ways of distributing the remaining balls","code":"res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 ) NEW_LINE"}
{"text":"Decrement box1 by one","code":"box1 -= 1 NEW_LINE"}
{"text":"Increment box2 by 1","code":"box2 += 1 NEW_LINE return res NEW_LINE"}
{"text":"Function to calculate factorial of N","code":"def factorial ( N ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE DEDENT"}
{"text":"Base Case","code":"fact [ 0 ] = 1 NEW_LINE"}
{"text":"Iterate over the range [ 1 , N ]","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT"}
{"text":"Function to calculate NcR","code":"def comb ( n , r ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE res = fact [ n ] \/\/ fact [ r ] NEW_LINE res \/\/= fact [ n - r ] NEW_LINE return res NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 2 , 1 , 1 ] NEW_LINE N = 4 NEW_LINE"}
{"text":"Print the result","code":"print ( getProbability ( arr ) ) NEW_LINE"}
{"text":"Python3 Program to find the area of a regular polygon with given radius","code":"from math import sin NEW_LINE"}
{"text":"Function to find the area of a regular polygon","code":"def polyarea ( n , r ) : NEW_LINE"}
{"text":"Side and radius cannot be negative","code":"if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Area degree converted to radians","code":"A = ( ( ( r * r * n ) * sin ( ( 360 \/ n ) * 3.14159 \/ 180 ) ) \/ 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"}
{"text":"Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal","code":"def is_partition_possible ( n , x , y , w ) : NEW_LINE INDENT weight_at_x = defaultdict ( int ) NEW_LINE max_x = - 2e3 NEW_LINE min_x = 2e3 NEW_LINE DEDENT"}
{"text":"Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates","code":"for i in range ( n ) : NEW_LINE INDENT new_x = x [ i ] - y [ i ] NEW_LINE max_x = max ( max_x , new_x ) NEW_LINE min_x = min ( min_x , new_x ) NEW_LINE DEDENT"}
{"text":"storing weight sum upto x - y point","code":"weight_at_x [ new_x ] += w [ i ] NEW_LINE sum_till = [ ] NEW_LINE sum_till . append ( 0 ) NEW_LINE"}
{"text":"Finding prefix sum","code":"for x in range ( min_x , max_x + 1 ) : NEW_LINE INDENT sum_till . append ( sum_till [ - 1 ] + weight_at_x [ x ] ) NEW_LINE DEDENT total_sum = sum_till [ - 1 ] NEW_LINE partition_possible = False NEW_LINE for i in range ( 1 , len ( sum_till ) ) : NEW_LINE INDENT if ( sum_till [ i ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT DEDENT"}
{"text":"Line passes through i , so it neither falls left nor right .","code":"if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT if partition_possible : NEW_LINE print ( \" YES \" ) NEW_LINE else : NEW_LINE print ( \" NO \" ) NEW_LINE"}
{"text":"Driven Program","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE x = [ - 1 , - 2 , 1 ] NEW_LINE y = [ 1 , 1 , - 1 ] NEW_LINE w = [ 3 , 1 , 4 ] NEW_LINE is_partition_possible ( n , x , y , w ) NEW_LINE DEDENT"}
{"text":"Function to find the Slope of other line","code":"def findPCSlope ( m ) : NEW_LINE INDENT return - 1.0 \/ m NEW_LINE DEDENT"}
{"text":"Driver code","code":"m = 2.0 NEW_LINE print ( findPCSlope ( m ) ) NEW_LINE"}
{"text":"Python3 Program to find area of segment of a circle","code":"import math NEW_LINE pi = 3.14159 NEW_LINE"}
{"text":"Function to find area of segment","code":"def area_of_segment ( radius , angle ) : NEW_LINE"}
{"text":"Calculating area of sector","code":"area_of_sector = pi * NEW_LINE INDENT ( radius * radius ) NEW_LINE * ( angle \/ 360 ) NEW_LINE DEDENT"}
{"text":"Calculating area of triangle","code":"area_of_triangle = 1 \/ 2 * NEW_LINE INDENT ( radius * radius ) * NEW_LINE math . sin ( ( angle * pi ) \/ 180 ) NEW_LINE DEDENT return area_of_sector - area_of_triangle ; NEW_LINE"}
{"text":"Driver Code","code":"radius = 10.0 NEW_LINE angle = 90.0 NEW_LINE print ( \" Area \u2581 of \u2581 minor \u2581 segment \u2581 = \" , area_of_segment ( radius , angle ) ) NEW_LINE print ( \" Area \u2581 of \u2581 major \u2581 segment \u2581 = \" , area_of_segment ( radius , ( 360 - angle ) ) ) NEW_LINE"}
{"text":"Python program to find Area of a Sector","code":"def SectorArea ( radius , angle ) : NEW_LINE INDENT pi = 22 \/ 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( \" Angle \u2581 not \u2581 possible \" ) NEW_LINE return NEW_LINE DEDENT DEDENT"}
{"text":"Calculating area of the sector","code":"else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle \/ 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Driver code","code":"radius = 9 NEW_LINE angle = 60 NEW_LINE SectorArea ( radius , angle ) NEW_LINE"}
{"text":"Python program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to calculate total number of prime factor with their prime factor","code":"def PrimeFactor ( N ) : NEW_LINE INDENT ANS = dict ( ) NEW_LINE DEDENT"}
{"text":"Iterate while the number is even","code":"while N % 2 == 0 : NEW_LINE INDENT if 2 in ANS : NEW_LINE INDENT ANS [ 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ 2 ] = 1 NEW_LINE DEDENT DEDENT"}
{"text":"Reduce to half","code":"N = N \/\/ 2 NEW_LINE"}
{"text":"Iterate up to sqrt ( N )","code":"for i in range ( 3 , int ( math . sqrt ( N ) ) + 1 , 2 ) : NEW_LINE"}
{"text":"Iterate while N has factors of i","code":"while N % i == 0 : NEW_LINE INDENT if i in ANS : NEW_LINE INDENT ANS [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ i ] = 1 NEW_LINE DEDENT DEDENT"}
{"text":"Removing one factor of i","code":"N = N \/\/ i NEW_LINE if 2 < N : NEW_LINE ANS [ N ] = 1 NEW_LINE return ANS NEW_LINE"}
{"text":"Function to count the number of factors","code":"def CountToMakeEqual ( X , Y ) : NEW_LINE"}
{"text":"Find the GCD","code":"GCD = math . gcd ( X , Y ) NEW_LINE"}
{"text":"Find multiples left in X and Y","code":"newY = X \/\/ GCD NEW_LINE newX = Y \/\/ GCD NEW_LINE"}
{"text":"Find prime factor of multiple left in X and Y","code":"primeX = PrimeFactor ( newX ) NEW_LINE primeY = PrimeFactor ( newY ) NEW_LINE"}
{"text":"Initialize ans","code":"ans = 0 NEW_LINE"}
{"text":"Check if it possible to obtain X or not","code":"for factor in primeX : NEW_LINE INDENT if X % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeX [ factor ] NEW_LINE DEDENT"}
{"text":"Check if it possible to obtain Y or not","code":"for factor in primeY : NEW_LINE INDENT if Y % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeY [ factor ] NEW_LINE DEDENT"}
{"text":"return main ans","code":"return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given Input","code":"X = 36 NEW_LINE Y = 48 NEW_LINE"}
{"text":"Function Call","code":"ans = CountToMakeEqual ( X , Y ) NEW_LINE print ( ans ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from collections import deque NEW_LINE"}
{"text":"Function to check whether the graph is bipartite or not","code":"def check ( Adj , Src , N , visited ) : NEW_LINE INDENT color = [ 0 ] * N NEW_LINE DEDENT"}
{"text":"Mark source node as visited","code":"visited = [ True ] * Src NEW_LINE q = deque ( ) NEW_LINE"}
{"text":"Push the source vertex in queue","code":"q . append ( Src ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE"}
{"text":"Get the front of the queue","code":"u = q . popleft ( ) NEW_LINE"}
{"text":"Assign the color to the popped node","code":"Col = color [ u ] NEW_LINE"}
{"text":"Traverse the adjacency list of the node u","code":"for x in Adj [ u ] : NEW_LINE"}
{"text":"If any node is visited & a different colors has been assigned , then return false","code":"if ( visited [ x ] == True and color [ x ] == Col ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( visited [ x ] == False ) : NEW_LINE"}
{"text":"Set visited [ x ]","code":"visited [ x ] = True NEW_LINE"}
{"text":"Push the node x into the queue","code":"q . append ( x ) NEW_LINE"}
{"text":"Update color of node","code":"color [ x ] = 1 - Col NEW_LINE"}
{"text":"If the graph is bipartite","code":"return True NEW_LINE"}
{"text":"Function to add an edge between the nodes u and v","code":"def addEdge ( Adj , u , v ) : NEW_LINE INDENT Adj [ u ] . append ( v ) NEW_LINE Adj [ v ] . append ( u ) NEW_LINE return Adj NEW_LINE DEDENT"}
{"text":"Function to check if the assignment of direction can be possible to all the segments , such that they do not intersect after a long period of time","code":"def isPossible ( Arr , N ) : NEW_LINE"}
{"text":"Stores the adjacency list of the created graph","code":"Adj = [ [ ] for i in range ( N ) ] NEW_LINE"}
{"text":"Generate all possible pairs","code":"for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE DEDENT"}
{"text":"If segments do not overlap","code":"if ( Arr [ i ] [ 0 ] < Arr [ j ] [ 1 ] or Arr [ i ] [ 1 ] > Arr [ j ] [ 0 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"Otherwise , the segments overlap","code":"else : NEW_LINE INDENT if ( Arr [ i ] [ 2 ] == Arr [ j ] [ 2 ] ) : NEW_LINE DEDENT"}
{"text":"If both segments have same speed , then add an edge","code":"Adj = addEdge ( Adj , i , j ) NEW_LINE"}
{"text":"Keep the track of visited nodes","code":"visited = [ False ] * N NEW_LINE"}
{"text":"Iterate for all possible nodes","code":"for i in range ( N ) : NEW_LINE INDENT if ( visited [ i ] == False and len ( Adj [ i ] ) > 0 ) : NEW_LINE DEDENT"}
{"text":"Check whether graph is bipartite or not","code":"if ( check ( Adj , i , N , visited ) == False ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"If the graph is bipartite","code":"print ( \" Yes \" ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 5 , 7 , 2 ] , [ 4 , 6 , 1 ] , [ 1 , 5 , 2 ] , [ 6 , 5 , 1 ] ] NEW_LINE N = len ( arr ) NEW_LINE isPossible ( arr , N ) NEW_LINE DEDENT"}
{"text":"Python program for the above approach","code":"def lexNumbers ( n ) : NEW_LINE INDENT sol = [ ] NEW_LINE dfs ( 1 , n , sol ) NEW_LINE print ( \" [ \" , sol [ 0 ] , end = \" \" , sep = \" \" ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( \" , \u2581 \" , sol [ i ] , end = \" \" , sep = \" \" ) print ( \" ] \" ) NEW_LINE DEDENT DEDENT def dfs ( temp , n , sol ) : NEW_LINE INDENT if ( temp > n ) : NEW_LINE INDENT return NEW_LINE DEDENT sol . append ( temp ) NEW_LINE dfs ( temp * 10 , n , sol ) NEW_LINE if ( temp % 10 != 9 ) : NEW_LINE INDENT dfs ( temp + 1 , n , sol ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"n = 15 NEW_LINE lexNumbers ( n ) NEW_LINE"}
{"text":"Function to find minimum swaps","code":"def minimumSwaps ( arr ) : NEW_LINE"}
{"text":"Initialise count variable","code":"count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( arr ) ) : NEW_LINE"}
{"text":"If current element is not at the right position","code":"if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE DEDENT DEDENT"}
{"text":"Swap current element with correct position of that element","code":"temp = arr [ arr [ i ] - 1 ] ; NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] ; NEW_LINE arr [ i ] = temp ; NEW_LINE count += 1 ; NEW_LINE"}
{"text":"Increment for next index when current element is at correct position","code":"i += 1 ; NEW_LINE return count ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] ; NEW_LINE DEDENT"}
{"text":"Function to find minimum swaps","code":"print ( minimumSwaps ( arr ) ) ; NEW_LINE"}
{"text":"A linked list node","code":"class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT"}
{"text":"Given a reference ( pointer to pointer ) to the head Of a DLL and an int , appends a new node at the end","code":"def append ( head_ref , new_data ) : NEW_LINE"}
{"text":"Allocate node","code":"new_node = Node ( 0 ) NEW_LINE last = head_ref NEW_LINE"}
{"text":"Put in the data","code":"new_node . data = new_data NEW_LINE"}
{"text":"This new node is going to be the last node , so make next of it as None","code":"new_node . next = None NEW_LINE"}
{"text":"If the Linked List is empty , then make the new node as head","code":"if ( head_ref == None ) : NEW_LINE INDENT new_node . prev = None NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT"}
{"text":"Else traverse till the last node","code":"while ( last . next != None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT"}
{"text":"Change the next of last node","code":"last . next = new_node NEW_LINE"}
{"text":"Make last node as previous of new node","code":"new_node . prev = last NEW_LINE return head_ref NEW_LINE"}
{"text":"Function to print the list","code":"def printList ( node ) : NEW_LINE INDENT last = None NEW_LINE DEDENT"}
{"text":"Run while loop unless node becomes None","code":"while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT"}
{"text":"Function to merge two sorted doubly linked lists","code":"def mergeList ( p , q ) : NEW_LINE INDENT s = None NEW_LINE DEDENT"}
{"text":"If any of the list is empty","code":"if ( p == None or q == None ) : NEW_LINE INDENT if ( p == None ) : NEW_LINE INDENT return q NEW_LINE DEDENT else : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT"}
{"text":"Comparison the data of two linked list","code":"if ( p . data < q . data ) : NEW_LINE INDENT p . prev = s NEW_LINE s = p NEW_LINE p = p . next NEW_LINE DEDENT else : NEW_LINE INDENT q . prev = s NEW_LINE s = q NEW_LINE q = q . next NEW_LINE DEDENT"}
{"text":"Store head pointer before merge the list","code":"head = s NEW_LINE while ( p != None and q != None ) : NEW_LINE INDENT if ( p . data < q . data ) : NEW_LINE DEDENT"}
{"text":"Changing of pointer between Two list for merging","code":"s . next = p NEW_LINE p . prev = s NEW_LINE s = s . next NEW_LINE p = p . next NEW_LINE else : NEW_LINE"}
{"text":"Changing of pointer between Two list for merging","code":"s . next = q NEW_LINE q . prev = s NEW_LINE s = s . next NEW_LINE q = q . next NEW_LINE"}
{"text":"Condition to check if any anyone list not end","code":"if ( p == None ) : NEW_LINE INDENT s . next = q NEW_LINE q . prev = s NEW_LINE DEDENT if ( q == None ) : NEW_LINE INDENT s . next = p NEW_LINE p . prev = s NEW_LINE DEDENT"}
{"text":"Return head pointer of merged list","code":"return head NEW_LINE"}
{"text":"Function to merge all sorted linked list in sorted order","code":"def mergeAllList ( head , k ) : NEW_LINE INDENT finalList = None NEW_LINE i = 0 NEW_LINE while ( i < k ) : NEW_LINE DEDENT"}
{"text":"Function call to merge two sorted doubly linked list at a time","code":"finalList = mergeList ( finalList , head [ i ] ) NEW_LINE i = i + 1 NEW_LINE"}
{"text":"Return final sorted doubly linked list","code":"return finalList NEW_LINE"}
{"text":"Driver code","code":"k = 3 NEW_LINE head = [ 0 ] * k NEW_LINE i = 0 NEW_LINE"}
{"text":"Loop to initialize all the lists to empty","code":"while ( i < k ) : NEW_LINE INDENT head [ i ] = None NEW_LINE i = i + 1 NEW_LINE DEDENT"}
{"text":"Create first doubly linked List List1 . 1 <= > 5 <= > 9","code":"head [ 0 ] = append ( head [ 0 ] , 1 ) NEW_LINE head [ 0 ] = append ( head [ 0 ] , 5 ) NEW_LINE head [ 0 ] = append ( head [ 0 ] , 9 ) NEW_LINE"}
{"text":"Create second doubly linked List List2 . 2 <= > 3 <= > 7 <= > 12","code":"head [ 1 ] = append ( head [ 1 ] , 2 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 3 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 7 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 12 ) NEW_LINE"}
{"text":"Create third doubly linked List List3 . 8 <= > 11 <= > 13 <= > 18","code":"head [ 2 ] = append ( head [ 2 ] , 8 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 11 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 13 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 18 ) NEW_LINE"}
{"text":"Function call to merge all sorted doubly linked lists in sorted order","code":"finalList = mergeAllList ( head , k ) NEW_LINE"}
{"text":"Print final sorted list","code":"printList ( finalList ) NEW_LINE"}
{"text":"Return minimum index","code":"def minIndex ( a , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT"}
{"text":"Find minimum of remaining elements","code":"k = minIndex ( a , i + 1 , j ) NEW_LINE"}
{"text":"Return minimum of current and remaining .","code":"return ( i if a [ i ] < a [ k ] else k ) NEW_LINE"}
{"text":"Recursive selection sort . n is size of a [ ] and index is index of starting element .","code":"def recurSelectionSort ( a , n , index = 0 ) : NEW_LINE"}
{"text":"Return when starting and size are same","code":"if index == n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"calling minimum index function for minimum index","code":"k = minIndex ( a , index , n - 1 ) NEW_LINE"}
{"text":"Swapping when index and minimum index are not same","code":"if k != index : NEW_LINE INDENT a [ k ] , a [ index ] = a [ index ] , a [ k ] NEW_LINE DEDENT"}
{"text":"swap","code":"a [ k ] , a [ index ] = a [ index ] , a [ k ] NEW_LINE"}
{"text":"Recursively calling selection sort function","code":"recurSelectionSort ( a , n , index + 1 ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ 3 , 1 , 5 , 2 , 7 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE"}
{"text":"Calling function","code":"recurSelectionSort ( arr , n ) NEW_LINE"}
{"text":"printing sorted array","code":"for i in arr : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"text":"Recursive function to sort an array using insertion sort","code":"def insertionSortRecursive ( arr , n ) : NEW_LINE"}
{"text":"base case","code":"if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"Sort first n - 1 elements","code":"insertionSortRecursive ( arr , n - 1 ) NEW_LINE"}
{"text":"Insert last element at its correct position in sorted array .","code":"last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE"}
{"text":"Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position","code":"while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE"}
{"text":"A utility function to print an array of size n","code":"def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT"}
{"text":"Driver program to test insertion sort","code":"arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE insertionSortRecursive ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"text":"Python Program for implementation of Recursive Bubble sort","code":"class bubbleSort : NEW_LINE"}
{"text":"A function to implement bubble sort","code":"def __init__ ( self , array ) : NEW_LINE INDENT self . array = array NEW_LINE self . length = len ( array ) NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return \" \u2581 \" . join ( [ str ( x ) for x in self . array ] ) NEW_LINE DEDENT def bubbleSortRecursive ( self , n = None ) : NEW_LINE INDENT if n is None : NEW_LINE INDENT n = self . length NEW_LINE DEDENT DEDENT"}
{"text":"Base case","code":"if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"One pass of bubble sort . After this pass , the largest element is moved ( or bubbled ) to end .","code":"for i in range ( n - 1 ) : NEW_LINE INDENT if self . array [ i ] > self . array [ i + 1 ] : NEW_LINE DEDENT"}
{"text":"swap arr [ i ] , arr [ i + 1 ]","code":"self . array [ i ] , self . array [ i + 1 ] = self . array [ i + 1 ] , self . array [ i ] NEW_LINE"}
{"text":"Largest element is fixed , recur for remaining array","code":"self . bubbleSortRecursive ( n - 1 ) NEW_LINE"}
{"text":"Python 3 Program for the above approach","code":"def maxSumAfterPartition ( arr , n ) : NEW_LINE"}
{"text":"Stores the positive elements","code":"pos = [ ] NEW_LINE"}
{"text":"Stores the negative elements","code":"neg = [ ] NEW_LINE"}
{"text":"Stores the count of 0 s","code":"zero = 0 NEW_LINE"}
{"text":"Sum of all positive numbers","code":"pos_sum = 0 NEW_LINE"}
{"text":"Sum of all negative numbers","code":"neg_sum = 0 NEW_LINE"}
{"text":"Iterate over the array","code":"for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos . append ( arr [ i ] ) NEW_LINE pos_sum += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 ) : NEW_LINE INDENT neg . append ( arr [ i ] ) NEW_LINE neg_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Stores the difference","code":"ans = 0 NEW_LINE"}
{"text":"Sort the positive numbers in ascending order","code":"pos . sort ( ) NEW_LINE"}
{"text":"Sort the negative numbers in decreasing order","code":"neg . sort ( reverse = True ) NEW_LINE"}
{"text":"Case 1 : Include both positive and negative numbers","code":"if ( len ( pos ) > 0 and len ( neg ) > 0 ) : NEW_LINE INDENT ans = ( pos_sum - neg_sum ) NEW_LINE DEDENT elif ( len ( pos ) > 0 ) : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE DEDENT"}
{"text":"Put all numbers in subset A and one 0 in subset B","code":"ans = ( pos_sum ) NEW_LINE else : NEW_LINE"}
{"text":"Put all numbers in subset A except the smallest positive number which is put in B","code":"ans = ( pos_sum - 2 * pos [ 0 ] ) NEW_LINE else : NEW_LINE if ( zero > 0 ) : NEW_LINE"}
{"text":"Put all numbers in subset B and one 0 in subset A","code":"ans = ( - 1 * neg_sum ) NEW_LINE else : NEW_LINE"}
{"text":"Place the largest negative number in subset A and remaining in B","code":"ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) NEW_LINE return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , - 5 , - 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumAfterPartition ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"Function to find the bitwise OR of array elements","code":"def MaxXOR ( arr , N ) : NEW_LINE"}
{"text":"Stores the resultant maximum value of Bitwise XOR","code":"res = 0 NEW_LINE"}
{"text":"Traverse the array arr [ ]","code":"for i in range ( N ) : NEW_LINE INDENT res |= arr [ i ] NEW_LINE DEDENT"}
{"text":"Return the maximum value res","code":"return res NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( MaxXOR ( arr , N ) ) NEW_LINE DEDENT"}
{"text":"Function to count the number of elements common in both the arrays","code":"def countEqual ( A , B , N ) : NEW_LINE"}
{"text":"Used to traverse array A [ ] and B [ ] from the front and the back","code":"first = 0 NEW_LINE second = N - 1 NEW_LINE"}
{"text":"Stores the count of numbers common in both array","code":"count = 0 NEW_LINE while ( first < N and second >= 0 ) : NEW_LINE"}
{"text":"If A [ first ] is less than B [ second ]","code":"if ( A [ first ] < B [ second ] ) : NEW_LINE"}
{"text":"Increment the value of first","code":"first += 1 NEW_LINE"}
{"text":"IF B [ second ] is less than A [ first ]","code":"elif ( B [ second ] < A [ first ] ) : NEW_LINE"}
{"text":"Decrement the value of second","code":"second -= 1 NEW_LINE"}
{"text":"A [ first ] is equal to B [ second ]","code":"else : NEW_LINE"}
{"text":"Increment the value of count","code":"count += 1 NEW_LINE"}
{"text":"Increment the value of first","code":"first += 1 NEW_LINE"}
{"text":"Decrement the value of second","code":"second -= 1 NEW_LINE"}
{"text":"Return the value of count","code":"return count NEW_LINE"}
{"text":"Driver Code","code":"A = [ 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 ] NEW_LINE B = [ 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( countEqual ( A , B , N ) ) NEW_LINE"}
{"text":"Python 3 program for the above approach","code":"arr = [ 0 for i in range ( 100005 ) ] NEW_LINE"}
{"text":"Function to check if the number N is palindrome or not","code":"def isPalindrome ( N ) : NEW_LINE"}
{"text":"Store the value of N","code":"temp = N NEW_LINE"}
{"text":"Store the reverse of number N","code":"res = 0 NEW_LINE"}
{"text":"Reverse temp and store in res","code":"while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE res = res * 10 + rem NEW_LINE temp \/\/= 10 NEW_LINE DEDENT"}
{"text":"If N is the same as res , then return true","code":"if ( res == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Function to find the sum of the digits of the number N","code":"def sumOfDigits ( N ) : NEW_LINE"}
{"text":"Stores the sum of the digits","code":"sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE"}
{"text":"Add the last digit of the number N to the sum","code":"sum += N % 10 NEW_LINE"}
{"text":"Remove the last digit from N","code":"N \/\/= 10 NEW_LINE"}
{"text":"Return the resultant sum","code":"return sum NEW_LINE"}
{"text":"Function to check if N is prime or not","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"If i is 1 or 0 , then return false","code":"if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Check if i is divisible by any number in the range [ 2 , n \/ 2 ]","code":"for i in range ( 2 , ( n \/\/ 2 ) + 1 , 1 ) : NEW_LINE"}
{"text":"If n is divisible by i","code":"if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Function to precompute all the numbers till 10 ^ 5 that are palindromic and whose sum of digits is prime numbers","code":"def precompute ( ) : NEW_LINE"}
{"text":"Iterate over the range 1 to 10 ^ 5","code":"for i in range ( 1 , 100001 , 1 ) : NEW_LINE"}
{"text":"If i is a palindrome number","code":"if ( isPalindrome ( i ) ) : NEW_LINE"}
{"text":"Stores the sum of the digits in i","code":"sum = sumOfDigits ( i ) NEW_LINE"}
{"text":"If the sum of digits in i is a prime number","code":"if ( isPrime ( sum ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE arr [ i ] = 0 NEW_LINE"}
{"text":"Find the prefix sum of arr [ ]","code":"for i in range ( 1 , 100001 , 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE DEDENT"}
{"text":"Function to count all the numbers in the given ranges that are palindromic and the sum of digits is prime numbers","code":"def countNumbers ( Q , N ) : NEW_LINE"}
{"text":"Function Call to precompute all the numbers till 10 ^ 5","code":"precompute ( ) NEW_LINE"}
{"text":"Traverse the given queries Q [ ]","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Print the result for each query","code":"print ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Q = [ [ 5 , 9 ] , [ 1 , 101 ] ] NEW_LINE N = len ( Q ) NEW_LINE DEDENT"}
{"text":"Function Call","code":"countNumbers ( Q , N ) NEW_LINE"}
{"text":"Function to calculate sum of digits of n","code":"def sum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sm += n % 10 NEW_LINE n \/\/= 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT"}
{"text":"Function to find the smallest possible integer satisfying the given condition","code":"def smallestNumber ( n , s ) : NEW_LINE"}
{"text":"If sum of digits is already smaller than s","code":"if ( sum ( n ) <= s ) : NEW_LINE INDENT return n NEW_LINE DEDENT"}
{"text":"Initialize variables","code":"ans , k = n , 1 NEW_LINE for i in range ( 9 ) : NEW_LINE"}
{"text":"Find the k - th digit","code":"digit = ( ans \/\/ k ) % 10 NEW_LINE"}
{"text":"Add remaining","code":"add = k * ( ( 10 - digit ) % 10 ) NEW_LINE ans += add NEW_LINE"}
{"text":"If sum of digits does not exceed s","code":"if ( sum ( ans ) <= s ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Update K","code":"k *= 10 NEW_LINE return ans NEW_LINE"}
{"text":"Given N and S","code":"n , s = 3 , 2 NEW_LINE"}
{"text":"Function call","code":"print ( smallestNumber ( n , s ) ) NEW_LINE"}
{"text":"Python program to implement the above approach","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function to find the maximum number number of required subsequences","code":"def maxSubsequences ( arr , n ) -> int : NEW_LINE"}
{"text":"Dictionary to store number of arrows available with height of arrow as key","code":"m = defaultdict ( int ) NEW_LINE"}
{"text":"Stores the maximum count of possible subsequences","code":"maxCount = 0 NEW_LINE"}
{"text":"Stores the count of possible subsequences","code":"count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE"}
{"text":"Check if i - th element can be part of any of the previous subsequence","code":"if arr [ i ] in m . keys ( ) : NEW_LINE"}
{"text":"Count of subsequences possible with arr [ i ] as the next element","code":"count = m [ arr [ i ] ] NEW_LINE"}
{"text":"If more than one such subsequence exists","code":"if count > 1 : NEW_LINE"}
{"text":"Include arr [ i ] in a subsequence","code":"m [ arr [ i ] ] = count - 1 NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT m . pop ( arr [ i ] ) NEW_LINE DEDENT"}
{"text":"Increase count of subsequence possible with arr [ i ] - 1 as the next element","code":"if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE maxCount += 1 NEW_LINE"}
{"text":"Start a new subsequence","code":"maxCount += 1 NEW_LINE"}
{"text":"Increase count of subsequence possible with arr [ i ] - 1 as the next element","code":"if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT"}
{"text":"Return the answer","code":"return maxCount NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 4 , 5 , 2 , 1 , 4 ] NEW_LINE print ( maxSubsequences ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"Function to remove first and last occurrence of a given character from the given string","code":"def removeOcc ( s , ch ) : NEW_LINE"}
{"text":"Traverse the given string from the beginning","code":"for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"If ch is found","code":"if ( s [ i ] == ch ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT"}
{"text":"Traverse the given string from the end","code":"for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE"}
{"text":"If ch is found","code":"if ( s [ i ] == ch ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT return s NEW_LINE"}
{"text":"Driver Code","code":"s = \" hello \u2581 world \" NEW_LINE ch = ' l ' NEW_LINE print ( removeOcc ( s , ch ) ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function that finds the minimum steps to reach either 0 or N for given increasing and decreasing arrays","code":"def minSteps ( N , increasing , decreasing ) : NEW_LINE"}
{"text":"Initialize variable to find the minimum element","code":"Min = sys . maxsize ; NEW_LINE"}
{"text":"Find minimum element in increasing array","code":"for i in increasing : NEW_LINE INDENT if ( Min > i ) : NEW_LINE INDENT Min = i ; NEW_LINE DEDENT DEDENT"}
{"text":"Initialize variable to find the maximum element","code":"Max = - sys . maxsize ; NEW_LINE"}
{"text":"Find maximum element in decreasing array","code":"for i in decreasing : NEW_LINE INDENT if ( Max < i ) : NEW_LINE INDENT Max = i ; NEW_LINE DEDENT DEDENT"}
{"text":"Find the minimum steps","code":"minSteps = max ( Max , N - Min ) ; NEW_LINE"}
{"text":"Prthe minimum steps","code":"print ( minSteps ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given N","code":"N = 7 ; NEW_LINE"}
{"text":"Given increasing and decreasing array","code":"increasing = [ 3 , 5 ] ; NEW_LINE decreasing = [ 6 ] ; NEW_LINE"}
{"text":"Function call","code":"minSteps ( N , increasing , decreasing ) ; NEW_LINE"}
{"text":"Function to find the minimum number of swaps","code":"def solve ( P , n ) : NEW_LINE"}
{"text":"New array to convert to 1 - based indexing","code":"arr = [ ] NEW_LINE arr . append ( 0 ) NEW_LINE for x in P : NEW_LINE INDENT arr . append ( x ) NEW_LINE DEDENT"}
{"text":"Keeps count of swaps","code":"cnt = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE"}
{"text":"Check if it is an ' X ' position","code":"if ( arr [ i ] == i ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE cnt += 1 NEW_LINE DEDENT"}
{"text":"Corner Case","code":"if ( arr [ n ] == n ) : NEW_LINE"}
{"text":"Swap","code":"arr [ n - 1 ] , arr [ n ] = arr [ n ] , arr [ n - 1 ] NEW_LINE cnt += 1 NEW_LINE"}
{"text":"Print the minimum swaps","code":"print ( cnt ) NEW_LINE"}
{"text":"Given number N","code":"N = 9 NEW_LINE"}
{"text":"Given permutation of N numbers","code":"P = [ 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 ] NEW_LINE"}
{"text":"Function call","code":"solve ( P , N ) NEW_LINE"}
{"text":"Function to find all prime numbers","code":"def SieveOfEratosthenes ( n , allPrimes ) : NEW_LINE"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries as true . A value in prime [ i ] will finally be false if i is Not a prime .","code":"prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if prime [ p ] == True : NEW_LINE"}
{"text":"Update all multiples of p greater than or equal to the square of it","code":"for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"Store all prime numbers","code":"for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT allPrimes . add ( p ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to check if a number is perfect square or not","code":"def countInterestingPrimes ( n ) : NEW_LINE"}
{"text":"To store all primes","code":"allPrimes = set ( ) NEW_LINE"}
{"text":"To store all interseting primes","code":"SieveOfEratosthenes ( n , allPrimes ) NEW_LINE interestingPrimes = set ( ) NEW_LINE squares , quadruples = [ ] , [ ] NEW_LINE"}
{"text":"Store all perfect squares","code":"i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT squares . append ( i * i ) NEW_LINE i += 1 NEW_LINE DEDENT"}
{"text":"Store all perfect quadruples","code":"i = 1 NEW_LINE while i * i * i * i <= n : NEW_LINE INDENT quadruples . append ( i * i * i * i ) NEW_LINE i += 1 NEW_LINE DEDENT"}
{"text":"Store all interseting primes","code":"for a in squares : NEW_LINE INDENT for b in quadruples : NEW_LINE INDENT if a + b in allPrimes : NEW_LINE INDENT interestingPrimes . add ( a + b ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Return count of interseting primes","code":"return len ( interestingPrimes ) NEW_LINE"}
{"text":"Driver code","code":"N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE"}
{"text":"Function to check if array is wave array arr : input array n : size of array","code":"def isWaveArray ( arr , n ) : NEW_LINE INDENT result = True NEW_LINE DEDENT"}
{"text":"Check the wave form If arr [ 1 ] is greater than left and right . Same pattern will be followed by whole elements , else reverse pattern will be followed by array elements","code":"if ( arr [ 1 ] > arr [ 0 ] and arr [ 1 ] > arr [ 2 ] ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Check for last element","code":"if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] <= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT elif ( arr [ 1 ] < arr [ 0 ] and arr [ 1 ] < arr [ 2 ] ) : NEW_LINE for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"Check for last element","code":"if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT return result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Array","code":"arr = [ 1 , 3 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isWaveArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Function to count number of sequences satisfying the given criteria","code":"def countPossiblities ( arr , n ) : NEW_LINE"}
{"text":"Stores the index of the last occurrence of the element","code":"lastOccur = [ - 1 ] * 100000 NEW_LINE"}
{"text":"Initialize an array to store the number of different sequences that are possible of length i","code":"dp = [ 0 ] * ( n + 1 ) NEW_LINE"}
{"text":"Base Case","code":"dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curEle = arr [ i - 1 ] NEW_LINE DEDENT"}
{"text":"If no operation is applied on ith element","code":"dp [ i ] = dp [ i - 1 ] NEW_LINE"}
{"text":"If operation is applied on ith element","code":"if ( lastOccur [ curEle ] != - 1 and lastOccur [ curEle ] < i - 1 ) : NEW_LINE INDENT dp [ i ] += dp [ lastOccur [ curEle ] ] NEW_LINE DEDENT"}
{"text":"Update the last occurrence of curEle","code":"lastOccur [ curEle ] = i NEW_LINE"}
{"text":"Finally , prthe answer","code":"print ( dp [ n ] ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE countPossiblities ( arr , N ) NEW_LINE DEDENT"}
{"text":"Function to prthe maximum sum","code":"def maxSum ( arr , n , m ) : NEW_LINE"}
{"text":"Dp table","code":"dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( 2 ) ] NEW_LINE"}
{"text":"Base case","code":"dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] NEW_LINE dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] NEW_LINE"}
{"text":"Traverse each column","code":"for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE"}
{"text":"Update answer for both rows","code":"for i in range ( 2 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Print the maximum sum","code":"print ( max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given array","code":"arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] NEW_LINE"}
{"text":"Number of Columns","code":"N = len ( arr [ 0 ] ) NEW_LINE"}
{"text":"Function calls","code":"maxSum ( arr , 2 , N ) NEW_LINE"}
{"text":"Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row","code":"def maxSum ( arr , n ) : NEW_LINE"}
{"text":"Initialize variables","code":"r1 = r2 = 0 NEW_LINE"}
{"text":"Traverse each column","code":"for i in range ( n ) : NEW_LINE INDENT r1 , r2 = max ( r1 , r2 + arr [ 0 ] [ i ] ) , max ( r2 , r1 + arr [ 1 ] [ i ] ) NEW_LINE DEDENT"}
{"text":"Print answer","code":"print ( max ( r1 , r2 ) ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] NEW_LINE"}
{"text":"Numberof columns","code":"n = len ( arr [ 0 ] ) NEW_LINE maxSum ( arr , n ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"mod = 1e9 + 7 NEW_LINE mx = 1000000 NEW_LINE fact = [ 0 ] * ( mx + 1 ) NEW_LINE"}
{"text":"Function to calculate the factorials up to a number","code":"def Calculate_factorial ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE DEDENT"}
{"text":"Calculate the factorial","code":"for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE fact [ i ] %= mod NEW_LINE DEDENT"}
{"text":"Function to find power ( a , b )","code":"def UniModal_per ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT"}
{"text":"Iterate until b exists","code":"while ( b != 0 ) : NEW_LINE"}
{"text":"If b is divisible by 2","code":"if ( b % 2 != 0 ) : NEW_LINE INDENT res = res * a NEW_LINE DEDENT res %= mod NEW_LINE a = a * a NEW_LINE a %= mod NEW_LINE"}
{"text":"Decrease the value of b","code":"b \/\/= 2 NEW_LINE"}
{"text":"Return the answer","code":"return res NEW_LINE"}
{"text":"Function that counts the unimodal and non - unimodal permutations of a given integer N","code":"def countPermutations ( n ) : NEW_LINE"}
{"text":"Function Call for finding factorials up to N","code":"Calculate_factorial ( ) NEW_LINE"}
{"text":"Function to count unimodal permutations","code":"uni_modal = UniModal_per ( 2 , n - 1 ) NEW_LINE"}
{"text":"Non - unimodal permutation is N ! - unimodal permutations","code":"nonuni_modal = fact [ n ] - uni_modal NEW_LINE print ( int ( uni_modal ) , \" \" , int ( nonuni_modal ) ) NEW_LINE return NEW_LINE"}
{"text":"Driver Code Given number N","code":"N = 4 NEW_LINE"}
{"text":"Function call","code":"countPermutations ( N ) NEW_LINE"}
{"text":"Python3 program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle","code":"import sys NEW_LINE def longestSubseq ( s , length ) : NEW_LINE"}
{"text":"Prefix array to store the occurences of '1' and '0' Initialise prefix arrays with 0","code":"ones = [ 0 for i in range ( length + 1 ) ] NEW_LINE zeroes = [ 0 for i in range ( length + 1 ) ] NEW_LINE"}
{"text":"Iterate over the length of the string","code":"for i in range ( length ) : NEW_LINE"}
{"text":"If current character is '1","code":"' NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT ones [ i + 1 ] = ones [ i ] + 1 NEW_LINE zeroes [ i + 1 ] = zeroes [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Add '1' available for the first string","code":"x += ones [ i ] NEW_LINE"}
{"text":"Add '0' available for the second string","code":"x += ( zeroes [ j ] - zeroes [ i ] ) NEW_LINE"}
{"text":"Add '1' available for the third string","code":"x += ( ones [ length ] - ones [ j ] ) NEW_LINE"}
{"text":"Update answer","code":"answer = max ( answer , x ) NEW_LINE x = 0 NEW_LINE"}
{"text":"Print the final result","code":"print ( answer ) NEW_LINE"}
{"text":"Driver Code","code":"S = \"10010010111100101\" NEW_LINE length = len ( S ) NEW_LINE longestSubseq ( S , length ) NEW_LINE"}
{"text":"Python3 implementation to find the largest square in the matrix such that it contains at most K 1 's","code":"MAX = 100 NEW_LINE"}
{"text":"Function to calculate the largest square with atmost K 1 s for Q queries","code":"def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE"}
{"text":"Loop to solve for each query","code":"for q in range ( Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) NEW_LINE ans = - 1 NEW_LINE for k in range ( min_dist + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT"}
{"text":"Traversing the each sub square and counting total","code":"for row in range ( i - k , i + k + 1 ) : NEW_LINE INDENT for col in range ( j - k , j + k + 1 ) : NEW_LINE INDENT count += matrix [ row ] [ col ] NEW_LINE DEDENT DEDENT"}
{"text":"Breaks when exceeds the maximum count","code":"if count > K : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE"}
{"text":"Function to find the largest square in the matrix such that it contains atmost K 1 's","code":"def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE DEDENT"}
{"text":"Precomputing the countDP prefix sum of the matrix","code":"countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Loop to solve Queries","code":"for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE DEDENT"}
{"text":"Calculating the maximum possible distance of the centre from edge","code":"min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE for k in range ( 0 , min_dist + 1 ) : NEW_LINE INDENT x1 = i - k NEW_LINE x2 = i + k NEW_LINE y1 = j - k NEW_LINE y2 = j + k NEW_LINE DEDENT"}
{"text":"Calculating the number of 1 s in the submatrix","code":"count = countDP [ x2 ] [ y2 ] ; NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count > K ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE"}
{"text":"Function to return the minimum cost to connect the given ropes","code":"def MinCost ( arr , n ) : NEW_LINE"}
{"text":"dp [ i ] [ j ] = minimum cost in range ( i , j ) sum [ i ] [ j ] = sum of range ( i , j )","code":"dp = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE sum = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE"}
{"text":"Initializing the sum table memset ( sum , 0 , sizeof ( 0 ) ) ;","code":"for i in range ( n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT sum [ i ] [ j ] = k NEW_LINE DEDENT else : NEW_LINE INDENT k += arr [ j ] NEW_LINE sum [ i ] [ j ] = k NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Computing minimum cost for all the possible interval ( i , j ) Left range","code":"for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE"}
{"text":"Right range","code":"for j in range ( i , n ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE DEDENT"}
{"text":"No cost for a single rope","code":"if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE"}
{"text":"Driver code","code":"arr = [ 7 , 6 , 8 , 6 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCost ( arr , n ) ) NEW_LINE"}
{"text":"Function to recursively fill the dp array","code":"def f ( i , state , A , dp , N ) : NEW_LINE INDENT if i >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT"}
{"text":"If f ( i , state ) is already calculated then return the value","code":"elif dp [ i ] [ state ] != - 1 : NEW_LINE INDENT return dp [ i ] [ state ] NEW_LINE DEDENT"}
{"text":"Calculate f ( i , state ) according to the recurrence relation and store in dp [ ] [ ]","code":"else : NEW_LINE INDENT if i == N - 1 : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] > A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 2 and A [ i ] < A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) NEW_LINE DEDENT elif state == 2 and A [ i ] >= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) NEW_LINE DEDENT return dp [ i ] [ state ] NEW_LINE DEDENT"}
{"text":"Function that calls the resucrsive function to fill the dp array and then returns the result","code":"def maxLenSeq ( A , N ) : NEW_LINE"}
{"text":"dp [ ] [ ] array for storing result of f ( i , 1 ) and f ( 1 , 2 ) Populating the array dp [ ] with - 1","code":"dp = [ [ - 1 , - 1 , - 1 ] for i in range ( 1000 ) ] NEW_LINE"}
{"text":"Make sure that longest UD and DU sequence starting at each index is calculated","code":"for i in range ( N ) : NEW_LINE INDENT tmp = f ( i , 1 , A , dp , N ) NEW_LINE tmp = f ( i , 2 , A , dp , N ) NEW_LINE DEDENT"}
{"text":"Assume the answer to be - 1 This value will only increase","code":"ans = - 1 NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"y is the length of the longest UD sequence starting at i","code":"y = dp [ i ] [ 1 ] NEW_LINE if ( i + y ) >= N : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 ) NEW_LINE DEDENT"}
{"text":"If length is even then add an integer and then a DU sequence starting at i + y","code":"elif y % 2 == 0 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) NEW_LINE DEDENT"}
{"text":"If length is odd then add an integer and then a UD sequence starting at i + y","code":"elif y % 2 == 1 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 10 , 3 , 20 , 25 , 24 ] NEW_LINE n = len ( A ) NEW_LINE print ( maxLenSeq ( A , n ) ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of the above approach","code":"import math as mt NEW_LINE"}
{"text":"Function to return the maximized gcd after removing a single element from the given array","code":"def MaxGCD ( a , n ) : NEW_LINE"}
{"text":"Prefix and Suffix arrays","code":"Prefix = [ 0 for i in range ( n + 2 ) ] NEW_LINE Suffix = [ 0 for i in range ( n + 2 ) ] NEW_LINE"}
{"text":"Single state dynamic programming relation for storing gcd of first i elements from the left in Prefix [ i ]","code":"Prefix [ 1 ] = a [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = mt . gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT"}
{"text":"Initializing Suffix array","code":"Suffix [ n ] = a [ n - 1 ] NEW_LINE"}
{"text":"Single state dynamic programming relation for storing gcd of all the elements having greater than or equal to i in Suffix [ i ]","code":"for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = mt . gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT"}
{"text":"If first or last element of the array has to be removed","code":"ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) NEW_LINE"}
{"text":"If any other element is replaced","code":"for i in range ( 2 , n ) : NEW_LINE INDENT ans = max ( ans , mt . gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) NEW_LINE DEDENT"}
{"text":"Return the maximized gcd","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"a = [ 14 , 17 , 28 , 70 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxGCD ( a , n ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"import numpy as np NEW_LINE right = 3 ; NEW_LINE left = 6 ; NEW_LINE dp = np . ones ( ( left , right ) ) NEW_LINE dp = - 1 * dp NEW_LINE"}
{"text":"Function to find the maximum subarray sum with flips starting from index i","code":"def findSubarraySum ( ind , flips , n , a , k ) : NEW_LINE"}
{"text":"If the number of flips have exceeded","code":"if ( flips > k ) : NEW_LINE INDENT return - 1e9 ; NEW_LINE DEDENT"}
{"text":"Complete traversal","code":"if ( ind == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"If the state has previously been visited","code":"if ( dp [ ind ] [ flips ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ flips ] ; NEW_LINE DEDENT"}
{"text":"Initially","code":"ans = 0 ; NEW_LINE"}
{"text":"Use Kadane 's algorithm and  call two states","code":"ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; NEW_LINE ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; NEW_LINE"}
{"text":"Memoize the answer and return it","code":"dp [ ind ] [ flips ] = ans ; NEW_LINE return dp [ ind ] [ flips ] ; NEW_LINE"}
{"text":"Utility function to call flips from index and return the answer","code":"def findMaxSubarraySum ( a , n , k ) : NEW_LINE"}
{"text":"Create DP array int dp [ n , k + 1 ]","code":"ans = - 1e9 ; NEW_LINE"}
{"text":"Iterate and call recursive function from every index to get the maximum subarray sum","code":"for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; NEW_LINE DEDENT"}
{"text":"corner casae","code":"if ans == 0 and k == 0 : NEW_LINE return max ( a ) ; NEW_LINE return ans ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 100 , - 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 1 ; NEW_LINE print ( findMaxSubarraySum ( a , n , k ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 program to Find the sum of first N odd Fibonacci numbers","code":"mod = 1000000007 ; NEW_LINE"}
{"text":"Function to calculate sum of first N odd Fibonacci numbers","code":"def sumOddFibonacci ( n ) : NEW_LINE INDENT Sum = [ 0 ] * ( n + 1 ) ; NEW_LINE DEDENT"}
{"text":"base values","code":"Sum [ 0 ] = 0 ; NEW_LINE Sum [ 1 ] = 1 ; NEW_LINE Sum [ 2 ] = 2 ; NEW_LINE Sum [ 3 ] = 5 ; NEW_LINE Sum [ 4 ] = 10 ; NEW_LINE Sum [ 5 ] = 23 ; NEW_LINE for i in range ( 6 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; NEW_LINE DEDENT return Sum [ n ] ; NEW_LINE"}
{"text":"Driver code","code":"n = 6 ; NEW_LINE print ( sumOddFibonacci ( n ) ) ; NEW_LINE"}
{"text":"Python implementation of the above approach","code":"def fun ( marks , n ) : NEW_LINE"}
{"text":"Initializing one tablet for each student","code":"dp = [ 1 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE"}
{"text":"if left adjacent is having higher marks review and change all the dp values assigned before until assigned dp values are found wrong according to given constrains","code":"if marks [ i ] > marks [ i + 1 ] : NEW_LINE INDENT temp = i NEW_LINE while True : NEW_LINE INDENT if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : NEW_LINE INDENT if dp [ temp ] > dp [ temp + 1 ] : NEW_LINE INDENT temp -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ temp ] = dp [ temp + 1 ] + 1 NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"if right adjacent is having higher marks add one in dp of left adjacent and assign to right one","code":"elif marks [ i ] < marks [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT return ( sum ( dp ) ) NEW_LINE"}
{"text":"n number of students","code":"n = 6 NEW_LINE"}
{"text":"marks of students","code":"marks = [ 1 , 4 , 5 , 2 , 2 , 1 ] NEW_LINE"}
{"text":"solution of problem","code":"print ( fun ( marks , n ) ) NEW_LINE"}
{"text":"Python3 program to reach N - th stair by taking a maximum of K leap","code":"def solve ( N , K ) : NEW_LINE"}
{"text":"elements of combo [ ] stores the no of possible ways to reach it by all combinations of k leaps or less","code":"combo = [ 0 ] * ( N + 1 ) NEW_LINE"}
{"text":"assuming leap 0 exist and assigning its value to 1 for calculation","code":"combo [ 0 ] = 1 NEW_LINE"}
{"text":"loop to iterate over all possible leaps upto k ;","code":"for i in range ( 1 , K + 1 ) : NEW_LINE"}
{"text":"in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less","code":"for j in range ( 0 , N + 1 ) : NEW_LINE"}
{"text":"if the leap is not more than the i - j","code":"if j >= i : NEW_LINE"}
{"text":"calculate the value and store in combo [ j ] to reuse it for next leap calculation for the jth stair","code":"combo [ j ] += combo [ j - i ] NEW_LINE"}
{"text":"returns the no of possible number of leaps to reach the top of building of n stairs","code":"return combo [ N ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"N i the no of total stairs K is the value of the greatest leap","code":"N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE"}
{"text":"Utility method to find LIS using Dynamic programming","code":"def computeLIS ( circBuff , start , end , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( end ) ] NEW_LINE DEDENT"}
{"text":"Initialize LIS values for all indexes","code":"for i in range ( start , end ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT"}
{"text":"Compute optimized LIS values in bottom up manner","code":"for i in range ( start + 1 , end ) : NEW_LINE"}
{"text":"Set j on the basis of current window i . e . first element of the current window","code":"for j in range ( start , i ) : NEW_LINE INDENT if ( circBuff [ i ] > circBuff [ j ] and LIS [ i ] < LIS [ j ] + 1 ) : NEW_LINE INDENT LIS [ i ] = LIS [ j ] + 1 NEW_LINE DEDENT DEDENT"}
{"text":"Pick maximum of all LIS values","code":"res = - 100000 NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT res = max ( res , LIS [ i ] ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Function to find Longest Increasing subsequence in Circular manner","code":"def LICS ( arr , n ) : NEW_LINE"}
{"text":"Make a copy of given array by appending same array elements to itself","code":"circBuff = [ 0 for i in range ( 2 * n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n , 2 * n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i - n ] NEW_LINE DEDENT"}
{"text":"Perform LIS for each window of size n","code":"res = - 100000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( computeLIS ( circBuff , i , i + n , n ) , res ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 4 , 6 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length \u2581 of \u2581 LICS \u2581 is \" , LICS ( arr , n ) ) NEW_LINE"}
{"text":"Function to find binomial Coefficient","code":"def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE DEDENT"}
{"text":"Constructing Pascal 's Triangle","code":"for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE"}
{"text":"Driver Code","code":"n = 3 NEW_LINE m = 2 NEW_LINE print ( \" Number \u2581 of \u2581 Paths : \" , binomialCoeff ( n + m , n ) ) NEW_LINE"}
{"text":"Returns the length and the LCIS of two arrays arr1 [ 0. . n - 1 ] and arr2 [ 0. . m - 1 ]","code":"def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE"}
{"text":"table [ j ] is going to store length of LCIS ending with arr2 [ j ] . We initialize it as 0 ,","code":"table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT"}
{"text":"Traverse all elements of arr1 [ ]","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Initialize current length of LCIS","code":"current = 0 NEW_LINE"}
{"text":"For each element of arr1 [ ] , traverse all elements of arr2 [ ] .","code":"for j in range ( m ) : NEW_LINE"}
{"text":"If both the array have same elements . Note that we don 't break the loop here.","code":"if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT"}
{"text":"Now seek for previous smaller common element for current element of arr1","code":"if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT"}
{"text":"The maximum value in table [ ] is out result","code":"result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 3 , 4 , 9 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( \" Length \u2581 of \u2581 LCIS \u2581 is \" , LCIS ( arr1 , n , arr2 , m ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to implement the above approach","code":"import sys NEW_LINE"}
{"text":"Function to get the length of the longest common prefix by rearranging the strings","code":"def longComPre ( arr , N ) : NEW_LINE"}
{"text":"freq [ i ] [ j ] : stores the frequency of a character ( = j ) in a arr [ i ]","code":"freq = [ [ 0 for i in range ( 256 ) ] for i in range ( N ) ] NEW_LINE"}
{"text":"Traverse the given array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Stores length of current string","code":"M = len ( arr [ i ] ) NEW_LINE"}
{"text":"Traverse current string of the given array","code":"for j in range ( M ) : NEW_LINE"}
{"text":"Update the value of freq [ i ] [ arr [ i ] [ j ] ]","code":"freq [ i ] [ ord ( arr [ i ] [ j ] ) ] += 1 NEW_LINE"}
{"text":"Stores the length of longest common prefix","code":"maxLen = 0 NEW_LINE"}
{"text":"Count the minimum frequency of each character in in all the strings of arr [ ]","code":"for j in range ( 256 ) : NEW_LINE"}
{"text":"Stores minimum value in each row of freq [ ] [ ]","code":"minRowVal = sys . maxsize NEW_LINE"}
{"text":"Calculate minimum frequency of current character in all the strings .","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Update minRowVal","code":"minRowVal = min ( minRowVal , freq [ i ] [ j ] ) NEW_LINE"}
{"text":"Update maxLen","code":"maxLen += minRowVal NEW_LINE return maxLen NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" aabdc \" , \" abcd \" , \" aacd \" ] NEW_LINE N = 3 NEW_LINE print ( longComPre ( arr , N ) ) NEW_LINE DEDENT"}
{"text":"Python 3 program to remove characters from a String that appears exactly K times","code":"MAX_CHAR = 26 NEW_LINE"}
{"text":"Function to reduce the string by removing the characters which appears exactly k times","code":"def removeChars ( arr , k ) : NEW_LINE"}
{"text":"Hash table initialised to 0","code":"hash = [ 0 ] * MAX_CHAR NEW_LINE"}
{"text":"Increment the frequency of the character","code":"n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT"}
{"text":"To store answer","code":"ans = \" \" NEW_LINE"}
{"text":"Next index in reduced string","code":"index = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Append the characters which appears exactly k times","code":"if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE DEDENT"}
{"text":"Function call","code":"print ( removeChars ( str , k ) ) NEW_LINE"}
{"text":"Function that prints the segments","code":"def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE DEDENT DEDENT"}
{"text":"New array for every iteration","code":"arr = [ ] NEW_LINE for y in newlist : NEW_LINE"}
{"text":"Check if the character is in the array","code":"if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT print ( ' ' . join ( arr ) ) NEW_LINE"}
{"text":"Driver code","code":"string = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE"}
{"text":"Function to find the encrypted string","code":"def findWord ( c , n ) : NEW_LINE INDENT co = 0 NEW_LINE DEDENT"}
{"text":"to store the encrypted string","code":"s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n \/ 2 ) : NEW_LINE INDENT co += 1 NEW_LINE DEDENT else : NEW_LINE INDENT co = n - i NEW_LINE DEDENT DEDENT"}
{"text":"after ' z ' , it should go to a .","code":"if ( ord ( c [ i ] ) + co <= 122 ) : NEW_LINE INDENT s [ i ] = chr ( ord ( c [ i ] ) + co ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = chr ( ord ( c [ i ] ) + co - 26 ) NEW_LINE DEDENT print ( * s , sep = \" \" ) NEW_LINE"}
{"text":"Driver code","code":"s = \" abcd \" NEW_LINE findWord ( s , len ( s ) ) NEW_LINE"}
{"text":"Function to compare two strings ignoring their cases","code":"def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT"}
{"text":"length of first string","code":"len1 = len ( str1 ) NEW_LINE"}
{"text":"length of second string","code":"len2 = len ( str2 ) NEW_LINE"}
{"text":"if length is not same simply return false since both string can not be same if length is not equal","code":"if ( len1 != len2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"loop to match one by one all characters of both string","code":"while ( i < len1 ) : NEW_LINE"}
{"text":"if current characters of both string are same , increase value of i to compare next character","code":"if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT"}
{"text":"if any character of first string is some special character or numeric character and not same as corresponding character of second string then return false","code":"elif ( ( ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) or ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"do the same for second string","code":"elif ( ( ( str2 [ i ] >= ' a ' and str2 [ i ] <= ' z ' ) or ( str2 [ i ] >= ' A ' and str2 [ i ] <= ' Z ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"this block of code will be executed if characters of both strings are of different cases","code":"else : NEW_LINE"}
{"text":"compare characters by ASCII value","code":"if ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) : NEW_LINE INDENT if ( ord ( str1 [ i ] ) - 32 != ord ( str2 [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) : NEW_LINE INDENT if ( ord ( str1 [ i ] ) + 32 != ord ( str2 [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"if characters matched , increase the value of i to compare next char","code":"i += 1 NEW_LINE"}
{"text":"if all characters of the first string are matched with corresponding characters of the second string , then return true","code":"return True NEW_LINE"}
{"text":"Function to print the same or not same if strings are equal or not equal","code":"def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Same \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" Geeks \" NEW_LINE str2 = \" geeks \" NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) NEW_LINE str1 = \" Geek \" NEW_LINE str2 = \" geeksforgeeks \" NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) NEW_LINE DEDENT"}
{"text":"Function to return the maximized value of A","code":"def maxValue ( a , b ) : NEW_LINE"}
{"text":"Sort digits in ascending order","code":"b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE"}
{"text":"j points to largest digit in B","code":"j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"If all the digits of b have been used","code":"if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE DEDENT"}
{"text":"Current digit has been used","code":"j -= 1 NEW_LINE"}
{"text":"Return the maximized value","code":"x = \" \" . join ( ai ) NEW_LINE return x NEW_LINE"}
{"text":"Driver code","code":"a = \"1234\" NEW_LINE b = \"4321\" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE"}
{"text":"Function to check if all of the digits in a number and it 's product with q are unequal or not","code":"def checkIfUnequal ( n , q ) : NEW_LINE"}
{"text":"convert first number into string","code":"s1 = str ( n ) NEW_LINE a = [ 0 for i in range ( 26 ) ] NEW_LINE"}
{"text":"Insert elements from 1 st number to hash","code":"for i in range ( 0 , len ( s1 ) , 1 ) : NEW_LINE INDENT a [ ord ( s1 [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT"}
{"text":"Calculate corresponding product","code":"prod = n * q NEW_LINE"}
{"text":"Convert the product to string","code":"s2 = str ( prod ) NEW_LINE"}
{"text":"Using the hash check if any digit of product matches with the digits of input number","code":"for i in range ( 0 , len ( s2 ) , 1 ) : NEW_LINE"}
{"text":"If yes , return false","code":"if ( a [ ord ( s2 [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Return true","code":"return True NEW_LINE"}
{"text":"Function to count numbers in the range [ l , r ] such that all of the digits of the number and it 's product with q are unequal","code":"def countInRange ( l , r , q ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE DEDENT"}
{"text":"check for every number between l and r","code":"if ( checkIfUnequal ( i , q ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 10 NEW_LINE r = 12 NEW_LINE q = 2 NEW_LINE DEDENT"}
{"text":"Function call","code":"print ( countInRange ( l , r , q ) ) NEW_LINE"}
{"text":"function to check the binary string","code":"def is_possible ( s ) : NEW_LINE"}
{"text":"length of string","code":"l = len ( s ) NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE"}
{"text":"count zero 's","code":"if ( s [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT"}
{"text":"count one 's","code":"else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT"}
{"text":"if length is even","code":"if ( l % 2 == 0 ) : NEW_LINE INDENT return ( one == zero ) NEW_LINE DEDENT"}
{"text":"if length is odd","code":"else : NEW_LINE INDENT return ( abs ( one - zero ) == 1 ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"100110\" NEW_LINE if ( is_possible ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 program to count frequencies of array items","code":"limit = 255 NEW_LINE def countFreq ( Str ) : NEW_LINE"}
{"text":"Create an array to store counts . The size of array is limit + 1 and all values are initially 0","code":"count = [ 0 ] * ( limit + 1 ) NEW_LINE"}
{"text":"Traverse through string characters and count frequencies","code":"for i in range ( len ( Str ) ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( chr ( i ) , count [ i ] ) NEW_LINE DEDENT"}
{"text":"Function to store EVEN and odd variable","code":"def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE DEDENT"}
{"text":"Store the count of even and odd set bit","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Count the set bit using in built function","code":"x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT"}
{"text":"Count of set - bit of K","code":"y = bin ( K ) . count ( '1' ) ; NEW_LINE"}
{"text":"If y is odd then , count of even and odd set bit will be interchanged","code":"if ( y & 1 ) : NEW_LINE INDENT print ( \" Even \u2581 = \" , odd , \" , \u2581 Odd \u2581 = \" , even ) ; NEW_LINE DEDENT"}
{"text":"Else it will remain same as the original array","code":"else : NEW_LINE INDENT print ( \" Even \u2581 = \" , even , \" , \u2581 Odd \u2581 = \" , odd ) ; NEW_LINE DEDENT"}
{"text":"Driver 's Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE DEDENT"}
{"text":"Function call to count even and odd","code":"countEvenOdd ( arr , n , K ) ; NEW_LINE"}
{"text":"Python program to convert given sentence to camel case .","code":"import math NEW_LINE"}
{"text":"Function to remove spaces and convert into camel case","code":"def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = \" \" NEW_LINE s1 = s1 + s [ 0 ] . lower ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE DEDENT"}
{"text":"check for spaces in the sentence","code":"if ( s [ i ] == ' \u2581 ' and i <= n ) : NEW_LINE"}
{"text":"conversion into upper case","code":"s1 = s1 + \" \u2581 \" + ( s [ i + 1 ] ) . lower ( ) NEW_LINE i = i + 1 NEW_LINE"}
{"text":"If not space , copy character","code":"else : NEW_LINE INDENT s1 = s1 + ( s [ i ] ) . upper ( ) NEW_LINE DEDENT i = i + 1 NEW_LINE"}
{"text":"return string to main","code":"return s1 NEW_LINE"}
{"text":"Driver code","code":"str = \" I \u2581 get \u2581 intern \u2581 at \u2581 geeksforgeeks \" NEW_LINE print ( convert ( str ) ) NEW_LINE"}
{"text":"Python3 implementation to check if N is a Tcefrep number","code":"import math NEW_LINE"}
{"text":"Iterative function to reverse digits of num","code":"def reverse ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num \/\/ 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT"}
{"text":"Function to calculate sum of all proper divisors num -- > given natural number","code":"def properDivSum ( num ) : NEW_LINE"}
{"text":"Final result of summation of divisors","code":"result = 0 NEW_LINE"}
{"text":"find all divisors which divides 'num","code":"' NEW_LINE INDENT for i in range ( 2 , ( int ) ( math . sqrt ( num ) ) + 1 ) : NEW_LINE DEDENT"}
{"text":"if ' i ' is divisor of 'num","code":"' NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE DEDENT"}
{"text":"if both divisors are same then add it only once else add both","code":"if ( i == ( num \/\/ i ) ) : NEW_LINE INDENT result += i NEW_LINE DEDENT else : NEW_LINE INDENT result += ( i + num \/ i ) NEW_LINE DEDENT"}
{"text":"Add 1 to the result as 1 is also a divisor","code":"return ( result + 1 ) NEW_LINE def isTcefrep ( n ) : NEW_LINE return properDivSum ( n ) == reverse ( n ) ; NEW_LINE"}
{"text":"Given Number N","code":"N = 6 NEW_LINE"}
{"text":"Function Call","code":"if ( isTcefrep ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python3 program to find n - th number containing only 3 and 5.","code":"def reverse ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return reverse ( s [ 1 : ] ) + s [ 0 ] NEW_LINE DEDENT DEDENT def findNthNo ( n ) : NEW_LINE INDENT res = \" \" ; NEW_LINE while ( n >= 1 ) : NEW_LINE DEDENT"}
{"text":"If n is odd , append 3 and move to parent","code":"if ( n & 1 ) : NEW_LINE INDENT res = res + \"3\" ; NEW_LINE n = ( int ) ( ( n - 1 ) \/ 2 ) ; NEW_LINE DEDENT"}
{"text":"If n is even , append 5 and move to parent","code":"else : NEW_LINE INDENT res = res + \"5\" ; NEW_LINE n = ( int ) ( ( n - 2 ) \/ 2 ) ; NEW_LINE DEDENT"}
{"text":"Reverse res and return .","code":"return reverse ( res ) ; NEW_LINE"}
{"text":"Driver code","code":"n = 5 ; NEW_LINE print ( findNthNo ( n ) ) ; NEW_LINE"}
{"text":"Python3 program to find n - th non - square number .","code":"import math NEW_LINE"}
{"text":"function to find the nth Non - Square Number","code":"def findNthNonSquare ( n ) : NEW_LINE"}
{"text":"conversion from int to long double is necessary in order to preserve decimal places after square root .","code":"x = n ; NEW_LINE"}
{"text":"calculating the result","code":"ans = x + math . floor ( 0.5 + math . sqrt ( x ) ) ; NEW_LINE return int ( ans ) ; NEW_LINE"}
{"text":"initializing the term number","code":"n = 16 ; NEW_LINE"}
{"text":"Print the result","code":"print ( \" The \" , n , \" th \u2581 Non - Square \u2581 number \u2581 is \" , findNthNonSquare ( n ) ) ; NEW_LINE"}
{"text":"Function to calculate series sum","code":"def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) \/ ( 2 * n - 1 ) ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( int ( seiresSum ( n , a ) ) ) NEW_LINE"}
{"text":"Function for checking if digit k is in n or not","code":"def checkdigit ( n , k ) : NEW_LINE INDENT while ( n ) : NEW_LINE DEDENT"}
{"text":"finding remainder","code":"rem = n % 10 NEW_LINE"}
{"text":"if digit found","code":"if ( rem == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n \/ 10 NEW_LINE return 0 NEW_LINE"}
{"text":"Function for finding nth number","code":"def findNthNumber ( n , k ) : NEW_LINE"}
{"text":"since k is the first which satisfy th criteria , so consider it in count making count = 1 and starting from i = k + 1","code":"i = k + 1 NEW_LINE count = 1 NEW_LINE while ( count < n ) : NEW_LINE"}
{"text":"checking that the number contain k digit or divisible by k","code":"if ( checkdigit ( i , k ) or ( i % k == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE return - 1 NEW_LINE"}
{"text":"Driver code","code":"n = 10 NEW_LINE k = 2 NEW_LINE print ( findNthNumber ( n , k ) ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"def find_permutations ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE max_ind = - 1 NEW_LINE min_ind = 10000000 ; NEW_LINE n = len ( arr ) NEW_LINE index_of = { } NEW_LINE DEDENT"}
{"text":"Save index of numbers of the array","code":"for i in range ( n ) : NEW_LINE INDENT index_of [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE"}
{"text":"Update min and max index with the current index and check if it 's a  valid permutation","code":"max_ind = max ( max_ind , index_of [ i ] ) NEW_LINE min_ind = min ( min_ind , index_of [ i ] ) NEW_LINE if ( max_ind - min_ind + 1 == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT nums = [ ] NEW_LINE nums . append ( 2 ) NEW_LINE nums . append ( 3 ) NEW_LINE nums . append ( 1 ) NEW_LINE nums . append ( 5 ) NEW_LINE nums . append ( 4 ) NEW_LINE print ( find_permutations ( nums ) ) NEW_LINE DEDENT"}
{"text":"Function to return the count of the required integers","code":"from math import gcd as __gcd NEW_LINE def getCount ( a , n ) : NEW_LINE"}
{"text":"To store the gcd of the array elements","code":"gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( gcd , a [ i ] ) NEW_LINE DEDENT"}
{"text":"To store the count of factors of the found gcd","code":"cnt = 0 NEW_LINE for i in range ( 1 , gcd + 1 ) : NEW_LINE INDENT if i * i > gcd : NEW_LINE INDENT break NEW_LINE DEDENT if ( gcd % i == 0 ) : NEW_LINE DEDENT"}
{"text":"If g is a perfect square","code":"if ( i * i == gcd ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT"}
{"text":"Factors appear in pairs","code":"else : NEW_LINE INDENT cnt += 2 NEW_LINE DEDENT return cnt NEW_LINE"}
{"text":"Driver code","code":"a = [ 4 , 16 , 1024 , 48 ] NEW_LINE n = len ( a ) NEW_LINE print ( getCount ( a , n ) ) NEW_LINE"}
{"text":"Function to find the minimum cost of removing characters to make the string unique","code":"def delCost ( s , cost ) : NEW_LINE"}
{"text":"Stores the visited characters","code":"visited = [ False ] * len ( s ) NEW_LINE"}
{"text":"Stores the answer","code":"ans = 0 NEW_LINE"}
{"text":"Traverse the string","code":"for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"If already visited","code":"if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"Stores the maximum cost of removing a particular character","code":"maxDel = 0 NEW_LINE"}
{"text":"Store the total deletion cost of a particular character","code":"totCost = 0 NEW_LINE"}
{"text":"Mark the current character visited","code":"visited [ i ] = True NEW_LINE"}
{"text":"Traverse the indices of the string [ i , N - 1 ]","code":"for j in range ( i , len ( s ) ) : NEW_LINE"}
{"text":"If any duplicate is found","code":"if s [ i ] == s [ j ] : NEW_LINE"}
{"text":"Update the maximum cost and total cost","code":"maxDel = max ( maxDel , cost [ j ] ) NEW_LINE totCost += cost [ j ] NEW_LINE"}
{"text":"Mark the current character visited","code":"visited [ j ] = True NEW_LINE"}
{"text":"Keep the character with maximum cost and delete the rest","code":"ans += totCost - maxDel NEW_LINE"}
{"text":"Return the minimum cost","code":"return ans NEW_LINE"}
{"text":"Driver code Given string","code":"string = \" AAABBB \" NEW_LINE"}
{"text":"input array","code":"cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE"}
{"text":"input array","code":"string = \" AAABBB \" NEW_LINE"}
{"text":"Function Call","code":"print ( delCost ( string , cost ) ) NEW_LINE"}
{"text":"Function to find triplets such that replacing them with their XOR make all array elements equal","code":"def checkXOR ( arr , N ) : NEW_LINE"}
{"text":"If N is even","code":"if ( N % 2 == 0 ) : NEW_LINE"}
{"text":"Calculate xor of array elements","code":"xro = 0 ; NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Update xor","code":"xro ^= arr [ i ] ; NEW_LINE"}
{"text":"If xor is not equal to 0","code":"if ( xro != 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT"}
{"text":"Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal","code":"for i in range ( 0 , N - 3 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( i + 2 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"text":"Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]","code":"for i in range ( 0 , N - 3 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( N - 1 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal","code":"for i in range ( 0 , N - 2 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( i + 2 ) ) ; NEW_LINE DEDENT"}
{"text":"Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]","code":"for i in range ( 0 , N - 2 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( N - 1 ) ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given array","code":"arr = [ 4 , 2 , 1 , 7 , 2 ] ; NEW_LINE"}
{"text":"Size of array","code":"N = len ( arr ) ; NEW_LINE"}
{"text":"Function call","code":"checkXOR ( arr , N ) ; NEW_LINE"}
{"text":"Function to find minimum count of operations required to make all array elements even","code":"def make_array_element_even ( arr , N ) : NEW_LINE"}
{"text":"Stores minimum count of replacements to make all array elements even","code":"res = 0 NEW_LINE"}
{"text":"Stores the count of odd continuous numbers","code":"odd_cont_seg = 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( 0 , N ) : NEW_LINE"}
{"text":"If arr [ i ] is an odd number","code":"if ( arr [ i ] % 2 == 1 ) : NEW_LINE"}
{"text":"Update odd_cont_seg","code":"odd_cont_seg += 1 NEW_LINE else : NEW_LINE if ( odd_cont_seg > 0 ) : NEW_LINE"}
{"text":"If odd_cont_seg is even","code":"if ( odd_cont_seg % 2 == 0 ) : NEW_LINE"}
{"text":"Update res","code":"res += odd_cont_seg \/\/ 2 NEW_LINE else : NEW_LINE"}
{"text":"Update res","code":"res += ( odd_cont_seg \/\/ 2 ) + 2 NEW_LINE"}
{"text":"Reset odd_cont_seg = 0","code":"odd_cont_seg = 0 NEW_LINE"}
{"text":"If odd_cont_seg exceeds 0","code":"if ( odd_cont_seg > 0 ) : NEW_LINE"}
{"text":"If odd_cont_seg is even","code":"if ( odd_cont_seg % 2 == 0 ) : NEW_LINE"}
{"text":"Update res","code":"res += odd_cont_seg \/\/ 2 NEW_LINE else : NEW_LINE"}
{"text":"Update res","code":"res += odd_cont_seg \/\/ 2 + 2 NEW_LINE"}
{"text":"Prthe result","code":"return res NEW_LINE"}
{"text":"Drivers Code","code":"arr = [ 2 , 4 , 5 , 11 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( make_array_element_even ( arr , N ) ) NEW_LINE"}
{"text":"Function to find K for which there are exactly K array elements greater than or equal to K","code":"def zvalue ( nums ) : NEW_LINE"}
{"text":"Finding the largest array element","code":"m = max ( nums ) NEW_LINE cnt = 0 NEW_LINE"}
{"text":"Possible values of K","code":"for i in range ( 0 , m + 1 , 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT"}
{"text":"Traverse the array","code":"for j in range ( 0 , len ( nums ) , 1 ) : NEW_LINE"}
{"text":"If current array element is greater than or equal to i","code":"if ( nums [ j ] >= i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT"}
{"text":"If i array elements are greater than or equal to i","code":"if ( cnt == i ) : NEW_LINE INDENT return i NEW_LINE DEDENT"}
{"text":"Otherwise","code":"return - 1 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT nums = [ 7 , 8 , 9 , 0 , 0 , 1 ] NEW_LINE print ( zvalue ( nums ) ) NEW_LINE DEDENT"}
{"text":"Function to find the lexicographically smallest anagram of string which contains another string","code":"def lexico_smallest ( s1 , s2 ) : NEW_LINE"}
{"text":"Initializing the dictionary and set","code":"M = { } NEW_LINE S = [ ] NEW_LINE pr = { } NEW_LINE"}
{"text":"Iterating over s1","code":"for i in range ( len ( s1 ) ) : NEW_LINE"}
{"text":"Storing the frequency of characters present in s1","code":"if s1 [ i ] not in M : NEW_LINE INDENT M [ s1 [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ s1 [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"Storing the distinct characters present in s1","code":"S . append ( s1 [ i ] ) NEW_LINE S = list ( set ( S ) ) NEW_LINE S . sort ( ) NEW_LINE"}
{"text":"Decreasing the frequency of characters from M that are already present in s2","code":"for i in range ( len ( s2 ) ) : NEW_LINE INDENT if s2 [ i ] in M : NEW_LINE INDENT M [ s2 [ i ] ] -= 1 NEW_LINE DEDENT DEDENT c = s2 [ 0 ] NEW_LINE index = 0 NEW_LINE res = \" \" NEW_LINE"}
{"text":"Traversing alphabets in sorted order","code":"for x in S : NEW_LINE"}
{"text":"If current character of set is not equal to current character of s2","code":"if ( x != c ) : NEW_LINE INDENT for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT else : NEW_LINE"}
{"text":"If element is equal to current character of s2","code":"j = 0 NEW_LINE index = len ( res ) NEW_LINE"}
{"text":"Checking for second distinct character in s2","code":"while ( s2 [ j ] == x ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT"}
{"text":"s2 [ j ] will store second distinct character","code":"if ( s2 [ j ] < c ) : NEW_LINE INDENT res += s2 NEW_LINE for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT index += M [ x ] NEW_LINE res += s2 NEW_LINE DEDENT pr [ res ] = index NEW_LINE"}
{"text":"Return the answer","code":"return pr NEW_LINE"}
{"text":"Function to find the lexicographically largest anagram of string which contains another string","code":"def lexico_largest ( s1 , s2 ) : NEW_LINE"}
{"text":"Getting the lexicographically smallest anagram","code":"Pr = dict ( lexico_smallest ( s1 , s2 ) ) NEW_LINE"}
{"text":"d1 stores the prefix","code":"d1 = \" \" NEW_LINE key = [ * Pr ] [ 0 ] NEW_LINE for i in range ( Pr . get ( key ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT d1 += key [ i ] NEW_LINE DEDENT"}
{"text":"d2 stores the suffix","code":"d2 = \" \" NEW_LINE for i in range ( len ( key ) - 1 , Pr [ key ] + len ( s2 ) - 1 , - 1 ) : NEW_LINE INDENT d2 += key [ i ] NEW_LINE DEDENT res = d2 + s2 + d1 NEW_LINE"}
{"text":"Return the result","code":"return res NEW_LINE"}
{"text":"Given two strings","code":"s1 = \" ethgakagmenpgs \" NEW_LINE s2 = \" geeks \" NEW_LINE"}
{"text":"Function Calls","code":"print ( * lexico_smallest ( s1 , s2 ) ) NEW_LINE print ( lexico_largest ( s1 , s2 ) ) NEW_LINE"}
{"text":"Python3 implementation for the above approach","code":"sz = 100000 NEW_LINE"}
{"text":"Adjacency list to represent the tree","code":"tree = [ [ ] for i in range ( sz ) ] NEW_LINE"}
{"text":"Number of vertices","code":"n = 0 NEW_LINE"}
{"text":"Mark visited \/ unvisited vertices","code":"vis = [ False ] * sz NEW_LINE"}
{"text":"Stores the subtree size of the corresponding nodes","code":"subtreeSize = [ 0 for i in range ( sz ) ] NEW_LINE"}
{"text":"Function to create an edge between two vertices","code":"def addEdge ( a , b ) : NEW_LINE INDENT global tree NEW_LINE DEDENT"}
{"text":"Add a to b 's list","code":"tree [ a ] . append ( b ) NEW_LINE"}
{"text":"Add b to a 's list","code":"tree [ b ] . append ( a ) NEW_LINE"}
{"text":"Function to perform DFS","code":"def dfs ( x ) : NEW_LINE"}
{"text":"Mark the vertex visited","code":"global vis NEW_LINE global subtreeSize NEW_LINE global tree NEW_LINE vis [ x ] = True NEW_LINE"}
{"text":"Include the node in the subtree","code":"subtreeSize [ x ] = 1 NEW_LINE"}
{"text":"Traverse all its children","code":"for i in tree [ x ] : NEW_LINE INDENT if ( vis [ i ] == False ) : NEW_LINE INDENT dfs ( i ) NEW_LINE subtreeSize [ x ] += subtreeSize [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Function to print the required number of paths","code":"def countPairs ( a , b ) : NEW_LINE INDENT global subtreeSize NEW_LINE sub = min ( subtreeSize [ a ] , subtreeSize [ b ] ) NEW_LINE print ( sub * ( n - sub ) ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Number of vertices","code":"n = 6 NEW_LINE addEdge ( 0 , 1 ) NEW_LINE addEdge ( 0 , 2 ) NEW_LINE addEdge ( 1 , 3 ) NEW_LINE addEdge ( 3 , 4 ) NEW_LINE addEdge ( 3 , 5 ) NEW_LINE"}
{"text":"Calling modified dfs function","code":"dfs ( 0 ) NEW_LINE"}
{"text":"Count pairs of vertices in the tree","code":"countPairs ( 1 , 3 ) NEW_LINE countPairs ( 0 , 2 ) NEW_LINE"}
{"text":"Function to find the count of desired permutations","code":"def findPermutation ( arr , N ) : NEW_LINE INDENT pos = len ( arr ) + 1 NEW_LINE DEDENT"}
{"text":"Base case","code":"if ( pos > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE"}
{"text":"If i has not been inserted","code":"if ( i not in arr ) : NEW_LINE"}
{"text":"Backtrack","code":"if ( i % pos == 0 or pos % i == 0 ) : NEW_LINE"}
{"text":"Insert i","code":"arr . add ( i ) NEW_LINE"}
{"text":"Recur to find valid permutations","code":"res += findPermutation ( arr , N ) NEW_LINE"}
{"text":"Remove i","code":"arr . remove ( i ) NEW_LINE"}
{"text":"Return the final count","code":"return res NEW_LINE"}
{"text":"Driver Code","code":"N = 5 NEW_LINE arr = set ( ) NEW_LINE print ( findPermutation ( arr , N ) ) NEW_LINE"}
{"text":"Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr [ ]","code":"def solve ( arr , n , X , Y ) : NEW_LINE"}
{"text":"Store the difference","code":"diff = Y - X NEW_LINE"}
{"text":"Iterate over the array","code":"for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT"}
{"text":"If diff reduced to 0","code":"if ( diff == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE X , Y = 11 , 13 NEW_LINE solve ( arr , n , X , Y ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"maxN = 100001 NEW_LINE"}
{"text":"Adjacency List to store the graph","code":"adj = [ [ ] for i in range ( maxN ) ] NEW_LINE"}
{"text":"Stores the height of each node","code":"height = [ 0 for i in range ( maxN ) ] NEW_LINE"}
{"text":"Stores the maximum distance of a node from its ancestors","code":"dist = [ 0 for i in range ( maxN ) ] NEW_LINE"}
{"text":"Function to add edge between two vertices","code":"def addEdge ( u , v ) : NEW_LINE"}
{"text":"Insert edge from u to v","code":"adj [ u ] . append ( v ) NEW_LINE"}
{"text":"Insert edge from v to u","code":"adj [ v ] . append ( u ) NEW_LINE"}
{"text":"Function to calculate height of each Node","code":"def dfs1 ( cur , par ) : NEW_LINE"}
{"text":"Iterate in the adjacency list of the current node","code":"for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE DEDENT"}
{"text":"Dfs for child node","code":"dfs1 ( u , cur ) NEW_LINE"}
{"text":"Calculate height of nodes","code":"height [ cur ] = max ( height [ cur ] , height [ u ] ) NEW_LINE"}
{"text":"Increase height","code":"height [ cur ] += 1 NEW_LINE"}
{"text":"Function to calculate the maximum distance of a node from its ancestor","code":"def dfs2 ( cur , par ) : NEW_LINE INDENT max1 = 0 NEW_LINE max2 = 0 NEW_LINE DEDENT"}
{"text":"Iterate in the adjacency list of the current node","code":"for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE DEDENT"}
{"text":"Find two children with maximum heights","code":"if ( height [ u ] >= max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = height [ u ] NEW_LINE DEDENT elif ( height [ u ] > max2 ) : NEW_LINE INDENT max2 = height [ u ] NEW_LINE DEDENT sum = 0 NEW_LINE for u in adj [ cur ] : NEW_LINE if ( u != par ) : NEW_LINE"}
{"text":"Calculate the maximum distance with ancestor for every node","code":"sum = ( max2 if ( max1 == height [ u ] ) else max1 ) NEW_LINE if ( max1 == height [ u ] ) : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max2 , dist [ cur ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max1 , dist [ cur ] ) NEW_LINE DEDENT"}
{"text":"Calculating for children","code":"dfs2 ( u , cur ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE addEdge ( 1 , 2 ) NEW_LINE addEdge ( 2 , 3 ) NEW_LINE addEdge ( 2 , 4 ) NEW_LINE addEdge ( 2 , 5 ) NEW_LINE addEdge ( 5 , 6 ) NEW_LINE DEDENT"}
{"text":"Calculate height of nodes of the tree","code":"dfs1 ( 1 , 0 ) NEW_LINE"}
{"text":"Calculate the maximum distance with ancestors","code":"dfs2 ( 1 , 0 ) NEW_LINE"}
{"text":"Print the maximum of the two distances from each node","code":"for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( max ( dist [ i ] , height [ i ] ) - 1 , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"text":"Python3 program to find middle of three distinct numbers","code":"def middleOfThree ( a , b , c ) : NEW_LINE"}
{"text":"Function to find the middle of three number","code":"INDENT def middleOfThree ( a , b , c ) : NEW_LINE DEDENT"}
{"text":"Checking for b","code":"if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT"}
{"text":"Checking for a","code":"if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT"}
{"text":"Driver Code","code":"a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE"}
{"text":"Function to implement the selection sort","code":"def selectionSort ( arr , n ) : NEW_LINE"}
{"text":"One by one move boundary of unsorted subarray","code":"for i in range ( n - 1 ) : NEW_LINE"}
{"text":"Find the minimum element in unsorted array","code":"min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ min_idx ] ) : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT"}
{"text":"Swap the found minimum element with the first element","code":"arr [ min_idx ] , arr [ i ] = arr [ i ] , arr [ min_idx ] NEW_LINE"}
{"text":"Function to print an array","code":"def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 64 , 25 , 12 , 22 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT"}
{"text":"Function Call","code":"selectionSort ( arr , n ) NEW_LINE print ( \" Sorted \u2581 array : \u2581 \" ) NEW_LINE"}
{"text":"Print the array","code":"printArray ( arr , n ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"def checkStr1CanConStr2 ( str1 , str2 ) : NEW_LINE"}
{"text":"Stores length of str1","code":"N = len ( str1 ) NEW_LINE"}
{"text":"Stores length of str2","code":"M = len ( str2 ) NEW_LINE"}
{"text":"Stores distinct characters of str1","code":"st1 = set ( [ ] ) NEW_LINE"}
{"text":"Stores distinct characters of str2","code":"st2 = set ( [ ] ) NEW_LINE"}
{"text":"Stores frequency of each character of str1","code":"hash1 = [ 0 ] * 256 NEW_LINE"}
{"text":"Traverse the string str1","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Update frequency of str1 [ i ]","code":"hash1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE"}
{"text":"Traverse the string str1","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Insert str1 [ i ] into st1","code":"st1 . add ( str1 [ i ] ) NEW_LINE"}
{"text":"Traverse the string str2","code":"for i in range ( M ) : NEW_LINE"}
{"text":"Insert str1 [ i ] into st1","code":"st2 . add ( str2 [ i ] ) NEW_LINE"}
{"text":"If distinct characters in str1 and str2 are not same","code":"if ( st1 != st2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Stores frequency of each character of str2","code":"hash2 = [ 0 ] * 256 NEW_LINE"}
{"text":"Traverse the string str2","code":"for i in range ( M ) : NEW_LINE"}
{"text":"Update frequency of str2 [ i ]","code":"hash2 [ ord ( str2 [ i ] ) ] += 1 NEW_LINE"}
{"text":"Sort hash1 [ ] array","code":"hash1 . sort ( ) NEW_LINE"}
{"text":"Sort hash2 [ ] array","code":"hash2 . sort ( ) NEW_LINE"}
{"text":"Traverse hash1 [ ] and hash2 [ ]","code":"for i in range ( 256 ) : NEW_LINE"}
{"text":"If hash1 [ i ] not equal to hash2 [ i ]","code":"if ( hash1 [ i ] != hash2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" xyyzzlll \" NEW_LINE str2 = \" yllzzxxx \" NEW_LINE if ( checkStr1CanConStr2 ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to sort the elements of the array from index a to index b","code":"def partSort ( arr , N , a , b ) : NEW_LINE"}
{"text":"Variables to store start and end of the index range","code":"l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE arr = ( arr [ 0 : l ] + sorted ( arr [ l : r + 1 ] ) + arr [ r : N ] ) NEW_LINE"}
{"text":"Print the modified array","code":"for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"}
{"text":"A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0.","code":"INF = 2147483647 NEW_LINE N = 4 NEW_LINE"}
{"text":"This function returns the smallest possible cost to reach station N - 1 from station 0.","code":"def minCost ( cost ) : NEW_LINE"}
{"text":"dist [ i ] stores minimum cost to reach station i from station 0.","code":"dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE"}
{"text":"Go through every station and check if using it as an intermediate station gives better path","code":"for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE"}
{"text":"Driver program to test above function","code":"cost = [ [ 0 , 15 , 80 , 90 ] , [ INF , 0 , 40 , 50 ] , [ INF , INF , 0 , 70 ] , [ INF , INF , INF , 0 ] ] NEW_LINE print ( \" The \u2581 Minimum \u2581 cost \u2581 to \u2581 reach \u2581 station \u2581 \" , N , \" \u2581 is \u2581 \" , minCost ( cost ) ) NEW_LINE"}
{"text":"Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes","code":"def numOfways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) \/ n NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 4 NEW_LINE k = 2 NEW_LINE print ( numOfways ( n , k ) ) NEW_LINE"}
{"text":"Function that return the largest alphabet","code":"def largest_alphabet ( a , n ) : NEW_LINE"}
{"text":"Initializing max alphabet to 'a","code":"' NEW_LINE INDENT max = ' A ' NEW_LINE DEDENT"}
{"text":"Find largest alphabet","code":"for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Returning largest element","code":"return max NEW_LINE"}
{"text":"Function that return the smallest alphabet","code":"def smallest_alphabet ( a , n ) : NEW_LINE"}
{"text":"Initializing smallest alphabet to 'z","code":"' NEW_LINE INDENT min = ' z ' ; NEW_LINE DEDENT"}
{"text":"Find smallest alphabet","code":"for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Returning smallest alphabet","code":"return min NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Character array","code":"a = \" GeEksforGeeks \" NEW_LINE"}
{"text":"Calculating size of the string","code":"size = len ( a ) NEW_LINE"}
{"text":"Calling functions and print returned value","code":"print ( \" Largest \u2581 and \u2581 smallest \u2581 alphabet \u2581 is \u2581 : \u2581 \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" \u2581 and \u2581 \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE ' NEW_LINE"}
{"text":"Returns maximum possible palindrome using k changes","code":"def maximumPalinUsingKChanges ( strr , k ) : NEW_LINE INDENT palin = strr [ : : ] NEW_LINE DEDENT"}
{"text":"Initialize l and r by leftmost and rightmost ends","code":"l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE"}
{"text":"first try to make palindrome","code":"while ( l <= r ) : NEW_LINE"}
{"text":"Replace left and right character by maximum of both","code":"if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = NEW_LINE INDENT max ( strr [ l ] , strr [ r ] ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE"}
{"text":"If k is negative then we can 't make  palindrome","code":"if ( k < 0 ) : NEW_LINE INDENT return \" Not \u2581 possible \" NEW_LINE DEDENT l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE"}
{"text":"At mid character , if K > 0 then change it to 9","code":"if ( l == r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT"}
{"text":"If character at lth ( same as rth ) is less than 9","code":"if ( palin [ l ] < '9' ) : NEW_LINE"}
{"text":"If none of them is changed in the previous loop then subtract 2 from K and convert both to 9","code":"if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT"}
{"text":"If one of them is changed in the previous loop then subtract 1 from K ( 1 more is subtracted already ) and make them 9","code":"elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE return palin NEW_LINE"}
{"text":"Driver code","code":"st = \"43435\" NEW_LINE strr = [ i for i in st ] NEW_LINE k = 3 NEW_LINE a = maximumPalinUsingKChanges ( strr , k ) NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE"}
{"text":"Function to find the number of triplets whose Bitwise AND is 0.","code":"def countTriplets ( A ) : NEW_LINE"}
{"text":"Stores the count of triplets having bitwise AND equal to 0","code":"cnt = 0 ; NEW_LINE"}
{"text":"Stores frequencies of all possible A [ i ] & A [ j ]","code":"tuples = { } ; NEW_LINE"}
{"text":"Traverse the array","code":"for a in A : NEW_LINE"}
{"text":"Update frequency of Bitwise AND of all array elements with a","code":"for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Traverse the array","code":"for a in A : NEW_LINE"}
{"text":"Iterate the map","code":"for t in tuples : NEW_LINE"}
{"text":"If bitwise AND of triplet is zero , increment cnt","code":"if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT"}
{"text":"Return the number of triplets whose Bitwise AND is 0.","code":"return cnt ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Input Array","code":"A = [ 2 , 1 , 3 ] ; NEW_LINE"}
{"text":"Function Call","code":"print ( countTriplets ( A ) ) ; NEW_LINE"}
{"text":"Python3 implementation of above approach","code":"mn = 1000 NEW_LINE"}
{"text":"Recursive function to calculate minimum adjacent pairs with different parity","code":"def parity ( even , odd , v , i ) : NEW_LINE INDENT global mn NEW_LINE DEDENT"}
{"text":"If all the numbers are placed","code":"if ( i == len ( v ) or len ( even ) == 0 or len ( odd ) == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( len ( v ) - 1 ) : NEW_LINE INDENT if ( v [ j ] % 2 != v [ j + 1 ] % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < mn ) : NEW_LINE INDENT mn = count NEW_LINE DEDENT return NEW_LINE DEDENT"}
{"text":"If replacement is not required","code":"if ( v [ i ] != - 1 ) : NEW_LINE INDENT parity ( even , odd , v , i + 1 ) NEW_LINE DEDENT"}
{"text":"If replacement is required","code":"else : NEW_LINE INDENT if ( len ( even ) != 0 ) : NEW_LINE INDENT x = even [ len ( even ) - 1 ] NEW_LINE even . remove ( even [ len ( even ) - 1 ] ) NEW_LINE v [ i ] = x NEW_LINE parity ( even , odd , v , i + 1 ) NEW_LINE DEDENT DEDENT"}
{"text":"backtracking","code":"even . append ( x ) NEW_LINE if ( len ( odd ) != 0 ) : NEW_LINE x = odd [ len ( odd ) - 1 ] NEW_LINE odd . remove ( odd [ len ( odd ) - 1 ] ) NEW_LINE v [ i ] = x NEW_LINE parity ( even , odd , v , i + 1 ) NEW_LINE"}
{"text":"backtracking","code":"odd . append ( x ) NEW_LINE"}
{"text":"Function to display the minimum number of adjacent elements with different parity","code":"def mnDiffParity ( v , n ) : NEW_LINE INDENT global mn NEW_LINE DEDENT"}
{"text":"Store no of even numbers not present in the array","code":"even = [ ] NEW_LINE"}
{"text":"Store no of odd numbers not present in the array","code":"odd = [ ] NEW_LINE m = { i : 0 for i in range ( 100 ) } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE"}
{"text":"Erase exisiting numbers","code":"if ( v [ i ] != - 1 ) : NEW_LINE INDENT m . pop ( v [ i ] ) NEW_LINE DEDENT"}
{"text":"Store non - exisiting even and odd numbers","code":"for key in m . keys ( ) : NEW_LINE INDENT if ( key % 2 == 0 ) : NEW_LINE INDENT even . append ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( key ) NEW_LINE DEDENT DEDENT parity ( even , odd , v , 0 ) NEW_LINE print ( mn + 4 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE v = [ 2 , 1 , 4 , - 1 , - 1 , 6 , - 1 , 8 ] NEW_LINE mnDiffParity ( v , n ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of the approach","code":"MAX = 100005 NEW_LINE adjacent = [ [ ] for i in range ( MAX ) ] NEW_LINE visited = [ False ] * MAX NEW_LINE"}
{"text":"To store the required nodes","code":"startnode = endnode = thirdnode = None NEW_LINE maxi , N = - 1 , None NEW_LINE"}
{"text":"Parent array to retrace the nodes","code":"parent = [ None ] * MAX NEW_LINE"}
{"text":"Visited array to prevent DFS in direction on Diameter path","code":"vis = [ False ] * MAX NEW_LINE"}
{"text":"DFS function to find the startnode","code":"def dfs ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global startnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE dfs ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE startnode = u NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"DFS function to find the endnode of diameter and maintain the parent array","code":"def dfs1 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global endnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE parent [ adjacent [ u ] [ i ] ] = u NEW_LINE dfs1 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE endnode = u NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"DFS function to find the end node of the Longest Branch to Diameter","code":"def dfs2 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global thirdnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if ( not visited [ adjacent [ u ] [ i ] ] and not vis [ adjacent [ u ] [ i ] ] ) : NEW_LINE INDENT temp += 1 NEW_LINE dfs2 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE thirdnode = u NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Function to find the required nodes","code":"def findNodes ( ) : NEW_LINE"}
{"text":"To find start node of diameter","code":"dfs ( 1 , 0 ) NEW_LINE global maxi NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT maxi = - 1 NEW_LINE"}
{"text":"To find end node of diameter","code":"dfs1 ( startnode , 0 ) NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT"}
{"text":"x is the end node of diameter","code":"x = endnode NEW_LINE vis [ startnode ] = True NEW_LINE"}
{"text":"Mark all the nodes on diameter using back tracking","code":"while x != startnode : NEW_LINE INDENT vis [ x ] = True NEW_LINE x = parent [ x ] NEW_LINE DEDENT maxi = - 1 NEW_LINE"}
{"text":"Find the end node of longest branch to diameter","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if vis [ i ] : NEW_LINE INDENT dfs2 ( i , 0 ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE adjacent [ 1 ] . append ( 2 ) NEW_LINE adjacent [ 2 ] . append ( 1 ) NEW_LINE adjacent [ 1 ] . append ( 3 ) NEW_LINE adjacent [ 3 ] . append ( 1 ) NEW_LINE adjacent [ 1 ] . append ( 4 ) NEW_LINE adjacent [ 4 ] . append ( 1 ) NEW_LINE findNodes ( ) NEW_LINE print ( \" ( { } , \u2581 { } , \u2581 { } ) \" . format ( startnode , endnode , thirdnode ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to find percentage increase in the volume of the sphere if radius is increased by a given percentage","code":"def newvol ( x ) : NEW_LINE INDENT print ( \" percentage \u2581 increase \u2581 in \u2581 the \" , pow ( x , 3 ) \/ 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) \/ 100 , \" % \" ) DEDENT"}
{"text":"Driver code","code":"x = 10.0 NEW_LINE newvol ( x ) NEW_LINE"}
{"text":"Python3 program to find the length chord of the circle whose radius and the angle subtended at the centre is also given","code":"import math as mt NEW_LINE"}
{"text":"Function to find the length of the chord","code":"def length_of_chord ( r , x ) : NEW_LINE INDENT print ( \" The \u2581 length \u2581 of \u2581 the \u2581 chord \" , \" \u2581 of \u2581 the \u2581 circle \u2581 is \u2581 \" , 2 * r * mt . sin ( x * ( 3.14 \/ 180 ) ) ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"r = 4 NEW_LINE x = 63 ; NEW_LINE length_of_chord ( r , x ) NEW_LINE"}
{"text":"Python3 Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle","code":"from math import * NEW_LINE"}
{"text":"Function to find the area of the square","code":"def area ( a ) : NEW_LINE"}
{"text":"a cannot be negative","code":"if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"area of the square","code":"area = sqrt ( a ) \/ 6 NEW_LINE return area NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 NEW_LINE print ( round ( area ( a ) , 6 ) ) NEW_LINE DEDENT"}
{"text":"Python 3 program to find the longest rod that can fit in a cuboid","code":"from math import * NEW_LINE"}
{"text":"Function to find the length","code":"def longestRodInCuboid ( length , breadth , height ) : NEW_LINE"}
{"text":"temporary variable to hold the intermediate result","code":"temp = length * length + breadth * breadth + height * height NEW_LINE"}
{"text":"length of longest rod is calculated using square root function","code":"result = sqrt ( temp ) NEW_LINE return result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT length , breadth , height = 12 , 9 , 8 NEW_LINE DEDENT"}
{"text":"calling longestRodInCuboid ( ) function to get the length of longest rod","code":"print ( longestRodInCuboid ( length , breadth , height ) ) NEW_LINE"}
{"text":"function to Check whether a given point lies inside or on the rectangle or not","code":"def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print ( \" Given \u2581 point \u2581 lies \u2581 inside \" \" \u2581 the \u2581 rectangle \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Given \u2581 point \u2581 does \u2581 not \u2581 lie \" \" \u2581 on \u2581 the \u2581 rectangle \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Return the maximum volume .","code":"def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE DEDENT"}
{"text":"for length","code":"i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE DEDENT"}
{"text":"for breadth","code":"for j in range ( s ) : NEW_LINE"}
{"text":"for height","code":"k = s - i - j NEW_LINE"}
{"text":"calculating maximum volume .","code":"maxvalue = max ( maxvalue , i * j * k ) NEW_LINE return maxvalue NEW_LINE"}
{"text":"Driven Program","code":"s = 8 NEW_LINE print ( maxvolume ( s ) ) NEW_LINE"}
{"text":"Return the maximum volume .","code":"def maxvolume ( s ) : NEW_LINE"}
{"text":"finding length","code":"length = int ( s \/ 3 ) NEW_LINE s -= length NEW_LINE"}
{"text":"finding breadth","code":"breadth = s \/ 2 NEW_LINE"}
{"text":"finding height","code":"height = s - breadth NEW_LINE return int ( length * breadth * height ) NEW_LINE"}
{"text":"Driven Program","code":"s = 8 NEW_LINE print ( maxvolume ( s ) ) NEW_LINE"}
{"text":"Python3 program to find area of a Hexagon","code":"import math NEW_LINE"}
{"text":"Function for calculating area of the hexagon .","code":"def hexagonArea ( s ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) \/ 2 ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"length of a side .","code":"s = 4 NEW_LINE print ( \" Area : \" , \" { 0 : . 4f } \" . format ( hexagonArea ( s ) ) ) NEW_LINE"}
{"text":"function for finding max squares","code":"def maxSquare ( b , m ) : NEW_LINE"}
{"text":"return in O ( 1 ) with derived formula","code":"return ( b \/ m - 1 ) * ( b \/ m ) \/ 2 NEW_LINE"}
{"text":"driver program","code":"b = 10 NEW_LINE m = 2 NEW_LINE print ( int ( maxSquare ( b , m ) ) ) NEW_LINE"}
{"text":"Python program to check existence of right triangle .","code":"from math import sqrt NEW_LINE"}
{"text":"Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1.","code":"def findRightAngle ( A , H ) : NEW_LINE"}
{"text":"Descriminant of the equation","code":"D = pow ( H , 4 ) - 16 * A * A NEW_LINE if D >= 0 : NEW_LINE"}
{"text":"applying the linear equation formula to find both the roots","code":"root1 = ( H * H + sqrt ( D ) ) \/ 2 NEW_LINE root2 = ( H * H - sqrt ( D ) ) \/ 2 NEW_LINE a = sqrt ( root1 ) NEW_LINE b = sqrt ( root2 ) NEW_LINE if b >= a : NEW_LINE INDENT print a , b , H NEW_LINE DEDENT else : NEW_LINE INDENT print b , a , H NEW_LINE DEDENT else : NEW_LINE print \" - 1\" NEW_LINE"}
{"text":"Driver code Area is 6 and hypotenuse is 5.","code":"findRightAngle ( 6 , 5 ) NEW_LINE"}
{"text":"Python3 program to count number of 2 x 2 squares in a right isosceles triangle","code":"def numberOfSquares ( base ) : NEW_LINE"}
{"text":"removing the extra part we would always need","code":"base = ( base - 2 ) NEW_LINE"}
{"text":"Since each square has base of length of 2","code":"base = base \/\/ 2 NEW_LINE return base * ( base + 1 ) \/ 2 NEW_LINE"}
{"text":"Driver code","code":"base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE"}
{"text":"Function to find the Bitwise OR of Bitwise AND of all possible subarrays after performing the every query","code":"def performQuery ( arr , Q ) : NEW_LINE"}
{"text":"Traversing each pair of the query","code":"for i in range ( 0 , len ( Q ) ) : NEW_LINE"}
{"text":"Stores the Bitwise OR","code":"orr = 0 NEW_LINE"}
{"text":"Updating the array","code":"x = Q [ i ] [ 0 ] NEW_LINE arr [ x - 1 ] = Q [ i ] [ 1 ] NEW_LINE"}
{"text":"Find the Bitwise OR of new updated array","code":"for j in range ( 0 , len ( arr ) ) : NEW_LINE INDENT orr = orr | arr [ j ] NEW_LINE DEDENT"}
{"text":"Print the ans","code":"print ( orr , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 3 ] NEW_LINE Q = [ [ 1 , 4 ] , [ 3 , 0 ] ] NEW_LINE performQuery ( arr , Q ) NEW_LINE"}
{"text":"Function to form the smallest number possible","code":"def smallest ( k , d ) : NEW_LINE INDENT cnt = 1 NEW_LINE m = d % k NEW_LINE DEDENT"}
{"text":"Array to mark the remainders counted already","code":"v = [ 0 for i in range ( k ) ] ; NEW_LINE v [ m ] = 1 NEW_LINE"}
{"text":"Iterate over the range","code":"while ( 1 ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k NEW_LINE DEDENT"}
{"text":"If that remainder is already found , return - 1","code":"if ( v [ m ] == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT v [ m ] = 1 NEW_LINE cnt += 1 NEW_LINE return - 1 NEW_LINE"}
{"text":"Driver Code","code":"d = 1 NEW_LINE k = 41 NEW_LINE print ( smallest ( k , d ) ) NEW_LINE"}
{"text":"Function to find fibonacci number","code":"def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT"}
{"text":"Function for finding number of vertices in fibonacci cube graph","code":"def findVertices ( n ) : NEW_LINE"}
{"text":"return fibonacci number for f ( n + 2 )","code":"return fib ( n + 2 ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findVertices ( n ) ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to check if it is possible to modify the array such that there is no common factor between array elements except 1","code":"def checkCommonDivisor ( arr , N , X ) : NEW_LINE"}
{"text":"Stores GCD of the array","code":"G = 0 NEW_LINE"}
{"text":"Calculate GCD of the array","code":"for i in range ( N ) : NEW_LINE INDENT G = math . gcd ( G , arr [ i ] ) NEW_LINE DEDENT copy_G = G NEW_LINE for divisor in range ( 2 , X + 1 ) : NEW_LINE"}
{"text":"If the current divisor is smaller than X","code":"while ( G % divisor == 0 ) : NEW_LINE"}
{"text":"Divide GCD by the current divisor","code":"G = G \/\/ divisor NEW_LINE"}
{"text":"If possible","code":"if ( G <= X ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"}
{"text":"Print the modified array","code":"for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] \/\/ copy_G , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given array","code":"arr = [ 6 , 15 , 6 ] NEW_LINE X = 6 NEW_LINE"}
{"text":"Size of the array","code":"N = len ( arr ) NEW_LINE checkCommonDivisor ( arr , N , X ) NEW_LINE"}
{"text":"Node of a doubly linked list","code":"class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT"}
{"text":"Function to reverse a Doubly Linked List","code":"def reverse ( head_ref ) : NEW_LINE INDENT temp = None NEW_LINE current = head_ref NEW_LINE DEDENT"}
{"text":"swap next and prev for all nodes of doubly linked list","code":"while ( current != None ) : NEW_LINE INDENT temp = current . prev NEW_LINE current . prev = current . next NEW_LINE current . next = temp NEW_LINE current = current . prev NEW_LINE DEDENT"}
{"text":"Before changing head , check for the cases like empty list and list with only one node","code":"if ( temp != None ) : NEW_LINE INDENT head_ref = temp . prev NEW_LINE return head_ref NEW_LINE DEDENT"}
{"text":"Function to merge two sorted doubly linked lists","code":"def merge ( first , second ) : NEW_LINE"}
{"text":"If first linked list is empty","code":"if ( first == None ) : NEW_LINE INDENT return second NEW_LINE DEDENT"}
{"text":"If second linked list is empty","code":"if ( second == None ) : NEW_LINE INDENT return first NEW_LINE DEDENT"}
{"text":"Pick the smaller value","code":"if ( first . data < second . data ) : NEW_LINE INDENT first . next = merge ( first . next , second ) NEW_LINE first . next . prev = first NEW_LINE first . prev = None NEW_LINE return first NEW_LINE DEDENT else : NEW_LINE INDENT second . next = merge ( first , second . next ) NEW_LINE second . next . prev = second NEW_LINE second . prev = None NEW_LINE return second NEW_LINE DEDENT"}
{"text":"function to sort a biotonic doubly linked list","code":"def sort ( head ) : NEW_LINE"}
{"text":"if list is empty or if it contains a single node only","code":"if ( head == None or head . next == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT current = head . next NEW_LINE while ( current != None ) : NEW_LINE"}
{"text":"if true , then ' current ' is the first node which is smaller than its previous node","code":"if ( current . data < current . prev . data ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"move to the next node","code":"current = current . next NEW_LINE"}
{"text":"if true , then list is already sorted","code":"if ( current == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT"}
{"text":"spilt into two lists , one starting with ' head ' and other starting with ' current '","code":"current . prev . next = None NEW_LINE current . prev = None NEW_LINE"}
{"text":"reverse the list starting with ' current '","code":"current = reverse ( current ) NEW_LINE"}
{"text":"merge the two lists and return the final merged doubly linked list","code":"return merge ( head , current ) NEW_LINE"}
{"text":"Function to insert a node at the beginning of the Doubly Linked List","code":"def push ( head_ref , new_data ) : NEW_LINE"}
{"text":"allocate node","code":"new_node = Node ( ) NEW_LINE"}
{"text":"put in the data","code":"new_node . data = new_data NEW_LINE"}
{"text":"since we are adding at the beginning , prev is always None","code":"new_node . prev = None NEW_LINE"}
{"text":"link the old list off the new node","code":"new_node . next = ( head_ref ) NEW_LINE"}
{"text":"change prev of head node to new node","code":"if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . prev = new_node NEW_LINE DEDENT"}
{"text":"move the head to point to the new node","code":"( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE"}
{"text":"Function to print nodes in a given doubly linked list","code":"def printList ( head ) : NEW_LINE"}
{"text":"if list is empty","code":"if ( head == None ) : NEW_LINE INDENT print ( \" Doubly \u2581 Linked \u2581 list \u2581 empty \" ) NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT"}
{"text":"Driver Code","code":"head = None NEW_LINE"}
{"text":"Create the doubly linked list : 2 < .5 < .7 < .12 < .10 < .6 < .4 < .1","code":"head = push ( head , 1 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE print ( \" Original \u2581 Doubly \u2581 linked \u2581 list : n \" ) NEW_LINE printList ( head ) NEW_LINE"}
{"text":"sort the biotonic DLL","code":"head = sort ( head ) NEW_LINE print ( \" Doubly linked list after sorting : \" ) NEW_LINE printList ( head ) NEW_LINE"}
{"text":"A linked list node","code":"class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"}
{"text":"Utility function to print the linked list","code":"def printlist ( head ) : NEW_LINE INDENT if ( not head ) : NEW_LINE INDENT print ( \" Empty \u2581 List \" ) NEW_LINE return NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE if ( head . next ) : NEW_LINE INDENT print ( end = \" - > \u2581 \" ) NEW_LINE DEDENT head = head . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Utility function for checking vowel","code":"def isVowel ( x ) : NEW_LINE INDENT return ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' or x == ' A ' or x == ' E ' or x == ' I ' or x == ' O ' or x == ' U ' ) NEW_LINE DEDENT"}
{"text":"function to arrange consonants and vowels nodes","code":"def arrange ( head ) : NEW_LINE INDENT newHead = head NEW_LINE DEDENT"}
{"text":"for keep track of vowel","code":"latestVowel = None NEW_LINE curr = head NEW_LINE"}
{"text":"list is empty","code":"if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT"}
{"text":"We need to discover the first vowel in the list . It is going to be the returned head , and also the initial latestVowel .","code":"if ( isVowel ( head . data ) ) : NEW_LINE"}
{"text":"first element is a vowel . It will also be the new head and the initial latestVowel","code":"latestVowel = head NEW_LINE else : NEW_LINE"}
{"text":"First element is not a vowel . Iterate through the list until we find a vowel . Note that curr points to the element * before * the element with the vowel .","code":"while ( curr . next != None and not isVowel ( curr . next . data ) ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT"}
{"text":"This is an edge case where there are only consonants in the list .","code":"if ( curr . next == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT"}
{"text":"Set the initial latestVowel and the new head to the vowel item that we found . Relink the chain of consonants after that vowel item : old_head_consonant . consonant1 . consonant2 . vowel . rest_of_list becomes vowel . old_head_consonant . consonant1 . consonant2 . rest_of_list","code":"latestVowel = newHead = curr . next NEW_LINE curr . next = curr . next . next NEW_LINE latestVowel . next = head NEW_LINE"}
{"text":"Now traverse the list . Curr is always the item * before * the one we are checking , so that we can use it to re - link .","code":"while ( curr != None and curr . next != None ) : NEW_LINE INDENT if ( isVowel ( curr . next . data ) ) : NEW_LINE DEDENT"}
{"text":"The next discovered item is a vowel","code":"if ( curr == latestVowel ) : NEW_LINE"}
{"text":"If it comes directly after the previous vowel , we don 't need to  move items around, just mark the  new latestVowel and advance curr.","code":"latestVowel = curr = curr . next NEW_LINE else : NEW_LINE"}
{"text":"But if it comes after an intervening chain of consonants , we need to chain the newly discovered vowel right after the old vowel . Curr is not changed as after the re - linking it will have a new next , that has not been checked yet , and we always keep curr at one before the next to check .","code":"temp = latestVowel . next NEW_LINE"}
{"text":"Chain in new vowel","code":"latestVowel . next = curr . next NEW_LINE"}
{"text":"Advance latestVowel","code":"latestVowel = latestVowel . next NEW_LINE"}
{"text":"Remove found vowel from previous place","code":"curr . next = curr . next . next NEW_LINE"}
{"text":"Re - link chain of consonants after latestVowel","code":"latestVowel . next = temp NEW_LINE else : NEW_LINE"}
{"text":"No vowel in the next element , advance curr .","code":"curr = curr . next NEW_LINE return newHead NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = Node ( ' a ' ) NEW_LINE head . next = Node ( ' b ' ) NEW_LINE head . next . next = Node ( ' c ' ) NEW_LINE head . next . next . next = Node ( ' e ' ) NEW_LINE head . next . next . next . next = Node ( ' d ' ) NEW_LINE head . next . next . next . next . next = Node ( ' o ' ) NEW_LINE head . next . next . next . next . next . next = Node ( ' x ' ) NEW_LINE head . next . next . next . next . next . next . next = Node ( ' i ' ) NEW_LINE print ( \" Linked \u2581 list \u2581 before \u2581 : \" ) NEW_LINE printlist ( head ) NEW_LINE head = arrange ( head ) NEW_LINE print ( \" Linked \u2581 list \u2581 after \u2581 : \" ) NEW_LINE printlist ( head ) NEW_LINE DEDENT"}
{"text":"helper function to create a new Node","code":"class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = self . left = None NEW_LINE DEDENT DEDENT def KthLargestUsingMorrisTraversal ( root , k ) : NEW_LINE INDENT curr = root NEW_LINE Klargest = None NEW_LINE DEDENT"}
{"text":"count variable to keep count of visited Nodes","code":"count = 0 NEW_LINE while ( curr != None ) : NEW_LINE"}
{"text":"if right child is None","code":"if ( curr . right == None ) : NEW_LINE"}
{"text":"first increment count and check if count = k","code":"count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT Klargest = curr NEW_LINE DEDENT"}
{"text":"otherwise move to the left child","code":"curr = curr . left NEW_LINE else : NEW_LINE"}
{"text":"find inorder successor of current Node","code":"succ = curr . right NEW_LINE while ( succ . left != None and succ . left != curr ) : NEW_LINE INDENT succ = succ . left NEW_LINE DEDENT if ( succ . left == None ) : NEW_LINE"}
{"text":"set left child of successor to the current Node","code":"succ . left = curr NEW_LINE"}
{"text":"move current to its right","code":"curr = curr . right NEW_LINE"}
{"text":"restoring the tree back to original binary search tree removing threaded links","code":"else : NEW_LINE INDENT succ . left = None NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT Klargest = curr NEW_LINE DEDENT DEDENT"}
{"text":"move current to its left child","code":"curr = curr . left NEW_LINE return Klargest NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Constructed binary tree is 4 \/ \\ 2 7 \/ \\ \/ \\ 1 3 6 10","code":"root = newNode ( 4 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 7 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 10 ) NEW_LINE print ( \" Finding \u2581 K - th \u2581 largest \u2581 Node \u2581 in \u2581 BST \u2581 : \u2581 \" , KthLargestUsingMorrisTraversal ( root , 2 ) . data ) NEW_LINE"}
{"text":"Python implementation to sort the rows of matrix in ascending order followed by sorting the columns in descending order","code":"MAX_SIZE = 10 NEW_LINE"}
{"text":"function to sort each row of the matrix according to the order specified by ascending .","code":"def sortByRow ( mat , n , ascending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ascending ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"function to find transpose of the matrix","code":"def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT DEDENT"}
{"text":"swapping element at index ( i , j ) by element at index ( j , i )","code":"temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = temp NEW_LINE"}
{"text":"function to sort the matrix row - wise and column - wise","code":"def sortMatRowAndColWise ( mat , n ) : NEW_LINE"}
{"text":"sort rows of mat [ ] [ ]","code":"sortByRow ( mat , n , True ) NEW_LINE"}
{"text":"get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) NEW_LINE"}
{"text":"again sort rows of mat [ ] [ ] in descending order .","code":"sortByRow ( mat , n , False ) NEW_LINE"}
{"text":"again get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) NEW_LINE"}
{"text":"function to print the matrix","code":"def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( \" Original \u2581 Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix \u2581 After \u2581 Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE"}
{"text":"Python 3 implementation to sort the matrix row - wise and column - wise","code":"MAX_SIZE = 10 NEW_LINE"}
{"text":"function to sort each row of the matrix","code":"def sortByRow ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE DEDENT"}
{"text":"sorting row number 'i","code":"for j in range ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] > mat [ i ] [ j + 1 ] : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ i ] [ j + 1 ] NEW_LINE mat [ i ] [ j + 1 ] = temp NEW_LINE DEDENT DEDENT"}
{"text":"function to find transpose of the matrix","code":"def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT DEDENT"}
{"text":"swapping element at index ( i , j ) by element at index ( j , i )","code":"t = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = t NEW_LINE"}
{"text":"function to sort the matrix row - wise and column - wise","code":"def sortMatRowAndColWise ( mat , n ) : NEW_LINE"}
{"text":"sort rows of mat [ ] [ ]","code":"sortByRow ( mat , n ) NEW_LINE"}
{"text":"get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) NEW_LINE"}
{"text":"again sort rows of mat [ ] [ ]","code":"sortByRow ( mat , n ) NEW_LINE"}
{"text":"again get transpose of mat [ ] [ ]","code":"transpose ( mat , n ) NEW_LINE"}
{"text":"function to print the matrix","code":"def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str ( mat [ i ] [ j ] ) , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"mat = [ [ 4 , 1 , 3 ] , [ 9 , 6 , 8 ] , [ 5 , 2 , 7 ] ] NEW_LINE n = 3 NEW_LINE print ( \" Original \u2581 Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix After Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE"}
{"text":"Function for calculating Magic square","code":"def DoublyEven ( n ) : NEW_LINE"}
{"text":"2 - D matrix with all entries as 0","code":"arr = [ [ ( n * y ) + x + 1 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE"}
{"text":"Change value of array elements at fix location as per the rule ( n * n + 1 ) - arr [ i ] [ [ j ] Corners of order ( n \/ 4 ) * ( n \/ 4 ) Top left corner","code":"for i in range ( 0 , n \/ 4 ) : NEW_LINE INDENT for j in range ( 0 , n \/ 4 ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Top right corner","code":"for i in range ( 0 , n \/ 4 ) : NEW_LINE INDENT for j in range ( 3 * ( n \/ 4 ) , n ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Bottom Left corner","code":"for i in range ( 3 * ( n \/ 4 ) , n ) : NEW_LINE INDENT for j in range ( 0 , n \/ 4 ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Bottom Right corner","code":"for i in range ( 3 * ( n \/ 4 ) , n ) : NEW_LINE INDENT for j in range ( 3 * ( n \/ 4 ) , n ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Centre of matrix , order ( n \/ 2 ) * ( n \/ 2 )","code":"for i in range ( n \/ 4 , 3 * ( n \/ 4 ) ) : NEW_LINE INDENT for j in range ( n \/ 4 , 3 * ( n \/ 4 ) ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Printing the square","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ' % 2d \u2581 ' % ( arr [ i ] [ j ] ) , NEW_LINE DEDENT print NEW_LINE DEDENT"}
{"text":"Driver Program","code":"n = 8 NEW_LINE"}
{"text":"Function call","code":"DoublyEven ( n ) NEW_LINE"}
{"text":"rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B","code":"cola = 2 NEW_LINE rowa = 3 NEW_LINE colb = 3 NEW_LINE rowb = 2 NEW_LINE"}
{"text":"Function to computes the Kronecker Product of two matrices","code":"def Kroneckerproduct ( A , B ) : NEW_LINE INDENT C = [ [ 0 for j in range ( cola * colb ) ] for i in range ( rowa * rowb ) ] NEW_LINE DEDENT"}
{"text":"i loops till rowa","code":"for i in range ( 0 , rowa ) : NEW_LINE"}
{"text":"k loops till rowb","code":"for k in range ( 0 , rowb ) : NEW_LINE"}
{"text":"j loops till cola","code":"for j in range ( 0 , cola ) : NEW_LINE"}
{"text":"l loops till colb","code":"for l in range ( 0 , colb ) : NEW_LINE"}
{"text":"Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C","code":"C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] NEW_LINE print ( C [ i + l + 1 ] [ j + k + 1 ] , end = ' \u2581 ' ) NEW_LINE print ( \" \" ) NEW_LINE"}
{"text":"Driver code .","code":"A = [ [ 0 for j in range ( 2 ) ] for i in range ( 3 ) ] NEW_LINE B = [ [ 0 for j in range ( 3 ) ] for i in range ( 2 ) ] NEW_LINE A [ 0 ] [ 0 ] = 1 NEW_LINE A [ 0 ] [ 1 ] = 2 NEW_LINE A [ 1 ] [ 0 ] = 3 NEW_LINE A [ 1 ] [ 1 ] = 4 NEW_LINE A [ 2 ] [ 0 ] = 1 NEW_LINE A [ 2 ] [ 1 ] = 0 NEW_LINE B [ 0 ] [ 0 ] = 0 NEW_LINE B [ 0 ] [ 1 ] = 5 NEW_LINE B [ 0 ] [ 2 ] = 2 NEW_LINE B [ 1 ] [ 0 ] = 6 NEW_LINE B [ 1 ] [ 1 ] = 7 NEW_LINE B [ 1 ] [ 2 ] = 3 NEW_LINE Kroneckerproduct ( A , B ) NEW_LINE"}
{"text":"Function to check matrix is in lower triangular","code":"def islowertriangular ( M ) : NEW_LINE INDENT for i in range ( 0 , len ( M ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( M ) ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT"}
{"text":"Driver function .","code":"M = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 4 , 0 , 0 ] , [ 4 , 6 , 2 , 0 ] , [ 0 , 4 , 7 , 6 ] ] NEW_LINE"}
{"text":"Function call","code":"if islowertriangular ( M ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to check matrix is in upper triangular","code":"def isuppertriangular ( M ) : NEW_LINE INDENT for i in range ( 1 , len ( M ) ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT"}
{"text":"Driver function .","code":"M = [ [ 1 , 3 , 5 , 3 ] , [ 0 , 4 , 6 , 2 ] , [ 0 , 0 , 2 , 5 ] , [ 0 , 0 , 0 , 6 ] ] NEW_LINE if isuppertriangular ( M ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"no of columns","code":"m = 3 NEW_LINE"}
{"text":"no of rows","code":"n = 2 NEW_LINE"}
{"text":"function to calculate the number of non empty sets of cell","code":"def countSets ( a ) : NEW_LINE"}
{"text":"stores the final answer","code":"res = 0 NEW_LINE"}
{"text":"traverses row - wise","code":"for i in range ( n ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT"}
{"text":"traverses column wise","code":"for i in range ( m ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] [ i ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT"}
{"text":"at the end subtract n * m as no of single sets have been added twice .","code":"return res - ( n * m ) NEW_LINE"}
{"text":"Driver program to test the above function .","code":"a = [ [ 1 , 0 , 1 ] , [ 0 , 1 , 0 ] ] NEW_LINE print ( countSets ( a ) ) NEW_LINE"}
{"text":"Fills transpose of mat [ N ] [ N ] in tr [ N ] [ N ]","code":"def transpose ( mat , tr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT tr [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Returns true if mat [ N ] [ N ] is symmetric , else false","code":"def isSymmetric ( mat , N ) : NEW_LINE INDENT tr = [ [ 0 for j in range ( len ( mat [ 0 ] ) ) ] for i in range ( len ( mat ) ) ] NEW_LINE transpose ( mat , tr , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT"}
{"text":"Driver code","code":"mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT"}
{"text":"Returns true if mat [ N ] [ N ] is symmetric , else false","code":"def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT"}
{"text":"Driver code","code":"mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT"}
{"text":"Python3 program to find trace and normal of given matrix","code":"import math NEW_LINE"}
{"text":"Size of given matrix","code":"MAX = 100 ; NEW_LINE"}
{"text":"Returns Normal of a matrix of size n x n","code":"def findNormal ( mat , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return math . floor ( math . sqrt ( sum ) ) ; NEW_LINE DEDENT"}
{"text":"Returns trace of a matrix of size n x n","code":"def findTrace ( mat , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] ; NEW_LINE print ( \" Trace \u2581 of \u2581 Matrix \u2581 = \" , findTrace ( mat , 5 ) ) ; NEW_LINE print ( \" Normal \u2581 of \u2581 Matrix \u2581 = \" , findNormal ( mat , 5 ) ) ; NEW_LINE"}
{"text":"Function for maximum determinant","code":"def maxDet ( n ) : NEW_LINE INDENT return 2 * n * n * n NEW_LINE DEDENT"}
{"text":"Function to print resulatant matrix","code":"def resMatrix ( n ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE DEDENT DEDENT"}
{"text":"three position where 0 appears","code":"if i == 0 and j == 2 : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif i == 1 and j == 0 : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif i == 2 and j == 1 : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"position where n appears","code":"else : NEW_LINE INDENT print ( n , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE"}
{"text":"Driver code","code":"n = 15 NEW_LINE print ( \" Maximum \u2581 Detrminat = \" , maxDet ( n ) ) NEW_LINE print ( \" Resultant \u2581 Matrix : \" ) NEW_LINE resMatrix ( n ) NEW_LINE"}
{"text":"Python implementation of Naive method to count of negative numbers in M [ n ] [ m ]","code":"def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT"}
{"text":"Follow the path shown using arrows above","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE DEDENT DEDENT"}
{"text":"no more negative numbers in this row","code":"break NEW_LINE return count NEW_LINE"}
{"text":"Driver code","code":"M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE print ( countNegative ( M , 3 , 4 ) ) NEW_LINE"}
{"text":"Function to count negative number","code":"def countNegative ( M , n , m ) : NEW_LINE"}
{"text":"initialize result","code":"count = 0 NEW_LINE"}
{"text":"Start with top right corner","code":"i = 0 NEW_LINE j = m - 1 NEW_LINE"}
{"text":"Follow the path shown using arrows above","code":"while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE DEDENT"}
{"text":"j is the index of the last negative number in this row . So there must be ( j + 1 )","code":"count += ( j + 1 ) NEW_LINE"}
{"text":"negative numbers in this row .","code":"i += 1 NEW_LINE else : NEW_LINE"}
{"text":"move to the left and see if we can find a negative number there","code":"j -= 1 NEW_LINE return count NEW_LINE"}
{"text":"Driver code","code":"M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE print ( countNegative ( M , 3 , 4 ) ) NEW_LINE"}
{"text":"Recursive binary search to get last negative value in a row between a start and an end","code":"def getLastNegativeIndex ( array , start , end , n ) : NEW_LINE"}
{"text":"Base case","code":"if ( start == end ) : NEW_LINE INDENT return start NEW_LINE DEDENT"}
{"text":"Get the mid for binary search","code":"mid = start + ( end - start ) \/\/ 2 NEW_LINE"}
{"text":"If current element is negative","code":"if ( array [ mid ] < 0 ) : NEW_LINE"}
{"text":"If it is the rightmost negative element in the current row","code":"if ( mid + 1 < n and array [ mid + 1 ] >= 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT"}
{"text":"Check in the right half of the array","code":"return getLastNegativeIndex ( array , mid + 1 , end , n ) NEW_LINE else : NEW_LINE"}
{"text":"Check in the left half of the array","code":"return getLastNegativeIndex ( array , start , mid - 1 , n ) NEW_LINE"}
{"text":"Function to return the count of negative numbers in the given matrix","code":"def countNegative ( M , n , m ) : NEW_LINE"}
{"text":"Initialize result","code":"count = 0 NEW_LINE"}
{"text":"To store the index of the rightmost negative element in the row under consideration","code":"nextEnd = m - 1 NEW_LINE"}
{"text":"Iterate over all rows of the matrix","code":"for i in range ( n ) : NEW_LINE"}
{"text":"If the first element of the current row is positive then there will be no negatives in the matrix below or after it","code":"if ( M [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Run binary search only until the index of last negative Integer in the above row","code":"nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd , 4 ) NEW_LINE count += nextEnd + 1 NEW_LINE return count NEW_LINE"}
{"text":"Driver code","code":"M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE r = 3 NEW_LINE c = 4 NEW_LINE print ( countNegative ( M , r , c ) ) NEW_LINE"}
{"text":"A Naive method to find maximum value of mat [ d ] [ e ] - mat [ a ] [ b ] such that d > a and e > b","code":"N = 5 NEW_LINE"}
{"text":"The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b .","code":"def findMaxValue ( mat ) : NEW_LINE"}
{"text":"stores maximum value","code":"maxValue = 0 NEW_LINE"}
{"text":"Consider all possible pairs mat [ a ] [ b ] and mat [ d ] [ e ]","code":"for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : NEW_LINE INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue ; NEW_LINE"}
{"text":"Driver Code","code":"mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] ; NEW_LINE print ( \" Maximum \u2581 Value \u2581 is \u2581 \" + str ( findMaxValue ( mat ) ) ) NEW_LINE"}
{"text":"An efficient method to find maximum value of mat [ d ] - ma [ a ] [ b ] such that c > a and d > b","code":"import sys NEW_LINE N = 5 NEW_LINE"}
{"text":"The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b .","code":"def findMaxValue ( mat ) : NEW_LINE"}
{"text":"stores maximum value","code":"maxValue = - sys . maxsize - 1 NEW_LINE"}
{"text":"maxArr [ i ] [ j ] stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 )","code":"maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE"}
{"text":"last element of maxArr will be same 's as of the input matrix","code":"maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] NEW_LINE"}
{"text":"preprocess last row Initialize max","code":"maxv = mat [ N - 1 ] [ N - 1 ] ; NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > maxv ) : NEW_LINE INDENT maxv = mat [ N - 1 ] [ j ] NEW_LINE DEDENT maxArr [ N - 1 ] [ j ] = maxv NEW_LINE DEDENT"}
{"text":"preprocess last column Initialize max","code":"maxv = mat [ N - 1 ] [ N - 1 ] ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] > maxv ) : NEW_LINE INDENT maxv = mat [ i ] [ N - 1 ] NEW_LINE DEDENT maxArr [ i ] [ N - 1 ] = maxv NEW_LINE DEDENT"}
{"text":"preprocess rest of the matrix from bottom","code":"for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE DEDENT"}
{"text":"Update maxValue","code":"if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) NEW_LINE DEDENT"}
{"text":"set maxArr ( i , j )","code":"maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) NEW_LINE return maxValue NEW_LINE"}
{"text":"Driver Code","code":"mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] NEW_LINE print ( \" Maximum \u2581 Value \u2581 is \" , findMaxValue ( mat ) ) NEW_LINE"}
{"text":"Python 3 program to Print all elements in sorted order from row and column wise sorted matrix","code":"import sys NEW_LINE INF = sys . maxsize NEW_LINE N = 4 NEW_LINE"}
{"text":"A utility function to youngify a Young Tableau . This is different from standard youngify . It assumes that the value at mat [ 0 ] [ 0 ] is infinite .","code":"def youngify ( mat , i , j ) : NEW_LINE"}
{"text":"Find the values at down and right sides of mat [ i ] [ j ]","code":"downVal = mat [ i + 1 ] [ j ] if ( i + 1 < N ) else INF NEW_LINE rightVal = mat [ i ] [ j + 1 ] if ( j + 1 < N ) else INF NEW_LINE"}
{"text":"If mat [ i ] [ j ] is the down right corner element , return","code":"if ( downVal == INF and rightVal == INF ) : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"Move the smaller of two values ( downVal and rightVal ) to mat [ i ] [ j ] and recur for smaller value","code":"if ( downVal < rightVal ) : NEW_LINE INDENT mat [ i ] [ j ] = downVal NEW_LINE mat [ i + 1 ] [ j ] = INF NEW_LINE youngify ( mat , i + 1 , j ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = rightVal NEW_LINE mat [ i ] [ j + 1 ] = INF NEW_LINE youngify ( mat , i , j + 1 ) NEW_LINE DEDENT"}
{"text":"A utility function to extract minimum element from Young tableau","code":"def extractMin ( mat ) : NEW_LINE INDENT ret = mat [ 0 ] [ 0 ] NEW_LINE mat [ 0 ] [ 0 ] = INF NEW_LINE youngify ( mat , 0 , 0 ) NEW_LINE return ret NEW_LINE DEDENT"}
{"text":"This function uses extractMin ( ) to print elements in sorted order","code":"def printSorted ( mat ) : NEW_LINE INDENT print ( \" Elements \u2581 of \u2581 matrix \u2581 in \u2581 sorted \u2581 order \u2581 n \" ) NEW_LINE i = 0 NEW_LINE while i < N * N : NEW_LINE INDENT print ( extractMin ( mat ) , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] ] NEW_LINE printSorted ( mat ) NEW_LINE DEDENT"}
{"text":"size k x k Size of given matrix","code":"n = 5 NEW_LINE"}
{"text":"A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n","code":"def printSumSimple ( mat , k ) : NEW_LINE"}
{"text":"k must be smaller than or equal to n","code":"if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"row number of first cell in current sub - square of size k x k","code":"for i in range ( n - k + 1 ) : NEW_LINE"}
{"text":"column of first cell in current sub - square of size k x k","code":"for j in range ( n - k + 1 ) : NEW_LINE"}
{"text":"Calculate and print sum of current sub - square","code":"sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Line separator for sub - squares starting with next row","code":"print ( ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumSimple ( mat , k ) NEW_LINE DEDENT"}
{"text":"Size of given matrix","code":"n = 5 NEW_LINE"}
{"text":"A O ( n ^ 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n","code":"def printSumTricky ( mat , k ) : NEW_LINE INDENT global n NEW_LINE DEDENT"}
{"text":"k must be smaller than or equal to n","code":"if k > n : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"1 : PREPROCESSING To store sums of all strips of size k x 1","code":"stripSum = [ [ None ] * n for i in range ( n ) ] NEW_LINE"}
{"text":"Go column by column","code":"for j in range ( n ) : NEW_LINE"}
{"text":"Calculate sum of first k x 1 rectangle in this column","code":"Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = Sum NEW_LINE"}
{"text":"Calculate sum of remaining rectangles","code":"for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = Sum NEW_LINE DEDENT"}
{"text":"2 : CALCULATE SUM of Sub - Squares using stripSum [ ] [ ]","code":"for i in range ( n - k + 1 ) : NEW_LINE"}
{"text":"Calculate and prsum of first subsquare in this row","code":"Sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT Sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( Sum , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip","code":"for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( Sum , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Driver Code","code":"mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumTricky ( mat , k ) NEW_LINE"}
{"text":"Python3 Program to find transpose of a matrix","code":"M = 3 NEW_LINE N = 4 NEW_LINE"}
{"text":"This function stores transpose of A [ ] [ ] in B [ ] [ ]","code":"def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"driver code","code":"A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] NEW_LINE B = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE transpose ( A , B ) NEW_LINE print ( \" Result \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( B [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Python3 Program to find transpose of a matrix","code":"N = 4 NEW_LINE"}
{"text":"Finds transpose of A [ ] [ ] in - place","code":"def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"driver code","code":"A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE transpose ( A ) NEW_LINE print ( \" Modified \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( A [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"A Naive Recursive Python program to count paths with exactly ' k ' coins","code":"R = 3 NEW_LINE C = 3 NEW_LINE"}
{"text":"Recursive function to count paths with sum k from ( 0 , 0 ) to ( m , n )","code":"def pathCountRec ( mat , m , n , k ) : NEW_LINE"}
{"text":"Base cases","code":"if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT"}
{"text":"( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )","code":"return ( pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE"}
{"text":"A wrapper over pathCountRec ( )","code":"def pathCount ( mat , k ) : NEW_LINE INDENT return pathCountRec ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT"}
{"text":"Driver Program","code":"k = 12 NEW_LINE mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] NEW_LINE print ( pathCount ( mat , k ) ) NEW_LINE"}
{"text":"A Dynamic Programming based Python3 program to count paths with exactly ' k ' coins","code":"R = 3 NEW_LINE C = 3 NEW_LINE MAX_K = 1000 NEW_LINE def pathCountDPRecDP ( mat , m , n , k ) : NEW_LINE"}
{"text":"Base cases","code":"if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT"}
{"text":"If this subproblem is already solved","code":"if ( dp [ m ] [ n ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] [ k ] NEW_LINE DEDENT"}
{"text":"( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )","code":"dp [ m ] [ n ] [ k ] = ( pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE return dp [ m ] [ n ] [ k ] NEW_LINE"}
{"text":"A wrapper over pathCountDPRecDP ( )","code":"def pathCountDP ( mat , k ) : NEW_LINE INDENT return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"k = 12 NEW_LINE dp = [ [ [ - 1 for col in range ( MAX_K ) ] for col in range ( C ) ] for row in range ( R ) ] NEW_LINE mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] NEW_LINE print ( pathCountDP ( mat , k ) ) NEW_LINE"}
{"text":"Python3 implementation to sort the given matrix","code":"SIZE = 10 NEW_LINE"}
{"text":"Function to sort the given matrix","code":"def sortMat ( mat , n ) : NEW_LINE"}
{"text":"Temporary matrix of size n ^ 2","code":"temp = [ 0 ] * ( n * n ) NEW_LINE k = 0 NEW_LINE"}
{"text":"Copy the elements of matrix one by one into temp [ ]","code":"for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT temp [ k ] = mat [ i ] [ j ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT"}
{"text":"sort temp [ ]","code":"temp . sort ( ) NEW_LINE"}
{"text":"copy the elements of temp [ ] one by one in mat [ ] [ ]","code":"k = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] [ j ] = temp [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Function to print the given matrix","code":"def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver program to test above","code":"mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE n = 3 NEW_LINE print ( \" Original \u2581 Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMat ( mat , n ) NEW_LINE print ( \" Matrix After Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE"}
{"text":"An optimized version of Bubble Sort","code":"def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT swapped = False NEW_LINE for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"traverse the array from 0 to n - i - 1. Swap if the element found is greater than the next element","code":"arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE swapped = True NEW_LINE"}
{"text":"IF no two elements were swapped by inner loop , then break","code":"if swapped == False : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Driver code to test above","code":"arr = [ 64 , 34 , 25 , 12 , 22 , 11 , 90 ] NEW_LINE bubbleSort ( arr ) NEW_LINE print ( \" Sorted \u2581 array \u2581 : \" ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( \" % d \" % arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Function to find the cross over point ( the point before which elements aresmaller than or equal to x and afterwhich greater than x )","code":"def findCrossOver ( arr , low , high , x ) : NEW_LINE"}
{"text":"Base cases x is greater than all","code":"if ( arr [ high ] <= x ) : NEW_LINE INDENT return high NEW_LINE DEDENT"}
{"text":"x is smaller than all","code":"if ( arr [ low ] > x ) : NEW_LINE INDENT return low NEW_LINE DEDENT"}
{"text":"Find the middle point","code":"mid = ( low + high ) \/\/ 2 NEW_LINE"}
{"text":"If x is same as middle element , then return mid","code":"if ( arr [ mid ] <= x and arr [ mid + 1 ] > x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT"}
{"text":"If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ]","code":"if ( arr [ mid ] < x ) : NEW_LINE INDENT return findCrossOver ( arr , mid + 1 , high , x ) NEW_LINE DEDENT return findCrossOver ( arr , low , mid - 1 , x ) NEW_LINE"}
{"text":"This function prints k closest elements to x in arr [ ] . n is the number of elements in arr [ ]","code":"def printKclosest ( arr , x , k , n ) : NEW_LINE"}
{"text":"Find the crossover point","code":"l = findCrossOver ( arr , 0 , n - 1 , x ) NEW_LINE"}
{"text":"Right index to search","code":"r = l + 1 NEW_LINE"}
{"text":"To keep track of count of elements already printed","code":"count = 0 NEW_LINE"}
{"text":"If x is present in arr [ ] , then reduce left index . Assumption : all elements in arr [ ] are distinct","code":"if ( arr [ l ] == x ) : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT"}
{"text":"Compare elements on left and right of crossover point to find the k closest elements","code":"while ( l >= 0 and r < n and count < k ) : NEW_LINE INDENT if ( x - arr [ l ] < arr [ r ] - x ) : NEW_LINE INDENT print ( arr [ l ] , end = \" \u2581 \" ) NEW_LINE l -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ r ] , end = \" \u2581 \" ) NEW_LINE r += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT"}
{"text":"If there are no more elements on right side , then print left elements","code":"while ( count < k and l >= 0 ) : NEW_LINE INDENT print ( arr [ l ] , end = \" \u2581 \" ) NEW_LINE l -= 1 NEW_LINE count += 1 NEW_LINE DEDENT"}
{"text":"If there are no more elements on left side , then print right elements","code":"while ( count < k and r < n ) : NEW_LINE INDENT print ( arr [ r ] , end = \" \u2581 \" ) NEW_LINE r += 1 NEW_LINE count += 1 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 ] NEW_LINE n = len ( arr ) NEW_LINE x = 35 NEW_LINE k = 4 NEW_LINE printKclosest ( arr , x , 4 , n ) NEW_LINE DEDENT"}
{"text":"Pyhton implementation of above algorithm","code":"class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"}
{"text":"A utility function to insert a node at the beginning of linked list","code":"def push ( head_ref , new_data ) : NEW_LINE"}
{"text":"allocate node","code":"new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE"}
{"text":"link the old list off the new node","code":"new_node . next = ( head_ref ) NEW_LINE"}
{"text":"move the head to point to the new node","code":"( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE"}
{"text":"function to sort a singly linked list using insertion sort","code":"def insertionSort ( head_ref ) : NEW_LINE"}
{"text":"Initialize sorted linked list","code":"sorted = None NEW_LINE"}
{"text":"Traverse the given linked list and insert every node to sorted","code":"current = head_ref NEW_LINE while ( current != None ) : NEW_LINE"}
{"text":"Store next for next iteration","code":"next = current . next NEW_LINE"}
{"text":"insert current in sorted linked list","code":"sorted = sortedInsert ( sorted , current ) NEW_LINE"}
{"text":"Update current","code":"current = next NEW_LINE"}
{"text":"Update head_ref to point to sorted linked list","code":"head_ref = sorted NEW_LINE return head_ref NEW_LINE"}
{"text":"function to insert a new_node in a list . Note that this function expects a pointer to head_ref as this can modify the head of the input linked list ( similar to push ( ) )","code":"def sortedInsert ( head_ref , new_node ) : NEW_LINE INDENT current = None NEW_LINE DEDENT"}
{"text":"Special case for the head end","code":"if ( head_ref == None or ( head_ref ) . data >= new_node . data ) : NEW_LINE INDENT new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE DEDENT else : NEW_LINE INDENT current = head_ref NEW_LINE DEDENT"}
{"text":"Locate the node before the point of insertion","code":"while ( current . next != None and current . next . data < new_node . data ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT new_node . next = current . next NEW_LINE current . next = new_node NEW_LINE return head_ref NEW_LINE"}
{"text":"BELOW FUNCTIONS ARE JUST UTILITY TO TEST sortedInsert Function to print linked list","code":"def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT"}
{"text":"Driver program to test above functions","code":"a = None NEW_LINE a = push ( a , 5 ) NEW_LINE a = push ( a , 20 ) NEW_LINE a = push ( a , 4 ) NEW_LINE a = push ( a , 3 ) NEW_LINE a = push ( a , 30 ) NEW_LINE print ( \" Linked \u2581 List \u2581 before \u2581 sorting \u2581 \" ) NEW_LINE printList ( a ) NEW_LINE a = insertionSort ( a ) NEW_LINE print ( \" Linked List after sorting   \" ) NEW_LINE printList ( a ) NEW_LINE"}
{"text":"Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n","code":"def count ( S , m , n ) : NEW_LINE"}
{"text":"If n is 0 then there is 1 solution ( do not include any coin )","code":"if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"If n is less than 0 then no solution exists","code":"if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"If there are no coins and n is greater than 0 , then no solution exist","code":"if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ]","code":"return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE"}
{"text":"Driver program to test above function","code":"arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE print ( count ( arr , m , 4 ) ) NEW_LINE"}
{"text":"Dynamic Programming Python implementation of Coin Change problem","code":"def count ( S , m , n ) : NEW_LINE"}
{"text":"table [ i ] will be storing the number of solutions for value i . We need n + 1 rows as the table is constructed in bottom up manner using the base case ( n = 0 ) Initialize all table values as 0","code":"table = [ 0 for k in range ( n + 1 ) ] NEW_LINE"}
{"text":"Base case ( If given value is 0 )","code":"table [ 0 ] = 1 NEW_LINE"}
{"text":"Pick all coins one by one and update the table [ ] values after the index greater than or equal to the value of the picked coin","code":"for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE"}
{"text":"Driver program to test above function","code":"arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"}
{"text":"Python program using memoization","code":"import sys NEW_LINE dp = [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE"}
{"text":"Function for matrix chain multiplication","code":"def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \" , MatrixChainOrder ( arr , n ) ) NEW_LINE"}
{"text":"Dynamic Programming Python implementation of Matrix Chain Multiplication . See the Cormen book for details of the following algorithm","code":"import sys NEW_LINE"}
{"text":"Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n","code":"def MatrixChainOrder ( p , n ) : NEW_LINE"}
{"text":"For simplicity of the program , one extra row and one extra column are allocated in m [ ] [ ] . 0 th row and 0 th column of m [ ] [ ] are not used","code":"m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE"}
{"text":"cost is zero when multiplying one matrix .","code":"for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT"}
{"text":"L is chain length .","code":"for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE DEDENT DEDENT"}
{"text":"q = cost \/ scalar multiplications","code":"q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 2 , 3 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + str ( MatrixChainOrder ( arr , size ) ) ) NEW_LINE"}
{"text":"A Naive recursive solution for Rod cutting problem","code":"import sys NEW_LINE"}
{"text":"A utility function to get the maximum of two integers","code":"def max ( a , b ) : NEW_LINE INDENT return a if ( a > b ) else b NEW_LINE DEDENT"}
{"text":"Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces","code":"def cutRod ( price , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_val = - sys . maxsize - 1 NEW_LINE DEDENT"}
{"text":"Recursively cut the rod in different pieces and compare different configurations","code":"for i in range ( 0 , n ) : NEW_LINE INDENT max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) NEW_LINE DEDENT return max_val NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \" , cutRod ( arr , size ) ) NEW_LINE"}
{"text":"A Dynamic Programming solution for Rod cutting problem","code":"INT_MIN = - 32767 NEW_LINE"}
{"text":"Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces","code":"def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE DEDENT"}
{"text":"Build the table val [ ] in bottom up manner and return the last entry from the table","code":"for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE"}
{"text":"Driver program to test above functions","code":"arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + str ( cutRod ( arr , size ) ) ) NEW_LINE"}
{"text":"Function to multiply two numbers x and y","code":"def multiply ( x , y ) : NEW_LINE"}
{"text":"0 multiplied with anything gives 0","code":"if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Add x one by one","code":"if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT"}
{"text":"The case where y is negative","code":"if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"print ( multiply ( 5 , - 11 ) ) NEW_LINE"}
{"text":"Python program to print all primes smaller than or equal to n using Sieve of Eratosthenes","code":"def SieveOfEratosthenes ( n ) : NEW_LINE"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == True ) : NEW_LINE"}
{"text":"Update all multiples of p","code":"for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"Print all prime numbers","code":"for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT print p , NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 30 NEW_LINE print \" Following \u2581 are \u2581 the \u2581 prime \u2581 numbers \u2581 smaller \" , NEW_LINE print \" than \u2581 or \u2581 equal \u2581 to \" , n NEW_LINE SieveOfEratosthenes ( n ) NEW_LINE DEDENT"}
{"text":"binomialCoeff","code":"def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res \/\/ ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT"}
{"text":"A simple O ( n ^ 3 ) program for Pascal ' s \u2581 Triangle \u2581 Function \u2581 to \u2581 print \u2581 first \u2581 n \u2581 lines \u2581 of \u2581 Pascal ' s Triangle","code":"def printPascal ( n ) : NEW_LINE"}
{"text":"Iterate through every line and print entries in it","code":"for line in range ( 0 , n ) : NEW_LINE"}
{"text":"Every line has number of integers equal to line number","code":"for i in range ( 0 , line + 1 ) : NEW_LINE INDENT print ( binomialCoeff ( line , i ) , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Driver program","code":"n = 7 NEW_LINE printPascal ( n ) NEW_LINE"}
{"text":"A O ( n ^ 2 ) time and O ( n ^ 2 ) extra space method for Pascal 's Triangle","code":"def printPascal ( n : int ) : NEW_LINE"}
{"text":"An auxiliary array to store generated pascal triangle values","code":"arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE"}
{"text":"Iterate through every line and print integer ( s ) in it","code":"for line in range ( 0 , n ) : NEW_LINE"}
{"text":"Every line has number of integers equal to line number","code":"for i in range ( 0 , line + 1 ) : NEW_LINE"}
{"text":"First and last values in every row are 1","code":"if ( i == 0 or i == line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Other values are sum of values just above and left of above","code":"else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , \u2581 end \u2581 = \u2581 \" \" ) NEW_LINE"}
{"text":"Driver Code","code":"n = 5 NEW_LINE printPascal ( n ) NEW_LINE"}
{"text":"Python3 program for Pascal ' s \u2581 Triangle \u2581 A \u2581 O ( n ^ 2 ) \u2581 time \u2581 and \u2581 O ( 1 ) \u2581 extra \u2581 space \u2581 method \u2581 for \u2581 Pascal ' s Triangle Pascal function","code":"def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE DEDENT"}
{"text":"used to represent C ( line , i )","code":"C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE"}
{"text":"The first value in a line is always 1","code":"print ( C , end = \" \u2581 \" ) ; NEW_LINE C = int ( C * ( line - i ) \/ i ) ; NEW_LINE print ( \" \" ) ; NEW_LINE"}
{"text":"Driver code","code":"n = 5 ; NEW_LINE printPascal ( n ) ; NEW_LINE"}
{"text":"Python3 Program to add two numbers without using arithmetic operator","code":"def Add ( x , y ) : NEW_LINE"}
{"text":"Iterate till there is no carry","code":"while ( y != 0 ) : NEW_LINE"}
{"text":"carry now contains common set bits of x and y","code":"carry = x & y NEW_LINE"}
{"text":"Sum of bits of x and y where at least one of the bits is not set","code":"x = x ^ y NEW_LINE"}
{"text":"Carry is shifted by one so that adding it to x gives the required sum","code":"y = carry << 1 NEW_LINE return x NEW_LINE"}
{"text":"Driver Code","code":"print ( Add ( 15 , 32 ) ) NEW_LINE"}
{"text":"This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 , ...","code":"def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT"}
{"text":"Driver program to test above function","code":"n = 6 NEW_LINE"}
{"text":"d must be a power of 2","code":"d = 4 NEW_LINE print ( n , \" moduo \" , d , \" is \" , getModulo ( n , d ) ) NEW_LINE"}
{"text":"Function to get no of set bits in binary representation of positive integer n","code":"def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT"}
{"text":"Program to test function countSetBits","code":"i = 9 NEW_LINE print ( countSetBits ( i ) ) NEW_LINE"}
{"text":"recursive function to count set bits","code":"def countSetBits ( n ) : NEW_LINE"}
{"text":"base case","code":"if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT"}
{"text":"Get value from user","code":"n = 9 NEW_LINE"}
{"text":"function calling","code":"print ( countSetBits ( n ) ) NEW_LINE"}
{"text":"Lookup table","code":"BitsSetTable256 = [ 0 ] * 256 NEW_LINE"}
{"text":"Function to initialise the lookup table","code":"def initialize ( ) : NEW_LINE"}
{"text":"To initially generate the table algorithmically","code":"BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i \/\/ 2 ] NEW_LINE DEDENT"}
{"text":"Function to return the count of set bits in n","code":"def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT"}
{"text":"Initialise the lookup table","code":"initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"}
{"text":"Driver code","code":"print ( bin ( 4 ) . count ( '1' ) ) ; NEW_LINE print ( bin ( 15 ) . count ( '1' ) ) ; NEW_LINE"}
{"text":"Python3 program to count set bits by pre - storing count set bits in nibbles .","code":"num_to_bits = [ 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ] ; NEW_LINE"}
{"text":"Recursively get nibble of a given number and map them in the array","code":"def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Find last nibble","code":"nibble = num & 0xf ; NEW_LINE"}
{"text":"Use pre - stored values to find count in last nibble plus recursively add remaining nibbles .","code":"return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE"}
{"text":"Driver code","code":"num = 31 ; NEW_LINE print ( countSetBitsRec ( num ) ) ; NEW_LINE"}
{"text":"Check each bit in a number is set or not and return the total count of the set bits","code":"def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT"}
{"text":"( 1 << i ) = pow ( 2 , i )","code":"INDENT for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE count += 1 NEW_LINE return count NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"N = 15 NEW_LINE print ( countSetBits ( N ) ) NEW_LINE"}
{"text":"Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity","code":"def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT"}
{"text":"Driver program to test getParity ( )","code":"n = 7 NEW_LINE print ( \" Parity \u2581 of \u2581 no \u2581 \" , n , \" \u2581 = \u2581 \" , ( \" odd \" if getParity ( n ) else \" even \" ) ) NEW_LINE"}
{"text":"Python3 Program to find whether a no is power of two","code":"import math NEW_LINE"}
{"text":"Function to check Log base 2","code":"def Log2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return false ; NEW_LINE DEDENT return ( math . log10 ( x ) \/ math . log10 ( 2 ) ) ; NEW_LINE DEDENT"}
{"text":"Function to check if x is power of 2","code":"def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( Log2 ( n ) ) == math . floor ( Log2 ( n ) ) ) ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"text":"Function to check if x is power of 2","code":"def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n \/\/ 2 NEW_LINE DEDENT return True NEW_LINE DEDENT"}
{"text":"Driver code","code":"if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"text":"function which checks whether a number is a power of 2","code":"def powerof2 ( n ) : NEW_LINE"}
{"text":"base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )","code":"if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"all other odd numbers are not powers of 2","code":"elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"recursive function call","code":"return powerof2 ( n \/ 2 ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"True","code":"print ( powerof2 ( 64 ) ) NEW_LINE"}
{"text":"False","code":"print ( powerof2 ( 12 ) ) NEW_LINE"}
{"text":"Function to check if x is power of 2","code":"def isPowerOfTwo ( x ) : NEW_LINE"}
{"text":"First x in the below expression is for the case when x is 0","code":"return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE"}
{"text":"Driver code","code":"if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"text":"Returns maximum repeating element in arr [ 0. . n - 1 ] . The array elements are in range from 0 to k - 1","code":"def maxRepeating ( arr , n , k ) : NEW_LINE"}
{"text":"Iterate though input array , for every element arr [ i ] , increment arr [ arr [ i ] % k ] by k","code":"for i in range ( 0 , n ) : NEW_LINE INDENT arr [ arr [ i ] % k ] += k NEW_LINE DEDENT"}
{"text":"Find index of the maximum repeating element","code":"max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT"}
{"text":"Return index of the maximum element","code":"return result NEW_LINE"}
{"text":"Driver program to test above function","code":"arr = [ 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE print ( \" The \u2581 maximum \u2581 repeating \u2581 number \u2581 is \" , maxRepeating ( arr , n , k ) ) NEW_LINE"}
{"text":"function return derived formula value .","code":"def fun ( x ) : NEW_LINE INDENT y = ( x \/\/ 4 ) * 4 NEW_LINE DEDENT"}
{"text":"finding xor value of range [ y ... x ]","code":"ans = 0 NEW_LINE for i in range ( y , x + 1 ) : NEW_LINE INDENT ans ^= i NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"function to solve query for l and r .","code":"def query ( x ) : NEW_LINE"}
{"text":"if l or r is 0.","code":"if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = ( x + 1 ) \/\/ 2 NEW_LINE"}
{"text":"finding x is divisible by 2 or not .","code":"if x % 2 == 0 : NEW_LINE INDENT return ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * fun ( k ) ) NEW_LINE DEDENT def allQueries ( q , l , r ) : NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"q = 3 NEW_LINE l = [ 2 , 2 , 5 ] NEW_LINE r = [ 4 , 8 , 9 ] NEW_LINE allQueries ( q , l , r ) NEW_LINE"}
{"text":"Precompute the prefix XOR of greatest odd divisor","code":"def prefixXOR ( arr , preXOR , n ) : NEW_LINE"}
{"text":"Finding the Greatest Odd divisor","code":"for i in range ( 0 , n , 1 ) : NEW_LINE INDENT while ( arr [ i ] % 2 != 1 ) : NEW_LINE INDENT arr [ i ] = int ( arr [ i ] \/ 2 ) NEW_LINE DEDENT preXOR [ i ] = arr [ i ] NEW_LINE DEDENT"}
{"text":"Finding prefix XOR","code":"for i in range ( 1 , n , 1 ) : NEW_LINE INDENT preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] NEW_LINE DEDENT"}
{"text":"Return XOR of the range","code":"def query ( preXOR , l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return preXOR [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return preXOR [ r ] ^ preXOR [ l - 1 ] NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE preXOR = [ 0 for i in range ( n ) ] NEW_LINE prefixXOR ( arr , preXOR , n ) NEW_LINE print ( query ( preXOR , 0 , 2 ) ) NEW_LINE print ( query ( preXOR , 1 , 2 ) ) NEW_LINE DEDENT"}
{"text":"Function to find minimum swaps to sort an array of 0 s and 1 s .","code":"def findMinSwaps ( arr , n ) : NEW_LINE"}
{"text":"Array to store count of zeroes","code":"noOfZeroes = [ 0 ] * n NEW_LINE count = 0 NEW_LINE"}
{"text":"Count number of zeroes on right side of every one .","code":"noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i + 1 ] NEW_LINE if ( arr [ i ] == 0 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i ] + 1 NEW_LINE DEDENT DEDENT"}
{"text":"Count total number of swaps by adding number of zeroes on right side of every one .","code":"for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count = count + noOfZeroes [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE"}
{"text":"Driver code","code":"arr = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinSwaps ( arr , n ) ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE print ( minswaps ( arr ) ) NEW_LINE"}
{"text":"Function that returns true if array is sorted in non - decreasing order .","code":"def arraySortedOrNot ( arr , n ) : NEW_LINE"}
{"text":"Array has one or no element","code":"if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE"}
{"text":"Unsorted pair found","code":"if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"No unsorted pair found","code":"return True NEW_LINE"}
{"text":"Driver code","code":"arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times .","code":"def printTwoOdd ( arr , size ) : NEW_LINE"}
{"text":"Will hold XOR of two odd occurring elements","code":"xor2 = arr [ 0 ] NEW_LINE"}
{"text":"Will have only single set bit of xor2","code":"set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE"}
{"text":"Get the xor of all elements in arr [ ] . The xor will basically be xor of two odd occurring elements","code":"for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT"}
{"text":"Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get","code":"set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE"}
{"text":"Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0.","code":"for i in range ( size ) : NEW_LINE"}
{"text":"XOR of first set is finally going to hold one odd occurring number x","code":"if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT"}
{"text":"XOR of second set is finally going to hold the other odd occurring number y","code":"else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT print ( \" The \u2581 two \u2581 ODD \u2581 elements \u2581 are \" , x , \" & \" , y ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE"}
{"text":"The function assumes that the array is sorted","code":"def findPair ( arr , n ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE DEDENT"}
{"text":"Initialize positions of two elements","code":"i , j = 0 , 1 NEW_LINE"}
{"text":"Search for a pair","code":"while i < size and j < size : NEW_LINE INDENT if i != j and arr [ j ] - arr [ i ] == n : NEW_LINE INDENT print \" Pair \u2581 found \u2581 ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" NEW_LINE return True NEW_LINE DEDENT elif arr [ j ] - arr [ i ] < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print \" No \u2581 pair \u2581 found \" NEW_LINE return False NEW_LINE"}
{"text":"Driver function to test above function","code":"arr = [ 1 , 8 , 30 , 40 , 100 ] NEW_LINE n = 60 NEW_LINE findPair ( arr , n ) NEW_LINE"}
{"text":"Function to pr m Maximum elements","code":"def printMax ( arr , k , n ) : NEW_LINE"}
{"text":"vector to store the copy of the original array","code":"brr = arr . copy ( ) NEW_LINE"}
{"text":"Sorting the vector in descending order . Please refer below link for details","code":"brr . sort ( reverse = True ) NEW_LINE"}
{"text":"Traversing through original array and pring all those elements that are in first k of sorted vector .","code":"for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in brr [ 0 : k ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"arr = [ 50 , 8 , 45 , 12 , 25 , 40 , 84 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printMax ( arr , k , n ) NEW_LINE"}
{"text":"Function for binary_search","code":"def binary_search ( arr , low , high , ele ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 NEW_LINE if arr [ mid ] == ele : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > ele : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT"}
{"text":"Function to print smallest n numbers","code":"def printSmall ( arr , asize , n ) : NEW_LINE"}
{"text":"Make copy of array","code":"copy_arr = arr . copy ( ) NEW_LINE"}
{"text":"Sort copy array","code":"copy_arr . sort ( ) NEW_LINE"}
{"text":"For each arr [ i ] find whether it is a part of n - smallest with binary search","code":"for i in range ( asize ) : NEW_LINE INDENT if binary_search ( copy_arr , low = 0 , high = n , ele = arr [ i ] ) > - 1 : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE DEDENT"}
{"text":"Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression","code":"def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE DEDENT"}
{"text":"Sort array","code":"arr . sort ( ) NEW_LINE"}
{"text":"After sorting , difference between consecutive elements must be same .","code":"d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Driver code","code":"arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Yes \" ) if ( checkIsAP ( arr , n ) ) else print ( \" No \" ) NEW_LINE"}
{"text":"Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression","code":"def checkIsAP ( arr , n ) : NEW_LINE INDENT hm = { } NEW_LINE smallest = float ( ' inf ' ) NEW_LINE second_smallest = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE DEDENT"}
{"text":"Find the smallest and and update second smallest","code":"if ( arr [ i ] < smallest ) : NEW_LINE INDENT second_smallest = smallest NEW_LINE smallest = arr [ i ] NEW_LINE DEDENT"}
{"text":"Find second smallest","code":"elif ( arr [ i ] != smallest and arr [ i ] < second_smallest ) : NEW_LINE INDENT second_smallest = arr [ i ] NEW_LINE DEDENT"}
{"text":"Check if the duplicate element found or not","code":"if arr [ i ] not in hm : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT"}
{"text":"If duplicate found then return false","code":"else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Find the difference between smallest and second smallest","code":"diff = second_smallest - smallest NEW_LINE"}
{"text":"As we have used smallest and second smallest , so we should now only check for n - 2 elements","code":"for i in range ( n - 1 ) : NEW_LINE INDENT if ( second_smallest ) not in hm : NEW_LINE INDENT return False NEW_LINE DEDENT second_smallest += diff NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Driver code","code":"arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkIsAP ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python Code to find no . of Ways of choosing a pair with maximum difference","code":"def countPairs ( a , n ) : NEW_LINE"}
{"text":"To find minimum and maximum of the array","code":"mn = + 2147483647 NEW_LINE mx = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( mn , a [ i ] ) NEW_LINE mx = max ( mx , a [ i ] ) NEW_LINE DEDENT"}
{"text":"to find the count of minimum and maximum elements","code":"c1 = 0 NEW_LINE"}
{"text":"Count variables","code":"c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == mn ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( a [ i ] == mx ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT"}
{"text":"condition for all elements equal","code":"if ( mn == mx ) : NEW_LINE INDENT return n * ( n - 1 ) \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT return c1 * c2 NEW_LINE DEDENT"}
{"text":"Driver code","code":"a = [ 3 , 2 , 1 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n ) ) NEW_LINE"}
{"text":"Python3 code to rearrange linked list in place","code":"class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"}
{"text":"Function for rearranging a linked list with high and low value","code":"def rearrange ( head ) : NEW_LINE"}
{"text":"Base case","code":"if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT"}
{"text":"Two pointer variable","code":"prev , curr = head , head . next NEW_LINE while ( curr ) : NEW_LINE"}
{"text":"Swap function for swapping data","code":"if ( prev . data > curr . data ) : NEW_LINE INDENT prev . data , curr . data = curr . data , prev . data NEW_LINE DEDENT"}
{"text":"Swap function for swapping data","code":"if ( curr . next and curr . next . data > curr . data ) : NEW_LINE INDENT curr . next . data , curr . data = curr . data , curr . next . data NEW_LINE DEDENT prev = curr . next NEW_LINE if ( not curr . next ) : NEW_LINE INDENT break NEW_LINE DEDENT curr = curr . next . next NEW_LINE return head NEW_LINE"}
{"text":"Function to insert a node in the linked list at the beginning","code":"def push ( head , k ) : NEW_LINE INDENT tem = Node ( k ) NEW_LINE tem . data = k NEW_LINE tem . next = head NEW_LINE head = tem NEW_LINE return head NEW_LINE DEDENT"}
{"text":"Function to display node of linked list","code":"def display ( head ) : NEW_LINE INDENT curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( curr . data , end = \" \u2581 \" ) NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE DEDENT"}
{"text":"Let create a linked list 9 . 6 . 8 . 3 . 7","code":"head = push ( head , 7 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = rearrange ( head ) NEW_LINE display ( head ) NEW_LINE"}
{"text":"Python3 implementation","code":"class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"}
{"text":"Function to print the list","code":"def printlist ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE if ( head . next != None ) : NEW_LINE INDENT print ( \" - > \" , end = \" \" ) NEW_LINE DEDENT head = head . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Function to rearrange","code":"def rearrange ( head ) : NEW_LINE INDENT global left NEW_LINE if ( head != None ) : NEW_LINE INDENT left = head NEW_LINE reorderListUtil ( left ) NEW_LINE DEDENT DEDENT def reorderListUtil ( right ) : NEW_LINE INDENT global left NEW_LINE if ( right == None ) : NEW_LINE INDENT return NEW_LINE DEDENT reorderListUtil ( right . next ) NEW_LINE DEDENT"}
{"text":"We set left = null , when we reach stop condition , so no processing required after that","code":"if ( left == None ) : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"Stop condition : odd case : left = right , even case : left . next = right","code":"if ( left != right and left . next != right ) : NEW_LINE INDENT temp = left . next NEW_LINE left . next = right NEW_LINE right . next = temp NEW_LINE left = temp NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Stop condition , set null to left nodes","code":"if ( left . next == right ) : NEW_LINE"}
{"text":"Even case","code":"left . next . next = None NEW_LINE left = None NEW_LINE else : NEW_LINE"}
{"text":"Odd case","code":"left . next = None NEW_LINE left = None NEW_LINE"}
{"text":"Driver code","code":"head = Node ( 1 ) NEW_LINE head . next = Node ( 2 ) NEW_LINE head . next . next = Node ( 3 ) NEW_LINE head . next . next . next = Node ( 4 ) NEW_LINE head . next . next . next . next = Node ( 5 ) NEW_LINE"}
{"text":"Print original list","code":"printlist ( head ) NEW_LINE"}
{"text":"Modify the list","code":"rearrange ( head ) NEW_LINE"}
{"text":"Print modified list","code":"printlist ( head ) NEW_LINE"}
{"text":"A linked List Node","code":"class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT"}
{"text":"A utility function to get length of linked list","code":"def getLength ( Node ) : NEW_LINE INDENT size = 0 NEW_LINE while ( Node != None ) : NEW_LINE INDENT Node = Node . next NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT"}
{"text":"A Utility that padds zeros in front of the Node , with the given diff","code":"def paddZeros ( sNode , diff ) : NEW_LINE INDENT if ( sNode == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT zHead = newNode ( 0 ) NEW_LINE diff = diff - 1 NEW_LINE temp = zHead NEW_LINE while ( diff > 0 ) : NEW_LINE INDENT diff = diff - 1 NEW_LINE temp . next = newNode ( 0 ) NEW_LINE temp = temp . next NEW_LINE DEDENT temp . next = sNode NEW_LINE return zHead NEW_LINE DEDENT borrow = True NEW_LINE"}
{"text":"Subtract LinkedList Helper is a recursive function , move till the last Node , and subtract the digits and create the Node and return the Node . If d1 < d2 , we borrow the number from previous digit .","code":"def subtractLinkedListHelper ( l1 , l2 ) : NEW_LINE INDENT global borrow NEW_LINE if ( l1 == None and l2 == None and not borrow ) : NEW_LINE INDENT return None NEW_LINE DEDENT l3 = None NEW_LINE l4 = None NEW_LINE if ( l1 != None ) : NEW_LINE INDENT l3 = l1 . next NEW_LINE DEDENT if ( l2 != None ) : NEW_LINE INDENT l4 = l2 . next NEW_LINE DEDENT previous = subtractLinkedListHelper ( l3 , l4 ) NEW_LINE d1 = l1 . data NEW_LINE d2 = l2 . data NEW_LINE sub = 0 NEW_LINE DEDENT"}
{"text":"if you have given the value value to next digit then reduce the d1 by 1","code":"if ( borrow ) : NEW_LINE INDENT d1 = d1 - 1 NEW_LINE borrow = False NEW_LINE DEDENT"}
{"text":"If d1 < d2 , then borrow the number from previous digit . Add 10 to d1 and set borrow = True","code":"if ( d1 < d2 ) : NEW_LINE INDENT borrow = True NEW_LINE d1 = d1 + 10 NEW_LINE DEDENT"}
{"text":"subtract the digits","code":"sub = d1 - d2 NEW_LINE"}
{"text":"Create a Node with sub value","code":"current = newNode ( sub ) NEW_LINE"}
{"text":"Set the Next pointer as Previous","code":"current . next = previous NEW_LINE return current NEW_LINE"}
{"text":"This API subtracts two linked lists and returns the linked list which shall have the subtracted result .","code":"def subtractLinkedList ( l1 , l2 ) : NEW_LINE"}
{"text":"Base Case .","code":"if ( l1 == None and l2 == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT"}
{"text":"In either of the case , get the lengths of both Linked list .","code":"len1 = getLength ( l1 ) NEW_LINE len2 = getLength ( l2 ) NEW_LINE lNode = None NEW_LINE sNode = None NEW_LINE temp1 = l1 NEW_LINE temp2 = l2 NEW_LINE"}
{"text":"If lengths differ , calculate the smaller Node and padd zeros for smaller Node and ensure both larger Node and smaller Node has equal length .","code":"if ( len1 != len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT lNode = l1 NEW_LINE DEDENT else : NEW_LINE INDENT lNode = l2 NEW_LINE DEDENT if ( len1 > len2 ) : NEW_LINE INDENT sNode = l2 NEW_LINE DEDENT else : NEW_LINE INDENT sNode = l1 NEW_LINE DEDENT sNode = paddZeros ( sNode , abs ( len1 - len2 ) ) NEW_LINE DEDENT else : NEW_LINE"}
{"text":"If both list lengths are equal , then calculate the larger and smaller list . If 5 - 6 - 7 & 5 - 6 - 8 are linked list , then walk through linked list at last Node as 7 < 8 , larger Node is 5 - 6 - 8 and smaller Node is 5 - 6 - 7.","code":"while ( l1 != None and l2 != None ) : NEW_LINE INDENT if ( l1 . data != l2 . data ) : NEW_LINE INDENT if ( l1 . data > l2 . data ) : NEW_LINE INDENT lNode = temp1 NEW_LINE DEDENT else : NEW_LINE INDENT lNode = temp2 NEW_LINE DEDENT if ( l1 . data > l2 . data ) : NEW_LINE INDENT sNode = temp2 NEW_LINE DEDENT else : NEW_LINE INDENT sNode = temp1 NEW_LINE DEDENT break NEW_LINE DEDENT l1 = l1 . next NEW_LINE l2 = l2 . next NEW_LINE DEDENT global borrow NEW_LINE"}
{"text":"After calculating larger and smaller Node , call subtractLinkedListHelper which returns the subtracted linked list .","code":"borrow = False NEW_LINE return subtractLinkedListHelper ( lNode , sNode ) NEW_LINE"}
{"text":"A utility function to print linked list","code":"def printList ( Node ) : NEW_LINE INDENT while ( Node != None ) : NEW_LINE INDENT print ( Node . data , end = \" \u2581 \" ) NEW_LINE Node = Node . next NEW_LINE DEDENT print ( \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver program to test above functions","code":"head1 = newNode ( 1 ) NEW_LINE head1 . next = newNode ( 0 ) NEW_LINE head1 . next . next = newNode ( 0 ) NEW_LINE head2 = newNode ( 1 ) NEW_LINE result = subtractLinkedList ( head1 , head2 ) NEW_LINE printList ( result ) NEW_LINE"}
{"text":"Node class","code":"class Node : NEW_LINE"}
{"text":"constructor to create a new node","code":"def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT"}
{"text":"function to insert node at the middle of linked list given the head","code":"def insertAtMid ( head , x ) : NEW_LINE"}
{"text":"if the list is empty","code":"if ( head == None ) : NEW_LINE INDENT head = Node ( x ) NEW_LINE DEDENT else : NEW_LINE"}
{"text":"create a new node for the value to be inserted","code":"newNode = Node ( x ) NEW_LINE ptr = head NEW_LINE length = 0 NEW_LINE"}
{"text":"calcualte the length of the linked list","code":"while ( ptr != None ) : NEW_LINE INDENT ptr = ptr . next NEW_LINE length += 1 NEW_LINE DEDENT"}
{"text":"' count ' the number of node after which the new node has to be inserted","code":"if ( length % 2 == 0 ) : NEW_LINE INDENT count = length \/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT ( length + 1 ) \/ 2 NEW_LINE DEDENT ptr = head NEW_LINE"}
{"text":"move ptr to the node after which the new node has to inserted","code":"while ( count > 1 ) : NEW_LINE INDENT count -= 1 NEW_LINE ptr = ptr . next NEW_LINE DEDENT"}
{"text":"insert the ' newNode ' and adjust links accordingly","code":"newNode . next = ptr . next NEW_LINE ptr . next = newNode NEW_LINE"}
{"text":"function to displat the linked list","code":"def display ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( str ( temp . data ) , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT"}
{"text":"Creating the linked list 1.2 . 4.5","code":"head = Node ( 1 ) NEW_LINE head . next = Node ( 2 ) NEW_LINE head . next . next = Node ( 4 ) NEW_LINE head . next . next . next = Node ( 5 ) NEW_LINE print ( \" Linked \u2581 list \u2581 before \u2581 insertion : \u2581 \" , end = \" \" ) NEW_LINE display ( head ) NEW_LINE"}
{"text":"inserting 3 in the middle of the linked list .","code":"x = 3 NEW_LINE insertAtMid ( head , x ) NEW_LINE print ( \" Linked list after insertion : \" \u2581 , \u2581 end \u2581 = \u2581 \" \" ) NEW_LINE display ( head ) NEW_LINE"}
{"text":"Node of a doubly linked list","code":"class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"}
{"text":"function to create and return a new node of a doubly linked list","code":"def getNode ( data ) : NEW_LINE"}
{"text":"allocate node","code":"newNode = Node ( 0 ) NEW_LINE"}
{"text":"put in the data","code":"newNode . data = data NEW_LINE newNode . prev = newNode . next = None NEW_LINE return newNode NEW_LINE"}
{"text":"function to insert a new node in sorted way in a sorted doubly linked list","code":"def sortedInsert ( head_ref , newNode ) : NEW_LINE INDENT current = None NEW_LINE DEDENT"}
{"text":"if list is empty","code":"if ( head_ref == None ) : NEW_LINE INDENT head_ref = newNode NEW_LINE DEDENT"}
{"text":"if the node is to be inserted at the beginning of the doubly linked list","code":"elif ( ( head_ref ) . data >= newNode . data ) : NEW_LINE INDENT newNode . next = head_ref NEW_LINE newNode . next . prev = newNode NEW_LINE head_ref = newNode NEW_LINE DEDENT else : NEW_LINE INDENT current = head_ref NEW_LINE DEDENT"}
{"text":"locate the node after which the new node is to be inserted","code":"while ( current . next != None and current . next . data < newNode . data ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT"}
{"text":"Make the appropriate links","code":"newNode . next = current . next NEW_LINE"}
{"text":"if the new node is not inserted at the end of the list","code":"if ( current . next != None ) : NEW_LINE INDENT newNode . next . prev = newNode NEW_LINE DEDENT current . next = newNode NEW_LINE newNode . prev = current NEW_LINE return head_ref ; NEW_LINE"}
{"text":"function to sort a doubly linked list using insertion sort","code":"def insertionSort ( head_ref ) : NEW_LINE"}
{"text":"Initialize ' sorted ' - a sorted doubly linked list","code":"sorted = None NEW_LINE"}
{"text":"Traverse the given doubly linked list and insert every node to 'sorted","code":"current = head_ref NEW_LINE while ( current != None ) : NEW_LINE"}
{"text":"Store next for next iteration","code":"next = current . next NEW_LINE"}
{"text":"removing all the links so as to create ' current ' as a new node for insertion","code":"current . prev = current . next = None NEW_LINE"}
{"text":"insert current in ' sorted ' doubly linked list","code":"sorted = sortedInsert ( sorted , current ) NEW_LINE"}
{"text":"Update current","code":"current = next NEW_LINE"}
{"text":"Update head_ref to point to sorted doubly linked list","code":"head_ref = sorted NEW_LINE return head_ref NEW_LINE"}
{"text":"function to print the doubly linked list","code":"def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT"}
{"text":"function to insert a node at the beginning of the doubly linked list","code":"def push ( head_ref , new_data ) : NEW_LINE"}
{"text":"allocate node","code":"new_node = Node ( 0 ) NEW_LINE"}
{"text":"put in the data","code":"new_node . data = new_data NEW_LINE"}
{"text":"Make next of new node as head and previous as None","code":"new_node . next = ( head_ref ) NEW_LINE new_node . prev = None NEW_LINE"}
{"text":"change prev of head node to new node","code":"if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . prev = new_node NEW_LINE DEDENT"}
{"text":"move the head to point to the new node","code":"( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"start with the empty doubly linked list","code":"head = None NEW_LINE"}
{"text":"insert the following data","code":"head = push ( head , 9 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 8 ) NEW_LINE print ( \" Doubly \u2581 Linked \u2581 List \u2581 Before \u2581 Sorting \" ) NEW_LINE printList ( head ) NEW_LINE head = insertionSort ( head ) NEW_LINE print ( \" Doubly Linked List After Sorting \" ) NEW_LINE printList ( head ) NEW_LINE"}
{"text":"Function to reverse array between indices s and e","code":"def reverse ( arr , s , e ) : NEW_LINE INDENT while s < e : NEW_LINE INDENT tem = arr [ s ] NEW_LINE arr [ s ] = arr [ e ] NEW_LINE arr [ e ] = tem NEW_LINE s = s + 1 NEW_LINE e = e - 1 NEW_LINE DEDENT DEDENT"}
{"text":"Function to generate all possible rotations of array","code":"def fun ( arr , k ) : NEW_LINE INDENT n = len ( arr ) - 1 NEW_LINE v = n - k NEW_LINE if v >= 0 : NEW_LINE INDENT reverse ( arr , 0 , v ) NEW_LINE reverse ( arr , v + 1 , n ) NEW_LINE reverse ( arr , 0 , n ) NEW_LINE return arr NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 3 , 4 ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT count = 0 NEW_LINE p = fun ( arr , i ) NEW_LINE print ( p , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Python3 program to find Bitwise OR of two equal halves of an array after performing K right circular shifts","code":"MAX = 100005 NEW_LINE"}
{"text":"Array for storing the segment tree","code":"seg = [ 0 ] * ( 4 * MAX ) NEW_LINE"}
{"text":"Function to build the segment tree","code":"def build ( node , l , r , a ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg [ node ] = a [ l ] NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( l + r ) \/\/ 2 NEW_LINE build ( 2 * node , l , mid , a ) NEW_LINE build ( 2 * node + 1 , mid + 1 , r , a ) NEW_LINE seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to return the OR of elements in the range [ l , r ]","code":"def query ( node , l , r , start , end , a ) : NEW_LINE"}
{"text":"Check for out of bound condition","code":"if ( l > end or r < start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( start <= l and r <= end ) : NEW_LINE INDENT return seg [ node ] NEW_LINE DEDENT"}
{"text":"Find middle of the range","code":"mid = ( l + r ) \/\/ 2 NEW_LINE"}
{"text":"Recurse for all the elements in array","code":"return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) NEW_LINE"}
{"text":"Function to find the OR sum","code":"def orsum ( a , n , q , k ) : NEW_LINE"}
{"text":"Function to build the segment Tree","code":"build ( 1 , 0 , n - 1 , a ) NEW_LINE"}
{"text":"Loop to handle q queries","code":"for j in range ( q ) : NEW_LINE"}
{"text":"Effective number of right circular shifts","code":"i = k [ j ] % ( n \/\/ 2 ) NEW_LINE"}
{"text":"OR of second half of the array [ n \/ 2 - i , n - 1 - i ]","code":"sec = query ( 1 , 0 , n - 1 , n \/\/ 2 - i , n - i - 1 , a ) NEW_LINE"}
{"text":"OR of first half of the array [ n - i , n - 1 ] OR [ 0 , n \/ 2 - 1 - i ]","code":"first = ( query ( 1 , 0 , n - 1 , 0 , n \/\/ 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) NEW_LINE temp = sec + first NEW_LINE"}
{"text":"Print final answer to the query","code":"print ( temp ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 ] NEW_LINE n = len ( a ) NEW_LINE q = 2 NEW_LINE k = [ 4 , 2 ] NEW_LINE orsum ( a , n , q , k ) NEW_LINE DEDENT"}
{"text":"Function that prints maximum equal elements","code":"def maximumEqual ( a , b , n ) : NEW_LINE"}
{"text":"List to store the index of elements of array b","code":"store = [ 0 ] * 10 ** 5 NEW_LINE"}
{"text":"Storing the positions of array B","code":"for i in range ( n ) : NEW_LINE INDENT store [ b [ i ] ] = i + 1 NEW_LINE DEDENT"}
{"text":"Frequency array to keep count of elements with similar difference in distances","code":"ans = [ 0 ] * 10 ** 5 NEW_LINE"}
{"text":"Iterate through all element in arr1 [ ]","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Calculate number of shift required to make current element equal","code":"d = abs ( store [ a [ i ] ] - ( i + 1 ) ) NEW_LINE"}
{"text":"If d is less than 0","code":"if ( store [ a [ i ] ] < i + 1 ) : NEW_LINE INDENT d = n - d NEW_LINE DEDENT"}
{"text":"Store the frequency of current diff","code":"ans [ d ] += 1 NEW_LINE finalans = 0 NEW_LINE"}
{"text":"Compute the maximum frequency stored","code":"for i in range ( 10 ** 5 ) : NEW_LINE INDENT finalans = max ( finalans , ans [ i ] ) NEW_LINE DEDENT"}
{"text":"Printing the maximum number of equal elements","code":"print ( finalans ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given two arrays","code":"A = [ 6 , 7 , 3 , 9 , 5 ] NEW_LINE B = [ 7 , 3 , 9 , 5 , 6 ] NEW_LINE size = len ( A ) NEW_LINE"}
{"text":"Function Call","code":"maximumEqual ( A , B , size ) NEW_LINE"}
{"text":"Function to rightRotate array","code":"def RightRotate ( a , n , k ) : NEW_LINE"}
{"text":"If rotation is greater than size of array","code":"k = k % n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE DEDENT"}
{"text":"Printing rightmost kth elements","code":"print ( a [ n + i - k ] , end = \" \u2581 \" ) ; NEW_LINE else : NEW_LINE"}
{"text":"Prints array after ' k ' elements","code":"print ( a [ i - k ] , end = \" \u2581 \" ) ; NEW_LINE print ( \" \" ) ; NEW_LINE"}
{"text":"Driver code","code":"Array = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE N = len ( Array ) ; NEW_LINE K = 2 ; NEW_LINE RightRotate ( Array , N , K ) ; NEW_LINE"}
{"text":"Function to restore the Original Sort","code":"def restoreSortedArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE DEDENT DEDENT"}
{"text":"In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one .","code":"reverse ( arr , 0 , i ) ; NEW_LINE reverse ( arr , i + 1 , n ) ; NEW_LINE reverse ( arr , 0 , n ) ; NEW_LINE def reverse ( arr , i , j ) : NEW_LINE while ( i < j ) : NEW_LINE temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE"}
{"text":"Function to print the Array","code":"def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE restoreSortedArray ( arr , n - 1 ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT"}
{"text":"Function to find start index of array","code":"def findStartIndexOfArray ( arr , low , high ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( low == high ) : NEW_LINE INDENT return low ; NEW_LINE DEDENT mid = low + ( high - low ) \/ 2 ; NEW_LINE if ( arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT if ( arr [ mid - 1 ] > arr [ mid ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findStartIndexOfArray ( arr , low , mid - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return findStartIndexOfArray ( arr , mid + 1 , high ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Function to restore the Original Sort","code":"def restoreSortedArray ( arr , n ) : NEW_LINE"}
{"text":"array is already sorted","code":"if ( arr [ 0 ] < arr [ n - 1 ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; NEW_LINE"}
{"text":"In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one .","code":"reverse ( arr , 0 , start ) ; NEW_LINE reverse ( arr , start , n ) ; NEW_LINE reverse ( arr ) ; NEW_LINE"}
{"text":"Function to print the Array","code":"def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT def reverse ( arr , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE restoreSortedArray ( arr , n ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT"}
{"text":"In - place rotates s towards left by d","code":"def leftrotate ( s , d ) : NEW_LINE INDENT tmp = s [ d : ] + s [ 0 : d ] NEW_LINE return tmp NEW_LINE DEDENT"}
{"text":"In - place rotates s towards right by d","code":"def rightrotate ( s , d ) : NEW_LINE INDENT return leftrotate ( s , len ( s ) - d ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" GeeksforGeeks \" NEW_LINE print ( leftrotate ( str1 , 2 ) ) NEW_LINE str2 = \" GeeksforGeeks \" NEW_LINE print ( rightrotate ( str2 , 2 ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to illustrate inserting a Node in a Cicular Doubly Linked list in begging , end and middle","code":"import math NEW_LINE"}
{"text":"Structure of a Node","code":"class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"}
{"text":"Function to insert a node at the end","code":"def insertNode ( start , value ) : NEW_LINE"}
{"text":"If the list is empty , create a single node circular and doubly list","code":"if ( start == None ) : NEW_LINE INDENT new_node = Node ( value ) NEW_LINE new_node . data = value NEW_LINE new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE start = new_node NEW_LINE return new_node NEW_LINE DEDENT"}
{"text":"Find last node","code":"last = start . prev NEW_LINE"}
{"text":"Create Node dynamically","code":"new_node = Node ( value ) NEW_LINE new_node . data = value NEW_LINE"}
{"text":"Start is going to be next of new_node","code":"new_node . next = start NEW_LINE"}
{"text":"Make new node previous of start","code":"( start ) . prev = new_node NEW_LINE"}
{"text":"Make last preivous of new node","code":"new_node . prev = last NEW_LINE"}
{"text":"Make new node next of old last","code":"last . next = new_node NEW_LINE return start NEW_LINE"}
{"text":"Function to display the circular doubly linked list","code":"def displayList ( start ) : NEW_LINE INDENT temp = start NEW_LINE while ( temp . next != start ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT"}
{"text":"Function to search the particular element from the list","code":"def searchList ( start , search ) : NEW_LINE"}
{"text":"Declare the temp variable","code":"temp = start NEW_LINE"}
{"text":"Declare other control variable for the searching","code":"count = 0 NEW_LINE flag = 0 NEW_LINE value = 0 NEW_LINE"}
{"text":"If start is None return - 1","code":"if ( temp == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Move the temp pointer until , temp . next doesn 't move  start address (Circular Fashion)","code":"while ( temp . next != start ) : NEW_LINE"}
{"text":"Increment count for location","code":"count = count + 1 NEW_LINE"}
{"text":"If it is found raise the flag and break the loop","code":"if ( temp . data == search ) : NEW_LINE INDENT flag = 1 NEW_LINE count = count - 1 NEW_LINE break NEW_LINE DEDENT"}
{"text":"Increment temp pointer","code":"temp = temp . next NEW_LINE"}
{"text":"Check whether last element in the list content the value if contain , raise a flag and increment count","code":"if ( temp . data == search ) : NEW_LINE INDENT count = count + 1 NEW_LINE flag = 1 NEW_LINE DEDENT"}
{"text":"If flag is true , then element found , else not","code":"if ( flag == 1 ) : NEW_LINE INDENT print ( search , \" found \u2581 at \u2581 location \u2581 \" , count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( search , \" \u2581 not \u2581 found \" ) NEW_LINE DEDENT return - 1 NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Start with the empty list","code":"start = None NEW_LINE"}
{"text":"Insert 4. So linked list becomes 4. None","code":"start = insertNode ( start , 4 ) NEW_LINE"}
{"text":"Insert 5. So linked list becomes 4.5","code":"start = insertNode ( start , 5 ) NEW_LINE"}
{"text":"Insert 7. So linked list becomes 4.5 . 7","code":"start = insertNode ( start , 7 ) NEW_LINE"}
{"text":"Insert 8. So linked list becomes 4.5 . 7.8","code":"start = insertNode ( start , 8 ) NEW_LINE"}
{"text":"Insert 6. So linked list becomes 4.5 . 7.8 . 6","code":"start = insertNode ( start , 6 ) NEW_LINE print ( \" Created \u2581 circular \u2581 doubly \u2581 linked \u2581 list \u2581 is : \u2581 \" , end = \" \" ) NEW_LINE displayList ( start ) NEW_LINE searchList ( start , 5 ) NEW_LINE"}
{"text":"Python3 implementation to revesre a doubly circular linked list","code":"import math NEW_LINE"}
{"text":"structure of a node of linked list","code":"class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT"}
{"text":"function to create and return a new node","code":"def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT"}
{"text":"Function to insert at the end","code":"def insertEnd ( head , new_node ) : NEW_LINE"}
{"text":"If the list is empty , create a single node circular and doubly list","code":"if ( head == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT"}
{"text":"Find last node","code":"last = head . prev NEW_LINE"}
{"text":"Start is going to be next of new_node","code":"new_node . next = head NEW_LINE"}
{"text":"Make new node previous of start","code":"head . prev = new_node NEW_LINE"}
{"text":"Make last preivous of new node","code":"new_node . prev = last NEW_LINE"}
{"text":"Make new node next of old last","code":"last . next = new_node NEW_LINE return head NEW_LINE"}
{"text":"Uitlity function to revesre a doubly circular linked list","code":"def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT"}
{"text":"Initialize a new head pointer","code":"new_head = None NEW_LINE"}
{"text":"get pointer to the the last node","code":"last = head . prev NEW_LINE"}
{"text":"set ' curr ' to last node","code":"curr = last NEW_LINE"}
{"text":"traverse list in backward direction","code":"while ( curr . prev != last ) : NEW_LINE INDENT prev = curr . prev NEW_LINE DEDENT"}
{"text":"insert ' curr ' at the end of the list starting with the ' new _ head ' pointer","code":"new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE"}
{"text":"head pointer of the reversed list","code":"return new_head NEW_LINE"}
{"text":"function to display a doubly circular list in forward and backward direction","code":"def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( \" Forward \u2581 direction : \u2581 \" , end = \" \" ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( \" Backward \u2581 direction : \u2581 \" , end = \" \" ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print ( \" Current \u2581 list : \" ) NEW_LINE display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print ( \" Reversed list : \" ) NEW_LINE display ( head ) NEW_LINE DEDENT"}
{"text":"Python3 implementation to find LCA in a tree","code":"MAXN = 1001 NEW_LINE"}
{"text":"stores depth for each node","code":"depth = [ 0 for i in range ( MAXN ) ] ; NEW_LINE"}
{"text":"stores first parent for each node","code":"parent = [ 0 for i in range ( MAXN ) ] ; NEW_LINE adj = [ [ ] for i in range ( MAXN ) ] NEW_LINE def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) ; NEW_LINE adj [ v ] . append ( u ) ; NEW_LINE DEDENT def dfs ( cur , prev ) : NEW_LINE"}
{"text":"marking parent for each node","code":"parent [ cur ] = prev ; NEW_LINE"}
{"text":"marking depth for each node","code":"depth [ cur ] = depth [ prev ] + 1 ; NEW_LINE"}
{"text":"propogating marking down the tree","code":"for i in range ( len ( adj [ cur ] ) ) : NEW_LINE INDENT if ( adj [ cur ] [ i ] != prev ) : NEW_LINE INDENT dfs ( adj [ cur ] [ i ] , cur ) ; NEW_LINE DEDENT DEDENT def preprocess ( ) : NEW_LINE"}
{"text":"a dummy node","code":"depth [ 0 ] = - 1 ; NEW_LINE"}
{"text":"precalculating 1 ) depth . 2 ) parent . for each node","code":"dfs ( 1 , 0 ) ; NEW_LINE"}
{"text":"Time Complexity : O ( Height of tree ) recursively jumps one node above till both the nodes become equal","code":"def LCANaive ( u , v ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT return u ; NEW_LINE DEDENT if ( depth [ u ] > depth [ v ] ) : NEW_LINE INDENT u , v = v , u NEW_LINE DEDENT v = parent [ v ] ; NEW_LINE return LCANaive ( u , v ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"adding edges to the tree","code":"addEdge ( 1 , 2 ) ; NEW_LINE addEdge ( 1 , 3 ) ; NEW_LINE addEdge ( 1 , 4 ) ; NEW_LINE addEdge ( 2 , 5 ) ; NEW_LINE addEdge ( 2 , 6 ) ; NEW_LINE addEdge ( 3 , 7 ) ; NEW_LINE addEdge ( 4 , 8 ) ; NEW_LINE addEdge ( 4 , 9 ) ; NEW_LINE addEdge ( 9 , 10 ) ; NEW_LINE addEdge ( 9 , 11 ) ; NEW_LINE addEdge ( 7 , 12 ) ; NEW_LINE addEdge ( 7 , 13 ) ; NEW_LINE preprocess ( ) ; NEW_LINE print ( ' LCA ( 11,8 ) \u2581 : \u2581 ' + str ( LCANaive ( 11 , 8 ) ) ) NEW_LINE print ( ' LCA ( 3,13 ) \u2581 : \u2581 ' + str ( LCANaive ( 3 , 13 ) ) ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE DEDENT"}
{"text":"Formula for number of trails for N consecutive heads","code":"print ( pow ( 2 , N + 1 ) - 2 ) NEW_LINE"}
{"text":"Function to return the count of numbers which are divisible by both A and B in the range [ 1 , N ] in constant time","code":"def countOfNum ( n , a , b ) : NEW_LINE INDENT cnt_of_a , cnt_of_b , cnt_of_ab , sum = 0 , 0 , 0 , 0 NEW_LINE DEDENT"}
{"text":"Compute the count of numbers divisible by A in the range [ 1 , N ]","code":"cnt_of_a = n \/\/ a NEW_LINE"}
{"text":"Compute the count of numbers divisible by B in the range [ 1 , N ]","code":"cnt_of_b = n \/\/ b NEW_LINE"}
{"text":"Adding the counts which are divisible by A and B","code":"sum = cnt_of_b + cnt_of_a NEW_LINE"}
{"text":"The above value might contain repeated values which are divisible by both A and B . Therefore , the count of numbers which are divisible by both A and B are found","code":"cnt_of_ab = n \/\/ ( a * b ) NEW_LINE"}
{"text":"The count computed above is subtracted to compute the final count","code":"sum = sum - cnt_of_ab NEW_LINE return sum NEW_LINE"}
{"text":"Function to return the sum of numbers which are divisible by both A and B in the range [ 1 , N ]","code":"def sumOfNum ( n , a , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE DEDENT"}
{"text":"Set to store the numbers so that the numbers are not repeated","code":"ans = dict ( ) NEW_LINE"}
{"text":"For loop to find the numbers which are divisible by A and insert them into the set","code":"for i in range ( a , n + 1 , a ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT"}
{"text":"For loop to find the numbers which are divisible by A and insert them into the set","code":"for i in range ( b , n + 1 , b ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT"}
{"text":"For loop to iterate through the set and find the sum","code":"for it in ans : NEW_LINE INDENT sum = sum + it NEW_LINE DEDENT return sum NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 88 NEW_LINE A = 11 NEW_LINE B = 8 NEW_LINE count = countOfNum ( N , A , B ) NEW_LINE sumofnum = sumOfNum ( N , A , B ) NEW_LINE print ( sumofnum % count ) NEW_LINE DEDENT"}
{"text":"Function to return the value of the given expression","code":"def get ( L , R ) : NEW_LINE"}
{"text":"Value of the first term","code":"x = 1.0 \/ L ; NEW_LINE"}
{"text":"Value of the last term","code":"y = 1.0 \/ ( R + 1.0 ) ; NEW_LINE return ( x - y ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 6 ; R = 12 ; NEW_LINE DEDENT"}
{"text":"Get the result","code":"ans = get ( L , R ) ; NEW_LINE print ( round ( ans , 2 ) ) ; NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"from bisect import bisect_right as upper_bound NEW_LINE MAX = 100000 NEW_LINE"}
{"text":"To store the pre - computed integers","code":"v = [ ] NEW_LINE"}
{"text":"Function that returns true if the binary representation of x contains consecutive 1 s","code":"def consecutiveOnes ( x ) : NEW_LINE"}
{"text":"To store the previous bit","code":"p = 0 NEW_LINE while ( x > 0 ) : NEW_LINE"}
{"text":"Check whether the previous bit and the current bit are both 1","code":"if ( x % 2 == 1 and p == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"Update previous bit","code":"p = x % 2 NEW_LINE"}
{"text":"Go to the next bit","code":"x \/\/= 2 NEW_LINE return False NEW_LINE"}
{"text":"Function to pre - compute the valid numbers from 0 to MAX","code":"def preCompute ( ) : NEW_LINE"}
{"text":"Store all the numbers which do not have consecutive 1 s","code":"for i in range ( MAX + 1 ) : NEW_LINE INDENT if ( consecutiveOnes ( i ) == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to return the minimum number greater than n which does not contain consecutive 1 s","code":"def nextValid ( n ) : NEW_LINE"}
{"text":"Search for the next greater element with no consecutive 1 s","code":"it = upper_bound ( v , n ) NEW_LINE val = v [ it ] NEW_LINE return val NEW_LINE"}
{"text":"Function to perform the queries","code":"def performQueries ( queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( nextValid ( queries [ i ] ) ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"queries = [ 4 , 6 ] NEW_LINE q = len ( queries ) NEW_LINE"}
{"text":"Pre - compute the numbers","code":"preCompute ( ) NEW_LINE"}
{"text":"Perform the queries","code":"performQueries ( queries , q ) NEW_LINE"}
{"text":"Function to return the number of operations required","code":"def changeToOnes ( string ) : NEW_LINE"}
{"text":"ctr will store the number of consecutive ones at the end of the given binary string","code":"ctr = 0 ; NEW_LINE l = len ( string ) ; NEW_LINE"}
{"text":"Loop to find number of 1 s at the end of the string","code":"for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE"}
{"text":"If the current character is 1","code":"if ( string [ i ] == '1' ) : NEW_LINE INDENT ctr += 1 ; NEW_LINE DEDENT"}
{"text":"If we encounter the first 0 from the LSB position then we 'll break the loop","code":"else : NEW_LINE INDENT break ; NEW_LINE DEDENT"}
{"text":"Number of operations required is ( l - ctr )","code":"return l - ctr ; NEW_LINE"}
{"text":"Function to remove leading zeroes from the string","code":"def removeZeroesFromFront ( string ) : NEW_LINE INDENT s = \" \" ; NEW_LINE i = 0 ; NEW_LINE DEDENT"}
{"text":"Loop until s [ i ] becomes not equal to 1","code":"while ( i < len ( string ) and string [ i ] == '0' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT"}
{"text":"If we reach the end of the string , it means that string contains only 0 's","code":"if ( i == len ( string ) ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE DEDENT"}
{"text":"Return the string without leading zeros","code":"else : NEW_LINE INDENT s = string [ i : len ( string ) - i ] ; NEW_LINE DEDENT return s ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"10010111\" ; NEW_LINE DEDENT"}
{"text":"Removing the leading zeroes","code":"string = removeZeroesFromFront ( string ) ; NEW_LINE print ( changeToOnes ( string ) ) ; NEW_LINE"}
{"text":"Function to return the minimum deletions required","code":"def MinDeletion ( a , n ) : NEW_LINE"}
{"text":"To store the frequency of the array elements","code":"map = dict . fromkeys ( a , 0 ) ; NEW_LINE"}
{"text":"Store frequency of each element","code":"for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 ; NEW_LINE DEDENT"}
{"text":"To store the minimum deletions required","code":"ans = 0 ; NEW_LINE for key , value in map . items ( ) : NEW_LINE"}
{"text":"Value","code":"x = key ; NEW_LINE"}
{"text":"It 's frequency","code":"frequency = value ; NEW_LINE"}
{"text":"If number less than or equal to it 's frequency","code":"if ( x <= frequency ) : NEW_LINE"}
{"text":"Delete extra occurrences","code":"ans += ( frequency - x ) ; NEW_LINE"}
{"text":"Delete every occurrence of x","code":"else : NEW_LINE INDENT ans += frequency ; NEW_LINE DEDENT return ans ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinDeletion ( a , n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to find maximum number of ABs","code":"def maxCountAB ( s , n ) : NEW_LINE"}
{"text":"variable A , B , AB for count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively .","code":"A = 0 NEW_LINE B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE DEDENT"}
{"text":"' AB ' is already present in string before concatenate them","code":"if ( S [ j ] == ' A ' and S [ j + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT"}
{"text":"count of strings that begins with ' B ' and ends with 'A","code":"if ( S [ 0 ] == ' B ' and S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT"}
{"text":"count of strings that begins with ' B ' but does not end with 'A","code":"' NEW_LINE INDENT elif ( S [ 0 ] == ' B ' ) : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT"}
{"text":"count of strings that ends with ' A ' but not end with 'B","code":"' NEW_LINE INDENT elif ( S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT DEDENT"}
{"text":"updating the value of ans and add extra count of 'AB","code":"' NEW_LINE INDENT if ( BA == 0 ) : NEW_LINE INDENT ans += min ( B , A ) NEW_LINE DEDENT elif ( A + B == 0 ) : NEW_LINE INDENT ans += BA - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += BA + min ( B , A ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ \" ABCA \" , \" BOOK \" , \" BAND \" ] NEW_LINE n = len ( s ) NEW_LINE print ( maxCountAB ( s , n ) ) NEW_LINE DEDENT"}
{"text":"Function to return the minimum number of operations required","code":"def MinOperations ( n , x , arr ) : NEW_LINE"}
{"text":"To store total operations required","code":"total = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"First make all elements equal to x which are currenctly greater","code":"if ( arr [ i ] > x ) : NEW_LINE INDENT difference = arr [ i ] - x NEW_LINE total = total + difference NEW_LINE arr [ i ] = x NEW_LINE DEDENT"}
{"text":"Left scan the array","code":"for i in range ( n ) : NEW_LINE INDENT LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] NEW_LINE DEDENT"}
{"text":"Update the current element such that neighbouring sum is < x","code":"if ( LeftNeigbouringSum > x ) : NEW_LINE INDENT current_diff = LeftNeigbouringSum - x NEW_LINE arr [ i ] = max ( 0 , arr [ i ] - current_diff ) NEW_LINE total = total + current_diff NEW_LINE DEDENT return total NEW_LINE"}
{"text":"Driver code","code":"X = 1 NEW_LINE arr = [ 1 , 6 , 1 , 2 , 0 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( MinOperations ( N , X , arr ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"import math NEW_LINE"}
{"text":"Function to print the required numbers","code":"def findNumbers ( arr , n ) : NEW_LINE"}
{"text":"Sum of first n natural numbers","code":"sumN = ( n * ( n + 1 ) ) \/ 2 ; NEW_LINE"}
{"text":"Sum of squares of first n natural numbers","code":"sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) \/ 6 ; NEW_LINE"}
{"text":"To store the sum and sum of squares of the array elements","code":"sum = 0 ; NEW_LINE sumSq = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE sumSq = sumSq + ( math . pow ( arr [ i ] , 2 ) ) ; NEW_LINE DEDENT B = ( ( ( sumSq - sumSqN ) \/ ( sum - sumN ) ) + sumN - sum ) \/ 2 ; NEW_LINE A = sum - sumN + B ; NEW_LINE print ( \" A \u2581 = \u2581 \" , int ( A ) ) ; NEW_LINE print ( \" B \u2581 = \u2581 \" , int ( B ) ) ; NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 2 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNumbers ( arr , n ) ; NEW_LINE"}
{"text":"Function to find the whether the string temp starts with str or not","code":"def is_prefix ( temp , str ) : NEW_LINE"}
{"text":"Base Case","code":"if ( len ( temp ) < len ( str ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Check for the corresponding characters in temp & str","code":"for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != temp [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE"}
{"text":"Function to find lexicographic smallest string consisting of the string str as prefix","code":"def lexicographicallyString ( input , n , str ) : NEW_LINE"}
{"text":"Sort the given array string arr [ ]","code":"input . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = input [ i ] NEW_LINE DEDENT"}
{"text":"If the i - th string contains given string as a prefix , then print the result","code":"if ( is_prefix ( temp , str ) ) : NEW_LINE INDENT return temp NEW_LINE DEDENT"}
{"text":"If no string exists then return \" - 1\"","code":"return \" - 1\" NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" ] NEW_LINE S = \" app \" NEW_LINE N = 5 NEW_LINE print ( lexicographicallyString ( arr , N , S ) ) NEW_LINE DEDENT"}
{"text":"Function to rearrange the array","code":"def Rearrange ( arr , K , N ) : NEW_LINE"}
{"text":"Stores the rearranged array","code":"ans = [ 0 ] * ( N + 1 ) NEW_LINE"}
{"text":"Stores whether the arrangement is possible or not","code":"f = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans [ i ] = - 1 NEW_LINE DEDENT"}
{"text":"Update K with the position of K","code":"K = arr . index ( K ) NEW_LINE"}
{"text":"Stores all elements lesser than and greater than in vector smaller and greater respectively","code":"smaller = [ ] NEW_LINE greater = [ ] NEW_LINE"}
{"text":"Traverse the array arr [ ]","code":"for i in range ( N ) : NEW_LINE"}
{"text":"If arr [ i ] is less than arr [ K ]","code":"if ( arr [ i ] < arr [ K ] ) : NEW_LINE INDENT smaller . append ( arr [ i ] ) NEW_LINE DEDENT"}
{"text":"Else","code":"elif ( arr [ i ] > arr [ K ] ) : NEW_LINE INDENT greater . append ( arr [ i ] ) NEW_LINE DEDENT low = 0 NEW_LINE high = N - 1 NEW_LINE"}
{"text":"Iterate unil low is less than or equal to high","code":"while ( low <= high ) : NEW_LINE"}
{"text":"Stores mid point","code":"mid = ( low + high ) \/\/ 2 NEW_LINE"}
{"text":"If mid is equal to K","code":"if ( mid == K ) : NEW_LINE INDENT ans [ mid ] = arr [ K ] NEW_LINE f = 1 NEW_LINE break NEW_LINE DEDENT"}
{"text":"If mid is less than K","code":"elif ( mid < K ) : NEW_LINE INDENT if ( len ( smaller ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans [ mid ] = smaller [ - 1 ] NEW_LINE smaller . pop ( ) NEW_LINE low = mid + 1 NEW_LINE DEDENT"}
{"text":"If mid is greater than K","code":"else : NEW_LINE INDENT if ( len ( greater ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans [ mid ] = greater [ - 1 ] NEW_LINE greater . pop ( ) NEW_LINE high = mid - 1 NEW_LINE DEDENT"}
{"text":"If f is - 1","code":"if ( f == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Iterate in the range [ 1 , N ]","code":"for i in range ( N ) : NEW_LINE"}
{"text":"If ans [ i ] is equal to - 1","code":"if ( ans [ i ] == - 1 ) : NEW_LINE INDENT if ( len ( smaller ) ) : NEW_LINE INDENT ans [ i ] = smaller [ - 1 ] NEW_LINE smaller . pop ( ) NEW_LINE DEDENT elif ( len ( greater ) ) : NEW_LINE INDENT ans [ i ] = greater [ - 1 ] NEW_LINE greater . pop ( ) NEW_LINE DEDENT DEDENT"}
{"text":"Print the rearranged array","code":"for i in range ( N ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Input","code":"arr = [ 10 , 7 , 2 , 5 , 3 , 8 ] NEW_LINE K = 7 NEW_LINE N = len ( arr ) NEW_LINE"}
{"text":"Function Call","code":"Rearrange ( arr , K , N ) NEW_LINE"}
{"text":"Python 3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to find minimum value of K such that the first person gets at least ( N \/ ( M + 1 ) ) candies","code":"def minimumK ( arr , M , N ) : NEW_LINE"}
{"text":"Find the minimum required value of candies for the first person","code":"good = math . ceil ( ( N * 1.0 ) \/ ( ( M + 1 ) * 1.0 ) ) NEW_LINE"}
{"text":"Iterate K from [ 1 , n ]","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT K = i NEW_LINE DEDENT"}
{"text":"Total number of candies","code":"candies = N NEW_LINE"}
{"text":"Candies taken by Person 1","code":"taken = 0 NEW_LINE while ( candies > 0 ) : NEW_LINE"}
{"text":"Candies taken by 1 st person is minimum of K and candies left","code":"taken += min ( K , candies ) NEW_LINE candies -= min ( K , candies ) NEW_LINE"}
{"text":"Traverse the array arr [ ]","code":"for j in range ( M ) : NEW_LINE"}
{"text":"Amount consumed by the person j","code":"consume = ( arr [ j ] * candies ) \/ 100 NEW_LINE"}
{"text":"Update the number of candies","code":"candies -= consume NEW_LINE"}
{"text":"Good share of candies achieved","code":"if ( taken >= good ) : NEW_LINE print ( i ) NEW_LINE return NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 13 NEW_LINE M = 1 NEW_LINE arr = [ 50 ] NEW_LINE minimumK ( arr , M , N ) NEW_LINE DEDENT"}
{"text":"Function to calculate time taken to travel the path","code":"def calcTotalTime ( path ) : NEW_LINE"}
{"text":"Stores total time","code":"time = 0 NEW_LINE"}
{"text":"Initial position","code":"x = 0 NEW_LINE y = 0 NEW_LINE"}
{"text":"Stores visited segments","code":"s = set ( [ ] ) NEW_LINE for i in range ( len ( path ) ) : NEW_LINE INDENT p = x NEW_LINE q = y NEW_LINE if ( path [ i ] == ' N ' ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif ( path [ i ] == ' S ' ) : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif ( path [ i ] == ' E ' ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif ( path [ i ] == ' W ' ) : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT"}
{"text":"Check whether segment is present in the set","code":"if ( p + x , q + y ) not in s : NEW_LINE"}
{"text":"Increment the value of time by 2","code":"time += 2 NEW_LINE"}
{"text":"Insert segment into the set","code":"s . add ( ( p + x , q + y ) ) NEW_LINE else : NEW_LINE time += 1 NEW_LINE"}
{"text":"Print the value of time","code":"print ( time ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT path = \" NSE \" NEW_LINE calcTotalTime ( path ) NEW_LINE DEDENT"}
{"text":"Function to calculate the cost required to make all array elements equal to 1","code":"def findCost ( A , N ) : NEW_LINE"}
{"text":"Stores the total cost","code":"totalCost = 0 NEW_LINE"}
{"text":"Traverse the array arr [ ]","code":"for i in range ( N ) : NEW_LINE"}
{"text":"If current element is 0","code":"if ( A [ i ] == 0 ) : NEW_LINE"}
{"text":"Convert 0 to 1","code":"A [ i ] = 1 NEW_LINE"}
{"text":"Add the cost","code":"totalCost += i NEW_LINE"}
{"text":"Return the total cost","code":"return totalCost NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findCost ( arr , N ) ) NEW_LINE DEDENT"}
{"text":"Function to find the peak index for the given array","code":"def peakIndex ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE DEDENT"}
{"text":"Base Case","code":"if ( len ( arr ) < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 0 NEW_LINE"}
{"text":"Check for strictly increasing array","code":"while ( i + 1 < N ) : NEW_LINE"}
{"text":"If the strictly increasing condition is violated , then break","code":"if ( arr [ i + 1 ] < arr [ i ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE if ( i == 0 or i == N - 1 ) : NEW_LINE return - 1 NEW_LINE"}
{"text":"Stores the value of i , which is a potential peak index","code":"ans = i NEW_LINE"}
{"text":"Second traversal , for strictly decreasing array","code":"while ( i < N - 1 ) : NEW_LINE"}
{"text":"When the strictly decreasing condition is violated , then break","code":"if ( arr [ i ] < arr [ i + 1 ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"If i = N - 1 , it means that ans is the peak index","code":"if ( i == N - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT"}
{"text":"Otherwise , peak index doesn 't exist","code":"return - 1 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 1 , 0 ] NEW_LINE print ( peakIndex ( arr ) ) NEW_LINE DEDENT"}
{"text":"Function to check if the array has 2 elements whose sum is equal to the given value","code":"def hasArrayTwoPairs ( nums , n , target ) : NEW_LINE"}
{"text":"Sort the array in increasing order","code":"nums = sorted ( nums ) NEW_LINE"}
{"text":"Traverse the array , nums [ ]","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Store the required number to be found","code":"x = target - nums [ i ] NEW_LINE"}
{"text":"Perform binary search","code":"low , high = 0 , n - 1 NEW_LINE while ( low <= high ) : NEW_LINE"}
{"text":"Store the mid value","code":"mid = low + ( ( high - low ) \/\/ 2 ) NEW_LINE"}
{"text":"If nums [ mid ] is greater than x , then update high to mid - 1","code":"if ( nums [ mid ] > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT"}
{"text":"If nums [ mid ] is less than x , then update low to mid + 1","code":"elif ( nums [ mid ] < x ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"If mid is equal i , check mid - 1 and mid + 1","code":"if ( mid == i ) : NEW_LINE INDENT if ( ( mid - 1 >= 0 ) and nums [ mid - 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = \" , \u2581 \" ) NEW_LINE print ( nums [ mid - 1 ] ) NEW_LINE return NEW_LINE DEDENT if ( ( mid + 1 < n ) and nums [ mid + 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = \" , \u2581 \" ) NEW_LINE print ( nums [ mid + 1 ] ) NEW_LINE return NEW_LINE DEDENT break NEW_LINE DEDENT"}
{"text":"Otherwise , prthe pair and return","code":"else : NEW_LINE INDENT print ( nums [ i ] , end = \" , \u2581 \" ) NEW_LINE print ( nums [ mid ] ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"If no such pair is found , then pr - 1","code":"print ( - 1 ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , - 1 , 2 , - 3 , 1 ] NEW_LINE X = - 2 NEW_LINE N = len ( A ) NEW_LINE DEDENT"}
{"text":"Function Call","code":"hasArrayTwoPairs ( A , N , X ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from math import sqrt , floor , ceil NEW_LINE"}
{"text":"Function to find the divisor of N closest to the target","code":"def findClosest ( N , target ) : NEW_LINE INDENT closest = - 1 NEW_LINE diff = 10 ** 18 NEW_LINE DEDENT"}
{"text":"Iterate till square root of N","code":"for i in range ( 1 , ceil ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE DEDENT"}
{"text":"Check if divisors are equal","code":"if ( N \/\/ i == i ) : NEW_LINE"}
{"text":"Check if i is the closest","code":"if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Check if i is the closest","code":"if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT"}
{"text":"Check if n \/ i is the closest","code":"if ( abs ( target - N \/\/ i ) < diff ) : NEW_LINE INDENT diff = abs ( target - N \/\/ i ) NEW_LINE closest = N \/\/ i NEW_LINE DEDENT"}
{"text":"Prthe closest value","code":"print ( closest ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given N & X","code":"N , X = 16 , 5 NEW_LINE"}
{"text":"Function Call","code":"findClosest ( N , X ) NEW_LINE"}
{"text":"Function to calculate the minimum power of A and B greater than N","code":"def power ( A , N ) : NEW_LINE"}
{"text":"Stores the power of A which is greater than N","code":"count = 0 ; NEW_LINE if ( A == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( N > 0 ) : NEW_LINE"}
{"text":"Increment count by 1","code":"count += 1 ; NEW_LINE"}
{"text":"Divide N by A","code":"N \/\/= A ; NEW_LINE return int ( count ) ; NEW_LINE"}
{"text":"Function to find a pair ( a , b ) such that A ^ a + B ^ b = N","code":"def Pairs ( N , A , B ) : NEW_LINE INDENT powerA , powerB = 0 , 0 ; NEW_LINE DEDENT"}
{"text":"Calculate the minimum power of A greater than N","code":"powerA = power ( A , N ) ; NEW_LINE"}
{"text":"Calculate the minimum power of B greater than N","code":"powerB = power ( B , N ) ; NEW_LINE"}
{"text":"Make copy of A and B","code":"intialB = B ; NEW_LINE intialA = A ; NEW_LINE"}
{"text":"Traverse for every pair ( i , j )","code":"A = 1 ; NEW_LINE for i in range ( powerA + 1 ) : NEW_LINE INDENT B = 1 ; NEW_LINE for j in range ( powerB + 1 ) : NEW_LINE DEDENT"}
{"text":"Check if B ^ j + A ^ i = N To overcome the overflow problem use B = N - A rather than B + A = N","code":"if ( B == N - A ) : NEW_LINE INDENT print ( i , \" \u2581 \" , j ) ; NEW_LINE return ; NEW_LINE DEDENT"}
{"text":"Increment power B by 1","code":"B *= intialB ; NEW_LINE"}
{"text":"Increment power A by 1","code":"A *= intialA ; NEW_LINE"}
{"text":"Finally pr - 1 if no pair is found","code":"print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given A , B and N","code":"N = 106 ; NEW_LINE A = 3 ; NEW_LINE B = 5 ; NEW_LINE"}
{"text":"Function Call","code":"Pairs ( N , A , B ) ; NEW_LINE"}
{"text":"Function to find the non - multiples till k","code":"def findNonMultiples ( arr , n , k ) : NEW_LINE"}
{"text":"Stores all unique multiples","code":"multiples = set ( [ ] ) NEW_LINE"}
{"text":"Iterate the array","code":"for i in range ( n ) : NEW_LINE"}
{"text":"For finding duplicates only once","code":"if ( arr [ i ] not in multiples ) : NEW_LINE"}
{"text":"Inserting all multiples into the set","code":"for j in range ( 1 , k \/\/ arr [ i ] + 1 ) : NEW_LINE INDENT multiples . add ( arr [ i ] * j ) NEW_LINE DEDENT"}
{"text":"Returning only the count of numbers that are not divisible by any of the array elements","code":"return k - len ( multiples ) NEW_LINE"}
{"text":"Function to count the total values in the range [ L , R ]","code":"def countValues ( arr , N , L , R ) : NEW_LINE"}
{"text":"Count all values in the range using exclusion principle","code":"return ( findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE L = 1 NEW_LINE R = 20 NEW_LINE DEDENT"}
{"text":"Function Call","code":"print ( countValues ( arr , N , L , R ) ) NEW_LINE"}
{"text":"Function to find the minimum number of coins to be collected per hour to empty N piles in H hours","code":"def minCollectingSpeed ( piles , H ) : NEW_LINE"}
{"text":"Stores the minimum coins to be removed per hour","code":"ans = - 1 NEW_LINE low = 1 NEW_LINE"}
{"text":"Find the maximum array element","code":"high = max ( piles ) NEW_LINE"}
{"text":"Perform Binary Search","code":"while ( low <= high ) : NEW_LINE"}
{"text":"Store the mid value of the range in K","code":"K = low + ( high - low ) \/\/ 2 NEW_LINE time = 0 NEW_LINE"}
{"text":"Find the total time taken to empty N piles by removing K coins per hour","code":"for ai in piles : NEW_LINE time += ( ai + K - 1 ) \/\/ K NEW_LINE"}
{"text":"If total time does not exceed H","code":"if ( time <= H ) : NEW_LINE INDENT ans = K NEW_LINE high = K - 1 NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT low = K + 1 NEW_LINE DEDENT"}
{"text":"Prthe required result","code":"print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 7 , 11 ] NEW_LINE H = 8 NEW_LINE DEDENT"}
{"text":"Function Call","code":"minCollectingSpeed ( arr , H ) NEW_LINE"}
{"text":"Function to count distinct pairs in array whose sum equal to K","code":"def cntDisPairs ( arr , N , K ) : NEW_LINE"}
{"text":"Stores count of distinct pairs whose sum equal to K","code":"cntPairs = 0 NEW_LINE"}
{"text":"Sort the array","code":"arr = sorted ( arr ) NEW_LINE"}
{"text":"Stores index of the left pointer","code":"i = 0 NEW_LINE"}
{"text":"Stores index of the right pointer","code":"j = N - 1 NEW_LINE"}
{"text":"Calculate count of distinct pairs whose sum equal to K","code":"while ( i < j ) : NEW_LINE"}
{"text":"If sum of current pair is equal to K","code":"if ( arr [ i ] + arr [ j ] == K ) : NEW_LINE"}
{"text":"Remove consecutive duplicate array elements","code":"while ( i < j and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE"}
{"text":"Update i","code":"i += 1 NEW_LINE"}
{"text":"Remove consecutive duplicate array elements","code":"while ( i < j and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE"}
{"text":"Update j","code":"j -= 1 NEW_LINE"}
{"text":"Update cntPairs","code":"cntPairs += 1 NEW_LINE"}
{"text":"Update i","code":"i += 1 NEW_LINE"}
{"text":"Update j","code":"j -= 1 NEW_LINE"}
{"text":"If sum of current pair less than K","code":"elif ( arr [ i ] + arr [ j ] < K ) : NEW_LINE"}
{"text":"Update i","code":"i += 1 NEW_LINE else : NEW_LINE"}
{"text":"Update j","code":"j -= 1 NEW_LINE return cntPairs NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 5 , 7 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( cntDisPairs ( arr , N , K ) ) NEW_LINE DEDENT"}
{"text":"Function to count distinct pairs in array whose sum equal to K","code":"def cntDisPairs ( arr , N , K ) : NEW_LINE"}
{"text":"Stores count of distinct pairs whose sum equal to K","code":"cntPairs = 0 NEW_LINE"}
{"text":"Store frequency of each distinct element of the array","code":"cntFre = { } NEW_LINE for i in arr : NEW_LINE"}
{"text":"Update frequency of arr [ i ]","code":"if i in cntFre : NEW_LINE INDENT cntFre [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntFre [ i ] = 1 NEW_LINE DEDENT"}
{"text":"Traverse the map","code":"for key , value in cntFre . items ( ) : NEW_LINE"}
{"text":"Stores key value of the map","code":"i = key NEW_LINE"}
{"text":"If i is the half of K","code":"if ( 2 * i == K ) : NEW_LINE"}
{"text":"If frequency of i greater than 1","code":"if ( cntFre [ i ] > 1 ) : NEW_LINE INDENT cntPairs += 2 NEW_LINE DEDENT else : NEW_LINE if ( cntFre [ K - i ] ) : NEW_LINE"}
{"text":"Update cntPairs","code":"cntPairs += 1 NEW_LINE"}
{"text":"Update cntPairs","code":"cntPairs = cntPairs \/ 2 NEW_LINE return cntPairs NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 5 , 6 , 5 , 7 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( int ( cntDisPairs ( arr , N , K ) ) ) NEW_LINE"}
{"text":"Function to find the length of the longest subsequence such that no two adjacent elements are equal","code":"def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT for i in range ( Q ) : NEW_LINE DEDENT"}
{"text":"Replace element at index x with y","code":"x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE"}
{"text":"Since x is 1 - indexed , decrement x by 1","code":"arr [ x - 1 ] = y NEW_LINE"}
{"text":"Keep track of number of elements in subsequence","code":"count = 1 NEW_LINE for j in range ( 1 , N ) : NEW_LINE"}
{"text":"If previous element is not same as current element","code":"if ( arr [ j ] != arr [ j - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Print the desired count","code":"print ( count , end = ' \u2581 ' ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Q = 2 NEW_LINE Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE DEDENT"}
{"text":"Function Call","code":"longestSubsequence ( N , Q , arr , Queries ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT"}
{"text":"Traverse the array arr [ ]","code":"for i in range ( 1 , N ) : NEW_LINE"}
{"text":"If previous element is not same as current element","code":"if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Traverse the queries","code":"for i in range ( Q ) : NEW_LINE"}
{"text":"Replace element at index x with y","code":"x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE"}
{"text":"Recalculate for index x","code":"if ( x > 1 ) : NEW_LINE"}
{"text":"Subtract contribution of element at index x","code":"if ( arr [ x - 1 ] != arr [ x - 2 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT"}
{"text":"Add contribution of y","code":"if ( arr [ x - 2 ] != y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Recalculate for index x + 1","code":"if ( x < N ) : NEW_LINE"}
{"text":"Subtract contribution of element at index x + 1","code":"if ( arr [ x ] != arr [ x - 1 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT"}
{"text":"Adds contribution of y","code":"if ( y != arr [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count , end = ' \u2581 ' ) NEW_LINE"}
{"text":"Replace the element","code":"arr [ x - 1 ] = y NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Q = 2 NEW_LINE Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE DEDENT"}
{"text":"Function Call","code":"longestSubsequence ( N , Q , arr , Queries ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function to find sum of differences of indices of occurrences of each unique array element","code":"def sum_i ( arr , n ) : NEW_LINE"}
{"text":"Stores indices of each array element","code":"mp = defaultdict ( lambda : [ ] ) NEW_LINE"}
{"text":"Store the indices","code":"for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] . append ( i ) NEW_LINE DEDENT"}
{"text":"Stores the sums","code":"ans = [ 0 ] * n NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Find sum for each element","code":"sum = 0 NEW_LINE"}
{"text":"Iterate over the Map","code":"for it in mp [ arr [ i ] ] : NEW_LINE"}
{"text":"Calculate sum of occurrences of arr [ i ]","code":"sum += abs ( it - i ) NEW_LINE"}
{"text":"Store sum for current element","code":"ans [ i ] = sum NEW_LINE"}
{"text":"Print answer for each element","code":"for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given array","code":"arr = [ 1 , 3 , 1 , 1 , 2 ] NEW_LINE"}
{"text":"Given size","code":"n = len ( arr ) NEW_LINE"}
{"text":"Function Call","code":"sum_i ( arr , n ) NEW_LINE"}
{"text":"Function to convert vowels into uppercase","code":"def conVowUpp ( str ) : NEW_LINE"}
{"text":"Stores the length of str","code":"N = len ( str ) NEW_LINE str1 = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT c = ( str [ i ] ) . upper ( ) NEW_LINE str1 += c NEW_LINE DEDENT else : NEW_LINE INDENT str1 += str [ i ] NEW_LINE DEDENT DEDENT print ( str1 ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" eutopia \" NEW_LINE conVowUpp ( str ) NEW_LINE DEDENT"}
{"text":"Stores the frequency of each type of chocolate","code":"mp = { } NEW_LINE N , P = 0 , 0 NEW_LINE"}
{"text":"Function to check if chocolates can be eaten for ' mid ' no . of days","code":"def helper ( mid ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in mp : NEW_LINE INDENT temp = mp [ i ] NEW_LINE while ( temp >= mid ) : NEW_LINE INDENT temp -= mid NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"If cnt exceeds N , return true","code":"return cnt >= N NEW_LINE"}
{"text":"Function to find the maximum number of days for which chocolates can be eaten","code":"def findMaximumDays ( arr ) : NEW_LINE"}
{"text":"Store the frequency of each type of chocolate","code":"for i in range ( P ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT"}
{"text":"Initialize start and end with 0 and P respectively","code":"start = 0 NEW_LINE end = P NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE"}
{"text":"Calculate mid","code":"mid = start + ( ( end - start ) \/\/ 2 ) NEW_LINE"}
{"text":"Check if chocolates can be distributed for mid days","code":"if ( mid != 0 and helper ( mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE DEDENT"}
{"text":"Check if chocolates can be distributed for more than mid consecutive days","code":"start = mid + 1 NEW_LINE elif ( mid == 0 ) : NEW_LINE start = mid + 1 NEW_LINE else : NEW_LINE end = mid - 1 NEW_LINE return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE P = 10 NEW_LINE arr = [ 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 ] NEW_LINE DEDENT"}
{"text":"Function call","code":"print ( findMaximumDays ( arr ) ) NEW_LINE"}
{"text":"Function that counts the subarrays having sum modulo k equal to the length of subarray","code":"def countSubarrays ( a , n , k ) : NEW_LINE"}
{"text":"Stores the count of subarrays","code":"ans = 0 NEW_LINE"}
{"text":"Stores prefix sum of the array","code":"pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE"}
{"text":"Calculate prefix sum array","code":"for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT"}
{"text":"Generate all the subarrays","code":"for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE DEDENT"}
{"text":"Check if this subarray is a valid subarray or not","code":"if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT"}
{"text":"Total count of subarrays","code":"print ( ans , end = ' \u2581 ' ) NEW_LINE"}
{"text":"Given arr [ ]","code":"arr = [ 2 , 3 , 5 , 3 , 1 , 5 ] NEW_LINE"}
{"text":"Size of the array","code":"N = len ( arr ) NEW_LINE"}
{"text":"Given K","code":"K = 4 NEW_LINE"}
{"text":"Function call","code":"countSubarrays ( arr , N , K ) NEW_LINE"}
{"text":"Function that counts the subarrays s . t . sum of elements in the subarray modulo k is equal to size of subarray","code":"def countSubarrays ( a , n , k ) : NEW_LINE"}
{"text":"Stores the count of ( pref [ i ] - i ) % k","code":"cnt = { } NEW_LINE"}
{"text":"Stores the count of subarray","code":"ans = 0 NEW_LINE"}
{"text":"Stores prefix sum of the array","code":"pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE"}
{"text":"Find prefix sum array","code":"for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT"}
{"text":"Base Condition","code":"cnt [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE"}
{"text":"Remove the index at present after K indices from the current index","code":"remIdx = i - k NEW_LINE if ( remIdx >= 0 ) : NEW_LINE INDENT if ( ( pref [ remIdx ] - remIdx % k + k ) % k in cnt ) : NEW_LINE INDENT cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] = - 1 NEW_LINE DEDENT DEDENT"}
{"text":"Update the answer for subarrays ending at the i - th index","code":"if ( pref [ i ] - i % k + k ) % k in cnt : NEW_LINE INDENT ans += cnt [ ( pref [ i ] - i % k + k ) % k ] NEW_LINE DEDENT"}
{"text":"Add the calculated value of current index to count","code":"if ( pref [ i ] - i % k + k ) % k in cnt : NEW_LINE INDENT cnt [ ( pref [ i ] - i % k + k ) % k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ( pref [ i ] - i % k + k ) % k ] = 1 NEW_LINE DEDENT"}
{"text":"Print the count of subarrays","code":"print ( ans , end = ' \u2581 ' ) NEW_LINE"}
{"text":"Given arr [ ]","code":"arr = [ 2 , 3 , 5 , 3 , 1 , 5 ] NEW_LINE"}
{"text":"Size of the array","code":"N = len ( arr ) NEW_LINE"}
{"text":"Given K","code":"K = 4 NEW_LINE"}
{"text":"Function call","code":"countSubarrays ( arr , N , K ) NEW_LINE"}
{"text":"Function to check if the substring of length K has equal 0 and 1","code":"def check ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT"}
{"text":"Traverse the string","code":"for i in range ( k ) : NEW_LINE INDENT for j in range ( i , n , k ) : NEW_LINE DEDENT"}
{"text":"Check if every K - th character is the same or not","code":"if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = 0 NEW_LINE"}
{"text":"Traverse substring of length K","code":"for i in range ( k ) : NEW_LINE"}
{"text":"If current character is 0","code":"if ( s [ i ] == '0' ) : NEW_LINE"}
{"text":"Increment count","code":"c += 1 NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Decrement count","code":"c -= 1 NEW_LINE"}
{"text":"Check for equal 0 s and 1 s","code":"if ( c == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"s = \"101010\" NEW_LINE k = 2 NEW_LINE if ( check ( s , k ) != 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function to check if the freq of any character is divisible by N","code":"def isSame ( str , n ) : NEW_LINE"}
{"text":"Stores the frequency of characters","code":"mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mp [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for it in mp . keys ( ) : NEW_LINE"}
{"text":"If frequency of a character is not divisible by n","code":"if ( mp [ it ] >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"If no character has frequency at least N","code":"return False NEW_LINE"}
{"text":"Driver Code","code":"str = \" ccabcba \" NEW_LINE n = 4 NEW_LINE"}
{"text":"Function call","code":"if ( isSame ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE eps = 1e-6 NEW_LINE"}
{"text":"Given function","code":"def func ( a , b , c , x ) : NEW_LINE INDENT return a * x * x + b * x + c NEW_LINE DEDENT"}
{"text":"Function to find the root of the given non - decreasing Function","code":"def findRoot ( a , b , c , low , high ) : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT"}
{"text":"To get the minimum possible answer for the root","code":"while abs ( high - low ) > eps : NEW_LINE"}
{"text":"Find mid","code":"x = ( low + high ) \/ 2 NEW_LINE"}
{"text":"Search in [ low , x ]","code":"if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) : NEW_LINE INDENT high = x NEW_LINE DEDENT"}
{"text":"Search in [ x , high ]","code":"else : NEW_LINE INDENT low = x NEW_LINE DEDENT"}
{"text":"Return the required answer","code":"return x NEW_LINE"}
{"text":"Function to find the roots of the given equation within range [ a , b ]","code":"def solve ( a , b , c , A , B ) : NEW_LINE"}
{"text":"If root doesn 't exists","code":"if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) : NEW_LINE INDENT print ( \" No \u2581 solution \" ) NEW_LINE DEDENT"}
{"text":"Else find the root upto 4 decimal places","code":"else : NEW_LINE INDENT print ( \" { : . 4f } \" . format ( findRoot ( a , b , c , A , B ) ) ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given range","code":"a = 2 NEW_LINE b = - 3 NEW_LINE c = - 2 NEW_LINE A = 0 NEW_LINE B = 3 NEW_LINE"}
{"text":"Function call","code":"solve ( a , b , c , A , B ) NEW_LINE"}
{"text":"Function check if mid can be median index of the difference array","code":"def possible ( mid , a ) : NEW_LINE"}
{"text":"Size of the array","code":"n = len ( a ) ; NEW_LINE"}
{"text":"Total possible no of pair possible","code":"total = ( n * ( n - 1 ) ) \/\/ 2 ; NEW_LINE"}
{"text":"The index of the element in the difference of all pairs from the array","code":"need = ( total + 1 ) \/\/ 2 ; NEW_LINE count = 0 ; NEW_LINE start = 0 ; end = 1 ; NEW_LINE"}
{"text":"Count the number of pairs having difference <= mid","code":"while ( end < n ) : NEW_LINE INDENT if ( a [ end ] - a [ start ] <= mid ) : NEW_LINE INDENT end += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( end - start - 1 ) ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"If the difference between end and first element is less then or equal to mid","code":"if ( end == n and start < end and a [ end - 1 ] - a [ start ] <= mid ) : NEW_LINE INDENT t = end - start - 1 ; NEW_LINE count += ( t * ( t + 1 ) \/\/ 2 ) ; NEW_LINE DEDENT"}
{"text":"Checking for the no of element less than or equal to mid is greater than median or not","code":"if ( count >= need ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT"}
{"text":"Function to calculate the median of differences of all pairs from the array","code":"def findMedian ( a ) : NEW_LINE"}
{"text":"Size of the array","code":"n = len ( a ) ; NEW_LINE"}
{"text":"Initialising the low and high","code":"low = 0 ; high = a [ n - 1 ] - a [ 0 ] ; NEW_LINE"}
{"text":"Binary search","code":"while ( low <= high ) : NEW_LINE"}
{"text":"Calculate mid","code":"mid = ( low + high ) \/\/ 2 ; NEW_LINE"}
{"text":"If mid can be the median of the array","code":"if ( possible ( mid , a ) ) : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT"}
{"text":"Returning the median of the differences of pairs from the array","code":"return high + 1 ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 7 , 5 , 2 ] ; NEW_LINE a . sort ( ) NEW_LINE print ( findMedian ( a ) ) ; NEW_LINE DEDENT"}
{"text":"Function to find strings from A [ ] having all strings in B [ ] as subsequence","code":"def UniversalSubset ( A , B ) : NEW_LINE"}
{"text":"Calculate respective sizes","code":"n1 = len ( A ) NEW_LINE n2 = len ( B ) NEW_LINE"}
{"text":"Stores the answer","code":"res = [ ] NEW_LINE"}
{"text":"Stores the frequency of each character in strings of A [ ]","code":"A_freq = [ [ 0 for x in range ( 26 ) ] for y in range ( n1 ) ] NEW_LINE"}
{"text":"Compute the frequencies of characters of all strings","code":"for i in range ( n1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT A_freq [ i ] [ ord ( A [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Stores the frequency of each character in strings of B [ ] each character of a string in B [ ]","code":"B_freq = [ 0 ] * 26 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE for j in range ( len ( B [ i ] ) ) : NEW_LINE INDENT arr [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE B_freq [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] = max ( B_freq [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] , arr [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] ) NEW_LINE DEDENT DEDENT for i in range ( n1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE DEDENT"}
{"text":"If the frequency of a character in B [ ] exceeds that in A [ ]","code":"if ( A_freq [ i ] [ j ] < B_freq [ j ] ) : NEW_LINE"}
{"text":"A string exists in B [ ] which is not a proper subset of A [ i ]","code":"flag = 1 NEW_LINE break NEW_LINE"}
{"text":"If all strings in B [ ] are proper subset of A [ ]","code":"if ( flag == 0 ) : NEW_LINE"}
{"text":"Push the string in resultant vector","code":"res . append ( A [ i ] ) NEW_LINE"}
{"text":"If any string is found","code":"if ( len ( res ) ) : NEW_LINE"}
{"text":"Print those strings","code":"for i in range ( len ( res ) ) : NEW_LINE INDENT for j in range ( len ( res [ i ] ) ) : NEW_LINE INDENT print ( res [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT print ( - 1 , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" ] NEW_LINE B = [ \" geek \" , \" ee \" ] NEW_LINE UniversalSubset ( A , B ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to find the minimum distance pair where one is the multiple of the other","code":"def findPair ( a , n ) : NEW_LINE"}
{"text":"Initialize the variables","code":"min_dist = sys . maxsize NEW_LINE index_a = - 1 NEW_LINE index_b = - 1 NEW_LINE"}
{"text":"Iterate for all the elements","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Loop to make pairs","code":"for j in range ( i + 1 , n ) : NEW_LINE"}
{"text":"Check for minimum distance","code":"if ( j - i < min_dist ) : NEW_LINE"}
{"text":"Check if one is a multiple of other","code":"if ( ( a [ i ] % a [ j ] == 0 ) or ( a [ j ] % a [ i ] == 0 ) ) : NEW_LINE"}
{"text":"Update the distance","code":"min_dist = j - i NEW_LINE"}
{"text":"Store indexes","code":"index_a = i NEW_LINE index_b = j NEW_LINE"}
{"text":"If no such pair exists","code":"if ( index_a == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"}
{"text":"Print the answer","code":"else : NEW_LINE INDENT print ( \" ( \" , a [ index_a ] , \" , \u2581 \" , a [ index_b ] , \" ) \" ) NEW_LINE DEDENT"}
{"text":"Given array arr [ ]","code":"a = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE"}
{"text":"Function call","code":"findPair ( a , n ) NEW_LINE"}
{"text":"Function to print all numbers in the range [ L , R ] having digits in strictly increasing order","code":"def printNum ( L , R ) : NEW_LINE"}
{"text":"Iterate over the range","code":"for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE DEDENT"}
{"text":"Iterate over the digits","code":"while ( temp > 0 ) : NEW_LINE"}
{"text":"Check if the current digit is >= the previous digit","code":"if ( temp % 10 >= c ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp \/\/= 10 NEW_LINE"}
{"text":"If the digits are in ascending order","code":"if ( flag == 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Given range L and R","code":"L = 10 NEW_LINE R = 15 NEW_LINE"}
{"text":"Function call","code":"printNum ( L , R ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to find the missing element","code":"def findMissing ( arr , left , right , diff ) : NEW_LINE"}
{"text":"Fix left and right boundary for binary search","code":"if ( right <= left ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT"}
{"text":"Find index of middle element","code":"mid = left + ( right - left ) \/\/ 2 NEW_LINE"}
{"text":"Check if the element just after the middle element is missing","code":"if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) NEW_LINE DEDENT"}
{"text":"Check if the element just before mid is missing","code":"if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) NEW_LINE DEDENT"}
{"text":"Check if the elements till mid follow the AP , then recur for right half","code":"if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissing ( arr , mid + 1 , right , diff ) NEW_LINE DEDENT"}
{"text":"Else recur for left half","code":"return findMissing ( arr , left , mid - 1 , diff ) NEW_LINE"}
{"text":"Function to find the missing element in AP series","code":"def missingElement ( arr , n ) : NEW_LINE"}
{"text":"Sort the array arr [ ]","code":"arr . sort ( ) NEW_LINE"}
{"text":"Calculate Common Difference","code":"diff = ( arr [ n - 1 ] - arr [ 0 ] ) \/\/ n NEW_LINE"}
{"text":"Binary search for the missing","code":"return findMissing ( arr , 0 , n - 1 , diff ) NEW_LINE"}
{"text":"Given array arr [ ]","code":"arr = [ 2 , 8 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE"}
{"text":"Function call","code":"print ( missingElement ( arr , n ) ) NEW_LINE"}
{"text":"Function to calculate x raised to the power y in O ( logn )","code":"def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = power ( x , y \/\/ 2 ) ; NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp ; NEW_LINE DEDENT DEDENT"}
{"text":"Function to find the Kth root of the number N using BS","code":"def nthRootSearch ( low , high , N , K ) : NEW_LINE"}
{"text":"If the range is still valid","code":"if ( low <= high ) : NEW_LINE"}
{"text":"Find the mid - value of range","code":"mid = ( low + high ) \/\/ 2 ; NEW_LINE"}
{"text":"Base Case","code":"if ( ( power ( mid , K ) <= N ) and ( power ( mid + 1 , K ) > N ) ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT"}
{"text":"Condition to check if the left search space is useless","code":"elif ( power ( mid , K ) < N ) : NEW_LINE INDENT return nthRootSearch ( mid + 1 , high , N , K ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return nthRootSearch ( low , mid - 1 , N , K ) ; NEW_LINE DEDENT return low ; NEW_LINE"}
{"text":"Given N and K","code":"N = 16 ; K = 4 ; NEW_LINE"}
{"text":"Function Call","code":"print ( nthRootSearch ( 0 , N , N , K ) ) NEW_LINE"}
{"text":"Function that return the count of subset such that min ( S ) + max ( S ) < K","code":"def get_subset_count ( arr , K , N ) : NEW_LINE"}
{"text":"Sorting the array","code":"arr . sort ( ) NEW_LINE left = 0 ; NEW_LINE right = N - 1 ; NEW_LINE"}
{"text":"ans stores total number of subsets","code":"ans = 0 ; NEW_LINE while ( left <= right ) : NEW_LINE INDENT if ( arr [ left ] + arr [ right ] < K ) : NEW_LINE DEDENT"}
{"text":"Add all possible subsets between i and j","code":"ans += 1 << ( right - left ) ; NEW_LINE left += 1 ; NEW_LINE else : NEW_LINE"}
{"text":"Decrease the sum","code":"right -= 1 ; NEW_LINE return ans ; NEW_LINE"}
{"text":"Driver code","code":"arr = [ 2 , 4 , 5 , 7 ] ; NEW_LINE K = 8 ; NEW_LINE print ( get_subset_count ( arr , K , 4 ) ) NEW_LINE"}
{"text":"Python3 program to find the minimum of maximum difference between adjacent elements after at most K insertions","code":"def minMaxDiff ( arr , n , k ) : NEW_LINE INDENT max_adj_dif = float ( ' - inf ' ) ; NEW_LINE DEDENT"}
{"text":"Calculate the maximum adjacent difference","code":"for i in range ( n - 1 ) : NEW_LINE INDENT max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; NEW_LINE DEDENT"}
{"text":"If the maximum adjacent difference is already zero","code":"if ( max_adj_dif == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"best and worst specifies range of the maximum adjacent difference","code":"best = 1 ; NEW_LINE worst = max_adj_dif ; NEW_LINE while ( best < worst ) : NEW_LINE INDENT mid = ( best + worst ) \/\/ 2 ; NEW_LINE DEDENT"}
{"text":"To store the no of insertions required for respective values of mid","code":"required = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) \/\/ mid NEW_LINE DEDENT"}
{"text":"If the number of insertions required exceeds K","code":"if ( required > k ) : NEW_LINE INDENT best = mid + 1 ; NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT worst = mid NEW_LINE DEDENT return worst NEW_LINE"}
{"text":"Driver code","code":"arr = [ 3 , 12 , 25 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( minMaxDiff ( arr , n , k ) ) NEW_LINE"}
{"text":"Python3 implementation to Check if the minimum element in the array is greater than or equal to half of every other element","code":"import math NEW_LINE"}
{"text":"Function to Check if the minimum element in the array is greater than or equal to half of every other element","code":"def checkMin ( arr , n ) : NEW_LINE"}
{"text":"Initialise the variables to store smallest and second smallest","code":"smallest = math . inf NEW_LINE secondSmallest = math . inf NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Check if current element is smaller than smallest , the current smallest will become secondSmallest and current element will be the new smallest","code":"if ( arr [ i ] < smallest ) : NEW_LINE INDENT secondSmallest = smallest NEW_LINE smallest = arr [ i ] NEW_LINE DEDENT"}
{"text":"Check if current element is smaller than secondSmallest simply update the latter","code":"elif ( arr [ i ] < secondSmallest ) : NEW_LINE INDENT secondSmallest = arr [ i ] NEW_LINE DEDENT if ( 2 * smallest <= secondSmallest ) : NEW_LINE print ( \" Yes \" ) NEW_LINE else : NEW_LINE print ( \" No \" ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE checkMin ( arr , n ) NEW_LINE DEDENT"}
{"text":"Python 3 program to find minimum and maximum fibonacci number in given array","code":"import sys NEW_LINE"}
{"text":"Function to create hash table to check Fibonacci numbers","code":"def createHash ( hash , maxElement ) : NEW_LINE"}
{"text":"Insert initial two numbers in the hash table","code":"prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE"}
{"text":"Sum of previous two numbers","code":"temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE"}
{"text":"Update the variable each time","code":"prev = curr NEW_LINE curr = temp NEW_LINE"}
{"text":"Function to find minimum and maximum fibonacci number in given array","code":"def fibonacci ( arr , n ) : NEW_LINE"}
{"text":"Find maximum value in the array","code":"max_val = max ( arr ) NEW_LINE"}
{"text":"Creating a set containing all Fibonacci numbers up to maximum value in the array","code":"hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE"}
{"text":"For storing the Minimum and Maximum Fibonacci number","code":"minimum = sys . maxsize NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Check if current element is a fibonacci number","code":"if ( arr [ i ] in hash ) : NEW_LINE"}
{"text":"Update the maximum and minimum accordingly","code":"minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE print ( minimum , end = \" , \u2581 \" ) NEW_LINE print ( maximum ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"}
{"text":"Function that returns True if there is a sub of length len with <= k unique characters","code":"def isValidLen ( s , lenn , k ) : NEW_LINE"}
{"text":"Size of the","code":"n = len ( s ) NEW_LINE"}
{"text":"Map to store the characters and their frequency","code":"mp = dict ( ) NEW_LINE right = 0 NEW_LINE"}
{"text":"Update the map for the first sub","code":"while ( right < lenn ) : NEW_LINE INDENT mp [ s [ right ] ] = mp . get ( s [ right ] , 0 ) + 1 NEW_LINE right += 1 NEW_LINE DEDENT if ( len ( mp ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"Check for the rest of the subs","code":"while ( right < n ) : NEW_LINE"}
{"text":"Add the new character","code":"mp [ s [ right ] ] = mp . get ( s [ right ] , 0 ) + 1 NEW_LINE"}
{"text":"Remove the first character of the previous window","code":"mp [ s [ right - lenn ] ] -= 1 NEW_LINE"}
{"text":"Update the map","code":"if ( mp [ s [ right - lenn ] ] == 0 ) : NEW_LINE INDENT del mp [ s [ right - lenn ] ] NEW_LINE DEDENT if ( len ( mp ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE return len ( mp ) <= k NEW_LINE"}
{"text":"Function to return the length of the longest sub which has K unique characters","code":"def maxLenSubStr ( s , k ) : NEW_LINE"}
{"text":"Check if the complete contains K unique characters","code":"uni = dict ( ) NEW_LINE for x in s : NEW_LINE INDENT uni [ x ] = 1 NEW_LINE DEDENT if ( len ( uni ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Size of the","code":"n = len ( s ) NEW_LINE"}
{"text":"Apply binary search","code":"lo = - 1 NEW_LINE hi = n + 1 NEW_LINE while ( hi - lo > 1 ) : NEW_LINE INDENT mid = lo + hi >> 1 NEW_LINE if ( isValidLen ( s , mid , k ) ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT DEDENT return lo NEW_LINE"}
{"text":"Driver code","code":"s = \" aabacbebebe \" NEW_LINE k = 3 NEW_LINE print ( maxLenSubStr ( s , k ) ) NEW_LINE"}
{"text":"Function that returns true if it is possible to make a square with side equal to l","code":"def isSquarePossible ( arr , n , l ) : NEW_LINE"}
{"text":"To store the count of elements greater than or equal to l","code":"cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Increment the count","code":"if arr [ i ] >= l : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT"}
{"text":"If the count becomes greater than or equal to l","code":"if cnt >= l : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE"}
{"text":"Function to return the maximum area of the square that can be obtained","code":"def maxArea ( arr , n ) : NEW_LINE INDENT l , r = 0 , n NEW_LINE len = 0 NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( ( r - l ) \/\/ 2 ) NEW_LINE DEDENT DEDENT"}
{"text":"If square is possible with side length m","code":"if isSquarePossible ( arr , n , m ) : NEW_LINE INDENT len = m NEW_LINE l = m + 1 NEW_LINE DEDENT"}
{"text":"Try to find a square with smaller side length","code":"else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT"}
{"text":"Return the area","code":"return ( len * len ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 3 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxArea ( arr , n ) ) NEW_LINE"}
{"text":"Function to insert the names and check whether they appear for the first time","code":"def insertNames ( arr , n ) : NEW_LINE"}
{"text":"To store the names of the employees","code":"string = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"If current name is appearing for the first time","code":"if arr [ i ] not in string : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE string . add ( arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" for \" , \" geeks \" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE insertNames ( arr , n ) ; NEW_LINE DEDENT"}
{"text":"Function to return the count of elements in arr [ ] which are less than the given key","code":"def countLessThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE DEDENT"}
{"text":"Modified binary search","code":"while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 NEW_LINE if ( arr [ m ] < key ) : NEW_LINE INDENT l = m + 1 NEW_LINE index = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ( index + 1 ) NEW_LINE"}
{"text":"Function to return the count of elements in arr [ ] which are greater than the given key","code":"def countGreaterThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE DEDENT"}
{"text":"Modified binary search","code":"while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) \/\/ 2 NEW_LINE if ( arr [ m ] <= key ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE index = m NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n - index ) NEW_LINE"}
{"text":"Function to return the count of the required triplets","code":"def countTriplets ( n , a , b , c ) : NEW_LINE"}
{"text":"Sort all three arrays","code":"a . sort NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE count = 0 NEW_LINE"}
{"text":"Iterate for all the elements of array B","code":"for i in range ( n ) : NEW_LINE INDENT current = b [ i ] NEW_LINE a_index = - 1 NEW_LINE c_index = - 1 NEW_LINE DEDENT"}
{"text":"Count of elements in A [ ] which are less than the chosen element from B [ ]","code":"low = countLessThan ( a , n , current ) NEW_LINE"}
{"text":"Count of elements in C [ ] which are greater than the chosen element from B [ ]","code":"high = countGreaterThan ( c , n , current ) NEW_LINE"}
{"text":"Update the count","code":"count += ( low * high ) NEW_LINE return count NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 5 ] NEW_LINE b = [ 2 , 4 ] NEW_LINE c = [ 3 , 6 ] NEW_LINE size = len ( a ) NEW_LINE print ( countTriplets ( size , a , b , c ) ) NEW_LINE DEDENT"}
{"text":"Python 3 code to calculate the minimum cost to make the given parentheses balanced","code":"def costToBalance ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT"}
{"text":"To store absolute count of balanced and unbalanced parenthesis","code":"ans = 0 NEW_LINE"}
{"text":"o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ')","code":"' NEW_LINE INDENT o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT if ( s [ i ] == ' ) ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( o != c ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = [ 0 for i in range ( len ( s ) ) ] NEW_LINE if ( s [ 0 ] == ' ( ' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE DEDENT if ( a [ 0 ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : s = \" ) ) ) ( ( ( \" NEW_LINE INDENT print ( costToBalance ( s ) ) s = \" ) ) ( ( \" NEW_LINE print ( costToBalance ( s ) ) NEW_LINE DEDENT"}
{"text":"Function to find the middle of three number","code":"def middleOfThree ( a , b , c ) : NEW_LINE"}
{"text":"x is positive if a is greater than b . x is negative if b is greater than a .","code":"x = a - b NEW_LINE"}
{"text":"Similar to x","code":"y = b - c NEW_LINE"}
{"text":"Similar to x and y .","code":"z = a - c NEW_LINE"}
{"text":"Checking if b is middle ( x and y both are positive )","code":"if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT"}
{"text":"Checking if c is middle ( x and z both are positive )","code":"elif ( x * z > 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT"}
{"text":"Driver Code","code":"a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE"}
{"text":"Finds missing 4 numbers in O ( N ) time and O ( 1 ) auxiliary space .","code":"def missing4 ( arr ) : NEW_LINE"}
{"text":"To keep track of 4 possible numbers greater than length of input array In Java , helper is automatically initialized as 0.","code":"helper = [ 0 ] * 4 NEW_LINE"}
{"text":"Traverse the input array and mark visited elements either by marking them as negative in arr [ ] or in helper [ ] .","code":"for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT temp = abs ( arr [ i ] ) NEW_LINE DEDENT"}
{"text":"If element is smaller than or equal to length , mark its presence in arr [ ]","code":"if ( temp <= len ( arr ) ) : NEW_LINE INDENT arr [ temp - 1 ] = arr [ temp - 1 ] * ( - 1 ) NEW_LINE DEDENT"}
{"text":"Mark presence in helper [ ]","code":"elif ( temp > len ( arr ) ) : NEW_LINE INDENT if ( temp % len ( arr ) ) : NEW_LINE INDENT helper [ temp % len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT helper [ ( temp % len ( arr ) ) + len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT DEDENT"}
{"text":"Print all those elements whose presence is not marked .","code":"for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT print ( ( i + 1 ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( helper ) ) : NEW_LINE INDENT if ( helper [ i ] >= 0 ) : NEW_LINE INDENT print ( ( len ( arr ) + i + 1 ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"arr = [ 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 ] NEW_LINE missing4 ( arr ) NEW_LINE"}
{"text":"Function that finds the middle the lexicographical smallest sequence","code":"def lexiMiddleSmallest ( K , N ) : NEW_LINE"}
{"text":"If K is even","code":"if ( K % 2 == 0 ) : NEW_LINE"}
{"text":"First element is K \/ 2","code":"print ( K \/\/ 2 , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Remaining elements of the sequence are all integer K","code":"for i in range ( N - 1 ) : NEW_LINE INDENT print ( K , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE"}
{"text":"Stores the sequence when K is odd","code":"a = [ ( K + 1 ) \/\/ 2 ] * ( N ) NEW_LINE"}
{"text":"Iterate over the range [ 0 , N \/ 2 ]","code":"for i in range ( N \/\/ 2 ) : NEW_LINE"}
{"text":"Check if the sequence ends with in 1 or not","code":"if ( a [ - 1 ] == 1 ) : NEW_LINE"}
{"text":"Remove the sequence ending in 1","code":"del a [ - 1 ] NEW_LINE"}
{"text":"If it doesn 't end in 1","code":"else : NEW_LINE"}
{"text":"Decrement by 1","code":"a [ - 1 ] -= 1 NEW_LINE"}
{"text":"Insert K to the sequence till its size is N","code":"while ( len ( a ) < N ) : NEW_LINE INDENT a . append ( K ) NEW_LINE DEDENT"}
{"text":"Prthe sequence stored in the vector","code":"for i in a : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K , N = 2 , 4 NEW_LINE lexiMiddleSmallest ( K , N ) NEW_LINE DEDENT"}
{"text":"Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0","code":"def findLastElement ( arr , N ) : NEW_LINE"}
{"text":"Sort the given array in ascending order","code":"arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( 1 , N ) : NEW_LINE"}
{"text":"If difference between adjacent elements is not equal to 0 or 2","code":"if ( arr [ i ] - arr [ i - 1 ] != 0 \\ and arr [ i ] - arr [ i - 1 ] != 2 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE DEDENT"}
{"text":"If operations can be performed","code":"print ( arr [ N - 1 ] ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 0 , 8 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE findLastElement ( arr , N ) ; NEW_LINE DEDENT"}
{"text":"Function to count maximum subsets into which the given array can be split such that it satisfies the given condition","code":"def maxDivisions ( arr , N , X ) : NEW_LINE"}
{"text":"Sort the array in decreasing order","code":"arr . sort ( reverse = True ) NEW_LINE"}
{"text":"Stores count of subsets possible","code":"maxSub = 0 ; NEW_LINE"}
{"text":"Stores count of elements in current subset","code":"size = 0 ; NEW_LINE"}
{"text":"Traverse the array arr [ ]","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Update size","code":"size += 1 ; NEW_LINE"}
{"text":"If product of the smallest element present in the current subset and size of current subset is >= K","code":"if ( arr [ i ] * size >= X ) : NEW_LINE"}
{"text":"Update maxSub","code":"maxSub += 1 ; NEW_LINE"}
{"text":"Update size","code":"size = 0 ; NEW_LINE print ( maxSub ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given array","code":"arr = [ 1 , 3 , 3 , 7 ] ; NEW_LINE"}
{"text":"Size of the array","code":"N = len ( arr ) ; NEW_LINE"}
{"text":"Given value of X","code":"X = 3 ; NEW_LINE maxDivisions ( arr , N , X ) ; NEW_LINE"}
{"text":"Function to find maximum possible sum of second minimums in each quadruple","code":"def maxPossibleSum ( arr , N ) : NEW_LINE"}
{"text":"Sort the array","code":"arr . sort ( ) NEW_LINE sum = 0 NEW_LINE j = N - 3 NEW_LINE while ( j >= 0 ) : NEW_LINE"}
{"text":"Add the second minimum","code":"sum += arr [ j ] NEW_LINE j -= 3 NEW_LINE"}
{"text":"Print maximum possible sum","code":"print ( sum ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given array","code":"arr = [ 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 ] NEW_LINE"}
{"text":"Size of the array","code":"N = 8 NEW_LINE maxPossibleSum ( arr , N ) NEW_LINE"}
{"text":"Function to sort an array using insertion sort","code":"def insertionSort ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE key = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE j = i - 1 NEW_LINE DEDENT DEDENT"}
{"text":"Move elements of arr [ 0. . i - 1 ] , that are greater than key to one position ahead of their current position","code":"while ( j >= 0 and arr [ j ] > key ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE"}
{"text":"Function to print an array of size N","code":"def printArray ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT"}
{"text":"Print the array","code":"for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , end \u2581 = \u2581 \" \" ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT"}
{"text":"Function Call","code":"insertionSort ( arr , N ) NEW_LINE printArray ( arr , N ) NEW_LINE"}
{"text":"Function to find the count required pairs","code":"def getPairs ( arr , N , K ) : NEW_LINE"}
{"text":"Stores count of pairs","code":"count = 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE DEDENT"}
{"text":"Check if the condition is satisfied or not","code":"if ( arr [ i ] > K * arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 2 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE DEDENT"}
{"text":"Function Call","code":"getPairs ( arr , N , K ) NEW_LINE"}
{"text":"Function to merge two sorted arrays","code":"def merge ( arr , temp , l , m , r , K ) : NEW_LINE"}
{"text":"i : index to left subarray","code":"i = l NEW_LINE"}
{"text":"j : index to right subarray","code":"j = m + 1 NEW_LINE"}
{"text":"Stores count of pairs that satisfy the given condition","code":"cnt = 0 NEW_LINE for l in range ( m + 1 ) : NEW_LINE INDENT found = False NEW_LINE DEDENT"}
{"text":"Traverse to check for the valid conditions","code":"while ( j <= r ) : NEW_LINE"}
{"text":"If condition satisfies","code":"if ( arr [ i ] >= K * arr [ j ] ) : NEW_LINE INDENT found = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE"}
{"text":"All elements in the right side of the left subarray also satisfies","code":"if ( found ) : NEW_LINE INDENT cnt += j - ( m + 1 ) NEW_LINE j -= 1 NEW_LINE DEDENT"}
{"text":"Sort the two given arrays and store in the resultant array","code":"k = l NEW_LINE i = l NEW_LINE j = m + 1 NEW_LINE while ( i <= m and j <= r ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Elements which are left in the left subarray","code":"while ( i <= m ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT"}
{"text":"Elements which are left in the right subarray","code":"while ( j <= r ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT"}
{"text":"Return the count obtained","code":"return cnt NEW_LINE"}
{"text":"Function to partition array into two halves","code":"def mergeSortUtil ( arr , temp , l , r , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( l < r ) : NEW_LINE DEDENT"}
{"text":"Same as ( l + r ) \/ 2 , but avoids overflow for large l and h","code":"m = ( l + r ) \/\/ 2 NEW_LINE"}
{"text":"Sort first and second halves","code":"cnt += mergeSortUtil ( arr , temp , l , m , K ) NEW_LINE cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) NEW_LINE"}
{"text":"Call the merging function","code":"cnt += merge ( arr , temp , l , m , r , K ) NEW_LINE return cnt NEW_LINE"}
{"text":"Function to print the count of required pairs using Merge Sort","code":"def mergeSort ( arr , N , K ) : NEW_LINE INDENT temp = [ 0 ] * N NEW_LINE print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"arr = [ 5 , 6 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE"}
{"text":"Function Call","code":"mergeSort ( arr , N , K ) NEW_LINE"}
{"text":"Function to count minimum consecutive removals of elements of the same type","code":"def minRemovals ( A , N ) : NEW_LINE"}
{"text":"Sort the array","code":"A . sort ( ) NEW_LINE"}
{"text":"Stores the maximum element present in the array","code":"mx = A [ N - 1 ] NEW_LINE"}
{"text":"stores the sum of array","code":"sum = 1 NEW_LINE"}
{"text":"Calculate sum of array","code":"for i in range ( 0 , N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT if ( ( sum - mx ) >= mx ) : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * mx - sum , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 3 , 2 ] NEW_LINE N = len ( A ) NEW_LINE DEDENT"}
{"text":"Function call","code":"minRemovals ( A , N ) NEW_LINE"}
{"text":"Function to rearrange the array a [ ] such that none of the array elements is same as its index","code":"def rearrangeArray ( a , n ) : NEW_LINE"}
{"text":"Sort the array","code":"a = sorted ( a ) NEW_LINE"}
{"text":"Traverse the indices [ 0 , N - 2 ] of the given array","code":"for i in range ( n - 1 ) : NEW_LINE"}
{"text":"Check if the current element is equal to its index","code":"if ( a [ i ] == i + 1 ) : NEW_LINE"}
{"text":"If found to be true , swap current element with the next element","code":"a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE"}
{"text":"Check if the last element is same as its index","code":"if ( a [ n - 1 ] == n ) : NEW_LINE"}
{"text":"If found to be true , swap current element with the previous element","code":"a [ n - 1 ] , a [ n - 2 ] = a [ n - 2 ] , a [ n - 1 ] NEW_LINE"}
{"text":"Prthe modified array","code":"for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT"}
{"text":"Function Call","code":"rearrangeArray ( arr , N ) NEW_LINE"}
{"text":"Function that counts the minimum moves required to covert arr [ ] to brr [ ]","code":"def minOperations ( arr1 , arr2 , i , j ) : NEW_LINE"}
{"text":"Base Case","code":"if arr1 == arr2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= len ( arr1 ) or j >= len ( arr2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"If arr [ i ] < arr [ j ]","code":"if arr1 [ i ] < arr2 [ j ] : NEW_LINE"}
{"text":"Include the current element","code":"return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 ) NEW_LINE"}
{"text":"Otherwise , excluding the current element","code":"return max ( minOperations ( arr1 , arr2 , i , j + 1 ) , minOperations ( arr1 , arr2 , i + 1 , j ) ) NEW_LINE"}
{"text":"Function that counts the minimum moves required to sort the array","code":"def minOperationsUtil ( arr ) : NEW_LINE INDENT brr = sorted ( arr ) ; NEW_LINE DEDENT"}
{"text":"If both the arrays are equal","code":"if ( arr == brr ) : NEW_LINE"}
{"text":"No moves required","code":"print ( \"0\" ) NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Print minimum operations required","code":"print ( minOperations ( arr , brr , 0 , 0 ) ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 4 , 7 , 2 , 3 , 9 ] NEW_LINE minOperationsUtil ( arr ) NEW_LINE"}
{"text":"Function to check if str1 can be transformed to t by sorting substrings","code":"def canTransform ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT"}
{"text":"Occur [ i ] stores the indices of ( ' a ' + i ) in string s","code":"occur = [ [ ] for i in range ( 26 ) ] NEW_LINE for x in range ( n ) : NEW_LINE INDENT ch = ord ( s [ x ] ) - ord ( ' a ' ) NEW_LINE occur [ ch ] . append ( x ) NEW_LINE DEDENT"}
{"text":"idx [ i ] stores the next available index of ( ' a ' + i ) in occur [ i ]","code":"idx = [ 0 ] * ( 26 ) NEW_LINE poss = True NEW_LINE for x in range ( n ) : NEW_LINE INDENT ch = ord ( t [ x ] ) - ord ( ' a ' ) NEW_LINE DEDENT"}
{"text":"If this is not available anymore","code":"if ( idx [ ch ] >= len ( occur [ ch ] ) ) : NEW_LINE"}
{"text":"Conversion not possible","code":"poss = False NEW_LINE break NEW_LINE for small in range ( ch ) : NEW_LINE"}
{"text":"If one of the smaller characters is available and occurs before","code":"if ( idx [ small ] < len ( occur [ small ] ) and occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) : NEW_LINE"}
{"text":"Conversion not possible","code":"poss = False NEW_LINE break NEW_LINE idx [ ch ] += 1 NEW_LINE"}
{"text":"Print the answer","code":"if ( poss ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hdecb \" NEW_LINE t = \" cdheb \" NEW_LINE canTransform ( s , t ) NEW_LINE DEDENT"}
{"text":"function to count inversion count of the string","code":"def inversionCount ( s ) : NEW_LINE"}
{"text":"for storing frequency","code":"freq = [ 0 for _ in range ( 26 ) ] NEW_LINE inv = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"we 'll add all the characters  which are less than the ith  character before i.","code":"temp = 0 NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( ' a ' ) ) : NEW_LINE"}
{"text":"adding the count to inversion count","code":"temp += freq [ j ] NEW_LINE inv += ( i - temp ) NEW_LINE"}
{"text":"updating the character in the frequency array","code":"freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE return inv NEW_LINE"}
{"text":"function to check whether any of the string have a repeated character","code":"def haveRepeated ( S1 , S2 ) : NEW_LINE INDENT freq = [ 0 for _ in range ( 26 ) ] NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE INDENT if freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( S2 ) ) : NEW_LINE INDENT if freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT"}
{"text":"function to check whether the string S1 and S2 can be made equal by reversing sub strings ofsame size in both strings","code":"def checkToMakeEqual ( S1 , S2 ) : NEW_LINE"}
{"text":"frequency array to check whether both string have same character or not","code":"freq = [ 0 for _ in range ( 26 ) ] NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE"}
{"text":"adding the frequency ;","code":"freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE flag = 0 NEW_LINE for i in range ( len ( S2 ) ) : NEW_LINE if freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE"}
{"text":"if the character is not in S1","code":"flag = 1 NEW_LINE break NEW_LINE"}
{"text":"decrementing the frequency","code":"freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if flag == 1 : NEW_LINE"}
{"text":"If both string does not have same characters or not","code":"print ( \" No \" ) NEW_LINE return NEW_LINE"}
{"text":"finding inversion count of both strings","code":"invCount1 = inversionCount ( S1 ) NEW_LINE invCount2 = inversionCount ( S2 ) NEW_LINE if ( ( invCount1 == invCount2 ) or ( ( invCount1 % 2 ) == ( invCount2 % 2 ) ) or haveRepeated ( S1 , S2 ) == 1 ) : NEW_LINE"}
{"text":"If inversion count is same , or have same parity or if any of the string have a repeated character then the answer is Yes else No","code":"print ( \" Yes \" ) NEW_LINE else : NEW_LINE print ( \" No \" ) NEW_LINE"}
{"text":"Driver Code","code":"S1 = \" abbca \" NEW_LINE S2 = \" acabb \" NEW_LINE checkToMakeEqual ( S1 , S2 ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to sort bitonic array in constant space","code":"def sortArr ( a , n ) : NEW_LINE"}
{"text":"Initialize thevalue of k","code":"k = int ( math . log ( n , 2 ) ) NEW_LINE k = int ( pow ( 2 , k ) ) NEW_LINE"}
{"text":"In each iteration compare elements k distance apart and swap it they are not in order","code":"while ( k > 0 ) : NEW_LINE INDENT i = 0 NEW_LINE while i + k < n : NEW_LINE INDENT if a [ i ] > a [ i + k ] : NEW_LINE INDENT a [ i ] , a [ i + k ] = a [ i + k ] , a [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT"}
{"text":"k is reduced to half after every iteration","code":"k = k \/\/ 2 NEW_LINE"}
{"text":"Print the array elements","code":"for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Given array","code":"a = [ 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 ] NEW_LINE n = len ( a ) NEW_LINE"}
{"text":"Function call","code":"sortArr ( a , n ) NEW_LINE"}
{"text":"Function that prints the maximum sum possible","code":"def maximumSum ( arr , n , k ) : NEW_LINE"}
{"text":"Find elements in each group","code":"elt = n \/\/ k ; NEW_LINE sum = 0 ; NEW_LINE"}
{"text":"Sort all elements in non - descending order","code":"arr . sort ( ) ; NEW_LINE count = 0 ; NEW_LINE i = n - 1 ; NEW_LINE"}
{"text":"Add K largest elements","code":"while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE i -= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE"}
{"text":"For sum of minimum elements from each subset","code":"while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE i += elt - 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT"}
{"text":"Printing the maximum sum","code":"print ( sum ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Arr = [ 1 , 13 , 7 , 17 , 6 , 5 ] ; NEW_LINE K = 2 ; NEW_LINE size = len ( Arr ) ; NEW_LINE maximumSum ( Arr , size , K ) ; NEW_LINE DEDENT"}
{"text":"Function to find the minimum sum","code":"def findMinSum ( arr , K , L , size ) : NEW_LINE INDENT if ( K * L > size ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minsum = 0 NEW_LINE DEDENT"}
{"text":"Sort the array","code":"arr . sort ( ) NEW_LINE"}
{"text":"Calculate sum of smallest K elements","code":"for i in range ( K ) : NEW_LINE INDENT minsum += arr [ i ] NEW_LINE DEDENT"}
{"text":"Return the sum","code":"return minsum NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 ] NEW_LINE K = 3 NEW_LINE L = 2 NEW_LINE length = len ( arr ) NEW_LINE print ( findMinSum ( arr , K , L , length ) ) NEW_LINE DEDENT"}
{"text":"Function to find the Kth smallest element in Unsorted Array","code":"def findKthSmallest ( arr , n , k ) : NEW_LINE"}
{"text":"Initialize the max Element as 0","code":"max = 0 NEW_LINE"}
{"text":"Iterate arr [ ] and find the maximum element in it","code":"for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Frequency array to store the frequencies","code":"counter = [ 0 ] * ( max + 1 ) NEW_LINE"}
{"text":"Counter variable","code":"smallest = 0 NEW_LINE"}
{"text":"Counting the frequencies","code":"for i in range ( n ) : NEW_LINE INDENT counter [ arr [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"Iterate through the freq [ ]","code":"for num in range ( 1 , max + 1 ) : NEW_LINE"}
{"text":"Check if num is present in the array","code":"if ( counter [ num ] > 0 ) : NEW_LINE"}
{"text":"Increment the counter with the frequency of num","code":"smallest += counter [ num ] NEW_LINE"}
{"text":"Checking if we have reached the Kth smallest element","code":"if ( smallest >= k ) : NEW_LINE"}
{"text":"Return the Kth smallest element","code":"return num NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given array","code":"arr = [ 7 , 1 , 4 , 4 , 20 , 15 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 5 NEW_LINE"}
{"text":"Function Call","code":"print ( findKthSmallest ( arr , N , K ) ) NEW_LINE"}
{"text":"Function to print all the numbers up to n in lexicographical order","code":"def lexNumbers ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s . append ( str ( i ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( int ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 NEW_LINE lexNumbers ( n ) NEW_LINE DEDENT"}
{"text":"Python3 implementation to print row of matrix in ascending or descending order alternatively","code":"N = 4 NEW_LINE def func ( a ) : NEW_LINE"}
{"text":"Iterate matrix rowwise","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Sort even rows in ascending order","code":"if i % 2 == 0 : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE DEDENT DEDENT"}
{"text":"Compare adjacent elements","code":"if a [ i ] [ j ] > a [ i ] [ k ] : NEW_LINE"}
{"text":"Swap adjacent element","code":"temp = a [ i ] [ j ] NEW_LINE a [ i ] [ j ] = a [ i ] [ k ] NEW_LINE a [ i ] [ k ] = temp NEW_LINE"}
{"text":"Sort even rows in descending order","code":"else : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE DEDENT DEDENT"}
{"text":"Compare adjacent elements","code":"if a [ i ] [ j ] < a [ i ] [ k ] : NEW_LINE"}
{"text":"Swap adjacent element","code":"temp = a [ i ] [ j ] NEW_LINE a [ i ] [ j ] = a [ i ] [ k ] NEW_LINE a [ i ] [ k ] = temp NEW_LINE"}
{"text":"Printing the final output","code":"for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ [ 5 , 7 , 3 , 4 ] , [ 9 , 5 , 8 , 2 ] , [ 6 , 3 , 8 , 1 ] , [ 5 , 8 , 9 , 3 ] ] NEW_LINE func ( a ) NEW_LINE DEDENT"}
{"text":"To store the edges of the given graph","code":"g = [ dict ( ) for i in range ( 200005 ) ] NEW_LINE s = set ( ) NEW_LINE ns = set ( ) NEW_LINE"}
{"text":"A utility function to perform DFS Traversal","code":"def dfs ( x ) : NEW_LINE INDENT global s , g , ns NEW_LINE v = [ ] NEW_LINE v . clear ( ) ; NEW_LINE ns . clear ( ) ; NEW_LINE DEDENT"}
{"text":"Check those vertices which are stored in the set","code":"for it in s : NEW_LINE"}
{"text":"Vertices are included if the weight of edge is 0","code":"if ( x in g and not g [ x ] [ it ] ) : NEW_LINE INDENT v . append ( it ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ns . add ( it ) ; NEW_LINE DEDENT s = ns ; NEW_LINE for i in v : NEW_LINE dfs ( i ) ; NEW_LINE"}
{"text":"A utility function to find the weight of Minimum Spanning Tree","code":"def weightOfMST ( N ) : NEW_LINE"}
{"text":"To count the connected components","code":"cnt = 0 ; NEW_LINE"}
{"text":"Inserting the initial vertices in the set","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s . add ( i ) ; NEW_LINE DEDENT"}
{"text":"Traversing vertices stored in the set and Run DFS Traversal for each vertices","code":"while ( len ( s ) != 0 ) : NEW_LINE"}
{"text":"Incrementing the zero weight connected components","code":"cnt += 1 NEW_LINE t = list ( s ) [ 0 ] NEW_LINE s . discard ( t ) ; NEW_LINE"}
{"text":"DFS Traversal for every vertex remove","code":"dfs ( t ) ; NEW_LINE print ( cnt ) NEW_LINE"}
{"text":"Driver 's Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE M = 11 ; NEW_LINE edges = [ [ 1 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 1 , 6 ] , [ 2 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 4 ] , [ 3 , 5 ] , [ 3 , 6 ] ] ; NEW_LINE DEDENT"}
{"text":"Insert edges","code":"for i in range ( M ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] ; NEW_LINE v = edges [ i ] [ 1 ] ; NEW_LINE g [ u ] [ v ] = 1 ; NEW_LINE g [ v ] [ u ] = 1 ; NEW_LINE DEDENT"}
{"text":"Function call find the weight of Minimum Spanning Tree","code":"weightOfMST ( N ) ; NEW_LINE"}
{"text":"Function to return the count of pairs","code":"def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 30 , 28 , 45 , 22 ] NEW_LINE B = [ 35 , 25 , 22 , 48 ] NEW_LINE print ( countPairs ( A , B ) ) NEW_LINE DEDENT"}
{"text":"Function to return the maximum mod value for any pair from the array","code":"def maxMod ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) NEW_LINE secondMax = 0 NEW_LINE DEDENT"}
{"text":"Find the second maximum element from the array","code":"for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < maxVal and arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return secondMax NEW_LINE"}
{"text":"Driver code","code":"arr = [ 2 , 4 , 1 , 5 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxMod ( arr , n ) ) NEW_LINE"}
{"text":"Function to that returns true if it possible to choose the elements","code":"def isPossible ( A , B , n , m , x , y ) : NEW_LINE"}
{"text":"If elements can 't be chosen","code":"if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Sort both the arrays","code":"A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE"}
{"text":"If xth smallest element of A [ ] is smaller than the yth greatest element of B [ ]","code":"if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = [ 2 , 2 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE if ( isPossible ( A , B , n , m , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python 3 program to minimum changes required in an array for k distinct elements .","code":"MAX = 100005 NEW_LINE"}
{"text":"Function to minimum changes required in an array for k distinct elements .","code":"def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE DEDENT"}
{"text":"Store the frequency of each element","code":"freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE"}
{"text":"Store the frequency of elements","code":"for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Sort frequencies in descending order","code":"freq . sort ( reverse = True ) NEW_LINE"}
{"text":"To store the required answer","code":"ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT"}
{"text":"Return the required answer","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"}
{"text":"Function to find maximum number of elements without overlapping in a line","code":"def Segment ( x , l , n ) : NEW_LINE"}
{"text":"If n = 1 , then answer is one","code":"if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"We can always make 1 st element to cover left segment and nth the right segment","code":"ans = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE"}
{"text":"If left segment for ith element doesnt overlap with i - 1 th element then do left","code":"if ( x [ i ] - l [ i ] > x [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT"}
{"text":"else try towards right if possible","code":"elif ( x [ i ] + l [ i ] < x [ i + 1 ] ) : NEW_LINE"}
{"text":"update x [ i ] to right endpoof segment covered by it","code":"x [ i ] = x [ i ] + l [ i ] NEW_LINE ans += 1 NEW_LINE"}
{"text":"Return the required answer","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"x = [ 1 , 3 , 4 , 5 , 8 ] NEW_LINE l = [ 10 , 1 , 2 , 2 , 5 ] NEW_LINE n = len ( x ) NEW_LINE"}
{"text":"Function call","code":"print ( Segment ( x , l , n ) ) NEW_LINE"}
{"text":"Function to find the minimized sum","code":"def MinimizeleftOverSum ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"If more odd elements","code":"if ( len ( v1 ) > len ( v2 ) ) : NEW_LINE"}
{"text":"Sort the elements","code":"v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE"}
{"text":"Left - over elements","code":"x = len ( v1 ) - len ( v2 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE"}
{"text":"Find the sum of leftover elements","code":"while ( i < x ) : NEW_LINE INDENT sum += v1 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT"}
{"text":"Return the sum","code":"return sum ; NEW_LINE"}
{"text":"If more even elements","code":"elif ( len ( v2 ) > len ( v1 ) ) : NEW_LINE"}
{"text":"Sort the elements","code":"v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE"}
{"text":"Left - over elements","code":"x = len ( v2 ) - len ( v1 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE"}
{"text":"Find the sum of leftover elements","code":"while ( i < x ) : NEW_LINE INDENT sum += v2 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT"}
{"text":"Return the sum","code":"return sum ; NEW_LINE"}
{"text":"If same elements","code":"else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 2 , 2 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinimizeleftOverSum ( a , n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to find the minimum number of operations to convert the given string","code":"def minOperation ( S , N , K ) : NEW_LINE"}
{"text":"Check if N is divisible by K","code":"if N % K : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Array to store frequency of characters in given string","code":"count = [ 0 ] * 26 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT count [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT E = N \/\/ K NEW_LINE greaterE = [ ] NEW_LINE lessE = [ ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE"}
{"text":"Two arrays with number of operations required","code":"if count [ i ] < E : NEW_LINE INDENT lessE . append ( E - count [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT greaterE . append ( count [ i ] - E ) NEW_LINE DEDENT greaterE . sort ( ) NEW_LINE lessE . sort ( ) NEW_LINE mi = float ( ' inf ' ) NEW_LINE for i in range ( 0 , K + 1 ) : NEW_LINE"}
{"text":"Checking for all possibility","code":"set1 , set2 = i , K - i NEW_LINE if ( len ( greaterE ) >= set1 and len ( lessE ) >= set2 ) : NEW_LINE INDENT step1 , step2 = 0 , 0 NEW_LINE for j in range ( 0 , set1 ) : NEW_LINE INDENT step1 += greaterE [ j ] NEW_LINE DEDENT for j in range ( 0 , set2 ) : NEW_LINE INDENT step2 += lessE [ j ] NEW_LINE DEDENT mi = min ( mi , max ( step1 , step2 ) ) NEW_LINE DEDENT print ( mi ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" accb \" NEW_LINE N = len ( S ) NEW_LINE K = 2 NEW_LINE minOperation ( S , N , K ) NEW_LINE DEDENT"}
{"text":"Function to find minimum range increments to sort an array","code":"def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT"}
{"text":"If current element is found greater than last element Increment all terms in range i + 1 to n - 1","code":"if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT"}
{"text":"mn = arr [ i ] Minimum in range i to n - 1","code":"return moves NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMovesToSort ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of the approach","code":"def SieveOfEratosthenes ( n ) : NEW_LINE"}
{"text":"false here indicates that it is not prime","code":"prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if prime [ p ] : NEW_LINE"}
{"text":"Update all multiples of p , set them to non - prime","code":"for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"Function that sorts all the prime numbers from the array in descending","code":"def sortPrimes ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE DEDENT"}
{"text":"This vector will contain prime numbers to sort","code":"v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE"}
{"text":"If the element is prime","code":"if prime [ arr [ i ] ] : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT v . sort ( reverse = True ) NEW_LINE j = 0 NEW_LINE"}
{"text":"update the array elements","code":"for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT arr [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 6 , 100 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE prime = [ True ] * 100006 NEW_LINE arr = sortPrimes ( arr , n ) NEW_LINE DEDENT"}
{"text":"print the results .","code":"for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Python 3 Program to divide the array into N pairs such that maximum pair is minimized","code":"def findOptimalPairs ( arr , N ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE DEDENT"}
{"text":"After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element","code":"i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT print ( \" ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 6 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE findOptimalPairs ( arr , N ) NEW_LINE DEDENT"}
{"text":"a utility function that returns total set bits count in an integer","code":"def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT"}
{"text":"Function to simultaneously sort both arrays using insertion sort ( http : quiz . geeksforgeeks . org \/ insertion - sort \/ )","code":"def insertionSort ( arr , aux , n ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE DEDENT"}
{"text":"use 2 keys because we need to sort both arrays simultaneously","code":"key1 = aux [ i ] NEW_LINE key2 = arr [ i ] NEW_LINE j = i - 1 NEW_LINE"}
{"text":"Move elements of arr [ 0. . i - 1 ] and aux [ 0. . i - 1 ] , such that elements of aux [ 0. . i - 1 ] are greater than key1 , to one position ahead of their current position","code":"while ( j >= 0 and aux [ j ] < key1 ) : NEW_LINE INDENT aux [ j + 1 ] = aux [ j ] NEW_LINE arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT aux [ j + 1 ] = key1 NEW_LINE arr [ j + 1 ] = key2 NEW_LINE"}
{"text":"Function to sort according to bit count using an auxiliary array","code":"def sortBySetBitCount ( arr , n ) : NEW_LINE"}
{"text":"Create an array and store count of set bits in it .","code":"aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT aux [ i ] = countBits ( arr [ i ] ) NEW_LINE DEDENT"}
{"text":"Sort arr [ ] according to values in aux [ ]","code":"insertionSort ( arr , aux , n ) NEW_LINE"}
{"text":"Utility function to print an array","code":"def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE DEDENT"}
{"text":"a utility function that returns total set bits count in an integer","code":"def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT"}
{"text":"Function to sort according to bit count This function assumes that there are 32 bits in an integer .","code":"def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT count = [ [ ] for i in range ( 32 ) ] NEW_LINE setbitcount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT setbitcount = countBits ( arr [ i ] ) NEW_LINE count [ setbitcount ] . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Traverse through all bit counts ( Note that we sort array in decreasing order )","code":"for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT v1 = count [ i ] NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT arr [ j ] = v1 [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Utility function to pran array","code":"def printArr ( arr , n ) : NEW_LINE INDENT print ( * arr ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE"}
{"text":"Function to find lexicographically smallest string having number of 1 s greater than number of 0 s","code":"def generateString ( k1 , k2 , s ) : NEW_LINE"}
{"text":"C1s And C0s stores the count of 1 s and 0 s at every position","code":"s = list ( s ) NEW_LINE C1s = 0 NEW_LINE C0s = 0 NEW_LINE flag = 0 NEW_LINE pos = [ ] NEW_LINE"}
{"text":"Traverse the string S","code":"for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT C0s += 1 NEW_LINE DEDENT DEDENT"}
{"text":"If the position is not divisible by k1 and k2","code":"if ( ( i + 1 ) % k1 != 0 and ( i + 1 ) % k2 != 0 ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT else : NEW_LINE C1s += 1 NEW_LINE if ( C0s >= C1s ) : NEW_LINE"}
{"text":"If C0s >= C1s and pos [ ] is empty then the string can 't  be formed","code":"if ( len ( pos ) == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT"}
{"text":"If pos [ ] is not empty then flip the bit of last position present in pos [ ]","code":"else : NEW_LINE INDENT k = pos [ len ( pos ) - 1 ] NEW_LINE s [ k ] = '1' NEW_LINE C0s -= 1 NEW_LINE C1s += 1 NEW_LINE pos = pos [ : - 1 ] NEW_LINE DEDENT"}
{"text":"Print the result","code":"s = ' ' . join ( s ) NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K1 = 2 NEW_LINE K2 = 4 NEW_LINE S = \"11000100\" NEW_LINE generateString ( K1 , K2 , S ) NEW_LINE DEDENT"}
{"text":"python 3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to find the pair ( X , Y ) such that X xor Y = N and the count of set bits in X and Y is less than count of set bit in N","code":"def maximizeProduct ( N ) : NEW_LINE"}
{"text":"Stores MSB ( Most Significant Bit )","code":"MSB = ( int ) ( math . log2 ( N ) ) NEW_LINE"}
{"text":"Stores the value of X","code":"X = 1 << MSB NEW_LINE"}
{"text":"\/ Stores the value of Y","code":"Y = N - ( 1 << MSB ) NEW_LINE"}
{"text":"Traversing over all bits of N","code":"for i in range ( MSB ) : NEW_LINE"}
{"text":"If ith bit of N is 0","code":"if ( not ( N & ( 1 << i ) ) ) : NEW_LINE"}
{"text":"\/ Set ith bit of X to 1","code":"X += 1 << i NEW_LINE"}
{"text":"Set ith bit of Y to 1","code":"Y += 1 << i NEW_LINE"}
{"text":"Print Answer","code":"print ( X , Y ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 45 NEW_LINE maximizeProduct ( N ) NEW_LINE DEDENT"}
{"text":"python 3 program for the above approach","code":"from math import log10 NEW_LINE"}
{"text":"Function to check if the number is valid","code":"def check ( num ) : NEW_LINE"}
{"text":"Sum of digits of num","code":"sm = 0 NEW_LINE"}
{"text":"Squared number","code":"num2 = num * num NEW_LINE while ( num ) : NEW_LINE INDENT sm += num % 10 NEW_LINE num \/\/= 10 NEW_LINE DEDENT"}
{"text":"Sum of digits of ( num * num )","code":"sm2 = 0 NEW_LINE while ( num2 ) : NEW_LINE INDENT sm2 += num2 % 10 NEW_LINE num2 \/\/= 10 NEW_LINE DEDENT return ( ( sm * sm ) == sm2 ) NEW_LINE"}
{"text":"Function to convert a string to an integer","code":"def convert ( s ) : NEW_LINE INDENT val = 0 NEW_LINE s = s [ : : - 1 ] NEW_LINE cur = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val += ( ord ( s [ i ] ) - ord ( '0' ) ) * cur NEW_LINE cur *= 10 NEW_LINE DEDENT return val NEW_LINE DEDENT"}
{"text":"Function to generate all possible strings of length len","code":"def generate ( s , len1 , uniq ) : NEW_LINE"}
{"text":"Desired string","code":"if ( len ( s ) == len1 ) : NEW_LINE"}
{"text":"Take only valid numbers","code":"if ( check ( convert ( s ) ) ) : NEW_LINE INDENT uniq . add ( convert ( s ) ) NEW_LINE DEDENT return NEW_LINE"}
{"text":"Recurse for all possible digits","code":"for i in range ( 4 ) : NEW_LINE INDENT generate ( s + chr ( i + ord ( '0' ) ) , len1 , uniq ) NEW_LINE DEDENT"}
{"text":"Function to calculate unique numbers in range [ L , R ]","code":"def totalNumbers ( L , R ) : NEW_LINE"}
{"text":"Initialize a variable to store the answer","code":"ans = 0 NEW_LINE"}
{"text":"Calculate the maximum possible length","code":"max_len = int ( log10 ( R ) ) + 1 NEW_LINE"}
{"text":"Set to store distinct valid numbers","code":"uniq = set ( ) NEW_LINE for i in range ( 1 , max_len + 1 , 1 ) : NEW_LINE"}
{"text":"Generate all possible strings of length i","code":"generate ( \" \" , i , uniq ) NEW_LINE"}
{"text":"Iterate the set to get the count of valid numbers in the range [ L , R ]","code":"for x in uniq : NEW_LINE INDENT if ( x >= L and x <= R ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 22 NEW_LINE R = 22 NEW_LINE print ( totalNumbers ( L , R ) ) NEW_LINE DEDENT"}
{"text":"Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end","code":"def convertXintoY ( X , Y ) : NEW_LINE"}
{"text":"Iterate until Y is at least X","code":"while ( Y > X ) : NEW_LINE"}
{"text":"If Y is even","code":"if ( Y % 2 == 0 ) : NEW_LINE INDENT Y \/\/= 2 NEW_LINE DEDENT"}
{"text":"If the last digit of Y is 1","code":"elif ( Y % 10 == 1 ) : NEW_LINE INDENT Y \/\/= 10 NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Check if X is equal to Y","code":"if ( X == Y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X , Y = 100 , 40021 NEW_LINE convertXintoY ( X , Y ) NEW_LINE DEDENT"}
{"text":"Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings","code":"def generateString ( K ) : NEW_LINE"}
{"text":"Stores the resultant string","code":"s = \" \" NEW_LINE"}
{"text":"Iterate through all the characters","code":"for i in range ( 97 , 97 + K , 1 ) : NEW_LINE INDENT s = s + chr ( i ) ; NEW_LINE DEDENT"}
{"text":"Inner Loop for making pairs and adding them into string","code":"for j in range ( i + 1 , 97 + K , 1 ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE DEDENT"}
{"text":"Adding first character so that substring consisting of the last the first alphabet is present","code":"s += chr ( 97 ) NEW_LINE"}
{"text":"Print the resultant string","code":"print ( s ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 4 NEW_LINE generateString ( K ) NEW_LINE DEDENT"}
{"text":"Function to find the quadratic equation from the given sum and products of roots","code":"def findEquation ( S , M ) : NEW_LINE"}
{"text":"Print the coefficients","code":"print ( \"1 \u2581 \" , ( ( - 1 ) * S ) , \" \u2581 \" , M ) NEW_LINE"}
{"text":"Driver Code","code":"S = 5 NEW_LINE M = 6 NEW_LINE findEquation ( S , M ) NEW_LINE"}
{"text":"Function to count the minimum number of pairs of adjacent elements required to be replaced by their sum to make all arrat elements equal","code":"def minSteps ( a , n ) : NEW_LINE"}
{"text":"Stores the prefix sum of the array","code":"prefix_sum = a [ : ] NEW_LINE"}
{"text":"Calculate the prefix sum array","code":"for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT"}
{"text":"Stores the maximum number of subarrays into which the array can be split","code":"mx = - 1 NEW_LINE"}
{"text":"Iterate over all possible sums","code":"for subgroupsum in prefix_sum : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE grp_count = 0 NEW_LINE DEDENT"}
{"text":"Traverse the array","code":"while i < n : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT"}
{"text":"If the sum is equal to the current prefix sum","code":"if sum == subgroupsum : NEW_LINE"}
{"text":"Increment count of groups by 1","code":"grp_count += 1 NEW_LINE sum = 0 NEW_LINE"}
{"text":"Otherwise discard this subgroup sum","code":"elif sum > subgroupsum : NEW_LINE INDENT grp_count = - 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"Update the maximum this of subarrays","code":"if grp_count > mx : NEW_LINE INDENT mx = grp_count NEW_LINE DEDENT"}
{"text":"Return the minimum number of operations","code":"return n - mx NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 2 , 1 , 3 ] NEW_LINE N = len ( A ) NEW_LINE DEDENT"}
{"text":"Function Call","code":"print ( minSteps ( A , N ) ) NEW_LINE"}
{"text":"Function to find the most frequent character after replacing X with either '0' or '1' according as per the given conditions","code":"def maxOccuringCharacter ( s ) : NEW_LINE"}
{"text":"Store the count of 0 s and 1 s in the S","code":"INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE DEDENT"}
{"text":"Count the frequency of 0 and 1","code":"INDENT for i in range ( len ( s ) ) : NEW_LINE DEDENT"}
{"text":"If the character is 1","code":"if ( s [ i ] == '1' ) : NEW_LINE count1 += 1 NEW_LINE"}
{"text":"If the character is 0","code":"elif ( s [ i ] == '0' ) : NEW_LINE count0 += 1 NEW_LINE"}
{"text":"Stores first occurence of 1","code":"INDENT prev = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE prev = i NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"Traverse the to count the number of X between two consecutive 1 s","code":"INDENT for i in range ( prev + 1 , len ( s ) ) : NEW_LINE DEDENT"}
{"text":"If the current character is not X","code":"if ( s [ i ] != ' X ' ) : NEW_LINE"}
{"text":"If the current character is 1 , add the number of Xs to count1 and set prev to i","code":"if ( s [ i ] == '1' ) : NEW_LINE INDENT count1 += i - prev - 1 NEW_LINE prev = i NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Find next occurence of 1 in the string","code":"flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE if ( s [ j ] == '1' ) : NEW_LINE INDENT flag = False NEW_LINE prev = j NEW_LINE break NEW_LINE DEDENT"}
{"text":"If it is found , set i to prev","code":"if ( flag == False ) : NEW_LINE i = prev NEW_LINE"}
{"text":"Otherwise , break out of the loop","code":"else : NEW_LINE i = len ( s ) NEW_LINE"}
{"text":"Store the first occurence of 0","code":"INDENT prev = - 1 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE prev = i NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"Repeat the same procedure to count the number of X between two consecutive 0 s","code":"INDENT for i in range ( prev + 1 , len ( s ) ) : NEW_LINE DEDENT"}
{"text":"If the current character is not X","code":"if ( s [ i ] != ' X ' ) : NEW_LINE"}
{"text":"If the current character is 0","code":"if ( s [ i ] == '0' ) : NEW_LINE"}
{"text":"Add the count of Xs to count0","code":"count0 += i - prev - 1 NEW_LINE"}
{"text":"Set prev to i","code":"prev = i NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Find the next occurence of 0 in the string","code":"flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE if ( s [ j ] == '0' ) : NEW_LINE INDENT prev = j NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT"}
{"text":"If it is found , set i to prev","code":"if ( flag == False ) : NEW_LINE i = prev NEW_LINE"}
{"text":"Otherwise , break out of the loop","code":"else : NEW_LINE i = len ( s ) NEW_LINE"}
{"text":"Count number of X present in the starting of the string as XXXX1 ...","code":"INDENT if ( s [ 0 ] == ' X ' ) : NEW_LINE DEDENT"}
{"text":"Store the count of X","code":"count = 0 NEW_LINE i = 0 NEW_LINE while ( s [ i ] == ' X ' ) : NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE"}
{"text":"Increment count1 by count if the condition is satisfied","code":"if ( s [ i ] == '1' ) : NEW_LINE count1 += count NEW_LINE"}
{"text":"Count the number of X present in the ending of the as ... XXXX0","code":"INDENT if ( s [ ( len ( s ) - 1 ) ] == ' X ' ) : NEW_LINE DEDENT"}
{"text":"Store the count of X","code":"count = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' X ' ) : NEW_LINE count += 1 NEW_LINE i -= 1 NEW_LINE"}
{"text":"Increment count0 by count if the condition is satisfied","code":"if ( s [ i ] == '0' ) : NEW_LINE count0 += count NEW_LINE"}
{"text":"If count of 1 is equal to count of 0 , prX","code":"INDENT if ( count0 == count1 ) : NEW_LINE INDENT print ( \" X \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Otherwise , if count of 1 is greater than count of 0","code":"INDENT elif ( count0 > count1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT"}
{"text":"Otherwise , pr0","code":"INDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"S = \" XX10XX10XXX1XX \" NEW_LINE maxOccuringCharacter ( S ) NEW_LINE"}
{"text":"Function to calculate the maximum number of sheets possible by given operations","code":"def maxSheets ( A , B ) : NEW_LINE INDENT area = A * B NEW_LINE DEDENT"}
{"text":"Initial count of sheets","code":"count = 1 NEW_LINE"}
{"text":"Keep dividing the sheets into half","code":"while ( area % 2 == 0 ) : NEW_LINE"}
{"text":"Reduce area by half","code":"area \/\/= 2 NEW_LINE"}
{"text":"Increase count by twice","code":"count *= 2 NEW_LINE return count NEW_LINE"}
{"text":"Driver Code","code":"A = 5 NEW_LINE B = 10 NEW_LINE print ( maxSheets ( A , B ) ) NEW_LINE"}
{"text":"function to find the minimum moves required to reach origin from ( a , b )","code":"def findMinMoves ( a , b ) : NEW_LINE"}
{"text":"Stores the minimum number of moves","code":"ans = 0 NEW_LINE"}
{"text":"Check if the absolute difference is 1 or 0","code":"if ( a == b or abs ( a - b ) == 1 ) : NEW_LINE INDENT ans = a + b NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Store the minimum of a , b","code":"k = min ( a , b ) NEW_LINE"}
{"text":"Store the maximum of a , b","code":"j = max ( a , b ) NEW_LINE ans = 2 * k + 2 * ( j - k ) - 1 NEW_LINE"}
{"text":"Prthe answer","code":"print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given co - ordinates","code":"a , b = 3 , 5 NEW_LINE"}
{"text":"Function Call","code":"findMinMoves ( a , b ) NEW_LINE"}
{"text":"Function to count even sum pairs in the given range","code":"def cntEvenSumPairs ( X , Y ) : NEW_LINE"}
{"text":"Stores the count of even numbers between 1 to X","code":"cntXEvenNums = X \/ 2 NEW_LINE"}
{"text":"Stores the count of odd numbers between 1 to X","code":"cntXOddNums = ( X + 1 ) \/ 2 NEW_LINE"}
{"text":"Stores the count of even numbers between 1 to Y","code":"cntYEvenNums = Y \/ 2 NEW_LINE"}
{"text":"Stores the count of odd numbers between 1 to Y","code":"cntYOddNums = ( Y + 1 ) \/ 2 NEW_LINE"}
{"text":"Stores the count of pairs having even sum","code":"cntPairs = ( ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ) NEW_LINE"}
{"text":"Returns the count of pairs having even sum","code":"return cntPairs NEW_LINE"}
{"text":"Driver code","code":"X = 2 NEW_LINE Y = 3 NEW_LINE print ( cntEvenSumPairs ( X , Y ) ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to calculate minimum number of moves to make the sequence a Fibonacci series","code":"def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE DEDENT"}
{"text":"If number of elements is less than 3","code":"if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Initialize the value of the result","code":"ans = sys . maxsize NEW_LINE"}
{"text":"Try all permutations of the first two elements","code":"for i in range ( - 1 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 ) : NEW_LINE DEDENT"}
{"text":"Value of first element after operation","code":"num1 = arr [ 0 ] + i NEW_LINE"}
{"text":"Value of second element after operation","code":"num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE"}
{"text":"Calculate number of moves for rest of the elements of the array","code":"for idx in range ( 2 , N ) : NEW_LINE"}
{"text":"Element at idx index","code":"num = num1 + num2 NEW_LINE"}
{"text":"If it is not possible to change the element in atmost one move","code":"if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE"}
{"text":"Update the answer","code":"if ( flag ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT"}
{"text":"Return the answer","code":"if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 17 , 27 ] NEW_LINE print ( minMoves ( arr ) ) NEW_LINE DEDENT"}
{"text":"Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries","code":"def querySum ( arr , N , Q , M ) : NEW_LINE"}
{"text":"Iterate over each query","code":"for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE DEDENT"}
{"text":"Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ...","code":"sum = 0 NEW_LINE"}
{"text":"Traverse the array and calculate the sum of the expression","code":"while ( x < N ) : NEW_LINE"}
{"text":"Update sum","code":"sum += arr [ x ] NEW_LINE"}
{"text":"Update x","code":"x += y NEW_LINE print ( sum , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 5 , 4 ] ; NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE DEDENT"}
{"text":"Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values","code":"def findBitwiseORGivenXORAND ( X , Y ) : NEW_LINE INDENT return X + Y NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 5 NEW_LINE Y = 2 NEW_LINE print ( findBitwiseORGivenXORAND ( X , Y ) ) NEW_LINE DEDENT"}
{"text":"Function to return GCD of two numbers a and b","code":"def GCD ( a , b ) : NEW_LINE"}
{"text":"Base Case","code":"if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT"}
{"text":"Recursively Find the GCD","code":"return GCD ( b , a % b ) NEW_LINE"}
{"text":"Function to check of B can be reaced from A with a jump of K elements in the circular queue","code":"def canReach ( N , A , B , K ) : NEW_LINE"}
{"text":"Find GCD of N and K","code":"gcd = GCD ( N , K ) NEW_LINE"}
{"text":"If A - B is divisible by gcd then prYes","code":"if ( abs ( A - B ) % gcd == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE A = 2 NEW_LINE B = 1 NEW_LINE K = 2 NEW_LINE DEDENT"}
{"text":"Function Call","code":"canReach ( N , A , B , K ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function that counts the subarrays with sum of its elements as its length","code":"def countOfSubarray ( arr , N ) : NEW_LINE"}
{"text":"Store count of elements upto current element with length i","code":"mp = defaultdict ( lambda : 0 ) NEW_LINE"}
{"text":"Stores the final count of subarray","code":"answer = 0 NEW_LINE"}
{"text":"Stores the prefix sum","code":"sum = 0 NEW_LINE"}
{"text":"If size of subarray is 1","code":"mp [ 1 ] += 1 NEW_LINE"}
{"text":"Iterate the array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Find the sum","code":"sum += arr [ i ] NEW_LINE answer += mp [ sum - i ] NEW_LINE"}
{"text":"Update frequency in map","code":"mp [ sum - i ] += 1 NEW_LINE"}
{"text":"Print the total count","code":"print ( answer ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given array","code":"arr = [ 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 ] NEW_LINE"}
{"text":"Size of the array","code":"N = len ( arr ) NEW_LINE"}
{"text":"Function Call","code":"countOfSubarray ( arr , N ) NEW_LINE"}
{"text":"Function to split the first N natural numbers into two sets having minimum absolute difference of their sums","code":"def minAbsDiff ( N ) : NEW_LINE"}
{"text":"Stores the sum of elements of set1","code":"sumSet1 = 0 NEW_LINE"}
{"text":"Stores the sum of elements of set2","code":"sumSet2 = 0 NEW_LINE"}
{"text":"Traverse first N natural numbers","code":"for i in reversed ( range ( N + 1 ) ) : NEW_LINE"}
{"text":"Check if sum of elements of set1 is less than or equal to sum of elements of set2","code":"if sumSet1 <= sumSet2 : NEW_LINE sumSet1 = sumSet1 + i NEW_LINE else : NEW_LINE sumSet2 = sumSet2 + i NEW_LINE return abs ( sumSet1 - sumSet2 ) NEW_LINE"}
{"text":"Driver Code","code":"N = 6 NEW_LINE print ( minAbsDiff ( N ) ) NEW_LINE"}
{"text":"Function to check if N contains digits 0 , 1 , 2 , 5 , 8 only","code":"def checkDigits ( n ) : NEW_LINE"}
{"text":"Extract digits of N","code":"while True : NEW_LINE INDENT r = n % 10 NEW_LINE DEDENT"}
{"text":"Return false if any of these digits are present","code":"if ( r == 3 or r == 4 or r == 6 or r == 7 or r == 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n \/\/= 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Function to check if N is prime or not","code":"def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Check for all factors","code":"for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Function to check if n is prime in all the desired forms","code":"def isAllPrime ( n ) : NEW_LINE INDENT return isPrime ( n ) and checkDigits ( n ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 101 NEW_LINE if ( isAllPrime ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to calculate the minimum cost required to generate a balanced bracket sequence","code":"def minCost ( str , a , b ) : NEW_LINE"}
{"text":"Stores the count of unbalanced open brackets","code":"openUnbalanced = 0 ; NEW_LINE"}
{"text":"Stores the count of unbalanced closed brackets","code":"closedUnbalanced = 0 ; NEW_LINE"}
{"text":"Stores the count of open brackets","code":"openCount = 0 ; NEW_LINE"}
{"text":"Stores the count of closed brackets","code":"closedCount = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE"}
{"text":"If open brace is encountered","code":"if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT openUnbalanced += 1 ; NEW_LINE openCount += 1 ; NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"If no unbalanced open brackets are present","code":"if ( openUnbalanced == 0 ) : NEW_LINE"}
{"text":"Increase count of unbalanced closed brackets","code":"closedUnbalanced += 1 ; NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Reduce count of unbalanced open brackets","code":"openUnbalanced -= 1 ; NEW_LINE"}
{"text":"Increase count of closed brackets","code":"closedCount += 1 ; NEW_LINE"}
{"text":"Calculate lower bound of minimum cost","code":"result = a * ( abs ( openCount - closedCount ) ) ; NEW_LINE"}
{"text":"Reduce excess open or closed brackets to prevent counting them twice","code":"if ( closedCount > openCount ) : NEW_LINE INDENT closedUnbalanced -= ( closedCount - openCount ) ; NEW_LINE DEDENT if ( openCount > closedCount ) : NEW_LINE INDENT openUnbalanced -= ( openCount - closedCount ) ; NEW_LINE DEDENT"}
{"text":"Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of String","code":"result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; NEW_LINE"}
{"text":"Prthe result","code":"print ( result ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : str = \" ) ) ( ) ( ( ) ( ) ( \" ; NEW_LINE INDENT A = 1 ; B = 3 ; NEW_LINE minCost ( str , A , B ) ; NEW_LINE DEDENT"}
{"text":"Function to return the number of all permutations such that sum of K numbers in range is even","code":"def countEvenSum ( low , high , k ) : NEW_LINE"}
{"text":"Find total count of even and odd number in given range","code":"even_count = high \/ 2 - ( low - 1 ) \/ 2 NEW_LINE odd_count = ( high + 1 ) \/ 2 - low \/ 2 NEW_LINE even_sum = 1 NEW_LINE odd_sum = 0 NEW_LINE"}
{"text":"Iterate loop k times and update even_sum & odd_sum using previous values","code":"for i in range ( 0 , k ) : NEW_LINE"}
{"text":"Update the prev_even and odd_sum","code":"prev_even = even_sum NEW_LINE prev_odd = odd_sum NEW_LINE"}
{"text":"Even sum","code":"even_sum = ( ( prev_even * even_count ) + ( prev_odd * odd_count ) ) NEW_LINE"}
{"text":"Odd sum","code":"odd_sum = ( ( prev_even * odd_count ) + ( prev_odd * even_count ) ) NEW_LINE"}
{"text":"Return even_sum","code":"print ( int ( even_sum ) ) NEW_LINE"}
{"text":"Given ranges","code":"low = 4 ; NEW_LINE high = 5 ; NEW_LINE"}
{"text":"Length of permutation","code":"K = 3 ; NEW_LINE"}
{"text":"Function call","code":"countEvenSum ( low , high , K ) ; NEW_LINE"}
{"text":"Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal","code":"def count ( n , k ) : NEW_LINE INDENT count = ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; NEW_LINE DEDENT"}
{"text":"Print the answer","code":"print ( count ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 ; NEW_LINE k = 1 ; NEW_LINE count ( n , k ) ; NEW_LINE DEDENT"}
{"text":"Function to find the sum of largest divisors of numbers in range 1 to N not divisible by prime number P","code":"def func ( N , P ) : NEW_LINE"}
{"text":"Total sum upto N","code":"sumUptoN = ( N * ( N + 1 ) \/ 2 ) ; NEW_LINE sumOfMultiplesOfP = 0 ; NEW_LINE"}
{"text":"If no multiple of P exist up to N","code":"if ( N < P ) : NEW_LINE INDENT return sumUptoN ; NEW_LINE DEDENT"}
{"text":"If only P itself is in the range from 1 to N","code":"elif ( ( N \/ P ) == 1 ) : NEW_LINE INDENT return sumUptoN - P + 1 ; NEW_LINE DEDENT"}
{"text":"Sum of those that are divisible by P","code":"sumOfMultiplesOfP = ( ( ( N \/ P ) * ( 2 * P + ( N \/ P - 1 ) * P ) ) \/ 2 ) ; NEW_LINE"}
{"text":"Recursively function call to find the sum for N \/ P","code":"return ( sumUptoN + func ( N \/ P , P ) - sumOfMultiplesOfP ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given N and P","code":"N = 10 ; NEW_LINE P = 5 ; NEW_LINE"}
{"text":"Function call","code":"print ( func ( N , P ) ) ; NEW_LINE"}
{"text":"Function to find the right shifts required for each element to reach its sorted array position in A [ ]","code":"def findShifts ( A , N ) : NEW_LINE"}
{"text":"Stores required number of shifts for each element","code":"shift = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"If the element is at sorted position","code":"if ( i == A [ i ] - 1 ) : NEW_LINE INDENT shift [ i ] = 0 NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Calculate right shift","code":"shift [ i ] = ( A [ i ] - 1 - i + N ) % N NEW_LINE"}
{"text":"Print the respective shifts","code":"for i in range ( N ) : NEW_LINE INDENT print ( shift [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 3 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findShifts ( arr , N ) NEW_LINE DEDENT"}
{"text":"Function to construct matrix with diagonal sum equal to matrix sum","code":"def constructmatrix ( N ) : NEW_LINE INDENT check = bool ( True ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE DEDENT DEDENT"}
{"text":"If diagonal position","code":"if ( i == j ) : NEW_LINE INDENT print ( 1 , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( check ) : NEW_LINE"}
{"text":"Positive element","code":"print ( 2 , end = \" \u2581 \" ) NEW_LINE check = bool ( False ) NEW_LINE else : NEW_LINE"}
{"text":"Negative element","code":"print ( - 2 , end = \" \u2581 \" ) NEW_LINE check = bool ( True ) NEW_LINE print ( ) NEW_LINE"}
{"text":"Driver code","code":"N = 5 NEW_LINE constructmatrix ( 5 ) NEW_LINE"}
{"text":"Function to calculate and return the minimum number of times a number with unit digit X needs to be added to get a sum N","code":"def check ( unit_digit , X ) : NEW_LINE"}
{"text":"Calculate the number of additions required to get unit digit of N","code":"for times in range ( 1 , 11 ) : NEW_LINE INDENT digit = ( X * times ) % 10 NEW_LINE if ( digit == unit_digit ) : NEW_LINE INDENT return times NEW_LINE DEDENT DEDENT"}
{"text":"If unit digit of N cannot be obtained","code":"return - 1 NEW_LINE"}
{"text":"Function to return the minimum number required to represent N","code":"def getNum ( N , X ) : NEW_LINE"}
{"text":"Stores unit digit of N","code":"unit_digit = N % 10 NEW_LINE"}
{"text":"Stores minimum addition of X required to obtain unit digit of N","code":"times = check ( unit_digit , X ) NEW_LINE"}
{"text":"If unit digit of N cannot be obtained","code":"if ( times == - 1 ) : NEW_LINE INDENT return times NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"If N is greater than or equal to ( X * times )","code":"if ( N >= ( times * X ) ) : NEW_LINE"}
{"text":"Minimum count of numbers that needed to represent N","code":"return times NEW_LINE"}
{"text":"Representation not possible","code":"else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 58 NEW_LINE X = 7 NEW_LINE print ( getNum ( N , X ) ) NEW_LINE"}
{"text":"Function to find the minimum number of Points required to cover a grid","code":"def minPoints ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT"}
{"text":"If number of block is even","code":"if ( ( n % 2 != 0 ) and ( m % 2 != 0 ) ) : NEW_LINE INDENT ans = ( ( n * m ) \/\/ 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n * m ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"Return the minimum points","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given size of grid","code":"N = 5 NEW_LINE M = 7 NEW_LINE"}
{"text":"Function call","code":"print ( minPoints ( N , M ) ) NEW_LINE"}
{"text":"Function to find the largest lexicographical string with given constraints .","code":"def getLargestString ( s , k ) : NEW_LINE"}
{"text":"Vector containing frequency of each character .","code":"frequency_array = [ 0 ] * 26 NEW_LINE"}
{"text":"Assigning frequency to","code":"for i in range ( len ( s ) ) : NEW_LINE INDENT frequency_array [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT"}
{"text":"Empty string of string class type","code":"ans = \" \" NEW_LINE"}
{"text":"Loop to iterate over maximum priority first .","code":"i = 25 NEW_LINE while i >= 0 : NEW_LINE"}
{"text":"If frequency is greater than or equal to k .","code":"if ( frequency_array [ i ] > k ) : NEW_LINE"}
{"text":"Temporary variable to operate in - place of k .","code":"temp = k NEW_LINE st = chr ( i + ord ( ' a ' ) ) NEW_LINE while ( temp > 0 ) : NEW_LINE"}
{"text":"concatenating with the resultant string ans .","code":"ans += st NEW_LINE temp -= 1 NEW_LINE frequency_array [ i ] -= k NEW_LINE"}
{"text":"Handling k case by adjusting with just smaller priority element .","code":"j = i - 1 NEW_LINE while ( frequency_array [ j ] <= 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT"}
{"text":"Condition to verify if index j does have frequency greater than 0 ;","code":"if ( frequency_array [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT str1 = chr ( j + ord ( ' a ' ) ) NEW_LINE ans += str1 NEW_LINE frequency_array [ j ] -= 1 NEW_LINE DEDENT else : NEW_LINE"}
{"text":"if no such element is found than string can not be processed further .","code":"break NEW_LINE"}
{"text":"If frequency is greater than 0 and less than k .","code":"elif ( frequency_array [ i ] > 0 ) : NEW_LINE"}
{"text":"Here we don 't need to fix K  consecutive element criteria.","code":"temp = frequency_array [ i ] NEW_LINE frequency_array [ i ] -= temp NEW_LINE st = chr ( i + ord ( ' a ' ) ) NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT ans += st NEW_LINE temp -= 1 NEW_LINE DEDENT"}
{"text":"Otherwise check for next possible element .","code":"else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" xxxxzza \" NEW_LINE k = 3 NEW_LINE print ( getLargestString ( S , k ) ) NEW_LINE DEDENT"}
{"text":"Function to find the minimum operations required to make all elements of the array equal","code":"def minOperations ( a , b , n ) : NEW_LINE"}
{"text":"Minimum element of A","code":"minA = min ( a ) ; NEW_LINE"}
{"text":"Traverse through all final values","code":"for x in range ( minA , - 1 , - 1 ) : NEW_LINE"}
{"text":"Variable indicating whether all elements can be converted to x or not","code":"check = True ; NEW_LINE"}
{"text":"Total operations","code":"operations = 0 ; NEW_LINE"}
{"text":"Traverse through all array elements","code":"for i in range ( n ) : NEW_LINE INDENT if ( x % b [ i ] == a [ i ] % b [ i ] ) : NEW_LINE INDENT operations += ( a [ i ] - x ) \/ b [ i ] ; NEW_LINE DEDENT DEDENT"}
{"text":"All elements can 't  be converted to x","code":"else : NEW_LINE INDENT check = False ; NEW_LINE break ; NEW_LINE DEDENT if ( check ) : NEW_LINE return operations ; NEW_LINE return - 1 ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE A = [ 5 , 7 , 10 , 5 , 15 ] ; NEW_LINE B = [ 2 , 2 , 1 , 3 , 5 ] ; NEW_LINE print ( int ( minOperations ( A , B , N ) ) ) ; NEW_LINE DEDENT"}
{"text":"Function to return the maximum sum of a + b satisfying the given condition","code":"def getLargestSum ( N ) : NEW_LINE"}
{"text":"Initialize max_sum","code":"max_sum = 0 NEW_LINE"}
{"text":"Consider all the possible pairs","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 , 1 ) : NEW_LINE DEDENT"}
{"text":"Check if the product is divisible by the sum","code":"if ( i * j % ( i + j ) == 0 ) : NEW_LINE"}
{"text":"Storing the maximum sum in the max_sum variable","code":"max_sum = max ( max_sum , i + j ) NEW_LINE"}
{"text":"Return the max_sum value","code":"return max_sum NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE max_sum = getLargestSum ( N ) NEW_LINE print ( max_sum ) NEW_LINE DEDENT"}
{"text":"Kadane 's algorithm to find the maximum subarray sum","code":"def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 10 ** 9 NEW_LINE max_ending_here = 0 NEW_LINE DEDENT"}
{"text":"Loop to find the maximum subarray array sum in the given array","code":"for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE"}
{"text":"Function to find the maximum sum of the array by multiplying the prefix and suffix by - 1","code":"def maxSum ( a , n ) : NEW_LINE"}
{"text":"Total intital sum","code":"S = 0 NEW_LINE"}
{"text":"Loop to find the maximum sum of the array","code":"for i in range ( n ) : NEW_LINE INDENT S += a [ i ] NEW_LINE DEDENT X = maxSubArraySum ( a , n ) NEW_LINE"}
{"text":"Maximum value","code":"return 2 * X - S NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 1 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE max_sum = maxSum ( a , n ) NEW_LINE print ( max_sum ) NEW_LINE DEDENT"}
{"text":"Python3 program to find the number of interesting primes up to N","code":"import math NEW_LINE"}
{"text":"Function to check if a number is prime or not","code":"def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT"}
{"text":"If n is divisible by any number between 2 and sqrt ( n ) , it is not prime","code":"i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if flag == 1 else False ) NEW_LINE"}
{"text":"Function to check if a number is perfect square or not","code":"def isPerfectSquare ( x ) : NEW_LINE"}
{"text":"Find floating povalue of square root of x .","code":"sr = math . sqrt ( x ) NEW_LINE"}
{"text":"If square root is an integer","code":"return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE"}
{"text":"Function to find the number of interesting primes less than equal to N .","code":"def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE DEDENT"}
{"text":"Check whether the number is prime or not","code":"if ( isPrime ( i ) ) : NEW_LINE"}
{"text":"Iterate for values of b","code":"j = 1 NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE"}
{"text":"Check condition for a","code":"if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE"}
{"text":"Return the required answer","code":"return answer NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE DEDENT"}
{"text":"Python implementation of the approach","code":"import math NEW_LINE"}
{"text":"Function to convert decimal number n to its binary representation stored as an array arr [ ]","code":"def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT DEDENT"}
{"text":"Function to convert the number represented as a binary array arr [ ] into its decimal equivalent","code":"def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"}
{"text":"Function to return the maximized number by flipping atmost k bits","code":"def maxNum ( n , k ) : NEW_LINE"}
{"text":"Number of bits in n","code":"l = int ( math . log2 ( n ) ) + 1 NEW_LINE"}
{"text":"Find the binary representation of n","code":"a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE"}
{"text":"To count the number of 0 s flipped","code":"cn = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( a [ i ] == 0 and cn < k ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE cn = cn + 1 NEW_LINE DEDENT DEDENT"}
{"text":"Return the decimal equivalent of the maximized number","code":"return binaryDec ( a , l ) NEW_LINE"}
{"text":"Driver code","code":"n = 4 NEW_LINE k = 1 NEW_LINE print ( maxNum ( n , k ) ) NEW_LINE"}
{"text":"Function to find the required subsequence","code":"def findSubSeq ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT"}
{"text":"Current element cannot be a part of the required subsequence","code":"if ( sum < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = - 1 ; NEW_LINE DEDENT"}
{"text":"Include current element in the required subsequence So update the sum","code":"else : NEW_LINE INDENT sum -= arr [ i ] ; NEW_LINE DEDENT"}
{"text":"Print the elements of the required subsequence","code":"for i in range ( n ) : NEW_LINE"}
{"text":"If the current element was included in the subsequence","code":"if ( arr [ i ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 17 , 25 , 46 , 94 , 201 , 400 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sum = 272 ; NEW_LINE findSubSeq ( arr , n , sum ) ; NEW_LINE DEDENT"}
{"text":"Python implementation of the approach","code":"MAX = 26 NEW_LINE"}
{"text":"Function to return the maximum valued alphabet","code":"def maxAlpha ( str , len ) : NEW_LINE"}
{"text":"Set the first and the last occurrence of all the characters to - 1","code":"first = [ - 1 for x in range ( MAX ) ] NEW_LINE last = [ - 1 for x in range ( MAX ) ] NEW_LINE"}
{"text":"Update the occurrences of the characters","code":"for i in range ( 0 , len ) : NEW_LINE INDENT index = ord ( str [ i ] ) - 97 NEW_LINE DEDENT"}
{"text":"Only set the first occurrence if it hasn 't already been set","code":"if ( first [ index ] == - 1 ) : NEW_LINE INDENT first [ index ] = i NEW_LINE DEDENT last [ index ] = i NEW_LINE"}
{"text":"To store the result","code":"ans = - 1 NEW_LINE maxVal = - 1 NEW_LINE"}
{"text":"For every alphabet","code":"for i in range ( 0 , MAX ) : NEW_LINE"}
{"text":"If current alphabet doesn 't appear  in the given string","code":"if ( first [ i ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"If the current character has the highest value so far","code":"if ( ( last [ i ] - first [ i ] ) > maxVal ) : NEW_LINE INDENT maxVal = last [ i ] - first [ i ] ; NEW_LINE ans = i NEW_LINE DEDENT return chr ( ans + 97 ) NEW_LINE"}
{"text":"Driver code","code":"str = \" abbba \" NEW_LINE len = len ( str ) NEW_LINE print ( maxAlpha ( str , len ) ) NEW_LINE"}
{"text":"Python implementation of the approach","code":"MAX = 100001 ; NEW_LINE"}
{"text":"Function to perform queries to find number of distinct elements from a given index till last index in an array","code":"def find_distinct ( a , n , q , queries ) : NEW_LINE INDENT check = [ 0 ] * MAX ; NEW_LINE idx = [ 0 ] * MAX ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT"}
{"text":"Check if current element already visited or not","code":"if ( check [ a [ i ] ] == 0 ) : NEW_LINE"}
{"text":"If not visited store current counter and increment it and mark check as 1","code":"idx [ i ] = cnt ; NEW_LINE check [ a [ i ] ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE else : NEW_LINE"}
{"text":"Otherwise if visited simply store current counter","code":"idx [ i ] = cnt - 1 ; NEW_LINE"}
{"text":"Perform queries","code":"for i in range ( 0 , q ) : NEW_LINE INDENT m = queries [ i ] ; NEW_LINE print ( idx [ m ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"a = [ 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE queries = [ 0 , 3 , 5 , 7 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE find_distinct ( a , n , q , queries ) ; NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"MAX = 24 ; NEW_LINE"}
{"text":"Function to return the count of operations required","code":"def countOp ( x ) : NEW_LINE"}
{"text":"To store the powers of 2","code":"arr = [ 0 ] * MAX ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] * 2 ; NEW_LINE DEDENT"}
{"text":"Temporary variable to store x","code":"temp = x ; NEW_LINE flag = True ; NEW_LINE"}
{"text":"To store the index of smaller number larger than x","code":"ans = 0 ; NEW_LINE"}
{"text":"To store the count of operations","code":"operations = 0 ; NEW_LINE flag2 = False ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] - 1 == x ) : NEW_LINE INDENT flag2 = True ; NEW_LINE DEDENT DEDENT"}
{"text":"Stores the index of number in the form of 2 ^ n - 1","code":"if ( arr [ i ] > x ) : NEW_LINE INDENT ans = i ; NEW_LINE break ; NEW_LINE DEDENT"}
{"text":"If x is already in the form 2 ^ n - 1 then no operation is required","code":"if ( flag2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( flag ) : NEW_LINE"}
{"text":"If number is less than x increase the index","code":"if ( arr [ ans ] < x ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT operations += 1 ; NEW_LINE"}
{"text":"Calculate all the values ( x xor 2 ^ n - 1 ) for all possible n","code":"for i in range ( MAX ) : NEW_LINE INDENT take = x ^ ( arr [ i ] - 1 ) ; NEW_LINE if ( take <= arr [ ans ] - 1 ) : NEW_LINE DEDENT"}
{"text":"Only take value which is closer to the number","code":"if ( take > temp ) : NEW_LINE INDENT temp = take ; NEW_LINE DEDENT"}
{"text":"If number is in the form of 2 ^ n - 1 then break","code":"if ( temp == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT temp += 1 ; NEW_LINE operations += 1 ; NEW_LINE x = temp ; NEW_LINE if ( x == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT"}
{"text":"Return the count of operations required to obtain the number","code":"return operations ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 39 ; NEW_LINE print ( countOp ( x ) ) ; NEW_LINE DEDENT"}
{"text":"Function to return the minimum operations required","code":"def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT"}
{"text":"Count the frequency of each element","code":"freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"Maximum element from the array","code":"maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE DEDENT"}
{"text":"Find all the multiples of i","code":"for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE"}
{"text":"Delete the multiples","code":"freq [ j ] = 0 NEW_LINE"}
{"text":"Increment the operations","code":"result += 1 NEW_LINE return result NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of the approach","code":"from math import gcd NEW_LINE"}
{"text":"Function to return minimum GCD among all subarrays","code":"def minGCD ( arr , n ) : NEW_LINE INDENT minGCD = 0 ; NEW_LINE DEDENT"}
{"text":"Minimum GCD among all sub - arrays will be the GCD of all the elements of the array","code":"for i in range ( n ) : NEW_LINE INDENT minGCD = gcd ( minGCD , arr [ i ] ) ; NEW_LINE DEDENT return minGCD ; NEW_LINE"}
{"text":"Function to return minimum LCM among all subarrays","code":"def minLCM ( arr , n ) : NEW_LINE INDENT minLCM = arr [ 0 ] ; NEW_LINE DEDENT"}
{"text":"Minimum LCM among all sub - arrays will be the minimum element from the array","code":"for i in range ( 1 , n ) : NEW_LINE INDENT minLCM = min ( minLCM , arr [ i ] ) ; NEW_LINE DEDENT return minLCM ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 66 , 14 , 521 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" LCM \u2581 = \u2581 \" , minLCM ( arr , n ) , \" , \u2581 GCD \u2581 = \" , minGCD ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 implementation of the approach","code":"import math NEW_LINE"}
{"text":"Function that returns the modified lexicographically smallest string after performing minimum number of given operations","code":"def formStringMinOperations ( ss ) : NEW_LINE"}
{"text":"Stores the initial frequencies of characters 0 s , 1 s and 2 s","code":"count = [ 0 ] * 3 ; NEW_LINE s = list ( ss ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 ; NEW_LINE DEDENT"}
{"text":"Stores number of processed characters upto that point of each type","code":"processed = [ 0 ] * 3 ; NEW_LINE"}
{"text":"Required number of characters of each type","code":"reqd = math . floor ( len ( s ) \/ 3 ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"If the current type has already reqd number of characters , no need to perform any operation","code":"if ( count [ ord ( s [ i ] ) - ord ( '0' ) ] == reqd ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT"}
{"text":"Process all 3 cases","code":"if ( s [ i ] == '0' and count [ 0 ] > reqd and processed [ 0 ] >= reqd ) : NEW_LINE"}
{"text":"Check for 1 first","code":"if ( count [ 1 ] < reqd ) : NEW_LINE INDENT s [ i ] = '1' ; NEW_LINE count [ 1 ] += 1 ; NEW_LINE count [ 0 ] -= 1 ; NEW_LINE DEDENT"}
{"text":"Else 2","code":"elif ( count [ 2 ] < reqd ) : NEW_LINE INDENT s [ i ] = '2' ; NEW_LINE count [ 2 ] += 1 ; NEW_LINE count [ 0 ] -= 1 ; NEW_LINE DEDENT"}
{"text":"Here we need to check processed [ 1 ] only for 2 since 0 is less than 1 and we can replace it anytime","code":"if ( s [ i ] == '1' and count [ 1 ] > reqd ) : NEW_LINE INDENT if ( count [ 0 ] < reqd ) : NEW_LINE INDENT s [ i ] = '0' ; NEW_LINE count [ 0 ] += 1 ; NEW_LINE count [ 1 ] -= 1 ; NEW_LINE DEDENT elif ( count [ 2 ] < reqd and processed [ 1 ] >= reqd ) : NEW_LINE INDENT s [ i ] = '2' ; NEW_LINE count [ 2 ] += 1 ; NEW_LINE count [ 1 ] -= 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Here we can replace 2 with 0 and 1 anytime","code":"if ( s [ i ] == '2' and count [ 2 ] > reqd ) : NEW_LINE INDENT if ( count [ 0 ] < reqd ) : NEW_LINE INDENT s [ i ] = '0' ; NEW_LINE count [ 0 ] += 1 ; NEW_LINE count [ 2 ] -= 1 ; NEW_LINE DEDENT elif ( count [ 1 ] < reqd ) : NEW_LINE INDENT s [ i ] = '1' ; NEW_LINE count [ 1 ] += 1 ; NEW_LINE count [ 2 ] -= 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"keep count of processed characters of each type","code":"processed [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 ; NEW_LINE return ' ' . join ( s ) ; NEW_LINE"}
{"text":"Driver Code","code":"s = \"011200\" ; NEW_LINE print ( formStringMinOperations ( s ) ) ; NEW_LINE"}
{"text":"Function to find minimum swaps","code":"def findMinimumAdjacentSwaps ( arr , N ) : NEW_LINE"}
{"text":"visited array to check if value is seen already","code":"visited = [ False ] * ( N + 1 ) NEW_LINE minimumSwaps = 0 NEW_LINE for i in range ( 2 * N ) : NEW_LINE"}
{"text":"If the arr [ i ] is seen first time","code":"if ( visited [ arr [ i ] ] == False ) : NEW_LINE INDENT visited [ arr [ i ] ] = True NEW_LINE DEDENT"}
{"text":"stores the number of swaps required to find the correct position of current element 's partner","code":"count = 0 NEW_LINE for j in range ( i + 1 , 2 * N ) : NEW_LINE"}
{"text":"Increment count only if the current element has not been visited yet ( if is visited , means it has already been placed at its correct position )","code":"if ( visited [ arr [ j ] ] == False ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"If current element 's partner is found","code":"elif ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT minimumSwaps += count NEW_LINE DEDENT return minimumSwaps NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE N \/\/= 2 NEW_LINE print ( findMinimumAdjacentSwaps ( arr , N ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to print the largest palindromic number by permuting digits of a number","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function to check if a number can be permuted to form a palindrome number","code":"def possibility ( m , length , s ) : NEW_LINE"}
{"text":"counts the occurrence of number which is odd","code":"countodd = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE"}
{"text":"if occurrence is odd","code":"if m [ int ( s [ i ] ) ] & 1 : NEW_LINE INDENT countodd += 1 NEW_LINE DEDENT"}
{"text":"if number exceeds 1","code":"if countodd > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Function to print the largest palindromic number by permuting digits of a number","code":"def largestPalindrome ( s ) : NEW_LINE"}
{"text":"string length","code":"l = len ( s ) NEW_LINE"}
{"text":"map that marks the occurrence of a number","code":"m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT m [ int ( s [ i ] ) ] += 1 NEW_LINE DEDENT"}
{"text":"check the possibility of a palindromic number","code":"if possibility ( m , l , s ) == False : NEW_LINE INDENT print ( \" Palindrome \u2581 cannot \u2581 be \u2581 formed \" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"string array that stores the largest permuted palindromic number","code":"largest = [ None ] * l NEW_LINE"}
{"text":"pointer of front","code":"front = 0 NEW_LINE"}
{"text":"greedily start from 9 to 0 and place the greater number in front and odd in the middle","code":"for i in range ( 9 , - 1 , - 1 ) : NEW_LINE"}
{"text":"if the occurrence of number is odd","code":"if m [ i ] & 1 : NEW_LINE"}
{"text":"place one odd occurring number in the middle","code":"largest [ l \/\/ 2 ] = chr ( i + 48 ) NEW_LINE"}
{"text":"decrease the count","code":"m [ i ] -= 1 NEW_LINE"}
{"text":"place the rest of numbers greedily","code":"while m [ i ] > 0 : NEW_LINE INDENT largest [ front ] = chr ( i + 48 ) NEW_LINE largest [ l - front - 1 ] = chr ( i + 48 ) NEW_LINE m [ i ] -= 2 NEW_LINE front += 1 NEW_LINE DEDENT else : NEW_LINE"}
{"text":"if all numbers occur even times , then place greedily","code":"while m [ i ] > 0 : NEW_LINE"}
{"text":"place greedily at front","code":"largest [ front ] = chr ( i + 48 ) NEW_LINE largest [ l - front - 1 ] = chr ( i + 48 ) NEW_LINE"}
{"text":"2 numbers are placed , so decrease the count","code":"m [ i ] -= 2 NEW_LINE"}
{"text":"increase placing position","code":"front += 1 NEW_LINE"}
{"text":"print the largest string thus formed","code":"for i in range ( 0 , l ) : NEW_LINE INDENT print ( largest [ i ] , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"313551\" NEW_LINE largestPalindrome ( s ) NEW_LINE DEDENT"}
{"text":"Function to calculate swaps required","code":"def swapCount ( s ) : NEW_LINE"}
{"text":"Keep track of '[","code":"' NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' [ ' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"To count number of encountered ' [ '","code":"count = 0 NEW_LINE"}
{"text":"To track position of next ' [ ' in pos","code":"p = 0 NEW_LINE"}
{"text":"To store result","code":"sum = 0 NEW_LINE s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"Increment count and move p to next position","code":"if ( s [ i ] == ' [ ' ) : NEW_LINE INDENT count += 1 NEW_LINE p += 1 NEW_LINE DEDENT elif ( s [ i ] == ' ] ' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT"}
{"text":"We have encountered an unbalanced part of string","code":"if ( count < 0 ) : NEW_LINE"}
{"text":"Increment sum by number of swaps required i . e . position of next ' [ ' - current position","code":"sum += pos [ p ] - i NEW_LINE s [ i ] , s [ pos [ p ] ] = ( s [ pos [ p ] ] , s [ i ] ) NEW_LINE p += 1 NEW_LINE"}
{"text":"Reset count to 1","code":"count = 1 NEW_LINE return sum NEW_LINE"}
{"text":"Driver code","code":"s = \" [ ] ] [ ] [ \" NEW_LINE print ( swapCount ( s ) ) NEW_LINE s = \" [ [ ] [ ] ] \" NEW_LINE print ( swapCount ( s ) ) NEW_LINE"}
{"text":"Method returns minimum cost to break board into m * n squares","code":"def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT"}
{"text":"sort the horizontal cost in reverse order","code":"X . sort ( reverse = True ) NEW_LINE"}
{"text":"sort the vertical cost in reverse order","code":"Y . sort ( reverse = True ) NEW_LINE"}
{"text":"initialize current width as 1","code":"hzntl = 1 ; vert = 1 NEW_LINE"}
{"text":"loop until one or both cost array are processed","code":"i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE DEDENT DEDENT"}
{"text":"increase current horizontal part count by 1","code":"hzntl += 1 NEW_LINE i += 1 NEW_LINE else : NEW_LINE res += Y [ j ] * hzntl NEW_LINE"}
{"text":"increase current vertical part count by 1","code":"vert += 1 NEW_LINE j += 1 NEW_LINE"}
{"text":"loop for horizontal array , if remains","code":"total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE"}
{"text":"loop for vertical array , if remains","code":"total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE"}
{"text":"Driver program","code":"m = 6 ; n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE"}
{"text":"Function to find the minimum of the three numbers","code":"def getMin ( x , y , z ) : NEW_LINE INDENT return min ( min ( x , y ) , z ) NEW_LINE DEDENT"}
{"text":"Function to find the minimum number operations required to convert string str1 to str2 using the operations","code":"def editDistance ( str1 , str2 , m , n ) : NEW_LINE"}
{"text":"Stores the results of subproblems","code":"dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE"}
{"text":"Fill dp [ ] [ ] in bottom up manner","code":"for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE DEDENT"}
{"text":"If str1 is empty , then insert all characters of string str2","code":"if ( i == 0 ) : NEW_LINE"}
{"text":"Minimum operations is j","code":"dp [ i ] [ j ] = j NEW_LINE"}
{"text":"If str2 is empty , then remove all characters of string str2","code":"elif ( j == 0 ) : NEW_LINE"}
{"text":"Minimum operations is i","code":"dp [ i ] [ j ] = i NEW_LINE"}
{"text":"If the last characters are same , then ignore last character","code":"elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT"}
{"text":"If the last character is different , then find the minimum","code":"else : NEW_LINE"}
{"text":"Perform one of the insert , remove and the replace","code":"dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE"}
{"text":"Return the minimum number of steps required","code":"return dp [ m ] [ n ] NEW_LINE"}
{"text":"Function to find the minimum number of steps to modify the string such that first half and second half becomes the same","code":"def minimumSteps ( S , N ) : NEW_LINE"}
{"text":"Stores the minimum number of operations required","code":"ans = 10 ** 10 NEW_LINE"}
{"text":"Traverse the given string S","code":"for i in range ( 1 , N ) : NEW_LINE INDENT S1 = S [ : i ] NEW_LINE S2 = S [ i : ] NEW_LINE DEDENT"}
{"text":"Find the minimum operations","code":"count = editDistance ( S1 , S2 , len ( S1 ) , len ( S2 ) ) NEW_LINE"}
{"text":"Update the ans","code":"ans = min ( ans , count ) NEW_LINE"}
{"text":"Print the result","code":"print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"S = \" aabb \" NEW_LINE N = len ( S ) NEW_LINE minimumSteps ( S , N ) NEW_LINE"}
{"text":"Function to find the minimum number of operations to reduce N to 2 by dividing N by 5 or decrementing by 3","code":"def minimumOperations ( N ) : NEW_LINE"}
{"text":"Initialize the dp array","code":"dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE"}
{"text":"Initialize the array dp [ ]","code":"for i in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] = 1000000000 NEW_LINE DEDENT"}
{"text":"For N = 2 number of operations needed is zero","code":"dp [ 2 ] = 0 NEW_LINE"}
{"text":"Iterating over the range [ 1 , N ]","code":"for i in range ( 2 , N + 1 , 1 ) : NEW_LINE"}
{"text":"If it 's not possible to  create current N","code":"if ( dp [ i ] == 1000000000 ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"Multiply with 5","code":"if ( i * 5 <= N ) : NEW_LINE INDENT dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) NEW_LINE DEDENT"}
{"text":"Adding the value 3","code":"if ( i + 3 <= N ) : NEW_LINE INDENT dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) NEW_LINE DEDENT"}
{"text":"Checking if not possible to make the number as 2","code":"if ( dp [ N ] == 1000000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Return the minimum number of operations","code":"return dp [ N ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( minimumOperations ( N ) ) NEW_LINE DEDENT"}
{"text":"Function to find the maximum profit with transaction fee","code":"def MaxProfit ( arr , n , transactionFee ) : NEW_LINE INDENT buy = - arr [ 0 ] NEW_LINE sell = 0 NEW_LINE DEDENT"}
{"text":"Traversing the stocks for each day","code":"for i in range ( 1 , n , 1 ) : NEW_LINE INDENT temp = buy NEW_LINE DEDENT"}
{"text":"Update buy and sell","code":"buy = max ( buy , sell - arr [ i ] ) NEW_LINE sell = max ( sell , temp + arr [ i ] - transactionFee ) NEW_LINE"}
{"text":"Return the maximum profit","code":"return max ( sell , buy ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Input","code":"arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE transactionFee = 2 NEW_LINE"}
{"text":"Function Call","code":"print ( MaxProfit ( arr , n , transactionFee ) ) NEW_LINE"}
{"text":"Stores the maximum path sum from the cell ( 1 , 1 ) to ( N , M )","code":"start = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE"}
{"text":"Stores the maximum path sum from the cell ( j , j ) to ( N , M )","code":"ending = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE"}
{"text":"Function to find the maximum path sum from the cell ( 1 , 1 ) to ( N , M )","code":"def calculateStart ( n , m ) : NEW_LINE"}
{"text":"Traverse the first row","code":"for i in range ( 1 , m , 1 ) : NEW_LINE INDENT start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] NEW_LINE DEDENT"}
{"text":"Traverse the first column","code":"for i in range ( 1 , n , 1 ) : NEW_LINE INDENT start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] NEW_LINE DEDENT"}
{"text":"Traverse the matrix","code":"for i in range ( 1 , n , 1 ) : NEW_LINE INDENT for j in range ( 1 , m , 1 ) : NEW_LINE DEDENT"}
{"text":"Update the value of start [ i ] [ j ]","code":"start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) NEW_LINE"}
{"text":"Function to find the maximum path sum from the cell ( j , j ) to ( N , M )","code":"def calculateEnd ( n , m ) : NEW_LINE"}
{"text":"Traverse the last row","code":"i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT"}
{"text":"Traverse the last column","code":"i = m - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT"}
{"text":"Traverse the matrix","code":"i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = m - 2 NEW_LINE while ( j >= 0 ) : NEW_LINE DEDENT"}
{"text":"Update the value of ending [ i ] [ j ]","code":"ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) NEW_LINE j -= 1 NEW_LINE i -= 1 NEW_LINE"}
{"text":"Function to find the maximum path sum from the top - left to the bottom right cell such that path contains one of the cells in the array coordinates [ ] [ ]","code":"def maximumPathSum ( mat , n , m , q , coordinates ) : NEW_LINE"}
{"text":"Initialize the start and the end matrices","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT start [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE ending [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT"}
{"text":"Calculate the start matrix","code":"calculateStart ( n , m ) NEW_LINE"}
{"text":"Calculate the end matrix","code":"calculateEnd ( n , m ) NEW_LINE"}
{"text":"Stores the maximum path sum","code":"ans = 0 NEW_LINE"}
{"text":"Traverse the coordinates","code":"for i in range ( q ) : NEW_LINE INDENT X = coordinates [ i ] [ 0 ] - 1 NEW_LINE Y = coordinates [ i ] [ 1 ] - 1 NEW_LINE DEDENT"}
{"text":"Update the value of ans","code":"ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) NEW_LINE"}
{"text":"Print the resultant maximum sum path value","code":"print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE N = 3 NEW_LINE M = 3 NEW_LINE Q = 2 NEW_LINE coordinates = [ [ 1 , 2 ] , [ 2 , 2 ] ] NEW_LINE maximumPathSum ( mat , N , M , Q , coordinates ) NEW_LINE DEDENT"}
{"text":"Function to find the length of the longest subset of an array of strings with at most A 0 s and B 1 s","code":"def MaxSubsetlength ( arr , A , B ) : NEW_LINE"}
{"text":"Initialize a 2D array with its entries as 0","code":"dp = [ [ 0 for i in range ( B + 1 ) ] for i in range ( A + 1 ) ] NEW_LINE"}
{"text":"Traverse the given array","code":"for str in arr : NEW_LINE"}
{"text":"Store the count of 0 s and 1 s in the current string","code":"zeros = str . count ( '0' ) NEW_LINE ones = str . count ( '1' ) NEW_LINE"}
{"text":"Iterate in the range [ A , zeros ]","code":"for i in range ( A , zeros - 1 , - 1 ) : NEW_LINE"}
{"text":"Iterate in the range [ B , ones ]","code":"for j in range ( B , ones - 1 , - 1 ) : NEW_LINE"}
{"text":"Update the value of dp [ i ] [ j ]","code":"dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) NEW_LINE"}
{"text":"Print the result","code":"return dp [ A ] [ B ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" ] NEW_LINE A , B = 5 , 3 NEW_LINE print ( MaxSubsetlength ( arr , A , B ) ) NEW_LINE DEDENT"}
{"text":"Function to count ways to select N distinct pairs of candies with different colours","code":"def numOfWays ( a , n , i = 0 , blue = [ ] ) : NEW_LINE"}
{"text":"If n pairs are selected","code":"if i == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Stores count of ways to select the i - th pair","code":"count = 0 NEW_LINE"}
{"text":"Iterate over the range [ 0 , n ]","code":"for j in range ( n ) : NEW_LINE"}
{"text":"If pair ( i , j ) is not included","code":"if mat [ i ] [ j ] == 1 and j not in blue : NEW_LINE INDENT count += numOfWays ( mat , n , i + 1 , blue + [ j ] ) NEW_LINE DEDENT return count NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 0 , 1 , 1 ] , [ 1 , 0 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( numOfWays ( mat , n ) ) NEW_LINE DEDENT"}
{"text":"Function to find the minimum cost to reach the end of an array","code":"def minCost ( arr , n ) : NEW_LINE"}
{"text":"Base Case : When N < 3","code":"if ( n < 3 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Store the results in table","code":"dp = [ 0 ] * n NEW_LINE"}
{"text":"Initialize base cases","code":"dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] NEW_LINE"}
{"text":"Iterate over the range [ 2 , N - 2 ] to construct the dp array","code":"for i in range ( 2 , n - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT"}
{"text":"Handle case for the last index , i . e . N - 1","code":"dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) NEW_LINE"}
{"text":"Print the answer","code":"print ( dp [ n - 1 ] ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 4 , 6 , 8 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE minCost ( arr , N ) NEW_LINE DEDENT"}
{"text":"Python3 program to implement the above approach","code":"M = 1000000007 NEW_LINE"}
{"text":"Function to find the value of power ( X , Y ) in O ( log Y )","code":"def power ( X , Y ) : NEW_LINE"}
{"text":"Stores power ( X , Y )","code":"res = 1 NEW_LINE"}
{"text":"Update X","code":"X = X % M NEW_LINE"}
{"text":"Base Case","code":"if ( X == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Calculate power ( X , Y )","code":"while ( Y > 0 ) : NEW_LINE"}
{"text":"If Y is an odd number","code":"if ( Y & 1 ) : NEW_LINE"}
{"text":"Update res","code":"res = ( res * X ) % M NEW_LINE"}
{"text":"Update Y","code":"Y = Y >> 1 NEW_LINE"}
{"text":"Update X","code":"X = ( X * X ) % M NEW_LINE return res NEW_LINE"}
{"text":"Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"def findValue ( n ) : NEW_LINE"}
{"text":"Stores binary representation of n","code":"X = 0 NEW_LINE"}
{"text":"Stores power of 10","code":"pow_10 = 1 NEW_LINE"}
{"text":"Calculate the binary representation of n","code":"while ( n ) : NEW_LINE"}
{"text":"If n is an odd number","code":"if ( n & 1 ) : NEW_LINE"}
{"text":"Update X","code":"X += pow_10 NEW_LINE"}
{"text":"Update pow_10","code":"pow_10 *= 10 NEW_LINE"}
{"text":"Update n","code":"n \/\/= 2 NEW_LINE"}
{"text":"Double the value of X","code":"X = ( X * 2 ) % M NEW_LINE"}
{"text":"Stores the value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"res = power ( 2 , X ) NEW_LINE return res NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( findValue ( n ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to implement the above approach","code":"M = 1000000007 ; NEW_LINE"}
{"text":"Function to find the value of power ( X , Y ) in O ( log Y )","code":"def power ( X , Y ) : NEW_LINE"}
{"text":"Stores power ( X , Y )","code":"res = 1 ; NEW_LINE"}
{"text":"Update X","code":"X = X % M ; NEW_LINE"}
{"text":"Base Case","code":"if ( X == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Calculate power ( X , Y )","code":"while ( Y > 0 ) : NEW_LINE"}
{"text":"If Y is an odd number","code":"if ( Y % 2 == 1 ) : NEW_LINE"}
{"text":"Update res","code":"res = ( res * X ) % M ; NEW_LINE"}
{"text":"Update Y","code":"Y = Y >> 1 ; NEW_LINE"}
{"text":"Update X","code":"X = ( X * X ) % M ; NEW_LINE return res ; NEW_LINE"}
{"text":"Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"def findValue ( N ) : NEW_LINE"}
{"text":"dp [ N ] * dp [ N ] : Stores value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )","code":"dp = [ 0 ] * ( N + 1 ) ; NEW_LINE"}
{"text":"Base Case","code":"dp [ 1 ] = 2 ; NEW_LINE dp [ 2 ] = 1024 ; NEW_LINE"}
{"text":"Iterate over the range [ 3 , N ]","code":"for i in range ( 3 , N + 1 ) : NEW_LINE"}
{"text":"Stores rightmost bit of i","code":"y = ( i & ( - i ) ) ; NEW_LINE"}
{"text":"Stores the value of ( i - y )","code":"x = i - y ; NEW_LINE"}
{"text":"If x is power of 2","code":"if ( x == 0 ) : NEW_LINE"}
{"text":"Update dp [ i ]","code":"dp [ i ] = power ( dp [ i \/\/ 2 ] , 10 ) ; NEW_LINE else : NEW_LINE"}
{"text":"Update dp [ i ]","code":"dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; NEW_LINE return ( dp [ N ] * dp [ N ] ) % M ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 150 ; NEW_LINE print ( findValue ( n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to find the number of ways to get the sum N with throw of dice","code":"def findWays ( N ) : NEW_LINE"}
{"text":"Base case","code":"if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Stores the count of total number of ways to get sum N","code":"cnt = 0 NEW_LINE"}
{"text":"Recur for all 6 states","code":"for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = cnt + findWays ( N - i ) NEW_LINE DEDENT DEDENT"}
{"text":"Return answer","code":"return cnt NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE DEDENT"}
{"text":"Function call","code":"print ( findWays ( N ) ) NEW_LINE"}
{"text":"Utility function to check array can be partition to 3 subsequences of equal sum or not","code":"def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE"}
{"text":"Base case","code":"if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE"}
{"text":"When element at index j is added to sm1","code":"l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE"}
{"text":"When element at index j is added to sm2","code":"m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE"}
{"text":"When element at index j is added to sm3","code":"r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE"}
{"text":"Return maximum value among all above 3 recursive call","code":"return max ( l , m , r ) NEW_LINE"}
{"text":"Function to check array can be partition to 3 subsequences of equal sum or not","code":"def checkEqualSum ( arr , N ) : NEW_LINE"}
{"text":"Initialise 3 sums to 0","code":"sum1 = sum2 = sum3 = 0 NEW_LINE"}
{"text":"Function call","code":"if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Given array arr [ ]","code":"arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE"}
{"text":"Function call","code":"checkEqualSum ( arr , N ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"dp = { } NEW_LINE"}
{"text":"Function to check array can be partition into sum of 3 equal","code":"def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE INDENT s = str ( sm1 ) + \" _ \" + str ( sm2 ) + str ( j ) NEW_LINE DEDENT"}
{"text":"Base Case","code":"if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT"}
{"text":"If value at particular index is not - 1 then return value at that index which ensure no more further calls","code":"if s in dp : NEW_LINE INDENT return dp [ s ] NEW_LINE DEDENT"}
{"text":"When element at index j is added to sm1","code":"l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE"}
{"text":"When element at index j is added to sm2","code":"m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE"}
{"text":"When element at index j is added to sm3","code":"r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE"}
{"text":"Update the current state and return that value","code":"dp [ s ] = max ( l , m , r ) NEW_LINE return dp [ s ] NEW_LINE"}
{"text":"Function to check array can be partition to 3 subsequences of equal sum or not","code":"def checkEqualSum ( arr , N ) : NEW_LINE"}
{"text":"Initialise 3 sums to 0","code":"sum1 = sum2 = sum3 = 0 NEW_LINE"}
{"text":"Function Call","code":"if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Given array arr [ ]","code":"arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE"}
{"text":"Function call","code":"checkEqualSum ( arr , N ) NEW_LINE"}
{"text":"Precompute the index of next different element in the array for every array element","code":"def precompute ( nextpos , arr , N ) : NEW_LINE"}
{"text":"Default value","code":"nextpos [ N - 1 ] = N NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE"}
{"text":"Compute nextpos [ i ] using nextpos [ i + 1 ]","code":"if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT nextpos [ i ] = nextpos [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nextpos [ i ] = i + 1 NEW_LINE DEDENT"}
{"text":"Function to return the smallest index","code":"def findIndex ( query , arr , N , Q ) : NEW_LINE"}
{"text":"nextpos [ i ] will store the next position p where arr [ p ] != arr [ i ]","code":"nextpos = [ 0 ] * N NEW_LINE precompute ( nextpos , arr , N ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE x = query [ i ] [ 2 ] NEW_LINE ans = - 1 NEW_LINE DEDENT"}
{"text":"If X is not present at l","code":"if arr [ l ] != x : NEW_LINE INDENT ans = l NEW_LINE DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Find the index which stores a value different from X","code":"d = nextpos [ l ] NEW_LINE"}
{"text":"If that index is within the range","code":"if d <= r : NEW_LINE INDENT ans = d NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"text":"Driver code","code":"N = 6 NEW_LINE Q = 3 NEW_LINE arr = [ 1 , 2 , 1 , 1 , 3 , 5 ] NEW_LINE query = [ [ 0 , 3 , 1 ] , [ 1 , 5 , 2 ] , [ 2 , 3 , 1 ] ] NEW_LINE findIndex ( query , arr , N , Q ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"mod = 1000000007 NEW_LINE"}
{"text":"Function to count number of ways to convert string S to string T by performing K cyclic shifts","code":"def countWays ( s , t , k ) : NEW_LINE"}
{"text":"Calculate length of string","code":"n = len ( s ) NEW_LINE"}
{"text":"a is no . of good cyclic shifts b is no . of bad cyclic shifts","code":"a = 0 NEW_LINE b = 0 NEW_LINE"}
{"text":"Iterate in string","code":"for i in range ( n ) : NEW_LINE INDENT p = s [ i : n - i + 1 ] + s [ : i + 1 ] NEW_LINE DEDENT"}
{"text":"Precompute the number of good and bad cyclic shifts","code":"if ( p == t ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT"}
{"text":"dp2 [ i ] to store the no of ways to get to a bad shift in i moves","code":"dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if ( s == t ) : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ 0 ] = 0 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT"}
{"text":"Calculate good and bad shifts","code":"for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod NEW_LINE DEDENT"}
{"text":"Return the required number of ways","code":"return ( dp1 [ k ] ) NEW_LINE"}
{"text":"Given Strings","code":"S = ' ab ' NEW_LINE T = ' ab ' NEW_LINE"}
{"text":"Given K shifts required","code":"K = 2 NEW_LINE"}
{"text":"Function call","code":"print ( countWays ( S , T , K ) ) NEW_LINE"}
{"text":"Function to find minimum operations","code":"def minOperation ( k ) : NEW_LINE"}
{"text":"dp is initialised to store the steps","code":"dp = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE DEDENT"}
{"text":"For all even numbers","code":"if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i \/\/ 2 ] + 1 ) NEW_LINE DEDENT return dp [ k ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 12 NEW_LINE print ( minOperation ( k ) ) NEW_LINE DEDENT"}
{"text":"Function to find the maximum subset sum","code":"def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Ignore the current element","code":"ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE"}
{"text":"including element in partition 1","code":"ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE"}
{"text":"including element in partition 2","code":"ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"size of the array","code":"n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) ; NEW_LINE"}
{"text":"Python3 implementation for the above mentioned Dynamic Programming approach","code":"import numpy as np NEW_LINE import sys NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) NEW_LINE"}
{"text":"Function to find the maximum subset sum","code":"def maxSum ( a , n ) : NEW_LINE"}
{"text":"sum of all elements","code":"sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT limit = 2 * sum + 1 ; NEW_LINE"}
{"text":"bottom up lookup table ;","code":"dp = np . zeros ( ( n + 1 , limit ) ) ; NEW_LINE"}
{"text":"initialising dp table with INT_MIN where , INT_MIN means no solution","code":"for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT dp [ i ] [ j ] = INT_MIN ; NEW_LINE DEDENT DEDENT"}
{"text":"Case when diff is 0","code":"dp [ 0 ] [ sum ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE DEDENT"}
{"text":"Putting ith element in g0","code":"if ( ( j - a [ i - 1 ] ) >= 0 and dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; NEW_LINE DEDENT"}
{"text":"Putting ith element in g1","code":"if ( ( j + a [ i - 1 ] ) < limit and dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; NEW_LINE DEDENT"}
{"text":"Ignoring ith element","code":"if ( dp [ i - 1 ] [ j ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT return dp [ n ] [ sum ] ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( a , n ) ) ; NEW_LINE DEDENT"}
{"text":"Array to find the fibonacci sequence","code":"fib = [ 0 ] * 100005 ; NEW_LINE"}
{"text":"Function to find the fibonacci sequence","code":"def computeFibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 ; NEW_LINE fib [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , 100005 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Function to count all possible strings","code":"def countString ( string ) : NEW_LINE"}
{"text":"Initialize ans = 1","code":"ans = 1 ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE"}
{"text":"If two consecutive char are same increase cnt","code":"if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT"}
{"text":"Else multiply the fib [ cnt ] to ans and initialize ans to 1","code":"else : NEW_LINE INDENT ans = ans * fib [ cnt ] ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT"}
{"text":"If str = abcdeeee , then for last \" eeee \" the count munst be updated","code":"ans = ans * fib [ cnt ] ; NEW_LINE"}
{"text":"Return the total count","code":"return ans ; NEW_LINE"}
{"text":"Driver 's Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abdllldefkkkk \" ; NEW_LINE DEDENT"}
{"text":"Function to precompute all the fibonacci number","code":"computeFibonacci ( ) ; NEW_LINE"}
{"text":"Function call to find the count","code":"print ( countString ( string ) ) ; NEW_LINE"}
{"text":"Python3 program to find the first N terms of Golomb Sequence","code":"MAX = 100001 NEW_LINE"}
{"text":"Function to print the Golomb Sequence","code":"def printGolombSequence ( N ) : NEW_LINE"}
{"text":"Initialise the array","code":"arr = [ 0 ] * MAX NEW_LINE"}
{"text":"Initialise the cnt to 0","code":"cnt = 0 NEW_LINE"}
{"text":"First and second element of Golomb Sequence is 0 , 1","code":"arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE"}
{"text":"Map to store the count of current element in Golomb Sequence","code":"M = dict ( ) NEW_LINE"}
{"text":"Store the count of 2","code":"M [ 2 ] = 2 NEW_LINE"}
{"text":"Iterate over 2 to N","code":"for i in range ( 2 , N + 1 ) : NEW_LINE"}
{"text":"If cnt is equals to 0 then we have new number for Golomb Sequence which is 1 + previous element","code":"if ( cnt == 0 ) : NEW_LINE INDENT arr [ i ] = 1 + arr [ i - 1 ] NEW_LINE cnt = M [ arr [ i ] ] NEW_LINE cnt -= 1 NEW_LINE DEDENT"}
{"text":"Else the current element is the previous element in this Sequence","code":"else : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE cnt -= 1 NEW_LINE DEDENT"}
{"text":"Map the current index to current value in arr [ ]","code":"M [ i ] = arr [ i ] NEW_LINE"}
{"text":"Print the Golomb Sequence","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 11 NEW_LINE printGolombSequence ( N ) NEW_LINE"}
{"text":"Function to find the number the number of ways to reach Nth stair","code":"def number_of_ways ( n ) : NEW_LINE"}
{"text":"Array including number of ways that includes 3","code":"includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE"}
{"text":"Array including number of ways that doesn 't includes 3","code":"not_includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE"}
{"text":"Initially to reach 3 stairs by taking 3 steps can be reached by 1 way","code":"includes_3 [ 3 ] = 1 NEW_LINE not_includes_3 [ 1 ] = 1 NEW_LINE not_includes_3 [ 2 ] = 2 NEW_LINE not_includes_3 [ 3 ] = 3 NEW_LINE"}
{"text":"Loop to find the number the number of ways to reach Nth stair","code":"for i in range ( 4 , n + 1 ) : NEW_LINE INDENT includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] NEW_LINE not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] NEW_LINE DEDENT return includes_3 [ n ] NEW_LINE"}
{"text":"Driver Code","code":"n = 7 NEW_LINE print ( number_of_ways ( n ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"from math import ceil , sqrt NEW_LINE MAX = 100000 NEW_LINE"}
{"text":"Map to store the divisor count","code":"divisors = [ 0 ] * MAX NEW_LINE"}
{"text":"Function to generate the divisors of all the array elements","code":"def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n \/\/ i == i ) : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE divisors [ n \/\/ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT"}
{"text":"Function to find the maximum number of multiples in an array before it","code":"def findMaxMultiples ( arr , n ) : NEW_LINE"}
{"text":"To store the maximum divisor count","code":"ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Update ans if more number of divisors are found","code":"ans = max ( divisors [ arr [ i ] ] , ans ) NEW_LINE"}
{"text":"Generating all the divisors of the next element of the array","code":"generateDivisors ( arr [ i ] ) NEW_LINE return ans NEW_LINE"}
{"text":"Driver code","code":"arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxMultiples ( arr , n ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"n = 3 NEW_LINE maxV = 20 NEW_LINE"}
{"text":"3d array to store states of dp","code":"dp = [ [ [ 0 for i in range ( maxV ) ] for i in range ( n ) ] for i in range ( n ) ] NEW_LINE"}
{"text":"Array to determine whether a state has been solved before","code":"v = [ [ [ 0 for i in range ( maxV ) ] for i in range ( n ) ] for i in range ( n ) ] NEW_LINE"}
{"text":"Function to return the count of required paths","code":"def countWays ( i , j , x , arr ) : NEW_LINE"}
{"text":"Base cases","code":"if ( i == n or j == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = ( x & arr [ i ] [ j ] ) NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"If a state has been solved before it won 't be evaluated again","code":"if ( v [ i ] [ j ] [ x ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT v [ i ] [ j ] [ x ] = 1 NEW_LINE"}
{"text":"Recurrence relation","code":"dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; NEW_LINE return dp [ i ] [ j ] [ x ] NEW_LINE"}
{"text":"Driver code","code":"arr = [ [ 1 , 2 , 1 ] , [ 1 , 1 , 0 ] , [ 2 , 1 , 1 ] ] NEW_LINE print ( countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ) NEW_LINE"}
{"text":"Function to return the maximum sum","code":"def FindMaximumSum ( ind , kon , a , b , c , n , dp ) : NEW_LINE"}
{"text":"Base case","code":"if ind == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Already visited","code":"if dp [ ind ] [ kon ] != - 1 : NEW_LINE INDENT return dp [ ind ] [ kon ] NEW_LINE DEDENT ans = - 10 ** 9 + 5 NEW_LINE"}
{"text":"If the element has been taken from first array in previous step","code":"if kon == 0 : NEW_LINE INDENT ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT"}
{"text":"If the element has been taken from second array in previous step","code":"elif kon == 1 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT"}
{"text":"If the element has been taken from third array in previous step","code":"elif kon == 2 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE DEDENT dp [ ind ] [ kon ] = ans NEW_LINE return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE a = [ 6 , 8 , 2 , 7 , 4 , 2 , 7 ] NEW_LINE b = [ 7 , 8 , 5 , 8 , 6 , 3 , 5 ] NEW_LINE c = [ 8 , 3 , 2 , 6 , 8 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE dp = [ [ - 1 for i in range ( N ) ] for j in range ( n ) ] NEW_LINE DEDENT"}
{"text":"Pick element from first array","code":"x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) NEW_LINE"}
{"text":"Pick element from second array","code":"y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) NEW_LINE"}
{"text":"Pick element from third array","code":"z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) NEW_LINE"}
{"text":"Print the maximum of them","code":"print ( max ( x , y , z ) ) NEW_LINE"}
{"text":"Python3 iimplementation of the above approach","code":"mod = 1000000007 ; NEW_LINE"}
{"text":"Function to return no of ways to build a binary string of length N such that 0 s always occur in groups of size K","code":"def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE K = 2 ; NEW_LINE print ( noOfBinaryStrings ( N , K ) ) ; NEW_LINE DEDENT"}
{"text":"Function to find number of ways to pair people in party","code":"def findWays ( p ) : NEW_LINE"}
{"text":"To store count of number of ways .","code":"dp = [ 0 ] * ( p + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE"}
{"text":"Using the recurrence defined find count for different values of p .","code":"for i in range ( 3 , p + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return dp [ p ] NEW_LINE"}
{"text":"Driver code","code":"p = 3 NEW_LINE print ( findWays ( p ) ) NEW_LINE"}
{"text":"A simple recursive implementation for counting ways to reach a score using 1 and 2 with consecutive 2 allowed","code":"def CountWays ( n ) : NEW_LINE"}
{"text":"base case","code":"if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 1 + 1 NEW_LINE DEDENT"}
{"text":"For cases n > 2","code":"return CountWays ( n - 1 ) + CountWays ( n - 3 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT"}
{"text":"Python 3 program to check if the number is weird or not","code":"from math import sqrt NEW_LINE"}
{"text":"code to find all the factors of the number excluding the number itself","code":"def factors ( n ) : NEW_LINE"}
{"text":"vector to store the factors","code":"v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE"}
{"text":"note that this loop runs till sqrt ( n )","code":"for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE"}
{"text":"if the value of i is a factor","code":"if ( n % i == 0 ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE DEDENT"}
{"text":"condition to check the divisor is not the number itself","code":"if ( int ( n \/ i ) != i ) : NEW_LINE INDENT v . append ( int ( n \/ i ) ) NEW_LINE DEDENT"}
{"text":"return the vector","code":"return v NEW_LINE"}
{"text":"Function to check if the number is abundant or not","code":"def checkAbundant ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT"}
{"text":"find the divisors using function","code":"v = factors ( n ) NEW_LINE"}
{"text":"sum all the factors","code":"for i in range ( len ( v ) ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT"}
{"text":"check for abundant or not","code":"if ( sum > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Function to check if the number is semi - perfect or not","code":"def checkSemiPerfect ( n ) : NEW_LINE"}
{"text":"find the divisors","code":"v = factors ( n ) NEW_LINE"}
{"text":"sorting the vector","code":"v . sort ( reverse = False ) NEW_LINE r = len ( v ) NEW_LINE"}
{"text":"subset to check if no is semiperfect","code":"subset = [ [ 0 for i in range ( n + 1 ) ] for j in range ( r + 1 ) ] NEW_LINE"}
{"text":"initialising 1 st column to true","code":"for i in range ( r + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT"}
{"text":"initialing 1 st row except zero position to 0","code":"for i in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT"}
{"text":"loop to find whether the number is semiperfect","code":"for i in range ( 1 , r + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE DEDENT"}
{"text":"calculation to check if the number can be made by summation of divisors","code":"if ( j < v [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - v [ i - 1 ] ] ) NEW_LINE DEDENT"}
{"text":"if not possible to make the number by any combination of divisors","code":"if ( ( subset [ r ] [ n ] ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"Function to check for weird or not","code":"def checkweird ( n ) : NEW_LINE INDENT if ( checkAbundant ( n ) == True and checkSemiPerfect ( n ) == False ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 70 NEW_LINE if ( checkweird ( n ) ) : NEW_LINE INDENT print ( \" Weird \u2581 Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Weird \u2581 Number \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Returns sum of maximum sum subarray created after concatenating a [ 0. . n - 1 ] k times .","code":"def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE DEDENT"}
{"text":"This is where it differs from Kadane 's  algorithm. We use  modular arithmetic to  find next element.","code":"max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT return max_so_far NEW_LINE"}
{"text":"Driver program to test maxSubArraySum","code":"a = [ 10 , 20 , - 30 , - 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" , maxSubArraySumRepeated ( a , n , k ) ) NEW_LINE"}
{"text":"function to find the longest increasing odd even subsequence","code":"def longOddEvenIncSeq ( arr , n ) : NEW_LINE"}
{"text":"lioes [ i ] stores longest increasing odd even subsequence ending at arr [ i ]","code":"lioes = list ( ) NEW_LINE"}
{"text":"to store the length of longest increasing odd even subsequence","code":"maxLen = 0 NEW_LINE"}
{"text":"Initialize LIOES values for all indexes","code":"for i in range ( n ) : NEW_LINE INDENT lioes . append ( 1 ) NEW_LINE DEDENT"}
{"text":"Compute optimized LIOES values in bottom up manner","code":"i = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Pick maximum of all LIOES values","code":"for i in range ( n ) : NEW_LINE INDENT if maxLen < lioes [ i ] : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"required maximum length","code":"return maxLen NEW_LINE"}
{"text":"Driver to test above","code":"arr = [ 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Longest \u2581 Increasing \u2581 Odd \u2581 Even \u2581 \" + \" Subsequence : \u2581 \" , longOddEvenIncSeq ( arr , n ) ) NEW_LINE"}
{"text":"Utility method to check whether a character is operator or not","code":"def isOperator ( op ) : NEW_LINE INDENT return ( op == ' + ' or op == ' * ' ) NEW_LINE DEDENT"}
{"text":"method prints minimum and maximum value obtainable from an expression","code":"def printMinAndMaxValueOfExp ( exp ) : NEW_LINE INDENT num = [ ] NEW_LINE opr = [ ] NEW_LINE tmp = \" \" NEW_LINE DEDENT"}
{"text":"store operator and numbers in different vectors","code":"for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( isOperator ( exp [ i ] ) ) : NEW_LINE INDENT opr . append ( exp [ i ] ) NEW_LINE num . append ( int ( tmp ) ) NEW_LINE tmp = \" \" NEW_LINE DEDENT else : NEW_LINE INDENT tmp += exp [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"storing last number in vector","code":"num . append ( int ( tmp ) ) NEW_LINE llen = len ( num ) NEW_LINE minVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE maxVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE"}
{"text":"initializing minval and maxval 2D array","code":"for i in range ( llen ) : NEW_LINE INDENT for j in range ( llen ) : NEW_LINE INDENT minVal [ i ] [ j ] = 10 ** 9 NEW_LINE maxVal [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT"}
{"text":"initializing main diagonal by num values","code":"if ( i == j ) : NEW_LINE INDENT minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] NEW_LINE DEDENT"}
{"text":"looping similar to matrix chain multiplication and updating both 2D arrays","code":"for L in range ( 2 , llen + 1 ) : NEW_LINE INDENT for i in range ( llen - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT minTmp = 0 NEW_LINE maxTmp = 0 NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"if current operator is ' + ' , updating tmp variable by addition","code":"if ( opr [ k ] == ' + ' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT"}
{"text":"if current operator is ' * ' , updating tmp variable by multiplication","code":"elif ( opr [ k ] == ' * ' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT"}
{"text":"updating array values by tmp variables","code":"if ( minTmp < minVal [ i ] [ j ] ) : NEW_LINE INDENT minVal [ i ] [ j ] = minTmp NEW_LINE DEDENT if ( maxTmp > maxVal [ i ] [ j ] ) : NEW_LINE INDENT maxVal [ i ] [ j ] = maxTmp NEW_LINE DEDENT"}
{"text":"last element of first row will store the result","code":"print ( \" Minimum \u2581 value \u2581 : \u2581 \" , minVal [ 0 ] [ llen - 1 ] , \" , \u2581 \\ \u2581 Maximum \u2581 value \u2581 : \u2581 \" , maxVal [ 0 ] [ llen - 1 ] ) NEW_LINE"}
{"text":"Driver code","code":"expression = \"1 + 2*3 + 4*5\" NEW_LINE printMinAndMaxValueOfExp ( expression ) NEW_LINE"}
{"text":"A naive recursive implementation that simply follows the above optimal substructure property","code":"import sys NEW_LINE"}
{"text":"Matrix A [ i ] has dimension p [ i - 1 ] x p [ i ] for i = 1. . n","code":"def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE DEDENT"}
{"text":"place parenthesis at different places between first and last matrix , recursively calculate count of multiplications for each parenthesis placement and return the minimum count","code":"for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT"}
{"text":"Return minimum count","code":"return _min NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" , MatrixChainOrder ( arr , 1 , n - 1 ) ) NEW_LINE"}
{"text":"Python program using memoization","code":"import sys NEW_LINE dp = [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE"}
{"text":"Function for matrix chain multiplication","code":"def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \" , MatrixChainOrder ( arr , n ) ) NEW_LINE"}
{"text":"Function to flip bits of A and B which are set in both of them","code":"def flipBitsOfAandB ( A , B ) : NEW_LINE"}
{"text":"Clear the bits of A which are set in both A and B","code":"A = A ^ ( A & B ) NEW_LINE"}
{"text":"Clear the bits of B which are set in both A and B","code":"B = B ^ ( A & B ) NEW_LINE"}
{"text":"Print updated A and B","code":"print ( A , B ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 10 NEW_LINE B = 20 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT"}
{"text":"Function to calculate and return the hamming distance between all consecutive numbers from 0 to N","code":"def TotalHammingDistance ( n ) : NEW_LINE INDENT i = 1 NEW_LINE sum = 0 NEW_LINE while ( n \/\/ i > 0 ) : NEW_LINE INDENT sum = sum + n \/\/ i NEW_LINE i = i * 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE print ( TotalHammingDistance ( N ) ) NEW_LINE DEDENT"}
{"text":"Python3 Program to implement the above approach","code":"import math NEW_LINE m = 1000000007 NEW_LINE"}
{"text":"Function to find the sum of all divisors of all numbers from 1 to N","code":"def solve ( n ) : NEW_LINE"}
{"text":"Stores the sum","code":"s = 0 ; NEW_LINE l = 1 ; NEW_LINE while ( l < n + 1 ) : NEW_LINE"}
{"text":"Marks the last poof occurence with same count","code":"r = ( int ) ( n \/ math . floor ( n \/ l ) ) ; NEW_LINE x = ( ( ( ( r % m ) * ( ( r + 1 ) % m ) ) \/ 2 ) % m ) ; NEW_LINE y = ( ( ( ( l % m ) * ( ( l - 1 ) % m ) ) \/ 2 ) % m ) ; NEW_LINE p = ( int ) ( ( n \/ l ) % m ) ; NEW_LINE"}
{"text":"Calculate the sum","code":"s = ( ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ) ; NEW_LINE s %= m ; NEW_LINE l = r + 1 ; NEW_LINE"}
{"text":"Return the result","code":"print ( int ( ( s + m ) % m ) ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"}
{"text":"Python3 program to find minimum time required to split a stick of N length into unit pieces","code":"import math NEW_LINE"}
{"text":"Function to return the minimum time required to split stick of N into length into unit pieces","code":"def min_time_to_cut ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT"}
{"text":"Return the minimum unit of time required","code":"return int ( math . log2 ( N ) ) + 1 NEW_LINE"}
{"text":"Driver Code","code":"N = 100 NEW_LINE print ( min_time_to_cut ( N ) ) NEW_LINE"}
{"text":"Function to find the distinct sums","code":"def findDistinctSums ( n ) : NEW_LINE"}
{"text":"Set to store distinct sums","code":"s = set ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE DEDENT"}
{"text":"Inserting every sum","code":"s . add ( i + j ) NEW_LINE"}
{"text":"Returning distinct sums","code":"return len ( s ) NEW_LINE"}
{"text":"Driver code","code":"N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE"}
{"text":"Function to print pattern recursively","code":"def printPattern ( i , j , n ) : NEW_LINE"}
{"text":"Base Case","code":"if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Conditions to print slash","code":"if ( j == i or j == n - 1 - i ) : NEW_LINE"}
{"text":"Condition to print forword slash","code":"if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" \/ \" , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Condition to print backward slash","code":"else : NEW_LINE INDENT print ( \" \\\\ \" , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Else print '*","code":"' NEW_LINE INDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Recursive call for rows","code":"if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Recursive call for changing the rows","code":"return printPattern ( i + 1 , 0 , n ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE DEDENT"}
{"text":"Function Call","code":"printPattern ( 0 , 0 , N ) NEW_LINE"}
{"text":"Python3 implementation for pattern searching in an array using Z - Algorithm","code":"import sys ; NEW_LINE"}
{"text":"Function to calculate Z - Array","code":"def zArray ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE z = [ 0 ] * n ; NEW_LINE r = 0 ; NEW_LINE l = 0 ; NEW_LINE DEDENT"}
{"text":"Loop to calculate Z - Array","code":"for k in range ( 1 , n ) : NEW_LINE"}
{"text":"Outside the Z - box","code":"if ( k > r ) : NEW_LINE INDENT r = l = k ; NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 ; NEW_LINE DEDENT z [ k ] = r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT"}
{"text":"Inside Z - box","code":"else : NEW_LINE INDENT k1 = k - l ; NEW_LINE if ( z [ k1 ] < r - k + 1 ) : NEW_LINE INDENT z [ k ] = z [ k1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT l = k ; NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 ; NEW_LINE DEDENT z [ k ] = r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT return z ; NEW_LINE"}
{"text":"Helper function to merge two arrays and create a single array","code":"def mergeArray ( A , B ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE m = len ( B ) ; NEW_LINE DEDENT"}
{"text":"Array to store merged array","code":"c = [ 0 ] * ( n + m + 1 ) ; NEW_LINE"}
{"text":"Copying array B","code":"for i in range ( m ) : NEW_LINE INDENT c [ i ] = B [ i ] ; NEW_LINE DEDENT"}
{"text":"Adding a separator","code":"c [ m ] = sys . maxsize ; NEW_LINE"}
{"text":"Copying array A","code":"for i in range ( n ) : NEW_LINE INDENT c [ m + i + 1 ] = A [ i ] ; NEW_LINE DEDENT"}
{"text":"Calling Z - function","code":"z = zArray ( c ) ; NEW_LINE return z ; NEW_LINE"}
{"text":"Function to help compute the Z array","code":"def findZArray ( A , B , n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE z = mergeArray ( A , B ) ; NEW_LINE DEDENT"}
{"text":"Printing indexes where array B occur","code":"for i in range ( len ( z ) ) : NEW_LINE INDENT if ( z [ i ] == n ) : NEW_LINE INDENT print ( i - n - 1 , end = \" \u2581 \" ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" Not \u2581 Found \" ) ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 2 , 3 , 2 ] ; NEW_LINE B = [ 2 , 3 ] ; NEW_LINE n = len ( B ) ; NEW_LINE findZArray ( A , B , n ) ; NEW_LINE DEDENT"}
{"text":"Function to return the count of repetitions of string a to generate string b","code":"def getCount ( a , b ) : NEW_LINE"}
{"text":"If b cannot be generated by repeating a","code":"if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT count = int ( len ( b ) \/ len ( a ) ) NEW_LINE"}
{"text":"Repeat a count number of times","code":"a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = ' geeks ' NEW_LINE b = ' geeksgeeks ' NEW_LINE print ( getCount ( a , b ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to Check if a given string can be formed from another string using given constraints","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function to check if S2 can be formed of S1","code":"def check ( S1 , S2 ) : NEW_LINE"}
{"text":"length of strings","code":"n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE"}
{"text":"hash - table to store count","code":"mp = defaultdict ( lambda : 0 ) NEW_LINE"}
{"text":"store count of each character","code":"for i in range ( 0 , n1 ) : NEW_LINE INDENT mp [ S1 [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"traverse and check for every character","code":"for i in range ( 0 , n2 ) : NEW_LINE"}
{"text":"if the character of s2 is present in s1","code":"if mp [ S2 [ i ] ] : NEW_LINE INDENT mp [ S2 [ i ] ] -= 1 NEW_LINE DEDENT"}
{"text":"if the character of s2 is not present in S1 , then check if previous two ASCII characters are present in S1","code":"elif ( mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] and mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] ) : NEW_LINE INDENT mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] -= 1 NEW_LINE mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S1 = \" abbat \" NEW_LINE S2 = \" cat \" NEW_LINE DEDENT"}
{"text":"Calling function to check","code":"if check ( S1 , S2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Returns count of occurrences of \"1(0 + ) 1\"","code":"def countPattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE oneSeen = False NEW_LINE DEDENT"}
{"text":"count = 0 Initialize result","code":"for i in range ( length ) : NEW_LINE"}
{"text":"Check if encountered '1' forms a valid pattern as specified","code":"if ( s [ i ] == '1' and oneSeen ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT"}
{"text":"if 1 encountered for first time set oneSeen to 1","code":"if ( s [ i ] == '1' and oneSeen == 0 ) : NEW_LINE INDENT oneSeen = True NEW_LINE DEDENT"}
{"text":"Check if there is any other character other than '0' or '1' . If so then set oneSeen to 0 to search again for new pattern","code":"if ( s [ i ] != '0' and s [ i ] != '1' ) : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT return count NEW_LINE"}
{"text":"Driver code","code":"s = \"100001abc101\" NEW_LINE print countPattern ( s ) NEW_LINE"}
{"text":"Function to check if it possible to make all the strings equal to the T","code":"def checkIfPossible ( N , arr , T ) : NEW_LINE"}
{"text":"Stores the frequency of all the strings in the array arr [ ]","code":"freqS = [ 0 ] * 256 NEW_LINE"}
{"text":"Stores the frequency of the T","code":"freqT = [ 0 ] * 256 NEW_LINE"}
{"text":"Iterate over the characters of the T","code":"for ch in T : NEW_LINE INDENT freqT [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT"}
{"text":"Iterate in the range [ 0 , N - 1 ]","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Iterate over the characters of the arr [ i ]","code":"for ch in arr [ i ] : NEW_LINE INDENT freqS [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE"}
{"text":"If freqT [ i ] is 0 and freqS [ i ] is not 0","code":"if ( freqT [ i ] == 0 and freqS [ i ] != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT"}
{"text":"If freqS [ i ] is 0 and freqT [ i ] is not 0","code":"elif ( freqS [ i ] == 0 and freqT [ i ] != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT"}
{"text":"If freqS [ i ] is not freqT [ i ] * N","code":"elif ( freqT [ i ] != 0 and freqS [ i ] != ( freqT [ i ] * N ) ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT"}
{"text":"Otherwise , return \" Yes \"","code":"return \" Yes \" NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" abc \" , \" abb \" , \" acc \" ] NEW_LINE T = \" abc \" NEW_LINE N = len ( arr ) NEW_LINE print ( checkIfPossible ( N , arr , T ) ) NEW_LINE DEDENT"}
{"text":"Function to find the number of the groups of 1 s only in the binary string","code":"def groupsOfOnes ( S , N ) : NEW_LINE"}
{"text":"Stores number of groups of 1 s","code":"count = 0 NEW_LINE"}
{"text":"Initialization of the stack","code":"st = [ ] NEW_LINE"}
{"text":"Traverse the string S","code":"for i in range ( N ) : NEW_LINE"}
{"text":"If S [ i ] is '1","code":"' NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT st . append ( 1 ) NEW_LINE DEDENT DEDENT"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"If st is empty","code":"if ( len ( st ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT del st [ - 1 ] NEW_LINE DEDENT DEDENT"}
{"text":"If st is not empty","code":"if ( len ( st ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Return answer","code":"return count NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Input","code":"S = \"100110111\" NEW_LINE N = len ( S ) NEW_LINE"}
{"text":"Function call","code":"print ( groupsOfOnes ( S , N ) ) NEW_LINE"}
{"text":"Function to print all palindromic strings of length 3 that can be formed using characters of string S","code":"def generatePalindrome ( S ) : NEW_LINE"}
{"text":"Stores the count of character","code":"Hash = { } NEW_LINE"}
{"text":"Traverse the string S","code":"for ch in S : NEW_LINE INDENT Hash [ ch ] = Hash . get ( ch , 0 ) + 1 NEW_LINE DEDENT"}
{"text":"Stores all palindromic strings","code":"st = { } NEW_LINE"}
{"text":"Iterate over the charchaters over the range [ ' a ' , ' z ' ]","code":"for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE"}
{"text":"If Hash [ ch ] is equal to 2","code":"if ( chr ( i ) in Hash and Hash [ chr ( i ) ] == 2 ) : NEW_LINE"}
{"text":"Iterate over the characters over the range [ ' a ' , ' z ' ]","code":"for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE"}
{"text":"Stores all the palindromic string","code":"s = \" \" NEW_LINE if ( chr ( j ) in Hash and i != j ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE s += chr ( i ) NEW_LINE DEDENT"}
{"text":"Push the s into the set st","code":"st [ s ] = 1 NEW_LINE"}
{"text":"If Hash [ i ] is greater than or equal to 3","code":"if ( ( chr ( i ) in Hash ) and Hash [ chr ( i ) ] >= 3 ) : NEW_LINE"}
{"text":"Iterate over charchaters over the range [ ' a ' , ' z ' ]","code":"for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE"}
{"text":"Stores all the palindromic string","code":"s = \" \" NEW_LINE"}
{"text":"If Hash [ j ] is positive","code":"if ( chr ( j ) in Hash ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE s += chr ( i ) NEW_LINE DEDENT"}
{"text":"Push s into the set st","code":"st [ s ] = 1 NEW_LINE"}
{"text":"Iterate over the set","code":"for ans in st : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" ddabdac \" NEW_LINE generatePalindrome ( S ) NEW_LINE DEDENT"}
{"text":"Function to count occurrences of the string Y in the string S for every occurrence of X in S","code":"def countOccurrences ( S , X , Y ) : NEW_LINE"}
{"text":"Stores the count of occurrences of X","code":"count = 0 NEW_LINE"}
{"text":"Stores the lengths of the three strings","code":"N = len ( S ) NEW_LINE A = len ( X ) NEW_LINE B = len ( Y ) NEW_LINE"}
{"text":"Traverse the string S","code":"for i in range ( 0 , N ) : NEW_LINE"}
{"text":"If the current substring is Y , then increment the value of count by 1","code":"if ( S [ i : i + B ] == Y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"If the current substring is X , then print the count","code":"if ( S [ i : i + A ] == X ) : NEW_LINE INDENT print ( count , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"S = \" abcdefdefabc \" NEW_LINE X = \" abc \" NEW_LINE Y = \" def \" NEW_LINE countOccurrences ( S , X , Y ) NEW_LINE"}
{"text":"Function to find whether the given is Accepted by the DFA","code":"def DFA ( str , N ) : NEW_LINE"}
{"text":"If n <= 1 , then prNo","code":"if ( N <= 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"To count the matched characters","code":"count = 0 NEW_LINE"}
{"text":"Check if the first character is C","code":"if ( str [ 0 ] == ' C ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Traverse the rest of string","code":"for i in range ( 1 , N ) : NEW_LINE"}
{"text":"If character is A or B , increment count by 1","code":"if ( str [ i ] == ' A ' or str [ i ] == ' B ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE"}
{"text":"If the first character is not C , pr - 1","code":"print ( \" No \" ) NEW_LINE return NEW_LINE"}
{"text":"If all characters matches","code":"if ( count == N ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" CAABBAAB \" NEW_LINE N = len ( str ) NEW_LINE DFA ( str , N ) NEW_LINE DEDENT"}
{"text":"Function to find the maximum and minimum number of digits to be removed to make str divisible by 3","code":"def minMaxDigits ( str , N ) : NEW_LINE"}
{"text":"Convert the string into array of digits","code":"arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] = ( ord ( str [ i ] ) - ord ( '0' ) ) % 3 NEW_LINE DEDENT"}
{"text":"Count of 0 s , 1 s , and 2 s","code":"zero = 0 NEW_LINE one = 0 NEW_LINE two = 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Find the sum of digits % 3","code":"sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = ( sum + arr [ i ] ) % 3 NEW_LINE DEDENT"}
{"text":"Cases to find minimum number of digits to be removed","code":"if ( sum == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT if ( one and N > 1 ) : NEW_LINE INDENT print ( \"1\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( two > 1 and N > 2 ) : NEW_LINE INDENT print ( \"2\" , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if ( sum == 2 ) : NEW_LINE INDENT if ( two and N > 1 ) : NEW_LINE INDENT print ( \"1\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( one > 1 and N > 2 ) : NEW_LINE INDENT print ( \"2\" , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Cases to find maximum number of digits to be removed","code":"if ( zero > 0 ) : NEW_LINE INDENT print ( N - 1 , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( one > 0 and two > 0 ) : NEW_LINE INDENT print ( N - 2 , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( one > 2 or two > 2 ) : NEW_LINE INDENT print ( N - 3 , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"str = \"12345\" NEW_LINE N = len ( str ) NEW_LINE"}
{"text":"Function Call","code":"minMaxDigits ( str , N ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to find the minimum number of changes to make the string K - periodic and palindrome","code":"def findMinimumChanges ( N , K , S ) : NEW_LINE"}
{"text":"Initialize ans with 0","code":"ans = 0 NEW_LINE"}
{"text":"Iterate from 0 to ( K + 1 ) \/ 2","code":"for i in range ( ( K + 1 ) \/\/ 2 ) : NEW_LINE"}
{"text":"Store frequency of character","code":"mp = { } NEW_LINE"}
{"text":"Iterate through all indices , i , i + K , i + 2 k ... . and store the frequency of character","code":"for j in range ( i , N , K ) : NEW_LINE"}
{"text":"Increase the frequency of current character","code":"mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE"}
{"text":"Iterate through all indices K - i , 2 K - i , 3 K - i ... . and store the frequency of character","code":"j = N - i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE"}
{"text":"If K is odd & i is samw as K \/ 2 , break the loop","code":"if ( ( K & 1 ) and ( i == K \/\/ 2 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Increase the frequency of current character","code":"mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE j -= K NEW_LINE"}
{"text":"Find the maximum frequency of a character among all visited characters","code":"curr_max = - sys . maxsize - 1 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT curr_max = max ( curr_max , value ) NEW_LINE DEDENT"}
{"text":"If K is odd and i is same as K \/ 2 then , only N \/ K characters is visited","code":"if ( ( K & 1 ) and ( i == K \/\/ 2 ) ) : NEW_LINE INDENT ans += ( N \/\/ K - curr_max ) NEW_LINE DEDENT"}
{"text":"Otherwise N \/ K * 2 characters has visited","code":"else : NEW_LINE INDENT ans += ( N \/\/ K * 2 - curr_max ) NEW_LINE DEDENT"}
{"text":"Return the result","code":"return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aabbcbbcb \" NEW_LINE N = len ( S ) NEW_LINE K = 3 NEW_LINE DEDENT"}
{"text":"Function Call","code":"print ( findMinimumChanges ( N , K , S ) ) NEW_LINE"}
{"text":"Function to check if any index contains more than K active characters","code":"def checkString ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT"}
{"text":"Store the last occurrence of each character","code":"dict = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT dict [ s [ i ] ] = i ; NEW_LINE DEDENT"}
{"text":"Stores the active characters","code":"st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Insert the character","code":"st . add ( s [ i ] ) NEW_LINE"}
{"text":"If the size of set exceeds K","code":"if len ( st ) > K : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Remove the character from set if i is the last index of the current character","code":"if dict [ s [ i ] ] == i : NEW_LINE INDENT st . remove ( s [ i ] ) NEW_LINE DEDENT print ( \" No \" ) NEW_LINE"}
{"text":"Driver code","code":"s = \" aabbcdca \" NEW_LINE K = 2 NEW_LINE checkString ( s , K ) NEW_LINE"}
{"text":"Function to count the strings whose distinct characters count is less than M","code":"def distinct ( S , M ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT"}
{"text":"Loop to iterate over all the strings of the array","code":"for i in range ( len ( S ) ) : NEW_LINE"}
{"text":"Distinct characters in the String with the help of set","code":"c = len ( set ( [ d for d in S [ i ] ] ) ) NEW_LINE"}
{"text":"Checking if its less than or equal to M","code":"if ( c <= M ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = [ \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" ] NEW_LINE M = 7 NEW_LINE distinct ( S , M ) NEW_LINE DEDENT"}
{"text":"Function to remove the characters which have odd frequencies in the string","code":"def removeOddFrequencyCharacters ( s ) : NEW_LINE"}
{"text":"Create a map to store the frequency of each character","code":"m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT"}
{"text":"To store the new string","code":"new_s = \" \" NEW_LINE"}
{"text":"Remove the characters which have odd frequencies","code":"for i in s : NEW_LINE"}
{"text":"If the character has odd frequency then skip","code":"if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"Else concatenate the character to the new string","code":"new_s += i NEW_LINE"}
{"text":"Return the modified string","code":"return new_s NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE DEDENT"}
{"text":"Remove the characters which have odd frequencies","code":"str = removeOddFrequencyCharacters ( str ) NEW_LINE print ( str ) NEW_LINE"}
{"text":"Recursive Function to find product of elements at k - th level","code":"def productAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i [ 0 ] ] == ' ( ' ) : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE DEDENT DEDENT"}
{"text":"if subtree is null , just like if root == NULL","code":"if ( tree [ i [ 0 ] ] == ' ) ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT product = 1 NEW_LINE"}
{"text":"Consider only level k node to be part of the product","code":"if ( level == k ) : NEW_LINE INDENT product = int ( tree [ i [ 0 ] ] ) NEW_LINE DEDENT"}
{"text":"Recur for Left Subtree","code":"i [ 0 ] += 1 NEW_LINE leftproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE"}
{"text":"Recur for Right Subtree","code":"i [ 0 ] += 1 NEW_LINE rightproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE"}
{"text":"Taking care of ' ) ' after left and right subtree","code":"i [ 0 ] += 1 NEW_LINE return product * leftproduct * rightproduct NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" NEW_LINE k = 2 NEW_LINE i = [ 0 ] NEW_LINE print ( productAtKthLevel ( tree , k , i , 0 ) ) NEW_LINE DEDENT"}
{"text":"Function to print the most occurring character","code":"def findMostOccurringChar ( string ) : NEW_LINE"}
{"text":"Creating a hash of size 26","code":"hash = [ 0 ] * 26 ; NEW_LINE"}
{"text":"For loop to iterate through every string of the array","code":"for i in range ( len ( string ) ) : NEW_LINE"}
{"text":"For loop to iterate through every character of the string","code":"for j in range ( len ( string [ i ] ) ) : NEW_LINE"}
{"text":"Incrementing the count of the character in the hash","code":"hash [ ord ( string [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE"}
{"text":"Finding the character with the maximum count","code":"max = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT max = i if hash [ i ] > hash [ max ] else max ; NEW_LINE DEDENT print ( ( chr ) ( max + 97 ) ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Declaring Vector of String type","code":"string = [ ] ; NEW_LINE string . append ( \" animal \" ) ; NEW_LINE string . append ( \" zebra \" ) ; NEW_LINE string . append ( \" lion \" ) ; NEW_LINE string . append ( \" giraffe \" ) ; NEW_LINE findMostOccurringChar ( string ) ; NEW_LINE"}
{"text":"Function that returns true if num is palindrome","code":"def isPalindrome ( num ) : NEW_LINE"}
{"text":"Convert the given floating point number into a string","code":"s = str ( num ) NEW_LINE"}
{"text":"Pointers pointing to the first and the last character of the string","code":"low = 0 NEW_LINE high = len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE"}
{"text":"Not a palindrome","code":"if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Update the pointers","code":"low += 1 NEW_LINE high -= 1 NEW_LINE return True NEW_LINE"}
{"text":"Driver code","code":"n = 123.321 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of the approach","code":"import sys NEW_LINE MAX = 26 ; NEW_LINE"}
{"text":"Function to return the maximum number of times str1 can appear as a non - overlapping substring bin str2","code":"def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE"}
{"text":"str1 cannot never be substring of str2","code":"if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Store the frequency of the characters of str1","code":"freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT"}
{"text":"Store the frequency of the characters of str2","code":"freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT"}
{"text":"To store the required count of substrings","code":"minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE"}
{"text":"Current character doesn 't appear  in str1","code":"if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT"}
{"text":"Frequency of the current character in str1 is greater than its frequency in str2","code":"if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Update the count of possible substrings","code":"minPoss = min ( minPoss , freq2 [ i ] \/ freq1 [ i ] ) ; NEW_LINE return int ( minPoss ) ; NEW_LINE"}
{"text":"Driver code","code":"str1 = \" geeks \" ; str2 = \" gskefrgoekees \" ; NEW_LINE len1 = len ( str1 ) ; NEW_LINE len2 = len ( str2 ) ; NEW_LINE print ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ; NEW_LINE"}
{"text":"Function to return the number of ways to insert the bracket pairs","code":"def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) \/\/ 12 ; NEW_LINE return ways ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ab \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( cntWays ( string , n ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 implementation of the approach","code":"import sys NEW_LINE"}
{"text":"Set to store all the strings from the given array","code":"uSet = set ( ) ; NEW_LINE"}
{"text":"To store the required count","code":"minCnt = sys . maxsize ; NEW_LINE"}
{"text":"Recursive function to find the count of substrings that can be splitted starting from the index start such that all the substrings are present in the map","code":"def findSubStr ( string , cnt , start ) : NEW_LINE INDENT global minCnt ; NEW_LINE DEDENT"}
{"text":"All the chosen substrings are present in the map","code":"if ( start == len ( string ) ) : NEW_LINE"}
{"text":"Update the minimum count of substrings","code":"minCnt = min ( cnt , minCnt ) ; NEW_LINE"}
{"text":"Starting from the substrings of length 1 that start with the given index","code":"for length in range ( 1 , len ( string ) - start + 1 ) : NEW_LINE"}
{"text":"Get the substring","code":"subStr = string [ start : start + length ] ; NEW_LINE"}
{"text":"If the substring is present in the set","code":"if subStr in uSet : NEW_LINE"}
{"text":"Recursive call for the rest of the string","code":"findSubStr ( string , cnt + 1 , start + length ) ; NEW_LINE"}
{"text":"Function that inserts all the strings from the given array in a set and calls the recursive function to find the minimum count of substrings str can be splitted into that satisfy the given condition","code":"def findMinSubStr ( arr , n , string ) : NEW_LINE"}
{"text":"Insert all the strings from the given array in a set","code":"for i in range ( n ) : NEW_LINE INDENT uSet . add ( arr [ i ] ) ; NEW_LINE DEDENT"}
{"text":"Find the required count","code":"findSubStr ( string , 0 , 0 ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"123456\" ; NEW_LINE arr = [ \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMinSubStr ( arr , n , string ) ; NEW_LINE print ( minCnt ) ; NEW_LINE DEDENT"}
{"text":"Function to return the count of required substrings","code":"def countSubStr ( s , n ) : NEW_LINE INDENT c1 = 0 ; c2 = 0 ; NEW_LINE DEDENT"}
{"text":"For every index of the string","code":"for i in range ( n ) : NEW_LINE"}
{"text":"If the substring starting at the current index is \" geeks \"","code":"if ( s [ i : i + 5 ] == \" geeks \" ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT"}
{"text":"If the substring is \" for \"","code":"if ( s [ i : i + 3 ] == \" for \" ) : NEW_LINE INDENT c2 = c2 + c1 ; NEW_LINE DEDENT return c2 ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeksisforgeeks \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( countSubStr ( s , n ) ) ; NEW_LINE DEDENT"}
{"text":"Defining the string","code":"string = \" { [ ( ) ] } [ ] \" NEW_LINE"}
{"text":"Storing opening braces in list lst1","code":"lst1 = [ ' { ' , ' ( ' , ' [ ' ] NEW_LINE"}
{"text":"Storing closing braces in list lst2","code":"lst2 = [ ' } ' , ' ) ' , ' ] ' ] NEW_LINE"}
{"text":"Creating an empty list lst","code":"lst = [ ] NEW_LINE"}
{"text":"Creating dictionary to map closing braces to opening ones","code":"Dict = { ' ) ' : ' ( ' , ' } ' : ' { ' , ' ] ' : ' [ ' } NEW_LINE a = b = c = 0 NEW_LINE"}
{"text":"If first position of string contain any closing braces return 1","code":"if string [ 0 ] in lst2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE"}
{"text":"If characters of string are opening braces then append them in a list","code":"for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if string [ i ] in lst1 : NEW_LINE INDENT lst . append ( string [ i ] ) NEW_LINE k = i + 2 NEW_LINE DEDENT else : NEW_LINE DEDENT"}
{"text":"When size of list is 0 and new closing braces is encountered then print its index starting from 1","code":"if len ( lst ) == 0 and ( string [ i ] in lst2 ) : NEW_LINE INDENT print ( i + 1 ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE"}
{"text":"As we encounter closing braces we map them with theircorresponding opening braces using dictionary and check if it is same as last opened braces ( last element in list ) if yes then we delete that elememt from list","code":"if Dict [ string [ i ] ] == lst [ len ( lst ) - 1 ] : NEW_LINE INDENT lst . pop ( ) NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Otherwise we return the index ( starting from 1 ) at which nesting is found wrong","code":"print ( i + 1 ) NEW_LINE a = 1 NEW_LINE break NEW_LINE"}
{"text":"At end if the list is empty it means the string is perfectly nested","code":"if len ( lst ) == 0 and c == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE b = 1 NEW_LINE DEDENT if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of the above approach :","code":"MAX = 26 NEW_LINE"}
{"text":"Function to return the encrypted string","code":"def encryptstrr ( strr , n , x ) : NEW_LINE"}
{"text":"Reduce x because rotation of length 26 is unnecessary","code":"x = x % MAX NEW_LINE arr = list ( strr ) NEW_LINE"}
{"text":"calculate the frequency of characters","code":"freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE"}
{"text":"If the frequency of current character is even then increment it by x","code":"if ( freq [ ord ( arr [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT pos = ( ord ( arr [ i ] ) - ord ( ' a ' ) + x ) % MAX NEW_LINE arr [ i ] = chr ( pos + ord ( ' a ' ) ) NEW_LINE DEDENT"}
{"text":"Else decrement it by x","code":"else : NEW_LINE INDENT pos = ( ord ( arr [ i ] ) - ord ( ' a ' ) - x ) NEW_LINE if ( pos < 0 ) : NEW_LINE INDENT pos += MAX NEW_LINE DEDENT arr [ i ] = chr ( pos + ord ( ' a ' ) ) NEW_LINE DEDENT"}
{"text":"Return the count","code":"return \" \" . join ( arr ) NEW_LINE"}
{"text":"Driver code","code":"s = \" abcda \" NEW_LINE n = len ( s ) NEW_LINE x = 3 NEW_LINE print ( encryptstrr ( s , n , x ) ) NEW_LINE"}
{"text":"Function that returns true if it is possible to rearrange the characters of the String such that no two consecutive characters are same","code":"def isPossible ( Str ) : NEW_LINE"}
{"text":"To store the frequency of each of the character","code":"freq = dict ( ) NEW_LINE"}
{"text":"To store the maximum frequency so far","code":"max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT"}
{"text":"If possible","code":"if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE"}
{"text":"Driver code","code":"Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to print the uncommon characters in the given string in sorted order","code":"def printUncommon ( str1 , str2 ) : NEW_LINE INDENT a1 = 0 ; a2 = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE DEDENT"}
{"text":"Converting character to ASCII code","code":"ch = ord ( str1 [ i ] ) - ord ( ' a ' ) ; NEW_LINE"}
{"text":"Bit operation","code":"a1 = a1 | ( 1 << ch ) ; NEW_LINE for i in range ( len ( str2 ) ) : NEW_LINE"}
{"text":"Converting character to ASCII code","code":"ch = ord ( str2 [ i ] ) - ord ( ' a ' ) ; NEW_LINE"}
{"text":"Bit operation","code":"a2 = a2 | ( 1 << ch ) ; NEW_LINE"}
{"text":"XOR operation leaves only uncommon characters in the ans variable","code":"ans = a1 ^ a2 ; NEW_LINE i = 0 ; NEW_LINE while ( i < 26 ) : NEW_LINE INDENT if ( ans % 2 == 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) ; NEW_LINE DEDENT ans = ans \/\/ 2 ; NEW_LINE i += 1 ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE str2 = \" geeksquiz \" ; NEW_LINE printUncommon ( str1 , str2 ) ; NEW_LINE DEDENT"}
{"text":"Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced .","code":"def countMinReversals ( expr ) : NEW_LINE INDENT length = len ( expr ) NEW_LINE DEDENT"}
{"text":"length of expression must be even to make it balanced by using reversals .","code":"if length % 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"To store number of reversals required .","code":"ans = 0 NEW_LINE"}
{"text":"To store number of unbalanced opening brackets .","code":"open = 0 NEW_LINE"}
{"text":"To store number of unbalanced closing brackets .","code":"close = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE"}
{"text":"If current bracket is open then increment open count .","code":"if expr [ i ] == \" \" : NEW_LINE INDENT open += 1 NEW_LINE DEDENT"}
{"text":"If current bracket is close , check if it balances opening bracket . If yes then decrement count of unbalanced opening bracket else increment count of closing bracket .","code":"else : NEW_LINE INDENT if not open : NEW_LINE INDENT close += 1 NEW_LINE DEDENT else : NEW_LINE INDENT open -= 1 NEW_LINE DEDENT DEDENT ans = ( close \/\/ 2 ) + ( open \/\/ 2 ) NEW_LINE"}
{"text":"For the case : \" \" or when one closing and one opening bracket remains for pairing , then both need to be reversed .","code":"close %= 2 NEW_LINE open %= 2 NEW_LINE if close > 0 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT expr = \" } } { { \" NEW_LINE print ( countMinReversals ( expr ) ) NEW_LINE DEDENT"}
{"text":"Function to return the total number of valid pairs","code":"def totalPairs ( s1 , s2 ) : NEW_LINE INDENT a1 = 0 ; b1 = 0 ; NEW_LINE DEDENT"}
{"text":"Count total number of even and odd ascii values for string s1","code":"for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( ord ( s1 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT b1 += 1 ; NEW_LINE DEDENT DEDENT a2 = 0 ; b2 = 0 ; NEW_LINE"}
{"text":"Count total number of even and odd ascii values for string s2","code":"for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( ord ( s2 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a2 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT b2 += 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Return total valid pairs","code":"return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" for \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"}
{"text":"Function to return the count of the required prefix","code":"def prefixOccurrences ( str1 ) : NEW_LINE INDENT c = str1 [ 0 ] NEW_LINE countc = 0 NEW_LINE DEDENT"}
{"text":"Find the frequency of first character of str1ing","code":"for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == c ) : NEW_LINE INDENT countc += 1 NEW_LINE DEDENT DEDENT return countc NEW_LINE"}
{"text":"Driver code","code":"str1 = \" abbcdabbcd \" NEW_LINE print ( prefixOccurrences ( str1 ) ) NEW_LINE"}
{"text":"Function to return the minimum operations of the given type required to convert string s to string t","code":"def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE DEDENT"}
{"text":"Characters are already equal","code":"if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"Increment count of 0 s","code":"if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT"}
{"text":"Increment count of 1 s","code":"else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT return max ( ct0 , ct1 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"}
{"text":"Function to return the decrypted string","code":"def decryptString ( str , n ) : NEW_LINE"}
{"text":"Initial jump will be 1","code":"i = 0 NEW_LINE jump = 1 NEW_LINE decryptedStr = \" \" NEW_LINE while ( i < n ) : NEW_LINE INDENT decryptedStr += str [ i ] ; NEW_LINE i += jump NEW_LINE DEDENT"}
{"text":"Increment jump by 1 with every character","code":"jump += 1 NEW_LINE return decryptedStr NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeeeekkkksssss \" NEW_LINE n = len ( str ) NEW_LINE print ( decryptString ( str , n ) ) NEW_LINE DEDENT"}
{"text":"Function to check which bit is to be flipped","code":"def bitToBeFlipped ( s ) : NEW_LINE"}
{"text":"variable to store first and last character of string","code":"last = s [ len ( s ) - 1 ] NEW_LINE first = s [ 0 ] NEW_LINE"}
{"text":"Check if first and last characters are equal , if yes , then return the character which is not at last","code":"if ( last == first ) : NEW_LINE INDENT if ( last == '0' ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT else : NEW_LINE INDENT return '0' NEW_LINE DEDENT DEDENT"}
{"text":"else return last","code":"elif ( last != first ) : NEW_LINE INDENT return last NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"1101011000\" NEW_LINE print ( bitToBeFlipped ( s ) ) NEW_LINE DEDENT"}
{"text":"Function to create Sieve to check primes","code":"def SieveofEratosthenes ( prime , p_size ) : NEW_LINE"}
{"text":"false here indicates that it is not prime","code":"prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if prime [ p ] : NEW_LINE"}
{"text":"Update all multiples of p , set them to non - prime","code":"for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT"}
{"text":"Function to find the sum of prime frequencies of the characters of the given string","code":"def sumProdOfPrimeFreq ( s ) : NEW_LINE INDENT prime = [ True ] * ( len ( s ) + 2 ) NEW_LINE SieveofEratosthenes ( prime , len ( s ) + 1 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE DEDENT"}
{"text":"map is used to store character frequencies","code":"m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = ( m [ s [ i ] ] + 1 ) if s [ i ] in m else 1 NEW_LINE DEDENT s = 0 NEW_LINE product = 1 NEW_LINE"}
{"text":"Traverse the map","code":"for it in m : NEW_LINE"}
{"text":"If the frequency is prime","code":"if prime [ m [ it ] ] : NEW_LINE INDENT s += m [ it ] NEW_LINE product *= m [ it ] NEW_LINE DEDENT print ( \" Sum \u2581 = \" , s ) NEW_LINE print ( \" Product \u2581 = \" , product ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sumProdOfPrimeFreq ( s ) NEW_LINE DEDENT"}
{"text":"Python3 implementation of above approach","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function that checks if the frequency of character are a factor or multiple of each other","code":"def multipleOrFactor ( s1 , s2 ) : NEW_LINE"}
{"text":"map store frequency of each character","code":"m1 = defaultdict ( lambda : 0 ) NEW_LINE m2 = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s1 ) ) : NEW_LINE INDENT m1 [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( s2 ) ) : NEW_LINE INDENT m2 [ s2 [ i ] ] += 1 NEW_LINE DEDENT for it in m1 : NEW_LINE"}
{"text":"if any frequency is 0 , then continue as condition is satisfied","code":"if it not in m2 : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"if factor or multiple , then condition satisfied","code":"if ( m2 [ it ] % m1 [ it ] == 0 or m1 [ it ] % m2 [ it ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"if condition not satisfied","code":"else : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" geeks \" NEW_LINE if multipleOrFactor ( s1 , s2 ) : print ( \" YES \" ) NEW_LINE else : print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Function that removes the characters which have even frequencies in the string","code":"def solve ( s ) : NEW_LINE"}
{"text":"create a map to store the frequency of each character","code":"m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT"}
{"text":"to store the new string","code":"new_string = \" \" NEW_LINE"}
{"text":"remove the characters which have even frequencies","code":"for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"if the character has even frequency then skip","code":"if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"else concatenate the character to the new string","code":"new_string = new_string + s [ i ] NEW_LINE"}
{"text":"display the modified string","code":"print ( new_string ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE DEDENT"}
{"text":"remove the characters which have even frequencies","code":"solve ( s ) NEW_LINE"}
{"text":"function to check if ' str ' is palindrome","code":"def isPalindrome ( string ) : NEW_LINE INDENT i = 0 ; j = len ( string ) - 1 ; NEW_LINE DEDENT"}
{"text":"traversing from both the ends","code":"while ( i < j ) : NEW_LINE"}
{"text":"not palindrome","code":"if ( string [ i ] != string [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE"}
{"text":"palindrome","code":"return True ; NEW_LINE"}
{"text":"function to remove all the palindromic words from the given sentence","code":"def removePalinWords ( string ) : NEW_LINE"}
{"text":"' final _ str ' to store the final string and ' word ' to one by one store each word of 'str","code":"' NEW_LINE INDENT final_str = \" \" ; word = \" \" ; NEW_LINE DEDENT"}
{"text":"add space at the end of 'str","code":"' NEW_LINE INDENT string = string + \" \u2581 \" ; NEW_LINE n = len ( string ) ; NEW_LINE DEDENT"}
{"text":"traversing 'str","code":"' NEW_LINE INDENT for i in range ( n ) : NEW_LINE DEDENT"}
{"text":"accumulating characters of the current word","code":"if ( string [ i ] != ' \u2581 ' ) : NEW_LINE INDENT word = word + string [ i ] ; NEW_LINE DEDENT else : NEW_LINE"}
{"text":"if ' word ' is not palindrome then a add it to 'final_str","code":"' NEW_LINE INDENT if ( not ( isPalindrome ( word ) ) ) : NEW_LINE INDENT final_str += word + \" \u2581 \" ; NEW_LINE DEDENT DEDENT"}
{"text":"reset","code":"word = \" \" ; NEW_LINE"}
{"text":"required final string","code":"return final_str ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Text \u2581 contains \u2581 malayalam \u2581 and \u2581 level \u2581 words \" ; NEW_LINE print ( removePalinWords ( string ) ) ; NEW_LINE DEDENT"}
{"text":"Returns numeric value of a subsequence of s . The subsequence to be picked is decided using bit pattern of num ( We pick all thosedigits for which there is a set bit in num )","code":"def findSubSequence ( s , num ) : NEW_LINE"}
{"text":"Initialize the result","code":"res = 0 NEW_LINE"}
{"text":"till n != 0","code":"i = 0 NEW_LINE while ( num ) : NEW_LINE"}
{"text":"if i - th bit is set then add this number","code":"if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"right shift i","code":"num = num >> 1 NEW_LINE return res NEW_LINE"}
{"text":"function to find combined sum of all individual subsequence sum","code":"def combinedSum ( s ) : NEW_LINE"}
{"text":"length of string","code":"n = len ( s ) NEW_LINE"}
{"text":"stores the combined","code":"c_sum = 0 NEW_LINE"}
{"text":"2 ^ n - 1 subsequences","code":"ran = ( 1 << n ) - 1 NEW_LINE"}
{"text":"loop for all subsequences","code":"for i in range ( ran + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT"}
{"text":"returns the combined sum","code":"return c_sum NEW_LINE"}
{"text":"driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"123\" NEW_LINE print ( combinedSum ( s ) ) NEW_LINE DEDENT"}
{"text":"Python Program to find the subsequence with each character occurring at least k times in string s","code":"MAX_CHAR = 26 NEW_LINE"}
{"text":"Function to find the subsequence","code":"def findSubsequence ( stri , k ) : NEW_LINE"}
{"text":"Taking an extra array to keep record for character count in s","code":"a = [ 0 ] * MAX_CHAR ; NEW_LINE"}
{"text":"Counting occurrences of all characters in str [ ]","code":"for i in range ( len ( stri ) ) : NEW_LINE INDENT a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT"}
{"text":"Printing characters with count >= k in same order as they appear in str .","code":"for i in range ( len ( stri ) ) : NEW_LINE INDENT if a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] >= k : NEW_LINE INDENT print ( stri [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"k = 2 NEW_LINE findSubsequence ( \" geeksforgeeks \" , k ) NEW_LINE"}
{"text":"Python3 program to convert a sentence to gOOGLE cASE .","code":"def convert ( str ) : NEW_LINE"}
{"text":"empty strings","code":"w = \" \" NEW_LINE z = \" \" ; NEW_LINE"}
{"text":"convert input string to upper case","code":"str = str . upper ( ) + \" \u2581 \" ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE"}
{"text":"checki if character is not a space and adding it to string w","code":"ch = str [ i ] ; NEW_LINE if ( ch != ' \u2581 ' ) : NEW_LINE INDENT w = w + ch ; NEW_LINE DEDENT else : NEW_LINE"}
{"text":"converting first character to lower case and subsequent initial letter of another word to lower case","code":"z = ( z + ( w [ 0 ] ) . lower ( ) + w [ 1 : len ( w ) ] + \" \u2581 \" ) ; NEW_LINE w = \" \" ; NEW_LINE return z ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" I \u2581 got \u2581 intern \u2581 at \u2581 geeksforgeeks \" ; NEW_LINE print ( convert ( str ) ) ; NEW_LINE DEDENT"}
{"text":"isVowel ( ) is a function that returns true for a vowel and false otherwise .","code":"def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT"}
{"text":"function to Encrypt the string","code":"def encryptString ( s , n , k ) : NEW_LINE"}
{"text":"cv to count vowel cc to count consonants","code":"cv = [ 0 for i in range ( n ) ] NEW_LINE cc = [ 0 for i in range ( n ) ] NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT cv [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 NEW_LINE DEDENT"}
{"text":"Counting prefix count of vowel and prefix count of consonants","code":"for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + isVowel ( s [ i ] ) NEW_LINE cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == False ) NEW_LINE DEDENT ans = \" \" NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += str ( prod ) NEW_LINE"}
{"text":"generating the encrypted string .","code":"for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ) NEW_LINE ans += str ( prod ) NEW_LINE DEDENT return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hello \" NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT"}
{"text":"Python program to count the number of occurrence of a word in the given string","code":"def countOccurrences ( str , word ) : NEW_LINE"}
{"text":"split the string by spaces in a","code":"a = str . split ( \" \u2581 \" ) NEW_LINE"}
{"text":"search for pattern in a","code":"count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE"}
{"text":"if match found increase count","code":"if ( word == a [ i ] ) : NEW_LINE count = count + 1 NEW_LINE return count NEW_LINE"}
{"text":"Driver code","code":"str = \" GeeksforGeeks \u2581 A \u2581 computer \u2581 science \u2581 portal \u2581 for \u2581 geeks \u2581 \" NEW_LINE word = \" portal \" NEW_LINE print ( countOccurrences ( str , word ) ) NEW_LINE"}
{"text":"Python3 program to print initials of a name","code":"def printInitials ( name ) : NEW_LINE INDENT if ( len ( name ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT"}
{"text":"Split the string using ' space ' and print the first character of every word","code":"words = name . split ( \" \u2581 \" ) NEW_LINE for word in words : NEW_LINE INDENT print ( word [ 0 ] . upper ( ) , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT name = \" prabhat \u2581 kumar \u2581 singh \" NEW_LINE printInitials ( name ) NEW_LINE DEDENT"}
{"text":"Function to generate permutations","code":"def permute ( inp ) : NEW_LINE INDENT n = len ( inp ) NEW_LINE DEDENT"}
{"text":"Number of permutations is 2 ^ n","code":"mx = 1 << n NEW_LINE"}
{"text":"Converting string to lower case","code":"inp = inp . lower ( ) NEW_LINE"}
{"text":"Using all subsequences and permuting them","code":"for i in range ( mx ) : NEW_LINE"}
{"text":"If j - th bit is set , we convert it to upper case","code":"combination = [ k for k in inp ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) == 1 ) : NEW_LINE INDENT combination [ j ] = inp [ j ] . upper ( ) NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE"}
{"text":"Printing current combination","code":"for i in combination : NEW_LINE INDENT temp += i NEW_LINE DEDENT print temp , NEW_LINE"}
{"text":"Driver code","code":"permute ( \" ABC \" ) NEW_LINE"}
{"text":"Function to print the string","code":"def printString ( str , ch , count ) : NEW_LINE INDENT occ , i = 0 , 0 NEW_LINE DEDENT"}
{"text":"If given count is 0 print the given string and return","code":"if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT"}
{"text":"Start traversing the string","code":"for i in range ( len ( str ) ) : NEW_LINE"}
{"text":"Increment occ if current char is equal to given character","code":"if ( str [ i ] == ch ) : NEW_LINE INDENT occ += 1 NEW_LINE DEDENT"}
{"text":"Break the loop if given character has been occurred given no . of times","code":"if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Print the string after the occurrence of given character given no . of times","code":"if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : len ( str ) - i + 2 ] ) NEW_LINE DEDENT"}
{"text":"Otherwise string is empty","code":"else : NEW_LINE INDENT print ( \" Empty \u2581 string \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeks \u2581 for \u2581 geeks \" NEW_LINE printString ( str , ' e ' , 2 ) NEW_LINE DEDENT"}
{"text":"utility function to check for vowel","code":"def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT"}
{"text":"Function to reverse order of vowels","code":"def reverseVowel ( str ) : NEW_LINE"}
{"text":"Start two indexes from two corners and move toward each other","code":"i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT DEDENT"}
{"text":"swapping","code":"str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE return str NEW_LINE"}
{"text":"Driver function","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello \u2581 world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT"}
{"text":"A function to check if a string str is palindrome","code":"def isPalindrome ( str ) : NEW_LINE"}
{"text":"Start from leftmost and rightmost corners of str","code":"l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE"}
{"text":"Keep comparing characters while they are same","code":"while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = l + 1 NEW_LINE h = h - 1 NEW_LINE DEDENT return 1 NEW_LINE"}
{"text":"Returns count of minimum palindromic subseuqnces to be removed to make string empty","code":"def minRemovals ( str ) : NEW_LINE"}
{"text":"If string is empty","code":"if ( str [ 0 ] == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"If string is palindrome","code":"if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"If string is not palindrome","code":"return 2 NEW_LINE"}
{"text":"Driver code","code":"print ( minRemovals ( \"010010\" ) ) NEW_LINE print ( minRemovals ( \"0100101\" ) ) NEW_LINE"}
{"text":"Iterative function to calculate ( x ^ y ) % p in O ( log y )","code":"def power ( x , y , p ) : NEW_LINE"}
{"text":"Initialize result","code":"res = 1 ; NEW_LINE"}
{"text":"Update x if it is >= p","code":"x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE"}
{"text":"If y is odd , multiply x with result","code":"if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT"}
{"text":"y must be even now y = y 2","code":"y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE return res ; NEW_LINE"}
{"text":"Function to return XXX ... . . ( N times ) % M","code":"def findModuloByM ( X , N , M ) : NEW_LINE"}
{"text":"Return the mod by M of smaller numbers","code":"if ( N < 6 ) : NEW_LINE"}
{"text":"Creating a string of N X 's","code":"temp = chr ( 48 + X ) * N NEW_LINE"}
{"text":"Converting the string to int and calculating the modulo","code":"res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE"}
{"text":"Checking the parity of N","code":"if ( N % 2 == 0 ) : NEW_LINE"}
{"text":"Dividing the number into equal half","code":"half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE"}
{"text":"Utilizing the formula for even N","code":"res = ( half * power ( 10 , N \/\/ 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE else : NEW_LINE"}
{"text":"Dividing the number into equal half","code":"half = findModuloByM ( X , N \/\/ 2 , M ) % M ; NEW_LINE"}
{"text":"Utilizing the formula for odd N","code":"res = ( half * power ( 10 , N \/\/ 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE DEDENT"}
{"text":"Print XXX ... ( N times ) % M","code":"print ( findModuloByM ( X , N , M ) ) ; NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from math import sqrt NEW_LINE"}
{"text":"Structure of the circle","code":"class circle : NEW_LINE INDENT def __init__ ( self , a , b , c ) : NEW_LINE INDENT self . x = a NEW_LINE self . y = b NEW_LINE self . r = c NEW_LINE DEDENT DEDENT"}
{"text":"Utility function to check if given circles satisfy required criteria","code":"def check ( C ) : NEW_LINE"}
{"text":"Stores the distance between the centres of C1 and C2","code":"C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) NEW_LINE"}
{"text":"Stores the status if the given given criteria is satisfied or not","code":"flag = 0 NEW_LINE"}
{"text":"If C1C2 is less than the sum of the radii of the first 2 circles","code":"if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) : NEW_LINE"}
{"text":"If C3 is the midpoint of the centres at C1 and C2","code":"if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x and ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) : NEW_LINE"}
{"text":"Mark flag true","code":"flag = 1 NEW_LINE"}
{"text":"Return flag","code":"return flag NEW_LINE"}
{"text":"Function to check if the given circles satisfy required criteria","code":"def IsFairTriplet ( c ) : NEW_LINE INDENT f = False NEW_LINE DEDENT"}
{"text":"Check for the current combination of circles","code":"f |= check ( c ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c [ 0 ] , c [ 2 ] = c [ 2 ] , c [ 0 ] NEW_LINE DEDENT"}
{"text":"Check for the next combination","code":"f |= check ( c ) NEW_LINE return f NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = [ circle ( 0 , 0 , 0 ) for i in range ( 3 ) ] NEW_LINE C [ 0 ] = circle ( 0 , 0 , 8 ) NEW_LINE C [ 1 ] = circle ( 0 , 10 , 6 ) NEW_LINE C [ 2 ] = circle ( 0 , 5 , 5 ) NEW_LINE if ( IsFairTriplet ( C ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to find the eccentricity of a hyperbola","code":"def eccHyperbola ( A , B ) : NEW_LINE"}
{"text":"Stores the squared ratio of major axis to minor axis","code":"r = B * B \/ A * A NEW_LINE"}
{"text":"Increment r by 1","code":"r += 1 NEW_LINE"}
{"text":"Return the square root of r","code":"return math . sqrt ( r ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 3.0 NEW_LINE B = 2.0 NEW_LINE print ( eccHyperbola ( A , B ) ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"from math import sqrt NEW_LINE"}
{"text":"Function to find the area of cyclic quadrilateral","code":"def calculateArea ( A , B , C , D ) : NEW_LINE"}
{"text":"Stores the value of half of the perimeter","code":"S = ( A + B + C + D ) \/\/ 2 NEW_LINE"}
{"text":"Stores area of cyclic quadrilateral","code":"area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) NEW_LINE"}
{"text":"Return the resultant area","code":"return area NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 10 NEW_LINE B = 15 NEW_LINE C = 20 NEW_LINE D = 25 NEW_LINE print ( round ( calculateArea ( A , B , C , D ) , 3 ) ) NEW_LINE DEDENT"}
{"text":"Function to calculate ratio of a triangle inscribed in an ellipse to the triangle on the auxiliary circle","code":"def triangleArea ( a , b ) : NEW_LINE"}
{"text":"Stores the ratio of the semi - major to semi - minor axes","code":"ratio = b \/ a NEW_LINE"}
{"text":"Print the ratio","code":"print ( ratio ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE triangleArea ( a , b ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"from math import sqrt NEW_LINE"}
{"text":"Function to calculate the distance between a pair of points","code":"def distance ( m , n , p , q ) : NEW_LINE INDENT return ( sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ) NEW_LINE DEDENT"}
{"text":"Function to calculate the coordinates of the excenters of a triangle","code":"def Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE"}
{"text":"Length of the sides of the triangle","code":"a = distance ( x2 , x3 , y2 , y3 ) NEW_LINE b = distance ( x3 , x1 , y3 , y1 ) NEW_LINE c = distance ( x1 , x2 , y1 , y2 ) NEW_LINE"}
{"text":"Stores the coordinates of the excenters of the triangle","code":"excenter = [ [ 0 , 0 ] for i in range ( 4 ) ] NEW_LINE"}
{"text":"For I1","code":"excenter [ 1 ] [ 0 ] = ( ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) \/\/ ( - a + b + c ) ) NEW_LINE excenter [ 1 ] [ 1 ] = ( ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) \/\/ ( - a + b + c ) ) NEW_LINE"}
{"text":"For I2","code":"excenter [ 2 ] [ 0 ] = ( ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) \/\/ ( a - b + c ) ) NEW_LINE excenter [ 2 ] [ 1 ] = ( ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) \/\/ ( a - b + c ) ) NEW_LINE"}
{"text":"For I3","code":"excenter [ 3 ] [ 0 ] = ( ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) \/\/ ( a + b - c ) ) NEW_LINE excenter [ 3 ] [ 1 ] = ( ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) \/\/ ( a + b - c ) ) NEW_LINE"}
{"text":"Print the excenters of the triangle","code":"for i in range ( 1 , 4 ) : NEW_LINE INDENT print ( int ( excenter [ i ] [ 0 ] ) , int ( excenter [ i ] [ 1 ] ) ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE x2 = 3 NEW_LINE x3 = 0 NEW_LINE y1 = 0 NEW_LINE y2 = 0 NEW_LINE y3 = 4 NEW_LINE Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE DEDENT"}
{"text":"Python3 program to implement the above approach","code":"import math NEW_LINE"}
{"text":"Function to calculate height of the trapezoid","code":"def findHeight ( p1 , p2 , b , c ) : NEW_LINE INDENT a = max ( p1 , p2 ) - min ( p1 , p2 ) NEW_LINE DEDENT"}
{"text":"Apply Heron 's formula","code":"s = ( a + b + c ) \/\/ 2 NEW_LINE"}
{"text":"Calculate the area","code":"area = math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE"}
{"text":"Calculate height of trapezoid","code":"height = ( area * 2 ) \/ a NEW_LINE"}
{"text":"Prthe height","code":"print ( \" Height \u2581 is : \u2581 \" , height ) NEW_LINE"}
{"text":"Given a , b , p1 and p2","code":"p1 = 25 NEW_LINE p2 = 10 NEW_LINE a = 14 NEW_LINE b = 13 NEW_LINE findHeight ( p1 , p2 , a , b ) NEW_LINE"}
{"text":"Function to find Icositetragonal number","code":"def Icositetragonal_num ( n ) : NEW_LINE"}
{"text":"Formula to calculate nth Icositetragonal number","code":"return ( 22 * n * n - 20 * n ) \/ 2 NEW_LINE"}
{"text":"Driver Code","code":"n = 3 NEW_LINE print ( int ( Icositetragonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icositetragonal_num ( n ) ) ) NEW_LINE"}
{"text":"Function to find area of circle inscribed in a trapezoid having non - parallel sides m , n","code":"def area_of_circle ( m , n ) : NEW_LINE"}
{"text":"radius of circle by the formula i . e . root ( m * n ) \/ 2 area of circle = ( 3.141 ) * ( R * * 2 )","code":"square_of_radius = ( m * n ) \/ 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"}
{"text":"Function to find the area of equilateral triangle inscribed in a circle of radius R","code":"def area ( R ) : NEW_LINE"}
{"text":"Base and Height of equilateral triangle","code":"base = 1.732 * R NEW_LINE height = ( 3 \/ 2 ) * R NEW_LINE"}
{"text":"Area using Base and Height","code":"area = ( ( 1 \/ 2 ) * base * height ) NEW_LINE return area NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT R = 7 NEW_LINE print ( area ( R ) ) NEW_LINE DEDENT"}
{"text":"Function to find the area of the circle","code":"def circlearea ( R ) : NEW_LINE"}
{"text":"Radius cannot be negative","code":"if ( R < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT"}
{"text":"Area of the largest circle","code":"a = ( 3.14 * R * R ) \/ 4 ; NEW_LINE return a ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 2 ; NEW_LINE print ( circlearea ( R ) ) ; NEW_LINE DEDENT"}
{"text":"Count number of pairs of lines having eger ersection po","code":"def countPairs ( P , Q , N , M ) : NEW_LINE"}
{"text":"Initialize arrays to store counts","code":"A = [ 0 ] * 2 NEW_LINE B = [ 0 ] * 2 NEW_LINE"}
{"text":"Count number of odd and even Pi","code":"for i in range ( N ) : NEW_LINE INDENT A [ P [ i ] % 2 ] += 1 NEW_LINE DEDENT"}
{"text":"Count number of odd and even Qi","code":"for i in range ( M ) : NEW_LINE INDENT B [ Q [ i ] % 2 ] += 1 NEW_LINE DEDENT"}
{"text":"Return the count of pairs","code":"return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) NEW_LINE"}
{"text":"Driver code","code":"P = [ 1 , 3 , 2 ] NEW_LINE Q = [ 3 , 0 ] NEW_LINE N = len ( P ) NEW_LINE M = len ( Q ) NEW_LINE print ( countPairs ( P , Q , N , M ) ) NEW_LINE"}
{"text":"Function to count maximum number of intersections possible","code":"def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"import math NEW_LINE PI = 3.14159 NEW_LINE"}
{"text":"Function to return the area of triangle BCD","code":"def areaOfTriangle ( d ) : NEW_LINE"}
{"text":"Using Golden ratio","code":"c = 1.618 * d NEW_LINE s = ( d + c + c ) \/ 2 NEW_LINE"}
{"text":"Calculate area of triangle BCD","code":"area = math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) NEW_LINE"}
{"text":"Return area of all 5 triangles are the same","code":"return 5 * area NEW_LINE"}
{"text":"Function to return the area of regular pentagon","code":"def areaOfRegPentagon ( d ) : NEW_LINE INDENT global PI NEW_LINE DEDENT"}
{"text":"Calculate the area of regular pentagon using above formula","code":"cal = 4 * math . tan ( PI \/ 5 ) NEW_LINE area = ( 5 * d * d ) \/ cal NEW_LINE"}
{"text":"Return area of regular pentagon","code":"return area NEW_LINE"}
{"text":"Function to return the area of pentagram","code":"def areaOfPentagram ( d ) : NEW_LINE"}
{"text":"Area of a pentagram is equal to the area of regular pentagon and five times the area of Triangle","code":"return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) NEW_LINE"}
{"text":"Driver code","code":"d = 5 NEW_LINE print ( areaOfPentagram ( d ) ) NEW_LINE"}
{"text":"Python 3 program to find the angle subtended by the chord to the centre of the circle when the angle subtended by another equal chord of a congruent circle is given","code":"def anglequichord ( z ) : NEW_LINE INDENT print ( \" The \u2581 angle \u2581 is \u2581 \" , z , \" \u2581 degrees \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT"}
{"text":"Function to convert digits of N to respective ASCII values","code":"def convertToASCII ( N ) : NEW_LINE INDENT num = str ( N ) NEW_LINE i = 0 NEW_LINE for ch in num : NEW_LINE INDENT print ( ch , \" ( \" , ord ( ch ) , \" ) \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"N = 36 NEW_LINE convertToASCII ( N ) NEW_LINE"}
{"text":"Python 3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to form product array with O ( n ) time and O ( 1 ) space","code":"def productExceptSelf ( arr , N ) : NEW_LINE"}
{"text":"Stores the product of array","code":"product = 1 NEW_LINE"}
{"text":"Stores the count of zeros","code":"z = 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"If arr [ i ] is not zero","code":"if ( arr [ i ] != 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT"}
{"text":"If arr [ i ] is zero then increment count of z by 1","code":"if ( arr [ i ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT"}
{"text":"Stores the absolute value of the product","code":"a = abs ( product ) NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"If Z is equal to 1","code":"if ( z == 1 ) : NEW_LINE"}
{"text":"If arr [ i ] is not zero","code":"if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT"}
{"text":"Else","code":"else : NEW_LINE INDENT arr [ i ] = product NEW_LINE DEDENT continue NEW_LINE"}
{"text":"If count of 0 s at least 2","code":"elif ( z > 1 ) : NEW_LINE"}
{"text":"Assign arr [ i ] = 0","code":"arr [ i ] = 0 NEW_LINE continue NEW_LINE"}
{"text":"Store absolute value of arr [ i ]","code":"b = abs ( arr [ i ] ) NEW_LINE"}
{"text":"Find the value of a \/ b","code":"curr = round ( math . exp ( math . log ( a ) - math . log ( b ) ) ) NEW_LINE"}
{"text":"If arr [ i ] and product both are less than zero","code":"if ( arr [ i ] < 0 and product < 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT"}
{"text":"If arr [ i ] and product both are greater than zero","code":"elif ( arr [ i ] > 0 and product > 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT"}
{"text":"Else","code":"else : NEW_LINE INDENT arr [ i ] = - 1 * curr NEW_LINE DEDENT"}
{"text":"Traverse the array arr [ ]","code":"for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE"}
{"text":"Function Call","code":"productExceptSelf ( arr , N ) NEW_LINE"}
{"text":"Function to count of subarrays made up of single digit integers only","code":"def singleDigitSubarrayCount ( arr , N ) : NEW_LINE"}
{"text":"Stores count of subarrays","code":"res = 0 NEW_LINE"}
{"text":"Stores the count of consecutive single digit numbers in the array","code":"count = 0 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE DEDENT"}
{"text":"Increment size of block by 1","code":"count += 1 NEW_LINE"}
{"text":"Increment res by count","code":"res += count NEW_LINE else : NEW_LINE"}
{"text":"Assign count = 0","code":"count = 0 NEW_LINE print ( res ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given array","code":"arr = [ 0 , 1 , 14 , 2 , 5 ] NEW_LINE"}
{"text":"Size of the array","code":"N = len ( arr ) NEW_LINE singleDigitSubarrayCount ( arr , N ) NEW_LINE"}
{"text":"Function to check if the number N can be expressed as sum of 2 or more consecutive numbers or not","code":"def isPossible ( N ) : NEW_LINE INDENT return ( ( N & ( N - 1 ) ) and N ) NEW_LINE DEDENT"}
{"text":"Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers","code":"def countElements ( N ) : NEW_LINE"}
{"text":"Stores the required count","code":"count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isPossible ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE countElements ( N ) NEW_LINE DEDENT"}
{"text":"Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers","code":"def countElements ( N ) : NEW_LINE INDENT Cur_Ele = 1 NEW_LINE Count = 0 NEW_LINE DEDENT"}
{"text":"Count powers of 2 up to N","code":"while ( Cur_Ele <= N ) : NEW_LINE"}
{"text":"Increment count","code":"Count += 1 NEW_LINE"}
{"text":"Update current power of 2","code":"Cur_Ele = Cur_Ele * 2 NEW_LINE print ( N - Count ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE countElements ( N ) NEW_LINE DEDENT"}
{"text":"Python 3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to calculate maximum difference between adjacent elements excluding every array element once","code":"def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE arr_max = - sys . maxsize - 1 NEW_LINE DEDENT"}
{"text":"Compute maximum adjacent difference for whole array","code":"for i in range ( 1 , N ) : NEW_LINE INDENT arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT for i in range ( 1 , N - 1 ) : NEW_LINE INDENT curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) NEW_LINE DEDENT"}
{"text":"Store the maximum between arr_max and curr_max","code":"ans = max ( curr_max , arr_max ) NEW_LINE"}
{"text":"Append the result into a vector","code":"res . append ( ans ) NEW_LINE"}
{"text":"Print the result","code":"for x in res : NEW_LINE INDENT print ( x , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE DEDENT"}
{"text":"Function to find min operations to make even and odd count equal","code":"def minimumIncrement ( arr , N ) : NEW_LINE"}
{"text":"Odd size will never make odd and even counts equal","code":"if ( N % 2 != 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"Stores the count of even numbers in the array arr [ ]","code":"cntEven = 0 NEW_LINE"}
{"text":"Stores count of odd numbers in the array arr [ ]","code":"cntOdd = 0 NEW_LINE"}
{"text":"Traverse the array arr [ ]","code":"for i in range ( N ) : NEW_LINE"}
{"text":"If arr [ i ] is an even number","code":"if ( arr [ i ] % 2 == 0 ) : NEW_LINE"}
{"text":"Update cntEven","code":"cntEven += 1 NEW_LINE"}
{"text":"Odd numbers in arr [ ]","code":"cntOdd = N - cntEven NEW_LINE"}
{"text":"Return absolute difference divided by 2","code":"return abs ( cntEven - cntOdd ) \/\/ 2 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT"}
{"text":"Function call","code":"print ( minimumIncrement ( arr , N ) ) NEW_LINE"}
{"text":"Function to find count the ways to construct an array , B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 and product of elements of B [ ] is even","code":"def cntWaysConsArray ( A , N ) : NEW_LINE"}
{"text":"Stores count of arrays B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1","code":"total = 1 ; NEW_LINE"}
{"text":"Stores count of arrays B [ ] whose product of elements is not even","code":"oddArray = 1 ; NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Update total","code":"total = total * 3 ; NEW_LINE"}
{"text":"If A [ i ] is an even number","code":"if ( A [ i ] % 2 == 0 ) : NEW_LINE"}
{"text":"Update oddArray","code":"oddArray *= 2 ; NEW_LINE"}
{"text":"Print 3 ^ N - 2 ^ X","code":"print ( total - oddArray ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 4 ] ; NEW_LINE N = len ( A ) ; NEW_LINE cntWaysConsArray ( A , N ) ; NEW_LINE DEDENT"}
{"text":"Function to count the numbers in the range [ 1 , N ] whose rightmost set bit is K","code":"def countNumberHavingKthBitSet ( N , K ) : NEW_LINE"}
{"text":"Stores the number whose rightmost set bit is K","code":"numbers_rightmost_setbit_K = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE"}
{"text":"Numbers whose rightmost set bit is i","code":"numbers_rightmost_bit_i = ( N + 1 ) \/\/ 2 NEW_LINE"}
{"text":"Subtracting the number whose rightmost set bit is i , from N","code":"N -= numbers_rightmost_bit_i NEW_LINE"}
{"text":"Since i = k , then the number whose rightmost set bit is K is stored","code":"if ( i == K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = numbers_rightmost_bit_i NEW_LINE DEDENT print ( numbers_rightmost_setbit_K ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE K = 2 NEW_LINE countNumberHavingKthBitSet ( N , K ) NEW_LINE DEDENT"}
{"text":"Function to count set bits in binary representation of number N","code":"def countSetBits ( N : int ) -> int : NEW_LINE INDENT count = 0 NEW_LINE DEDENT"}
{"text":"Count set bits in N","code":"while ( N ) : NEW_LINE INDENT N = N & ( N - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT"}
{"text":"Return the final count","code":"return count NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE bits = countSetBits ( N ) NEW_LINE DEDENT"}
{"text":"Print odd Binomial coefficients","code":"print ( \" Odd \u2581 : \u2581 { } \" . format ( pow ( 2 , bits ) ) ) NEW_LINE"}
{"text":"Print even Binomial coefficients","code":"print ( \" Even \u2581 : \u2581 { } \" . format ( N + 1 - pow ( 2 , bits ) ) ) NEW_LINE"}
{"text":"Function to find the minimum number of replacements required to make all array elements even","code":"def minMoves ( arr , N ) : NEW_LINE"}
{"text":"Stores the count of odd elements","code":"odd_element_cnt = 0 ; NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Increase count of odd elements","code":"if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT odd_element_cnt += 1 ; NEW_LINE DEDENT"}
{"text":"Store number of replacements required","code":"moves = ( odd_element_cnt ) \/\/ 2 ; NEW_LINE"}
{"text":"Two extra moves will be required to make the last odd element even","code":"if ( odd_element_cnt % 2 != 0 ) : NEW_LINE INDENT moves += 2 ; NEW_LINE DEDENT"}
{"text":"Prthe minimum replacements","code":"print ( moves ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 7 , 20 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE DEDENT"}
{"text":"Function call","code":"minMoves ( arr , N ) ; NEW_LINE"}
{"text":"Function to partition squares of N natural number in two subset","code":"def minimumSubsetDifference ( N ) : NEW_LINE"}
{"text":"Store the count of blocks of size 8","code":"blockOfSize8 = N \/\/ 8 NEW_LINE"}
{"text":"Partition of block of 8 element","code":"str = \" ABBABAAB \" NEW_LINE"}
{"text":"Store the minimum subset difference","code":"subsetDifference = 0 NEW_LINE"}
{"text":"Partition of N elements to minimize their subset sum difference","code":"partition = \" \" NEW_LINE while blockOfSize8 != 0 : NEW_LINE INDENT partition = partition + str NEW_LINE blockOfSize8 = blockOfSize8 - 1 NEW_LINE DEDENT"}
{"text":"Store elements of subset A and B","code":"A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"If element is of type A","code":"if partition [ i ] == ' A ' : NEW_LINE INDENT A . append ( ( i + 1 ) * ( i + 1 ) ) NEW_LINE DEDENT"}
{"text":"If the element is of type B","code":"else : NEW_LINE INDENT B . append ( ( i + 1 ) * ( i + 1 ) ) NEW_LINE DEDENT"}
{"text":"Print the minimum subset difference","code":"print ( subsetDifference ) NEW_LINE"}
{"text":"Print the first subset","code":"for i in A : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Print the second subset","code":"for i in B : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 8 NEW_LINE"}
{"text":"Function call","code":"minimumSubsetDifference ( N ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"from collections import defaultdict NEW_LINE"}
{"text":"Function to find the largest number X such that it divides P but is not divisible by Q","code":"def findTheGreatestX ( P , Q ) : NEW_LINE"}
{"text":"Stores the frequency count of of all Prime Factors","code":"divisiors = defaultdict ( int ) NEW_LINE i = 2 NEW_LINE while i * i <= Q : NEW_LINE INDENT while ( Q % i == 0 and Q > 1 ) : NEW_LINE INDENT Q \/\/= i NEW_LINE DEDENT DEDENT"}
{"text":"Increment the frequency of the current prime factor","code":"divisiors [ i ] += 1 NEW_LINE i += 1 NEW_LINE"}
{"text":"If Q is a prime factor","code":"if ( Q > 1 ) : NEW_LINE INDENT divisiors [ Q ] += 1 NEW_LINE DEDENT"}
{"text":"Stores the desired result","code":"ans = 0 NEW_LINE"}
{"text":"Iterate through all divisors of Q","code":"for i in divisiors : NEW_LINE INDENT frequency = divisiors [ i ] NEW_LINE temp = P NEW_LINE DEDENT"}
{"text":"Stores the frequency count of current prime divisor on dividing P","code":"cur = 0 NEW_LINE while ( temp % i == 0 ) : NEW_LINE INDENT temp \/\/= i NEW_LINE DEDENT"}
{"text":"Count the frequency of the current prime factor","code":"cur += 1 NEW_LINE"}
{"text":"If cur is less than frequency then P is the final result","code":"if ( cur < frequency ) : NEW_LINE INDENT ans = P NEW_LINE break NEW_LINE DEDENT temp = P NEW_LINE"}
{"text":"Iterate to get temporary answer","code":"for j in range ( cur , frequency - 1 , - 1 ) : NEW_LINE INDENT temp \/\/= i NEW_LINE DEDENT"}
{"text":"Update current answer","code":"ans = max ( temp , ans ) NEW_LINE"}
{"text":"Print the desired result","code":"print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given P and Q","code":"P = 10 NEW_LINE Q = 4 NEW_LINE"}
{"text":"Function Call","code":"findTheGreatestX ( P , Q ) NEW_LINE"}
{"text":"Function to check if there is any row where number of unique elements are greater than 1","code":"def checkRearrangements ( mat , N , M ) : NEW_LINE"}
{"text":"Iterate over the matrix","code":"for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT DEDENT return \" No \" NEW_LINE"}
{"text":"Function to check if it is possible to rearrange mat [ ] [ ] such that XOR of its first column is non - zero","code":"def nonZeroXor ( mat , N , M ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT"}
{"text":"Find bitwise XOR of the first column of mat [ ] [ ]","code":"for i in range ( N ) : NEW_LINE INDENT res = res ^ mat [ i ] [ 0 ] NEW_LINE DEDENT"}
{"text":"If bitwise XOR of the first column of mat [ ] [ ] is non - zero","code":"if ( res != 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT"}
{"text":"Otherwise check rearrangements","code":"else : NEW_LINE INDENT return checkRearrangements ( mat , N , M ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given Matrix mat [ ] [ ]","code":"mat = [ [ 1 , 1 , 2 ] , [ 2 , 2 , 2 ] , [ 3 , 3 , 3 ] ] NEW_LINE N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE"}
{"text":"Function Call","code":"print ( nonZeroXor ( mat , N , M ) ) NEW_LINE"}
{"text":"Function to maximize the value for the given function and the array elements","code":"def functionMax ( arr , n ) : NEW_LINE"}
{"text":"Vector array to maintain which bit is set for which integer in the given array by saving index of that integer","code":"setBit = [ [ ] for i in range ( 32 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE DEDENT"}
{"text":"Check if j - th bit is set for i - th integer","code":"if ( arr [ i ] & ( 1 << j ) ) : NEW_LINE"}
{"text":"Push the index of that integer in setBit [ j ]","code":"setBit [ j ] . append ( i ) NEW_LINE"}
{"text":"Find the element having highest significant set bit unset in other elements","code":"i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( len ( setBit [ i ] ) == 1 ) : NEW_LINE DEDENT"}
{"text":"Place that integer at 0 - th index","code":"temp = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ setBit [ i ] [ 0 ] ] NEW_LINE arr [ setBit [ i ] [ 0 ] ] = temp NEW_LINE break NEW_LINE i -= 1 NEW_LINE"}
{"text":"Store the maximum AND value","code":"maxAnd = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT maxAnd = ( maxAnd & ( ~ arr [ i ] ) ) NEW_LINE DEDENT"}
{"text":"Return the answer","code":"return maxAnd NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT"}
{"text":"Function call","code":"print ( functionMax ( arr , n ) ) NEW_LINE"}
{"text":"Function returns nCr i . e . Binomial Coefficient","code":"def nCr ( n , r ) : NEW_LINE"}
{"text":"Initialize res with 1","code":"res = 1 NEW_LINE"}
{"text":"Since C ( n , r ) = C ( n , n - r )","code":"if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT"}
{"text":"Evaluating expression","code":"for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res \/= ( i + 1 ) NEW_LINE DEDENT return res ; NEW_LINE"}
{"text":"Function to calculate and return the sum of the products","code":"def solve ( n , m , k ) : NEW_LINE"}
{"text":"Initialize sum to 0","code":"sum = 0 ; NEW_LINE"}
{"text":"Traverse from 0 to k","code":"for i in range ( k + 1 ) : NEW_LINE INDENT sum += nCr ( n , i ) * nCr ( m , k - i ) NEW_LINE DEDENT return int ( sum ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 ; NEW_LINE print ( solve ( n , m , k ) ) NEW_LINE DEDENT"}
{"text":"Function to return a ^ n","code":"def powerOptimised ( a , n ) : NEW_LINE"}
{"text":"Stores final answer","code":"ans = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last_bit = ( n & 1 ) NEW_LINE DEDENT"}
{"text":"Check if current LSB is set","code":"if ( last_bit ) : NEW_LINE INDENT ans = ans * a NEW_LINE DEDENT a = a * a NEW_LINE"}
{"text":"Right shift","code":"n = n >> 1 NEW_LINE return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE n = 5 NEW_LINE print ( powerOptimised ( a , n ) ) NEW_LINE DEDENT"}
{"text":"Function to find the integer M such that gcd ( N , M ) is maximum","code":"def findMaximumGcd ( n ) : NEW_LINE"}
{"text":"Initialize variables","code":"max_gcd = 1 NEW_LINE i = 1 NEW_LINE"}
{"text":"Find all the divisors of N and return the maximum divisor","code":"while ( i * i <= n ) : NEW_LINE"}
{"text":"Check if i is divisible by N","code":"if n % i == 0 : NEW_LINE"}
{"text":"Update max_gcd","code":"if ( i > max_gcd ) : NEW_LINE INDENT max_gcd = i NEW_LINE DEDENT if ( ( n \/ i != i ) and ( n \/ i != n ) and ( ( n \/ i ) > max_gcd ) ) : NEW_LINE INDENT max_gcd = n \/ i NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"Return the maximum value","code":"return ( int ( max_gcd ) ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given number","code":"n = 10 NEW_LINE"}
{"text":"Function call","code":"print ( findMaximumGcd ( n ) ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"x = 2000021 NEW_LINE"}
{"text":"For storing smallest prime factor","code":"v = [ 0 ] * x NEW_LINE"}
{"text":"Function construct smallest prime factor array","code":"def sieve ( ) : NEW_LINE INDENT v [ 1 ] = 1 NEW_LINE DEDENT"}
{"text":"Mark smallest prime factor for every number to be itself","code":"for i in range ( 2 , x ) : NEW_LINE INDENT v [ i ] = i NEW_LINE DEDENT"}
{"text":"separately mark spf for every even number as 2","code":"for i in range ( 4 , x , 2 ) : NEW_LINE INDENT v [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < x ) : NEW_LINE"}
{"text":"Check if i is prime","code":"if ( v [ i ] == i ) : NEW_LINE"}
{"text":"Mark SPF for all numbers divisible by i","code":"for j in range ( i * i , x , i ) : NEW_LINE"}
{"text":"Mark spf [ i ] if it is not previously marked","code":"if ( v [ j ] == j ) : NEW_LINE INDENT v [ j ] = i NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"Function for counts total number of prime factors","code":"def prime_factors ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE while ( n != 1 ) : NEW_LINE INDENT s . add ( v [ n ] ) NEW_LINE n = n \/\/ v [ n ] NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT"}
{"text":"Function to print elements of sets of K consecutive elements having K prime factors","code":"def distinctPrimes ( m , k ) : NEW_LINE"}
{"text":"To store the result","code":"result = [ ] NEW_LINE for i in range ( 14 , m + k ) : NEW_LINE"}
{"text":"Count number of prime factors of number","code":"count = prime_factors ( i ) NEW_LINE"}
{"text":"If number has exactly K factors puch in result [ ]","code":"if ( count == k ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT p = len ( result ) NEW_LINE for index in range ( p - 1 ) : NEW_LINE element = result [ index ] NEW_LINE count = 1 NEW_LINE z = index NEW_LINE"}
{"text":"Iterate till we get K consecutive elements in result [ ]","code":"while ( z < p - 1 and count <= k and result [ z ] + 1 == result [ z + 1 ] ) : NEW_LINE"}
{"text":"Count sequence until K","code":"count += 1 NEW_LINE z += 1 NEW_LINE"}
{"text":"Print the element if count >= K","code":"if ( count >= k ) : NEW_LINE INDENT print ( element , end = ' \u2581 ' ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"To construct spf [ ]","code":"sieve ( ) NEW_LINE"}
{"text":"Given N and K","code":"N = 1000 NEW_LINE K = 3 NEW_LINE"}
{"text":"Function call","code":"distinctPrimes ( N , K ) NEW_LINE"}
{"text":"Function to multiply Complex Numbers with just three multiplications","code":"def print_product ( a , b , c , d ) : NEW_LINE"}
{"text":"Find value of prod1 , prod2 and prod3","code":"prod1 = a * c NEW_LINE prod2 = b * d NEW_LINE prod3 = ( a + b ) * ( c + d ) NEW_LINE"}
{"text":"Real part","code":"real = prod1 - prod2 NEW_LINE"}
{"text":"Imaginary part","code":"imag = prod3 - ( prod1 + prod2 ) NEW_LINE"}
{"text":"Print the result","code":"print ( real , \" \u2581 + \u2581 \" , imag , \" i \" ) NEW_LINE"}
{"text":"Given four numbers","code":"a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE"}
{"text":"Function call","code":"print_product ( a , b , c , d ) NEW_LINE"}
{"text":"Function to check if a number is an Insolite numbers","code":"def isInsolite ( n ) : NEW_LINE INDENT N = n ; NEW_LINE DEDENT"}
{"text":"To store sum of squares of digits","code":"sum = 0 ; NEW_LINE"}
{"text":"To store product of squares of digits","code":"product = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE"}
{"text":"extracting digit","code":"r = n % 10 ; NEW_LINE sum = sum + r * r ; NEW_LINE product = product * r * r ; NEW_LINE n = n \/\/ 10 ; NEW_LINE return ( ( N % sum == 0 ) and ( N % product == 0 ) ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 111 ; NEW_LINE DEDENT"}
{"text":"Function Call","code":"if ( isInsolite ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"text":"Function to calculate the sum of all divisors of a given number","code":"def sigma ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT"}
{"text":"Sum of divisors","code":"result = 0 NEW_LINE"}
{"text":"Find all divisors which divides 'num","code":"' NEW_LINE INDENT for i in range ( 2 , pow ( n , 1 \/\/ 2 ) ) : NEW_LINE DEDENT"}
{"text":"If ' i ' is divisor of 'n","code":"' NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT"}
{"text":"If both divisors are same then add it once else add both","code":"if ( i == ( n \/ i ) ) : NEW_LINE INDENT result += i NEW_LINE DEDENT else : NEW_LINE INDENT result += ( i + n \/ i ) NEW_LINE DEDENT"}
{"text":"Add 1 and n to result as above loop considers proper divisors greater than 1.","code":"return ( result + n + 1 ) NEW_LINE"}
{"text":"Function to check if N is a superabundant number","code":"def isSuperabundant ( N ) : NEW_LINE"}
{"text":"To check all numbers from 1 to N","code":"for i in range ( 1 , N ) : NEW_LINE INDENT x = sigma ( ( int ) ( i ) ) \/ i NEW_LINE y = sigma ( ( int ) ( N ) ) \/ ( N * 1.0 ) NEW_LINE if ( x > y ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE if ( isSuperabundant ( N ) != True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 implementation for the above approach","code":"import math NEW_LINE"}
{"text":"Function to find the N - th icosikaipentagon number","code":"def isDNum ( n ) : NEW_LINE"}
{"text":"number should be greater than 3","code":"if n < 4 : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Check every k in range 2 to n - 1","code":"for k in range ( 2 , n ) : NEW_LINE INDENT numerator = pow ( k , n - 2 ) - k NEW_LINE hcf = math . gcd ( n , k ) NEW_LINE DEDENT"}
{"text":"condition for D - Number","code":"if ( hcf == 1 and ( numerator % n ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Driver code","code":"n = 15 NEW_LINE if isDNum ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to find prime divisors of all numbers from 1 to N","code":"def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE DEDENT"}
{"text":"If the number is prime","code":"if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE"}
{"text":"Add this prime to all it 's multiples","code":"for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE"}
{"text":"Function to check Ruth - Aaron number","code":"def RuthAaronNumber ( n ) : NEW_LINE INDENT if ( Sum ( n ) == Sum ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"N = 714 NEW_LINE if ( RuthAaronNumber ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function for maximising the sum","code":"def maxAdjacentDifference ( N , K ) : NEW_LINE"}
{"text":"Difference is 0 when only one element is present in array","code":"if ( N == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Difference is K when two elements are present in array","code":"if ( N == 2 ) : NEW_LINE INDENT return K ; NEW_LINE DEDENT"}
{"text":"Otherwise","code":"return 2 * K ; NEW_LINE"}
{"text":"Driver code","code":"N = 6 ; NEW_LINE K = 11 ; NEW_LINE print ( maxAdjacentDifference ( N , K ) ) ; NEW_LINE"}
{"text":"Python3 program for the above approach","code":"mod = 1000000007 NEW_LINE"}
{"text":"Functions returns sum of numbers from 1 to n","code":"def linearSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) \/\/ 2 % mod NEW_LINE DEDENT"}
{"text":"Functions returns sum of numbers from a + 1 to b","code":"def rangeSum ( b , a ) : NEW_LINE INDENT return ( linearSum ( b ) - ( linearSum ( a ) ) ) % mod NEW_LINE DEDENT"}
{"text":"Function returns total sum of divisors","code":"def totalSum ( n ) : NEW_LINE"}
{"text":"Stores total sum","code":"result = 0 NEW_LINE i = 1 NEW_LINE"}
{"text":"Finding numbers and its occurence","code":"while True : NEW_LINE"}
{"text":"Sum of product of each number and its occurence","code":"result += rangeSum ( n \/\/ i , n \/\/ ( i + 1 ) ) * ( i % mod ) % mod ; NEW_LINE result %= mod ; NEW_LINE if i == n : NEW_LINE INDENT break NEW_LINE DEDENT i = n \/\/ ( n \/\/ ( i + 1 ) ) NEW_LINE return result NEW_LINE"}
{"text":"Driver code","code":"N = 4 NEW_LINE print ( totalSum ( N ) ) NEW_LINE N = 12 NEW_LINE print ( totalSum ( N ) ) NEW_LINE"}
{"text":"Function to check if a string is double string or not","code":"def isDouble ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE l = len ( s ) NEW_LINE DEDENT"}
{"text":"a and b should not be equal","code":"if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Condition to check if length is odd make length even","code":"if ( l % 2 == 1 ) : NEW_LINE INDENT s = s + s [ 1 ] NEW_LINE l += 1 NEW_LINE DEDENT"}
{"text":"First half of s","code":"s1 = s [ : l \/\/ 2 ] NEW_LINE"}
{"text":"Second half of s","code":"s2 = s [ l \/\/ 2 : ] NEW_LINE"}
{"text":"Double string if first and last half are equal","code":"return s1 == s2 NEW_LINE"}
{"text":"Function to check if N is an Nontrivial undulant number","code":"def isNontrivialUndulant ( N ) : NEW_LINE INDENT return N > 100 and isDouble ( N ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 121 NEW_LINE if ( isNontrivialUndulant ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to find the nth Megagon Number","code":"def MegagonNum ( n ) : NEW_LINE INDENT return ( 999998 * n * n - 999996 * n ) \/\/ 2 ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 3 ; NEW_LINE print ( MegagonNum ( n ) ) ; NEW_LINE"}
{"text":"Python3 implementation to find the product of all the pairs from the given array","code":"mod = 1000000007 ; NEW_LINE"}
{"text":"Function to return the product of the elements of all possible pairs from the array","code":"def productPairs ( arr , n ) : NEW_LINE"}
{"text":"To store the required product","code":"product = 1 ; NEW_LINE"}
{"text":"Nested loop to calculate all possible pairs","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE DEDENT"}
{"text":"Multiply the product of the elements of the current pair","code":"product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; NEW_LINE product = product % mod ; NEW_LINE"}
{"text":"Return the final result","code":"return product % mod ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( productPairs ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 implementation to Find the product of all the pairs from the given array","code":"mod = 1000000007 NEW_LINE"}
{"text":"Function to calculate ( x ^ y ) % 1000000007","code":"def power ( x , y ) : NEW_LINE INDENT p = 1000000007 NEW_LINE DEDENT"}
{"text":"Initialize result","code":"res = 1 NEW_LINE"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE"}
{"text":"If y is odd , multiply x with result","code":"if ( ( y & 1 ) != 0 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE"}
{"text":"Return the final result","code":"return res NEW_LINE"}
{"text":"Function to return the product of the elements of all possible pairs from the array","code":"def productPairs ( arr , n ) : NEW_LINE"}
{"text":"To store the required product","code":"product = 1 NEW_LINE"}
{"text":"Iterate for every element of the array","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Each element appears ( 2 * n ) times","code":"product = ( product % mod * ( int ) ( power ( arr [ i ] , ( 2 * n ) ) ) % mod ) % mod NEW_LINE return ( product % mod ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPairs ( arr , n ) ) NEW_LINE"}
{"text":"Function to create and print the array","code":"def constructArray ( N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE DEDENT"}
{"text":"Initialise the array of size N","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i - 1 ] = i ; NEW_LINE DEDENT"}
{"text":"Print the array","code":"for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" , \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"N = 6 ; NEW_LINE constructArray ( N ) ; NEW_LINE"}
{"text":"Function to check whether a number is prime or not","code":"def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT"}
{"text":"Function to find number of subsequences whose product is a composite number","code":"def countSubsequences ( arr , n ) : NEW_LINE"}
{"text":"Find total non empty subsequence","code":"totalSubsequence = ( int ) ( pow ( 2 , n ) - 1 ) ; NEW_LINE countPrime = 0 ; NEW_LINE countOnes = 0 ; NEW_LINE"}
{"text":"Find count of prime number and ones","code":"for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT countOnes += 1 ; NEW_LINE DEDENT elif ( isPrime ( arr [ i ] ) ) : NEW_LINE INDENT countPrime += 1 ; NEW_LINE DEDENT DEDENT compositeSubsequence = 0 ; NEW_LINE"}
{"text":"Calculate the non empty one subsequence","code":"onesSequence = ( int ) ( pow ( 2 , countOnes ) - 1 ) ; NEW_LINE"}
{"text":"Find count of composite subsequence","code":"compositeSubsequence = ( totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ) ; NEW_LINE return compositeSubsequence ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countSubsequences ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to check if a number can be expressed as the sum of k consecutive","code":"def checksum ( n , k ) : NEW_LINE"}
{"text":"Finding the first term of AP","code":"first_term = ( ( 2 * n ) \/ k + ( 1 - k ) ) \/ 2.0 NEW_LINE"}
{"text":"Checking if first term is an integer","code":"if ( first_term - int ( first_term ) == 0 ) : NEW_LINE"}
{"text":"Loop to print the K consecutive integers","code":"for i in range ( int ( first_term ) , int ( first_term ) + k ) : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT else : NEW_LINE print ( ' - 1' ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( n , k ) = ( 33 , 6 ) NEW_LINE checksum ( n , k ) NEW_LINE DEDENT"}
{"text":"Function to print the representation","code":"def sumEvenNumbers ( N , K ) : NEW_LINE INDENT check = N - 2 * ( K - 1 ) NEW_LINE DEDENT"}
{"text":"N must be greater than equal to 2 * K and must be even","code":"if ( check > 0 and check % 2 == 0 ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( \"2 \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 8 NEW_LINE K = 2 NEW_LINE sumEvenNumbers ( N , K ) NEW_LINE"}
{"text":"Function to find the number of subarrays including the element at every index of the array","code":"def calculateWays ( N ) : NEW_LINE INDENT x = 0 ; NEW_LINE v = [ ] ; NEW_LINE DEDENT"}
{"text":"Creating an array of size N","code":"for i in range ( N ) : NEW_LINE INDENT v . append ( 0 ) ; NEW_LINE DEDENT"}
{"text":"The loop is iterated till half the length of the array","code":"for i in range ( N \/\/ 2 + 1 ) : NEW_LINE"}
{"text":"Condition to avoid overwriting the middle element for the array with even length .","code":"if ( N % 2 == 0 and i == N \/\/ 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT"}
{"text":"Computing the number of subarrays","code":"x = N * ( i + 1 ) - ( i + 1 ) * i ; NEW_LINE"}
{"text":"The ith element from the beginning and the ending have the same number of possible subarrays","code":"v [ i ] = x ; NEW_LINE v [ N - i - 1 ] = x ; NEW_LINE return v ; NEW_LINE"}
{"text":"Function to print the vector","code":"def printArray ( v ) : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = calculateWays ( 4 ) ; NEW_LINE printArray ( v ) ; NEW_LINE DEDENT"}
{"text":"Python3 program to find the smallest number greater than or equal to X and divisible by Y","code":"MAXN = 10000000 NEW_LINE"}
{"text":"Function that returns the sum of digits of a number","code":"def sumOfDigits ( n ) : NEW_LINE"}
{"text":"Initialize variable to store the sum","code":"sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE"}
{"text":"Add the last digit of the number","code":"sum += n % 10 NEW_LINE"}
{"text":"Remove the last digit from the number","code":"n \/\/= 10 NEW_LINE return sum NEW_LINE"}
{"text":"Function that returns the smallest number greater than or equal to X and divisible by Y","code":"def smallestNum ( X , Y ) : NEW_LINE"}
{"text":"Initialize result variable","code":"res = - 1 ; NEW_LINE"}
{"text":"Loop through numbers greater than equal to X","code":"for i in range ( X , MAXN ) : NEW_LINE"}
{"text":"Calculate sum of digits","code":"sum_of_digit = sumOfDigits ( i ) NEW_LINE"}
{"text":"Check if sum of digits is divisible by Y","code":"if sum_of_digit % Y == 0 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( X , Y ) = ( 5923 , 13 ) NEW_LINE print ( smallestNum ( X , Y ) ) NEW_LINE DEDENT"}
{"text":"Function to count the numbers which can convert N to 1 using the given operation","code":"def countValues ( N ) : NEW_LINE INDENT div = [ ] NEW_LINE i = 2 NEW_LINE DEDENT"}
{"text":"Store all the divisors of N","code":"while ( ( i * i ) <= N ) : NEW_LINE"}
{"text":"If i is a divisor","code":"if ( N % i == 0 ) : NEW_LINE INDENT div . append ( i ) NEW_LINE DEDENT"}
{"text":"If i is not equal to N \/ i","code":"if ( N != i * i ) : NEW_LINE INDENT div . append ( N \/\/ i ) NEW_LINE DEDENT i += 1 NEW_LINE answer = 0 NEW_LINE i = 1 NEW_LINE"}
{"text":"Iterate through all the divisors of N - 1 and count them in answer","code":"while ( ( i * i ) <= N - 1 ) : NEW_LINE"}
{"text":"Check if N - 1 is a divisor or not","code":"if ( ( N - 1 ) % i == 0 ) : NEW_LINE INDENT if ( i * i == N - 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE"}
{"text":"Iterate through all divisors and check for N mod d = 1 or ( N - 1 ) mod d = 0","code":"for d in div : NEW_LINE INDENT K = N NEW_LINE while ( K % d == 0 ) : NEW_LINE INDENT K \/\/= d NEW_LINE DEDENT if ( ( K - 1 ) % d == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT"}
{"text":"Function to find the maximum possible prime divisors of a number can have with N divisors","code":"def findMaxPrimeDivisor ( n ) : NEW_LINE INDENT max_possible_prime = 0 NEW_LINE DEDENT"}
{"text":"Number of time number divided by 2","code":"while ( n % 2 == 0 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE n = n \/\/ 2 NEW_LINE DEDENT"}
{"text":"Divide by other prime numbers","code":"i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE n = n \/\/ i NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT"}
{"text":"If the last number of also prime then also include it","code":"if ( n > 2 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE DEDENT print ( max_possible_prime ) NEW_LINE"}
{"text":"Driver Code","code":"n = 4 NEW_LINE"}
{"text":"Function Call","code":"findMaxPrimeDivisor ( n ) NEW_LINE"}
{"text":"Function returns the count of ways express a number as sum of two numbers .","code":"def CountWays ( n ) : NEW_LINE INDENT ans = ( n - 1 ) \/\/ 2 NEW_LINE return ans NEW_LINE DEDENT"}
{"text":"Driver code","code":"N = 8 NEW_LINE print ( CountWays ( N ) ) NEW_LINE"}
{"text":"Function to find the max - size to which an array can be divided into 2 equal parts","code":"def Solve ( arr , size , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) ; NEW_LINE DEDENT"}
{"text":"Vector to find the frequency of each element of list","code":"for i in range ( size ) : NEW_LINE INDENT v [ arr [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"Find the maximum frequency element present in list arr","code":"max1 = max ( set ( arr ) , key = v . count ) NEW_LINE"}
{"text":"Find total unique elements present in list arr","code":"diff1 = n + 1 - v . count ( 0 ) NEW_LINE"}
{"text":"Find the Max - Size to which an array arr [ ] can be splitted","code":"max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) NEW_LINE print ( \" Maximum \u2581 size \u2581 is \u2581 : \" , max_size ) NEW_LINE"}
{"text":"Find the first array containing same elements","code":"print ( \" The \u2581 First \u2581 Array \u2581 Is \u2581 : \u2581 \" ) NEW_LINE for i in range ( max_size ) : NEW_LINE INDENT print ( max1 , end = \" \u2581 \" ) NEW_LINE v [ max1 ] -= 1 NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Find the second array containing unique elements","code":"print ( \" The \u2581 Second \u2581 Array \u2581 Is \u2581 : \u2581 \" ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( v [ i ] > 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE max_size -= 1 NEW_LINE DEDENT if ( max_size < 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Initialise n","code":"n = 7 NEW_LINE"}
{"text":"Array declaration","code":"arr = [ 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 ] NEW_LINE"}
{"text":"Size of array","code":"size = len ( arr ) NEW_LINE Solve ( arr , size , n ) NEW_LINE"}
{"text":"Iterative Function to calculate ( x ^ y ) % p in O ( log y )","code":"def power ( x , y , p ) : NEW_LINE"}
{"text":"Initialize result","code":"res = 1 NEW_LINE"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE"}
{"text":"If y is odd , multiply x with result","code":"if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT"}
{"text":"y must be even now y = y >> 1 y = y \/ 2","code":"x = ( x * x ) % p NEW_LINE return res NEW_LINE"}
{"text":"Returns n ^ ( - 1 ) mod p","code":"def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT"}
{"text":"Returns nCr % p using Fermat 's little theorem.","code":"def nCrModPFermat ( n , r , p ) : NEW_LINE"}
{"text":"Base case","code":"if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Fill factorial array so that we can find all factorial of r , n and n - r","code":"fac = [ 0 ] * ( n + 1 ) NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE"}
{"text":"Function returns sum of xor of all unordered triplets of the array","code":"def SumOfXor ( a , n ) : NEW_LINE INDENT mod = 10037 NEW_LINE answer = 0 NEW_LINE DEDENT"}
{"text":"Iterating over the bits","code":"for k in range ( 32 ) : NEW_LINE"}
{"text":"Number of elements whith k 'th bit  1 and 0 respectively","code":"x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Checking if k 'th bit is 1","code":"if ( a [ i ] & ( 1 << k ) ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT"}
{"text":"Adding this bit 's part to the answer","code":"answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod NEW_LINE return answer NEW_LINE"}
{"text":"Drivers code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE A = [ 3 , 5 , 2 , 18 , 7 ] NEW_LINE print ( SumOfXor ( A , n ) ) NEW_LINE DEDENT"}
{"text":"Python3 implementation to find the probability of not getting two consecutive heads together when N coins are tossed","code":"import math NEW_LINE"}
{"text":"Function to compute the N - th Fibonacci number in the sequence where a = 2 and b = 3","code":"def probability ( N ) : NEW_LINE"}
{"text":"The first two numbers in the sequence are initialized","code":"a = 2 NEW_LINE b = 3 NEW_LINE"}
{"text":"Base cases","code":"if N == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Loop to compute the fibonacci sequence based on the first two initialized numbers","code":"for i in range ( 3 , N + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE"}
{"text":"Function to find the probability of not getting two consecutive heads when N coins are tossed","code":"def operations ( N ) : NEW_LINE"}
{"text":"Computing the number of favourable cases","code":"x = probability ( N ) NEW_LINE"}
{"text":"Computing the number of all possible outcomes for N tosses","code":"y = math . pow ( 2 , N ) NEW_LINE return round ( x \/ y , 2 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( operations ( N ) ) NEW_LINE DEDENT"}
{"text":"Function to check if a number is a perfect Cube or not","code":"def isPerfectCube ( x ) : NEW_LINE INDENT x = abs ( x ) NEW_LINE return int ( round ( x ** ( 1. \/ 3 ) ) ) ** 3 == x NEW_LINE DEDENT"}
{"text":"Function to check if concatenation of two numbers is a perfect cube or not","code":"def checkCube ( a , b ) : NEW_LINE"}
{"text":"Convert numbers to string using to_string ( )","code":"s1 = str ( a ) NEW_LINE s2 = str ( b ) NEW_LINE"}
{"text":"Concatenate the numbers and convert it into integer","code":"c = int ( s1 + s2 ) NEW_LINE"}
{"text":"Check if concatenated value is perfect cube or not","code":"if ( isPerfectCube ( c ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 6 NEW_LINE b = 4 NEW_LINE checkCube ( a , b ) NEW_LINE DEDENT"}
{"text":"Function to return the largest sum","code":"def largest_sum ( arr , n ) : NEW_LINE"}
{"text":"Variable to store the largest sum","code":"maximum = - 1 NEW_LINE"}
{"text":"Map to store the frequencies of each element","code":"m = dict ( ) NEW_LINE"}
{"text":"Store the Frequencies","code":"for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT"}
{"text":"Loop to combine duplicate elements and update the sum in the map","code":"for j in list ( m ) : NEW_LINE"}
{"text":"If j is a duplicate element","code":"if ( ( j in m ) and m [ j ] > 1 ) : NEW_LINE"}
{"text":"Update the frequency of 2 * j","code":"x , y = 0 , 0 NEW_LINE if 2 * j in m : NEW_LINE INDENT m [ 2 * j ] = m [ 2 * j ] + m [ j ] \/\/ 2 NEW_LINE DEDENT else : NEW_LINE INDENT m [ 2 * j ] = m [ j ] \/\/ 2 NEW_LINE DEDENT"}
{"text":"If the new sum is greater than maximum value , Update the maximum","code":"if ( 2 * j > maximum ) : NEW_LINE INDENT maximum = 2 * j NEW_LINE DEDENT"}
{"text":"Returns the largest sum","code":"return maximum NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 4 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT"}
{"text":"Function Calling","code":"print ( largest_sum ( arr , n ) ) NEW_LINE"}
{"text":"Function to check if it is possible to make x and y can become 0 at same time","code":"def canBeReduced ( x , y ) : NEW_LINE INDENT maxi = max ( x , y ) NEW_LINE mini = min ( x , y ) NEW_LINE DEDENT"}
{"text":"Check the given conditions","code":"if ( ( ( x + y ) % 3 ) == 0 and maxi <= 2 * mini ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 6 NEW_LINE y = 9 NEW_LINE DEDENT"}
{"text":"Function Call","code":"canBeReduced ( x , y ) NEW_LINE"}
{"text":"Python3 program to check if the given number is prime using Wheel Factorization Method","code":"import math NEW_LINE"}
{"text":"Function to check if a given number x is prime or not","code":"def isPrime ( N ) : NEW_LINE INDENT isPrime = True ; NEW_LINE DEDENT"}
{"text":"The Wheel for checking prime number","code":"arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE"}
{"text":"Base Case","code":"if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT"}
{"text":"Check for the number taken as basis","code":"if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT"}
{"text":"Check for Wheel Here i , acts as the layer of the wheel","code":"for i in range ( 0 , int ( math . sqrt ( N ) ) , 30 ) : NEW_LINE"}
{"text":"Check for the list of Sieve in arr [ ]","code":"for c in arr : NEW_LINE"}
{"text":"If number is greater than sqrt ( N ) break","code":"if ( c > int ( math . sqrt ( N ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"Check if N is a multiple of prime number in the wheel","code":"else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"If at any iteration isPrime is false , break from the loop","code":"if ( not isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( isPrime ) : NEW_LINE print ( \" Prime \u2581 Number \" ) NEW_LINE else : NEW_LINE print ( \" Not \u2581 a \u2581 Prime \u2581 Number \" ) NEW_LINE"}
{"text":"Driver 's Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 121 NEW_LINE DEDENT"}
{"text":"Function call for primality check","code":"isPrime ( N ) NEW_LINE"}
{"text":"Function to prall possible pairs from the array","code":"def printPairs ( arr , n ) : NEW_LINE"}
{"text":"Nested loop for all possible pairs","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( \" ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" , end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"arr = [ 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"mod = int ( 1e9 ) + 7 ; NEW_LINE"}
{"text":"Function to return ( 2 ^ P % mod )","code":"def power ( p ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 ; NEW_LINE res %= mod ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT"}
{"text":"Function to return the sum of cubes of subsets","code":"def subset_cube_sum ( A ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE ans = 0 ; NEW_LINE DEDENT"}
{"text":"cubing the elements and adding it to ans","code":"for i in A : NEW_LINE INDENT ans += ( i * i * i ) % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT return ( ans * power ( n - 1 ) ) % mod ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 ] ; NEW_LINE print ( subset_cube_sum ( A ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 program to check if one circle lies inside another circle or not .","code":"def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ** ( .5 ) NEW_LINE if ( distSq + r2 == r1 ) : NEW_LINE INDENT print ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 with \u2581 \" \" touching \u2581 each \u2581 other \u2581 \" \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \u2581 \" ) NEW_LINE DEDENT elif ( distSq + r2 < r1 ) : NEW_LINE INDENT print ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 without \" \" \u2581 touching \u2581 each \u2581 other \u2581 \" \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The \u2581 smaller \u2581 does \u2581 not \u2581 lies \u2581 inside \" \" \u2581 the \u2581 bigger \u2581 circle \u2581 completely . \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"x1 , y1 = 10 , 8 NEW_LINE x2 , y2 = 1 , 2 NEW_LINE r1 , r2 = 30 , 10 NEW_LINE circle ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE"}
{"text":"Function to find the length of the direct common tangent","code":"def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \u2581 common \u2581 tangent \u2581 is \u2581 \" , ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 \/ 2 ) ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"r1 = 4 ; r2 = 6 ; d = 3 ; NEW_LINE lengtang ( r1 , r2 , d ) ; NEW_LINE"}
{"text":"Function to find the radius","code":"def rad ( d , h ) : NEW_LINE INDENT print ( \" The \u2581 radius \u2581 of \u2581 the \u2581 circle \u2581 is \" , ( ( d * d ) \/ ( 8 * h ) + h \/ 2 ) ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"d = 4 ; h = 1 ; NEW_LINE rad ( d , h ) ; NEW_LINE"}
{"text":"Function to find the shortest distance","code":"def shortdis ( r , d ) : NEW_LINE INDENT print ( \" The \u2581 shortest \u2581 distance \u2581 \" , end = \" \" ) ; NEW_LINE print ( \" from \u2581 the \u2581 chord \u2581 to \u2581 centre \u2581 \" , end = \" \" ) ; NEW_LINE print ( ( ( r * r ) - ( ( d * d ) \/ 4 ) ) ** ( 1 \/ 2 ) ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"r = 4 ; NEW_LINE d = 3 ; NEW_LINE shortdis ( r , d ) ; NEW_LINE"}
{"text":"Python3 program to find the length of the direct common tangent between two circles which do not touch each other","code":"import math NEW_LINE"}
{"text":"Function to find the length of the direct common tangent","code":"def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \u2581 common \u2581 tangent \u2581 is \" , ( ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 \/ 2 ) ) ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"r1 = 4 ; r2 = 6 ; d = 12 ; NEW_LINE lengtang ( r1 , r2 , d ) ; NEW_LINE"}
{"text":"Function to find the side of the square","code":"def square ( a ) : NEW_LINE"}
{"text":"the side cannot be negative","code":"if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"side of the square","code":"x = 0.464 * a NEW_LINE return x NEW_LINE"}
{"text":"Driver code","code":"a = 5 NEW_LINE print ( square ( a ) ) NEW_LINE"}
{"text":"Python 3 Program to find the apothem of a regular polygon with given side length","code":"from math import tan NEW_LINE"}
{"text":"Function to find the apothem of a regular polygon","code":"def polyapothem ( n , a ) : NEW_LINE"}
{"text":"Side and side length cannot be negative","code":"if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Degree converted to radians","code":"return a \/ ( 2 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyapothem ( n , a ) ) ) NEW_LINE DEDENT"}
{"text":"Python 3 Program to find the area of a regular polygon with given side length","code":"from math import tan NEW_LINE"}
{"text":"Function to find the area of a regular polygon","code":"def polyarea ( n , a ) : NEW_LINE"}
{"text":"Side and side length cannot be negative","code":"if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Area degree converted to radians","code":"A = ( a * a * n ) \/ ( 4 * tan ( ( 180 \/ n ) * 3.14159 \/ 180 ) ) NEW_LINE return A NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyarea ( n , a ) ) ) NEW_LINE DEDENT"}
{"text":"Python 3 implementation of the approach","code":"from math import sin NEW_LINE"}
{"text":"Function to calculate the side of the polygon circumscribed in a circle","code":"def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 \/ n NEW_LINE theta_in_radians = theta * 3.14 \/ 180 NEW_LINE return 2 * r * sin ( theta_in_radians \/ 2 ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Total sides of the polygon","code":"n = 3 NEW_LINE"}
{"text":"Radius of the circumscribing circle","code":"r = 5 NEW_LINE print ( ' { 0 : . 5 } ' . format ( calculateSide ( n , r ) ) ) NEW_LINE"}
{"text":"Function to find the biggest right circular cylinder","code":"def cyl ( r , R , h ) : NEW_LINE"}
{"text":"radii and height cannot be negative","code":"if ( h < 0 and r < 0 and R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"radius of right circular cylinder","code":"r1 = r NEW_LINE"}
{"text":"height of right circular cylinder","code":"h1 = h NEW_LINE"}
{"text":"volume of right circular cylinder","code":"V = 3.14 * pow ( r1 , 2 ) * h1 NEW_LINE return round ( V , 2 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , R , h = 7 , 11 , 6 NEW_LINE print ( cyl ( r , R , h ) ) NEW_LINE DEDENT"}
{"text":"Function to calculate the perimeter","code":"def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE DEDENT"}
{"text":"Calculate Perimeter","code":"perimeter = n * s NEW_LINE return perimeter NEW_LINE"}
{"text":"driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Get the number of sides","code":"n = 5 NEW_LINE"}
{"text":"Get the length of side","code":"s = 2.5 NEW_LINE"}
{"text":"find perimeter","code":"peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter \u2581 of \u2581 Regular \u2581 Polygon \u2581 with \" , n , \" sides \u2581 of \u2581 length \" , s , \" = \" , peri ) NEW_LINE"}
{"text":"Function to find the area of the biggest rhombus","code":"def rhombusarea ( l , b ) : NEW_LINE"}
{"text":"the length and breadth cannot be negative","code":"if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"area of the rhombus","code":"return ( l * b ) \/ 2 NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 16 NEW_LINE b = 6 NEW_LINE print ( rhombusarea ( l , b ) ) NEW_LINE DEDENT"}
{"text":"function to find if given point lies inside a given rectangle or not .","code":"def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"bottom - left and top - right corners of rectangle . use multiple assignment","code":"x1 , y1 , x2 , y2 = 0 , 0 , 10 , 8 NEW_LINE"}
{"text":"given point","code":"x , y = 1 , 5 NEW_LINE"}
{"text":"function call","code":"if FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Python program to find the Perpendicular ( shortest ) distance between a point and a Plane in 3 D .","code":"import math NEW_LINE"}
{"text":"Function to find distance","code":"def shortest_distance ( x1 , y1 , z1 , a , b , c , d ) : NEW_LINE INDENT d = abs ( ( a * x1 + b * y1 + c * z1 + d ) ) NEW_LINE e = ( math . sqrt ( a * a + b * b + c * c ) ) NEW_LINE print ( \" Perpendicular \u2581 distance \u2581 is \" , d \/ e ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"x1 = 4 NEW_LINE y1 = - 4 NEW_LINE z1 = 3 NEW_LINE a = 2 NEW_LINE b = - 2 NEW_LINE c = 5 NEW_LINE d = 8 NEW_LINE"}
{"text":"Function call","code":"shortest_distance ( x1 , y1 , z1 , a , b , c , d ) NEW_LINE"}
{"text":"function to find the Volume of triangular prism","code":"def findVolume ( l , b , h ) : NEW_LINE"}
{"text":"formula to find Volume","code":"return ( ( l * b * h ) \/ 2 ) NEW_LINE"}
{"text":"Driver Code","code":"l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE"}
{"text":"function calling","code":"print ( \" Volume \u2581 of \u2581 triangular \u2581 prism : \u2581 \" , findVolume ( l , b , h ) ) NEW_LINE"}
{"text":"Function to check if the given integers value make a rectangle","code":"def isRectangle ( a , b , c , d ) : NEW_LINE"}
{"text":"check all sides of rectangle combinations","code":"if ( a == b and d == c ) or ( a == c and b == d ) or ( a == d and b == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE"}
{"text":"Function to find the midpoint of a line","code":"def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) \/\/ 2 , \" \u2581 , \u2581 \" , ( y1 + y2 ) \/\/ 2 ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"x1 , y1 , x2 , y2 = - 1 , 2 , 3 , - 6 NEW_LINE midpoint ( x1 , x2 , y1 , y2 ) NEW_LINE"}
{"text":"Python3 code to calculate length of an arc","code":"import math NEW_LINE"}
{"text":"function to calculate arc length","code":"def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( \" Angle \u2581 cannot \u2581 be \u2581 formed \" ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle \/ 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"diameter = 25.0 NEW_LINE angle = 45.0 NEW_LINE arc_len = arcLength ( diameter , angle ) NEW_LINE print ( arc_len ) NEW_LINE"}
{"text":"python program to check if a line touches or intersects or outside a circle .","code":"import math NEW_LINE def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE"}
{"text":"Finding the distance of line from center .","code":"dist = ( ( abs ( a * x + b * y + c ) ) \/ math . sqrt ( a * a + b * b ) ) NEW_LINE"}
{"text":"Checking if the distance is less than , greater than or equal to radius .","code":"if ( radius == dist ) : NEW_LINE INDENT print ( \" Touch \" ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( \" Intersect \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Outside \" ) NEW_LINE DEDENT"}
{"text":"Driven Program","code":"radius = 5 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 25 NEW_LINE checkCollision ( a , b , c , x , y , radius ) NEW_LINE"}
{"text":"Function to find the line given two points","code":"def lineFromPoints ( P , Q , a , b , c ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE return a , b , c NEW_LINE DEDENT"}
{"text":"Function which converts the input line to its perpendicular bisector . It also inputs the points whose mid - point lies on the bisector","code":"def perpendicularBisectorFromLine ( P , Q , a , b , c ) : NEW_LINE INDENT mid_point = [ ( P [ 0 ] + Q [ 0 ] ) \/\/ 2 , ( P [ 1 ] + Q [ 1 ] ) \/\/ 2 ] NEW_LINE DEDENT"}
{"text":"c = - bx + ay","code":"c = - b * ( mid_point [ 0 ] ) + a * ( mid_point [ 1 ] ) NEW_LINE temp = a NEW_LINE a = - b NEW_LINE b = temp NEW_LINE return a , b , c NEW_LINE"}
{"text":"Returns the intersection point of two lines","code":"def lineLineIntersection ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT determinant = a1 * b2 - a2 * b1 NEW_LINE if ( determinant == 0 ) : NEW_LINE DEDENT"}
{"text":"The lines are parallel . This is simplified by returning a pair of ( 10.0 ) * * 19","code":"return [ ( 10.0 ) ** 19 , ( 10.0 ) ** 19 ] NEW_LINE else : NEW_LINE x = ( b2 * c1 - b1 * c2 ) \/\/ determinant NEW_LINE y = ( a1 * c2 - a2 * c1 ) \/\/ determinant NEW_LINE return [ x , y ] NEW_LINE def findCircumCenter ( P , Q , R ) : NEW_LINE"}
{"text":"Line PQ is represented as ax + by = c","code":"a , b , c = 0.0 , 0.0 , 0.0 NEW_LINE a , b , c = lineFromPoints ( P , Q , a , b , c ) NEW_LINE"}
{"text":"Line QR is represented as ex + fy = g","code":"e , f , g = 0.0 , 0.0 , 0.0 NEW_LINE e , f , g = lineFromPoints ( Q , R , e , f , g ) NEW_LINE"}
{"text":"Converting lines PQ and QR to perpendicular vbisectors . After this , L = ax + by = c M = ex + fy = g","code":"a , b , c = perpendicularBisectorFromLine ( P , Q , a , b , c ) NEW_LINE e , f , g = perpendicularBisectorFromLine ( Q , R , e , f , g ) NEW_LINE"}
{"text":"The point of intersection of L and M gives the circumcenter","code":"circumcenter = lineLineIntersection ( a , b , c , e , f , g ) NEW_LINE if ( circumcenter [ 0 ] == ( 10.0 ) ** 19 and circumcenter [ 1 ] == ( 10.0 ) ** 19 ) : NEW_LINE INDENT print ( \" The \u2581 two \u2581 perpendicular \u2581 bisectors \u2581 found \u2581 come \u2581 parallel \" ) NEW_LINE print ( \" Thus , \u2581 the \u2581 given \u2581 points \u2581 do \u2581 not \u2581 form \u2581 a \u2581 triangle \u2581 and \u2581 are \u2581 collinear \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The \u2581 circumcenter \u2581 of \u2581 the \u2581 triangle \u2581 PQR \u2581 is : \u2581 \" , end = \" \" ) NEW_LINE print ( \" ( \" , circumcenter [ 0 ] , \" , \" , circumcenter [ 1 ] , \" ) \" ) NEW_LINE DEDENT"}
{"text":"Driver code .","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = [ 6 , 0 ] NEW_LINE Q = [ 0 , 0 ] NEW_LINE R = [ 0 , 8 ] NEW_LINE findCircumCenter ( P , Q , R ) NEW_LINE DEDENT"}
{"text":"( X [ i ] , Y [ i ] ) are coordinates of i 'th point.","code":"def polygonArea ( X , Y , n ) : NEW_LINE"}
{"text":"Initialize area","code":"area = 0.0 NEW_LINE"}
{"text":"Calculate value of shoelace formula","code":"j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT"}
{"text":"Return absolute value","code":"return abs ( area \/\/ 2.0 ) NEW_LINE"}
{"text":"Driver program to test above function","code":"X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"}
{"text":"Function top get LSB value of v","code":"def chk ( v ) : NEW_LINE"}
{"text":"Binary conversion","code":"v = list ( bin ( v ) [ 2 : ] ) NEW_LINE v . reverse ( ) NEW_LINE if ( '1' in v ) : NEW_LINE INDENT v = v . index ( '1' ) NEW_LINE return ( 2 ** v ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Function to find the sum of LSBs of all possible pairs of the given array","code":"def sumOfLSB ( arr , N ) : NEW_LINE"}
{"text":"Stores the LSB of array elements","code":"lsb_arr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"Storing the LSB values","code":"lsb_arr . append ( chk ( arr [ i ] ) ) NEW_LINE"}
{"text":"Sort the array lab_arr [ ]","code":"lsb_arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N - 1 , 2 ) : NEW_LINE"}
{"text":"Taking pairwise sum to get the maximum sum of LSB","code":"ans += ( lsb_arr [ i + 1 ] ) NEW_LINE"}
{"text":"Print the result","code":"print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"N = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE"}
{"text":"Function Call","code":"sumOfLSB ( arr , N ) NEW_LINE"}
{"text":"Function to find count of subsequences having odd bitwise AND value","code":"def countSubsequences ( arr ) : NEW_LINE"}
{"text":"Stores count of odd elements","code":"odd = 0 NEW_LINE"}
{"text":"Traverse the array arr [ ]","code":"for x in arr : NEW_LINE"}
{"text":"If x is odd increment count","code":"if ( x & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT"}
{"text":"Return Answer","code":"return ( 1 << odd ) - 1 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 ] NEW_LINE DEDENT"}
{"text":"Function Call","code":"print ( countSubsequences ( arr ) ) NEW_LINE"}
{"text":"Function to find the number of pairs ( i , j ) such that abs ( a [ i ] - a [ j ] ) is at least the minimum of ( a [ i ] , a [ j ] )","code":"def getPairsCount ( arr , n ) : NEW_LINE"}
{"text":"Stores the resultant count of pairs","code":"count = 0 NEW_LINE"}
{"text":"Iterate over the range [ 0 , n ]","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Iterate from arr [ i ] - ( i % arr [ i ] ) till n with an increment of arr [ i ]","code":"for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE"}
{"text":"Count the possible pairs","code":"if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Return the total count","code":"return count NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getPairsCount ( arr , N ) ) NEW_LINE DEDENT"}
{"text":"Function to check if N can be changed to 1 or not .","code":"def check ( N ) : NEW_LINE INDENT twos = 0 NEW_LINE fives = 0 NEW_LINE DEDENT"}
{"text":"Count the number of 2 in the prime factorisation of N","code":"while ( N % 2 == 0 ) : NEW_LINE INDENT N \/= 2 NEW_LINE twos += 1 NEW_LINE DEDENT"}
{"text":"Count the number of 5 in the prime factorisation of N","code":"while ( N % 5 == 0 ) : NEW_LINE INDENT N \/= 5 NEW_LINE fives += 1 NEW_LINE DEDENT if ( N == 1 and twos <= fives ) : NEW_LINE INDENT print ( 2 * fives - twos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 50 NEW_LINE check ( N ) NEW_LINE DEDENT"}
{"text":"Function to find the sum of elements in a given range of an infinite array","code":"def rangeSum ( arr , N , L , R ) : NEW_LINE"}
{"text":"Stores the sum of array elements from L to R","code":"sum = 0 NEW_LINE"}
{"text":"Traverse from L to R","code":"for i in range ( L - 1 , R , 1 ) : NEW_LINE INDENT sum += arr [ i % N ] NEW_LINE DEDENT"}
{"text":"Print the resultant sum","code":"print ( sum ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 6 , 9 ] NEW_LINE L = 10 NEW_LINE R = 13 NEW_LINE N = len ( arr ) NEW_LINE rangeSum ( arr , N , L , R ) NEW_LINE DEDENT"}
{"text":"Function to find the sum of elements in a given range of an infinite array","code":"def rangeSum ( arr , N , L , R ) : NEW_LINE"}
{"text":"Stores the prefix sum","code":"prefix = [ 0 for i in range ( N + 1 ) ] NEW_LINE prefix [ 0 ] = 0 NEW_LINE"}
{"text":"Calculate the prefix sum","code":"for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT"}
{"text":"Stores the sum of elements from 1 to L - 1","code":"leftsum = ( ( L - 1 ) \/\/ N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] NEW_LINE"}
{"text":"Stores the sum of elements from 1 to R","code":"rightsum = ( R \/\/ N ) * prefix [ N ] + prefix [ R % N ] NEW_LINE"}
{"text":"Print the resultant sum","code":"print ( rightsum - leftsum ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 6 , 9 ] NEW_LINE L = 10 NEW_LINE R = 13 NEW_LINE N = len ( arr ) NEW_LINE rangeSum ( arr , N , L , R ) NEW_LINE DEDENT"}
{"text":"Function to find exponential factorial of a given number","code":"def ExpoFactorial ( N ) : NEW_LINE"}
{"text":"Stores the exponetial factor of N","code":"res = 1 NEW_LINE mod = ( int ) ( 1000000007 ) NEW_LINE"}
{"text":"Iterare over the range [ 2 , N ]","code":"for i in range ( 2 , N + 1 ) : NEW_LINE"}
{"text":"Update res","code":"res = pow ( i , res , mod ) NEW_LINE"}
{"text":"Return res","code":"return res NEW_LINE"}
{"text":"Input","code":"N = 4 NEW_LINE"}
{"text":"Function call","code":"print ( ExpoFactorial ( N ) ) NEW_LINE"}
{"text":"Function to find contiguous subarray with maximum sum if array is repeated K times","code":"def maxSubArraySumRepeated ( arr , N , K ) : NEW_LINE"}
{"text":"Store the sum of the array arr [ ]","code":"sum = 0 NEW_LINE"}
{"text":"Traverse the array and find sum","code":"for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT curr = arr [ 0 ] NEW_LINE"}
{"text":"Store the answer","code":"ans = arr [ 0 ] NEW_LINE"}
{"text":"If K = 1","code":"if ( K == 1 ) : NEW_LINE"}
{"text":"Apply Kadane algorithm to find sum","code":"for i in range ( 1 , N , 1 ) : NEW_LINE INDENT curr = max ( arr [ i ] , curr + arr [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT"}
{"text":"Return the answer","code":"return ans NEW_LINE"}
{"text":"Stores the twice repeated array","code":"V = [ ] NEW_LINE"}
{"text":"Traverse the range [ 0 , 2 * N ]","code":"for i in range ( 2 * N ) : NEW_LINE INDENT V . append ( arr [ i % N ] ) NEW_LINE DEDENT"}
{"text":"Stores the maximum suffix sum","code":"maxSuf = V [ 0 ] NEW_LINE"}
{"text":"Stores the maximum prefix sum","code":"maxPref = V [ 2 * N - 1 ] NEW_LINE curr = V [ 0 ] NEW_LINE for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxPref = max ( maxPref , curr ) NEW_LINE DEDENT curr = V [ 2 * N - 1 ] NEW_LINE i = 2 * N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxSuf = max ( maxSuf , curr ) NEW_LINE i -= 1 NEW_LINE DEDENT curr = V [ 0 ] NEW_LINE"}
{"text":"Apply Kadane algorithm for 2 repetition of the array","code":"for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr = max ( V [ i ] , curr + V [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT"}
{"text":"If the sum of the array is greater than 0","code":"if ( sum > 0 ) : NEW_LINE INDENT temp = sum * ( K - 2 ) NEW_LINE ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) NEW_LINE DEDENT"}
{"text":"Return the answer","code":"return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Input","code":"arr = [ 10 , 20 , - 30 , - 1 , 40 ] NEW_LINE N = len ( arr ) NEW_LINE K = 10 NEW_LINE"}
{"text":"Function Call","code":"print ( maxSubArraySumRepeated ( arr , N , K ) ) NEW_LINE"}
{"text":"Function to find count of subarrays which have max element greater than twice maximum of all other elements","code":"def countSubarray ( arr , n ) : NEW_LINE"}
{"text":"Stores the count of subarrays","code":"count = 0 NEW_LINE"}
{"text":"Generate all possible subarrays","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n , 1 ) : NEW_LINE DEDENT"}
{"text":"Stores the maximum element of the subarray","code":"mxSubarray = 0 NEW_LINE"}
{"text":"Stores the maximum of all other elements","code":"mxOther = 0 NEW_LINE"}
{"text":"Find the maximum element in the subarray [ i , j ]","code":"for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT mxSubarray = max ( mxSubarray , arr [ k ] ) NEW_LINE DEDENT"}
{"text":"Find the maximum of all other elements","code":"for k in range ( 0 , i , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT"}
{"text":"If the maximum of subarray is greater than twice the maximum of other elements","code":"if ( mxSubarray > ( 2 * mxOther ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT"}
{"text":"Print the maximum value obtained","code":"print ( count ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countSubarray ( arr , N ) NEW_LINE DEDENT"}
{"text":"Function to find count of subarrays which have max element greater than twice maximum of all other elements","code":"def countSubarray ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE L = 0 NEW_LINE R = 0 NEW_LINE DEDENT"}
{"text":"Stores the maximum element of the array","code":"mx = max ( arr ) NEW_LINE"}
{"text":"Traverse the given array","code":"for i in range ( n ) : NEW_LINE"}
{"text":"If the value of 2 * arr [ i ] is greater than mx","code":"if ( arr [ i ] * 2 > mx ) : NEW_LINE"}
{"text":"Update the value of L and break out of loop","code":"L = i NEW_LINE break NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE"}
{"text":"If the value 2 * arr [ i ] is greater than mx","code":"if ( arr [ i ] * 2 > mx ) : NEW_LINE"}
{"text":"Update the value of R and break out of loop","code":"R = i NEW_LINE break NEW_LINE i -= 1 NEW_LINE"}
{"text":"Print the final answer","code":"print ( ( L + 1 ) * ( n - R ) ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countSubarray ( arr , N ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"from math import sqrt NEW_LINE"}
{"text":"Utility function to check for primality of a number X by checking whether X haACCs any factors other than 1 and itself .","code":"def isPrime ( X ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( X ) ) + 1 , 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE DEDENT DEDENT"}
{"text":"Factor found","code":"return False NEW_LINE return True NEW_LINE"}
{"text":"Function to print primes just less than and just greater than of each element in an array","code":"def printPrimes ( A , N ) : NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( N ) : NEW_LINE"}
{"text":"Traverse for finding prime just less than A [ i ]","code":"j = A [ i ] - 1 NEW_LINE while ( 1 ) : NEW_LINE"}
{"text":"Prime just less than A [ i ] found","code":"if ( isPrime ( j ) ) : NEW_LINE INDENT print ( j , end = \" \u2581 \" ) NEW_LINE break NEW_LINE DEDENT j -= 1 NEW_LINE"}
{"text":"Traverse for finding prime just greater than A [ i ]","code":"j = A [ i ] + 1 NEW_LINE while ( 1 ) : NEW_LINE"}
{"text":"Prime just greater than A [ i ] found","code":"if ( isPrime ( j ) ) : NEW_LINE INDENT print ( j , end = \" \u2581 \" ) NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE print ( \" \" , \u2581 end \u2581 = \u2581 \" \" ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Input","code":"A = [ 17 , 28 ] NEW_LINE N = len ( A ) NEW_LINE"}
{"text":"Function call","code":"printPrimes ( A , N ) NEW_LINE"}
{"text":"Function to find the Kth smallest element that contains A [ i ] exactly B [ i ] times","code":"def KthSmallest ( A , B , N , K ) : NEW_LINE INDENT M = 0 NEW_LINE DEDENT"}
{"text":"Traverse the given array","code":"for i in range ( N ) : NEW_LINE INDENT M = max ( A [ i ] , M ) NEW_LINE DEDENT"}
{"text":"Stores the frequency of every elements","code":"freq = [ 0 ] * ( M + 1 ) NEW_LINE"}
{"text":"Traverse the given array","code":"for i in range ( N ) : NEW_LINE INDENT freq [ A [ i ] ] += B [ i ] NEW_LINE DEDENT"}
{"text":"Initialize a variable to store the prefix sums","code":"sum = 0 NEW_LINE"}
{"text":"Iterate over the range [ 0 , M ]","code":"for i in range ( M + 1 ) : NEW_LINE"}
{"text":"Increment sum by freq [ i ]","code":"sum += freq [ i ] NEW_LINE"}
{"text":"If sum is greater than or equal to K","code":"if ( sum >= K ) : NEW_LINE"}
{"text":"Return the current element as answer","code":"return i NEW_LINE"}
{"text":"Return - 1","code":"return - 1 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given Input","code":"A = [ 3 , 4 , 5 ] NEW_LINE B = [ 2 , 1 , 3 ] NEW_LINE N = len ( A ) NEW_LINE K = 4 NEW_LINE"}
{"text":"Function call","code":"print ( KthSmallest ( A , B , N , K ) ) NEW_LINE"}
{"text":"Function to find the Bitwise OR of Bitwise AND of all subarrays","code":"def findbitwiseOR ( a , n ) : NEW_LINE"}
{"text":"Stores the required result","code":"res = 0 NEW_LINE"}
{"text":"Generate all the subarrays","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Store the current element","code":"curr_sub_array = a [ i ] NEW_LINE"}
{"text":"Find the Bitwise OR","code":"res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE"}
{"text":"Update the result","code":"curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE"}
{"text":"Print the result","code":"print ( res ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE findbitwiseOR ( A , N ) NEW_LINE DEDENT"}
{"text":"Function to find the Bitwise OR of Bitwise AND of all consecutive subsets of the array","code":"def findbitwiseOR ( a , n ) : NEW_LINE"}
{"text":"Stores the required result","code":"res = 0 NEW_LINE"}
{"text":"Traverse the given array","code":"for i in range ( n ) : NEW_LINE INDENT res = res | a [ i ] NEW_LINE DEDENT"}
{"text":"Print the result","code":"print ( res ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE findbitwiseOR ( A , N ) NEW_LINE DEDENT"}
{"text":"Function to check if the sum of the digits of N is strictly greater than the product of the digits of N or not","code":"def check ( n ) : NEW_LINE"}
{"text":"Stores the sum and the product of the digits of N","code":"sumOfDigit = 0 NEW_LINE prodOfDigit = 1 NEW_LINE while n > 0 : NEW_LINE"}
{"text":"Stores the last digit if N","code":"rem = n % 10 NEW_LINE"}
{"text":"Increment the value of sumOfDigits","code":"sumOfDigit += rem NEW_LINE"}
{"text":"Update the prodOfDigit","code":"prodOfDigit *= rem NEW_LINE"}
{"text":"Divide N by 10","code":"n = n \/\/ 10 NEW_LINE"}
{"text":"Print the result","code":"if sumOfDigit > prodOfDigit : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 1234 NEW_LINE check ( N ) NEW_LINE"}
{"text":"Print all distinct even & odd prefix Bitwise XORs from 1 to N","code":"def evenOddBitwiseXOR ( N ) : NEW_LINE INDENT print ( \" Even : \u2581 \" , 0 , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Print the even number","code":"for i in range ( 4 , N + 1 , 4 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE print ( \" Odd : \u2581 \" , 1 , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Print the odd number","code":"for i in range ( 4 , N + 1 , 4 ) : NEW_LINE INDENT print ( i - 1 , end = \" \u2581 \" ) NEW_LINE DEDENT if ( N % 4 == 2 ) : NEW_LINE INDENT print ( N + 1 ) NEW_LINE DEDENT elif ( N % 4 == 3 ) : NEW_LINE INDENT print ( N ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 6 NEW_LINE evenOddBitwiseXOR ( N ) NEW_LINE"}
{"text":"Function to lexicographic largest permutation possible by a swap that is smaller than given array","code":"def findPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE i = N - 2 NEW_LINE DEDENT"}
{"text":"Find the index of first element such that arr [ i ] > arr [ i + 1 ]","code":"while ( i >= 0 and arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT"}
{"text":"If the array is sorted in increasing order","code":"if ( i == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT j = N - 1 NEW_LINE"}
{"text":"Find the index of first element which is smaller than arr [ i ]","code":"while ( j > i and arr [ j ] >= arr [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT"}
{"text":"If arr [ j ] = = arr [ j - 1 ]","code":"while ( j > i and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE"}
{"text":"Decrement j","code":"j -= 1 NEW_LINE"}
{"text":"Swap the element","code":"temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE"}
{"text":"Pr the array arr [ ]","code":"for it in arr : NEW_LINE INDENT print ( it , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE findPermutation ( arr ) NEW_LINE"}
{"text":"Function to find the smallest prime factor of all the numbers using Sieve Of Eratosthenes","code":"def sieveOfEratosthenes ( N , s ) : NEW_LINE"}
{"text":"Stores whether any number is prime or not","code":"prime = [ False ] * ( N + 1 ) NEW_LINE"}
{"text":"Initialize smallest factor as 2 for all the even numbers","code":"for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT"}
{"text":"Iterate over the range [ 3 , N ]","code":"for i in range ( 3 , N , 2 ) : NEW_LINE"}
{"text":"If i is prime","code":"if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE DEDENT"}
{"text":"Iterate all multiples of i","code":"for j in range ( i , N , 2 ) : NEW_LINE INDENT if j * i > N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT"}
{"text":"i is the smallest prime factor of i * j","code":"if ( not prime [ i * j ] ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT"}
{"text":"Function to find the absolute difference between the count of odd and even factors of N","code":"def findDifference ( N ) : NEW_LINE"}
{"text":"Stores the smallest prime factor of i","code":"s = [ 0 ] * ( N + 1 ) NEW_LINE"}
{"text":"Fill values in s [ ] using sieve of eratosthenes","code":"sieveOfEratosthenes ( N , s ) NEW_LINE"}
{"text":"Stores the total number of factors and the total number of odd and even factors","code":"total , odd , even = 1 , 1 , 0 NEW_LINE"}
{"text":"Store the current prime factor of the number N","code":"curr = s [ N ] NEW_LINE"}
{"text":"Store the power of current prime factor","code":"cnt = 1 NEW_LINE"}
{"text":"Loop while N is greater than 1","code":"while ( N > 1 ) : NEW_LINE INDENT N \/\/= s [ N ] NEW_LINE DEDENT"}
{"text":"If N also has smallest prime factor as curr , then increment cnt by 1","code":"if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT"}
{"text":"Update only total number of factors if curr is 2","code":"if ( curr == 2 ) : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE DEDENT"}
{"text":"Update total number of factors and total number of odd factors","code":"else : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE odd = odd * ( cnt + 1 ) NEW_LINE DEDENT"}
{"text":"Update current prime factor as s [ N ] and count as 1","code":"curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE"}
{"text":"Calculate the number of even factors","code":"even = total - odd NEW_LINE"}
{"text":"Print the difference","code":"print ( abs ( even - odd ) ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE findDifference ( N ) NEW_LINE DEDENT"}
{"text":"Function to find the median of a group of data with given mean and mode","code":"def findMedian ( Mean , Mode ) : NEW_LINE"}
{"text":"Calculate the median","code":"Median = ( 2 * Mean + Mode ) \/\/ 3 NEW_LINE"}
{"text":"Print the median","code":"print ( Median ) NEW_LINE"}
{"text":"Driver code","code":"Mode = 6 NEW_LINE Mean = 3 NEW_LINE findMedian ( Mean , Mode ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from math import sqrt NEW_LINE"}
{"text":"Function to calculate magnitude of a 3 dimensional vector","code":"def vectorMagnitude ( x , y , z ) : NEW_LINE"}
{"text":"Stores the sum of squares of coordinates of a vector","code":"sum = x * x + y * y + z * z NEW_LINE"}
{"text":"Return the magnitude","code":"return sqrt ( sum ) NEW_LINE"}
{"text":"Driver code","code":"x = 1 NEW_LINE y = 2 NEW_LINE z = 3 NEW_LINE print ( vectorMagnitude ( x , y , z ) ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to find prodcut of a Mersenne number with another number","code":"def multiplyByMersenne ( N , M ) : NEW_LINE"}
{"text":"Stores the power of 2 of integer M + 1","code":"x = int ( math . log2 ( M + 1 ) ) NEW_LINE"}
{"text":"Return the product","code":"return ( ( N << x ) - N ) NEW_LINE"}
{"text":"Driver Code","code":"N = 4 NEW_LINE M = 15 NEW_LINE print ( multiplyByMersenne ( N , M ) ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"from math import sqrt , log2 , pow NEW_LINE"}
{"text":"Function to find nearest perfect square of num","code":"def perfectSquare ( num ) : NEW_LINE"}
{"text":"Calculate square root of num","code":"sr = int ( sqrt ( num ) ) NEW_LINE"}
{"text":"Calculate perfect square","code":"a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE"}
{"text":"Find the nearest perfect square","code":"if ( ( num - a ) < ( b - num ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT"}
{"text":"Function to find the power of 2 nearest to the number num","code":"def powerOfTwo ( num ) : NEW_LINE"}
{"text":"Calculate log base 2 of num","code":"lg = int ( log2 ( num ) ) NEW_LINE"}
{"text":"Highest power of 2 which is <= num","code":"p = int ( pow ( 2 , lg ) ) NEW_LINE return p NEW_LINE"}
{"text":"Function to find the nearest perfect square and the nearest power of 2 of every array element whose occurrence is 1","code":"def uniqueElement ( arr , N ) : NEW_LINE INDENT ans = True NEW_LINE DEDENT"}
{"text":"Stores frequency of array elements","code":"freq = { } NEW_LINE"}
{"text":"Traverse the array and update frequency of current array element","code":"for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] in freq ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT"}
{"text":"Traverse the map freq","code":"res = [ ] NEW_LINE for key , value in freq . items ( ) : NEW_LINE"}
{"text":"If the frequency is 1","code":"if ( value == 1 ) : NEW_LINE INDENT ans = False NEW_LINE DEDENT"}
{"text":"Find nearest perfect square","code":"ps = perfectSquare ( key ) NEW_LINE"}
{"text":"Print the nearest power of 2","code":"res . append ( powerOfTwo ( ps ) ) NEW_LINE res . sort ( reverse = False ) NEW_LINE for x in res : NEW_LINE print ( x , end = \" \u2581 \" ) NEW_LINE"}
{"text":"If the any does not contain any non - repeating elements","code":"if ( ans ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 11 , 4 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE uniqueElement ( arr , N ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to partition the array into two non - empty subarrays which satisfies the given condition","code":"def partitionArray ( a , n ) : NEW_LINE"}
{"text":"Stores the suffix Min array","code":"INDENT Min = [ 0 ] * n NEW_LINE DEDENT"}
{"text":"Stores the Minimum of a suffix","code":"INDENT Mini = sys . maxsize NEW_LINE DEDENT"}
{"text":"Traverse the array in reverse","code":"INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT"}
{"text":"Update Minimum","code":"Mini = min ( Mini , a [ i ] ) NEW_LINE"}
{"text":"Store the Minimum","code":"Min [ i ] = Mini NEW_LINE"}
{"text":"Stores the Maximum value of a prefix","code":"INDENT Maxi = - sys . maxsize - 1 NEW_LINE DEDENT"}
{"text":"Stores the index of the partition","code":"INDENT ind = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE DEDENT"}
{"text":"Update Max","code":"Maxi = max ( Maxi , a [ i ] ) NEW_LINE"}
{"text":"If Max is less than Min [ i + 1 ]","code":"if ( Maxi < Min [ i + 1 ] ) : NEW_LINE"}
{"text":"Store the index of partition","code":"ind = i NEW_LINE"}
{"text":"break","code":"break NEW_LINE"}
{"text":"If ind is not - 1","code":"INDENT if ( ind != - 1 ) : NEW_LINE DEDENT"}
{"text":"Print first subarray","code":"for i in range ( ind + 1 ) : NEW_LINE print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE print ( ) NEW_LINE"}
{"text":"Print second subarray","code":"for i in range ( ind + 1 , n , 1 ) : NEW_LINE print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Otherwise","code":"INDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"arr = [ 5 , 3 , 2 , 7 , 9 ] NEW_LINE N = 5 NEW_LINE partitionArray ( arr , N ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to count all prime factors of a given number","code":"def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT"}
{"text":"Count the number of 2 s that divides n","code":"while ( n % 2 == 0 ) : NEW_LINE INDENT n = n \/\/ 2 NEW_LINE count += 1 NEW_LINE DEDENT"}
{"text":"Since n is odd at this point , skip one element","code":"for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) , 2 ) : NEW_LINE"}
{"text":"While i divides n , count i and divide n","code":"while ( n % i == 0 ) : NEW_LINE INDENT n = n \/\/ i NEW_LINE count += 1 NEW_LINE DEDENT"}
{"text":"If n is a prime number greater than 2","code":"if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE"}
{"text":"Function to find the sum of first n nearly prime numbers","code":"def findSum ( n ) : NEW_LINE"}
{"text":"Store the required sum","code":"sum = 0 NEW_LINE i = 1 NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE"}
{"text":"Add this number if it is satisfies the condition","code":"if ( countPrimeFactors ( num ) == 2 ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT"}
{"text":"Increment count of nearly prime numbers","code":"i += 1 NEW_LINE num += 1 NEW_LINE return sum NEW_LINE"}
{"text":"Function to check if N can be represented as sum of K different positive integers out of which at least K - 1 of them are nearly prime","code":"def check ( n , k ) : NEW_LINE"}
{"text":"Store the sum of first K - 1 nearly prime numbers","code":"s = findSum ( k - 1 ) NEW_LINE"}
{"text":"If sum is great than or equal to n","code":"if ( s >= n ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Otherwise , prYes","code":"else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 100 NEW_LINE k = 6 NEW_LINE check ( n , k ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import math NEW_LINE"}
{"text":"Function to calculate GCD of a and b using Euclidean Algorithm","code":"def gcd ( a , b ) : NEW_LINE"}
{"text":"Iterate until b is non - zero","code":"while ( b > 0 ) : NEW_LINE INDENT rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT"}
{"text":"Return the GCD","code":"return a NEW_LINE"}
{"text":"Function to count the number of ways N can be expressed as x ^ y","code":"def countNumberOfWays ( n ) : NEW_LINE"}
{"text":"Base Case","code":"if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"Stores the gcd of powers","code":"g = 0 NEW_LINE power = 0 NEW_LINE"}
{"text":"Calculate the degree of 2 in N","code":"while ( n % 2 == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n \/\/= 2 NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE"}
{"text":"Calculate the degree of prime numbers in N","code":"for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE DEDENT"}
{"text":"Calculate the degree of prime ' i ' in N","code":"while ( n % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n \/\/= i NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE"}
{"text":"If N is a prime , g becomes 1.","code":"if ( n > 2 ) : NEW_LINE INDENT g = gcd ( g , 1 ) NEW_LINE DEDENT"}
{"text":"Stores the number of ways to represent N as x ^ y","code":"ways = 1 NEW_LINE"}
{"text":"Find the number of Factors of g","code":"power = 0 NEW_LINE while ( g % 2 == 0 ) : NEW_LINE INDENT g \/\/= 2 NEW_LINE power += 1 NEW_LINE DEDENT"}
{"text":"Update the count of ways","code":"ways *= ( power + 1 ) NEW_LINE"}
{"text":"Iterate to find rest of the prime numbers","code":"for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE DEDENT"}
{"text":"Find the power of i","code":"while ( g % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE g \/= i NEW_LINE DEDENT"}
{"text":"Update the count of ways","code":"ways *= ( power + 1 ) NEW_LINE"}
{"text":"If g is prime","code":"if ( g > 2 ) : NEW_LINE INDENT ways *= 2 NEW_LINE DEDENT"}
{"text":"Return the total number of ways","code":"return ways NEW_LINE"}
{"text":"Driver Code","code":"N = 64 NEW_LINE print ( countNumberOfWays ( N ) ) NEW_LINE"}
{"text":"Python3 implementation of the above approach","code":"from math import floor , ceil , log2 NEW_LINE"}
{"text":"Function to return the lowest power of 2 close to given positive number","code":"def powOfPositive ( n ) : NEW_LINE"}
{"text":"Floor function is used to determine the value close to the number","code":"pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE"}
{"text":"Function to return the lowest power of 2 close to given negative number","code":"def powOfNegative ( n ) : NEW_LINE"}
{"text":"Ceil function is used for negative numbers as - 1 > - 4. It would be opposite to positive numbers where 1 < 4","code":"pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE"}
{"text":"Function to find the highest power of 2","code":"def highestPowerOf2 ( n ) : NEW_LINE"}
{"text":"To check if the given number is positive or negative","code":"if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE"}
{"text":"If the number is negative , then the ceil of the positive number is calculated and negative sign is added","code":"n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT"}
{"text":"Function to find number of cards needed","code":"def noOfCards ( n ) : NEW_LINE INDENT return n * ( 3 * n + 1 ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 3 NEW_LINE print ( noOfCards ( n ) ) NEW_LINE"}
{"text":"Function for finding the smallest possible number after swapping the digits any number of times","code":"def smallestPoss ( s , n ) : NEW_LINE"}
{"text":"Variable to store the final answer","code":"ans = \" \" ; NEW_LINE"}
{"text":"Array to store the count of occurrence of each digit","code":"arr = [ 0 ] * 10 ; NEW_LINE"}
{"text":"Loop to calculate the number of occurrences of every digit","code":"for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT"}
{"text":"Loop to get smallest number","code":"for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Returning the answer","code":"return ans ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; NEW_LINE K = \"325343273113434\" ; NEW_LINE print ( smallestPoss ( K , N ) ) ; NEW_LINE DEDENT"}
{"text":"Function to count the number of sub - arrays with sum strictly greater than the remaining elements of array","code":"def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 ; NEW_LINE DEDENT"}
{"text":"For loop for beginning point of a subarray","code":"for i in range ( n ) : NEW_LINE"}
{"text":"For loop for ending point of the subarray","code":"for j in range ( i , n ) : NEW_LINE"}
{"text":"Initialise subarray_sum and remaining_sum to 0","code":"subarray_sum = 0 ; NEW_LINE remaining_sum = 0 ; NEW_LINE"}
{"text":"For loop to calculate the sum of generated subarray","code":"for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] ; NEW_LINE DEDENT"}
{"text":"For loop to calculate the sum remaining array element","code":"for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT"}
{"text":"Checking for condition when subarray sum is strictly greater than remaining sum of array element","code":"if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 implementation of the above approach","code":"def Count_subarray ( arr , n ) : NEW_LINE INDENT total_sum = 0 ; NEW_LINE count = 0 ; NEW_LINE DEDENT"}
{"text":"Calculating total sum of given array","code":"for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] ; NEW_LINE DEDENT"}
{"text":"For loop for beginning point of a subarray","code":"for i in range ( n ) : NEW_LINE"}
{"text":"initialise subarray_sum to 0","code":"subarray_sum = 0 ; NEW_LINE"}
{"text":"For loop for calculating subarray_sum and remaining_sum","code":"for j in range ( i , n ) : NEW_LINE"}
{"text":"Calculating subarray_sum and corresponding remaining_sum","code":"subarray_sum += arr [ j ] ; NEW_LINE remaining_sum = total_sum - subarray_sum ; NEW_LINE"}
{"text":"Checking for the condition when subarray sum is strictly greater than the remaining sum of the array element","code":"if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to return the maximized XOR after removing an element from the array","code":"def maxXOR ( arr , n ) : NEW_LINE"}
{"text":"Find XOR of the complete array","code":"xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT"}
{"text":"To store the final answer","code":"ans = 0 NEW_LINE"}
{"text":"Iterating through the array to find the final answer","code":"for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT"}
{"text":"Return the final answer","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"arr = [ 1 , 1 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxXOR ( arr , n ) ) NEW_LINE"}
{"text":"Function that returns true if num contains at least one digit that divides k","code":"def digitDividesK ( num , k ) : NEW_LINE INDENT while ( num ) : NEW_LINE DEDENT"}
{"text":"Get the last digit","code":"d = num % 10 NEW_LINE"}
{"text":"If the digit is non - zero and it divides k","code":"if ( d != 0 and k % d == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"Remove the last digit","code":"num = num \/\/ 10 NEW_LINE"}
{"text":"There is no digit in num that divides k","code":"return False NEW_LINE"}
{"text":"Function to return the required count of elements from the given range which contain at least one digit that divides k","code":"def findCount ( l , r , k ) : NEW_LINE"}
{"text":"To store the result","code":"count = 0 NEW_LINE"}
{"text":"For every number from the range","code":"for i in range ( l , r + 1 ) : NEW_LINE"}
{"text":"If any digit of the current number divides k","code":"if ( digitDividesK ( i , k ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE"}
{"text":"Driver code","code":"l = 20 NEW_LINE r = 35 NEW_LINE k = 45 NEW_LINE print ( findCount ( l , r , k ) ) NEW_LINE"}
{"text":"Function to check if the given number is a factorial of any number","code":"def isFactorial ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n \/\/= i ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 ; NEW_LINE ans = isFactorial ( n ) ; NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Python3 implementation of the above approach","code":"from math import gcd NEW_LINE"}
{"text":"Function to return the LCM of two numbers","code":"def lcm ( a , b ) : NEW_LINE INDENT GCD = gcd ( a , b ) ; NEW_LINE return ( a * b ) \/\/ GCD ; NEW_LINE DEDENT"}
{"text":"Function to return the minimum LCM after removing a single element from the given array","code":"def MinLCM ( a , n ) : NEW_LINE"}
{"text":"Prefix and Suffix arrays","code":"Prefix = [ 0 ] * ( n + 2 ) ; NEW_LINE Suffix = [ 0 ] * ( n + 2 ) ; NEW_LINE"}
{"text":"Single state dynamic programming relation for storing LCM of first i elements from the left in Prefix [ i ]","code":"Prefix [ 1 ] = a [ 0 ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; NEW_LINE DEDENT"}
{"text":"Initializing Suffix array","code":"Suffix [ n ] = a [ n - 1 ] ; NEW_LINE"}
{"text":"Single state dynamic programming relation for storing LCM of all the elements having index greater than or equal to i in Suffix [ i ]","code":"for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; NEW_LINE DEDENT"}
{"text":"If first or last element of the array has to be removed","code":"ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; NEW_LINE"}
{"text":"If any other element is replaced","code":"for i in range ( 2 , n ) : NEW_LINE INDENT ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; NEW_LINE DEDENT"}
{"text":"Return the minimum LCM","code":"return ans ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 15 , 9 , 36 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinLCM ( a , n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to return the count of coloured 0 s in an n - level hexagon","code":"def count ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) \/\/ 2 ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to return the minimum required value","code":"def findMinValue ( arr , n ) : NEW_LINE"}
{"text":"Find the sum of the array elements","code":"sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT"}
{"text":"Return the required value","code":"return ( sum \/\/ n ) + 1 NEW_LINE"}
{"text":"Driver code","code":"arr = [ 4 , 2 , 1 , 10 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinValue ( arr , n ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"MOD = 1000000007 NEW_LINE"}
{"text":"Function to return ( m ! % MOD )","code":"def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"mod = 10 ** 9 + 7 NEW_LINE"}
{"text":"Function to return ( 2 ^ P % mod )","code":"def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT"}
{"text":"Function to return the sum of squares of subsets","code":"def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE DEDENT"}
{"text":"Squaring the elements and adding it to ans","code":"for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE"}
{"text":"Driver code","code":"A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"}
{"text":"Python3 program to find the number of pairs such that gcd equals to 1","code":"N = 100050 NEW_LINE lpf = [ 0 for i in range ( N ) ] NEW_LINE mobius = [ 0 for i in range ( N ) ] NEW_LINE"}
{"text":"Function to calculate least prime factor of each number","code":"def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE DEDENT"}
{"text":"If it is a prime number","code":"if ( lpf [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE DEDENT"}
{"text":"For all multiples which are not visited yet .","code":"if ( lpf [ j ] == 0 ) : NEW_LINE INDENT lpf [ j ] = i NEW_LINE DEDENT"}
{"text":"Function to find the value of Mobius function for all the numbers from 1 to n","code":"def Mobius ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE DEDENT"}
{"text":"If number is one","code":"if ( i == 1 ) : NEW_LINE INDENT mobius [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE"}
{"text":"If number has a squared prime factor","code":"if ( lpf [ ( i \/\/ lpf [ i ] ) ] == lpf [ i ] ) : NEW_LINE INDENT mobius [ i ] = 0 NEW_LINE DEDENT"}
{"text":"Multiply - 1 with the previous number","code":"else : NEW_LINE INDENT mobius [ i ] = - 1 * mobius [ i \/\/ lpf [ i ] ] NEW_LINE DEDENT"}
{"text":"Function to find the number of pairs such that gcd equals to 1","code":"def gcd_pairs ( a , n ) : NEW_LINE"}
{"text":"To store maximum number","code":"maxi = 0 NEW_LINE"}
{"text":"To store frequency of each number","code":"fre = [ 0 for i in range ( N ) ] NEW_LINE"}
{"text":"Find frequency and maximum number","code":"for i in range ( n ) : NEW_LINE INDENT fre [ a [ i ] ] += 1 NEW_LINE maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT least_prime_factor ( ) NEW_LINE Mobius ( ) NEW_LINE"}
{"text":"To store number of pairs with gcd equals to 1","code":"ans = 0 NEW_LINE"}
{"text":"Traverse through the all possible elements","code":"for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( mobius [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = 0 NEW_LINE for j in range ( i , maxi + 1 , i ) : NEW_LINE INDENT temp += fre [ j ] NEW_LINE DEDENT ans += temp * ( temp - 1 ) \/\/ 2 * mobius [ i ] NEW_LINE DEDENT"}
{"text":"Return the number of pairs","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE"}
{"text":"Function call","code":"print ( gcd_pairs ( a , n ) ) NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"from math import log NEW_LINE"}
{"text":"Function to compare x ^ y and y ^ x","code":"def compareVal ( x , y ) : NEW_LINE"}
{"text":"Storing values OF x ^ y AND y ^ x","code":"a = y * log ( x ) ; NEW_LINE b = x * log ( y ) ; NEW_LINE"}
{"text":"Comparing values","code":"if ( a > b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" > \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT elif ( a < b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" < \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" = \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 4 ; y = 5 ; NEW_LINE compareVal ( x , y ) ; NEW_LINE DEDENT"}
{"text":"Function to prfirst n zigzag numbers","code":"def ZigZag ( n ) : NEW_LINE"}
{"text":"To store factorial and n 'th zig zag number","code":"fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE zig = [ 0 for i in range ( n + 1 ) ] NEW_LINE"}
{"text":"Initialize factorial upto n","code":"fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT"}
{"text":"Set first two zig zag numbers","code":"zig [ 0 ] = 1 NEW_LINE zig [ 1 ] = 1 NEW_LINE print ( \" zig \u2581 zag \u2581 numbers : \u2581 \" , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Print first two zig zag number","code":"print ( zig [ 0 ] , zig [ 1 ] , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Print the rest zig zag numbers","code":"for i in range ( 2 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , i ) : NEW_LINE DEDENT"}
{"text":"Binomial ( n , k ) * a ( k ) * a ( n - k )","code":"sum += ( ( fact [ i - 1 ] \/\/ ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ) NEW_LINE"}
{"text":"Store the value","code":"zig [ i ] = sum \/\/ 2 NEW_LINE"}
{"text":"Print the number","code":"print ( sum \/\/ 2 , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Driver code","code":"n = 10 NEW_LINE"}
{"text":"Function call","code":"ZigZag ( n ) NEW_LINE"}
{"text":"if the sequence is a ( 1 ) a ( 2 ) a ( 3 ) . . a ( n - 1 ) check if the sequence can be represented as x * ( y ^ k ) find the largest value of k","code":"def find_count ( ele ) : NEW_LINE"}
{"text":"count","code":"count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE"}
{"text":"pattern of elements of size i from the end of sequence","code":"p = [ ] NEW_LINE"}
{"text":"count","code":"c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE"}
{"text":"extract the pattern in a reverse order","code":"while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE"}
{"text":"check how many times the pattern is repeated","code":"while j >= 0 : NEW_LINE"}
{"text":"if the element dosent match","code":"if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE"}
{"text":"if the end of pattern is reached set value of k = 0 and increase the count","code":"if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT count = max ( count , c ) NEW_LINE"}
{"text":"return the max count","code":"return count NEW_LINE"}
{"text":"print first n terms of Gijswijt 's sequence","code":"def solve ( n ) : NEW_LINE"}
{"text":"set the count","code":"count = 1 NEW_LINE"}
{"text":"stoes the element","code":"ele = [ ] NEW_LINE"}
{"text":"print the first n terms of the sequence","code":"for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"push the element","code":"ele . append ( count ) NEW_LINE"}
{"text":"find the count for next number","code":"count = find_count ( ele ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"}
{"text":"Stores the Wedderburn Etherington numbers","code":"store = dict ( ) NEW_LINE"}
{"text":"Function to return the nth Wedderburn Etherington numbers","code":"def Wedderburn ( n ) : NEW_LINE"}
{"text":"Base case","code":"if ( n <= 2 ) : NEW_LINE INDENT return store [ n ] NEW_LINE DEDENT"}
{"text":"If n is even n = 2 x","code":"elif ( n % 2 == 0 ) : NEW_LINE"}
{"text":"get x","code":"x = n \/\/ 2 NEW_LINE ans = 0 NEW_LINE"}
{"text":"a ( 2 x ) = a ( 1 ) a ( 2 x - 1 ) + a ( 2 ) a ( 2 x - 2 ) + ... + a ( x - 1 ) a ( x + 1 )","code":"for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT"}
{"text":"a ( x ) ( a ( x ) + 1 ) \/ 2","code":"ans += ( store [ x ] * ( store [ x ] + 1 ) ) \/\/ 2 NEW_LINE"}
{"text":"Store the ans","code":"store [ n ] = ans NEW_LINE"}
{"text":"Return the required answer","code":"return ans NEW_LINE else : NEW_LINE"}
{"text":"If n is odd","code":"x = ( n + 1 ) \/\/ 2 NEW_LINE ans = 0 NEW_LINE"}
{"text":"a ( 2 x - 1 ) = a ( 1 ) a ( 2 x - 2 ) + a ( 2 ) a ( 2 x - 3 ) + ... + a ( x - 1 ) a ( x ) ,","code":"for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT"}
{"text":"Store the ans","code":"store [ n ] = ans NEW_LINE"}
{"text":"Return the required answer","code":"return ans NEW_LINE"}
{"text":"Function to prfirst N Wedderburn Etherington numbers","code":"def Wedderburn_Etherington ( n ) : NEW_LINE"}
{"text":"Store first 3 numbers","code":"store [ 0 ] = 0 NEW_LINE store [ 1 ] = 1 NEW_LINE store [ 2 ] = 1 NEW_LINE"}
{"text":"PrN terms","code":"for i in range ( n ) : NEW_LINE INDENT print ( Wedderburn ( i ) , end = \" \" ) NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"n = 10 NEW_LINE"}
{"text":"function call","code":"Wedderburn_Etherington ( n ) NEW_LINE"}
{"text":"Function to maximum value after merging all elements in the array","code":"def Max_sum ( a , n ) : NEW_LINE"}
{"text":"To check if positive and negative elements present or not","code":"pos = 0 NEW_LINE neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Check for positive integer","code":"if ( a [ i ] > 0 ) : NEW_LINE INDENT pos = 1 NEW_LINE DEDENT"}
{"text":"Check for negative integer","code":"elif ( a [ i ] < 0 ) : NEW_LINE INDENT neg = 1 NEW_LINE DEDENT"}
{"text":"If both positive and negative elements are present","code":"if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT"}
{"text":"To store maximum value possible","code":"sum = 0 NEW_LINE if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT elif ( pos == 1 ) : NEW_LINE"}
{"text":"To find minimum value","code":"mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT"}
{"text":"Remove minimum element","code":"sum -= 2 * mini NEW_LINE elif ( neg == 1 ) : NEW_LINE"}
{"text":"Replace with absolute values","code":"for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT"}
{"text":"To find minimum value","code":"mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT"}
{"text":"Remove minimum element","code":"sum -= 2 * mini NEW_LINE"}
{"text":"Return the required sum","code":"return sum NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 5 , - 2 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE DEDENT"}
{"text":"Function call","code":"print ( Max_sum ( a , n ) ) NEW_LINE"}
{"text":"Recursive function to convert n to its binary equivalent","code":"def decimalToBinary ( n ) : NEW_LINE"}
{"text":"Base case","code":"if ( n == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT"}
{"text":"Recursive call","code":"decimalToBinary ( n \/\/ 2 ) ; NEW_LINE print ( n % 2 , end = \" \" ) ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE decimalToBinary ( n ) ; NEW_LINE DEDENT"}
{"text":"Function to find A , B and C","code":"def MinimumValue ( x , y ) : NEW_LINE"}
{"text":"Keep minimum number in x","code":"if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT"}
{"text":"Find the numbers","code":"a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE"}
{"text":"Driver code","code":"x = 123 NEW_LINE y = 13 NEW_LINE"}
{"text":"Function call","code":"MinimumValue ( x , y ) NEW_LINE"}
{"text":"Function that returns true if A can be converted to B with the given operations","code":"def canConvert ( a , b ) : NEW_LINE INDENT while ( b > a ) : NEW_LINE DEDENT"}
{"text":"If the current number ends with 1","code":"if ( b % 10 == 1 ) : NEW_LINE INDENT b \/\/= 10 ; NEW_LINE continue ; NEW_LINE DEDENT"}
{"text":"If the current number is divisible by 2","code":"if ( b % 2 == 0 ) : NEW_LINE INDENT b \/= 2 ; NEW_LINE continue ; NEW_LINE DEDENT"}
{"text":"If the above two conditions fail","code":"return false ; NEW_LINE"}
{"text":"If it is possible to convert A to B","code":"if ( b == a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 ; B = 82 ; NEW_LINE if ( canConvert ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Function to return the count of distinct rectangles","code":"def count ( N ) : NEW_LINE INDENT a = 0 ; NEW_LINE a = ( N * ( N + 1 ) ) \/ 2 ; NEW_LINE return int ( a ) ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 4 ; NEW_LINE print ( count ( N ) ) ; NEW_LINE"}
{"text":"Function to return the number of days required","code":"def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) \/\/ ( a + b ) NEW_LINE return Days NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 NEW_LINE b = 20 NEW_LINE n = 5 NEW_LINE print ( numberOfDays ( a , b , n ) ) NEW_LINE DEDENT"}
{"text":"Function to return the average of x and y using bit operations","code":"def getAverage ( x , y ) : NEW_LINE"}
{"text":"Calculate the average Floor value of ( x + y ) \/ 2","code":"avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; NEW_LINE return avg NEW_LINE"}
{"text":"Driver code","code":"x = 10 NEW_LINE y = 9 NEW_LINE print ( getAverage ( x , y ) ) NEW_LINE"}
{"text":"Function to find the smallest index such that there are no 0 or 1 to its right","code":"def smallestIndex ( a , n ) : NEW_LINE"}
{"text":"Initially","code":"right1 = 0 NEW_LINE right0 = 0 NEW_LINE"}
{"text":"Traverse in the array","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Check if array element is 1","code":"if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT"}
{"text":"a [ i ] = 0","code":"else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT"}
{"text":"Return minimum of both","code":"return min ( right1 , right0 ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"}
{"text":"Function to return the count of squares that can be visited by king in m moves","code":"def countSquares ( r , c , m ) : NEW_LINE"}
{"text":"To store the count of squares","code":"squares = 0 NEW_LINE"}
{"text":"Check all squares of the chessboard","code":"for i in range ( 1 , 9 ) : NEW_LINE INDENT for j in range ( 1 , 9 ) : NEW_LINE DEDENT"}
{"text":"Check if square ( i , j ) is at a distance <= m units from king 's current position","code":"if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) : NEW_LINE INDENT squares = squares + 1 NEW_LINE DEDENT"}
{"text":"Return count of squares","code":"return squares NEW_LINE"}
{"text":"Driver code","code":"r = 4 NEW_LINE c = 4 NEW_LINE m = 1 NEW_LINE print ( countSquares ( r , c , m ) ) ; NEW_LINE"}
{"text":"Function to return the count of quadruples","code":"def countQuadruples ( a , n ) : NEW_LINE"}
{"text":"Hash table to count the number of occurrences","code":"mpp = dict . fromkeys ( a , 0 ) ; NEW_LINE"}
{"text":"Traverse and increment the count","code":"for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE"}
{"text":"Run two nested loop for second and third element","code":"for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE DEDENT"}
{"text":"If they are same","code":"if ( j == k ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT"}
{"text":"Initially decrease the count","code":"mpp [ a [ j ] ] -= 1 ; NEW_LINE mpp [ a [ k ] ] -= 1 ; NEW_LINE"}
{"text":"Find the first element using common difference","code":"first = a [ j ] - ( a [ k ] - a [ j ] ) ; NEW_LINE if first not in mpp : NEW_LINE INDENT mpp [ first ] = 0 ; NEW_LINE DEDENT"}
{"text":"Find the fourth element using GP y ^ 2 = x * z property","code":"fourth = ( a [ k ] * a [ k ] ) \/\/ a [ j ] ; NEW_LINE if fourth not in mpp : NEW_LINE INDENT mpp [ fourth ] = 0 ; NEW_LINE DEDENT"}
{"text":"If it is an integer","code":"if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) : NEW_LINE"}
{"text":"If not equal","code":"if ( a [ j ] != a [ k ] ) : NEW_LINE INDENT count += mpp [ first ] * mpp [ fourth ] ; NEW_LINE DEDENT"}
{"text":"Same elements","code":"else : NEW_LINE INDENT count += ( mpp [ first ] * ( mpp [ fourth ] - 1 ) ) ; NEW_LINE DEDENT"}
{"text":"Later increase the value for future calculations","code":"mpp [ a [ j ] ] += 1 ; NEW_LINE mpp [ a [ k ] ] += 1 ; NEW_LINE return count ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 6 , 4 , 9 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( countQuadruples ( a , n ) ) ; NEW_LINE DEDENT"}
{"text":"Function to return the count of required numbers","code":"def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT DEDENT"}
{"text":"Count of numbers present in given range","code":"totalnumbers = R - L + 1 NEW_LINE"}
{"text":"Number of groups of 9 elements starting from L","code":"factor9 = totalnumbers \/\/ 9 NEW_LINE"}
{"text":"Left over elements not covered in factor 9","code":"rem = totalnumbers % 9 NEW_LINE"}
{"text":"One Number in each group of 9","code":"ans = factor9 NEW_LINE"}
{"text":"To check if any number in rem satisfy the property","code":"for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE"}
{"text":"Driver code","code":"L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"}
{"text":"Function to return the sum of even elements after updating value at given index","code":"def EvenSum ( A , index , value ) : NEW_LINE"}
{"text":"Add given value to A [ index ]","code":"A [ index ] = A [ index ] + value NEW_LINE"}
{"text":"To store the sum of even elements","code":"sum = 0 NEW_LINE for i in A : NEW_LINE"}
{"text":"If current element is even","code":"if ( i % 2 == 0 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum NEW_LINE"}
{"text":"Function to print result for every query","code":"def BalanceArray ( A , Q ) : NEW_LINE"}
{"text":"Resultant vector that stores the result for every query","code":"ANS = [ ] NEW_LINE i , sum = 0 , 0 NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT index = Q [ i ] [ 0 ] NEW_LINE value = Q [ i ] [ 1 ] NEW_LINE DEDENT"}
{"text":"Get sum of even elements after updating value at given index","code":"sum = EvenSum ( A , index , value ) NEW_LINE"}
{"text":"Store sum for each query","code":"ANS . append ( sum ) NEW_LINE"}
{"text":"Print the result for every query","code":"for i in ANS : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"A = [ 1 , 2 , 3 , 4 ] NEW_LINE Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] NEW_LINE BalanceArray ( A , Q ) NEW_LINE"}
{"text":"Function to print the result for every query","code":"def BalanceArray ( A , Q ) : NEW_LINE INDENT ANS = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE DEDENT"}
{"text":"If current element is even","code":"if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ i ] ; NEW_LINE DEDENT for i in range ( len ( Q ) ) : NEW_LINE index = Q [ i ] [ 0 ] ; NEW_LINE value = Q [ i ] [ 1 ] ; NEW_LINE"}
{"text":"If element is even then remove it from sum","code":"if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum -= A [ index ] ; NEW_LINE DEDENT A [ index ] += value ; NEW_LINE"}
{"text":"If the value becomes even after updating","code":"if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ index ] ; NEW_LINE DEDENT"}
{"text":"Store sum for each query","code":"ANS . append ( sum ) ; NEW_LINE"}
{"text":"Print the result for every query","code":"for i in range ( len ( ANS ) ) : NEW_LINE INDENT print ( ANS [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] ; NEW_LINE Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] ; NEW_LINE BalanceArray ( A , Q ) ; NEW_LINE DEDENT"}
{"text":"Python3 program for implementation of the above program","code":"import math as mt NEW_LINE"}
{"text":"Function that calculates number of Hamiltonian cycle","code":"def Cycles ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE result = N - 1 NEW_LINE DEDENT"}
{"text":"Calculating factorial","code":"i = result NEW_LINE while ( i > 0 ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact \/\/ 2 NEW_LINE"}
{"text":"Driver code","code":"N = 5 NEW_LINE Number = Cycles ( N ) NEW_LINE print ( \" Hamiltonian \u2581 cycles \u2581 = \u2581 \" , Number ) NEW_LINE"}
{"text":"Function that returns true if n contains digit m exactly k times","code":"def digitWell ( n , m , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == m ) : NEW_LINE INDENT cnt = cnt + 1 ; NEW_LINE DEDENT n = ( int ) ( n \/ 10 ) ; NEW_LINE DEDENT return cnt == k ; NEW_LINE DEDENT"}
{"text":"Function to return the smallest integer > n with digit m occurring exactly k times","code":"def findInt ( n , m , k ) : NEW_LINE INDENT i = n + 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( digitWell ( i , m , k ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"n = 111 ; m = 2 ; k = 2 ; NEW_LINE print ( findInt ( n , m , k ) ) ; NEW_LINE"}
{"text":"Function to return the count of odd numbers in the array","code":"def countOdd ( arr , n ) : NEW_LINE"}
{"text":"Variable to count odd numbers","code":"odd = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE"}
{"text":"Odd number","code":"if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd = odd + 1 ; NEW_LINE DEDENT return odd ; NEW_LINE"}
{"text":"Function to return the count of valid pairs","code":"def countValidPairs ( arr , n ) : NEW_LINE INDENT odd = countOdd ( arr , n ) ; NEW_LINE return ( odd * ( odd - 1 ) ) \/ 2 ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( int ( countValidPairs ( arr , n ) ) ) ; NEW_LINE"}
{"text":"Function to return the gcd of two numbers","code":"def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to return the lcm of all the elements of the array","code":"def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE DEDENT"}
{"text":"To calculate lcm of two numbers multiply them and divide the result by gcd of both the numbers","code":"for i in range ( n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) \/\/ gcd ( lcm , arr [ i ] ) ; NEW_LINE DEDENT"}
{"text":"Return the LCM of the array elements","code":"return lcm NEW_LINE"}
{"text":"Function to return the smallest perfect cube divisible by all the elements of arr [ ]","code":"def minPerfectCube ( arr , n ) : NEW_LINE"}
{"text":"LCM of all the elements of arr [ ]","code":"lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm \/\/= 2 NEW_LINE DEDENT"}
{"text":"If 2 divides lcm cnt number of times","code":"if ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE"}
{"text":"Check all the numbers that divide lcm","code":"while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm \/\/= i NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT"}
{"text":"Return the answer","code":"return minPerfectCube NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"Python 3 program to check if given number is strong prime","code":"from math import sqrt NEW_LINE"}
{"text":"Utility function to check if a number is prime or not","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Function that returns true if n is a strong prime","code":"def isStrongPrime ( n ) : NEW_LINE"}
{"text":"If n is not a prime number or n is the first prime then return false","code":"if ( isPrime ( n ) == False or n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Initialize previous_prime to n - 1 and next_prime to n + 1","code":"previous_prime = n - 1 NEW_LINE next_prime = n + 1 NEW_LINE"}
{"text":"Find next prime number","code":"while ( isPrime ( next_prime ) == False ) : NEW_LINE INDENT next_prime += 1 NEW_LINE DEDENT"}
{"text":"Find previous prime number","code":"while ( isPrime ( previous_prime ) == False ) : NEW_LINE INDENT previous_prime -= 1 NEW_LINE DEDENT"}
{"text":"Arithmetic mean","code":"mean = ( previous_prime + next_prime ) \/ 2 NEW_LINE"}
{"text":"If n is a strong prime","code":"if ( n > mean ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 11 NEW_LINE if ( isStrongPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"function to return the required number of digits to be removed","code":"def countDigitsToBeRemoved ( N , K ) : NEW_LINE"}
{"text":"Converting the given number into string","code":"s = str ( N ) ; NEW_LINE"}
{"text":"variable to store number of digits to be removed","code":"res = 0 ; NEW_LINE"}
{"text":"variable to denote if atleast one zero has been found","code":"f_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE DEDENT"}
{"text":"zero found","code":"f_zero = 1 ; NEW_LINE K -= 1 ; NEW_LINE else : NEW_LINE res += 1 ; NEW_LINE"}
{"text":"return size - 1 if K is not zero and atleast one zero is present , otherwise result","code":"if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT elif ( f_zero > 0 ) : NEW_LINE INDENT return len ( s ) - 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE"}
{"text":"Driver Code","code":"N = 10904025 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 1000 ; NEW_LINE K = 5 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 23985 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE"}
{"text":"Python 3 program to find the sum of the given series","code":"import math NEW_LINE"}
{"text":"Function to return the sum of the series","code":"def getSum ( a , n ) : NEW_LINE"}
{"text":"variable to store the answer","code":"sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE"}
{"text":"Math . pow ( x , y ) returns x ^ y","code":"sum += ( i \/ math . pow ( a , i ) ) ; NEW_LINE return sum ; NEW_LINE"}
{"text":"Driver code","code":"a = 3 ; n = 3 ; NEW_LINE"}
{"text":"Print the sum of the series","code":"print ( getSum ( a , n ) ) ; NEW_LINE"}
{"text":"Python Program to check Unusual number","code":"from math import sqrt NEW_LINE"}
{"text":"Utility function to find largest prime factor of a number","code":"def largestPrimeFactor ( n ) : NEW_LINE"}
{"text":"Initialize the maximum prime factor variable with the lowest one","code":"max = - 1 NEW_LINE"}
{"text":"Print the number of 2 s that divide n","code":"while n % 2 == 0 : NEW_LINE INDENT max = 2 ; NEW_LINE DEDENT"}
{"text":"n must be odd at this point , thus skip the even numbers and iterate only for odd integers","code":"for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT max = i ; NEW_LINE n = n \/ i ; NEW_LINE DEDENT DEDENT"}
{"text":"This condition is to handle the case when n is a prime number greater than 2","code":"if n > 2 : NEW_LINE INDENT max = n NEW_LINE DEDENT return max NEW_LINE"}
{"text":"Function to check Unusual number","code":"def checkUnusual ( n ) : NEW_LINE"}
{"text":"Get the largest Prime Factor of the number","code":"factor = largestPrimeFactor ( n ) NEW_LINE"}
{"text":"Check if largest prime factor is greater than sqrt ( n )","code":"if factor > sqrt ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if checkUnusual ( n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to print the desired result after computation","code":"def isHalfReducible ( arr , n , m ) : NEW_LINE INDENT frequencyHash = [ 0 ] * ( m + 1 ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT frequencyHash [ ( arr [ i ] % ( m + 1 ) ) ] += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( i <= m ) : NEW_LINE INDENT if ( frequencyHash [ i ] >= ( n \/ 2 ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( i <= m ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"arr = [ 8 , 16 , 32 , 3 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 7 ; NEW_LINE isHalfReducible ( arr , n , m ) ; NEW_LINE"}
{"text":"Python3 program to check if the given number is Ore number","code":"arr = [ ] NEW_LINE"}
{"text":"Function that returns harmonic mean","code":"def generateDivisors ( n ) : NEW_LINE"}
{"text":"Note that this loop runs till square root","code":"for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE DEDENT"}
{"text":"If divisors are equal , store 'i","code":"' NEW_LINE INDENT if n \/\/ i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT DEDENT"}
{"text":"Otherwise store ' i ' and ' n \/ i ' both","code":"else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n \/\/ i ) NEW_LINE DEDENT"}
{"text":"Utility function to calculate harmonic mean of the divisors","code":"def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE DEDENT"}
{"text":"Declare sum variables and initialize with zero .","code":"Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE"}
{"text":"calculate denominator","code":"for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n \/ arr [ i ] ) NEW_LINE DEDENT Sum = Sum \/ n NEW_LINE"}
{"text":"Calculate harmonic mean and return","code":"return length \/ Sum NEW_LINE"}
{"text":"Function to check if a number is ore number","code":"def isOreNumber ( n ) : NEW_LINE"}
{"text":"Calculate Harmonic mean of divisors of n","code":"mean = harmonicMean ( n ) NEW_LINE"}
{"text":"Check if harmonic mean is an integer or not","code":"if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if isOreNumber ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 program to check Euclid Number","code":"MAX = 10000 NEW_LINE s = set ( ) NEW_LINE"}
{"text":"Function to generate the Prime numbers and store their products","code":"def SieveOfEratosthenes ( ) : NEW_LINE"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"prime = [ True ] * ( MAX ) NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 100 ) : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if prime [ p ] == True : NEW_LINE"}
{"text":"Update all multiples of p","code":"for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT"}
{"text":"store prefix product of prime numbers to unordered_set 's","code":"' NEW_LINE INDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE DEDENT DEDENT"}
{"text":"update product by multiplying next prime","code":"product = product * p NEW_LINE"}
{"text":"insert ' produc + 1' to set","code":"s . add ( product + 1 ) NEW_LINE"}
{"text":"Function to check the number for Euclid Number","code":"def isEuclid ( n ) : NEW_LINE"}
{"text":"Check if number exist in unordered set or not If exist , return true","code":"if n in s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Get the prime numbers","code":"SieveOfEratosthenes ( ) NEW_LINE"}
{"text":"Get n","code":"n = 31 NEW_LINE"}
{"text":"Check if n is Euclid Number","code":"if isEuclid ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Get n","code":"n = 42 NEW_LINE"}
{"text":"Check if n is Euclid Number","code":"if isEuclid ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Utility function to check if a number is prime or not","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Utility function to Check power of two","code":"def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 43 NEW_LINE"}
{"text":"Check if number is prime and of the form ( 2 ^ q + 1 ) \/ 3","code":"if ( isPrime ( n ) and isPowerOfTwo ( n * 3 - 1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Python 3 Program to find the area of the square inscribed within the circle which in turn is inscribed in a hexagon","code":"from math import pow , sqrt NEW_LINE"}
{"text":"Function to find the area of the square","code":"def area ( a ) : NEW_LINE"}
{"text":"side of hexagon cannot be negative","code":"if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"area of the square","code":"area = pow ( ( a * sqrt ( 3 ) ) \/ ( sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE print ( \" { 0 : . 3 } \" . format ( area ( a ) ) ) NEW_LINE DEDENT"}
{"text":"calculate Nth term of series","code":"def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT"}
{"text":"Driver code","code":"N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"}
{"text":"Function to calculate the sum","code":"def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) \/\/ 2 + pow ( ( n * ( n + 1 ) \/\/ 2 ) , 2 ) ) NEW_LINE DEDENT"}
{"text":"number of terms to be included in the sum","code":"n = 3 NEW_LINE"}
{"text":"find the Sum","code":"print ( \" Sum \u2581 = \u2581 \" , calculateSum ( n ) ) NEW_LINE"}
{"text":"Function to check if arrays are permutations of each other","code":"def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 , sum2 , mul1 , mul2 = 0 , 0 , 1 , 1 NEW_LINE DEDENT"}
{"text":"Calculating sum and multiply of first array","code":"for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT"}
{"text":"Calculating sum and multiply of second array","code":"for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT"}
{"text":"If sum and mul of both arrays are equal , return true , else return false .","code":"return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if arePermutations ( a , b , n , m ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to find the B start to C","code":"def Race ( B , C ) : NEW_LINE INDENT result = 0 ; NEW_LINE DEDENT"}
{"text":"When B completed it 's 100 meter  then Completed meters by C is","code":"result = ( ( C * 100 ) \/\/ B ) NEW_LINE return 100 - result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT B = 10 NEW_LINE C = 28 NEW_LINE DEDENT"}
{"text":"When A completed it 's 100 meter  Then completed meters of B and C is","code":"B = 100 - B ; NEW_LINE C = 100 - C ; NEW_LINE print ( str ( Race ( B , C ) ) + \" \u2581 meters \" ) NEW_LINE"}
{"text":"Function to calculate the time","code":"def Time ( arr , n , Emptypipe ) : NEW_LINE INDENT fill = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fill += ( 1 \/ arr [ i ] ) NEW_LINE DEDENT fill = fill - ( 1 \/ float ( Emptypipe ) ) NEW_LINE return int ( 1 \/ fill ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 14 ] NEW_LINE Emptypipe = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( ( Time ( arr , n , Emptypipe ) ) , \" Hours \" ) NEW_LINE DEDENT"}
{"text":"Function to check Divisibility","code":"def check ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT"}
{"text":"Sum of all individual digits","code":"while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n \/\/ 10 NEW_LINE DEDENT"}
{"text":"Condition","code":"if sum % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Octal number","code":"n = 25 NEW_LINE print ( ( \" YES \" ) if check ( n ) == 1 else print ( \" NO \" ) ) NEW_LINE"}
{"text":"Python 3 program to find sum of prime divisors of N","code":"N = 1000005 NEW_LINE"}
{"text":"Function to check if the number is prime or not .","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner cases","code":"if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE"}
{"text":"function to find sum of prime divisors of N","code":"def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 60 NEW_LINE print ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE"}
{"text":"function to find prime divisors of all numbers from 1 to n","code":"def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE DEDENT"}
{"text":"if the number is prime","code":"if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE"}
{"text":"add this prime to all it 's multiples","code":"for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE"}
{"text":"Driver code","code":"N = 60 NEW_LINE print ( \" Sum \u2581 of \u2581 prime \" , \" divisors \u2581 of \u2581 60 \u2581 is \" , Sum ( N ) ) ; NEW_LINE"}
{"text":"Function to find power","code":"def power ( x , y , p ) : NEW_LINE"}
{"text":"Update x if it is more than or equal to p","code":"x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE"}
{"text":"If y is odd , multiply x with the result","code":"if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT"}
{"text":"y must be even now y = y >> 1 y = y \/ 2","code":"x = ( x * x ) % p NEW_LINE return res NEW_LINE"}
{"text":"Driver Code","code":"a = 3 NEW_LINE"}
{"text":"String input as b is very large","code":"b = \"100000000000000000000000000\" NEW_LINE remainderB = 0 NEW_LINE MOD = 1000000007 NEW_LINE"}
{"text":"Reduce the number B to a small number using Fermat Little","code":"for i in range ( len ( b ) ) : NEW_LINE INDENT remainderB = ( ( remainderB * 10 + ord ( b [ i ] ) - 48 ) % ( MOD - 1 ) ) NEW_LINE DEDENT print ( power ( a , remainderB , MOD ) ) NEW_LINE"}
{"text":"Function to find the square of 333. . .333 , 666. . .666 and 999. . .999","code":"def find_Square_369 ( num ) : NEW_LINE"}
{"text":"if the number is 333. . .333","code":"if ( num [ 0 ] == '3' ) : NEW_LINE INDENT a = '1' NEW_LINE b = '0' NEW_LINE c = '8' NEW_LINE d = '9' NEW_LINE DEDENT"}
{"text":"if the number is 666. . .666","code":"elif ( num [ 0 ] == '6' ) : NEW_LINE INDENT a = '4' NEW_LINE b = '3' NEW_LINE c = '5' NEW_LINE d = '6' NEW_LINE DEDENT"}
{"text":"if the number is 999. . .999","code":"else : NEW_LINE INDENT a = '9' NEW_LINE b = '8' NEW_LINE c = '0' NEW_LINE d = '1' NEW_LINE DEDENT"}
{"text":"variable for hold result","code":"result = \" \" NEW_LINE"}
{"text":"find the no of digit","code":"size = len ( num ) NEW_LINE"}
{"text":"add size - 1 time a in result","code":"for i in range ( 1 , size ) : NEW_LINE INDENT result += a NEW_LINE DEDENT"}
{"text":"add one time b in result","code":"result += b NEW_LINE"}
{"text":"add size - 1 time c in result","code":"for i in range ( 1 , size ) : NEW_LINE INDENT result += c NEW_LINE DEDENT"}
{"text":"add one time d in result","code":"result += d NEW_LINE"}
{"text":"return result","code":"return result NEW_LINE"}
{"text":"Drivers code Your Python 3 Code","code":"num_3 = \"3333\" NEW_LINE num_6 = \"6666\" NEW_LINE num_9 = \"9999\" NEW_LINE result = \" \" NEW_LINE"}
{"text":"find square of 33. .33","code":"result = find_Square_369 ( num_3 ) NEW_LINE print ( \" Square \u2581 of \u2581 \" + num_3 + \" \u2581 is \u2581 : \u2581 \" + result ) ; NEW_LINE"}
{"text":"find square of 66. .66","code":"result = find_Square_369 ( num_6 ) NEW_LINE print ( \" Square \u2581 of \u2581 \" + num_6 + \" \u2581 is \u2581 : \u2581 \" + result ) ; NEW_LINE"}
{"text":"find square of 66. .66","code":"result = find_Square_369 ( num_9 ) NEW_LINE print ( \" Square \u2581 of \u2581 \" + num_9 + \" \u2581 is \u2581 : \u2581 \" + result ) ; NEW_LINE"}
{"text":"Python3 program to implement the above approach To run this code , we need to copy modular inverse from below post . https : www . geeksforgeeks . org \/ multiplicative - inverse - under - modulo - m \/","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"naive method - calculating the result in a single line","code":"naive_answer = ( ( ( 55555 * 55554 * 55553 * 55552 * 55551 ) \/\/ 120 ) % 1000000007 ) NEW_LINE ans = 1 NEW_LINE"}
{"text":"modular_inverse ( ) is a user defined function that calculates inverse of a number","code":"i = modular_inverse ( 120 , 10000007 ) NEW_LINE"}
{"text":"it will use extended Eucledian algorithm or Fermat 's Little  Theorem for calculation.  MMI of 120 under division by  1000000007 will be 808333339","code":"for i in range ( 5 ) : NEW_LINE INDENT ans = ( ( ans * ( 55555 - i ) ) % 1000000007 ) NEW_LINE DEDENT ans = ( ans * i ) % 1000000007 NEW_LINE print ( \" Answer \u2581 using \u2581 naive \u2581 method : \" , naive_answer ) NEW_LINE print ( \" Answer \u2581 using \u2581 multiplicative \" + \" modular \u2581 inverse \u2581 concept : \" , ans ) NEW_LINE"}
{"text":"Function to find the required factorial","code":"def fact ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT ans = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT"}
{"text":"Function to find nCr","code":"def nCr ( n , r ) : NEW_LINE INDENT Nr = n ; Dr = 1 ; ans = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans = int ( ( ans * Nr ) \/ ( Dr ) ) ; NEW_LINE Nr = Nr - 1 ; NEW_LINE Dr = Dr + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT"}
{"text":"function to find the number of ways","code":"def solve ( n ) : NEW_LINE INDENT N = 2 * n - 2 ; NEW_LINE R = n - 1 ; NEW_LINE return ( nCr ( N , R ) * fact ( n - 1 ) ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 6 ; NEW_LINE print ( solve ( n ) ) ; NEW_LINE"}
{"text":"Python3 program to find Pythagorean Triplet of given sum .","code":"def pythagoreanTriplet ( n ) : NEW_LINE"}
{"text":"Considering triplets in sorted order . The value of first element in sorted triplet can be at - most n \/ 3.","code":"for i in range ( 1 , int ( n \/ 3 ) + 1 ) : NEW_LINE"}
{"text":"The value of second element must be less than equal to n \/ 2","code":"for j in range ( i + 1 , int ( n \/ 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , \" , \u2581 \" , j , \" , \u2581 \" , k , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" No \u2581 Triplet \" ) NEW_LINE"}
{"text":"Driver Code","code":"n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE"}
{"text":"function to calculate factorial of a number","code":"def factorial ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f *= i NEW_LINE DEDENT return f NEW_LINE DEDENT"}
{"text":"Function to print the series","code":"def series ( A , X , n ) : NEW_LINE"}
{"text":"calculating the value of n !","code":"nFact = factorial ( n ) NEW_LINE"}
{"text":"loop to display the series","code":"for i in range ( 0 , n + 1 ) : NEW_LINE"}
{"text":"For calculating the value of nCr","code":"niFact = factorial ( n - i ) NEW_LINE iFact = factorial ( i ) NEW_LINE"}
{"text":"calculating the value of A to the power k and X to the power k","code":"aPow = pow ( A , n - i ) NEW_LINE xPow = pow ( X , i ) NEW_LINE"}
{"text":"display the series","code":"print ( int ( ( nFact * aPow * xPow ) \/ ( niFact * iFact ) ) , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Driver Code","code":"A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"}
{"text":"Function to calculate series sum","code":"def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( seiresSum ( n , a ) ) NEW_LINE"}
{"text":"Function to return power of a no . ' r ' in factorial of n","code":"def power ( n , r ) : NEW_LINE"}
{"text":"Keep dividing n by powers of ' r ' and update count","code":"count = 0 ; i = r NEW_LINE while ( ( n \/ i ) >= 1 ) : NEW_LINE INDENT count += n \/ i NEW_LINE i = i * r NEW_LINE DEDENT return int ( count ) NEW_LINE"}
{"text":"Driver Code","code":"n = 6 ; r = 3 NEW_LINE print ( power ( n , r ) ) NEW_LINE"}
{"text":"Returns the Avg of first n odd numbers","code":"def avg_of_odd_num ( n ) : NEW_LINE"}
{"text":"sum of first n odd number","code":"sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 2 * i + 1 ) NEW_LINE DEDENT"}
{"text":"Average of first n odd numbers","code":"return sm \/\/ n NEW_LINE"}
{"text":"Driver Code","code":"n = 20 NEW_LINE print ( avg_of_odd_num ( n ) ) NEW_LINE"}
{"text":"Return the average of sum of first n odd numbers","code":"def avg_of_odd_num ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 8 NEW_LINE print ( avg_of_odd_num ( n ) ) NEW_LINE"}
{"text":"function to fill Fibonacci Numbers in f [ ]","code":"def fib ( f , N ) : NEW_LINE"}
{"text":"1 st and 2 nd number of the series are 1 and 1","code":"f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE"}
{"text":"Add the previous 2 numbers in the series and store it","code":"f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE def fiboTriangle ( n ) : NEW_LINE"}
{"text":"Fill Fibonacci numbers in f [ ] using fib ( ) . We need N = n * ( n + 1 ) \/ 2 Fibonacci numbers to make a triangle of height n","code":"N = n * ( n + 1 ) \/\/ 2 NEW_LINE f = [ 0 ] * ( N + 1 ) NEW_LINE fib ( f , N ) NEW_LINE"}
{"text":"To store next Fibonacci Number to print","code":"fiboNum = 1 NEW_LINE"}
{"text":"for loop to keep track of number of lines","code":"for i in range ( 1 , n + 1 ) : NEW_LINE"}
{"text":"For loop to keep track of numbers in each line","code":"for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( f [ fiboNum ] , \" \u2581 \" , end = \" \" ) NEW_LINE fiboNum = fiboNum + 1 NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Driver code","code":"n = 5 NEW_LINE fiboTriangle ( n ) NEW_LINE"}
{"text":"Function to calculate the average of odd numbers","code":"def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE DEDENT"}
{"text":"count odd numbers","code":"count = count + 1 NEW_LINE"}
{"text":"store the sum of odd numbers","code":"sm = sm + n NEW_LINE n = n - 2 NEW_LINE return sm \/\/ count NEW_LINE"}
{"text":"Driver function","code":"n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE"}
{"text":"Function to calculate the average of odd numbers","code":"def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"driver function","code":"n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE"}
{"text":"Python program to find max between two Rational numbers","code":"import math NEW_LINE"}
{"text":"Get lcm of two number 's","code":"def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) \/\/ ( math . gcd ( a , b ) ) NEW_LINE DEDENT"}
{"text":"Get max rational number","code":"def maxRational ( first , sec ) : NEW_LINE"}
{"text":"Find the LCM of first -> denominator and sec -> denominator","code":"k = lcm ( first [ 1 ] , sec [ 1 ] ) NEW_LINE"}
{"text":"Declare nume1 and nume2 for get the value of first numerator and second numerator","code":"nume1 = first [ 0 ] NEW_LINE nume2 = sec [ 0 ] NEW_LINE nume1 *= k \/\/ ( first [ 1 ] ) NEW_LINE nume2 *= k \/\/ ( sec [ 1 ] ) NEW_LINE return first if ( nume2 < nume1 ) else sec NEW_LINE"}
{"text":"Driver Code","code":"first = [ 3 , 2 ] NEW_LINE sec = [ 3 , 4 ] NEW_LINE res = maxRational ( first , sec ) NEW_LINE print ( res [ 0 ] , \" \/ \" , res [ 1 ] , sep = \" \" ) NEW_LINE"}
{"text":"Function to find the trinomial triangle value .","code":"def TrinomialValue ( n , k ) : NEW_LINE"}
{"text":"base case","code":"if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"base cas","code":"if k < - n or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"recursive step .","code":"return ( TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ) NEW_LINE"}
{"text":"Function to print Trinomial Triangle of height n .","code":"def printTrinomial ( n ) : NEW_LINE"}
{"text":"printing n rows .","code":"for i in range ( n ) : NEW_LINE"}
{"text":"printing first half of triangle","code":"for j in range ( - i , 1 ) : NEW_LINE INDENT print ( TrinomialValue ( i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"printing second half of triangle .","code":"for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( TrinomialValue ( i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , end = ' ' ) NEW_LINE"}
{"text":"Driven Code","code":"n = 4 NEW_LINE printTrinomial ( n ) NEW_LINE"}
{"text":"Function to find the trinomial triangle value .","code":"def TrinomialValue ( dp , n , k ) : NEW_LINE"}
{"text":"Using property of trinomial triangle .","code":"if k < 0 : NEW_LINE INDENT k = - k NEW_LINE DEDENT"}
{"text":"If value already calculated , return that .","code":"if dp [ n ] [ k ] != 0 : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT"}
{"text":"base case","code":"if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"base case","code":"if k < - n or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"recursive step and storing the value .","code":"return ( TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) NEW_LINE"}
{"text":"Function to print Trinomial Triangle of height n .","code":"def printTrinomial ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * 10 ] * 10 NEW_LINE DEDENT"}
{"text":"printing n rows .","code":"for i in range ( n ) : NEW_LINE"}
{"text":"printing first half of triangle","code":"for j in range ( - i , 1 ) : NEW_LINE INDENT print ( TrinomialValue ( dp , i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"printing second half of triangle .","code":"for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( TrinomialValue ( dp , i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , end = ' ' ) NEW_LINE"}
{"text":"Driven Program","code":"n = 4 NEW_LINE printTrinomial ( n ) NEW_LINE"}
{"text":"function to find sum of largest prime factor of each number less than equal to n","code":"def sumOfLargePrimeFactor ( n ) : NEW_LINE"}
{"text":"Create an integer array \" prime [ 0 . . n ] \" and initialize all entries of it as 0. A value in prime [ i ] will finally be 0 if ' i ' is a prime , else it will contain the largest prime factor of ' i ' .","code":"prime = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE max = int ( n \/ 2 ) NEW_LINE for p in range ( 2 , max + 1 ) : NEW_LINE"}
{"text":"If prime [ p ] is '0' , then it is a prime number","code":"if prime [ p ] == 0 : NEW_LINE"}
{"text":"Update all multiples of p","code":"for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE DEDENT"}
{"text":"Sum up the largest prime factor of all the numbers","code":"for p in range ( 2 , n + 1 ) : NEW_LINE"}
{"text":"if ' p ' is a non - prime number then prime [ p ] gives its largesr prime factor","code":"if prime [ p ] : NEW_LINE INDENT sum += prime [ p ] NEW_LINE DEDENT"}
{"text":"' p ' is a prime number","code":"else : NEW_LINE INDENT sum += p NEW_LINE DEDENT"}
{"text":"required sum","code":"return sum NEW_LINE"}
{"text":"Driver code to test above function","code":"n = 12 NEW_LINE print ( \" Sum \u2581 = \" , sumOfLargePrimeFactor ( n ) ) NEW_LINE"}
{"text":"Calculates sum of multiples of a number upto N","code":"def calculate_sum ( a , N ) : NEW_LINE"}
{"text":"Number of multiples","code":"m = N \/ a NEW_LINE"}
{"text":"sum of first m natural numbers","code":"sum = m * ( m + 1 ) \/ 2 NEW_LINE"}
{"text":"sum of multiples","code":"ans = a * sum NEW_LINE print ( \" Sum \u2581 of \u2581 multiples \u2581 of \u2581 \" , a , \" \u2581 up \u2581 to \u2581 \" , N , \" \u2581 = \u2581 \" , ans ) NEW_LINE"}
{"text":"Driver Code","code":"calculate_sum ( 7 , 49 ) NEW_LINE"}
{"text":"returns 1 when str is power of 2 return 0 when str is not a power of 2","code":"def isPowerOf2 ( sttr ) : NEW_LINE INDENT len_str = len ( sttr ) ; NEW_LINE sttr = list ( sttr ) ; NEW_LINE DEDENT"}
{"text":"sum stores the intermediate dividend while dividing .","code":"num = 0 ; NEW_LINE"}
{"text":"if the input is \"1\" then return 0 because 2 ^ k = 1 where k >= 1 and here k = 0","code":"if ( len_str == 1 and sttr [ len_str - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"Divide the number until it gets reduced to 1 if we are successfully able to reduce the number to 1 it means input string is power of two if in between an odd number appears at the end it means string is not divisible by two hence not a power of 2.","code":"while ( len_str != 1 or sttr [ len_str - 1 ] != '1' ) : NEW_LINE"}
{"text":"if the last digit is odd then string is not divisible by 2 hence not a power of two return 0.","code":"if ( ( ord ( sttr [ len_str - 1 ] ) - ord ( '0' ) ) % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"divide the whole string by 2. i is used to track index in current number . j is used to track index for next iteration .","code":"j = 0 ; NEW_LINE for i in range ( len_str ) : NEW_LINE INDENT num = num * 10 + ( ord ( sttr [ i ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT"}
{"text":"if num < 2 then we have to take another digit to the right of A [ i ] to make it bigger than A [ i ] . E . g . 214 \/ 2 -- > 107","code":"if ( num < 2 ) : NEW_LINE"}
{"text":"if it 's not the first index. E.g 214  then we have to include 0.","code":"if ( i != 0 ) : NEW_LINE INDENT sttr [ j ] = '0' ; NEW_LINE j += 1 ; NEW_LINE DEDENT"}
{"text":"for eg . \"124\" we will not write 064 so if it is the first index just ignore","code":"continue ; NEW_LINE sttr [ j ] = chr ( ( num \/\/ 2 ) + ord ( '0' ) ) ; NEW_LINE j += 1 ; NEW_LINE num = ( num ) - ( num \/\/ 2 ) * 2 ; NEW_LINE"}
{"text":"After every division by 2 the length of string is changed .","code":"len_str = j ; NEW_LINE"}
{"text":"if the string reaches to 1 then the str is a power of 2.","code":"return 1 ; NEW_LINE"}
{"text":"Driver code .","code":"str1 = \"124684622466842024680246842024662202000002\" ; NEW_LINE str2 = \"1\" ; NEW_LINE str3 = \"128\" ; NEW_LINE print ( \" \" , isPowerOf2 ( str1 ) ,   \" \" , isPowerOf2 ( str2 ) ,   \" \" , isPowerOf2 ( str3 ) ) ; NEW_LINE"}
{"text":"Function to check whether a number is power of 2 or not","code":"def ispowerof2 ( num ) : NEW_LINE INDENT if ( ( num & ( num - 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT"}
{"text":"Driver function","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 549755813888 NEW_LINE print ( ispowerof2 ( num ) ) NEW_LINE DEDENT"}
{"text":"To count number of factors in a number","code":"def counDivisors ( X ) : NEW_LINE"}
{"text":"Initialize count with 0","code":"count = 0 NEW_LINE"}
{"text":"Increment count for every factor of the given number X .","code":"for i in range ( 1 , X + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Return number of factors","code":"return count NEW_LINE"}
{"text":"Returns number of divisors in array multiplication","code":"def countDivisorsMult ( arr , n ) : NEW_LINE"}
{"text":"Multipliying all elements of the given array .","code":"mul = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul *= arr [ i ] NEW_LINE DEDENT"}
{"text":"Calling function which count number of factors of the number","code":"return counDivisors ( mul ) NEW_LINE"}
{"text":"Driver code","code":"arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDivisorsMult ( arr , n ) ) NEW_LINE"}
{"text":"Python 3 program to count divisors in array multiplication .","code":"from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( largest , prime ) : NEW_LINE"}
{"text":"Create a boolean array \" isPrime [ 0 . . n ] \" and initialize all entries it as true . A value in isPrime [ i ] will finally be false if i is Not a isPrime , else true .","code":"isPrime = [ True ] * ( largest + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= largest : NEW_LINE"}
{"text":"If isPrime [ p ] is not changed , then it is a isPrime","code":"if ( isPrime [ p ] == True ) : NEW_LINE"}
{"text":"Update all multiples of p","code":"for i in range ( p * 2 , largest + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"Print all isPrime numbers","code":"for p in range ( 2 , largest + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE DEDENT DEDENT"}
{"text":"Returns number of divisors in array multiplication","code":"def countDivisorsMult ( arr , n ) : NEW_LINE"}
{"text":"Find all prime numbers smaller than the largest element .","code":"largest = max ( arr ) NEW_LINE prime = [ ] NEW_LINE SieveOfEratosthenes ( largest , prime ) NEW_LINE"}
{"text":"Find counts of occurrences of each prime factor","code":"mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( prime ) ) : NEW_LINE INDENT while ( arr [ i ] > 1 and arr [ i ] % prime [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] \/\/= prime [ j ] NEW_LINE mp [ prime [ j ] ] += 1 NEW_LINE DEDENT DEDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Compute count of all divisors using counts prime factors .","code":"res = 1 NEW_LINE for it in mp . values ( ) : NEW_LINE INDENT res *= ( it + 1 ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDivisorsMult ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"from math import sqrt NEW_LINE"}
{"text":"Function to generate prime numbers in the given range [ L , R ]","code":"def findPrimeNos ( L , R , M ) : NEW_LINE"}
{"text":"Store all value in the range","code":"for i in range ( L , R + 1 ) : NEW_LINE INDENT M [ i ] = M . get ( i , 0 ) + 1 NEW_LINE DEDENT"}
{"text":"Erase 1 as its non - prime","code":"if ( 1 in M ) : NEW_LINE INDENT M . pop ( 1 ) NEW_LINE DEDENT"}
{"text":"Perform Sieve of Eratosthenes","code":"for i in range ( 2 , int ( sqrt ( R ) ) + 1 , 1 ) : NEW_LINE INDENT multiple = 2 NEW_LINE while ( ( i * multiple ) <= R ) : NEW_LINE DEDENT"}
{"text":"Find current multiple","code":"if ( ( i * multiple ) in M ) : NEW_LINE"}
{"text":"Erase as it is a non - prime","code":"M . pop ( i * multiple ) NEW_LINE"}
{"text":"Increment multiple","code":"multiple += 1 NEW_LINE"}
{"text":"Function to print all the prime pairs in the given range that differs by K","code":"def getPrimePairs ( L , R , K ) : NEW_LINE INDENT M = { } NEW_LINE DEDENT"}
{"text":"Generate all prime number","code":"findPrimeNos ( L , R , M ) NEW_LINE"}
{"text":"Traverse the Map M","code":"for key , values in M . items ( ) : NEW_LINE"}
{"text":"If it . first & ( it . first + K ) is prime then print this pair","code":"if ( ( key + K ) in M ) : NEW_LINE INDENT print ( \" ( \" , key , \" , \" , key + K , \" ) \" , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given range","code":"L = 1 NEW_LINE R = 19 NEW_LINE"}
{"text":"Given K","code":"K = 6 NEW_LINE"}
{"text":"Function Call","code":"getPrimePairs ( L , R , K ) NEW_LINE"}
{"text":"Function to find the Nth Enneacontahexagon Number","code":"def EnneacontahexagonNum ( n ) : NEW_LINE INDENT return ( 94 * n * n - 92 * n ) \/\/ 2 ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 3 ; NEW_LINE print ( EnneacontahexagonNum ( n ) ) ; NEW_LINE"}
{"text":"Function to find the two composite numbers","code":"def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE find_composite_nos ( n ) ; NEW_LINE DEDENT"}
{"text":"Function to find number of unordered pairs","code":"def freqPairs ( arr , n ) : NEW_LINE"}
{"text":"Maximum element from the array","code":"max = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Array to store the frequency of each element","code":"freq = [ 0 for i in range ( max + 1 ) ] NEW_LINE"}
{"text":"Stores the number of unordered pairs","code":"count = 0 NEW_LINE"}
{"text":"Store the frequency of each element","code":"for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT"}
{"text":"Find the number of unordered pairs","code":"for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 * arr [ i ] , max + 1 , arr [ i ] ) : NEW_LINE DEDENT"}
{"text":"If the number j divisible by ith element is present in the array","code":"if ( freq [ j ] >= 1 ) : NEW_LINE INDENT count += freq [ j ] NEW_LINE DEDENT"}
{"text":"If the ith element of the array has frequency more than one","code":"if ( freq [ arr [ i ] ] > 1 ) : NEW_LINE INDENT count += freq [ arr [ i ] ] - 1 NEW_LINE freq [ arr [ i ] ] -= 1 NEW_LINE DEDENT return count NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 4 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( freqPairs ( arr , n ) ) NEW_LINE DEDENT"}
{"text":"calculate Nth term of given series","code":"def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) \/\/ 6 NEW_LINE DEDENT"}
{"text":"Driver code","code":"N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"}
{"text":"Return n - th number in series made of 3 and 5","code":"def printNthElement ( n ) : NEW_LINE"}
{"text":"create an array of size ( n + 1 )","code":"arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 3 NEW_LINE arr [ 2 ] = 5 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE"}
{"text":"If i is odd","code":"if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i \/\/ 2 ] * 10 + 3 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i \/\/ 2 ) - 1 ] * 10 + 5 NEW_LINE DEDENT return arr [ n ] NEW_LINE"}
{"text":"Driver code","code":"n = 6 NEW_LINE print ( printNthElement ( n ) ) NEW_LINE"}
{"text":"function to calculate Nth term of series","code":"def nthTerm ( N ) : NEW_LINE"}
{"text":"By using above formula","code":"return ( N * ( ( N \/\/ 2 ) + ( ( N % 2 ) * 2 ) + N ) ) NEW_LINE"}
{"text":"get the value of N","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE DEDENT"}
{"text":"Calculate and print the Nth term","code":"print ( \" Nth \u2581 term \u2581 for \u2581 N \u2581 = \u2581 \" , N , \" \u2581 : \u2581 \" , nthTerm ( N ) ) NEW_LINE"}
{"text":"Function to print the series","code":"def series ( A , X , n ) : NEW_LINE"}
{"text":"Calculating and printing first term","code":"term = pow ( A , n ) NEW_LINE print ( term , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Computing and printing remaining terms","code":"for i in range ( 1 , n + 1 ) : NEW_LINE"}
{"text":"Find current term using previous terms We increment power of X by 1 , decrement power of A by 1 and compute nCi using previous term by multiplying previous term with ( n - i + 1 ) \/ i","code":"term = int ( term * X * ( n - i + 1 ) \/ ( i * A ) ) NEW_LINE print ( term , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Driver Code","code":"A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"}
{"text":"Python program to check whether the number is divisible by 8 or not using bitwise operator","code":"import math NEW_LINE"}
{"text":"function to check number is div by 8 or not using bitwise operator","code":"def Div_by_8 ( n ) : NEW_LINE INDENT return ( ( ( n >> 3 ) << 3 ) == n ) NEW_LINE DEDENT"}
{"text":"driver code","code":"n = 16 NEW_LINE if ( Div_by_8 ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Function to calculate the average of even numbers","code":"def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 2 ) : NEW_LINE DEDENT"}
{"text":"count even numbers","code":"count = count + 1 NEW_LINE"}
{"text":"store the sum of even numbers","code":"sm = sm + n NEW_LINE n = n - 2 NEW_LINE return sm \/\/ count NEW_LINE"}
{"text":"driver function","code":"n = 16 NEW_LINE print ( averageEven ( n ) ) NEW_LINE"}
{"text":"Function to calculate the average of even numbers","code":"def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 2 ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"Driver function","code":"n = 16 NEW_LINE print ( averageEven ( n ) ) NEW_LINE"}
{"text":"Recursive function to return gcd of a and b","code":"def gcd ( a , b ) : NEW_LINE"}
{"text":"Everything divides 0","code":"if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"base case","code":"if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT"}
{"text":"a is greater","code":"if a > b : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE"}
{"text":"function to find largest coprime divisor","code":"def cpFact ( x , y ) : NEW_LINE INDENT while gcd ( x , y ) != 1 : NEW_LINE INDENT x = x \/ gcd ( x , y ) NEW_LINE DEDENT return int ( x ) NEW_LINE DEDENT"}
{"text":"divisor code","code":"x = 15 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 14 NEW_LINE y = 28 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 7 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE"}
{"text":"Returns count of numbers with k as last digit .","code":"def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( i % 10 == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT"}
{"text":"Driver Program","code":"low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE"}
{"text":"Python3 implementation to print first N Taxicab ( 2 ) numbers","code":"import math NEW_LINE def printTaxicab2 ( N ) : NEW_LINE"}
{"text":"Starting from 1 , check every number if it is Taxicab until count reaches N .","code":"i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE DEDENT"}
{"text":"Try all possible pairs ( j , k ) whose cube sums can be i .","code":"for j in range ( 1 , math . ceil ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , math . ceil ( pow ( i , 1.0 \/ 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Taxicab ( 2 ) found","code":"if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" \u2581 \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE"}
{"text":"Driver code","code":"N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"}
{"text":"A optimized school method based Python program to check if a number is composite .","code":"def isComposite ( n ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"This is checked so that we can skip middle five numbers in below loop","code":"if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE"}
{"text":"Driver Program to test above function","code":"print ( \" true \" ) if ( isComposite ( 11 ) ) else print ( \" false \" ) NEW_LINE print ( \" true \" ) if ( isComposite ( 15 ) ) else print ( \" false \" ) NEW_LINE"}
{"text":"function to check if a number is prime or not","code":"def isPrime ( n ) : NEW_LINE"}
{"text":"Corner case","code":"if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Check from 2 to n - 1","code":"for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Find prime number greater than a number","code":"def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE DEDENT"}
{"text":"find prime greater than n","code":"while ( num ) : NEW_LINE"}
{"text":"check if num is prime","code":"if isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT"}
{"text":"Increment num","code":"num += 1 NEW_LINE return 0 NEW_LINE"}
{"text":"To find number to be added so sum of array is prime","code":"def minNumber ( arr ) : NEW_LINE INDENT s = 0 NEW_LINE DEDENT"}
{"text":"To find sum of array elements","code":"for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT"}
{"text":"If sum is already prime return 0","code":"if isPrime ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"To find prime number greater than sum","code":"num = findPrime ( s ) NEW_LINE"}
{"text":"Return difference of sum and num","code":"return num - s NEW_LINE"}
{"text":"Driver code","code":"arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE"}
{"text":"function to calculate factorial","code":"def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT"}
{"text":"function to calculate sum of divisor","code":"def div ( x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"}
{"text":"Returns sum of divisors of n !","code":"def sumFactDiv ( n ) : NEW_LINE INDENT return div ( fact ( n ) ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 4 NEW_LINE print ( sumFactDiv ( n ) ) NEW_LINE"}
{"text":"allPrimes [ ] stores all prime numbers less than or equal to n .","code":"allPrimes = [ ] ; NEW_LINE"}
{"text":"Fills above vector allPrimes [ ] for a given n","code":"def sieve ( n ) : NEW_LINE"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true .","code":"prime = [ True ] * ( n + 1 ) ; NEW_LINE"}
{"text":"Loop to update prime [ ]","code":"p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == True ) : NEW_LINE"}
{"text":"Update all multiples of p","code":"for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT p += 1 ; NEW_LINE"}
{"text":"Store primes in the vector allPrimes","code":"for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT allPrimes . append ( p ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Function to find all result of factorial number","code":"def factorialDivisors ( n ) : NEW_LINE"}
{"text":"Initialize result","code":"result = 1 ; NEW_LINE"}
{"text":"find exponents of all primes which divides n and less than n","code":"for i in range ( len ( allPrimes ) ) : NEW_LINE"}
{"text":"Current divisor","code":"p = allPrimes [ i ] ; NEW_LINE"}
{"text":"Find the highest power ( stored in exp ) ' \u2581 \u2581 of \u2581 allPrimes [ i ] \u2581 that \u2581 divides \u2581 n \u2581 using \u2581 \u2581 Legendre ' s formula .","code":"exp = 0 ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT exp = exp + int ( n \/ p ) ; NEW_LINE p = p * allPrimes [ i ] ; NEW_LINE DEDENT"}
{"text":"Using the divisor function to calculate the sum","code":"result = int ( result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) \/ ( allPrimes [ i ] - 1 ) ) ; NEW_LINE"}
{"text":"return total divisors","code":"return result ; NEW_LINE"}
{"text":"Driver Code","code":"print ( factorialDivisors ( 4 ) ) ; NEW_LINE"}
{"text":"Return true if n is pandigit else return false .","code":"def checkPandigital ( b , n ) : NEW_LINE"}
{"text":"Checking length is less than base","code":"if ( len ( n ) < b ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT hash = [ 0 ] * b ; NEW_LINE"}
{"text":"Traversing each digit of the number .","code":"for i in range ( len ( n ) ) : NEW_LINE"}
{"text":"If digit is integer","code":"if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 ; NEW_LINE DEDENT"}
{"text":"If digit is alphabet","code":"elif ( ord ( n [ i ] ) - ord ( ' A ' ) <= b - 11 ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; NEW_LINE DEDENT"}
{"text":"Checking hash array , if any index is unmarked .","code":"for i in range ( b ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE"}
{"text":"Driver Code","code":"b = 13 ; NEW_LINE n = \"1298450376ABC \" ; NEW_LINE if ( checkPandigital ( b , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"text":"Function to find minimum number of given operations to convert m to n","code":"def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT"}
{"text":"only way is to do - 1 ( m - n ) : times","code":"if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT"}
{"text":"not possible","code":"if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"n is greater and n is odd","code":"if ( n % 2 == 1 ) : NEW_LINE"}
{"text":"perform ' - 1' on m ( or + 1 on n ) :","code":"return 1 + conver ( m , n + 1 ) NEW_LINE"}
{"text":"n is even","code":"else : NEW_LINE"}
{"text":"perform ' * 2' on m ( or n \/ 2 on n ) :","code":"return 1 + conver ( m , n \/ 2 ) NEW_LINE"}
{"text":"Driver code","code":"m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 operations \u2581 : \" , conver ( m , n ) ) NEW_LINE"}
{"text":"Python3 program to find Seed of a number","code":"MAX = 10000 ; NEW_LINE prodDig = [ 0 ] * MAX ; NEW_LINE"}
{"text":"Stores product of digits of x in prodDig [ x ]","code":"def getDigitProduct ( x ) : NEW_LINE"}
{"text":"If x has single digit","code":"if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT"}
{"text":"If digit product is already computed","code":"if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] ; NEW_LINE DEDENT"}
{"text":"If digit product is not computed before .","code":"prod = ( int ( x % 10 ) * getDigitProduct ( int ( x \/ 10 ) ) ) ; NEW_LINE prodDig [ x ] = prod ; NEW_LINE return prod ; NEW_LINE"}
{"text":"Prints all seeds of n","code":"def findSeed ( n ) : NEW_LINE"}
{"text":"Find all seeds using prodDig [ ]","code":"res = [ ] ; NEW_LINE for i in range ( 1 , int ( n \/ 2 + 2 ) ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE DEDENT DEDENT"}
{"text":"If there was no seed","code":"if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" NO \u2581 seed \u2581 exists \" ) ; NEW_LINE return ; NEW_LINE DEDENT"}
{"text":"Print seeds","code":"for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 138 ; NEW_LINE findSeed ( n ) ; NEW_LINE"}
{"text":"Python 3 program to find integer having maximum number of prime factor in first N natural numbers .","code":"from math import sqrt NEW_LINE"}
{"text":"Return smallest number having maximum prime factors .","code":"def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 5 ) ] NEW_LINE DEDENT"}
{"text":"Sieve of eratosthenes method to count number of prime factors .","code":"for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 NEW_LINE DEDENT DEDENT arr [ i ] = 1 NEW_LINE DEDENT maxval = 0 NEW_LINE maxint = 1 NEW_LINE"}
{"text":"Finding number having maximum number of prime factor .","code":"for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] NEW_LINE maxint = i NEW_LINE DEDENT DEDENT return maxint NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT"}
{"text":"function compute sum all sub - array","code":"def SubArraySum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT"}
{"text":"computing sum of subarray using formula","code":"for i in range ( 0 , n ) : NEW_LINE INDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEW_LINE DEDENT"}
{"text":"return all subarray sum","code":"return result NEW_LINE"}
{"text":"driver program","code":"arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum \u2581 of \u2581 SubArray \u2581 : \u2581 \" , SubArraySum ( arr , n ) ) NEW_LINE"}
{"text":"Python3 program to find highest power of 2 smaller than or equal to n .","code":"def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE DEDENT"}
{"text":"If i is a power of 2","code":"if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i ; NEW_LINE break ; NEW_LINE DEDENT return res ; NEW_LINE"}
{"text":"Driver code","code":"n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE"}
{"text":"Python3 program to find pairs that can represent the given number as sum of two cubes","code":"import math NEW_LINE"}
{"text":"Function to find pairs that can represent the given number as sum of two cubes","code":"def findPairs ( n ) : NEW_LINE"}
{"text":"find cube root of n","code":"cubeRoot = int ( math . pow ( n , 1.0 \/ 3.0 ) ) ; NEW_LINE"}
{"text":"create a array of size of size 'cubeRoot","code":"' NEW_LINE INDENT cube = [ 0 ] * ( cubeRoot + 1 ) ; NEW_LINE DEDENT"}
{"text":"for index i , cube [ i ] will contain i ^ 3","code":"for i in range ( 1 , cubeRoot + 1 ) : NEW_LINE INDENT cube [ i ] = i * i * i ; NEW_LINE DEDENT"}
{"text":"Find all pairs in above sorted array cube [ ] whose sum is equal to n","code":"l = 1 ; NEW_LINE r = cubeRoot ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( cube [ l ] + cube [ r ] < n ) : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT elif ( cube [ l ] + cube [ r ] > n ) : NEW_LINE INDENT r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ( \" , l , \" , \u2581 \" , math . floor ( r ) , \" ) \" , end = \" \" ) ; NEW_LINE print ( ) ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"n = 20683 ; NEW_LINE findPairs ( n ) ; NEW_LINE"}
{"text":"Function to find pairs that can represent the given number as sum of two cubes","code":"def findPairs ( n ) : NEW_LINE"}
{"text":"Find cube root of n","code":"cubeRoot = pow ( n , 1.0 \/ 3.0 ) ; NEW_LINE"}
{"text":"Create an empty map","code":"s = { } NEW_LINE"}
{"text":"Consider all pairs such with values less than cuberoot","code":"for x in range ( int ( cubeRoot ) ) : NEW_LINE INDENT for y in range ( x + 1 , int ( cubeRoot ) + 1 ) : NEW_LINE DEDENT"}
{"text":"Find sum of current pair ( x , y )","code":"sum = x * x * x + y * y * y ; NEW_LINE"}
{"text":"Do nothing if sum is not equal to given number","code":"if ( sum != n ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT"}
{"text":"If sum is seen before , we found two pairs","code":"if sum in s . keys ( ) : NEW_LINE INDENT print ( \" ( \" + str ( s [ sum ] [ 0 ] ) + \" , \u2581 \" + str ( s [ sum ] [ 1 ] ) + \" ) \u2581 and \u2581 ( \" + str ( x ) + \" , \u2581 \" + str ( y ) + \" ) \" +   \" \" ) NEW_LINE DEDENT else : NEW_LINE"}
{"text":"If sum is seen for the first time","code":"s [ sum ] = [ x , y ] NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13832 NEW_LINE findPairs ( n ) NEW_LINE DEDENT"}
{"text":"python3 program to find the minimum difference between any two terms of two tables","code":"import math as mt NEW_LINE"}
{"text":"Utility function to find GCD of a and b","code":"def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT"}
{"text":"Returns minimum difference between any two terms of shifted tables of ' a ' and ' b ' . ' x ' is shift in table of ' a ' and ' y ' is shift in table of ' b ' .","code":"def findMinDiff ( a , b , x , y ) : NEW_LINE"}
{"text":"Calculate gcd of a nd b","code":"g = gcd ( a , b ) NEW_LINE"}
{"text":"Calculate difference between x and y","code":"diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE"}
{"text":"Driver Code","code":"a , b , x , y = 20 , 52 , 5 , 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE"}
{"text":"A O ( sqrt ( n ) ) java program that prints all divisors in sorted order","code":"import math NEW_LINE"}
{"text":"Method to print the divisors","code":"def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE DEDENT"}
{"text":"List to store half of the divisors","code":"for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT"}
{"text":"Check if divisors are equal","code":"if ( n \/ i == i ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Otherwise print both","code":"print ( i , end = \" \u2581 \" ) NEW_LINE list . append ( int ( n \/ i ) ) NEW_LINE"}
{"text":"The list will be printed in reverse","code":"for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver method","code":"print ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text":"A O ( sqrt ( n ) ) program that prints all divisors in sorted order","code":"from math import * NEW_LINE"}
{"text":"Function to print the divisors","code":"def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( int ( sqrt ( n ) ) , 0 , - 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n \/\/ i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Driver Code","code":"print ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text":"method to print the divisors","code":"def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT"}
{"text":"Driver method","code":"print \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text":"A Better ( than Naive ) Solution to find all divisiors","code":"import math NEW_LINE"}
{"text":"method to print the divisors","code":"def printDivisors ( n ) : NEW_LINE"}
{"text":"Note that this loop runs till square root","code":"i = 1 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT"}
{"text":"If divisors are equal , print only one","code":"if ( n \/ i == i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Otherwise print both","code":"print i , n \/ i , NEW_LINE i = i + 1 NEW_LINE"}
{"text":"Driver method","code":"print \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text":"Python 3 program for implementation of Sieve of Atkin","code":"def SieveOfAtkin ( limit ) : NEW_LINE"}
{"text":"2 and 3 are known to be prime","code":"if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" \u2581 \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Initialise the sieve array with False values","code":"sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT"}
{"text":"Mark sieve [ n ] is True if one of the following is True : a ) n = ( 4 * x * x ) + ( y * y ) has odd number of solutions , i . e . , there exist odd number of distinct pairs ( x , y ) that satisfy the equation and n % 12 = 1 or n % 12 = 5. b ) n = ( 3 * x * x ) + ( y * y ) has odd number of solutions and n % 12 = 7 c ) n = ( 3 * x * x ) - ( y * y ) has odd number of solutions , x > y and n % 12 = 11","code":"x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE DEDENT"}
{"text":"Main part of Sieve of Atkin","code":"n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE x += 1 NEW_LINE"}
{"text":"Mark all multiples of squares as non - prime","code":"r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Print primes using sieve [ ]","code":"for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE"}
{"text":"Python3 program to check if a point lies inside a circle or not","code":"def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE"}
{"text":"Compare radius of circle with distance of its center from given point","code":"if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT"}
{"text":"Driver Code","code":"x = 1 ; NEW_LINE y = 1 ; NEW_LINE circle_x = 0 ; NEW_LINE circle_y = 1 ; NEW_LINE rad = 2 ; NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( \" Inside \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Outside \" ) ; NEW_LINE DEDENT"}
{"text":"Utility function to evaluate a simple expression with one operator only .","code":"def eval ( a , op , b ) : NEW_LINE INDENT if op == ' + ' : return a + b NEW_LINE if op == ' - ' : return a - b NEW_LINE if op == ' * ' : return a * b NEW_LINE DEDENT"}
{"text":"This function evaluates all possible values and returns a list of evaluated values .","code":"def evaluateAll ( expr , low , high ) : NEW_LINE"}
{"text":"To store result ( all possible evaluations of given expression ' expr ' )","code":"res = [ ] NEW_LINE"}
{"text":"If there is only one character , it must be a digit ( or operand ) , return it .","code":"if low == high : NEW_LINE INDENT res . append ( int ( expr [ low ] ) ) NEW_LINE return res NEW_LINE DEDENT"}
{"text":"If there are only three characters , middle one must be operator and corner ones must be operand","code":"if low == ( high - 2 ) : NEW_LINE INDENT num = eval ( int ( expr [ low ] ) , expr [ low + 1 ] , int ( expr [ low + 2 ] ) ) NEW_LINE res . append ( num ) NEW_LINE return res NEW_LINE DEDENT"}
{"text":"every i refers to an operator","code":"for i in range ( low + 1 , high + 1 , 2 ) : NEW_LINE"}
{"text":"l refers to all the possible values in the left of operator 'expr[i]","code":"' NEW_LINE INDENT l = evaluateAll ( expr , low , i - 1 ) NEW_LINE DEDENT"}
{"text":"r refers to all the possible values in the right of operator 'expr[i]","code":"' NEW_LINE INDENT r = evaluateAll ( expr , i + 1 , high ) NEW_LINE DEDENT"}
{"text":"Take above evaluated all possible values in left side of 'i","code":"' NEW_LINE INDENT for s1 in range ( 0 , len ( l ) ) : NEW_LINE DEDENT"}
{"text":"Take above evaluated all possible values in right side of 'i","code":"' NEW_LINE INDENT for s2 in range ( 0 , len ( r ) ) : NEW_LINE DEDENT"}
{"text":"Calculate value for every pair and add the value to result .","code":"val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) NEW_LINE res . append ( val ) NEW_LINE return res NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT expr = \"1*2 + 3*4\" NEW_LINE length = len ( expr ) NEW_LINE ans = evaluateAll ( expr , 0 , length - 1 ) NEW_LINE for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT DEDENT"}
{"text":"python program to check if a given number is lucky","code":"import math NEW_LINE"}
{"text":"This function returns true if n is lucky","code":"def isLucky ( n ) : NEW_LINE"}
{"text":"Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not .","code":"ar = [ 0 ] * 10 NEW_LINE"}
{"text":"Traverse through all digits of given number","code":"while ( n > 0 ) : NEW_LINE"}
{"text":"Find the last digit","code":"digit = math . floor ( n % 10 ) NEW_LINE"}
{"text":"If digit is already seen , return false","code":"if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Mark this digit as seen","code":"ar [ digit ] = 1 NEW_LINE"}
{"text":"REmove the last digit from number","code":"n = n \/ 10 NEW_LINE return 1 NEW_LINE"}
{"text":"Driver program to test above function .","code":"arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , \" \u2581 is \u2581 Lucky \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , \" \u2581 is \u2581 not \u2581 Lucky \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Python3 program to print squares of first ' n ' natural numbers wothout using * , \/ and -","code":"def printSquares ( n ) : NEW_LINE"}
{"text":"Initialize ' square ' and first odd number","code":"square = 0 NEW_LINE odd = 1 NEW_LINE"}
{"text":"Calculate and print squares","code":"for x in range ( 0 , n ) : NEW_LINE"}
{"text":"Print square","code":"print ( square , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Update ' square ' and 'odd","code":"' NEW_LINE INDENT square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 5 ; NEW_LINE printSquares ( n ) NEW_LINE"}
{"text":"Python 3 program to reverse digits of a number","code":"rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE"}
{"text":"Recursive function to reverse digits of num","code":"def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num \/ 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT"}
{"text":"Driver Code","code":"num = 4562 NEW_LINE print ( \" Reverse \u2581 of \u2581 no . \u2581 is \u2581 \" , reversDigits ( num ) ) NEW_LINE"}
{"text":"Recursive function that find the minimum value after exclusive - OR","code":"def RecursiveFunction ( ref , bit ) : NEW_LINE"}
{"text":"Condition if ref size is zero or bit is negative then return 0","code":"if ( len ( ref ) == 0 or bit < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT curr_on = [ ] NEW_LINE curr_off = [ ] NEW_LINE for i in range ( len ( ref ) ) : NEW_LINE"}
{"text":"Condition if current bit is off then push current value in curr_off vector","code":"if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) : NEW_LINE INDENT curr_off . append ( ref [ i ] ) NEW_LINE DEDENT"}
{"text":"Condition if current bit is on then push current value in curr_on vector","code":"else : NEW_LINE INDENT curr_on . append ( ref [ i ] ) NEW_LINE DEDENT"}
{"text":"Condition if curr_off is empty then call recursive function on curr_on vector","code":"if ( len ( curr_off ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_on , bit - 1 ) NEW_LINE DEDENT"}
{"text":"Condition if curr_on is empty then call recursive function on curr_off vector","code":"if ( len ( curr_on ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_off , bit - 1 ) NEW_LINE DEDENT"}
{"text":"Return the minimum of curr_off and curr_on and add power of 2 of current bit","code":"return ( min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ) NEW_LINE"}
{"text":"Function that print the minimum value after exclusive - OR","code":"def PrintMinimum ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE DEDENT"}
{"text":"Pushing values in vector","code":"for i in range ( n ) : NEW_LINE INDENT v . append ( a [ i ] ) NEW_LINE DEDENT"}
{"text":"Printing answer","code":"print ( RecursiveFunction ( v , 30 ) ) NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 3 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE PrintMinimum ( arr , size ) NEW_LINE"}
{"text":"Function to return the count of elements which are equal to the XOR of the next two elements","code":"def cntElements ( arr , n ) : NEW_LINE"}
{"text":"To store the required count","code":"cnt = 0 NEW_LINE"}
{"text":"For every element of the array such that it has at least two elements appearing after it in the array","code":"for i in range ( n - 2 ) : NEW_LINE"}
{"text":"If current element is equal to the XOR of the next two elements in the array","code":"if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE"}
{"text":"Driver code","code":"arr = [ 4 , 2 , 1 , 3 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntElements ( arr , n ) ) NEW_LINE"}
{"text":"Function to return the count","code":"def xor_triplet ( arr , n ) : NEW_LINE"}
{"text":"Initialise result","code":"ans = 0 ; NEW_LINE"}
{"text":"Pick 1 st element of the triplet","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Pick 2 nd element of the triplet","code":"for j in range ( i + 1 , n ) : NEW_LINE"}
{"text":"Pick 3 rd element of the triplet","code":"for k in range ( j , n ) : NEW_LINE INDENT xor1 = 0 ; xor2 = 0 ; NEW_LINE DEDENT"}
{"text":"Taking xor in the first subarray","code":"for x in range ( i , j ) : NEW_LINE INDENT xor1 ^= arr [ x ] ; NEW_LINE DEDENT"}
{"text":"Taking xor in the second subarray","code":"for x in range ( j , k + 1 ) : NEW_LINE INDENT xor2 ^= arr [ x ] ; NEW_LINE DEDENT"}
{"text":"If both xor is equal","code":"if ( xor1 == xor2 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE DEDENT"}
{"text":"Function Calling","code":"print ( xor_triplet ( arr , n ) ) ; NEW_LINE"}
{"text":"Python3 implementation of the approach","code":"N = 100005 NEW_LINE Ideal_pair = 0 NEW_LINE"}
{"text":"Adjacency list","code":"al = [ [ ] for i in range ( 100005 ) ] NEW_LINE bit = [ 0 for i in range ( N ) ] NEW_LINE root_node = [ 0 for i in range ( N ) ] NEW_LINE"}
{"text":"bit : bit array i and j are starting and ending index INCLUSIVE","code":"def bit_q ( i , j ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( j > 0 ) : NEW_LINE INDENT sum += bit [ j ] NEW_LINE j -= ( j & ( j * - 1 ) ) NEW_LINE DEDENT i -= 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum -= bit [ i ] NEW_LINE i -= ( i & ( i * - 1 ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT"}
{"text":"bit : bit array n : size of bit array i is the index to be updated diff is ( new_val - old_val )","code":"def bit_up ( i , diff ) : NEW_LINE INDENT while ( i <= n ) : NEW_LINE INDENT bit [ i ] += diff NEW_LINE i += i & - i NEW_LINE DEDENT DEDENT"}
{"text":"DFS function to find ideal pairs","code":"def dfs ( node , x ) : NEW_LINE INDENT Ideal_pair = x NEW_LINE Ideal_pair += bit_q ( max ( 1 , node - k ) , min ( n , node + k ) ) NEW_LINE bit_up ( node , 1 ) NEW_LINE for i in range ( len ( al [ node ] ) ) : NEW_LINE INDENT Ideal_pair = dfs ( al [ node ] [ i ] , Ideal_pair ) NEW_LINE DEDENT bit_up ( node , - 1 ) NEW_LINE return Ideal_pair NEW_LINE DEDENT"}
{"text":"Function for initialisation","code":"def initialise ( ) : NEW_LINE INDENT Ideal_pair = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT root_node [ i ] = True NEW_LINE bit [ i ] = 0 NEW_LINE DEDENT DEDENT"}
{"text":"Function to add an edge","code":"def Add_Edge ( x , y ) : NEW_LINE INDENT al [ x ] . append ( y ) NEW_LINE root_node [ y ] = False NEW_LINE DEDENT"}
{"text":"Function to find number of ideal pairs","code":"def Idealpairs ( ) : NEW_LINE"}
{"text":"Find root of the tree","code":"r = - 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( root_node [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT Ideal_pair = dfs ( r , 0 ) NEW_LINE return Ideal_pair NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE initialise ( ) NEW_LINE DEDENT"}
{"text":"Add edges","code":"Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 3 , 4 ) NEW_LINE Add_Edge ( 3 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE"}
{"text":"Function call","code":"print ( Idealpairs ( ) ) NEW_LINE"}
{"text":"function to find bitwise subsets Efficient approach","code":"def printSubsets ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( i != 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE i = ( i - 1 ) & n NEW_LINE DEDENT print ( \"0\" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"n = 9 NEW_LINE printSubsets ( n ) NEW_LINE"}
{"text":"function to check recursively if the number is divisible by 17 or not","code":"def isDivisibleby17 ( n ) : NEW_LINE"}
{"text":"if n = 0 or n = 17 then yes","code":"if ( n == 0 or n == 17 ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"if n is less then 17 , not divisible by 17","code":"if ( n < 17 ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"reducing the number by floor ( n \/ 16 ) - n % 16","code":"return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) NEW_LINE"}
{"text":"driver code to check the above function","code":"n = 35 NEW_LINE if ( isDivisibleby17 ( n ) ) : NEW_LINE INDENT print ( n , \" is \u2581 divisible \u2581 by \u2581 17\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is \u2581 not \u2581 divisible \u2581 by \u2581 17\" ) NEW_LINE DEDENT"}
{"text":"Python3 program to find largest number smaller than equal to n with m set bits then m - 1 0 bits .","code":"import math NEW_LINE"}
{"text":"Returns largest number with m set bits then m - 1 0 bits .","code":"def answer ( n ) : NEW_LINE"}
{"text":"Start with 2 bits .","code":"m = 2 ; NEW_LINE"}
{"text":"initial answer is 1 which meets the given condition","code":"ans = 1 ; NEW_LINE r = 1 ; NEW_LINE"}
{"text":"check for all numbers","code":"while r < n : NEW_LINE"}
{"text":"compute the number","code":"r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE"}
{"text":"if less then N","code":"if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT"}
{"text":"increment m to get the next number","code":"m = m + 1 ; NEW_LINE return ans ; NEW_LINE"}
{"text":"Driver Code","code":"print ( answer ( 7 ) ) ; NEW_LINE"}
{"text":"Simple Python3 program to find MSB number for given n .","code":"def setBitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT msb = 0 ; NEW_LINE n = int ( n \/ 2 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = int ( n \/ 2 ) ; NEW_LINE msb += 1 ; NEW_LINE DEDENT return ( 1 << msb ) ; NEW_LINE DEDENT"}
{"text":"Driver code","code":"n = 0 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE"}
{"text":"Python program to find MSB number for given n .","code":"def setBitNumber ( n ) : NEW_LINE"}
{"text":"Suppose n is 273 ( binary is 100010001 ) . It does following 100010001 | 010001000 = 110011001","code":"n |= n >> 1 NEW_LINE"}
{"text":"This makes sure 4 bits ( From MSB and including MSB ) are set . It does following 110011001 | 001100110 = 111111111","code":"n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE"}
{"text":"Increment n by 1 so that there is only one set bit which is just before original MSB . n now becomes 1000000000","code":"n = n + 1 NEW_LINE"}
{"text":"Return original MSB after shifting . n now becomes 100000000","code":"return ( n >> 1 ) NEW_LINE"}
{"text":"Driver code","code":"n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"}
{"text":"Python 3 code for counting trailing zeros in binary representation of a number","code":"def countTrailingZero ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( x & 1 ) == 0 ) : NEW_LINE INDENT x = x >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( countTrailingZero ( 11 ) ) NEW_LINE DEDENT"}
{"text":"Python3 code for counting trailing zeros in binary representation of a number","code":"def countTrailingZero ( x ) : NEW_LINE"}
{"text":"Map a bit value mod 37 to its position","code":"lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] NEW_LINE"}
{"text":"Only difference between ( x and - x ) is the value of signed magnitude ( leftmostbit ) negative numbers signed bit is 1","code":"return lookup [ ( - x & x ) % 37 ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( countTrailingZero ( 48 ) ) NEW_LINE DEDENT"}
{"text":"Python program to evaluate ceil ( 7 n \/ 8 ) without using * and \/","code":"def multiplyBySevenByEight ( n ) : NEW_LINE"}
{"text":"Note the inner bracket here . This is needed because precedence of ' - ' operator is higher than '<<","code":"' NEW_LINE INDENT return ( n - ( n >> 3 ) ) NEW_LINE DEDENT"}
{"text":"Driver program to test above function","code":"n = 9 NEW_LINE print ( multiplyBySevenByEight ( n ) ) NEW_LINE"}
{"text":"Python3 program to evaluate 7 n \/ 8 without using * and \/","code":"def multiplyBySevenByEight ( n ) : NEW_LINE"}
{"text":"Step 1 ) First multiply number by 7 i . e . 7 n = ( n << 3 ) - n Step 2 ) Divide result by 8","code":"return ( ( n << 3 ) - n ) >> 3 ; NEW_LINE"}
{"text":"Driver code","code":"n = 15 ; NEW_LINE print ( multiplyBySevenByEight ( n ) ) ; NEW_LINE"}
{"text":"Function to find the maximum size of group of palindrome numbers having difference between maximum and minimum element at most K","code":"def countNumbers ( L , R , K ) : NEW_LINE"}
{"text":"Stores the all the palindromic numbers in the range [ L , R ]","code":"list = [ ] NEW_LINE"}
{"text":"Traverse over the range [ L , R ]","code":"for i in range ( L , R + 1 ) : NEW_LINE"}
{"text":"If i is a palindrome","code":"if ( isPalindrome ( i ) ) : NEW_LINE"}
{"text":"Append the number in the list","code":"list . append ( i ) NEW_LINE"}
{"text":"Stores count of maximum palindromic numbers","code":"count = 0 NEW_LINE"}
{"text":"Iterate each element in the list","code":"for i in range ( len ( list ) ) : NEW_LINE"}
{"text":"Calculate rightmost index in the list < current element + K","code":"right_index = search ( list , list [ i ] + K - 1 ) NEW_LINE"}
{"text":"Check if there is rightmost index from the current index","code":"if ( right_index != - 1 ) : NEW_LINE INDENT count = max ( count , right_index - i + 1 ) NEW_LINE DEDENT"}
{"text":"Return the count","code":"return count NEW_LINE"}
{"text":"Function to search the rightmost index of given number","code":"def search ( list , num ) : NEW_LINE INDENT low , high = 0 , len ( list ) - 1 NEW_LINE DEDENT"}
{"text":"Store the rightmost index","code":"ans = - 1 NEW_LINE while ( low <= high ) : NEW_LINE"}
{"text":"Calculate the mid","code":"mid = low + ( high - low ) \/\/ 2 NEW_LINE"}
{"text":"If given number <= num","code":"if ( list [ mid ] <= num ) : NEW_LINE"}
{"text":"Assign ans = mid","code":"ans = mid NEW_LINE"}
{"text":"Update low","code":"low = mid + 1 NEW_LINE else : NEW_LINE"}
{"text":"Update high","code":"high = mid - 1 NEW_LINE"}
{"text":"return ans","code":"return ans NEW_LINE"}
{"text":"Function to check if the given number is palindrome or not","code":"def isPalindrome ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = n NEW_LINE DEDENT"}
{"text":"Generate reverse of the given number","code":"while ( n > 0 ) : NEW_LINE INDENT rev = rev * 10 + n % 10 NEW_LINE n \/\/= 10 NEW_LINE DEDENT"}
{"text":"If n is a palindrome","code":"return rev == temp NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 98 , 112 NEW_LINE K = 13 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE DEDENT"}
{"text":"Function to find the maximum sum by subtracting same value from all elements of a Subarray","code":"def findMaximumSum ( a , n ) : NEW_LINE"}
{"text":"Stores previous smaller element","code":"prev_smaller = findPrevious ( a , n ) NEW_LINE"}
{"text":"Stores next smaller element","code":"next_smaller = findNext ( a , n ) NEW_LINE max_value = 0 NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Calculate contribution of each element","code":"max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) NEW_LINE"}
{"text":"Return answer","code":"return max_value NEW_LINE"}
{"text":"Function to generate previous smaller element for each array element","code":"def findPrevious ( a , n ) : NEW_LINE INDENT ps = [ 0 ] * n NEW_LINE DEDENT"}
{"text":"The first element has no previous smaller","code":"ps [ 0 ] = - 1 NEW_LINE"}
{"text":"Stack to keep track of elements that have occurred previously","code":"stack = [ ] NEW_LINE"}
{"text":"Push the first index","code":"stack . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE"}
{"text":"Pop all the elements until the previous element is smaller than current element","code":"while len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT"}
{"text":"Store the previous smaller element","code":"ps [ i ] = stack [ - 1 ] if len ( stack ) > 0 else - 1 NEW_LINE"}
{"text":"Push the index of the current element","code":"stack . append ( i ) NEW_LINE"}
{"text":"Return the array","code":"return ps NEW_LINE"}
{"text":"Function to generate next smaller element for each array element","code":"def findNext ( a , n ) : NEW_LINE INDENT ns = [ 0 ] * n NEW_LINE ns [ n - 1 ] = n NEW_LINE DEDENT"}
{"text":"Stack to keep track of elements that have occurring next","code":"stack = [ ] NEW_LINE stack . append ( n - 1 ) NEW_LINE"}
{"text":"Iterate in reverse order for calculating next smaller","code":"for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE"}
{"text":"Pop all the elements until the next element is smaller than current element","code":"while ( len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT"}
{"text":"Store the next smaller element","code":"ns [ i ] = stack [ - 1 ] if len ( stack ) > 0 else n NEW_LINE"}
{"text":"Push the index of the current element","code":"stack . append ( i ) NEW_LINE"}
{"text":"Return the array","code":"return ns NEW_LINE"}
{"text":"Driver code","code":"n = 3 NEW_LINE a = [ 80 , 48 , 82 ] NEW_LINE print ( findMaximumSum ( a , n ) ) NEW_LINE"}
{"text":"''This function returns true if contents of arr1[] and arr2[] are same, otherwise false.","code":"MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT global MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT"}
{"text":"This function search for all permutations of pat [ ] in txt [ ]","code":"def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE DEDENT"}
{"text":"countP [ ] : Store count of all characters of pattern countTW [ ] : Store count of current window of text","code":"countP = [ 0 for i in range ( MAX ) ] NEW_LINE countTW = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE DEDENT"}
{"text":"Traverse through remaining characters of pattern","code":"for i in range ( M , N ) : NEW_LINE"}
{"text":"Compare counts of current window of text with counts of pattern [ ]","code":"if ( compare ( countP , countTW ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT"}
{"text":"Add current character to current window","code":"countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE"}
{"text":"Remove the first character of previous window","code":"countTW [ ord ( txt [ i - M ] ) ] -= 1 NEW_LINE"}
{"text":"Check for the last window in text","code":"if ( compare ( countP , countTW ) ) : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT"}
{"text":"Driver code","code":"txt = \" BACDGABCDA \" NEW_LINE pat = \" ABCD \" NEW_LINE if ( search ( pat , txt ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to return the maximized median","code":"def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE DEDENT"}
{"text":"Sort the array","code":"arr . sort ( reverse = False ) NEW_LINE"}
{"text":"If size is even","code":"if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size \/ 2 ) - 1 ] + arr [ int ( size \/ 2 ) ] ) \/ 2 NEW_LINE return median NEW_LINE DEDENT"}
{"text":"If size is odd","code":"median = arr [ int ( size \/ 2 ) ] NEW_LINE return median NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( getMaxMedian ( arr , n , k ) ) NEW_LINE DEDENT"}
{"text":"Python3 program to print three numbers in sorted order using max function","code":"def printSorted ( a , b , c ) : NEW_LINE"}
{"text":"Find maximum element","code":"get_max = max ( a , max ( b , c ) ) NEW_LINE"}
{"text":"Find minimum element","code":"get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , \" \u2581 \" , get_mid , \" \u2581 \" , get_max ) NEW_LINE"}
{"text":"Driver Code","code":"a , b , c = 4 , 1 , 9 NEW_LINE printSorted ( a , b , c ) NEW_LINE"}
{"text":"iterative implementation","code":"def binarySearch ( a , item , low , high ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) \/\/ 2 NEW_LINE if ( item == a [ mid ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT elif ( item > a [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT"}
{"text":"Function to sort an array a [ ] of size 'n","code":"' NEW_LINE def insertionSort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = i - 1 NEW_LINE selected = a [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"find location where selected should be inseretd","code":"loc = binarySearch ( a , selected , 0 , j ) NEW_LINE"}
{"text":"Move all elements after location to create space","code":"while ( j >= loc ) : NEW_LINE INDENT a [ j + 1 ] = a [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT a [ j + 1 ] = selected NEW_LINE"}
{"text":"Driver Code","code":"a = [ 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 ] NEW_LINE n = len ( a ) NEW_LINE insertionSort ( a , n ) NEW_LINE print ( \" Sorted \u2581 array : \u2581 \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Function to do insertion sort","code":"def insertionSort ( arr ) : NEW_LINE INDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position","code":"j = i - 1 NEW_LINE while j >= 0 and key < arr [ j ] : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE"}
{"text":"Driver code to test above","code":"arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE insertionSort ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( \" % \u2581 d \" % arr [ i ] ) NEW_LINE DEDENT"}
{"text":"Function to calculate total number of valid permutations","code":"def validPermutations ( str ) : NEW_LINE INDENT m = { } NEW_LINE DEDENT"}
{"text":"Creating count which is equal to the Total number of characters present and ans that will store the number of unique permutations","code":"count = len ( str ) NEW_LINE ans = 0 NEW_LINE"}
{"text":"Storing frequency of each character present in the string","code":"for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] in m ) : NEW_LINE INDENT m [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( str ) ) : NEW_LINE"}
{"text":"Adding count of characters by excluding characters equal to current char","code":"ans += count - m [ str [ i ] ] NEW_LINE"}
{"text":"Reduce the frequency of the current character and count by 1 , so that it cannot interfere with the calculations of the same elements present to the right of it .","code":"m [ str [ i ] ] -= 1 NEW_LINE count -= 1 NEW_LINE"}
{"text":"Return ans + 1 ( Because the given string is also a unique permutation )","code":"return ans + 1 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" sstt \" NEW_LINE print ( validPermutations ( str ) ) NEW_LINE DEDENT"}
{"text":"Recursive function to count number of paths","code":"def countPaths ( n , m ) : NEW_LINE"}
{"text":"If we reach bottom or top left , we are have only one way to reach ( 0 , 0 )","code":"if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Else count sum of both ways","code":"return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE"}
{"text":"Driver Code","code":"n = 3 NEW_LINE m = 2 NEW_LINE print ( \" Number \u2581 of \u2581 Paths \" , countPaths ( n , m ) ) NEW_LINE"}
{"text":"Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n","code":"def count ( S , m , n ) : NEW_LINE"}
{"text":"If n is 0 then there is 1 solution ( do not include any coin )","code":"if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"If n is less than 0 then no solution exists","code":"if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"If there are no coins and n is greater than 0 , then no solution exist","code":"if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ]","code":"return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE"}
{"text":"Driver program to test above function","code":"arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE print ( count ( arr , m , 4 ) ) NEW_LINE"}
{"text":"Function to compare two strings ignoring their cases","code":"def equalIgnoreCase ( str1 , str2 ) : NEW_LINE"}
{"text":"Convert to uppercase","code":"str1 = str1 . upper ( ) ; NEW_LINE str2 = str2 . upper ( ) ; NEW_LINE"}
{"text":"if strings are equal , return true otherwise false","code":"x = str1 == str2 ; NEW_LINE return x ; NEW_LINE"}
{"text":"Function to print the same or not same if strings are equal or not equal","code":"def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Same \" ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" Geeks \" ; NEW_LINE str2 = \" geeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = \" Geek \" ; NEW_LINE str2 = \" geeksforgeeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT"}
{"text":"Function to return the converted string after replacing every consonant sequence with its length","code":"def replaceConsonants ( string ) : NEW_LINE"}
{"text":"To store the resultant string","code":"res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE"}
{"text":"Checking each character for consonant sequence","code":"while ( i < len ( string ) ) : NEW_LINE"}
{"text":"Count the length of consonants sequence","code":"if ( string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' o ' and string [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Add the length in the string","code":"if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT"}
{"text":"Add the vowel","code":"res += string [ i ] ; NEW_LINE i += 1 NEW_LINE count = 0 ; NEW_LINE"}
{"text":"Check for the last consonant sequence in the string","code":"if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT"}
{"text":"Return the resultant string","code":"return res ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdeiop \" ; NEW_LINE print ( replaceConsonants ( string ) ) ; NEW_LINE DEDENT"}
{"text":"isVowel ( ) is a function that returns true for a vowel and false otherwise .","code":"def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT"}
{"text":"function to Encrypt the dtring","code":"def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = \" \" NEW_LINE DEDENT"}
{"text":"for each substring","code":"for l in range ( n - k + 1 ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE DEDENT"}
{"text":"substring of size k","code":"for r in range ( l , l + k ) : NEW_LINE"}
{"text":"counting number of vowels and consonants","code":"if ( isVowel ( s [ r ] ) == True ) : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT"}
{"text":"append product to answer","code":"ans += ( str ) ( countVowels * countConsonants ) NEW_LINE return ans NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hello \" NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT"}
{"text":"An efficient Python3 implementation of above approach","code":"charBuffer = [ ] NEW_LINE def processWords ( input ) : NEW_LINE"}
{"text":"we are splitting the input based on spaces ( s ) + : this regular expression will handle scenarios where we have words separated by multiple spaces","code":"s = input . split ( \" \u2581 \" ) NEW_LINE for values in s : NEW_LINE"}
{"text":"charAt ( 0 ) will pick only the first character from the string and append to buffer","code":"charBuffer . append ( values [ 0 ] ) NEW_LINE return charBuffer NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = \" geeks \u2581 for \u2581 geeks \" NEW_LINE print ( * processWords ( input ) , sep = \" \" ) NEW_LINE DEDENT"}
{"text":"A utility function generate all string without consecutive 1 'sof size K","code":"def generateAllStringsUtil ( K , str , n ) : NEW_LINE"}
{"text":"print binary string without consecutive 1 's","code":"if ( n == K ) : NEW_LINE"}
{"text":"terminate binary string","code":"print ( * str [ : n ] , sep = \" \" , end = \" \u2581 \" ) NEW_LINE return NEW_LINE"}
{"text":"if previous character is '1' then we put only 0 at end of string example str = \"01\" then new string be \"000\"","code":"if ( str [ n - 1 ] == '1' ) : NEW_LINE INDENT str [ n ] = '0' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE DEDENT"}
{"text":"if previous character is '0' than we put both '1' and '0' at end of string example str = \"00\" then new string \"001\" and \"000\"","code":"if ( str [ n - 1 ] == '0' ) : NEW_LINE INDENT str [ n ] = '0' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE str [ n ] = '1' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE DEDENT"}
{"text":"function generate all binary string without consecutive 1 's","code":"def generateAllStrings ( K ) : NEW_LINE"}
{"text":"Base case","code":"if ( K <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT"}
{"text":"One by one stores every binary string of length K","code":"str = [ 0 ] * K NEW_LINE"}
{"text":"Generate all Binary string starts with '0","code":"' NEW_LINE INDENT str [ 0 ] = '0' NEW_LINE generateAllStringsUtil ( K , str , 1 ) NEW_LINE DEDENT"}
{"text":"Generate all Binary string starts with '1","code":"' NEW_LINE INDENT str [ 0 ] = '1' NEW_LINE generateAllStringsUtil ( K , str , 1 ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"K = 3 NEW_LINE generateAllStrings ( K ) NEW_LINE"}
{"text":"Function to find the biggest right circular cylinder","code":"def findVolume ( a ) : NEW_LINE"}
{"text":"side cannot be negative","code":"if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"radius of right circular cylinder","code":"r = a \/ 2 NEW_LINE"}
{"text":"height of right circular cylinder","code":"h = a NEW_LINE"}
{"text":"volume of right circular cylinder","code":"V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 5 NEW_LINE print ( findVolume ( a ) ) NEW_LINE DEDENT"}
{"text":"Function to calculate Volume of Triangular Pyramid","code":"def volumeTriangular ( a , b , h ) : NEW_LINE INDENT return ( 0.1666 ) * a * b * h NEW_LINE DEDENT"}
{"text":"Function To calculate Volume of Square Pyramid","code":"def volumeSquare ( b , h ) : NEW_LINE INDENT return ( 0.33 ) * b * b * h NEW_LINE DEDENT"}
{"text":"Function To calculate Volume of Pentagonal Pyramid","code":"def volumePentagonal ( a , b , h ) : NEW_LINE INDENT return ( 0.83 ) * a * b * h NEW_LINE DEDENT"}
{"text":"Function To calculate Volume of Hexagonal Pyramid","code":"def volumeHexagonal ( a , b , h ) : NEW_LINE INDENT return a * b * h NEW_LINE DEDENT"}
{"text":"Driver Code","code":"b = float ( 4 ) NEW_LINE h = float ( 9 ) NEW_LINE a = float ( 4 ) NEW_LINE print ( \" Volume \u2581 of \u2581 triangular \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumeTriangular ( a , b , h ) ) NEW_LINE print ( \" Volume \u2581 of \u2581 square \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumeSquare ( b , h ) ) NEW_LINE print ( \" Volume \u2581 of \u2581 pentagonal \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumePentagonal ( a , b , h ) ) NEW_LINE print ( \" Volume \u2581 of \u2581 Hexagonal \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumeHexagonal ( a , b , h ) ) NEW_LINE"}
{"text":"Function for the area","code":"def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) \/ 2 ) * h NEW_LINE DEDENT"}
{"text":"Driver Code","code":"base1 = 8 ; base2 = 10 ; height = 6 NEW_LINE area = Area ( base1 , base2 , height ) NEW_LINE print ( \" Area \u2581 is : \" , area ) NEW_LINE"}
{"text":"''Python3 program to find number of diagonals in n sided convex polygon","code":"def numberOfDiagonals ( n ) : NEW_LINE INDENT return n * ( n - 3 ) \/ 2 NEW_LINE DEDENT"}
{"text":"''driver code to test above function","code":"def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" \u2581 sided \u2581 convex \u2581 polygon \u2581 have \u2581 \" ) NEW_LINE print ( numberOfDiagonals ( n ) , \" \u2581 diagonals \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"text":"Function to find the maximum area such that it does not contains any hole","code":"def maximumArea ( l , b , x , y ) : NEW_LINE"}
{"text":"Area for all the possible positions of the cut","code":"left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE"}
{"text":"Find the maximum area among the above rectangles","code":"print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE"}
{"text":"Driver Code","code":"l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE"}
{"text":"Function call","code":"maximumArea ( l , b , x , y ) NEW_LINE"}
{"text":"Function to find the minimum cost of removing characters to make the string unique","code":"def delCost ( s , cost ) : NEW_LINE"}
{"text":"Store the minimum cost required","code":"ans = 0 NEW_LINE"}
{"text":"Create a dictionary to store the maximum cost of removal a character","code":"forMax = { } NEW_LINE"}
{"text":"Create a dictionary to store the total deletion cost of a character","code":"forTot = { } NEW_LINE"}
{"text":"Traverse the string , S","code":"for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"Keep track of maximum cost of each character","code":"if s [ i ] not in forMax : NEW_LINE INDENT forMax [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Update the maximum deletion cost","code":"forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) NEW_LINE"}
{"text":"Keep track of the total cost of each character","code":"if s [ i ] not in forTot : NEW_LINE INDENT forTot [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE"}
{"text":"Update the total deletion cost","code":"forTot [ s [ i ] ] += cost [ i ] NEW_LINE"}
{"text":"Traverse through all the unique characters","code":"for i in forMax : NEW_LINE"}
{"text":"Keep the maximum cost character and delete the rest","code":"ans += forTot [ i ] - forMax [ i ] NEW_LINE"}
{"text":"Return the answer","code":"return ans NEW_LINE"}
{"text":"Given string","code":"string = \" AAABBB \" NEW_LINE"}
{"text":"Given cost array","code":"cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE"}
{"text":"Function Call","code":"print ( delCost ( string , cost ) ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"MAX = 10000 NEW_LINE divisors = [ [ ] for i in range ( MAX + 1 ) ] NEW_LINE"}
{"text":"Stores divisors for all numbers in the vector divisors","code":"def computeDivisors ( ) : NEW_LINE INDENT global divisors NEW_LINE global MAX NEW_LINE for i in range ( 1 , MAX + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 , i ) : NEW_LINE DEDENT DEDENT"}
{"text":"i is the divisor and j is the multiple","code":"divisors [ j ] . append ( i ) NEW_LINE"}
{"text":"Function to compare the closeness of the given target","code":"def getClosest ( val1 , val2 , target ) : NEW_LINE INDENT if ( target - val1 >= val2 - target ) : NEW_LINE INDENT return val2 NEW_LINE DEDENT else : NEW_LINE INDENT return val1 NEW_LINE DEDENT DEDENT"}
{"text":"Function to find the element closest to target in divisors vector","code":"def findClosest ( arr , n , target ) : NEW_LINE"}
{"text":"Corner cases","code":"if ( target <= arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( target >= arr [ n - 1 ] ) : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT"}
{"text":"Perform binary search","code":"i = 0 NEW_LINE j = n NEW_LINE mid = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT mid = ( i + j ) \/\/ 2 NEW_LINE if ( arr [ mid ] == target ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT DEDENT"}
{"text":"Check if target is less than the array element then search in left half","code":"if ( target < arr [ mid ] ) : NEW_LINE"}
{"text":"Check if target is greater than previous to mid , return closest of two","code":"if ( mid > 0 and target > arr [ mid - 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) NEW_LINE DEDENT"}
{"text":"Repeat for left half","code":"j = mid NEW_LINE"}
{"text":"Check if target is greater than mid","code":"else : NEW_LINE INDENT if ( mid < n - 1 and target < arr [ mid + 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) NEW_LINE DEDENT DEDENT"}
{"text":"Update i","code":"i = mid + 1 NEW_LINE"}
{"text":"Only single element left after search","code":"return arr [ mid ] NEW_LINE"}
{"text":"Function to print the divisor of N closest to X","code":"def printClosest ( N , X ) : NEW_LINE INDENT global divisors NEW_LINE DEDENT"}
{"text":"Function call to calculate and stores divisors of all numbers in a vector","code":"computeDivisors ( ) NEW_LINE"}
{"text":"Stores the closest value to target","code":"ans = findClosest ( divisors [ N ] , len ( divisors [ N ] ) , X ) NEW_LINE"}
{"text":"Print the answer","code":"print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given N & X","code":"N = 16 NEW_LINE X = 5 NEW_LINE"}
{"text":"Function Call","code":"printClosest ( N , X ) NEW_LINE"}
{"text":"Function to count maximum matched elements from the arrays A [ ] and B [ ]","code":"def maxMatch ( A , B ) : NEW_LINE"}
{"text":"Stores position of elements of array A [ ] in the array B [ ]","code":"Aindex = { } NEW_LINE"}
{"text":"Keep track of difference between the indices","code":"diff = { } NEW_LINE"}
{"text":"Traverse the array A [ ]","code":"for i in range ( len ( A ) ) : NEW_LINE INDENT Aindex [ A [ i ] ] = i NEW_LINE DEDENT"}
{"text":"Traverse the array B [ ]","code":"for i in range ( len ( B ) ) : NEW_LINE"}
{"text":"If difference is negative , add N to it","code":"if i - Aindex [ B [ i ] ] < 0 : NEW_LINE INDENT if len ( A ) + i - Aindex [ B [ i ] ] not in diff : NEW_LINE INDENT diff [ len ( A ) + i - Aindex [ B [ i ] ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff [ len ( A ) + i - Aindex [ B [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Keep track of the number of shifts required to place elements at same indices","code":"else : NEW_LINE INDENT if i - Aindex [ B [ i ] ] not in diff : NEW_LINE INDENT diff [ i - Aindex [ B [ i ] ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff [ i - Aindex [ B [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Return the max matches","code":"return max ( diff . values ( ) ) NEW_LINE"}
{"text":"Driver Code","code":"A = [ 5 , 3 , 7 , 9 , 8 ] NEW_LINE B = [ 8 , 7 , 3 , 5 , 9 ] NEW_LINE"}
{"text":"Returns the count of matched elements","code":"print ( maxMatch ( A , B ) ) NEW_LINE"}
{"text":"Function to check if all elements of the board [ ] [ ] array store value in the range [ 1 , 9 ]","code":"def isinRange ( board ) : NEW_LINE INDENT N = 9 NEW_LINE DEDENT"}
{"text":"Traverse board [ ] [ ] array","code":"INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE DEDENT DEDENT"}
{"text":"Function to check if the solution of sudoku puzzle is valid or not","code":"def isValidSudoku ( board ) : NEW_LINE INDENT N = 9 NEW_LINE DEDENT"}
{"text":"Check if all elements of board [ ] [ ] stores value in the range [ 1 , 9 ]","code":"INDENT if ( isinRange ( board ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text":"Stores unique value from 1 to N","code":"INDENT unique = [ False ] * ( N + 1 ) NEW_LINE DEDENT"}
{"text":"Traverse each row of the given array","code":"INDENT for i in range ( 0 , N ) : NEW_LINE DEDENT"}
{"text":"Initialize unique [ ] array to false","code":"for m in range ( 0 , N + 1 ) : NEW_LINE unique [ m ] = False NEW_LINE"}
{"text":"Traverse each column of current row","code":"for j in range ( 0 , N ) : NEW_LINE"}
{"text":"Stores the value of board [ i ] [ j ]","code":"Z = board [ i ] [ j ] NEW_LINE"}
{"text":"Check if current row stores duplicate value","code":"if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE"}
{"text":"Traverse each column of the given array","code":"INDENT for i in range ( 0 , N ) : NEW_LINE DEDENT"}
{"text":"Initialize unique [ ] array to false","code":"for m in range ( 0 , N + 1 ) : NEW_LINE unique [ m ] = False NEW_LINE"}
{"text":"Traverse each row of current column","code":"for j in range ( 0 , N ) : NEW_LINE"}
{"text":"Stores the value of board [ j ] [ i ]","code":"Z = board [ j ] [ i ] NEW_LINE"}
{"text":"Check if current column stores duplicate value","code":"if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE"}
{"text":"Traverse each block of size 3 * 3 in board [ ] [ ] array","code":"INDENT for i in range ( 0 , N - 2 , 3 ) : NEW_LINE DEDENT"}
{"text":"j stores first column of each 3 * 3 block","code":"for j in range ( 0 , N - 2 , 3 ) : NEW_LINE"}
{"text":"Initialize unique [ ] array to false","code":"for m in range ( 0 , N + 1 ) : NEW_LINE INDENT unique [ m ] = False NEW_LINE DEDENT"}
{"text":"Traverse current block","code":"for k in range ( 0 , 3 ) : NEW_LINE INDENT for l in range ( 0 , 3 ) : NEW_LINE DEDENT"}
{"text":"Stores row number of current block","code":"X = i + k NEW_LINE"}
{"text":"Stores column number of current block","code":"Y = j + l NEW_LINE"}
{"text":"Stores the value of board [ X ] [ Y ]","code":"Z = board [ X ] [ Y ] NEW_LINE"}
{"text":"Check if current block stores duplicate value","code":"if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE"}
{"text":"If all conditions satisfied","code":"INDENT return True NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT board = [ [ 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 ] , [ 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 ] , [ 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 ] , [ 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 ] , [ 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 ] , [ 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 ] , [ 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 ] , [ 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 ] , [ 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 ] ] NEW_LINE if ( isValidSudoku ( board ) ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Valid \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to check if a number is Palindrome or not here i is the starting index and j is the last index of the subarray","code":"def palindrome ( a , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE DEDENT"}
{"text":"If the integer at i is not equal to j then the subarray is not palindrome","code":"if ( a [ i ] != a [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT"}
{"text":"Otherwise","code":"i += 1 NEW_LINE j -= 1 NEW_LINE"}
{"text":"all a [ i ] is equal to a [ j ] then the subarray is palindrome","code":"return True NEW_LINE"}
{"text":"Function to find a subarray whose concatenation forms a palindrome and return its starting index","code":"def findSubArray ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE DEDENT"}
{"text":"Iterating over subarray of length k and checking if that subarray is palindrome","code":"for i in range ( n - k + 1 ) : NEW_LINE INDENT if ( palindrome ( arr , i , i + k - 1 ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT"}
{"text":"If no subarray is palindrome","code":"return - 1 NEW_LINE"}
{"text":"Driver code","code":"arr = [ 2 , 3 , 5 , 1 , 3 ] NEW_LINE k = 4 NEW_LINE ans = findSubArray ( arr , k ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( ans , ans + k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to check if the man crosses previous visited coordinate or not","code":"def isCrossed ( path ) : NEW_LINE INDENT if ( len ( path ) == 0 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT DEDENT"}
{"text":"Stores the count of crossed vertex","code":"ans = bool ( False ) NEW_LINE"}
{"text":"Stores ( x , y ) coordinates","code":"Set = set ( ) NEW_LINE"}
{"text":"The coordinates for the origin","code":"x , y = 0 , 0 NEW_LINE Set . add ( ( x , y ) ) NEW_LINE"}
{"text":"Iterate over the string","code":"for i in range ( len ( path ) ) : NEW_LINE"}
{"text":"Condition to increment X or Y co - ordinates respectively","code":"if ( path [ i ] == ' N ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y + 1 NEW_LINE DEDENT if ( path [ i ] == ' S ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y - 1 NEW_LINE DEDENT if ( path [ i ] == ' E ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x + 1 NEW_LINE DEDENT if ( path [ i ] == ' W ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x - 1 NEW_LINE DEDENT"}
{"text":"Check if ( x , y ) is already visited","code":"if ( x , y ) in Set : NEW_LINE INDENT ans = bool ( True ) NEW_LINE break NEW_LINE DEDENT"}
{"text":"Print the result","code":"if ( ans ) : NEW_LINE INDENT print ( \" Crossed \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Crossed \" ) NEW_LINE DEDENT"}
{"text":"Given string","code":"path = \" NESW \" NEW_LINE"}
{"text":"Function call","code":"isCrossed ( path ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"from collections import deque NEW_LINE"}
{"text":"Function to find the maximum width of . he tree using level order traversal","code":"def maxWidth ( N , M , cost , s ) : NEW_LINE"}
{"text":"Store the edges of the tree","code":"adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT adj [ s [ i ] [ 0 ] ] . append ( s [ i ] [ 1 ] ) NEW_LINE DEDENT"}
{"text":"Stores maximum width of the tree","code":"result = 0 NEW_LINE"}
{"text":"Stores the nodes of each level","code":"q = deque ( ) NEW_LINE"}
{"text":"Insert root node","code":"q . append ( 0 ) NEW_LINE"}
{"text":"Perform level order traversal on the tree","code":"while ( len ( q ) > 0 ) : NEW_LINE"}
{"text":"Stores the size of the queue","code":"count = len ( q ) NEW_LINE"}
{"text":"Update maximum width","code":"result = max ( count , result ) NEW_LINE"}
{"text":"Push the nodes of the next level and pop the elements of the current level","code":"while ( count > 0 ) : NEW_LINE"}
{"text":"Get element from the front the Queue","code":"temp = q . popleft ( ) NEW_LINE"}
{"text":"Push all nodes of the next level .","code":"for i in adj [ temp ] : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT count -= 1 NEW_LINE"}
{"text":"Return the result .","code":"return result NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE M = 10 NEW_LINE edges = [ ] NEW_LINE edges . append ( [ 0 , 1 ] ) NEW_LINE edges . append ( [ 0 , 2 ] ) NEW_LINE edges . append ( [ 0 , 3 ] ) NEW_LINE edges . append ( [ 1 , 4 ] ) NEW_LINE edges . append ( [ 1 , 5 ] ) NEW_LINE edges . append ( [ 3 , 6 ] ) NEW_LINE edges . append ( [ 4 , 7 ] ) NEW_LINE edges . append ( [ 6 , 1 ] ) NEW_LINE edges . append ( [ 6 , 8 ] ) NEW_LINE edges . append ( [ 6 , 9 ] ) NEW_LINE cost = [ 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 ] NEW_LINE DEDENT"}
{"text":"Constructed tree is : 1 \/ | \\ 2 - 1 3 \/ \\ \\ 4 5 8 \/ \/ | \\ 2 6 12 7","code":"print ( maxWidth ( N , M , cost , edges ) ) NEW_LINE"}
{"text":"Pthon3 Program to implement the above approach","code":"MAX = 10000000 NEW_LINE"}
{"text":"Stores if an index is a prime \/ non - prime value","code":"isPrime = [ True ] * ( MAX + 1 ) NEW_LINE"}
{"text":"Stores the prime","code":"primes = [ ] NEW_LINE"}
{"text":"Function to generate all prime numbers","code":"def SieveOfEratosthenes ( ) : NEW_LINE INDENT global isPrime NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE DEDENT"}
{"text":"If current element is prime","code":"if ( isPrime [ p ] == True ) : NEW_LINE"}
{"text":"Set all its multiples non - prime","code":"for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE"}
{"text":"Store all prime numbers","code":"for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT"}
{"text":"Function to find the closest prime to a particular number","code":"def prime_search ( primes , diff ) : NEW_LINE"}
{"text":"Applying binary search on primes vector","code":"low = 0 NEW_LINE high = len ( primes ) - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"If the prime added makes the elements equal","code":"if ( primes [ mid ] == diff ) : NEW_LINE"}
{"text":"Return this as the closest prime","code":"return primes [ mid ] NEW_LINE"}
{"text":"If the array remains non - decreasing","code":"elif ( primes [ mid ] < diff ) : NEW_LINE"}
{"text":"Search for a bigger prime number","code":"low = mid + 1 NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT res = primes [ mid ] NEW_LINE DEDENT"}
{"text":"Check if a smaller prime can make array non - decreasing or not","code":"high = mid - 1 NEW_LINE"}
{"text":"Return closest number","code":"return res NEW_LINE"}
{"text":"Function to find the minimum cost","code":"def minCost ( arr , n ) : NEW_LINE"}
{"text":"Find all primes","code":"SieveOfEratosthenes ( ) NEW_LINE"}
{"text":"Store the result","code":"res = 0 NEW_LINE"}
{"text":"Iterate over the array","code":"for i in range ( 1 , n ) : NEW_LINE"}
{"text":"Current element is less than the previous element","code":"if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT diff = arr [ i - 1 ] - arr [ i ] NEW_LINE DEDENT"}
{"text":"Find the closest prime which makes the array non decreasing","code":"closest_prime = prime_search ( primes , diff ) NEW_LINE"}
{"text":"Add to overall cost","code":"res += closest_prime NEW_LINE"}
{"text":"Update current element","code":"arr [ i ] += closest_prime NEW_LINE"}
{"text":"Return the minimum cost","code":"return res NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given array","code":"arr = [ 2 , 1 , 5 , 4 , 3 ] NEW_LINE n = 5 NEW_LINE"}
{"text":"Function Call","code":"print ( minCost ( arr , n ) ) NEW_LINE"}
{"text":"Function to return ways to split a string into three parts with the equal number of 0","code":"def count ( s ) : NEW_LINE"}
{"text":"Store total count of 0 s","code":"cnt = 0 NEW_LINE"}
{"text":"Count total no . of 0 s character in given string","code":"for c in s : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT"}
{"text":"If total count of 0 character is not divisible by 3","code":"if ( cnt % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE k = cnt \/\/ 3 NEW_LINE sum = 0 NEW_LINE"}
{"text":"Initialize map to store frequency of k","code":"mp = { } NEW_LINE"}
{"text":"Traverse string to find ways to split string","code":"for i in range ( len ( s ) ) : NEW_LINE"}
{"text":"Increment count if 0 appears","code":"if s [ i ] == '0' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT"}
{"text":"Increment result if sum equal to 2 * k and k exists in map","code":"if ( sum == 2 * k and k in mp and i < len ( s ) - 1 and i > 0 ) : NEW_LINE INDENT res += mp [ k ] NEW_LINE DEDENT"}
{"text":"Insert sum in map","code":"if sum in mp : NEW_LINE INDENT mp [ sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ sum ] = 1 NEW_LINE DEDENT"}
{"text":"Return result","code":"return res NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given string","code":"st = \"01010\" NEW_LINE"}
{"text":"Function call","code":"print ( count ( st ) ) NEW_LINE"}
{"text":"Function to calculate the number of ways to split","code":"def splitstring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT"}
{"text":"Calculating the total number of zeros","code":"zeros = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Case1 If total count of zeros is not divisible by 3","code":"if zeros % 3 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT"}
{"text":"Case2 if total count of zeros is zero","code":"if zeros == 0 : NEW_LINE INDENT return ( ( n - 1 ) * ( n - 2 ) ) \/\/ 2 NEW_LINE DEDENT"}
{"text":"Number of zeros in each substring","code":"zerosInEachSubstring = zeros \/\/ 3 NEW_LINE"}
{"text":"Initialising zero to the number of ways for first and second cut","code":"waysOfFirstCut , waysOfSecondCut = 0 , 0 NEW_LINE"}
{"text":"Initializing the count","code":"count = 0 NEW_LINE"}
{"text":"Traversing from the beginning","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Incrementing the count if the element is '0","code":"' NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Incrementing the ways for the 1 st cut if count is equal to zeros required in each substring","code":"if ( count == zerosInEachSubstring ) : NEW_LINE INDENT waysOfFirstCut += 1 NEW_LINE DEDENT"}
{"text":"Incrementing the ways for the 2 nd cut if count is equal to 2 * ( zeros required in each substring )","code":"elif ( count == 2 * zerosInEachSubstring ) : NEW_LINE INDENT waysOfSecondCut += 1 NEW_LINE DEDENT"}
{"text":"Total number of ways to split is multiplication of ways for the 1 st and 2 nd cut","code":"return waysOfFirstCut * waysOfSecondCut NEW_LINE"}
{"text":"Driver code","code":"s = \"01010\" NEW_LINE"}
{"text":"Function call","code":"print ( \" The \u2581 number \u2581 of \u2581 ways \u2581 to \u2581 split \u2581 is \" , splitstring ( s ) ) NEW_LINE"}
{"text":"Function to check if it is possible to transform start to end","code":"def canTransform ( str1 , str2 ) : NEW_LINE INDENT s1 = \" \" NEW_LINE s2 = \" \" NEW_LINE DEDENT"}
{"text":"Check the sequence of A , B in both strings str1 and str2","code":"for c in str1 : NEW_LINE INDENT if ( c != ' C ' ) : NEW_LINE INDENT s1 += c NEW_LINE DEDENT DEDENT for c in str2 : NEW_LINE INDENT if ( c != ' C ' ) : NEW_LINE INDENT s2 += c NEW_LINE DEDENT DEDENT"}
{"text":"If both the strings are not equal","code":"if ( s1 != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE n = len ( str1 ) NEW_LINE"}
{"text":"Traverse the strings","code":"while ( i < n and j < n ) : NEW_LINE INDENT if ( str1 [ i ] == ' C ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( str2 [ j ] == ' C ' ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Check for indexes of A and B","code":"else : NEW_LINE INDENT if ( ( str1 [ i ] == ' A ' and i < j ) or ( str1 [ i ] == ' B ' and i > j ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" BCCABCBCA \" NEW_LINE str2 = \" CBACCBBAC \" NEW_LINE DEDENT"}
{"text":"Function call","code":"if ( canTransform ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to return the length of the longest substring having equal number of vowel and consonant","code":"def maxsubstringLength ( S , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE DEDENT"}
{"text":"Generate the array","code":"for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' a ' or S [ i ] == ' e ' or S [ i ] == ' i ' or S [ i ] == ' o ' or S [ i ] == ' u ' ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT"}
{"text":"Initialize variable to store result","code":"maxLen = 0 NEW_LINE"}
{"text":"Stores the sum of subarray","code":"curr_sum = 0 NEW_LINE"}
{"text":"Map to store indices of the sum","code":"hash = { } NEW_LINE"}
{"text":"Loop through the array","code":"for i in range ( N ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT"}
{"text":"If sum is 0","code":"if ( curr_sum == 0 ) : NEW_LINE"}
{"text":"Count of vowels and consonants are equal","code":"maxLen = max ( maxLen , i + 1 ) NEW_LINE"}
{"text":"Update the maximum length of substring in HashMap","code":"if ( curr_sum in hash . keys ( ) ) : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) NEW_LINE DEDENT"}
{"text":"Store the index of the sum","code":"else : NEW_LINE INDENT hash [ curr_sum ] = i NEW_LINE DEDENT"}
{"text":"Return the maximum length of required substring","code":"return maxLen NEW_LINE"}
{"text":"Driver Code","code":"S = \" geeksforgeeks \" NEW_LINE n = len ( S ) NEW_LINE print ( maxsubstringLength ( S , n ) ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"mat = [ [ 0 for x in range ( 1001 ) ] for y in range ( 1001 ) ] NEW_LINE"}
{"text":"Stores the accessible directions","code":"dx = [ 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 ] NEW_LINE dy = [ 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 ] NEW_LINE"}
{"text":"Function to find the minimum distance from a given cell to all other cells in the matrix","code":"def FindMinimumDistance ( ) : NEW_LINE INDENT global x , y , r , c NEW_LINE DEDENT"}
{"text":"Stores the accessible cells from current cell","code":"q = [ ] NEW_LINE"}
{"text":"Insert pair ( x , y )","code":"q . append ( [ x , y ] ) NEW_LINE mat [ x ] [ y ] = 0 NEW_LINE"}
{"text":"Iterate untill queue is empty","code":"while ( len ( q ) != 0 ) : NEW_LINE"}
{"text":"Extract the pair","code":"x = q [ 0 ] [ 0 ] NEW_LINE y = q [ 0 ] [ 1 ] NEW_LINE"}
{"text":"Pop them","code":"q . pop ( 0 ) NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT a = x + dx [ i ] NEW_LINE b = y + dy [ i ] NEW_LINE DEDENT"}
{"text":"Checking boundary condition","code":"if ( a < 0 or a >= r or b >= c or b < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT"}
{"text":"If the cell is not visited","code":"if ( mat [ a ] [ b ] == 0 ) : NEW_LINE"}
{"text":"Assign the minimum distance","code":"mat [ a ] [ b ] = mat [ x ] [ y ] + 1 NEW_LINE"}
{"text":"Insert the traversed neighbour into the queue","code":"q . append ( [ a , b ] ) NEW_LINE"}
{"text":"Driver Code","code":"r = 5 NEW_LINE c = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE t = x NEW_LINE l = y NEW_LINE mat [ x ] [ y ] = 0 NEW_LINE FindMinimumDistance ( ) NEW_LINE mat [ t ] [ l ] = 0 NEW_LINE"}
{"text":"Print the required distances","code":"for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Function that returns the minimum number of flips to convert the s into a concatenation of K - length sub - string","code":"def minOperations ( S , K ) : NEW_LINE"}
{"text":"Stores the result","code":"ans = 0 NEW_LINE"}
{"text":"Iterate through string index","code":"for i in range ( K ) : NEW_LINE"}
{"text":"Stores count of 0 s & 1 s","code":"zero , one = 0 , 0 NEW_LINE"}
{"text":"Iterate making K jumps","code":"for j in range ( i , len ( S ) , K ) : NEW_LINE"}
{"text":"Count 0 's","code":"if ( S [ j ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT"}
{"text":"Count 1 's","code":"else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT"}
{"text":"Add minimum flips for index i","code":"ans += min ( zero , one ) NEW_LINE"}
{"text":"Return minimum number of flips","code":"return ans NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"110100101\" NEW_LINE K = 3 NEW_LINE print ( minOperations ( s , K ) ) NEW_LINE DEDENT"}
{"text":"Function to get the missing element","code":"def missingElement ( arr , n ) : NEW_LINE"}
{"text":"For maximum element in the array","code":"max_ele = arr [ 0 ] NEW_LINE"}
{"text":"For minimum Element in the array","code":"min_ele = arr [ 0 ] NEW_LINE"}
{"text":"For xor of all elements","code":"x = 0 NEW_LINE"}
{"text":"Common difference of AP series","code":"d = 0 NEW_LINE"}
{"text":"Find maximum and minimum element","code":"for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min_ele ) : NEW_LINE INDENT min_ele = arr [ i ] NEW_LINE DEDENT DEDENT"}
{"text":"Calculating common difference","code":"d = ( max_ele - min_ele ) \/\/ n NEW_LINE"}
{"text":"Calculate the XOR of all elements","code":"for i in range ( n ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT"}
{"text":"Perform XOR with actual AP series resultant x will be the ans","code":"for i in range ( n + 1 ) : NEW_LINE INDENT x = x ^ ( min_ele + ( i * d ) ) NEW_LINE DEDENT"}
{"text":"Return the missing element","code":"return x NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given array","code":"arr = [ 12 , 3 , 6 , 15 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE"}
{"text":"Function Call","code":"element = missingElement ( arr , n ) NEW_LINE"}
{"text":"Print the missing element","code":"print ( element ) NEW_LINE"}
{"text":"Function to prints kth sub - string","code":"def Printksubstring ( str1 , n , k ) : NEW_LINE"}
{"text":"Total sub - strings possible","code":"total = int ( ( n * ( n + 1 ) ) \/ 2 ) NEW_LINE"}
{"text":"If k is greater than total number of sub - strings","code":"if ( k > total ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT"}
{"text":"To store number of sub - strings starting with ith character of the string","code":"substring = [ 0 for i in range ( n + 1 ) ] NEW_LINE substring [ 0 ] = 0 NEW_LINE"}
{"text":"Compute the values","code":"temp = n NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE"}
{"text":"substring [ i - 1 ] is added to store the cumulative sum","code":"substring [ i ] = substring [ i - 1 ] + temp NEW_LINE temp -= 1 NEW_LINE"}
{"text":"Binary search to find the starting index of the kth sub - string","code":"l = 1 NEW_LINE h = n NEW_LINE start = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = int ( ( l + h ) \/ 2 ) NEW_LINE if ( substring [ m ] > k ) : NEW_LINE INDENT start = m NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( substring [ m ] < k ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = m NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"To store the ending index of the kth sub - string","code":"end = n - ( substring [ start ] - k ) NEW_LINE"}
{"text":"Print the sub - string","code":"for i in range ( start - 1 , end ) : NEW_LINE INDENT print ( str1 [ i ] , end = \" \" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abc \" NEW_LINE k = 4 NEW_LINE n = len ( str1 ) NEW_LINE Printksubstring ( str1 , n , k ) NEW_LINE DEDENT"}
{"text":"Function to return the lower insertion point of an element in a sorted array","code":"def LowerInsertionPoint ( arr , n , X ) : NEW_LINE"}
{"text":"Base cases","code":"if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lowerPnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lowerPnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT"}
{"text":"Final check for the remaining elements which are < X","code":"while ( lowerPnt < n and arr [ lowerPnt ] < X ) : NEW_LINE INDENT lowerPnt += 1 NEW_LINE DEDENT return lowerPnt NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE X = 4 NEW_LINE print ( LowerInsertionPoint ( arr , n , X ) ) NEW_LINE DEDENT"}
{"text":"Returns count of required positions","code":"def getCount ( M , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT"}
{"text":"horizontal 1D array","code":"if ( M == 1 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT"}
{"text":"vertical 1D array","code":"if ( N == 1 ) : NEW_LINE INDENT return M ; NEW_LINE DEDENT if ( N > M ) : NEW_LINE"}
{"text":"iterating for all possible i","code":"for i in range ( 1 , M + 1 ) : NEW_LINE INDENT numerator = N * i - N + M - i ; NEW_LINE denominator = M - 1 ; NEW_LINE DEDENT"}
{"text":"checking if j is integer","code":"if ( numerator % denominator == 0 ) : NEW_LINE INDENT j = numerator \/ denominator ; NEW_LINE DEDENT"}
{"text":"checking if j lies b \/ w 1 to N","code":"if ( j >= 1 and j <= N ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE"}
{"text":"iterating for all possible j","code":"for j in range ( 1 , N + 1 ) : NEW_LINE INDENT numerator = M * j - M + N - j ; NEW_LINE denominator = N - 1 ; NEW_LINE DEDENT"}
{"text":"checking if i is integer","code":"if ( numerator % denominator == 0 ) : NEW_LINE INDENT i = numerator \/ denominator ; NEW_LINE DEDENT"}
{"text":"checking if i lies b \/ w 1 to M","code":"if ( i >= 1 and i <= M ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M , N = 3 , 5 ; NEW_LINE print ( getCount ( M , N ) ) ; NEW_LINE DEDENT"}
{"text":"Python3 program to make array sorted","code":"import sys NEW_LINE"}
{"text":"Function to check whether there is any swappable element present to make the first array sorted","code":"def swapElement ( arr1 , arr2 , n ) : NEW_LINE"}
{"text":"wrongIdx is the index of the element which is making the first array unsorted","code":"wrongIdx = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr1 [ i - 1 ] ) : NEW_LINE INDENT wrongIdx = i NEW_LINE DEDENT DEDENT maximum = - ( sys . maxsize - 1 ) NEW_LINE maxIdx = - 1 NEW_LINE res = False NEW_LINE"}
{"text":"Find the maximum element which satisfies the above mentioned neighboring conditions","code":"for i in range ( n ) : NEW_LINE INDENT if ( arr2 [ i ] > maximum and arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) : NEW_LINE INDENT if ( wrongIdx + 1 <= n - 1 and arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) : NEW_LINE INDENT maximum = arr2 [ i ] NEW_LINE maxIdx = i NEW_LINE res = True NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"if res is true then swap the element and make the first array sorted","code":"if ( res ) : NEW_LINE INDENT ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) = ( arr2 [ maxIdx ] , arr1 [ wrongIdx ] ) NEW_LINE DEDENT return res NEW_LINE"}
{"text":"Function to print the sorted array if elements are swapped .","code":"def getSortedArray ( arr1 , arr2 , n ) : NEW_LINE INDENT if ( swapElement ( arr1 , arr2 , n ) ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 1 , 3 , 7 , 4 , 10 ] NEW_LINE arr2 = [ 2 , 1 , 6 , 8 , 9 ] NEW_LINE n = len ( arr1 ) NEW_LINE getSortedArray ( arr1 , arr2 , n ) NEW_LINE DEDENT"}
{"text":"Function to find the middle of three numbers","code":"def middleOfThree ( a , b , c ) : NEW_LINE"}
{"text":"Compare each three number to find middle number . Enter only if a > b","code":"if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE"}
{"text":"Decided a is not greater than b .","code":"if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT"}
{"text":"Driver Code","code":"a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE"}
{"text":"Function to find the transpose of the matrix mat [ ]","code":"def transpose ( mat , row , col ) : NEW_LINE"}
{"text":"Stores the transpose of matrix mat [ ] [ ]","code":"tr = [ [ 0 for i in range ( row ) ] for i in range ( col ) ] NEW_LINE"}
{"text":"Traverse each row of the matrix","code":"for i in range ( row ) : NEW_LINE"}
{"text":"Traverse each column of the matrix","code":"for j in range ( col ) : NEW_LINE"}
{"text":"Transpose matrix elements","code":"tr [ j ] [ i ] = mat [ i ] [ j ] NEW_LINE return tr NEW_LINE"}
{"text":"Function to sort the given matrix in row wise manner","code":"def RowWiseSort ( B ) : NEW_LINE"}
{"text":"Traverse the row","code":"for i in range ( len ( B ) ) : NEW_LINE"}
{"text":"Row - Wise Sorting","code":"B [ i ] = sorted ( B [ i ] ) NEW_LINE return B NEW_LINE"}
{"text":"Function to print the matrix in column wise sorted manner","code":"def sortCol ( mat , N , M ) : NEW_LINE"}
{"text":"Function call to find transpose of the the matrix mat [ ] [ ]","code":"B = transpose ( mat , N , M ) NEW_LINE"}
{"text":"Sorting the matrix row - wise","code":"B = RowWiseSort ( B ) NEW_LINE"}
{"text":"Calculate transpose of B [ ] [ ]","code":"mat = transpose ( B , M , N ) NEW_LINE"}
{"text":"Print the matrix mat [ ] [ ]","code":"for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Input","code":"mat = [ [ 1 , 6 , 10 ] , [ 8 , 5 , 9 ] , [ 9 , 4 , 15 ] , [ 7 , 3 , 60 ] ] NEW_LINE N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE"}
{"text":"Function call to print the matrix in column wise sorted manner","code":"sortCol ( mat , N , M ) NEW_LINE"}
{"text":"Function to find the largest area when a series of horizontal & vertical bars are removed","code":"def largestArea ( N , M , H , V , h , v ) : NEW_LINE"}
{"text":"Stores all bars","code":"INDENT s1 = set ( [ ] ) ; NEW_LINE s2 = set ( [ ] ) ; NEW_LINE DEDENT"}
{"text":"Insert horizontal bars","code":"INDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT s1 . add ( i ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Insert vertictal bars","code":"INDENT for i in range ( 1 , M + 2 ) : NEW_LINE INDENT s2 . add ( i ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Remove horizontal separators from s1","code":"INDENT for i in range ( h ) : NEW_LINE INDENT s1 . remove ( H [ i ] ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Remove vertical separators from s2","code":"INDENT for i in range ( v ) : NEW_LINE INDENT s2 . remove ( V [ i ] ) ; NEW_LINE DEDENT DEDENT"}
{"text":"Stores left out horizontal and vertical separators","code":"INDENT list1 = [ 0 ] * len ( s1 ) NEW_LINE list2 = [ 0 ] * len ( s2 ) ; NEW_LINE i = 0 ; NEW_LINE for it1 in s1 : NEW_LINE INDENT list1 [ i ] = it1 ; NEW_LINE i += 1 NEW_LINE DEDENT i = 0 ; NEW_LINE for it2 in s2 : NEW_LINE INDENT list2 [ i ] = it2 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT"}
{"text":"Sort both list in ascending order","code":"INDENT list1 . sort ( ) ; NEW_LINE list2 . sort ( ) ; NEW_LINE maxH = 0 NEW_LINE p1 = 0 NEW_LINE maxV = 0 NEW_LINE p2 = 0 ; NEW_LINE DEDENT"}
{"text":"Find maximum difference of neighbors of list1","code":"INDENT for j in range ( len ( s1 ) ) : NEW_LINE INDENT maxH = max ( maxH , list1 [ j ] - p1 ) ; NEW_LINE p1 = list1 [ j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Find max difference of neighbors of list2","code":"INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT maxV = max ( maxV , list2 [ j ] - p2 ) ; NEW_LINE p2 = list2 [ j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Print largest volume","code":"INDENT print ( ( maxV * maxH ) ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given value of N & M","code":"INDENT N = 3 NEW_LINE M = 3 ; NEW_LINE DEDENT"}
{"text":"Given arrays","code":"INDENT H = [ 2 ] NEW_LINE V = [ 2 ] ; NEW_LINE h = len ( H ) NEW_LINE v = len ( V ) ; NEW_LINE DEDENT"}
{"text":"Function call to find the largest area when a series of horizontal & vertical bars are removed","code":"INDENT largestArea ( N , M , H , V , h , v ) ; NEW_LINE DEDENT"}
{"text":"Function to check if array , A [ ] can be converted into sorted array by swapping ( A [ i ] , A [ j ] ) if B [ i ] not equal to B [ j ]","code":"def checkifSorted ( A , B , N ) : NEW_LINE"}
{"text":"Stores if array A [ ] is sorted in descending order or not","code":"INDENT flag = False NEW_LINE DEDENT"}
{"text":"Traverse the array A [ ]","code":"INDENT for i in range ( N - 1 ) : NEW_LINE DEDENT"}
{"text":"If A [ i ] is greater than A [ i + 1 ]","code":"if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE"}
{"text":"Update flag","code":"flag = True NEW_LINE break NEW_LINE"}
{"text":"If array is sorted in ascending order","code":"INDENT if ( not flag ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT"}
{"text":"count = 2 : Check if 0 s and 1 s both present in the B [ ]","code":"INDENT count = 0 NEW_LINE DEDENT"}
{"text":"Traverse the array","code":"INDENT for i in range ( N ) : NEW_LINE DEDENT"}
{"text":"If current element is 0","code":"if ( B [ i ] == 0 ) : NEW_LINE"}
{"text":"Update count","code":"count += 1 NEW_LINE break NEW_LINE"}
{"text":"Traverse the array B [ ]","code":"INDENT for i in range ( N ) : NEW_LINE DEDENT"}
{"text":"If current element is 1","code":"if B [ i ] : NEW_LINE count += 1 NEW_LINE break NEW_LINE"}
{"text":"If both 0 s and 1 s are present in the array","code":"INDENT if ( count == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT"}
{"text":"Input array A [ ]","code":"A = [ 3 , 1 , 2 ] NEW_LINE"}
{"text":"Input array B [ ]","code":"B = [ 0 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE"}
{"text":"Function call","code":"check = checkifSorted ( A , B , N ) NEW_LINE"}
{"text":"If true , print YES","code":"if ( check ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT"}
{"text":"Else print NO","code":"else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text":"Function to find the minimum number of steps to make A > B","code":"def minSteps ( A , B , M , N ) : NEW_LINE INDENT if ( A [ 0 ] > B [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B [ 0 ] > A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT"}
{"text":"If all character are same and M <= N","code":"if ( M <= N and A [ 0 ] == B [ 0 ] and A . count ( A [ 0 ] ) == M and B . count ( B [ 0 ] ) == N ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT"}
{"text":"If there lies any character in B which is greater than B [ 0 ]","code":"for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] > B [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT"}
{"text":"If there lies any character in A which is smaller than A [ 0 ]","code":"for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] < A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT"}
{"text":"If there lies a character which is in A and greater than A [ 0 ]","code":"for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] > A [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT"}
{"text":"If there lies a character which is in B and less than B [ 0 ]","code":"for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] < B [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT"}
{"text":"Otherwise","code":"return 0 NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" adsfd \" NEW_LINE B = \" dffff \" NEW_LINE M = len ( A ) NEW_LINE N = len ( B ) NEW_LINE print ( minSteps ( A , B , M , N ) ) NEW_LINE DEDENT"}
{"text":"Python3 program for the above approach","code":"maxN = 201 ; NEW_LINE"}
{"text":"Variables which represent the size of the array","code":"n1 , n2 , n3 = 0 , 0 , 0 ; NEW_LINE"}
{"text":"Stores the results","code":"dp = [ [ [ 0 for i in range ( maxN ) ] for j in range ( maxN ) ] for j in range ( maxN ) ] ; NEW_LINE"}
{"text":"Function to return the maximum possible sum","code":"def getMaxSum ( i , j , k , arr1 , arr2 , arr3 ) : NEW_LINE"}
{"text":"Stores the count of arrays processed","code":"cnt = 0 ; NEW_LINE if ( i >= n1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( j >= n2 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( k >= n3 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT"}
{"text":"If more than two arrays have been processed","code":"if ( cnt >= 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT"}
{"text":"If an already computed subproblem occurred","code":"if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE"}
{"text":"Explore all the possible pairs","code":"if ( i < n1 and j < n2 ) : NEW_LINE"}
{"text":"Recursive function call","code":"ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; NEW_LINE if ( i < n1 and k < n3 ) : NEW_LINE ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; NEW_LINE if ( j < n2 and k < n3 ) : NEW_LINE ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; NEW_LINE"}
{"text":"Memoize the maximum","code":"dp [ i ] [ j ] [ k ] = ans ; NEW_LINE"}
{"text":"Returning the value","code":"return dp [ i ] [ j ] [ k ] ; NEW_LINE def reverse ( tmp ) : NEW_LINE i , k , t = 0 , 0 , 0 ; NEW_LINE n = len ( tmp ) ; NEW_LINE for i in range ( n \/\/ 2 ) : NEW_LINE INDENT t = tmp [ i ] ; NEW_LINE tmp [ i ] = tmp [ n - i - 1 ] ; NEW_LINE tmp [ n - i - 1 ] = t ; NEW_LINE DEDENT"}
{"text":"Function to return the maximum sum of products of pairs possible","code":"def maxProductSum ( arr1 , arr2 , arr3 ) : NEW_LINE"}
{"text":"Initialising the dp array to - 1","code":"for i in range ( len ( dp ) ) : NEW_LINE INDENT for j in range ( len ( dp [ 0 ] ) ) : NEW_LINE INDENT for k in range ( len ( dp [ j ] [ 0 ] ) ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 ; NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Sort the arrays in descending order","code":"arr1 . sort ( ) ; NEW_LINE reverse ( arr1 ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE reverse ( arr2 ) ; NEW_LINE arr3 . sort ( ) ; NEW_LINE reverse ( arr3 ) ; NEW_LINE return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 2 ; NEW_LINE arr1 = [ 3 , 5 ] ; NEW_LINE n2 = 2 ; NEW_LINE arr2 = [ 2 , 1 ] ; NEW_LINE n3 = 3 ; NEW_LINE arr3 = [ 4 , 3 , 5 ] ; NEW_LINE print ( maxProductSum ( arr1 , arr2 , arr3 ) ) ; NEW_LINE DEDENT"}
{"text":"Function to find lexicographically largest triplet that forms a triangle in the given array","code":"def findTriplet ( arr , N ) : NEW_LINE"}
{"text":"Sort the array","code":"arr . sort ( ) NEW_LINE"}
{"text":"Iterate from the end of the array","code":"i = N - 1 NEW_LINE while i - 2 >= 0 : NEW_LINE"}
{"text":"If the triplet forms a triangle","code":"if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE"}
{"text":"If triplet found","code":"if ( flag ) : NEW_LINE"}
{"text":"Print the triplet","code":"print ( arr [ i - 2 ] , arr [ i - 1 ] , arr [ i ] ) NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 10 , 3 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findTriplet ( arr , N ) NEW_LINE DEDENT"}
{"text":"Function to return the count of all pairs having minimal absolute difference","code":"def numberofpairs ( arr , N ) : NEW_LINE"}
{"text":"Stores the count of pairs","code":"answer = 0 NEW_LINE"}
{"text":"Sort the array","code":"arr . sort ( ) NEW_LINE"}
{"text":"Stores the minimum difference between adjacent pairs","code":"minDiff = 10000000 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE"}
{"text":"Update the minimum difference between pairs","code":"minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE if arr [ i + 1 ] - arr [ i ] == minDiff : NEW_LINE"}
{"text":"Increase count of pairs with difference equal to that of minimum difference","code":"answer += 1 NEW_LINE"}
{"text":"Return the final count","code":"return answer NEW_LINE"}
{"text":"Driver code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given array arr [ ]","code":"arr = [ 4 , 2 , 1 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE"}
{"text":"Function call","code":"print ( numberofpairs ( arr , N ) ) NEW_LINE"}
{"text":"Initialise maximum possible length of subsequence","code":"max_length = 0 NEW_LINE"}
{"text":"Store elements to compare max_length with its size and change the value of max_length accordingly","code":"store = [ ] NEW_LINE"}
{"text":"Store the elements of the longest subsequence","code":"ans = [ ] NEW_LINE"}
{"text":"Function to find the length of longest subsequence","code":"def find_max_length ( arr , index , sum , k ) : NEW_LINE INDENT global max_length NEW_LINE sum = sum + arr [ index ] NEW_LINE store . append ( arr [ index ] ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT if ( max_length < len ( store ) ) : NEW_LINE DEDENT DEDENT"}
{"text":"Update max_length","code":"max_length = len ( store ) NEW_LINE"}
{"text":"Store the subsequence elements","code":"ans = store NEW_LINE for i in range ( index + 1 , len ( arr ) ) : NEW_LINE if ( sum + arr [ i ] <= k ) : NEW_LINE"}
{"text":"Recursively proceed with obtained sum","code":"find_max_length ( arr , i , sum , k ) NEW_LINE"}
{"text":"poping elements from back of vector store","code":"store . pop ( ) NEW_LINE"}
{"text":"if sum > 0 then we don 't  required thatsubsequence  so return and continue  with earlier elements","code":"else : NEW_LINE INDENT return NEW_LINE DEDENT return NEW_LINE def longestSubsequence ( arr , n , k ) : NEW_LINE"}
{"text":"Sort the given array","code":"arr . sort ( ) NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( n ) : NEW_LINE"}
{"text":"If max_length is already greater than or equal than remaining length","code":"if ( max_length >= n - i ) : NEW_LINE INDENT break NEW_LINE DEDENT store . clear ( ) NEW_LINE find_max_length ( arr , i , 0 , k ) NEW_LINE return max_length NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 3 , 0 , 1 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( longestSubsequence ( arr , n , k ) ) NEW_LINE DEDENT"}
{"text":"Function to sort array","code":"def sortArray ( A , N ) : NEW_LINE"}
{"text":"Check if possible to sort array","code":"if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE"}
{"text":"Swapping to bring element at required position Bringing at least one element at correct position","code":"for i in range ( N \/\/ 2 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT DEDENT"}
{"text":"Tracing changes in Array","code":"A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE"}
{"text":"Print the sorted array","code":"print ( \" Sorted \u2581 Array : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"If not possible to sort","code":"else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"}
{"text":"Driver code","code":"A = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE sortArray ( A , N ) NEW_LINE"}
{"text":"Function to return K such that changing all elements greater than K to K will make array sum N otherwise return - 1","code":"def findK ( arr , size , N ) : NEW_LINE"}
{"text":"Sorting the array in increasing order","code":"arr = sorted ( arr ) NEW_LINE temp_sum = 0 NEW_LINE"}
{"text":"Loop through all the elements of the array","code":"for i in range ( size ) : NEW_LINE INDENT temp_sum += arr [ i ] NEW_LINE DEDENT"}
{"text":"Checking if sum of array equals N","code":"if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE"}
{"text":"Driver code","code":"arr = [ 3 , 1 , 10 , 4 , 8 ] NEW_LINE size = len ( arr ) NEW_LINE N = 16 NEW_LINE print ( findK ( arr , size , N ) ) NEW_LINE"}
{"text":"Function that returns True if there exists a triplet with sum x","code":"def existsTriplet ( a , b , c , x , l1 , l2 , l3 ) : NEW_LINE"}
{"text":"Sorting arrays such that a represents smallest array","code":"if ( l2 <= l1 and l2 <= l3 ) : NEW_LINE INDENT l1 , l2 = l2 , l1 NEW_LINE a , b = b , a NEW_LINE DEDENT elif ( l3 <= l1 and l3 <= l2 ) : NEW_LINE INDENT l1 , l3 = l3 , l1 NEW_LINE a , c = c , a NEW_LINE DEDENT"}
{"text":"Iterating the smallest array","code":"for i in range ( l1 ) : NEW_LINE"}
{"text":"Two pointers on second and third array","code":"j = 0 NEW_LINE k = l3 - 1 NEW_LINE while ( j < l2 and k >= 0 ) : NEW_LINE"}
{"text":"If a valid triplet is found","code":"if ( a [ i ] + b [ j ] + c [ k ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( a [ i ] + b [ j ] + c [ k ] < x ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT return False NEW_LINE"}
{"text":"Driver code","code":"a = [ 2 , 7 , 8 , 10 , 15 ] NEW_LINE b = [ 1 , 6 , 7 , 8 ] NEW_LINE c = [ 4 , 5 , 5 ] NEW_LINE l1 = len ( a ) NEW_LINE l2 = len ( b ) NEW_LINE l3 = len ( c ) NEW_LINE x = 14 NEW_LINE if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Utility function to print the contents of an array","code":"def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT"}
{"text":"A comparison function that return true if ' AB ' is smaller than ' BA ' when we concatenate two numbers ' A ' and ' B ' For example , it will return true if we pass 12 and 24 as arguments . This function will be used by sort ( ) function","code":"def compare ( num1 , num2 ) : NEW_LINE"}
{"text":"Convert first number to string format","code":"A = str ( num1 ) NEW_LINE"}
{"text":"Convert second number to string format","code":"B = str ( num2 ) NEW_LINE"}
{"text":"Check if ' AB ' is smaller or ' BA ' and return bool value since comparison operator ' < = ' returns true or false","code":"return int ( A + B ) <= int ( B + A ) NEW_LINE"}
{"text":"Function to print the arrangement with the smallest value","code":"def printSmallest ( N , arr ) : NEW_LINE"}
{"text":"If we pass the name of the comparison function it will sort the array according to the compare function","code":"sort ( arr ) NEW_LINE"}
{"text":"Print the sorted array","code":"printArr ( arr , N ) NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 2 , 9 , 21 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printSmallest ( N , arr ) NEW_LINE DEDENT"}
{"text":"Python3 program for modifying Selection Sort so that it becomes stable .","code":"def stableSelectionSort ( a , n ) : NEW_LINE"}
{"text":"Traverse through all array elements","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Find the minimum element in remaining unsorted array","code":"min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ min_idx ] > a [ j ] : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT"}
{"text":"Move minimum element at current i","code":"key = a [ min_idx ] NEW_LINE while min_idx > i : NEW_LINE INDENT a [ min_idx ] = a [ min_idx - 1 ] NEW_LINE min_idx -= 1 NEW_LINE DEDENT a [ i ] = key NEW_LINE def printArray ( a , n ) : NEW_LINE for i in range ( n ) : NEW_LINE print ( \" % d \" % a [ i ] , end = \" \u2581 \" ) NEW_LINE"}
{"text":"Driver Code","code":"a = [ 4 , 5 , 3 , 2 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE stableSelectionSort ( a , n ) NEW_LINE printArray ( a , n ) NEW_LINE"}
{"text":"Check whether any permutation exists which satisfy the condition .","code":"def isPossible ( a , b , n , k ) : NEW_LINE"}
{"text":"Sort the array a [ ] in decreasing order .","code":"a . sort ( reverse = True ) NEW_LINE"}
{"text":"Sort the array b [ ] in increasing order .","code":"b . sort ( ) NEW_LINE"}
{"text":"Checking condition on each index .","code":"for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE"}
{"text":"Driver code","code":"a = [ 2 , 1 , 3 ] NEW_LINE b = [ 7 , 8 , 9 ] NEW_LINE k = 10 NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , b , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text":"Function to count setbits","code":"def setBitCount ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT num = num >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT"}
{"text":"Function to sort By SetBitCount","code":"def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT count = [ ] NEW_LINE DEDENT"}
{"text":"Iterate over all values and insert into multimap","code":"for i in range ( n ) : NEW_LINE INDENT count . append ( [ ( - 1 ) * setBitCount ( arr [ i ] ) , arr [ i ] ] ) NEW_LINE DEDENT count . sort ( key = lambda x : x [ 0 ] ) NEW_LINE for i in range ( len ( count ) ) : NEW_LINE INDENT print ( count [ i ] [ 1 ] , end = \" \u2581 \" ) NEW_LINE DEDENT"}
{"text":"Driver Code","code":"arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE"}
{"text":"Function to check if it is possible to reach the end of the binary string using the given jumps","code":"def canReach ( s , L , R ) : NEW_LINE"}
{"text":"Stores the DP states","code":"dp = [ 0 for _ in range ( len ( s ) ) ] NEW_LINE"}
{"text":"Initial state","code":"dp [ 0 ] = 1 NEW_LINE"}
{"text":"Stores count of indices from which it is possible to reach index i","code":"pre = 0 NEW_LINE"}
{"text":"Traverse the given string","code":"for i in range ( 1 , len ( s ) ) : NEW_LINE"}
{"text":"Update the values of pre accordingly","code":"if ( i >= L ) : NEW_LINE INDENT pre += dp [ i - L ] NEW_LINE DEDENT"}
{"text":"If the jump size is out of the range [ L , R ]","code":"if ( i > R ) : NEW_LINE INDENT pre -= dp [ i - R - 1 ] NEW_LINE DEDENT dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) NEW_LINE"}
{"text":"Return answer","code":"return dp [ len ( s ) - 1 ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"01101110\" NEW_LINE L = 2 NEW_LINE R = 3 NEW_LINE if canReach ( S , L , R ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text":"Recursive function to find all the possible breaking of arrays o subarrays and find the maximum Bitwise XOR","code":"def maxXORUtil ( arr , N , xrr , orr ) : NEW_LINE"}
{"text":"If the value of N is 0","code":"if ( N == 0 ) : NEW_LINE INDENT return xrr ^ orr NEW_LINE DEDENT"}
{"text":"Stores the result if the new group is formed with the first element as arr [ i ]","code":"x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) NEW_LINE"}
{"text":"Stores if the result if the arr [ i ] is included in the last group","code":"y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) NEW_LINE"}
{"text":"Returns the maximum of x and y","code":"return max ( x , y ) NEW_LINE"}
{"text":"Function to find the maximum possible Bitwise XOR of all possible values of the array after breaking the arrays o subarrays","code":"def maximumXOR ( arr , N ) : NEW_LINE"}
{"text":"Return the result","code":"return maxXORUtil ( arr , N , 0 , 0 ) NEW_LINE"}
{"text":"Driver Code","code":"arr = 1 , 5 , 7 NEW_LINE N = len ( arr ) NEW_LINE print ( maximumXOR ( arr , N ) ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"N = 10 ** 5 + 5 NEW_LINE"}
{"text":"Keep track of visited nodes","code":"visited = [ 0 ] * N NEW_LINE"}
{"text":"Function to construct a tree such that there are no two adjacent nodes with the same weight","code":"def construct_tree ( weights , n ) : NEW_LINE INDENT minimum = min ( weights ) NEW_LINE maximum = max ( weights ) NEW_LINE DEDENT"}
{"text":"If minimum and maximum elements are equal , i . e . array contains one distinct element","code":"if ( minimum == maximum ) : NEW_LINE"}
{"text":"Tree cannot be constructed","code":"print ( \" No \" ) NEW_LINE return NEW_LINE"}
{"text":"Otherwise","code":"else : NEW_LINE"}
{"text":"Tree can be constructed","code":"print ( \" Yes \" ) NEW_LINE"}
{"text":"Choose weights [ 0 ] as root","code":"root = weights [ 0 ] NEW_LINE"}
{"text":"First Node is visited","code":"visited [ 1 ] = 1 NEW_LINE"}
{"text":"Traverse the array","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Otherwise , make an edge","code":"if ( weights [ i ] != root and visited [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( 1 , i + 1 ) NEW_LINE DEDENT"}
{"text":"Mark this node as visited","code":"visited [ i + 1 ] = 1 NEW_LINE"}
{"text":"Find a weight not same as the root & make edges with that node","code":"notroot = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( weights [ i ] != root ) : NEW_LINE INDENT notroot = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT"}
{"text":"Join non - roots with remaining nodes","code":"for i in range ( n ) : NEW_LINE"}
{"text":"Check if current node ' s \u2581 weight \u2581 \u2581 is \u2581 same \u2581 as \u2581 root \u2581 node ' s weight and if it is not visited or not","code":"if ( weights [ i ] == root and visited [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( notroot , i + 1 ) NEW_LINE visited [ i + 1 ] = 1 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT weights = [ 1 , 2 , 1 , 2 , 5 ] NEW_LINE N = len ( weights ) NEW_LINE DEDENT"}
{"text":"Function Call","code":"construct_tree ( weights , N ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"import sys NEW_LINE"}
{"text":"Function to find minimum cost to convert given string into string of K length same substring","code":"def minCost ( s , k ) : NEW_LINE"}
{"text":"Stores length of string","code":"n = len ( s ) NEW_LINE"}
{"text":"Stores the minimum cost","code":"ans = 0 NEW_LINE"}
{"text":"Traverse left substring of k length","code":"for i in range ( k ) : NEW_LINE"}
{"text":"Stores the frequency","code":"a = [ 0 ] * 26 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT a [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT"}
{"text":"Stores minimum cost for sequence of S [ i ] % k indices","code":"min_cost = sys . maxsize - 1 NEW_LINE"}
{"text":"Check for optimal character","code":"for ch in range ( 26 ) : NEW_LINE INDENT cost = 0 NEW_LINE DEDENT"}
{"text":"Find sum of distance ' a ' + ch from character S [ i ] % k indices","code":"for tr in range ( 26 ) : NEW_LINE INDENT cost += abs ( ch - tr ) * a [ tr ] NEW_LINE DEDENT"}
{"text":"Choose minimum cost for each index i","code":"min_cost = min ( min_cost , cost ) NEW_LINE"}
{"text":"Increment ans","code":"ans += min_cost NEW_LINE"}
{"text":"Print minimum cost to convert string","code":"print ( ans ) NEW_LINE"}
{"text":"Given string S","code":"S = \" abcdefabc \" NEW_LINE K = 3 NEW_LINE"}
{"text":"Function call","code":"minCost ( S , K ) NEW_LINE"}
{"text":"Function to split the first N natural numbers into two sets having minimum absolute difference of their sums","code":"def minAbsDiff ( N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT"}
{"text":"Driver Code","code":"N = 6 NEW_LINE print ( minAbsDiff ( N ) ) NEW_LINE"}
{"text":"Python3 program for the above approach","code":"N = 10000 NEW_LINE"}
{"text":"Adjacency list to store edges","code":"adj = { } NEW_LINE used = [ 0 for i in range ( N ) ] NEW_LINE max_matching = 0 NEW_LINE"}
{"text":"Add an edge between U and V in tree","code":"def AddEdge ( u , v ) : NEW_LINE INDENT if u not in adj : NEW_LINE INDENT adj [ u ] = [ ] NEW_LINE DEDENT if v not in adj : NEW_LINE INDENT adj [ v ] = [ ] NEW_LINE DEDENT DEDENT"}
{"text":"Edge from u to v","code":"adj [ u ] . append ( v ) NEW_LINE"}
{"text":"Edge from V to U","code":"adj [ v ] . append ( u ) NEW_LINE"}
{"text":"Function that finds the maximum matching of the DFS","code":"def Matching_dfs ( u , p ) : NEW_LINE INDENT global max_matching NEW_LINE for i in range ( len ( adj [ u ] ) ) : NEW_LINE DEDENT"}
{"text":"Go further as we are not allowed to go towards its parent","code":"if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT Matching_dfs ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT"}
{"text":"If U and its parent P is not taken then we must take & mark them as taken","code":"if ( not used [ u ] and not used [ p ] and p != 0 ) : NEW_LINE"}
{"text":"Increment size of edge set","code":"max_matching += 1 NEW_LINE used [ u ] = 1 NEW_LINE used [ p ] = 1 NEW_LINE"}
{"text":"Function to find the maximum matching in a graph","code":"def maxMatching ( ) : NEW_LINE"}
{"text":"Taking 1 as a root of the tree","code":"Matching_dfs ( 1 , 0 ) NEW_LINE"}
{"text":"Print maximum Matching","code":"print ( max_matching ) NEW_LINE"}
{"text":"Driver Code","code":"n = 5 NEW_LINE"}
{"text":"Joining edge between two nodes in tree","code":"AddEdge ( 1 , 2 ) NEW_LINE AddEdge ( 1 , 3 ) NEW_LINE AddEdge ( 3 , 4 ) NEW_LINE AddEdge ( 3 , 5 ) NEW_LINE"}
{"text":"Function Call","code":"maxMatching ( ) NEW_LINE"}
{"text":"Python3 program to implement the above approach","code":"import sys NEW_LINE"}
{"text":"Function to calculate and return the minimum cost required to swap two arrays","code":"def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT DEDENT"}
{"text":"Return the total minimum cost","code":"return mini * ( 2 * N - 1 ) NEW_LINE"}
{"text":"Driver Code","code":"N = 3 NEW_LINE A = [ 1 , 4 , 2 ] NEW_LINE B = [ 10 , 6 , 12 ] NEW_LINE print ( getMinCost ( A , B , N ) ) NEW_LINE"}
{"text":"Function to print the values stored in vector arr","code":"def printVector ( arr ) : NEW_LINE INDENT if ( len ( arr ) != 1 ) : NEW_LINE DEDENT"}
{"text":"Traverse the vector arr","code":"for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE"}
{"text":"Recursive function to prdifferent ways in which N can be written as a sum of at 2 or more positive integers","code":"def findWays ( arr , i , n ) : NEW_LINE"}
{"text":"If n is zero then prthis ways of breaking numbers","code":"if ( n == 0 ) : NEW_LINE INDENT printVector ( arr ) NEW_LINE DEDENT"}
{"text":"Start from previous element in the representation till n","code":"for j in range ( i , n + 1 ) : NEW_LINE"}
{"text":"Include current element from representation","code":"arr . append ( j ) NEW_LINE"}
{"text":"Call function again with reduced sum","code":"findWays ( arr , j , n - j ) NEW_LINE"}
{"text":"Backtrack to remove current element from representation","code":"del arr [ - 1 ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given sum N","code":"n = 4 NEW_LINE"}
{"text":"To store the representation of breaking N","code":"arr = [ ] NEW_LINE"}
{"text":"Function Call","code":"findWays ( arr , 1 , n ) NEW_LINE"}
{"text":"Function to count maximum subsequence","code":"def Maximum_subsequence ( A , N ) : NEW_LINE"}
{"text":"Stores the frequency of array elements","code":"frequency = dict ( ) ; NEW_LINE"}
{"text":"Stores max frequency","code":"max_freq = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"Update max subsequence","code":"if ( frequency [ it ] > max_freq ) : NEW_LINE INDENT max_freq = frequency [ it ] ; NEW_LINE DEDENT"}
{"text":"Print the count","code":"print ( max_freq ) ; NEW_LINE"}
{"text":"Driver Code","code":"arr = [ 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 ] ; NEW_LINE Maximum_subsequence ( arr , len ( arr ) ) ; NEW_LINE"}
{"text":"Function to print the arrangement of characters","code":"def DivideString ( s , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE no = 1 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE DEDENT"}
{"text":"Stores frequency of characters","code":"fr = [ 0 ] * 26 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE"}
{"text":"Count the character having frequency K","code":"if ( fr [ i ] == k ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT"}
{"text":"Count the character having frequency greater than K and not equal to 2 K","code":"if ( fr [ i ] > k and fr [ i ] != 2 * k ) : NEW_LINE INDENT c1 += 1 NEW_LINE ch = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT if ( fr [ i ] == 2 * k ) : NEW_LINE INDENT c2 += 1 NEW_LINE ch1 = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE ans . append ( \"1\" ) NEW_LINE mp = { } NEW_LINE if ( c % 2 == 0 or c1 > 0 or c2 > 0 ) : NEW_LINE for i in range ( n ) : NEW_LINE"}
{"text":"Case 1","code":"if ( fr [ ord ( s [ i ] ) - ord ( ' a ' ) ] == k ) : NEW_LINE INDENT if ( s [ i ] in mp ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE DEDENT else : NEW_LINE INDENT if ( no <= ( c \/\/ 2 ) ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE mp [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Case 2","code":"if ( c % 2 == 1 and c1 > 0 ) : NEW_LINE INDENT no = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ch and no <= k ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"text":"Case 3","code":"if ( c % 2 == 1 and c1 == 0 ) : NEW_LINE INDENT no = 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ch1 and no <= k ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE DEDENT if ( fr [ s [ i ] - ' a ' ] == k and flag == 0 and ans [ i ] == '1' ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" \" . join ( ans ) ) NEW_LINE else : NEW_LINE"}
{"text":"If all cases fail","code":"print ( \" NO \" ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abbbccc \" NEW_LINE N = len ( S ) NEW_LINE K = 1 NEW_LINE DivideString ( S , N , K ) NEW_LINE DEDENT"}
{"text":"Function to check if two items can be selected from two different categories without exceeding the total price","code":"def check ( S , prices , type1 , n ) : NEW_LINE"}
{"text":"Loop to choose two different pairs using two nested loops","code":"for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE DEDENT"}
{"text":"Condition to check if the price of these two elements is less than S","code":"if ( ( type1 [ j ] == 0 and type1 [ k ] == 1 ) or ( type1 [ j ] == 1 and type1 [ k ] == 0 ) ) : NEW_LINE INDENT if ( prices [ j ] + prices [ k ] <= S ) : NEW_LINE INDENT return \" Yes \" ; NEW_LINE DEDENT DEDENT return \" No \" ; NEW_LINE"}
{"text":"Driver Code","code":"prices = [ 3 , 8 , 6 , 5 ] ; NEW_LINE type1 = [ 0 , 1 , 1 , 0 ] ; NEW_LINE S = 10 ; NEW_LINE n = 4 ; NEW_LINE"}
{"text":"Function Call","code":"print ( check ( S , prices , type1 , n ) ) ; NEW_LINE"}
{"text":"Function to return the maximum sum of a + b satisfying the given condition","code":"def getLargestSum ( N ) : NEW_LINE"}
{"text":"Consider all possible pairs and check the sum divides product property","code":"for i in range ( 1 , int ( N ** ( 1 \/ 2 ) ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( N ** ( 1 \/ 2 ) ) + 1 ) : NEW_LINE DEDENT"}
{"text":"To find the largest factor k","code":"k = N \/\/ j ; NEW_LINE a = k * i ; NEW_LINE b = k * j ; NEW_LINE"}
{"text":"Check if the product is divisible by the sum","code":"if ( a <= N and b <= N and a * b % ( a + b ) == 0 ) : NEW_LINE"}
{"text":"Storing the maximum sum in the max_sum variable","code":"max_sum = max ( max_sum , a + b ) ; NEW_LINE"}
{"text":"Return the max_sum value","code":"return max_sum ; NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 25 ; NEW_LINE max_sum = getLargestSum ( N ) ; NEW_LINE print ( max_sum ) ; NEW_LINE DEDENT"}
{"text":"Function to return the encrypted string","code":"def encryptString ( string , n ) : NEW_LINE INDENT i , cnt = 0 , 0 NEW_LINE encryptedStr = \" \" NEW_LINE while i < n : NEW_LINE DEDENT"}
{"text":"Number of times the current character will be repeated","code":"cnt = i + 1 NEW_LINE"}
{"text":"Repeat the current character in the encrypted string","code":"while cnt > 0 : NEW_LINE INDENT encryptedStr += string [ i ] NEW_LINE cnt -= 1 NEW_LINE DEDENT i += 1 NEW_LINE return encryptedStr NEW_LINE"}
{"text":"Driver code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" NEW_LINE n = len ( string ) NEW_LINE print ( encryptString ( string , n ) ) NEW_LINE DEDENT"}
{"text":"Function to return required minimum difference","code":"def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE DEDENT"}
{"text":"finding minimum and maximum values","code":"for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT"}
{"text":"returning minimum possible difference","code":"return max ( 0 , mx - mn - 2 * x ) NEW_LINE"}
{"text":"Driver program","code":"n = 3 NEW_LINE x = 3 NEW_LINE A = [ 1 , 3 , 6 ] NEW_LINE"}
{"text":"function to return the answer","code":"print ( minDiff ( n , x , A ) ) NEW_LINE"}
{"text":"Python3 program to count swaps required to balance string","code":"def swapCount ( s ) : NEW_LINE INDENT chars = s NEW_LINE DEDENT"}
{"text":"Stores total number of left and right brackets encountered","code":"countLeft = 0 NEW_LINE countRight = 0 NEW_LINE"}
{"text":"Swap stores the number of swaps required imbalance maintains the number of imbalance pair","code":"swap = 0 NEW_LINE imbalance = 0 ; NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT if chars [ i ] == ' [ ' : NEW_LINE DEDENT"}
{"text":"Increment count of left bracket","code":"countLeft += 1 NEW_LINE if imbalance > 0 : NEW_LINE"}
{"text":"Swaps count is last swap count + total number imbalanced brackets","code":"swap += imbalance NEW_LINE"}
{"text":"Imbalance decremented by 1 as it solved only one imbalance of left and right","code":"imbalance -= 1 NEW_LINE elif chars [ i ] == ' ] ' : NEW_LINE"}
{"text":"Increment count of right bracket","code":"countRight += 1 NEW_LINE"}
{"text":"Imbalance is reset to current difference between left and right brackets","code":"imbalance = ( countRight - countLeft ) NEW_LINE return swap NEW_LINE"}
{"text":"Driver code","code":"s = \" [ ] ] [ ] [ \" ; NEW_LINE print ( swapCount ( s ) ) NEW_LINE s = \" [ [ ] [ ] ] \" ; NEW_LINE print ( swapCount ( s ) ) NEW_LINE"}
{"text":"Function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing","code":"def longestSubSequence ( A , N ) : NEW_LINE"}
{"text":"dp [ i ] : Stores the longest subsequence upto i","code":"dp = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE"}
{"text":"Base case","code":"dp [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE"}
{"text":"When the conditions hold","code":"if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] and A [ j ] [ 1 ] > A [ i ] [ 1 ] ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT"}
{"text":"Finally , prthe required answer","code":"print ( dp [ N - 1 ] ) NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given Input","code":"A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE"}
{"text":"Function Call","code":"longestSubSequence ( A , N ) NEW_LINE"}
{"text":"Function to calculate the total number of ways to have sum N","code":"def findWays ( N , dp ) : NEW_LINE"}
{"text":"Base Case","code":"if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT"}
{"text":"Return already stored result","code":"if ( dp [ N ] != - 1 ) : NEW_LINE INDENT return dp [ N ] NEW_LINE DEDENT cnt = 0 NEW_LINE"}
{"text":"Recur for all 6 states","code":"for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = ( cnt + findWays ( N - i , dp ) ) NEW_LINE DEDENT DEDENT"}
{"text":"Return the result","code":"dp [ N ] = cnt NEW_LINE return dp [ N ] NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == \" _ _ main _ _ \" : NEW_LINE"}
{"text":"Given sum N","code":"N = 4 NEW_LINE"}
{"text":"Initialize the dp array","code":"dp = [ - 1 ] * ( N + 1 ) NEW_LINE"}
{"text":"Function Call","code":"print ( findWays ( N , dp ) ) NEW_LINE"}
{"text":"Function to calculate the total number of ways to have sum N","code":"def findWays ( N ) : NEW_LINE"}
{"text":"Initialize dp array","code":"dp = [ 0 ] * ( N + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE"}
{"text":"Iterate over all the possible intermediate values to reach N","code":"for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 ; NEW_LINE DEDENT"}
{"text":"Calculate the sum for all 6 faces","code":"for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] ; NEW_LINE DEDENT DEDENT"}
{"text":"Print total number of ways","code":"print ( dp [ N ] ) ; NEW_LINE"}
{"text":"Driver Code","code":"if __name__ == ' _ _ main _ _ ' : NEW_LINE"}
{"text":"Given sum N","code":"N = 4 ; NEW_LINE"}
{"text":"Function call","code":"findWays ( N ) ; NEW_LINE"}
{"text":"Python3 implementation to split the string into minimum number of parts such that each part is also present in the another string","code":"INF = 1e9 + 9 NEW_LINE"}
{"text":"Node of Trie","code":"class TrieNode ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . child = [ None ] * 26 NEW_LINE DEDENT DEDENT"}
{"text":"Function to insert a node in the Trie Data Structure","code":"def insert ( idx , s , root ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( idx , len ( s ) ) : NEW_LINE DEDENT"}
{"text":"Inserting every character from idx till end to string into trie","code":"if temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] == None : NEW_LINE"}
{"text":"If there is no edge corresponding to the ith character , then make a new node","code":"temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] = TrieNode ( ) NEW_LINE temp = temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] NEW_LINE"}
{"text":"Function to find the minimum number of parts such that each part is present into another string","code":"def minCuts ( S1 , S2 ) : NEW_LINE INDENT n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE DEDENT"}
{"text":"Making a new trie","code":"root = TrieNode ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE"}
{"text":"Inserting every substring of S2 in trie","code":"insert ( i , S2 , root ) NEW_LINE"}
{"text":"Creating dp array and init it with infinity","code":"dp = [ INF ] * ( n1 + 1 ) NEW_LINE"}
{"text":"Base Case","code":"dp [ 0 ] = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE"}
{"text":"Starting the cut from ith character taking temporary node pointer for checking whether the substring [ i , j ) is present in trie of not","code":"temp = root NEW_LINE for j in range ( i + 1 , n1 + 1 ) : NEW_LINE INDENT if temp . child [ ord ( S1 [ j - 1 ] ) - ord ( ' a ' ) ] == None : NEW_LINE DEDENT"}
{"text":"If the jth character is not in trie we 'll break","code":"break NEW_LINE"}
{"text":"Updating the the ending of jth character with dp [ i ] + 1","code":"dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) NEW_LINE"}
{"text":"Descending the trie pointer","code":"temp = temp . child [ ord ( S1 [ j - 1 ] ) - ord ( ' a ' ) ] NEW_LINE"}
{"text":"Answer not possible","code":"if dp [ n1 ] >= INF : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n1 ] NEW_LINE DEDENT"}
{"text":"Driver Code","code":"S1 = \" abcdab \" NEW_LINE S2 = \" dabc \" NEW_LINE print ( minCuts ( S1 , S2 ) ) NEW_LINE"}
{"text":"Function to find the largest square in the matrix such that it contains atmost K 1 's","code":"def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE DEDENT"}
{"text":"Precomputing the countDP prefix sum of the matrix","code":"countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT"}
{"text":"Loop to solve Queries","code":"for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE DEDENT"}
{"text":"Calculating the maximum possible distance of the centre from edge","code":"min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE l = 0 NEW_LINE u = min_dist NEW_LINE while ( l <= u ) : NEW_LINE INDENT mid = int ( ( l + u ) \/ 2 ) NEW_LINE x1 = i - mid NEW_LINE x2 = i + mid NEW_LINE y1 = j - mid NEW_LINE y2 = j + mid NEW_LINE DEDENT"}
{"text":"Count total number of 1 s in the sub square considered","code":"count = countDP [ x2 ] [ y2 ] NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT"}
{"text":"If the count is less than or equals to the maximum move to right half","code":"if ( count <= K ) : NEW_LINE INDENT ans = 2 * mid + 1 NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT u = mid - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"}
{"text":"Driver Code","code":"matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE"}
