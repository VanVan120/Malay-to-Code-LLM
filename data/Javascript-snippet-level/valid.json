{"text":"Function to convert centimeter to pixels","code":"function Conversion ( centi ) { let pixels = ( 96 * centi ) \/ 2.54 ; document . write ( pixels ) ; return 0 ; }"}
{"text":"Driver Code","code":"let centi = 15 ; Conversion ( centi )"}
{"text":"Method that returns the corresponding output by taking the given inputs .","code":"function xor_operations ( N , arr , M , K ) {"}
{"text":"If this condition is satisfied , value of M is invalid","code":"if ( M < 0 M >= N ) return - 1 ;"}
{"text":"Check if index K is valid","code":"if ( K < 0 K >= N - M ) return - 1 ;"}
{"text":"Loop to perform M operations","code":"for ( let p = 0 ; p < M ; p ++ ) {"}
{"text":"Creating a temporary list","code":"let temp = [ ] ;"}
{"text":"Traversing the array","code":"for ( let i = 0 ; i < N ; i ++ ) {"}
{"text":"Calculate XOR values of adjacent elements","code":"let value = arr [ i ] ^ arr [ i + 1 ] ;"}
{"text":"Adding this value to the temporary list","code":"temp . push ( value ) ;"}
{"text":"Update the original array","code":"arr [ i ] = temp [ i ] ; } }"}
{"text":"Getting value at index K","code":"let ans = arr [ K ] ; return ans ; }"}
{"text":"Number of elements","code":"let N = 5 ;"}
{"text":"Given array arr [ ]","code":"let arr = [ 1 , 4 , 5 , 6 , 7 ] ; let M = 1 , K = 2 ;"}
{"text":"Function call","code":"document . write ( xor_operations ( N , arr , M , K ) ) ;"}
{"text":"Function to find the K consecutive elements with a sum equal to N","code":"function canBreakN ( n ) {"}
{"text":"Iterate over [ 2 , INF ]","code":"for ( let i = 2 ; ; i ++ ) {"}
{"text":"Store the sum","code":"let m = parseInt ( i * ( i + 1 ) \/ 2 , 10 ) ;"}
{"text":"If the sum exceeds N then break the loop","code":"if ( m > n ) break ; let k = n - m ;"}
{"text":"Common difference should be divisible by number of terms","code":"if ( k % i != 0 ) continue ;"}
{"text":"Print value of i & return","code":"document . write ( i ) ; return ; }"}
{"text":"Print \" - 1\" if not possible to break N","code":"document . write ( \" \" ) ; }"}
{"text":"Given N","code":"let N = 12 ;"}
{"text":"Function call","code":"canBreakN ( N ) ;"}
{"text":"Function which finds the required pair of divisors of N","code":"function findCoprimePair ( N ) {"}
{"text":"We iterate upto sqrt ( N ) as we can find all the divisors of N in this time","code":"for ( let x = 2 ; x <= Math . sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) {"}
{"text":"If x is a divisor of N keep dividing as long as possible","code":"while ( N % x == 0 ) { N = Math . floor ( N \/ x ) ; } if ( N > 1 ) {"}
{"text":"We have found a required pair","code":"document . write ( x + \" \" + N + \" \" ) ; return ; } } }"}
{"text":"No such pair of divisors of N was found , hence print - 1","code":"document . write ( - 1 + \" \" ) ; }"}
{"text":"Sample example 1","code":"let N = 45 ; findCoprimePair ( N ) ;"}
{"text":"Sample example 2","code":"N = 25 ; findCoprimePair ( N ) ;"}
{"text":"Javascript implementation for the above approach","code":"let MAX = 10000 ;"}
{"text":"Array to store all prime less than and equal to MAX .","code":"let primes = [ ] ;"}
{"text":"Function for Sieve of Sundaram","code":"function sieveSundaram ( ) {"}
{"text":"Boolean Array","code":"let marked = Array . from ( { length : MAX \/ 2 + 1 } , ( _ , i ) => 0 ) ;"}
{"text":"Mark all numbers which do not generate prime number by 2 * i + 1","code":"for ( let i = 1 ; i <= Math . floor ( ( Math . sqrt ( MAX ) - 1 ) \/ 2 ) ; i ++ ) { for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= Math . floor ( MAX \/ 2 ) ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } }"}
{"text":"Since 2 is a prime number","code":"primes . push ( 2 ) ;"}
{"text":"Print remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for ( let i = 1 ; i <= Math . floor ( MAX \/ 2 ) ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; }"}
{"text":"Function that returns true if n is a Wasteful number","code":"function isWasteful ( n ) { if ( n == 1 ) return false ;"}
{"text":"Count digits in original number","code":"let original_no = n ; let sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = Math . floor ( original_no \/ 10 ) ; } let pDigit = 0 , count_exp = 0 , p = 0 ;"}
{"text":"Count all digits in prime factors of N pDigit is going to hold this value .","code":"for ( let i = 0 ; primes [ i ] <= Math . floor ( n \/ 2 ) ; i ++ ) {"}
{"text":"Count powers of p in n","code":"while ( n % primes [ i ] == 0 ) {"}
{"text":"If primes [ i ] is a prime factor ,","code":"p = primes [ i ] ; n = Math . floor ( n \/ p ) ;"}
{"text":"Count the power of prime factors","code":"count_exp ++ ; }"}
{"text":"Add its digits to pDigit","code":"while ( p > 0 ) { pDigit ++ ; p = Math . floor ( p \/ 10 ) ; }"}
{"text":"Add digits of power of prime factors to pDigit .","code":"while ( count_exp > 1 ) { pDigit ++ ; count_exp = Math . floor ( count_exp \/ 10 ) ; } }"}
{"text":"If n != 1 then one prime factor still to be summed up","code":"if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = Math . floor ( n \/ 10 ) ; } }"}
{"text":"If digits in prime factors is more than digits in original number then return true . Else return false .","code":"return ( pDigit > sumDigits ) ; }"}
{"text":"Function to print Wasteful Number before N","code":"function Solve ( N ) {"}
{"text":"Iterate till N and check if i is wastefull or not","code":"for ( let i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { document . write ( i + \" \" ) ; } } }"}
{"text":"Precompute prime numbers upto 10 ^ 6","code":"sieveSundaram ( ) ; let N = 10 ;"}
{"text":"Function Call","code":"Solve ( N ) ;"}
{"text":"Function to print the Nth Hexanacci number","code":"function printhexaRec ( n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; } function printhexa ( n ) { document . write ( printhexaRec ( n ) + \" \" ) ; }"}
{"text":"Driver code","code":"let n = 11 ; printhexa ( n ) ;"}
{"text":"Function to print the Nth term of the Hexanacci number","code":"function printhexa ( n ) { if ( n < 0 ) return ;"}
{"text":"Initialize first five numbers to base cases","code":"let first = 0 ; let second = 0 ; let third = 0 ; let fourth = 0 ; let fifth = 0 ; let sixth = 1 ;"}
{"text":"Declare a current variable","code":"let curr = 0 ; if ( n < 6 ) document . write ( first ) ; else if ( n == 6 ) document . write ( sixth ) ; else {"}
{"text":"Loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth fifth to second , third , fourth , fifth and curr to sixth respectively","code":"for ( let i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } document . write ( curr ) ; }"}
{"text":"Driver code","code":"let n = 11 ; printhexa ( n ) ;"}
{"text":"Function to find the smallest number whose sum of digits is also N","code":"function smallestNumber ( N ) { document . write ( ( N % 9 + 1 ) * Math . pow ( 10 , parseInt ( N \/ 9 , 10 ) ) - 1 ) ; }"}
{"text":"Driver code","code":"let N = 10 ; smallestNumber ( N ) ;"}
{"text":"Javascript program to find compositorial of composite numbers","code":"let compo = [ ] ;"}
{"text":"Function to check if a number is composite .","code":"function isComposite ( n ) {"}
{"text":"Corner cases","code":"if ( n <= 3 ) return false ;"}
{"text":"This is checked so that we can skip the middle five numbers in the below loop","code":"if ( n % 2 == 0 n % 3 == 0 ) return true ; let i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; }"}
{"text":"This function stores all composite numbers less than N","code":"function Compositorial_list ( n ) { let l = 0 ; for ( let i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . push ( i ) ; l += 1 ; } } } }"}
{"text":"Function to calculate the compositorial of n","code":"function calculateCompositorial ( n ) {"}
{"text":"Multiply first n composite number","code":"let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; }"}
{"text":"Driver code","code":"let n = 5 ;"}
{"text":"Vector to store all the composite less than N","code":"Compositorial_list ( n ) ; document . write ( calculateCompositorial ( n ) ) ;"}
{"text":"Initializing the PowerArray with all 0 's","code":"let b = new Array ( 50 ) ; b . fill ( 0 ) ;"}
{"text":"Function to find the powers of N that add up to K","code":"function PowerArray ( n , k ) {"}
{"text":"Initializing the counter","code":"let count = 0 ;"}
{"text":"Executing the while loop until K is greater than 0","code":"while ( k > 0 ) { if ( k % n == 0 ) { k = parseInt ( k \/ n , 10 ) ; count ++ ; }"}
{"text":"If K % N == 1 , then the power array is incremented by 1","code":"else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ;"}
{"text":"Checking if any power is occurred more than once","code":"if ( b [ count ] > 1 ) { document . write ( - 1 ) ; return 0 ; } }"}
{"text":"For any other value , the sum of powers cannot be added up to K","code":"else { document . write ( - 1 ) ; return 0 ; } }"}
{"text":"Printing the powers of N that sum up to K","code":"for ( let i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { document . write ( i + \" \" ) ; } } return Number . MIN_VALUE ; }"}
{"text":"Driver code","code":"let N = 3 ; let K = 40 ; PowerArray ( N , K ) ;"}
{"text":"Function to find value of 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K","code":"function findSum ( N , k ) {"}
{"text":"Initialise sum to 0","code":"let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) {"}
{"text":"Find the value of pow ( i , 4 ) and then add it to the sum","code":"sum += Math . pow ( i , k ) ; }"}
{"text":"Return the sum","code":"return sum ; }"}
{"text":"Drivers Code","code":"let N = 8 , k = 4 ;"}
{"text":"Function call to find the sum","code":"document . write ( findSum ( N , k ) ) ;"}
{"text":"Function to return the count of indices that satisfy the given condition","code":"function countIndices ( arr , n ) {"}
{"text":"To store the result","code":"var cnt = 0 ;"}
{"text":"To store the current maximum Initialized to 0 since there are only positive elements in the array","code":"var max = 0 ; for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"i is a valid index","code":"if ( max < arr [ i ] ) {"}
{"text":"Update the maximum so far","code":"max = arr [ i ] ;"}
{"text":"Increment the counter","code":"cnt ++ ; } } return cnt ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 2 , 3 , 4 ] ; var n = arr . length ; document . write ( countIndices ( arr , n ) ) ;"}
{"text":"Binary representation of the digits","code":"bin = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ;"}
{"text":"Function to return the maximum frequency of s modulo with a power of 2","code":"function maxFreq ( s ) {"}
{"text":"Store the binary representation","code":"var binary = \" \" ;"}
{"text":"Convert the octal to binary","code":"for ( var i = 0 ; i < s . length ; i ++ ) { binary += bin [ s . charAt ( i ) - ' ' ] ; }"}
{"text":"Remove the LSB","code":"binary = binary . substr ( 0 , binary . length - 1 ) ; var count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length - 1 ; i >= 0 ; i -- , j ++ )"}
{"text":"If there is 1 in the binary representation","code":"if ( binary . charAt ( i ) == ' ' ) {"}
{"text":"Find the number of zeroes in between two 1 's in the binary representation","code":"count = Math . max ( count , j - prev ) ; prev = j ; } return count ; }"}
{"text":"Driver code","code":"var octal = \" \" ; document . write ( maxFreq ( octal ) ) ;"}
{"text":"Javascript implementation of the approach","code":"let sz = 100000 ; let isPrime = new Array ( sz + 1 ) ; isPrime . fill ( false ) ;"}
{"text":"Function for Sieve of Eratosthenes","code":"function sieve ( ) { for ( let i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( let j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }"}
{"text":"Function to print all the prime numbers with d digits","code":"function findPrimesD ( d ) {"}
{"text":"Range to check integers","code":"let left = Math . pow ( 10 , d - 1 ) ; let right = Math . pow ( 10 , d ) - 1 ;"}
{"text":"For every integer in the range","code":"for ( let i = left ; i <= right ; i ++ ) {"}
{"text":"If the current integer is prime","code":"if ( isPrime [ i ] ) { document . write ( i + \" \" ) ; } } }"}
{"text":"Generate primes","code":"sieve ( ) ; let d = 1 ; findPrimesD ( d ) ;"}
{"text":"Function to find number of cells in the table contains X","code":"function Cells ( n , x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; var i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }"}
{"text":"Driver Code","code":"var n = 6 , x = 12 ;"}
{"text":"Function call","code":"document . write ( Cells ( n , x ) ) ;"}
{"text":"Function to find the maximum possible value of the minimum value of the modified array","code":"function maxOfMin ( a , n , S ) {"}
{"text":"To store minimum value of array","code":"let mi = Number . MAX_VALUE ;"}
{"text":"To store sum of elements of array","code":"let s1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . min ( a [ i ] , mi ) ; }"}
{"text":"Solution is not possible","code":"if ( s1 < S ) return - 1 ;"}
{"text":"zero is the possible value","code":"if ( s1 == S ) return 0 ;"}
{"text":"minimum possible value","code":"let low = 0 ;"}
{"text":"maximum possible value","code":"let high = mi ;"}
{"text":"to store a required answer","code":"let ans = 0 ;"}
{"text":"Binary Search","code":"while ( low <= high ) { let mid = parseInt ( ( low + high ) \/ 2 , 10 ) ;"}
{"text":"If mid is possible then try to increase required answer","code":"if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; }"}
{"text":"If mid is not possible then decrease required answer","code":"else high = mid - 1 ; }"}
{"text":"Return required answer","code":"return ans ; }"}
{"text":"Driver Code","code":"let a = [ 10 , 10 , 10 , 10 , 10 ] ; let S = 10 ; let n = a . length ; document . write ( maxOfMin ( a , n , S ) ) ;"}
{"text":"Function to print the desired Alphabet N Pattern","code":"function Alphabet_N_Pattern ( N ) { var index , side_index , size ;"}
{"text":"Declaring the values of Right , Left and Diagonal values","code":"var Right = 1 , Left = 1 , Diagonal = 2 ;"}
{"text":"Main Loop for the rows","code":"for ( index = 0 ; index < N ; index ++ ) {"}
{"text":"For the left Values","code":"document . write ( Left ++ ) ;"}
{"text":"Spaces for the diagonals","code":"for ( side_index = 0 ; side_index < 2 * index ; side_index ++ ) document . write ( \" \" ) ;"}
{"text":"Condition for the diagonals","code":"if ( index != 0 && index != N - 1 ) document . write ( Diagonal ++ ) ; else document . write ( \" \" ) ;"}
{"text":"Spaces for the Right Values","code":"for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) document . write ( \" \" ) ;"}
{"text":"For the right values","code":"document . write ( Right ++ ) ; document . write ( \" \" ) ; } }"}
{"text":"Size of the Pattern","code":"var Size = 6 ;"}
{"text":"Calling the function to print the desired Pattern","code":"Alphabet_N_Pattern ( Size ) ;"}
{"text":"Function to check if sum of digits of a number divides it","code":"function isSumDivides ( N ) { var temp = N ; var sum = 0 ;"}
{"text":"Calculate sum of all of digits of N","code":"while ( temp > 0 ) { sum += temp % 10 ; temp = parseInt ( temp \/ 10 ) ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }"}
{"text":"Driver Code","code":"var N = 12 ; if ( isSumDivides ( N ) == 1 ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to calculate the sum of numbers divisible by 3 or 4","code":"function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( N \/ 3 ) ) * ( 2 * 3 + ( N \/ 3 - 1 ) * 3 ) \/ 2 ; S2 = ( ( N \/ 4 ) ) * ( 2 * 4 + ( N \/ 4 - 1 ) * 4 ) \/ 2 ; S3 = ( ( N \/ 12 ) ) * ( 2 * 12 + ( N \/ 12 - 1 ) * 12 ) \/ 2 ; return S1 + S2 - S3 ; }"}
{"text":"Driver code","code":"var N = 20 ; document . write ( sum ( 12 ) ) ;"}
{"text":"Function to find next greater number than N with exactly one bit different in binary representation of N","code":"function nextGreater ( N ) { var power_of_2 = 1 , shift_count = 0 ;"}
{"text":"It is guaranteed that there is a bit zero in the number","code":"while ( true ) {"}
{"text":"If the shifted bit is zero then break","code":"if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ;"}
{"text":"increase the bit shift","code":"shift_count ++ ;"}
{"text":"increase the power of 2","code":"power_of_2 = power_of_2 * 2 ; }"}
{"text":"set the lowest bit of the number","code":"return ( N + power_of_2 ) ; }"}
{"text":"Driver code","code":"var N = 11 ;"}
{"text":"display the next number","code":"document . write ( \" \" + nextGreater ( N ) ) ;"}
{"text":"Function to return the count of the total number of ways to cover the distance with 1 , 2 and 3 steps","code":"function countWays ( n ) {"}
{"text":"Base conditions","code":"if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ;"}
{"text":"To store the last three stages","code":"let f0 = 1 , f1 = 1 , f2 = 2 ; let ans = 0 ;"}
{"text":"Find the numbers of steps required to reach the distance i","code":"for ( let i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; }"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"let n = 4 ; document . write ( countWays ( n ) ) ;"}
{"text":"Javascript program for the above approach","code":"const n = 6 , m = 6 ;"}
{"text":"Function to find the maximum value","code":"function maxSum ( arr ) {"}
{"text":"Dp table","code":"const dp = new Array ( n + 1 ) . fill ( 0 ) . map ( ( ) => new Array ( 3 ) . fill ( 0 ) ) ;"}
{"text":"Fill the dp in bottom up manner","code":"for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"Maximum of the three sections","code":"var m1 = 0 , m2 = 0 , m3 = 0 ; for ( var j = 0 ; j < m ; j ++ ) {"}
{"text":"Maximum of the first section","code":"if ( parseInt ( j \/ ( m \/ 3 ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; }"}
{"text":"Maximum of the second section","code":"else if ( parseInt ( j \/ ( m \/ 3 ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; }"}
{"text":"Maximum of the third section","code":"else if ( parseInt ( j \/ ( m \/ 3 ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } }"}
{"text":"If we choose element from section 1 , we cannot have selection from same section in adjacent rows","code":"dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; }"}
{"text":"Print the maximum sum","code":"document . write ( parseInt ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) + \" \" ) ; }"}
{"text":"Driver code","code":"arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ; maxSum ( arr ) ;"}
{"text":"Function to find the total palindromic odd length sub - sequences","code":"function solve ( s ) { n = s . length ;"}
{"text":"dp array to store the number of palindromic subsequences for 0 to i - 1 and j + 1 to n - 1","code":"let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = 0 ; }"}
{"text":"We will start with the largest distance between i and j","code":"for ( let len = n - 1 ; len >= 0 ; -- len ) {"}
{"text":"For each len , we fix our i","code":"for ( let i = 0 ; i + len < n ; ++ i ) {"}
{"text":"For this i we will find our j","code":"let j = i + len ;"}
{"text":"Base cases","code":"if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) {"}
{"text":"If the characters are equal then look for out of bound index","code":"if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) {"}
{"text":"We have only 1 way that is to just pick these characters","code":"dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) {"}
{"text":"If the characters are not equal","code":"if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) {"}
{"text":"Subtract it as we have counted it twice","code":"dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } let ways = [ ] ; for ( let i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) {"}
{"text":"We have just 1 palindrome sequence of length 1","code":"ways . push ( 1 ) ; } else {"}
{"text":"Else total ways would be sum of dp [ i - 1 ] [ i + 1 ] , that is number of palindrome sub - sequences from 1 to i - 1 + number of palindrome sub - sequences from i + 1 to n - 1","code":"let total = dp [ i - 1 ] [ i + 1 ] ; ways . push ( total ) ; } } for ( let i = 0 ; i < ways . length ; ++ i ) { document . write ( ways [ i ] + \" \" ) ; } }"}
{"text":"Driver code","code":"let s = \" \" . split ( \" \" ) ; solve ( s ) ;"}
{"text":"Function to return the number of chicks on the nth day","code":"function getChicks ( n ) {"}
{"text":"Size of dp [ ] has to be at least 6 ( 1 - based indexing )","code":"let size = Math . max ( n , 7 ) ; let dp = new Array ( size ) ; dp . fill ( 0 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ;"}
{"text":"Every day current population will be three times of the previous day","code":"for ( let i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; }"}
{"text":"Manually calculated value","code":"dp [ 6 ] = 726 ;"}
{"text":"From 8 th day onwards","code":"for ( let i = 8 ; i <= n ; i ++ ) {"}
{"text":"Chick population decreases by 2 \/ 3 everyday . For 8 th day on [ i - 6 ] i . e 2 nd day population was 3 and so 2 new born die on the 6 th day and so on for the upcoming days","code":"dp [ i ] = ( dp [ i - 1 ] - ( 2 * parseInt ( dp [ i - 6 ] \/ 3 , 10 ) ) ) * 3 ; } return dp [ n ] ; }"}
{"text":"Driver code","code":"let n = 3 ; document . write ( getChicks ( n ) ) ;"}
{"text":"Function to return the number of chicks on the nth day","code":"function getChicks ( n ) { let chicks = Math . pow ( 3 , n - 1 ) ; return chicks ; }"}
{"text":"Driver code","code":"let n = 3 ; document . write ( getChicks ( n ) ) ;"}
{"text":"Javascript implementation of the approach","code":"let n = 3 ;"}
{"text":"2d array to store states of dp","code":"let dp = new Array ( n ) ;"}
{"text":"Array to determine whether a state has been solved before","code":"let v = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; v [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; v [ i ] [ j ] = 0 ; } }"}
{"text":"Function to return the minimum steps required","code":"function minSteps ( i , j , arr ) {"}
{"text":"Base cases","code":"if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; }"}
{"text":"If a state has been solved before it won 't be evaluated again","code":"if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ;"}
{"text":"Recurrence relation","code":"for ( let k = Math . max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= Math . min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; }"}
{"text":"Driver code","code":"let arr = [ [ 4 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 2 , 1 , 1 ] ] ; let ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { document . write ( - 1 ) ; } else { document . write ( ans ) ; }"}
{"text":"Javascript program to implement above approach","code":"let n = 3 ;"}
{"text":"2d array to store states of dp","code":"let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; }"}
{"text":"array to determine whether a state has been solved before","code":"let v = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { v [ i ] = new Array ( n ) ; }"}
{"text":"Function to find the minimum number of steps to reach the end of matrix","code":"function minSteps ( i , j , arr ) {"}
{"text":"base cases","code":"if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; }"}
{"text":"if a state has been solved before it won 't be evaluated again.","code":"if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ;"}
{"text":"recurrence relation","code":"dp [ i ] [ j ] = 1 + Math . min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; }"}
{"text":"Driver Code","code":"let arr = [ [ 2 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; let ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { document . write ( - 1 ) ; } else { document . write ( ans ) ; }"}
{"text":"A memoization based program to find maximum treasure that can be collected .","code":"let MAX = 1001 ; let dp = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = - 1 ; }"}
{"text":"k is current index and col is previous color .","code":"function MaxProfit ( treasure , color , n , k , col , A , B ) {"}
{"text":"if ( k == n ) base case","code":"return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; let sum = 0 ;"}
{"text":"check if color of this city is equal to prev visited city","code":"if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ;"}
{"text":"return max of both options","code":"return dp [ k ] [ col ] = sum ; }"}
{"text":"Driver code","code":"let A = - 5 , B = 7 ; let treasure = [ 4 , 8 , 2 , 9 ] ; let color = [ 2 , 2 , 6 , 2 ] ; let n = color . length ; document . write ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ;"}
{"text":"Function to print the N - th tetranacci number","code":"function printTetra ( n ) { let dp = new Array ( n + 5 ) ;"}
{"text":"base cases","code":"dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( let i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; document . write ( dp [ n ] ) ; }"}
{"text":"Driver code","code":"let n = 10 ; printTetra ( n ) ;"}
{"text":"Function to calculate the sum from 0 th position to ( n - 2 ) th position","code":"function maxSum1 ( arr , n ) { let dp = new Array ( n ) ; let maxi = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"copy the element of original array to dp [ ]","code":"dp [ i ] = arr [ i ] ;"}
{"text":"find the maximum element in the array","code":"if ( maxi < arr [ i ] ) maxi = arr [ i ] ; }"}
{"text":"start from 2 nd to n - 1 th pos","code":"for ( i = 2 ; i < n - 1 ; i ++ ) {"}
{"text":"traverse for all pairs bottom - up approach","code":"for ( j = 0 ; j < i - 1 ; j ++ ) {"}
{"text":"dp - condition","code":"if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ;"}
{"text":"find maximum sum","code":"if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } }"}
{"text":"return the maximum","code":"return maxi ; }"}
{"text":"Function to find the maximum sum from 1 st position to n - 1 - th position","code":"function maxSum2 ( arr , n ) { let dp = new Array ( n ) ; let maxi = 0 ; for ( i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; }"}
{"text":"Traverse from third to n - th pos","code":"for ( i = 3 ; i < n ; i ++ ) {"}
{"text":"bootom - up approach","code":"for ( j = 1 ; j < i - 1 ; j ++ ) {"}
{"text":"dp condition","code":"if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ;"}
{"text":"find max sum","code":"if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } }"}
{"text":"return max","code":"return maxi ; } function findMaxSum ( arr , n ) { let t = Math . max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; }"}
{"text":"Driver Code","code":"let arr = [ 1 , 2 , 3 , 1 ] ; let n = arr . length ; document . write ( findMaxSum ( arr , n ) ) ;"}
{"text":"Returns value of Permutation Coefficient P ( n , k )","code":"function permutationCoeff ( n , k ) { let P = new Array ( n + 2 ) ; for ( let i = 0 ; i < n + 2 ; i ++ ) { P [ i ] = new Array ( k + 2 ) ; }"}
{"text":"Calculate value of Permutation Coefficient in bottom up manner","code":"for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= Math . min ( i , k ) ; j ++ ) {"}
{"text":"Base Cases","code":"if ( j == 0 ) P [ i ] [ j ] = 1 ;"}
{"text":"Calculate value using previosly stored values","code":"else P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) ;"}
{"text":"This step is important as P ( i , j ) = 0 for j > i","code":"P [ i ] [ j + 1 ] = 0 ; } } return P [ n ] [ k ] ; }"}
{"text":"Driver Code","code":"let n = 10 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + \" \" + permutationCoeff ( n , k ) ) ;"}
{"text":"Returns value of Permutation Coefficient P ( n , k )","code":"function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ;"}
{"text":"base case","code":"fact [ 0 ] = 1 ;"}
{"text":"Calculate value factorials up to n","code":"for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ;"}
{"text":"P ( n , k ) = n ! \/ ( n - k ) !","code":"return parseInt ( fact [ n ] \/ fact [ n - k ] , 10 ) ; }"}
{"text":"Driver Code","code":"let n = 10 , k = 2 ; document . write ( \" \" + \" \" + n + \" \" + k + \" \" + permutationCoeff ( n , k ) ) ;"}
{"text":"Returns true if there is a subset of set [ ] with sum equal to given sum","code":"function isSubsetSum ( set , n , sum ) {"}
{"text":"Base Cases","code":"if ( sum == 0 ) return true ; if ( n == 0 ) return false ;"}
{"text":"If last element is greater than sum , then ignore it","code":"if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ;"}
{"text":"else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element","code":"return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }"}
{"text":"Driver Code","code":"let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Implementation of Z - algorithm for linear time pattern searching","code":"function compute_z ( s , z ) { var l = 0 , r = 0 ; var n = s . length ; for ( var i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s [ r - l ] === s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } else { var k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] === s [ r ] ) { r ++ ; } z [ i ] = r - l ; r -- ; } } } }"}
{"text":"Function to get the count of the cyclic permutations of b that given 0 when XORed with a","code":"function countPermutation ( a , b ) {"}
{"text":"concatenate b with b","code":"b = b + b ;"}
{"text":"new b now contains all the cyclic permutations of old b as it 's sub-strings","code":"b = b . substring ( 0 , b . length - 1 ) ;"}
{"text":"concatenate pattern with text","code":"var ans = 0 ; var s = a + \" \" + b ; var n = s . length ;"}
{"text":"Fill z array used in Z algorithm","code":"var z = new Array ( n ) . fill ( 0 ) ; compute_z ( s , z ) ; for ( var i = 1 ; i <= n - 1 ; i ++ ) {"}
{"text":"pattern occurs at index i since z value of i equals pattern length","code":"if ( z [ i ] === a . length ) { ans ++ ; } } return ans ; }"}
{"text":"Driver Code","code":"var a = \" \" ; var b = \" \" ; document . write ( countPermutation ( a , b ) ) ;"}
{"text":"function for reverse","code":"function reverse ( input ) { a = input ; var l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { var temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return a ; }"}
{"text":"Function to find lexicographically smallest subsequence of size K","code":"function smallestSubsequence ( S , K ) {"}
{"text":"Length of string","code":"var N = S . length ;"}
{"text":"Stores the minimum subsequence","code":"answer = [ ] ;"}
{"text":"Traverse the string S","code":"for ( var i = 0 ; i < N ; ++ i ) {"}
{"text":"If the stack is empty","code":"if ( answer . length == 0 ) { answer . push ( S [ i ] ) ; } else {"}
{"text":"Iterate till the current character is less than the the character at the top of stack","code":"while ( ( answer . length != 0 ) && ( S [ i ] < answer [ answer . length - 1 ] )"}
{"text":"Check if there are enough characters remaining to obtain length K","code":"&& ( answer . length - 1 + N - i >= K ) ) { answer . pop ( ) ; }"}
{"text":"If stack size is < K","code":"if ( answer . length == 0 answer . length < K ) {"}
{"text":"Push the current character into it","code":"answer . push ( S [ i ] ) ; } } }"}
{"text":"Stores the resultant string","code":"var ret = [ ] ;"}
{"text":"Iterate until stack is empty","code":"while ( answer . length != 0 ) { ret += answer [ answer . length - 1 ] ; answer . pop ( ) ; }"}
{"text":"Reverse the string","code":"reverse ( ret ) ;"}
{"text":"Print the string","code":"document . write ( ret ) ; } var S = \" \" ; var K = 3 ; smallestSubsequence ( S , K ) ;"}
{"text":"Function to check if the given string is right to left diagonal or not","code":"function is_rtol ( s ) { let tmp = ( Math . sqrt ( s . length ) ) - 1 ; let first = s [ tmp ] ;"}
{"text":"Iterate over string","code":"for ( let pos = tmp ; pos < s . length - 1 ; pos += tmp ) {"}
{"text":"If character is not same as the first character then return false","code":"if ( s [ pos ] != first ) { return false ; } } return true ; }"}
{"text":"Given String str","code":"let str = \" \" ;"}
{"text":"Function call","code":"if ( is_rtol ( str ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text":"Function for checking string","code":"function check ( str , K ) {"}
{"text":"Check if the string can be split into substrings of K length only","code":"if ( str . length % K === 0 ) { var sum = 0 , i ;"}
{"text":"Compute the sum of first substring of length K","code":"for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] . charCodeAt ( 0 ) ; }"}
{"text":"Compute the sum of remaining substrings","code":"for ( var j = i ; j < str . length ; j += K ) { var s_comp = 0 ; for ( var p = j ; p < j + K ; p ++ ) s_comp += str [ p ] . charCodeAt ( 0 ) ;"}
{"text":"Check if sum is equal to that of the first substring","code":"if ( s_comp !== sum )"}
{"text":"Since all sums are not equal , return false","code":"return false ; }"}
{"text":"All sums are equal , Return true","code":"return true ; }"}
{"text":"All substrings cannot be of size K","code":"return false ; }"}
{"text":"Driver code","code":"var K = 3 ; var str = \" \" ; if ( check ( str , K ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to maximize the sum of the count of zeros and ones in the left and right substring","code":"function maxSum ( str ) { var maximumSum = 0 ;"}
{"text":"To store the total ones","code":"var totalOnes = 0 ;"}
{"text":"Count the total numbers of ones in string str","code":"str . split ( ' ' ) . forEach ( c => { if ( c == ' ' ) totalOnes ++ ; } ) ;"}
{"text":"To store the count of zeros and ones while traversing string","code":"var zero = 0 , ones = 0 ;"}
{"text":"Iterate the given string and update the maximum sum","code":"for ( var i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == ' ' ) { zero ++ ; } else { ones ++ ; }"}
{"text":"Update the maximum Sum","code":"maximumSum = Math . max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; }"}
{"text":"Given binary string","code":"var str = \" \" ;"}
{"text":"Function call","code":"document . write ( maxSum ( str ) ) ;"}
{"text":"Function to return the length of the longest substring such that no three consecutive characters are same","code":"function maxLenSubStr ( s ) {"}
{"text":"If the length of the given string is less than 3","code":"if ( s . length < 3 ) return s . length ;"}
{"text":"Initialize temporary and final ans to 2 as this is the minimum length of substring when length of the given string is greater than 2","code":"let temp = 2 ; let ans = 2 ;"}
{"text":"Traverse the string from the third character to the last","code":"for ( let i = 2 ; i < s . length ; i ++ ) {"}
{"text":"If no three consecutive characters are same then increment temporary count","code":"if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ;"}
{"text":"Else update the final ans and reset the temporary count","code":"else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }"}
{"text":"Driver code","code":"let s = \" \" ; document . write ( maxLenSubStr ( s ) ) ;"}
{"text":"Function to return the number of ways of removing a sub - string from s such that all the remaining characters are same","code":"function no_of_ways ( s ) { let n = s . length ;"}
{"text":"To store the count of prefix and suffix","code":"let count_left = 0 , count_right = 0 ;"}
{"text":"Loop to count prefix","code":"for ( let i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; }"}
{"text":"Loop to count suffix","code":"for ( let i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; }"}
{"text":"First and last characters of the string are same","code":"if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ;"}
{"text":"Otherwise","code":"else return ( count_left + count_right + 1 ) ; }"}
{"text":"Driver Code","code":"let s = \" \" ; document . write ( no_of_ways ( s ) ) ;"}
{"text":"Function to create prefix array","code":"function preCompute ( n , s , pref ) { pref [ 0 ] = 0 ; for ( let i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } }"}
{"text":"Function to return the result of the query","code":"function query ( pref , l , r ) { return pref [ r ] - pref [ l ] ; }"}
{"text":"Driver Code","code":"let s = \" \" ; let n = s . length ; let pref = new Array ( n ) ; preCompute ( n , s , pref ) ;"}
{"text":"Query 1","code":"let l = 1 ; let r = 2 ; document . write ( query ( pref , l , r ) + \" \" ) ;"}
{"text":"Query 2","code":"l = 1 ; r = 5 ; document . write ( query ( pref , l , r ) + \" \" ) ;"}
{"text":"Function to find the final direction","code":"function findDirection ( s ) { let count = 0 ; let d = \" \" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ 0 ] == ' ' ) return null ; if ( s [ i ] == ' ' ) count -- ; else { if ( s [ i ] == ' ' ) count ++ ; } }"}
{"text":"if count is positive that implies resultant is clockwise direction","code":"if ( count > 0 ) { if ( count % 4 == 0 ) d = \" \" ; else if ( count % 4 == 1 ) d = \" \" ; else if ( count % 4 == 2 ) d = \" \" ; else if ( count % 4 == 3 ) d = \" \" ; }"}
{"text":"if count is negative that implies resultant is anti - clockwise direction","code":"if ( count < 0 ) { if ( count % 4 == 0 ) d = \" \" ; else if ( count % 4 == - 1 ) d = \" \" ; else if ( count % 4 == - 2 ) d = \" \" ; else if ( count % 4 == - 3 ) d = \" \" ; } return d ; }"}
{"text":"Driver code","code":"let s = \" \" ; document . write ( findDirection ( s ) + \" \" ) ; s = \" \" ; document . write ( findDirection ( s ) ) ;"}
{"text":"Function to check if both the case follow the same order","code":"function isCheck ( str ) { var len = str . length ; var lowerStr = \" \" , upperStr = \" \" ;"}
{"text":"Traverse the string","code":"for ( var i = 0 ; i < len ; i ++ ) {"}
{"text":"Store both lowercase and uppercase in two different strings","code":"if ( str [ i ] >= ' ' && str [ i ] < ' ' ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; }"}
{"text":"transform lowerStr1 to upper","code":"lowerStr = lowerStr . toUpperCase ( ) ; console . log ( lowerStr ) ; return lowerStr === upperStr ; }"}
{"text":"Driver code","code":"var str = \" \" ; isCheck ( str ) ? document . write ( \" \" ) : document . write ( \" \" ) ;"}
{"text":"Function to move string character","code":"function encode ( s , k ) {"}
{"text":"changed string","code":"let newS = \" \" ;"}
{"text":"iterate for every characters","code":"for ( let i = 0 ; i < s . length ; ++ i ) {"}
{"text":"ASCII value","code":"let val = s [ i ] . charCodeAt ( 0 ) ;"}
{"text":"store the duplicate","code":"let dup = k ;"}
{"text":"if k - th ahead character exceed ' z '","code":"if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += String . fromCharCode ( 96 + k ) ; } else { newS += String . fromCharCode ( val + k ) ; } k = dup ; }"}
{"text":"print the new string","code":"document . write ( newS ) ; }"}
{"text":"Driver Code","code":"let str = \" \" ; let k = 28 ;"}
{"text":"function call","code":"encode ( str , k ) ;"}
{"text":"Function to check if the character x is a vowel or not","code":"function isVowel ( x ) { if ( x === \" \" x === \" \" x === \" \" x === \" \" x === \" \" ) return true ; else return false ; }"}
{"text":"Returns the updated string formed after removing all the Sandwiched Vowels from the given string","code":"function updateSandwichedVowels ( a ) { var n = a . length ;"}
{"text":"string to store the Updated String after removing the Sandwiched Vowels","code":"var updatedString = \" \" ;"}
{"text":"traverse the string from left to right","code":"for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"if the current character is the first or the last character of the string then , this needs to be appended to the updatedString , since the corner alphabet irrespective of it being a vowel or a consonant , is never ' Sandwiched '","code":"if ( i === 0 i === n - 1 ) { updatedString += a [ i ] ; continue ; }"}
{"text":"Check if the current character of the string is a vowel and both the previous and the next characters are consonants , if so then this is a sandwiched vowel , thus is ignored and not appended to the updated string","code":"if ( isVowel ( a [ i ] ) === true && isVowel ( a [ i - 1 ] ) === false && isVowel ( a [ i + 1 ] ) === false ) { continue ; }"}
{"text":"if this character is not a sandwiched Vowel append it to the updated String","code":"updatedString += a [ i ] ; } return updatedString ; }"}
{"text":"Driver Code","code":"var str = \" \" ;"}
{"text":"Remove all the Sandwitched Vowels","code":"var updatedString = updateSandwichedVowels ( str ) ; document . write ( updatedString ) ;"}
{"text":"A Binary Tree node","code":"class Node { constructor ( ) { this . data = 0 ; this . left = null ; this . right = null ; } } ; var ans = 0 ;"}
{"text":"A utility function to create a new node","code":"function newNode ( data ) { var newNode = new Node ( ) ; newNode . data = data ; newNode . left = newNode . right = null ; return ( newNode ) ; }"}
{"text":"A recursive function to print the paths whose maximum element is greater than or equal to K .","code":"function findPathUtil ( root , k , path , flag ) { if ( root == null ) return ;"}
{"text":"If the current node value is greater than or equal to k , then all the subtrees following that node will get printed , flag = 1 indicates to print the required path","code":"if ( root . data >= k ) flag = 1 ;"}
{"text":"If the leaf node is encountered , then the path is printed if the size of the path vector is greater than 0","code":"if ( root . left == null && root . right == null ) { if ( flag == 1 ) { ans = 1 ; document . write ( \" \" ) ; for ( var i = 0 ; i < path . length ; i ++ ) { document . write ( path [ i ] + \" \" ) ; } document . write ( root . data + \" \" ) ; } return ; }"}
{"text":"Append the node to the path vector","code":"path . push ( root . data ) ;"}
{"text":"Recur left and right subtrees","code":"findPathUtil ( root . left , k , path , flag ) ; findPathUtil ( root . right , k , path , flag ) ;"}
{"text":"Backtracking to return the vector and print the path if the flag is 1","code":"path . pop ( ) ; }"}
{"text":"Function to initialize the variables and call the utility function to print the paths with maximum values greater than or equal to K","code":"function findPath ( root , k ) {"}
{"text":"Initialize flag","code":"var flag = 0 ;"}
{"text":"ans is used to check empty condition","code":"ans = 0 ; var v = [ ] ;"}
{"text":"Call function that print path","code":"findPathUtil ( root , k , v , flag ) ;"}
{"text":"If the path doesn 't exist","code":"if ( ans == 0 ) document . write ( \" \" ) ; }"}
{"text":"Driver code","code":"var K = 25 ;"}
{"text":"Constructing the following tree : 10 \/ \\ 5 8 \/ \\ \/ \\ 29 2 1 98 \/ \\ 20 50","code":"var root = newNode ( 10 ) ; root . left = newNode ( 5 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 29 ) ; root . left . right = newNode ( 2 ) ; root . right . right = newNode ( 98 ) ; root . right . left = newNode ( 1 ) ; root . right . right . right = newNode ( 50 ) ; root . left . left . left = newNode ( 20 ) ; findPath ( root , K ) ;"}
{"text":"Function to find N - th Tridecagonal number","code":"function Tridecagonal_num ( n ) {"}
{"text":"Formula to calculate nth Tridecagonal number","code":"return ( 11 * n * n - 9 * n ) \/ 2 ; }"}
{"text":"Driver Code","code":"let n = 3 ; document . write ( Tridecagonal_num ( n ) + \" \" ) ; n = 10 ; document . write ( Tridecagonal_num ( n ) ) ;"}
{"text":"Function to find total possible numbers with n digits and weight w","code":"function findNumbers ( n , w ) { let x = 0 , sum = 0 ;"}
{"text":"When Weight of an integer is Positive","code":"if ( w >= 0 && w <= 8 ) {"}
{"text":"Subtract the weight from 9","code":"x = 9 - w ; }"}
{"text":"When weight of an integer is negative","code":"else if ( w >= - 9 && w <= - 1 ) {"}
{"text":"add the weight to 10 to make it positive","code":"x = 10 + w ; } sum = Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }"}
{"text":"Driver code","code":"let n , w ;"}
{"text":"number of digits in an integer and w as weight","code":"n = 3 ; w = 4 ;"}
{"text":"print the total possible numbers with n digits and weight w","code":"document . write ( findNumbers ( n , w ) ) ;"}
{"text":"Javascript program to find the maximum height of Pyramidal Arrangement of array values","code":"function MaximumHeight ( a , n ) { let result = 1 ; for ( i = 1 ; i <= n ; ++ i ) {"}
{"text":"Just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) \/ 2 elements in the array","code":"let y = ( i * ( i + 1 ) ) \/ 2 ;"}
{"text":"updating the result value each time","code":"if ( y < n ) result = i ;"}
{"text":"otherwise we have exceeded n value","code":"else break ; } return result ; }"}
{"text":"Driver Code","code":"let arr = [ 40 , 100 , 20 , 30 ] ; let n = arr . length ; document . write ( MaximumHeight ( arr , n ) ) ;"}
{"text":"Javascript program to find k - th element in the Odd - Even sequence .","code":"function findK ( n , k ) { let a = [ ] ;"}
{"text":"insert all the odd numbers from 1 to n .","code":"for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push ( i ) ;"}
{"text":"insert all the even numbers from 1 to n .","code":"for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push ( i ) ; return ( a [ k - 1 ] ) ; }"}
{"text":"Driver code","code":"let n = 10 , k = 3 ; document . write ( findK ( n , k ) ) ;"}
{"text":"Javascript program to find factorial of given number","code":"function factorial ( n ) {"}
{"text":"single line to find factorial","code":"return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }"}
{"text":"Driver Code","code":"let num = 5 ; document . write ( \" \" , num , \" \" , factorial ( num ) ) ;"}
{"text":"calculate nth pell number","code":"function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c ; for ( let i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }"}
{"text":"Driver function","code":"let n = 4 ; document . write ( pell ( n ) ) ;"}
{"text":"Returns true if n - th Fibonacci number is multiple of 10.","code":"function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; }"}
{"text":"Driver Code","code":"let n = 30 ; if ( isMultipleOf10 ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"A function to count all odd prime factors of a given number n","code":"function countOddPrimeFactors ( n ) { let result = 1 ;"}
{"text":"Eliminate all even prime factor of number of n","code":"while ( n % 2 == 0 ) n \/= 2 ;"}
{"text":"n must be odd at this point , so iterate for only odd numbers till sqrt ( n )","code":"for ( let i = 3 ; i * i <= n ; i += 2 ) { let divCount = 0 ;"}
{"text":"if i divides n , then start counting of Odd divisors","code":"while ( n % i == 0 ) { n \/= i ; ++ divCount ; } result *= divCount + 1 ; }"}
{"text":"If n odd prime still remains then count it","code":"if ( n > 2 ) result *= 2 ; return result ; } function politness ( n ) { return countOddPrimeFactors ( n ) - 1 ; }"}
{"text":"Driver Code","code":"let n = 90 ; document . write ( \" \" + n + \" \" + politness ( n ) + \" \" ) ; n = 15 ; document . write ( \" \" + n + \" \" + politness ( n ) ) ;"}
{"text":"array to store all primes less than 10 ^ 6","code":"var primes = [ ] ;"}
{"text":"Utility function of Sieve of Sundaram","code":"var MAX = 1000000 ; function Sieve ( ) { let n = MAX ;"}
{"text":"In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x","code":"let nNew = parseInt ( Math . sqrt ( n ) ) ;"}
{"text":"This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j","code":"var marked = new Array ( n \/ 2 + 500 ) . fill ( 0 ) ;"}
{"text":"eliminate indexes which does not produce primes","code":"for ( let i = 1 ; i <= parseInt ( ( nNew - 1 ) \/ 2 ) ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= parseInt ( n \/ 2 ) ; j = j + 2 * i + 1 ) marked [ j ] = 1 ;"}
{"text":"Since 2 is a prime number","code":"primes . push ( 2 ) ;"}
{"text":"Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for ( let i = 1 ; i <= parseInt ( n \/ 2 ) ; i ++ ) if ( marked [ i ] == 0 ) primes . push ( 2 * i + 1 ) ; }"}
{"text":"modified binary search to find nearest prime less than N","code":"function binarySearch ( left , right , n ) { if ( left <= right ) { let mid = parseInt ( ( left + right ) \/ 2 ) ;"}
{"text":"base condition is , if we are reaching at left corner or right corner of primes [ ] array then return that corner element because before or after that we don 't have any prime number in  primes array","code":"if ( mid == 0 mid == primes . length - 1 ) return primes [ mid ] ;"}
{"text":"now if n is itself a prime so it will be present in primes array and here we have to find nearest prime less than n so we will return primes [ mid - 1 ]","code":"if ( primes [ mid ] == n ) return primes [ mid - 1 ] ;"}
{"text":"now if primes [ mid ] < n and primes [ mid + 1 ] > n that mean we reached at nearest prime","code":"if ( primes [ mid ] < n && primes [ mid + 1 ] > n ) return primes [ mid ] ; if ( n < primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; }"}
{"text":"Driver program to run the case","code":"Sieve ( ) ; let n = 17 ; document . write ( binarySearch ( 0 , primes . length - 1 , n ) ) ;"}
{"text":"function to find factorial of given number","code":"function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }"}
{"text":"Driver Code","code":"let num = 5 ; document . write ( \" \" + num + \" \" + factorial ( num ) ) ;"}
{"text":"Unsets the rightmost set bit of n and returns the result","code":"function FlipBits ( n ) { return n -= ( n & ( - n ) ) ; }"}
{"text":"Driver Code","code":"let N = 12 ; document . write ( \" \" ) ; document . write ( \" \" + FlipBits ( N ) ) ;"}
{"text":"function to count maximum XOR value for a triplet","code":"function Maximum_xor_Triplet ( n , a ) {"}
{"text":"set is used to avoid repetitions","code":"let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) {"}
{"text":"store all possible unique XOR value of pairs","code":"s . add ( a [ i ] ^ a [ j ] ) ; } } let ans = 0 ; for ( let i of s . values ( ) ) { for ( let j = 0 ; j < n ; j ++ ) {"}
{"text":"store maximum value","code":"ans = Math . max ( ans , i ^ a [ j ] ) ; } } document . write ( ans , \" \" ) ; }"}
{"text":"Driver code","code":"let a = [ 1 , 3 , 8 , 15 ] ; let n = a . length ; Maximum_xor_Triplet ( n , a ) ;"}
{"text":"Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]","code":"function prletMissing ( arr , low , high ) {"}
{"text":"Create boolean array of size high - low + 1 , each index i representing wether ( i + low ) th element found or not .","code":"let polets_of_range = Array ( high - low + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) {"}
{"text":"if ith element of arr is in range low to high then mark corresponding index as true in array","code":"if ( low <= arr [ i ] && arr [ i ] <= high ) polets_of_range [ arr [ i ] - low ] = true ; }"}
{"text":"Traverse through the range and prlet all elements whose value is false","code":"for ( let x = 0 ; x <= high - low ; x ++ ) { if ( polets_of_range [ x ] == false ) document . write ( ( low + x ) + \" \" ) ; } }"}
{"text":"Driver program","code":"let arr = [ 1 , 3 , 5 , 4 ] ; let low = 1 , high = 10 ; prletMissing ( arr , low , high ) ;"}
{"text":"Returns k - th missing element . It returns - 1 if no k is more than number of missing elements .","code":"function find ( a , b , k , n1 , n2 ) {"}
{"text":"Insert all elements of givens sequence b [ ] .","code":"var s = new Set ( ) ; for ( var i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ;"}
{"text":"Traverse through increasing sequence and keep track of count of missing numbers .","code":"var missing = 0 ; for ( var i = 0 ; i < n1 ; i ++ ) { if ( ! s . has ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }"}
{"text":"driver program to test the above function","code":"var a = [ 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 ] ; var b = [ 4 , 10 , 6 , 8 , 12 ] ; var n1 = a . length ; var n2 = b . length ; var k = 3 ; document . write ( find ( a , b , k , n1 , n2 ) ) ;"}
{"text":"Function to find the minimum number of string required to generate the original string","code":"function findString ( S , N ) {"}
{"text":"Stores the frequency of each character of String S","code":"let amounts = new Array ( 26 ) ;"}
{"text":"Iterate over the range [ 0 , 25 ]","code":"for ( let i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; }"}
{"text":"Stores the frequency of each character of String S","code":"for ( let i = 0 ; i < S . length ; i ++ ) { amounts [ S [ i ] . charCodeAt ( 0 ) - 97 ] ++ ; } let count = 0 ;"}
{"text":"Count unique characters in S","code":"for ( let i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; }"}
{"text":"If unique characters is greater then N , then return - 1","code":"if ( count > N ) { document . write ( \" \" ) ; }"}
{"text":"Otherwise","code":"else { let ans = \" \" ; let high = 100001 ; let low = 0 ; let mid , total ;"}
{"text":"Perform Binary Search","code":"while ( high - low > 1 ) { total = 0 ;"}
{"text":"Find the value of mid","code":"mid = Math . floor ( ( high + low ) \/ 2 ) ;"}
{"text":"Iterate over the range [ 0 , 26 ]","code":"for ( let i = 0 ; i < 26 ; i ++ ) {"}
{"text":"If the amount [ i ] is greater than 0","code":"if ( amounts [ i ] > 0 ) { total += Math . floor ( ( amounts [ i ] - 1 ) \/ mid + 1 ) ; } }"}
{"text":"Update the ranges","code":"if ( total <= N ) { high = mid ; } else { low = mid ; } } document . write ( high + \" \" ) ; total = 0 ;"}
{"text":"Find the resultant string","code":"for ( let i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += Math . floor ( ( amounts [ i ] - 1 ) \/ high + 1 ) ; for ( let j = 0 ; j < Math . floor ( ( amounts [ i ] - 1 ) \/ high + 1 ) ; j ++ ) {"}
{"text":"Generate the subsequence","code":"ans += String . fromCharCode ( i + 97 ) ; } } }"}
{"text":"If the length of resultant string is less than N than add a character ' a '","code":"for ( let i = total ; i < N ; i ++ ) { ans += \" \" ; } ans = ans . split ( \" \" ) . reverse ( ) . join ( \" \" ) ;"}
{"text":"Print the string","code":"document . write ( ans ) ; } }"}
{"text":"Driver Code","code":"let S = \" \" ; let K = 4 ; findString ( S , K ) ;"}
{"text":"This function prints the first repeating element in arr [ ]","code":"function printFirstRepeating ( arr ) {"}
{"text":"Initialize index of first repeating element","code":"let min = - 1 ;"}
{"text":"Creates an empty hashset","code":"let set = new Set ( ) ;"}
{"text":"Traverse the input array from right to left","code":"for ( let i = arr . length - 1 ; i >= 0 ; i -- ) {"}
{"text":"If element is already in hash set , update min","code":"if ( set . has ( arr [ i ] ) ) min = i ;"}
{"text":"Else add element to hash set","code":"else set . add ( arr [ i ] ) ; }"}
{"text":"Print the result","code":"if ( min != - 1 ) document . write ( \" \" + arr [ min ] ) ; else document . write ( \" \" ) ; }"}
{"text":"Driver code","code":"let arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; printFirstRepeating ( arr ) ;"}
{"text":"This function prints the first repeating element in arr","code":"function printFirstRepeating ( arr , n ) {"}
{"text":"This will set k = 1 , if any repeating element found","code":"var k = 0 ;"}
{"text":"max = maximum from ( all elements & n )","code":"var max = n ; for ( i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ;"}
{"text":"Array a is for storing 1 st time occurence of element initialized by 0","code":"var a = Array ( max + 1 ) . fill ( 0 ) ;"}
{"text":"Store 1 in array b if element is duplicate initialized by 0","code":"var b = Array ( max + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"Duplicate element found","code":"if ( a [ arr [ i ] ] != 0 ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else"}
{"text":"storing 1 st occurence of arr [ i ]","code":"a [ arr [ i ] ] = i ; } if ( k == 0 ) document . write ( \" \" ) ; else { var min = max + 1 ;"}
{"text":"trace array a & find repeating element with min index","code":"for ( i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] != 0 && min > a [ i ] && b [ i ] != 0 ) min = a [ i ] ; document . write ( arr [ min ] ) ; } document . write ( \" \" ) ; }"}
{"text":"Driver code","code":"var arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; var n = arr . length ; printFirstRepeating ( arr , n ) ;"}
{"text":"Returns k - th distinct element in arr .","code":"function printKDistinct ( arr , n , k ) { var dist_count = 0 ; for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"Check if current element is present somewhere else .","code":"var j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ;"}
{"text":"If element is unique","code":"if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }"}
{"text":"Driver Code","code":"var ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] ; var n = ar . length ; var k = 2 ; document . write ( printKDistinct ( ar , n , k ) ) ;"}
{"text":"Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together","code":"function countSubarrays ( A , N ) {"}
{"text":"Stores the count","code":"var res = 0 ;"}
{"text":"Initialize cur with first element","code":"var curr = A [ 0 ] ; var cnt = [ ] ; cnt . fill ( 1 ) for ( var c = 1 ; c < N ; c ++ ) {"}
{"text":"If the next element is same as the current element","code":"if ( A == curr )"}
{"text":"Increment count","code":"cnt [ cnt . length - 1 ] ++ ; else"}
{"text":"Update curr","code":"curr = A ; cnt . push ( 1 ) ; }"}
{"text":"Iterate over the array count","code":"for ( var i = 1 ; i < cnt . length ; i ++ ) {"}
{"text":"Consider the minimum","code":"res += Math . min ( cnt [ i - 1 ] , cnt [ i ] ) ; } document . write ( res ) ; }"}
{"text":"Given [ ] arr","code":"var A = [ 1 , 1 , 0 , 0 , 1 , 0 ] ; var N = A . length ;"}
{"text":"Function Call","code":"countSubarrays ( A , N ) ;"}
{"text":"Tree node","code":"class Node { constructor ( data ) { this . left = null ; this . right = null ; this . val = data ; } }"}
{"text":"Function to return new tree node","code":"function newNode ( data ) { let temp = new Node ( data ) ; return temp ; }"}
{"text":"Function to check if the tree is even - odd tree","code":"function isEvenOddBinaryTree ( root ) { if ( root == null ) return true ;"}
{"text":"Stores nodes of each level","code":"let q = [ ] ; q . push ( root ) ;"}
{"text":"Store the current level of the binary tree","code":"let level = 0 ;"}
{"text":"Traverse until the queue is empty","code":"while ( q . length > 0 ) {"}
{"text":"Stores the number of nodes present in the current level","code":"let size = q . length ; for ( let i = 0 ; i < size ; i ++ ) { let node = q [ 0 ] ; q . shift ( ) ;"}
{"text":"Check if the level is even or odd","code":"if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; }"}
{"text":"Add the nodes of the next level into the queue","code":"if ( node . left != null ) { q . push ( node . left ) ; } if ( node . right != null ) { q . push ( node . right ) ; } }"}
{"text":"Increment the level count","code":"level ++ ; } return true ; }"}
{"text":"Construct a Binary Tree","code":"let root = null ; root = newNode ( 2 ) ; root . left = newNode ( 3 ) ; root . right = newNode ( 9 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 10 ) ; root . right . right = newNode ( 6 ) ;"}
{"text":"Check if the binary tree is even - odd tree or not","code":"if ( isEvenOddBinaryTree ( root ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text":"Javascript Program to implement the above approach","code":"function findMaxLen ( a ) {"}
{"text":"Size of the array","code":"var n = a . length ;"}
{"text":"Stores the frequency of array elements","code":"var freq = Array ( n + 1 ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } var maxFreqElement = - 2147483648 ; var maxFreqCount = 1 ; for ( i = 1 ; i <= n ; ++ i ) {"}
{"text":"Find the highest frequency in the array","code":"if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; }"}
{"text":"Increase count of max frequent element","code":"else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } var ans ;"}
{"text":"If no repetition is present","code":"if ( maxFreqElement == 1 ) ans = 0 ; else {"}
{"text":"Find the maximum distance","code":"ans = ( ( n - maxFreqCount ) \/ ( maxFreqElement - 1 ) ) ; }"}
{"text":"Return the max distance","code":"return ans ; }"}
{"text":"Driver Code","code":"var a = [ 1 , 2 , 1 , 2 ] ; document . write ( findMaxLen ( a ) ) ;"}
{"text":"Function to obtain the middle index of the range","code":"function getMid ( s , e ) { return ( s + Math . floor ( ( e - s ) \/ 2 ) ) ; }"}
{"text":"Recursive function to get the sum of values in the given range from the array . The following are parameters for this function . st . Pointer to segment tree node . Index of current node in the segment tree ss & se . Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r . Starting and ending indexes of range query","code":"function MaxUtil ( st , ss , se , l , r , node ) {"}
{"text":"If the segment of this node lies completely within the given range","code":"if ( l <= ss && r >= se )"}
{"text":"Return maximum in the segment","code":"return st [ node ] ;"}
{"text":"If the segment of this node lies outside the given range","code":"if ( se < l ss > r ) return - 1 ;"}
{"text":"If segment of this node lies partially in the given range","code":"let mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }"}
{"text":"Function to return the maximum in the range from [ l , r ]","code":"function getMax ( st , n , l , r ) {"}
{"text":"Check for erroneous input values","code":"if ( l < 0 r > n - 1 l > r ) { document . write ( \" \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }"}
{"text":"Function to conSegment Tree for the subarray [ ss . . se ]","code":"function constructSTUtil ( arr , ss , se , st , si ) {"}
{"text":"For a single element","code":"if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; }"}
{"text":"Otherwise","code":"let mid = getMid ( ss , se ) ;"}
{"text":"Recur for left subtree","code":"st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) ,"}
{"text":"Recur for right subtree","code":"constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; }"}
{"text":"Function to conSegment Tree from the given array","code":"function constructST ( arr , n ) {"}
{"text":"Height of Segment Tree","code":"let x = ( Math . ceil ( Math . log ( n ) ) ) ;"}
{"text":"Maximum size of Segment Tree","code":"let max_size = 2 * Math . pow ( 2 , x ) - 1 ;"}
{"text":"Allocate memory","code":"let st = Array . from ( { length : max_size } , ( _ , i ) => 0 ) ;"}
{"text":"Fill the allocated memory","code":"constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;"}
{"text":"Return the constructed Segment Tree","code":"return st ; }"}
{"text":"Driver Code","code":"let arr = [ 5 , 2 , 3 , 0 ] ; let n = arr . length ;"}
{"text":"Build the Segment Tree from the given array","code":"let st = constructST ( arr , n ) ; let Q = [ [ 1 , 3 ] , [ 0 , 2 ] ] ; for ( let i = 0 ; i < Q . length ; i ++ ) { let max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; let ok = 0 ; for ( let j = 30 ; j >= 0 ; j -- ) { if ( ( max & ( 1 << j ) ) != 0 ) ok = 1 ; if ( ok <= 0 ) continue ; max |= ( 1 << j ) ; } document . write ( max + \" \" ) ; }"}
{"text":"Function to calculate the count","code":"function calculate ( a , n ) {"}
{"text":"Sorting the list using built in function","code":"a . sort ( ) ; let count = 1 ; let answer = 0 ;"}
{"text":"Traversing through the elements","code":"for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) {"}
{"text":"Counting frequency of each elements","code":"count += 1 ; } else {"}
{"text":"Adding the contribution of the frequency to the answer","code":"answer = answer + Math . floor ( ( count * ( count - 1 ) ) \/ 2 ) ; count = 1 ; } } answer = answer + Math . floor ( ( count * ( count - 1 ) ) \/ 2 ) ; return answer ; }"}
{"text":"Driver Code","code":"let a = [ 1 , 2 , 1 , 2 , 4 ] ; let n = a . length ;"}
{"text":"Print the count","code":"document . write ( calculate ( a , n ) ) ;"}
{"text":"Function to calculate the answer","code":"function calculate ( a , n ) {"}
{"text":"Finding the maximum of the array","code":"let maximum = Math . max ( ... a ) ;"}
{"text":"Creating frequency array With initial value 0","code":"let frequency = new Array ( maximum + 1 ) . fill ( 0 ) ;"}
{"text":"Traversing through the array","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"Counting frequency","code":"frequency [ a [ i ] ] += 1 ; } let answer = 0 ;"}
{"text":"Traversing through the frequency array","code":"for ( let i = 0 ; i < maximum + 1 ; i ++ ) {"}
{"text":"Calculating answer","code":"answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return parseInt ( answer \/ 2 ) ; }"}
{"text":"Driver Code","code":"let a = [ 1 , 2 , 1 , 2 , 4 ] ; let n = a . length ;"}
{"text":"Function calling","code":"document . write ( calculate ( a , n ) ) ;"}
{"text":"This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray .","code":"function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ;"}
{"text":"Pick a starting point as i","code":"for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;"}
{"text":"Consider all subarrays starting from i","code":"for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ;"}
{"text":"If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far","code":"if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( \" \" ) ; else document . write ( startindex + \" \" + endindex ) ; return maxsize ; }"}
{"text":"Driver program to test the above functions","code":"let arr = [ 1 , 0 , 0 , 1 , 0 , 1 , 1 ] ; let size = arr . length ; findSubArray ( arr , size ) ;"}
{"text":"Function to return the maximum element","code":"function findMax ( arr , low , high ) {"}
{"text":"If there is only one element left","code":"if ( high == low ) return arr [ low ] ;"}
{"text":"Find mid","code":"let mid = low + ( high - low ) \/ 2 ;"}
{"text":"Check if mid reaches 0 , it is greater than next element or not","code":"if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; }"}
{"text":"Check if mid itself is maximum element","code":"if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; }"}
{"text":"Decide whether we need to go to the left half or the right half","code":"if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } }"}
{"text":"Driver code","code":"let arr = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; let n = arr . length ; document . write ( findMax ( arr , 0 , n - 1 ) ) ;"}
{"text":"Function to perform Ternary Search","code":"function ternarySearch ( l , r , key , ar ) { while ( r >= l ) {"}
{"text":"Find the mid1 and mid2","code":"let mid1 = l + parseInt ( ( r - l ) \/ 3 , 10 ) ; let mid2 = r - parseInt ( ( r - l ) \/ 3 , 10 ) ;"}
{"text":"Check if key is present at any mid","code":"if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }"}
{"text":"Since key is not present at mid , check in which region it is present then repeat the Search operation in that region","code":"if ( key < ar [ mid1 ] ) {"}
{"text":"The key lies in between l and mid1","code":"r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) {"}
{"text":"The key lies in between mid2 and r","code":"l = mid2 + 1 ; } else {"}
{"text":"The key lies in between mid1 and mid2","code":"l = mid1 + 1 ; r = mid2 - 1 ; } }"}
{"text":"Key not found","code":"return - 1 ; }"}
{"text":"Driver code","code":"let l , r , p , key ;"}
{"text":"Get the array Sort the array if not sorted","code":"let ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ;"}
{"text":"Starting index","code":"l = 0 ;"}
{"text":"length of array","code":"r = 9 ;"}
{"text":"Key to be searched in the array","code":"key = 5 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"document . write ( \" \" + key + \" \" + p + \" \" ) ;"}
{"text":"Key to be searched in the array","code":"key = 50 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"document . write ( \" \" + key + \" \" + p ) ;"}
{"text":"function to print the majority Number","code":"function majorityNumber ( arr , n ) { let ans = - 1 ; let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) } else { freq . set ( arr [ i ] , 1 ) } if ( freq . get ( arr [ i ] ) > n \/ 2 ) ans = arr [ i ] ; } return ans ; }"}
{"text":"Driver code","code":"let a = [ 2 , 2 , 1 , 1 , 1 , 2 , 2 ] ; let n = a . length ; document . write ( majorityNumber ( a , n ) ) ;"}
{"text":"Returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1","code":"function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = Math . floor ( ( l + h ) \/ 2 ) ; if ( arr [ mid ] == key ) return mid ;"}
{"text":"If arr [ l ... mid ] is sorted","code":"if ( arr [ l ] <= arr [ mid ] ) {"}
{"text":"As this subarray is sorted , we can quickly check if key lies in half or other half","code":"if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;"}
{"text":"If key not lies in first half subarray , Divide other half into two subarrays , such that we can quickly check if key lies in other half","code":"return search ( arr , mid + 1 , h , key ) ; }"}
{"text":"If arr [ l . . mid ] first subarray is not sorted , then arr [ mid ... h ] must be sorted subarray","code":"if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }"}
{"text":"Driver program","code":"let arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] ; let n = arr . length ; let key = 6 ; let i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) document . write ( \" \" + i + \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Javascript program to find minimum element in a sorted and rotated array","code":"function findMin ( arr , low , high ) {"}
{"text":"This condition is needed to handle the case when array is not rotated at all","code":"if ( high < low ) return arr [ 0 ] ;"}
{"text":"If there is only one element left","code":"if ( high == low ) return arr [ low ] ;"}
{"text":"Find mid","code":"let mid = low + Math . floor ( ( high - low ) \/ 2 ) ;"}
{"text":"Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 }","code":"if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ;"}
{"text":"Check if mid itself is minimum element","code":"if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ;"}
{"text":"Decide whether we need to go to left half or right half","code":"if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }"}
{"text":"Driver Program","code":"let arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; let n1 = arr1 . length ; document . write ( \" \" + findMin ( arr1 , 0 , n1 - 1 ) + \" \" ) ; let arr2 = [ 1 , 2 , 3 , 4 ] ; let n2 = arr2 . length ; document . write ( \" \" + findMin ( arr2 , 0 , n2 - 1 ) + \" \" ) ; let arr3 = [ 1 ] ; let n3 = arr3 . length ; document . write ( \" \" + findMin ( arr3 , 0 , n3 - 1 ) + \" \" ) ; let arr4 = [ 1 , 2 ] ; let n4 = arr4 . length ; document . write ( \" \" + findMin ( arr4 , 0 , n4 - 1 ) + \" \" ) ; let arr5 = [ 2 , 1 ] ; let n5 = arr5 . length ; document . write ( \" \" + findMin ( arr5 , 0 , n5 - 1 ) + \" \" ) ; let arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] ; let n6 = arr6 . length ; document . write ( \" \" + findMin ( arr6 , 0 , n6 - 1 ) + \" \" ) ; let arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; let n7 = arr7 . length ; document . write ( \" \" + findMin ( arr7 , 0 , n7 - 1 ) + \" \" ) ; let arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] ; let n8 = arr8 . length ; document . write ( \" \" + findMin ( arr8 , 0 , n8 - 1 ) + \" \" ) ; let arr9 = [ 3 , 4 , 5 , 1 , 2 ] ; let n9 = arr9 . length ; document . write ( \" \" + findMin ( arr9 , 0 , n9 - 1 ) + \" \" ) ;"}
{"text":"Function to find minimum element","code":"function findMin ( arr , low , high ) { while ( low < high ) { let mid = Math . floor ( low + ( high - low ) \/ 2 ) ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }"}
{"text":"Driver code","code":"var arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; var n1 = arr1 . length ; document . write ( \" \" + findMin ( arr1 , 0 , n1 - 1 ) + \" \" ) ; var arr2 = [ 1 , 2 , 3 , 4 ] ; var n2 = arr2 . length ; document . write ( \" \" + findMin ( arr2 , 0 , n2 - 1 ) + \" \" ) ; var arr3 = [ 1 ] ; var n3 = arr3 . length ; document . write ( \" \" + findMin ( arr3 , 0 , n3 - 1 ) + \" \" ) ; var arr4 = [ 1 , 2 ] ; var n4 = arr4 . length ; document . write ( \" \" + findMin ( arr4 , 0 , n4 - 1 ) + \" \" ) ; var arr5 = [ 2 , 1 ] ; var n5 = arr5 . length ; document . write ( \" \" + findMin ( arr5 , 0 , n5 - 1 ) + \" \" ) ; var arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] ; var n6 = arr6 . length ; document . write ( \" \" + findMin ( arr6 , 0 , n6 - 1 ) + \" \" ) ; var arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; var n7 = arr7 . length ; document . write ( \" \" + findMin ( arr7 , 0 , n7 - 1 ) + \" \" ) ; var arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] ; var n8 = arr8 . length ; document . write ( \" \" + findMin ( arr8 , 0 , n8 - 1 ) + \" \" ) ; var arr9 = [ 3 , 4 , 5 , 1 , 2 ] ; var n9 = arr9 . length ; document . write ( \" \" + findMin ( arr9 , 0 , n9 - 1 ) + \" \" ) ;"}
{"text":"Function to print first smallest and second smallest elements","code":"function print2Smallest ( arr , arr_size ) { let i , first , second ;"}
{"text":"There should be atleast two elements","code":"if ( arr_size < 2 ) { document . write ( \" \" ) ; return ; } first = Number . MAX_VALUE ; second = Number . MAX_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) {"}
{"text":"If current element is smaller than first then update both first and second","code":"if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; }"}
{"text":"If arr [ i ] is in between first and second then update second","code":"else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Number . MAX_VALUE ) document . write ( \" \" ) ; else document . write ( \" \" + first + \" \" + \" \" + second + ' ' ) ; }"}
{"text":"Driver program","code":"let arr = [ 12 , 13 , 1 , 10 , 34 , 1 ] ; let n = arr . length ; print2Smallest ( arr , n ) ;"}
{"text":"LCM of given range queries using Segment Tree","code":"const MAX = 1000"}
{"text":"allocate space for tree","code":"var tree = new Array ( 4 * MAX ) ;"}
{"text":"declaring the array globally","code":"var arr = new Array ( MAX ) ;"}
{"text":"Function to return gcd of a and b","code":"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text":"utility function to find lcm","code":"function lcm ( a , b ) { return Math . floor ( a * b \/ gcd ( a , b ) ) ; }"}
{"text":"Function to build the segment tree Node starts beginning index of current subtree . start and end are indexes in arr [ ] which is global","code":"function build ( node , start , end ) {"}
{"text":"If there is only one element in current subarray","code":"if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } let mid = Math . floor ( ( start + end ) \/ 2 ) ;"}
{"text":"build left and right segments","code":"build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ;"}
{"text":"build the parent","code":"let left_lcm = tree [ 2 * node ] ; let right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; }"}
{"text":"Function to make queries for array range ) l , r ) . Node is index of root of current segment in segment tree ( Note that indexes in segment tree begin with 1f or simplicity ) . start and end are indexes of subarray covered by root of current segment .","code":"function query ( node , start , end , l , r ) {"}
{"text":"Completely outside the segment , returning 1 will not affect the lcm ;","code":"if ( end < l start > r ) return 1 ;"}
{"text":"completely inside the segment","code":"if ( l <= start && r >= end ) return tree [ node ] ;"}
{"text":"partially inside","code":"let mid = Math . floor ( ( start + end ) \/ 2 ) ; let left_lcm = query ( 2 * node , start , mid , l , r ) ; let right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; }"}
{"text":"driver function to check the above program initialize the array","code":"arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ;"}
{"text":"build the segment tree","code":"build ( 1 , 0 , 10 ) ;"}
{"text":"Now we can answer each query efficiently Print LCM of ( 2 , 5 )","code":"document . write ( query ( 1 , 0 , 10 , 2 , 5 ) + \" \" ) ;"}
{"text":"Print LCM of ( 5 , 10 )","code":"document . write ( query ( 1 , 0 , 10 , 5 , 10 ) + \" \" ) ;"}
{"text":"Print LCM of ( 0 , 10 )","code":"document . write ( query ( 1 , 0 , 10 , 0 , 10 ) + \" \" ) ;"}
{"text":"Javascript program for the above approach","code":"let M = 1000000007 ; function waysOfDecoding ( s ) { let dp = new Array ( s . length + 1 ) ; for ( let i = 0 ; i < s . length + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ;"}
{"text":"check the first character of the string if it is ' * ' then 9 ways","code":"dp [ 1 ] = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ;"}
{"text":"traverse the string","code":"for ( let i = 1 ; i < s . length ; i ++ ) {"}
{"text":"If s [ i ] = = ' * ' there can be 9 possible values of *","code":"if ( s [ i ] == ' ' ) { dp [ i + 1 ] = 9 * dp [ i ] ;"}
{"text":"If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 )","code":"if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ;"}
{"text":"If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 )","code":"else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ;"}
{"text":"If the previous digit is * then all 15 2 - digit characters can be formed","code":"else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else {"}
{"text":"taking the value from previous step","code":"dp [ i + 1 ] = s [ i ] != ' ' ? dp [ i ] : 0 ;"}
{"text":"If previous character is 1 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] .","code":"if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ;"}
{"text":"If previous character is 2 and ith character is less than 6 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] .","code":"else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ;"}
{"text":"If previous character is * then it will contain the above 2 cases","code":"else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= ' ' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ s . length ] ; }"}
{"text":"Driver code","code":"let s = \" \" ; document . write ( waysOfDecoding ( s ) ) ;"}
{"text":"Function to count the number of ways to divide the array into two subsets and such that the difference between their sums is equal to diff","code":"function countSubset ( arr , n , diff ) {"}
{"text":"Store the sum of the set S1","code":"var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum += diff ; sum = sum \/ 2 ;"}
{"text":"Initializing the matrix int t [ n + 1 ] [ sum + 1 ] ;","code":"var t = new Array ( n + 1 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( sum + 1 ) ; } for ( var i = 0 ; i < t . length ; i ++ ) { for ( var j = 0 ; j < t [ i ] . length ; j ++ ) { t [ i ] [ j ] = 0 ; } }"}
{"text":"Number of ways to get sum using 0 elements is 0","code":"for ( var j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ;"}
{"text":"Number of ways to get sum 0 using i elements is 1","code":"for ( var i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ;"}
{"text":"Traverse the 2D array","code":"for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) {"}
{"text":"If the value is greater than the sum store the value of previous state","code":"if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } }"}
{"text":"Return the result","code":"return t [ n ] [ sum ] ; }"}
{"text":"Given Input","code":"var diff = 1 ; var n = 4 ; var arr = [ 1 , 1 , 2 , 3 ] ;"}
{"text":"Function Call","code":"document . write ( countSubset ( arr , n , diff ) ) ;"}
{"text":"Javascript program of the above approach","code":"let dp = new Array ( 105 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } }"}
{"text":"Function to calculate probability that the sum of numbers on N throws of dice lies between A and B","code":"function find ( N , a , b ) { let probability = 0.0 ;"}
{"text":"Base case","code":"for ( let i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( 1.0 \/ 6 ) ; for ( let i = 2 ; i <= N ; i ++ ) { for ( let j = i ; j <= 6 * i ; j ++ ) { for ( let k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] \/ 6 ; } } }"}
{"text":"Add the probability for all the numbers between a and b","code":"for ( let sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }"}
{"text":"Driver Code","code":"let N = 4 , a = 13 , b = 17 ; let probability = find ( N , a , b ) ;"}
{"text":"Print the answer","code":"document . write ( probability ) ;"}
{"text":"Tree node class for Binary Tree representation","code":"class Node { constructor ( data ) { this . data = data ; this . left = this . right = null ; } }"}
{"text":"Recursive function to find the maximum sum returned for a root node and its grandchildren","code":"function getSumAlternate ( root ) { if ( root == null ) return 0 ; let sum = root . data ; if ( root . left != null ) { sum += getSum ( root . left . left ) ; sum += getSum ( root . left . right ) ; } if ( root . right != null ) { sum += getSum ( root . right . left ) ; sum += getSum ( root . right . right ) ; } return sum ; }"}
{"text":"Returns maximum sum with adjacent levels not allowed . This function mainly uses getSumAlternate ( )","code":"function getSum ( root ) { if ( root == null ) return 0 ;"}
{"text":"We compute sum of alternate levels starting first level and from second level . And return maximum of two values .","code":"return Math . max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) ; }"}
{"text":"Driver code","code":"let root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . right . left = new Node ( 4 ) ; root . right . left . right = new Node ( 5 ) ; root . right . left . right . left = new Node ( 6 ) ; document . write ( getSum ( root ) ) ;"}
{"text":"Returns true if there exists a subset with given sum in arr [ ]","code":"function isSubsetSum ( arr , n , sum ) {"}
{"text":"The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ]","code":"let subset = new Array ( 2 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) {"}
{"text":"A subset with sum 0 is always possible","code":"if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;"}
{"text":"If there exists no element no sum is possible","code":"else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }"}
{"text":"driver program","code":"let arr = [ 1 , 2 , 5 ] ; let sum = 7 ; let n = arr . length ; if ( isSubsetSum ( arr , n , sum ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"Function to find maximum equilibrium sum .","code":"function findMaxSum ( arr , n ) { var res = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var prefix_sum = arr [ i ] ; for ( var j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; var suffix_sum = arr [ i ] ; for ( var j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }"}
{"text":"Driver Code","code":"var arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] ; var n = arr . length ; document . write ( findMaxSum ( arr , n ) ) ;"}
{"text":"Function to find maximum equilibrium sum .","code":"function findMaxSum ( arr , n ) {"}
{"text":"Array to store prefix sum .","code":"let preSum = new Array ( n ) ; preSum . fill ( 0 ) ;"}
{"text":"Array to store suffix sum .","code":"let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ;"}
{"text":"Variable to store maximum sum .","code":"let ans = Number . MIN_VALUE ;"}
{"text":"Calculate prefix sum .","code":"preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ;"}
{"text":"Calculate suffix sum and compare it with prefix sum . Update ans accordingly .","code":"suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }"}
{"text":"Driver code","code":"let arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] ; let n = arr . length ; document . write ( findMaxSum ( arr , n ) ) ;"}
{"text":"Function to find Majority element in an array","code":"function findMajority ( arr , n ) { let maxCount = 0 ;"}
{"text":"sentinels","code":"let index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; }"}
{"text":"Update maxCount if count of current element is greater","code":"if ( count > maxCount ) { maxCount = count ; index = i ; } }"}
{"text":"If maxCount is greater than n \/ 2 return the corresponding element","code":"if ( maxCount > n \/ 2 ) document . write ( arr [ index ] ) ; else document . write ( \" \" ) ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] ; let n = arr . length ;"}
{"text":"Function calling","code":"findMajority ( arr , n ) ;"}
{"text":"Function to find the candidate for Majority","code":"function findCandidate ( a , size ) { let maj_index = 0 , count = 1 ; let i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; }"}
{"text":"Function to check if the candidate occurs more than n \/ 2 times","code":"function isMajority ( a , size , cand ) { let i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( a [ i ] == cand ) count ++ ; } if ( count > parseInt ( size \/ 2 , 10 ) ) return true ; else return false ; }"}
{"text":"Function to print Majority Element","code":"function printMajority ( a , size ) {"}
{"text":"Find the candidate for Majority","code":"let cand = findCandidate ( a , size ) ;"}
{"text":"Print the candidate if it is Majority","code":"if ( isMajority ( a , size , cand ) ) document . write ( \" \" + cand + \" \" ) ; else document . write ( \" \" ) ; }"}
{"text":"Driver Code","code":"let a = [ 1 , 3 , 3 , 1 , 2 ] ; let size = a . length ;"}
{"text":"Function call","code":"printMajority ( a , size ) ;"}
{"text":"Function to find Majority element in an array it returns - 1 if there is no majority element","code":"function majorityElement ( arr , n ) {"}
{"text":"Sort the array in O ( nlogn )","code":"arr . sort ( function ( a , b ) { return a - b } ) ; let count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( let i = 1 ; i < n ; i ++ ) {"}
{"text":"Increases the count if the same element occurs otherwise starts counting new element","code":"if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; }"}
{"text":"Sets maximum count and stores maximum occured element so far if maximum count becomes greater than n \/ 2 it breaks out setting the flag","code":"if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > parseInt ( n \/ 2 , 10 ) ) { f = 1 ; break ; } } }"}
{"text":"Returns maximum occured element if there is no such element , returns - 1","code":"return ( f == 1 ? ele : - 1 ) ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] ; let n = 7 ;"}
{"text":"Function calling","code":"document . write ( majorityElement ( arr , n ) ) ;"}
{"text":"Returns true if there is a subset of set [ ] with sum equal to given sum","code":"function isSubsetSum ( set , n , sum ) {"}
{"text":"The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i","code":"let subset = new Array ( sum + 1 ) ; for ( let i = 0 ; i < sum + 1 ; i ++ ) { subset [ i ] = new Array ( sum + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { subset [ i ] [ j ] = 0 ; } }"}
{"text":"If sum is 0 , then answer is true","code":"for ( let i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ;"}
{"text":"If sum is not 0 and set is empty , then answer is false","code":"for ( let i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ;"}
{"text":"Fill the subset table in bottom up manner","code":"for ( let i = 1 ; i <= sum ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } }"}
{"text":"uncomment this code to print table","code":"for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; }"}
{"text":"Driver code","code":"let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"Check if possible subset with given sum is possible or not","code":"function subsetSum ( a , n , sum ) {"}
{"text":"If the sum is zero it means we got our expected sum","code":"if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ;"}
{"text":"If the value is not - 1 it means it already call the function with the same value . it will save our from the repetition .","code":"if ( tab [ n - 1 ] [ sum ] != - 1 ) return tab [ n - 1 ] [ sum ] ;"}
{"text":"if the value of a [ n - 1 ] is greater than the sum . we call for the next value","code":"if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else {"}
{"text":"Here we do two calls because we don ' t \u2581 know \u2581 which \u2581 value \u2581 is \u2581 \u2581 full - fill \u2581 our \u2581 criteria \u2581 \u2581 that ' s why we doing two calls","code":"return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } }"}
{"text":"Driver Code","code":"let tab = Array ( 2000 ) . fill ( ) . map ( ( ) => Array ( 2000 ) . fill ( - 1 ) ) ; let n = 5 ; let a = [ 1 , 5 , 3 , 7 , 4 ] ; let sum = 12 ; if ( subsetSum ( a , n , sum ) ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" + \" \" ) ; }"}
{"text":"Function to implement fast exponentiation","code":"function binpow ( a , b ) { let res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b = Math . floor ( b \/ 2 ) ; } return res ; }"}
{"text":"Function to return the value for powers of 2","code":"function find ( x ) { if ( x == 0 ) return 0 ; let p = Math . log2 ( x ) ; return binpow ( 2 , p + 1 ) - 1 ; }"}
{"text":"Function to convert N into binary","code":"function getBinary ( n ) {"}
{"text":"To store binary representation","code":"let ans = \" \" ;"}
{"text":"Iterate each digit of n","code":"while ( n ) { let dig = n % 2 ; ans += String ( dig ) ; n = Math . floor ( n \/ 2 ) ; }"}
{"text":"Return binary representation","code":"return ans ; }"}
{"text":"Function to find difference in bits","code":"function totalCountDifference ( n ) {"}
{"text":"Get binary representation","code":"let ans = getBinary ( n ) ;"}
{"text":"total number of bit differences from 0 to N","code":"let req = 0 ;"}
{"text":"Iterate over each binary bit","code":"for ( let i = 0 ; i < ans . length ; i ++ ) {"}
{"text":"If current bit is '1' then add the count of current bit","code":"if ( ans [ i ] == ' ' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; }"}
{"text":"Given Number","code":"let N = 5 ;"}
{"text":"Function Call","code":"document . write ( totalCountDifference ( N ) ) ;"}
{"text":"Function to return the maximum length of the required prefix","code":"function Maximum_Length ( a ) {"}
{"text":"Array to store the frequency of each element of the array","code":"let counts = new Array ( 11 ) ; counts . fill ( 0 ) ;"}
{"text":"Iterating for all the elements","code":"let ans = 0 ; for ( let index = 0 ; index < a . length ; index ++ ) {"}
{"text":"Update the frequency of the current element i . e . v","code":"counts [ a [ index ] ] += 1 ;"}
{"text":"Sorted positive values from counts array","code":"let k = [ ] ; for ( let i = 0 ; i < counts . length ; i ++ ) { if ( counts [ i ] != 0 ) { k . push ( i ) ; } } k . sort ( function ( a , b ) { return a - b } ) ;"}
{"text":"If current prefix satisfies the given conditions","code":"if ( k . length == 1 || ( k [ 0 ] == k [ k . length - 2 ] && k [ k . length - 1 ] - k [ k . length - 2 ] == 1 ) || ( k [ 0 ] == 1 && k [ 1 ] == k [ k . length - 1 ] ) ) ans = index ; }"}
{"text":"Return the maximum length","code":"return ( ans ) ; }"}
{"text":"Driver code","code":"let a = [ 1 , 1 , 1 , 2 , 2 , 2 ] ; document . write ( Maximum_Length ( a ) ) ;"}
{"text":"returns the gcd after all updates in the array","code":"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }"}
{"text":"Function to calculate gcd of onine queries","code":"function print_gcd_online ( n , m , query , arr ) {"}
{"text":"stores the gcd of the initial array elements","code":"let max_gcd = 0 ; let i = 0 ;"}
{"text":"calculates the gcd","code":"for ( i = 0 ; i < n ; i ++ ) max_gcd = gcd ( max_gcd , arr [ i ] ) ;"}
{"text":"performing online queries","code":"for ( i = 0 ; i < m ; i ++ ) {"}
{"text":"index is 1 based","code":"query [ i ] [ 0 ] -- ;"}
{"text":"divide the array element","code":"arr [ query [ i ] [ 0 ] ] \/= query [ i ] [ 1 ] ;"}
{"text":"calculates the current gcd","code":"max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ;"}
{"text":"print the gcd after each step","code":"document . write ( max_gcd + \" \" ) ; } }"}
{"text":"Driver code","code":"let n = 3 ; let m = 3 ; let query = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { query [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { query [ i ] [ j ] = 0 ; } } let arr = [ 36 , 24 , 72 ] ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ;"}
{"text":"Javascript implementation of the approach","code":"var MAX = 1000000 ;"}
{"text":"stores whether the number is prime or not","code":"var prime = Array ( MAX + 1 ) . fill ( true ) ;"}
{"text":"stores the count of prime numbers less than or equal to the index","code":"var sum = Array ( MAX + 1 ) . fill ( 0 ) ;"}
{"text":"create the sieve","code":"function SieveOfEratosthenes ( ) {"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all the entries as true . A value in prime [ i ] will finally be false if ' i ' is Not a prime , else true .","code":"prime [ 1 ] = false ; for ( var p = 2 ; p * p <= MAX ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p","code":"for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } }"}
{"text":"stores the prefix sum of number of primes less than or equal to ' i '","code":"for ( var i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }"}
{"text":"create the sieve","code":"SieveOfEratosthenes ( ) ;"}
{"text":"' l ' and ' r ' are the lower and upper bounds of the range","code":"var l = 3 , r = 9 ;"}
{"text":"get the value of count","code":"var c = ( sum [ r ] - sum [ l - 1 ] ) ;"}
{"text":"display the count","code":"document . write ( \" \" + c ) ;"}
{"text":"Function to find the area of the circle","code":"function area ( r ) {"}
{"text":"radius cannot be negative","code":"if ( r < 0 ) return - 1 ;"}
{"text":"area of the circle","code":"var area = ( 3.14 * Math . pow ( r \/ ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }"}
{"text":"Driver code","code":"var a = 5 ; document . write ( area ( a ) . toFixed ( 6 ) ) ;"}
{"text":"Javascript program to count almost prime numbers from 1 to n","code":"let N = 100005 ;"}
{"text":"Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true .","code":"let prime = new Array ( N ) . fill ( true ) ; function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( let p = 2 ; p < Math . floor ( Math . sqrt ( N ) ) ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true )"}
{"text":"Update all multiples of p","code":"for ( let i = 2 * p ; i < N ; i += p ) prime [ i ] = false ; } }"}
{"text":"Function to count almost prime numbers from 1 to n","code":"function almostPrimes ( n ) {"}
{"text":"to store required answer","code":"let ans = 0 ;"}
{"text":"6 is first almost prime number","code":"for ( let i = 6 ; i < n + 1 ; i ++ ) {"}
{"text":"to count prime factors","code":"let c = 0 ; for ( let j = 2 ; i >= j * j ; j ++ ) {"}
{"text":"if it is perfect square","code":"if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c += 1 ; } else { if ( prime [ j ] ) c += 1 ; if ( prime [ ( i \/ j ) ] ) c += 1 ; } } }"}
{"text":"if I is almost prime number","code":"if ( c == 2 ) ans += 1 ; } return ans ; }"}
{"text":"Driver Code","code":"SieveOfEratosthenes ( ) ; let n = 21 ; document . write ( almostPrimes ( n ) ) ;"}
{"text":"Returns sum of digits of x","code":"function sumOfDigitsSingle ( x ) { let ans = 0 ; while ( x ) { ans += x % 10 ; x = Math . floor ( x \/ 10 ) ; } return ans ; }"}
{"text":"Returns closest number to x in terms of 9 's.","code":"function closest ( x ) { let ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } function sumOfDigitsTwoParts ( N ) { let A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; }"}
{"text":"Driver code","code":"let N = 35 ; document . write ( sumOfDigitsTwoParts ( N ) ) ;"}
{"text":"Function to check whether ( 2 ^ p - 1 ) is prime or not .","code":"function isPrime ( p ) {"}
{"text":"generate the number","code":"let checkNumber = Math . pow ( 2 , p ) - 1 ;"}
{"text":"First number of the series","code":"let nextval = 4 % checkNumber ;"}
{"text":"Generate the rest ( p - 2 ) terms of the series .","code":"for ( let i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;"}
{"text":"now if the ( p - 1 ) th term is 0 return true else false .","code":"return ( nextval == 0 ) ; }"}
{"text":"Check whether 2 ^ p - 1 is prime or not .","code":"let p = 7 ; let checkNumber = Math . pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) document . write ( checkNumber + \" \" ) ; else document . write ( checkNumber + \" \" ) ;"}
{"text":"function to detect prime number here we have used sieve method https : www . geeksforgeeks . org \/ sieve - of - eratosthenes \/ to detect prime number","code":"function sieve ( n , prime ) { for ( let p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } function printSophieGermanNumber ( n ) {"}
{"text":"We have made array till 2 * n + 1 so that we can check prime number till that and conclude about sophie german prime .","code":"let prime = new Array ( ) ; for ( let i = 0 ; i < ( 2 * n + 1 ) ; i ++ ) prime [ i ] = true ; sieve ( 2 * n + 1 , prime ) ; for ( let i = 2 ; i <= n ; ++ i ) {"}
{"text":"checking every i whether it is sophie german prime or not .","code":"if ( prime [ i ] && prime [ 2 * i + 1 ] ) document . write ( i + \" \" ) ; } }"}
{"text":"Driver code","code":"let n = 25 ; printSophieGermanNumber ( n ) ;"}
{"text":"Calculating u mentioned in the formula","code":"function ucal ( u , n ) { if ( n == 0 ) return 1 ; var temp = u ; for ( var i = 1 ; i <= n \/ 2 ; i ++ ) temp = temp * ( u - i ) ; for ( var i = 1 ; i < n \/ 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; }"}
{"text":"Calculating factorial of given number n","code":"function fact ( n ) { var f = 1 ; for ( var i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }"}
{"text":"Number of values given","code":"var n = 6 ; var x = [ 25 , 26 , 27 , 28 , 29 , 30 ] ;"}
{"text":"y is used for difference table with y [ 0 ] used for input","code":"var y = Array ( n ) . fill ( 0.0 ) . map ( x => Array ( n ) . fill ( 0.0 ) ) ; ; y [ 0 ] [ 0 ] = 4.000 ; y [ 1 ] [ 0 ] = 3.846 ; y [ 2 ] [ 0 ] = 3.704 ; y [ 3 ] [ 0 ] = 3.571 ; y [ 4 ] [ 0 ] = 3.448 ; y [ 5 ] [ 0 ] = 3.333 ;"}
{"text":"Calculating the central difference table","code":"for ( var i = 1 ; i < n ; i ++ ) for ( var j = 0 ; j < n - i ; j ++ ) y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ;"}
{"text":"Displaying the central difference table","code":"for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n - i ; j ++ ) document . write ( y [ i ] [ j ] . toFixed ( 6 ) + \" \" ) ; document . write ( ' ' ) ; }"}
{"text":"Value to interpolate at","code":"var value = 27.4 ;"}
{"text":"Initializing u and sum","code":"var sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) \/ 2 ;"}
{"text":"k is origin thats is f ( 0 )","code":"var k ;"}
{"text":"Origin for odd","code":"if ( ( n % 2 ) > 0 ) k = n \/ 2 ; else"}
{"text":"Origin for even","code":"k = n \/ 2 - 1 ; var u = ( value - x [ k ] ) \/ ( x [ 1 ] - x [ 0 ] ) ;"}
{"text":"Solving using bessel 's formula","code":"for ( var i = 1 ; i < n ; i ++ ) { if ( ( i % 2 ) > 0 ) sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) \/ fact ( i ) ; else sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ -- k ] [ i ] ) \/ ( fact ( i ) * 2 ) ) ; } document . write ( \" \" + value . toFixed ( 6 ) + \" \" + sum . toFixed ( 6 ) ) ;"}
{"text":"A simple Javascript program to check if n - th Fibonacci number is multiple of 10.","code":"function fibonacci ( n ) { let a = 0 ; let b = 1 ; let c ; if ( n <= 1 ) return n ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }"}
{"text":"Returns true if n - th Fibonacci number is multiple of 10.","code":"function isMultipleOf10 ( n ) { let f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; }"}
{"text":"Driver code","code":"let n = 30 ; if ( isMultipleOf10 ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function which checks whether a number is a power of 2","code":"function powerOf2 ( n ) {"}
{"text":"base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )","code":"if ( n == 1 ) return true ;"}
{"text":"all other odd numbers are not powers of 2","code":"else if ( n % 2 != 0 n == 0 ) return false ;"}
{"text":"recursive function call","code":"return powerOf2 ( n \/ 2 ) ; }"}
{"text":"True","code":"var n = 64 ;"}
{"text":"False","code":"var m = 12 ; if ( powerOf2 ( n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; if ( powerOf2 ( m ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"Method to check if x is power of 2","code":"function isPowerOfTwo ( x ) {"}
{"text":"First x in the below expression is for the case when x is 0","code":"return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }"}
{"text":"Driver method","code":"document . write ( isPowerOfTwo ( 31 ) ? \" \" : \" \" ) ; document . write ( \" \" + ( isPowerOfTwo ( 64 ) ? \" \" : \" \" ) ) ;"}
{"text":"Function to check if x is power of 2","code":"function isPowerofTwo ( n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }"}
{"text":"Driver code","code":"if ( isPowerofTwo ( 30 ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ; if ( isPowerofTwo ( 128 ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to find the nearest power of 2","code":"function nextPowerOf2 ( n ) {"}
{"text":"The number","code":"let p = 1 ;"}
{"text":"If already a power of 2","code":"if ( n && ! ( n & ( n - 1 ) ) ) return n ;"}
{"text":"Find the next power of 2","code":"while ( p < n ) p <<= 1 ; return p ; }"}
{"text":"Function to find the memory used","code":"function memoryUsed ( arr , n ) {"}
{"text":"Sum of array","code":"let sum = 0 ;"}
{"text":"Traverse and find the sum of array","code":"for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;"}
{"text":"Function call to find the nearest power of 2","code":"let nearest = nextPowerOf2 ( sum ) ; return nearest ; }"}
{"text":"Driver Code","code":"let arr = [ 1 , 2 , 3 , 2 ] ; let n = arr . length ; document . write ( memoryUsed ( arr , n ) ) ;"}
{"text":"Javascript program to toogle k - th bit of a number","code":"function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }"}
{"text":"Driver code","code":"let n = 5 , k = 1 ; document . write ( toggleKthBit ( n , k ) ) ;"}
{"text":"JavaScript program to find smallest power of 2 greater than or equal to n","code":"function nextPowerOf2 ( n ) { var count = 0 ;"}
{"text":"First n in the below condition is for the case where n is 0","code":"if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }"}
{"text":"Driver Code","code":"var n = 0 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text":"Function to return the GCD of A and B","code":"function gcd ( A , B ) { if ( B === 0 ) return A ; return gcd ( B , A % B ) ; }"}
{"text":"Function to return the LCM of A and B","code":"function lcm ( A , B ) { return ( A * B ) \/ gcd ( A , B ) ; }"}
{"text":"Function to return the Kth element from the required set if it a multiple of A","code":"function checkA ( A , B , C , K ) {"}
{"text":"Start and End for Binary Search","code":"var start = 1 ; var end = K ;"}
{"text":"If no answer found return - 1","code":"var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) \/ 2 ) ; var value = A * mid ; var divA = mid - 1 ; var divB = parseInt ( value % B === 0 ? value \/ B - 1 : value \/ B ) ; var divC = parseInt ( value % C === 0 ? value \/ C - 1 : value \/ C ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value \/ lcm ( A , B ) - 1 : value \/ lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value \/ lcm ( C , B ) - 1 : value \/ lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value \/ lcm ( A , C ) - 1 : value \/ lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value \/ lcm ( A , lcm ( B , C ) ) - 1 : value \/ lcm ( A , lcm ( B , C ) ) ) ;"}
{"text":"Inclusion and Exclusion","code":"var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; }"}
{"text":"Multiple should be smaller","code":"else if ( elem > K - 1 ) { end = mid - 1 ; }"}
{"text":"Multiple should be bigger","code":"else { start = mid + 1 ; } } return ans ; }"}
{"text":"Function to return the Kth element from the required set if it a multiple of B","code":"function checkB ( A , B , C , K ) {"}
{"text":"Start and End for Binary Search","code":"var start = 1 ; var end = K ;"}
{"text":"If no answer found return - 1","code":"var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) \/ 2 ) ; var value = B * mid ; var divB = mid - 1 ; var divA = parseInt ( value % A === 0 ? value \/ A - 1 : value \/ A ) ; var divC = parseInt ( value % C === 0 ? value \/ C - 1 : value \/ C ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value \/ lcm ( A , B ) - 1 : value \/ lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value \/ lcm ( C , B ) - 1 : value \/ lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value \/ lcm ( A , C ) - 1 : value \/ lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value \/ lcm ( A , lcm ( B , C ) ) - 1 : value \/ lcm ( A , lcm ( B , C ) ) ) ;"}
{"text":"Inclusion and Exclusion","code":"var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; }"}
{"text":"Multiple should be smaller","code":"else if ( elem > K - 1 ) { end = mid - 1 ; }"}
{"text":"Multiple should be bigger","code":"else { start = mid + 1 ; } } return ans ; }"}
{"text":"Function to return the Kth element from the required set if it a multiple of C","code":"function checkC ( A , B , C , K ) {"}
{"text":"Start and End for Binary Search","code":"var start = 1 ; var end = K ;"}
{"text":"If no answer found return - 1","code":"var ans = - 1 ; while ( start <= end ) { var mid = parseInt ( ( start + end ) \/ 2 ) ; var value = C * mid ; var divC = mid - 1 ; var divB = parseInt ( value % B === 0 ? value \/ B - 1 : value \/ B ) ; var divA = parseInt ( value % A === 0 ? value \/ A - 1 : value \/ A ) ; var divAB = parseInt ( value % lcm ( A , B ) === 0 ? value \/ lcm ( A , B ) - 1 : value \/ lcm ( A , B ) ) ; var divBC = parseInt ( value % lcm ( C , B ) === 0 ? value \/ lcm ( C , B ) - 1 : value \/ lcm ( C , B ) ) ; var divAC = parseInt ( value % lcm ( A , C ) === 0 ? value \/ lcm ( A , C ) - 1 : value \/ lcm ( A , C ) ) ; var divABC = parseInt ( value % lcm ( A , lcm ( B , C ) ) === 0 ? value \/ lcm ( A , lcm ( B , C ) ) - 1 : value \/ lcm ( A , lcm ( B , C ) ) ) ;"}
{"text":"Inclusion and Exclusion","code":"var elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem === K - 1 ) { ans = value ; break ; }"}
{"text":"Multiple should be smaller","code":"else if ( elem > K - 1 ) { end = mid - 1 ; }"}
{"text":"Multiple should be bigger","code":"else { start = mid + 1 ; } } return ans ; }"}
{"text":"Function to return the Kth element from the set of multiples of A , B and C","code":"function findKthMultiple ( A , B , C , K ) {"}
{"text":"Apply binary search on the multiples of A","code":"var res = checkA ( A , B , C , K ) ; console . log ( res ) ;"}
{"text":"If the required element is not a multiple of A then the multiples of B and C need to be checked","code":"if ( res === - 1 ) res = checkB ( A , B , C , K ) ;"}
{"text":"If the required element is neither a multiple of A nor a multiple of B then the multiples of C need to be checked","code":"if ( res === - 1 ) res = checkC ( A , B , C , K ) ; return res ; }"}
{"text":"Driver code","code":"var A = 2 , B = 4 , C = 5 , K = 5 ; document . write ( findKthMultiple ( A , B , C , K ) ) ;"}
{"text":"Function to sort the array","code":"function variationStalinsort ( arr ) { let j = 0 ; while ( true ) { let moved = 0 ; for ( let i = 0 ; i < ( arr . length - 1 - j ) ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) {"}
{"text":"Iterator < Integer > index = arr . iterator ( ) ;","code":"let index ; let temp ; index = arr [ i ] ; temp = arr [ i + 1 ] ; arr . splice ( i , 1 ) ; arr . splice ( i , 0 , temp ) ; arr [ i ] = temp ; arr . splice ( i + 1 , 1 ) ; arr . splice ( i + 1 , 0 , index ) arr [ i + 1 ] = index ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } document . write ( \" \" + arr + \" \" ) ; }"}
{"text":"Driver Code","code":"let arr = [ 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 ] ; let arr1 = [ ] ; for ( let i = 0 ; i < arr . length ; i ++ ) arr1 . push ( arr [ i ] ) ;"}
{"text":"Function call","code":"variationStalinsort ( arr1 ) ;"}
{"text":"Function to print array element","code":"function printArray ( arr , N ) {"}
{"text":"Traverse the array","code":"for ( var i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + ' ' ) ; } }"}
{"text":"Function to sort the array in O ( N )","code":"function sortArray ( arr , N ) {"}
{"text":"Traverse the array","code":"for ( var i = 0 ; i < N ; ) {"}
{"text":"If the current element is at correct position","code":"if ( arr [ i ] == i + 1 ) { i ++ ; }"}
{"text":"Else swap the current element with it 's correct position","code":"else {"}
{"text":"Swap the value of arr [ i ] and arr [ arr [ i ] - 1 ]","code":"var temp1 = arr [ i ] ; var temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } }"}
{"text":"Driver Code","code":"var arr = [ 2 , 1 , 5 , 3 , 4 ] ; var N = arr . length ;"}
{"text":"Function call to sort the array","code":"sortArray ( arr , N ) ;"}
{"text":"Function call to print the array","code":"printArray ( arr , N ) ;"}
{"text":"Function to find the maximum value","code":"function maximum ( value , weight , weight1 , flag , K , index ) {"}
{"text":"base condition","code":"if ( index >= value . length ) { return 0 ; }"}
{"text":"K elements already reduced to half of their weight","code":"if ( flag == K ) {"}
{"text":"Dont include item","code":"var skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; var full = 0 ;"}
{"text":"If weight of the item is less than or equal to the remaining weight then include the item","code":"if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; }"}
{"text":"Return the maximum of both cases","code":"return Math . max ( full , skip ) ; }"}
{"text":"If the weight reduction to half is possible","code":"else {"}
{"text":"Skip the item","code":"var skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; var full = 0 ; var half = 0 ;"}
{"text":"Include item with full weight if weight of the item is less than the remaining weight","code":"if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; }"}
{"text":"Include item with half weight if half weight of the item is less than the remaining weight","code":"if ( weight [ index ] \/ 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] \/ 2 , flag , K , index + 1 ) ; }"}
{"text":"Return the maximum of all 3 cases","code":"return Math . max ( full , Math . max ( skip , half ) ) ; } }"}
{"text":"Driver code","code":"var value = [ 17 , 20 , 10 , 15 ] ; var weight = [ 4 , 2 , 7 , 5 ] ; var K = 1 ; var W = 4 ; document . write ( maximum ( value , weight , W , 0 , K , 0 ) ) ;"}
{"text":"JavaScript program to find the size of the minimum dominating set of the tree","code":"let N = 1005 ;"}
{"text":"Definition of a tree node","code":"class Node { constructor ( data ) { this . left = null ; this . right = null ; this . data = data ; } }"}
{"text":"Helper function that allocates a new node","code":"function newNode ( data ) { let node = new Node ( data ) ; return node ; }"}
{"text":"DP array to precompute and store the results","code":"let dp = new Array ( N ) ;"}
{"text":"minDominatingSettion to return the size of the minimum dominating set of the array","code":"function minDominatingSet ( root , covered , compulsory ) {"}
{"text":"Base case","code":"if ( root == null ) return 0 ;"}
{"text":"Setting the compulsory value if needed","code":"if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ;"}
{"text":"Check if the answer is already computed","code":"if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) return dp [ root . data ] [ covered ] [ compulsory ] ;"}
{"text":"If it is compulsory to select the node","code":"if ( compulsory > 0 ) {"}
{"text":"Choose the node and set its children as covered","code":"return dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; }"}
{"text":"If it is covered","code":"if ( covered > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = Math . min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; }"}
{"text":"If the current node is neither covered nor needs to be selected compulsorily","code":"let ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; }"}
{"text":"Store the result","code":"dp [ root . data ] [ covered ] [ compulsory ] = ans ; return dp [ root . data ] [ covered ] [ compulsory ] ; }"}
{"text":"Initialising the DP array","code":"for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 5 ) ; for ( let j = 0 ; j < 5 ; j ++ ) { dp [ i ] [ j ] = new Array ( 5 ) ; for ( let l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } }"}
{"text":"Constructing the tree","code":"let root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 4 ) ; root . left . left . left = newNode ( 5 ) ; root . left . left . left . left = newNode ( 6 ) ; root . left . left . left . right = newNode ( 7 ) ; root . left . left . left . right . right = newNode ( 10 ) ; root . left . left . left . left . left = newNode ( 8 ) ; root . left . left . left . left . right = newNode ( 9 ) ; document . write ( minDominatingSet ( root , 0 , 0 ) ) ;"}
{"text":"variable to store states of dp","code":"var dp = Array . from ( Array ( arrSize ) , ( ) => Array ( maxSum ) ) ; var visit = Array . from ( Array ( arrSize ) , ( ) => Array ( maxSum ) ) ;"}
{"text":"To find the number of subsets with sum equal to 0 Since S can be negative , we will maxSum to it to make it positive","code":"function SubsetCnt ( i , s , arr , n ) {"}
{"text":"Base cases","code":"if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; }"}
{"text":"Returns the value if a state is already solved","code":"if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ;"}
{"text":"If the state is not visited , then continue","code":"visit [ i ] [ s + maxSum ] = 1 ;"}
{"text":"Recurrence relation","code":"dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ;"}
{"text":"Returning the value","code":"return dp [ i ] [ s + maxSum ] ; }"}
{"text":"Driver function","code":"var arr = [ 2 , 2 , 2 , - 4 , - 4 ] ; var n = arr . length ; document . write ( SubsetCnt ( 0 , 0 , arr , n ) ) ;"}
{"text":"JavaScript program to find the number of Bit Strings of length N with K adjacent set bits","code":"var MAX = 1000 ;"}
{"text":"Function to find the number of Bit Strings of length N with K adjacent set bits","code":"function waysToKAdjacentSetBits ( dp , n , k , currentIndex , adjacentSetBits , lastBit ) {"}
{"text":"Base Case when we form bit string of length n","code":"if ( currentIndex == n ) {"}
{"text":"if f ( bit string ) = k , count this way","code":"if ( adjacentSetBits == k ) return 1 ; return 0 ; } if ( dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] != - 1 ) { return dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] ; } var noOfWays = 0 ;"}
{"text":"Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset","code":"if ( lastBit == 1 ) {"}
{"text":"set the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;"}
{"text":"unset the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] = noOfWays ; return noOfWays ; }"}
{"text":"Driver Code","code":"var n = 5 , k = 2 ;"}
{"text":"dp [ i ] [ j ] [ k ] represents bit strings of length i with f ( bit string ) = j and last bit as k","code":"var dp = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) ) ;"}
{"text":"initializes the dp","code":"for ( var i = 0 ; i < MAX ; i ++ ) for ( var j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = new Array ( 2 ) . fill ( - 1 ) ;"}
{"text":"total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )","code":"var totalWays = waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 0 ) ; document . write ( \" \" + totalWays + \" \" ) ;"}
{"text":"Function to print the N - th tetranacci number","code":"function printTetra ( n ) { if ( n < 0 ) return ;"}
{"text":"Initialize first four numbers to base cases","code":"var first = 0 , second = 1 ; var third = 1 , fourth = 2 ;"}
{"text":"declare a current variable","code":"var curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else {"}
{"text":"Loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively","code":"for ( var i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } document . write ( curr ) ; } }"}
{"text":"Driver code","code":"var n = 10 ; printTetra ( n ) ;"}
{"text":"A recursive function used by countWays","code":"function countWays ( n ) { let res = new Array ( n + 2 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }"}
{"text":"Driver Code","code":"let n = 4 ; document . write ( countWays ( n ) ) ;"}
{"text":"A recursive function used by countWays","code":"function countWays ( n ) {"}
{"text":"Declaring three variables and holding the ways for first three stairs","code":"var a = 1 , b = 2 , c = 4 ;"}
{"text":"Fourth variable","code":"var d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ;"}
{"text":"Starting from 4 as already counted for 3 stairs","code":"for ( var i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }"}
{"text":"Driver code","code":"var n = 4 ; document . write ( countWays ( n ) ) ;"}
{"text":"initializing with 1 as sum 0 is always possible","code":"dp [ 0 ] = 1 ;"}
{"text":"loop to go through every element of the elements array","code":"for ( var i = 0 ; i < elements . length ; i ++ ) {"}
{"text":"to change the values of all possible sum values to 1","code":"for ( var j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } }"}
{"text":"if sum is possible then return 1","code":"if ( dp [ sum ] == 1 ) return true ; return false ; }"}
{"text":"Driver code","code":"var elements = [ 6 , 2 , 5 ] ; var sum = 7 ; if ( isPossible ( elements , sum ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Returns maximum amount of task that can be done till day n","code":"function maxTasks ( high , low , n ) {"}
{"text":"If n is less than equal to 0 , then no solution exists","code":"if ( n <= 0 ) return 0 ;"}
{"text":"Determines which task to choose on day n , then returns the maximum till that day","code":"return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }"}
{"text":"Driver code","code":"let n = 5 ; let high = [ 3 , 6 , 8 , 7 , 6 ] ; let low = [ 1 , 5 , 4 , 5 , 3 ] ; document . write ( maxTasks ( high , low , n ) ) ; ;"}
{"text":"Function to find gcd of two numbers in O ( log ( min ( a , b ) ) )","code":"function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function nCr ( n , r ) {"}
{"text":"Base case","code":"if ( r > n ) return 0 ;"}
{"text":"C ( n , r ) = C ( n , n - r ) better time complexity for lesser r value","code":"if ( r > n - r ) r = n - r ; mod = 1000000007 ;"}
{"text":"Array of elements from n - r + 1 to n","code":"var arr = new Array ( r ) ; for ( var i = n - r + 1 ; i <= n ; i ++ ) { arr [ i + r - n - 1 ] = i ; } var ans = 1 ;"}
{"text":"For numbers from 1 to r find arr [ j ] such that gcd ( i , arr [ j ] ) > 1","code":"for ( var k = 1 ; k < r + 1 ; k ++ ) { var j = 0 , i = k ; while ( j < arr . length ) { var x = gcd ( i , arr [ j ] ) ; if ( x > 1 ) {"}
{"text":"If gcd > 1 , divide both by gcd","code":"arr [ j ] \/= x ; i \/= x ; }"}
{"text":"If i becomes 1 , no need to search arr","code":"if ( i == 1 ) break ; j += 1 ; } }"}
{"text":"Single pass to multiply the numerator","code":"arr . forEach ( function ( i ) { ans = ( ans * i ) % mod ; } ) ; return ans ; }"}
{"text":"Driver code","code":"var n = 5 , r = 2 ; document . write ( \" \" + n + \" \" + r + \" \" + nCr ( n , r ) + \" \" ) ;"}
{"text":"javascript program for the above approach Function to find the Kth character after X days","code":"function FindKthChar ( str , K , X ) {"}
{"text":"Variable to store the KthChar","code":"var ans = \" \" ; var sum = 0 ;"}
{"text":"Traverse the string","code":"for ( i = 0 ; i < str . length ; i ++ ) {"}
{"text":"Convert char into int","code":"var digit = parseInt ( str [ i ] ) ;"}
{"text":"Calculate characters","code":"var range = parseInt ( Math . pow ( digit , X ) ) ; sum += range ;"}
{"text":"If K is less than sum than ans = str [ i ]","code":"if ( K <= sum ) { ans = str [ i ] ; break ; } }"}
{"text":"Return answer","code":"return ans ; }"}
{"text":"Given Input","code":"var str = \" \" ; var K = 9 ; var X = 3 ;"}
{"text":"Function Call","code":"var ans = FindKthChar ( str , K , X ) ; document . write ( ans ) ;"}
{"text":"JavaScript implementation of the approach Function to get no of set bits in binary representation of positive integer n","code":"function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }"}
{"text":"Function to return the count of valid pairs","code":"function totalPairs ( s1 , s2 ) { var count = 0 ; var arr1 = new Array ( 7 ) . fill ( 0 ) ; var arr2 = new Array ( 7 ) . fill ( 0 ) ;"}
{"text":"Store frequency of number of set bits for s1","code":"for ( let i = 0 ; i < s1 . length ; i ++ ) { set_bits = countSetBits ( s1 [ i ] . charCodeAt ( 0 ) ) ; arr1 [ set_bits ] += 1 ; }"}
{"text":"Store frequency of number of set bits for s2","code":"for ( let i = 0 ; i < s2 . length ; i ++ ) { set_bits = countSetBits ( s2 [ i ] . charCodeAt ( 0 ) ) ; arr2 [ set_bits ] += 1 ; }"}
{"text":"Calculate total pairs","code":"for ( let i = 1 ; i < 7 ; i ++ ) { count += arr1 [ i ] * arr2 [ i ] ; }"}
{"text":"Return the count of valid pairs","code":"return count ; }"}
{"text":"Driver code","code":"var s1 = \" \" ; var s2 = \" \" ; document . write ( totalPairs ( s1 , s2 ) ) ;"}
{"text":"function to count substrings starting with character X and ending with character Y","code":"function countSubstr ( str , n , x , y ) {"}
{"text":"to store total count of required substrings","code":"var tot_count = 0 ;"}
{"text":"to store count of character ' x ' up to the point the string ' str ' has been traversed so far","code":"var count_x = 0 ;"}
{"text":"traverse ' str ' form left to right","code":"for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"if true , increment ' count _ x '","code":"if ( str [ i ] === x ) count_x ++ ;"}
{"text":"if true accumulate ' count _ x ' to ' tot _ count '","code":"if ( str [ i ] === y ) tot_count += count_x ; }"}
{"text":"required count","code":"return tot_count ; }"}
{"text":"Driver code","code":"var str = \" \" ; var n = str . length ; var x = \" \" , y = \" \" ; document . write ( \" \" + countSubstr ( str , n , x , y ) ) ;"}
{"text":"javascript program to count no of words from given input string .","code":"var OUT = 0 ; var IN = 1 ;"}
{"text":"returns number of words in str","code":"function countWords ( str ) { var state = OUT ;"}
{"text":"word count","code":"var wc = 0 ; var i = 0 ;"}
{"text":"Scan all characters one by one","code":"while ( i < str . length ) {"}
{"text":"If next character is a separator , set the state as OUT","code":"if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) state = OUT ;"}
{"text":"If next character is not a word separator and state is OUT , then set the state as IN and increment word count","code":"else if ( state == OUT ) { state = IN ; ++ wc ; }"}
{"text":"Move to next character","code":"++ i ; } return wc ; }"}
{"text":"Driver program to test above functions","code":"var str = \" \" ; document . write ( \" \" + countWords ( str ) ) ;"}
{"text":"Function to calculate Enneadecagonal number","code":"function nthEnneadecagonal ( n ) {"}
{"text":"Formula for finding nth Enneadecagonal number","code":"return ( 17 * n * n - 15 * n ) \/ 2 ; }"}
{"text":"Driver code","code":"let n = 6 ; document . write ( n + \" \" ) ; document . write ( nthEnneadecagonal ( n ) ) ;"}
{"text":"Utiity function","code":"function areacircumscribed ( a ) { return ( a * a * ( 3.1415 \/ 2 ) ) ; }"}
{"text":"Driver code","code":"let a = 6 ; document . write ( \" \" , areacircumscribed ( a ) ) ;"}
{"text":"Function to find the type of the item given out according to the given rules","code":"function itemType ( n ) {"}
{"text":"Stores the count of item given out at each step","code":"let count = 0 ; let day = 1 ;"}
{"text":"Iterate to find the Nth day present is given out","code":"while ( count + day * ( day + 1 ) \/ 2 < n ) {"}
{"text":"Find the number of presents given on day is day * ( day + 1 ) \/ 2","code":"count += day * ( day + 1 ) \/ 2 ; day ++ ; } for ( let type = day ; type > 0 ; type -- ) {"}
{"text":"Iterate over the type","code":"count += type ;"}
{"text":"Return the resultant type","code":"if ( count >= n ) { return type ; } } }"}
{"text":"Driver code","code":"let N = 10 ; document . write ( itemType ( N ) ) ;"}
{"text":"Linked list node","code":"class Node { constructor ( ) { this . data = 0 ; this . next = null ; } }"}
{"text":"function to Check Linked List is sorted in descending order or not","code":"function isSortedDesc ( head ) {"}
{"text":"Base cases","code":"if ( head == null head . next == null ) return true ;"}
{"text":"Check first two nodes and recursively check remaining .","code":"return head . data > head . next . data && isSortedDesc ( head . next ) ; } function newNode ( data ) { var temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; }"}
{"text":"Driver code","code":"var head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to find the maximum length continuos segment of character c after flipping at most K characters","code":"const maxLength = ( str , n , c , k ) => {"}
{"text":"Stores the maximum length","code":"let ans = - 1 ;"}
{"text":"Stores the count of char ' c '","code":"let cnt = 0 ;"}
{"text":"Start of window","code":"let left = 0 ; for ( let right = 0 ; right < n ; right ++ ) { if ( str [ right ] == c ) { cnt ++ ; }"}
{"text":"Remove the extra ' c ' from left","code":"while ( cnt > k ) { if ( str [ left ] == c ) { cnt -- ; }"}
{"text":"Increment the value of the left","code":"left ++ ; }"}
{"text":"Update the resultant maximum length of character ch","code":"ans = Math . max ( ans , right - left + 1 ) ; } return ans ; }"}
{"text":"Function to find the maximum length of consecutive 0 s or 1 s by flipping at most K characters of the string","code":"const maxConsecutiveSegment = ( S , K ) => { let N = S . length ;"}
{"text":"Print the maximum of the maximum length of 0 s or 1 s","code":"return Math . max ( maxLength ( S , N , ' ' , K ) , maxLength ( S , N , ' ' , K ) ) ; }"}
{"text":"Driver Code","code":"let S = \" \" ; let K = 1 ; document . write ( maxConsecutiveSegment ( S , K ) ) ;"}
{"text":"Function to find minimum count of { 1 , 2 , 5 } valued coins required to make a change of all values in the range [ 1 , N ]","code":"function find ( N ) { var T , F , O ;"}
{"text":"Number of 5 valueds coins required","code":"F = parseInt ( ( N - 4 ) \/ 5 ) ;"}
{"text":"Number of 1 valued coins required","code":"if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; }"}
{"text":"Number of 2 valued coins required","code":"T = Math . floor ( ( N - 5 * F - O ) \/ 2 ) ; document . write ( \" \" + F + \" \" ) ; document . write ( \" \" + T + \" \" ) ; document . write ( \" \" + O + \" \" ) ; }"}
{"text":"Driver Code","code":"var N = 8 ; find ( N ) ;"}
{"text":"Function to maximize count of 0 and 10 by replacing character ' ? ' to '0' or '1'","code":"function findMaxOccurence ( str , N ) {"}
{"text":"Traverse the given string","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"If current character is ' ? '","code":"if ( str [ i ] == ' ' ) {"}
{"text":"Replace str [ i ] to '0'","code":"str [ i ] = ' ' ; } } document . write ( str . join ( ' ' ) ) ; }"}
{"text":"Given string","code":"var str = \" \" . split ( ' ' ) ; var N = str . length ; findMaxOccurence ( str , N ) ;"}
{"text":"Function checks if a given string is valid or not and prints the output","code":"function checkInfinite ( s ) {"}
{"text":"Boolean flag variable to mark if given string is valid","code":"var flag = 1 ; var N = s . length ;"}
{"text":"Traverse the given string","code":"for ( var i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"If adjacent character differ by 1","code":"if ( s [ i ] == String . fromCharCode ( ( s [ i + 1 ] . charCodeAt ( 0 ) ) + 1 ) ) { continue ; }"}
{"text":"If character ' a ' is followed by 4","code":"else if ( s [ i ] == ' ' && s [ i + 1 ] == ' ' ) { continue ; }"}
{"text":"Else flip the flag and break from the loop","code":"else { flag = 0 ; break ; } }"}
{"text":"Output according to flag variable","code":"if ( flag == 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; }"}
{"text":"Given string","code":"var s = \" \" ;"}
{"text":"Function Call","code":"checkInfinite ( s ) ;"}
{"text":"Function to find the minimum number of changes of lane required","code":"function minChangeInLane ( barrier , n ) { let dp = [ 1 , 0 , 1 ] ; for ( let j = 0 ; j < n ; j ++ ) {"}
{"text":"If there is a barrier , then add very large value","code":"let val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( let i = 0 ; i < 3 ; i ++ ) {"}
{"text":"Add the minimum value to move forword with or without crossing barrier","code":"if ( val != i + 1 ) { dp [ i ] = Math . min ( dp [ i ] , Math . min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } }"}
{"text":"Return the minimum value of dp [ 0 ] , dp [ 1 ] and dp [ 2 ]","code":"return Math . min ( dp [ 0 ] , Math . min ( dp [ 1 ] , dp [ 2 ] ) ) ; }"}
{"text":"Driver Code","code":"let barrier = [ 0 , 1 , 2 , 3 , 0 ] ; let N = barrier . length ; document . write ( minChangeInLane ( barrier , N ) ) ;"}
{"text":"Function to count number of ways to get given sum groups","code":"function numWays ( ratings , queries ) {"}
{"text":"Initialise dp array","code":"var dp = Array . from ( Array ( n ) , ( ) => Array ( 10002 ) . fill ( 0 ) ) ;"}
{"text":"Mark all 1 st row values as 1 since the mat [ 0 ] [ i ] is all possible sums in first row","code":"for ( var i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ;"}
{"text":"Fix the ith row","code":"for ( var i = 1 ; i < n ; i ++ ) {"}
{"text":"Fix the sum","code":"for ( var sum = 0 ; sum <= 10000 ; sum ++ ) {"}
{"text":"Iterate through all values of ith row","code":"for ( var j = 0 ; j < k ; j ++ ) {"}
{"text":"If sum can be obtained","code":"if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } }"}
{"text":"Find the prefix sum of last row","code":"for ( var sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; }"}
{"text":"Traverse each query","code":"for ( var q = 0 ; q < 2 ; q ++ ) { var a = queries [ q ] [ 0 ] ; var b = queries [ q ] [ 1 ] ;"}
{"text":"No of ways to form groups","code":"document . write ( dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] + \" \" ) ; } }"}
{"text":"Given n batches and k students","code":"var n = 2 ; var k = 3 ;"}
{"text":"Given ratings","code":"var ratings = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ;"}
{"text":"Given Queries","code":"var queries = [ [ 6 , 6 ] , [ 1 , 6 ] ] ;"}
{"text":"Function Call","code":"numWays ( ratings , queries ) ;"}
{"text":"Function to count permutations with K inversions","code":"function numberOfPermWithKInversion ( N , K ) {"}
{"text":"Store number of permutations with K inversions","code":"let dp = new Array ( 2 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let mod = 1000000007 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= K ; j ++ ) {"}
{"text":"If N = 1 only 1 permutation with no inversion","code":"if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; }"}
{"text":"For K = 0 only 1 permutation with no inversion","code":"else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ;"}
{"text":"Otherwise Update each dp state as per the reccurrance relation formed","code":"else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ Math . max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } }"}
{"text":"Print final count","code":"document . write ( dp [ N % 2 ] [ K ] ) ; }"}
{"text":"Given N and K","code":"let N = 3 , K = 2 ;"}
{"text":"Function Call","code":"numberOfPermWithKInversion ( N , K ) ;"}
{"text":"k is current index and col is previous color .","code":"function MaxProfit ( treasure , color , n , k , col , A , B ) { let sum = 0 ;"}
{"text":"base case","code":"if ( k == n ) return 0 ;"}
{"text":"check if color of this city is equal to prev visited city","code":"if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ;"}
{"text":"return max of both options","code":"return sum ; }"}
{"text":"Driver code","code":"let A = - 5 , B = 7 ; let treasure = [ 4 , 8 , 2 , 9 ] ; let color = [ 2 , 2 , 6 , 2 ] ; let n = color . length ;"}
{"text":"Initially begin with color 0","code":"document . write ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ;"}
{"text":"Function to return the N - th tetranacci number","code":"function printTetraRec ( n ) {"}
{"text":"base cases","code":"if ( n == 0 ) return 0 ;"}
{"text":"base cases","code":"if ( n == 1 n == 2 ) return 1 ;"}
{"text":"base cases","code":"if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; }"}
{"text":"function to print the Nth tetranacci number","code":"function printTetra ( n ) { document . write ( printTetraRec ( n ) + \" \" + \" \" ) ; }"}
{"text":"Driver code","code":"let n = 10 ; printTetra ( n ) ;"}
{"text":"to store sum of every combination","code":"let sum = 0 ; function Combination ( a , combi , n , r , depth , index ) {"}
{"text":"if we have reached sufficient depth","code":"if ( index == r ) {"}
{"text":"find the product of combination","code":"let product = 1 ; for ( let i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ;"}
{"text":"add the product into sum","code":"sum += product ; return ; }"}
{"text":"recursion to produce different combination","code":"for ( let i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } }"}
{"text":"function to print sum of products of all combination taken 1 - N at a time","code":"function allCombination ( a , n ) { for ( let i = 1 ; i <= n ; i ++ ) {"}
{"text":"creating temporary array for storing combination","code":"let combi = [ ] ;"}
{"text":"call combination with r = i for combination taken i at a time","code":"Combination ( a , combi , n , i , 0 , 0 ) ;"}
{"text":"displaying sum","code":"document . write ( \" \" + i + \" \" + sum + \" \" ) ; sum = 0 ; } }"}
{"text":"Driver code","code":"let n = 5 ; let a = [ ] ;"}
{"text":"storing numbers from 1 - N in array","code":"for ( let i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ;"}
{"text":"calling allCombination","code":"allCombination ( a , n ) ;"}
{"text":"Returns the maximum among the 2 numbers","code":"function max ( x , y ) { return ( x > y ? x : y ) ; }"}
{"text":"Returns maximum amount of task that can be done till day n","code":"function maxTasks ( high , low , n ) {"}
{"text":"An array task_dp that stores the maximum task done","code":"var task_dp = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ;"}
{"text":"If n = 0 , no solution exists","code":"task_dp [ 0 ] = 0 ;"}
{"text":"If n = 1 , high effort task on that day will be the solution","code":"task_dp [ 1 ] = high [ 0 ] ;"}
{"text":"Fill the entire array determining which task to choose on day i","code":"for ( i = 2 ; i <= n ; i ++ ) task_dp [ i ] = Math . max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }"}
{"text":"Driver code","code":"var n = 5 ; var high = [ 3 , 6 , 8 , 7 , 6 ] ; var low = [ 1 , 5 , 4 , 5 , 3 ] ; document . write ( maxTasks ( high , low , n ) ) ;"}
{"text":"A O ( n ) time and O ( 1 ) extra space solution to calculate the Permutation Coefficient","code":"function PermutationCoeff ( n , k ) { let P = 1 ;"}
{"text":"Compute n * ( n - 1 ) * ( n - 2 ) . ... ( n - k + 1 )","code":"for ( let i = 0 ; i < k ; i ++ ) P *= ( n - i ) ; return P ; }"}
{"text":"Driver code","code":"let n = 10 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + PermutationCoeff ( n , k ) ) ;"}
{"text":"Returns true if arr can be partitioned in two subsets of equal sum , otherwise false","code":"function findPartition ( arr , n ) { var sum = 0 ; var i , j ;"}
{"text":"Calculate sum of all elements","code":"for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; var part = Array ( parseInt ( sum \/ 2 ) + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ;"}
{"text":"initialize top row as true","code":"for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ;"}
{"text":"initialize leftmost column , except part [ 0 ] [ 0 ] , as 0","code":"for ( i = 1 ; i <= parseInt ( sum \/ 2 ) ; i ++ ) part [ i ] [ 0 ] = false ;"}
{"text":"Fill the partition table in bottom up manner","code":"for ( i = 1 ; i <= parseInt ( sum \/ 2 ) ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } }"}
{"text":"uncomment this part to print table","code":"return part [ parseInt ( sum \/ 2 ) ] [ n ] ; }"}
{"text":"Driver code","code":"var arr = [ 3 , 1 , 1 , 2 , 2 , 1 ] ; var n = arr . length ;"}
{"text":"Function call","code":"if ( findPartition ( arr , n ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to find the minimum operations required to get the given string after appending m or n characters from the end to the front of the string in each operation","code":"function minimumOperations ( orig_str , m , n ) {"}
{"text":"Store the original string","code":"let orig = orig_str ;"}
{"text":"Stores the count of operations","code":"let turn = 1 ; let j = 1 ;"}
{"text":"Traverse the string","code":"for ( let i = 0 ; i < orig_str . length ; i ++ ) {"}
{"text":"Cut m letters from end","code":"let m_cut = orig_str . substring ( orig_str . length - m ) ; orig_str = orig_str . substring ( 0 , orig_str . length - m ) ;"}
{"text":"Add cut m letters to beginning","code":"orig_str = m_cut + orig_str ;"}
{"text":"Update j","code":"j = j + 1 ;"}
{"text":"Check if strings are the same","code":"if ( orig != orig_str ) { turn = turn + 1 ;"}
{"text":"Cut n letters from end","code":"let n_cut = orig_str . substring ( orig_str . length - n ) ; orig_str = orig_str . substring ( 0 , orig_str . length - n ) ;"}
{"text":"Add cut n letters to beginning","code":"orig_str = n_cut + orig_str ;"}
{"text":"Update j","code":"j = j + 1 ; }"}
{"text":"Check if strings are the same","code":"if ( orig == orig_str ) { break ; }"}
{"text":"Update the turn","code":"turn = turn + 1 ; } document . write ( turn ) ; }"}
{"text":"Given string S","code":"let S = \" \" ; let X = 5 , Y = 3 ;"}
{"text":"Function Call","code":"minimumOperations ( S , X , Y ) ;"}
{"text":"Prints occurrences of txt [ ] in pat [ ]","code":"function KMPSearch ( pat , txt ) { let M = pat . length ; let N = txt . length ;"}
{"text":"Create lps [ ] that will hold the longest prefix suffix values for pattern","code":"let lps = new Array ( M ) ; lps . fill ( 0 ) ;"}
{"text":"Preprocess the pattern ( calculate lps [ ] array )","code":"computeLPSArray ( pat , M , lps ) ;"}
{"text":"Index for txt [ ] , index for pat [ ]","code":"let i = 0 ; let j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j ; }"}
{"text":"Mismatch after j matches","code":"else if ( i < N && pat [ j ] != txt [ i ] ) {"}
{"text":"Do not match lps [ 0. . lps [ j - 1 ] ] characters , they will match anyway","code":"if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; }"}
{"text":"Fills lps [ ] for given pattern pat [ 0. . M - 1 ]","code":"function computeLPSArray ( pat , M , lps ) {"}
{"text":"Length of the previous longest prefix suffix","code":"let len = 0 ;"}
{"text":"lps [ 0 ] is always 0","code":"lps [ 0 ] = 0 ;"}
{"text":"The loop calculates lps [ i ] for i = 1 to M - 1","code":"let i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; }"}
{"text":"( pat [ i ] != pat [ len ] )","code":"else {"}
{"text":"This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step .","code":"if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }"}
{"text":"Returns count of rotations to get the same string back","code":"function countRotations ( s ) {"}
{"text":"Form a string excluding the first character and concatenating the string at the end","code":"let s1 = s . substring ( 1 , s . length ) + s ;"}
{"text":"Convert the string to character array","code":"let pat = s . split ( ' ' ) ; let text = s1 . split ( ' ' ) ;"}
{"text":"Use the KMP search algorithm to find it in O ( N ) time","code":"return 1 + KMPSearch ( pat , text ) ; }"}
{"text":"Driver code","code":"let s1 = \" \" ; document . write ( countRotations ( s1 ) ) ;"}
{"text":"dfa tells the number associated with the present state","code":"let dfa = 0 ;"}
{"text":"This function is for the starting state ( zeroth ) of DFA","code":"function start ( c ) {"}
{"text":"On receiving ' T ' or ' t ' goto first state ( 1 )","code":"if ( c == ' ' c == ' ' ) dfa = 1 ; }"}
{"text":"This function is for the first state of DFA","code":"function state1 ( c ) {"}
{"text":"On receiving ' T ' or ' t ' goto first state ( 1 )","code":"if ( c == ' ' c == ' ' ) dfa = 1 ;"}
{"text":"On receiving ' H ' or ' h ' goto second state ( 2 )","code":"else if ( c == ' ' c == ' ' ) dfa = 2 ;"}
{"text":"else goto starting state ( 0 )","code":"else dfa = 0 ; }"}
{"text":"This function is for the second state of DFA","code":"function state2 ( c ) {"}
{"text":"On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 )","code":"if ( c == ' ' c == ' ' ) dfa = 3 ; else dfa = 0 ; }"}
{"text":"This function is for the third state of DFA","code":"function state3 ( c ) {"}
{"text":"On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 )","code":"if ( c == ' ' c == ' ' ) dfa = 1 ; else dfa = 0 ; } function isAccepted ( str ) {"}
{"text":"store length of string","code":"let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }"}
{"text":"Driver code","code":"let str = \" \" . split ( ' ' ) ; if ( isAccepted ( str ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"JavaScript implementation of the above approach .","code":"var parent = new Array ( 26 ) . fill ( 0 ) ;"}
{"text":"Function for find from Disjoint set algorithm","code":"function find ( x ) { if ( x !== parent [ x ] ) return ( parent [ x ] = find ( parent [ x ] ) ) ; return x ; }"}
{"text":"Function for the union from Disjoint set algorithm","code":"function join ( x , y ) { var px = find ( x ) ; var pz = find ( y ) ; if ( px !== pz ) { parent [ pz ] = px ; } }"}
{"text":"Function to check if one String can be converted to another .","code":"function convertible ( s1 , s2 ) {"}
{"text":"All the characters are checked whether it 's either not replaced or replaced  by a similar character using a map.","code":"var mp = { } ; for ( var i = 0 ; i < s1 . length ; i ++ ) { if ( ! mp . hasOwnProperty ( s1 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ) ) { mp [ s1 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] = s2 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ; } else { if ( mp [ s1 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] !== s2 [ i ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ) return false ; } }"}
{"text":"To check if there are cycles . If yes , then they are not convertible . Else , they are convertible .","code":"for ( const [ key , value ] of Object . entries ( mp ) ) { if ( key === value ) continue ; else { if ( find ( key ) == find ( value ) ) return false ; else join ( key , value ) ; } } return true ; }"}
{"text":"Function to initialize parent array for union and find algorithm .","code":"function initialize ( ) { for ( var i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } }"}
{"text":"Driver code","code":"var s1 , s2 ; s1 = \" \" ; s2 = \" \" ; initialize ( ) ; if ( convertible ( s1 , s2 ) ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"javaScript implementation of the approach","code":"let SIZE = 26 ;"}
{"text":"Function to create Sieve to check primes Function to create Sieve to check primes","code":"function SieveOfEratosthenes ( prime , p_size ) {"}
{"text":"False here indicates that it is not prime","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p , set them to non - prime","code":"for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } return prime ; }"}
{"text":"Function to print the prime frequency characters in the order of their occurrence","code":"function printChar ( str , n ) { let prime = [ ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) { prime . push ( true ) ; }"}
{"text":"Function to create Sieve to check primes","code":"prime = SieveOfEratosthenes ( prime , str . length + 1 ) ;"}
{"text":"To store the frequency of each of the character of the string","code":"let freq = [ ] ;"}
{"text":"Initialize all elements of freq [ ] to 0","code":"for ( let i = 0 ; i < 26 ; i ++ ) { freq . push ( 0 ) ; }"}
{"text":"Update the frequency of each character","code":"for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ;"}
{"text":"Traverse str character by character","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If frequency of current character is prime","code":"if ( prime [ freq [ str . charCodeAt ( i ) - 97 ] ] ) { document . write ( str [ i ] ) ; } } }"}
{"text":"Driver code","code":"let str = \" \" ; let n = str . length ; printChar ( str , n ) ;"}
{"text":"Function to check primes","code":"function prime ( n ) { if ( n <= 1 ) return false ; let max_div = Math . floor ( Math . sqrt ( n ) ) ; for ( let i = 2 ; i < 1 + max_div ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function checkString ( s ) {"}
{"text":"Counting the frequency of all character using Counter function","code":"let freq = new Map ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ! freq . has ( s [ i ] ) ) freq . set ( s [ i ] , 0 ) ; freq . set ( s [ i ] , freq . get ( s [ i ] ) + 1 ) ; }"}
{"text":"Traversing string","code":"for ( let i = 0 ; i < s . length ; i ++ ) { if ( prime ( freq . get ( s [ i ] ) ) ) document . write ( s [ i ] ) ; } }"}
{"text":"Driver code","code":"let s = \" \" ;"}
{"text":"Passing string to checkString function","code":"checkString ( s ) ;"}
{"text":"Javascript implementation of the approach","code":"let SIZE = 26 ;"}
{"text":"Function to print the even frequency characters in the order of their occurrence","code":"function printChar ( str , n ) {"}
{"text":"To store the frequency of each of the character of the string","code":"let freq = new Array ( SIZE ) ;"}
{"text":"Initialize all elements of freq [ ] to 0","code":"for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; }"}
{"text":"Update the frequency of each character","code":"for ( let i = 0 ; i < n ; i ++ ) { freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; }"}
{"text":"Traverse str character by character","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If frequency of current character is even","code":"if ( freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] % 2 == 0 ) { document . write ( str [ i ] ) ; } } }"}
{"text":"Driver code","code":"let str = \" \" ; let n = str . length ; printChar ( str , n ) ;"}
{"text":"Function to check alphanumeric equality of both strings","code":"function CompareAlphanumeric ( str1 , str2 ) {"}
{"text":"variable declaration","code":"let i , j ; i = 0 ; j = 0 ;"}
{"text":"Length of first string","code":"let len1 = str1 . length ;"}
{"text":"Length of second string","code":"let len2 = str2 . length ;"}
{"text":"To check each and every characters of both string","code":"while ( i <= len1 && j <= len2 ) {"}
{"text":"If the current character of the first string is not an alphanumeric character , increase the pointer i","code":"while ( i < len1 && ( ! ( ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str1 [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str1 [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) ) ) ) { i ++ ; }"}
{"text":"If the current character of the second string is not an alphanumeric character , increase the pointer j","code":"while ( j < len2 && ( ! ( ( str2 [ j ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str2 [ j ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str2 [ j ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str2 [ j ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) ) ) ) { j ++ ; }"}
{"text":"if all alphanumeric characters of both strings are same then return true","code":"if ( i == len1 && j == len2 ) { return true ; }"}
{"text":"if any alphanumeric characters of both strings are not same then return false","code":"else if ( str1 [ i ] != str2 [ j ] ) { return false ; }"}
{"text":"If current character matched , increase both pointers to check the next character","code":"else { i ++ ; j ++ ; } }"}
{"text":"If not same , then return false","code":"return false ; }"}
{"text":"Function to print Equal or Unequal if strings are same or not","code":"function CompareAlphanumericUtil ( str1 , str2 ) { let res ;"}
{"text":"check alphanumeric equality of both strings","code":"res = CompareAlphanumeric ( str1 . split ( ' ' ) , str2 . split ( ' ' ) ) ;"}
{"text":"if both are alphanumeric equal , print Equal","code":"if ( res == true ) { document . write ( \" \" + \" \" ) ; }"}
{"text":"otherwise print Unequal","code":"else { document . write ( \" \" ) ; } }"}
{"text":"Driver code","code":"let str1 , str2 ; str1 = \" \" ; str2 = \" \" ; CompareAlphanumericUtil ( str1 , str2 ) ; str1 = \" \" ; str2 = \" \" ; CompareAlphanumericUtil ( str1 , str2 ) ;"}
{"text":"Function that answers all the queries","code":"function solveQueries ( str , query ) {"}
{"text":"Length of the string","code":"let len = str . length ;"}
{"text":"Number of queries","code":"let Q = query . length ;"}
{"text":"Prefix array","code":"let pre = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { pre [ i ] = new Array ( 26 ) ; for ( let j = 0 ; j < 26 ; j ++ ) { pre [ i ] [ j ] = 0 ; } }"}
{"text":"Iterate for all the characters","code":"for ( let i = 0 ; i < len ; i ++ ) {"}
{"text":"Increase the count of the character","code":"pre [ i ] [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ;"}
{"text":"Presum array for all 26 characters","code":"if ( i > 0 ) {"}
{"text":"Update the prefix array","code":"for ( let j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } }"}
{"text":"Answer every query","code":"for ( let i = 0 ; i < Q ; i ++ ) {"}
{"text":"Range","code":"let l = query [ i ] [ 0 ] ; let r = query [ i ] [ 1 ] ; let maxi = 0 ; let c = ' ' ;"}
{"text":"Iterate for all characters","code":"for ( let j = 0 ; j < 26 ; j ++ ) {"}
{"text":"Times the lowercase character j occurs till r - th index","code":"let times = pre [ r ] [ j ] ;"}
{"text":"Subtract the times it occurred till ( l - 1 ) th index","code":"if ( l > 0 ) times -= pre [ l - 1 ] [ j ] ;"}
{"text":"Max times it occurs","code":"if ( times > maxi ) { maxi = times ; c = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + j ) ; } }"}
{"text":"Print the answer","code":"document . write ( \" \" + ( i + 1 ) + \" \" + c + \" \" ) ; } }"}
{"text":"Driver Code","code":"let str = \" \" ; let query = [ [ 0 , 1 ] , [ 1 , 6 ] , [ 5 , 6 ] ] ; solveQueries ( str , query ) ;"}
{"text":"Function that return true if pre is a prefix of str","code":"function startsWith ( str , pre ) { let strLen = str . length ; let preLen = pre . length ; let i = 0 , j = 0 ;"}
{"text":"While there are characters to match","code":"while ( i < strLen && j < preLen ) {"}
{"text":"If characters differ at any position","code":"if ( str [ i ] != pre [ j ] ) return false ; i ++ ; j ++ ; }"}
{"text":"str starts with pre","code":"return true ; }"}
{"text":"Function that return true if suff is a suffix of str","code":"function endsWith ( str , suff ) { let i = str . length - 1 ; let j = suff . length - 1 ;"}
{"text":"While there are characters to match","code":"while ( i >= 0 && j >= 0 ) {"}
{"text":"If characters differ at any position","code":"if ( str [ i ] != suff [ j ] ) return false ; i -- ; j -- ; }"}
{"text":"str ends with suff","code":"return true ; }"}
{"text":"Function that returns true if str = a + b or str = b + a","code":"function checkString ( str , a , b ) {"}
{"text":"str cannot be generated by concatenating a and b","code":"if ( str . length != a . length + b . length ) return false ;"}
{"text":"If str starts with a i . e . a is a prefix of str","code":"if ( startsWith ( str , a ) ) {"}
{"text":"Check if the rest of the characters are equal to b i . e . b is a suffix of str","code":"if ( endsWith ( str , b ) ) return true ; }"}
{"text":"If str starts with b i . e . b is a prefix of str","code":"if ( startsWith ( str , b ) ) {"}
{"text":"Check if the rest of the characters are equal to a i . e . a is a suffix of str","code":"if ( endsWith ( str , a ) ) return true ; } return false ; }"}
{"text":"Driver code","code":"let str = \" \" ; let a = \" \" ; let b = \" \" ; if ( checkString ( str , a , b ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"javascript implementation of the approach","code":"let SIZE = 26 ;"}
{"text":"Function to print the odd frequency characters in the order of their occurrence","code":"function printChar ( str , n ) {"}
{"text":"To store the frequency of each of the character of the string","code":"let freq = [ ] ;"}
{"text":"Initialize all elements of freq [ ] to 0","code":"for ( let i = 0 ; i < SIZE ; i ++ ) { freq . push ( 0 ) ; }"}
{"text":"Update the frequency of each character","code":"for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ;"}
{"text":"Traverse str character by character","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If frequency of current character is odd","code":"if ( freq [ str . charCodeAt ( i ) - 97 ] % 2 == 1 ) { document . write ( str [ i ] ) ; } } }"}
{"text":"Driver code","code":"let str = \" \" ; let n = str . length ; printChar ( str , n ) ;"}
{"text":"JavaScript implementation of the approach Check UpperCase","code":"function isupper ( str ) { return str === str . toUpperCase ( ) ; }"}
{"text":"Function to return the minimum number of operations required","code":"function minOperations ( str , n ) {"}
{"text":"To store the indices of the last uppercase and the first lowercase character","code":"var i , lastUpper = - 1 , firstLower = - 1 ;"}
{"text":"Find the last uppercase character","code":"for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } }"}
{"text":"Find the first lowercase character","code":"for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } }"}
{"text":"If all the characters are either uppercase or lowercase","code":"if ( lastUpper === - 1 firstLower === - 1 ) return 0 ;"}
{"text":"Count of uppercase characters that appear after the first lowercase character","code":"var countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } }"}
{"text":"Count of lowercase characters that appear before the last uppercase character","code":"var countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } }"}
{"text":"Return the minimum operations required","code":"return Math . min ( countLower , countUpper ) ; }"}
{"text":"Driver Code","code":"var str = \" \" ; var n = str . length ; document . write ( minOperations ( str , n ) + \" \" ) ;"}
{"text":"Function to find the sum of the all betrothed numbers","code":"function Betrothed_Sum ( n ) {"}
{"text":"To store the betrothed numbers","code":"let Set = [ ] ; for ( let number_1 = 1 ; number_1 < n ; number_1 ++ ) {"}
{"text":"Calculate sum of number_1 's divisors  1 is always a divisor","code":"let sum_divisor_1 = 1 ;"}
{"text":"i = 2 because we don 't  want to include  1 as a divisor.","code":"let i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += parseInt ( number_1 \/ i ) ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { let number_2 = sum_divisor_1 - 1 ; let sum_divisor_2 = 1 ; let j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += parseInt ( number_2 \/ j ) ; } j = j + 1 ; } if ( ( sum_divisor_2 == number_1 + 1 ) && number_1 <= n && number_2 <= n ) { Set . push ( number_1 ) ; Set . push ( number_2 ) ; } } }"}
{"text":"Sum all betrothed numbers up to N","code":"let Summ = 0 ; for ( let i = 0 ; i < Set . length ; i ++ ) { if ( Set [ i ] <= n ) Summ += Set [ i ] ; } return Summ ; }"}
{"text":"Driver code","code":"let n = 78 ; document . write ( Betrothed_Sum ( n ) ) ;"}
{"text":"Function to find the probability","code":"function rainDayProbability ( a , n ) { let count = 0 , m ;"}
{"text":"count 1","code":"for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; }"}
{"text":"find probability","code":"m = count \/ n ; return m ; }"}
{"text":"Driver Code","code":"let a = [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] ; let n = a . length ; document . write ( rainDayProbability ( a , n ) ) ;"}
{"text":"Function to calculate the following series","code":"function Series ( n ) { let sums = 0.0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { ser = 1 \/ Math . pow ( i , i ) ; sums += ser ; } return sums ; }"}
{"text":"Driver Code","code":"let n = 3 ; let res = Math . round ( Series ( n ) * 100000 ) \/ 100000 ; document . write ( res ) ;"}
{"text":"Function to print the lexicographically the largest string obtained in process of obtaining a string containing first N lower case english alphabtes","code":"function lexicographicallyMaximum ( S , N ) {"}
{"text":"Store the frequency of each character","code":"let M = new Map ( ) ;"}
{"text":"Traverse the string S","code":"for ( let i = 0 ; i < N ; ++ i ) { if ( M . has ( S [ i ] ) ) M . set ( S [ i ] , M . get ( S [ i ] ) + 1 ) ; else M . set ( S [ i ] , 1 ) ; }"}
{"text":"Stores the characters which are not appearing in S","code":"let V = [ ] ; for ( let i = ' ' . charCodeAt ( ) ; i < ( ' ' . charCodeAt ( ) + Math . min ( N , 25 ) ) ; ++ i ) { if ( M . has ( String . fromCharCode ( i ) ) == false ) { V . push ( String . fromCharCode ( i ) ) ; } }"}
{"text":"Stores the index of the largest character in the array V , that need to be replaced","code":"let j = V . length - 1 ;"}
{"text":"Traverse the string , S","code":"for ( let i = 0 ; i < N ; ++ i ) {"}
{"text":"If frequency of S [ i ] is greater than 1 or it is outside the range","code":"if ( S [ i ] . charCodeAt ( ) >= ( ' ' . charCodeAt ( ) + Math . min ( N , 25 ) ) || ( M . has ( S [ i ] ) && M . get ( S [ i ] ) > 1 ) ) { if ( V [ j ] . charCodeAt ( ) < S [ i ] . charCodeAt ( ) ) continue ;"}
{"text":"Decrement its frequency by 1","code":"M . set ( S [ i ] , M . get ( S [ i ] ) - 1 ) ;"}
{"text":"Update S [ i ]","code":"S = S . substr ( 0 , i ) + V [ j ] + S . substr ( i + 1 ) ;"}
{"text":"Decrement j by 1","code":"j -- ; } if ( j < 0 ) break ; } let l = 0 ;"}
{"text":"Traverse the string , S","code":"for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] . charCodeAt ( ) >= ( ' ' . charCodeAt ( ) + Math . min ( N , 25 ) ) || M . has ( S [ i ] ) && M . get ( S [ i ] ) > 1 ) {"}
{"text":"Decrement its frequency by 1","code":"M . set ( S [ i ] , M . get ( S [ i ] ) - 1 ) ;"}
{"text":"Update S [ i ]","code":"S = S . substr ( 0 , i ) + V [ l ] + S . substr ( i + 1 ) ;"}
{"text":"Increment l by 1","code":"l ++ ; } }"}
{"text":"Return S","code":"return S ; }"}
{"text":"Given Input","code":"let S = \" \" ; let N = S . length ;"}
{"text":"Function Call","code":"document . write ( lexicographicallyMaximum ( S , N ) ) ;"}
{"text":"A Utility Function to check if a subarray can be palindromic by replacing less than half of the elements present in it","code":"function isConsistingSubarrayUtil ( arr , n ) {"}
{"text":"Stores frequency of array elements","code":"var mp = new Map ( ) ;"}
{"text":"Traverse the array","code":"for ( var i = 0 ; i < n ; ++ i ) {"}
{"text":"Update frequency of each array element","code":"if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } var ans = false ;"}
{"text":"Iterator over the Map","code":"mp . forEach ( ( value , key ) => {"}
{"text":"If frequency of any element exceeds 1","code":"if ( value > 1 ) { ans = true ; } } ) ; if ( ans ) return true ;"}
{"text":"If no repetition is found","code":"return false ; }"}
{"text":"Function to check and print if any subarray can be made palindromic by replacing less than half of its elements","code":"function isConsistingSubarray ( arr , N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } }"}
{"text":"Given array arr [ ]","code":"var arr = [ 1 , 2 , 3 , 4 , 5 , 1 ] ;"}
{"text":"Size of array","code":"var N = arr . length ;"}
{"text":"Function Call","code":"isConsistingSubarray ( arr , N ) ;"}
{"text":"Function to find all Fibonacci numbers up to Max","code":"function createhashmap ( Max ) {"}
{"text":"Store all Fibonacci numbers upto Max","code":"var hashmap = new Set ( ) ;"}
{"text":"Stores previous element of Fibonacci sequence","code":"var curr = 1 ;"}
{"text":"Stores previous element of Fibonacci sequence","code":"var prev = 0 ;"}
{"text":"Insert prev into hashmap","code":"hashmap . add ( prev ) ;"}
{"text":"Insert all the Fibonacci numbers up to Max","code":"while ( curr <= Max ) {"}
{"text":"Insert curr into hashmap","code":"hashmap . add ( curr ) ;"}
{"text":"Stores curr into temp","code":"var temp = curr ;"}
{"text":"Update curr","code":"curr = curr + prev ;"}
{"text":"Update prev","code":"prev = temp ; } return hashmap ; }"}
{"text":"Function to find all Composite numbers up to Max","code":"function SieveOfEratosthenes ( Max ) {"}
{"text":"isPrime [ i ] : Stores if i is a prime number or not","code":"var isPrime = Array ( Max + 1 ) . fill ( true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ;"}
{"text":"Calculate all prime numbers up to Max using Sieve of Eratosthenes","code":"for ( var p = 2 ; p * p <= Max ; p ++ ) {"}
{"text":"If P is a prime number","code":"if ( isPrime [ p ] ) {"}
{"text":"Set all multiple of P as non - prime","code":"for ( var i = p * p ; i <= Max ; i += p ) {"}
{"text":"Update isPrime","code":"isPrime [ i ] = false ; } } } return isPrime ; }"}
{"text":"Function to find the numbers which is both a composite and Fibonacci number","code":"function cntFibonacciPrime ( arr , N ) {"}
{"text":"Stores the largest element of the array","code":"var Max = arr [ 0 ] ;"}
{"text":"Traverse the array arr [ ]","code":"for ( var i = 1 ; i < N ; i ++ ) {"}
{"text":"Update Max","code":"Max = Math . max ( Max , arr [ i ] ) ; }"}
{"text":"isPrim [ i ] check i is a prime number or not","code":"var isPrime = SieveOfEratosthenes ( Max ) ;"}
{"text":"Stores all the Fibonacci numbers","code":"var hashmap = createhashmap ( Max ) ;"}
{"text":"Traverse the array arr [ ]","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"current element is not a composite number","code":"if ( arr [ i ] == 1 ) continue ;"}
{"text":"If current element is a Fibonacci and composite number","code":"if ( hashmap . has ( arr [ i ] ) && ! isPrime [ arr [ i ] ] ) {"}
{"text":"Print current element","code":"document . write ( arr [ i ] + \" \" ) ; } } }"}
{"text":"Driver Code","code":"var arr = [ 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 ] ; var N = arr . length ; cntFibonacciPrime ( arr , N ) ;"}
{"text":"Function to find the key of the given number","code":"function key ( N ) {"}
{"text":"Convert the integer to String","code":"let num = \" \" + N . toString ( ) ; let ans = 0 ; let j = 0 ;"}
{"text":"Iterate the num - string to get the result","code":"for ( j = 0 ; j < num . length ; j ++ ) {"}
{"text":"Check if digit is even or odd","code":"if ( ( num [ j ] . charCodeAt ( ) - 48 ) % 2 == 0 ) { let add = 0 ; let i ;"}
{"text":"Iterate until odd sum is obtained by adding consecutive digits","code":"for ( i = j ; j < num . length ; j ++ ) { add += num [ j ] . charCodeAt ( ) - 48 ;"}
{"text":"Check if sum becomes odd","code":"if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { let digit = Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= parseInt ( Math . pow ( 10 , digit ) , 10 ) ;"}
{"text":"Add the result in ans","code":"ans += add ; }"}
{"text":"Assign the digit index to num string","code":"i = j ; } else {"}
{"text":"If the number is odd","code":"let add = 0 ; let i ;"}
{"text":"Iterate until odd sum is obtained by adding consecutive digits","code":"for ( i = j ; j < num . length ; j ++ ) { add += num [ j ] . charCodeAt ( ) - 48 ;"}
{"text":"Check if sum becomes even","code":"if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { let digit = Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= parseInt ( Math . pow ( 10 , digit ) , 10 ) ;"}
{"text":"Add the result in ans","code":"ans += add ; }"}
{"text":"assign the digit index to main numstring","code":"i = j ; } }"}
{"text":"Check if all digits are visited or not","code":"if ( j + 1 >= num . length ) { return ans ; } else { return ans += num [ num . length - 1 ] . charCodeAt ( ) - 48 ; } }"}
{"text":"Driver Code","code":"let N = 1667848271 ; document . write ( key ( N ) ) ;"}
{"text":"Function to search x in the given array","code":"function sentinelSearch ( arr , n , key ) {"}
{"text":"Last element of the array","code":"var last = arr [ n - 1 ] ;"}
{"text":"Element to be searched is placed at the last index","code":"arr [ n - 1 ] = key ; var i = 0 ; while ( arr [ i ] != key ) i ++ ;"}
{"text":"Put the last element back","code":"arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) document . write ( key + \" \" + i ) ; else document . write ( \" \" ) ; }"}
{"text":"Driver code","code":"var arr = [ 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 ] ; var n = arr . length ; var key = 180 ; sentinelSearch ( arr , n , key ) ;"}
{"text":"Function to calculate maximum possible middle value of the array after deleting exactly k elements","code":"function maximum_middle_value ( n , k , arr ) {"}
{"text":"Initialize answer as - 1","code":"let ans = - 1 ;"}
{"text":"Calculate range of elements that can give maximum possible middle value of the array since index of maximum possible middle value after deleting exactly k elements from array will lie in between low and high","code":"let low = Math . floor ( ( n + 1 - k ) \/ 2 ) ; let high = Math . floor ( ( ( n + 1 - k ) \/ 2 ) + k ) ;"}
{"text":"Find maximum element of the array in range low and high","code":"for ( let i = low ; i <= high ; i ++ ) {"}
{"text":"since indexing is 1 based so check element at index i - 1","code":"ans = Math . max ( ans , arr [ i - 1 ] ) ; }"}
{"text":"Return the maximum possible middle value of the array after deleting exactly k elements from the array","code":"return ans ; }"}
{"text":"Driver Code","code":"let n = 5 , k = 2 ; let arr = [ 9 , 5 , 3 , 7 , 10 ] ; document . write ( maximum_middle_value ( n , k , arr ) + \" \" ) ; n = 9 ; k = 3 ; let arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] ; document . write ( maximum_middle_value ( n , k , arr1 ) + \" \" ) ;"}
{"text":"Function to perform Ternary Search","code":"function ternarySearch ( l , r , key , ar ) { if ( r >= l ) {"}
{"text":"Find the mid1 and mid2","code":"let mid1 = l + parseInt ( ( r - l ) \/ 3 , 10 ) ; let mid2 = r - parseInt ( ( r - l ) \/ 3 , 10 ) ;"}
{"text":"Check if key is present at any mid","code":"if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }"}
{"text":"Since key is not present at mid , check in which region it is present then repeat the Search operation in that region","code":"if ( key < ar [ mid1 ] ) {"}
{"text":"The key lies in between l and mid1","code":"return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) {"}
{"text":"The key lies in between mid2 and r","code":"return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else {"}
{"text":"The key lies in between mid1 and mid2","code":"return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } }"}
{"text":"Key not found","code":"return - 1 ; } let l , r , p , key ;"}
{"text":"Get the array Sort the array if not sorted","code":"let ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ;"}
{"text":"Starting index","code":"l = 0 ;"}
{"text":"length of array","code":"r = 9 ;"}
{"text":"Key to be searched in the array","code":"key = 5 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"document . write ( \" \" + key + \" \" + p + \" \" ) ;"}
{"text":"Key to be searched in the array","code":"key = 50 ;"}
{"text":"Search the key using ternarySearch","code":"p = ternarySearch ( l , r , key , ar ) ;"}
{"text":"Print the result","code":"document . write ( \" \" + key + \" \" + p ) ;"}
{"text":"Function to find the minimum number of points","code":"function findmin ( p , n ) { let a = 0 , b = 0 , c = 0 , d = 0 ; for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"Number of points on the left of Y - axis .","code":"if ( p [ i ] [ 0 ] <= 0 ) a ++ ;"}
{"text":"Number of points on the right of Y - axis .","code":"else if ( p [ i ] [ 0 ] >= 0 ) b ++ ;"}
{"text":"Number of points above X - axis .","code":"if ( p [ i ] [ 1 ] >= 0 ) c ++ ;"}
{"text":"Number of points below X - axis .","code":"else if ( p [ i ] [ 1 ] <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }"}
{"text":"Driver Code","code":"let p = [ [ 1 , 1 ] , [ 2 , 2 ] , [ - 1 , - 1 ] , [ - 2 , 2 ] ] let n = p . length ; document . write ( findmin ( p , n ) ) ;"}
{"text":"Function to count the maximum number of pair reductions possible on a given triplet","code":"function maxOps ( a , b , c ) {"}
{"text":"Convert them into an array","code":"let arr = [ a , b , c ] ;"}
{"text":"Stores count of operations","code":"let count = 0 ; while ( 1 ) {"}
{"text":"Sort the array","code":"arr . sort ( ) ;"}
{"text":"If the first two array elements reduce to 0","code":"if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ;"}
{"text":"Apply the operations","code":"arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ;"}
{"text":"Increment count","code":"count += 1 ; }"}
{"text":"Print the maximum count","code":"document . write ( count ) ; }"}
{"text":"Given triplet","code":"let a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ;"}
{"text":"Javascript implementation of the approach","code":"var MAX = 26 ;"}
{"text":"Function to return the sorted string","code":"function getSortedString ( s , n ) {"}
{"text":"To store the frequencies of the lowercase and the uppercase characters in the given string","code":"var lower = Array ( MAX ) . fill ( 0 ) ; var upper = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"If current character is lowercase then increment its frequency in the lower [ ] array","code":"if ( ( s [ i ] ) == s [ i ] . toLowerCase ( ) ) lower [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ;"}
{"text":"Else increment in the upper [ ] array","code":"else if ( s [ i ] = s [ i ] . toUpperCase ( ) ) upper [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; }"}
{"text":"Pointers that point to the smallest lowercase and the smallest uppercase characters respectively in the given string","code":"var i = 0 , j = 0 ; while ( i < MAX && lower [ i ] == 0 ) i ++ ; while ( j < MAX && upper [ j ] == 0 ) j ++ ;"}
{"text":"For every character in the given string","code":"for ( var k = 0 ; k < n ; k ++ ) {"}
{"text":"If the current character is lowercase then replace it with the smallest lowercase character available","code":"if ( s [ k ] == s [ k ] . toLowerCase ( ) ) { while ( lower [ i ] == 0 ) i ++ ; s [ k ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ;"}
{"text":"Decrement the frequency of the used character","code":"lower [ i ] -- ; }"}
{"text":"Else replace it with the smallest uppercase character available","code":"else if ( s [ k ] == s [ k ] . toUpperCase ( ) ) { while ( upper [ j ] == 0 ) j ++ ; s [ k ] = String . fromCharCode ( j + ' ' . charCodeAt ( 0 ) ) ;"}
{"text":"Decrement the frequency of the used character","code":"upper [ j ] -- ; } }"}
{"text":"Return the sorted string","code":"return s . join ( ' ' ) ; }"}
{"text":"Driver code","code":"var s = \" \" ; var n = s . length ; document . write ( getSortedString ( s . split ( ' ' ) , n ) ) ;"}
{"text":"Javascript implementation to print the character and its frequency in order of its occurrence","code":"let SIZE = 26 ;"}
{"text":"function to print the character and its frequency in order of its occurrence","code":"function printCharWithFreq ( str ) {"}
{"text":"size of the string ' str '","code":"let n = str . length ;"}
{"text":"' freq [ ] ' implemented as hash table","code":"let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; }"}
{"text":"accumulate frequency of each character in ' str '","code":"for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ;"}
{"text":"traverse ' str ' from left to right","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"if frequency of character str . charAt ( i ) is not equal to 0","code":"if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) {"}
{"text":"print the character along with its frequency","code":"document . write ( str [ i ] ) ; document . write ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] + \" \" ) ;"}
{"text":"update frequency of str . charAt ( i ) to 0 so that the same character is not printed again","code":"freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; } } }"}
{"text":"Driver program to test above","code":"let str = \" \" ; printCharWithFreq ( str ) ;"}
{"text":"JavaScript program to reverse a string","code":"var s = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; var ans = \" \" ; for ( var i = 5 ; i >= 0 ; i -- ) { ans += s [ i ] + \" \" ; } document . write ( \" \" + \" \" ) ; document . write ( ans . slice ( 0 , ans . length - 1 ) ) ;"}
{"text":"Function to generate prime numbers using Sieve of Eratosthenes","code":"function SieveOfEratosthenes ( prime , n ) { for ( let p = 2 ; p * p <= n ; p ++ ) {"}
{"text":"If prime [ p ] is unchanged , then it is a prime","code":"if ( prime [ p ] == true ) {"}
{"text":"Update all multiples of p","code":"for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to segregate the primes and non - primes","code":"function segregatePrimeNonPrime ( prime , arr , N ) {"}
{"text":"Generate all primes till 10 ^","code":"SieveOfEratosthenes ( prime , 10000000 ) ;"}
{"text":"Initialize left and right","code":"let left = 0 , right = N - 1 ;"}
{"text":"Traverse the array","code":"while ( left < right ) {"}
{"text":"Increment left while array element at left is prime","code":"while ( prime [ arr [ left ] ] ) left ++ ;"}
{"text":"Decrement right while array element at right is non - prime","code":"while ( ! prime [ arr [ right ] ] ) right -- ;"}
{"text":"If left < right , then swap arr [ left ] and arr [ right ]","code":"if ( left < right ) {"}
{"text":"Swap arr [ left ] and arr [ right ]","code":"let temp = arr [ left ] ; arr [ left ] = arr [ right ] ; arr [ right ] = temp ; left ++ ; right -- ; } }"}
{"text":"Print segregated array","code":"for ( let i = 0 ; i < N ; i ++ ) document . write ( arr [ i ] + \" \" ) ; }"}
{"text":"Driver Code","code":"let prime = Array . from ( { length : 10000001 } , ( _ , i ) => true ) ; let arr = [ 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 ] ; let N = arr . length ;"}
{"text":"Function Call","code":"segregatePrimeNonPrime ( prime , arr , N ) ;"}
{"text":"function to return max of left subtree height or right subtree height","code":"function findDepthRec ( tree , n , index ) { if ( index >= n tree [ index ] == ' ' ) return 0 ;"}
{"text":"calc height of left subtree ( In preorder left subtree is processed before right )","code":"index ++ ; let left = findDepthRec ( tree , n , index ) ;"}
{"text":"calc height of right subtree","code":"index ++ ; let right = findDepthRec ( tree , n , index ) ; return Math . max ( left , right ) + 1 ; }"}
{"text":"Wrapper over findDepthRec ( )","code":"function findDepth ( tree , n ) { let index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; }"}
{"text":"Driver program","code":"let tree = \" \" . split ( ' ' ) ; let n = tree . length ; document . write ( findDepth ( tree , n ) ) ;"}
{"text":"Node structure","code":"class Node { constructor ( ) { this . key = 0 ; this . left = null , this . right = null ; } }"}
{"text":"To create new BST Node","code":"function newNode ( item ) { var temp = new Node ( ) ; temp . key = item ; temp . left = null ; temp . right = null ; return temp ; }"}
{"text":"To insert a new node in BST","code":"function insert ( node , key ) {"}
{"text":"if tree is empty return new node","code":"if ( node == null ) return newNode ( key ) ;"}
{"text":"if key is less then or greater then node value then recur down the tree","code":"if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ;"}
{"text":"return the ( unchanged ) node pointer","code":"return node ; }"}
{"text":"function to find max value less then N","code":"function findMaxforN ( root , N ) {"}
{"text":"Base cases","code":"if ( root == null ) return - 1 ; if ( root . key == N ) return N ;"}
{"text":"If root 's value is smaller, try in right  subtree","code":"else if ( root . key < N ) { var k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; }"}
{"text":"If root 's key is greater, return value  from left subtree.","code":"else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return - 1 ; }"}
{"text":"Driver code","code":"var N = 4 ;"}
{"text":"creating following BST * 5 \/ \\ 2 12 \/ \\ \/ \\ 1 3 9 21 \/ \\ 19 25","code":"var root = null ; root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; document . write ( findMaxforN ( root , N ) ) ;"}
{"text":"JavaScript program to find maximum element in the path between two Nodes of Binary Search Tree .","code":"class Node { constructor ( val ) { this . data = val ; this . left = null ; this . right = null ; } }"}
{"text":"Create and return a pointer of new Node .","code":"function createNode ( x ) { var p = new Node ( ) ; p . data = x ; p . left = p . right = null ; return p ; }"}
{"text":"Insert a new Node in Binary Search Tree .","code":"function insertNode ( root , x ) { var p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } }"}
{"text":"Return the maximum element between a Node and its given ancestor .","code":"function maxelpath ( q , x ) { var p = q ; var mx = - 1 ;"}
{"text":"Traversing the path between ansector and Node and finding maximum element .","code":"while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; }"}
{"text":"Return maximum element in the path between two given Node of BST .","code":"function maximumElement ( root , x , y ) { var p = root ;"}
{"text":"Finding the LCA of Node x and Node y","code":"while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) {"}
{"text":"Checking if both the Node lie on the left side of the parent p .","code":"if ( x < p . data && y < p . data ) p = p . left ;"}
{"text":"Checking if both the Node lie on the right side of the parent p .","code":"else if ( x > p . data && y > p . data ) p = p . right ; }"}
{"text":"Return the maximum of maximum elements occur in path from ancestor to both Node .","code":"return Math . max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; }"}
{"text":"Driver Code","code":"var arr = [ 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 ] ; var a = 1 , b = 10 ; var n = arr . length ;"}
{"text":"Creating the root of Binary Search Tree","code":"var root = createNode ( arr [ 0 ] ) ;"}
{"text":"Inserting Nodes in Binary Search Tree","code":"for ( i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; document . write ( maximumElement ( root , a , b ) ) ;"}
{"text":"javascript program Insertion in Threaded Binary Search Tree .","code":"class Node { constructor ( ) { this . left = null , this . right = null ; this . info = 0 ;"}
{"text":"True if left pointer points to predecessor in Inorder Traversal","code":"this . lthread = false ;"}
{"text":"True if right pointer points to successor in Inorder Traversal","code":"this . rthread = false ; } }"}
{"text":"Insert a Node in Binary Threaded Tree","code":"function insert ( root , ikey ) {"}
{"text":"Searching for a Node with given value","code":"var ptr = root ;"}
{"text":"Parent of key to be inserted","code":"var par = null ; while ( ptr != null ) {"}
{"text":"If key already exists , return","code":"if ( ikey == ( ptr . info ) ) { document . write ( \" \" ) ; return root ; }"}
{"text":"Update parent pointer","code":"par = ptr ;"}
{"text":"Moving on left subtree .","code":"if ( ikey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; }"}
{"text":"Moving on right subtree .","code":"else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } }"}
{"text":"Create a new node","code":"var tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; }"}
{"text":"Returns inorder successor using rthread","code":"function inorderSuccessor ( ptr ) {"}
{"text":"If rthread is set , we can quickly find","code":"if ( ptr . rthread == true ) return ptr . right ;"}
{"text":"Else return leftmost child of right subtree","code":"ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; }"}
{"text":"Printing the threaded tree","code":"function inorder ( root ) { if ( root == null ) document . write ( \" \" ) ;"}
{"text":"Reach leftmost node","code":"var ptr = root ; while ( ptr . lthread == false ) ptr = ptr . left ;"}
{"text":"One by one prvar successors","code":"while ( ptr != null ) { document . write ( ptr . info + \" \" ) ; ptr = inorderSuccessor ( ptr ) ; } }"}
{"text":"Driver Program","code":"var root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ;"}
{"text":"True if left pointer points to predecessor in Inorder Traversal","code":"this . lthread = false ;"}
{"text":"True if right pointer points to predecessor in Inorder Traversal","code":"this . rthread = false ; } }"}
{"text":"Javascript program to find if a matrix is symmetric .","code":"function checkHV ( arr , N , M ) {"}
{"text":"Initializing as both horizontal and vertical symmetric .","code":"let horizontal = true ; let vertical = true ;"}
{"text":"Checking for Horizontal Symmetry . We compare first row with last row , second row with second last row and so on .","code":"for ( let i = 0 , k = N - 1 ; i < parseInt ( N \/ 2 , 10 ) ; i ++ , k -- ) {"}
{"text":"Checking each cell of a column .","code":"for ( let j = 0 ; j < M ; j ++ ) {"}
{"text":"check if every cell is identical","code":"if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } }"}
{"text":"Checking for Vertical Symmetry . We compare first column with last column , second xolumn with second last column and so on .","code":"for ( let i = 0 , k = M - 1 ; i < parseInt ( M \/ 2 , 10 ) ; i ++ , k -- ) {"}
{"text":"Checking each cell of a row .","code":"for ( let j = 0 ; j < N ; j ++ ) {"}
{"text":"check if every cell is identical","code":"if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) document . write ( \" \" ) ; else if ( horizontal && ! vertical ) document . write ( \" \" ) ; else if ( vertical && ! horizontal ) document . write ( \" \" ) ; else document . write ( \" \" ) ; }"}
{"text":"Driver Code","code":"let mat = [ [ 1 , 0 , 1 ] , [ 0 , 0 , 0 ] , [ 1 , 0 , 1 ] ] ; checkHV ( mat , 3 , 3 ) ;"}
{"text":"Javascript program to replace each each element with maximum of GCD of row or column .","code":"let R = 3 ; let C = 4 ;"}
{"text":"returning the greatest common divisor of two number","code":"function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }"}
{"text":"Finding GCD of each row and column and replacing with each element with maximum of GCD of row or column .","code":"function replacematrix ( mat , n , m ) { let rgcd = new Array ( R ) ; rgcd . fill ( 0 ) ; let cgcd = new Array ( C ) ; cgcd . fill ( 0 ) ;"}
{"text":"Calculating GCD of each row and each column in O ( mn ) and store in arrays .","code":"for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } }"}
{"text":"Replacing matrix element","code":"for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rgcd [ i ] , cgcd [ j ] ) ; }"}
{"text":"Driver program","code":"let m = [ [ 1 , 2 , 3 , 3 ] , [ 4 , 5 , 6 , 6 ] , [ 7 , 8 , 9 , 9 ] ] ; replacematrix ( m , R , C ) ; for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) document . write ( m [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text":"Javascript program for addition of two matrices","code":"let N = 4 ;"}
{"text":"This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ]","code":"function add ( A , B , C ) { let i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }"}
{"text":"Driver code","code":"let A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let C = new Array ( N ) ; for ( let k = 0 ; k < N ; k ++ ) C [ k ] = new Array ( N ) ; let i , j ; add ( A , B , C ) ; document . write ( \" \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text":"Javascript program for subtraction of matrices","code":"var N = 4 ;"}
{"text":"This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ]","code":"function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }"}
{"text":"Driver code","code":"var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( \" \" + \" \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; }"}
{"text":"JavaScript program to check fixed point in an array using linear search","code":"function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; }"}
{"text":"If no fixed point present then return - 1","code":"return - 1 ; }"}
{"text":"Driver Code","code":"let arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] ; let n = arr . length ; document . write ( \" \" + linearSearch ( arr , n ) ) ;"}
{"text":"javascript program to check fixed point in an array using binary search","code":"function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = Math . floor ( ( low + high ) \/ 2 ) ;"}
{"text":"low + ( high - low ) \/ 2 ;","code":"if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; }"}
{"text":"Return - 1 if there is no Fixed Point","code":"return - 1 ; }"}
{"text":"Driver program","code":"let arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] ; let n = arr . length ; document . write ( \" \" + binarySearch ( arr , 0 , n - 1 ) ) ;"}
{"text":"JavaScript Program to find maximum triplet sum","code":"function maxTripletSum ( arr , n ) {"}
{"text":"Initialize sum with INT_MIN","code":"let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] ; let n = arr . length ; document . write ( maxTripletSum ( arr , n ) ) ;"}
{"text":"This function assumes that there are at least three elements in arr [ ] .","code":"function maxTripletSum ( arr , n ) {"}
{"text":"sort the given array","code":"arr . sort ( ) ;"}
{"text":"After sorting the array . Add last three element of the given array","code":"return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }"}
{"text":"Driven code","code":"let arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] ; let n = arr . length ; document . write ( maxTripletSum ( arr , n ) ) ;"}
{"text":"This function assumes that there are at least three elements in arr [ ] .","code":"function maxTripletSum ( arr , n ) {"}
{"text":"Initialize Maximum , second maximum and third maximum element","code":"let maxA = Number . MIN_SAFE_INTEGER ; let maxB = Number . MIN_SAFE_INTEGER ; let maxC = Number . MIN_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"Update Maximum , second maximum and third maximum element","code":"if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; }"}
{"text":"Update second maximum and third maximum element","code":"else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; }"}
{"text":"Update third maximum element","code":"else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }"}
{"text":"Driven code","code":"let arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] ; let n = arr . length ; document . write ( maxTripletSum ( arr , n ) ) ;"}
{"text":"Javascript code to linearly search x in arr [ ] . If x is present then return its location , otherwise return - 1","code":"function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }"}
{"text":"Driver code","code":"let arr = [ 2 , 3 , 4 , 10 , 40 ] ; let x = 10 ; let n = arr . length ;"}
{"text":"Function call","code":"let result = search ( arr , n , x ) ; ( result == - 1 ) ? document . write ( \" \" ) : document . write ( \" \" + result ) ;"}
{"text":"Javascript program for linear search","code":"function search ( arr , search_Element ) { let left = 0 ; let length = arr . length ; let right = length - 1 ; let position = - 1 ;"}
{"text":"Run loop from 0 to right","code":"for ( left = 0 ; left <= right ; ) {"}
{"text":"If search_element is found with left variable","code":"if ( arr [ left ] == search_Element ) { position = left ; document . write ( \" \" + ( position + 1 ) + \" \" + ( left + 1 ) + \" \" ) ; break ; }"}
{"text":"If search_element is found with right variable","code":"if ( arr [ right ] == search_Element ) { position = right ; document . write ( \" \" + ( position + 1 ) + \" \" + ( length - right ) + \" \" ) ; break ; } left ++ ; right -- ; }"}
{"text":"If element not found","code":"if ( position == - 1 ) document . write ( \" \" + left + \" \" ) ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let search_element = 5 ;"}
{"text":"Function call","code":"search ( arr , search_element ) ;"}
{"text":"The main function that sort the given string arr [ ] in alphabetical order","code":"function sort ( arr ) { var n = arr . length ;"}
{"text":"The output character array that will have sorted arr","code":"var output = Array . from ( { length : n } , ( _ , i ) => 0 ) ;"}
{"text":"Create a count array to store count of inidividul characters and initialize count array as 0","code":"var count = Array . from ( { length : 256 } , ( _ , i ) => 0 ) ;"}
{"text":"store count of each character","code":"for ( var i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] . charCodeAt ( 0 ) ] ;"}
{"text":"Change count [ i ] so that count [ i ] now contains actual position of this character in output array","code":"for ( var i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ;"}
{"text":"Build the output character array To make it stable we are operating in reverse order .","code":"for ( var i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] . charCodeAt ( 0 ) ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] . charCodeAt ( 0 ) ] ; }"}
{"text":"Copy the output array to arr , so that arr now contains sorted characters","code":"for ( var i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; return arr ; }"}
{"text":"Driver method","code":"var arr = [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] ; arr = sort ( arr ) ; document . write ( \" \" ) ; for ( var i = 0 ; i < arr . length ; ++ i ) document . write ( arr [ i ] ) ; cript"}
{"text":"The function that sorts the given arr [ ]","code":"function countSort ( arr ) { var max = Math . max . apply ( Math , arr ) ; var min = Math . min . apply ( Math , arr ) ; var range = max - min + 1 ; var count = Array . from ( { length : range } , ( _ , i ) => 0 ) ; var output = Array . from ( { length : arr . length } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < arr . length ; i ++ ) { count [ arr [ i ] - min ] ++ ; } for ( i = 1 ; i < count . length ; i ++ ) { count [ i ] += count [ i - 1 ] ; } for ( i = arr . length - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = output [ i ] ; } }"}
{"text":"function to print array","code":"function printArray ( arr ) { for ( i = 0 ; i < arr . length ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; } document . write ( ' ' ) ; }"}
{"text":"Driver code","code":"var arr = [ - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 ] ; countSort ( arr ) ; printArray ( arr ) ;"}
{"text":"Returns value of Binomial Coefficient C ( n , k )","code":"function binomialCoeff ( n , k ) {"}
{"text":"Base Cases","code":"if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ;"}
{"text":"Recur","code":"return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }"}
{"text":"Driver program to test above function","code":"var n = 5 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + binomialCoeff ( n , k ) ) ;"}
{"text":"Javascript program for space optimized Dynamic Programming Solution of Binomial Coefficient","code":"function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ;"}
{"text":"nC0 is 1","code":"C [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) {"}
{"text":"Compute next row of pascal triangle using the previous row","code":"for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }"}
{"text":"Driver code","code":"let n = 5 , k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + binomialCoeff ( n , k ) ) ;"}
{"text":"Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false","code":"function findPartiion ( arr , n ) { let sum = 0 ; let i , j ;"}
{"text":"Calculate sum of all elements","code":"for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; let part = new Array ( parseInt ( sum \/ 2 + 1 , 10 ) ) ;"}
{"text":"Initialze the part array as 0","code":"for ( i = 0 ; i <= parseInt ( sum \/ 2 , 10 ) ; i ++ ) { part [ i ] = false ; }"}
{"text":"Fill the partition table in bottom up manner","code":"for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"The element to be included in the sum cannot be greater than the sum","code":"for ( j = parseInt ( sum \/ 2 , 10 ) ; j >= arr [ i ] ; j -- ) {"}
{"text":"Check if sum - arr [ i ] could be formed from a subset using elements before index i","code":"if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ parseInt ( sum \/ 2 , 10 ) ] ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] ; let n = arr . length ;"}
{"text":"Function call","code":"if ( findPartiion ( arr , n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"Returns true if there is a subset of set [ ] with sum equal to given sum","code":"function isSubsetSum ( set , n , sum ) {"}
{"text":"Base Cases","code":"if ( sum == 0 ) return true ; if ( n == 0 ) return false ;"}
{"text":"If last element is greater than sum , then ignore it","code":"if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ;"}
{"text":"else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element","code":"return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }"}
{"text":"Driver Code","code":"let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Returns true if there is a subset of set [ ] with sun equal to given sum","code":"function isSubsetSum ( set , n , sum ) {"}
{"text":"The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i","code":"let subset = new Array ( sum + 1 ) ; for ( let i = 0 ; i < sum + 1 ; i ++ ) { subset [ i ] = new Array ( sum + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { subset [ i ] [ j ] = 0 ; } }"}
{"text":"If sum is 0 , then answer is true","code":"for ( let i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ;"}
{"text":"If sum is not 0 and set is empty , then answer is false","code":"for ( let i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ;"}
{"text":"Fill the subset table in botton up manner","code":"for ( let i = 1 ; i <= sum ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } }"}
{"text":"print table","code":"for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; }"}
{"text":"Driver Code","code":"let set = [ 3 , 34 , 4 , 12 , 5 , 2 ] ; let sum = 9 ; let n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"A recursive function that returns the optimal length string for N keystrokes","code":"function findoptimal ( N ) {"}
{"text":"The optimal string length is N when N is smaller than 7","code":"if ( N <= 6 ) return N ;"}
{"text":"Initialize result","code":"let max = 0 ;"}
{"text":"TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way .","code":"let b ; for ( b = N - 3 ; b >= 1 ; b -- ) {"}
{"text":"If the breakpoint is s at b 'th  keystroke then the optimal string  would have length  (n-b-1)*screen[b-1];","code":"let curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }"}
{"text":"Driver code","code":"let N ;"}
{"text":"For the rest of the array we will rely on the previous entries to compute new ones","code":"for ( N = 1 ; N <= 20 ; N ++ ) document . write ( \" \" + N + \" \" + findoptimal ( N ) + \" \" ) ;"}
{"text":"This function returns the optimal length string for N keystrokes","code":"function findoptimal ( N ) {"}
{"text":"The optimal string length is N when N is smaller than 7","code":"if ( N <= 6 ) return N ;"}
{"text":"An array to store result of subproblems","code":"let screen = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { screen [ i ] = 0 ; }"}
{"text":"To pick a breakpoint","code":"let b ;"}
{"text":"Initializing the optimal lengths array for uptil 6 input strokes","code":"let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ;"}
{"text":"Solve all subproblems in bottom manner","code":"for ( n = 7 ; n <= N ; n ++ ) {"}
{"text":"Initialize length of optimal string for n keystrokes","code":"screen [ n - 1 ] = 0 ;"}
{"text":"For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way .","code":"for ( b = n - 3 ; b >= 1 ; b -- ) {"}
{"text":"If the breakpoint is at b 'th keystroke then  the optimal string would  have length  (n-b-1)*screen[b-1];","code":"let curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }"}
{"text":"Driver code","code":"let N ;"}
{"text":"for the rest of the array we will rely on the previous entries to compute new ones","code":"for ( N = 1 ; N <= 20 ; N ++ ) document . write ( \" \" + N + \" \" + findoptimal ( N ) + \" \" ) ;"}
{"text":"This function returns the optimal length string for N keystrokes","code":"function findoptimal ( N ) {"}
{"text":"The optimal string length is N when N is smaller than 7","code":"if ( N <= 6 ) return N ;"}
{"text":"An array to store result of subproblems","code":"let screen = [ ] ;"}
{"text":"To pick a breakpoint","code":"let b ;"}
{"text":"Initializing the optimal lengths array for uptil 6 input strokes .","code":"let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ;"}
{"text":"Solve all subproblems in bottom - up manner","code":"for ( n = 7 ; n <= N ; n ++ ) {"}
{"text":"for any keystroke n , we will need to choose between : - 1. pressing Ctrl - V once after copying the A ' s \u2581 obtained \u2581 by \u2581 n - 3 \u2581 keystrokes . \u2581 \u2581 2 . \u2581 pressing \u2581 Ctrl - V \u2581 twice \u2581 after \u2581 \u2581 copying \u2581 the \u2581 A ' s obtained by n - 4 keystrokes . 3. pressing Ctrl - V thrice after copying the A 's  obtained by n-5 keystrokes.","code":"screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }"}
{"text":"Driver program","code":"let N ;"}
{"text":"for the rest of the array we will rely on the previous entries to compute new ones","code":"for ( N = 1 ; N <= 20 ; N ++ ) document . write ( \" \" + N + \" \" + findoptimal ( N ) + \" \" ) ;"}
{"text":"Function to calculate x raised to the power y","code":"function power ( x , y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , parseInt ( y \/ 2 , 10 ) ) * power ( x , parseInt ( y \/ 2 , 10 ) ) ; else return x * power ( x , parseInt ( y \/ 2 , 10 ) ) * power ( x , parseInt ( y \/ 2 , 10 ) ) ; }"}
{"text":"Driver code","code":"let x = 2 ; let y = 3 ; document . write ( power ( x , y ) ) ;"}
{"text":"Function to calculate x raised to the power y in O ( logn )","code":"function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , y \/ 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }"}
{"text":"Javascript code for extended version of power function that can work for var x and negative y","code":"function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y \/ 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) \/ x ; } }"}
{"text":"Driver code","code":"var x = 2 ; var y = - 3 ; document . write ( power ( x , y ) . toFixed ( 6 ) ) ;"}
{"text":"javascript program for the above approach","code":"function power ( x , y ) {"}
{"text":"If x ^ 0 return 1","code":"if ( y == 0 ) return 1 ;"}
{"text":"If we need to find of 0 ^ y","code":"if ( x == 0 ) return 0 ;"}
{"text":"For all other cases","code":"return x * power ( x , y - 1 ) ; }"}
{"text":"Driver Code","code":"var x = 2 ; var y = 3 ; document . write ( power ( x , y ) ) ;"}
{"text":"Javascript program for the above approach","code":"function power ( x , y ) {"}
{"text":"Math . pow ( ) is a function that return floating number","code":"return parseInt ( Math . pow ( x , y ) ) ; }"}
{"text":"Driver Code","code":"let x = 2 ; let y = 3 ; document . write ( power ( x , y ) ) ;"}
{"text":"Returns the square root of n . Note that the function","code":"function squareRoot ( n ) {"}
{"text":"We are using n itself as initial approximation This can definitely be improved","code":"let x = n ; let y = 1 ; let e = 0.000001 ;"}
{"text":"e decides the accuracy level","code":"while ( x - y > e ) { x = ( x + y ) \/ 2 ; y = n \/ x ; } return x ; }"}
{"text":"Driver program to test above function","code":"let n = 50 ; document . write ( \" \" + n + \" \" + squareRoot ( n ) . toFixed ( 6 ) ) ;"}
{"text":"Returns the new average after including x","code":"function getAvg ( prev_avg , x , n ) { return ( prev_avg * n + x ) \/ ( n + 1 ) ; }"}
{"text":"Prints average of a stream of numbers","code":"function streamAvg ( arr , n ) { let avg = 0 ; for ( let i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; document . write ( \" \" + ( i + 1 ) + \" \" + avg . toFixed ( 6 ) + \" \" ) ; } return ; }"}
{"text":"Driver program to test above functions","code":"let arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; let n = arr . length ; streamAvg ( arr , n ) ;"}
{"text":"javascript program to return Average of a stream of numbers","code":"var sum = 0 , n = 0 ;"}
{"text":"Returns the new average after including x","code":"function getAvg ( x ) { sum += x ; n ++ ; return ( sum \/ n ) ; }"}
{"text":"Prints average of a stream of numbers","code":"function streamAvg ( arr , m ) { var avg = 0 ; for ( i = 0 ; i < m ; i ++ ) { avg = getAvg ( parseInt ( arr [ i ] ) ) ; document . write ( \" \" + ( i + 1 ) + \" \" + avg . toFixed ( 1 ) + \" \" ) ; } return ; }"}
{"text":"Driver Code","code":"var arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; var m = arr . length ; streamAvg ( arr , m ) ;"}
{"text":"Returns value of Binomial Coefficient C ( n , k )","code":"function binomialCoeff ( n , k ) { let res = 1 ;"}
{"text":"Since C ( n , k ) = C ( n , n - k )","code":"if ( k > n - k ) k = n - k ;"}
{"text":"Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ]","code":"for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Driver Code","code":"let n = 8 ; let k = 2 ; document . write ( \" \" + n + \" \" + k + \" \" + \" \" + \" \" + binomialCoeff ( n , k ) ) ;"}
{"text":"A function to print all prime factors of a given number n","code":"function primeFactors ( n ) {"}
{"text":"Print the number of 2 s that divide n","code":"while ( n % 2 == 0 ) { document . write ( 2 + \" \" ) ; n = Math . floor ( n \/ 2 ) ; }"}
{"text":"n must be odd at this point . So we can skip one element ( Note i = i + 2 )","code":"for ( let i = 3 ; i <= Math . floor ( Math . sqrt ( n ) ) ; i = i + 2 ) {"}
{"text":"While i divides n , print i and divide n","code":"while ( n % i == 0 ) { document . write ( i + \" \" ) ; n = Math . floor ( n \/ i ) ; } }"}
{"text":"This condition is to handle the case when n is a prime number greater than 2","code":"if ( n > 2 ) document . write ( n + \" \" ) ; }"}
{"text":"Driver code","code":"let n = 315 ; primeFactors ( n ) ;"}
{"text":"The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )","code":"function printCombination ( arr , n , r ) {"}
{"text":"A temporary array to store all combination one by one","code":"let data = new Array ( r ) ;"}
{"text":"Print all combination using temprary array ' data [ ] '","code":"combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }"}
{"text":"arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed","code":"function combinationUtil ( arr , data , start , end , index , r ) {"}
{"text":"Current combination is ready to be printed , print it","code":"if ( index == r ) { for ( let j = 0 ; j < r ; j ++ ) { document . write ( data [ j ] + \" \" ) ; } document . write ( \" \" ) }"}
{"text":"replace index with all possible elements . The condition \" end - i + 1 \u2581 > = \u2581 r - index \" makes sure that including one element at index will make a combination with remaining elements at remaining positions","code":"for ( let i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } }"}
{"text":"Driver function to check for above function","code":"let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let r = 3 ; let n = arr . length ; printCombination ( arr , n , r ) ;"}
{"text":"The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )","code":"function printCombination ( arr , n , r ) {"}
{"text":"A temporary array to store all combination one by one","code":"let data = new Array ( r ) ;"}
{"text":"Print all combination using temprary array ' data [ ] '","code":"combinationUtil ( arr , n , r , 0 , data , 0 ) ; }"}
{"text":"arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed","code":"function combinationUtil ( arr , n , r , index , data , i ) {"}
{"text":"Current combination is ready to be printed , print it","code":"if ( index == r ) { for ( let j = 0 ; j < r ; j ++ ) { document . write ( data [ j ] + \" \" ) ; } document . write ( \" \" ) ; return ; }"}
{"text":"When no more elements are there to put in data [ ]","code":"if ( i >= n ) { return ; }"}
{"text":"current is included , put next at next location","code":"data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ;"}
{"text":"current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed )","code":"combinationUtil ( arr , n , r , index , data , i + 1 ) ; }"}
{"text":"Driver function to check for above function","code":"let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let r = 3 ; let n = arr . length ; printCombination ( arr , n , r ) ;"}
{"text":"Returns count of all possible groups that can be formed from elements of a [ ] .","code":"function findgroups ( arr , n ) {"}
{"text":"Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i","code":"let c = [ 0 , 0 , 0 ] ; let i ;"}
{"text":"To store the result","code":"let res = 0 ;"}
{"text":"Count elements with remainder 0 , 1 and 2","code":"for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ;"}
{"text":"Case 3. a : Count groups of size 2 from 0 remainder elements","code":"res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;"}
{"text":"Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder","code":"res += c [ 1 ] * c [ 2 ] ;"}
{"text":"Case 4. a : Count groups of size 3 with all 0 remainder elements","code":"res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * Math . floor ( ( c [ 0 ] - 2 ) ) \/ 6 ) ;"}
{"text":"Case 4. b : Count groups of size 3 with all 1 remainder elements","code":"res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * Math . floor ( ( c [ 1 ] - 2 ) ) \/ 6 ) ;"}
{"text":"Case 4. c : Count groups of size 3 with all 2 remainder elements","code":"res += ( Math . floor ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) \/ 6 ) ;"}
{"text":"Case 4. c : Count groups of size 3 with different remainders","code":"res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;"}
{"text":"Return total count stored in res","code":"return res ; }"}
{"text":"Driver Code","code":"let arr = [ 3 , 6 , 7 , 2 , 9 ] ; let n = arr . length ; document . write ( \" \" + findgroups ( arr , n ) ) ;"}
{"text":"JavaScript program to find smallest power of 2 greater than or equal to n","code":"function nextPowerOf2 ( n ) { var count = 0 ;"}
{"text":"First n in the below condition is for the case where n is 0","code":"if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }"}
{"text":"Driver Code","code":"var n = 0 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text":"Program to find smallest power of 2 greater than or equal to n","code":"function nextPowerOf2 ( n ) { p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }"}
{"text":"Driver Code","code":"n = 5 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text":"Finds next power of two for n . If n itself is a power of two then returns n","code":"function nextPowerOf2 ( n ) { n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n }"}
{"text":"Driver Code","code":"n = 5 ; document . write ( nextPowerOf2 ( n ) ) ;"}
{"text":"Function to segregate 0 s and 1 s","code":"function segregate0and1 ( arr , n ) {"}
{"text":"Counts the no of zeros in arr","code":"let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; }"}
{"text":"Loop fills the arr with 0 until count","code":"for ( let i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ;"}
{"text":"Loop fills remaining arr space with 1","code":"for ( let i = count ; i < n ; i ++ ) arr [ i ] = 1 ; }"}
{"text":"Function to print segregated array","code":"function print ( arr , n ) { document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + \" \" ) ; }"}
{"text":"Driver function","code":"let arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] ; let n = arr . length ; segregate0and1 ( arr , n ) ; print ( arr , n ) ;"}
{"text":"Function to put all 0 s on left and all 1 s on right","code":"function segregate0and1 ( arr , size ) {"}
{"text":"Initialize left and right indexes","code":"let left = 0 , right = size - 1 ; while ( left < right ) {"}
{"text":"Increment left index while we see 0 at left","code":"while ( arr [ left ] == 0 && left < right ) left ++ ;"}
{"text":"Decrement right index while we see 1 at right","code":"while ( arr [ right ] == 1 && left < right ) right -- ;"}
{"text":"If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ]","code":"if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }"}
{"text":"Driver code","code":"let arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] ; let i , arr_size = arr . length ; segregate0and1 ( arr , arr_size ) ; document . write ( \" \" ) ; for ( i = 0 ; i < 6 ; i ++ ) document . write ( arr [ i ] + \" \" ) ;"}
{"text":"Function to put all 0 s on left and all 1 s on right","code":"function segregate0and1 ( arr , size ) { let type0 = 0 ; let type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else type0 ++ ; } }"}
{"text":"Driver Code","code":"let arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] ; let i , arr_size = arr . length ; segregate0and1 ( arr , arr_size ) ; document . write ( \" \" ) ; for ( i = 0 ; i < arr_size ; i ++ ) document . write ( arr [ i ] + \" \" ) ;"}
{"text":"JavaScript program to check if we can make neighbors distinct .","code":"function distinctAdjacentElement ( a , n ) {"}
{"text":"map used to count the frequency of each element occurring in the array","code":"let m = new Map ( ) ;"}
{"text":"In this loop we count the frequency of element through map m .","code":"for ( let i = 0 ; i < n ; ++ i ) { m [ a [ i ] ] ++ ; if ( m . has ( a [ i ] ) ) { m . set ( a [ i ] , m . get ( a [ i ] ) + 1 ) } else { m . set ( a [ i ] , 1 ) } }"}
{"text":"mx store the frequency of element which occurs most in array .","code":"let mx = 0 ;"}
{"text":"In this loop we calculate the maximum frequency and store it in variable mx .","code":"for ( let i = 0 ; i < n ; ++ i ) if ( mx < m . get ( a [ i ] ) ) mx = m . get ( a [ i ] ) ;"}
{"text":"By swapping we can adjust array only when the frequency of the element which occurs most is less than or equal to ( n + 1 ) \/ 2 .","code":"if ( mx > Math . floor ( ( n + 1 ) \/ 2 ) ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" ) ; }"}
{"text":"Driver program to test the above function","code":"let a = [ 7 , 7 , 7 , 7 ] ; let n = a . length ; distinctAdjacentElement ( a , n ) ;"}
{"text":"For a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ]","code":"function maxIndexDiff ( arr , n ) { let maxDiff = - 1 ; let i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }"}
{"text":"Driver code","code":"let arr = [ 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 ] ; let n = arr . length ; let maxDiff = maxIndexDiff ( arr , n ) ; document . write ( maxDiff ) ;"}
{"text":"For a given array [ ] arr , calculates the maximum j a i such that arr [ j ] > arr [ i ]","code":"let v = [ 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 ] ; let n = v . length ; let maxFromEnd = new Array ( n + 1 ) ; for ( let i = 0 ; i < maxFromEnd . length ; i ++ ) maxFromEnd [ i ] = Number . MIN_VALUE ;"}
{"text":"Create an array maxfromEnd","code":"for ( let i = v . length - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = Math . max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } let result = 0 ; for ( let i = 0 ; i < v . length ; i ++ ) { let low = i + 1 , high = v . length - 1 , ans = i ; while ( low <= high ) { let mid = parseInt ( ( low + high ) \/ 2 , 10 ) ; if ( v [ i ] <= maxFromEnd [ mid ] ) {"}
{"text":"We store this as current answer and look for further larger number to the right side","code":"ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } }"}
{"text":"Keeping a track of the maximum difference in indices","code":"result = Math . max ( result , ans - i ) ; } document . write ( result ) ;"}
{"text":"Javascript program to print sorted distinct elements .","code":"function printRepeating ( arr , size ) {"}
{"text":"Create a set using array elements","code":"var s = new Set ( arr ) ;"}
{"text":"Print contents of the set .","code":"[ ... s ] . sort ( ( a , b ) => a - b ) . forEach ( x => { document . write ( x + \" \" ) } ) ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 3 , 2 , 2 , 1 ] ; var n = arr . length ; printRepeating ( arr , n ) ;"}
{"text":"Function returns the minimum number of swaps required to sort the array This method is taken from below post","code":"function minSwapsToSort ( arr , n ) {"}
{"text":"Create an array of pairs where first element is array element and second element is position of first element","code":"let arrPos = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { arrPos . push ( [ arr [ i ] , i ] ) ; }"}
{"text":"Sort the array by array element values to get right position of every element as second element of pair .","code":"arrPos . sort ( function ( a , b ) { return a [ 0 ] - b [ 0 ] ; } ) ;"}
{"text":"To keep track of visited elements . Initialize all elements as not visited or false .","code":"let vis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { vis [ i ] = false ; }"}
{"text":"Initialize result","code":"let ans = 0 ;"}
{"text":"Traverse array elements","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"already swapped and corrected or already present at correct pos","code":"if ( vis [ i ] arrPos [ i ] [ 1 ] == i ) continue ;"}
{"text":"find out the number of node in this cycle and add in ans","code":"let cycle_size = 0 ; let j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ;"}
{"text":"move to next node","code":"j = arrPos [ j ] [ 1 ] ; cycle_size ++ ; }"}
{"text":"Update answer by adding current cycle .","code":"ans += ( cycle_size - 1 ) ; }"}
{"text":"Return result","code":"return ans ; }"}
{"text":"method returns minimum number of swap to make array B same as array A","code":"function minSwapToMakeArraySame ( a , b , n ) {"}
{"text":"map to store position of elements in array B we basically store element to index mapping .","code":"let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mp . set ( b [ i ] , i ) ; }"}
{"text":"now we 're storing position of array A elements  in array B.","code":"for ( let i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ;"}
{"text":"returing minimum swap for sorting in modified array B as final answer","code":"return minSwapsToSort ( b , n ) ; }"}
{"text":"Driver code","code":"let a = [ 3 , 6 , 4 , 8 ] ; let b = [ 4 , 6 , 8 , 3 ] ; let n = a . length ; document . write ( minSwapToMakeArraySame ( a , b , n ) ) ;"}
{"text":"Function to find k - th missing element","code":"function missingK ( a , k , n ) { let difference = 0 , ans = 0 , count = k ; let flag = false ;"}
{"text":"interating over the array","code":"for ( let i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ;"}
{"text":"Check if i - th and ( i + 1 ) - th element are not consecutive","code":"if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) {"}
{"text":"Save their difference","code":"difference += ( a [ i + 1 ] - a [ i ] ) - 1 ;"}
{"text":"Check for difference and given k","code":"if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } }"}
{"text":"If found","code":"if ( flag ) return ans ; else return - 1 ; }"}
{"text":"Input array","code":"let a = [ 1 , 5 , 11 , 19 ] ;"}
{"text":"k - th missing element to be found in the array","code":"let k = 11 ; let n = a . length ;"}
{"text":"Calling function to find missing element","code":"let missing = missingK ( a , k , n ) ; document . write ( missing ) ;"}
{"text":"class node","code":"class Node { constructor ( ) { this . data = 0 ; this . next = null ; } }"}
{"text":"A utility function to print linked list","code":"function printList ( node ) { while ( node != null ) { document . write ( node . data + \" \" ) ; node = node . next ; } document . write ( ) ; }"}
{"text":"Function to create newNode in a linkedlist","code":"function newNode ( key ) { var temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }"}
{"text":"Function to insert at beginning","code":"function insertBeg ( head , val ) { var temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; }"}
{"text":"Function to rearrange the odd and even nodes","code":"function rearrangeOddEven ( head ) { var odd = [ ] ; var even = [ ] ; var i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) {"}
{"text":"Odd Value in Even Position Add pointer to current node in odd stack","code":"odd . push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) {"}
{"text":"Even Value in Odd Position Add pointer to current node in even stack","code":"even . push ( head ) ; } head = head . next ; i ++ ; } while ( odd . length > 0 && even . length > 0 ) {"}
{"text":"Swap Data at the top of two stacks","code":"var k = odd [ odd . length - 1 ] . data ; odd [ odd . length - 1 ] . data = even [ even . length - 1 ] . data ; even [ even . length - 1 ] . data = k ; odd . pop ( ) ; even . pop ( ) ; } }"}
{"text":"Driver code","code":"var head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; document . write ( \" \" ) ; printList ( head ) ; rearrangeOddEven ( head ) ; document . write ( \" \" + \" \" ) ; printList ( head ) ;"}
{"text":"Structure node","code":"class Node { constructor ( ) { this . data = 0 ; this . next = null ; } }"}
{"text":"A utility function to print linked list","code":"function printList ( node ) { while ( node != null ) { document . write ( node . data + \" \" ) ; node = node . next ; } document . write ( \" \" ) ; }"}
{"text":"Function to create newNode in a linkedlist","code":"function newNode ( key ) { var temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }"}
{"text":"Function to insert at beginning","code":"function insertBeg ( head , val ) { var temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; }"}
{"text":"Function to rearrange the odd and even nodes","code":"function rearrange ( head ) {"}
{"text":"Step 1 : Segregate even and odd nodes Step 2 : Split odd and even lists Step 3 : Merge even list into odd list","code":"var even ; var temp , prev_temp ; var i , j , k , l , ptr = null ;"}
{"text":"Step 1 : Segregate Odd and Even Nodes","code":"temp = ( head ) . next ; prev_temp = head ; while ( temp != null ) {"}
{"text":"Backup next pointer of temp","code":"var x = temp . next ;"}
{"text":"If temp is odd move the node to beginning of list","code":"if ( temp . data % 2 != 0 ) { prev_temp . next = x ; temp . next = ( head ) ; ( head ) = temp ; } else { prev_temp = temp ; }"}
{"text":"Advance Temp Pointer","code":"temp = x ; }"}
{"text":"Step 2 Split the List into Odd and even","code":"temp = ( head ) . next ; prev_temp = ( head ) ; while ( temp != null && temp . data % 2 != 0 ) { prev_temp = temp ; temp = temp . next ; } even = temp ;"}
{"text":"End the odd List ( Make last node null )","code":"prev_temp . next = null ;"}
{"text":"Step 3 : Merge Even List into odd","code":"i = head ; j = even ; while ( j != null && i != null ) {"}
{"text":"While both lists are not exhausted Backup next pointers of i and j","code":"k = i . next ; l = j . next ; i . next = j ; j . next = k ;"}
{"text":"ptr points to the latest node added","code":"ptr = j ;"}
{"text":"Advance i and j pointers","code":"i = k ; j = l ; } if ( i == null ) {"}
{"text":"Odd list exhausts before even , append remainder of even list to odd .","code":"ptr . next = j ; }"}
{"text":"The case where even list exhausts before odd list is automatically handled since we merge the even list into the odd list","code":"return head ; }"}
{"text":"Driver Code","code":"var head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; document . write ( \" \" ) ; printList ( head ) ; document . write ( \" \" ) ; head = rearrange ( head ) ; printList ( head ) ;"}
{"text":"Function to prlet the matrix","code":"function print ( mat ) {"}
{"text":"Iterate over the rows","code":"for ( let i = 0 ; i < mat . length ; i ++ ) {"}
{"text":"Iterate over the columns","code":"for ( let j = 0 ; j < mat [ 0 ] . length ; j ++ )"}
{"text":"Print the value","code":"document . write ( mat [ i ] [ j ] + \" \" ) ; document . write ( \" \" ) ; } }"}
{"text":"Function to perform the swapping of matrix elements in clockwise manner","code":"function performSwap ( mat , i , j ) { let N = mat . length ;"}
{"text":"Stores the last row","code":"let ei = N - 1 - i ;"}
{"text":"Stores the last column","code":"let ej = N - 1 - j ;"}
{"text":"Perform the swaps","code":"let temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; }"}
{"text":"Function to rotate non - diagonal elements of the matrix K times in clockwise direction","code":"function rotate ( mat , N , K ) {"}
{"text":"Update K to K % 4","code":"K = K % 4 ;"}
{"text":"Iterate until K is positive","code":"while ( K -- > 0 ) {"}
{"text":"Iterate each up to N \/ 2 - th row","code":"for ( let i = 0 ; i < N \/ 2 ; i ++ ) {"}
{"text":"Iterate each column from i to N - i - 1","code":"for ( let j = i ; j < N - i - 1 ; j ++ ) {"}
{"text":"Check if the element at i , j is not a diagonal element","code":"if ( i != j && ( i + j ) != N - 1 ) {"}
{"text":"Perform the swapping","code":"performSwap ( mat , i , j ) ; } } } }"}
{"text":"Print the matrix","code":"print ( mat ) ; }"}
{"text":"Driver Code","code":"let K = 5 ; let mat = [ [ 1 , 2 , 3 , 4 ] , [ 6 , 7 , 8 , 9 ] , [ 11 , 12 , 13 , 14 ] , [ 16 , 17 , 18 , 19 ] , ] ; let N = mat . length ; rotate ( mat , N , K ) ;"}
{"text":"Javascript implementation to find elements that are a power of two","code":"let MAX = 10000 ;"}
{"text":"prefix [ i ] is going to store the number of elements which are a power of two till i ( including i ) .","code":"let prefix = Array . from ( { length : MAX + 1 } , ( _ , i ) => 0 ) ; function isPowerOfTwo ( x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; }"}
{"text":"Function to find the maximum range whose sum is divisible by M .","code":"function computePrefix ( n , a ) {"}
{"text":"Calculate the prefix sum","code":"if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } }"}
{"text":"Function to return the number of elements which are a power of two in a subarray","code":"function query ( L , R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; }"}
{"text":"Driver Code","code":"let A = [ 3 , 8 , 5 , 2 , 5 , 10 ] ; let N = A . length ; computePrefix ( N , A ) ; document . write ( query ( 0 , 4 ) + \" \" ) ; document . write ( query ( 3 , 5 ) ) ;"}
{"text":"Function to calculate the integral points inside a square","code":"function countIntgralPoints ( x1 , y1 , x2 , y2 ) { document . write ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }"}
{"text":"Driver Code","code":"var x1 = 1 , y1 = 1 ; var x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ;"}
{"text":"Function to find the next distinct digits number","code":"function findNextNumber ( n ) { let h = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; let i = 0 , msb = n , rem = 0 ; let next_num = - 1 , count = 0 ;"}
{"text":"Loop to find the distinct digits using hash array and the number of digits","code":"while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb = Math . floor ( msb \/ 10 ) ; count ++ ; } h [ msb ] = 1 ; count ++ ;"}
{"text":"Loop to find the most significant distinct digit of the next number","code":"for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } }"}
{"text":"Condition to check if the number is possible with the same number of digits count","code":"if ( next_num == - 1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } }"}
{"text":"Condition to check if the desired most siginificant distinct digit is found","code":"if ( next_num > 0 ) {"}
{"text":"Loop to find the minimum next digit which is not present in the number","code":"for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } }"}
{"text":"Computation of the number","code":"for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; }"}
{"text":"Condition to check if the number is greater than the given number","code":"if ( next_num > n ) document . write ( next_num + \" \" ) ; else document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } }"}
{"text":"Driver code","code":"let n = 2019 ; findNextNumber ( n ) ;"}
{"text":"Function to find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is N","code":"function CalculateValues ( N ) { var A = 0 , B = 0 , C = 0 ;"}
{"text":"Iterate over the range [ 0 , N7 ]","code":"for ( C = 0 ; C < N \/ 7 ; C ++ ) {"}
{"text":"Iterate over the range [ 0 , N5 ]","code":"for ( B = 0 ; B < N \/ 5 ; B ++ ) {"}
{"text":"Find the value of A","code":"var A = N - 7 * C - 5 * B ;"}
{"text":"If A is greater than or equal to 0 and divisible by 3","code":"if ( A >= 0 && A % 3 == 0 ) { document . write ( \" \" + A \/ 3 + \" \" + B + \" \" + C ) ; return ; } } }"}
{"text":"Otherwise , print - 1","code":"document . write ( - 1 ) ; }"}
{"text":"Driver Code","code":"var N = 19 ; CalculateValues ( 19 ) ;"}
{"text":"Function to find the minimum time to visit all the cities such that both the person never meets","code":"function minimumTime ( arr , n ) {"}
{"text":"Initialize sum as 0","code":"var sum = 0 ;"}
{"text":"Find the maximum element","code":"var T = Math . max ( ... arr ) ;"}
{"text":"Traverse the array","code":"for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"Increment sum by arr [ i ]","code":"sum += arr [ i ] ; }"}
{"text":"Prvar maximum of 2 * T and sum","code":"document . write ( Math . max ( 2 * T , sum ) ) ; }"}
{"text":"Driver code","code":"var arr = [ 2 , 8 , 3 ] ; var N = arr . length ;"}
{"text":"Function Call","code":"minimumTime ( arr , N ) ;"}
{"text":"Function to find the lexicographically maximum string by reversing substrings having even numbers of 1 s","code":"function lexicographicallyMax ( s ) {"}
{"text":"Store size of string","code":"var n = s . length ;"}
{"text":"Traverse the string","code":"for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"Count the number of 1 s","code":"var count = 0 ;"}
{"text":"Stores the starting index","code":"var beg = i ;"}
{"text":"Stores the end index","code":"var end = i ;"}
{"text":"Increment count , when 1 is encountered","code":"if ( s [ i ] == ' ' ) count ++ ;"}
{"text":"Traverse the remaining string","code":"for ( var j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == ' ' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } }"}
{"text":"Reverse the string from starting and end index","code":"for ( var i = beg ; i < parseInt ( ( end + 1 ) \/ 2 ) ; i ++ ) { let temp = s [ i ] ; s [ i ] = s [ end - i + 1 ] ; s [ end - i + 1 ] = temp ; } }"}
{"text":"Printing the string","code":"document . write ( s . join ( \" \" ) + \" \" ) ; }"}
{"text":"Driver Code","code":"var S = \" \" . split ( ' ' ) ; lexicographicallyMax ( S ) ;"}
{"text":"Function to count the maximum number of pairs from given array with sum K","code":"function maxPairs ( nums , k ) {"}
{"text":"Sort array in increasing order","code":"nums . sort ( ) ;"}
{"text":"Stores the final result","code":"let result = 0 ;"}
{"text":"Initialize the left and right pointers","code":"let start = 0 , end = nums . length - 1 ;"}
{"text":"Traverse array until start < end","code":"while ( start < end ) { if ( nums [ start ] + nums [ end ] > k )"}
{"text":"Decrement right by 1","code":"end -- ; else if ( nums [ start ] + nums [ end ] < k )"}
{"text":"Increment left by 1","code":"start ++ ;"}
{"text":"Increment result and left poleter by 1 and decrement right pointer by 1","code":"else { start ++ ; end -- ; result ++ ; } }"}
{"text":"Print the result","code":"document . write ( result ) ; }"}
{"text":"Driver Code","code":"let arr = [ 1 , 2 , 3 , 4 ] ; let K = 5 ;"}
{"text":"Function Call","code":"maxPairs ( arr , K ) ;"}
{"text":"Function to find the maximum number of pairs with a sum K such that same element can 't be used twice","code":"function maxPairs ( nums , k ) {"}
{"text":"Initialize a hashm","code":"var m = new Map ( ) ;"}
{"text":"Store the final result","code":"var result = 0 ;"}
{"text":"Iterate over the array nums [ ]","code":"nums . forEach ( i => {"}
{"text":"Decrement its frequency in m and increment the result by 1","code":"if ( m . has ( i ) && m . get ( i ) > 0 ) { m . set ( i , m . get ( i ) - 1 ) ; result ++ ; }"}
{"text":"Increment its frequency by 1 if it is already present in m . Otherwise , set its frequency to 1","code":"else { if ( m . has ( k - i ) ) m . set ( k - i , m . get ( k - i ) + 1 ) else m . set ( k - i , 1 ) } } ) ;"}
{"text":"Print the result","code":"document . write ( result ) ; }"}
{"text":"Driver Code","code":"var arr = [ 1 , 2 , 3 , 4 ] ; var K = 5 ;"}
{"text":"Function Call","code":"maxPairs ( arr , K ) ;"}
{"text":"Function to find indices of array elements whose removal makes the sum of odd and even indexed array elements equal","code":"function removeIndicesToMakeSumEqual ( arr ) {"}
{"text":"Stores size of array","code":"var N = arr . length ;"}
{"text":"Store prefix sum of odd index array elements","code":"var odd = Array ( N ) . fill ( 0 ) ;"}
{"text":"Store prefix sum of even index array elements","code":"var even = Array ( N ) . fill ( 0 ) ;"}
{"text":"Update even [ 0 ]","code":"even [ 0 ] = arr [ 0 ] ;"}
{"text":"Traverse the given array","code":"for ( i = 1 ; i < N ; i ++ ) {"}
{"text":"Update odd [ i ]","code":"odd [ i ] = odd [ i - 1 ] ;"}
{"text":"Update even [ i ]","code":"even [ i ] = even [ i - 1 ] ;"}
{"text":"If the current index is an even number","code":"if ( i % 2 == 0 ) {"}
{"text":"Update even [ i ]","code":"even [ i ] += arr [ i ] ; }"}
{"text":"If the current index is an odd number","code":"else {"}
{"text":"Update odd [ i ]","code":"odd [ i ] += arr [ i ] ; } }"}
{"text":"Check if at least one index found or not that satisfies the condition","code":"var find = false ;"}
{"text":"Store odd indices sum by removing 0 - th index","code":"var p = odd [ N - 1 ] ;"}
{"text":"Store even indices sum by removing 0 - th index","code":"var q = even [ N - 1 ] - arr [ 0 ] ;"}
{"text":"If p and q are equal","code":"if ( p == q ) { document . write ( \" \" ) ; find = true ; }"}
{"text":"Traverse the array arr","code":"for ( i = 1 ; i < N ; i ++ ) {"}
{"text":"If i is an even number","code":"if ( i % 2 == 0 ) {"}
{"text":"Update p by removing the i - th element","code":"p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ;"}
{"text":"Update q by removing the i - th element","code":"q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else {"}
{"text":"Update q by removing the i - th element","code":"q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ;"}
{"text":"Update p by removing the i - th element","code":"p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; }"}
{"text":"If odd index values sum is equal to even index values sum","code":"if ( p == q ) {"}
{"text":"Set the find variable","code":"find = true ;"}
{"text":"Print the current index","code":"document . write ( i + \" \" ) ; } }"}
{"text":"If no index found","code":"if ( ! find ) {"}
{"text":"Print not possible","code":"document . write ( - 1 ) ; } }"}
{"text":"Driver Code","code":"var arr = [ 4 , 1 , 6 , 2 ] ; removeIndicesToMakeSumEqual ( arr ) ;"}
{"text":"Function to coutnt minimum array elements required to be removed to make an array bitonic","code":"function min_element_removal ( arr , N ) {"}
{"text":"left [ i ] : Stores the length of LIS up to i - th index","code":"var left = Array ( N ) . fill ( 1 ) ;"}
{"text":"right [ i ] : Stores the length of decreasing subsequence over the range [ i , N ]","code":"var right = Array ( N ) . fill ( 1 ) ;"}
{"text":"Calculate the length of LIS up to i - th index","code":"for ( var i = 1 ; i < N ; i ++ ) {"}
{"text":"Traverse the array upto i - th index","code":"for ( var j = 0 ; j < i ; j ++ ) {"}
{"text":"If arr [ j ] is less than arr [ i ]","code":"if ( arr [ j ] < arr [ i ] ) {"}
{"text":"Update left [ i ]","code":"left [ i ] = Math . max ( left [ i ] , left [ j ] + 1 ) ; } } }"}
{"text":"Calculate the length of decreasing subsequence over the range [ i , N ]","code":"for ( var i = N - 2 ; i >= 0 ; i -- ) {"}
{"text":"Traverse right [ ] array","code":"for ( var j = N - 1 ; j > i ; j -- ) {"}
{"text":"If arr [ i ] is greater than arr [ j ]","code":"if ( arr [ i ] > arr [ j ] ) {"}
{"text":"Update right [ i ]","code":"right [ i ] = Math . max ( right [ i ] , right [ j ] + 1 ) ; } } }"}
{"text":"Stores length of the longest bitonic array","code":"var maxLen = 0 ;"}
{"text":"Traverse left [ ] and right [ ] array","code":"for ( var i = 1 ; i < N - 1 ; i ++ ) {"}
{"text":"Update maxLen","code":"maxLen = Math . max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } document . write ( ( N - maxLen ) + \" \" ) ; }"}
{"text":"Function to print minimum removals required to make given array bitonic","code":"function makeBitonic ( arr , N ) { if ( N == 1 ) { document . write ( \" \" + \" \" ) ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ; return ; } min_element_removal ( arr , N ) ; }"}
{"text":"Driver Code","code":"var arr = [ 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 ] ; var N = arr . length ; makeBitonic ( arr , N ) ;"}
{"text":"Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together","code":"function countSubarrays ( A , N ) {"}
{"text":"Stores the count of subarrays","code":"let ans = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"If current element is different from the next array element","code":"if ( A [ i ] != A [ i + 1 ] ) {"}
{"text":"Increment count","code":"ans ++ ;"}
{"text":"Count the frequency of 1 s and 0 s","code":"for ( let j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) {"}
{"text":"Increment count","code":"ans ++ ; } } }"}
{"text":"Prlet the final count","code":"document . write ( ans + \" \" ) ; }"}
{"text":"Driver Code","code":"let A = [ 1 , 1 , 0 , 0 , 1 , 0 ] ; let N = A . length ;"}
{"text":"Function Call","code":"countSubarrays ( A , N ) ;"}
{"text":"Javascript program of the above approach","code":"let maxN = 2002 ;"}
{"text":"lcount [ i ] [ j ] : Stores the count of i on left of index j","code":"let lcount = new Array ( maxN ) ;"}
{"text":"rcount [ i ] [ j ] : Stores the count of i on right of index j","code":"let rcount = new Array ( maxN ) ; for ( let i = 0 ; i < maxN ; i ++ ) { lcount [ i ] = new Array ( maxN ) ; rcount [ i ] = new Array ( maxN ) ; for ( let j = 0 ; j < maxN ; j ++ ) { lcount [ i ] [ j ] = 0 ; rcount [ i ] [ j ] = 0 ; } }"}
{"text":"Function to count unique elements on left and right of any index","code":"function fill_counts ( a , n ) { let i , j ;"}
{"text":"Find the maximum array element","code":"let maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) {"}
{"text":"Calculate prefix sum of counts of each value","code":"for ( j = 1 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; }"}
{"text":"Calculate suffix sum of counts of each value","code":"for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } }"}
{"text":"Function to count quadruples of the required type","code":"function countSubsequence ( a , n ) { let i , j ; fill_counts ( a , n ) ; let answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; }"}
{"text":"Driver Code","code":"let a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] ; document . write ( countSubsequence ( a , a . length ) ) ;"}
{"text":"Function to remove the outermost parentheses of every primitive substring from the given string","code":"function removeOuterParentheses ( S ) {"}
{"text":"Stores the resultant string","code":"let res = \" \" ;"}
{"text":"Stores the count of opened parentheses","code":"let count = 0 ;"}
{"text":"Traverse the string","code":"for ( let c = 0 ; c < S . length ; c ++ ) {"}
{"text":"If opening parenthesis is encountered and their count exceeds 0","code":"if ( S . charAt ( c ) == ' ' && count ++ > 0 )"}
{"text":"Include the character","code":"res += S . charAt ( c ) ;"}
{"text":"If closing parenthesis is encountered and their count is less than count of opening parentheses","code":"if ( S . charAt ( c ) == ' ' && count -- > 1 )"}
{"text":"Include the character","code":"res += S . charAt ( c ) ; }"}
{"text":"Return the resultant string","code":"return res ; }"}
{"text":"Driver Code","code":"let S = \" \" ; document . write ( removeOuterParentheses ( S ) ) ;"}
{"text":"Function to find the longest subarray with increasing contiguous elements","code":"function maxiConsecutiveSubarray ( arr , N ) {"}
{"text":"Stores the length of required longest subarray","code":"let maxi = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"Stores the length of length of longest such subarray from ith index","code":"let cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) {"}
{"text":"If consecutive elements are increasing and differ by 1","code":"if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; }"}
{"text":"Otherwise","code":"else { break ; } }"}
{"text":"Update the longest subarray obtained so far","code":"maxi = Math . max ( maxi , cnt ) ; i = j ; }"}
{"text":"Return the length obtained","code":"return maxi ; }"}
{"text":"Driver Code","code":"let N = 11 ; let arr = [ 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 ] ; document . write ( maxiConsecutiveSubarray ( arr , N ) ) ;"}
{"text":"Javascript implementation of the above approach","code":"let N = 100005 ;"}
{"text":"Function to generate prime numbers using Sieve of Eratosthenes","code":"function SieveOfEratosthenes ( prime , p_size ) {"}
{"text":"Set 0 and 1 as non - prime","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) {"}
{"text":"If p is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Set all multiples of p as non - prime","code":"for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to find the digit sum of a given number","code":"function digitSum ( number ) {"}
{"text":"Stores the sum of digits","code":"let sum = 0 ; while ( number > 0 ) {"}
{"text":"Extract digits and add to the sum","code":"sum += ( number % 10 ) ; number = Math . floor ( number \/ 10 ) ; }"}
{"text":"Return the sum of the digits","code":"return sum ; }"}
{"text":"Function to find the longest subsequence with sum of digits of each element equal to a composite number","code":"function longestCompositeDigitSumSubsequence ( arr , n ) { let count = 0 ; let prime = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"Calculate sum of digits of current array element","code":"let res = digitSum ( arr [ i ] ) ;"}
{"text":"If sum of digits equal to 1","code":"if ( res == 1 ) { continue ; }"}
{"text":"If sum of digits is a prime","code":"if ( prime [ res ] == false ) { count ++ ; } } document . write ( count ) ; }"}
{"text":"Driver Code","code":"let arr = [ 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 ] ; let n = arr . length ;"}
{"text":"Function call","code":"longestCompositeDigitSumSubsequence ( arr , n ) ;"}
{"text":"Javascript program for the above approach","code":"let sum ;"}
{"text":"Structure of Binary Tree","code":"class Node { constructor ( data ) { this . left = null ; this . right = null ; this . data = data ; } }"}
{"text":"Function to create a new node","code":"function newnode ( data ) { let temp = new Node ( data ) ;"}
{"text":"Return the created node","code":"return temp ; }"}
{"text":"Function to insert a node in the tree","code":"function insert ( s , i , N , root , temp ) { if ( i == N ) return temp ;"}
{"text":"Left insertion","code":"if ( s [ i ] == ' ' ) root . left = insert ( s , i + 1 , N , root . left , temp ) ;"}
{"text":"Right insertion","code":"else root . right = insert ( s , i + 1 , N , root . right , temp ) ;"}
{"text":"Return the root node","code":"return root ; }"}
{"text":"Function to find sum of specially balanced nodes in the Tree","code":"function SBTUtil ( root ) {"}
{"text":"Base Case","code":"if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return root . data ;"}
{"text":"Find the left subtree sum","code":"let left = SBTUtil ( root . left ) ;"}
{"text":"Find the right subtree sum","code":"let right = SBTUtil ( root . right ) ;"}
{"text":"Condition of specially balanced node","code":"if ( root . left != null && root . right != null ) {"}
{"text":"Condition of specially balanced node","code":"if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root . data ; } }"}
{"text":"Return the sum","code":"return left + right + root . data ; }"}
{"text":"Function to build the binary tree","code":"function build_tree ( R , N , str , values ) {"}
{"text":"Form root node of the tree","code":"let root = newnode ( R ) ; let i ;"}
{"text":"Insert nodes into tree","code":"for ( i = 0 ; i < N - 1 ; i ++ ) { let s = str [ i ] ; let x = values [ i ] ;"}
{"text":"Create a new Node","code":"let temp = newnode ( x ) ;"}
{"text":"Insert the node","code":"root = insert ( s , 0 , s . length , root , temp ) ; }"}
{"text":"Return the root of the Tree","code":"return root ; }"}
{"text":"Function to find the sum of specially balanced nodes","code":"function speciallyBalancedNodes ( R , N , str , values ) {"}
{"text":"Build Tree","code":"let root = build_tree ( R , N , str , values ) ;"}
{"text":"Stores the sum of specially balanced node","code":"sum = 0 ;"}
{"text":"Function Call","code":"SBTUtil ( root ) ;"}
{"text":"Print required sum","code":"document . write ( sum + \" \" ) ; }"}
{"text":"Given nodes","code":"let N = 7 ;"}
{"text":"Given root","code":"let R = 12 ;"}
{"text":"Given path info of nodes from root","code":"let str = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ;"}
{"text":"Given node values","code":"let values = [ 17 , 16 , 4 , 9 , 2 , 3 ] ;"}
{"text":"Function Call","code":"speciallyBalancedNodes ( R , N , str , values ) ;"}
{"text":"Function to find the position of the pair that covers every pair in the array arr [ ] [ ]","code":"function position ( arr , N ) {"}
{"text":"Stores the index of the resultant pair","code":"let pos = - 1 ;"}
{"text":"To count the occurences","code":"let count ;"}
{"text":"Iterate to check every pair","code":"for ( let i = 0 ; i < N ; i ++ ) {"}
{"text":"Set count to 0","code":"count = 0 ; for ( let j = 0 ; j < N ; j ++ ) {"}
{"text":"Condition to checked for overlapping of pairs","code":"if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } }"}
{"text":"If that pair can cover all other pairs then store its position","code":"if ( count == N ) { pos = i ; } }"}
{"text":"If position not found","code":"if ( pos == - 1 ) { document . write ( pos ) ; }"}
{"text":"Otherwise","code":"else { document . write ( pos + 1 ) ; } }"}
{"text":"Given array of pairs","code":"let arr = [ [ 3 , 3 ] , [ 1 , 3 ] , [ 2 , 2 ] , [ 2 , 3 ] , [ 1 , 2 ] ] ; let N = arr . length ;"}
{"text":"Function Call","code":"position ( arr , N ) ;"}
{"text":"Function to minimize the count of operations to make str1 and str2 permutations of each other","code":"function ctMinEdits ( str1 , str2 ) { let N1 = str1 . length ; let N2 = str2 . length ;"}
{"text":"Store the frequency of each character of str1","code":"let freq1 = new Array ( 256 ) . fill ( 0 ) ; for ( let i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] . charCodeAt ( ) ] ++ ; }"}
{"text":"Store the frequency of each character of str2","code":"let freq2 = new Array ( 256 ) . fill ( 0 ) ; for ( let i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] . charCodeAt ( ) ] ++ ; }"}
{"text":"Traverse the freq1 [ ] and freq2 [ ]","code":"for ( let i = 0 ; i < 256 ; i ++ ) {"}
{"text":"If frequency of character in str1 is greater than str2","code":"if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; }"}
{"text":"Otherwise","code":"else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } }"}
{"text":"Store sum of freq1 [ ]","code":"let sum1 = 0 ;"}
{"text":"Store sum of freq2 [ ]","code":"let sum2 = 0 ; for ( let i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . max ( sum1 , sum2 ) ; }"}
{"text":"Driver Code","code":"let str1 = \" \" ; let str2 = \" \" ; document . write ( ctMinEdits ( str1 . split ( ' ' ) , str2 . split ( ' ' ) ) ) ;"}
{"text":"Function to count the pairs such that given condition is satisfied","code":"function CountPairs ( a , b , n ) {"}
{"text":"Stores the sum of element at each corresponding index","code":"var C = Array ( n ) ;"}
{"text":"Find the sum of each index of both array","code":"for ( var i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; }"}
{"text":"Stores frequency of each element present in sumArr","code":"var freqCount = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freqCount . has ( C [ i ] ) ) freqCount . set ( C [ i ] , freqCount . get ( C [ i ] ) + 1 ) else freqCount . set ( C [ i ] , 1 ) }"}
{"text":"Initialize number of pairs","code":"var NoOfPairs = 0 ; freqCount . forEach ( ( value , key ) => { var y = value ;"}
{"text":"Add possible vaid pairs","code":"NoOfPairs = NoOfPairs + y * ( y - 1 ) \/ 2 ; } ) ;"}
{"text":"Return Number of Pairs","code":"document . write ( NoOfPairs ) ; }"}
{"text":"Given array arr [ ] and brr [ ]","code":"var arr = [ 1 , 4 , 20 , 3 , 10 , 5 ] ; var brr = [ 9 , 6 , 1 , 7 , 11 , 6 ] ;"}
{"text":"Size of given array","code":"var N = arr . length ;"}
{"text":"Function calling","code":"CountPairs ( arr , brr , N ) ;"}
{"text":"Function to find the median change after removing elements from arr2 [ ]","code":"function medianChange ( arr1 , arr2 ) { let N = arr1 . length ;"}
{"text":"To store the median","code":"let median = [ ] ;"}
{"text":"If N is odd","code":"if ( ( N & 1 ) ) median . push ( ( arr1 [ Math . floor ( N \/ 2 ) ] * 1 ) ) ;"}
{"text":"If N is even","code":"else median . push ( Math . floor ( ( arr1 [ Math . floor ( N \/ 2 ) ] + arr1 [ Math . floor ( ( N - 1 ) \/ 2 ) ] ) \/ 2 ) ) ; for ( let x = 0 ; x < arr2 . length ; x ++ ) {"}
{"text":"Find the current element in arr1","code":"let it = arr1 . indexOf ( arr2 [ x ] ) ;"}
{"text":"Erase the element","code":"arr1 . splice ( it , 1 ) ;"}
{"text":"Decrement N","code":"N -- ;"}
{"text":"If N is odd","code":"if ( ( N & 1 ) ) { median . push ( arr1 [ Math . floor ( N \/ 2 ) ] * 1 ) ; }"}
{"text":"If N is even","code":"else { median . push ( Math . floor ( ( arr1 [ Math . floor ( N \/ 2 ) ] + arr1 [ Math . floor ( ( N - 1 ) \/ 2 ) ] ) \/ 2 ) ) ; } }"}
{"text":"Print the corresponding difference of median","code":"for ( let i = 0 ; i < median . length - 1 ; i ++ ) { document . write ( ( median [ i + 1 ] - median [ i ] ) + \" \" ) ; } }"}
{"text":"Given arrays","code":"let arr1 = [ 2 , 4 , 6 , 8 , 10 ] ; let arr2 = [ 4 , 6 ] ;"}
{"text":"Function Call","code":"medianChange ( arr1 , arr2 )"}
{"text":"NFA variable that keeps track of the state while transaction .","code":"let nfa = 1 ;"}
{"text":"This checks for invalid input .","code":"let flag = 0 ;"}
{"text":"Function for the state Q2","code":"function state1 ( c ) {"}
{"text":"State transitions ' a ' takes to Q4 , and ' b ' and ' c ' remain at Q2","code":"if ( c == ' ' ) nfa = 2 ; else if ( c == ' ' c == ' ' ) nfa = 1 ; else flag = 1 ; }"}
{"text":"Function for the state Q3","code":"function state2 ( c ) {"}
{"text":"State transitions ' a ' takes to Q3 , and ' b ' and ' c ' remain at Q4","code":"if ( c == ' ' ) nfa = 3 ; else if ( c == ' ' c == ' ' ) nfa = 2 ; else flag = 1 ; }"}
{"text":"Function for the state Q4","code":"function state3 ( c ) {"}
{"text":"State transitions ' a ' takes to Q2 , and ' b ' and ' c ' remain at Q3","code":"if ( c == ' ' ) nfa = 1 ; else if ( c == ' ' c == ' ' ) nfa = 3 ; else flag = 1 ; }"}
{"text":"Function for the state Q5","code":"function state4 ( c ) {"}
{"text":"State transitions ' b ' takes to Q6 , and ' a ' and ' c ' remain at Q5","code":"if ( c == ' ' ) nfa = 5 ; else if ( c == ' ' c == ' ' ) nfa = 4 ; else flag = 1 ; }"}
{"text":"Function for the state Q6","code":"function state5 ( c ) {"}
{"text":"State transitions ' b ' takes to Q7 , and ' a ' and ' c ' remain at Q7","code":"if ( c == ' ' ) nfa = 6 ; else if ( c == ' ' c == ' ' ) nfa = 5 ; else flag = 1 ; }"}
{"text":"Function for the state Q7","code":"function state6 ( c ) {"}
{"text":"State transitions ' b ' takes to Q5 , and ' a ' and ' c ' remain at Q7","code":"if ( c == ' ' ) nfa = 4 ; else if ( c == ' ' c == ' ' ) nfa = 6 ; else flag = 1 ; }"}
{"text":"Function for the state Q8","code":"function state7 ( c ) {"}
{"text":"State transitions ' c ' takes to Q9 , and ' a ' and ' b ' remain at Q8","code":"if ( c == ' ' ) nfa = 8 ; else if ( c == ' ' c == ' ' ) nfa = 7 ; else flag = 1 ; }"}
{"text":"Function for the state Q9","code":"function state8 ( c ) {"}
{"text":"State transitions ' c ' takes to Q10 , and ' a ' and ' b ' remain at Q9","code":"if ( c == ' ' ) nfa = 9 ; else if ( c == ' ' c == ' ' ) nfa = 8 ; else flag = 1 ; }"}
{"text":"Function for the state Q10","code":"function state9 ( c ) {"}
{"text":"State transitions ' c ' takes to Q8 , and ' a ' and ' b ' remain at Q10","code":"if ( c == ' ' ) nfa = 7 ; else if ( c == ' ' c == ' ' ) nfa = 9 ; else flag = 1 ; }"}
{"text":"Function to check for 3 a 's","code":"function checkA ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } }"}
{"text":"Function to check for 3 b 's","code":"function checkB ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } }"}
{"text":"Function to check for 3 c 's","code":"function checkC ( s , x ) { for ( let i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } }"}
{"text":"Driver Code","code":"let s = \" \" ; let x = 5 ;"}
{"text":"If any of the states is true , that is , if either the number of a ' s \u2581 or \u2581 number \u2581 of \u2581 b ' s or number of c 's is a multiple of three, then the string is accepted","code":"if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { document . write ( \" \" ) ; } else { if ( flag == 0 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } }"}
{"text":"Function to count positions such that all elements before it are greater","code":"function getPositionCount ( a , n ) {"}
{"text":"Count is initially 1 for the first element","code":"var count = 1 ;"}
{"text":"Initial Minimum","code":"var min = a [ 0 ] ;"}
{"text":"Traverse the array","code":"for ( var i = 1 ; i < n ; i ++ ) {"}
{"text":"If current element is new minimum","code":"if ( a [ i ] <= min ) {"}
{"text":"Update minimum","code":"min = a [ i ] ;"}
{"text":"Increment count","code":"count ++ ; } } return count ; }"}
{"text":"Driver Code","code":"var a = [ 5 , 4 , 6 , 1 , 3 , 1 ] ; var n = a . length ; document . write ( getPositionCount ( a , n ) ) ;"}
{"text":"Function to return the maximum sum in a subarray of size k","code":"function maxSum ( arr , n , k ) {"}
{"text":"k must be greater","code":"if ( n < k ) { return - 1 ; }"}
{"text":"Compute sum of first window of size k","code":"var res = 0 ; for ( i = 0 ; i < k ; i ++ ) res += arr [ i ] ;"}
{"text":"Compute sums of remaining windows by removing first element of previous window and adding last element of current window .","code":"var curr_sum = res ; for ( i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . max ( res , curr_sum ) ; } return res ; }"}
{"text":"Function to return the length of subarray Sum of all the subarray of this length is less than or equal to K","code":"function solve ( arr , n , k ) { var max_len = 0 , l = 0 , r = n , m ;"}
{"text":"Binary search from l to r as all the array elements are positive so that the maximum subarray sum is monotonically increasing","code":"while ( l <= r ) { m = parseInt ( ( l + r ) \/ 2 ) ;"}
{"text":"Check if the subarray sum is greater than K or not","code":"if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ;"}
{"text":"Update the maximum length","code":"max_len = m ; } } return max_len ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 2 , 3 , 4 , 5 ] ; var n = arr . length ; var k = 10 ; document . write ( solve ( arr , n , k ) ) ;"}
{"text":"Javascript implementation of the approach","code":"var MAX = 100001 var ROW = 10 var COl = 3 var indices = Array . from ( Array ( MAX ) , ( ) => new Array ( ) ) ;"}
{"text":"All possible solutions of the equation 1 \/ a + 1 \/ b + 1 \/ c = 1","code":"var test = [ [ 2 , 3 , 6 ] , [ 2 , 4 , 4 ] , [ 2 , 6 , 3 ] , [ 3 , 2 , 6 ] , [ 3 , 3 , 3 ] , [ 3 , 6 , 2 ] , [ 4 , 2 , 4 ] , [ 4 , 4 , 2 ] , [ 6 , 2 , 3 ] , [ 6 , 3 , 2 ] ] ;"}
{"text":"Function to find the triplets","code":"function find_triplet ( array , n ) { var answer = 0 ;"}
{"text":"Storing indices of the elements","code":"for ( var i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push ( i ) ; } for ( var i = 0 ; i < n ; i ++ ) { var y = array [ i ] ; for ( var j = 0 ; j < ROW ; j ++ ) { var s = test [ j ] [ 1 ] * y ;"}
{"text":"Check if y can act as the middle element of triplet with the given solution of 1 \/ a + 1 \/ b + 1 \/ c = 1","code":"if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; var x = s \/ test [ j ] [ 0 ] ; var z = s \/ test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; var l = 0 ; var r = indices [ x ] . length - 1 ; var first = - 1 ;"}
{"text":"Binary search to find the number of possible values of the first element","code":"while ( l <= r ) { var m = ( l + r ) \/ 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . length - 1 ; var third = - 1 ;"}
{"text":"Binary search to find the number of possible values of the third element","code":"while ( l <= r ) { var m = ( l + r ) \/ 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) {"}
{"text":"Contribution to the answer would be the multiplication of the possible values for the first and the third element","code":"answer += ( first + 1 ) * ( indices [ z ] . length - third ) ; } } } return answer ; }"}
{"text":"Driver code","code":"var array = [ 2 , 4 , 5 , 6 , 7 ] ; var n = array . length ; document . write ( find_triplet ( array , n ) ) ;"}
{"text":"JavaScript implementation of the above approach","code":"function distinct ( arr , n ) { let count = 0 ;"}
{"text":"if array has only one element , return 1","code":"if ( n == 1 ) return 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"For first element compare with only next element","code":"if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; }"}
{"text":"For remaining elements compare with both prev and next elements","code":"else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } }"}
{"text":"For last element compare with only prev element","code":"if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }"}
{"text":"Driver code","code":"let arr = [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ; let n = arr . length ; document . write ( distinct ( arr , n ) ) ;"}
{"text":"Function to check if an array is sorted or not","code":"function isSorted ( arr , N ) {"}
{"text":"Traverse the array arr [ ]","code":"for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } }"}
{"text":"Return true","code":"return true ; }"}
{"text":"Function to check if it is possible to sort the array w . r . t . first element","code":"function isPossibleToSort ( arr , N ) {"}
{"text":"Stores the ID of the first element","code":"let group = arr [ 0 ] [ 1 ] ;"}
{"text":"Traverse the array arr [ ]","code":"for ( let i = 1 ; i < N ; i ++ ) {"}
{"text":"If arr [ i ] . second is not equal to that of the group","code":"if ( arr [ i ] [ 1 ] != group ) { return \" \" ; } }"}
{"text":"If array is sorted","code":"if ( isSorted ( arr , N ) ) { return \" \" ; } else { return \" \" ; } }"}
{"text":"Driver Code","code":"let arr = [ [ 340000 , 2 ] , [ 15000 , 2 ] , [ 34000 , 2 ] , [ 10000 , 2 ] ] ; let N = arr . length ; document . write ( isPossibleToSort ( arr , N ) ) ;"}
{"text":"Structure of a node","code":"class Node { constructor ( data ) { this . data = data ; this . left = null ; this . right = null ; } } var root = null ; function AlphaScore ( ) { root = null ; } var sum = 0 , total_sum = 0 ; var mod = 1000000007 ;"}
{"text":"Function to calculate and return the Alpha Score of the journey","code":"function getAlphaScore ( node ) {"}
{"text":"Traverse left subtree","code":"if ( node . left != null ) getAlphaScore ( node . left ) ;"}
{"text":"Calculate the alpha score of the current step","code":"sum = ( sum + node . data ) % mod ;"}
{"text":"Update alpha score of the journey","code":"total_sum = ( total_sum + sum ) % mod ;"}
{"text":"Traverse right subtree","code":"if ( node . right != null ) getAlphaScore ( node . right ) ;"}
{"text":"Return","code":"return total_sum ; }"}
{"text":"Function to construct a BST from the sorted array [ ] arr","code":"function constructBST ( arr , start , end , root ) { if ( start > end ) return null ; var mid = parseInt ( ( start + end ) \/ 2 ) ;"}
{"text":"Insert root","code":"if ( root == null ) root = new Node ( arr [ mid ] ) ;"}
{"text":"Construct left subtree","code":"root . left = constructBST ( arr , start , mid - 1 , root . left ) ;"}
{"text":"Construct right subtree","code":"root . right = constructBST ( arr , mid + 1 , end , root . right ) ;"}
{"text":"Return root","code":"return root ; }"}
{"text":"Driver Code","code":"var arr = [ 10 , 11 , 12 ] ; var length = arr . length ;"}
{"text":"Sort the array","code":"arr . sort ( ) ; var root = null ;"}
{"text":"Construct BST from the sorted array","code":"root = constructBST ( arr , 0 , length - 1 , root ) ; document . write ( getAlphaScore ( root ) ) ;"}
{"text":"Function that return the index upto all the array elements are updated .","code":"function sortByFreq ( arr , n ) {"}
{"text":"Initialise maxE = - 1","code":"var maxE = - 1 ;"}
{"text":"Find the maximum element of arr [ ]","code":"for ( var i = 0 ; i < n ; i ++ ) { maxE = Math . max ( maxE , arr [ i ] ) ; }"}
{"text":"Create frequency array freq [ ]","code":"var freq = new Array ( maxE + 1 ) . fill ( 0 ) ;"}
{"text":"Update the frequency array as per the occurrence of element in arr [ ]","code":"for ( var i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; }"}
{"text":"Initialise cnt to 0","code":"var cnt = 0 ;"}
{"text":"Traversing freq [ ]","code":"for ( var i = 0 ; i <= maxE ; i ++ ) {"}
{"text":"If freq of an element is greater than 0 update the value of arr [ ] at index cnt & increment cnt","code":"if ( freq [ i ] > 0 ) { var value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } }"}
{"text":"Return cnt","code":"return cnt ; }"}
{"text":"Function that print array arr [ ] elements in sorted order","code":"function printSortedArray ( arr , cnt ) {"}
{"text":"Traversing arr [ ] till index cnt","code":"for ( var i = 0 ; i < cnt ; i ++ ) {"}
{"text":"Find frequency of elements","code":"var frequency = parseInt ( arr [ i ] \/ 100000 ) ;"}
{"text":"Find value at index i","code":"var value = 100000 - ( arr [ i ] % 100000 ) ;"}
{"text":"Traversing till frequency to print value at index i","code":"for ( var j = 0 ; j < frequency ; j ++ ) { document . write ( value + \" \" ) ; } } }"}
{"text":"Driver code","code":"var arr = [ 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 ] ;"}
{"text":"Size of array arr [ ]","code":"var n = arr . length ;"}
{"text":"Function call to get cnt","code":"var cnt = sortByFreq ( arr , n ) ;"}
{"text":"Sort the arr [ ] in decreasing order","code":"arr . sort ( ( a , b ) => b - a ) ;"}
{"text":"Function that prints elements in decreasing order","code":"printSortedArray ( arr , cnt ) ;"}
{"text":"Function to check whether we can make n rectangles of equal area","code":"function checkRectangles ( arr , n ) { let ans = true ;"}
{"text":"Sort the array","code":"arr . sort ( ) ;"}
{"text":"Find the area of any one rectangle","code":"var area = arr [ 0 ] * arr [ 4 * n - 1 ] ;"}
{"text":"Check whether we have two equal sides for each rectangle and that area of each rectangle formed is the same","code":"for ( let i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) {"}
{"text":"Update the answer to false if any condition fails","code":"ans = false ; break ; } }"}
{"text":"If possible","code":"if ( ans ) return true ; return false ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 ] ; var n = 2 ; if ( checkRectangles ( arr , n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to return the count of elements which are not in the correct position when sorted","code":"function cntElements ( arr , n ) {"}
{"text":"To store a copy of the original array","code":"let copy_arr = new Array ( n ) ;"}
{"text":"Copy the elements of the given array to the new array","code":"for ( let i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ;"}
{"text":"To store the required count","code":"let count = 0 ;"}
{"text":"Sort the original array","code":"arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If current element was not at the right position","code":"if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 2 , 6 , 2 , 4 , 5 ] ; let n = arr . length ; document . write ( cntElements ( arr , n ) ) ;"}
{"text":"Function to find the required pairs","code":"function findPairs ( arr , n , k , d ) {"}
{"text":"There has to be atleast 2 * k elements","code":"if ( n < 2 * k ) { document . write ( - 1 ) ; return ; }"}
{"text":"To store the pairs","code":"let pairs = [ ] ;"}
{"text":"Sort the given array","code":"arr . sort ( ( a , b ) => a - b ) ;"}
{"text":"For every possible pair","code":"for ( let i = 0 ; i < k ; i ++ ) {"}
{"text":"If the current pair is valid","code":"if ( arr [ n - k + i ] - arr [ i ] >= d ) {"}
{"text":"Insert it leto the pair vector","code":"let p = [ arr [ i ] , arr [ n - k + i ] ] ; pairs . push ( p ) ; } }"}
{"text":"If k pairs are not possible","code":"if ( pairs . length < k ) { document . write ( - 1 ) ; return ; }"}
{"text":"Print the pairs","code":"for ( let v of pairs ) { document . write ( \" \" + v [ 0 ] + \" \" + v [ 1 ] + \" \" + \" \" ) ; } }"}
{"text":"Driver code","code":"let arr = [ 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 ] ; let n = arr . length ; let k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ;"}
{"text":"Function to return the count of pairs from arr [ ] with the given sum","code":"function pairs_count ( arr , n , sum ) {"}
{"text":"To store the count of pairs","code":"let ans = 0 ;"}
{"text":"Sort the given array","code":"arr . sort ( ) ;"}
{"text":"Take two pointers","code":"let i = 0 , j = n - 1 ; while ( i < j ) {"}
{"text":"If sum is greater","code":"if ( arr [ i ] + arr [ j ] < sum ) i ++ ;"}
{"text":"If sum is lesser","code":"else if ( arr [ i ] + arr [ j ] > sum ) j -- ;"}
{"text":"If sum is equal","code":"else {"}
{"text":"Find the frequency of arr [ i ]","code":"let x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ;"}
{"text":"Find the frequency of arr [ j ]","code":"let y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ;"}
{"text":"If arr [ i ] and arr [ j ] are same then remove the extra number counted","code":"if ( x == y ) { let temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) \/ 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } }"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 5 , 7 , 5 , - 1 ] ; let n = arr . length ; let sum = 6 ; document . write ( pairs_count ( arr , n , sum ) ) ;"}
{"text":"javascript program to implement the above approach","code":"function check ( str ) { var min = Number . MAX_VALUE ; var max = Number . MIN_VALUE ; var sum = 0 ;"}
{"text":"for all the characters of the string","code":"for ( i = 0 ; i < str . length ; i ++ ) {"}
{"text":"find the ascii value of the character","code":"var ascii = parseInt ( str . charCodeAt ( i ) ) ;"}
{"text":"check if if its a valid character , if not then return false","code":"if ( ascii < 96 ascii > 122 ) return false ;"}
{"text":"calculate sum of all the characters ascii values","code":"sum += ascii ;"}
{"text":"find minimum ascii value from the string","code":"if ( min > ascii ) min = ascii ;"}
{"text":"find maximum ascii value from the string","code":"if ( max < ascii ) max = ascii ; }"}
{"text":"To get the previous element of the minimum ASCII value","code":"min -= 1 ;"}
{"text":"take the expected sum from the above equation","code":"var eSum = parseInt ( ( max * ( max + 1 ) ) \/ 2 ) - ( ( min * ( min + 1 ) ) \/ 2 ) ;"}
{"text":"check if the expected sum is equals to the calculated sum or not","code":"return sum == eSum ; }"}
{"text":"1 st example","code":"var str = \" \" ; if ( check ( str ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"2 nd example","code":"var str1 = \" \" ; if ( check ( str1 ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to find the sum of minimum of all subarrays","code":"function findKth ( arr , n , k ) { var missing = new Set ( ) ; var count = 0 ;"}
{"text":"Insert all the elements in a set","code":"for ( var i = 0 ; i < n ; i ++ ) missing . add ( arr [ i ] ) ;"}
{"text":"Find the maximum and minimum element","code":"var maxm = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var minm = arr . reduce ( ( a , b ) => Math . min ( a , b ) ) ;"}
{"text":"Traverse from the minimum to maximum element","code":"for ( var i = minm + 1 ; i < maxm ; i ++ ) {"}
{"text":"Check if \" i \" is missing","code":"if ( ! missing . has ( i ) ) count ++ ;"}
{"text":"Check if it is kth missing","code":"if ( count == k ) return i ; }"}
{"text":"If no kth element is missing","code":"return - 1 ; }"}
{"text":"Driver code","code":"var arr = [ 2 , 10 , 9 , 4 ] ; var n = arr . length ; var k = 5 ; document . write ( findKth ( arr , n , k ) ) ;"}
{"text":"Link list node","code":"class Node { constructor ( ) { this . data = 0 ; this . next = null ; } } var start = null ;"}
{"text":"Function to sort linked list","code":"function sortList ( head ) { var startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } }"}
{"text":"Function to add a node at the beginning of Linked List","code":"function push ( head_ref , new_data ) {"}
{"text":"allocate node","code":"var new_node = new Node ( ) ;"}
{"text":"put in the data","code":"new_node . data = new_data ;"}
{"text":"link the old list off the new node","code":"new_node . next = head_ref ;"}
{"text":"move the head to point to the new node","code":"head_ref = new_node ; start = head_ref ; }"}
{"text":"This function prints contents of linked list starting from the given node","code":"function printList ( node ) { while ( node != null ) { document . write ( node . data + \" \" ) ; node = node . next ; } }"}
{"text":"Driver Code","code":"start = null ;"}
{"text":"The constructed linked list is : 3 -> 5 -> 4 -> 6 -> 1 -> 2","code":"push ( start , 2 ) ; push ( start , 1 ) ; push ( start , 6 ) ; push ( start , 4 ) ; push ( start , 5 ) ; push ( start , 3 ) ; sortList ( start ) ; printList ( start ) ;"}
{"text":"Javascript program to sort an array such that sum of product of alternate element is minimum .","code":"function minSum ( arr , n ) {"}
{"text":"create evenArr [ ] and oddArr [ ]","code":"let evenArr = [ ] ; let oddArr = [ ] ;"}
{"text":"sort main array in ascending order","code":"arr . sort ( function ( a , b ) { return a - b ; } ) ;"}
{"text":"Put elements in oddArr [ ] and evenArr [ ] as per desired value .","code":"for ( let i = 0 ; i < n ; i ++ ) { if ( i < Math . floor ( n \/ 2 ) ) { oddArr . push ( arr [ i ] ) ; } else { evenArr . push ( arr [ i ] ) ; } }"}
{"text":"sort evenArr [ ] in descending order","code":"evenArr . sort ( function ( a , b ) { return b - a ; } ) ;"}
{"text":"merge both sub - array and calculate minimum sum of product of alternate elements","code":"let i = 0 , sum = 0 ; for ( let j = 0 ; j < evenArr . length ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; }"}
{"text":"Driver program","code":"let arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] ; let n = arr . length ; document . write ( \" \" + minSum ( arr , n ) + \" \" ) ; document . write ( \" \" ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + \" \" ) ; }"}
{"text":"Function to calculate minimum time to print all characters in the string","code":"funs minTime ( string word ) { int ans = 0 ;"}
{"text":"Current element where the pointer is pointing","code":"let curr = 0 ; for ( let i = 0 ; i < word . Length ; i ++ ) {"}
{"text":"Find index of that element","code":"int k = word [ i ] . charAt ( 0 ) - ' ' . charAt ( 0 ) ;"}
{"text":"Calculate absolute difference between pointer index and character index as clockwise distance","code":"let a = Math . abs ( curr - k ) ;"}
{"text":"Subtract clockwise time from 26 to get anti - clockwise time","code":"let b = 26 - Math . abs ( curr - k ) ;"}
{"text":"Add minimum of both times to the answer","code":"ans += Math . min ( a , b ) ;"}
{"text":"Add one unit time to print the character","code":"ans ++ ; curr = word [ i ] . charAt ( 0 ) - ' ' . charAt ( 0 ) ; }"}
{"text":"Print the final answer","code":"document . write ( ans ) ; }"}
{"text":"Given Input","code":"let str = \" \" ;"}
{"text":"Function Call","code":"minTime ( str ) ;"}
{"text":"Function to find the minimum number of steps required to reduce N to 1","code":"function reduceToOne ( N ) {"}
{"text":"Stores the number of steps required","code":"let cnt = 0 ; while ( N != 1 ) {"}
{"text":"If the value of N is equal to 2 or N is odd","code":"if ( N == 2 || ( N % 2 == 1 ) ) {"}
{"text":"Decrement N by 1","code":"N = N - 1 ;"}
{"text":"Increment cnt by 1","code":"cnt ++ ; }"}
{"text":"If N is even","code":"else if ( N % 2 == 0 ) {"}
{"text":"Update N","code":"N = Math . floor ( N \/ Math . floor ( N \/ 2 ) ) ;"}
{"text":"Increment cnt by 1","code":"cnt ++ ; } }"}
{"text":"Return the number of steps obtained","code":"return cnt ; }"}
{"text":"Driver Code","code":"let N = 35 ; document . write ( reduceToOne ( N ) ) ;"}
{"text":"Function to find the maximum number of diamonds that can be gained in exactly K minutes","code":"function maxDiamonds ( A , N , K ) {"}
{"text":"Stores all the array elements","code":"let pq = [ ] ;"}
{"text":"Push all the elements to the priority queue","code":"for ( let i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; }"}
{"text":"Stores the required result","code":"let ans = 0 ;"}
{"text":"Loop while the queue is not empty and K is positive","code":"pq . sort ( ( a , b ) => a - b ) while ( pq . length && K -- ) { pq . sort ( ( a , b ) => a - b )"}
{"text":"Store the top element from the pq","code":"let top = pq [ pq . length - 1 ] ;"}
{"text":"Pop it from the pq","code":"pq . pop ( ) ;"}
{"text":"Add it to the answer","code":"ans += top ;"}
{"text":"Divide it by 2 and push it back to the pq","code":"top = Math . floor ( top \/ 2 ) ; pq . push ( top ) ; }"}
{"text":"Print the answer","code":"document . write ( ans ) ; }"}
{"text":"Driver Code","code":"let A = [ 2 , 1 , 7 , 4 , 2 ] ; let K = 3 ; let N = A . length ; maxDiamonds ( A , N , K ) ;"}
{"text":"Function to find the minimum cost to make A [ i ] multiple of B [ i ] or vice - versa for every array element","code":"function MinimumCost ( A , B , N ) {"}
{"text":"Stores the minimum cost","code":"var totalCost = 0 ;"}
{"text":"Traverse the array","code":"for ( i = 0 ; i < N ; i ++ ) {"}
{"text":"Case 1 : Update A [ i ]","code":"var mod_A = B [ i ] % A [ i ] ; var totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ;"}
{"text":"Case 2 : Update B [ i ]","code":"var mod_B = A [ i ] % B [ i ] ; var totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ;"}
{"text":"Add the minimum of the above two cases","code":"totalCost += Math . min ( totalCost_A , totalCost_B ) ; }"}
{"text":"Return the resultant cost","code":"return totalCost ; }"}
{"text":"Driver Code","code":"var A = [ 3 , 6 , 3 ] ; var B = [ 4 , 8 , 13 ] ; var N = A . length ; document . write ( MinimumCost ( A , B , N ) ) ;"}
{"text":"Print the largest number divisible by 50","code":"function printLargestDivisible ( arr , N ) { var i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) {"}
{"text":"Counting number of 0 s and 7 s","code":"if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; }"}
{"text":"If count of 7 is divisible by 50","code":"if ( count7 % 50 == 0 ) { while ( count7 -- ) document . write ( 7 ) ; while ( count0 -- ) document . write ( 0 ) ; }"}
{"text":"If count of 7 is less than 5","code":"else if ( count7 < 5 ) { if ( count0 == 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; }"}
{"text":"If count of 7 is not divisible by 50","code":"else {"}
{"text":"Count of groups of 5 in which count of 7 s can be grouped","code":"count7 = count7 - count7 % 5 ; while ( count7 -- ) document . write ( 7 ) ; while ( count0 -- ) document . write ( 0 ) ; } }"}
{"text":"Given array","code":"var arr = [ 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 ] ;"}
{"text":"Size of the array","code":"var N = arr . length ; printLargestDivisible ( arr , N ) ;"}
{"text":"Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array","code":"function findMaxValByRearrArr ( arr , N ) {"}
{"text":"Sort the array in ascending order","code":"arr . sort ( ) ;"}
{"text":"Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements","code":"let res = 0 ;"}
{"text":"Generate all possible permutations of the array","code":"do {"}
{"text":"Stores sum of GCD ( arr [ i ] , i )","code":"let sum = 0 ;"}
{"text":"Traverse the array","code":"for ( let i = 0 ; i < N ; i ++ ) {"}
{"text":"Update sum","code":"sum += __gcd ( i + 1 , arr [ i ] ) ; }"}
{"text":"Update res","code":"res = Math . max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function next_permutation ( p ) { for ( let a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( let b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { let t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; }"}
{"text":"Driver Code","code":"let arr = [ 3 , 2 , 1 ] ; let N = arr . length ; document . write ( findMaxValByRearrArr ( arr , N ) ) ;"}
{"text":"Function to find the minimum count of elements required to be removed such that frequency of arr [ i ] equal to arr [ i ]","code":"function min_elements ( arr , N ) {"}
{"text":"Stores frequency of each element of the array","code":"var mp = new Map ( ) ;"}
{"text":"Traverse the array","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"Update frequency of arr [ i ]","code":"if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } }"}
{"text":"Stores minimum count of removals","code":"var cntMinRem = 0 ;"}
{"text":"Traverse the map","code":"mp . forEach ( ( value , key ) => {"}
{"text":"Stores key value of the map","code":"var i = key ;"}
{"text":"If frequency of i is less than i","code":"if ( mp . get ( i ) < i ) {"}
{"text":"Update cntMinRem","code":"cntMinRem += mp . get ( i ) ; }"}
{"text":"If frequency of i is greater than i","code":"else if ( mp . get ( i ) > i ) {"}
{"text":"Update cntMinRem","code":"cntMinRem += ( mp . get ( i ) - i ) ; } } ) ; return cntMinRem ; }"}
{"text":"Driver Code","code":"var arr = [ 2 , 4 , 1 , 4 , 2 ] ; var N = arr . length ; document . write ( min_elements ( arr , N ) ) ;"}
{"text":"Function to check if an array of equal elements with sum equal to the given array can be obtained or not","code":"function CheckAllarrayEqual ( arr , N ) {"}
{"text":"Base case","code":"if ( N == 1 ) { return true ; }"}
{"text":"Stores sum of array elements","code":"let totalSum = arr [ 0 ] ;"}
{"text":"Stores second largest array element","code":"let secMax = Number . MIN_VALUE ;"}
{"text":"Stores the largest array element","code":"let Max = arr [ 0 ] ;"}
{"text":"Traverse the array","code":"for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) {"}
{"text":"Update secMax","code":"secMax = Max ;"}
{"text":"Update Max","code":"Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) {"}
{"text":"Update secMax","code":"secMax = arr [ i ] ; }"}
{"text":"Update totalSum","code":"totalSum += arr [ i ] ; }"}
{"text":"If totalSum is less than secMax * ( N - 1 ) )","code":"if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; }"}
{"text":"If totalSum is not divisible by ( N - 1 )","code":"if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; }"}
{"text":"Driver Code","code":"let arr = [ 6 , 2 , 2 , 2 ] ; let N = arr . length ; if ( CheckAllarrayEqual ( arr , N ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text":"Function to count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element","code":"function Remove_one_element ( arr , n ) {"}
{"text":"Stores xor of odd and even indexed elements from the end","code":"let post_odd = 0 , post_even = 0 ;"}
{"text":"Stores xor of odd and even indexed elements from the start","code":"let curr_odd = 0 , curr_even = 0 ;"}
{"text":"Stores the required count","code":"let res = 0 ;"}
{"text":"Traverse the array in reverse","code":"for ( let i = n - 1 ; i >= 0 ; i -- ) {"}
{"text":"If i is odd","code":"if ( i % 2 != 0 ) post_odd ^= arr [ i ] ;"}
{"text":"If i is even","code":"else post_even ^= arr [ i ] ; }"}
{"text":"Traverse the array","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If i is odd","code":"if ( i % 2 != 0 ) post_odd ^= arr [ i ] ;"}
{"text":"If i is even","code":"else post_even ^= arr [ i ] ;"}
{"text":"Removing arr [ i ] , post_even stores XOR of odd indexed elements","code":"let X = curr_odd ^ post_even ;"}
{"text":"Removing arr [ i ] , post_odd stores XOR of even indexed elements","code":"let Y = curr_even ^ post_odd ;"}
{"text":"Check if they are equal","code":"if ( X == Y ) res ++ ;"}
{"text":"If i is odd , xor it with curr_odd","code":"if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ;"}
{"text":"If i is even , xor it with curr_even","code":"else curr_even ^= arr [ i ] ; }"}
{"text":"Finally print res","code":"document . write ( res ) ; }"}
{"text":"Given array","code":"let arr = [ 1 , 0 , 1 , 0 , 1 ] ;"}
{"text":"Given size","code":"let N = arr . length ;"}
{"text":"Function call","code":"Remove_one_element ( arr , N ) ;"}
{"text":"Function to count array indices whose removal makes sum of odd and even indexed elements equal","code":"function cntIndexesToMakeBalance ( arr , n ) {"}
{"text":"If size of the array is 1","code":"if ( n == 1 ) { return 1 ; }"}
{"text":"If size of the array is 2","code":"if ( n == 2 ) return 0 ;"}
{"text":"Stores sum of even - indexed elements of the given array","code":"let sumEven = 0 ;"}
{"text":"Stores sum of odd - indexed elements of the given array","code":"let sumOdd = 0 ;"}
{"text":"Traverse the array","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If i is an even number","code":"if ( i % 2 == 0 ) {"}
{"text":"Update sumEven","code":"sumEven += arr [ i ] ; }"}
{"text":"If i is an odd number","code":"else {"}
{"text":"Update sumOdd","code":"sumOdd += arr [ i ] ; } }"}
{"text":"Stores sum of even - indexed array elements till i - th index","code":"let currOdd = 0 ;"}
{"text":"Stores sum of odd - indexed array elements till i - th index","code":"let currEven = arr [ 0 ] ;"}
{"text":"Stores count of indices whose removal makes sum of odd and even indexed elements equal","code":"let res = 0 ;"}
{"text":"Stores sum of even - indexed elements after removing the i - th element","code":"let newEvenSum = 0 ;"}
{"text":"Stores sum of odd - indexed elements after removing the i - th element","code":"let newOddSum = 0 ;"}
{"text":"Traverse the array","code":"for ( let i = 1 ; i < n - 1 ; i ++ ) {"}
{"text":"If i is an odd number","code":"if ( i % 2 ) {"}
{"text":"Update currOdd","code":"currOdd += arr [ i ] ;"}
{"text":"Update newEvenSum","code":"newEvenSum = currEven + sumOdd - currOdd ;"}
{"text":"Update newOddSum","code":"newOddSum = currOdd + sumEven - currEven - arr [ i ] ; }"}
{"text":"If i is an even number","code":"else {"}
{"text":"Update currEven","code":"currEven += arr [ i ] ;"}
{"text":"Update newOddSum","code":"newOddSum = currOdd + sumEven - currEven ;"}
{"text":"Update newEvenSum","code":"newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; }"}
{"text":"If newEvenSum is equal to newOddSum","code":"if ( newEvenSum == newOddSum ) {"}
{"text":"Increase the count","code":"res ++ ; } }"}
{"text":"If sum of even - indexed and odd - indexed elements is equal by removing the first element","code":"if ( sumOdd == sumEven - arr [ 0 ] ) {"}
{"text":"Increase the count","code":"res ++ ; }"}
{"text":"If length of the array is an odd number","code":"if ( n % 2 == 1 ) {"}
{"text":"If sum of even - indexed and odd - indexed elements is equal by removing the last element","code":"if ( sumOdd == sumEven - arr [ n - 1 ] ) {"}
{"text":"Increase the count","code":"res ++ ; } }"}
{"text":"If length of the array is an even number","code":"else {"}
{"text":"If sum of even - indexed and odd - indexed elements is equal by removing the last element","code":"if ( sumEven == sumOdd - arr [ n - 1 ] ) {"}
{"text":"Increase the count","code":"res ++ ; } } return res ; }"}
{"text":"Driver Code","code":"let arr = [ 1 , 1 , 1 ] ; let n = arr . length ; document . write ( cntIndexesToMakeBalance ( arr , n ) ) ;"}
{"text":"Function to find the value of A and B whose sum is X and xor is Y","code":"function findNums ( X , Y ) {"}
{"text":"Initialize the two numbers","code":"let A , B ;"}
{"text":"Case 1 : X < Y","code":"if ( X < Y ) { A = - 1 ; B = - 1 ; }"}
{"text":"Case 2 : X - Y is odd","code":"else if ( Math . abs ( X - Y ) & 1 ) { A = - 1 ; B = - 1 ; }"}
{"text":"Case 3 : If both Sum and XOR are equal","code":"else if ( X == Y ) { A = 0 ; B = Y ; }"}
{"text":"Case 4 : If above cases fails","code":"else {"}
{"text":"Update the value of A","code":"A = ( X - Y ) \/ 2 ;"}
{"text":"Check if A & Y value is 0","code":"if ( ( A & Y ) == 0 ) {"}
{"text":"If true , update B","code":"B = ( A + Y ) ; }"}
{"text":"Otherwise assign - 1 to A , - 1 to B","code":"else { A = - 1 ; B = - 1 ; } }"}
{"text":"Print the numbers A and B","code":"document . write ( A + \" \" + B ) ; }"}
{"text":"Given Sum and XOR of 2 numbers","code":"let X = 17 , Y = 13 ;"}
{"text":"Function Call","code":"findNums ( X , Y ) ;"}
{"text":"Function to check if given range have equal number of increasing as well as decreasing subarrays","code":"function checkCount ( A , Q , q ) {"}
{"text":"Traverse each query","code":"for ( let i = 0 ; i < q ; i ++ ) { let L = Q [ i ] [ 0 ] ; let R = Q [ i ] [ 1 ] ;"}
{"text":"For 0 - based indexing","code":"L -- ; R -- ;"}
{"text":"Condition for same count of increasing & decreasing subarray","code":"if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" + \" \" ) ; } } }"}
{"text":"Driver Code","code":"let arr = [ 11 , 13 , 12 , 14 ] ; let Q = [ [ 1 , 4 ] , [ 2 , 4 ] ] ; let q = Q . length ; checkCount ( arr , Q , q ) ;"}
{"text":"Function to find the mean of pair product array of arr","code":"function pairProductMean ( arr , N ) {"}
{"text":"Store product of pairs","code":"var pairArray = [ ] ;"}
{"text":"Generate all unordered pairs","code":"for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var pairProduct = arr [ i ] * arr [ j ] ;"}
{"text":"Store product of pairs","code":"pairArray . push ( pairProduct ) ; } }"}
{"text":"Size of pairArray","code":"var length = pairArray . length ;"}
{"text":"Store sum of pairArray","code":"var sum = 0 ; for ( i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ;"}
{"text":"Stores the mean of pairArray","code":"var mean ;"}
{"text":"Find mean of pairArray","code":"if ( length != 0 ) mean = sum \/ length ; else mean = 0 ;"}
{"text":"Return the resultant mean","code":"return mean ; }"}
{"text":"Given array arr","code":"var arr = [ 1 , 2 , 4 , 8 ] ; var N = arr . length ;"}
{"text":"Function Call","code":"document . write ( pairProductMean ( arr , N ) . toFixed ( 2 ) ) ;"}
{"text":"Function to find the player who loses the game","code":"function findPlayer ( str , n ) {"}
{"text":"Moves for the first player","code":"let move_first = 0 ;"}
{"text":"Moves for the second player","code":"let move_sec = 0 ;"}
{"text":"Iterate over array of Strings","code":"for ( let i = 0 ; i < n - 1 ; i ++ ) {"}
{"text":"Check if the first and last character are the same","code":"if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . length - 1 ] ) {"}
{"text":"Check if String start and end with character '0'","code":"if ( str [ i ] [ 0 ] == 48 ) move_first ++ ; else move_sec ++ ; } }"}
{"text":"If first player have less moves","code":"if ( move_first <= move_sec ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } }"}
{"text":"Given array of Strings","code":"let str = [ \" \" , \" \" ] ; let N = str [ 0 ] . length ;"}
{"text":"Function Call","code":"findPlayer ( str , N ) ;"}
{"text":"Function to find the number greater than n whose Kth bit is set","code":"function find_next ( n , k ) {"}
{"text":"Iterate from N + 1","code":"let M = n + 1 ; while ( true ) {"}
{"text":"Check if Kth bit is set or not","code":"if ( ( M & ( 1 << k ) ) > 0 ) break ;"}
{"text":"Increment M for next number","code":"M ++ ; }"}
{"text":"Return the minimum value","code":"return M ; }"}
{"text":"Given N and K","code":"let N = 15 , K = 2 ;"}
{"text":"Function Call","code":"document . write ( find_next ( N , K ) ) ;"}
{"text":"JavaScript program to implement the above approach","code":"function largestString ( num , k ) {"}
{"text":"Final result String","code":"var ans = \" \" ; var str = num . split ( \" \" ) ; for ( const i of str ) {"}
{"text":"If the current char exceeds the character at the top of the stack","code":"while ( ans . length > 0 && ans [ ans . length - 1 ] < i && k > 0 ) {"}
{"text":"Remove from the end of the String","code":"ans = ans . substring ( 0 , ans . length - 1 ) ;"}
{"text":"Decrease k for the removal","code":"k -- ; }"}
{"text":"Insert current character","code":"ans += i ; }"}
{"text":"Perform remaining K deletions from the end of the String","code":"while ( ans . length > 0 && k -- > 0 ) { ans = ans . substring ( 0 , ans . length - 1 ) ; }"}
{"text":"Return the String","code":"return ans ; }"}
{"text":"Driver Code","code":"var str = \" \" ; var k = 1 ; document . write ( largestString ( str , k ) + \" \" ) ;"}
{"text":"Function that finds the maximum length of the sub - array that contains equal element on both halves of sub - array","code":"function maxLengthSubArray ( A , N ) {"}
{"text":"To store continuous occurence of the element","code":"let forward = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let backward = Array . from ( { length : N } , ( _ , i ) => 0 ) ;"}
{"text":"To store continuous forkward occurence","code":"for ( let i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; }"}
{"text":"To store continuous backward occurence","code":"for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; }"}
{"text":"To store the maximum length","code":"let ans = 0 ;"}
{"text":"Find maximum length","code":"for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . max ( ans , Math . min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; }"}
{"text":"Print the result","code":"document . write ( ans ) ; }"}
{"text":"Given array","code":"let arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 ] ;"}
{"text":"Size of the array","code":"let N = arr . length ;"}
{"text":"Function call","code":"maxLengthSubArray ( arr , N ) ;"}
{"text":"Function to find the minimum number of n digits divisible by all prime digits","code":"function minNum ( n ) { if ( n < 3 ) document . write ( - 1 ) ; else document . write ( ( 210 * ( parseInt ( Math . pow ( 10 , n - 1 ) \/ 210 ) + 1 ) ) ) ; }"}
{"text":"Driver Code","code":"var n = 5 ; minNum ( n ) ;"}
{"text":"Function to return the minimum String of length d having the sum of digits s","code":"function helper ( d , s ) {"}
{"text":"Return a String of length d","code":"let ans = [ ] ; for ( let i = 0 ; i < d ; i ++ ) { ans . push ( \" \" ) ; } for ( let i = d - 1 ; i >= 0 ; i -- ) {"}
{"text":"Greedily put 9 's in the end","code":"if ( s >= 9 ) { ans [ i ] = ' ' ; s -= 9 ; }"}
{"text":"Put remaining sum","code":"else { let c = String . fromCharCode ( s + ' ' . charCodeAt ( 0 ) ) ; ans [ i ] = c ; s = 0 ; } } return ans . join ( \" \" ) ; }"}
{"text":"Function to find the smallest number greater than Y whose sum of digits is X","code":"function findMin ( x , Y ) {"}
{"text":"Convert number y to String","code":"let y = Y . toString ( ) ; let n = y . length ; let p = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { p . push ( 0 ) ; }"}
{"text":"Maintain prefix sum of digits","code":"for ( let i = 0 ; i < n ; i ++ ) { p [ i ] = y [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( i > 0 ) { p [ i ] = p [ i ] + p [ i - 1 ] ; } }"}
{"text":"Iterate over Y from the back where k is current length of suffix","code":"for ( let i = n - 1 , k = 0 ; ; i -- , k ++ ) {"}
{"text":"Stores current digit","code":"let d = 0 ; if ( i >= 0 ) { d = y [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; }"}
{"text":"Increase current digit","code":"for ( let j = d + 1 ; j <= 9 ; j ++ ) { let r = j ;"}
{"text":"Sum upto current prefix","code":"if ( i > 0 ) { r += p [ i - 1 ] ; }"}
{"text":"Return answer if remaining sum can be obtained in suffix","code":"if ( x - r >= 0 && x - r <= 9 * k ) {"}
{"text":"Find suffix of length k having sum of digits x - r","code":"let suf = helper ( k , x - r ) ; let pre = \" \" ; if ( i > 0 ) pre = y . substring ( 0 , i ) ;"}
{"text":"Append current character","code":"let cur = String . fromCharCode ( j + ' ' . charCodeAt ( 0 ) ) ; pre += cur ;"}
{"text":"Return the result","code":"return pre + suf ; } } } }"}
{"text":"Given number and sum","code":"let x = 18 ; let y = 99 ;"}
{"text":"Function call","code":"document . write ( findMin ( x , y ) ) ;"}
{"text":"Function to generate and return the largest number","code":"function largestNumber ( n , X , Y ) { let maxm = Math . max ( X , Y ) ;"}
{"text":"Store the smaller in Y","code":"Y = X + Y - maxm ;"}
{"text":"Store the larger in X","code":"X = maxm ;"}
{"text":"Stores respective counts","code":"let Xs = 0 ; let Ys = 0 ; while ( n > 0 ) {"}
{"text":"If N is divisible by Y","code":"if ( n % Y == 0 ) {"}
{"text":"Append X , N times to the answer","code":"Xs += n ;"}
{"text":"Reduce N to zero","code":"n = 0 ; } else {"}
{"text":"Reduce N by X","code":"n -= X ;"}
{"text":"Append Y , X times to the answer","code":"Ys += X ; } }"}
{"text":"If number can be formed","code":"if ( n == 0 ) { while ( Xs -- > 0 ) document . write ( X ) ; while ( Ys -- > 0 ) document . write ( Y ) ; }"}
{"text":"Otherwise","code":"else document . write ( \" \" ) ; }"}
{"text":"Driver Code","code":"let n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ;"}
{"text":"Javascript implementation of the above approach","code":"function minChanges ( str , N ) { var res ; var count0 = 0 , count1 = 0 ;"}
{"text":"Traverse input string and store the count of 0","code":"str . split ( ' ' ) . forEach ( x => { count0 += ( x == ' ' ) ; } ) ; res = count0 ;"}
{"text":"Traverse the input string again to find minimum number of flips","code":"str . split ( ' ' ) . forEach ( x => { count0 -= ( x == ' ' ) ; count1 += ( x == ' ' ) ; res = Math . min ( res , count1 + count0 ) ; } ) ; return res ; }"}
{"text":"Driver code","code":"var N = 9 ; var str = \" \" ; document . write ( minChanges ( str , N ) ) ;"}
{"text":"Function to find the missing number such that maximum absolute difference is minimum","code":"function missingnumber ( n , arr ) { let mn = 10000 ; let mx = - 10000 ;"}
{"text":"Loop to find the maximum and minimum adjacent element to missing number","code":"for ( let i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } let res = ( mx + mn ) \/ 2 ; return res ; }"}
{"text":"Driver Code","code":"let n = 5 ; let arr = [ - 1 , 10 , - 1 , 12 , - 1 ] ;"}
{"text":"Function Call","code":"let res = missingnumber ( n , arr ) ; document . write ( res ) ;"}
{"text":"Function to find the length of the longest common substring of the string X and Y","code":"function LCSubStr ( A , B , m , n ) {"}
{"text":"LCSuff [ i ] [ j ] stores the lengths of the longest common suffixes of substrings","code":"let LCSuff = Array ( m + 1 ) . fill ( Array ( n + 1 ) ) ; let result = 0 ;"}
{"text":"Itearate over strings A and B","code":"for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) {"}
{"text":"If first row or column","code":"if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ;"}
{"text":"If matching is found","code":"else if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; if ( LCSuff [ i ] [ j ] > result ) { result = LCSuff [ i ] [ j ] ; } }"}
{"text":"Otherwise , if matching is not found","code":"else LCSuff [ i ] [ j ] = 0 ; } } result ++ ;"}
{"text":"Finally , return the resultant maximum value LCS","code":"return result ; }"}
{"text":"Driver Code","code":"let A = \" \" ; let B = \" \" ; let M = A . length ; let N = B . length ;"}
{"text":"Function Call","code":"document . write ( LCSubStr ( A , B , M , N ) ) ;"}
{"text":"Javascript program for the above approach","code":"var maxN = 20 ; var maxSum = 50 ; var minSum = 50 ; var base = 50 ;"}
{"text":"To store the states of DP","code":"var dp = Array . from ( Array ( maxN ) , ( ) => Array ( maxSum + minSum ) ) ; var v = Array . from ( Array ( maxN ) , ( ) => Array ( maxSum + minSum ) ) ;"}
{"text":"Function to find count of subsets with a given sum","code":"function findCnt ( arr , i , required_sum , n ) {"}
{"text":"Base case","code":"if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; }"}
{"text":"If an already computed subproblem occurs","code":"if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ;"}
{"text":"Set the state as solved","code":"v [ i ] [ required_sum + base ] = 1 ;"}
{"text":"Recurrence relation","code":"dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }"}
{"text":"Function to count ways to split array into pair of subsets with difference K","code":"function countSubsets ( arr , K , n ) {"}
{"text":"Store the total sum of element of the array","code":"var sum = 0 ;"}
{"text":"Traverse the array","code":"for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"Calculate sum of array elements","code":"sum += arr [ i ] ; }"}
{"text":"Store the required sum","code":"var S1 = ( sum + K ) \/ 2 ;"}
{"text":"Print the number of subsets with sum equal to S1","code":"document . write ( findCnt ( arr , 0 , S1 , n ) ) ; }"}
{"text":"Driver Code","code":"var arr = [ 1 , 1 , 2 , 3 ] ; var N = arr . length ; var K = 1 ;"}
{"text":"Function Call","code":"countSubsets ( arr , K , N ) ;"}
{"text":"Javascript program for above approach","code":"var dp = Array ( 105 ) . fill ( ) . map ( ( ) => Array ( 605 ) . fill ( 0.0 ) ) ;"}
{"text":"Function to calculate the probability for the given sum to be equal to sum in N throws of dice","code":"function find ( N , sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ;"}
{"text":"Base cases","code":"if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( 1.0 \/ 6 ) ; else return 0 ; } for ( var i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) \/ 6 ; return dp [ N ] [ sum ] ; }"}
{"text":"Driver Code","code":"var N = 4 , a = 13 , b = 17 ; var probability = 0.0 ;"}
{"text":"Calculate probability of all sums from a to b","code":"for ( sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ;"}
{"text":"Print the answer","code":"document . write ( probability . toFixed ( 6 ) ) ;"}
{"text":"Function to find the minimum number to steps to reduce N to 0","code":"function count ( n ) {"}
{"text":"Dictionary for storing the precomputed sum","code":"var dp = new Map ( ) ;"}
{"text":"Bases Cases","code":"dp . set ( 0 , 0 ) ; dp . set ( 1 , 1 ) ;"}
{"text":"Check if n is not in dp then only call the function so as to reduce no of recursive calls","code":"if ( ! dp . has ( n ) ) dp . set ( n , 1 + Math . min ( n % 2 + count ( parseInt ( n \/ 2 ) ) , n % 3 + count ( parseInt ( n \/ 3 ) ) ) ) ;"}
{"text":"Return the answer","code":"return dp . get ( n ) ; }"}
{"text":"Given number N","code":"var N = 6 ;"}
{"text":"Function call","code":"document . write ( count ( N ) ) ;"}
{"text":"Function to find the minimum number of operations required to change all the array of zeros such that every element is greater than the given array","code":"function find_minimum_operations ( n , b , k ) {"}
{"text":"Declaring the difference array of size N","code":"let d = new Array ( n + 1 ) ; d . fill ( 0 ) ;"}
{"text":"Number of operations","code":"let i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"First update the D [ i ] value with the previous value","code":"if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; }"}
{"text":"The index i has to be incremented","code":"if ( b [ i ] > d [ i ] ) {"}
{"text":"We have to perform ( b [ i ] - d [ i ] ) operations more","code":"operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ;"}
{"text":"Increment the range i to i + k by need","code":"d [ i ] += need ;"}
{"text":"Check if i + k is valid index","code":"if ( i + k <= n ) { d [ i + k ] -= need ; } } } document . write ( operations ) ; }"}
{"text":"Driver code","code":"let n = 5 ; let b = [ 1 , 2 , 3 , 4 , 5 ] ; let k = 2 ;"}
{"text":"Function Call","code":"find_minimum_operations ( n , b , k ) ;"}
{"text":"Function to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell","code":"function ways ( arr , K ) { let R = arr . length ; let C = arr [ 0 ] . length ; let preSum = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { preSum [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) { preSum [ i ] [ j ] = 0 ; } }"}
{"text":"Loop to find prefix sum of the given matrix","code":"for ( let r = R - 1 ; r >= 0 ; r -- ) { for ( let c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } }"}
{"text":"dp ( r , c , 1 ) = 1 if preSum [ r ] else 0","code":"let dp = new Array ( K + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( R ) ; for ( let j = 0 ; j < R ; j ++ ) { dp [ i ] [ j ] = new Array ( C ) ; for ( let k = 0 ; k < C ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } }"}
{"text":"Loop to iterate over the dp table of the given matrix","code":"for ( let k = 1 ; k <= K ; k ++ ) { for ( let r = R - 1 ; r >= 0 ; r -- ) { for ( let c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( let r1 = r + 1 ; r1 < R ; r1 ++ ) {"}
{"text":"Check if can cut horizontally at r1 , at least one apple in matrix ( r , c ) -> r1 , C - 1","code":"if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( let c1 = c + 1 ; c1 < C ; c1 ++ ) {"}
{"text":"Check if we can cut vertically at c1 , at least one apple in matrix ( r , c ) -> R - 1 , c1","code":"if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; }"}
{"text":"Driver code","code":"let arr = [ [ 1 , 0 , 0 ] , [ 1 , 1 , 1 ] , [ 0 , 0 , 0 ] ] ; let k = 3 ;"}
{"text":"Function Call","code":"document . write ( ways ( arr , k ) ) ;"}
{"text":"Javascript implementation for the above approach","code":"let p = 1000000007 ;"}
{"text":"Iterative Function to calculate ( x ^ y ) % p in O ( log y )","code":"function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) {"}
{"text":"If y is odd , multiply x with result","code":"if ( y % 2 == 1 ) res = ( res * x ) % p ;"}
{"text":"y must be even now","code":"y = y >> 1 ; x = ( x * x ) % p ; } return res ; }"}
{"text":"Iterative Function to calculate ( nCr ) % p and save in f [ n ] [ r ]","code":"function nCr ( n , p , f , m ) { for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) {"}
{"text":"If j > i then C ( i , j ) = 0","code":"if ( j > i ) { f [ i ] [ j ] = 0 ; }"}
{"text":"If iis equal to j then C ( i , j ) = 1","code":"else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } }"}
{"text":"Function calculate the Final answer","code":"function ProductOfSubsets ( arr , n , m ) { let f = new Array ( n + 1 ) ; for ( var i = 0 ; i < f . length ; i ++ ) { f [ i ] = new Array ( 2 ) ; } nCr ( n , p - 1 , f , m ) ; arr . sort ( ) ;"}
{"text":"Initialize ans","code":"let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"x is count of occurence of arr [ i ] in different set such that index of arr [ i ] in those sets divides K completely .","code":"let x = 0 ; for ( let j = 1 ; j <= m ; j ++ ) {"}
{"text":"Finding the count of arr [ i ] by placing it at index which divides K completely","code":"if ( m % j == 0 ) {"}
{"text":"By Fermat 's theorem","code":"x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } document . write ( ans + \" \" ) ; }"}
{"text":"Driver Code","code":"let arr = [ 4 , 5 , 7 , 9 , 3 ] ; let K = 4 ; let N = arr . length ; ProductOfSubsets ( arr , N , K ) ;"}
{"text":"Function to count the number of ways to write N as sum of k non - negative integers","code":"function countWays ( n , m ) {"}
{"text":"Initialise dp [ ] [ ] array","code":"var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ;"}
{"text":"Only 1 way to choose the value with sum K","code":"for ( var i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; }"}
{"text":"Initialise sum","code":"var sum ; for ( var i = 2 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { sum = 0 ;"}
{"text":"Count the ways from previous states","code":"for ( var k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; }"}
{"text":"Update the sum","code":"dp [ i ] [ j ] = sum ; } }"}
{"text":"Return the final count of ways","code":"return dp [ m ] [ n ] ; }"}
{"text":"Driver Code","code":"var N = 2 , K = 3 ;"}
{"text":"Function call","code":"document . write ( countWays ( N , K ) ) ;"}
{"text":"Function to count the number of ways to write N as sum of k non - negative integers","code":"function countWays ( n , m ) {"}
{"text":"Initialise dp [ ] [ ] array","code":"let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = 0 ; }"}
{"text":"Fill the dp [ ] [ ] with sum = m","code":"for ( let i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } }"}
{"text":"Iterate the dp [ ] [ ] to fill the dp [ ] [ ] array","code":"for ( let i = 2 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) {"}
{"text":"Condition for first column","code":"if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; }"}
{"text":"Else fill the dp [ ] [ ] with sum till ( i , j )","code":"else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;"}
{"text":"If reach the end , then return the value","code":"if ( i == m && j == n ) { return dp [ i ] [ j ] ; }"}
{"text":"Update at current index","code":"dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Number . MIN_VALUE ; }"}
{"text":"Driver Code","code":"let N = 2 , K = 3 ;"}
{"text":"Function call","code":"document . write ( countWays ( N , K ) ) ;"}
{"text":"Function to pre - store primes","code":"function SieveOfEratosthenes ( MAX , primes ) { let prime = new Array ( MAX + 1 ) . fill ( true ) ;"}
{"text":"Sieve method to check if prime or not","code":"for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) {"}
{"text":"Multiples","code":"for ( let i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } }"}
{"text":"Pre - store all the primes","code":"for ( let i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . push ( i ) ; } }"}
{"text":"Function to find the longest subsequence","code":"function findLongest ( A , n ) {"}
{"text":"Hash map","code":"let mpp = new Map ( ) ; let primes = new Array ( ) ;"}
{"text":"Call the function to pre - store the primes","code":"SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; let dp = new Array ( n ) ; dp . fill ( 0 )"}
{"text":"Initialize last element with 1 as that is the longest possible","code":"dp [ n - 1 ] = 1 ; mpp . set ( A [ n - 1 ] , n - 1 ) ;"}
{"text":"Iterate from the back and find the longest","code":"for ( let i = n - 2 ; i >= 0 ; i -- ) {"}
{"text":"Get the number","code":"let num = A [ i ] ;"}
{"text":"Initialize dp [ i ] as 1 as the element will only me in the subsequence .","code":"dp [ i ] = 1 ; let maxi = 0 ;"}
{"text":"Iterate in all the primes and multiply to get the next element","code":"for ( let it of primes ) {"}
{"text":"Next element if multiplied with it","code":"let xx = num * it ;"}
{"text":"If exceeds the last element then break","code":"if ( xx > A [ n - 1 ] ) break ;"}
{"text":"If the number is there in the array","code":"else if ( mpp . get ( xx ) ) {"}
{"text":"Get the maximum most element","code":"dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ mpp . get ( xx ) ] ) ; } }"}
{"text":"Hash the element","code":"mpp . set ( A [ i ] , i ) ; } let ans = 1 ;"}
{"text":"Find the longest","code":"for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , dp [ i ] ) ; } return ans ; }"}
{"text":"Driver Code","code":"let a = [ 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 ] ; let n = a . length ; document . write ( findLongest ( a , n ) ) ;"}
{"text":"Function to find the number of Bit Strings of length N with K adjacent set bits","code":"function waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) {"}
{"text":"Base Case when we form bit string of length n","code":"if ( currentIndex == n ) {"}
{"text":"if f ( bit string ) = k , count this way","code":"if ( adjacentSetBits == k ) return 1 ; return 0 ; } let noOfWays = 0 ;"}
{"text":"Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset","code":"if ( lastBit == 1 ) {"}
{"text":"set the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;"}
{"text":"unset the bit at currentIndex","code":"noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; }"}
{"text":"Driver Code","code":"let n = 5 , k = 2 ;"}
{"text":"total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )","code":"let totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; document . write ( \" \" + totalWays ) ;"}
{"text":"find the postfix sum array","code":"function postfix ( a , n ) { for ( let i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } }"}
{"text":"modify the array such that we don 't  have to compute the products which  are obtained before","code":"function modify ( a , n ) { for ( let i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } }"}
{"text":"finding sum of all combination taken 1 to N at a time","code":"function allCombination ( a , n ) { let sum = 0 ;"}
{"text":"sum taken 1 at time is simply sum of 1 - N","code":"for ( let i = 1 ; i <= n ; i ++ ) { sum += i ; } document . write ( \" \" + sum + \" \" ) ;"}
{"text":"for sum of products for all combination","code":"for ( let i = 1 ; i < n ; i ++ ) {"}
{"text":"finding postfix array","code":"postfix ( a , n - i + 1 ) ;"}
{"text":"sum of products taken i + 1 at a time","code":"sum = 0 ; for ( let j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } document . write ( \" \" + ( i + 1 ) + \" \" + sum + \" \" ) ;"}
{"text":"modify the array for overlapping problem","code":"modify ( a , n ) ; } }"}
{"text":"Driver 's Code","code":"let n = 5 ; let a = new Array ( n ) ;"}
{"text":"storing numbers from 1 to N","code":"for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = i + 1 ; }"}
{"text":"calling allCombination","code":"allCombination ( a , n ) ;"}
{"text":"Returns count of ways to reach n - th stair using 1 or 2 or 3 steps .","code":"function findStep ( n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }"}
{"text":"Driver code","code":"let n = 4 ; document . write ( findStep ( n ) ) ;"}
{"text":"A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum","code":"function isSubsetSum ( arr , n , sum ) {"}
{"text":"Base Cases","code":"if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ;"}
{"text":"If last element is greater than sum , then ignore it","code":"if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ;"}
{"text":"else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element","code":"return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }"}
{"text":"Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false","code":"function findPartition ( arr , n ) {"}
{"text":"Calculate sum of the elements in array","code":"let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;"}
{"text":"If sum is odd , there cannot be two subsets with equal sum","code":"if ( sum % 2 != 0 ) return false ;"}
{"text":"Find if there is subset with sum equal to half of total sum","code":"return isSubsetSum ( arr , n , Math . floor ( sum \/ 2 ) ) ; }"}
{"text":"Driver code","code":"let arr = [ 3 , 1 , 5 , 9 , 12 ] ; let n = arr . length ;"}
{"text":"Function call","code":"if ( findPartition ( arr , n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false","code":"function findPartiion ( arr , n ) { let sum = 0 ; let i , j ;"}
{"text":"Calculate sum of all elements","code":"for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; let part = new Array ( parseInt ( sum \/ 2 + 1 , 10 ) ) ;"}
{"text":"Initialize the part array as 0","code":"for ( i = 0 ; i <= parseInt ( sum \/ 2 , 10 ) ; i ++ ) { part [ i ] = false ; }"}
{"text":"Fill the partition table in bottom up manner","code":"for ( i = 0 ; i < n ; i ++ ) {"}
{"text":"The element to be included in the sum cannot be greater than the sum","code":"for ( j = parseInt ( sum \/ 2 , 10 ) ; j >= arr [ i ] ; j -- ) {"}
{"text":"Check if sum - arr [ i ] could be formed from a subset using elements before index i","code":"if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ parseInt ( sum \/ 2 , 10 ) ] ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] ; let n = arr . length ;"}
{"text":"Function call","code":"if ( findPartiion ( arr , n ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"Function to find binomial coefficient","code":"function binomialCoeff ( n , r ) { if ( r > n ) return 0 ; let m = 1000000007 ; let inv = new Array ( r + 1 ) . fill ( 0 ) ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ;"}
{"text":"Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007","code":"for ( let i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - Math . floor ( m \/ i ) * inv [ m % i ] % m ; } let ans = 1 ;"}
{"text":"for 1 \/ ( r ! ) part","code":"for ( let i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; }"}
{"text":"for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part","code":"for ( let i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; }"}
{"text":"Driver code","code":"let n = 5 , r = 2 ; document . write ( \" \" + n + \" \" + r + \" \" + binomialCoeff ( n , r ) + \" \" ) ;"}
{"text":"Function to find the gcd of two numbers","code":"function gcd ( a , b ) {"}
{"text":"Base case","code":"if ( a < b ) { let t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ;"}
{"text":"Recurse","code":"return gcd ( b , a % b ) ; }"}
{"text":"Function to print the answer","code":"function printAnswer ( x , y ) {"}
{"text":"GCD of X and Y","code":"let val = gcd ( x , y ) ;"}
{"text":"If GCD is power of 2","code":"if ( ( val & ( val - 1 ) ) == 0 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; }"}
{"text":"Given X and Y","code":"let x = 4 ; let y = 7 ;"}
{"text":"Function call","code":"printAnswer ( x , y ) ;"}
{"text":"Function to return the element in the rth row and cth column from the required matrix","code":"function getElement ( N , r , c ) {"}
{"text":"Condition for lower half of matrix","code":"if ( r > c ) return 0 ;"}
{"text":"Condition if element is in first row","code":"if ( r == 1 ) { return c ; }"}
{"text":"Starting element of AP in row r","code":"let a = ( r + 1 ) * parseInt ( Math . pow ( 2 , ( r - 2 ) ) ) ;"}
{"text":"Common difference of AP in row r","code":"let d = parseInt ( Math . pow ( 2 , ( r - 1 ) ) ) ;"}
{"text":"Position of element to find in AP in row r","code":"c = c - r ; let element = a + d * c ; return element ; }"}
{"text":"Driver Code","code":"let N = 4 , R = 3 , C = 4 ; document . write ( getElement ( N , R , C ) ) ;"}
{"text":"Function to insert X in N and return the minimum value string","code":"function MinValue ( N , X ) {"}
{"text":"Variable to store length of string N","code":"let len = N . length ;"}
{"text":"Variable to denote the position where X must be added","code":"let position = len + 1 ;"}
{"text":"If the given string N represent a negative value","code":"if ( N [ 0 ] == ' ' ) {"}
{"text":"X must be place at the last index where is greater than N [ i ]","code":"for ( let i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) < X ) { position = i ; } } } else {"}
{"text":"For positive numbers , X must be placed at the last index where it is smaller than N [ i ]","code":"for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) > X ) { position = i ; } } }"}
{"text":"Insert X at that position","code":"const c = String . fromCharCode ( X + ' ' . charCodeAt ( 0 ) ) ; let str = N . slice ( 0 , position ) + c + N . slice ( position ) ;"}
{"text":"Return the string","code":"return str ; }"}
{"text":"Given Input","code":"let N = \" \" ; let X = 1 ;"}
{"text":"Function Call","code":"document . write ( MinValue ( N , X ) ) ;"}
{"text":"Function to check the binary number is divisible by K","code":"function divisibleByk ( s , n , k ) {"}
{"text":"Array poweroftwo will store pow ( 2 , i ) % k","code":"let poweroftwo = new Array ( n ) ;"}
{"text":"Initializing the first element in Array","code":"poweroftwo [ 0 ] = 1 % k ; for ( let i = 1 ; i < n ; i ++ ) {"}
{"text":"Storing every pow ( 2 , i ) % k value in the array","code":"poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; }"}
{"text":"To store the remaining","code":"let rem = 0 ;"}
{"text":"Iterating till N","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If current bit is 1","code":"if ( s [ n - i - 1 ] == ' ' ) {"}
{"text":"Updating rem","code":"rem += ( poweroftwo [ i ] ) ; rem %= k ; } }"}
{"text":"If completely divisible","code":"if ( rem == 0 ) { return \" \" ; }"}
{"text":"If not Completely divisible","code":"else return \" \" ; }"}
{"text":"Given Input","code":"let s = \" \" ; let k = 9 ;"}
{"text":"length of string s","code":"let n = s . length ;"}
{"text":"Function Call","code":"document . write ( divisibleByk ( s , n , k ) ) ;"}
{"text":"Function to find the maximum sum of count of 0 s in the left substring and count of 1 s in the right substring by splitting the string","code":"function maxSumbySplittingstring ( str , N ) {"}
{"text":"Stores count of 1 s the in binary string","code":"var cntOne = 0 ;"}
{"text":"Traverse the binary string","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"If current character is '1'","code":"if ( str [ i ] == ' ' ) {"}
{"text":"Update cntOne","code":"cntOne ++ ; } }"}
{"text":"Stores count of 0 s","code":"var zero = 0 ;"}
{"text":"Stores count of 1 s","code":"var one = 0 ;"}
{"text":"Stores maximum sum of count of 0 s and 1 s by splitting the string","code":"var res = 0 ;"}
{"text":"Traverse the binary string","code":"for ( var i = 0 ; i < N - 1 ; i ++ ) {"}
{"text":"If current character is '0'","code":"if ( str [ i ] == ' ' ) {"}
{"text":"Update zero","code":"zero ++ ; }"}
{"text":"If current character is '1'","code":"else {"}
{"text":"Update one","code":"one ++ ; }"}
{"text":"Update res","code":"res = Math . max ( res , zero + cntOne - one ) ; } return res ; }"}
{"text":"Driver Code","code":"var str = \" \" ; var N = str . length ; document . write ( maxSumbySplittingstring ( str , N ) ) ;"}
{"text":"Function to find the maximum count of pairs required to be removed such that subsequence of string does not contain any valid parenthesis","code":"function cntBalancedParenthesis ( s , N ) {"}
{"text":"Stores count of pairs of balanced parenthesis","code":"var cntPairs = 0 ;"}
{"text":"Stores count of curly balanced parenthesis","code":"var cntCurly = 0 ;"}
{"text":"Stores count of small balanced parenthesis","code":"var cntSml = 0 ;"}
{"text":"Stores count of square balanced parenthesis","code":"var cntSqr = 0 ;"}
{"text":"Iterate over characters of the string","code":"for ( i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' ' ) {"}
{"text":"Update cntCurly","code":"cntCurly ++ ; } else if ( s . charAt ( i ) == ' ' ) {"}
{"text":"Update cntSml","code":"cntSml ++ ; } else if ( s . charAt ( i ) == ' ' ) {"}
{"text":"Update cntSqr","code":"cntSqr ++ ; } else if ( s . charAt ( i ) == ' ' && cntCurly > 0 ) {"}
{"text":"Update cntCurly","code":"cntCurly -- ;"}
{"text":"Update cntPairs","code":"cntPairs ++ ; } else if ( s . charAt ( i ) == ' ' && cntSml > 0 ) {"}
{"text":"Update cntSml","code":"cntSml -- ;"}
{"text":"Update cntPairs","code":"cntPairs ++ ; } else if ( s . charAt ( i ) == ' ' && cntSqr > 0 ) {"}
{"text":"Update cntSml","code":"cntSqr -- ;"}
{"text":"Update cntPairs","code":"cntPairs ++ ; } } document . write ( cntPairs ) ; }"}
{"text":"Given String","code":"var s = \" \" ; var N = s . length ;"}
{"text":"Function call","code":"cntBalancedParenthesis ( s , N ) ;"}
{"text":"Function to check if there is arc intersection or not","code":"function arcIntersection ( S , len ) { var stk = [ ] ;"}
{"text":"Traverse the string S","code":"for ( var i = 0 ; i < len ; i ++ ) {"}
{"text":"Insert all the elements in the stack one by one","code":"stk . push ( S [ i ] ) ; if ( stk . length >= 2 ) {"}
{"text":"Extract the top element","code":"var temp = stk [ stk . length - 1 ] ;"}
{"text":"Pop out the top element","code":"stk . pop ( ) ;"}
{"text":"Check if the top element is same as the popped element","code":"if ( stk [ stk . length - 1 ] == temp ) { stk . pop ( ) ; }"}
{"text":"Otherwise","code":"else { stk . push ( temp ) ; } } }"}
{"text":"If the stack is empty","code":"if ( stk . length == 0 ) return 1 ; return 0 ; }"}
{"text":"Function to check if there is arc intersection or not for the given array of strings","code":"function countString ( arr , N ) {"}
{"text":"Stores count of string not having arc intersection","code":"var count = 0 ;"}
{"text":"Iterate through array","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"Length of every string","code":"var len = arr [ i ] . length ;"}
{"text":"Function Call","code":"count += arcIntersection ( arr [ i ] , len ) ; }"}
{"text":"Print the desired count","code":"document . write ( count + \" \" ) ; }"}
{"text":"Driver Code","code":"var arr = [ \" \" , \" \" , \" \" ] ; var N = arr . length ;"}
{"text":"Function Call","code":"countString ( arr , N ) ;"}
{"text":"Function to convert the binary string into octal representation","code":"function ConvertequivalentBase8 ( S ) {"}
{"text":"Stores binary representation of the decimal value [ 0 - 7 ]","code":"let mp = new Map ( ) ;"}
{"text":"Stores the decimal values of binary Strings [ 0 - 7 ]","code":"mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ; mp . set ( \" \" , ' ' ) ;"}
{"text":"Stores length of S","code":"let N = S . length ; if ( N % 3 == 2 ) {"}
{"text":"Update S","code":"S = \" \" + S ; } else if ( N % 3 == 1 ) {"}
{"text":"Update S","code":"S = \" \" + S ; }"}
{"text":"Update N","code":"N = S . length ;"}
{"text":"Stores octal representation of the binary String","code":"let oct = \" \" ;"}
{"text":"Traverse the binary String","code":"for ( let i = 0 ; i < N ; i += 3 ) {"}
{"text":"Stores 3 consecutive characters of the binary String","code":"let temp = S . substring ( i , i + 3 ) ;"}
{"text":"Append octal representation of temp","code":"oct += mp . get ( temp ) ; } return oct ; }"}
{"text":"Function to check if binary String is divisible by 9 or not","code":"function binString_div_9 ( S , N ) {"}
{"text":"Stores octal representation of S","code":"let oct = \" \" ; oct = ConvertequivalentBase8 ( S ) ;"}
{"text":"Stores sum of elements present at odd positions of oct","code":"let oddSum = 0 ;"}
{"text":"Stores sum of elements present at odd positions of oct","code":"let evenSum = 0 ;"}
{"text":"Stores length of oct","code":"let M = oct . length ;"}
{"text":"Traverse the String oct","code":"for ( let i = 0 ; i < M ; i += 2 )"}
{"text":"Update oddSum","code":"oddSum += ( oct [ i ] - ' ' ) ;"}
{"text":"Traverse the String oct","code":"for ( let i = 1 ; i < M ; i += 2 ) {"}
{"text":"Update evenSum","code":"evenSum += ( oct [ i ] - ' ' ) ; }"}
{"text":"Stores octal representation of 9","code":"let Oct_9 = 11 ;"}
{"text":"If absolute value of ( oddSum - evenSum ) is divisible by Oct_9","code":"if ( Math . abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return \" \" ; } return \" \" ; }"}
{"text":"Driver Code","code":"let S = \" \" ; let N = S . length ; document . write ( binString_div_9 ( S , N ) ) ;"}
{"text":"Function to calculate the minimum cost","code":"function min_cost ( S ) {"}
{"text":"Stores the minimum cost","code":"let cost = 0 ;"}
{"text":"Stores the count of characters found","code":"let F = 0 ;"}
{"text":"Stores the count of blank spaces found","code":"let B = 0 ; let count = 0 ; for ( let i in S ) if ( S [ i ] == ' ' ) count ++ ;"}
{"text":"Stores the count of total characters","code":"let n = S . length - count ;"}
{"text":"If the count of characters is equal to 1","code":"if ( n == 1 ) return cost ;"}
{"text":"Iterate over the string","code":"for ( let i in S ) {"}
{"text":"Consider the previous character together with current character","code":"if ( S [ i ] != ' ' ) {"}
{"text":"If not together already","code":"if ( B != 0 ) {"}
{"text":"Add the cost to group them together","code":"cost += Math . min ( n - F , F ) * B ; B = 0 ; }"}
{"text":"Increase count of characters found","code":"F += 1 ; }"}
{"text":"Otherwise","code":"else {"}
{"text":"Increase count of spaces found","code":"B += 1 ; } }"}
{"text":"Return the total cost obtained","code":"return cost ; }"}
{"text":"Driver Code","code":"let S = \" \" ; document . write ( min_cost ( S . split ( ' ' ) ) ) ;"}
{"text":"Function that return true if the given character is a vowel","code":"function isVowel ( ch ) { if ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) return true ; else return false ; }"}
{"text":"Function to return the minimum cost to convert all the vowels of a string to a single one","code":"function minCost ( S ) {"}
{"text":"St || es count of respective vowels","code":"var cA = 0 ; var cE = 0 ; var cI = 0 ; var cO = 0 ; var cU = 0 ;"}
{"text":"Iterate through the string","code":"for ( var i = 0 ; i < S . length ; i ++ ) {"}
{"text":"If a vowel is encountered","code":"if ( isVowel ( S [ i ] ) ) {"}
{"text":"Calculate the cost","code":"cA += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cE += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cI += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cO += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; cU += Math . abs ( S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; } }"}
{"text":"Return the Math . minimum cost","code":"return Math . min ( Math . min ( Math . min ( Math . min ( cA , cE ) , cI ) , cO ) , cU ) ; }"}
{"text":"Driver Code","code":"var S = \" \" ; document . write ( minCost ( S ) ) ;"}
{"text":"Function to return the required required string","code":"function decode_String ( str , K ) { let ans = \" \" ;"}
{"text":"Iterate the given string","code":"for ( let i = 0 ; i < str . length ; i += K )"}
{"text":"Append the first character of every substring of length K","code":"ans += str [ i ] ;"}
{"text":"Consider all characters from the last substring","code":"for ( let i = str . length - ( K - 1 ) ; i < str . length ; i ++ ) ans += str [ i ] ; document . write ( ans ) ; }"}
{"text":"Driver code","code":"let K = 3 ; let str = \" \" ; decode_String ( str , K ) ;"}
{"text":"Function that prints the lexicographically smallest K - length substring containing maximum number of vowels","code":"function maxVowelSubString ( str , K ) {"}
{"text":"St || e the length of the string","code":"var N = str . length ;"}
{"text":"Initialize a prefix sum array","code":"var pref = Array ( N ) ;"}
{"text":"Loop through the string to create the prefix sum array","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"St || e 1 at the index if it is a vowel","code":"if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) pref [ i ] = 1 ;"}
{"text":"Otherwise , st || e 0","code":"else pref [ i ] = 0 ;"}
{"text":"Process the prefix array","code":"if ( i ) pref [ i ] += pref [ i - 1 ] ; }"}
{"text":"Initialize the variable to st || e maximum count of vowels","code":"var maxCount = pref [ K - 1 ] ;"}
{"text":"Initialize the variable to st || e substring with maximum count of vowels","code":"var res = str . substring ( 0 , K ) ;"}
{"text":"Loop through the prefix array","code":"for ( var i = K ; i < N ; i ++ ) {"}
{"text":"St || e the current count of vowels","code":"var currCount = pref [ i ] - pref [ i - K ] ;"}
{"text":"Update the result if current count is greater than maximum count","code":"if ( currCount > maxCount ) { maxCount = currCount ; res = str . substring ( i - K + 1 , i - 1 ) ; }"}
{"text":"Update lexicographically smallest substring if the current count is equal to the maximum count","code":"else if ( currCount == maxCount ) { var temp = str . substring ( i - K + 1 , i + 1 ) ; if ( temp < res ) res = temp ; } }"}
{"text":"Return the result","code":"return res ; }"}
{"text":"Driver Program","code":"var str = \" \" ; var K = 3 ; document . write ( maxVowelSubString ( str , K ) ) ;"}
{"text":"Function to decode and print the original string","code":"function decodeStr ( str , len ) {"}
{"text":"To store the decoded string","code":"var c = Array ( len ) . fill ( \" \" ) ; var med , pos = 1 , k ;"}
{"text":"Getting the mid element","code":"if ( len % 2 == 1 ) med = parseInt ( len \/ 2 ) ; else med = parseInt ( len \/ 2 ) - 1 ;"}
{"text":"Storing the first element of the string at the median position","code":"c [ med ] = str [ 0 ] ;"}
{"text":"If the length is even then store the second element also","code":"if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ;"}
{"text":"k represents the number of characters that are already stored in the c [ ]","code":"if ( len & 1 ) k = 1 ; else k = 2 ; for ( var i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ;"}
{"text":"If string length is odd","code":"if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ;"}
{"text":"If it is even","code":"else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; }"}
{"text":"Print the decoded string","code":"for ( var i = 0 ; i < len ; i ++ ) { document . write ( c [ i ] ) ; } }"}
{"text":"Driver code","code":"var str = \" \" ; var len = str . length ; decodeStr ( str , len ) ;"}
{"text":"Javascript Program for Naive Approach","code":"function findCount ( s , L , R ) {"}
{"text":"counter to count distinct char","code":"var distinct = 0 ;"}
{"text":"Initializing frequency array to count characters as the appear in substring S [ L : R ]","code":"var frequency = Array ( 26 ) . fill ( 0 ) ;"}
{"text":"Iterating over S [ L ] to S [ R ]","code":"for ( var i = L ; i <= R ; i ++ ) {"}
{"text":"incrementing the count of s [ i ] character in frequency array","code":"frequency [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } for ( var i = 0 ; i < 26 ; i ++ ) {"}
{"text":"if frequency of any character is > 0 then increment the counter","code":"if ( frequency [ i ] > 0 ) distinct ++ ; } document . write ( distinct + \" \" ) ; }"}
{"text":"Driver code","code":"var s = \" \" ; var queries = 3 ; var Q = [ [ 0 , 10 ] , [ 15 , 18 ] , [ 12 , 20 ] ] ; for ( var i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ;"}
{"text":"Function to perform K operations upon the string and find modified string","code":"function ReverseComplement ( s , n , k ) {"}
{"text":"Number of reverse operations","code":"var rev = parseInt ( ( k + 1 ) \/ 2 ) ;"}
{"text":"Number of complement operations","code":"var complement = k - rev ;"}
{"text":"If rev is odd parity","code":"if ( rev % 2 ) { s = s . split ( ' ' ) . reverse ( ) . join ( ' ' ) ; }"}
{"text":"If complement is odd parity","code":"if ( complement % 2 ) { for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"Complementing each position","code":"if ( s [ i ] == ' ' ) s [ i ] = ' ' ; else s [ i ] = ' ' ; } }"}
{"text":"Return the modified string","code":"return s ; }"}
{"text":"Driver Code","code":"var str = \" \" ; var k = 5 ; var n = str . length ;"}
{"text":"Function call","code":"document . write ( ReverseComplement ( str , n , k ) ) ;"}
{"text":"Function to check that permutation of the given string is a K times repeating String","code":"function repeatingString ( s , n , k ) {"}
{"text":"if length of string is not divisible by K","code":"if ( n % k != 0 ) { return false ; }"}
{"text":"Frequency Array","code":"var frequency = new Array ( 123 ) ;"}
{"text":"Initially frequency of each character is 0","code":"for ( let i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; }"}
{"text":"Computing the frequency of each character in the string","code":"for ( let i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } var repeat = n \/ k ;"}
{"text":"Loop to check that frequency of every character of the string is divisible by K","code":"for ( let i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; }"}
{"text":"Driver Code","code":"var s = \" \" ; var n = s . length ; var k = 3 ; if ( repeatingString ( s , n , k ) ) { console . log ( \" \" ) ; } else { console . log ( \" \" ) ; }"}
{"text":"Function to find the last two digits of the number and print the complete number","code":"function findPhoneNumber ( n ) { let temp = n ; let sum = 0 ;"}
{"text":"Sum of the first eight digits of the number","code":"while ( temp != 0 ) { sum += temp % 10 ; temp = Math . floor ( temp \/ 10 ) ; }"}
{"text":"if sum < 10 , then the two digits are '0' and the value of sum","code":"if ( sum < 10 ) document . write ( n + \" \" + sum ) ;"}
{"text":"if sum > 10 , then the two digits are the value of sum","code":"else document . write ( n + \" \" + sum ) ; }"}
{"text":"Driver code","code":"let n = 98765432 ; findPhoneNumber ( n ) ;"}
{"text":"Javascript implementation of the approach","code":"var maxN = 20 ; var maxM = 64 ;"}
{"text":"Function to return the required count","code":"function cntSplits ( s ) {"}
{"text":"If the splitting is not possible","code":"if ( s [ s . length - 1 ] == ' ' ) return 0 ;"}
{"text":"To store the count of zeroes","code":"var c_zero = 0 ;"}
{"text":"Counting the number of zeroes","code":"for ( var i = 0 ; i < s . length ; i ++ ) c_zero += ( s [ i ] == ' ' ) ;"}
{"text":"Return the final answer","code":"return Math . pow ( 2 , c_zero - 1 ) ; }"}
{"text":"Driver code","code":"var s = \" \" ; document . write ( cntSplits ( s ) ) ;"}
{"text":"Function to return the number of substrings of same characters","code":"function findNumbers ( s ) {"}
{"text":"Size of the string","code":"var n = s . length ;"}
{"text":"Initialize count to 1","code":"var count = 1 ; var result = 0 ;"}
{"text":"Initialize left to 0 and right to 1 to traverse the string","code":"var left = 0 ; var right = 1 ; while ( right < n ) {"}
{"text":"Checking if consecutive characters are same and increment the count","code":"if ( s [ left ] == s [ right ] ) { count ++ ; }"}
{"text":"When we encounter a different characters","code":"else {"}
{"text":"Increment the result","code":"result += parseInt ( count * ( count + 1 ) \/ 2 ) ;"}
{"text":"To repeat the whole process set left equals right and count variable to 1","code":"left = right ; count = 1 ; } right ++ ; }"}
{"text":"Store the final value of result","code":"result += parseInt ( count * ( count + 1 ) \/ 2 ) ; document . write ( result ) ; }"}
{"text":"Driver code","code":"var s = \" \" ; findNumbers ( s ) ;"}
{"text":"Function to check for the Vowel","code":"function isVowel ( ch ) { ch = ch . toUpperCase ( ) ; return ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) ; }"}
{"text":"Function to get the resultant string with vowels duplicated","code":"function duplicateVowels ( str ) { let t = str . length ;"}
{"text":"Another string to store the resultant string","code":"let res = \" \" ;"}
{"text":"Loop to check for each character","code":"for ( let i = 0 ; i < t ; i ++ ) { if ( isVowel ( str [ i ] ) ) res += str [ i ] ; res += str [ i ] ; } return res ; }"}
{"text":"Driver Code","code":"let str = \" \" ;"}
{"text":"Print the original string","code":"document . write ( \" \" + str + \" \" ) ; let res = duplicateVowels ( str ) ;"}
{"text":"Print the resultant string","code":"document . write ( \" \" + res + \" \" ) ;"}
{"text":"Recursive function to convert string to integer","code":"function stringToInt ( str ) {"}
{"text":"If the number represented as a string contains only a single digit then returns its value","code":"if ( str . length == 1 ) return ( str [ 0 ] - ' ' ) ;"}
{"text":"Recursive call for the sub - string starting at the second character","code":"var y = stringToInt ( str . substring ( 1 ) ) ;"}
{"text":"First digit of the number","code":"var x = str [ 0 ] - ' ' ;"}
{"text":"First digit multiplied by the appropriate power of 10 and then add the recursive result For example , xy = ( ( x * 10 ) + y )","code":"x = x * Math . pow ( 10 , str . Length - 1 ) + y ; return ( x ) ; }"}
{"text":"Driver code","code":"var str = \" \" . split ( ) document . write ( stringToInt ( str ) ) ;"}
{"text":"Javascript implementation of the approach","code":"var MAX = 26 ;"}
{"text":"Function to return the length of the longest sub - sequence with at least one common character in every string","code":"function largestSubSeq ( arr , n ) {"}
{"text":"count [ 0 ] will store the number of strings which contain ' a ' , count [ 1 ] will store the number of strings which contain ' b ' and so on . .","code":"var count = Array ( MAX ) . fill ( 0 ) ;"}
{"text":"For every string","code":"for ( var i = 0 ; i < n ; i ++ ) { var str = arr [ i ] ;"}
{"text":"Hash array to set which character is present in the current string","code":"var hash = Array ( MAX ) . fill ( 0 ) ; for ( var j = 0 ; j < str . length ; j ++ ) { hash [ str [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = true ; } for ( var j = 0 ; j < MAX ; j ++ ) {"}
{"text":"If current character appears in the string then update its count","code":"if ( hash [ j ] ) count [ j ] ++ ; } } return count . reduce ( ( a , b ) => Math . max ( a , b ) ) ; }"}
{"text":"Driver code","code":"var arr = [ \" \" , \" \" , \" \" ] ; var n = arr . length ; document . write ( largestSubSeq ( arr , n ) ) ;"}
{"text":"Function that returns true if str is a palindrome","code":"function isPalindrome ( str ) { let len = str . length ; for ( let i = 0 ; i < len \/ 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; }"}
{"text":"Function that returns true if the generated string is a palindrome","code":"function createStringAndCheckPalindrome ( N ) {"}
{"text":"sub contains N as a string","code":"let sub = \" \" + N , res_str = \" \" ; let sum = 0 ;"}
{"text":"Calculate the sum of the digits","code":"while ( N > 0 ) { let digit = N % 10 ; sum += digit ; N = N \/ 10 ; }"}
{"text":"Repeat the substring until the length of the resultant string < sum","code":"while ( res_str . length < sum ) res_str += sub ;"}
{"text":"If length of the resultant string exceeded sum then take substring from 0 to sum - 1","code":"if ( res_str . length > sum ) res_str = res_str . substring ( 0 , sum ) ;"}
{"text":"If the generated string is a palindrome","code":"if ( isPalindrome ( res_str ) ) return true ; return false ; }"}
{"text":"Driver code","code":"let N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to find the minimum length","code":"function minimumLength ( s ) { var maxOcc = 0 , n = s . length ; var arr = Array ( 26 ) . fill ( 0 ) ;"}
{"text":"Count the frequency of each alphabet","code":"for ( var i = 0 ; i < n ; i ++ ) arr [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ;"}
{"text":"Find the alphabets with maximum frequency","code":"for ( var i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ;"}
{"text":"Subtract the frequency of character from length of string","code":"return ( n - maxOcc ) ; }"}
{"text":"Driver Code","code":"var str = \" \" ; document . write ( minimumLength ( str ) ) ;"}
{"text":"function to remove characters and print new string","code":"function removeSpecialCharacter ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) {"}
{"text":"Finding the character whose ASCII value fall under this range","code":"if ( s [ i ] < ' ' s [ i ] > ' ' && s [ i ] < ' ' s [ i ] > ' ' ) {"}
{"text":"erase function to erase the character","code":"s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } document . write ( s ) ; }"}
{"text":"Driver code","code":"let s = \" \" ; removeSpecialCharacter ( s ) ;"}
{"text":"function to remove characters and print new string","code":"function removeSpecialCharacter ( str ) { let s = str . split ( \" \" ) ; let j = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) {"}
{"text":"Store only valid characters","code":"if ( ( s [ i ] >= ' ' && s [ i ] <= ' ' ) || ( s [ i ] >= ' ' && s [ i ] <= ' ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } document . write ( ( s ) . join ( \" \" ) . substring ( 0 , j ) ) ; }"}
{"text":"driver code","code":"let s = \" \" ; removeSpecialCharacter ( s ) ;"}
{"text":"Javascript program to find the first character that is repeated","code":"function findRepeatFirstN2 ( s ) {"}
{"text":"This is O ( N ^ 2 ) method","code":"let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }"}
{"text":"Driver code","code":"let str = \" \" ; let pos = findRepeatFirstN2 ( str ) ; if ( pos == - 1 ) document . write ( \" \" ) ; else document . write ( str [ pos ] ) ;"}
{"text":"Javascript implementation to print the characters and frequencies in order of its occurrence","code":"function prCharWithFreq ( s ) {"}
{"text":"Store all characters and their frequencies in dictionary","code":"var d = new Map ( ) ; s . split ( ' ' ) . forEach ( element => { if ( d . has ( element ) ) { d . set ( element , d . get ( element ) + 1 ) ; } else d . set ( element , 1 ) ; } ) ;"}
{"text":"Print characters and their frequencies in same order of their appearance","code":"s . split ( ' ' ) . forEach ( element => {"}
{"text":"Print only if this character is not printed before","code":"if ( d . has ( element ) && d . get ( element ) != 0 ) { document . write ( element + d . get ( element ) + \" \" ) ; d . set ( element , 0 ) ; } } ) ; }"}
{"text":"Driver Code","code":"var s = \" \" ; prCharWithFreq ( s ) ;"}
{"text":"Function to calculate number of strings","code":"function possibleStrings ( n , r , b , g ) {"}
{"text":"Store factorial of numbers up to n for further computation","code":"let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ;"}
{"text":"Find the remaining values to be added","code":"let left = n - ( r + g + b ) ; let sum = 0 ;"}
{"text":"Make all possible combinations of R , B and G for the remaining value","code":"for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ;"}
{"text":"Compute permutation of each combination one by one and add them .","code":"sum = sum + fact [ n ] \/ ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } }"}
{"text":"Return total no . of strings \/ permutation","code":"return sum ; }"}
{"text":"Drivers code","code":"let n = 4 , r = 2 ; let b = 0 , g = 1 ; document . write ( possibleStrings ( n , r , b , g ) ) ;"}
{"text":"function to calculate minimum numbers of characters to be removed to make two strings anagram","code":"function remAnagram ( str1 , str2 ) {"}
{"text":"make hash array for both string and calculate frequency of each character","code":"var count1 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; var count2 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ;"}
{"text":"count frequency of each character in first string","code":"for ( i = 0 ; i < str1 . length ; i ++ ) count1 [ str1 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ;"}
{"text":"count frequency of each character in second string","code":"for ( i = 0 ; i < str2 . length ; i ++ ) count2 [ str2 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ;"}
{"text":"traverse count arrays to find number of characters to be removed","code":"var result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }"}
{"text":"Driver program to run the case","code":"var str1 = \" \" , str2 = \" \" ; document . write ( remAnagram ( str1 , str2 ) ) ;"}
{"text":"Assuming only lower case characters","code":"let CHARS = 26 ;"}
{"text":"To check a string S can be converted to a valid string by removing less than or equal to one character .","code":"function isValidString ( str ) { let freq = new Array ( CHARS ) ; for ( let i = 0 ; i < CHARS ; i ++ ) { freq [ i ] = 0 ; }"}
{"text":"freq [ ] : stores the frequency of each character of a string","code":"for ( let i = 0 ; i < str . length ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; }"}
{"text":"Find first character with non - zero frequency","code":"let i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } }"}
{"text":"Find a character with frequency different from freq1 .","code":"let j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } }"}
{"text":"If we find a third non - zero frequency or count of both frequencies become more than 1 , then return false","code":"for ( let k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ;"}
{"text":"} else If we find a third non - zero freq","code":"{ return false ; } }"}
{"text":"If counts of both frequencies is more than 1","code":"if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } }"}
{"text":"Return true if we reach here","code":"return true ; }"}
{"text":"Driver code","code":"let str = \" \" ; if ( isValidString ( str ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text":"To check a string S can be converted to a variation string","code":"function checkForVariation ( str ) { if ( str == null str . length == 0 ) { return true ; } let map = new Map ( ) ;"}
{"text":"Run loop form 0 to length of string","code":"for ( let i = 0 ; i < str . length ; i ++ ) { if ( ! map . has ( str [ i ] ) ) map . set ( str [ i ] , 0 ) ; map . set ( str [ i ] , map . get ( str [ i ] ) + 1 ) ; }"}
{"text":"declaration of variables","code":"let first = true , second = true ; let val1 = 0 , val2 = 0 ; let countOfVal1 = 0 , countOfVal2 = 0 ; for ( let [ key , value ] of map . entries ( ) ) { let i = value ;"}
{"text":"if first is true than countOfVal1 increase","code":"if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; }"}
{"text":"if second is true than countOfVal2 increase","code":"if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } }"}
{"text":"Driver code","code":"document . write ( checkForVariation ( \" \" ) ) ;"}
{"text":"Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ]","code":"function countCompletePairs ( set1 , set2 , n , m ) { let result = 0 ;"}
{"text":"Consider all pairs of both strings","code":"for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) {"}
{"text":"Create a concatenation of current pair","code":"let concat = set1 [ i ] + set2 [ j ] ;"}
{"text":"Compute frequencies of all characters in the concatenated String .","code":"let frequency = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { frequency [ i ] = 0 ; } for ( let k = 0 ; k < concat . length ; k ++ ) { frequency [ concat [ k ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; }"}
{"text":"If frequency of any character is not greater than 0 , then this pair is not complete .","code":"let k ; for ( k = 0 ; k < 26 ; k ++ ) { if ( frequency [ k ] < 1 ) { break ; } } if ( k == 26 ) { result ++ ; } } } return result ; }"}
{"text":"Driver code","code":"let set1 = [ \" \" , \" \" , \" \" , \" \" ] ; let set2 = [ \" \" , \" \" , \" \" ] let n = set1 . length ; let m = set2 . length ; document . write ( countCompletePairs ( set1 , set2 , n , m ) ) ;"}
{"text":"Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ]","code":"function countCompletePairs ( set1 , set2 , n , m ) { let result = 0 ;"}
{"text":"con_s1 [ i ] is going to store an integer whose set bits represent presence \/ absence of characters in string set1 [ i ] . Similarly con_s2 [ i ] is going to store an integer whose set bits represent presence \/ absence of characters in string set2 [ i ]","code":"let con_s1 = new Array ( n ) ; let con_s2 = new Array ( m ) ;"}
{"text":"Process all strings in set1 [ ]","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"initializing all bits to 0","code":"con_s1 [ i ] = 0 ; for ( let j = 0 ; j < set1 [ i ] . length ; j ++ ) {"}
{"text":"Setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer .","code":"con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; } }"}
{"text":"Process all strings in set2 [ ]","code":"for ( let i = 0 ; i < m ; i ++ ) {"}
{"text":"initializing all bits to 0","code":"con_s2 [ i ] = 0 ; for ( let j = 0 ; j < set2 [ i ] . length ; j ++ ) {"}
{"text":"setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer .","code":"con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; } }"}
{"text":"assigning a variable whose all 26 ( 0. . 25 ) bits are set to 1","code":"let complete = ( 1 << 26 ) - 1 ;"}
{"text":"Now consider every pair of integer in con_s1 [ ] and con_s2 [ ] and check if the pair is complete .","code":"for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) {"}
{"text":"if all bits are set , the strings are complete !","code":"if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; }"}
{"text":"Driver code","code":"let set1 = [ \" \" , \" \" , \" \" , \" \" ] ; let set2 = [ \" \" , \" \" , \" \" ] let n = set1 . length ; let m = set2 . length ; document . write ( countCompletePairs ( set1 , set2 , n , m ) ) ;"}
{"text":"Function to encode given string","code":"function encodeString ( str ) { let map = new Map ( ) ; let res = \" \" ; let i = 0 ;"}
{"text":"for each character in given string","code":"let ch ; for ( let j = 0 ; j < str . length ; j ++ ) { ch = str [ j ] ;"}
{"text":"If the character is occurring for the first time , assign next unique number to that char","code":"if ( ! map . has ( ch ) ) map . set ( ch , i ++ ) ;"}
{"text":"append the number associated with current character into the output string","code":"res += map . get ( ch ) ; } return res ; }"}
{"text":"Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary","code":"function findMatchedWords ( dict , pattern ) {"}
{"text":"len is length of the pattern","code":"let len = pattern . length ;"}
{"text":"encode the string","code":"let hash = encodeString ( pattern ) ;"}
{"text":"for each word in the dictionary array","code":"for ( let word = 0 ; word < dict . length ; word ++ ) {"}
{"text":"If size of pattern is same as size of current dictionary word and both pattern and the word has same hash , print the word","code":"if ( dict [ word ] . length == len && encodeString ( dict [ word ] ) == ( hash ) ) document . write ( dict [ word ] + \" \" ) ; } }"}
{"text":"Driver code","code":"let dict = [ \" \" , \" \" , \" \" , \" \" ] ; let pattern = \" \" ; findMatchedWords ( dict , pattern ) ;"}
{"text":"Javascript program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary","code":"function check ( pattern , word ) { if ( pattern . length != word . length ) return false ; let ch = new Array ( 128 ) ; for ( let i = 0 ; i < 128 ; i ++ ) { ch [ i ] = 0 ; } let Len = word . length ; for ( let i = 0 ; i < Len ; i ++ ) { if ( ch [ pattern [ i ] . charCodeAt ( 0 ) ] == 0 ) { ch [ pattern [ i ] . charCodeAt ( 0 ) ] = word [ i ] ; } else if ( ch [ pattern [ i ] . charCodeAt ( 0 ) ] != word [ i ] ) { return false ; } } return true ; }"}
{"text":"Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary","code":"function findMatchedWords ( dict , pattern ) {"}
{"text":"len is length of the pattern","code":"let Len = pattern . length ;"}
{"text":"For each word in the dictionary","code":"let result = \" \" ; for ( let word of dict . values ( ) ) { if ( check ( pattern , word ) ) { result = word + \" \" + result ; } } document . write ( result ) ; }"}
{"text":"Driver code","code":"let dict = new Set ( ) ; dict . add ( \" \" ) ; dict . add ( \" \" ) ; dict . add ( \" \" ) ; dict . add ( \" \" ) ; let pattern = \" \" ; findMatchedWords ( dict , pattern ) ;"}
{"text":"Function to count total number of words in the string","code":"function countWords ( str ) {"}
{"text":"Check if the string is null or empty then return zero","code":"if ( str == null str . length == 0 ) return 0 ; let wordCount = 0 ; let isWord = false ; let endOfLine = str . length - 1 ;"}
{"text":"Converting the given string into a character array","code":"let ch = str . split ( \" \" ) ; for ( let i = 0 ; i < ch . length ; i ++ ) {"}
{"text":"Check if the character is a letter and index of character array doesn 't  equal to end of line that means, it is  a word and set isWord by true","code":"if ( isLetter ( ch [ i ] ) && i != endOfLine ) isWord = true ;"}
{"text":"Check if the character is not a letter that means there is a space , then we increment the wordCount by one and set the isWord by false","code":"else if ( ! isLetter ( ch [ i ] ) && isWord ) { wordCount ++ ; isWord = false ; }"}
{"text":"Check for the last word of the sentence and increment the wordCount by one","code":"else if ( isLetter ( ch [ i ] ) && i == endOfLine ) wordCount ++ ; }"}
{"text":"Return the total number of words in the string","code":"return wordCount ; } function isLetter ( c ) { return c . toLowerCase ( ) != c . toUpperCase ( ) ; }"}
{"text":"Given String str","code":"let str = \" \" ;"}
{"text":"Print the result","code":"document . write ( \" \" + countWords ( str ) ) ;"}
{"text":"Reverse the string","code":"function RevString ( s , l ) {"}
{"text":"Check if number of words is even","code":"if ( l % 2 == 0 ) {"}
{"text":"Find the middle word","code":"let j = parseInt ( l \/ 2 , 10 ) ;"}
{"text":"Starting from the middle start swapping words at jth position and l - 1 - j position","code":"while ( j <= l - 1 ) { let temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } }"}
{"text":"Check if number of words is odd","code":"else {"}
{"text":"Find the middle word","code":"let j = parseInt ( ( l \/ 2 ) , 10 ) + 1 ;"}
{"text":"Starting from the middle start swapping the words at jth position and l - 1 - j position","code":"while ( j <= l - 1 ) { let temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } let S = s [ 0 ] ;"}
{"text":"Return the reversed sentence","code":"for ( let i = 1 ; i < 9 ; i ++ ) { S = S + \" \" + s [ i ] ; } return S ; }"}
{"text":"Driver code","code":"let s = \" \" \" \" ; let words = [ \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" , \" \" ] ; document . write ( RevString ( words , 9 ) ) ;"}
{"text":"Function to print path of all the nodes nth node represent as given node kth node represents as left and right node","code":"function printPath ( res , nThNode , kThNode ) {"}
{"text":"base condition if kth node value is greater then nth node then its means kth node is not valid so we not store it into the res simply we just return","code":"if ( kThNode > nThNode ) return ;"}
{"text":"Storing node into res","code":"res . push ( kThNode ) ;"}
{"text":"Print the path from root to node","code":"for ( var i = 0 ; i < res . length ; i ++ ) document . write ( res [ i ] + \" \" ) ; document . write ( \" \" ) ;"}
{"text":"store left path of a tree So for left we will go node ( kThNode * 2 )","code":"printPath ( res , nThNode , kThNode * 2 ) ;"}
{"text":"right path of a tree and for right we will go node ( kThNode * 2 + 1 )","code":"printPath ( res , nThNode , kThNode * 2 + 1 ) ; res . pop ( ) }"}
{"text":"Function to print path from root to all of the nodes","code":"function printPathToCoverAllNodeUtil ( nThNode ) {"}
{"text":"res is for store the path from root to particulate node","code":"var res = [ ] ;"}
{"text":"Print path from root to all node . third argument 1 because of we have to consider root node is 1","code":"printPath ( res , nThNode , 1 ) ; }"}
{"text":"Given Node","code":"var nThNode = 7 ;"}
{"text":"Print path from root to all node .","code":"printPathToCoverAllNodeUtil ( nThNode ) ;"}
{"text":"A utility function to get the middle index of given range .","code":"function getMid ( s , e ) { return s + Math . floor ( ( e - s ) \/ 2 ) ; }"}
{"text":"Function that return true if num is armstrong else return false","code":"function isArmstrong ( x ) { let n = ( x ) . toString ( ) . length ; let sum1 = 0 ; let temp = x ; while ( temp > 0 ) { let digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp = Math . floor ( temp \/ 10 ) ; } if ( sum1 == x ) return true ; return false ; }"}
{"text":"A recursive function to get the sum of values in the given range of the array . The following are parameters for this function . st . Pointer to segment tree node . Index of current node in the segment tree . ss & se . Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r . Starting and ending indexes of range query","code":"function MaxUtil ( st , ss , se , l , r , node ) {"}
{"text":"If segment of this node is completely part of given range , then return the max of segment .","code":"if ( l <= ss && r >= se ) return st [ node ] ;"}
{"text":"If segment of this node does not belong to given range","code":"if ( se < l ss > r ) return - 1 ;"}
{"text":"If segment of this node is partially the part of given range","code":"let mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; }"}
{"text":"A recursive function to update the nodes which have the given the index in their range . The following are parameters st , ss and se are same as defined above index . index of the element to be updated .","code":"function updateValue ( arr , st , ss , se , index , value , node ) { if ( index < ss index > se ) { document . write ( \" \" + \" \" ) ; return ; } if ( ss == se ) {"}
{"text":"update value in array and in segment tree","code":"arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = - 1 ; } else { let mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 1 ) ; st [ node ] = Math . max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; }"}
{"text":"Return max of elements in range from index l ( query start ) to r ( query end ) .","code":"function getMax ( st , n , l , r ) {"}
{"text":"Check for erroneous input values","code":"if ( l < 0 r > n - 1 l > r ) { document . write ( \" \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }"}
{"text":"A recursive function that constructs Segment Tree for array [ ss . . se ] . si is index of current node in segment tree st","code":"function constructSTUtil ( arr , ss , se , st , si ) {"}
{"text":"If there is one element in array , store it in current node of segment tree and return","code":"if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = - 1 ; return st [ si ] ; }"}
{"text":"If there are more than one elements , then recur for left and right subtrees and store the max of values in this node","code":"let mid = getMid ( ss , se ) ; st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 1 ) ) ; return st [ si ] ; }"}
{"text":"Function to cona segment tree from given array . This function allocates memory for segment tree .","code":"function constructST ( arr , n ) {"}
{"text":"Height of segment tree","code":"let x = ( Math . ceil ( Math . log ( n ) ) ) ;"}
{"text":"Maximum size of segment tree","code":"let max_size = 2 * Math . pow ( 2 , x ) - 1 ;"}
{"text":"Allocate memory","code":"let st = new Array ( max_size ) ;"}
{"text":"Fill the allocated memory st","code":"constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;"}
{"text":"Return the constructed segment tree","code":"return st ; }"}
{"text":"Driver code","code":"let arr = [ 192 , 113 , 535 , 7 , 19 , 111 ] ; let n = arr . length ;"}
{"text":"Build segment tree from given array","code":"let st = constructST ( arr , n ) ;"}
{"text":"Print max of values in array from index 1 to 3","code":"document . write ( \" \" + \" \" + getMax ( st , n , 1 , 3 ) + \" \" ) ;"}
{"text":"Update : set arr [ 1 ] = 153 and update corresponding segment tree nodes .","code":"updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ;"}
{"text":"Find max after the value is updated","code":"document . write ( \" \" + \" \" + getMax ( st , n , 1 , 3 ) + \" \" ) ;"}
{"text":"Function to find the maximum number of regions on a plane","code":"function maxRegions ( n ) { let num ; num = parseInt ( n * ( n + 1 ) \/ 2 ) + 1 ;"}
{"text":"print the maximum number of regions","code":"document . write ( num ) ; }"}
{"text":"Driver code","code":"let n = 10 ; maxRegions ( n ) ;"}
{"text":"Function to check if the jigsaw Puzzle is solveable or not","code":"function checkSolveable ( n , m ) {"}
{"text":"Base Case","code":"if ( n == 1 m == 1 ) document . write ( \" \" ) ;"}
{"text":"By placing the blank tabs as a chain","code":"else if ( m == 2 && n == 2 ) document . write ( \" \" ) ; else document . write ( \" \" ) ; }"}
{"text":"Driver code","code":"let n = 1 , m = 3 ; checkSolveable ( n , m ) ;"}
{"text":"Function to find the GCD of two numbers a and b","code":"function GCD ( a , b ) {"}
{"text":"Base Case","code":"if ( b == 0 ) return a ;"}
{"text":"Recursively find the GCD","code":"else return GCD ( b , a % b ) ; }"}
{"text":"Function to check if ( x , y ) can be reached from ( 1 , 0 ) from given moves","code":"function check ( x , y ) {"}
{"text":"If GCD is 1 , then print \" Yes \"","code":"if ( GCD ( x , y ) == 1 ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; } }"}
{"text":"Given X and Y","code":"let X = 2 , Y = 7 ;"}
{"text":"Function call","code":"check ( X , Y ) ;"}
{"text":"JavaScript Program to implement the above approach","code":"let size = 1000001 ; let prime = new Array ( size , 0 ) ;"}
{"text":"Seieve of Erotosthenes to compute all primes","code":"function seiveOfEratosthenes ( ) { prime [ 0 ] = 1 ; prime [ 1 ] = 0 ; for ( let i = 2 ; i * i < 1000001 ; i ++ ) {"}
{"text":"If prime","code":"if ( prime [ i ] == 0 ) { for ( let j = i * i ; j < 1000001 ; j += i ) {"}
{"text":"Mark all its multiples as non - prime","code":"prime [ j ] = 1 ; } } } }"}
{"text":"Function to find the probability of Euler 's Totient Function in a given range","code":"function probabiltyEuler ( L , R , M ) { let arr = new Array ( size , 0 ) ; let eulerTotient = new Array ( size , 0 ) ; let count = 0 ;"}
{"text":"Initializing two arrays with values from L to R for Euler 's totient","code":"for ( let i = L ; i <= R ; i ++ ) {"}
{"text":"Indexing from 0","code":"eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( let i = 2 ; i < 1000001 ; i ++ ) {"}
{"text":"If the current number is prime","code":"if ( prime [ i ] == 0 ) {"}
{"text":"Checking if i is prime factor of numbers in range L to R","code":"for ( let j = ( L \/ i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) {"}
{"text":"Update all the numbers which has prime factor i","code":"eulerTotient [ j - L ] = eulerTotient [ j - L ] \/ i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] \/= i ; } } } } }"}
{"text":"If number in range has a prime factor > Math . Sqrt ( number )","code":"for ( let i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] \/ arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( let i = L ; i <= R ; i ++ ) {"}
{"text":"Count those which are divisible by M","code":"if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } } count \/= 2 ;"}
{"text":"Return the result","code":"return1 .0 * count \/ ( R + 1 - L ) ; }"}
{"text":"Driver Code","code":"seiveOfEratosthenes ( ) ; let L = 1 ; let R = 7 ; let M = 3 ; document . write ( probabiltyEuler ( L , R , M ) . toFixed ( 7 ) ) ;"}
{"text":"Function to find the Largest Odd Divisior Game to check which player wins","code":"function findWinner ( n , k ) { let cnt = 0 ;"}
{"text":"Check if n == 1 then player 2 will win","code":"if ( n == 1 ) document . write ( \" \" ) ;"}
{"text":"Check if n == 2 or n is odd","code":"else if ( ( n & 1 ) != 0 n == 2 ) document . write ( \" \" ) ; else { let tmp = n ; let val = 1 ;"}
{"text":"While n is greater than k and divisible by 2 keep incrementing tha val","code":"while ( tmp > k && tmp % 2 == 0 ) { tmp \/= 2 ; val *= 2 ; }"}
{"text":"Loop to find greatest odd divisor","code":"for ( let i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp \/= i ; } } if ( tmp > 1 ) cnt ++ ;"}
{"text":"Check if n is a power of 2","code":"if ( val == n ) document . write ( \" \" ) ; else if ( n \/ tmp == 2 && cnt == 1 ) document . write ( \" \" ) ;"}
{"text":"Check if cnt is not one then player 1 wins","code":"else document . write ( \" \" ) ; } }"}
{"text":"Driver Code","code":"let n = 1 , k = 1 ; findWinner ( n , k ) ;"}
{"text":"Function to prvar numbers upto N which are both pentagonal as well as hexagonal numbers","code":"function pen_hex ( n ) { var pn = 1 ; for ( i = 1 ; i < n ; i ++ ) {"}
{"text":"Calculate i - th pentagonal number","code":"pn = parseInt ( i * ( 3 * i - 1 ) \/ 2 ) ; if ( pn > n ) break ;"}
{"text":"Check if the pentagonal number pn is hexagonal or not","code":"var seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) \/ 4 ; if ( seqNum == parseInt ( seqNum ) ) document . write ( pn + \" \" ) ; } }"}
{"text":"Driver code","code":"var N = 1000000 ; pen_hex ( N ) ;"}
{"text":"Function to check if row - major order traversal of the matrix is is palindrome","code":"function isPal ( a , n , m ) {"}
{"text":"Loop to check if the matrix is matrix is palindrome or not","code":"for ( let i = 0 ; i < n \/ 2 ; i ++ ) { for ( let j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }"}
{"text":"Driver Code","code":"let n = 3 , m = 3 ; let a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 4 ] , [ 3 , 2 , 1 ] ] ; if ( isPal ( a , n , m ) ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" + \" \" ) ; }"}
{"text":"Function to get sum of digits","code":"function getSum ( n ) { let sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = Math . floor ( n \/ 10 ) ; } return sum ; }"}
{"text":"Function to find the smallest number whose sum of digits is also N","code":"function smallestNumber ( N ) { let i = 1 ; while ( 1 ) {"}
{"text":"Checking if number has sum of digits = N","code":"if ( getSum ( i ) == N ) { document . write ( i ) ; break ; } i ++ ; } }"}
{"text":"Driver code","code":"let N = 10 ; smallestNumber ( N ) ;"}
{"text":"Iterative function to reverse digits of num","code":"function reversDigits ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num \/ 10 ) ; } return rev_num ; }"}
{"text":"Function to check if N is perfect square","code":"function isPerfectSquare ( x ) {"}
{"text":"Find floating point value of square root of x .","code":"let sr = Math . sqrt ( x ) ;"}
{"text":"If square root is an integer","code":"return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }"}
{"text":"Function to check if N is an Rare number","code":"function isRare ( N ) {"}
{"text":"Find reverse of N","code":"let reverseN = reversDigits ( N ) ;"}
{"text":"Number should be non - palindromic","code":"if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; }"}
{"text":"Driver code","code":"let n = 65 ; if ( isRare ( n ) ) { document . write ( \" \" ) ; } else { document . write ( \" \" ) ; }"}
{"text":"Function which will calculate the elements in the given range","code":"function calc_ans ( l , r ) { var power2 = [ ] , power3 = [ ] ;"}
{"text":"Store the current power of 2","code":"var mul2 = 1 ; while ( mul2 <= r ) { power2 . push ( mul2 ) ; mul2 *= 2 ; }"}
{"text":"Store the current power of 3","code":"var mul3 = 1 ; while ( mul3 <= r ) { power3 . push ( mul3 ) ; mul3 *= 3 ; }"}
{"text":"power23 [ ] will store pairwise product of elements of power2 and power3 that are <= r","code":"var power23 = [ ] ; for ( var x = 0 ; x < power2 . length ; x ++ ) { for ( var y = 0 ; y < power3 . length ; y ++ ) { var mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ;"}
{"text":"Insert in power23 ] [ ] only if mul <= r","code":"if ( mul <= r ) power23 . push ( mul ) ; } }"}
{"text":"Store the required answer","code":"var ans = 0 ; power23 . forEach ( x => { if ( x >= l && x <= r ) ans ++ ; } ) ;"}
{"text":"Print the result","code":"document . write ( ans ) ; }"}
{"text":"Driver code","code":"var l = 1 , r = 10 ; calc_ans ( l , r ) ;"}
{"text":"Function to calculate nCr","code":"function nCr ( n , r ) { if ( r > n ) return 0 ; return fact ( n ) \/ ( fact ( r ) * fact ( n - r ) ) ; }"}
{"text":"Returns factorial of n","code":"function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }"}
{"text":"Function for finding number of K length subsequences whose product is even number","code":"function countSubsequences ( arr , n , k ) { var countOdd = 0 ;"}
{"text":"counting odd numbers in the array","code":"for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) countOdd ++ ; } var ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; }"}
{"text":"Driver code","code":"var arr = [ 2 , 4 ] ; var K = 1 ; var N = arr . length ; document . write ( countSubsequences ( arr , N , K ) ) ;"}
{"text":"Function to find the first digit of X in base Y","code":"function first_digit ( x , y ) {"}
{"text":"calculating number of digits of x in base y","code":"var length = parseInt ( Math . log ( x ) \/ Math . log ( y ) ) + 1 ;"}
{"text":"finding first digit of x in base y","code":"var first_digit = parseInt ( x \/ Math . pow ( y , length - 1 ) ) ; document . write ( first_digit ) ; }"}
{"text":"Driver code","code":"var X = 55 , Y = 3 ; first_digit ( X , Y ) ;"}
{"text":"Function to check if a number is a Curzon number or not","code":"function checkIfCurzonNumber ( N ) { var powerTerm , productTerm ;"}
{"text":"Find 2 ^ N + 1","code":"powerTerm = Math . pow ( 2 , N ) + 1 ;"}
{"text":"Find 2 * N + 1","code":"productTerm = 2 * N + 1 ;"}
{"text":"Check for divisibility","code":"if ( powerTerm % productTerm == 0 ) { document . write ( \" \" + \" \" ) ; } else { document . write ( \" \" ) ; } }"}
{"text":"Driver code","code":"var N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ;"}
{"text":"Function to return the count of minimum numbers ending with 7 required such that the sum of these numbers is n","code":"function minCount ( n ) {"}
{"text":"hasharr [ i ] will store the minimum numbers ending with 7 so that it sums to number ending with digit i","code":"let hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] ;"}
{"text":"Its always possible to write numbers > 69 to write as numbers ending with 7","code":"if ( n > 69 ) return hasharr [ n % 10 ] ; else {"}
{"text":"If the number is atleast equal to the sum of minimum numbers ending with 7","code":"if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }"}
{"text":"Driver code","code":"let n = 38 ; document . write ( minCount ( n ) ) ;"}
{"text":"Function to print the modified binary pattern","code":"function modifiedBinaryPattern ( n ) {"}
{"text":"Loop to traverse the rows","code":"for ( let i = 1 ; i <= n ; i ++ ) {"}
{"text":"Loop to traverse the numbers in each row","code":"for ( let j = 1 ; j <= i ; j ++ ) {"}
{"text":"Check if j is 1 or i In either case print 1","code":"if ( j == 1 j == i ) document . write ( 1 ) ;"}
{"text":"Else print 0","code":"else document . write ( 0 ) ; }"}
{"text":"Change the cursor to next line after each row","code":"document . write ( \" \" ) ; } }"}
{"text":"Driver code","code":"let n = 7 ;"}
{"text":"Function call","code":"modifiedBinaryPattern ( n ) ;"}
{"text":"Function to find real and imaginary parts of a complex number","code":"function findRealAndImag ( s ) {"}
{"text":"string length stored in variable l","code":"let l = s . length - 1 ;"}
{"text":"variable for the index of the separator","code":"let i ;"}
{"text":"Storing the index of ' + '","code":"if ( s . indexOf ( ' ' ) != - 1 ) { i = s . indexOf ( ' ' ) ; }"}
{"text":"else storing the index of ' - '","code":"else { i = s . indexOf ( ' ' ) ; }"}
{"text":"Finding the real part of the complex number","code":"let real = s . substr ( 0 , i ) ;"}
{"text":"Finding the imaginary part of the complex number","code":"let imaginary = s . substr ( i + 1 , l - 2 ) ; document . write ( \" \" + real + \" \" ) ; document . write ( \" \" + imaginary ) ; }"}
{"text":"Driver code","code":"let s = \" \" ; findRealAndImag ( s ) ;"}
{"text":"Function to return the highest power of N not exceeding K","code":"function highestPower ( n , k ) { let i = 0 ; let a = Math . pow ( n , i ) ;"}
{"text":"Loop to find the highest power less than K","code":"while ( a <= k ) { i += 1 ; a = Math . pow ( n , i ) ; } return i - 1 ; }"}
{"text":"Initializing the PowerArray with all 0 's.","code":"let b = Array . from ( { length : 50 } , ( _ , i ) => 0 ) ;"}
{"text":"Function to print the distinct powers of N that add upto K","code":"function PowerArray ( n , k ) { while ( k > 0 ) {"}
{"text":"Getting the highest power of n before k","code":"let t = highestPower ( n , k ) ;"}
{"text":"To check if the power is being used twice or not","code":"if ( b [ t ] > 0 ) {"}
{"text":"Prlet - 1 if power is being used twice","code":"document . write ( - 1 ) ; return 0 ; } else"}
{"text":"If the power is not visited , then mark the power as visited","code":"b [ t ] = 1 ;"}
{"text":"Decrementing the value of K","code":"k -= Math . pow ( n , t ) ; }"}
{"text":"Prleting the powers of N that sum up to K","code":"for ( let i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { document . write ( i + \" \" ) ; } } return 0 ; }"}
{"text":"Driver Code","code":"let N = 3 ; let K = 40 ; PowerArray ( N , K ) ;"}
{"text":"JavaScript program to find sum of elements in an array having composite frequency","code":"let N = 100005"}
{"text":"Function to create Sieve to check primes","code":"function SieveOfEratosthenes ( composite ) { for ( let i = 0 ; i < N ; i ++ ) composite [ i ] = false ; for ( let p = 2 ; p * p < N ; p ++ ) {"}
{"text":"If composite [ p ] is not changed , then it is a prime","code":"if ( ! composite [ p ] ) {"}
{"text":"Update all multiples of p , set them to composite","code":"for ( let i = p * 2 ; i < N ; i += p ) composite [ i ] = true ; } } }"}
{"text":"Function to return the sum of elements in an array having composite frequency","code":"function sumOfElements ( arr , n ) { let composite = new Array ( N ) ; SieveOfEratosthenes ( composite ) ;"}
{"text":"Map is used to store element frequencies","code":"let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( m . has ( arr [ i ] ) ) { m [ arr [ i ] ] = m [ arr [ i ] ] + 1 ; } else { m . set ( arr [ i ] , 1 ) ; }"}
{"text":"To store sum","code":"let sum = 0 ;"}
{"text":"Traverse the map using iterators","code":"m . forEach ( ( value , key ) => {"}
{"text":"Count the number of elements having composite frequencies","code":"if ( composite [ key ] ) { sum += value ; } } ) return sum ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 ] ; let n = arr . length ;"}
{"text":"Function call","code":"document . write ( sumOfElements ( arr , n ) ) ;"}
{"text":"Function that removes the elements which have odd frequencies in the array","code":"function remove ( arr , n ) {"}
{"text":"Create a map to store the frequency of each element","code":"let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } }"}
{"text":"Remove the elements which have odd frequencies","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If the element has odd frequency then skip","code":"if ( ( mp . has ( arr [ i ] ) && mp . get ( arr [ i ] ) % 2 == 1 ) ) continue ; document . write ( arr [ i ] + \" \" ) ; } }"}
{"text":"Driver code","code":"let arr = [ 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 ] ; let n = arr . length ;"}
{"text":"Function call","code":"remove ( arr , n ) ;"}
{"text":"Maximum value of the first array element that can be attained","code":"function getmax ( arr , n , x ) {"}
{"text":"Variable to store the sum","code":"let s = 0 ;"}
{"text":"Loop to find the sum of array","code":"for ( let i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; }"}
{"text":"Desired maximum value","code":"document . write ( Math . min ( s , x ) ) ; }"}
{"text":"Driver Code","code":"let arr = [ 1 , 2 , 3 , 4 ] ; let x = 5 ; let arr_size = arr . length ; getmax ( arr , arr_size , x ) ;"}
{"text":"function to get the minimum length of the shorter side of the triangle","code":"function shortestLength ( n , x , y ) { let answer = 0 ;"}
{"text":"traversing through each polets on the plane","code":"let i = 0 ; while ( n != 0 && i < x . length ) {"}
{"text":"if sum of a polets is greater than the previous one , the maximum gets replaced","code":"if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; }"}
{"text":"prlet the length","code":"document . write ( \" \" + answer + \" \" ) ; document . write ( \" \" + \" \" + answer + \" \" + \" \" + answer + \" \" ) ; }"}
{"text":"initialize the number of polets","code":"let n = 4 ;"}
{"text":"polets on the plane","code":"let x = [ 1 , 4 , 2 , 1 ] ; let y = [ 4 , 1 , 1 , 2 ] ; shortestLength ( n , x , y ) ;"}
{"text":"Function to find intersection rectangle of given two rectangles .","code":"function FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) {"}
{"text":"Gives bottom - left point of intersection rectangle","code":"var x5 = Math . max ( x1 , x3 ) ; var y5 = Math . max ( y1 , y3 ) ;"}
{"text":"Gives top - right point of intersection rectangle","code":"var x6 = Math . min ( x2 , x4 ) ; var y6 = Math . min ( y2 , y4 ) ;"}
{"text":"No intersection","code":"if ( x5 > x6 y5 > y6 ) { document . write ( \" \" ) ; return ; } document . write ( \" \" + x5 + \" \" + y5 + \" \" ) ; document . write ( \" \" + x6 + \" \" + y6 + \" \" ) ;"}
{"text":"Gives top - left point of intersection rectangle","code":"var x7 = x5 ; var y7 = y6 ; document . write ( \" \" + x7 + \" \" + y7 + \" \" ) ;"}
{"text":"Gives bottom - right point of intersection rectangle","code":"var x8 = x6 ; var y8 = y5 ; document . write ( \" \" + x8 + \" \" + y8 + \" \" ) ; }"}
{"text":"bottom - left and top - right corners of first rectangle","code":"var x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ;"}
{"text":"bottom - left and top - right corners of first rectangle","code":"var x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ;"}
{"text":"Function call","code":"FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ;"}
{"text":"Structure to represent a co - ordinate point","code":"class Point { constructor ( a , b ) { this . x = a ; this . y = b ; } }"}
{"text":"This function receives two points and length of the side of rectangle and prints the 4 corner points of the rectangle","code":"function printCorners ( p , q , l ) { let a = new Point ( ) , b = new Point ( ) , c = new Point ( ) , d = new Point ( ) ;"}
{"text":"horizontal rectangle","code":"if ( p . x == q . x ) { a . x = ( p . x - ( l \/ 2.0 ) ) ; a . y = p . y ; d . x = ( p . x + ( l \/ 2.0 ) ) ; d . y = p . y ; b . x = ( q . x - ( l \/ 2.0 ) ) ; b . y = q . y ; c . x = ( q . x + ( l \/ 2.0 ) ) ; c . y = q . y ; }"}
{"text":"vertical rectangle","code":"else if ( p . y == q . y ) { a . y = ( p . y - ( l \/ 2.0 ) ) ; a . x = p . x ; d . y = ( p . y + ( l \/ 2.0 ) ) ; d . x = p . x ; b . y = ( q . y - ( l \/ 2.0 ) ) ; b . x = q . x ; c . y = ( q . y + ( l \/ 2.0 ) ) ; c . x = q . x ; }"}
{"text":"slanted rectangle","code":"else {"}
{"text":"calculate slope of the side","code":"let m = ( p . x - q . x ) \/ ( q . y - p . y ) ;"}
{"text":"calculate displacements along axes","code":"let dx = ( ( l \/ Math . sqrt ( 1 + ( m * m ) ) ) * 0.5 ) ; let dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } document . write ( a . x + \" \" + a . y + \" \" + b . x + \" \" + b . y + \" \" + c . x + \" \" + c . y + \" \" + d . x + \" \" + d . y + \" \" ) ; }"}
{"text":"Driver code","code":"let p1 = new Point ( 1 , 0 ) , q1 = new Point ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; let p = new Point ( 1 , 1 ) , q = new Point ( - 1 , - 1 ) ; printCorners ( p , q , ( 2 * Math . sqrt ( 2 ) ) ) ;"}
{"text":"Function to find the minimum cost to modify the array according to the given criteria","code":"function minimumCost ( arr , N , X , Y ) {"}
{"text":"Count of wrong positioned odd and even elements","code":"let even_count = 0 , odd_count = 0 ; for ( let i = 0 ; i < N ; i ++ ) {"}
{"text":"Odd Count","code":"if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; }"}
{"text":"Even Count","code":"if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } }"}
{"text":"Swapping Cost","code":"let cost1 = X * Math . min ( odd_count , even_count ) ;"}
{"text":"Decrementing cost after swapping","code":"let cost2 = Y * ( Math . max ( odd_count , even_count ) - Math . min ( odd_count , even_count ) ) ;"}
{"text":"Only decrementing cost","code":"let cost3 = ( odd_count + even_count ) * Y ;"}
{"text":"Return the minimum cost of the two cases","code":"return Math . min ( cost1 + cost2 , cost3 ) ; }"}
{"text":"Driver Code","code":"let arr = [ 5 , 3 , 7 , 2 , 1 ] , X = 10 , Y = 2 ; let N = arr . length ; document . write ( minimumCost ( arr , N , X , Y ) ) ;"}
{"text":"Function to find the minimum product of the minimum and maximum among all the possible subarrays","code":"function findMinMax ( a ) {"}
{"text":"Stores resultant minimum product","code":"let min_val = 1000000000 ;"}
{"text":"Traverse the given array arr [ ]","code":"for ( let i = 1 ; i < a . length ; ++ i ) {"}
{"text":"Min of product of all two pair of consecutive elements","code":"min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; }"}
{"text":"Return the resultant value","code":"return min_val ; }"}
{"text":"Driver Code","code":"let arr = [ 6 , 4 , 5 , 6 , 2 , 4 , 1 ] ; document . write ( findMinMax ( arr ) )"}
{"text":"Structure of Tree","code":"let sum = 0 ; class TreeNode {"}
{"text":"Constructor","code":"constructor ( data = \" \" , left = null , right = null ) { this . data = data ; this . left = left ; this . right = right ; } }"}
{"text":"Function to add the node to the sum below the target node","code":"function kDistanceDownSum ( root , k ) {"}
{"text":"Base Case","code":"if ( root == null k < 0 ) { return }"}
{"text":"If Kth distant node is reached","code":"if ( k == 0 ) { sum += root . data ; return ; }"}
{"text":"Recur for the left and the right subtrees","code":"kDistanceDownSum ( root . left , k - 1 ) ; kDistanceDownSum ( root . right , k - 1 ) ; }"}
{"text":"Function to find the K distant nodes from target node , it returns - 1 if target node is not present in tree","code":"function kDistanceSum ( root , target , k ) {"}
{"text":"Base Case 1","code":"if ( root == null ) return - 1 ;"}
{"text":"If target is same as root .","code":"if ( root . data == target ) { kDistanceDownSum ( root . left , k - 1 ) ; return 0 ; }"}
{"text":"Recurr for the left subtree","code":"let dl = - 1 ;"}
{"text":"Tree is BST so reduce the search space","code":"if ( target < root . data ) { dl = kDistanceSum ( root . left , target , k ) ; }"}
{"text":"Check if target node was found in left subtree","code":"if ( dl != - 1 ) {"}
{"text":"If root is at distance k from the target","code":"if ( dl + 1 == k ) sum += root . data ;"}
{"text":"Node less than target will be present in left","code":"return - 1 ; }"}
{"text":"When node is not present in the left subtree","code":"let dr = - 1 ; if ( target > root . data ) { dr = kDistanceSum ( root . right , target , k ) ; } if ( dr != - 1 ) {"}
{"text":"If Kth distant node is reached","code":"if ( dr + 1 == k ) sum += root . data ;"}
{"text":"Node less than target at k distance maybe present in the left tree","code":"else kDistanceDownSum ( root . left , k - dr - 2 ) ; return 1 + dr ; }"}
{"text":"If target was not present in the left nor in right subtree","code":"return - 1 ; }"}
{"text":"Function to insert a node in BST","code":"function insertNode ( data , root ) {"}
{"text":"If root is null","code":"if ( root == null ) { let node = new TreeNode ( data ) ; return node ; }"}
{"text":"Insert the data in right half","code":"else if ( data > root . data ) { root . right = insertNode ( data , root . right ) ; }"}
{"text":"Insert the data in left half","code":"else if ( data <= root . data ) { root . left = insertNode ( data , root . left ) ; }"}
{"text":"Return the root node","code":"return root ; }"}
{"text":"Function to find the sum of K distant nodes from the target node having value less than target node","code":"function findSum ( root , target , K ) {"}
{"text":"Stores the sum of nodes having values < target at K distance","code":"kDistanceSum ( root , target , K , sum ) ;"}
{"text":"Print the resultant sum","code":"document . write ( sum ) ; }"}
{"text":"Driver Code","code":"let root = null ; let N = 11 ; let tree = [ 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 ] ;"}
{"text":"Create the Tree","code":"for ( let i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } let target = 7 ; let K = 2 ; findSum ( root , target , K ) ;"}
{"text":"Function to find the type of the item given out according to the given rules","code":"function itemType ( n ) {"}
{"text":"Stores the count of item given out at each step","code":"let count = 0 ;"}
{"text":"Iterate over the days from 1","code":"for ( let day = 1 ; ; day ++ ) {"}
{"text":"Iterate over type of item on that day","code":"for ( let type = day ; type > 0 ; type -- ) { count += type ;"}
{"text":"Count of items given out should exceed n","code":"if ( count >= n ) return type ; } } }"}
{"text":"Driver Code","code":"let N = 10 ; document . write ( itemType ( N ) ) ;"}
{"text":"Function to print the sum of array elements that are equidistant from two consecutive powers of 2","code":"function FindSum ( arr , N ) {"}
{"text":"Stores the resultant sum of the array elements","code":"let res = 0 ;"}
{"text":"Traverse the array arr [ ]","code":"for ( let i = 0 ; i < N ; i ++ ) {"}
{"text":"Stores the power of 2 of the number arr [ i ]","code":"let power = Math . floor ( Math . log2 ( arr [ i ] ) ) ;"}
{"text":"Stores the number which is power of 2 and lesser than or equal to arr [ i ]","code":"let LesserValue = Math . pow ( 2 , power ) ;"}
{"text":"Stores the number which is power of 2 and greater than or equal to arr [ i ]","code":"let LargerValue = Math . pow ( 2 , power + 1 ) ;"}
{"text":"If arr [ i ] - LesserValue is the same as LargerValue - arr [ i ]","code":"if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) {"}
{"text":"Increment res by arr [ i ]","code":"res += arr [ i ] ; } }"}
{"text":"Return the resultant sum res","code":"return res ; }"}
{"text":"Driver Code","code":"let arr = [ 10 , 24 , 17 , 3 , 8 ] ; let N = arr . length ; document . write ( FindSum ( arr , N ) ) ;"}
{"text":"Function to find the person who will finish last","code":"function findLast ( mat ) { let m = mat . length ; let n = mat [ 0 ] . length ;"}
{"text":"To keep track of rows and columns having 1","code":"let rows = new Set ( ) ; let cols = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . add ( i ) ; cols . add ( j ) ; } } }"}
{"text":"Available rows and columns","code":"let avRows = m - rows . size ; let avCols = n - cols . size ;"}
{"text":"Minimum number of choices we have","code":"let choices = Math . min ( avRows , avCols ) ;"}
{"text":"If number of choices are odd","code":"if ( choices & 1 )"}
{"text":"P1 will finish last","code":"document . write ( \" \" )"}
{"text":"Otherwise , P2 will finish last","code":"else document . write ( \" \" ) }"}
{"text":"Given matrix","code":"let mat = [ [ 1 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 1 ] ] findLast ( mat ) ;"}
{"text":"JavaScript program to implement the above approach","code":"let MOD = 1000000007 ;"}
{"text":"Function to find the sum of first N natural numbers represented in binary representation","code":"function sumOfBinaryNumbers ( n ) {"}
{"text":"Stores the resultant sum","code":"let ans = 0 ; let one = 1 ;"}
{"text":"Iterate until the value of N is greater than 0","code":"while ( true ) {"}
{"text":"If N is less than 2","code":"if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; }"}
{"text":"Store the MSB position of N","code":"let x = Math . floor ( Math . log ( n ) \/ Math . log ( 2 ) ) ; let cur = 0 ; let add = Math . floor ( Math . pow ( 2 , ( x - 1 ) ) ) ;"}
{"text":"Iterate in the range [ 1 , x ] and add the contribution of the numbers from 1 to ( 2 ^ x - 1 )","code":"for ( let i = 1 ; i <= x ; i ++ ) {"}
{"text":"Update the value of the cur and add","code":"cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; }"}
{"text":"Add the cur to ans","code":"ans = ( ans + cur ) % MOD ;"}
{"text":"Store the remaining numbers","code":"let rem = n - Math . floor ( Math . pow ( 2 , x ) ) + 1 ;"}
{"text":"Add the contribution by MSB by the remaining numbers","code":"let p = Math . floor ( Math . pow ( 10 , x ) ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ;"}
{"text":"The next iteration will be repeated for 2 ^ x - 1","code":"n = rem - 1 ; }"}
{"text":"Print the result","code":"document . write ( ans ) ; }"}
{"text":"Driver code","code":"let N = 3 ; sumOfBinaryNumbers ( N ) ;"}
{"text":"Function to find the Fibonacci number which is nearest to N","code":"function nearestFibonacci ( num ) {"}
{"text":"Base Case","code":"if ( num == 0 ) { document . write ( 0 ) ; return ; }"}
{"text":"Initialize the first & second terms of the Fibonacci series","code":"let first = 0 , second = 1 ;"}
{"text":"Store the third term","code":"let third = first + second ;"}
{"text":"Iterate until the third term is less than or equal to num","code":"while ( third <= num ) {"}
{"text":"Update the first","code":"first = second ;"}
{"text":"Update the second","code":"second = third ;"}
{"text":"Update the third","code":"third = first + second ; }"}
{"text":"Store the Fibonacci number having smaller difference with N","code":"let ans = ( Math . abs ( third - num ) >= Math . abs ( second - num ) ) ? second : third ;"}
{"text":"Print the result","code":"document . write ( ans ) ; }"}
{"text":"Driver Code","code":"let N = 17 ; nearestFibonacci ( N ) ;"}
{"text":"Function to check if the maximum prefix array of ans [ ] is equal to array arr [ ]","code":"function checkPermutation ( ans , a , n ) {"}
{"text":"Initialize a variable , Max","code":"let Max = Number . MIN_VALUE ;"}
{"text":"Traverse the array , ans [ ]","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"Store the maximum value upto index i","code":"Max = Math . max ( Max , ans [ i ] ) ;"}
{"text":"If it is not equal to a [ i ] , then return false","code":"if ( Max != a [ i ] ) return false ; }"}
{"text":"Otherwise return false","code":"return true ; }"}
{"text":"Function to find the permutation of the array whose prefix maximum array is same as the given array a [ ]","code":"function findPermutation ( a , n ) {"}
{"text":"Stores the required permutation","code":"let ans = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { ans [ i ] = 0 ; }"}
{"text":"Stores the index of first occurrence of elements","code":"let um = new Map ( ) ;"}
{"text":"Traverse the array a [ ]","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"If a [ i ] is not present in um , then store it in um","code":"if ( ! um . has ( a [ i ] ) ) {"}
{"text":"Update the ans [ i ] to a [ i ]","code":"ans [ i ] = a [ i ] ; um . set ( a [ i ] , i ) ; } }"}
{"text":"Stores the unvisited numbers","code":"let v = [ ] ; let j = 0 ;"}
{"text":"Fill the array , v [ ]","code":"for ( let i = 1 ; i <= n ; i ++ ) {"}
{"text":"Store the index","code":"if ( ! um . has ( i ) ) { v . push ( i ) ; } }"}
{"text":"Traverse the array , ans [ ]","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"Fill v [ j ] at places where ans [ i ] is 0","code":"if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } }"}
{"text":"Check if the current permutation maximum prefix array is same as the given array a [ ]","code":"if ( checkPermutation ( ans , a , n ) ) {"}
{"text":"If true , the print the permutation","code":"for ( let i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + \" \" ) ; } }"}
{"text":"Otherwise , print - 1","code":"else document . write ( \" \" ) ; }"}
{"text":"Driver Code","code":"let arr = [ 1 , 3 , 4 , 5 , 5 ] ; let N = arr . length ;"}
{"text":"Function Call","code":"findPermutation ( arr , N ) ;"}
{"text":"Function to count the number of required pairs for every array element","code":"function countEqualElementPairs ( arr , N ) {"}
{"text":"Initialize a map","code":"var mp = new Map ( ) ;"}
{"text":"Update the frequency of every element","code":"for ( var i = 0 ; i < N ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } }"}
{"text":"Stores the count of pairs","code":"var total = 0 ;"}
{"text":"Traverse the map","code":"mp . forEach ( ( value , key ) => {"}
{"text":"Count the number of ways to select pairs consisting of equal elements only","code":"total += ( value * ( value - 1 ) ) \/ 2 ; } ) ;"}
{"text":"Traverse the array","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"Print the count for every array element","code":"document . write ( total - ( mp . get ( arr [ i ] ) - 1 ) + \" \" ) ; } }"}
{"text":"Given array","code":"var arr = [ 1 , 1 , 2 , 1 , 2 ] ;"}
{"text":"Size of the array","code":"var N = arr . length ; countEqualElementPairs ( arr , N ) ;"}
{"text":"Function to return the count of natural octal numbers upto N digits","code":"function count ( N ) { var sum = 0 ;"}
{"text":"Loop to iterate from 1 to N and calculating number of octal numbers for every ' i ' th digit .","code":"for ( var i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }"}
{"text":"Driver code","code":"var N = 4 ; document . write ( count ( N ) ) ;"}
{"text":"Function to check is num is palindromic or not","code":"function isPalindrome ( n ) {"}
{"text":"Convert n to string str","code":"var str = ( n . toString ( ) ) ;"}
{"text":"Starting and ending index of string str","code":"var s = 0 , e = str . length - 1 ; while ( s < e ) {"}
{"text":"If char at s and e are not equals then return false","code":"if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; }"}
{"text":"Function to find palindromic divisors","code":"function palindromicDivisors ( n ) {"}
{"text":"To sore the palindromic divisors of number n","code":"var PalindromDivisors = [ ] ; for ( var i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) {"}
{"text":"If n is divisible by i","code":"if ( n % i == 0 ) {"}
{"text":"Check if number is a perfect square","code":"if ( n \/ i == i ) {"}
{"text":"Check divisor is palindromic , then store it","code":"if ( isPalindrome ( i ) ) { PalindromDivisors . push ( i ) ; } } else {"}
{"text":"Check if divisors are palindrome","code":"if ( isPalindrome ( i ) ) { PalindromDivisors . push ( i ) ; }"}
{"text":"Check if n \/ divisors is palindromic or not","code":"if ( isPalindrome ( n \/ i ) ) { PalindromDivisors . push ( n \/ i ) ; } } } }"}
{"text":"Print all palindromic divisors in sorted order","code":"PalindromDivisors . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < PalindromDivisors . length ; i ++ ) { document . write ( PalindromDivisors [ i ] + \" \" ) ; } }"}
{"text":"Driver code","code":"var n = 66 ;"}
{"text":"Function call to find all palindromic divisors","code":"palindromicDivisors ( n ) ;"}
{"text":"Function to return the minimum deletions to get minimum OR","code":"function findMinDel ( arr , n ) {"}
{"text":"To store the minimum element","code":"var min_num = 1000000000 ;"}
{"text":"Find the minimum element from the array","code":"for ( var i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ;"}
{"text":"To store the frequency of the minimum element","code":"var cnt = 0 ;"}
{"text":"Find the frequency of the minimum element","code":"for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ;"}
{"text":"Return the final answer","code":"return n - cnt ; }"}
{"text":"Driver code","code":"var arr = [ 3 , 3 , 2 ] ; var n = arr . length ; document . write ( findMinDel ( arr , n ) ) ;"}
{"text":"Javascript implementation of the approach","code":"function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; }"}
{"text":"Function to return the required count","code":"function cntSubArr ( arr , n ) {"}
{"text":"To store the final answer","code":"var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"To store the GCD starting from index ' i '","code":"var curr_gcd = 0 ;"}
{"text":"Loop to find the gcd of each subarray from arr [ i ] to arr [ i ... n - 1 ]","code":"for ( var j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ;"}
{"text":"Increment the count if curr_gcd = 1","code":"ans += ( curr_gcd == 1 ) ; } }"}
{"text":"Return the final answer","code":"return ans ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 1 , 1 ] ; var n = arr . length ; document . write ( cntSubArr ( arr , n ) ) ;"}
{"text":"Function to print first N prime numbers","code":"function print_primes_till_N ( N ) {"}
{"text":"Declare the variables","code":"let i , j , flag ;"}
{"text":"Print display message","code":"document . write ( \" \" + N + \" \" ) ;"}
{"text":"Traverse each number from 1 to N with the help of for loop","code":"for ( i = 1 ; i <= N ; i ++ ) {"}
{"text":"Skip 0 and 1 as they are neither prime nor composite","code":"if ( i == 1 i == 0 ) continue ;"}
{"text":"flag variable to tell if i is prime or not","code":"flag = 1 ; for ( j = 2 ; j <= i \/ 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } }"}
{"text":"flag = 1 means i is prime and flag = 0 means i is not prime","code":"if ( flag == 1 ) document . write ( i + \" \" ) ; } }"}
{"text":"Driver code","code":"let N = 100 ; print_primes_till_N ( N ) ;"}
{"text":"Function to find X according to the given conditions","code":"function findX ( A , B ) { var X = 0 ; var MAX = 32 ;"}
{"text":"int can have 32 bits","code":"for ( var bit = 0 ; bit < MAX ; bit ++ ) {"}
{"text":"Temporary ith bit","code":"var tempBit = 1 << bit ;"}
{"text":"Compute ith bit of X according to given conditions Expression below is the direct conclusion from the illustration we had taken earlier","code":"var bitOfX = A & B & tempBit ;"}
{"text":"Add the ith bit of X to X","code":"X += bitOfX ; } return X ; }"}
{"text":"Driver code","code":"var A = 11 , B = 13 ; document . write ( findX ( A , B ) ) ;"}
{"text":"Function to return the count of subsets with the maximum mean","code":"function cntSubSets ( arr , n ) {"}
{"text":"Maximum value from the array","code":"var maxVal = arr . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ;"}
{"text":"To store the number of times maximum element appears in the array","code":"var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; }"}
{"text":"Return the count of valid subsets","code":"return ( Math . pow ( 2 , cnt ) - 1 ) ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 2 , 1 , 2 ] var n = arr . length ; document . write ( cntSubSets ( arr , n ) ) ;"}
{"text":"Function to return the probability of getting the maximum pair sum when a random pair is chosen from the given array","code":"function findProb ( arr , n ) {"}
{"text":"Initialize the maximum sum , its count and the count of total pairs","code":"var maxSum = - 100000000 , maxCount = 0 , totalPairs = 0 ;"}
{"text":"For every single pair","code":"for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) {"}
{"text":"Get the sum of the current pair","code":"var sum = arr [ i ] + arr [ j ] ;"}
{"text":"If the sum is equal to the current maximum sum so far","code":"if ( sum == maxSum ) {"}
{"text":"Increment its count","code":"maxCount ++ ; }"}
{"text":"If the sum is greater than the current maximum","code":"else if ( sum > maxSum ) {"}
{"text":"Update the current maximum and re - initialize the count to 1","code":"maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } }"}
{"text":"Find the required probability","code":"var prob = maxCount \/ totalPairs ; return prob ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 1 , 1 , 2 , 2 , 2 ] var n = arr . length ; document . write ( findProb ( arr , n ) ) ;"}
{"text":"Javascript implementation of the approach","code":"function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }"}
{"text":"Function to return the count of common factors of a and b such that all the elements are co - prime to one another","code":"function maxCommonFactors ( a , b ) {"}
{"text":"GCD of a and b","code":"let gcd = GCD ( a , b ) ;"}
{"text":"Include 1 initially","code":"let ans = 1 ;"}
{"text":"Find all the prime factors of the gcd","code":"for ( let i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd = parseInt ( gcd \/ i ) ; } }"}
{"text":"If gcd is prime","code":"if ( gcd != 1 ) ans ++ ;"}
{"text":"Return the required answer","code":"return ans ; }"}
{"text":"Driver code","code":"let a = 12 , b = 18 ; document . write ( maxCommonFactors ( a , b ) ) ;"}
{"text":"Javascript implementation of the approach","code":"var days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ;"}
{"text":"Function to return the day number of the year for the given date","code":"function dayOfYear ( date ) {"}
{"text":"Extract the year , month and the day from the date string","code":"var year = parseInt ( date . substring ( 0 , 4 ) ) ; var month = parseInt ( date . substring ( 5 , 6 ) ) ; var day = parseInt ( date . substring ( 8 ) ) ;"}
{"text":"If current year is a leap year and the date given is after the 28 th of February then it must include the 29 th February","code":"if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; }"}
{"text":"Add the days in the previous months","code":"while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; }"}
{"text":"Driver code","code":"var date = \" \" ; document . write ( dayOfYear ( date ) ) ;"}
{"text":"Function to find number of cells in the table contains X","code":"function Cells ( n , x ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && parseInt ( x \/ i ) <= n ) ans ++ ; return ans ; }"}
{"text":"Driver code","code":"let n = 6 , x = 12 ;"}
{"text":"Function call","code":"document . write ( Cells ( n , x ) ) ;"}
{"text":"Function to return the smallest power of 4 greater than or equal to n","code":"function nextPowerOfFour ( n ) { let x = Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ;"}
{"text":"If n is itself is a power of 4 then return n","code":"if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return Math . pow ( x , 4 ) ; } }"}
{"text":"Driver code","code":"let n = 122 ; document . write ( nextPowerOfFour ( n ) ) ;"}
{"text":"Function to return the minimum operations required","code":"function minOperations ( x , y , p , q ) {"}
{"text":"Not possible","code":"if ( y % x != 0 ) return - 1 var d = Math . floor ( y \/ x )"}
{"text":"To store the greatest power of p that divides d","code":"var a = 0"}
{"text":"While divible by p","code":"while ( d % p == 0 ) { d = Math . floor ( d \/ p ) a += 1 }"}
{"text":"To store the greatest power of q that divides d","code":"var b = 0"}
{"text":"While divible by q","code":"while ( d % q == 0 ) { d = Math . floor ( d \/ q ) b += 1 }"}
{"text":"If d > 1","code":"if ( d != 1 ) return - 1"}
{"text":"Since , d = p ^ a * q ^ b","code":"return ( a + b ) }"}
{"text":"Driver code","code":"var x = 12 var y = 2592 var p = 2 var q = 3 document . write ( minOperations ( x , y , p , q ) )"}
{"text":"Function to calculate NC4","code":"function nCr ( n ) {"}
{"text":"Base case to calculate NC4","code":"if ( n < 4 ) return 0 ; let answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer = parseInt ( answer \/ 24 ) ; return answer ; }"}
{"text":"Function to return the count of required quadruples using Inclusion Exclusion","code":"function countQuadruples ( N , K ) {"}
{"text":"Effective N","code":"let M = parseInt ( N \/ K ) ; let answer = nCr ( M ) ;"}
{"text":"Iterate over 2 to M","code":"for ( let i = 2 ; i < M ; i ++ ) { let j = i ;"}
{"text":"Number of divisors of i till M","code":"let temp2 = parseInt ( M \/ i ) ;"}
{"text":"Count stores the number of prime divisors occurring exactly once","code":"let count = 0 ;"}
{"text":"To prevent repetition of prime divisors","code":"let check = 0 ; let temp = j ; while ( j % 2 == 0 ) { count ++ ; j = parseInt ( j \/ 2 ) ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( let k = 3 ; k <= Math . sqrt ( temp ) ; k += 2 ) { let cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j = parseInt ( j \/ k ) ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; }"}
{"text":"If repetition of prime divisors present ignore this number","code":"if ( check ) continue ; else {"}
{"text":"If prime divisor count is odd subtract it from answer else add","code":"if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; }"}
{"text":"Driver code","code":"let N = 10 , K = 2 ; document . write ( countQuadruples ( N , K ) ) ;"}
{"text":"Function to return the required number X","code":"function getX ( a , b , c , d ) { var X = ( b * c - a * d ) \/ ( d - c ) ; return X ; }"}
{"text":"Driver code","code":"var a = 2 , b = 3 , c = 4 , d = 5 ; document . write ( getX ( a , b , c , d ) ) ;"}
{"text":"Function to check if a character is vowel or consonent","code":"function isVowel ( ch ) { if ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) return true ; else return false ; }"}
{"text":"Function to calculate factorial of a number","code":"function fact ( n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; }"}
{"text":"Calculating no of ways for arranging vowels","code":"function only_vowels ( freq ) { let denom = 1 ; let cnt_vwl = 0 ;"}
{"text":"Iterate the map and count the number of vowels and calculate no of ways to arrange vowels","code":"for ( let [ key , value ] of freq . entries ( ) ) { if ( isVowel ( key ) ) { denom *= fact ( value ) ; cnt_vwl += value ; } } return Math . floor ( fact ( cnt_vwl ) \/ denom ) ; }"}
{"text":"Calculating no of ways to arrange the given word such that all vowels come together","code":"function all_vowels_together ( freq ) {"}
{"text":"Calculate no of ways to arrange vowels","code":"let vow = only_vowels ( freq ) ;"}
{"text":"To store denominator of fraction","code":"let denom = 1 ;"}
{"text":"Count of consonents","code":"let cnt_cnst = 0 ; for ( let [ key , value ] of freq . entries ( ) ) { if ( ! isVowel ( key ) ) { denom *= fact ( value ) ; cnt_cnst += value ; } }"}
{"text":"Calculate the number of ways to arrange the word such that all vowels come together","code":"let ans = Math . floor ( fact ( cnt_cnst + 1 ) \/ denom ) ; return ( ans * vow ) ; }"}
{"text":"To calculate total number of permutations","code":"function total_permutations ( freq ) {"}
{"text":"To store length of the given word","code":"let cnt = 0 ;"}
{"text":"Denominator of fraction","code":"let denom = 1 ; for ( let [ key , value ] of freq . entries ( ) ) { denom *= fact ( value ) ; cnt += value ; }"}
{"text":"Return total number of permutations of the given word","code":"return Math . floor ( fact ( cnt ) \/ denom ) ; }"}
{"text":"Function to calculate number of permutations such that no vowels come together","code":"function no_vowels_together ( word ) {"}
{"text":"To store frequency of character","code":"let freq = new Map ( ) ;"}
{"text":"Count frequency of all characters","code":"for ( let i = 0 ; i < word . length ; i ++ ) { let ch = word [ i ] . toLowerCase ( ) ; if ( freq . has ( ch ) ) { freq . set ( ch , freq . get ( ch ) + 1 ) ; } else { freq . set ( ch , 1 ) ; } }"}
{"text":"Calculate total number of permutations","code":"let total = total_permutations ( freq ) ;"}
{"text":"Calculate total number of permutations such that all vowels come together","code":"let vwl_tgthr = all_vowels_together ( freq ) ;"}
{"text":"Subtract vwl_tgthr from total to get the result","code":"let res = total - vwl_tgthr ;"}
{"text":"Return the result","code":"return res ; }"}
{"text":"Driver code","code":"let word = \" \" ; let ans = no_vowels_together ( word ) ; document . write ( ans + \" \" ) ; word = \" \" ; ans = no_vowels_together ( word ) ; document . write ( ans + \" \" ) ; word = \" \" ; ans = no_vowels_together ( word ) ; document . write ( ans + \" \" ) ;"}
{"text":"Function to return the number of men initially","code":"function numberOfMen ( D , m , d ) { var Men = ( m * ( D - d ) ) \/ d ; return Men ; }"}
{"text":"Driver code","code":"var D = 5 , m = 4 , d = 4 ; document . write ( numberOfMen ( D , m , d ) ) ;"}
{"text":"Function to find area","code":"function area ( a , b , c ) { var d = Math . abs ( ( c * c ) \/ ( 2 * a * b ) ) ; return d ; }"}
{"text":"Driver code","code":"var a = - 2 , b = 4 , c = 3 ; document . write ( area ( a , b , c ) ) ;"}
{"text":"Function to return the vector containing the answer","code":"function addToArrayForm ( A , K ) {"}
{"text":"ArrayList v is to store each digits sum and ArrayList ans is to store the answer","code":"let v = [ ] ; let ans = [ ] ;"}
{"text":"No carry in the beginning","code":"let rem = 0 ; let i = 0 ;"}
{"text":"Start loop from the end and take element one by one","code":"for ( i = A . length - 1 ; i >= 0 ; i -- ) {"}
{"text":"Array index and last digit of number","code":"let my = A [ i ] + K % 10 + rem ; if ( my > 9 ) {"}
{"text":"Maintain carry of summation","code":"rem = 1 ;"}
{"text":"Push the digit value into the array","code":"v . push ( my % 10 ) ; } else { v . push ( my ) ; rem = 0 ; } K = parseInt ( K \/ 10 , 10 ) ; }"}
{"text":"K value is greater then 0","code":"while ( K > 0 ) {"}
{"text":"Push digits of K one by one in the array","code":"let my = K % 10 + rem ; v . push ( my % 10 ) ;"}
{"text":"Also maintain carry with summation","code":"if ( parseInt ( my \/ 10 , 10 ) > 0 ) rem = 1 ; else rem = 0 ; K = parseInt ( K \/ 10 , 10 ) ; } if ( rem > 0 ) v . push ( rem ) ;"}
{"text":"Reverse the elements of vector v and store it in vector ans","code":"for ( let j = v . length - 1 ; j >= 0 ; j -- ) ans . push ( v [ j ] ) ; return ans ; }"}
{"text":"Driver code","code":"let A = [ ] ; A . push ( 2 ) ; A . push ( 7 ) ; A . push ( 4 ) ; let K = 181 ; let ans = addToArrayForm ( A , K ) ;"}
{"text":"Print the answer","code":"for ( let i = 0 ; i < ans . length ; i ++ ) document . write ( ans [ i ] ) ;"}
{"text":"JavaScript implementation of the above approach","code":"const MAX = 100005 ;"}
{"text":"Function to return maximum sum of a sub - array","code":"function kadaneAlgorithm ( ar , n ) { let sum = 0 , maxSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . max ( maxSum , sum ) ; } return maxSum ; }"}
{"text":"Function to return maximum value of function F","code":"function maxFunction ( arr , n ) { let b = new Array ( MAX ) , c = new Array ( MAX ) ;"}
{"text":"Compute arrays B [ ] and C [ ]","code":"for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( i & 1 ) { b [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } }"}
{"text":"Find maximum sum sub - array of both of the arrays and take maximum among them","code":"let ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 5 , 4 , 7 ] ; let n = arr . length ; document . write ( maxFunction ( arr , n ) ) ;"}
{"text":"Function to find the element","code":"function findThirdDigit ( n ) {"}
{"text":"if n < 3","code":"if ( n < 3 ) return 0 ;"}
{"text":"If n is even return 6 If n is odd return 1","code":"return n & 1 ? 1 : 6 ; }"}
{"text":"Driver code","code":"var n = 7 ; document . write ( findThirdDigit ( n ) ) ;"}
{"text":"Function to return the probability of A winning","code":"function getProbability ( a , b , c , d ) {"}
{"text":"p and q store the values of fractions a \/ b and c \/ d","code":"var p = a \/ b ; var q = c \/ d ;"}
{"text":"To store the winning probability of A","code":"var ans = p * ( 1 \/ ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }"}
{"text":"Driver code","code":"var a = 1 , b = 2 , c = 10 , d = 11 ; document . write ( getProbability ( a , b , c , d ) . toFixed ( 5 ) ) ;"}
{"text":"Function to check if n is palindrome","code":"function isPalindrome ( n ) {"}
{"text":"Find the appropriate divisor to extract the leading digit","code":"var divisor = 1 ; while ( parseInt ( n \/ divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n \/ divisor ) ; var trailing = n % 10 ;"}
{"text":"If first and last digits are not same then return false","code":"if ( leading != trailing ) return false ;"}
{"text":"Removing the leading and trailing digits from the number","code":"n = parseInt ( ( n % divisor ) \/ 10 ) ;"}
{"text":"Reducing divisor by a factor of 2 as 2 digits are dropped","code":"divisor = parseInt ( divisor \/ 100 ) ; } return true ; }"}
{"text":"Function to find the largest palindromic number","code":"function largestPalindrome ( A , n ) { var currentMax = - 1 ; for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"If a palindrome larger than the currentMax is found","code":"if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; }"}
{"text":"Return the largest palindromic number from the array","code":"return currentMax ; }"}
{"text":"Driver code","code":"var A = [ 1 , 232 , 54545 , 999991 ] ; var n = A . length ;"}
{"text":"Print required answer","code":"document . write ( largestPalindrome ( A , n ) ) ;"}
{"text":"Function to return the final element","code":"function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }"}
{"text":"Driver code","code":"let N = 12 ; document . write ( getFinalElement ( N ) ) ;"}
{"text":"Function to create Sieve to check primes","code":"function SieveOfEratosthenes ( prime , p_size ) {"}
{"text":"False here indicates that it is not prime","code":"prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) {"}
{"text":"If prime [ p ] is not changed , then it is a prime","code":"if ( prime [ p ] ) {"}
{"text":"Update all multiples of p , set them to non - prime","code":"for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }"}
{"text":"Function to return the sum of elements in an array having prime frequency","code":"function sumOfElements ( arr , n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) SieveOfEratosthenes ( prime , n + 1 ) ; let i , j ;"}
{"text":"Map is used to store element frequencies","code":"let m = new Map ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . has ( arr [ i ] ) ) m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; else m . set ( arr [ i ] , 1 ) ; } let sum = 0 ;"}
{"text":"Traverse the map using iterators","code":"for ( let it of m ) {"}
{"text":"Count the number of elements having prime frequencies","code":"if ( prime [ it [ 1 ] ] ) { sum += ( it [ 0 ] ) ; } } return sum ; }"}
{"text":"Driver code","code":"let arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] ; let n = arr . length ; document . write ( sumOfElements ( arr , n ) ) ;"}
{"text":"Function that returns true if the given number is a palindrome","code":"function isPalindrome ( num ) { let reverse_num = 0 , remainder , temp ;"}
{"text":"Here we are generating a new number ( reverse_num ) * by reversing the digits of original input number","code":"temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp = Math . floor ( temp \/ 10 ) ; }"}
{"text":"If the original input number ( num ) is equal to * to its reverse ( reverse_num ) then its palindrome * else it is not .","code":"if ( reverse_num == num ) { return true ; } return false ; }"}
{"text":"Function that returns true if the given number is of odd length","code":"function isOddLength ( num ) { let count = 0 ; while ( num > 0 ) { num = Math . floor ( num \/ 10 ) ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; }"}
{"text":"Function to return the sum of all odd length palindromic numbers within the given range","code":"function sumOfAllPalindrome ( L , R ) { let sum = 0 ; if ( L <= R ) for ( let i = L ; i <= R ; i ++ ) {"}
{"text":"if number is palindrome and of odd length","code":"if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }"}
{"text":"Driver code","code":"let L = 110 , R = 1130 ; document . write ( sumOfAllPalindrome ( L , R ) ) ;"}
{"text":"Factorial of a number","code":"function fact ( n ) { let f = 1 ; for ( let i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; }"}
{"text":"Calculating ways for arranging consonants","code":"function waysOfConsonants ( size1 , freq ) { let ans = fact ( size1 ) ; for ( let i = 0 ; i < 26 ; i ++ ) {"}
{"text":"Ignore vowels","code":"if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = Math . floor ( ans \/ fact ( freq [ i ] ) ) ; } return ans ; }"}
{"text":"Calculating ways for arranging vowels","code":"function waysOfVowels ( size2 , freq ) { return Math . floor ( fact ( size2 ) \/ ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ) ; }"}
{"text":"Function to count total no . of ways","code":"function countWays ( str ) { let freq = new Array ( 200 ) ; for ( let i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ;"}
{"text":"Count vowels and consonant","code":"let vowel = 0 , consonant = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] != ' ' && str [ i ] != ' ' && str [ i ] != ' ' && str [ i ] != ' ' && str [ i ] != ' ' ) consonant ++ ; else vowel ++ ; }"}
{"text":"Total no . of ways","code":"return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; }"}
{"text":"Driver code","code":"let str = \" \" ; document . write ( countWays ( str ) ) ;"}
{"text":"Computes value of first fibonacci numbers and stores their alternate sum","code":"function calculateAlternateSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ;"}
{"text":"Initialize result","code":"var sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ;"}
{"text":"Add remaining terms","code":"for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;"}
{"text":"For even terms","code":"if ( i % 2 == 0 ) sum -= fibo [ i ] ;"}
{"text":"For odd terms","code":"else sum += fibo [ i ] ; }"}
{"text":"Return the alternating sum","code":"return sum ; }"}
{"text":"Get n","code":"var n = 8 ;"}
{"text":"Find the alternating sum","code":"document . write ( \" \" + n + \" \" + calculateAlternateSum ( n ) ) ;"}
{"text":"Function that will return nth term","code":"function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return parseInt ( k \/ 2 ) ; }"}
{"text":"Get n","code":"let n = 9 ;"}
{"text":"Get the value","code":"document . write ( getValue ( n ) + \" \" ) ;"}
{"text":"Get n","code":"n = 1025 ;"}
{"text":"Get the value","code":"document . write ( getValue ( n ) + \" \" ) ;"}
{"text":"Function that traverses digits in a number and modifies frequency count array","code":"function countDigits ( val , arr ) { while ( val > 0 ) { let digit = val % 10 ; arr [ digit ] ++ ; val = Math . floor ( val \/ 10 ) ; } return ; } function countFrequency ( x , n ) {"}
{"text":"Array to keep count of digits","code":"let freq_count = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { freq_count [ i ] = 0 ; }"}
{"text":"Traversing through x ^ 1 to x ^ n","code":"for ( let i = 1 ; i <= n ; i ++ ) {"}
{"text":"For power function , both its parameters are to be in double","code":"let val = Math . pow ( x , i ) ;"}
{"text":"calling countDigits function on x ^ i","code":"countDigits ( val , freq_count ) ; }"}
{"text":"Printing count of digits 0 - 9","code":"for ( let i = 0 ; i <= 9 ; i ++ ) { document . write ( freq_count [ i ] + \" \" ) ; } }"}
{"text":"Driver code","code":"let x = 15 , n = 3 ; countFrequency ( x , n ) ;"}
{"text":"function to return the number of solutions","code":"function countSolutions ( a ) { let count = 0 ;"}
{"text":"check for every possible value","code":"for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }"}
{"text":"Driver Code","code":"let a = 3 ; document . write ( countSolutions ( a ) ) ;"}
{"text":"Javascript program to find the number of values of b such that a = b + ( a ^ b )","code":"function bitCount ( n ) { let count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; }"}
{"text":"Function to return the number of solutions","code":"function countSolutions ( a ) { let count = bitCount ( a ) ; count = Math . pow ( 2 , count ) ; return count ; }"}
{"text":"Driver Code","code":"let a = 3 ; document . write ( countSolutions ( a ) ) ;"}
{"text":"Function to calculate the sum of area of all possible squares that comes inside the rectangle","code":"function calculateAreaSum ( l , b ) { var size = 1 ;"}
{"text":"Square with max size possible","code":"var maxSize = Math . min ( l , b ) ; var totalArea = 0 ; for ( var i = 1 ; i <= maxSize ; i ++ ) {"}
{"text":"calculate total square of a given size","code":"var totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ;"}
{"text":"calculate area of squares of a particular size","code":"var area = totalSquares * size * size ;"}
{"text":"total area","code":"totalArea += area ;"}
{"text":"increment size","code":"size ++ ; } return totalArea ; }"}
{"text":"Driver Code","code":"var l = 4 , b = 3 ; document . write ( calculateAreaSum ( l , b ) ) ;"}
{"text":"function to calculate the value of hyperfactorial","code":"function boost_hyperfactorial ( num ) {"}
{"text":"initialise the val to 1","code":"let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { val = val * Math . pow ( i , i ) ; }"}
{"text":"returns the hyperfactorial of a number","code":"return val ; }"}
{"text":"Driver code","code":"let num = 5 ; document . write ( boost_hyperfactorial ( num ) ) ;"}
{"text":"function to calculate the value of hyperfactorial","code":"function boost_hyperfactorial ( num ) {"}
{"text":"initialise the val to 1","code":"var val = 1 ; for ( var i = 1 ; i <= num ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) {"}
{"text":"1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . .","code":"val *= i ; } }"}
{"text":"returns the hyperfactorial of a number","code":"return val ; }"}
{"text":"Driver code","code":"var num = 5 ; document . write ( boost_hyperfactorial ( num ) ) ;"}
{"text":"JavaScript code to subtract one from a given number","code":"function subtractOne ( x ) { let m = 1 ;"}
{"text":"Flip all the set bits until we find a 1","code":"while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; }"}
{"text":"flip the rightmost 1 bit","code":"x = x ^ m ; return x ; }"}
{"text":"Driver program to test above functions","code":"document . write ( subtractOne ( 13 ) ) ;"}
{"text":"Javascript program to find mean vector of given matrix","code":"var rows = 3 ; var cols = 3 ;"}
{"text":"Function to find mean vector","code":"function meanVector ( mat ) { document . write ( \" \" ) ;"}
{"text":"Loop to traverse each column","code":"for ( var i = 0 ; i < rows ; i ++ ) {"}
{"text":"To calculate mean of each row","code":"var mean = 0.00 ;"}
{"text":"to store sum of elements of a column","code":"var sum = 0 ; for ( var j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum \/ rows ; document . write ( mean + \" \" ) ; } document . write ( \" \" ) ; }"}
{"text":"Driver code","code":"var mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; meanVector ( mat ) ;"}
{"text":"Function to find distinct prime factors of given number n","code":"function primeFactors ( n ) { var res = [ ] ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = parseInt ( n \/ 2 ) ; res . push ( 2 ) ; }"}
{"text":"n is odd at this point , since it is no longer divisible by 2. So we can test only for the odd numbers , whether they are factors of n","code":"for ( var i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) {"}
{"text":"Check if i is prime factor","code":"if ( n % i == 0 ) { while ( n % i == 0 ) n = parseInt ( n \/ i ) ; res . push ( i ) ; } }"}
{"text":"This condition is to handle the case when n is a prime number greater than 2","code":"if ( n > 2 ) res . push ( n ) ; return res ; }"}
{"text":"Function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained","code":"function isHoax ( n ) {"}
{"text":"Distinct prime factors of n are being stored in vector pf","code":"var pf = primeFactors ( n ) ;"}
{"text":"If n is a prime number , it cannot be a hoax number","code":"if ( pf [ 0 ] == n ) return false ;"}
{"text":"Finding sum of digits of distinct prime factors of the number n","code":"var all_pf_sum = 0 ; for ( var i = 0 ; i < pf . length ; i ++ ) {"}
{"text":"Finding sum of digits in current prime factor pf [ i ] .","code":"var pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] = parseInt ( pf [ i ] \/ 10 ) ) ; all_pf_sum += pf_sum ; }"}
{"text":"Finding sum of digits of number n","code":"var sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n = parseInt ( n \/ 10 ) ) ;"}
{"text":"Comparing the two calculated sums","code":"return sum_n == all_pf_sum ; }"}
{"text":"Driver Method","code":"var n = 84 ; if ( isHoax ( n ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to find out first n terms ( considering 4 as 0 th term ) of Lucas - Lehmer series .","code":"function LucasLehmer ( n ) {"}
{"text":"the 0 th term of the series is 4.","code":"let current_val = 4 ;"}
{"text":"create an array to store the terms .","code":"let series = [ ] ;"}
{"text":"compute each term and add it to the array .","code":"series . push ( current_val ) ; for ( let i = 0 ; i < n ; i ++ ) { current_val = ( current_val * current_val ) - 2 ; series . push ( current_val ) ; }"}
{"text":"print out the terms one by one .","code":"for ( let i = 0 ; i <= n ; i ++ ) { document . write ( \" \" + i + \" \" + series [ i ] + \" \" ) ; } }"}
{"text":"Driver Code","code":"let n = 5 ; LucasLehmer ( n ) ;"}
{"text":"A naive method to find modular multiplicative inverse of ' a ' under modulo ' prime '","code":"function modInverse ( a , prime ) { a = a % prime ; for ( let x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; } function printModIverses ( n , prime ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( modInverse ( i , prime ) + \" \" ) ; }"}
{"text":"Driver code","code":"let n = 10 ; let prime = 17 ; printModIverses ( n , prime ) ;"}
{"text":"function for minimum operation","code":"function minOp ( num ) {"}
{"text":"remainder and operations count","code":"var rem ; var count = 0 ;"}
{"text":"count digits not equal to 3 or 8","code":"while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = parseInt ( num \/ 10 ) ; } return count ; }"}
{"text":"driver function","code":"var num = 234198 ; document . write ( \" \" + minOp ( num ) ) ;"}
{"text":"Function to calculate the sum of digits of a number .","code":"function sumOfDigits ( a ) { var sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a = parseInt ( a \/ 10 ) ; } return sum ; }"}
{"text":"Returns the maximum number with maximum sum of digits .","code":"function findMax ( x ) {"}
{"text":"Initializing b as 1 and initial max sum to be of n","code":"var b = 1 , ans = x ;"}
{"text":"Iterates from right to left in a digit","code":"while ( x != 0 ) {"}
{"text":"While iterating this is the number from from right to left","code":"var cur = ( x - 1 ) * b + ( b - 1 ) ;"}
{"text":"Calls the function to check if sum of cur is more then of ans","code":"if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ;"}
{"text":"Reduces the number to one unit less","code":"x = parseInt ( x \/ 10 ) ; b *= 10 ; } return ans ; }"}
{"text":"Driver Code","code":"var n = 521 ; document . write ( findMax ( n ) ) ;"}
{"text":"Function to give index of the median","code":"function median ( a , l , r ) { var n = r - l + 1 ; n = parseInt ( ( n + 1 ) \/ 2 ) - 1 ; return parseInt ( n + l ) ; }"}
{"text":"Function to calculate IQR","code":"function IQR ( a , n ) { a . sort ( ( a , b ) => a - b ) ;"}
{"text":"Index of median of entire data","code":"var mid_index = median ( a , 0 , n ) ;"}
{"text":"Median of first half","code":"var Q1 = a [ median ( a , 0 , mid_index ) ] ;"}
{"text":"Median of second half","code":"var Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ;"}
{"text":"IQR calculation","code":"return ( Q3 - Q1 ) ; }"}
{"text":"Driver Code","code":"var a = [ 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 ] ; var n = a . length ; document . write ( IQR ( a , n ) ) ;"}
{"text":"function for sorting","code":"function ssort ( a , n ) { var i , j , min , temp ; for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( a [ j ] < a [ min ] ) min = j ; temp = a [ i ] ; a [ i ] = a [ min ] ; a [ min ] = temp ; } }"}
{"text":"Function to check if n is palindrome","code":"function isPalindrome ( n ) {"}
{"text":"Find the appropriate divisor to extract the leading digit","code":"var divisor = 1 ; while ( parseInt ( n \/ divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n \/ divisor ) ; var trailing = n % 10 ;"}
{"text":"If first and last digits are not same then return false","code":"if ( leading != trailing ) return false ;"}
{"text":"Removing the leading and trailing digits from the number","code":"n = parseInt ( ( n % divisor ) \/ 10 ) ;"}
{"text":"Reducing divisor by a factor of 2 as 2 digits are dropped","code":"divisor = parseInt ( divisor \/ 100 ) ; } return true ; }"}
{"text":"Function to find the largest palindromic number","code":"function largestPalindrome ( A , n ) {"}
{"text":"Sort the array","code":"ssort ( A , A . length ) ; for ( var i = n - 1 ; i >= 0 ; -- i ) {"}
{"text":"If number is palindrome","code":"if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; }"}
{"text":"If no palindromic number found","code":"return - 1 ; } var A = [ 1 , 232 , 54545 , 999991 ] ; var n = A . length ;"}
{"text":"print required answer","code":"document . write ( largestPalindrome ( A , n ) ) ;"}
{"text":"Function to return the sum of all the integers below N which are multiples of either A or B","code":"function findSum ( n , a , b ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ )"}
{"text":"If i is a multiple of a or b","code":"if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }"}
{"text":"Driver code","code":"let n = 10 ; let a = 3 ; let b = 5 ; document . write ( findSum ( n , a , b ) ) ;"}
{"text":"Driver program to test above functions","code":"function subtractOne ( x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } document . write ( ( subtractOne ( 13 ) ) ) ;"}
{"text":"calculate nth pell number","code":"function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }"}
{"text":"Driver Code","code":"let n = 4 ; document . write ( pell ( n ) ) ;"}
{"text":"Returns LCM of arr [ 0. . n - 1 ]","code":"function LCM ( arr , n ) {"}
{"text":"Find the maximum value in arr [ ]","code":"var max_num = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ;"}
{"text":"Initialize result","code":"var res = 1 ;"}
{"text":"Find all factors that are present in two or more array elements . var x = 2 ; Current factor .","code":"while ( x <= max_num ) {"}
{"text":"To store indexes of all array elements that are divisible by x .","code":"var indexes = [ ] ; for ( var j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push ( j ) ;"}
{"text":"If there are 2 or more array elements that are divisible by x .","code":"if ( indexes . length >= 2 ) {"}
{"text":"Reduce all array elements divisible by x .","code":"for ( var j = 0 ; j < indexes . length ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] \/ x ; res = res * x ; } else x ++ ; }"}
{"text":"Then multiply all reduced array elements","code":"for ( var i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ] ; var n = arr . length ; document . write ( LCM ( arr , n ) + \" \" ) ;"}
{"text":"Function to find politeness","code":"function politness ( n ) { let count = 0 ;"}
{"text":"sqrt ( 2 * n ) as max length will be when the sum starts from 1 which follows the equation n ^ 2 - n - ( 2 * sum ) = 0","code":"for ( let i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { let a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a = Math . floor ( a \/ i ) ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a = Math . floor ( a \/ 2 ) ; if ( a > 0 ) { count ++ ; } } return count ; }"}
{"text":"Driver Code","code":"let n = 90 ; document . write ( \" \" + n + \" \" + politness ( n ) + \" \" ) ; n = 15 ; document . write ( \" \" + n + \" \" + politness ( n ) ) ;"}
{"text":"Javascript program to implement Goldbach 's conjecture","code":"let MAX = 10000 ;"}
{"text":"Array to store all prime less than and equal to 10 ^ 6","code":"let primes = new Array ( ) ;"}
{"text":"Utility function for Sieve of Sundaram","code":"function sieveSundaram ( ) {"}
{"text":"In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half . This array is used to separate numbers of the form i + j + 2 * i * j from others where 1 <= i <= j","code":"let marked = new Array ( parseInt ( MAX \/ 2 ) + 100 ) . fill ( false ) ;"}
{"text":"Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1","code":"for ( let i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) \/ 2 ; i ++ ) for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= MAX \/ 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ;"}
{"text":"Since 2 is a prime number","code":"primes . push ( 2 ) ;"}
{"text":"Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false .","code":"for ( let i = 1 ; i <= MAX \/ 2 ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; }"}
{"text":"Function to perform Goldbach 's conjecture","code":"function findPrimes ( n ) {"}
{"text":"Return if number is not even or less than 3","code":"if ( n <= 2 n % 2 != 0 ) { document . write ( \" \" ) ; return ; }"}
{"text":"Check only upto half of number","code":"for ( let i = 0 ; primes [ i ] <= n \/ 2 ; i ++ ) {"}
{"text":"find difference by subtracting current prime from n","code":"let diff = n - primes [ i ] ;"}
{"text":"Search if the difference is also a prime number","code":"if ( primes . includes ( diff ) ) {"}
{"text":"Express as a sum of primes","code":"document . write ( primes [ i ] + \" \" + diff + \" \" + n + \" \" ) ; return ; } } }"}
{"text":"Finding all prime numbers before limit","code":"sieveSundaram ( ) ;"}
{"text":"Express number as a sum of two primes","code":"findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ;"}
{"text":"A function to generate prime factors of a given number n and return k - th prime factor","code":"function kPrimeFactor ( n , k ) {"}
{"text":"Find the number of 2 's that  divide k","code":"while ( n % 2 == 0 ) { k -- ; n = n \/ 2 ; if ( k == 0 ) return 2 ; }"}
{"text":"n must be odd at this point . So we can skip one element ( Note i = i + 2 )","code":"for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) {"}
{"text":"While i divides n , store i and divide n","code":"while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n \/ i ; } }"}
{"text":"This condition is to handle the case where n is a prime number greater than 2","code":"if ( n > 2 && k == 1 ) return n ; return - 1 ; }"}
{"text":"Driver code","code":"let n = 12 , k = 3 ; document . write ( kPrimeFactor ( n , k ) + \" \" ) ; n = 14 ; k = 3 ; document . write ( kPrimeFactor ( n , k ) ) ;"}
{"text":"Javascript program to find k - th prime factor using Sieve Of Eratosthenes . This program is efficient when we have a range of numbers .","code":"var MAX = 10001 ;"}
{"text":"Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if MAX is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7","code":"function sieveOfEratosthenes ( s ) {"}
{"text":"Create a boolean array \" prime [ 0 . . MAX ] \" and initialize all entries in it as false .","code":"prime = Array . from ( { length : MAX + 1 } , ( _ , i ) => false ) ;"}
{"text":"Initializing smallest factor equal to 2 for all the even numbers","code":"for ( i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ;"}
{"text":"For odd numbers less then equal to n","code":"for ( i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) {"}
{"text":"s ( i ) for a prime is the number itself","code":"s [ i ] = i ;"}
{"text":"For all multiples of current prime number","code":"for ( j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ;"}
{"text":"i is the smallest prime factor for number \" i * j \" .","code":"s [ i * j ] = i ; } } } } }"}
{"text":"Function to generate prime factors and return its k - th prime factor . s [ i ] stores least prime factor of i .","code":"function kPrimeFactor ( n , k , s ) {"}
{"text":"Keep dividing n by least prime factor while either n is not 1 or count of prime factors is not k .","code":"while ( n > 1 ) { if ( k == 1 ) return s [ n ] ;"}
{"text":"To keep track of count of prime factors","code":"k -- ;"}
{"text":"Divide n to find next prime factor","code":"n \/= s [ n ] ; } return - 1 ; }"}
{"text":"s [ i ] is going to store prime factor of i .","code":"var s = Array . from ( { length : MAX + 1 } , ( _ , i ) => 0 ) ; sieveOfEratosthenes ( s ) ; var n = 12 , k = 3 ; document . write ( kPrimeFactor ( n , k , s ) + \" \" ) ; n = 14 ; k = 3 ; document . write ( kPrimeFactor ( n , k , s ) ) ;"}
{"text":"Returns sum of divisors of all the divisors of n","code":"function sumDivisorsOfDivisors ( n ) {"}
{"text":"Calculating powers of prime factors and storing them in a map mp [ ] .","code":"let mp = new Map ( ) ; for ( let j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { let count = 0 ; while ( n % j == 0 ) { n = Math . floor ( n \/ j ) ; count ++ ; } if ( count != 0 ) mp . set ( j , count ) ; }"}
{"text":"If n is a prime number","code":"if ( n != 1 ) mp . set ( n , 1 ) ;"}
{"text":"For each prime factor , calculating ( p ^ ( a + 1 ) - 1 ) \/ ( p - 1 ) and adding it to answer .","code":"let ans = 1 ; for ( let [ key , value ] of mp . entries ( ) ) { let pw = 1 ; let sum = 0 ; for ( let i = value + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = key ; } ans *= sum ; } return ans ; }"}
{"text":"Driver code","code":"let n = 10 ; document . write ( sumDivisorsOfDivisors ( n ) ) ;"}
{"text":"Function to return nearest prime number","code":"function prime ( n ) {"}
{"text":"All prime numbers are odd except two","code":"if ( n & 1 ) n -= 2 ; else n -- ; let i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > Math . sqrt ( i ) ) return i ; }"}
{"text":"It will only be executed when n is 3","code":"return 2 ; }"}
{"text":"Driver Code","code":"let n = 17 ; document . write ( prime ( n ) ) ;"}
{"text":"This function returns repeating sequence of a fraction . If repeating sequence doesn 't  exits, then returns empty String","code":"function fractionToDecimal ( numr , denr ) {"}
{"text":"Initialize result","code":"let res = \" \" ;"}
{"text":"Create a map to store already seen remainders . Remainder is used as key and its position in result is stored as value . Note that we need position for cases like 1 \/ 6. In this case , the recurring sequence doesn 't  start from first remainder.","code":"let mp = new Map ( ) ; mp . clear ( ) ;"}
{"text":"Find first remainder","code":"let rem = numr % denr ;"}
{"text":"Keep finding remainder until either remainder becomes 0 or repeats","code":"while ( ( rem != 0 ) && ( ! mp . has ( rem ) ) ) {"}
{"text":"Store this remainder","code":"mp . set ( rem , res . length ) ;"}
{"text":"Multiply remainder with 10","code":"rem = rem * 10 ;"}
{"text":"Append rem \/ denr to result","code":"let res_part = Math . floor ( rem \/ denr ) ; res += res_part . toString ( ) ;"}
{"text":"Update remainder","code":"rem = rem % denr ; } if ( rem == 0 ) return \" \" ; else if ( mp . has ( rem ) ) return res . substr ( mp . get ( rem ) ) ; return \" \" ; }"}
{"text":"Driver program","code":"let numr = 50 , denr = 22 ; let res = fractionToDecimal ( numr , denr ) ; if ( res == \" \" ) document . write ( \" \" ) ; else document . write ( \" \" + res ) ;"}
{"text":"Returns 1 if x has 0 , else 0","code":"function has0 ( x ) {"}
{"text":"Traverse through all digits of x to check if it has 0.","code":"while ( x ) {"}
{"text":"If current digit is 0 , return true","code":"if ( x % 10 == 0 ) return 1 ; x = Math . floor ( x \/ 10 ) ; } return 0 ; }"}
{"text":"Returns count of numbers from 1 to n with 0 as digit","code":"function getCount ( n ) {"}
{"text":"Initialize count of numbers having 0 as digit","code":"let count = 0 ;"}
{"text":"Traverse through all numbers and for every number check if it has 0.","code":"for ( let i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; }"}
{"text":"Driver program","code":"let n = 107 ; document . write ( \" \" + \" \" + n + \" \" + getCount ( n ) ) ;"}
{"text":"Returns true if square root of n under modulo p exists","code":"function squareRootExists ( n , p ) { n = n % p ;"}
{"text":"One by one check all numbers from 2 to p - 1","code":"for ( let x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }"}
{"text":"Driver Code","code":"let p = 7 ; let n = 2 ; if ( squareRootExists ( n , p ) === true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Returns largest power of p that divides n !","code":"function largestPower ( n , p ) {"}
{"text":"Initialize result","code":"let x = 0 ;"}
{"text":"Calculate x = n \/ p + n \/ ( p ^ 2 ) + n \/ ( p ^ 3 ) + ... .","code":"while ( n ) { n = parseInt ( n \/ p ) ; x += n ; } return Math . floor ( x ) ; }"}
{"text":"Driver Code","code":"let n = 10 ; let p = 3 ; document . write ( \" \" + p ) ; document . write ( \" \" + n + \" \" ) ; document . write ( largestPower ( n , p ) ) ;"}
{"text":"JavaScript program to find factorial of given number","code":"function factorial ( n ) {"}
{"text":"single line to find factorial","code":"return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }"}
{"text":"Driver Code","code":"var num = 5 ; document . write ( \" \" + num + \" \" + factorial ( num ) ) ;"}
{"text":"Function to get the bit at the ith position","code":"function getBit ( num , i ) {"}
{"text":"Return true if the bit is set . Otherwise return false","code":"return ( ( num & ( 1 << i ) ) != 0 ) ; }"}
{"text":"Function to clear the ith bit of the given number N","code":"function clearBit ( num , i ) {"}
{"text":"Create the mask for the ith bit unset","code":"let mask = ~ ( 1 << i ) ;"}
{"text":"Return the update value","code":"return num & mask ; }"}
{"text":"Function to compute the AND sum for each element of an array","code":"function Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) {"}
{"text":"Declaring an array of size 32 for storing the count of each bit","code":"let frequency = new Array ( 32 ) . fill ( 0 ) ;"}
{"text":"Traverse the array arr2 [ ] and store the count of a bit in frequency array","code":"for ( let i = 0 ; i < N ; i ++ ) {"}
{"text":"Current bit position","code":"let bit_position = 0 ; let num = arr1 [ i ] ;"}
{"text":"While num is greater than 0","code":"while ( num ) {"}
{"text":"Checks if ith bit is set or not","code":"if ( num & 1 ) {"}
{"text":"Increment the count of bit by one","code":"frequency [ bit_position ] += 1 ; }"}
{"text":"Increment the bit position by one","code":"bit_position += 1 ;"}
{"text":"Right shift the num by one","code":"num >>= 1 ; } }"}
{"text":"Traverse in the arr2 [ ]","code":"for ( let i = 0 ; i < M ; i ++ ) { let num = arr2 [ i ] ;"}
{"text":"Store the ith bit value","code":"let value_at_that_bit = 1 ;"}
{"text":"Total required sum","code":"let bitwise_AND_sum = 0 ;"}
{"text":"Traverse in the range [ 0 , 31 ]","code":"for ( let bit_position = 0 ; bit_position < 32 ; bit_position ++ ) {"}
{"text":"Checks if current bit is set","code":"if ( num & 1 ) {"}
{"text":"Increment the bitwise sum by frequency [ bit_position ] * value_at_that_bit ;","code":"bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; }"}
{"text":"Right shift num by one","code":"num >>= 1 ;"}
{"text":"Left shift vale_at_that_bit by one","code":"value_at_that_bit <<= 1 ; }"}
{"text":"Print the sum obtained for ith number in arr1 [ ]","code":"document . write ( bitwise_AND_sum + ' ' ) ; } return ; }"}
{"text":"Given arr1 [ ]","code":"let arr1 = [ 1 , 2 , 3 ] ;"}
{"text":"Given arr2 [ ]","code":"let arr2 = [ 1 , 2 , 3 ] ;"}
{"text":"Size of arr1 [ ]","code":"let N = arr1 . length ;"}
{"text":"Size of arr2 [ ]","code":"let M = arr2 . length"}
{"text":"Function Call","code":"Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ;"}
{"text":"Unsets the rightmost set bit of n and returns the result","code":"function FlipBits ( n ) { for ( let bit = 0 ; bit < 32 ; bit ++ ) {"}
{"text":"Checking whether bit position is set or not","code":"if ( ( ( n >> bit ) & 1 ) > 0 ) {"}
{"text":"If bit position is found set , we flip this bit by xoring given number and number with bit position set","code":"n = n ^ ( 1 << bit ) ; break ; } } document . write ( \" \" ) ; document . write ( \" \" + n ) ; }"}
{"text":"Driver code","code":"let N = 12 ; FlipBits ( N ) ;"}
{"text":"Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]","code":"function bitwiseAndOdd ( n ) {"}
{"text":"Initialize result to 1","code":"var result = 1 ;"}
{"text":"Starting from 3 , bitwise AND all the odd integers less than or equal to n","code":"for ( var i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }"}
{"text":"Driver code","code":"var n = 10 ; document . write ( bitwiseAndOdd ( n ) ) ;"}
{"text":"Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]","code":"function bitwiseAndOdd ( n ) { return 1 ; }"}
{"text":"Driver code","code":"var n = 10 ; document . write ( bitwiseAndOdd ( n ) ) ;"}
{"text":"function to reverse bits of a number","code":"function reverseBits ( n ) { let rev = 0 ;"}
{"text":"traversing bits of ' n ' from the right","code":"while ( n > 0 ) {"}
{"text":"bitwise left shift ' rev ' by 1","code":"rev <<= 1 ;"}
{"text":"if current bit is '1'","code":"if ( ( n & 1 ) == 1 ) rev ^= 1 ;"}
{"text":"bitwise right shift ' n ' by 1","code":"n >>= 1 ; }"}
{"text":"required number","code":"return rev ; }"}
{"text":"Driver code","code":"let n = 11 ; document . write ( reverseBits ( n ) ) ;"}
{"text":"Return the count number of ways to split array into two groups such that each group has equal XOR value .","code":"function countgroup ( a , n ) { var xs = 0 ; for ( var i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ;"}
{"text":"We can split only if XOR is 0. Since XOR of all is 0 , we can consider all subsets as one group .","code":"if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; }"}
{"text":"Driver Program","code":"var a = [ 1 , 2 , 3 ] ; var n = a . length ; document . write ( countgroup ( a , n ) + \" \" ) ;"}
{"text":"Function to extract k bits from p position and returns the extracted value as integer","code":"function bitExtracted ( number , k , p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }"}
{"text":"Driver code","code":"let number = 171 , k = 5 , p = 2 ; document . write ( \" \" , bitExtracted ( number , k , p ) ) ;"}
{"text":"JavaScript program to find maximum number by swapping extreme bits .","code":"function findMax ( num ) { let num_copy = num ;"}
{"text":"Traverse bits from both extremes","code":"let j = 4 * 8 - 1 ; let i = 0 ; while ( i < j ) {"}
{"text":"Obtaining i - th and j - th bits","code":"let m = ( num_copy >> i ) & 1 ; let n = ( num_copy >> j ) & 1 ;"}
{"text":"Swapping the bits if lesser significant is greater than higher significant bit and accordingly modifying the number","code":"if ( m > n ) { let x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }"}
{"text":"Driver code","code":"let num = 4 ; document . write ( findMax ( num ) ) ;"}
{"text":"method to check whether ' n ' is a multiple of 4 or not","code":"function isAMultipleOf4 ( n ) {"}
{"text":"if true , then ' n ' is a multiple of 4","code":"if ( ( n & 3 ) == 0 ) return true ;"}
{"text":"else ' n ' is not a multiple of 4","code":"return false ; }"}
{"text":"Driver method","code":"let n = 16 ; document . write ( isAMultipleOf4 ( n ) ? \" \" : \" \" ) ;"}
{"text":"Simple solution to calculate square without using * and pow ( )","code":"function square ( n ) {"}
{"text":"handle negative input","code":"if ( n < 0 ) n = - n ;"}
{"text":"Initialize result","code":"let res = n ;"}
{"text":"Add n to res n - 1 times","code":"for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; }"}
{"text":"Driver code","code":"for ( let n = 1 ; n <= 5 ; n ++ ) document . write ( \" \" + n + \" \" + square ( n ) + \" \" ) ;"}
{"text":"Javascript implementation of the approach","code":"function PointInKSquares ( n , a , k ) { a . sort ( ) ; return a [ n - k ] ; }"}
{"text":"Driver Program to test above function","code":"let k = 2 ; let a = [ 1 , 2 , 3 , 4 ] ; let n = a . length ; let x = PointInKSquares ( n , a , k ) ; document . write ( \" \" + x + \" \" + x + \" \" ) ;"}
{"text":"function that calculates the answer","code":"function answer ( n ) {"}
{"text":"dp [ j ] stores count of i digit stepping numbers ending with digit j .","code":"var dp = Array ( 10 ) ;"}
{"text":"To store result of length i - 1 before updating dp [ j ] for length i .","code":"var prev = Array ( 10 ) ;"}
{"text":"if n is 1 then answer will be 10.","code":"if ( n == 1 ) return 10 ;"}
{"text":"Initialize values for count of digits equal to 1.","code":"for ( var j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ;"}
{"text":"Compute values for count of digits more than 1.","code":"for ( var i = 2 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( var j = 0 ; j <= 9 ; j ++ ) {"}
{"text":"If ending digit is 0","code":"if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ;"}
{"text":"If ending digit is 9","code":"else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ;"}
{"text":"For other digits .","code":"else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } }"}
{"text":"stores the final answer","code":"var sum = 0 ; for ( var j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; }"}
{"text":"driver program to test the above function","code":"var n = 2 ; document . write ( answer ( n ) ) ;"}
{"text":"Javascript implementation of the approach","code":"var MAX = 100000"}
{"text":"To store first N Catalan numbers","code":"var catalan = Array ( MAX ) ;"}
{"text":"Function to find first n Catalan numbers","code":"function catalanDP ( n ) {"}
{"text":"Initialize first two values in table","code":"catalan [ 0 ] = catalan [ 1 ] = 1 ;"}
{"text":"Fill entries in catalan [ ] using recursive formula","code":"for ( var i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( var j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } }"}
{"text":"Function to return the minimum changes required","code":"function CatalanSequence ( arr , n ) {"}
{"text":"Find first n Catalan Numbers","code":"catalanDP ( n ) ; var s = [ ] ;"}
{"text":"a and b are first two Catalan Sequence numbers","code":"var a = 1 , b = 1 ; var c ;"}
{"text":"push first n catalan elements to set","code":"s . push ( a ) ; if ( n >= 2 ) s . push ( b ) ; for ( var i = 2 ; i < n ; i ++ ) { s . push ( catalan [ i ] ) ; } s . sort ( ( a , b ) => b - a ) ; for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"If catalan element is present in the array then remove it from set","code":"if ( s . includes ( arr [ i ] ) ) { s . pop ( arr [ i ] ) ; } }"}
{"text":"Return the remaining number of elements in the set","code":"return s . length ; }"}
{"text":"Driver code","code":"var arr = [ 1 , 1 , 2 , 5 , 41 ] ; var n = arr . length ; document . write ( CatalanSequence ( arr , n ) ) ;"}
{"text":"Function to check for composite numbers","code":"function composite ( n ) { let flag = 0 ; let c = 0 ;"}
{"text":"Check if the factors are greater than 2","code":"for ( let j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } }"}
{"text":"Check if the number is composite or not","code":"if ( c >= 3 ) flag = 1 ; return flag ; }"}
{"text":"Function to print the sum of all composite numbers in the array","code":"function odd_indices ( arr , n ) { let sum = 0 ;"}
{"text":"Iterate for odd indices in the array","code":"for ( let k = 0 ; k < n ; k += 2 ) { let check = composite ( arr [ k ] ) ;"}
{"text":"Check if the number is composite then add it to sum","code":"if ( check == 1 ) sum += arr [ k ] ; }"}
{"text":"return the sum","code":"document . write ( sum + \" \" ) ; }"}
{"text":"Driver code","code":"let arr = [ 13 , 5 , 8 , 16 , 25 ] ; let n = arr . length odd_indices ( arr , n ) ;"}
{"text":"Computing the x ^ 2 + y ^ 2 for each given points and sorting them .","code":"function preprocess ( p , x , y , n ) { for ( let i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; p . sort ( function ( a , b ) { return a - b ; } ) ; }"}
{"text":"Return count of points lie inside or on circumference of circle using binary search on p [ 0. . n - 1 ]","code":"function query ( p , n , rad ) { let start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { let mid = Math . floor ( ( start + end ) \/ 2 ) ; let tp = Math . sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } let tp1 = Math . sqrt ( p [ start ] ) ; let tp2 = Math . sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; }"}
{"text":"Driver program to test above function","code":"let x = [ 1 , 2 , 3 , - 1 , 4 ] ; let y = [ 1 , 2 , 3 , - 1 , 4 ] ; let n = x . length ;"}
{"text":"Compute distances of all points and keep the distances sorted so that query can work in O ( logn ) using Binary Search .","code":"let p = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { p [ i ] = 0 ; } preprocess ( p , x , y , n ) ;"}
{"text":"Print number of points in a circle of radius 3.","code":"document . write ( query ( p , n , 3 ) + \" \" ) ;"}
{"text":"Print number of points in a circle of radius 32.","code":"document . write ( query ( p , n , 32 ) + \" \" ) ;"}
{"text":"function to find total number of ways","code":"function find_Numb_ways ( n ) {"}
{"text":"No of odd indices in n - digit number","code":"var odd_indices = n \/ 2 ;"}
{"text":"No of even indices in n - digit number","code":"var even_indices = ( n \/ 2 ) + ( n % 2 ) ;"}
{"text":"No of ways of arranging prime number digits in odd indices","code":"var arr_odd = Math . pow ( 4 , odd_indices ) ;"}
{"text":"No of ways of arranging odd number digits in even indices","code":"var arr_even = Math . pow ( 5 , even_indices ) ;"}
{"text":"returning the total number of ways","code":"return arr_odd * arr_even ; }"}
{"text":"drive code","code":"var n = 4 ; document . write ( find_Numb_ways ( n ) ) ;"}
{"text":"Function to check if the array is spirally sorted or not","code":"function isSpiralSorted ( arr , n ) {"}
{"text":"Stores start index of the array","code":"let start = 0 ;"}
{"text":"Stores end index of an array","code":"let end = n - 1 ; while ( start < end ) {"}
{"text":"If arr [ start ] greater than arr [ end ]","code":"if ( arr [ start ] > arr [ end ] ) { return false ; }"}
{"text":"Update start","code":"start ++ ;"}
{"text":"If arr [ end ] greater than arr [ start ]","code":"if ( arr [ end ] > arr [ start ] ) { return false ; }"}
{"text":"Update end","code":"end -- ; } return true ; }"}
{"text":"Driver code","code":"let arr = [ 1 , 10 , 14 , 20 , 18 , 12 , 5 ] ; let N = arr . length ;"}
{"text":"Function Call","code":"if ( isSpiralSorted ( arr , N ) ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"Function to print all strings that can be typed using keys of a single row in a QWERTY Keyboard","code":"function findWordsSameRow ( arr ) {"}
{"text":"Stores row number of all possible character of the strings","code":"var mp = { } ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 1 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 2 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ; mp [ \" \" ] = 3 ;"}
{"text":"Traverse the array","code":"for ( const word of arr ) {"}
{"text":"If current string is not an empty string","code":"if ( word . length !== 0 ) {"}
{"text":"Sets true \/ false if a string can be typed using keys of a single row or not","code":"var flag = true ;"}
{"text":"Stores row number of the first character of current string","code":"var rowNum = mp [ word [ 0 ] . toLowerCase ( ) ] ;"}
{"text":"Stores length of word","code":"var M = word . length ;"}
{"text":"Traverse current string","code":"for ( var i = 1 ; i < M ; i ++ ) {"}
{"text":"If current character can 't be  typed using keys of rowNum only","code":"if ( mp [ word [ i ] . toLowerCase ( ) ] !== rowNum ) {"}
{"text":"Update flag","code":"flag = false ; break ; } }"}
{"text":"If current string can be typed using keys from rowNum only","code":"if ( flag ) {"}
{"text":"Print the string","code":"document . write ( word + \" \" ) ; } } } }"}
{"text":"Driver Code","code":"var words = [ \" \" , \" \" , \" \" , \" \" ] ; findWordsSameRow ( words ) ;"}
{"text":"Function to find the count of the subsequence of given type","code":"function countSubsequece ( a , n ) { let i , j , k , l ;"}
{"text":"Stores the count of quadruples","code":"let answer = 0 ;"}
{"text":"Generate all possible combinations of quadruples","code":"for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) {"}
{"text":"Check if 1 st element is equal to 3 rd element","code":"if ( a [ j ] == a [ l ] &&"}
{"text":"Check if 2 nd element is equal to 4 th element","code":"a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }"}
{"text":"Driver Code","code":"let a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] ; document . write ( countSubsequece ( a , 7 ) ) ;"}
{"text":"Function to find the let acter repeats with minimum distance","code":"function minDistChar ( s ) { let n = s . length ;"}
{"text":"Stores the first and last index","code":"let first = new Array ( 26 ) ; let last = new Array ( 26 ) ;"}
{"text":"Initialize with - 1","code":"for ( let i = 0 ; i < 26 ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; }"}
{"text":"Get the values of last and first occurence","code":"for ( let i = 0 ; i < n ; i ++ ) {"}
{"text":"Update the first index","code":"if ( first [ s [ i ] - ' ' ] == - 1 ) { first [ s [ i ] - ' ' ] = i ; }"}
{"text":"Update the last index","code":"last [ s [ i ] - ' ' ] = i ; }"}
{"text":"Initialize min","code":"let min = 100000 ; var ans = ' ' ;"}
{"text":"Get the minimum","code":"for ( let i = 0 ; i < 26 ; i ++ ) {"}
{"text":"Values must not be same","code":"if ( last [ i ] == first [ i ] ) continue ;"}
{"text":"Update the minimum distance","code":"if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = String . fromCharCode ( i + 97 ) ; } }"}
{"text":"return ans","code":"return ans ; }"}
{"text":"Driver Code","code":"str = \" \" ;"}
{"text":"Function call","code":"document . write ( minDistChar ( str ) ) ;"}
{"text":"Javascript implementation of the approach","code":"var n = 3 ;"}
{"text":"Function to return the minimum steps required to reach the end of the matrix","code":"function minSteps ( arr ) {"}
{"text":"Array to determine whether a cell has been visited before","code":"var v = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( 0 ) ) ;"}
{"text":"Queue for bfs","code":"var q = [ ] ;"}
{"text":"Initializing queue","code":"q . push ( [ 0 , 0 ] ) ;"}
{"text":"To store the depth of search","code":"var depth = 0 ;"}
{"text":"BFS algorithm","code":"while ( q . length != 0 ) {"}
{"text":"Current queue size","code":"var x = q . length ; while ( x -- ) {"}
{"text":"Top - most element of queue","code":"var y = q [ 0 ] ;"}
{"text":"To store index of cell for simplicity","code":"var i = y [ 0 ] , j = y [ 1 ] ; q . shift ( ) ;"}
{"text":"Base case","code":"if ( v [ i ] [ j ] ) continue ;"}
{"text":"If we reach ( n - 1 , n - 1 )","code":"if ( i == n - 1 && j == n - 1 ) return depth ;"}
{"text":"Marking the cell visited","code":"v [ i ] [ j ] = 1 ;"}
{"text":"Pushing the adjacent cells in the queue that can be visited from the current cell","code":"if ( i + arr [ i ] [ j ] < n ) q . push ( [ i + arr [ i ] [ j ] , j ] ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( [ i , j + arr [ i ] [ j ] ] ) ; } depth ++ ; } return - 1 ; }"}
{"text":"Driver code","code":"var arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; document . write ( minSteps ( arr ) ) ;"}
{"text":"function to solve the given problem","code":"function solve ( a , n ) { let max1 = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }"}
{"text":"Driver Code","code":"let arr = [ - 1 , 2 , 3 , - 4 , - 10 , 22 ] ; let size = arr . length ; document . write ( \" \" + solve ( arr , size ) ) ;"}
{"text":"function to solve the given problem","code":"function solve ( a , n ) { let min1 = a [ 0 ] ; let max1 = a [ 0 ] ;"}
{"text":"finding maximum and minimum of an array","code":"for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }"}
{"text":"Driver code","code":"let arr = [ - 1 , 2 , 3 , 4 , - 10 ] ; let size = arr . length ; document . write ( \" \" + solve ( arr , size ) ) ;"}
{"text":"Function for replacing the string","code":"function replaceOriginal ( s , n ) {"}
{"text":"initialize a string of length n","code":"var r = new Array ( n ) ;"}
{"text":"Traverse through all characters of string","code":"for ( var i = 0 ; i < n ; i ++ ) {"}
{"text":"assign the value to string r from last index of string s","code":"r [ i ] = s . charAt ( n - 1 - i ) ;"}
{"text":"if s [ i ] is a consonant then print r [ i ]","code":"if ( s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' ) { document . write ( r [ i ] ) ; } } document . write ( \" \" ) ; }"}
{"text":"Driver function","code":"var s = \" \" ; var n = s . length ; replaceOriginal ( s , n ) ;"}
{"text":"Function to find if given Strings are same or not","code":"function sameStrings ( str1 , str2 ) { var N = str1 . length ; var M = str2 . length ;"}
{"text":"Base Condition","code":"if ( N !== M ) { return false ; }"}
{"text":"Stores frequency of characters of the String str1 and str2","code":"var a = new Array ( 256 ) . fill ( 0 ) ; var b = new Array ( 256 ) . fill ( 0 ) ;"}
{"text":"Traverse Strings str1 & str2 and store frequencies in a [ ] and b [ ]","code":"for ( var j = 0 ; j < N ; j ++ ) { a [ str1 [ j ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] ++ ; b [ str2 [ j ] . charCodeAt ( 0 ) - \" \" . charCodeAt ( 0 ) ] ++ ; }"}
{"text":"Check if both Strings have same characters or not","code":"var i = 0 ; while ( i < 256 ) { if ( ( a [ i ] === 0 && b [ i ] === 0 ) || ( a [ i ] !== 0 && b [ i ] !== 0 ) ) { i ++ ; }"}
{"text":"If a character is present in one String and is not in another String , return false","code":"else { return false ; } }"}
{"text":"Sort the array a [ ] and b [ ]","code":"a . sort ( ( x , y ) => x - y ) ; b . sort ( ( x , y ) => x - y ) ;"}
{"text":"Check arrays a and b contain the same frequency or not","code":"for ( var j = 0 ; j < 256 ; j ++ ) {"}
{"text":"If the frequencies are not the same after sorting","code":"if ( a [ j ] !== b [ j ] ) return false ; }"}
{"text":"At this point , str1 can be converted to str2","code":"return true ; }"}
{"text":"Driver Code","code":"var S1 = \" \" , S2 = \" \" ; if ( sameStrings ( S1 , S2 ) ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"Function to find the minimum number operations","code":"function solution ( A , B , C ) { let arr = Array . from ( { length : 3 } , ( _ , i ) => 0 ) ;"}
{"text":"Insert the three numbers in array","code":"arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ;"}
{"text":"Sort the array","code":"arr . sort ( ) ;"}
{"text":"Case 2","code":"if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) \/ 2 ) ;"}
{"text":"Case 1","code":"else return ( arr [ 0 ] + arr [ 1 ] ) ; }"}
{"text":"Given A , B , C","code":"let A = 8 , B = 1 , C = 5 ;"}
{"text":"Function call","code":"document . write ( solution ( A , B , C ) ) ;"}
{"text":"Function to return the index of the key in arr [ l . . h ] if the key is present otherwise return - 1","code":"function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = parseInt ( ( l + h ) \/ 2 , 10 ) ; if ( arr [ mid ] == key ) return mid ;"}
{"text":"The tricky case , just update left and right","code":"if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) }"}
{"text":"If arr [ l ... mid ] is sorted","code":"if ( arr [ l ] <= arr [ mid ] ) {"}
{"text":"As this subarray is sorted , we can quickly check if key lies in any of the halves","code":"if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;"}
{"text":"If key does not lie in the first half subarray then divide the other half into two subarrays such that we can quickly check if key lies in the other half","code":"return search ( arr , mid + 1 , h , key ) ; }"}
{"text":"If arr [ l . . mid ] first subarray is not sorted then arr [ mid ... h ] must be sorted subarray","code":"if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }"}
{"text":"Driver code","code":"let arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; let n = arr . length ; let key = 3 ; document . write ( search ( arr , 0 , n - 1 , key ) ) ;"}
{"text":"Function to return the sorted string","code":"function getSortedString ( s , n ) {"}
{"text":"Vectors to store the lowercase and uppercase characters","code":"var v1 = [ ] ; var v2 = [ ] ; var i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) v1 . push ( s [ i ] ) ; if ( s [ i ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) v2 . push ( s [ i ] ) ; }"}
{"text":"Sort both the vectors","code":"console . log ( v1 ) ; v1 . sort ( ) ; v2 . sort ( ) ; var j = 0 ; i = 0 ; for ( var k = 0 ; k < n ; k ++ ) {"}
{"text":"If current character is lowercase then pick the lowercase character from the sorted list","code":"if ( s [ k ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ k ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) { s [ k ] = v1 [ i ] ; ++ i ; }"}
{"text":"Else pick the uppercase character","code":"else if ( s [ k ] . charCodeAt ( 0 ) > \" \" . charCodeAt ( 0 ) && s [ k ] . charCodeAt ( 0 ) <= \" \" . charCodeAt ( 0 ) ) { s [ k ] = v2 [ j ] ; ++ j ; } }"}
{"text":"Return the sorted string","code":"return s . join ( \" \" ) ; }"}
{"text":"Driver code","code":"var s = \" \" ; var n = s . length ; document . write ( getSortedString ( s . split ( \" \" ) , n ) ) ;"}
{"text":"Function to check if the condition holds","code":"function check ( s ) {"}
{"text":"Get the length of the string","code":"let l = s . length ;"}
{"text":"sort the given string","code":"s . sort ( ) ;"}
{"text":"Iterate for every index and check for the condition","code":"for ( let i = 1 ; i < l ; i ++ ) {"}
{"text":"If are not consecutive","code":"if ( ( s [ i ] . charCodeAt ( ) - s [ i - 1 ] . charCodeAt ( ) ) != 1 ) return false ; } return true ; }"}
{"text":"1 st example","code":"let str = \" \" ; if ( check ( str . split ( ' ' ) ) == true ) document . write ( \" \" + \" \" ) ; else document . write ( \" \" + \" \" ) ;"}
{"text":"2 nd example","code":"let str1 = \" \" ; if ( check ( str1 . split ( ' ' ) ) == true ) document . write ( \" \" ) ; else document . write ( \" \" ) ;"}
{"text":"function to find minimum elements needed .","code":"function minElements ( arr , n ) {"}
{"text":"calculating HALF of array sum","code":"let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum \/ 2 , 10 ) ;"}
{"text":"sort the array in descending order .","code":"arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ;"}
{"text":"current sum greater than sum","code":"if ( curr_sum > halfSum ) return res ; } return res ; }"}
{"text":"Driver Code","code":"let arr = [ 3 , 1 , 7 , 1 ] ; let n = arr . length ; document . write ( minElements ( arr , n ) ) ;"}
{"text":"Function to check if its possible to make all array elements equal or not","code":"function arrayElementEqual ( arr , N ) {"}
{"text":"Stores the sum of the array","code":"var sum = 0 ;"}
{"text":"Traverse the array","code":"for ( i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; }"}
{"text":"If sum is divisible by N","code":"if ( sum % N == 0 ) { document . write ( \" \" ) ; }"}
{"text":"Otherwise , not possible to make all array elements equal","code":"else { document . write ( \" \" + \" \" ) ; } }"}
{"text":"Given array","code":"var arr = [ 1 , 5 , 6 , 4 ] ;"}
{"text":"Size of the array","code":"var N = arr . length ; arrayElementEqual ( arr , N ) ;"}
{"text":"Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array","code":"function findMaxValByRearrArr ( arr , N ) {"}
{"text":"Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements","code":"let res = 0 ;"}
{"text":"Update res","code":"res = parseInt ( ( N * ( N + 1 ) ) \/ 2 , 10 ) ; return res ; }"}
{"text":"Driver Code","code":"let arr = [ 3 , 2 , 1 ] ; let N = arr . length ; document . write ( findMaxValByRearrArr ( arr , N ) ) ;"}
{"text":"Function to find the maximum sided polygon that can be inscribed","code":"function MaximumSides ( n ) {"}
{"text":"Base Case","code":"if ( n < 4 ) return - 1 ;"}
{"text":"Return n \/ 2 if n is even Otherwise , return - 1","code":"return n % 2 == 0 ? n \/ 2 : - 1 ; }"}
{"text":"Given N","code":"let N = 8 ;"}
{"text":"Function Call","code":"document . write ( MaximumSides ( N ) ) ;"}
{"text":"Function to find the mean of pair product array of arr [ ]","code":"function pairProductMean ( arr , N ) {"}
{"text":"Initializing suffix sum array","code":"var suffixSumArray = Array ( N ) ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ;"}
{"text":"Build suffix sum array","code":"for ( var i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; }"}
{"text":"Size of pairProductArray","code":"var length = ( N * ( N - 1 ) ) \/ 2 ;"}
{"text":"Stores sum of pairProductArray","code":"var res = 0 ; for ( var i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; }"}
{"text":"Store the mean","code":"var mean ;"}
{"text":"Find mean of pairProductArray","code":"if ( length != 0 ) mean = res \/ length ; else mean = 0 ;"}
{"text":"Return the resultant mean","code":"return mean ; }"}
{"text":"Given array arr [ ]","code":"var arr = [ 1 , 2 , 4 , 8 ] ; var N = arr . length ;"}
{"text":"Function Call","code":"document . write ( pairProductMean ( arr , N ) . toFixed ( 2 ) ) ;"}
{"text":"Function to return the value of Binomial Coefficient C ( n , k )","code":"function ncr ( n , k ) { var res = 1 ;"}
{"text":"Since C ( n , k ) = C ( n , n - k )","code":"if ( k > n - k ) k = n - k ;"}
{"text":"Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- -- * 1 ]","code":"for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res \/= ( i + 1 ) ; } return res ; }"}
{"text":"Function to find the minimum count of paths from top left to bottom right by placing K 1 s in the matrix","code":"function countPath ( N , M , K ) { var answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else {"}
{"text":"Count of ways without 1 s","code":"answer = ncr ( N + M - 2 , N - 1 ) ;"}
{"text":"Count of paths from starting point to mid point","code":"var X = ( N - 1 ) \/ 2 + ( M - 1 ) \/ 2 ; var Y = ( N - 1 ) \/ 2 ; var midCount = ncr ( X , Y ) ;"}
{"text":"Count of paths from mid point to end point","code":"X = ( ( N - 1 ) - ( N - 1 ) \/ 2 ) + ( ( M - 1 ) - ( M - 1 ) \/ 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) \/ 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; }"}
{"text":"Driver Code","code":"var N = 3 ; var M = 3 ; var K = 1 ; document . write ( countPath ( N , M , K ) ) ;"}
{"text":"Function to find maximum count of operations","code":"function find_max ( v , n ) {"}
{"text":"Initialize count by 0","code":"let count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ;"}
{"text":"Iterate over remaining pairs","code":"for ( let i = 1 ; i < n - 1 ; i ++ ) {"}
{"text":"Check if first operation is applicable","code":"if ( v [ i - 1 ] [ 0 ] < ( v [ i ] [ 0 ] - v [ i ] [ 1 ] ) ) count ++ ;"}
{"text":"Check if 2 nd operation is applicable","code":"else if ( v [ i + 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) { count ++ ; v [ i ] [ 0 ] = v [ i ] [ 0 ] + v [ i ] [ 1 ] ; }"}
{"text":"Otherwise","code":"else continue ; }"}
{"text":"Return the count of operations","code":"return count ; }"}
{"text":"Driver Code","code":"let n = 3 ; let v = [ [ 10 , 20 ] , [ 15 , 10 ] , [ 20 , 16 ] ] ; document . write ( find_max ( v , n ) ) ;"}
{"text":"Function to find the number of substrings that can be formed using given characters","code":"function numberofsubstrings ( str , k , charArray ) { var N = str . length ;"}
{"text":"Boolean array for storing the available characters","code":"var available = [ 26 ] ;"}
{"text":"Mark indices of all available characters as 1","code":"for ( var i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' ' ] = 1 ; }"}
{"text":"Initialize lastPos as - 1","code":"var lastPos = - 1 ;"}
{"text":"Initialize ans with the total no of possible substrings","code":"var ans = ( N * ( N + 1 ) ) \/ 2 ;"}
{"text":"Traverse the string from left to right","code":"for ( var i = 0 ; i < N ; i ++ ) {"}
{"text":"If the current character is not present in B","code":"if ( available [ str . charAt ( i ) - ' ' ] == 0 ) {"}
{"text":"Subtract the total possible substrings","code":"ans -= ( ( i - lastPos ) * ( N - i ) ) ;"}
{"text":"Update the value of lastpos to current index","code":"lastPos = i ; } }"}
{"text":"Print the final answer","code":"document . write ( ans ) ; }"}
{"text":"Given String","code":"var str = \" \" ; var k = 2 ;"}
{"text":"Given character array","code":"var charArray = [ ' ' , ' ' ] ;"}
{"text":"Function Call","code":"numberofsubstrings ( str , k , charArray ) ;"}
{"text":"Function to return minimum cost to reach destination","code":"function minCost ( N , P , Q ) {"}
{"text":"Initialize cost to 0","code":"var cost = 0 ;"}
{"text":"going backwards until we reach initial position","code":"while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { var temp = parseInt ( N \/ 2 ) ;"}
{"text":"if 2 * X jump is better than X + 1","code":"if ( temp * P > Q ) cost += Q ;"}
{"text":"if X + 1 jump is better","code":"else cost += P * temp ; N = parseInt ( N \/ 2 ) ; } }"}
{"text":"return cost","code":"return cost ; }"}
{"text":"Driver Code","code":"var N = 9 , P = 5 , Q = 1 ; document . write ( minCost ( N , P , Q ) ) ;"}
{"text":"Function to find number of ways to reach from node 1 to 1 again , after moving exactly K edges","code":"function numberOfWays ( n , k ) {"}
{"text":"Initialize a dp [ ] array , where dp [ i ] stores number of ways to reach at a i node","code":"let dp = Array ( 1000 ) ;"}
{"text":"Initialize the dp array with 0","code":"for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; }"}
{"text":"Base Case","code":"dp [ 0 ] = 1 ;"}
{"text":"Iterate for the number of edges moved","code":"for ( let i = 1 ; i <= k ; i ++ ) {"}
{"text":"Sum will store number of ways to reach all the nodes","code":"let numWays = 0 ;"}
{"text":"Iterate for every possible state for the current step","code":"for ( let j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; }"}
{"text":"Update the value of the dp array after travelling each edge","code":"for ( let j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } }"}
{"text":"Prlet dp [ 0 ] as the answer","code":"document . write ( dp [ 0 ] ) ; }"}
{"text":"Given Input","code":"let N = 5 ; let K = 3 ;"}
{"text":"Function Call","code":"numberOfWays ( N , K ) ;"}
{"text":"JavaScript program for the above approach","code":"let M = 1000000007 ; function waysOfDecoding ( s ) { let first = 1 , second = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { let temp = second ;"}
{"text":"If s [ i ] = = ' * ' there can be 9 possible values of *","code":"if ( s [ i ] == ' ' ) { second = 9 * second ;"}
{"text":"If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 )","code":"if ( s [ i - 1 ] == ' ' ) second = ( second + 9 * first ) % M ;"}
{"text":"If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 )","code":"else if ( s [ i - 1 ] == ' ' ) second = ( second + 6 * first ) % M ;"}
{"text":"If the previous digit is * then all 15 2 - digit characters can be formed","code":"else if ( s [ i - 1 ] == ' ' ) second = ( second + 15 * first ) % M ; }"}
{"text":"If s [ i ] != ' * '","code":"else { second = s [ i ] != ' ' ? second : 0 ;"}
{"text":"Adding first in second if s [ i - 1 ] = 1","code":"if ( s [ i - 1 ] == ' ' ) second = ( second + first ) % M ;"}
{"text":"Adding first in second if s [ i - 1 ] = = 2 and s [ i ] <= '6'","code":"else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) second = ( second + first ) % M ;"}
{"text":"if s [ i - 1 ] == ' * ' the union of above 2 cases has to be done","code":"else if ( s [ i - 1 ] == ' ' ) second = ( second + ( s [ i ] <= ' ' ? 2 : 1 ) * first ) % M ; } first = temp ; } return second ; }"}
{"text":"Driver Code","code":"let s = \" \" ; document . write ( waysOfDecoding ( s ) ) ;"}
{"text":"Function to calculate minimum cost of buying least X chocolates","code":"function findMinCost ( arr , X , n , i = 0 ) {"}
{"text":"Base Case","code":"if ( X <= 0 ) return 0 ; if ( i >= n ) return Number . MAX_SAFE_INTEGER ;"}
{"text":"Include the i - th box","code":"let inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Number . MAX_SAFE_INTEGER ) inc += arr [ i ] [ 1 ] ;"}
{"text":"Exclude the i - th box","code":"let exc = findMinCost ( arr , X , n , i + 1 ) ;"}
{"text":"Return the minimum of the above two cases","code":"return Math . min ( inc , exc ) ; }"}
{"text":"Given array and value of X","code":"let arr = [ [ 4 , 3 ] , [ 3 , 2 ] , [ 2 , 4 ] , [ 1 , 3 ] , [ 4 , 2 ] ] ; let X = 7 ;"}
{"text":"Store the size of the array","code":"let n = arr . length ; let ans = findMinCost ( arr , X , n ) ;"}
{"text":"Print the answer","code":"if ( ans != Number . MAX_SAFE_INTEGER ) document . write ( ans ) else document . write ( - 1 )"}
{"text":"Function to calculate the probability for the given sum to be equal to sum in N throws of dice","code":"function find ( N , sum ) {"}
{"text":"Base cases","code":"if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 \/ 6 ; else return 0 ; } let s = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) \/ 6 ; return s ; }"}
{"text":"Driver code","code":"let N = 4 , a = 13 , b = 17 ; let probability = 0.0 ; for ( let sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ;"}
{"text":"Print the answer","code":"document . write ( probability . toFixed ( 6 ) ) ;"}
{"text":"Function to find the minimum number to steps to reduce N to 0","code":"function minDays ( n ) {"}
{"text":"Base case","code":"if ( n < 1 ) return n ;"}
{"text":"Recursive call to count the minimum steps needed","code":"var cnt = 1 + Math . min ( n % 2 + minDays ( parseInt ( n \/ 2 ) ) , n % 3 + minDays ( parseInt ( n \/ 3 ) ) ) ;"}
{"text":"Return the answer","code":"return cnt ; }"}
{"text":"Given number N","code":"var N = 6 ;"}
{"text":"Function call","code":"document . write ( minDays ( N ) ) ;"}
