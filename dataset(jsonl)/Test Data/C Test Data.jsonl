{"text": "Jarak antara dua pesawat selari dalam 3 | Program C untuk mencari jarak antara dua pesawat selari dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; printf ( \" Perpendicular ▁ distance ▁ is ▁ % f STRNEWLINE \" , d ) ; } else printf ( \" Planes ▁ are ▁ not ▁ parallel \" ) ; return ; } int main ( ) { float a1 = 1 ; float b1 = 2 ; float c1 = -1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = -3 ; float d2 = -4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; return 0 ; }"}
{"text": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | Program C untuk mengira siri berikut; Fungsi untuk mengira siri berikut; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } int main ( ) { int n = 3 ; int res = Series ( n ) ; printf ( \" % d \" , res ) ; }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | Pelaksanaan C ++ berasaskan penyortiran untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Susun array; Selepas menyusun, periksa sama ada elemen semasa sama seperti sebelumnya atau satu lagi. ; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk Putaran Array | Program c untuk memutar array oleh elemen d; Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar arr [] saiz n oleh d; fungsi utiliti untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void leftRotatebyOne ( int arr [ ] , int n ) ; void leftRotatebyOne ( int arr [ ] , int n ) { int temp = arr [ 0 ] , i ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { int i ; for ( i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; return 0 ; }"}
{"text": "Cari nombor yang paling kecil | Program C untuk mencari unsur -unsur terkecil yang hilang dalam array yang disusun. ; Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Smallest ▁ missing ▁ element ▁ is ▁ % d \" , findFirstMissing ( arr , 0 , n - 1 ) ) ; return 0 ; }"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan |  ; Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i; Max semasa termasuk i; kembali max incl and excl; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } int main ( ) { int arr [ ] = { 5 , 5 , 10 , 100 , 10 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d ▁ n \" , FindMaxSum ( arr , n ) ) ; return 0 ; }"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program C untuk memeriksa elemen majoriti dalam pelbagai disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Program pemacu untuk menyemak fungsi di atas", "code": "# include <stdio.h> NEW_LINE # include <stdbool.h> NEW_LINE bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( isMajority ( arr , n , x ) ) printf ( \" % d ▁ appears ▁ more ▁ than ▁ % d ▁ times ▁ in ▁ arr [ ] \" , x , n / 2 ) ; else printf ( \" % d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % d ▁ times ▁ in ▁ arr [ ] \" , x , n / 2 ) ; return 0 ; }"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program C untuk memeriksa elemen majoriti dalam pelbagai disusun; Jika x hadir dalam arr [rendah ... tinggi] maka mengembalikan indeks kejadian pertama x, jika tidak pulangan - 1; Semak jika ARR [MID] adalah kejadian pertama x. arr [pertengahan] adalah kejadian pertama jika x adalah salah satu daripada yang berikut adalah benar: (i) pertengahan == 0 dan arr [mid] = = x (ii) arr [pertengahan - 1] <x dan arr [mid] == x; Fungsi ini kembali benar jika x hadir lebih daripada n / 2 kali dalam arr [] saiz n; Cari indeks kejadian pertama x dalam arr []; Jika elemen tidak hadir sama sekali, kembali palsu; Semak jika elemen hadir lebih daripada n / 2 kali; Program pemacu untuk menyemak fungsi di atas", "code": "# include <stdio.h> NEW_LINE # include <stdbool.h> NEW_LINE int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; } bool isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == -1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajority ( arr , n , x ) ) printf ( \" % d ▁ appears ▁ more ▁ than ▁ % d ▁ times ▁ in ▁ arr [ ] \" , x , n / 2 ) ; else printf ( \" % d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % d ▁ times ▁ in ▁ arr [ ] \" , x , n / 2 ) ; return 0 ; }"}
{"text": "Semak elemen majoriti dalam array yang disusun |  ;", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) printf ( \" % d ▁ appears ▁ more ▁ than ▁ % d ▁ times ▁ in ▁ arr [ ] \" , x , n / 2 ) ; else printf ( \" % d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % d ▁ times ▁ in ▁ \" \" arr [ ] \" , x , n / 2 ) ; return 0 ; }"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ % d \" , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Memotong batang | DP | Program C untuk pendekatan di atas; Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; printf ( \" Maximum ▁ obtained ▁ value ▁ is ▁ % d ▁ STRNEWLINE \" , un_kp ( price , length , n , Max_len ) ) ; }"}
{"text": "Program untuk menukar radian ke ijazah | C kod untuk menukar radian ke ijazah; Fungsi untuk penukaran; Kod pemacu", "code": "#include <stdio.h> NEW_LINE double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } int main ( ) { double radian = 5.0 ; double degree = Convert ( radian ) ; printf ( \" % .5lf \" , degree ) ; return 0 ; }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program C untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } int main ( ) { int x = 29 , y = 13 ; printf ( \" x ▁ - ▁ y ▁ is ▁ % d \" , subtract ( x , y ) ) ; return 0 ; }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik |  ; Program Pemandu", "code": "#include <stdio.h> NEW_LINE int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } int main ( ) { int x = 29 , y = 13 ; printf ( \" x ▁ - ▁ y ▁ is ▁ % d \" , subtract ( x , y ) ) ; return 0 ; }"}
{"text": "Cetak terbalik rentetan menggunakan rekursi | C program untuk membalikkan rentetan menggunakan rekursi; Berfungsi untuk mencetak terbalik rentetan lulus; Program pemacu untuk menguji fungsi di atas", "code": "# include <stdio.h> NEW_LINE void reverse ( char * str ) { if ( * str ) { reverse ( str + 1 ) ; printf ( \" % c \" , * str ) ; } } int main ( ) { char a [ ] = \" Geeks ▁ for ▁ Geeks \" ; reverse ( a ) ; return 0 ; }"}
{"text": "Produk Kronecker Dua Matriks | C Kod untuk mencari produk Kronecker dua matriks dan menyimpannya sebagai Matrix C; Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Kod pemacu", "code": "#include <stdio.h> NEW_LINE const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; printf ( \" % d TABSYMBOL \" , C [ i + l + 1 ] [ j + k + 1 ] ) ; } } printf ( \" STRNEWLINE \" ) ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; return 0 ; }"}
{"text": "Pemilihan jenis | Program C untuk pelaksanaan pilihan pemilihan; fungsi swap; Susun fungsi; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; selectionSort ( arr , n ) ; printf ( \" Sorted ▁ array : ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Pendaraban rantai matriks | DP | Lihat buku Cormen untuk butiran algoritma berikut; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam M [] []. 0 bar dan lajur 0 M [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ % d ▁ \" , MatrixChainOrder ( arr , size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Memotong batang | DP | Program C untuk pendekatan di atas; Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; printf ( \" Maximum ▁ obtained ▁ value ▁ is ▁ % d ▁ STRNEWLINE \" , un_kp ( price , length , n , Max_len ) ) ; }"}
{"text": "Multiply dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung |  ; berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; kes di mana y adalah negatif; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } int main ( ) { printf ( \" % d \" , multiply ( 5 , -11 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Segitiga Pascal | A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga PSCAL yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai -nilai lain adalah jumlah nilai di atas dan kiri di atas; Kod pemacu", "code": "void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; printf ( \" % d ▁ \" , arr [ line ] [ i ] ) ; } printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }"}
{"text": "Segitiga Pascal | Program C untuk Pascals Triangle A O (N ^ 2) Masa dan O (1) Fungsi Ruang Tambahan untuk Segitiga Pascal; digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu", "code": "void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { printf ( \" % d ▁ \" , C ) ; C = C * ( line - i ) / i ; } printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | Program C untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { printf ( \" % d \" , Add ( 15 , 32 ) ) ; return 0 ; }"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik |", "code": "int Add ( int x , int y ) { if ( y == 0 ) return x ; else return Add ( x ^ y , ( x & y ) << 1 ) ; }"}
{"text": "Count set bit dalam integer | Program C untuk mengira set bit dalam integer; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Program untuk menguji fungsi countsetbits", "code": "#include <stdio.h> NEW_LINE unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; printf ( \" % d \" , countSetBits ( i ) ) ; return 0 ; }"}
{"text": "Count set bit dalam integer | Program C untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int num_to_bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } int main ( ) { int num = 31 ; printf ( \" % d STRNEWLINE \" , countSetBitsRec ( num ) ) ; }"}
{"text": "Count set bit dalam integer |  ; Semak setiap bit dalam nombor ditetapkan atau tidak dan kembalikan jumlah kiraan bit yang ditetapkan. ; (1 << i) = pow (2, i); Kod pemacu", "code": "#include <stdio.h> NEW_LINE int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; } int main ( ) { int N = 15 ; printf ( \" % d \" , countSetBits ( N ) ) ; return 0 ; }"}
{"text": "Program untuk mencari pariti | Program c untuk mencari pariti integer; Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Program Pemandu untuk Menguji GetParity ()", "code": "# include <stdio.h> NEW_LINE # define bool  int NEW_LINE bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; printf ( \" Parity ▁ of ▁ no ▁ % d ▁ = ▁ % s \" , n , ( getParity ( n ) ? \" odd \" : \" even \" ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program C untuk mencari sama ada tidak ada kuasa dua; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Program Pemandu", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE #include <math.h> NEW_LINE bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; isPowerOfTwo ( 64 ) ? printf ( \" Yes STRNEWLINE \" ) : printf ( \" No STRNEWLINE \" ) ; return 0 ; }"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Program untuk mencari dua elemen yang ganjil; Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan XOR semua elemen di arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana mudah diperoleh; Sekarang bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } printf ( \" The two ODD elements are % d & % d \" , x , y ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Cari pasangan dengan perbezaan yang diberikan | Program C untuk mencari pasangan dengan perbezaan yang diberikan; Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { printf ( \" Pair ▁ Found : ▁ ( % d , ▁ % d ) \" , arr [ i ] , arr [ j ] ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } printf ( \" No ▁ such ▁ pair \" ) ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 60 ; findPair ( arr , size , n ) ; return 0 ; }"}
{"text": "Pendaraban rantai matriks | DP | Pelaksanaan rekursif naif yang hanya mengikuti harta substruktur yang optimum di atas; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu", "code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ % d ▁ \" , MatrixChainOrder ( arr , 1 , n - 1 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencari perimeter poligon biasa | Program C untuk mencari perimeter poligon biasa; Berfungsi untuk mengira perimeter; Hitung perimeter; kod pemacu; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter", "code": "#include <stdio.h> NEW_LINE float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; } int main ( ) { int n = 5 ; float s = 2.5 , peri ; peri = Perimeter ( s , n ) ; printf ( \" Perimeter ▁ of ▁ Regular ▁ Polygon STRNEWLINE \" \" ▁ with ▁ % d ▁ sides ▁ of ▁ length ▁ % f ▁ = ▁ % f STRNEWLINE \" , n , s , peri ) ; return 0 ; }"}
{"text": "Jarak antara satu titik dan satah dalam 3 D | Program C untuk mencari jarak serenjang (terpendek) antara satu titik dan satah dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu; Panggilan fungsi", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; printf ( \" Perpendicular ▁ distance ▁ is ▁ % f \" , d / e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; }"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Program untuk mencari purata nombor ganjil sehingga nombor ganjil yang diberikan. ; Fungsi untuk mengira purata nombor ganjil; fungsi pemacu", "code": "#include <stdio.h> NEW_LINE int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } return ( n + 1 ) / 2 ; } int main ( ) { int n = 15 ; printf ( \" % d \" , averageOdd ( n ) ) ; return 0 ; }"}
{"text": "Trinomial Triangle | Program CPP untuk mencetak segitiga trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Menggunakan harta segitiga trinomial. ; Jika nilai sudah dikira, kembalikan itu. ; Kes asas; Kes asas; langkah rekursif dan menyimpan nilai. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  10 NEW_LINE using namespace std ; int TrinomialValue ( int dp [ MAX ] [ MAX ] , int n , int k ) { if ( k < 0 ) k = - k ; if ( dp [ n ] [ k ] != 0 ) return dp [ n ] [ k ] ; if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return ( dp [ n ] [ k ] = TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) ; } void printTrinomial ( int n ) { int dp [ MAX ] [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) cout << TrinomialValue ( dp , i , j ) << \" ▁ \" ; for ( int j = 1 ; j <= i ; j ++ ) cout << TrinomialValue ( dp , i , j ) << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 4 ; printTrinomial ( n ) ; return 0 ; }"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Program c untuk mencari sama ada nombor adalah kuasa 2 atau tidak; pulangan 1 apabila STR adalah kuasa 2 pulangan 0 apabila STR bukan kuasa 2; Jumlah menyimpan dividen pertengahan semasa membahagikan. ; jika input adalah \"1\" maka kembali 0 kerana 2 ^ k = 1 di mana k> = 1 dan di sini k = 0; Bahagikan nombor sehingga ia dikurangkan kepada 1 jika kita berjaya dapat mengurangkan nombor kepada 1, ia bermakna rentetan input adalah kuasa dua jika di antara nombor ganjil muncul pada akhirnya ia bermakna rentetan tidak dibahagikan dengan dua sehingga bukan kuasa 2; Sekiranya digit terakhir adalah ganjil maka rentetan tidak dapat dibahagikan dengan 2 oleh itu bukan kuasa dua pulangan 0 .; Bahagikan keseluruhan rentetan dengan 2. Saya digunakan untuk mengesan indeks dalam nombor semasa. J digunakan untuk mengesan indeks untuk lelaran seterusnya. ; Jika num <2 maka kita perlu mengambil satu lagi digit di sebelah kanan [i] untuk menjadikannya lebih besar daripada [i]. E. g. 214/2 -> 107; Jika ia bukan indeks pertama. Contohnya 214 maka kita perlu memasukkan 0 .; untuk contohnya. \"124\" Kami tidak akan menulis 064 jadi jika indeks pertama hanya mengabaikan; Selepas setiap bahagian dengan 2 panjang rentetan diubah. ; Jika rentetan mencapai 1 maka str adalah kuasa 2 .; Kod pemacu.", "code": "#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int isPowerOf2 ( char * str ) { int len_str = strlen ( str ) ; int num = 0 ; if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ; while ( len_str != 1 str [ len_str - 1 ] != '1' ) { if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ; for ( int i = 0 , j = 0 ; i < len_str ; i ++ ) { num = num * 10 + str [ i ] - '0' ; if ( num < 2 ) { if ( i != 0 ) str [ j ++ ] = '0' ; continue ; } str [ j ++ ] = ( int ) ( num / 2 ) + '0' ; num = ( num ) - ( num / 2 ) * 2 ; } str [ j ] = ' \\0' ; len_str = j ; } return 1 ; } int main ( ) { char str1 [ ] = \"12468462246684202468024\" \"6842024662202000002\" ; char str2 [ ] = \"1\" ; char str3 [ ] = \"128\" ; printf ( \" % d % d % d \" , isPowerOf2 ( str1 ) , isPowerOf2 ( str2 ) , isPowerOf2 ( str3 ) ) ; return 0 ; }"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Program untuk mencari purata nombor walaupun sehingga nombor yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; fungsi pemacu", "code": "#include <stdio.h> NEW_LINE int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } return ( n + 2 ) / 2 ; } int main ( ) { int n = 16 ; printf ( \" % d \" , averageEven ( n ) ) ; return 0 ; }"}
{"text": "Jumlah pembahagi faktorial nombor | C program untuk mencari jumlah pembahagi yang betul faktorial nombor; fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Program Pemandu", "code": "#include <stdio.h> NEW_LINE int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; } int main ( ) { int n = 4 ; printf ( \" % d \" , sumFactDiv ( n ) ) ; }"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; berfungsi untuk mencetak pembahagi; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) printf ( \" % d ▁ \" , i ) ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) printf ( \" % d ▁ \" , n / i ) ; } } int main ( ) { printf ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ) ; printDivisors ( 100 ) ; return 0 ; }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | C pelaksanaan kaedah naif untuk mencetak semua pembahagi; berfungsi untuk mencetak pembahagi; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) printf ( \" % d ▁ \" , i ) ; } int main ( ) { printf ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ) ; printDivisors ( 100 ) ; return 0 ; }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Penyelesaian yang lebih baik (daripada naif) untuk mencari semua divisior; Berfungsi untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; lain sebaliknya mencetak kedua -duanya; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( \" % d ▁ \" , i ) ; printf ( \" % d ▁ % d ▁ \" , i , n / i ) ; } } } int main ( ) { printf ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ) ; printDivisors ( 100 ) ; return 0 ; }"}
{"text": "Tulis program untuk membalikkan digit nombor | Program C untuk membalikkan digit nombor; Fungsi rekursif untuk membalikkan digit NUM; Program pemacu untuk menguji pembalikan", "code": "#include <stdio.h> ; int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } int main ( ) { int num = 4562 ; printf ( \" Reverse ▁ of ▁ no . ▁ is ▁ % d \" , reversDigits ( num ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | C Program untuk menilai Ceil (7 n / 8) tanpa menggunakan * dan /; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<'; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int multiplyBySevenByEight ( unsigned int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { unsigned int n = 9 ; printf ( \" % d \" , multiplyBySevenByEight ( n ) ) ; return 0 ; }"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | C program untuk menilai 7 n / 8 tanpa menggunakan * dan /; Langkah 1) Pertama kali ganda nombor dengan 7 i. e. 7 n = (n << 3) - n * Langkah 2) Bahagikan hasil sebanyak 8; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int multiplyBySevenByEight ( unsigned int n ) { return ( ( n << 3 ) - n ) >> 3 ; } int main ( ) { unsigned int n = 15 ; printf ( \" % u \" , multiplyBySevenByEight ( n ) ) ; return 0 ; }"}
{"text": "Jenis penyisipan binari | pelaksanaan berulang; Berfungsi untuk menyusun array [] saiz 'n'; Cari lokasi di mana dipilih haruslah inseretd; Gerakkan semua elemen selepas lokasi untuk mewujudkan ruang; Kod pemacu", "code": "#include <stdio.h> NEW_LINE int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } int main ( ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) , i ; insertionSort ( a , n ) ; printf ( \" Sorted ▁ array : ▁ STRNEWLINE \" ) ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , a [ i ] ) ; return 0 ; }"}
{"text": "SENARAI SENSI | Program C untuk jenis penyisipan; Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Program pemacu untuk menguji jenis penyisipan", "code": "#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSort ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Perubahan duit syiling | DP | Program C Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d ▁ \" , count ( arr , m , 4 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencari kawasan trapezoid | Program CPP untuk mengira kawasan trapezoid; Fungsi untuk kawasan tersebut; Kod pemacu", "code": "#include <stdio.h> NEW_LINE double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } int main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; printf ( \" Area ▁ is : ▁ % .1lf \" , area ) ; return 0 ; }"}
