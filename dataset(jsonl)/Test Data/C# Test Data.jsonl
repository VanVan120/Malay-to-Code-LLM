{"text": "Jumlah minimum mungkin dengan mengeluarkan semua kejadian mana -mana elemen array | C # Program untuk pendekatan di atas; Berfungsi untuk mencari jumlah minimum selepas penghapusan; Kedai kekerapan elemen array; Melintasi array; Hitung jumlah; Kekerapan kemas kini elemen semasa; Menyimpan jumlah minimum yang diperlukan; Peta Traverse; Cari jumlah minimum yang diperoleh; Kembali jumlah minimum; Kod pemacu; Arahan input; Saiz array", "code": "using System ; using System . Collections . Generic ; public class GFG { static int minSum ( int [ ] A , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( mp . ContainsKey ( A [ i ] ) ) { mp [ A [ i ] ] = mp [ A [ i ] ] + 1 ; } else { mp . Add ( A [ i ] , 1 ) ; } } int minSum = int . MaxValue ; foreach ( KeyValuePair < int , int > it in mp ) { minSum = Math . Min ( minSum , sum - ( it . Key * it . Value ) ) ; } return minSum ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 5 , 6 , 6 } ; int N = arr . Length ; Console . Write ( minSum ( arr , N ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | C # Program untuk pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Melintasi array; Menyimpan perbezaan maksimum; Semak elemen bersebelahan maksimum; Tidak termasuk elemen semasa; Mengemas kini perbezaan maksimum; Mengemas kini nilai sebelumnya; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; public class GFG { static void maxAdjacent ( int [ ] arr , int N ) { List < int > res = new List < int > ( ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = Int32 . MinValue ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = Math . Max ( maxi , Math . Abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . Add ( maxi ) ; } foreach ( int x in res ) { Console . Write ( x + \" ▁ \" ) ; } Console . WriteLine ( ) ; } static public void Main ( ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . Length ; maxAdjacent ( arr , N ) ; } }"}
{"text": "Kira 1 S hadir dalam pelbagai indeks [l, r] dalam array yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari saiz array jika array pada mulanya mengandungi elemen tunggal; Kes asas; P / 2 -> findSize (n / 2) p % 2 -> 1 p / 2 -> findSize (n / 2); Berfungsi untuk mengembalikan kiraan 1 s dalam julat [l, r]; Kes asas; Bahagian 1 -> n / 2 [1, siz_m]; Kemas kini titik akhir kanan julat ke min (Siz_m, r); Bahagian 2 -> n % 2 [Sizm + 1, Siz_m + 1]; Bahagian 3 -> n / 2 [Sizm + 2, 2 * Siz_m - 1] Sama seperti Bahagian 1 harta simetrik beralih koordinat mengikut bahagian 1 tolak (siz_m + 1) dari kedua -dua l, r; Kod pemacu; Input; Mengira bilangan 1 dalam julat [l, r]", "code": "using System ; class GFG { static int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; } static int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , Math . Min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , Math . Max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } static void Main ( ) { int N = 7 , L = 2 , R = 5 ; Console . WriteLine ( CountOnes ( N , L , R ) ) ; } }"}
{"text": "Cari pasangan (a, b) dengan LCM minimum supaya jumlahnya sama dengan n | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kerana 1 bukan pulangan utama atau komposit palsu; Semak jika ia dibahagikan dengan mana -mana nombor maka ia bukan perdana, kembali palsu; Semak jika n tidak dibahagikan dengan mana -mana nombor maka ia adalah perdana dan oleh itu kembali benar; Fungsi untuk mencari pasangan (a, b) seperti jumlah yang N & LCM adalah minimum; Semak sama ada nombor itu adalah perdana; Sekarang, jika tidak perdana maka cari yang paling kurang divisior; Semak jika membahagikan n maka ia adalah faktor; Output yang diperlukan ialah A = N / I & B = N / I * (n - 1); Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void minDivisior ( int n ) { if ( prime ( n ) ) { Console . Write ( 1 + \" ▁ \" + ( n - 1 ) ) ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { Console . Write ( n / i + \" ▁ \" + ( n / i * ( i - 1 ) ) ) ; break ; } } } } public static void Main ( String [ ] args ) { int N = 4 ; minDivisior ( N ) ; } }"}
{"text": "Cari fungsi Landau untuk nombor tertentu n | C # Program untuk pendekatan di atas; Untuk menyimpan fungsi Landau nombor; Berfungsi untuk mengembalikan GCD sebanyak 2 nombor; Berfungsi untuk mengembalikan LCM dua nombor; Berfungsi untuk mencari nilai LCM max di antara semua representasi n; Hitung nilai Landau; Fungsi rekursif untuk mencari cara yang berbeza di mana n boleh ditulis sebagai jumlah atleast satu bilangan bulat positif; Semak jika jumlah menjadi n, pertimbangkan perwakilan ini; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack - Keluarkan elemen semasa dari perwakilan; Berfungsi untuk mencari fungsi Landau; Menggunakan kambuhan mencari cara yang berbeza di mana n boleh ditulis sebagai sejumlah atleast satu + ve integer; Cetak hasilnya; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int Landau = int . MinValue ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } static void findLCM ( List < int > arr ) { int nth_lcm = arr [ 0 ] ; for ( int i = 1 ; i < arr . Count ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = Math . Max ( Landau , nth_lcm ) ; } static void findWays ( List < int > arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . Add ( j ) ; findWays ( arr , j , n - j ) ; arr . RemoveAt ( arr . Count - 1 ) ; } } static void Landau_function ( int n ) { List < int > arr = new List < int > ( ) ; findWays ( arr , 1 , n ) ; Console . Write ( Landau ) ; } public static void Main ( String [ ] args ) { int N = 4 ; Landau_function ( N ) ; } }"}
{"text": "Semak jika baki N | C # pelaksanaan untuk memeriksa ungkapan berikut untuk integer n adalah sah atau tidak; Fungsi untuk memeriksa sama ada nombor memegang syarat (n - 1)! % N = n - 1; Kes sudut; Nombor yang boleh dibahagikan dengan 2 atau 3 bukanlah perdana; Melangkah dari 5 dan terus memeriksa perdana; Fungsi untuk memeriksa ungkapan untuk nilai n; Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static void checkExpression ( int n ) { if ( isPrime ( n ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } public static void Main ( ) { int N = 3 ; checkExpression ( N ) ; } }"}
{"text": "Semak sama ada mungkin untuk memecah array yang diberikan ke dalam K Odd | C # Pelaksanaan untuk memeriksa sama ada mungkin untuk memecah array ke dalam sub subset dengan jumlah ganjil; Fungsi untuk memeriksa sama ada array boleh dibahagikan dalam subset k yang diperlukan; Menyimpan kiraan nombor ganjil; Semak jika elemen ganjil; Semak jika perpecahan mungkin; Kod pemacu", "code": "using System ; class GFG { static bool checkArray ( int n , int k , int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } public static void Main ( string [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = arr . Length ; int k = 4 ; if ( checkArray ( n , k , arr ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Jumlah pembahagian pasangan yang mungkin untuk array yang diberikan | C # pelaksanaan untuk mengira jumlah pembahagian semua pasangan yang mungkin untuk array yang diberikan; Berfungsi untuk mengira jumlah; Mengira kekerapan setiap istilah dan mencari maksimum di antara ia; Membuat kekerapan kumulatif; Mengambil nilai Ceil; nos. Dalam julat [(n - 0.5) x, (n + 0.5) x) akan menambah n ke ANS; Mengembalikan hasil readonly; Kod pemacu", "code": "using System ; class GFG { static long func ( int [ ] arr , int n ) { double ans = 0 ; int maxx = 0 ; double [ ] freq = new double [ 100005 ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . Max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ; double cur = Math . Ceiling ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . Min ( maxx , ( int ) ( Math . Ceiling ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( long ) ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; Console . Write ( func ( arr , n ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Count of Elements hendaklah dimasukkan untuk membuat array Jumlah dua kali xor array | C # Program untuk mencari kiraan elemen yang akan dimasukkan untuk membuat jumlah array dua kali ganda XOR array; Fungsi untuk mencari bilangan elemen minimum yang perlu dimasukkan supaya jumlah unsur -unsur array adalah dua kali ganda XOR array; Pembolehubah untuk menyimpan XOR semua elemen; Pembolehubah untuk menyimpan jumlah semua elemen; Gelung untuk mencari XOR dan jumlah array; Jika jumlah = 2 * xor; Tidak perlu memasukkan lebih banyak elemen; Kami memasukkan satu lagi elemen yang jumlahnya; Kami memasukkan dua lagi elemen SUM + XOR dan XOR. ; Cetak bilangan elemen yang dimasukkan dalam array; Cetak unsur -unsur yang dimasukkan dalam array; Kod pemacu", "code": "using System ; class GFG { static void insert_element ( int [ ] a , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { Console . Write ( \"0\" ) ; return ; } if ( Xor == 0 ) { Console . Write ( \"1\" + ' STRNEWLINE ' ) ; Console . Write ( Sum ) ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; Console . Write ( \"2\" ) ; Console . Write ( num1 + \" ▁ \" + num2 ) ; } public static void Main ( string [ ] args ) { int [ ] a = { 1 , 2 , 3 } ; int n = a . Length ; insert_element ( a , n ) ; } }"}
{"text": "Periksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak | C # Program untuk memeriksa sama ada akar persamaan kuadratik adalah timbal balik antara satu sama lain atau tidak; Berfungsi untuk memeriksa sama ada akar persamaan kuadratik adalah timbal balik antara satu sama lain atau tidak; Kod pemacu", "code": "using System ; class GFG { static void checkSolution ( int a , int b , int c ) { if ( a == c ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } public static void Main ( ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; } }"}
{"text": "Nombor Sunny | C # Program untuk pendekatan di atas; Periksa fungsi sama ada x adalah persegi yang sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Berfungsi untuk memeriksa nombor cerah; Semak jika (n + 1) adalah persegi yang sempurna atau tidak; Jika (n + 1) bukan persegi yang sempurna; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "using System ; class GFG { static bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; } static void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } public static void Main ( String [ ] args ) { int N = 8 ; checkSunnyNumber ( N ) ; } }"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | C # Program untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Melangkah melalui semua bilangan bulat; Semak jika n boleh ditukar kepada 1; Meningkatkan kiraan jika ia boleh ditukar; Kod pemacu", "code": "using System ; class GFG { static int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } public static void Main ( ) { int N = 6 ; Console . Write ( countValues ( N ) ) ; } }"}
{"text": "Cari nombor k dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan | C # Program untuk mencari nombor K dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan; Fungsi yang mencetak nombor k yang diperlukan; Cetak 1, k - 1 kali; Cetak (n - k + 1); Kod pemacu", "code": "using System ; class GFG { static void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) Console . Write ( 1 + \" ▁ \" ) ; Console . Write ( N - K + 1 ) ; } public static void Main ( String [ ] args ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; } }"}
{"text": "Cetak nth larian atau nombor autobiografi | C # pelaksanaan untuk mencari nombor semulajadi; Berfungsi untuk mencari nombor semula jadi yang melangkah; Mengisytiharkan barisan; Enqueue 1, 2, ..., 9 dalam perintah ini; Melakukan operasi k pada barisan; Dapatkan nombor langkah itu; Melakukan dequeue dari barisan; Jika x mod 10 tidak sama dengan 0; Kemudian enqueue 10 x + (x mod 10) - 1; Enqueue 10 x + (x mod 10); Jika x mod 10 tidak sama dengan 9; Kemudian enqueue 10 x + (x mod 10) + 1; Kembalikan jumlah operasi K - th sebagai nombor loncatan n; Kod pemacu; permulaan k", "code": "using System ; using System . Collections . Generic ; class GFG { static int NthSmallest ( int K ) { List < int > Q = new List < int > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . Add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q [ 0 ] ; Q . RemoveAt ( 0 ) ; if ( x % 10 != 0 ) { Q . Add ( x * 10 + x % 10 - 1 ) ; } Q . Add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . Add ( x * 10 + x % 10 + 1 ) ; } } return x ; } public static void Main ( String [ ] args ) { int N = 16 ; Console . Write ( NthSmallest ( N ) ) ; } }"}
{"text": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya persegi yang sempurna | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan persegi yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu", "code": "using System ; class GFG { static int nearest ( int n ) { int prevSquare = ( int ) Math . Sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } public static void Main ( string [ ] args ) { int n = 14 ; Console . WriteLine ( nearest ( n ) ) ; n = 16 ; Console . WriteLine ( nearest ( n ) ) ; n = 18 ; Console . WriteLine ( nearest ( n ) ) ; } }"}
{"text": "Nilai pi (Î) sehingga 50 tempat perpuluhan | C # Program untuk mengira nilai Pi sehingga tempat perpuluhan; Fungsi yang mencetak nilai tempat perpuluhan Pi; Cari nilai PI sehingga menggunakan fungsi ACOS (); Cetak nilai Pi sehingga tempat perpuluhan; Kod pemacu; Fungsi yang mencetak nilai pi", "code": "using System ; class GFG { static void printValueOfPi ( int N ) { double pi = 2 * Math . Acos ( 0.0 ) ; Console . WriteLine ( pi ) ; } public static void Main ( ) { int N = 4 ; printValueOfPi ( N ) ; } }"}
{"text": "Balikkan kth yang paling penting n | C # pelaksanaan pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array [] arr; Berfungsi untuk menukar nombor yang diwakili sebagai array binari [] arr ke setara perpuluhannya; Berfungsi untuk mengembalikan integer yang dikemas kini selepas membalikkan kth; Bilangan bit dalam n; Cari perwakilan binari n; Bilangan bit dalam n adalah kurang daripada k; Flip bit kth; Mengembalikan setara perpuluhan nombor; Kod pemacu", "code": "using System ; class GFG { static void decBinary ( int [ ] arr , int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int getNum ( int n , int k ) { int l = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int [ ] a = new int [ l ] ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } public static void Main ( String [ ] args ) { int n = 56 ; int k = 2 ; Console . WriteLine ( getNum ( n , k ) ) ; } }"}
{"text": "Pertanyaan untuk produk Factorial N First | C # pelaksanaan pendekatan; Mengisytiharkan hasil hasil di seluruh dunia; Berfungsi untuk precompute produk faktorial sehingga max; Inisialisasi keadaan asas jika n = 0 maka faktorial 0 adalah sama dengan 1 dan jawapan untuk n = 0 ialah 1; Gelung berulang dari 1 hingga max; faktorial (i) = factorial (i - 1) * i; Keputusan untuk n semasa adalah sama dengan hasil [i - 1] didarabkan oleh faktorial i; Berfungsi untuk melakukan pertanyaan; Precomputing hasil sehingga max; Melakukan pertanyaan; Kod pemacu", "code": "using System ; class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ; static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } static void performQueries ( int [ ] q , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) Console . WriteLine ( result [ q [ i ] ] ) ; } public static void Main ( String [ ] args ) { int [ ] q = { 4 , 5 } ; int n = q . Length ; performQueries ( q , n ) ; } }"}
{"text": "Nombor nth dalam satu set gandaan a, b atau c | C # Program untuk mencari istilah n divisible oleh a, b atau c; Berfungsi untuk mengembalikan GCD A dan B; Fungsi untuk mengembalikan kiraan bilangan bulat dari julat [1, num] yang boleh dibahagikan dengan sama ada A, B atau C; Kirakan bilangan istilah yang boleh dibahagi dengan A, B dan C kemudian keluarkan istilah yang boleh dibahagikan dengan kedua -dua (a, b) atau (b, c) atau (c, a) dan kemudian tambah nombor yang boleh dibahagikan dengan a, b dan c; Fungsi untuk carian binari untuk mencari istilah n yang boleh dibahagikan dengan a, b atau c; Tetapkan rendah hingga 1 dan tinggi ke long_max; Jika istilah semasa kurang daripada n maka kita perlu meningkat rendah hingga pertengahan + 1; Jika istilah semasa lebih besar daripada sama dengan n maka tinggi = pertengahan; Kod pemacu", "code": "using System ; class GFG { static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; } static long findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = long . MaxValue , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; } else { high = mid ; } } return low ; } public static void Main ( String [ ] args ) { int a = 2 , b = 3 , c = 5 , n = 100 ; Console . WriteLine ( findNthTerm ( a , b , c , n ) ) ; } }"}
{"text": "Sudut antara 3 simpang yang diberikan dalam n | C # pelaksanaan pendekatan; Fungsi yang memeriksa sama ada sudut yang diberikan boleh dibuat menggunakan mana -mana 3 sisi; Memulakan x dan y; Kirakan bilangan simpang antara i dan j, j dan k; Kirakan sudut yang diselaraskan di lilitan; Sudut yang diselaraskan di J boleh didapati menggunakan hakikat bahawa jumlah sudut segitiga adalah sama dengan 180 darjah; Kod pemacu", "code": "using System ; class GFG { static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } public static void Main ( ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; Console . WriteLine ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }"}
{"text": "Kerugian apabila dua item dijual pada harga yang sama dan keuntungan / kerugian peratusan yang sama | C # Pelaksanaan pendekatan di atas. ; Fungsi yang akan mendapati kerugian; Kod pemacu; Fungsi panggilan", "code": "class GFG { static void Loss ( int SP , int P ) { double loss = 0 ; loss = ( double ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . Console . WriteLine ( \" Loss ▁ = ▁ \" + System . Math . Round ( loss , 3 ) ) ; } static void Main ( ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; } }"}
{"text": "Semak elemen array iaitu CO | C # pelaksanaan pendekatan; Menyimpan faktor utama terkecil untuk setiap nombor; Hash untuk menyimpan kiraan faktor utama; Fungsi untuk mengira SPF (faktor utama terkecil) untuk setiap nombor sehingga maxn; Menandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; Menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; Menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Berfungsi untuk menyimpan faktor utama selepas membahagikan faktor utama terkecil di setiap langkah; Menyimpan kiraan faktor utama dalam hash; Fungsi yang mengembalikan benar jika tidak ada faktor utama yang sama antara x dan nombor array lain; Memeriksa sama ada faktor utama yang biasa dengan nombor lain; Fungsi yang mengembalikan benar jika terdapat elemen dalam array yang coprime dengan semua elemen lain dari array; Menggunakan ayak untuk menjana faktor utama; Memeriksa faktor utama biasa dengan nombor lain; Kod pemacu", "code": "using System ; class GFG { static int MAXN = 1000001 ; static int [ ] spf = new int [ MAXN ] ; static int [ ] hash1 = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } static bool check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } static bool hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } static void Main ( ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . Length ; if ( hasValidNum ( arr , n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Cara untuk mengeluarkan tepi dari graf lengkap untuk membuat tepi ganjil | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk mengeluarkan tepi dari graf supaya bilangan tepi yang ganjil ditinggalkan dalam graf; Jumlah bilangan tepi; Kod pemacu", "code": "using System ; public class GFG { static int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . Pow ( 2 , E - 1 ) ; } static public void Main ( ) { int N = 4 ; Console . WriteLine ( countWays ( N ) ) ; } }"}
{"text": "Hitung NCR Menggunakan Segitiga Pascal | C # pelaksanaan pendekatan; Memulakan matriks dengan 0; 0 C0 = 1; Tetapkan setiap NCR = 1 di mana r = 0; Nilai untuk sel semasa segitiga Pascal; Berfungsi untuk mengembalikan nilai NCR; Kembali NCR; Kod pemacu; Bina Segitiga Pascal", "code": "using System ; class GFG { static int [ , ] l = new int [ 1001 , 1001 ] ; static void initialize ( ) { l [ 0 , 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i , 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i , j ] = ( l [ i - 1 , j - 1 ] + l [ i - 1 , j ] ) ; } } } static int nCr ( int n , int r ) { return l [ n , r ] ; } public static void Main ( ) { initialize ( ) ; int n = 8 ; int r = 3 ; Console . WriteLine ( nCr ( n , r ) ) ; } }"}
{"text": "Partition Jumlah Paling Berdekatan (ke dalam dua subset) nombor dari 1 hingga N | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan perbezaan mutlak yang diperlukan minimum; Kod pemacu", "code": "using System ; class GFG { static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( minAbsDiff ( n ) ) ; } }"}
{"text": "Semak sama ada xor kekerapan semua digit nombor n adalah sifar atau tidak | C # pelaksanaan pendekatan di atas; mewujudkan pelbagai frekuensi; Mencari digit terakhir nombor; Membahagikan nombor dengan 10 untuk menghapuskan digit terakhir; kekerapan mengira setiap digit; Memeriksa jika XOR semua kekerapan adalah sifar atau tidak; Kod pemacu", "code": "using System ; class GFG { static bool check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; } public static void Main ( ) { int s = 122233 ; if ( check ( s ) ) Console . Write ( \" Yes STRNEWLINE \" ) ; else Console . Write ( \" No STRNEWLINE \" ) ; } }"}
{"text": "Cetak garis n 4 nombor supaya setiap pasangan di antara 4 nombor mempunyai gcd k | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencetak garis N; Iterat n kali untuk mencetak garis n; Kod pemacu", "code": "using System ; class GFG { static void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { Console . WriteLine ( k * ( 6 * i + 1 ) + \" ▁ \" + k * ( 6 * i + 2 ) + \" ▁ \" + k * ( 6 * i + 3 ) + \" ▁ \" + k * ( 6 * i + 5 ) ) ; } } public static void Main ( ) { int n = 2 , k = 2 ; printLines ( n , k ) ; } }"}
{"text": "Jumlah pertama N Siri 3, 5, 9, 17, 33 ... | C # Program untuk mencari jumlah terma pertama N; Sn = n * (4 * n * n + 6 * n - 1) / 3; Kod pemacu; bilangan terma yang akan dimasukkan dalam jumlah; Cari SN", "code": "using System ; class GFG { static int calculateSum ( int n ) { return ( ( int ) Math . Pow ( 2 , n + 1 ) + n - 2 ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( \" Sum ▁ = ▁ \" + calculateSum ( n ) ) ; } }"}
{"text": "Kira bilangan rentetan khas panjang n | C # program untuk mengira bilangan rentetan khas panjang n; Berfungsi untuk mengembalikan kiraan rentetan khas; Menyimpan jawapan untuk nilai tertentu n; Untuk n = 0 kita mempunyai rentetan kosong; Untuk n = 1 kita mempunyai 2 rentetan khas; Hitung kiraan rentetan panjang panjang i; Fib [n] menyimpan kiraan rentetan khas panjang n; Kod pemacu; Permulaan n", "code": "using System ; class GFG { const int mod = 1000000007 ; static int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } public static void Main ( ) { int n = 3 ; Console . Write ( count_special ( n ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Mengira laluan dalam array | C # pelaksanaan pendekatan di atas; Cari bilangan cara untuk mencapai akhir; Kes asas; Struktur rekursif; Kod pemacu", "code": "using System ; class GFG { static int mod = 1000000000 ; static int ways ( int i , int [ ] arr , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . Length ; Console . WriteLine ( ways ( 0 , arr , n ) ) ; } }"}
{"text": "Mengira laluan dalam array | C # pelaksanaan pendekatan di atas; Cari bilangan cara untuk mencapai akhir; DP untuk menyimpan nilai; Kes asas; Bawah struktur DP; F [i] bergantung kepada F [i + 1] ke F [i + k]; Nilai pulangan DP [0]; Kod pemacu", "code": "using System ; class GFG { static readonly int mod = ( int ) ( 1e9 + 7 ) ; static int ways ( int [ ] arr , int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . Length ; Console . WriteLine ( ways ( arr , n ) % mod ) ; } }"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | C # Program untuk mendapatkan kos minimum untuk menyusun rentetan dengan operasi pembalikan; Mengembalikan kiraan ganjil dan bahkan seterusnya; Pembolehubah untuk menyimpan kiraan bahkan seterusnya dan berikutnya yang ganjil; Inisialisasi count_even dan count_odd hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan yang lebih baik atau ganjil. ; Cari jumlah semua berikutnya dengan mengira dan mengira ganjil dan menyimpannya semasa kami melangkah. ; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu; Memanggil fungsi", "code": "using System ; class GFG { public class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair countSum ( int [ ] arr , int n ) { int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 2 , 3 } ; int n = arr . Length ; pair ans = countSum ( arr , n ) ; Console . Write ( \" EvenSum ▁ = ▁ \" + ans . first ) ; Console . Write ( \" ▁ OddSum ▁ = ▁ \" + ans . second ) ; } }"}
{"text": "Count integer panjang n dan nilai kurang daripada k sehingga ia mengandungi digit hanya dari set yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk menukar nombor menjadi vektor; Tolak semua digit n dari akhir satu demi satu ke vektor; Jika nombor asalnya adalah 0; Membalikkan elemen vektor; Mengembalikan vektor yang diperlukan; Berfungsi untuk mengembalikan bilangan bilangan bulat panjang b yang kurang daripada c dan mereka mengandungi digit dari set a [] sahaja; Menukar nombor ke array digit; Kes 1: Tidak ada bilangan sedemikian mungkin kerana nombor yang dihasilkan akan selalu lebih besar daripada C; Kes 2: Semua bilangan bulat panjang B adalah sah kerana mereka semua kurang daripada C; mengandungi 0; Kes 3; Kemas kini array yang lebih rendah [seperti yang lebih rendah [i] menyimpan kiraan unsur -unsur dalam [] yang kurang daripada saya; Untuk indeks pertama kita tidak boleh menggunakan 0; Sama ada (i - 1) digit nombor yang dihasilkan boleh sama dengan (i - 1) digit C; Adakah digit [i - 1] hadir dalam A? ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 10 ; static List < int > numToVec ( int N ) { List < int > digit = new List < int > ( ) ; while ( N != 0 ) { digit . Add ( N % 10 ) ; N = N / 10 ; } if ( digit . Count == 0 ) digit . Add ( 0 ) ; digit . Reverse ( ) ; return digit ; } static int solve ( List < int > A , int B , int C ) { List < int > digit = new List < int > ( ) ; int d , d2 ; digit = numToVec ( C ) ; d = A . Count ; if ( B > digit . Count d == 0 ) return 0 ; else if ( B < digit . Count ) { if ( A [ 0 ] == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . Pow ( d , B - 1 ) ) ; else return ( int ) Math . Pow ( d , B ) ; } else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; Boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 2 , 5 } ; List < int > A = new List < int > ( arr ) ; int N = 2 ; int k = 21 ; Console . WriteLine ( solve ( A , N , k ) ) ; } }"}
{"text": "Bilangan jalur berat w dalam k | C # Program untuk mengira bilangan laluan dengan berat w dalam pokok k - ary; Berfungsi untuk mengembalikan bilangan cara yang mempunyai berat badan sebagai wt dalam pokok k - ary; Kembali 0 jika berat menjadi kurang daripada sifar; Kembali hanya jika laluan semasa telah memasukkan berat kelebihan mehaum m; Jika berat tepi semasa lebih besar daripada atau sama dengan m, set digunakan sebagai benar; Kod pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { public static int solve ( int [ , ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used == 1 ) return 1 ; return 0 ; } if ( dp [ wt , used ] != - 1 ) return dp [ wt , used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt , used ] = ans ; } static void Main ( ) { int W = 3 , K = 3 , M = 2 ; int [ , ] dp = new int [ W + 1 , 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) dp [ i , j ] = - 1 ; Console . Write ( solve ( dp , W , K , M , 0 ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Cara Menulis N sebagai Jumlah Dua atau Lebih Integer Positif | Set | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan partition n; Kes asas; Kod pemacu", "code": "using System ; class GFG { static long partitions ( int n ) { long [ ] p = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } public static void Main ( String [ ] args ) { int N = 20 ; Console . WriteLine ( partitions ( N ) ) ; } }"}
{"text": "Laluan Terpanjang dalam Matriks | C # Program untuk mencari jalan yang paling lama dalam matriks. ; Kembalikan panjang bibir dalam matriks 2D; Jika nilai belum dikira. ; Jika mencapai sel kiri bawah, kembali 1 .; Jika sampai ke sudut matriks. ; Jika nilai lebih besar daripada sel bawah. ; Jika nilai lebih besar daripada sel kiri. ; Fungsi pembalut; Kod pemacu", "code": "using System ; public class GFG { static int LIP ( int [ , ] dp , int [ , ] mat , int n , int m , int x , int y ) { if ( dp [ x , y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x , y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x , y ] < mat [ x + 1 , y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x , y ] < mat [ x , y + 1 ] ) result = Math . Max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x , y ] = result ; } return dp [ x , y ] ; } static int wrapper ( int [ , ] mat , int n , int m ) { int [ , ] dp = new int [ 10 , 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { dp [ i , j ] = - 1 ; } } return LIP ( dp , mat , n , m , 0 , 0 ) ; } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; Console . WriteLine ( wrapper ( mat , n , m ) ) ; } }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | C # Program untuk mengira jumlah laluan dari titik ke asal; Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu", "code": "using System ; public class GFG { static int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } public static void Main ( ) { int n = 3 , m = 2 ; Console . WriteLine ( \" ▁ Number ▁ of \" + \" ▁ Paths ▁ \" + countPaths ( n , m ) ) ; } }"}
{"text": "Masalah Tambang Emas | C # Program untuk menyelesaikan masalah lombong emas; Mengembalikan jumlah maksimum emas yang boleh dikumpulkan apabila perjalanan bermula dari lajur pertama dan bergerak yang dibenarkan adalah betul, kanan dan kanan - ke bawah; Buat jadual untuk menyimpan hasil pertengahan dan memulakan semua sel ke 0. Baris pertama Goldminetable memberikan emas maksimum yang dapat dikumpulkan oleh pelombong ketika memulakan baris itu; Emas yang dikumpulkan pergi ke sel di sebelah kanan ( ->); Emas yang dikumpulkan untuk pergi ke sel untuk ke atas ( /); Emas yang dikumpulkan untuk pergi ke sel ke kanan (\\); Max Gold yang dikumpulkan daripada mengambil salah satu daripada 3 laluan di atas; Jumlah maksimum emas yang dikumpulkan akan menjadi nilai maksimum dalam lajur pertama semua baris; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100 ; static int getMaxGold ( int [ , ] gold , int m , int n ) { int [ , ] goldTable = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) goldTable [ i , j ] = 0 ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row , col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 , col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 , col + 1 ] ; goldTable [ row , col ] = gold [ row , col ] + Math . Max ( right , Math . Max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 , 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . Max ( res , goldTable [ i , 0 ] ) ; return res ; } static void Main ( ) { int [ , ] gold = new int [ , ] { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; Console . Write ( getMaxGold ( gold , m , n ) ) ; } }"}
{"text": "Cari Kos Pelarasan Minimum Array | C # Program untuk mencari kos pelarasan minimum array; Fungsi untuk mencari kos pelarasan minimum array; dp [i] [j] menyimpan kos pelarasan minimum untuk menukar [i] ke j; mengendalikan elemen pertama array secara berasingan; lakukan untuk elemen rehat array; Gantikan [i] ke J dan hitung kos pelarasan minimum DP [i] [J]; memulakan kos pelarasan minimum kepada int_max; Pertimbangkan semua k sedemikian rupa sehingga k> = max (j - sasaran, 0) dan k <= min (m, j + sasaran) dan ambil minimum; pulangan nilai minimum dari baris terakhir jadual DP; Program Pemandu", "code": "using System ; class GFG { public static int M = 100 ; static int minAdjustmentCost ( int [ ] A , int n , int target ) { int [ , ] dp = new int [ n , M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 , j ] = Math . Abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i , j ] = int . MaxValue ; int k = Math . Max ( j - target , 0 ) ; for ( ; k <= Math . Min ( M , j + target ) ; k ++ ) dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ i - 1 , k ] + Math . Abs ( A [ i ] - j ) ) ; } } int res = int . MaxValue ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . Min ( res , dp [ n - 1 , j ] ) ; return res ; } public static void Main ( ) { int [ ] arr = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = arr . Length ; int target = 10 ; Console . WriteLine ( \" Minimum ▁ adjustment \" + \" ▁ cost ▁ is ▁ \" + minAdjustmentCost ( arr , n , target ) ) ; } }"}
{"text": "Kira tiga kali ganda dari julat tertentu yang mempunyai jumlah dua nombor triplet yang sama dengan nombor ketiga | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda dari julat [l, r] yang mempunyai jumlah dua nombor dari triplet yang sama dengan nombor ketiga; Menyimpan jumlah tiga tiga; Cari perbezaan julat; Kes 1: Jika tiga kali boleh dibentuk, maka kembali 0; Jika tidak; Mengemas kini jumlah tiga kali ganda; Mengembalikan kiraan; Kod pemacu", "code": "using System ; class GFG { static int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } public static void Main ( ) { int L = 2 , R = 6 ; Console . WriteLine ( totalCombination ( L , R ) ) ; } }"}
{"text": "Bina Dua N | C # Program untuk pendekatan di atas; Memenuhi syarat yang diberikan; Mengisytiharkan kedua -dua array A dan B; Berulang dari julat [1, 2 * n]; Berikan nombor berturut -turut kepada indeks yang sama dari kedua -dua tatasusunan; Cetak array pertama; Cetak array kedua, b; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void printArrays ( int n ) { List < int > A = new List < int > ( ) ; List < int > B = new List < int > ( ) ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . Add ( i ) ; else B . Add ( i ) ; } Console . Write ( \" { ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( A [ i ] ) ; if ( i != n - 1 ) Console . Write ( \" , ▁ \" ) ; } Console . Write ( \" ▁ } STRNEWLINE \" ) ; Console . Write ( \" { ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( B [ i ] ) ; if ( i != n - 1 ) Console . Write ( \" , ▁ \" ) ; } Console . Write ( \" ▁ } \" ) ; } public static void Main ( ) { int N = 5 ; printArrays ( N ) ; } }"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit a dan b yang ditetapkan bit dalam a dan b; Iterater semua bit mungkin a dan b; Jika ia bit ditetapkan dalam kedua -dua A dan B; Jelas i - th bit a; Jelas i - th bit b; Cetak A dan B; Kod pemacu", "code": "using System ; class GFG { static void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } Console . Write ( A + \" ▁ \" + B ) ; } public static void Main ( string [ ] args ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; } }"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | C # Pelaksanaan untuk mencari kiraan jumlah pasangan yang berbeza antara dua array nilai 1 hingga N; Berfungsi untuk mencari jumlah yang berbeza; Kod pemacu", "code": "using System ; class GFG { static int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } public static void Main ( ) { int N = 3 ; Console . Write ( findDistinctSums ( N ) ) ; } }"}
{"text": "Count Substrings Dari Diberi String Ternary yang Mengandungi Karakter Sekurang -kurangnya sekali | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan substrings terdiri daripada 0, 1, dan 2; Memulakan pelbagai frekuensi saiz 3; Menyimpan kiraan yang dihasilkan; Traversing string str; Arahan kekerapan kemas kini; Jika semua watak hadir mengira bilangan substrings mungkin; Kemas kini bilangan substring; Mengembalikan bilangan substring; Kod pemacu", "code": "using System ; class GFG { public static int countSubstrings ( string str ) { int [ ] freq = new int [ 3 ] ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . Length ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; } public static void Main ( String [ ] args ) { string str = \"00021\" ; Console . Write ( countSubstrings ( str ) ) ; } }"}
{"text": "FLIPS MINIMUM UNTUK MENGURANGKAN SEBARANG TERBUKA 3 0 S atau 1 S DALAM RENCEN BINARY YANG DIPERLUKAN | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum flip untuk membuat ketiga -tiga pasang aksara berturut -turut berbeza; Kedai -kedai yang dihasilkan pasangan pasangan; Kes asas; Melangkah ke atas julat [0, n - 2]; Jika nombor 3 berturut -turut adalah sama maka kenaikan kiraan dan kaunter; Kembalikan jawapannya; Kod pemacu", "code": "using System ; public class GFG { static int minFlips ( string str ) { int count = 0 ; if ( str . Length <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . Length - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } public static void Main ( string [ ] args ) { string S = \"0011101\" ; Console . WriteLine ( minFlips ( S ) ) ; } }"}
{"text": "Menyulitkan rentetan | C # Program untuk pendekatan di atas; Berfungsi untuk menukar perpuluhan ke hex; Berfungsi untuk menyulitkan rentetan; Melepasi watak -watak rentetan; Iterat sehingga S [i] sama dengan CH; Kemas kini kiraan dan saya; Penurunan I oleh 1; Menukar kiraan kepada perwakilan heksadesimal; Tambah watak; Tambah kekerapan aksara dalam perwakilan heksadesimal; Membalikkan jawapan yang diperoleh; Mengembalikan jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; class GFG { static string convertToHex ( int num ) { string temp = \" \" ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp = temp + c ; num = num / 16 ; } return temp ; } static string encryptString ( string S , int N ) { string ans = \" \" ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S [ i ] ; int count = 0 ; string hex ; while ( i < N && S [ i ] == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans = ans + ch ; ans = ans + hex ; } char [ ] Ans = ans . ToCharArray ( ) ; Array . Reverse ( Ans ) ; ans = new string ( Ans ) ; return ans ; } static void Main ( ) { string S = \" abc \" ; int N = S . Length ; Console . WriteLine ( encryptString ( S , N ) ) ; } }"}
{"text": "Kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 s ~ melebihi »frekuensi ~» s | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Kirakan nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mengembalikan kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 's »s; Kiraan rentetan binari panjang n; Kiraan rentetan binari panjang n yang mempunyai kiraan yang sama dengan 0 dan 1 's; Untuk rentetan panjang; Kod pemacu", "code": "using System ; class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int countOfString ( int N ) { int Stotal = ( int ) Math . Pow ( 2 , N ) ; int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; } public static void Main ( String [ ] args ) { int N = 3 ; Console . Write ( countOfString ( N ) ) ; } }"}
{"text": "Keluarkan semua kejadian watak dalam rentetan | Pendekatan Rekursif | C # Program untuk pendekatan di atas; Berfungsi untuk menghapuskan semua kejadian watak dalam rentetan; Kes asas; Semak watak pertama rentetan yang diberikan; Lulus sisa rentetan ke panggilan fungsi rekursi; Tambah watak pertama STR dan String dari rekursi; Kod pemacu; Diberikan rentetan; Diberikan watak; Panggilan fungsi", "code": "using System ; class GFG { static String removeCharRecursive ( String str , char X ) { if ( str . Length == 0 ) { return \" \" ; } if ( str [ 0 ] == X ) { return removeCharRecursive ( str . Substring ( 1 ) , X ) ; } return str [ 0 ] + removeCharRecursive ( str . Substring ( 1 ) , X ) ; } public static void Main ( String [ ] args ) { String str = \" geeksforgeeks \" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; Console . WriteLine ( str ) ; } }"}
{"text": "Masa maksimum seperti perbezaan mutlak antara jam dan minit terletak pada julat yang diberikan | C # Program untuk pendekatan di atas; Pemeriksaan fungsi sama ada masa yang diberikan adalah betul; Untuk memeriksa nilai masa; Untuk memeriksa nilai jam masa; Perubahan nilai tidak dibenarkan di kedudukan di mana '? 'tidak hadir; Fungsi memeriksa sama ada perbezaan mutlak antara jam dan nilai minit berada dalam [l, r]; Cek jika perbezaan di luar julat memberi; Memaparkan masa dalam format 24 jam yang betul; Fungsi Cari nilai masa yang dikehendaki yang perbezaannya terletak dalam julat [l, r]; Menurunkan nilai jam dari 23 hingga 0; Semak jika nilai jam sah jika tidak sah maka tidak perlu menukar nilai minit, kerana masa masih akan sah, untuk memeriksa bendera nilai jam ditetapkan kepada 1 .; Mengurangkan nilai minit dari 59 hingga 0; Semak sama ada nilai minit sah, jika tidak sah kemudian langkau lelaran semasa, untuk memeriksa bendera nilai 'minit' ditetapkan kepada 0 .; Kod pemacu; Masa input; Julat Perbezaan", "code": "using System ; class GFG { static bool isValid ( char a1 , char a2 , string str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != ' ? ' ) { return false ; } if ( v2 != a2 && v2 != ' ? ' ) { return false ; } return true ; } static bool inRange ( int hh , int mm , int L , int R ) { int a = Math . Abs ( hh - mm ) ; if ( a < L a > R ) { return false ; } return true ; } static void displayTime ( int hh , int mm ) { if ( hh > 10 ) { Console . Write ( hh + \" : \" ) ; } else if ( hh < 10 ) { Console . Write ( \"0\" + hh + \" : \" ) ; } if ( mm > 10 ) { Console . Write ( mm ) ; } else if ( mm < 10 ) { Console . Write ( \"0\" + mm ) ; } } static void maximumTimeWithDifferenceInRange ( string str , int L , int R ) { int i = 0 , j = 0 ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ; if ( ! isValid ( ( char ) h1 , ( char ) h2 , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ; if ( ! isValid ( ( char ) m1 , ( char ) m2 , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; } else { Console . WriteLine ( \" - 1\" ) ; } } static public void Main ( ) { string timeValue = \" ? ? : ? ? \" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; } }"}
{"text": "Semak jika rentetan boleh dibahagikan kepada substrings Palindromic panjang walaupun | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa string str boleh memecah rentetan ke dalam substrings palindromik panjang; Memulakan timbunan; Melelehkan rentetan; Jika watak I - tH adalah sama seperti di bahagian atas timbunan kemudian pop elemen atas; Lain -lain menolak watak semasa ke dalam timbunan; Sekiranya timbunan kosong, maka substrings palindromik mungkin; Lain tidak - mungkin; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static bool check ( String s , int n ) { Stack < int > st = new Stack < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( st . Count != 0 && st . Peek ( ) == s [ i ] ) st . Pop ( ) ; else st . Push ( s [ i ] ) ; } if ( st . Count == 0 ) { return true ; } else { return false ; } } public static void Main ( String [ ] args ) { String str = \" aanncddc \" ; int n = str . Length ; if ( check ( str , n ) ) { Console . Write ( \" Yes \" + \" STRNEWLINE \" ) ; } else { Console . Write ( \" No \" + \" STRNEWLINE \" ) ; } } }"}
{"text": "Bilangan rentetan dalam dua array memenuhi syarat -syarat yang diberikan | C # Program untuk pendekatan di atas; Untuk menyimpan kekerapan rentetan selepas bitmasking; Untuk menyimpan hasil untuk setiap rentetan dalam ARR2 []; Melintasi arr1 [] dan bitmask setiap rentetan di dalamnya; Bitmasking untuk setiap rentetan s; Kemas kini kekerapan rentetan dengan nilai bitmasking; Melintasi arr2 []; Bitmasking untuk setiap rentetan s; Periksa sama ada temp ada dalam unstered_map atau tidak; Semak bit set seterusnya; Tolak kiraan untuk rentetan semasa dalam array yang dihasilkan; Cetak kiraan untuk setiap rentetan; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void findNumOfValidWords ( List < String > w , List < String > p ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; List < int > res = new List < int > ( ) ; foreach ( String s in w ) { int val = 0 ; foreach ( char c in s . ToCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } if ( m . ContainsKey ( val ) ) m [ val ] = m [ val ] + 1 ; else m . Add ( val , 1 ) ; } foreach ( String s in p ) { int val = 0 ; foreach ( char c in s . ToCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s [ 0 ] - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . ContainsKey ( temp ) ) { count += m [ temp ] ; } } temp = ( temp - 1 ) & val ; } res . Add ( count ) ; } foreach ( int it in res ) { Console . WriteLine ( it ) ; } } public static void Main ( String [ ] args ) { List < String > arr1 = new List < String > ( ) ; arr1 . Add ( \" aaaa \" ) ; arr1 . Add ( \" asas \" ) ; arr1 . Add ( \" able \" ) ; arr1 . Add ( \" ability \" ) ; arr1 . Add ( \" actt \" ) ; arr1 . Add ( \" actor \" ) ; arr1 . Add ( \" access \" ) ; List < String > arr2 = new List < String > ( ) ; arr2 . Add ( \" aboveyz \" ) ; arr2 . Add ( \" abrodyz \" ) ; arr2 . Add ( \" absolute \" ) ; arr2 . Add ( \" absoryz \" ) ; arr2 . Add ( \" actresz \" ) ; arr2 . Add ( \" gaswxyz \" ) ; findNumOfValidWords ( arr1 , arr2 ) ; } }"}
{"text": "Memaksimumkan setara perpuluhan dengan membalikkan hanya satu set bersebelahan 0 S | C # Pelaksanaan untuk memaksimumkan nilai setara perpuluhan yang diberikan dalam bentuk binari; Berfungsi untuk mencetak nombor binari; Semak sama ada nombor semasa ialah 0; Cari 0 s berterusan; Gantikan pada mulanya berlaku 0 dengan 1; Keluar dari gelung jika 1 berlaku; Kod pemacu", "code": "using System ; class GFG { static String flip ( char [ ] s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } return new String ( s ) ; } public static void Main ( String [ ] args ) { String s = \"100010001\" ; Console . WriteLine ( flip ( s . ToCharArray ( ) ) ) ; } }"}
{"text": "Kes Kalimat Rentetan Camel yang Diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan asal selepas menukarnya dari unta; Cetak watak pertama seperti itu; Melintasi seluruh watak satu demi satu; Jika watak semasa adalah ruang cetak huruf besar diikuti oleh watak semasa dalam huruf kecil; Lain mencetak watak semasa; Kod pemacu", "code": "using System ; class GFG { static void getOrgString ( String s ) { Console . Write ( s [ 0 ] ) ; int i = 1 ; while ( i < s . Length ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) Console . Write ( \" ▁ \" + char . ToLower ( s [ i ] ) ) ; else Console . Write ( s [ i ] ) ; i ++ ; } } public static void Main ( String [ ] args ) { String s = \" ILoveGeeksForGeeks \" ; getOrgString ( s ) ; } }"}
{"text": "Kira kejadian watak dalam rentetan berulang | C # Program untuk mencari kejadian aksara x dalam rentetan berulang tak terhingga sehingga panjang n; Berfungsi untuk mengira watak 'A'; Atleast k pengulangan diperlukan; Jika n bukanlah pelbagai pemeriksaan saiz rentetan untuk watak berulang yang tersisa. ; Kod pemacu", "code": "using System ; class GFG { static int countChar ( string str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . Length ; count = count * repetitions ; for ( int i = 0 ; i < n % str . Length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; } public static void Main ( ) { string str = \" abcac \" ; Console . WriteLine ( countChar ( str , ' a ' ) ) ; } }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | C # Program untuk mengira frekuensi item array yang mempunyai nilai kecil. ; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi unsur -unsur array dan kekerapan kiraan (dengan mengandaikan bahawa unsur -unsur dibatasi oleh had); Kod pemacu", "code": "using System ; class GFG { static void countFreq ( int [ ] arr , int n , int limit ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) Console . WriteLine ( i + \" ▁ \" + count [ i ] ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = arr . Length ; int limit = 10 ; countFreq ( arr , n , limit ) ; } }"}
{"text": "Semak jika rentetan mempunyai m berturut -turut 1 's atau ~ 0' s | Program untuk memeriksa sama ada rentetan binari mengandungi m berturut -turut 1 's atau' s; Fungsi yang memeriksa jika rentetan binari mengandungi m berturut -turut 1 's atau' s; panjang rentetan binari; Count Zeros; Count 1 's; Count berturut -turut 0 's; Count berturut -turut 1 's; Kod pemacu; panggilan fungsi", "code": "using System ; class GFG { static bool check ( string s , int m ) { int l = s . Length ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } public static void Main ( ) { String s = \"001001\" ; int m = 2 ; if ( check ( s , m ) ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Produk nod di k | C # pelaksanaan untuk mencari produk digit elemen di peringkat k - th; Berfungsi untuk mencari produk digit elemen di peringkat k - th; Memulakan hasil; peningkatan bilangan tahap; mengurangkan nombor tahap; Periksa sama ada tahap semasa adalah tahap yang dikehendaki atau tidak; produk yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int productAtKthLevel ( string tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; } static void Main ( ) { string tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; Console . WriteLine ( productAtKthLevel ( tree , k ) ) ; } }"}
{"text": "Mengeluarkan baris atau lajur bijak pendua dari matriks aksara | C # kod untuk membentuk rentetan selepas mengeluarkan pendua dari baris dan lajur. ; Berfungsi untuk memeriksa pendua dalam baris dan lajur; Buat array ispresent dan mulakan semua penyertaannya sebagai palsu. Nilai ispresent [i, j] akan benar jika S [i, j] hadir dalam baris atau lajurnya. ; Memeriksa setiap baris untuk pendua [i, j]; Memeriksa setiap lajur untuk aksara pendua; Jika watak itu unik dalam baris dan lajurnya; Kod pemacu; pelbagai watak; Fungsi panggilan", "code": "using System ; class GFG { static void findDuplciates ( string [ ] a , int n , int m ) { bool [ , ] isPresent = new bool [ n , m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] [ j ] == a [ k ] [ j ] && i != k ) { isPresent [ i , j ] = true ; isPresent [ k , j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] [ j ] == a [ i ] [ k ] && j != k ) { isPresent [ i , j ] = true ; isPresent [ i , k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( ! isPresent [ i , j ] ) Console . Write ( a [ i ] [ j ] ) ; } static void Main ( ) { int n = 2 , m = 2 ; string [ ] a = new string [ ] { \" zx \" , \" xz \" } ; findDuplciates ( a , n , m ) ; } }"}
{"text": "Program untuk memeriksa ISBN | C # Program untuk memeriksa sama ada ISBN yang diberikan isvalid atau tidak. ; panjang mestilah 10; Pengkomputeran berjumlah 9 digit pertama; Memeriksa digit terakhir. ; Jika digit terakhir adalah 'x', tambahkan 10 hingga jumlah, tambah nilainya. ; Kembali benar jika jumlah digit berwajaran boleh dibahagikan dengan 11 .; Kod pemacu", "code": "using System ; class GFG { static bool isValidISBN ( string isbn ) { int n = isbn . Length ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } public static void Main ( ) { string isbn = \"007462542X \" ; if ( isValidISBN ( isbn ) ) Console . WriteLine ( \" Valid \" ) ; else Console . WriteLine ( \" Invalid \" ) ; } }"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | C # Program untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Menyimpan vokal secara berasingan; Meletakkan vokal dalam urutan terbalik dalam rentetan; Kod pemacu", "code": "using System ; class GFG { static bool isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } static String reverseVowel ( String str1 ) { int j = 0 ; char [ ] str = str1 . ToCharArray ( ) ; String vowel = \" \" ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { j ++ ; vowel += str [ i ] ; } } for ( int i = 0 ; i < str . Length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { str [ i ] = vowel [ -- j ] ; } } return String . Join ( \" \" , str ) ; } public static void Main ( String [ ] args ) { String str = \" hello ▁ world \" ; Console . WriteLine ( reverseVowel ( str ) ) ; } }"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | C # Program untuk mencari rentetan yang mengandungi watak pertama setiap perkataan rentetan lain. ; Fungsi untuk mencari rentetan yang mempunyai watak pertama setiap perkataan. ; Melintasi rentetan. ; Jika ia adalah ruang, tetapkan V sebagai benar. ; Lain semak jika v adalah benar atau tidak. Jika benar, salin watak dalam rentetan output dan tetapkan V sebagai palsu. ; Kod pemacu", "code": "using System ; class GFG { static String firstLetterWord ( String str ) { String result = \" \" ; bool v = true ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ▁ ' ) { v = true ; } else if ( str [ i ] != ' ▁ ' && v == true ) { result += ( str [ i ] ) ; v = false ; } } return result ; } public static void Main ( ) { String str = \" geeks ▁ for ▁ geeks \" ; Console . WriteLine ( firstLetterWord ( str ) ) ; } }"}
{"text": "Laluan unik yang meliputi setiap bukan | C # pelaksanaan pendekatan; Fungsi untuk DFS. i, j ==> indeks sel semasa vis ==> untuk menandakan sel -sel yang dikunjungi ans ==> hasil z ==> kiraan semasa 0 s yang dikunjungi z_count ==> total 0 s hadir; Tandakan blok seperti yang dikunjungi; mengemas kini kiraan; Jika blok akhir dicapai; Jika jalan meliputi semua blok bukan halangan; Naik; Ke bawah; Kiri; Betul; Unmark blok (Unvisited); Berfungsi untuk mengembalikan kiraan laluan unik; int z_count = 0; Jumlah 0 s hadir; Menghitung blok penghalang; Kedudukan permulaan; Kod pemacu", "code": "using System ; class GFG { static int ans = 0 ; static void dfs ( int i , int j , int [ , ] grid , bool [ , ] vis , int z , int z_count ) { int n = grid . GetLength ( 0 ) , m = grid . GetLength ( 1 ) ; vis [ i , j ] = true ; if ( grid [ i , j ] == 0 ) z ++ ; if ( grid [ i , j ] == 2 ) { if ( z == z_count ) ans ++ ; vis [ i , j ] = false ; return ; } if ( i >= 1 && ! vis [ i - 1 , j ] && grid [ i - 1 , j ] != - 1 ) dfs ( i - 1 , j , grid , vis , z , z_count ) ; if ( i < n - 1 && ! vis [ i + 1 , j ] && grid [ i + 1 , j ] != - 1 ) dfs ( i + 1 , j , grid , vis , z , z_count ) ; if ( j >= 1 && ! vis [ i , j - 1 ] && grid [ i , j - 1 ] != - 1 ) dfs ( i , j - 1 , grid , vis , z , z_count ) ; if ( j < m - 1 && ! vis [ i , j + 1 ] && grid [ i , j + 1 ] != - 1 ) dfs ( i , j + 1 , grid , vis , z , z_count ) ; vis [ i , j ] = false ; } static int uniquePaths ( int [ , ] grid ) { int n = grid . GetLength ( 0 ) , m = grid . GetLength ( 1 ) ; bool [ , ] vis = new bool [ n , m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { vis [ i , j ] = false ; } } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i , j ] == 0 ) z_count ++ ; else if ( grid [ i , j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; } static void Main ( ) { int [ , ] grid = { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , - 1 } } ; Console . WriteLine ( uniquePaths ( grid ) ) ; } }"}
{"text": "Kira pasangan yang tidak teratur (x, y) array yang memenuhi persamaan yang diberikan | C # Program untuk mencari bilangan pasangan yang tidak teratur (x, y) yang memenuhi persamaan yang diberikan untuk array; Mengembalikan bilangan pasangan yang tidak teratur yang memenuhi syarat; Ans menyimpan bilangan pasangan yang tidak teratur; Menjadikan setiap nilai array menjadi positif; Susun array; Bagi setiap indeks mengira sempadan yang betul untuk pasangan yang tidak teratur; Mengembalikan hasil akhir; Kod pemacu", "code": "using System ; class GFG { static int numPairs ( int [ ] a , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . Abs ( a [ i ] ) ; Array . Sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; } public static void Main ( ) { int [ ] a = new int [ ] { 3 , 6 } ; int n = a . Length ; Console . Write ( numPairs ( a , n ) ) ; } }"}
{"text": "Kawasan persegi | Menggunakan sisi, pepenjuru dan perimeter | C # Program untuk pendekatan di atas; Berfungsi untuk mencari kawasan persegi; Gunakan formula di atas; Kod pemacu; Diberikan sisi persegi; Panggilan fungsi", "code": "using System ; class GFG { static int areaOfSquare ( int S ) { int area = S * S ; return area ; } public static void Main ( string [ ] args ) { int S = 5 ; Console . Write ( areaOfSquare ( S ) ) ; } }"}
{"text": "Titik maksimum persimpangan yang mungkin di kalangan x lingkaran dan garis lurus y | C # Program untuk melaksanakan pendekatan di atas; Kod pemacu; Bilangan bulatan; Bilangan garis lurus; Panggilan fungsi", "code": "using System ; class GFG { static int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } public static void Main ( String [ ] args ) { int x = 3 ; int y = 4 ; Console . Write ( maxPointOfIntersection ( x , y ) ) ; } }"}
{"text": "Nombor Icosihenagonal | C # Program untuk mencari nombor icosihenagon nth; Berfungsi untuk mencari nombor icosihenagonal; Formula untuk mengira nombor icosihenagon nth; Kod pemacu", "code": "using System ; class GFG { static int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } public static void Main ( ) { int n = 3 ; Console . Write ( Icosihenagonal_num ( n ) + \" STRNEWLINE \" ) ; n = 10 ; Console . Write ( Icosihenagonal_num ( n ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Cari centroid bukan | C # pelaksanaan pendekatan; Untuk semua simpang; Hitung nilai menggunakan formula kasut; Mengira koordinat centroid poligon; Kod pemacu; Menyelaras simpul", "code": "using System ; class GFG { static double [ ] find_Centroid ( double [ , ] v ) { double [ ] ans = new double [ 2 ] ; int n = v . GetLength ( 0 ) ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i , 0 ] , y0 = v [ i , 1 ] ; double x1 = v [ ( i + 1 ) % n , 0 ] , y1 = v [ ( i + 1 ) % n , 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; } public static void Main ( String [ ] args ) { double [ , ] vp = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; double [ ] ans = find_Centroid ( vp ) ; Console . WriteLine ( ans [ 0 ] + \" ▁ \" + ans [ 1 ] ) ; } }"}
{"text": "Program untuk mencari sudut segiempat | C # pelaksanaan pendekatan; Kod pemacu; Menurut formula yang diperolehi di atas; Cetak semua sudut", "code": "using System ; class GFG { public static void Main ( ) { int d = 10 ; double a ; a = ( double ) ( 360 - ( 6 * d ) ) / 4 ; Console . WriteLine ( a + \" , ▁ \" + ( a + d ) + \" , ▁ \" + ( a + ( 2 * d ) ) + \" , ▁ \" + ( a + ( 3 * d ) ) ) ; } }"}
{"text": "Jarak antara dua pesawat selari dalam 3 | C # Program untuk mencari jarak antara dua pesawat selari dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu", "code": "using System ; class GFG { static void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { z1 = - d1 / c1 ; d = Math . Abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; Console . Write ( \" Perpendicular ▁ distance ▁ is ▁ \" + d ) ; } else Console . Write ( \" Planes ▁ are ▁ not ▁ parallel \" ) ; } public static void Main ( ) { float a1 = 1 ; float b1 = 2 ; float c1 = - 1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = - 3 ; float d2 = - 4 ; distance ( a1 , b1 , c1 , d1 ,"}
{"text": "Mengira cara untuk membentuk 2 kalung dari manik n yang mengandungi n / 2 manik masing -masing | C # Program untuk pendekatan di atas; Fungsi untuk mengira faktorial; Fungsi untuk mengira bilangan cara untuk membuat 2 kalung yang mempunyai manik N / 2 jika setiap manik dianggap berbeza; Bilangan cara untuk memilih manik n / 2 dari manik N; Bilangan cara untuk membekalkan manik n / 2; Bahagikan Ans oleh 2 untuk menghapuskan pengulangan; Kembali Ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static long numOfNecklace ( int N ) { long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; } static public void Main ( ) { int N = 4 ; Console . Write ( numOfNecklace ( N ) ) ; } }"}
{"text": "Semak jika nombor s boleh dibuat dibahagikan dengan d dengan berulang kali menambahkan selebihnya kepada s | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada S dibahagi dengan d semasa menukar s ke (s + s % d); V (0) = s % d; Menyimpan nilai yang ditemui; V (i) = (v (i - 1) + v (i - 1) % d) % d; Semak sama ada nilai telah ditemui; Kes tepi; Jika tidak, masukkannya ke dalam hashmap; Kod pemacu", "code": "using System ; using System . Linq ; using System . Collections . Generic ; class GFG { static string isDivisibleByDivisor ( int S , int D ) { S %= D ; List < int > hashMap = new List < int > ( ) ; ; hashMap . Add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . Contains ( S ) ) { if ( S == 0 ) { return \" Yes \" ; } return \" No \" ; } else hashMap . Add ( S ) ; } return \" Yes \" ; } static void Main ( ) { int S = 3 , D = 6 ; Console . Write ( isDivisibleByDivisor ( S , D ) ) ; } }"}
{"text": "Bilangan minimum bergerak yang diperlukan untuk mencapai (1, 1) dari (x, y) | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan langkah yang diperlukan untuk menukar (x, y) hingga (1, 1); Simpan hasil yang diperlukan; Melangkah sementara kedua -dua x dan y tidak sama dengan 0; Jika x lebih besar daripada y; Kemas kini kiraan dan nilai x; Jika tidak; Kemas kini kiraan dan nilai y; Jika kedua -dua x dan y> 1; Cetak hasilnya; Kod pemacu; Diberikan x dan y", "code": "using System ; class GFG { public static void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; Console . WriteLine ( cnt ) ; } public static void Main ( ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; } }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | C # kod untuk mengira pembalikan minimum untuk membuat ekspresi seimbang. ; Kaedah mengira pembalikan minimum untuk membuat ungkapan seimbang. Pulangan - 1 jika ungkapan tidak boleh seimbang; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Selepas gelung ini, timbunan mengandungi bahagian ekspresi yang tidak seimbang, i. e. , ungkapan bentuk \"}}.} {{.. {\"; Panjang ekspresi yang dikurangkan red_len = (m + n); mengira kurungan pembukaan pada akhir timbunan; Kembali Ceil (m / 2) + Ceil (n / 2) yang sebenarnya sama dengan (m + n) / 2 + n % 2 apabila m + n juga. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static int countMinReversals ( string expr ) { int len = expr . Length ; if ( len % 2 != 0 ) { return - 1 ; } Stack < char > s = new Stack < char > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr [ i ] ; if ( c == ' } ' && s . Count > 0 ) { if ( s . Peek ( ) == ' { ' ) { s . Pop ( ) ; } else { s . Push ( c ) ; } } else { s . Push ( c ) ; } } int red_len = s . Count ; int n = 0 ; while ( s . Count > 0 && s . Peek ( ) == ' { ' ) { s . Pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } public static void Main ( string [ ] args ) { string expr = \" } } { { \" ; Console . WriteLine ( countMinReversals ( expr ) ) ; } }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | C # kod untuk mengira pembalikan minimum untuk membuat ekspresi seimbang. ; Kaedah mengira pembalikan minimum untuk membuat ungkapan seimbang. Pulangan - 1 jika ungkapan tidak boleh seimbang; Ekspresi panjang ganjil tidak boleh seimbang; Jika kita menemui pendakap kiri maka kita hanya menambah kurungan kiri; Lain jika pendakap kiri adalah 0 maka kita dapati pendakap kanan yang tidak seimbang dan pendakap kanan kenaikan atau jika ungkapan seimbang maka kita menurunkan kiri; Kaedah Pemandu", "code": "using System ; public class GFG { static int countMinReversals ( String expr ) { int len = expr . Length ; int ans ; if ( len % 2 != 0 ) { return - 1 ; } int left_brace = 0 , right_brace = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = expr [ i ] ; if ( ch == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ( int ) ( Math . Ceiling ( ( 0.0 + left_brace ) / 2 ) + Math . Ceiling ( ( 0.0 + right_brace ) / 2 ) ) ; return ans ; } public static void Main ( String [ ] args ) { String expr = \" } } { { \" ; Console . WriteLine ( countMinReversals ( expr ) ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | C # Program untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Mencetak nombor minimum yang boleh dibentuk dari urutan input i dan u; Inisialisasi Current_Max (untuk memastikan bahawa kita tidak menggunakan watak berulang; permulaan last_entry (menjejaki angka bercetak terakhir); beralih ke atas array input; memulakan 'noofnextd' untuk mendapatkan kiraan d berikut yang tersedia; Cetak angka untuk saya", "code": "using System ; class GFG { static void PrintMinNumberForPattern ( String arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int noOfNextD = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( j < arr . Length && arr [ j ] == ' D ' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; Console . Write ( \" ▁ \" + ++ last_entry ) ; Console . Write ( \" ▁ \" + curr_max ) ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; Console . Write ( \" ▁ \" + last_entry ) ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { Console . Write ( \" ▁ \" + -- last_entry ) ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( j < arr . Length && arr [ j ] == ' D ' ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; Console . Write ( \" ▁ \" + curr_max + \" ▁ \" + ( curr_max - 1 ) ) ; last_entry = curr_max - 1 ; } else { Console . Write ( \" ▁ \" + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | C # Program untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; min_avail mewakili nombor minimum yang masih tersedia untuk memasukkan dalam vektor output. pos_of_i menjejaki indeks paling terkini di mana 'i' ditemui w. r. t vektor output; vektor untuk menyimpan output; meliputi kes asas; Melintasi sisa input; Cetak nombor; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void printLeast ( String arr ) { int min_avail = 1 , pos_of_I = 0 ; List < int > al = new List < int > ( ) ; if ( arr [ 0 ] == ' I ' ) { al . Add ( 1 ) ; al . Add ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { al . Add ( 2 ) ; al . Add ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . Length ; i ++ ) { if ( arr [ i ] == ' I ' ) { al . Add ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { al . Add ( al [ i ] ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) al [ j ] = al [ j ] + 1 ; min_avail ++ ; } } for ( int i = 0 ; i < al . Count ; i ++ ) Console . Write ( al [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { printLeast ( \" IDID \" ) ; printLeast ( \" I \" ) ; printLeast ( \" DD \" ) ; printLeast ( \" II \" ) ; printLeast ( \" DIDI \" ) ; printLeast ( \" IIDDD \" ) ; printLeast ( \" DDIDDIID \" ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | C # Program untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Fungsi untuk menyahkod urutan yang diberikan untuk membina nombor minimum tanpa digit berulang; Hasil Store Output String; Buat timbunan integer kosong; Jalankan n + 1 kali di mana n adalah panjang urutan input; Tekan nombor I + 1 ke dalam timbunan; Jika semua aksara urutan input diproses atau watak semasa adalah 'I' (meningkat); Jalankan sehingga timbunan kosong; Keluarkan elemen teratas dari timbunan dan tambahkannya ke penyelesaian; fungsi utama", "code": "using System ; using System . Collections ; public class GFG { static void PrintMinNumberForPattern ( String seq ) { String result = \" \" ; Stack stk = new Stack ( ) ; for ( int i = 0 ; i <= seq . Length ; i ++ ) { stk . Push ( i + 1 ) ; if ( i == seq . Length seq [ i ] == ' I ' ) { while ( stk . Count != 0 ) { result += String . Join ( \" \" , stk . Peek ( ) ) ; result += \" ▁ \" ; stk . Pop ( ) ; } } } Console . WriteLine ( result ) ; } public static void Main ( ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | C # Program pendekatan di atas; Mengembalikan nombor minimum yang dibuat dari urutan yang diberikan tanpa mengulangi digit; Gelung berjalan untuk setiap aksara input serta satu masa tambahan untuk memberikan pangkat kepada setiap aksara yang tinggal; Kod pemacu", "code": "using System ; class GFG { static String getMinNumberForPattern ( String seq ) { int n = seq . Length ; if ( n >= 9 ) return \" - 1\" ; char [ ] result = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return new String ( result ) ; } public static void Main ( ) { String [ ] inputs = { \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" } ; foreach ( String input in inputs ) { Console . WriteLine ( getMinNumberForPattern ( input ) ) ; } } }"}
{"text": "Semak jika digit pertama dan terakhir nombor terkecil membentuk Perdana | C # pelaksanaan pendekatan di atas; berfungsi untuk memeriksa perdana; Berfungsi untuk menghasilkan nombor yang paling kecil dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam urutan menaik untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; mengekstrak digit pertama; mengekstrak digit terakhir; mencetak kombinasi utama; Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) { c ++ ; } } if ( c == 1 ) { return true ; } else { return false ; } } static void findMinNum ( int [ ] arr , int n ) { int first = 0 , last = 0 , num , rev , i ; int [ ] hash = new int [ 10 ] ; for ( i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } Console . Write ( \" Minimum ▁ number : ▁ \" ) ; for ( i = 0 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { Console . Write ( i ) ; } } Console . WriteLine ( ) ; Console . WriteLine ( ) ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } } for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ; Console . Write ( \" Prime ▁ combinations : ▁ \" ) ; if ( isPrime ( num ) && isPrime ( rev ) ) { Console . WriteLine ( num + \" ▁ \" + rev ) ; } else if ( isPrime ( num ) ) { Console . WriteLine ( num ) ; } else if ( isPrime ( rev ) ) { Console . WriteLine ( rev ) ; } else { Console . WriteLine ( \" No ▁ combinations ▁ exist \" ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 7 , 8 } ; findMinNum ( arr , 5 ) ; } }"}
{"text": "Mencari Co Transitif | C # Program untuk mencari kemungkinan triplets bukan transitif btw l dan r; Berfungsi untuk mengembalikan GCD A dan B; berfungsi untuk memeriksa GCD; A dan B adalah coprime jika GCD mereka adalah 1; Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Menjana dan menyemak semua kemungkinan tiga kali ganda antara L dan R; Jika kita dapati apa -apa tiga kali ganda menetapkan bendera kepada benar; Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static bool coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; } static void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) { if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } } if ( flag == true ) { Console . WriteLine ( \" ( \" + possibleA + \" , ▁ \" + possibleB + \" , ▁ \" + possibleC + \" ) \" + \" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ \" + \" between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } else { Console . WriteLine ( \" No ▁ Such ▁ Triplet ▁ exists \" + \" between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } } public static void Main ( ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }"}
{"text": "Jangkau A dan B dengan mengalikannya dengan k dan k ^ 2 pada setiap langkah | C # Program untuk menentukan sama ada A dan B boleh dicapai bermula dari 1, 1 berikutan langkah -langkah yang diberikan. ; Fungsi untuk memeriksa adalah mungkin untuk mencapai A dan B bermula dari 1 dan 1; Cari cuberoot nombor; Bahagikan nombor dengan Cuberoot; Jika ia adalah cuberoot yang sempurna dan membahagikan A dan B; Kod pemacu", "code": "using System ; public class GFG { public static bool possibleToReach ( int a , int b ) { int c = ( int ) Math . Pow ( a * b , ( double ) 1 / 3 ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } static public void Main ( String [ ] args ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Nombor bergelora | C # Program untuk memeriksa sama ada nombor beralun atau tidak; Memandangkan definisi dengan sekatan bahawa terdapat sekurang -kurangnya 3 digit; Semak sama ada semua digit alternatif adalah sama atau tidak. ; Kod pemacu", "code": "using System ; class GFG { public static bool isUndulating ( string n ) { if ( n . Length <= 2 ) return false ; for ( int i = 2 ; i < n . Length ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) return false ; return true ; } public static void Main ( ) { string n = \"1212121\" ; if ( isUndulating ( n ) == true ) Console . WriteLine ( \" yes \" ) ; else Console . WriteLine ( \" no \" ) ; } }"}
{"text": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | C # Program untuk mengira siri berikut; Fungsi untuk mengira siri berikut; Kod pemacu", "code": "using System ; class GFG { static int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } public static void Main ( ) { int n = 3 ; int res = Series ( n ) ; Console . Write ( res ) ; } }"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program Java yang cekap untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Fungsi pemacu", "code": "using System ; public class GfG { public static int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * Convert . ToInt32 ( Math . Ceiling ( low / 10.0 ) ) ; int mhigh = 10 * Convert . ToInt32 ( Math . Floor ( high / 10.0 ) ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; } public static void Main ( ) { int low = 3 , high = 35 , k = 3 ; Console . WriteLine ( counLastDigitK ( low , high , k ) ) ; } }"}
{"text": "Jumlah semua nombor yang boleh dibahagikan dengan 6 dalam julat yang diberikan | C # Program untuk mencari jumlah nombor yang boleh dibahagi dengan 6 dalam julat tertentu. ; fungsi untuk mengira jumlah semua nombor yang boleh dibahagi dengan 6 dalam julat l - r. . ; tidak ada gandaan 6 sehingga r; tiada gandaan 6 sehingga l - 1; penjumlahan semua gandaan 6 sehingga r; penjumlahan semua gandaan 6 sehingga l - 1; mengembalikan jawapannya; Program Pemandu", "code": "using System ; class GFG { static int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } public static void Main ( ) { int L = 1 , R = 20 ; Console . WriteLine ( sum ( L , R ) ) ; } }"}
{"text": "Nombor yang lebih kecil yang terbesar mungkin menggunakan hanya satu operasi swap | C # Program untuk mencari nombor yang lebih kecil dengan menukar satu digit. ; Mengembalikan nombor yang mungkin terbesar dengan satu swap supaya nombor itu lebih kecil daripada STR. Dianggap bahawa terdapat 0 s. ; Traverse dari kanan sehingga kita dapati digit yang lebih besar daripada digit seterusnya. Sebagai contoh, dalam 34125, indeks kami ialah 4 .; Kami juga boleh menggunakan carian binari di sini sebagai digit selepas indeks disusun dalam peningkatan urutan. Cari digit terbesar di sebelah kanan ARR [indeks] yang lebih kecil daripada ARR [indeks]; Jika indeks adalah - 1 i. e. Digit adalah dalam urutan yang semakin meningkat. ; Menukar kedua -dua nilai; Kod pemacu", "code": "using System ; class GFG { static String prevNum ( String str ) { int len = str . Length ; int index = - 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { index = i ; break ; } } int smallGreatDgt = - 1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str [ i ] < str [ index ] ) { if ( smallGreatDgt == - 1 ) { smallGreatDgt = i ; } else if ( str [ i ] >= str [ smallGreatDgt ] ) { smallGreatDgt = i ; } } } if ( index == - 1 ) { return \" - 1\" ; } if ( smallGreatDgt != - 1 ) { str = swap ( str , index , smallGreatDgt ) ; return str ; } return \" - 1\" ; } static String swap ( String str , int i , int j ) { char [ ] ch = str . ToCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . Join ( \" \" , ch ) ; } public static void Main ( String [ ] args ) { String str = \"34125\" ; Console . WriteLine ( prevNum ( str ) ) ; } }"}
{"text": "SGN Nilai polinomial | C # Program untuk mencari nilai tanda polinomial; Pulangan nilai poli [0] x (n - 1) + poli [1] x (n - 2) +. . + poli [n - 1]; Memulakan hasil; Menilai nilai polinomial menggunakan kaedah Horner; Mengembalikan nilai tanda polinomial; Kod pemacu; Marilah kita menilai nilai 2 x3 - 6 x2 + 2 x - 1 untuk x = 3", "code": "using System ; class GFG { static int horner ( int [ ] poly , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; } static int findSign ( int [ ] poly , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; } public static void Main ( ) { int [ ] poly = { 2 , - 6 , 2 , - 1 } ; int x = 3 ; int n = poly . Length ; Console . Write ( \" Sign ▁ of ▁ polynomial ▁ is ▁ \" + findSign ( poly , n , x ) ) ; } }"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | C # Program untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; Array untuk menyimpan prima; berfungsi untuk mengira prima menggunakan ayak eratosthenes; Cari nombor perdana lebih besar daripada nombor; Untuk mengembalikan nombor perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Panggil Sieveoferatostheneses untuk mengira prima; Untuk mencari jumlah elemen array; Untuk mencari nombor perdana yang lebih besar maka jumlahnya; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "class GFG { static int MAX = 100005 ; static bool [ ] isPrime = new bool [ MAX ] ; static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int [ ] arr , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . Length ; System . Console . WriteLine ( minNumber ( arr , n ) ) ; } }"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Program C # mudah untuk mengira jumlah elemen subarray; Mengira jumlah semua sub - array; Pilih titik permulaan; Memilih titik akhir; jumlah subarray antara titik permulaan dan akhir semasa; Kod pemacu", "code": "using System ; class GFG { public static long SubArraySum ( int [ ] arr , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; Console . Write ( \" Sum ▁ of ▁ SubArray ▁ : ▁ \" + SubArraySum ( arr , n ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | C # Program untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Kod pemacu", "code": "using System ; class GFG { static int highestPowerof2 ( int n ) { int p = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return ( int ) Math . Pow ( 2 , p ) ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( highestPowerof2 ( n ) ) ; } }"}
{"text": "Cari (a ^ b) % m di mana 'a' sangat besar | C # program untuk mencari (a ^ b) mod m untuk 'a' yang besar; fungsi utiliti untuk mengira % m; (S [i] - '0') memberikan nilai digit dan membentuk nombor; Pulangan mencari (a ^ b) % m; Cari % m; Sekarang kalikan Ans dengan b - 1 kali dan ambil mod dengan m; Kod pemacu", "code": "using System ; class GFG { static int aModM ( string s , int mod ) { int number = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { number = ( number * 10 ) ; int x = ( int ) ( s [ i ] - '0' ) ; number = number + x ; number %= mod ; } return number ; } static int ApowBmodM ( string a , int b , int m ) { int ans = aModM ( a , m ) ; int mul = ans ; for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; } public static void Main ( ) { string a = \"987584345091051645734583954832576\" ; int b = 3 , m = 11 ; Console . Write ( ApowBmodM ( a , b , m ) ) ; } }"}
{"text": "Interpolasi LaGrange | C # Program untuk pelaksanaan interpolasi LaGrange; Untuk mewakili titik data yang sepadan dengan x dan y = f (x); Fungsi untuk menginterpolasi titik data yang diberikan menggunakan Formula XI LaGrange sepadan dengan titik data baru yang nilainya diperoleh n mewakili bilangan titik data yang diketahui; hasil berganda = 0; Memulakan hasil; Mengira syarat individu di atas formula; Tambah istilah semasa untuk menghasilkan; Kod pemacu; mewujudkan pelbagai 4 mata data yang diketahui; Menggunakan fungsi interpolasi untuk mendapatkan titik data yang sepadan dengan x = 3", "code": "using System ; class GFG { class Data { public int x , y ; public Data ( int x , int y ) { this . x = x ; this . y = y ; } } ; static double interpolate ( Data [ ] f , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } public static void Main ( String [ ] args ) { Data [ ] f = { new Data ( 0 , 2 ) , new Data ( 1 , 3 ) , new Data ( 2 , 12 ) , new Data ( 5 , 147 ) } ; Console . Write ( \" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ \" + ( int ) interpolate ( f , 3 , 4 ) ) ; } }"}
{"text": "Sieve of Sundaram untuk mencetak semua prima yang lebih kecil daripada n | C # Program untuk mencetak prima yang lebih kecil daripada N menggunakan ayak Sundaram. ; Mencetak semua nombor perdana yang lebih kecil; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima lebih kecil daripada N, kita mengurangkan N hingga separuh; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; Memulakan semua elemen sebagai tidak ditandakan; Logik utama Sundaram. Tandakan semua nombor bentuk i + j + 2 ij sebagai benar di mana 1 <= i <= j; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Kod pemacu", "code": "using System ; class GFG { static int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool [ ] marked = new bool [ nNew + 1 ] ; for ( int i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) Console . Write ( 2 + \" ▁ \" ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) Console . Write ( 2 * i + 1 + \" ▁ \" ) ; return - 1 ; } public static void Main ( ) { int n = 20 ; SieveOfSundaram ( n ) ; } }"}
{"text": "Bina Arahan Asal Bermula dengan K dari pelbagai xor semua elemen kecuali elemen pada indeks yang sama | C # Program untuk pendekatan di atas; Berfungsi untuk membina array dengan setiap elemen yang sama dengan XOR semua elemen array kecuali elemen pada indeks yang sama; Array asal; Kedai bitwise xor array; Hitung XOR semua elemen array; Cetak array asal B []; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections ; class GFG { static void constructArray ( int [ ] A , int N , int K ) { int [ ] B = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( B [ i ] + \" ▁ \" ) ; } } static void Main ( ) { int [ ] A = { 13 , 14 , 10 , 6 } ; int K = 2 ; int N = A . Length ; constructArray ( A , N , K ) ; } }"}
{"text": "Cari elemen tambahan dalam array kedua | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan elemen tambahan dalam b []; Untuk menyimpan hasilnya; Cari xor semua elemen array a [] dan array b []; Kod pemacu", "code": "using System ; class GFG { static int extraElement ( int [ ] A , int [ ] B , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } public static void Main ( String [ ] args ) { int [ ] A = { 10 , 15 , 5 } ; int [ ] B = { 10 , 100 , 15 , 5 } ; int n = A . Length ; Console . WriteLine ( extraElement ( A , B , n ) ) ; } }"}
{"text": "Hamming jarak antara dua bilangan bulat | C # pelaksanaan pendekatan di atas; Fungsi untuk mengira jarak Hamming; Kod pemacu", "code": "class GFG { static int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } static void Main ( ) { int n1 = 9 , n2 = 14 ; System . Console . WriteLine ( hammingDistance ( n1 , n2 ) ) ; } }"}
{"text": "Cetak bitwise dan set nombor n | C # Program untuk mencetak semua subset bitwise N (pendekatan naif); berfungsi untuk mencari pendekatan naif subset bitwise; Fungsi pemacu", "code": "using System ; class GFG { static void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) Console . Write ( i + \" ▁ \" ) ; } public static void Main ( ) { int n = 9 ; printSubsets ( n ) ; } }"}
{"text": "Cari bit set yang paling ketara | C # Program untuk mencari nombor MSB untuk diberikan n. ; Untuk mencari kedudukan bit set yang paling penting; Untuk mengembalikan nilai nombor dengan set bit pada kedudukan k - th; Kod pemacu", "code": "using System ; public class GFG { static int setBitNumber ( int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return 1 << k ; } static public void Main ( ) { int n = 273 ; Console . WriteLine ( setBitNumber ( n ) ) ; } }"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan penyortiran untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Ambil input dan mulakan res = 0; Susun array; Melintasi array input dan cari kekerapan maksimum; Untuk setiap nombor mencari pengulangan / kekerapannya; Kemas kini res; Fungsi pemacu", "code": "using System ; public class GfG { public static int subset ( int [ ] ar , int n ) { int res = 0 ; Array . Sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . Max ( res , count ) ; } return res ; } public static void Main ( ) { int [ ] arr = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; Console . WriteLine ( subset ( arr , n ) ) ; } }"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan hash untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Melintasi array input dan frekuensi elemen; Cari nilai maksimum dalam peta. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int subset ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { var val = mp [ arr [ i ] ] ; mp . Remove ( arr [ i ] ) ; mp . Add ( arr [ i ] , val + 1 ) ; } else { mp . Add ( arr [ i ] , 1 ) ; } } int res = 0 ; foreach ( KeyValuePair < int , int > entry in mp ) res = Math . Max ( res , entry . Value ) ; return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = arr . Length ; Console . WriteLine ( subset ( arr , n ) ) ; } }"}
{"text": "Kira cara untuk mewakili nombor sebagai jumlah kotak yang sempurna |  ; Simpan kotak sempurna kurang daripada atau sama dengan n; Fungsi utiliti untuk mengira dataran sempurna kurang daripada atau sama dengan n; Berfungsi untuk mencari bilangan cara untuk mewakili nombor sebagai jumlah kuadrat yang sempurna; Mengendalikan kes asas; Sertakan elemen indeks I - th; Tidak termasuk elemen indeks i - th; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Precomment squares sempurna <= n; Panggilan fungsi", "code": "using System . IO ; using System ; using System . Collections ; class GFG { static ArrayList psquare = new ArrayList ( ) ; static void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . Add ( i * i ) ; } static int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - ( int ) psquare [ index ] ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; } static void Main ( ) { int N = 9 ; calcPsquare ( N ) ; Console . WriteLine ( countWays ( psquare . Count - 1 , N ) ) ; } }"}
{"text": "Jumlah jarak semua nod dari nod yang diberikan | C # Program untuk pendekatan di atas; Struktur nod pokok binari; Fungsi yang memperuntukkan nod baru dengan data yang diberikan dan batal ke petunjuk kiri dan kanannya; Kembali nod yang baru dibuat; Berfungsi untuk mengira bilangan nod di subtrees kiri dan kanan; Memulakan pasangan yang menyimpan pasangan {bilangan nod, kedalaman}; Mencari bilangan nod di subtree kiri; Cari bilangan nod di subtree yang betul; Mengisi medan saiz; Menyimpan jumlah jarak semua nod dari nod yang diberikan; Berfungsi untuk mencari jarak keseluruhan; Jika nod sasaran sepadan dengan nod semasa; Jika akar. Kiri tidak batal; Kemas kini Jumlah; Berulang untuk subtree kiri; Jika akar. Kanan tidak batal; Memohon formula yang diberikan dalam pendekatan; Berulang untuk subtree yang betul; Kod pemacu; Pokok input; Jumlah nod; Cetak jumlah jarak", "code": "using System ; public class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } class TreeNode { public int data , size ; public TreeNode left ; public TreeNode right ; } ; static TreeNode newNode ( int data ) { TreeNode Node = new TreeNode ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static pair sumofsubtree ( TreeNode root ) { pair p = new pair ( 1 , 0 ) ; if ( root . left != null ) { pair ptemp = sumofsubtree ( root . left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root . right != null ) { pair ptemp = sumofsubtree ( root . right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root . size = p . first ; return p ; } static int sum = 0 ; static void distance ( TreeNode root , int target , int distancesum , int n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { int tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { int tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } } public static void Main ( String [ ] args ) { TreeNode root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 7 ) ; root . left . left . left = newNode ( 8 ) ; root . left . left . right = newNode ( 9 ) ; int target = 3 ; pair p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; Console . Write ( sum + \" STRNEWLINE \" ) ; } }"}
{"text": "Menyusun semula array sedemikian rupa sehingga jumlah elemen yang diindeks yang sama adalah atmost k | C # Program untuk pendekatan di atas; Arahan terbalik; Fungsi untuk menyusun semula array sedemikian rupa sehingga jumlah unsur -unsur yang diindeks yang sama tidak melebihi k; Susun array [] b dalam urutan menurun; Jika keadaan gagal; Cetak array; Kod pemacu; Diberikan susunan", "code": "using System ; class GFG { static int [ ] reverse ( int [ ] a ) { int i , n = a . Length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } static void rearrangeArray ( int [ ] A , int [ ] B , int N , int K ) { Array . Sort ( B ) ; B = reverse ( B ) ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { Console . Write ( \" - 1\" + \" STRNEWLINE \" ) ; } else { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( B [ i ] + \" ▁ \" ) ; } } } public static void Main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 , 2 } ; int [ ] B = { 1 , 2 , 3 , 1 , 1 } ; int N = A . Length ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; } }"}
{"text": "Kira baris dengan jumlah melebihi jumlah matriks yang tinggal | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira bilangan baris yang jumlahnya melebihi jumlah unsur -unsur matriks yang tinggal; Menyimpan dimensi matriks; Untuk menyimpan hasilnya; Menyimpan jumlah keseluruhan unsur matriks; Kirakan jumlah keseluruhan; Melintasi untuk memeriksa setiap baris; Menyimpan jumlah elemen baris semasa; Kirakan jumlah elemen baris semasa; Jika jumlah baris semasa melebihi jumlah sisa matriks; Peningkatan kiraan; Cetak hasilnya; Kod pemacu; Diberikan matriks; Panggilan fungsi", "code": "using System ; class GFG { static void countRows ( int [ , ] mat ) { int n = mat . GetLength ( 0 ) ; int m = mat . GetLength ( 1 ) ; int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { totalSum += mat [ i , j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < m ; j ++ ) { currSum += mat [ i , j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } Console . WriteLine ( count ) ; } public static void Main ( String [ ] args ) { int [ , ] mat = { { 2 , - 1 , 5 } , { - 3 , 0 , - 2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; } }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | Pelaksanaan C # Sorting untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Susun array; Selepas menyusun, periksa sama ada elemen semasa sama seperti sebelumnya atau satu lagi. ; Program Pemandu", "code": "using System ; class GFG { static bool areElementsContiguous ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } public static void Main ( ) { int [ ] arr = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . Length ; if ( areElementsContiguous ( arr , n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | C # pelaksanaan untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Cari elemen maksimum dan minimum. ; Harus ada sekurang -kurangnya elemen M di Aaray untuk menjadikannya bersebelahan. ; Buat array yang dikunjungi dan mulakan palsu. ; Tandakan elemen sebagai benar. ; Jika mana -mana elemen tidak ditandakan, semua elemen tidak bersebelahan. ; Program Pemandu", "code": "using System ; class GFG { static bool areElementsContiguous ( int [ ] arr , int n ) { int max = int . MinValue ; int min = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . Max ( max , arr [ i ] ) ; min = Math . Min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; bool [ ] visited = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } public static void Main ( ) { int [ ] arr = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . Length ; if ( areElementsContiguous ( arr , n ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | C # pelaksanaan untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Menyimpan unsur -unsur 'arr []' dalam jadual hash 'kami'; Sebagai Arr [0] hadir dalam 'kami'; Bermula dengan elemen yang lebih kecil sebelumnya ARR [0]; Jika 'curr _ ele' hadir dalam 'kami'; kiraan kenaikan; mengemas kini 'curr_ele'; bermula dengan elemen yang lebih besar dari arr [0]; jika 'curr _ ele' hadir dalam 'us'; kiraan kenaikan; kemas kini 'curr_ele \"; Pulangan benar jika array mengandungi satu set bilangan bulat bersebelahan lain kembali palsu; Kod pemacu", "code": "using System ; using System . Collections . Generic ; public class GFG { public static bool ? areElementsContiguous ( int [ ] arr , int n ) { HashSet < int > us = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { us . Add ( arr [ i ] ) ; } int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . Contains ( curr_ele ) == true ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . Contains ( curr_ele ) == true ) { count ++ ; curr_ele ++ ; } return ( count == ( us . Count ) ) ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . Length ; if ( areElementsContiguous ( arr , n ) . Value ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } }"}
{"text": "Subarray terpanjang tidak mempunyai lebih banyak daripada elemen yang berbeza | C # Program untuk mencari subarray terpanjang dengan K atau kurang elemen yang berbeza. ; berfungsi untuk mencetak pelbagai sub - paling lama; Tandakan elemen yang dikunjungi; Jika ia dikunjungi kali pertama, maka tingkatkan kaunter unsur -unsur yang berbeza dengan 1; Apabila kaunter unsur -unsur yang berbeza meningkat dari k, kemudian mengurangkannya kepada k; Dari sebelah kiri, mengurangkan bilangan masa lawatan; Sekiranya elemen masa yang dikurangkan tidak terdapat dalam segmen selanjutnya maka mengurangkan kiraan unsur -unsur yang berbeza; meningkatkan tanda subsegment; Semak panjang sub -segmen terpanjang apabila lebih besar kemudian sebelum ini kemudian tukarnya; Cetak segmen sub - terpanjang; Kod pemacu", "code": "using System ; class GFG { static void longest ( int [ ] a , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) Console . Write ( a [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int [ ] a = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . Length ; int k = 3 ; longest ( a , n , k ) ; } }"}
{"text": "Periksa sama ada Kira K dalam mana -mana Titik | C # pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika mana -mana segmen K bertindih pada bila -bila masa; Vektor untuk menyimpan titik permulaan dan titik akhir; Titik permulaan ditandakan dengan - 1 dan titik berakhir dengan + 1; Susun vektor dengan elemen pertama; Tumpukan untuk menyimpan tumpang tindih; Dapatkan elemen semasa; Jika ia adalah titik permulaan; Tolaknya dalam timbunan; Ia adalah titik akhir; Pop elemen dari timbunan; Jika lebih daripada K -ranges bertindih; Kod pemacu", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static bool kOverlap ( List < Tuple < int , int > > pairs , int k ) { List < Tuple < int , int > > vec = new List < Tuple < int , int > > ( ) ; for ( int i = 0 ; i < pairs . Count ; i ++ ) { vec . Add ( new Tuple < int , int > ( pairs [ i ] . Item1 , - 1 ) ) ; vec . Add ( new Tuple < int , int > ( pairs [ i ] . Item2 , 1 ) ) ; } vec . Sort ( ) ; Stack st = new Stack ( ) ; for ( int i = 0 ; i < vec . Count ; i ++ ) { Tuple < int , int > cur = vec [ i ] ; if ( cur . Item2 == - 1 ) { st . Push ( cur ) ; } else { st . Pop ( ) ; } if ( st . Count >= k ) { return true ; } } return false ; } public static void Main ( params string [ ] args ) { List < Tuple < int , int > > pairs = new List < Tuple < int , int > > ( ) ; pairs . Add ( new Tuple < int , int > ( 1 , 3 ) ) ; pairs . Add ( new Tuple < int , int > ( 2 , 4 ) ) ; pairs . Add ( new Tuple < int , int > ( 3 , 5 ) ) ; pairs . Add ( new Tuple < int , int > ( 7 , 10 ) ) ; int n = pairs . Count , k = 3 ; if ( kOverlap ( pairs , k ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Cari julat terkecil yang mengandungi elemen dari senarai k | C # Program untuk mengetahui pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai disusun yang diberikan. ; array untuk menyimpan indeks semasa senarai i; Fungsi ini mengambil senarai yang disusun dalam bentuk array 2D sebagai hujah. Ia mendapati pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai K. ; memulakan ke 0 indeks; ; untuk mengekalkan indeks senarai yang mengandungi elemen minimum; melangkah ke atas semua senarai; Jika setiap elemen senarai [i] dilalui maka memecahkan gelung; Cari nilai minimum di antara semua elemen senarai yang menunjuk oleh array PTR []; mengemas kini indeks senarai; Cari nilai maksimum di antara semua elemen senarai yang menunjuk oleh array PTR []; Sekiranya ada senarai ekzos, kami tidak akan mendapat jawapan yang lebih baik, jadi pecahkan gelung sementara; mengemas kini Minrange; Kod pemacu", "code": "using System ; class GFG { static int N = 5 ; static int [ ] ptr = new int [ 501 ] ; static void findSmallestRange ( int [ , ] arr , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = int . MaxValue ; while ( true ) { minind = - 1 ; minval = int . MaxValue ; maxval = int . MinValue ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i , ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i , ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i , ptr [ i ] ] > maxval ) { maxval = arr [ i , ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } Console . WriteLine ( \" The ▁ smallest ▁ range ▁ is \" + \" [ { 0 } , ▁ { 1 } ] STRNEWLINE \" , minel , maxel ) ; } public static void Main ( String [ ] args ) { int [ , ] arr = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = arr . GetLength ( 0 ) ; findSmallestRange ( arr , N , k ) ; } }"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | C # Program untuk mencari yang terbesar sedemikian rupa sehingga D = A + B + C; berfungsi untuk mencari d terbesar; Susun array dalam urutan menaik; melangkah dari belakang untuk mencari D terbesar yang diperlukan; Oleh kerana semua empat A, B, C, D harus berbeza; Jika gabungan semasa J, K, L dalam set adalah sama dengan S [i] mengembalikan nilai ini kerana ini akan menjadi yang terbesar kita meleleh dalam urutan menurun; Kod pemacu", "code": "using System ; class GFG { static int findLargestd ( int [ ] S , int n ) { bool found = false ; Array . Sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return int . MaxValue ; return - 1 ; } public static void Main ( ) { int [ ] S = new int [ ] { 2 , 3 , 5 , 7 , 12 } ; int n = S . Length ; int ans = findLargestd ( S , n ) ; if ( ans == int . MaxValue ) Console . WriteLine ( \" No ▁ Solution \" ) ; else Console . Write ( \" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ \" + \" b ▁ + ▁ c ▁ = ▁ d ▁ is ▁ \" + ans ) ; } }"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Program C # berasaskan hashing untuk mencari D terbesar sedemikian rupa sehingga A + B + C = D. ; Untuk menyimpan dan mengambil indeks pasangan i & j; Fungsi ini menemui empat elemen dengan jumlah x yang diberikan; Jumlah wang (a + b) semua pasangan (a, b) dalam jadual hash; Melintasi semua pasangan dan mencari (D - C) hadir dalam jadual hash; Jika d - c ada dalam jadual hash ,; Memastikan semua elemen adalah elemen array yang berbeza dan elemen tidak dianggap lebih dari sekali. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; public class Indexes { int i , j ; public Indexes ( int i , int j ) { this . i = i ; this . j = j ; } public int getI ( ) { return i ; } public int getJ ( ) { return j ; } } public class GFG { static int findFourElements ( int [ ] arr , int n ) { Dictionary < int , Indexes > map = new Dictionary < int , Indexes > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . Add ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = int . MinValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . Abs ( arr [ i ] - arr [ j ] ) ; if ( map . ContainsKey ( abs_diff ) ) { Indexes indexes = map [ abs_diff ] ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . Max ( d , Math . Max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 7 , 12 } ; int n = arr . Length ; int res = findFourElements ( arr , n ) ; if ( res == int . MinValue ) Console . WriteLine ( \" No ▁ Solution \" ) ; else Console . WriteLine ( res ) ; } }"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Menyusun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } static public void Main ( ) { int [ ] arr = new int [ ] { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; Console . WriteLine ( CountMaximum ( arr , n , k ) ) ; } }"}
{"text": "Program untuk Putaran Array | C # Program untuk putaran array; Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar arr [] saiz n oleh d; fungsi utiliti untuk mencetak array; Kod pemacu", "code": "using System ; class GFG { static void leftRotatebyOne ( int [ ] arr , int n ) { int i , temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } static void leftRotate ( int [ ] arr , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; } }"}
{"text": "Susun array dalam julat indeks yang diberikan | C # Program untuk menyusun array dalam julat indeks yang diberikan; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Arahan sementara; Susun array sementara; Mengubah suai array asal dengan elemen array sementara; Cetak array yang diubah suai; Kod pemacu; panjang array", "code": "using System ; class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . Min ( a , b ) ; int r = Math . Max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Array . Sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } public static void Main ( ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . Length ; partSort ( arr , N , a , b ) ; } }"}
{"text": "Penyusun baris matriks dalam urutan menurun diikuti oleh lajur dalam urutan menaik | C # Pelaksanaan untuk menyusun baris matriks dalam urutan menurun diikuti dengan menyusun lajur dalam urutan menaik; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh turun. ; berfungsi untuk menyusun setiap baris matriks; menyusun nombor baris 'i'; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; menyusun baris [,] tikar dalam urutan menurun; dapatkan transpose [,] mat; Sekali lagi menyusun baris [,] tikar dalam urutan menaik. ; Sekali lagi dapatkan transpose [,] mat; berfungsi untuk mencetak matriks; Kod pemacu", "code": "using System ; class GFG { static int MAX_SIZE = 10 ; static void sortByRow ( int [ , ] mat , int n , bool descending ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) { int t = i ; for ( int p = 0 ; p < n ; p ++ ) { for ( int j = p + 1 ; j < n ; j ++ ) { if ( mat [ t , p ] < mat [ t , j ] ) { temp = mat [ t , p ] ; mat [ t , p ] = mat [ t , j ] ; mat [ t , j ] = temp ; } } } } else sortByRow ( mat , i , n ) ; } } static void sortByRow ( int [ , ] mat , int row , int n ) { for ( int i = row ; i < row + 1 ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( mat [ i , j ] > mat [ i , j + 1 ] ) { var temp = mat [ i , j ] ; mat [ i , j ] = mat [ i , j + 1 ] ; mat [ i , j + 1 ] = temp ; } } } } static void transpose ( int [ , ] mat , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { temp = mat [ i , j ] ; mat [ i , j ] = mat [ j , i ] ; mat [ j , i ] = temp ; } } } static void sortMatRowAndColWise ( int [ , ] mat , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } static void printMat ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) Console . Write ( mat [ i , j ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { int n = 3 ; int [ , ] mat = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; Console . WriteLine ( \" Original ▁ Matrix : \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; Console . WriteLine ( \" STRNEWLINE Matrix ▁ After ▁ Sorting : \" ) ; printMat ( mat , n ) ; } }"}
{"text": "Pindahkan semua sifar ke hujung array | C # Program untuk menolak sifar ke belakang array; Fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang dihadapi bukan sifar, kemudian gantikan elemen pada indeks a. . Counta. . dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan a. . Counta. . ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; Fungsi pemacu", "code": "using System ; class PushZero { static void pushZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } public static void Main ( ) { int [ ] arr = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . Length ; pushZerosToEnd ( arr , n ) ; Console . WriteLine ( \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ the ▁ back : ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Pindahkan semua sifar ke hujung array | Set | C # pelaksanaan untuk memindahkan semua sifar pada akhir array; berfungsi untuk memindahkan semua sifar pada akhir array; Kiraan unsur bukan sifar; Melintasi array. Jika arr [i] bukan sifar, maka swap elemen pada indeks 'kiraan' dengan elemen pada indeks 'i'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "using System ; class GFG { static void moveZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( ) { int [ ] arr = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . Length ; Console . Write ( \" Original ▁ array : ▁ \" ) ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; Console . Write ( \" STRNEWLINE Modified ▁ array : ▁ \" ) ; printArray ( arr , n ) ; } }"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | C # Pelaksanaan untuk menyusun semula elemen array selepas pengubahsuaian; fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; berfungsi untuk menyusun semula elemen array selepas pengubahsuaian; jika 'arr []' mengandungi satu elemen sahaja; melintasi array; Jika benar, lakukan pengubahsuaian yang diperlukan; nilai indeks semasa dua kali; Letakkan 0 dalam indeks seterusnya; kenaikan sebanyak 1 untuk memindahkan dua indeks di hadapan semasa lelaran gelung; tolak semua sifar pada akhir 'arr []'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "using System ; class GFG { static void pushZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } static void modifyAndRearrangeArr ( int [ ] arr , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = arr . Length ; Console . Write ( \" Original ▁ array : ▁ \" ) ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; Console . Write ( \" Modified ▁ array : ▁ \" ) ; printArray ( arr , n ) ; } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | C # Program untuk menyusun semula nombor positif dan negatif dalam array; Fungsi utiliti untuk mencetak pelbagai saiz n; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Jika elemen semasa positif tidak melakukan apa -apa; Jika elemen semasa adalah negatif, pergeseran elemen positif ARR [0. i - 1], ke satu kedudukan di sebelah kanan mereka; Letakkan elemen negatif pada kedudukan yang betul; Program Pemandu", "code": "using System ; class GFG { static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } static void RearrangePosNeg ( int [ ] arr , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } public static void Main ( ) { int [ ] arr = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int n = arr . Length ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | C # Program untuk menyusun semula nombor positif dan negatif dalam array; Berfungsi untuk mencetak array; Fungsi untuk membalikkan array. Arahan boleh diterbalikkan dalam masa O (n) dan O (1) ruang. ; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]; Indeks awal Subarray 1 ST; Indeks awal IIND; arr [i. . M] adalah positif; arr [j. . r] adalah bahagian positif yang positif dari sub - array kiri (arr [i. m]); Bahagian negatif terbalik sub - array kanan (arr [m + 1 ... j - 1]); ARR terbalik [i. . J - 1]; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Kod pemacu", "code": "using System ; class GFG { static void printArray ( int [ ] A , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( A [ i ] + \" ▁ \" ) ; Console . WriteLine ( \" \" ) ; ; } static void reverse ( int [ ] arr , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } } static void merge ( int [ ] arr , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } static void RearrangePosNeg ( int [ ] arr , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void Main ( ) { int [ ] arr = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_size = arr . Length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | C # pelaksanaan pendekatan di atas; Gelung sehingga arr [i] <0 dan masih di dalam array; Gelung sehingga arr [j]> 0 dan masih di dalam array; jika saya kurang daripada j; Kod pemacu", "code": "using System ; public class GFG { public static void RearrangePosNeg ( int [ ] arr ) { int i = 0 ; int j = arr . Length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . Length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } static public void Main ( ) { int [ ] arr = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; RearrangePosNeg ( arr ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Cari pemain untuk dapat menggantikan elemen terakhir yang boleh digantikan oleh pembahagi | C # Program untuk pendekatan di atas; Fungsi untuk mencari pemenang permainan yang dimainkan berdasarkan keadaan yang diberikan; Kemenangan jika saiz array adalah ganjil; Jika tidak, B menang; Kod pemacu; Arahan input; Saiz array", "code": "using System ; public class GFG { static void winner ( int [ ] arr , int N ) { if ( N % 2 == 1 ) { Console . Write ( \" A \" ) ; } else { Console . Write ( \" B \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 24 , 45 , 45 , 24 } ; int N = arr . Length ; winner ( arr , N ) ; } }"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | C # Program untuk pendekatan di atas; Fungsi kepada jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua nilai yang mungkin x dan y, di mana y kurang daripada atau sama dengan matematik. Sqrt (n). ; Melangkah ke atas semua kemungkinan nilai x; Precompute untuk semua nilai yang mungkin dari ungkapan seperti y <= matematik. Sqrt (n); Jika saya + j kurang daripada n; Mengemas kini dp [i, j]; Mengemas kini dp [i, j]; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; dp [x, y]: menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array pertanyaan, q [,]; Jika y kurang daripada atau sama dengan matematik. Sqrt (n); Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array, [] arr; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "using System ; class GFG { static int sz = 20 ; static int sqr = ( int ) ( Math . Sqrt ( sz ) ) + 1 ; static void precomputeExpressionForAllVal ( int [ ] arr , int N , int [ , ] dp ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= Math . Sqrt ( N ) ; j ++ ) { if ( i + j < N ) { dp [ i , j ] = arr [ i ] + dp [ i + j , j ] ; } else { dp [ i , j ] = arr [ i ] ; } } } } static void querySum ( int [ ] arr , int N , int [ , ] Q , int M ) { int [ , ] dp = new int [ sz , sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i , 0 ] ; int y = Q [ i , 1 ] ; if ( y <= Math . Sqrt ( N ) ) { Console . Write ( dp [ x , y ] + \" ▁ \" ) ; continue ; } int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } Console . Write ( sum + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 5 , 4 } ; int [ , ] Q = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . Length ; int M = Q . GetLength ( 0 ) ; querySum ( arr , N , Q , M ) ; } }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | C # Program untuk mencari semua elemen dalam pelbagai yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Pilih elemen satu demi satu dan hitung elemen yang lebih besar. Jika kiraan lebih daripada 2, cetak elemen itu. ; Kod pemacu", "code": "using System ; class GFG { static void findElements ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . Length ; findElements ( arr , n ) ; } }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Mengasingkan Program C # untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Kod pemacu", "code": "using System ; class GFG { static void findElements ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . Length ; findElements ( arr , n ) ; } }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | C # Program untuk mencari semua elemen dalam array yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "using System ; class GFG { static void findElements ( int [ ] arr , int n ) { int first = int . MinValue ; int second = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . Length ; findElements ( arr , n ) ; } }"}
{"text": "Kurangkan kiraan kenaikan setiap elemen subarray yang diperlukan untuk membuat array bukan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk membuat array tidak meningkat; Menyimpan kiraan operasi yang diperlukan; Jika arr [i]> arr [i + 1], tiada kenaikan diperlukan. Jika tidak, tambahkan perbezaannya kepada jawapannya; Mengembalikan hasil res; Kod pemacu", "code": "using System ; class GFG { public static int getMinOps ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { res += Math . Max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 1 , 2 } ; Console . WriteLine ( getMinOps ( arr ) ) ; } }"}
{"text": "Cari nombor yang paling kecil | C # Program untuk mencari unsur -unsur terkecil yang hilang dalam array yang disusun. ; Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int findFirstMissing ( int [ ] array , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } public static void Main ( ) { int [ ] arr = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . Length ; Console . Write ( \" smallest ▁ Missing ▁ element ▁ is ▁ : ▁ \" + findFirstMissing ( arr , 0 , n - 1 ) ) ; } }"}
{"text": "Cari nombor yang paling kecil | C # Program untuk pendekatan di atas; Program untuk mencari elemen yang hilang; Perlawanan indeks dengan nilai pada indeks itu, bermakna elemen yang hilang tidak boleh sampai ke titik itu; Program untuk mencari yang paling kecil hilang dalam pelbagai disusun; Semak jika 0 hilang dalam array; Cek adalah semua nombor 0 hingga n - 1 adalah prsent dalam array; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } int findSmallestMissinginSortedArray ( int [ ] arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . Length - 1 ] == arr . Length - 1 ) return arr . Length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . Length - 1 , first ) ; } static public void Main ( ) { GFG small = new GFG ( ) ; int [ ] arr = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . Length ; Console . WriteLine ( \" First ▁ Missing ▁ element ▁ is ▁ : ▁ \" + small . findSmallestMissinginSortedArray ( arr ) ) ; } }"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan | Program untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i; Max semasa termasuk i; kembali max incl and excl; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int FindMaxSum ( int [ ] arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void Main ( ) { int [ ] arr = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; Console . Write ( FindMaxSum ( arr , arr . Length ) ) ; } }"}
{"text": "Langkah -langkah minimum untuk menukar semua laluan kiri ke bawah ke bawah dalam matriks sebagai palindrome | Tetapkan 2 | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan perubahan minimum; Jarak elemen dari (0, 0) akan saya julat [0, n + m - 2]; Frekuensi kedai [0, 9] pada jarak I; Memulakan frekuensi sebagai 0; Mengira frekuensi [0, 9]; Kekerapan kenaikan matriks nilai [i, j] pada jarak i + j; Cari nilai dengan kekerapan maksimum dan hitung jumlah sel pada jarak i dari hujung depan dan belakang belakang; Tukar semua nilai ke nilai dengan kekerapan maksimum; Kembalikan jawapannya; Kod pemacu; Diberikan matriks; Panggilan fungsi", "code": "using System ; class GFG { static readonly int N = 7 ; static int countChanges ( int [ , ] matrix , int n , int m ) { int dist = n + m - 1 ; int [ , ] freq = new int [ dist , 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i , j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j , matrix [ i , j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . Max ( maximum , freq [ i , j ] + freq [ n + m - 2 - i , j ] ) ; total_values += ( freq [ i , j ] + freq [ n + m - 2 - i , j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } public static void Main ( String [ ] args ) { int [ , ] mat = { { 1 , 2 } , { 3 , 5 } } ; Console . Write ( countChanges ( mat , 2 , 2 ) ) ; } }"}
{"text": "Jadual jarang | C # Program untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan nilai minimum dalam arr [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Mengisi carian array carian [] [] dengan cara bawah. ; Memulakan m untuk selang dengan panjang 1; Mengira nilai dari selang yang lebih kecil hingga lebih besar; Kirakan nilai minimum untuk semua selang dengan saiz 2 ^ j; Untuk arr [2] [10], kami membandingkan arr [lookup [0] [7]] dan arr [lookup [3] [10]]; Mengembalikan minimum arr [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan minimum unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kami membandingkan arr [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Program Pemandu", "code": "using System ; public class GFG { static int MAX = 500 ; static int [ , ] lookup = new int [ MAX , MAX ] ; static void buildSparseTable ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i , 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i , j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) , j - 1 ] ) lookup [ i , j ] = lookup [ i , j - 1 ] ; else lookup [ i , j ] = lookup [ i + ( 1 << ( j - 1 ) ) , j - 1 ] ; } } } static int query ( int L , int R ) { int j = ( int ) Math . Log ( R - L + 1 ) ; if ( lookup [ L , j ] <= lookup [ R - ( 1 << j ) + 1 , j ] ) return lookup [ L , j ] ; else return lookup [ R - ( 1 << j ) + 1 , j ] ; } static public void Main ( ) { int [ ] a = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . Length ; buildSparseTable ( a , n ) ; Console . WriteLine ( query ( 0 , 4 ) ) ; Console . WriteLine ( query ( 4 , 7 ) ) ; Console . WriteLine ( query ( 7 , 8 ) ) ; } }"}
{"text": "Jadual jarang | C # Program untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [I, J] akan menyimpan GCD ARR [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Ia membina meja jarang. ; GCD elemen tunggal adalah elemen itu sendiri; Membina meja jarang; Mengembalikan GCD ARR [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan GCD unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kita dapati GCD ARR [lookup [0, 3]] dan arr [lookup [3, 3]] ,; Kod pemacu", "code": "using System ; class GFG { static readonly int MAX = 500 ; static int [ , ] table = new int [ MAX , MAX ] ; static void buildSparseTable ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) table [ i , 0 ] = arr [ i ] ; for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i , j ] = __gcd ( table [ i , j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) , j - 1 ] ) ; } static int query ( int L , int R ) { int j = ( int ) Math . Log ( R - L + 1 ) ; return __gcd ( table [ L , j ] , table [ R - ( 1 << j ) + 1 , j ] ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int [ ] a = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . Length ; buildSparseTable ( a , n ) ; Console . Write ( query ( 0 , 2 ) + \" STRNEWLINE \" ) ; Console . Write ( query ( 1 , 3 ) + \" STRNEWLINE \" ) ; Console . Write ( query ( 4 , 5 ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Arahan terkecil lexicographically selepas di | C # Program untuk mencari nilai minimum lexicographically selepas k swap. ; Modifies arr [0 .. n - 1] kepada lexicographically terkecil dengan s swap. ; Tetapkan kedudukan di mana kita mahu meletakkan integer terkecil; Jika kita melebihi swap maksimum kemudian menamatkan gelung; Cari nilai minimum dari i + 1 hingga max k atau n; Tukar unsur -unsur dari kedudukan minimum yang kami dapati hingga sekarang ke indeks I; Tetapkan nilai akhir selepas menukar elemen POS - I; Kaedah pemacu; Fungsi panggilan; Cetak Array Akhir", "code": "using System ; class GFG { static void minimizeWithKSwaps ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } } public static void Main ( ) { int [ ] arr = { 7 , 6 , 9 , 2 , 1 } ; int n = arr . Length ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Cari subarray purata maksimum K panjang | C # Program untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Buat dan isi array untuk menyimpan jumlah kumulatif. csum [i] menyimpan jumlah arr [0] ke arr [i]; Memulakan max_sm sebagai jumlah subarray pertama; Cari jumlah subarray lain dan kemas kini max_sum jika diperlukan. ; Indeks permulaan kembali; Kod pemacu", "code": "using System ; class GFG { static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; } static public void Main ( ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . Length ; Console . WriteLine ( \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ \" + \" length ▁ \" + k + \" ▁ begins ▁ at ▁ index ▁ \" + findMaxAverage ( arr , n , k ) ) ; } }"}
{"text": "Cari subarray purata maksimum K panjang | C # Program untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Mengira jumlah elemen 'k' pertama; Mengira jumlah subarray yang tinggal; Indeks permulaan kembali; Program Pemandu", "code": "using System ; class GFG { static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } public static void Main ( ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . Length ; Console . WriteLine ( \" The ▁ maximum ▁ \" + \" average ▁ subarray ▁ of ▁ length ▁ \" + k + \" ▁ begins ▁ at ▁ index ▁ \" + findMaxAverage ( arr , n , k ) ) ; } }"}
{"text": "Skor minimum mungkin untuk pemain dengan memilih satu atau dua elemen array berturut -turut dari array binari yang diberikan | C # Program untuk pendekatan di atas; Menyimpan skor minimum untuk setiap negeri sebagai peta <pasangan <pos, myturn>, ans>; Berfungsi untuk mencari skor minimum selepas memilih elemen dari array; Mengembalikan keadaan yang disimpan; Kes asas; Pemain A 'S giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Pemain B 's giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Fungsi yang mendapati penalti minimum selepas memilih elemen dari array binari yang diberikan; Memulakan kedudukan memilih elemen dari array; 0 menandakan pemain A Turn 1 menandakan pemain B giliran; Panggilan fungsi; Berfungsi untuk mencetak jawapan; Penalti minimum; Hitung jumlah semua elemen ARR; Cetak skor minimum; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static Dictionary < Tuple < int , int > , int > m = new Dictionary < Tuple < int , int > , int > ( ) ; static int findMinimum ( int [ ] arr , int N , int pos , int turn ) { Tuple < int , int > x = new Tuple < int , int > ( pos , turn ) ; if ( m . ContainsKey ( x ) ) { return m [ x ] ; } if ( pos >= N - 1 ) { return 0 ; } if ( turn == 0 ) { int ans = Math . Min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ; Tuple < int , int > v = new Tuple < int , int > ( pos , turn ) ; m [ v ] = ans ; return ans ; } if ( turn != 0 ) { int ans = Math . Min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ; Tuple < int , int > v = new Tuple < int , int > ( pos , turn ) ; m [ v ] = ans ; return ans ; } return 0 ; } static int countPenality ( int [ ] arr , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; } static void printAnswer ( int [ ] arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } Console . WriteLine ( a ) ; } static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = 8 ; printAnswer ( arr , N ) ; } }"}
{"text": "Jumlah nombor utama dalam julat [l, r] dari array yang diberikan untuk pertanyaan q | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor perdana; Buat Boolean Array Prime [] dan memulakan semua penyertaannya sebagai benar nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana; Semak jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan; Berfungsi untuk mendapatkan indeks pertengahan dari indeks sudut; Berfungsi untuk mendapatkan jumlah nilai dalam julat array yang diberikan; Jika segmen nod ini adalah sebahagian daripada julat yang diberikan, maka kembalikan jumlah segmen; Jika segmen nod ini berada di luar julat yang diberikan; Jika sebahagian daripada segmen ini bertindih dengan julat yang diberikan; Fungsi untuk mengemas kini nod yang mempunyai indeks yang diberikan dalam julatnya; Jika indeks input terletak di luar julat segmen ini; Jika indeks input berada dalam julat nod ini, maka kemas kini nilai nod dan anak -anaknya; Berfungsi untuk mengemas kini nilai dalam array input dan pokok segmen; Semak indeks input yang salah; Dapatkan perbezaan antara nilai baru dan nilai lama; Kemas kini nilai dalam array; Kemas kini nilai nod dalam pokok segmen hanya jika sama ada nilai sebelumnya atau nilai baru atau kedua -duanya adalah perdana; Jika hanya nilai baru adalah perdana; Jika hanya nilai baru adalah perdana; Jika kedua -duanya adalah perdana; Pulangan Jumlah Elemen dalam Julat dari Indeks QS (Permulaan Permintaan) ke QE (End Query). Ia terutamanya menggunakan getSumutil (); Semak nilai input yang salah; Fungsi yang membina pokok segmen; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Hanya tambah unsur -unsur dalam pokok segmen yang utama; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan jumlah nilai dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Panggilan fungsi; Membina pokok segmen dari array yang diberikan; Cetak jumlah nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 10 dan kemas kini nod pokok segmen yang sepadan; Cari jumlah selepas nilai dikemas kini", "code": "using System ; class GFG { static int MAX = 1000001 ; static int [ ] prime = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { Array . Fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } } static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } static int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } static void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } static void updateValue ( int [ ] arr , int [ ] st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { Console . Write ( \" - 1\" ) ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) ! = 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } } static int getSum ( int [ ] st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { Console . WriteLine ( \" - 1\" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } static int constructSTUtil ( int [ ] arr , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } static int [ ] constructST ( int [ ] arr , int n ) { int x = ( int ) ( Math . Ceiling ( Math . Log ( n , 2 ) ) ) ; int max_size = 2 * ( int ) Math . Pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = arr . Length ; SieveOfEratosthenes ( ) ; int [ ] st = constructST ( arr , n ) ; Console . WriteLine ( getSum ( st , n , 1 , 3 ) ) ; updateValue ( arr , st , n , 1 , 10 ) ; Console . WriteLine ( getSum ( st , n , 1 , 3 ) ) ; } }"}
{"text": "Kira bilangan cara untuk membina rentetan sasaran | C # Program untuk mengira bilangan cara untuk membina rentetan sasaran; Kes asas; Jika subproblem semasa telah diselesaikan, gunakan nilai; Cari melalui semua yang ditunjukkan di mana watak semasa berlaku. Untuk setiap indeks yang lebih besar daripada sebelumnya, ambil indeks dan bergerak ke kedudukan seterusnya, dan tambahkan jawapannya. ; Simpan dan kembalikan penyelesaian untuk subproblem ini; Pra -proses rentetan dengan menyimpan untuk setiap aksara setiap rentetan, indeks kejadian mereka kita akan menggunakan senarai umum untuk semua kerana hanya indeks perkara dalam rentetan dari mana watak itu dipilih; Kami menyimpan J + 1 kerana indeks yang dipilih awal dalam langkah rekursif akan NE 0. Ini hanya untuk kemudahan pelaksanaan; Inisiasi jadual DP. - 1 mewakili bahawa subproblem tidak diselesaikan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int mod = 1000000007 ; static int [ , ] dp = new int [ 1000 , 1000 ] ; static int calculate ( int pos , int prev , String s , List < int > index ) { if ( pos == s . Length ) return 1 ; if ( dp [ pos , prev ] != - 1 ) return dp [ pos , prev ] ; int answer = 0 ; for ( int i = 0 ; i < index . Count ; i ++ ) { if ( index [ i ] . CompareTo ( prev ) >= 0 ) { answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod ; } } return dp [ pos , prev ] = answer ; } static int countWays ( List < String > a , String s ) { int n = a . Count ; List < int > [ ] index = new List < int > [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a [ i ] . Length ; j ++ ) { index [ a [ i ] [ j ] - ' a ' ] . Add ( j + 1 ) ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i , j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; } public static void Main ( String [ ] args ) { List < String > A = new List < String > ( ) ; A . Add ( \" adc \" ) ; A . Add ( \" aec \" ) ; A . Add ( \" erg \" ) ; String S = \" ac \" ; Console . Write ( countWays ( A , S ) ) ; } }"}
{"text": "Count of integer dari julat [0, n] yang jumlah digitnya adalah pelbagai k | C # pelaksanaan pendekatan; Untuk menyimpan negeri -negeri DP; Berfungsi untuk mengembalikan kiraan nombor dari julat [0, n] yang jumlah digitnya adalah pelbagai k menggunakan dp bawah; Digit dalam indeks ini hanya boleh dari [0, num [idx]]; Digit dalam indeks ini boleh menjadi apa -apa dari [0, 9]; new_tight adalah nilai bendera untuk kedudukan seterusnya; Res tidak boleh menjadi negatif; Berfungsi untuk memproses rentetan ke vektor digit dari MSD ke LSD; Kod pemacu; Untuk nombor input besar n; Jumlah bilangan digit dalam n; Jadual DP Bersih; Proses rentetan ke vektor digit dari MSD ke LSD", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int MAX = 10005 ; static readonly int MOD = 1000000007 ; static int [ , , ] dp = new int [ MAX , 101 , 2 ] ; static int countNum ( int idx , int sum , int tight , List < int > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx , sum , tight ] != - 1 ) return dp [ idx , sum , tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx , sum , tight ] = res ; } static List < int > process ( String s ) { List < int > num = new List < int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { num . Add ( s [ i ] - '0' ) ; } return num ; } public static void Main ( String [ ] args ) { String n = \"98765432109876543210\" ; int len = n . Length ; int k = 58 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i , j , l ] = - 1 ; } } List < int > num = process ( n ) ; Console . Write ( countNum ( 0 , 0 , 0 , num , len , k ) ) ; } }"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | C # pelaksanaan untuk mencari bilangan berikutnya dengan jumlah yang lebih baik dan ganjil; Array untuk menyimpan kiraan walaupun seterusnya dan berikutnya yang ganjil; Inisialisasi counteven [0] dan countodd [0] hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan walaupun atau ganjil. ; Di sini Countodd [i] menandakan kiraan berikutnya yang ganjil sehingga i; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu", "code": "using System ; class GFG { public static int [ ] countSum ( int [ ] arr , int n ) { int [ ] countODD = new int [ n + 1 ] ; int [ ] countEVEN = new int [ n + 1 ] ; countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; } else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } int [ ] ans = new int [ 2 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 2 , 3 } ; int n = 4 ; int [ ] ans = countSum ( arr , n ) ; Console . WriteLine ( \" EvenSum ▁ = ▁ \" + ans [ 0 ] ) ; Console . WriteLine ( \" OddSum ▁ = ▁ \" + ans [ 1 ] ) ; } }"}
{"text": "Double Knapsack | Pengaturcaraan Dinamik | C # pelaksanaan pendekatan di atas; Arahan 3D untuk menyimpan negeri -negeri DP; W1_R mewakili kapasiti selebihnya 1 stnapsack w2_r mewakili kapasiti selebihnya 2 nd knapsack I mewakili indeks array arr yang kami sedang kerjakan; Kes asas; Pembolehubah untuk menyimpan hasil tiga bahagian hubungan berulang; Simpan negeri dalam array 3d; Kod pemacu; Arahan input; Memulakan array dengan - 1; Bilangan elemen dalam array; Kapasiti knapsacks; Berfungsi untuk dipanggil", "code": "using System ; class GFG { static int maxN = 31 ; static int maxW = 31 ; static int [ , , ] dp = new int [ maxN , maxW , maxW ] ; static int maxWeight ( int [ ] arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i , w1_r , w2_r ] != - 1 ) return dp [ i , w1_r , w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i , w1_r , w2_r ] = Math . Max ( fill_none , Math . Max ( fill_w1 , fill_w2 ) ) ; return dp [ i , w1_r , w2_r ] ; } public static void Main ( ) { int [ ] arr = { 8 , 2 , 3 } ; for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxW ; j ++ ) for ( int k = 0 ; k < maxW ; k ++ ) dp [ i , j , k ] = - 1 ; int n = arr . Length ; int w1 = 10 , w2 = 3 ; Console . WriteLine ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ; } }"}
{"text": "Jumlah bitwise dan semua submatrices | C # Program untuk mencari jumlah bit - bijak dan semua submatrices; Berfungsi untuk mencari awalan - kiraan untuk setiap baris dari kanan ke kiri; Berfungsi untuk mencari bilangan submatrik dengan semua 1 s; Array untuk menyimpan kiraan awalan yang diperlukan 1 s dari kanan ke kiri untuk array boolean; Pembolehubah untuk menyimpan jawapan terakhir; Untuk setiap indeks lajur, tentukan bilangan sub -matriks bermula dari indeks itu dan mempunyai semua 1 s; Stack untuk menyimpan unsur -unsur dan kiraan nombor yang mereka muncul bahagian pertama pasangan adalah nilai elemen yang dimasukkan bahagian kedua adalah mengira bilangan elemen yang ditolak sebelum dengan nilai yang lebih besar; pembolehubah untuk menyimpan bilangan submatrik dengan semua 1 s; Berfungsi untuk mencari jumlah bitwise - atau semua submatrices; matriks untuk menyimpan status ith bit setiap elemen matriks arr; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int n = 3 ; static void findPrefixCount ( int [ , ] p_arr , bool [ , ] set_bit ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i , j ] ) continue ; if ( j != n - 1 ) p_arr [ i , j ] += p_arr [ i , j + 1 ] ; p_arr [ i , j ] += ( set_bit [ i , j ] ) ? 1 : 0 ; } } } public class pair { public int first , second ; public pair ( ) { } public pair ( int a , int b ) { first = a ; second = b ; } } static int matrixAllOne ( bool [ , ] set_bit ) { int [ , ] p_arr = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) p_arr [ i , j ] = 0 ; findPrefixCount ( p_arr , set_bit ) ; int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; Stack < pair > q = new Stack < pair > ( ) ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . Count != 0 && q . Peek ( ) . first > p_arr [ i , j ] ) { to_sum -= ( q . Peek ( ) . second + 1 ) * ( q . Peek ( ) . first - p_arr [ i , j ] ) ; c += q . Peek ( ) . second + 1 ; q . Pop ( ) ; } to_sum += p_arr [ i , j ] ; ans += to_sum ; q . Push ( new pair ( p_arr [ i , j ] , c ) ) ; i -- ; } } return ans ; } static int sumAndMatrix ( int [ , ] arr ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { bool [ , ] set_bit = new bool [ n , n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R , C ] = ( ( arr [ R , C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; } public static void Main ( String [ ] args ) { int [ , ] arr = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; Console . WriteLine ( sumAndMatrix ( arr ) ) ; } }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk 3 nilai terakhir sebelum i. ; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Bilangan cara jika larian pertama adalah 2 dan larian kedua ialah 1; Ingat 3 nilai terakhir; Kod pemacu", "code": "using System ; using System . Collections . Generic ; public class GFG { static int CountWays ( int n ) { int [ ] noOfWays = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } public static void Main ( String [ ] args ) { int n = 5 ; Console . WriteLine ( CountWays ( n ) ) ; } }"}
{"text": "Laluan Perdana Lexicographically terbesar dari atas | C # pelaksanaan pendekatan di atas; Carian pertama kedalaman; Kembali jika sel mengandungi nombor bukan perdana atau halangan, atau keluar dari matriks atau sudah melawat sel atau sudah menemui jalan terbesar leksikografi; Penandaan sel sudah dikunjungi; Menyimpan indeks laluan terbesar leksikografi; Jika sampai ke akhir matriks; Mengemas kini bilangan akhir langkah dalam laluan terbesar leksikografi; Bergerak pepenjuru (mencuba laluan terbesar leksikografi); Menggerakkan sel ke sel semasa; Bergerak sel ke sel semasa. ; Cetak jalan utama lexicographical terbesar; Untuk mengira bilangan langkah dalam laluan utama terbesar leksikografi; Untuk menyimpan indeks jalan utama terbesar lexicographical; Untuk menandakan jika sel sudah dilalui atau tidak; Melintasi DFS; Mencetak laluan utama terbesar lexicographical; Kembalikan bilangan jalan utama dalam matriks. ; Untuk setiap sel; Jika di barisan atas atau lajur paling kiri, tidak ada jalan di sana. ; Jika nombor bukan perdana; Mencari pemetaan matriks dengan mempertimbangkan nombor bukan perdana sebagai halangan dan nombor utama menjadi laluan yang sah. ; Ayak; Jika Perdana; Jika bukan Perdana; Kod pemacu", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static int MAX = 105 ; static void sieve ( int [ ] prime ) { for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = 1 ; } } } class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void dfs ( int i , int j , int k , ref int q , int n , int m , int [ , ] mappedMatrix , int [ , ] mark , pair [ ] ans ) { if ( ( mappedMatrix [ i , j ] == 0 ? true : false ) || ( i > n ? true : false ) || ( j > m ? true : false ) || ( mark [ i , j ] != 0 ? true : false ) || ( q != 0 ? true : false ) ) return ; mark [ i , j ] = 1 ; ans [ k ] = new pair ( i , j ) ; if ( i == n && j == m ) { ( q ) = k ; return ; } dfs ( i + 1 , j + 1 , k + 1 , ref q , n , m , mappedMatrix , mark , ans ) ; dfs ( i + 1 , j , k + 1 , ref q , n , m , mappedMatrix , mark , ans ) ; dfs ( i , j + 1 , k + 1 , ref q , n , m , mappedMatrix , mark , ans ) ; } static void lexicographicalPath ( int n , int m , int [ , ] mappedMatrix ) { int q = 0 ; pair [ ] ans = new pair [ MAX ] ; int [ , ] mark = new int [ MAX , MAX ] ; dfs ( 1 , 1 , 1 , ref q , n , m , mappedMatrix , mark , ans ) ; for ( int i = 1 ; i <= q ; i ++ ) Console . WriteLine ( ans [ i ] . first + \" ▁ \" + ans [ i ] . second ) ; } static void countPrimePath ( int [ , ] mappedMatrix , int n , int m ) { int [ , ] dp = new int [ MAX , MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = 0 ; } } dp [ 1 , 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( i == 1 && j == 1 ) continue ; dp [ i , j ] = ( dp [ i - 1 , j ] + dp [ i , j - 1 ] + dp [ i - 1 , j - 1 ] ) ; if ( mappedMatrix [ i , j ] == 0 ) dp [ i , j ] = 0 ; } } Console . WriteLine ( dp [ n , m ] ) ; } static void preprocessMatrix ( int [ , ] mappedMatrix , int [ , ] a , int n , int m ) { int [ ] prime = new int [ MAX ] ; sieve ( prime ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ a [ i , j ] ] == 0 ) mappedMatrix [ i + 1 , j + 1 ] = 1 ; else mappedMatrix [ i + 1 , j + 1 ] = 0 ; } } } public static void Main ( string [ ] args ) { int n = 3 ; int m = 3 ; int [ , ] a = new int [ 3 , 3 ] { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int [ , ] mappedMatrix = new int [ MAX , MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { mappedMatrix [ i , j ] = 0 ; } } preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; } }"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset + nilai subset maksimal. ; Pulangan saiz subset bersaiz maksimum jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan. Ia kembali - 1 jika tidak ada subset dengan jumlah yang diberikan. ; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class sumofSub { static int isSubsetSum ( int [ ] set , int n , int sum ) { bool [ , ] subset = new bool [ sum + 1 , n + 1 ] ; int [ , ] count = new int [ sum + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 , i ] = true ; count [ 0 , i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i , 0 ] = false ; count [ i , 0 ] = - 1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i , j ] = subset [ i , j - 1 ] ; count [ i , j ] = count [ i , j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i , j ] = subset [ i , j ] || subset [ i - set [ j - 1 ] , j - 1 ] ; if ( subset [ i , j ] ) count [ i , j ] = Math . Max ( count [ i , j - 1 ] , count [ i - set [ j - 1 ] , j - 1 ] + 1 ) ; } } } return count [ sum , n ] ; } public static void Main ( ) { int [ ] set = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = set . Length ; Console . WriteLine ( isSubsetSum ( set , n , sum ) ) ; } }"}
{"text": "Cetak semua sub biasa terpanjang | C # Program untuk mencari semua LCS dua rentetan dalam urutan yang disusun. ; panjang LCS; Matriks DP untuk menyimpan hasil sub panggilan untuk LCS; Fungsi berasaskan memoisasi yang mengembalikan LCS STR1 [i. . len1 - 1] dan str2 [j. . len2 - 1]; keadaan asas; Jika LCS telah dikira; Jika watak -watak yang sama pulangan sebelumnya + 1 lain max dua urutan selepas mengeluarkan i 'th »dan u' th char satu demi satu; Berfungsi untuk mencetak semua laluan sub - urutan panjang lcslen panjang; Jika currlcs sama dengan lcslen maka cetaknya; Jika kita selesai dengan semua watak kedua -dua rentetan; Di sini kita perlu mencetak semua sub -urutan secara lexicographically, bahawa mengapa kita mula dari 'a' ke 'z' jika watak ini hadir dalam kedua -dua mereka kemudian menambahnya dalam data [] dan bahagian yang sama; Selesai adalah bendera untuk memberitahu bahawa kami telah mencetak semua berikutnya yang sepadan dengan watak semasa; Jika watak CH hadir dalam STR1 maka periksa sama ada ia terdapat dalam STR2; Jika CH hadir dalam kedua -dua mereka dan baki panjang adalah sama dengan panjang LCS yang tinggal kemudian tambah CH dalam sub -sequenece; Jika kami mendapati LCS bermula dengan watak semasa. ; Fungsi ini mencetak semua LCS Str1 dan Str2 dalam urutan leksikografi. ; Cari panjang kedua -dua rentetan; Cari panjang LCS; Cetak semua LCS menggunakan data backtracking rekursif [] digunakan untuk menyimpan LCS individu. ; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100 ; static int lcslen = 0 ; static int [ , ] dp = new int [ MAX , MAX ] ; static int lcs ( string str1 , string str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i , j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 [ i ] == str2 [ j ] ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . Max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; } static void printAll ( string str1 , string str2 , int len1 , int len2 , char [ ] data , int indx1 , int indx2 , int currlcs ) { if ( currlcs == lcslen ) { data [ currlcs ] = ' \\0' ; Console . WriteLine ( new string ( data ) ) ; return ; } if ( indx1 == len1 indx2 == len2 ) return ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { bool done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) { if ( ch == str1 [ i ] ) { for ( int j = indx2 ; j < len2 ; j ++ ) { if ( ch == str2 [ j ] && lcs ( str1 , str2 , len1 , len2 , i , j ) == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } } if ( done ) break ; } } } static void prinlAllLCSSorted ( string str1 , string str2 ) { int len1 = str1 . Length , len2 = str2 . Length ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; } static void Main ( ) { string str1 = \" abcabcaa \" , str2 = \" acbacba \" ; prinlAllLCSSorted ( str1 , str2 ) ; } }"}
{"text": "Semak elemen majoriti dalam array yang disusun | C # Program untuk menyemak unsur majoriti dalam array yang disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Kod pemacu", "code": "using System ; class GFG { static bool isMajority ( int [ ] arr , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . Length ; int x = 4 ; if ( isMajority ( arr , n , x ) == true ) Console . Write ( x + \" ▁ appears ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; else Console . Write ( x + \" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; } }"}
{"text": "Semak elemen majoriti dalam array yang disusun | C # Program untuk menyemak unsur majoriti dalam array yang disusun; Jika x hadir dalam arr [rendah ... tinggi] maka mengembalikan indeks kejadian pertama x, jika tidak pulangan - 1; Semak jika ARR [MID] adalah kejadian pertama x. arr [pertengahan] adalah kejadian pertama jika x adalah salah satu daripada yang berikut adalah benar: (i) pertengahan == 0 dan arr [mid] = = x (ii) arr [pertengahan - 1] <x dan arr [mid] == x; Fungsi ini kembali benar jika x hadir lebih daripada n / 2 kali dalam arr [] saiz n; Cari indeks kejadian pertama x dalam arr []; Jika elemen tidak hadir sama sekali, kembali palsu; Semak jika elemen hadir lebih daripada n / 2 kali; Kod pemacu", "code": "using System ; class GFG { static int _binarySearch ( int [ ] arr , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } static bool isMajority ( int [ ] arr , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . Length ; int x = 3 ; if ( isMajority ( arr , n , x ) == true ) Console . Write ( x + \" ▁ appears ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; else Console . Write ( x + \" ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; } }"}
{"text": "Semak elemen majoriti dalam array yang disusun |  ; Kod pemacu", "code": "using System ; class GFG { static bool isMajorityElement ( int [ ] arr , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . Length ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) Console . Write ( x + \" ▁ appears ▁ more ▁ than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ [ ] arr \" ) ; else Console . Write ( x + \" ▁ does ▁ not ▁ appear ▁ more ▁ \" + \" than ▁ \" + n / 2 + \" ▁ times ▁ in ▁ arr [ ] \" ) ; } }"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Kod pemacu", "code": "using System ; class GFG { static int cutRod ( int [ ] price , int n ) { int [ ] val = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = int . MinValue ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . Max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . Length ; Console . WriteLine ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + cutRod ( arr , size ) ) ; } }"}
{"text": "Ubah suai array ke array lain yang diberikan dengan menggantikan elemen array dengan jumlah array | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada arr [] boleh ditukar kepada sasaran [] dengan menggantikan mana -mana elemen dalam arr [] dengan jumlah arr []; Simpan elemen maksimum; Simpan indeks elemen maksimum; Melintasi sasaran array []; Jika elemen semasa lebih besar daripada maks; Jika elemen max adalah 1; Melintasi array, sasaran []; Jika indeks semasa tidak sama dengan indeks elemen maksimum; Kemas kini Max; Jika max kurang daripada atau sama dengan 0 ,; Mengemas kini elemen maksimum; Memanggil semula fungsi secara rekursif; Kod pemacu", "code": "using System ; class GFG { public static bool isPossible ( int [ ] target ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < target . Length ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < target . Length ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target ) ; } static public void Main ( ) { int [ ] target = { 9 , 3 , 5 } ; bool res = isPossible ( target ) ; if ( res ) { Console . WriteLine ( \" YES \" ) ; } else { Console . WriteLine ( \" NO \" ) ; } } }"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | C # pelaksanaan pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Kod pemacu", "code": "using System ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void Main ( ) { int n = 3 , m = 2 , k = 2 ; Console . Write ( nCr ( n + m , k ) ) ; } }"}
{"text": "Semak jika n boleh didapati dari 1 dengan mengulangi secara berulang dengan 10 atau 20 | C # Program untuk memeriksa sama ada n boleh diperolehi dari 1 dengan pendaraban berulang sebanyak 10 atau 20; Fungsi untuk memeriksa sama ada n boleh diperoleh atau tidak; Mengira dan mengeluarkan sifar trailing; Semak jika baki N adalah kuasa 2; Untuk memeriksa keadaan untuk prlong ya atau tidak; Kod pemacu", "code": "using System ; class GFG { static void Is_possible ( long N ) { long C = 0 ; long D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . Pow ( 2 , ( long ) ( Math . Log ( N ) / ( Math . Log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . Log ( N ) / ( Math . Log ( 2 ) ) ) ; if ( C >= D ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } else Console . WriteLine ( \" NO \" ) ; } public static void Main ( ) { long N = 2000000000000L ; Is_possible ( N ) ; } }"}
{"text": "Nombor Poligonal Tengah | C # Program untuk mencari istilah n dalam siri ini; Fungsi untuk mencari istilah n - th dalam siri ini; Kod pemacu", "code": "using System ; class GFG { static void findNthTerm ( int n ) { Console . Write ( n * n - n + 1 ) ; } public static void Main ( ) { int N = 4 ; findNthTerm ( N ) ; } }"}
{"text": "Anti | C # Program untuk pendekatan di atas; Fungsi berulang untuk membalikkan digit NUM; Mengembalikan nombor terbalik; Fungsi untuk mengira jumlah pembalikan semua pembahagi yang betul; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi Num; Jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Fungsi untuk memeriksa sama ada n adalah anti - sempurna atau tidak; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "using System ; class GFG { static int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } } return ( result + 1 ) ; } static Boolean isAntiPerfect ( int n ) { return divSum ( n ) == n ; } public static void Main ( String [ ] args ) { int N = 244 ; if ( isAntiPerfect ( N ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Program untuk mencetak Siri 1, 3, 4, 8, 15, 27, 50 â € | Sehingga N Syarat | C # pelaksanaan untuk mencetak istilah N siri yang tiga istilahnya diberikan; Berfungsi untuk mencetak siri; Menjana istilah ith dan mencetaknya; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { Console . Write ( a + \" ▁ \" ) ; return ; } if ( n == 2 ) { Console . Write ( a + \" ▁ \" + b + \" ▁ \" ) ; return ; } Console . Write ( a + \" ▁ \" + b + \" ▁ \" + c + \" ▁ \" ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; Console . Write ( d + \" ▁ \" ) ; a = b ; b = c ; c = d ; } } public static void Main ( ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; } }"}
{"text": "Diameter pokok terindeks binari dengan nod n | C # pelaksanaan pendekatan; Berfungsi untuk mencari diameter bit dengan n + 1 nod; L adalah saiz subtree sebelum subtree di mana n terletak; H ialah ketinggian subtree sebelum subtree di mana n terletak; Kes asas; Saiz subtree adalah kuasa 2; 3 kes seperti yang dijelaskan dalam pendekatan; Kod pemacu", "code": "using System ; class GFG { static int diameter ( int n ) { int L , H ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } public static void Main ( String [ ] args ) { int n = 15 ; Console . WriteLine ( diameter ( n ) ) ; } }"}
{"text": "Cari eksponen yang lebih besar di antara dua eksponen | C # pelaksanaan pendekatan; Fungsi untuk mencari sama ada A ^ B lebih besar atau c ^ d; Cari b * log (a); Cari d * log (c); Bandingkan kedua -dua nilai; Kod pemacu", "code": "using System ; class GFG { static void compareValues ( int a , int b , int c , int d ) { double log1 = Math . Log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . Log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) Console . WriteLine ( a + \" ^ \" + b ) ; else Console . WriteLine ( c + \" ^ \" + d ) ; } public static void Main ( ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; } }"}
{"text": "Jumlah nombor perdana tanpa digit utama yang ganjil | C # Program untuk pendekatan di atas; Cari semua nombor utama; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada digit adalah perdana ganjil atau tidak; Berfungsi untuk mencari jumlah; Untuk menyimpan jawapan yang diperlukan; Dapatkan semua nombor utama; Melintasi semua nombor perdana; Kedai bendera 1 Jika nombor tidak mengandungi sebarang prima yang ganjil; Cari semua digit nombor; Jika nombor tidak mengandungi sebarang prima yang ganjil; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 100005 ; static List < int > addPrimes ( ) { int n = MAX ; Boolean [ ] prime = new Boolean [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } List < int > ans = new List < int > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . Add ( p ) ; return ans ; } static Boolean is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; } static int find_Sum ( int n ) { int sum = 0 ; List < int > v = addPrimes ( ) ; for ( int i = 0 ; i < v . Count && n > 0 ; i ++ ) { int flag = 1 ; int a = v [ i ] ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v [ i ] ; } } return sum ; } public static void Main ( String [ ] args ) { int n = 7 ; Console . WriteLine ( find_Sum ( n ) ) ; } }"}
{"text": "Kira bilangan prima dalam array jumlah awalan array yang diberikan | C # pelaksanaan pendekatan; Mengembalikan elemen max; Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array bool \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari semua prima di arr []; Berfungsi untuk menghasilkan array awalan; Isi array awalan; Kod pemacu; Arahan awalan arr []; Count of Prima dalam Array Awalan", "code": "using System ; class GFG { static int max_element ( int [ ] a ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . Length ; i ++ ) m = Math . Max ( a [ i ] , m ) ; return m ; } static int primeCount ( int [ ] arr , int n ) { int max_val = max_element ( arr ) ; bool [ ] prime = new bool [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } static int [ ] getPrefixArray ( int [ ] arr , int n , int [ ] pre ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; } public static void Main ( ) { int [ ] arr = { 1 , 4 , 8 , 4 } ; int n = arr . Length ; int [ ] pre = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ; Console . Write ( primeCount ( pre , n ) ) ; } }"}
{"text": "Nilai minimum yang akan ditambah kepada x supaya sekurang -kurangnya y peratus daripada n | C # pelaksanaan pendekatan; Fungsi untuk mengembalikan nilai yang diperlukan yang mesti ditambah kepada x supaya sekurang -kurangnya y peratus daripada n; Nilai yang diperlukan; Jika x sudah> = y peratus n; Kod pemacu", "code": "using System ; class GFG { static int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . Ceiling ( val ) - x ) ; } public static void Main ( ) { int n = 10 , x = 2 , y = 40 ; Console . WriteLine ( ( int ) minValue ( n , x , y ) ) ; } }"}
{"text": "Semak jika n adalah faktorial utama | C # Program untuk memeriksa sama ada nombor yang diberikan adalah faktorial utama; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah faktorial utama; Jika n tidak perdana maka kembali palsu; Hitung faktorial; Jika n adalah perdana faktorial; n bukanlah perdana faktorial; Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; } public static void Main ( ) { int n = 23 ; if ( isFactorialPrime ( n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Susunan tempat duduk N Boys and Girls secara alternatif di sekitar meja bulat | C # Program untuk mencari bilangan cara di mana N Boys dan N Girls boleh duduk alternatif bunyi meja bulat. ; Dapatkan n; Cari FAC1 = (n - 1)! ; Cari FAC2 = N! ; Cari jumlah cara; Cetak jumlah cara", "code": "using System ; class GFG { long n = 5 ; long fac1 = 1 ; for ( int i = 2 ; i < = n - 1 ; ++ ) fac1 = fac1 * i ; long fac2 = fac1 * n ; long totalWays = fac1 * fac2 ; Console . WriteLine ( totalWays ) ; } }"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | C # Program untuk memeriksa nombor Euclid; Berfungsi untuk mendapatkan nombor perdana; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan semua nombor utama ke vektor 'arr'; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Masukkan nombor perdana seterusnya dan periksa sama ada produk + 1 = n memegang atau tidak; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int MAX = 10000 ; static List < int > arr = new List < int > ( ) ; static void SieveOfEratosthenes ( ) { bool [ ] prime = new bool [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . Add ( p ) ; } static bool isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr [ i ] ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } public static void Main ( String [ ] args ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; n = 42 ; if ( isEuclid ( n ) ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Cube sempurna lebih besar daripada nombor tertentu | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari kiub sempurna seterusnya; Kod pemacu", "code": "using System ; class GFG { static int nextPerfectCube ( int N ) { int nextN = ( int ) Math . Floor ( Math . Pow ( N , ( double ) 1 / 3 ) ) + 1 ; return nextN * nextN * nextN ; } public static void Main ( ) { int n = 35 ; Console . Write ( nextPerfectCube ( n ) ) ; } }"}
{"text": "Jumlah semua pembahagi utama nombor | C # Program untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kembali jenis fungsi SQRT jika terapung; Kedua -dua faktor adalah sama; Kedua -dua faktor tidak sama (i dan n / i); Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) Math . Sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; } static void Main ( ) { int n = 60 ; Console . WriteLine ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + SumOfPrimeDivisors ( n ) ) ; } }"}
{"text": "Kedudukan N di antara nombor yang diperbuat daripada 2, 3, 5 & 7 | C # kedudukan program N di antara nombor yang diperbuat daripada 2, 3, 5 & 7; Jika nombor adalah 2 maka ia berada di kedudukan pos * 2 + 1; Jika nombor adalah 3 maka ia berada di kedudukan pos * 2 + 2; Jika nombor adalah 5 maka ia berada di kedudukan pos * 2 + 3; Jika nombor adalah 7 maka ia berada di kedudukan pos * 2 + 4; Kod pemacu", "code": "using System ; class GFG { static int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . Length ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } public static void Main ( String [ ] args ) { String n = \"777\" ; Console . WriteLine ( findpos ( n ) ) ; } }"}
{"text": "Mencari Co Transitif | C # Program untuk mencari Triplets Perdana yang tidak transitif antara L dan R; Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Kes 1: Kurang daripada 3 nombor antara L dan R; Kes 2: Lebih daripada 3 nombor antara L dan R; Triplet harus selalu menjadi bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.1: Tepat 3 nombor dalam julat bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.2: Tepat 3 nombor dalam julat bentuk (2 k - 1, 2 k, 2 k + 1); Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "using System ; public class GFG { static void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { Console . WriteLine ( \" ( \" + possibleA + \" , ▁ \" + possibleB + \" , ▁ \" + possibleC + \" ) \" + \" ▁ is ▁ one ▁ such ▁ possible \" + \" ▁ triplet ▁ between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } else { Console . WriteLine ( \" No ▁ Such ▁ Triplet \" + \" ▁ exists ▁ between ▁ \" + L + \" ▁ and ▁ \" + R ) ; } } static public void Main ( ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }"}
{"text": "Count n digit nombor tidak mempunyai digit tertentu | C # pelaksanaan kaedah di atas; Mencari bilangan nombor yang mungkin dengan digit N tidak termasuk digit tertentu; Memeriksa jika bilangan digit adalah sifar; Memeriksa jika bilangan digit adalah satu; Memeriksa jika bilangan digit adalah ganjil; Memanggil fungsi digitNumber dengan (digit - 1) / 2 digit; Memanggil fungsi digitnumber dengan n / 2 digit; Memanggil fungsi DigitNumber Memeriksa jika tidak termasuk digit adalah sifar atau bukan sifar; Fungsi pemacu untuk menjalankan program di atas; Memulakan pembolehubah", "code": "using System ; class GFG { static int mod = 1000000007 ; static int digitNumber ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } public static void Main ( ) { int d = 9 ; int n = 3 ; Console . WriteLine ( countExcluding ( n , d ) ) ; } }"}
{"text": "Semak jika nombor yang diberikan adalah nombor emirp atau tidak | C # Program untuk memeriksa sama ada nombor yang diberikan adalah emirp atau tidak. ; Pulangan benar jika n adalah perdana lain palsu. ; Kes sudut; Semak dari 2 hingga n - 1; Fungsi akan memeriksa sama ada nombor adalah emirp atau tidak; Semak jika n adalah perdana; Cari terbalik n; Jika kedua -dua asal dan terbalik adalah perdana, maka ia adalah nombor emirp; Fungsi pemacu; Nombor input", "code": "using System ; class Emirp { public static bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static bool isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; } public static void Main ( ) { int n = 13 ; if ( isEmirp ( n ) == true ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Program untuk menukar radian ke ijazah | C # kod untuk menukar radian ke ijazah. ; Fungsi untuk penukaran; Kod pemacu", "code": "using System ; class GFG { static double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } public static void Main ( ) { double radian = 5.0 ; double degree = Convert ( radian ) ; Console . Write ( \" degree ▁ = ▁ \" + degree ) ; } }"}
{"text": "Cari jejak matriks yang dibentuk dengan menambah baris | C # Program untuk mencari jejak matriks yang dibentuk dengan menambah baris - utama dan lajur - urutan utama matriks yang sama; Kembali jumlah integer pertama A AP; Kembalikan jejak jumlah baris - matriks utama dan lajur - matriks utama; Mencari elemen ke dalam AP sekiranya matriks utama baris. ; Mencari jumlah integer pertama AP dalam kes matriks utama baris; Mencari elemen ke dalam AP sekiranya matriks utama baris; Mencari jumlah integer pertama AP dalam kes matriks utama lajur; Program yang didorong", "code": "using System ; public class GFG { static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } static int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } static public void Main ( ) { int N = 3 , M = 3 ; Console . WriteLine ( trace ( N , M ) ) ; } }"}
{"text": "Maksimum kawasan yang paling kecil yang boleh diperoleh dengan tepat K yang diberikan segi empat tepat | C # kod untuk maksimum kawasan yang paling kecil yang boleh mendapatkan dengan tepat K Cut dari segi empat tepat yang diberikan; Fungsi utiliti; untuk kes 1 st; untuk kes kedua; Hasil akhir cetak; Kod pemacu", "code": "using System ; class GFG { static void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) Console . WriteLine ( \" Not ▁ possible \" ) ; else { int result ; if ( k < Math . Max ( m , n ) - 1 ) { result = Math . Max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . Max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } Console . WriteLine ( result ) ; } } public static void Main ( ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; } }"}
{"text": "Program untuk mencari kawasan persegi | C # Program untuk mencari kawasan persegi; berfungsi untuk mencari kawasan; Kod pemacu", "code": "using System ; class GFG { static int area_fun ( int side ) { int area = side * side ; return area ; } public static void Main ( ) { int side = 4 ; int area = area_fun ( side ) ; Console . WriteLine ( area ) ; } }"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah nombor berturut -turut | Program C # untuk mengira bilangan cara untuk menyatakan n sebagai jumlah nombor berturut -turut. ; Kaedah utiliti untuk mengira bilangan cara di mana n boleh diwakili sebagai jumlah nombor berturut -turut; Kekangan pada nilai L memberi kita kerumitan masa sebagai O (n ^ 0.5); Kod pemacu untuk menguji fungsi di atas", "code": "using System ; public class GFG { static int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } public static void Main ( ) { int N = 15 ; Console . WriteLine ( countConsecutive ( N ) ) ; N = 10 ; Console . Write ( countConsecutive ( N ) ) ; } }"}
{"text": "Nombor Automorphic | C # Program untuk memeriksa sama ada nombor adalah authomorphic; Berfungsi untuk memeriksa nombor automorphic; Simpan dataran; Mula membandingkan digit; Kembali palsu, jika mana -mana digit dari n tidak sesuai dengan angka -angka yang terakhir; Mengurangkan N dan persegi; Kod pemacu", "code": "using System ; class GFG { static bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } public static void Main ( ) { int N = 5 ; Console . Write ( isAutomorphic ( N ) ? \" Automorphic \" : \" Not ▁ Automorphic \" ) ; } }"}
{"text": "Nombor dengan bilangan maksimum faktor utama | C # Program untuk mencari integer yang mempunyai bilangan maksimum faktor utama dalam nombor semulajadi n pertama; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Nilai lalai boolean adalah palsu; Ayak eratosthenes; Menyimpan nombor perdana. ; Nombor penjanaan yang mempunyai faktor utama maksimum. ; Kod pemacu", "code": "using System ; using System . Collections ; class GFG { static int maxPrimefactorNum ( int N ) { bool [ ] arr = new bool [ N + 5 ] ; int i ; for ( i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } ArrayList prime = new ArrayList ( ) ; prime . Add ( 2 ) ; for ( i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . Add ( i ) ; } } int ans = 1 ; i = 0 ; while ( ans * ( int ) prime [ i ] <= N && i < prime . Count ) { ans *= ( int ) prime [ i ] ; i ++ ; } return ans ; } public static void Main ( ) { int N = 40 ; Console . Write ( maxPrimefactorNum ( N ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | C # Program untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Semak bit set; Kemudian kita mengeluarkan semua tetapi bit atas oleh xor 'ing u »'» s dengan rentetan 1 's' u u u u u u u u u u u u u u u u u u u u u u. ; Kod pemacu", "code": "using System ; public class GFG { static int highestPowerof2 ( int x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } public static void Main ( String [ ] args ) { int n = 10 ; Console . WriteLine ( highestPowerof2 ( n ) ) ; } }"}
{"text": "Jumlah semua pembahagi yang betul dari nombor semulajadi | C # Program untuk mencari jumlah semua pembahagian nombor semulajadi; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Kod pemacu", "code": "using System ; class GFG { static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } public static void Main ( ) { int num = 36 ; Console . Write ( divSum ( num ) ) ; } }"}
{"text": "Cari akar persegi di bawah modulo p | Tetapkan 1 (apabila p dalam bentuk 4 * i + 3) | Program C # yang cekap untuk mencari akar persegi di bawah modulo p apabila p ialah 7, 11, 19, 23, 31, ... dan lain -lain. ; Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p. ; int res = 1; Inisialisasi hasil x = x % p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Pulangan benar jika akar kuadrat n di bawah modulo p ada asumsi: p adalah bentuk 3 * i + 4 di mana i> = 1; Cuba \" + (n ^ ((p ~ ~ 1) / 4))\"; Cuba \" - (n '((p ~ ~ 1) / 4))\"; Sekiranya tiada dua kerja di atas, maka akar persegi tidak wujud; Program Pemandu untuk Menguji", "code": "using System ; public class GFG { static int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { Console . Write ( \" Invalid ▁ Input \" ) ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { Console . Write ( \" Square ▁ root ▁ is ▁ \" + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { Console . Write ( \" Square ▁ root ▁ is ▁ \" + x ) ; return ; } Console . Write ( \" Square ▁ root ▁ doesn ' t ▁ exist ▁ \" ) ; } static public void Main ( ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; } }"}
{"text": "Ujian Primal | Tetapkan 3 (Millerâ € \"Rabin) | C # Program Miller - Rabin Primality Test; Fungsi Utiliti untuk Melakukan Eksponensiasi Modular. Jika n adalah perdana. N-1 Komposit;", "code": "using System ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static bool miillerTest ( int d , int n ) { Random r = new Random ( ) ; int a = 2 + ( int ) ( r . Next ( ) % ( n - 4 ) ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } static bool isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( miillerTest ( d , n ) == false ) return false ; return true ; } static void Main ( ) { int k = 4 ; Console . WriteLine ( \" All ▁ primes ▁ smaller ▁ \" + \" than ▁ 100 : ▁ \" ) ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) Console . Write ( n + \" ▁ \" ) ; } }"}
{"text": "Panjang paling lama berturut -turut 1 s dalam perwakilan binari | C # Program untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor. ; Berfungsi untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor; Memulakan hasil; Kira bilangan lelaran untuk mencapai x = 0 .; Operasi ini mengurangkan panjang setiap urutan 1 s dengan satu. ; Kod pemacu", "code": "using System ; class GFG { private static int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } public static void Main ( ) { Console . WriteLine ( maxConsecutiveOnes ( 14 ) ) ; Console . Write ( maxConsecutiveOnes ( 222 ) ) ; } }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | C # Program untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } public static void Main ( ) { int x = 29 , y = 13 ; Console . WriteLine ( \" x ▁ - ▁ y ▁ is ▁ \" + subtract ( x , y ) ) ; } }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | C # Program untuk menolak dua nombor tanpa menggunakan pelaksanaan rekursif pengendali aritmetik. ; Program Pemandu", "code": "using System ; class GFG { static int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } public static void Main ( ) { int x = 29 , y = 13 ; Console . WriteLine ( \" x ▁ - ▁ y ▁ is ▁ \" + subtract ( x , y ) ) ; } }"}
{"text": "Kth nenek moyang semua nod dalam n | C # pelaksanaan pendekatan di atas; Berfungsi untuk menambah kelebihan di dalam pokok; DFS untuk mencari nenek moyang Kth setiap nod; Menolak nod semasa dalam vektor; Melintasi jirannya; Jika n nenek moyang tidak dijumpai untuk nod semasa; Tambah nenek moyang KTH untuk nod; Berfungsi untuk mencari nenek moyang setiap nod; Membina pokok; Menyimpan semua ibu bapa nod; Simpan nenek moyang semua nod; Cetak nenek moyang; Kod pemacu; Diberikan n dan k; Diberi tepi pokok n - ary; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void addEdge ( List < int > [ ] v , int x , int y ) { v [ x ] . Add ( y ) ; v [ y ] . Add ( x ) ; } static void dfs ( List < int > [ ] tree , List < int > temp , int [ ] ancestor , int u , int parent , int k ) { temp . Add ( u ) ; foreach ( int i in tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . RemoveAt ( temp . Count - 1 ) ; if ( temp . Count < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp [ temp . Count - k ] ; } } static void KthAncestor ( int N , int K , int E , int [ , ] edges ) { List < int > [ ] tree = new List < int > [ N + 1 ] ; for ( int i = 0 ; i < tree . Length ; i ++ ) tree [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i , 0 ] , edges [ i , 1 ] ) ; } List < int > temp = new List < int > ( ) ; int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( ancestor [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int N = 9 ; int K = 2 ; int E = 8 ; int [ , ] edges = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ; KthAncestor ( N , K , E , edges ) ; } }"}
{"text": "Pertanyaan untuk mengira elemen array lebih besar daripada atau sama dengan nombor tertentu dengan kemas kini | C # Program untuk pendekatan di atas; Berfungsi untuk membina pokok segmen; Semak kes asas; Cari titik pertengahan; Secara rekursif membina pokok segmen; Fungsi untuk menolak operasi pada pokok segmen; Berfungsi untuk mengemas kini pokok segmen; Tumpang tindih lengkap; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Mengemas kini pokok segmen secara rekursif; Berfungsi untuk memproses pertanyaan; Kes asas; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Secara rekursif mengira hasil pertanyaan; Mengembalikan hasilnya; Fungsi untuk mengira nombor yang lebih besar daripada pertanyaan yang diberikan; Susun array input; Buat pokok segmen saiz 4 * n; Membina pokok segmen; Melangkah ke atas pertanyaan; Kedai hasil dalam pelbagai; Mengemas kini unsur -unsur dalam julat yang diberikan; Cetak hasil pertanyaan; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static void build ( ArrayList sum , ArrayList a , int l , int r , int rt ) { if ( l == r ) { sum [ rt ] = a [ l - 1 ] ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; } static void pushDown ( ArrayList sum , ArrayList add , int rt , int ln , int rn ) { if ( ( int ) add [ rt ] != 0 ) { add [ rt << 1 ] = ( int ) add [ rt << 1 ] + ( int ) add [ rt ] ; add [ rt << 1 1 ] = ( int ) add [ rt << 1 1 ] + ( int ) add [ rt ] ; sum [ rt << 1 ] = ( int ) sum [ rt << 1 ] + ( int ) add [ rt ] * ln ; sum [ rt << 1 1 ] = ( int ) sum [ rt << 1 1 ] + ( int ) add [ rt ] * rn ; add [ rt ] = 0 ; } } static void update ( ArrayList sum , ArrayList add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum [ rt ] = ( int ) sum [ rt ] + C * ( r - l + 1 ) ; add [ rt ] = ( int ) add [ rt ] + C ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) update ( sum , add , L , R , C , l , m , rt << 1 ) ; if ( R > m ) update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } static int query ( ArrayList sum , ArrayList add , int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return ( int ) sum [ rt ] ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ; if ( L <= m ) ans += query ( sum , add , L , R , l , m , rt << 1 ) ; if ( R > m ) ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; return ans ; } static void sequenceMaintenance ( int n , int q , ArrayList a , ArrayList b , int m ) { a . Sort ( ) ; ArrayList sum = new ArrayList ( ) ; ArrayList add = new ArrayList ( ) ; ArrayList ans = new ArrayList ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . Add ( 0 ) ; add . Add ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , add , m , m , 1 , n , 1 ) >= ( int ) b [ i ] ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) ans . Add ( 0 ) ; else { ans . Add ( n - pos + 1 ) ; update ( sum , add , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . Write ( ans [ i ] + \" ▁ \" ) ; } } public static void Main ( string [ ] args ) { int N = 4 ; int Q = 3 ; int M = 1 ; ArrayList arr = new ArrayList ( ) { 1 , 2 , 3 , 4 } ; ArrayList query = new ArrayList ( ) { 4 , 3 , 1 } ; sequenceMaintenance ( N , Q , arr , query , M ) ; } }"}
{"text": "Kurangkan panjang array dengan berulang kali menggantikan co | C # Program untuk pendekatan di atas; Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mencari panjang array readonly dengan menggantikan pasangan coprime dengan 1; Melangkah ke atas semua pasang elemen; Semak jika GCD adalah 1; Sekiranya tiada pasangan Coprime mendapati kembali palsu; Kod pemacu; Semak sama ada satu pasangan coprime wujud dalam array; Sekiranya tidak ada pasangan seperti itu", "code": "using System ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static bool hasCoprimePair ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; } public static void Main ( String [ ] args ) { int n = 3 ; int [ ] arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { Console . Write ( 1 + \" STRNEWLINE \" ) ; } else { Console . Write ( n + \" STRNEWLINE \" ) ; } } }"}
{"text": "Mengira cara untuk berpecah n ke dalam tiga kali ganda membentuk segitiga | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan bilangan cara yang diperlukan; Semak jika A, B, C boleh membentuk segitiga atau tidak; Mengembalikan bilangan cara; Kod pemacu", "code": "using System ; class GFG { static int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } static public void Main ( ) { int n = 15 ; Console . WriteLine ( Numberofways ( n ) ) ; } }"}
{"text": "Kira pasangan yang mempunyai setiap elemen yang sama dengan indeks yang lain dari array | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak kiraan pasangan; Melangkah ke atas semua elemen array; Kenaikan kiraan; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { static void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } Console . Write ( count / 2 ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 } ; int N = arr . Length ; countPairs ( N , arr ) ; } }"}
{"text": "Cari panjang fibonacci terpanjang seperti berikutnya | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan panjang maksimum fibonacci seterusnya; Simpan semua elemen array dalam jadual hash; Semak sehingga elemen FIB seterusnya dijumpai; Elemen seterusnya FIB Subseq; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int LongestFibSubseq ( int [ ] A , int n ) { SortedSet < int > S = new SortedSet < int > ( ) ; foreach ( int t in A ) { S . Add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . Contains ( y ) && y != last ( S ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . Max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } static int last ( SortedSet < int > S ) { int ans = 0 ; foreach ( int a in S ) ans = a ; return ans ; } public static void Main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . Length ; Console . Write ( LongestFibSubseq ( A , n ) ) ; } }"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Menyusun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } static public void Main ( ) { int [ ] arr = new int [ ] { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ; Console . WriteLine ( CountMaximum ( arr , n , k ) ) ; } }"}
{"text": "Jenis maksimum gula -gula seseorang boleh makan jika hanya n / 2 daripadanya boleh dimakan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan jenis gula -gula; Mengisytiharkan hashset untuk menyimpan gula -gula; Melintasi array yang diberikan dan memasukkan elemen ke dalam set; Mengembalikan hasilnya; Berfungsi untuk mencari bilangan maksimum jenis gula -gula yang boleh dimakan seseorang; Simpan bilangan gula -gula yang dibenarkan makan; Simpan bilangan jenis gula -gula; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; public class GFG { public static int num_candyTypes ( int [ ] candies ) { Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < candies . Length ; i ++ ) { if ( ! s . ContainsKey ( candies [ i ] ) ) s . Add ( candies [ i ] , 1 ) ; } return s . Count ; } public static void distribute_candies ( int [ ] candies ) { int allowed = candies . Length / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) Console . WriteLine ( types ) ; else Console . WriteLine ( allowed ) ; } static public void Main ( ) { int [ ] candies = { 4 , 4 , 5 , 5 , 3 , 3 } ; distribute_candies ( candies ) ; } }"}
{"text": "Panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak; Kod pemacu", "code": "using System ; class GFG { static double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . Sqrt ( 2 + ( 2 * Math . Cos ( theta * ( Math . PI / 180 ) ) ) ) ; double q = a * Math . Sqrt ( 2 - ( 2 * Math . Cos ( theta * ( Math . PI / 180 ) ) ) ) ; return new double [ ] { p , q } ; } public static void Main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; Console . Write ( \" { 0 : F2 } \" + \" ▁ \" + \" { 1 : F2 } \" , ans [ 0 ] , ans [ 1 ] ) ; } }"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | C # Program untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "using System ; public class GFG { static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static void countEvenOdd ( int [ ] arr , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { Console . WriteLine ( \" Even ▁ = ▁ \" + odd + \" , ▁ Odd ▁ = ▁ \" + even ) ; } else { Console . WriteLine ( \" Even ▁ = ▁ \" + even + \" , ▁ Odd ▁ = ▁ \" + odd ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . Length ; countEvenOdd ( arr , n , K ) ; } }"}
{"text": "Bilangan cara untuk memilih pasangan yang mengandungi nombor yang lebih dan ganjil dari 1 hingga n | C # pelaksanaan pendekatan di atas; Kod pemacu", "code": "using System ; class GFG { public static void Main ( ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; Console . WriteLine ( Even * Odd ) ; } }"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | C # Program untuk pendekatan di atas; Fungsi rekursif untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; Kes asas; Tidak termasuk pasangan semasa dalam masa yang paling lama; Termasuk pasangan semasa dalam masa yang paling lama; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; class GFG { public static int longestSubSequence ( int [ , ] A , int N , int ind , int lastf , int lasts ) { ind = ( ind > 0 ? ind : 0 ) ; lastf = ( lastf > 0 ? lastf : Int32 . MinValue ) ; lasts = ( lasts > 0 ? lasts : Int32 . MaxValue ) ; if ( ind == N ) return 0 ; int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ; if ( A [ ind , 0 ] > lastf && A [ ind , 1 ] < lasts ) ans = Math . Max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind , 0 ] , A [ ind , 1 ] ) + 1 ) ; return ans ; } public static void Main ( ) { int [ , ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . GetLength ( 0 ) ; Console . Write ( longestSubSequence ( A , N ) ) ; } }"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int countTriplets ( int [ ] A ) { int cnt = 0 ; Dictionary < int , int > tuples = new Dictionary < int , int > ( ) ; foreach ( int a in A ) foreach ( int b in A ) { if ( tuples . ContainsKey ( a & b ) ) tuples [ a & b ] = tuples [ a & b ] + 1 ; else tuples . Add ( a & b , 1 ) ; } foreach ( int a in A ) foreach ( KeyValuePair < int , int > t in tuples ) if ( ( t . Key & a ) == 0 ) cnt += t . Value ; return cnt ; } public static void Main ( String [ ] args ) { int [ ] A = { 2 , 1 , 3 } ; Console . Write ( countTriplets ( A ) ) ; } }"}
{"text": "Program untuk mencetak corak lingkaran | C # pelaksanaan pendekatan; Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "using System ; class GFG { public static void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int [ , ] matrix = new int [ size , size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row , col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row , col ] ; Console . Write ( ( n < 10 ) ? ( n + \" ▁ \" ) : ( n + \" ▁ \" ) ) ; } Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { int size = 5 ; printSpiral ( size ) ; } }"}
{"text": "Cari pemain terakhir untuk dapat membalikkan watak dalam rentetan binari | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada pemain A memenangi permainan atau tidak; Kedai saiz kumpulan 0 s; Kedai saiz kumpulan 0 s; Melintasi array; Kenaikan c oleh 1 jika a [i] adalah 0; Jika tidak, tolak saiz dalam array dan tetapkan semula C ke 0; Sekiranya tidak ada substring panjang ganjil yang terdiri daripada 0 s; Sekiranya terdapat hanya 1 substring panjang ganjil yang terdiri hanya 0 s; Jika tidak; Menyimpan saiz substring terbesar dan kedua terbesar 0 s; Melintasi array v []; Jika elemen semasa lebih besar daripada yang pertama, maka kemas kini kedua -dua dan kedua; Jika arr [i] berada di antara pertama dan kedua, maka kemas kini kedua; Sekiranya keadaan itu berpuas hati; Kod pemacu", "code": "using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static void findWinner ( string a , int n ) { List < int > v = new List < int > ( ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) { c ++ ; } else { if ( c != 0 ) v . Add ( c ) ; c = 0 ; } } if ( c != 0 ) v . Add ( c ) ; if ( v . Count == 0 ) { Console . Write ( \" Player ▁ B \" ) ; return ; } if ( v . Count == 1 ) { if ( ( v [ 0 ] & 1 ) != 0 ) Console . Write ( \" Player ▁ A \" ) ; else Console . Write ( \" Player ▁ B \" ) ; return ; } int first = Int32 . MinValue ; int second = Int32 . MinValue ; for ( int i = 0 ; i < v . Count ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) != 0 && ( first + 1 ) / 2 > second ) Console . Write ( \" Player ▁ A \" ) ; else Console . Write ( \" Player ▁ B \" ) ; } public static void Main ( String [ ] args ) { string S = \"1100011\" ; int N = S . Length ; findWinner ( S , N ) ; } }"}
{"text": "Periksa sama ada rentetan kalindromik boleh dibentuk dari rentetan yang diberikan | C # Program untuk memeriksa sama ada rentetan K Palindrome atau tidak; Berfungsi untuk memeriksa sama ada rentetan adalah k palindrome atau tidak; Peta kepada kekerapan watak; Semak apabila k diberikan sama seperti panjang rentetan; Menyimpan kekerapan setiap watak dalam peta; Jika k lebih besar daripada saiz maka kembali palsu; Semak bilangan watak yang mempunyai kekerapan ganjil; Jika k kurang daripada bilangan watak frekuensi ganjil maka ia sekali lagi palsu jika tidak benar; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool can_Construct ( String S , int K ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int p = 0 ; if ( S . Length == K ) return true ; for ( int i = 0 ; i < S . Length ; i ++ ) if ( ! m . ContainsKey ( S [ i ] ) ) m . Add ( S [ i ] , 1 ) ; else m [ S [ i ] ] = m [ S [ i ] ] + 1 ; if ( K > S . Length ) return false ; else { foreach ( int h in m . Values ) { if ( h % 2 != 0 ) p = p + 1 ; } } if ( K < p ) return false ; return true ; } public static void Main ( String [ ] args ) { String S = \" annabelle \" ; int K = 4 ; if ( can_Construct ( S , K ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka |  ; Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi ToUppercase; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "using System ; class GFG { static bool equalIgnoreCase ( String str1 , String str2 ) { str1 = str1 . ToUpper ( ) ; str2 = str2 . ToUpper ( ) ; int x = str1 . CompareTo ( str2 ) ; if ( x != 0 ) { return false ; } else { return true ; } } static void equalIgnoreCaseUtil ( String str1 , String str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { Console . WriteLine ( \" Same \" ) ; } else { Console . WriteLine ( \" Not ▁ Same \" ) ; } } public static void Main ( ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text": "Program untuk mencetak corak langkah | C # Program untuk mencetak corak langkah; berfungsi untuk mencetak langkah -langkah; mengisytiharkan bendera; melintasi semua watak dalam rentetan; Jika nilai x ialah 0 .. Kemudian kita mesti kenaikan sehingga n ... Tetapkan bendera kepada Benar; Jika nilai x adalah n - 1 maka kita mesti menurunkan sehingga 0 ... Tetapkan bendera sebagai palsu; cetak x * s; memeriksa sama ada untuk kenaikan atau penurunan x; Kod pemacu; Dapatkan rentetan dan nombor n; memanggil fungsi", "code": "public class solution { using System ; public static void steps ( string str , int n ) { bool flag = false ; int x = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( x == 0 ) { flag = true ; } if ( x == n - 1 ) { flag = false ; } for ( int j = 0 ; j < x ; j ++ ) { Console . Write ( \" * \" ) ; } Console . Write ( str [ i ] + \" STRNEWLINE \" ) ; if ( flag == true ) { x ++ ; } else { x -- ; } } } public static void Main ( string [ ] args ) { int n = 4 ; string str = \" GeeksForGeeks \" ; Console . WriteLine ( \" String : ▁ \" + str ) ; Console . WriteLine ( \" Max ▁ Length ▁ of ▁ Steps : ▁ \" + n ) ; steps ( str , n ) ; } }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | C # Program untuk mengira frekuensi item array; Tandakan semua elemen array seperti yang tidak dikunjungi; Melintasi unsur -unsur array dan kekerapan kiraan; Langkau elemen ini jika sudah diproses; Kekerapan kiraan; Kod pemacu", "code": "using System ; class GFG { static void countFreq ( int [ ] arr , int n ) { Boolean [ ] visited = new Boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } Console . WriteLine ( arr [ i ] + \" ▁ \" + count ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = arr . Length ; countFreq ( arr , n ) ; } }"}
{"text": "Semak pembahagian rentetan binari dengan 2 ^ k | C # Pelaksanaan untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; fungsi untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; kiraan bilangan 0 dari yang terakhir; Jika Count = k, nombor sama rata, jadi pulangan benar lain palsu; Program pemandu untuk menguji di atas; Contoh pertama; Contoh kedua", "code": "using System ; class GFG { static bool isDivisible ( String str , int k ) { int n = str . Length ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; } public static void Main ( ) { String str1 = \"10101100\" ; int k = 2 ; if ( isDivisible ( str1 , k ) == true ) Console . Write ( \" Yes STRNEWLINE \" ) ; else Console . Write ( \" No \" ) ; String str2 = \"111010100\" ; k = 2 ; if ( isDivisible ( str2 , k ) == true ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Semak jika ada anagram rentetan adalah palindrome atau tidak | C # Program untuk memeriksa sama ada anagram rentetan adalah palindrome atau tidak; berfungsi untuk memeriksa sama ada watak rentetan boleh membentuk palindrome; Buat array kiraan dan mulakan semua nilai sebagai 0; Bagi setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan; Mengira watak -watak yang ganjil; Kembali benar jika kiraan ganjil adalah 0 atau 1 ,; Program Pemandu", "code": "using System ; public class GFG { static int NO_OF_CHARS = 256 ; static bool canFormPalindrome ( string str ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . Length ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } public static void Main ( ) { Console . WriteLine ( canFormPalindrome ( \" geeksforgeeks \" ) ? \" Yes \" : \" No \" ) ; Console . WriteLine ( canFormPalindrome ( \" geeksogeeks \" ) ? \" Yes \" : \" No \" ) ; } }"}
{"text": "Program untuk memeriksa sama ada input adalah integer atau rentetan | C # Program untuk memeriksa sama ada rentetan yang diberikan adalah integer yang sah; Pulangan benar jika s adalah nombor lain palsu; Kod pemacu; Menyimpan input dalam rentetan; Fungsi pulangan 1 jika semua elemen berada dalam julat '0 ~ »~ 9'; Fungsi pulangan 0 jika input bukan integer", "code": "using System ; public class GFG { static bool isNumber ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) if ( char . IsDigit ( s [ i ] ) == false ) return false ; return true ; } static public void Main ( String [ ] args ) { string str = \"6790\" ; if ( isNumber ( str ) ) Console . WriteLine ( \" Integer \" ) ; else Console . WriteLine ( \" String \" ) ; } }"}
{"text": "Cetak terbalik rentetan menggunakan rekursi | C # Program untuk membalikkan rentetan menggunakan rekursi; Berfungsi untuk mencetak terbalik rentetan lulus; Kod pemacu", "code": "using System ; class GFG { static void reverse ( String str ) { if ( ( str == null ) || ( str . Length <= 1 ) ) Console . Write ( str ) ; else { Console . Write ( str [ str . Length - 1 ] ) ; reverse ( str . Substring ( 0 , ( str . Length - 1 ) ) ) ; } } public static void Main ( ) { String str = \" Geeks ▁ for ▁ Geeks \" ; reverse ( str ) ; } }"}
{"text": "Kebarangkalian mengedarkan bola yang diberikan kepada dua bahagian yang mempunyai kiraan yang sama dengan warna yang berbeza | C # Program untuk pendekatan di atas; Menyimpan kiraan warna yang berbeza dalam Box1; Menyimpan kiraan warna yang berbeza dalam Box2; Fungsi untuk mengira kebarangkalian yang diperlukan; Hitung faktorial dari [1, 10]; Berikan semua bola yang berbeza ke kotak kedua; Jumlah bola; Hitung jumlah bola; Jika k adalah nombor ganjil; Jumlah cara mengedarkan bola dalam dua bahagian yang sama; Bilangan cara yang diperlukan; Mengembalikan kebarangkalian yang diperlukan; Fungsi untuk mengira jumlah bilangan pengagihan yang mungkin memenuhi syarat yang diberikan; Jika bola yang digunakan adalah sama dengan k / 2; Jika Box1 sama dengan Box2; Keadaan asas; Menyimpan bilangan cara mengedarkan bola yang tinggal tanpa termasuk bola semasa dalam Box1; Kotak kenaikan1 dengan satu; Melangkah ke atas julat [1, bola [i]]; Jika semua bola pergi ke Box1, kemudian menurunkan Box2 dengan satu; Jumlah cara memilih bola J; Kenaikan res dengan jumlah cara yang sah untuk mengedarkan bola yang tinggal; Box1 box1 oleh satu; Box2 Box2 oleh 1; Fungsi untuk mengira faktorial n; Kes asas; Melangkah ke atas julat [1, n]; Fungsi untuk mengira NCR; Kod pemacu; Cetak hasilnya", "code": "using System ; public class GFG { static int box1 = 0 ; static int box2 = 0 ; static int [ ] fact = new int [ 11 ] ; public static double getProbability ( int [ ] balls ) { factorial ( 10 ) ; box2 = balls . Length ; int K = 0 ; for ( int i = 0 ; i < balls . Length ; i ++ ) K += balls [ i ] ; if ( K % 2 == 1 ) return 0 ; long all = comb ( K , K / 2 ) ; long validPermutationss = validPermutations ( ( K / 2 ) , balls , 0 , 0 ) ; return ( double ) validPermutationss / all ; } static long validPermutations ( int n , int [ ] balls , int usedBalls , int i ) { if ( usedBalls == n ) { return box1 == box2 ? 1 : 0 ; } if ( i >= balls . Length ) return 0 ; long res = validPermutations ( n , balls , usedBalls , i + 1 ) ; box1 ++ ; for ( int j = 1 ; j <= balls [ i ] ; j ++ ) { if ( j == balls [ i ] ) box2 -- ; long combinations = comb ( balls [ i ] , j ) ; res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 ) ; } box1 -- ; box2 ++ ; return res ; } static void factorial ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; } static long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 1 } ; int N = 4 ; Console . WriteLine ( getProbability ( arr ) ) ; } }"}
{"text": "Kawasan n | C # Program untuk mencari kawasan poligon biasa dengan radius yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Sampingan dan jejari tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "using System ; class GFG { static double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . Sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } public static void Main ( ) { float r = 9 , n = 6 ; Console . WriteLine ( polyarea ( n , r ) ) ; } }"}
{"text": "Semak jika garis pada 45 darjah boleh membahagikan pesawat ke dalam dua bahagian berat yang sama |  ; Memeriksa jika satah boleh dibahagikan dengan garis pada 45 darjah supaya jumlah berat adalah sama; Putar setiap titik sebanyak 45 darjah dan mengira jumlah awalan. Juga, mencari koordinat X maksimum dan minimum; menyimpan jumlah berat sehingga titik x - y; Mencari Jumlah awalan; Line melewati saya, jadi ia tidak jatuh ke kiri atau kanan. ; Kod yang didorong", "code": "using System ; using System . Collections . Generic ; public class GFG { static void is_partition_possible ( int n , int [ ] x , int [ ] y , int [ ] w ) { Dictionary < int , int > weight_at_x = new Dictionary < int , int > ( ) ; int max_x = ( int ) - 2e3 , min_x = ( int ) 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = Math . Max ( max_x , new_x ) ; min_x = Math . Min ( min_x , new_x ) ; if ( weight_at_x . ContainsKey ( new_x ) ) { weight_at_x [ new_x ] += w [ i ] ; } else { weight_at_x . Add ( new_x , w [ i ] ) ; } } List < int > sum_till = new List < int > ( ) ; sum_till . Add ( 0 ) ; for ( int s = min_x ; s <= max_x ; s ++ ) { if ( ! weight_at_x . ContainsKey ( s ) ) { sum_till . Add ( sum_till [ sum_till . Count - 1 ] ) ; } else { sum_till . Add ( sum_till [ sum_till . Count - 1 ] + weight_at_x [ s ] ) ; } } int total_sum = sum_till [ sum_till . Count - 1 ] ; int partition_possible = 0 ; for ( int i = 1 ; i < sum_till . Count ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = 1 ; } Console . WriteLine ( partition_possible == 1 ? \" YES \" : \" NO \" ) ; } static public void Main ( ) { int n = 3 ; int [ ] x = { - 1 , - 2 , 1 } ; int [ ] y = { 1 , 1 , - 1 } ; int [ ] w = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; } }"}
{"text": "Cerun tegak lurus ke garisan | C # Program untuk mencari cerun tegak lurus ke talian; Berfungsi untuk mencari cerun garis lain; Kod pemacu", "code": "using System ; class GFG { static double findPCSlope ( double m ) { return - 1.0 / m ; } public static void Main ( ) { double m = 2.0 ; Console . Write ( findPCSlope ( m ) ) ; } }"}
{"text": "Program untuk mencari kawasan segmen bulat | C # Program untuk mencari kawasan segmen bulatan; Fungsi untuk mencari kawasan segmen; Mengira kawasan sektor; Mengira kawasan segitiga; Fungsi pemacu", "code": "using System ; class GFG { static float pi = 3.14159f ; static float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . Sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; } public static void Main ( ) { float radius = 10.0f , angle = 90.0f ; Console . WriteLine ( \" Area ▁ of ▁ minor ▁ segment ▁ = ▁ \" + area_of_segment ( radius , angle ) ) ; Console . WriteLine ( \" Area ▁ of ▁ major ▁ segment ▁ = ▁ \" + area_of_segment ( radius , ( 360 - angle ) ) ) ; } }"}
{"text": "Kawasan Sektor Pekeliling | C # Program untuk mencari kawasan sektor; Mengira kawasan sektor; Kod pemacu", "code": "using System ; class GFG { static void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) Console . WriteLine ( \" Angle ▁ not ▁ possible \" ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; Console . WriteLine ( sector ) ; } } public static void Main ( ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; } }"}
{"text": "Buat dua nombor sama dengan mendarab dengan faktor utama mereka bilangan minimum kali | C # Program untuk pendekatan di atas; Semuanya membahagikan 0; Fungsi untuk mengira jumlah faktor utama dengan faktor utama mereka; Melangkah sementara nombornya juga; Mengurangkan separuh; Berulang sehingga sqrt (n); Melangkah sementara n mempunyai faktor i; Mengeluarkan satu faktor i; Berfungsi untuk mengira bilangan faktor; Cari GCD; Cari gandaan yang tersisa di x dan y; Cari faktor utama pelbagai kiri dalam x dan y; Memulakan ans; Semak sama ada mungkin untuk mendapatkan x atau tidak; Periksa sama ada mungkin untuk mendapatkan y atau tidak; Kembali utama ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } static Dictionary < int , int > PrimeFactor ( int N ) { Dictionary < int , int > primef = new Dictionary < int , int > ( ) ; while ( N % 2 == 0 ) { if ( primef . ContainsKey ( 2 ) ) { primef [ 2 ] ++ ; } else { primef [ 2 ] = 1 ; } N = N / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . ContainsKey ( i ) ) { primef [ i ] ++ ; } else { primef [ i ] = 1 ; } N = N / 2 ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; } static int CountToMakeEqual ( int X , int Y ) { int gcdofXY = gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; Dictionary < int , int > primeX = PrimeFactor ( newX ) ; Dictionary < int , int > primeY = PrimeFactor ( newY ) ; int ans = 0 ; foreach ( KeyValuePair < int , int > keys in primeX ) { if ( X % keys . Key != 0 ) { return - 1 ; } ans += primeX [ keys . Key ] ; } foreach ( KeyValuePair < int , int > keys in primeY ) { if ( Y % keys . Key != 0 ) { return - 1 ; } ans += primeY [ keys . Key ] ; } return ans ; } static void Main ( ) { int X = 36 ; int Y = 48 ; int ans = CountToMakeEqual ( X , Y ) ; Console . Write ( ans ) ; } }"}
{"text": "Buat segmen yang diberikan bukan | C # Program untuk pendekatan di atas; Menyimpan butiran segmen; Berfungsi untuk memeriksa sama ada graf adalah bipartite atau tidak; Tanda nod sumber seperti yang dikunjungi; Tolak puncak sumber dalam barisan; Dapatkan bahagian depan barisan; Berikan warna kepada nod yang muncul; Melintasi senarai addacency nod u; Jika mana -mana nod dikunjungi & warna yang berbeza telah diberikan, maka kembali palsu; Tetapkan dikunjungi [x]; Tolak nod X ke dalam barisan; Kemas kini warna nod; Jika graf adalah bipartite; Berfungsi untuk menambah kelebihan antara nod U dan V; Berfungsi untuk memeriksa sama ada tugasan arah boleh dilakukan untuk semua segmen, supaya mereka tidak bersilang selepas jangka masa yang panjang; Menyimpan senarai adjacency graf yang dicipta; Memulakan; Menjana semua pasangan yang mungkin; Jika segmen tidak bertindih; Jika tidak, segmen bertindih; Jika kedua -dua segmen mempunyai kelajuan yang sama, maka tambahkan kelebihan; Pastikan jejak nod yang dikunjungi; Berulang untuk semua nod yang mungkin; Semak sama ada graf adalah bipartite atau tidak; Jika graf adalah bipartite; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { class Node { public int L , R , V ; } ; static Node newNode ( int L , int R , int V ) { Node temp = new Node ( ) ; temp . L = L ; temp . R = R ; temp . V = V ; return temp ; } static bool check ( List < int > [ ] Adj , int Src , int N , bool [ ] visited ) { int [ ] color = new int [ N ] ; visited [ Src ] = true ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( Src ) ; while ( q . Count > 0 ) { int u = q . Peek ( ) ; q . Dequeue ( ) ; int Col = color [ u ] ; foreach ( int x in Adj [ u ] ) { if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) { visited [ x ] = true ; q . Enqueue ( x ) ; color [ x ] = 1 - Col ; } } } return true ; } static void addEdge ( List < int > [ ] Adj , int u , int v ) { Adj [ u ] . Add ( v ) ; Adj [ v ] . Add ( u ) ; } static void isPossible ( Node [ ] Arr , int N ) { List < int > [ ] Adj = new List < int > [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Adj [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } bool [ ] visited = new bool [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . Count > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { Console . Write ( \" No \" ) ; return ; } } } Console . Write ( \" Yes \" ) ; } public static void Main ( ) { Node [ ] arr = { newNode ( 5 , 7 , 2 ) , newNode ( 4 , 6 , 1 ) , newNode ( 1 , 5 , 2 ) , newNode ( 6 , 5 , 1 ) } ; int N = arr . Length ; isPossible ( arr , N ) ; } }"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | C # Program untuk pendekatan di atas; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static void lexNumbers ( int n ) { List < int > sol = new List < int > ( ) ; dfs ( 1 , n , sol ) ; Console . WriteLine ( \" [ \" + string . Join ( \" , ▁ \" , sol ) + \" ] \" ) ; } public static void dfs ( int temp , int n , List < int > sol ) { if ( temp > n ) return ; sol . Add ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; } public static void Main ( ) { int n = 15 ; lexNumbers ( n ) ; } }"}
{"text": "Bilangan swap minimum yang diperlukan untuk menyusun pelbagai nombor N pertama | C # Program untuk mencari bilangan swap minimum yang diperlukan untuk menyusun array yang diberikan; Berfungsi untuk mencari swap minimum; Pembolehubah kiraan permulaan; Jika elemen semasa tidak berada di kedudukan yang betul; Swap elemen semasa dengan kedudukan yang betul dari elemen itu; Kenaikan untuk indeks seterusnya apabila elemen semasa berada pada kedudukan yang betul; Kod pemacu; Berfungsi untuk mencari swap minimum", "code": "using System ; class GfG { static int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . Length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 1 , 5 } ; Console . WriteLine ( minimumSwaps ( arr ) ) ; } }"}
{"text": "Gabungkan K -Sorted Doubly Linked List dalam Order Sorted | C # Program untuk menggabungkan k -sorted senarai dikaitkan dua kali ganda dalam urutan yang disusun; Nod senarai yang dipautkan; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala DLL dan int, tambah nod baru pada akhir; Memperuntukkan nod; Masukkan data; Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai batal; Jika senarai yang dipautkan kosong, maka buat nod baru sebagai kepala; Lain melintasi sehingga nod terakhir; Tukar nod terakhir yang akan datang; Buat nod terakhir seperti sebelumnya dari nod baru; Berfungsi untuk mencetak senarai; Jalankan semasa gelung melainkan nod menjadi batal; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika mana -mana senarai kosong; Perbandingan data dua senarai yang dipautkan; Simpan penunjuk kepala sebelum menggabungkan senarai; Menukar penunjuk antara dua senarai untuk penggabungan; Menukar penunjuk antara dua senarai untuk penggabungan; Syarat untuk memeriksa sama ada sesiapa yang menyenaraikan tidak berakhir; Kembali penunjuk kepala senarai yang digabungkan; Berfungsi untuk menggabungkan semua senarai yang disusun dalam susunan yang disusun; Panggilan fungsi untuk menggabungkan dua senarai dikaitkan berganda yang disusun pada satu masa; Kembali akhir disusun senarai dua kali ganda; Kod pemacu; Gelung untuk memulakan semua senarai untuk kosong; Buat senarai senarai dua kali ganda pertama1. 1 <=> 5 <=> 9; Buat senarai dikaitkan dua kali ganda kedua2. 2 <=> 3 <=> 7 <=> 12; Buat senarai dikaitkan dua kali ganda 3 senarai3. 8 <=> 11 <=> 13 <=> 18; Panggilan fungsi untuk menggabungkan semua senarai dikaitkan dua kali ganda dalam urutan yang disusun; Cetak senarai disusun akhir", "code": "using System ; class GFG { public class Node { public int data ; public Node next ; public Node prev ; } ; static Node append ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; Node last = head_ref ; new_node . data = new_data ; new_node . next = null ; if ( head_ref == null ) { new_node . prev = null ; head_ref = new_node ; return head_ref ; } while ( last . next != null ) last = last . next ; last . next = new_node ; new_node . prev = last ; return head_ref ; } static void printList ( Node node ) { Node last ; while ( node != null ) { Console . Write ( node . data + \" ▁ \" ) ; last = node ; node = node . next ; } } static Node mergeList ( Node p , Node q ) { Node s = null ; if ( p == null q == null ) { return ( p == null ? q : p ) ; } if ( p . data < q . data ) { p . prev = s ; s = p ; p = p . next ; } else { q . prev = s ; s = q ; q = q . next ; } Node head = s ; while ( p != null && q != null ) { if ( p . data < q . data ) { s . next = p ; p . prev = s ; s = s . next ; p = p . next ; } else { s . next = q ; q . prev = s ; s = s . next ; q = q . next ; } } if ( p == null ) { s . next = q ; q . prev = s ; } if ( q == null ) { s . next = p ; p . prev = s ; } return head ; } static Node mergeAllList ( Node [ ] head , int k ) { Node finalList = null ; for ( int i = 0 ; i < k ; i ++ ) { finalList = mergeList ( finalList , head [ i ] ) ; } return finalList ; } public static void Main ( ) { int k = 3 ; Node [ ] head = new Node [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { head [ i ] = null ; } head [ 0 ] = append ( head [ 0 ] , 1 ) ; head [ 0 ] = append ( head [ 0 ] , 5 ) ; head [ 0 ] = append ( head [ 0 ] , 9 ) ; head [ 1 ] = append ( head [ 1 ] , 2 ) ; head [ 1 ] = append ( head [ 1 ] , 3 ) ; head [ 1 ] = append ( head [ 1 ] , 7 ) ; head [ 1 ] = append ( head [ 1 ] , 12 ) ; head [ 2 ] = append ( head [ 2 ] , 8 ) ; head [ 2 ] = append ( head [ 2 ] , 11 ) ; head [ 2 ] = append ( head [ 2 ] , 13 ) ; head [ 2 ] = append ( head [ 2 ] , 18 ) ; Node finalList = mergeAllList ( head , k ) ; printList ( finalList ) ; } }"}
{"text": "Susun Pemilihan Rekursif | Program C # Rekursif untuk menyusun pelbagai menggunakan pilihan pemilihan; Indeks minimum pulangan; Cari minimum elemen yang tinggal; Pulangan minimum semasa dan baki. ; Jenis pemilihan rekursif. N ialah saiz [] dan indeks adalah indeks elemen permulaan. ; Kembali apabila bermula dan saiznya sama; Memanggil fungsi indeks minimum untuk indeks minimum; Bertukar apabila indeks dan indeks minimum tidak sama; swap; Fungsi pemilihan pilihan rekursif; Kod pemacu; Fungsi panggilan; Percetakan Arahan yang disusun", "code": "using System ; class GFG { static int minIndex ( int [ ] a , int i , int j ) { if ( i == j ) return i ; int k = minIndex ( a , i + 1 , j ) ; return ( a [ i ] < a [ k ] ) ? i : k ; } static void recurSelectionSort ( int [ ] a , int n , int index ) { if ( index == n ) return ; int k = minIndex ( a , index , n - 1 ) ; if ( k != index ) { int temp = a [ k ] ; a [ k ] = a [ index ] ; a [ index ] = temp ; } recurSelectionSort ( a , n , index + 1 ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 5 , 2 , 7 , 0 } ; recurSelectionSort ( arr , arr . Length , 0 ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "SENARAI SENSI RECURSIVE | Program C # rekursif untuk jenis penyisipan; Fungsi rekursif untuk menyusun array menggunakan jenis penyisipan; Kes asas; Susun pertama n - 1 elemen; Masukkan elemen terakhir pada kedudukan yang betul dalam array yang disusun. ; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Kod pemacu", "code": "using System ; class GFG { static void insertionSortRecursive ( int [ ] arr , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; } static void Main ( ) { int [ ] arr = { 12 , 11 , 13 , 5 , 6 } ; insertionSortRecursive ( arr , arr . Length ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Susun gelembung rekursif | C # Program untuk pelaksanaan rekursif jenis gelembung; Fungsi untuk melaksanakan jenis gelembung; Kes asas; Satu lulus jenis gelembung. Selepas lulus ini, elemen terbesar dipindahkan (atau bubbled) untuk berakhir. ; swap arr [i], arr [i + 1]; Unsur terbesar ditetapkan, berulang untuk array yang tinggal; Kod pemacu", "code": "using System ; class GFG { static void bubbleSort ( int [ ] arr , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } bubbleSort ( arr , n - 1 ) ; } static void Main ( ) { int [ ] arr = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; bubbleSort ( arr , arr . Length ) ; Console . WriteLine ( \" Sorted ▁ array ▁ : ▁ \" ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } }"}
{"text": "Perbezaan maksimum jumlah dua subset dari array | Tetapkan 2 | C # Program untuk pendekatan di atas; Menyimpan unsur -unsur positif; Menyimpan unsur -unsur negatif; Menyimpan kiraan 0 s; Jumlah semua nombor positif; Jumlah semua nombor negatif; Melangkah ke atas array; Menyimpan perbezaan; Menyusun nombor positif dalam urutan menaik; Menyusun nombor negatif dalam penurunan urutan; Kes 1: Sertakan nombor positif dan negatif; Letakkan semua nombor dalam subset a dan satu 0 dalam subset b; Letakkan semua nombor dalam subset A kecuali nombor positif terkecil yang dimasukkan ke dalam B; Letakkan semua nombor dalam subset b dan satu 0 dalam subset A; Letakkan nombor negatif terbesar dalam subset A dan baki dalam B; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int maxSumAfterPartition ( int [ ] arr , int n ) { List < int > pos = new List < int > ( ) ; List < int > neg = new List < int > ( ) ; int zero = 0 ; int pos_sum = 0 ; int neg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . Add ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . Add ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } int ans = 0 ; pos . Sort ( ) ; neg . Sort ( ) ; neg . Reverse ( ) ; if ( pos . Count > 0 && neg . Count > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . Count > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos [ 0 ] ) ; } } else { if ( zero > 0 ) { ans = ( - 1 * neg_sum ) ; } else { ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , - 5 , - 7 } ; int n = arr . Length ; Console . Write ( maxSumAfterPartition ( arr , n ) ) ; } }"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | C # Program untuk pendekatan di atas; Berfungsi untuk mencari elemen bitwise atau array; Menyimpan nilai maksimum yang dihasilkan dari bitwise XOR; Melintasi array arr []; Mengembalikan nilai maksimum RES; Kod pemacu", "code": "using System ; class GFG { static int MaxXOR ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 7 } ; int N = arr . Length ; Console . Write ( MaxXOR ( arr , N ) ) ; } }"}
{"text": "Kira bilangan unsur biasa antara array yang disusun dan array yang disusun terbalik | C # Program untuk pendekatan di atas; Berfungsi untuk mengira bilangan elemen yang biasa dalam kedua -dua tatasusunan; Digunakan untuk melintasi array A [] dan B [] dari depan dan belakang; Menyimpan kiraan nombor yang biasa dalam kedua -dua array; Jika A [pertama] kurang daripada b [kedua]; Meningkatkan nilai pertama; Jika B [kedua] kurang daripada [pertama]; Menurunkan nilai kedua; A [pertama] adalah sama dengan b [kedua]; Meningkatkan nilai kiraan; Meningkatkan nilai pertama; Menurunkan nilai kedua; Mengembalikan nilai kiraan; Kod pemacu", "code": "using System ; class GFG { static int countEqual ( int [ ] A , int [ ] B , int N ) { int first = 0 ; int second = N - 1 ; int count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; } static void Main ( ) { int [ ] A = { 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 } ; int [ ] B = { 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 } ; int N = A . Length ; Console . WriteLine ( countEqual ( A , B , N ) ) ; } }"}
{"text": "Pertanyaan untuk mengira nombor palindrome dari julat yang jumlah digitnya adalah nombor utama | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor n adalah palindrome atau tidak; Simpan nilai n; Simpan sebaliknya nombor n; Tempatan terbalik dan simpan di res; Jika n adalah sama dengan res, maka kembali benar; Berfungsi untuk mencari jumlah digit nombor n; Menyimpan jumlah digit; Tambah digit terakhir nombor N ke jumlah; Keluarkan digit terakhir dari N; Mengembalikan jumlah yang dihasilkan; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Jika saya adalah 1 atau 0, maka kembali palsu; Semak jika saya boleh dibahagikan dengan mana -mana nombor dalam julat [2, n / 2]; Jika n boleh dibahagikan dengan i; Berfungsi untuk mendahului semua nombor sehingga 10 ^ 5 yang palindromik dan jumlah digitnya adalah nombor utama; Melangkah ke atas julat 1 hingga 10 ^ 5; Jika saya adalah nombor palindrome; Menyimpan jumlah digit dalam i; Jika jumlah digit dalam saya adalah nombor utama; Cari jumlah awalan arr []; Fungsi untuk mengira semua nombor dalam julat yang diberikan adalah palindromik dan jumlah digit adalah nombor utama; Fungsi panggilan untuk precompute semua nombor hingga 10 ^ 5; Melintasi pertanyaan yang diberikan Q []; Cetak hasil untuk setiap pertanyaan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int [ ] arr = new int [ 100005 ] ; static bool isPalindrome ( int N ) { int temp = N ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == N ) { return true ; } else { return false ; } } static int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; } static bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i <= n / 2 ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; } static void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { int sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } } static void countNumbers ( int [ , ] Q , int N ) { precompute ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Console . WriteLine ( ( arr [ Q [ i , 1 ] ] - arr [ Q [ i , 0 ] - 1 ] ) ) ; } } static public void Main ( ) { int [ , ] Q = { { 5 , 9 } , { 1 , 101 } } ; int N = Q . GetLength ( 0 ) ; countNumbers ( Q , N ) ; } }"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan N yang mempunyai jumlah digit tidak melebihi s | C # Program untuk pendekatan di atas; Fungsi untuk mengira jumlah digit n; Berfungsi untuk mencari integer yang paling kecil yang memenuhi syarat yang diberikan; Jika jumlah digit sudah lebih kecil daripada S; Memulakan pembolehubah; Mencari digit kth terakhir; Tambah baki untuk membuat digit 0; Jika jumlah digit tidak melebihi s; Kemas kini k; Kod pemacu; Diberikan n dan s; Panggilan fungsi", "code": "using System ; class GFG { static int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } static int smallestNumber ( int n , int s ) { if ( sum ( n ) <= s ) { return n ; } int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) { int digit = ( ans / k ) % 10 ; int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; } public static void Main ( ) { int N = 3 , S = 2 ; Console . WriteLine ( smallestNumber ( N , S ) ) ; } }"}
{"text": "Memaksimumkan kiraan penurunan seterusnya berturut -turut dari array | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum bilangan berikutnya yang diperlukan; Kamus untuk menyimpan bilangan anak panah yang tersedia dengan ketinggian anak panah sebagai kunci; Menyimpan kiraan maksimum kemungkinan berikutnya; Menyimpan kiraan kemungkinan seterusnya; Semak jika elemen saya boleh menjadi sebahagian daripada mana -mana berikutnya; Kiraan seterusnya mungkin dengan arr [i] sebagai elemen seterusnya; Jika lebih daripada satu berikutnya wujud; Termasuk arr [i] dalam berikutnya; Jika tidak; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Mulakan berikutnya baru; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Kembalikan jawapannya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int maxSubsequences ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . ContainsKey ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . Add ( arr [ i ] , count - 1 ) ; } else map . Remove ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . ContainsKey ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . Add ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . ContainsKey ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . Add ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; } public static void Main ( String [ ] args ) { int n = 5 ; int [ ] arr = { 4 , 5 , 2 , 1 , 4 } ; Console . WriteLine ( maxSubsequences ( arr , n ) ) ; } }"}
{"text": "Keluarkan kejadian pertama dan terakhir yang diberikan dari rentetan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk menghapuskan kejadian pertama dan terakhir dari watak yang diberikan dari rentetan yang diberikan; Melintasi rentetan yang diberikan dari awal; Jika ch dijumpai; Melintasi rentetan yang diberikan dari hujungnya; Jika ch dijumpai; Kod pemacu", "code": "using System ; class GFG { static String removeOcc ( String s , char ch ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ch ) { s = s . Substring ( 0 , i ) + s . Substring ( i + 1 ) ; break ; } } for ( int i = s . Length - 1 ; i > - 1 ; i -- ) { if ( s [ i ] == ch ) { s = s . Substring ( 0 , i ) + s . Substring ( i + 1 ) ; break ; } } return s ; } public static void Main ( String [ ] args ) { String s = \" hello ▁ world \" ; char ch = ' l ' ; Console . Write ( removeOcc ( s , ch ) ) ; } }"}
{"text": "Langkah -langkah minimum untuk meningkatkan dan mengurangkan array untuk mencapai 0 atau n | C # Program untuk pendekatan di atas; Fungsi yang mendapati langkah -langkah minimum untuk mencapai 0 atau n untuk peningkatan array yang semakin meningkat dan menurun; Memulakan pemboleh ubah untuk mencari elemen minimum; Cari elemen minimum dalam peningkatan [] array; Memulakan pembolehubah untuk mencari elemen maksimum; Cari elemen maksimum dalam penurunan [] array; Cari langkah minimum; Cetak langkah minimum; Kod pemacu; Diberikan n; Memandangkan peningkatan dan penurunan array; Panggilan fungsi", "code": "using System ; class GFG { public static void minSteps ( int N , int [ ] increasing , int [ ] decreasing ) { int min = int . MaxValue ; foreach ( int i in increasing ) { if ( min > i ) min = i ; } int max = int . MinValue ; foreach ( int i in decreasing ) { if ( max < i ) max = i ; } int minSteps = Math . Max ( max , N - min ) ; Console . WriteLine ( minSteps ) ; } public static void Main ( String [ ] args ) { int N = 7 ; int [ ] increasing = { 3 , 5 } ; int [ ] decreasing = { 6 } ; minSteps ( N , increasing , decreasing ) ; } }"}
{"text": "Bilangan minimum swap bersebelahan yang diperlukan untuk menukar permutasi kepada permutasi lain dengan keadaan yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan swap minimum; Array baru untuk menukar kepada pengindeksan berasaskan 1; Menyimpan swap; Semak sama ada kedudukan 'X'; Kes sudut; Swap; Cetak swap minimum; Kod pemacu; Diberi nombor n; Diberi permutasi nombor N; Panggilan fungsi", "code": "using System ; class GFG { static void solve ( int [ ] P , int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { int t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } } if ( arr [ n ] == n ) { int t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; } Console . WriteLine ( cnt ) ; } public static void Main ( String [ ] args ) { int N = 9 ; int [ ] P = { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ; solve ( P , N ) ; } }"}
{"text": "Count of Prima yang menarik sehingga n | C # Program untuk mencari bilangan prima yang menarik sehingga n. ; Berfungsi untuk mencari semua nombor utama; Buat array bool \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Mengemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat itu; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Untuk menyimpan semua prima; Untuk menyimpan semua prima interset; Simpan semua dataran yang sempurna; Simpan semua quadruples yang sempurna; Simpan semua prima interset; Kembali kiraan prima interset; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void SieveOfEratosthenes ( int n , HashSet < int > allPrimes ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . Add ( p ) ; } static int countInterestingPrimes ( int n ) { HashSet < int > allPrimes = new HashSet < int > ( ) ; SieveOfEratosthenes ( n , allPrimes ) ; HashSet < int > intersetingPrimes = new HashSet < int > ( ) ; List < int > squares = new List < int > ( ) , quadruples = new List < int > ( ) ; for ( int i = 1 ; i * i <= n ; i ++ ) { squares . Add ( i * i ) ; } for ( int i = 1 ; i * i * i * i <= n ; i ++ ) { quadruples . Add ( i * i * i * i ) ; } foreach ( int a in squares ) { foreach ( int b in quadruples ) { if ( allPrimes . Contains ( a + b ) ) intersetingPrimes . Add ( a + b ) ; } } return intersetingPrimes . Count ; } public static void Main ( String [ ] args ) { int N = 10 ; Console . Write ( countInterestingPrimes ( N ) ) ; } }"}
{"text": "Semak jika array adalah array gelombang | C # kod untuk memeriksa sama ada array adalah array gelombang; Fungsi untuk memeriksa sama ada array adalah array gelombang arr: array input n: saiz array; Semak borang gelombang * jika arr [1] lebih besar daripada kiri * dan kanan. Corak yang sama akan * diikuti oleh seluruh elemen, lain * corak terbalik akan diikuti oleh elemen array; Semak elemen terakhir; Semak elemen terakhir; Kod pemacu; Array", "code": "using System ; class GFG { static bool isWaveArray ( int [ ] arr , int n ) { bool result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 2 , 4 } ; int n = arr . Length ; if ( isWaveArray ( arr , n ) ) { Console . WriteLine ( \" YES \" ) ; } else { Console . WriteLine ( \" NO \" ) ; } } }"}
{"text": "Mengira urutan yang berbeza yang diperoleh dengan menggantikan semua elemen subarray yang mempunyai unsur -unsur pertama dan terakhir yang sama dengan elemen pertama sebilangan kali | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan urutan yang memenuhi kriteria yang diberikan; Menyimpan indeks kejadian terakhir elemen; Memulakan array untuk menyimpan bilangan urutan yang berbeza yang mungkin panjang i; Kes asas; Sekiranya tiada operasi digunakan pada elemen ITH; Jika operasi digunakan pada elemen ITH; Mengemas kini kejadian terakhir Curele; Akhirnya, cetak jawapannya", "code": "using System ; class GFG { static void countPossiblities ( int [ ] arr , int n ) { int [ ] lastOccur = new int [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = - 1 ; } int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ; dp [ i ] = dp [ i - 1 ] ; if ( lastOccur [ curEle ] != - 1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; } lastOccur [ curEle ] = i ; } Console . WriteLine ( dp [ n ] ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 1 , 2 , 2 } ; int N = arr . Length ; countPossiblities ( arr , N ) ; } }"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak jumlah maksimum; Jadual DP; Memulakan array DP dengan 0 s; Kes asas; Melintasi setiap lajur; Kemas kini jawapan untuk kedua -dua baris; Cetak jumlah maksimum; Kod pemacu; Diberikan array; Bilangan lajur; Panggilan fungsi", "code": "using System ; class GFG { static void maxSum ( int [ , ] arr , int n , int m ) { int [ , ] dp = new int [ n , m + 1 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i , j ] = 0 ; } } dp [ 0 , m - 1 ] = arr [ 0 , m - 1 ] ; dp [ 1 , m - 1 ] = arr [ 1 , m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i , j ] = Math . Max ( arr [ i , j ] + dp [ 0 , j + 1 ] , arr [ i , j ] + dp [ 0 , j + 2 ] ) ; } else { dp [ i , j ] = Math . Max ( arr [ i , j ] + dp [ 1 , j + 1 ] , arr [ i , j ] + dp [ 1 , j + 2 ] ) ; } } } Console . WriteLine ( Math . Max ( dp [ 0 , 0 ] , dp [ 1 , 0 ] ) ) ; } public static void Main ( ) { int [ , ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int N = arr . GetLength ( 1 ) ; maxSum ( arr , 2 , N ) ; } }"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | C # kod untuk pendekatan di atas; Fungsi untuk mencetak jumlah maksimum yang mungkin dengan memilih kebanyakan elemen dari setiap lajur sehingga tiada pasangan berturut -turut dipilih dari satu baris; Memulakan pembolehubah; Melintasi setiap lajur; Jawapan cetak; Kod pemacu; Lajur nombor", "code": "using System ; class GFG { static void maxSum ( int [ , ] arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . Max ( r1 , r2 + arr [ 0 , i ] ) ; r2 = Math . Max ( r2 , temp + arr [ 1 , i ] ) ; } Console . WriteLine ( Math . Max ( r1 , r2 ) ) ; } public static void Main ( ) { int [ , ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int n = arr . GetLength ( 1 ) ; maxSum ( arr , n ) ; } }"}
{"text": "Kira unimodal dan bukan | C # Program untuk pendekatan di atas; Berfungsi untuk mengira faktorial sehingga nombor; Kirakan faktorial; Berfungsi untuk mencari kuasa (a, b); Melangkah sehingga B wujud; Jika B boleh dibahagikan dengan 2; Mengurangkan nilai b; Kembalikan jawapannya; Fungsi yang mengira permutasi unimodal dan bukan unimodal dari integer yang diberikan; Fungsi panggilan untuk mencari faktorial sehingga n; Berfungsi untuk mengira permutasi unimodal; Permutasi bukan unimodal adalah N! - permutasi unimodal; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "using System ; class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int mx = ( int ) 1e6 ; static int [ ] fact = new int [ ( int ) mx + 1 ] ; static void Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } } static int UniModal_per ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 != 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b /= 2 ; } return res ; } static void countPermutations ( int n ) { Calculate_factorial ( ) ; int uni_modal = UniModal_per ( 2 , n - 1 ) ; int nonuni_modal = fact [ n ] - uni_modal ; Console . Write ( uni_modal + \" ▁ \" + nonuni_modal ) ; return ; } public static void Main ( String [ ] args ) { int N = 4 ; countPermutations ( N ) ; } }"}
{"text": "Susunan terpanjang mungkin yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah | C # Program untuk mencari kemungkinan seterusnya yang paling lama yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah; Arahan awalan untuk menyimpan kejadian '1' dan '0'; Melangkah ke atas panjang rentetan; Jika watak semasa adalah '1'; Jika watak semasa adalah '0'; Tambah '1' yang tersedia untuk rentetan pertama; Tambah '0' tersedia untuk rentetan kedua; Tambah '1' yang tersedia untuk rentetan ketiga; Jawapan kemas kini; Cetak hasil yang dibaca; Kod pemacu", "code": "using System ; class GFG { static void longestSubseq ( String s , int length ) { int [ ] ones = new int [ length + 1 ] ; int [ ] zeroes = new int [ length + 1 ] ; for ( int i = 0 ; i < length ; i ++ ) { if ( s [ i ] == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; } else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = int . MinValue ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) { x += ones [ i ] ; x += ( zeroes [ j ] - zeroes [ i ] ) ; x += ( ones [ length ] - ones [ j ] ) ; answer = Math . Max ( answer , x ) ; x = 0 ; } } Console . WriteLine ( answer ) ; } public static void Main ( String [ ] args ) { String s = \"10010010111100101\" ; int length = s . Length ; longestSubseq ( s , length ) ; } }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C # pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mengira dataran terbesar dengan atmost k 1 s untuk pertanyaan Q; Gelung untuk menyelesaikan setiap pertanyaan; Melintasi setiap sub persegi dan mengira jumlah; Pecah apabila melebihi kiraan maksimum; Kod pemacu", "code": "using System ; class GFG { static void largestSquare ( int [ , ] matrix , int R , int C , int [ ] q_i , int [ ] q_j , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . Min ( Math . Min ( i , j ) , Math . Min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row , col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } Console . Write ( ans + \" STRNEWLINE \" ) ; } } public static void Main ( String [ ] args ) { int [ , ] matrix = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int [ ] q_i = { 1 } ; int [ ] q_j = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C # pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputing jumlah awalan countdp matriks; Gelung untuk menyelesaikan pertanyaan; Mengira jarak maksimum yang mungkin dari pusat dari tepi; Mengira bilangan 1 s dalam submatrix; Kod pemacu", "code": "using System ; class GFG { static void largestSquare ( int [ , ] matrix , int R , int C , int [ ] q_i , int [ ] q_j , int K , int Q ) { int [ , ] countDP = new int [ R , C ] ; countDP [ 0 , 0 ] = matrix [ 0 , 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i , 0 ] = countDP [ i - 1 , 0 ] + matrix [ i , 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 , j ] = countDP [ 0 , j - 1 ] + matrix [ 0 , j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i , j ] = matrix [ i , j ] + countDP [ i - 1 , j ] + countDP [ i , j - 1 ] - countDP [ i - 1 , j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . Min ( Math . Min ( i , j ) , Math . Min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 , y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 , y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 , y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 , y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } Console . Write ( ans + \" STRNEWLINE \" ) ; } } public static void Main ( String [ ] args ) { int [ , ] matrix = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int [ ] q_i = { 1 } ; int [ ] q_j = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
{"text": "N Masalah Tali berturut -turut | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kos minimum untuk menyambungkan tali yang diberikan; dp [i, j] = kos minimum dalam julat (i, j) jumlah [i, j] = jumlah julat (i, j); Memulakan sum jadual memset (jumlah, 0, sizeof (0)); ; Pengkomputeran kos minimum untuk semua selang waktu yang mungkin (i, j) julat kiri; Julat kanan; Tiada kos untuk tali tunggal; Kod pemacu", "code": "using System ; class GFG { static int MinCost ( int [ ] arr , int n ) { int [ , ] dp = new int [ n + 5 , n + 5 ] ; int [ , ] sum = new int [ n + 5 , n + 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i , j ] = k ; else { k += arr [ j ] ; sum [ i , j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i , j ] = int . MaxValue ; if ( i == j ) dp [ i , j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ i , k ] + dp [ k + 1 , j ] + sum [ i , j ] ) ; } } } } return dp [ 0 , n - 1 ] ; } public static void Main ( String [ ] args ) { int [ ] arr = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = arr . Length ; Console . WriteLine ( MinCost ( arr , n ) ) ; } }"}
{"text": "Panjang subsegment terpanjang yang dikemas kini selepas memasukkan atmost satu integer | C # pelaksanaan pendekatan; Berfungsi untuk mengisi semula array DP; Jika f (i, state) sudah dikira maka kembalikan nilai; Hitung f (i, state) mengikut hubungan berulang dan simpan dalam dp [,]; Fungsi yang memanggil fungsi resucrsive untuk mengisi array DP dan kemudian mengembalikan hasilnya; DP [,] array untuk menyimpan hasil f (i, 1) dan f (1, 2); Memaparkan array dp [] dengan - 1; Pastikan urutan UD dan DU terpanjang bermula pada setiap indeks dikira; Anggapkan jawapannya - 1 Nilai ini hanya akan meningkat; y ialah panjang urutan UD terpanjang bermula pada i; Jika panjangnya, tambah integer dan kemudian urutan du bermula pada i + y; Jika panjang ganjil maka tambah integer dan kemudian urutan ud bermula pada i + y; Kod pemacu", "code": "using System ; class GFG { static int f ( int i , int state , int [ ] A , int [ , ] dp , int N ) { if ( i >= N ) return 0 ; else if ( dp [ i , state ] != - 1 ) { return dp [ i , state ] ; } else { if ( i == N - 1 ) dp [ i , state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i , state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i , state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i , state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i , state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i , state ] ; } } static int maxLenSeq ( int [ ] A , int N ) { int i , j , tmp , y , ans ; int [ , ] dp = new int [ 1000 , 3 ] ; for ( i = 0 ; i < 1000 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) dp [ i , j ] = - 1 ; for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i , 1 ] ; if ( i + y >= N ) ans = Math . Max ( ans , dp [ i , 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = Math . Max ( ans , dp [ i , 1 ] + 1 + dp [ i + y , 2 ] ) ; } else if ( y % 2 == 1 ) { ans = Math . Max ( ans , dp [ i , 1 ] + 1 + dp [ i + y , 1 ] ) ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] A = { 1 , 10 , 3 , 20 , 25 , 24 } ; int n = A . Length ; Console . WriteLine ( maxLenSeq ( A , n ) ) ; } }"}
{"text": "Keluarkan elemen untuk memaksimumkan GCD array yang diberikan | C # pelaksanaan pendekatan di atas; Fungsi rekursif untuk mengembalikan GCD A dan B; Berfungsi untuk mengembalikan GCD yang dimaksimumkan selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD dari semua elemen yang mempunyai lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan GCD yang dimaksimumkan; Kod pemacu", "code": "using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int MaxGCD ( int [ ] a , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . Max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . Max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } static public void Main ( ) { int [ ] a = { 14 , 17 , 28 , 70 } ; int n = a . Length ; Console . Write ( MaxGCD ( a , n ) ) ; } }"}
{"text": "SUM MAXIMUM SUMBER DENGAN MENGURANGKAN TANDA PALING PADA ELEMENT ARAY KEDUA | C # pelaksanaan pendekatan; Berfungsi untuk mencari jumlah subarray maksimum dengan flip bermula dari indeks I; Jika bilangan flip telah melebihi; Traversal lengkap; Sekiranya negara sebelum ini telah dikunjungi; Pada mulanya; Gunakan algoritma Kadane dan hubungi dua negeri; Memoize jawapan dan mengembalikannya; Fungsi utiliti untuk memanggil flips dari indeks dan mengembalikan jawapannya; Buat array dp int dp [n] [k + 1]; ; ITERATE dan CALL FUNGSI RECURSIF DARI SETIAP INDEX UNTUK MEMBERI JUMLAH SUBARRAY MAXIMUM; kes sudut; Kod pemacu", "code": "using System ; using System . Linq ; class GFG { static int right = 2 ; static int left = 4 ; static int [ , ] dp = new int [ left + 1 , right + 1 ] ; static int findSubarraySum ( int ind , int flips , int n , int [ ] a , int k ) { if ( flips > k ) return - ( int ) 1e9 ; if ( ind == n ) return 0 ; if ( dp [ ind , flips ] != - 1 ) return dp [ ind , flips ] ; int ans = 0 ; ans = Math . Max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . Max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind , flips ] = ans ; } static int findMaxSubarraySum ( int [ ] a , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i , j ] = - 1 ; int ans = - ( int ) 1e9 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) return a . Max ( ) ; return ans ; } static void Main ( ) { int [ ] a = { - 1 , - 2 , - 100 , - 10 } ; int n = a . Length ; int k = 1 ; Console . WriteLine ( findMaxSubarraySum ( a , n , k ) ) ; } }"}
{"text": "Cari Jumlah Nombor Fibonacci Pertama N yang pertama | C # Program untuk mencari jumlah nombor fibonacci pertama yang pertama; Fungsi untuk mengira jumlah nombor Fibonacci yang pertama; nilai asas; Kod pemacu", "code": "using System ; public class GFG { static int mod = 1000000007 ; static int sumOddFibonacci ( int n ) { int [ ] Sum = new int [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; } static public void Main ( ) { int n = 6 ; Console . WriteLine ( sumOddFibonacci ( n ) ) ; }"}
{"text": "Kurangkan jumlah teddies untuk diedarkan | C # pelaksanaan pendekatan di atas; Memulakan satu tablet untuk setiap pelajar; Jika dibiarkan bersebelahan mempunyai kajian markah yang lebih tinggi dan mengubah semua nilai DP yang diberikan sebelum sehingga nilai DP yang diberikan didapati salah mengikut kekangan yang diberikan; Jika betul bersebelahan mempunyai markah yang lebih tinggi, tambahkan satu di dp kiri bersebelahan dan berikan ke kanan; Kod pemacu; n bilangan pelajar; tanda pelajar; penyelesaian masalah", "code": "using System ; class GFG { public static long fun ( int [ ] marks , int n ) { long [ ] dp = new long [ n ] ; long temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; } static void Main ( ) { int n = 6 ; int [ ] marks = new int [ ] { 1 , 4 , 5 , 2 , 2 , 1 } ; Console . Write ( fun ( marks , n ) ) ; } }"}
{"text": "Bilangan cara untuk mencapai lantai nth dengan mengambil di | C # Program untuk mencapai tangga n - dengan mengambil maksimum l leap; Unsur -unsur kombo [] menyimpan no. cara yang mungkin untuk mencapainya dengan semua kombinasi K Leaps atau kurang; Dengan mengandaikan lompatan 0 wujud dan memberikan nilainya kepada 1 untuk pengiraan; gelung untuk melangkah ke atas semua kemungkinan melompat sehingga K; ; Dalam gelung ini kita mengira semua kemungkinan lompatan untuk mencapai tangga jth dengan bantuan lompatan atau kurang; Jika lompatan itu tidak lebih daripada i - j; Kirakan nilai dan simpan dalam combo [j] untuk menggunakannya semula untuk pengiraan lompatan seterusnya untuk tangga jth; Mengembalikan tidak ada kemungkinan lompatan untuk mencapai bahagian atas bangunan n tangga; Kod pemacu; N i tangga total k adalah nilai lompatan terbesar", "code": "using System ; class GFG { static int solve ( int N , int K ) { int [ ] combo ; combo = new int [ 50 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } public static void Main ( ) { int N = 29 ; int K = 5 ; Console . WriteLine ( solve ( N , K ) ) ; solve ( N , K ) ; } }"}
{"text": "Cari yang paling lama meningkat seterusnya secara bulat | C # pelaksanaan untuk mencari LIS dengan cara bulat; Kaedah utiliti untuk mencari LIS menggunakan pengaturcaraan dinamik; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Tetapkan j berdasarkan tetingkap semasa i. e. elemen pertama tetingkap semasa; Pilih maksimum semua nilai LIS; Berfungsi untuk mencari peningkatan yang paling lama dalam cara bulat; Buat salinan Array yang diberikan dengan memasuki elemen array yang sama kepada dirinya sendiri; Lakukan lis untuk setiap tetingkap saiz n; Kaedah Pemandu", "code": "using System ; class Test { static int computeLIS ( int [ ] circBuff , int start , int end , int n ) { int [ ] LIS = new int [ n + end - start ] ; for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( int i = start + 1 ; i < end ; i ++ ) for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; int res = int . MinValue ; for ( int i = start ; i < end ; i ++ ) res = Math . Max ( res , LIS [ i ] ) ; return res ; } static int LICS ( int [ ] arr , int n ) { int [ ] circBuff = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; } public static void Main ( ) { int [ ] arr = { 1 , 4 , 6 , 2 , 3 } ; Console . Write ( \" Length ▁ of ▁ LICS ▁ is ▁ \" + LICS ( arr , arr . Length ) ) ; } }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | C # Program untuk pendekatan di atas; Berfungsi untuk mencari pekali binomial; Membina segitiga Pascal; Kod pemacu", "code": "using System ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static void Main ( ) { int n = 3 , m = 2 ; Console . WriteLine ( \" Number ▁ of ▁ Paths : ▁ \" + binomialCoeff ( n + m , n ) ) ; } }"}
{"text": "Susunan peningkatan yang paling lama (LCS + LIS) | Program C # untuk mencari panjang peningkatan yang paling lama (LCIS); Mengembalikan panjang dan LCIS dua array ARR1 [0. n - 1] dan arr2 [0 .. m - 1]; Jadual [J] akan menyimpan panjang LCI yang berakhir dengan ARR2 [J]. Kami memulakannya sebagai 0 ,; Melintasi semua elemen ARR1 []; Memulakan panjang semasa LCI; Untuk setiap elemen arr1 [], trvars semua elemen ARR2 []. ; Jika kedua -dua array mempunyai elemen yang sama. Perhatikan bahawa kami tidak memecahkan gelung di sini. ; Sekarang cari elemen umum yang lebih kecil sebelumnya untuk elemen semasa ARR1; Nilai maksimum dalam Jadual [] adalah hasil; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } public static void Main ( ) { int [ ] arr1 = { 3 , 4 , 9 , 1 } ; int [ ] arr2 = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = arr1 . Length ; int m = arr2 . Length ; Console . Write ( \" Length ▁ of ▁ LCIS ▁ is ▁ \" + LCIS ( arr1 , n , arr2 , m ) ) ; } }"}
{"text": "Panjang awalan biasa terpanjang mungkin dengan menyusun semula rentetan dalam array yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan panjang awalan biasa terpanjang dengan menyusun semula rentetan; freq [i, j]: menyimpan kekerapan aksara (= j) dalam rentetan arr [i]; Melintasi array yang diberikan; Kedai panjang rentetan semasa; Melintasi rentetan arus array yang diberikan; Mengemas kini nilai freq [i, arr [i, j]]; Menyimpan panjang awalan biasa terpanjang; Hitung kekerapan minimum setiap aksara dalam semua rentetan [] arr; Kedai nilai minimum dalam setiap baris [,] freq; Kirakan kekerapan minimum aksara semasa dalam semua rentetan. ; Kemas kini Minrowval; Kemas kini Maxlen; Kod pemacu", "code": "using System ; class GFG { static int longComPre ( String [ ] arr , int N ) { int [ , ] freq = new int [ N , 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . Length ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i , arr [ i ] [ j ] ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = Math . Min ( minRowVal , freq [ i , j ] ) ; } maxLen += minRowVal ; } return maxLen ; } public static void Main ( String [ ] args ) { String [ ] arr = { \" aabdc \" , \" abcd \" , \" aacd \" } ; int N = 3 ; Console . Write ( longComPre ( arr , N ) ) ; } }"}
{"text": "Keluarkan aksara dari rentetan yang kelihatan tepat k kali | C # Program untuk menghapuskan aksara dari rentetan yang kelihatan tepat K kali; Berfungsi untuk mengurangkan rentetan dengan mengeluarkan aksara yang kelihatan tepat K kali; Jadual Hash diasaskan kepada 0; Meningkatkan kekerapan watak; Untuk menyimpan jawapan; Indeks seterusnya dalam rentetan yang dikurangkan; Tambah watak -watak yang kelihatan tepat K kali; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int MAX_CHAR = 26 ; static String removeChars ( char [ ] arr , int k ) { int [ ] hash = new int [ MAX_CHAR ] ; int n = arr . Length ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ; String ans = \" \" ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; } public static void Main ( String [ ] args ) { char [ ] str = \" geeksforgeeks \" . ToCharArray ( ) ; int k = 2 ; Console . Write ( removeChars ( str , k ) ) ; } }"}
{"text": "Subsegments bersebelahan rentetan yang mempunyai aksara berikutnya yang berbeza | C # pelaksanaan pendekatan; Fungsi yang mencetak segmen; Arahan baru untuk setiap lelaran; Periksa sama ada watak itu dalam array; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void sub_segments ( String str , int n ) { int l = str . Length ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . Substring ( x , n ) ; List < char > arr = new List < char > ( ) ; foreach ( char y in newlist . ToCharArray ( ) ) { if ( ! arr . Contains ( y ) ) arr . Add ( y ) ; } foreach ( char y in arr ) Console . Write ( y ) ; Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { String str = \" geeksforgeeksgfg \" ; int n = 4 ; sub_segments ( str , n ) ; } }"}
{"text": "Program untuk mencari perkataan yang disulitkan | C # Program untuk melaksanakan pendekatan di atas; Fungsi statik yang diisytiharkan untuk mencari rentetan yang disulitkan; Pelbagai watak untuk menyimpan rentetan yang disulitkan; Selepas 'Z', ia harus pergi ke a. ; Menyimpan array watak dalam rentetan. ; Kod pemacu", "code": "using System ; class GFG { public static void findWord ( String c , int n ) { int co = 0 , i ; char [ ] s = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ; if ( ( c [ i ] + co ) <= 122 ) s [ i ] = ( char ) ( ( int ) c [ i ] + co ) ; else s [ i ] = ( char ) ( ( int ) c [ i ] + co - 26 ) ; } String str = String . Join ( \" \" , s ) ; Console . WriteLine ( str ) ; } public static void Main ( String [ ] args ) { String s = \" abcd \" ; findWord ( s , s . Length ) ; } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; panjang rentetan pertama; panjang rentetan kedua; Jika panjang tidak sama hanya kembali palsu kerana kedua -dua rentetan tidak boleh sama jika panjang tidak sama; gelung untuk memadankan satu demi satu semua watak kedua -dua rentetan; Jika aksara semasa kedua -dua rentetan adalah sama, tambah nilai saya untuk membandingkan watak seterusnya; Jika mana -mana watak rentetan pertama adalah beberapa watak khas atau aksara angka dan tidak sama dengan watak yang sama rentetan kedua kemudian kembali palsu; Lakukan perkara yang sama untuk rentetan kedua; Blok kod ini akan dilaksanakan jika watak -watak kedua -dua rentetan adalah kes yang berbeza; Bandingkan watak dengan nilai ASCII; Jika watak dipadankan, tingkatkan nilai saya untuk membandingkan char seterusnya; Jika semua aksara rentetan pertama dipadankan dengan aksara yang sepadan dengan rentetan kedua, maka kembali benar; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "using System ; class GFG { static bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; int len1 = str1 . Length ; int len2 = str2 . Length ; if ( len1 != len2 ) return false ; while ( i < len1 ) { if ( str1 [ i ] == str2 [ i ] ) { i ++ ; } else if ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) ) ) { return false ; } else if ( ! ( ( str2 [ i ] >= ' a ' && str2 [ i ] <= ' z ' ) || ( str2 [ i ] >= ' A ' && str2 [ i ] <= ' Z ' ) ) ) { return false ; } else { if ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) { if ( str1 [ i ] - 32 != str2 [ i ] ) return false ; } else if ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) { if ( str1 [ i ] + 32 != str2 [ i ] ) return false ; } i ++ ; return true ; static void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) Console . WriteLine ( \" Same \" ) ; else Console . WriteLine ( \" Not ▁ Same \" ) ; } public static void Main ( ) { string str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text": "Memaksimumkan nilai A dengan menggantikan beberapa digitnya dengan digit B | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai yang dimaksimumkan A; Jenis digit dalam urutan menaik; J menunjuk kepada digit terbesar di B; Jika semua digit B telah digunakan; Digit semasa telah digunakan; Mengembalikan nilai yang dimaksimumkan; Kod pemacu", "code": "using System ; class GFG { static String maxValue ( char [ ] a , char [ ] b ) { Array . Sort ( b ) ; int n = a . Length ; int m = b . Length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . Join ( \" \" , a ) ; } public static void Main ( String [ ] args ) { String a = \"1234\" ; String b = \"4321\" ; Console . Write ( maxValue ( a . ToCharArray ( ) , b . ToCharArray ( ) ) ) ; } }"}
{"text": "Mengira nombor dalam julat supaya digit di dalamnya dan produknya dengan Q tidak sama rata | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada semua digit dalam nombor dan produknya dengan Q tidak sama atau tidak; Tukar nombor pertama ke dalam rentetan; Masukkan elemen dari nombor 1 ke hash; Hitung produk yang sepadan; Tukar produk ke rentetan; Menggunakan Hash Check jika mana -mana digit padanan produk dengan digit nombor input; Jika ya, kembali palsu; Lain, kembali benar; Berfungsi untuk mengira nombor dalam julat [l, r] supaya semua digit nombor dan produknya dengan Q tidak sama rata; Semak setiap nombor antara L dan R; Kod pemacu; Panggilan fungsi", "code": "using System ; class GfG { static bool checkIfUnequal ( int n , int q ) { string s1 = n . ToString ( ) ; int [ ] a = new int [ 26 ] ; for ( int i = 0 ; i < s1 . Length ; i ++ ) a [ s1 [ i ] - '0' ] ++ ; int prod = n * q ; string s2 = prod . ToString ( ) ; for ( int i = 0 ; i < s2 . Length ; i ++ ) { if ( a [ s2 [ i ] - '0' ] ) return false ; } return true ; } static int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; } public static void Main ( ) { int l = 10 , r = 12 , q = 2 ; Console . WriteLine ( countInRange ( l , r , q ) ) ; } }"}
{"text": "Semak sama ada mungkin untuk menyusun semula rentetan binari dengan alternatif 0 s dan 1 s | C # Program untuk memeriksa sama ada kita boleh menyusun semula rentetan supaya ia mempunyai alternatif 0 s dan 1 s. ; berfungsi untuk memeriksa rentetan binari; panjang rentetan; Count Zero; Kira satu 's; jika panjangnya; jika panjang ganjil; Kod pemacu", "code": "using System ; class GfG { public static bool is_possible ( String s ) { int l = s . Length ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . Abs ( one - zero ) == 1 ) ; } public static void Main ( String [ ] args ) { String s = \"100110\" ; if ( is_possible ( s ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | C # Program untuk mengira frekuensi item array; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi aksara rentetan dan mengira frekuensi; Kod pemacu", "code": "using System ; class GFG { static int limit = 25 ; static void countFreq ( String str ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < str . Length ; i ++ ) count [ str [ i ] - ' A ' ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) Console . WriteLine ( ( char ) ( i + ' A ' ) + \" ▁ \" + count [ i ] ) ; } public static void Main ( String [ ] args ) { String str = \" GEEKSFORGEEKS \" ; countFreq ( str ) ; } }"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | C # Program untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "using System ; public class GFG { static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static void countEvenOdd ( int [ ] arr , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { Console . WriteLine ( \" Even ▁ = ▁ \" + odd + \" , ▁ Odd ▁ = ▁ \" + even ) ; } else { Console . WriteLine ( \" Even ▁ = ▁ \" + even + \" , ▁ Odd ▁ = ▁ \" + odd ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . Length ; countEvenOdd ( arr , n , K ) ; } }"}
{"text": "Google Case Of A Sentyen tertentu | C # Program untuk menukar ayat yang diberikan kepada kes unta. ; Berfungsi untuk mengeluarkan ruang dan menukar ke dalam kes unta; Semak ruang dalam ayat; penukaran ke atas kes; Jika tidak ruang, salin watak; kembali rentetan ke Main; Kod pemacu", "code": "using System ; class GFG { static String convert ( String s ) { int n = s . Length ; String s1 = \" \" ; s1 = s1 + Char . ToLower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s1 = s1 + \" ▁ \" + Char . ToLower ( s [ i + 1 ] ) ; i ++ ; } else s1 = s1 + Char . ToUpper ( s [ i ] ) ; } return s1 ; } public static void Main ( ) { String str = \" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks \" ; Console . Write ( convert ( str ) ) ; } }"}
{"text": "Ubah rentetan | C # kod untuk mengubah rentetan; Fungsi untuk mengubah kes watak; Jika watak adalah perubahan huruf kecil ke huruf besar; Jika watak adalah perubahan huruf besar kepada huruf kecil; Berfungsi untuk memadam vokal; Jika watak adalah konsonan; Fungsi untuk memasukkan \" #\"; Jika watak bukan watak istimewa; Berfungsi untuk mengubah rentetan; Fungsi pemacu; Fungsi panggilan", "code": "using System ; class Gfg { public static String change_case ( string a ) { string temp = \" \" ; int l = a . Length ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a [ i ] ; if ( ch >= ' a ' && ch <= ' z ' ) ch = ( char ) ( 65 + ( int ) ( ch - ' a ' ) ) ; else if ( ch >= ' A ' && ch <= ' Z ' ) ch = ( char ) ( 97 + ( int ) ( ch - ' A ' ) ) ; temp += ch ; } return temp ; } public static String delete_vowels ( String a ) { String temp = \" \" ; int l = a . Length ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a [ i ] ; if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' && ch != ' A ' && ch != ' E ' && ch != ' O ' && ch != ' U ' && ch != ' I ' ) temp += ch ; } return temp ; } public static String insert_hash ( String a ) { String temp = \" \" ; int l = a . Length ; char hash = ' # ' ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a [ i ] ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) temp = temp + hash + ch ; else temp = temp + ch ; } return temp ; } public static void transformString ( string a ) { string b = delete_vowels ( a ) ; string c = change_case ( b ) ; string d = insert_hash ( c ) ; Console . WriteLine ( d ) ; } public static void Main ( ) { string a = \" SunshinE ! ! \" ; transformString ( a ) ; } }"}
{"text": "Nombor TCEFREP | C # Program untuk pendekatan di atas; Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "using System ; class GFG { static int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int properDivSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } static bool isTcefrep ( int n ) { return properDivSum ( n ) == reverse ( n ) ; } public static void Main ( ) { int N = 6 ; if ( isTcefrep ( N ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Program untuk mencari n | C # Program untuk mencari nombor N - tH yang mengandungi hanya 3 dan 5 .; Jika n adalah ganjil, tambah 3 dan pindah ke ibu bapa; Jika n adalah, tambah 5 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu", "code": "using System ; class GFG { if ( ( n & 1 ) == 1 ) { res = res + \" 3 \" ; n = ( n - 1 ) / 2 ; } else { res = res + \" 5 \" ; n = ( n - 2 ) / 2 ; } } string sb = Reverse ( res ) ; return sb ; } static void Main ( ) { int n = 5 ; Console . WriteLine ( findNthNo ( n ) ) ; } }"}
{"text": "Nth non | C # Program untuk mencari nombor n - th bukan persegi. ; berfungsi untuk mencari nombor non non - persegi; Penukaran dari Int ke Long Double diperlukan untuk memelihara tempat perpuluhan selepas akar persegi. ; mengira hasilnya; Kod pemacu; memulakan nombor jangka panjang; Cetak hasilnya", "code": "using System ; class GFG { static int findNthNonSquare ( int n ) { double x = ( double ) n ; double ans = x + Math . Floor ( 0.5 + Math . Sqrt ( x ) ) ; return ( int ) ans ; } public static void Main ( ) { int n = 16 ; Console . Write ( \" The ▁ \" + n + \" th ▁ Non - Square ▁ \" + \" number ▁ is ▁ \" ) ; Console . Write ( findNthNonSquare ( n ) ) ; } }"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Program C # yang cekap untuk mencari jumlah siri dengan jumlah AP Square yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu", "code": "using System ; class GFG { static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; } public static void Main ( ) { int n = 2 ; int [ ] a = { 1 , 2 , 3 , 4 } ; Console . WriteLine ( seiresSum ( n , a ) ) ; } }"}
{"text": "Cari nombor n yang mengandungi digit k atau dibahagikan dengan k. | C # Program untuk mencari nombor n yang mengandungi digit k atau dibahagikan oleh k. ; Fungsi untuk memeriksa jika digit k berada dalam n atau tidak; mencari selebihnya; jika digit dijumpai; Fungsi untuk mencari nombor nth; Oleh kerana k adalah yang pertama yang memenuhi kriteria, jadi pertimbangkannya dalam kiraan membuat kiraan = 1 dan bermula dari i = k + 1; Memeriksa bahawa nombor itu mengandungi k digit atau dibahagikan oleh k; Kod pemacu", "code": "using System ; class GFG { public static bool checkdigit ( int n , int k ) { while ( n != 0 ) { int rem = n % 10 ; if ( rem == k ) return true ; n = n / 10 ; } return false ; } public static int findNthNumber ( int n , int k ) { for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; } public static void Main ( ) { int n = 10 , k = 2 ; Console . WriteLine ( findNthNumber ( n , k ) ) ; } }"}
{"text": "Count subarrays saiz K yang merupakan permutasi nombor dari 1 hingga k | C # Program untuk melaksanakan pendekatan di atas; Simpan indeks nombor array; Kemas kini indeks min dan max dengan indeks semasa dan periksa sama ada ia adalah permutasi yang sah; Kod pemacu", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static int find_permutations ( ArrayList arr ) { int cnt = 0 ; int max_ind = - 1 , min_ind = 10000000 ; int n = arr . Count ; Dictionary < int , int > index_of = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { index_of [ ( int ) arr [ i ] ] = i + 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { max_ind = Math . Max ( max_ind , index_of [ i ] ) ; min_ind = Math . Min ( min_ind , index_of [ i ] ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; } public static void Main ( string [ ] args ) { ArrayList nums = new ArrayList ( ) ; nums . Add ( 2 ) ; nums . Add ( 3 ) ; nums . Add ( 1 ) ; nums . Add ( 5 ) ; nums . Add ( 4 ) ; Console . Write ( find_permutations ( nums ) ) ; } }"}
{"text": "Count of integer yang membahagikan semua elemen array yang diberikan | C # pelaksanaan pendekatan; Fungsi rekursif untuk mengembalikan GCD; Berfungsi untuk mengembalikan kiraan bilangan bulat yang diperlukan; Untuk menyimpan GCD unsur -unsur array; Untuk menyimpan kiraan faktor GCD yang dijumpai; Jika G adalah persegi yang sempurna; Faktor muncul berpasangan; Kod pemacu", "code": "using System ; class GFG { static int calgcd ( int a , int b ) { if ( b == 0 ) return a ; return calgcd ( b , a % b ) ; } static int getCount ( int [ ] a , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; } public static void Main ( ) { int [ ] a = { 4 , 16 , 1024 , 48 } ; int n = a . Length ; Console . WriteLine ( getCount ( a , n ) ) ; } }"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Menyimpan watak yang dikunjungi; Menyimpan jawapannya; Melintasi rentetan; Jika sudah dikunjungi; Menyimpan kos maksimum untuk mengeluarkan watak tertentu; Simpan jumlah kos penghapusan watak tertentu; Tandakan watak semasa yang dikunjungi; Melintasi indeks rentetan [i, n - 1]; Jika ada pendua yang dijumpai; Mengemas kini kos maksimum dan jumlah kos; Tandakan watak semasa yang dikunjungi; Simpan watak dengan kos maksimum dan padamkan yang lain; Mengembalikan kos minimum; Kod pemacu; Rentetan input; Arahan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { public static int delCost ( string s , int [ ] cost ) { bool [ ] visited = new bool [ s . Length ] ; int ans = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( visited [ i ] != false ) { continue ; } int maxDel = 0 ; int totalCost = 0 ; visited [ i ] = true ; for ( int j = i ; j < s . Length ; j ++ ) { if ( s [ i ] == s [ j ] ) { maxDel = Math . Max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ; visited [ j ] = true ; } } ans += totalCost - maxDel ; } return ans ; } public static void Main ( ) { string s = \" AAABBB \" ; int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ; Console . Write ( delCost ( s , cost ) ) ; } }"}
{"text": "Buat semua elemen array sama dengan menggantikan tiga kali ganda dengan bitwise xor mereka | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari tiga kali ganda yang menggantikannya dengan XOR mereka membuat semua elemen array sama; Jika n juga; Hitung XOR unsur array; Melintasi array; Kemas kini XOR; Jika XOR tidak sama dengan 0; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi", "code": "using System ; class GFG { static void checkXOR ( int [ ] arr , int N ) { if ( N % 2 == 0 ) { int xro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xro ^= arr [ i ] ; } if ( xro != 0 ) { Console . WriteLine ( - 1 ) ; return ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { Console . WriteLine ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( i + 2 ) ) ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { Console . WriteLine ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( N - 1 ) ) ; } } else { for ( int i = 0 ; i < N - 2 ; i += 2 ) { Console . WriteLine ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( i + 2 ) ) ; } for ( int i = 0 ; i < N - 2 ; i += 2 ) { Console . WriteLine ( i + \" ▁ \" + ( i + 1 ) + \" ▁ \" + ( N - 1 ) ) ; } } } public static void Main ( ) { int [ ] arr = { 4 , 2 , 1 , 7 , 2 } ; int N = arr . Length ; checkXOR ( arr , N ) ; } }"}
{"text": "Buat semua elemen array walaupun dengan menggantikan sepasang elemen array bersebelahan dengan jumlah mereka | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan minimum operasi yang diperlukan untuk membuat semua elemen array walaupun; Kedai minimum penggantian minimum untuk membuat semua elemen array walaupun; Menyimpan kiraan nombor berterusan ganjil; Melintasi array; Jika arr [i] adalah nombor ganjil; Kemas kini ODD_CONT_SEG; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Tetapkan semula ODD_CONT_SEG = 0; Jika odd_cont_seg melebihi 0; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Cetak hasilnya; Kod pemandu", "code": "using System ; public class GFG { static int make_array_element_even ( int [ ] arr , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 5 , 11 , 6 } ; int N = arr . Length ; Console . Write ( make_array_element_even ( arr , N ) ) ; } }"}
{"text": "Cari nombor k sedemikian rupa sehingga betul -betul elemen array lebih besar daripada atau sama dengan k | C # Program untuk pendekatan di atas; Fungsi untuk mencari k yang mana terdapat unsur -unsur array yang lebih besar daripada atau sama dengan k; Mencari elemen array terbesar; Nilai kemungkinan k; Melintasi array; Jika elemen array semasa lebih besar daripada atau sama dengan i; Jika saya pelbagai elemen adalah lebih besar daripada atau sama dengan i; Jika tidak; Untuk mencari elemen maksimum; Kod pemacu", "code": "using System ; class GFG { public static int zvalue ( int [ ] nums ) { int m = max_element ( nums ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . Length ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return - 1 ; } public static int max_element ( int [ ] nums ) { int max = nums [ 0 ] ; for ( int i = 1 ; i < nums . Length ; i ++ ) max = Math . Max ( max , nums [ i ] ) ; return max ; } public static void Main ( String [ ] args ) { int [ ] nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; Console . WriteLine ( zvalue ( nums ) ) ; } }"}
{"text": "Anagrams lexicographically terkecil dan terbesar rentetan yang mengandungi rentetan lain sebagai substringnya | C # Program untuk pendekatan di atas; Berfungsi untuk mencari anagram terkecil rentetan yang mengandungi rentetan lain; Memulakan peta dan set; Melangkah ke atas S1; Menyimpan kekerapan aksara yang ada di S1; Menyimpan watak -watak yang berbeza dalam S1; Mengurangkan kekerapan aksara dari m yang sudah ada di S2; Melintasi abjad dalam urutan yang disusun; Jika watak semasa set tidak sama dengan watak semasa S2; Jika elemen sama dengan watak semasa S2; Memeriksa watak kedua yang berbeza dalam S2; S2 [J] akan menyimpan watak kedua yang berbeza; Kembalikan jawapannya; Berfungsi untuk mencari anagram leksikografi terbesar rentetan yang mengandungi rentetan lain; Mendapatkan anagram terkecil secara lexicographically; D1 menyimpan awalan; D2 menyimpan akhiran; Mengembalikan hasilnya; Kod pemacu; Diberikan dua rentetan; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static Tuple < string , int > lexico_smallest ( string s1 , string s2 ) { Dictionary < char , int > M = new Dictionary < char , int > ( ) ; HashSet < char > S = new HashSet < char > ( ) ; Tuple < string , int > pr ; for ( int i = 0 ; i <= s1 . Length - 1 ; ++ i ) { if ( M . ContainsKey ( s1 [ i ] ) ) { M [ s1 [ i ] ] ++ ; } else { M [ s1 [ i ] ] = 1 ; } S . Add ( s1 [ i ] ) ; } for ( int i = 0 ; i <= s2 . Length - 1 ; ++ i ) { if ( M . ContainsKey ( s2 [ i ] ) ) { M [ s2 [ i ] ] -- ; } else { M [ s2 [ i ] ] = - 1 ; } } char c = s2 [ 0 ] ; int index = 0 ; string res = \" \" ; foreach ( char x in S ) { if ( x != c ) { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { int j = 0 ; index = res . Length ; while ( s2 [ j ] == x ) { j ++ ; } if ( s2 [ j ] < c ) { res += s2 ; for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } index += M [ x ] ; res += s2 ; } } } res = \" aageeksgghmnpt \" ; pr = new Tuple < string , int > ( res , index ) ; return pr ; } static string lexico_largest ( string s1 , string s2 ) { Tuple < string , int > pr = lexico_smallest ( s1 , s2 ) ; string d1 = \" \" ; for ( int i = pr . Item2 - 1 ; i >= 0 ; i -- ) { d1 += pr . Item1 [ i ] ; } string d2 = \" \" ; for ( int i = pr . Item1 . Length - 1 ; i >= pr . Item2 + s2 . Length ; -- i ) { d2 += pr . Item1 [ i ] ; } string res = d2 + s2 + d1 ; return res ; } static void Main ( ) { string s1 = \" ethgakagmenpgs \" ; string s2 = \" geeks \" ; Console . WriteLine ( lexico_smallest ( s1 , s2 ) . Item1 ) ; Console . Write ( lexico_largest ( s1 , s2 ) ) ; } }"}
{"text": "Pertanyaan untuk mencari kiraan laluan terpendek di dalam pokok yang mengandungi kelebihan yang diberikan | C # pelaksanaan untuk pendekatan di atas; Senarai Adjacency untuk mewakili pokok; Bilangan simpang; Mark yang melawat / tidak dapat Vertices; Menyimpan saiz subtree nod yang sepadan; Berfungsi untuk mewujudkan kelebihan antara dua simpul; Tambah senarai A ke B; Tambah B ke senarai A; Berfungsi untuk melaksanakan DFS; Tandakan puncak yang dikunjungi; Termasuk nod dalam subtree; Melintasi semua anaknya; Berfungsi untuk mencetak bilangan laluan yang diperlukan; Kod pemacu; Bilangan simpang; Memanggil fungsi DFS yang diubah suai; Kira pasangan simpang di pokok", "code": "using System ; using System . Collections . Generic ; class GFG { static int sz = ( int ) 1e5 ; static List < int > [ ] tree = new List < int > [ sz ] ; static int n ; static bool [ ] vis = new bool [ sz ] ; static int [ ] subtreeSize = new int [ sz ] ; static void addEdge ( int a , int b ) { tree [ a ] . Add ( b ) ; tree [ b ] . Add ( a ) ; } static void dfs ( int x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; foreach ( int i in tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } } static void countPairs ( int a , int b ) { int sub = Math . Min ( subtreeSize [ a ] , subtreeSize [ b ] ) ; Console . Write ( sub * ( n - sub ) + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { n = 6 ; for ( int i = 0 ; i < tree . Length ; i ++ ) tree [ i ] = new List < int > ( ) ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ; dfs ( 0 ) ; countPairs ( 1 , 3 ) ; countPairs ( 0 , 2 ) ; } }"}
{"text": "Kira permutasi array yang mempunyai setiap elemen sebagai pelbagai atau faktor indeksnya | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kiraan permutasi yang dikehendaki; Kes asas; Jika saya belum dimasukkan; Backtrack; Masukkan i; Berulang untuk mencari permutasi yang sah; Keluarkan i; Kembalikan kiraan readonly; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int findPermutation ( HashSet < int > arr , int N ) { int pos = arr . Count + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! arr . Contains ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . Add ( i ) ; res += findPermutation ( arr , N ) ; arr . Remove ( i ) ; } } } return res ; } public static void Main ( String [ ] args ) { int N = 5 ; HashSet < int > arr = new HashSet < int > ( ) ; Console . Write ( findPermutation ( arr , N ) ) ; } }"}
{"text": "Semak jika jumlah y boleh didapati dari array oleh operasi yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mendapatkan jumlah y dari urutan jumlah x dari array [] arr; Simpan perbezaan; Melangkah ke atas array; Jika diff dikurangkan kepada 0; Kod pemacu", "code": "using System ; class GFG { static void solve ( int [ ] arr , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 9 , 10 } ; int n = arr . Length ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; } }"}
{"text": "Jarak paling jauh dari nod dari setiap nod pokok | C # Program untuk melaksanakan pendekatan di atas; Senarai adjacency untuk menyimpan graf; Menyimpan ketinggian setiap nod; Menyimpan jarak maksimum nod dari nenek moyangnya; Berfungsi untuk menambah kelebihan antara dua simpang; Masukkan kelebihan dari u ke v; Masukkan tepi dari v ke u; Berfungsi untuk mengira ketinggian setiap nod; Melangkah dalam senarai addacency nod semasa; DFS untuk nod kanak -kanak; Hitung ketinggian nod; Meningkatkan ketinggian; Fungsi untuk mengira jarak maksimum nod dari nenek moyangnya; Melangkah dalam senarai addacency nod semasa; Cari dua kanak -kanak dengan ketinggian maksimum; Kirakan jarak maksimum dengan nenek moyang untuk setiap nod; Mengira untuk kanak -kanak; Kod pemacu; Hitung ketinggian nod pokok; Kirakan jarak maksimum dengan nenek moyang; Cetak maksimum dua jarak dari setiap nod", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int maxN = 100001 ; static List < int > [ ] adj = new List < int > [ maxN ] ; static int [ ] height = new int [ maxN ] ; static int [ ] dist = new int [ maxN ] ; static void addEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; } static void dfs1 ( int cur , int par ) { foreach ( int u in adj [ cur ] ) { if ( u != par ) { dfs1 ( u , cur ) ; height [ cur ] = Math . Max ( height [ cur ] , height [ u ] ) ; } } height [ cur ] += 1 ; } static void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ; foreach ( int u in adj [ cur ] ) { if ( u != par ) { if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; foreach ( int u in adj [ cur ] ) { if ( u != par ) { sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + Math . Max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + Math . Max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( u , cur ) ; } } } public static void Main ( String [ ] args ) { int n = 6 ; for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 5 , 6 ) ; dfs1 ( 1 , 0 ) ; dfs2 ( 1 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( ( Math . Max ( dist [ i ] , height [ i ] ) - 1 ) + \" ▁ \" ) ; } }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | C # Program untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Memeriksa B; Memeriksa A; Kod pemacu", "code": "using System ; class Middle { public static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; } public static void Main ( ) { int a = 20 , b = 30 , c = 40 ; Console . WriteLine ( middleOfThree ( a , b , c ) ) ; } }"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | C # Program untuk pelaksanaan pilihan pemilihan; Berfungsi untuk melaksanakan jenis pemilihan; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Kod pemacu; Panggilan fungsi; Cetak array", "code": "using System ; public class GFG { static void selectionSort ( int [ ] arr , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } } static void printArray ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 64 , 25 , 12 , 22 , 11 } ; int n = arr . Length ; selectionSort ( arr , n ) ; Console . Write ( \" Sorted ▁ array : ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; } }"}
{"text": "Semak jika rentetan yang diberikan boleh ditukar kepada yang lain dengan diberikan swap yang mungkin | C # Program untuk melaksanakan pendekatan di atas; Kedai panjang str1; Kedai panjang str2; Kedai watak -watak yang berbeza dari STR1; Kedai watak -watak yang berbeza dari STR2; Kedai kekerapan setiap watak Str1; Traverse string str1; Kemas kini kekerapan str1 [i]; Traverse string str1; Masukkan str1 [i] ke st1; Traverse string str2; Masukkan str1 [i] ke st1; Jika watak yang berbeza dalam str1 dan str2 tidak sama; Kedai kekerapan setiap watak Str2; Traverse string str2; Kemas kini kekerapan STR2 [i]; Sort hash1 [] array; Susun Hash2 [] array; Traverse Hash1 [] dan Hash2 []; Jika Hash1 [i] tidak sama dengan Hash2 [i]; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool checkStr1CanConStr2 ( String str1 , String str2 ) { int N = str1 . Length ; int M = str2 . Length ; HashSet < int > st1 = new HashSet < int > ( ) ; HashSet < int > st2 = new HashSet < int > ( ) ; int [ ] hash1 = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . Add ( str1 [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . Add ( str2 [ i ] ) ; } if ( st1 . Equals ( st2 ) ) { return false ; } int [ ] hash2 = new int [ 256 ] ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] ] ++ ; } Array . Sort ( hash1 ) ; Array . Sort ( hash2 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; } public static void Main ( String [ ] args ) { String str1 = \" xyyzzlll \" ; String str2 = \" yllzzxxx \" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { Console . Write ( \" True \" ) ; } else { Console . Write ( \" False \" ) ; } } }"}
{"text": "Susun array dalam julat indeks yang diberikan | C # Program untuk menyusun array dalam julat indeks yang diberikan; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Susun subarray dari arr [l] ke arr [r]; Cetak array yang diubah suai; Kod pemacu", "code": "using System ; class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . Min ( a , b ) ; int r = Math . Max ( a , b ) ; Array . Sort ( arr , l , r ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } static void Main ( ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . Length ; partSort ( arr , N , a , b ) ; } }"}
{"text": "Cari kos minimum untuk mencapai destinasi menggunakan kereta api | Penyelesaian berasaskan pengaturcaraan dinamik untuk mencari kos min untuk mencapai stesen n - 1 dari stesen 0 .; Fungsi rekursif untuk mencari jalan terpendek dari sumber 'S' ke destinasi 'd'. Fungsi ini mengembalikan kos yang paling kecil untuk mencapai stesen n - 1 dari stesen 0 .; Dist [i] menyimpan kos minimum untuk mencapai stesen I dari stesen 0 .; Pergi melalui setiap stesen dan periksa jika menggunakannya sebagai stesen perantaraan memberikan jalan yang lebih baik; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int INF = int . MaxValue , N = 4 ; static int minCost ( int [ , ] cost ) { int [ ] dist = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i , j ] ) dist [ j ] = dist [ i ] + cost [ i , j ] ; return dist [ N - 1 ] ; } public static void Main ( ) { int [ , ] cost = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; Console . WriteLine ( \" The ▁ Minimum ▁ cost ▁ to \" + \" ▁ reach ▁ station ▁ \" + N + \" ▁ is ▁ \" + minCost ( cost ) ) ; } }"}
{"text": "Bilangan gelung saiz k bermula dari nod tertentu | C # Program untuk mencari bilangan kitaran panjang k dalam graf dengan nod n. ; Kembalikan bilangan cara dari nod untuk membuat gelung saiz K dalam graf nod yang tidak disambungkan lengkap; Kod pemacu", "code": "using System ; class GFG { static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . Pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } static void Main ( ) { int n = 4 , k = 2 ; Console . Write ( numOfways ( n , k ) ) ; } }"}
{"text": "Program untuk mencari watak bernilai ASCII terbesar dan terkecil dalam rentetan | C # Program untuk mencari aksara terbesar dan terkecil dalam rentetan. ; Fungsi yang mengembalikan abjad terbesar. ; memulakan abjad max ke 'a'; Cari abjad terbesar; kembali elemen terbesar; fungsi yang mengembalikan abjad terkecil; memulakan abjad terkecil kepada 'z'; Cari abjad terkecil; kembali abjad terkecil; Kod pemacu; Rentetan input; Mengira saiz rentetan; fungsi memanggil dan mencetak nilai yang dikembalikan", "code": "using System ; class GFG { static char largest_alphabet ( String a , int n ) { char max = ' A ' ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] > max ) max = a [ i ] ; return max ; } static char smallest_alphabet ( String a , int n ) { char min = ' z ' ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < min ) min = a [ i ] ; return min ; } public static void Main ( ) { String a = \" GeEksforGeeks \" ; int size = a . Length ; Console . Write ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" ) ; Console . Write ( largest_alphabet ( a , size ) + \" ▁ and ▁ \" ) ; Console . Write ( smallest_alphabet ( a , size ) ) ; } }"}
{"text": "Buat palindrome terbesar dengan menukar paling banyak k | C # Program untuk mendapatkan palindrome terbesar mengubah digit at atmost; Mengembalikan maksimum palindrome menggunakan perubahan k; Memulakan l dan r oleh hujung kiri dan paling kanan; Pertama cuba membuat tali palindrome; Menggantikan watak kiri dan kanan dengan maksimum kedua -duanya; Jika k adalah negatif maka kita tidak boleh membuat palindrome rentetan; Pada watak pertengahan, jika k> 0 kemudian ubahnya menjadi 9; Jika watak di LTH (sama seperti RTH) kurang daripada 9; Jika tiada seorang pun daripada mereka diubah dalam gelung sebelumnya maka tolak 2 dari k dan tukar kedua -duanya ke 9; Jika salah satu daripada mereka diubah dalam gelung sebelumnya maka tolak 1 dari k (1 lagi telah dikurangkan) dan menjadikannya 9; Kod pemacu untuk menguji kaedah di atas", "code": "using System ; public class GFG { static String maximumPalinUsingKChanges ( String str , int k ) { char [ ] palin = str . ToCharArray ( ) ; String ans = \" \" ; int l = 0 ; int r = str . Length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = ( char ) Math . Max ( str [ l ] , str [ r ] ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) { return \" Not ▁ possible \" ; } l = 0 ; r = str . Length - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str [ l ] palin [ r ] != str [ r ] ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < palin . Length ; i ++ ) ans += palin [ i ] ; return ans ; } public static void Main ( ) { String str = \"43435\" ; int k = 3 ; Console . Write ( maximumPalinUsingKChanges ( str , k ) ) ; } }"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int countTriplets ( int [ ] A ) { int cnt = 0 ; Dictionary < int , int > tuples = new Dictionary < int , int > ( ) ; foreach ( int a in A ) foreach ( int b in A ) { if ( tuples . ContainsKey ( a & b ) ) tuples [ a & b ] = tuples [ a & b ] + 1 ; else tuples . Add ( a & b , 1 ) ; } foreach ( int a in A ) foreach ( KeyValuePair < int , int > t in tuples ) if ( ( t . Key & a ) == 0 ) cnt += t . Value ; return cnt ; } public static void Main ( String [ ] args ) { int [ ] A = { 2 , 1 , 3 } ; Console . Write ( countTriplets ( A ) ) ; } }"}
{"text": "Kurangkan kiraan pasangan bersebelahan dengan pariti yang berbeza | C # pelaksanaan pendekatan di atas; Fungsi rekursif untuk mengira pasangan bersebelahan minimum dengan pariti yang berbeza; Jika semua nombor diletakkan; Jika penggantian tidak diperlukan; Jika penggantian diperlukan; Mundur; Mundur; Berfungsi untuk memaparkan bilangan minimum elemen bersebelahan dengan pariti yang berbeza; Simpan tidak ada nombor yang tidak ada dalam array; Simpan tiada nombor ganjil yang tidak terdapat dalam array; Memadam nombor exisiting; Simpan bukan nombor dan nombor ganjil; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int min ; static void parity ( List < int > even , List < int > odd , List < int > v , int i ) { if ( i == v . Count even . Count == 0 && odd . Count == 0 ) { int count = 0 ; for ( int j = 0 ; j < v . Count - 1 ; j ++ ) { if ( v [ j ] % 2 != v [ j + 1 ] % 2 ) count ++ ; } if ( count < min ) min = count ; return ; } if ( v [ i ] != - 1 ) parity ( even , odd , v , i + 1 ) ; else { if ( even . Count != 0 ) { int x = even [ even . Count - 1 ] ; even . RemoveAt ( even . Count - 1 ) ; v [ i ] = x ; parity ( even , odd , v , i + 1 ) ; even . Add ( x ) ; } if ( odd . Count != 0 ) { int x = odd [ odd . Count - 1 ] ; odd . RemoveAt ( odd . Count - 1 ) ; v [ i ] = x ; parity ( even , odd , v , i + 1 ) ; odd . Add ( x ) ; } } } static void minDiffParity ( List < int > v , int n ) { List < int > even = new List < int > ( ) ; List < int > odd = new List < int > ( ) ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( m . ContainsKey ( i ) ) { m [ i ] = 1 ; } else { m . Add ( i , 1 ) ; } } for ( int i = 0 ; i < v . Count ; i ++ ) { if ( v [ i ] != - 1 ) m . Remove ( v [ i ] ) ; } foreach ( KeyValuePair < int , int > i in m ) { if ( i . Key % 2 == 0 ) { even . Add ( i . Key ) ; } else { odd . Add ( i . Key ) ; } } min = 1000 ; parity ( even , odd , v , 0 ) ; Console . WriteLine ( min ) ; } static void Main ( ) { int n = 8 ; List < int > v = new List < int > ( ) ; v . Add ( 2 ) ; v . Add ( 1 ) ; v . Add ( 4 ) ; v . Add ( - 1 ) ; v . Add ( - 1 ) ; v . Add ( 6 ) ; v . Add ( - 1 ) ; v . Add ( 8 ) ; minDiffParity ( v , n ) ; } }"}
{"text": "Cari triplet sedemikian rupa sehingga bilangan nod yang menghubungkan triplet ini adalah maksimum | C # pelaksanaan pendekatan; Untuk menyimpan nod yang diperlukan; Array induk untuk menjejaki semula nod; Arahan yang dikunjungi untuk mengelakkan DFS ke arah di garis pusat; Fungsi DFS untuk mencari startnode; Fungsi DFS untuk mencari endnode diameter dan mengekalkan array induk; Fungsi DFS untuk mencari nod akhir cawangan terpanjang ke diameter; Fungsi untuk mencari nod yang diperlukan; Untuk mencari node diameter; Untuk mencari nod akhir diameter; x adalah nod akhir diameter; Tandakan semua nod diameter menggunakan penjejakan belakang; Cari nod akhir cawangan terpanjang ke diameter; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 100005 ; static List < List < int > > adjacent = new List < List < int > > ( ) ; static bool [ ] visited = new bool [ MAX ] ; static int startnode , endnode , thirdnode ; static int maxi = - 1 , N ; static int [ ] parent = new int [ MAX ] ; static bool [ ] vis = new bool [ MAX ] ; static void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . Count ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } } static void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . Count ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; parent [ adjacent [ u ] [ i ] ] = u ; dfs1 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } } static void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . Count ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] && ! vis [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs2 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } } static void findNodes ( ) { dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ; dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; int x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } } static void Main ( ) { for ( int i = 0 ; i < MAX ; i ++ ) adjacent . Add ( new List < int > ( ) ) ; N = 4 ; adjacent [ 1 ] . Add ( 2 ) ; adjacent [ 2 ] . Add ( 1 ) ; adjacent [ 1 ] . Add ( 3 ) ; adjacent [ 3 ] . Add ( 1 ) ; adjacent [ 1 ] . Add ( 4 ) ; adjacent [ 4 ] . Add ( 1 ) ; findNodes ( ) ; Console . WriteLine ( \" ( \" + startnode + \" , ▁ \" + endnode + \" , ▁ \" + thirdnode + \" ) \" ) ; } }"}
{"text": "Peratusan peningkatan jumlah sfera jika radius meningkat dengan peratusan tertentu | Program C # untuk mencari peningkatan peratusan dalam jumlah sfera jika radius meningkat dengan peratusan tertentu; Kod pemacu", "code": "using System ; class GFG { static void newvol ( double x ) { Console . WriteLine ( \" percentage ▁ increase ▁ in ▁ the \" + \" ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ \" + ( Math . Pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . Pow ( x , 2 ) ) / 100 ) + \" % \" ) ; } public static void Main ( ) { double x = 10 ; newvol ( x ) ; } }"}
{"text": "Panjang kord bulatan yang jejari dan sudutnya diselipkan di pusat oleh kord diberikan | C # Program untuk mencari panjang kord bulatan yang jejari dan sudut yang diselaraskan di pusat juga diberikan; Berfungsi untuk mencari panjang kord; Kod pemacu", "code": "using System ; class GFG { static void length_of_chord ( double r , double x ) { Console . WriteLine ( \" The ▁ length ▁ of ▁ the ▁ chord \" + \" ▁ of ▁ the ▁ circle ▁ is ▁ \" + 2 * r * Math . Sin ( x * ( 3.14 / 180 ) ) ) ; } public static void Main ( String [ ] args ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; } }"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segitiga sama rata | C # Program untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segitiga sama rata; Berfungsi untuk mencari kawasan dataran; A tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "using System ; class GFG { static float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . Sqrt ( a ) / 6 ; return area ; } public static void Main ( ) { float a = 10 ; Console . WriteLine ( area ( a ) ) ; } }"}
{"text": "Panjang batang terpanjang yang boleh dimuatkan ke dalam cuboid | C # Program untuk mencari rod terpanjang yang boleh dimuatkan dalam cuboid; Berfungsi untuk mencari panjang; Pembolehubah sementara untuk memegang hasil pertengahan; Panjang rod terpanjang dikira menggunakan fungsi akar persegi; Kod pemacu; Memanggil LongeStroDincuboid () berfungsi untuk mendapatkan panjang rod terpanjang", "code": "using System ; class GFG { static double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = Math . Sqrt ( temp ) ; return result ; } public static void Main ( ) { int length = 12 , breadth = 9 , height = 8 ; Console . WriteLine ( ( int ) longestRodInCuboid ( length , breadth , height ) ) ; } }"}
{"text": "Semak sama ada titik tertentu terletak pada atau di dalam segi empat tepat | Set 3 | C # Program untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; berfungsi untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; Kod pemacu", "code": "using System ; class GFG { static bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } public static void Main ( ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) Console . Write ( \" Given ▁ point ▁ lies ▁ \" + \" inside ▁ the ▁ rectangle \" ) ; else Console . Write ( \" Given ▁ point ▁ does ▁ not ▁ \" + \" lie ▁ on ▁ the ▁ rectangle \" ) ; } }"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | C # kod untuk memaksimumkan jumlah cuboid dengan jumlah yang diberikan; Kembalikan jumlah maksimum. ; untuk panjang; untuk keluasan; untuk ketinggian; Mengira isipadu maksimum. ; Fungsi pemacu", "code": "using System ; class GFG { static int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . Max ( maxvalue , i * j * k ) ; } } return maxvalue ; } public static void Main ( ) { int s = 8 ; Console . WriteLine ( maxvolume ( s ) ) ; } }"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | C # kod untuk memaksimumkan jumlah cuboid dengan jumlah yang diberikan; Kembalikan jumlah maksimum. ; mencari panjang; mencari keluasan; Mencari ketinggian; Program yang didorong", "code": "using System ; class GFG { static int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; } public static void Main ( ) { int s = 8 ; Console . WriteLine ( maxvolume ( s ) ) ; } }"}
{"text": "Kawasan Hexagon | C # Program untuk mencari kawasan segi enam; Buat fungsi untuk mengira kawasan segi enam. ; Kod pemacu; Panjang sisi", "code": "using System ; class GFG { public static double hexagonArea ( double s ) { return ( ( 3 * Math . Sqrt ( 3 ) * ( s * s ) ) / 2 ) ; } public static void Main ( ) { double s = 4 ; Console . WriteLine ( \" Area : ▁ \" + hexagonArea ( s ) ) ; } }"}
{"text": "Bilangan maksimum kuadrat yang boleh dimuatkan dalam segitiga isosceles sudut kanan | C # Program untuk mencari dataran maksimum yang boleh dimuatkan dalam segitiga isosceles sudut kanan; fungsi untuk mencari dataran maksimum; kembali dalam O (1) dengan formula yang diperoleh; Program Pemandu", "code": "using System ; public class GFG { static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; } public static void Main ( ) { int b = 10 , m = 2 ; Console . WriteLine ( maxSquare ( b , m ) ) ; } }"}
{"text": "Semak jika segitiga yang betul mungkin dari kawasan tertentu dan hipotenus | C # Program untuk memeriksa kewujudan segitiga kanan. ; Mencetak tiga sisi segitiga kanan dari kawasan tertentu dan hipotenus jika segitiga mungkin, cetakan lain - 1 .; Deskripsi persamaan; memohon formula persamaan linear untuk mencari kedua -dua akar; Kod pemacu", "code": "using System ; class GFG { static void findRightAngle ( double A , double H ) { double D = Math . Pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { double root1 = ( H * H + Math . Sqrt ( D ) ) / 2 ; double root2 = ( H * H - Math . Sqrt ( D ) ) / 2 ; double a = Math . Sqrt ( root1 ) ; double b = Math . Sqrt ( root2 ) ; if ( b >= a ) Console . WriteLine ( a + \" ▁ \" + b + \" ▁ \" + H ) ; else Console . WriteLine ( b + \" ▁ \" + a + \" ▁ \" + H ) ; } else Console . WriteLine ( \" - 1\" ) ; } public static void Main ( ) { findRightAngle ( 6 , 5 ) ; } }"}
{"text": "Bilangan maksimum 2 x2 kotak yang boleh dimuatkan di dalam segitiga isosceles kanan | C # Program untuk mengira bilangan 2 x 2 kotak di segitiga isosceles yang betul; Mengeluarkan bahagian tambahan yang selalu kita perlukan; Kerana setiap persegi mempunyai asas panjang 2; Kod pemacu", "code": "using System ; class GFG { public static int numberOfSquares ( int _base ) { _base = ( _base - 2 ) ; _base = _base / 2 ; return _base * ( _base + 1 ) / 2 ; } public static void Main ( ) { int _base = 8 ; Console . WriteLine ( numberOfSquares ( _base ) ) ; } }"}
{"text": "Bitwise atau bitwise dan semua yang mungkin bukan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarray yang mungkin selepas melakukan setiap pertanyaan; Melintasi setiap pasangan pertanyaan; Menyimpan bitwise atau; Mengemas kini array; Cari bitwise atau array baru yang dikemas kini; Cetak Ans; Kod pemacu", "code": "using System ; class GFG { static void performQuery ( int [ ] arr , int [ , ] Q ) { for ( int i = 0 ; i < Q . Length ; i ++ ) { int or = 0 ; int x = Q [ i , 0 ] ; arr [ x - 1 ] = Q [ i , 1 ] ; for ( int j = 0 ; j < arr . Length ; j ++ ) { or = or | arr [ j ] ; } Console . Write ( or + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int [ , ] Q = { { 1 , 4 } , { 3 , 0 } } ; performQuery ( arr , Q ) ; } }"}
{"text": "Panjang terkecil nombor yang boleh dibahagi dengan k yang dibentuk dengan menggunakan d sahaja | C # Program untuk pendekatan di atas; Berfungsi untuk membentuk bilangan terkecil yang mungkin; Array untuk menandakan baki yang telah dikira sudah; Melangkah ke atas julat; Jika baki itu sudah dijumpai, kembali - 1; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; int [ ] v = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) v [ i ] = 0 ; v [ m ] = 1 ; while ( true ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } } public static void Main ( ) { int d = 1 ; int k = 41 ; Console . Write ( smallest ( k , d ) ) ; } }"}
{"text": "Grafik Cube Fibonacci | C # kod untuk mencari simpul dalam graf kiub Fibonacci Order N; berfungsi untuk mencari nombor Fibonacci; fungsi untuk mencari bilangan simpang dalam graf kiub Fibonacci; kembali nombor fibonacci untuk f (n + 2); Kod pemacu", "code": "using System ; class GFG { static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } static int findVertices ( int n ) { return fib ( n + 2 ) ; } static void Main ( ) { int n = 3 ; Console . Write ( findVertices ( n ) ) ; } }"}
{"text": "Ubah suai array supaya array tidak mengandungi mana -mana pembahagi biasa selain 1 | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mengubah suai array supaya tidak ada faktor yang sama antara elemen array kecuali 1; Menyimpan GCD array; Hitung GCD array; Jika pembahagi semasa lebih kecil daripada x; Bahagikan GCD oleh pembahagi semasa; Jika boleh; Cetak array yang diubah suai; Jika tidak; Kod pemacu; Diberikan array; Saiz array", "code": "using System ; using System . Collections . Generic ; class GFG { static int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ) ; } static void checkCommonDivisor ( int [ ] arr , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = GCD ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { Console . WriteLine ( \" Yes \" ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( arr [ i ] / copy_G + \" ▁ \" ) ; Console . Write ( \" STRNEWLINE \" ) ; } else Console . WriteLine ( \" No \" ) ; } public static void Main ( ) { int [ ] arr = { 6 , 15 , 6 } ; int X = 6 ; int N = arr . Length ; checkCommonDivisor ( arr , N , X ) ; } }"}
{"text": "Program untuk mencetak corak lingkaran | Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int [ , ] matrix = new int [ size , size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row , col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row , col ] ; Console . Write ( ( n < 10 ) ? ( n + \" ▁ \" ) : ( n + \" ▁ \" ) ) ; } Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { int size = 5 ; printSpiral ( size ) ; } }"}
{"text": "Sort Biotonic Doubly Linked List | C # Pelaksanaan untuk menyusun senarai dikaitkan dua kali ganda; nod senarai dikaitkan dua kali ganda; Berfungsi untuk membalikkan senarai dikaitkan dua kali ganda; swap seterusnya dan sebelumnya untuk semua nod senarai dikaitkan dua kali ganda; Sebelum menukar kepala, periksa kes -kes seperti senarai kosong dan senarai dengan hanya satu nod; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika senarai yang dipautkan pertama kosong; Jika senarai dikaitkan kedua kosong; Pilih nilai yang lebih kecil; berfungsi untuk menyusun senarai dikaitkan dua kali ganda biotonik; Jika senarai kosong atau jika ia mengandungi satu nod tunggal; Jika benar, maka 'semasa' adalah nod pertama yang lebih kecil daripada nod sebelumnya; Pindah ke nod seterusnya; Jika benar, maka senarai sudah disusun; tumpah ke dalam dua senarai, satu bermula dengan 'kepala' dan yang lain bermula dengan 'semasa'; membalikkan senarai bermula dengan 'semasa'; Gabungkan kedua -dua senarai dan kembalikan senarai dikaitkan dua kali ganda; Berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Oleh kerana kita menambah pada mulanya, sebelum ini sentiasa batal; Pautan senarai lama dari nod baru; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Berfungsi untuk mencetak nod dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Kod pemacu; Buat senarai dikaitkan dua kali: 2 <.5 <.7 <.12 <.10 <.6 <.4 <.1; Susun DLL Biotonik", "code": "using System ; class GFG { public class Node { public int data ; public Node next ; public Node prev ; } static Node reverse ( Node head_ref ) { Node temp = null ; Node current = head_ref ; while ( current != null ) { temp = current . prev ; current . prev = current . next ; current . next = temp ; current = current . prev ; } if ( temp != null ) head_ref = temp . prev ; return head_ref ; } static Node merge ( Node first , Node second ) { if ( first == null ) return second ; if ( second == null ) return first ; if ( first . data < second . data ) { first . next = merge ( first . next , second ) ; first . next . prev = first ; first . prev = null ; return first ; } else { second . next = merge ( first , second . next ) ; second . next . prev = second ; second . prev = null ; return second ; } } static Node sort ( Node head ) { if ( head == null head . next == null ) return head ; Node current = head . next ; while ( current != null ) { if ( current . data < current . prev . data ) break ; current = current . next ; } if ( current == null ) return head ; current . prev . next = null ; current . prev = null ; current = reverse ( current ) ; return merge ( head , current ) ; } static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . prev = null ; new_node . next = ( head_ref ) ; if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ; ( head_ref ) = new_node ; return head_ref ; } static void printList ( Node head ) { if ( head == null ) Console . WriteLine ( \" Doubly ▁ Linked ▁ list ▁ empty \" ) ; while ( head != null ) { Console . Write ( head . data + \" ▁ \" ) ; head = head . next ; } } public static void Main ( String [ ] args ) { Node head = null ; head = push ( head , 1 ) ; head = push ( head , 4 ) ; head = push ( head , 6 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 7 ) ; head = push ( head , 5 ) ; head = push ( head , 2 ) ; Console . WriteLine ( \" Original ▁ Doubly ▁ linked ▁ list : n \" ) ; printList ( head ) ; head = sort ( head ) ; Console . WriteLine ( \" STRNEWLINE Doubly ▁ linked ▁ list ▁ after ▁ sorting : n \" ) ; printList ( head ) ; } }"}
{"text": "Susun konsonan dan vokal nod dalam senarai yang dipautkan | C # Program untuk mengatur konsonan dan nod vokal dalam senarai yang dipautkan; Nod senarai yang dipautkan; Berfungsi untuk menambah nod baru ke senarai; fungsi utiliti untuk mencetak senarai yang dipautkan; fungsi utiliti untuk memeriksa vokal; berfungsi untuk mengatur konsonan dan nod vokal; untuk menjejaki vokal; senarai kosong; Kita perlu menemui vokal pertama dalam senarai. Ia akan menjadi kepala yang dikembalikan, dan juga Latarvowel awal. ; Unsur pertama adalah vokal. Ia juga akan menjadi kepala baru dan Latarvowel awal; ; Unsur pertama bukan vokal. Keluarkan melalui senarai sehingga kita dapati vokal. Perhatikan bahawa Curr menunjuk kepada elemen * sebelum * elemen dengan vokal. ; Ini adalah kes kelebihan di mana terdapat hanya konsonan dalam senarai. ; Tetapkan Latihan Awal dan kepala baru ke item vokal yang kami dapati. Relink rantai konsonan selepas item vokal itu: old_head_consonant -> consonant1 -> consonant2 -> vokal -> rest_of_list menjadi vokal -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list; Sekarang melintasi senarai. Curr sentiasa item * sebelum * yang kita periksa, supaya kita boleh menggunakannya untuk menghubungkan semula. ; Item yang ditemui seterusnya adalah vokal; Sekiranya ia datang secara langsung selepas vokal sebelumnya, kami tidak perlu memindahkan item di sekitar, hanya tandakan LatarVowel baru dan Advance Curr. ; Tetapi jika ia datang selepas rantaian konsonan intervensi, kita perlu mengikat vokal yang baru ditemui selepas vokal lama. Curr tidak berubah kerana selepas menghubungkannya akan mempunyai yang baru, yang belum diperiksa, dan kami sentiasa menyimpan Curr pada satu sebelum pemeriksaan seterusnya. ; Rantai dalam vokal baru; Advance Latestvowel; Keluarkan vokal yang dijumpai dari tempat sebelumnya; Re - Rantaian Konsonan Pautan Selepas Latihan Latihan; Tiada vokal dalam elemen seterusnya, Advance Curr. ; Kod pemacu", "code": "using System ; class GfG { public class Node { public char data ; public Node next ; } static Node newNode ( char key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static void printlist ( Node head ) { if ( head == null ) { Console . WriteLine ( \" Empty ▁ List \" ) ; return ; } while ( head != null ) { Console . Write ( head . data + \" ▁ \" ) ; if ( head . next != null ) Console . Write ( \" - > ▁ \" ) ; head = head . next ; } Console . WriteLine ( ) ; } static bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } static Node arrange ( Node head ) { Node newHead = head ; Node latestVowel ; Node curr = head ; if ( head == null ) return null ; if ( isVowel ( head . data ) == true ) latestVowel = head ; else { while ( curr . next != null && ! isVowel ( curr . next . data ) ) curr = curr . next ; if ( curr . next == null ) return head ; latestVowel = newHead = curr . next ; curr . next = curr . next . next ; latestVowel . next = head ; } while ( curr != null && curr . next != null ) { if ( isVowel ( curr . next . data ) == true ) { if ( curr == latestVowel ) { latestVowel = curr = curr . next ; } else { Node temp = latestVowel . next ; latestVowel . next = curr . next ; latestVowel = latestVowel . next ; curr . next = curr . next . next ; latestVowel . next = temp ; } } else { curr = curr . next ; } } return newHead ; } public static void Main ( String [ ] args ) { Node head = newNode ( ' a ' ) ; head . next = newNode ( ' b ' ) ; head . next . next = newNode ( ' c ' ) ; head . next . next . next = newNode ( ' e ' ) ; head . next . next . next . next = newNode ( ' d ' ) ; head . next . next . next . next . next = newNode ( ' o ' ) ; head . next . next . next . next . next . next = newNode ( ' x ' ) ; head . next . next . next . next . next . next . next = newNode ( ' i ' ) ; Console . WriteLine ( \" Linked ▁ list ▁ before ▁ : ▁ \" ) ; printlist ( head ) ; head = arrange ( head ) ; Console . WriteLine ( \" Linked ▁ list ▁ after ▁ : \" ) ; printlist ( head ) ; } }"}
{"text": "Elemen terbesar di BST menggunakan ruang tambahan yang berterusan | C # Program untuk Menemukan K - TH Node terbesar menggunakan O (1) Memori tambahan dan terbalik Morris Traversal. ; Struktur nod; fungsi penolong untuk membuat nod baru; Mengira pembolehubah untuk menyimpan kiraan nod yang dikunjungi; Jika anak yang betul adalah batal; kiraan kenaikan pertama dan semak jika Count = k; Jika tidak berpindah ke anak kiri; Cari pengganti inorder nod semasa; Tetapkan anak kiri pengganti ke nod semasa; gerakkan arus ke kanannya; memulihkan pokok itu kembali ke pokok carian binari asal yang mengeluarkan pautan berulir; gerakkan arus ke anak kiri; Kod pemacu; Pokok binari yang dibina adalah 4 / \\ 2 7 / \\ / \\ 1 3 6 10", "code": "using System ; using System . Collections . Generic ; class GfG { public class Node { public int data ; public Node left , right ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . right = null ; temp . left = null ; return temp ; } static Node KthLargestUsingMorrisTraversal ( Node root , int k ) { Node curr = root ; Node Klargest = null ; int count = 0 ; while ( curr != null ) { if ( curr . right == null ) { if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } else { Node succ = curr . right ; while ( succ . left != null && succ . left != curr ) succ = succ . left ; if ( succ . left == null ) { succ . left = curr ; curr = curr . right ; } else { succ . left = null ; if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } } } return Klargest ; } public static void Main ( String [ ] args ) { Node root = newNode ( 4 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 10 ) ; Console . Write ( \" Finding ▁ K - th ▁ largest ▁ Node ▁ in ▁ BST ▁ : ▁ \" + KthLargestUsingMorrisTraversal ( root , 2 ) . data ) ; } }"}
{"text": "Susun baris matriks | C # pelaksanaan untuk menyusun baris matriks - bijak dan lajur - bijak; berfungsi untuk menyusun setiap baris matriks; menyusun nombor baris 'i'; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [,]; dapatkan transpose tikar [,]; sekali lagi menyusun baris tikar [,]; sekali lagi dapatkan transpose tikar [,]; berfungsi untuk mencetak matriks; Kod pemacu", "code": "using System ; class GFG { static void sortByRow ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( mat [ i , j ] > mat [ i , j + 1 ] ) { var temp = mat [ i , j ] ; mat [ i , j ] = mat [ i , j + 1 ] ; mat [ i , j + 1 ] = temp ; } } } } static void transpose ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { var temp = mat [ i , j ] ; mat [ i , j ] = mat [ j , i ] ; mat [ j , i ] = temp ; } } static void sortMatRowAndColWise ( int [ , ] mat , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; } static void printMat ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) Console . Write ( mat [ i , j ] + \" ▁ \" ) ; Console . Write ( \" STRNEWLINE \" ) ; } } public static void Main ( ) { int [ , ] mat = { { 4 , 1 , 3 } , { 9 , 6 , 8 } , { 5 , 2 , 7 } } ; int n = 3 ; Console . Write ( \" Original ▁ Matrix : STRNEWLINE \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; Console . Write ( \" STRNEWLINE Matrix ▁ After ▁ Sorting : STRNEWLINE \" ) ; printMat ( mat , n ) ; } }"}
{"text": "Magic Square | Malah pesanan | C # Program untuk mencetak Magic Square of Doubly Even Order; Fungsi untuk mengira Magic Square; Mengisi matriks dengan nilai kiraannya bermula dari 1; ; Tukar nilai elemen array di lokasi pembaikan seperti peraturan (n * n + 1) - arr [i] [j] sudut kiri atas matriks (perintah (n / 4) * (n / 4)); Sudut kanan atas matriks (perintah (n / 4) * (n / 4)); Sudut kiri bawah matriks (pesanan (n / 4) * (n / 4)); Sudut kanan bawah matriks (pesanan (n / 4) * (n / 4)); Pusat matriks (perintah (n / 2) * (n / 2)); Mencetak Magic - Square; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { public static void doublyEven ( int n ) { int [ , ] arr = new int [ n , n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { arr [ i , j ] = ( n * i ) + j + 1 ; } } for ( i = 0 ; i < n / 4 ; i ++ ) { for ( j = 0 ; j < n / 4 ; j ++ ) { arr [ i , j ] = ( n * n + 1 ) - arr [ i , j ] ; } } for ( i = 0 ; i < n / 4 ; i ++ ) { for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) { arr [ i , j ] = ( n * n + 1 ) - arr [ i , j ] ; } } for ( i = 3 * n / 4 ; i < n ; i ++ ) { for ( j = 0 ; j < n / 4 ; j ++ ) { arr [ i , j ] = ( n * n + 1 ) - arr [ i , j ] ; } } for ( i = 3 * n / 4 ; i < n ; i ++ ) { for ( j = 3 * n / 4 ; j < n ; j ++ ) { arr [ i , j ] = ( n * n + 1 ) - arr [ i , j ] ; } } for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) { for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) { arr [ i , j ] = ( n * n + 1 ) - arr [ i , j ] ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { Console . Write ( arr [ i , j ] + \" ▁ \" + \" ▁ \" ) ; } Console . WriteLine ( ) ; } } public static void Main ( string [ ] args ) { int n = 8 ; doublyEven ( n ) ; } }"}
{"text": "Produk Kronecker Dua Matriks | C # kod untuk mencari produk kronecker dua matriks dan menyimpannya sebagai matriks c; Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Kod pemacu", "code": "using System ; class GFG { static int cola = 2 , rowa = 3 ; static int colb = 3 , rowb = 2 ; static void Kroneckerproduct ( int [ , ] A , int [ , ] B ) { int [ , ] C = new int [ rowa * rowb , cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 , j + k + 1 ] = A [ i , j ] * B [ k , l ] ; Console . Write ( C [ i + l + 1 , j + k + 1 ] + \" ▁ \" ) ; } } Console . WriteLine ( ) ; } } } public static void Main ( ) { int [ , ] A = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } ; int [ , ] B = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga yang lebih rendah | C # Program untuk memeriksa matriks segi tiga yang lebih rendah. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga yang lebih rendah atau tidak. ; Fungsi pemacu. ; Panggilan fungsi", "code": "using System ; class Lower_triangular { int N = 4 ; bool isLowerTriangularMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i , j ] != 0 ) return false ; return true ; } public static void Main ( ) { Lower_triangular ob = new Lower_triangular ( ) ; int [ , ] mat = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ; if ( ob . isLowerTriangularMatrix ( mat ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga atas | C # Program untuk memeriksa matriks segi tiga atas. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga atas atau tidak. ; Fungsi pemacu", "code": "using System ; public class GfG { private static int N = 4 ; public static bool isUpperTriangularMatrix ( int [ , ] mat ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i , j ] != 0 ) return false ; return true ; } public static void Main ( ) { int [ , ] mat = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Mengira set 1 s dan 0 s dalam matriks binari | C # Program untuk mengira bilangan set dalam matriks binari. ; tiada lajur; tiada baris; berfungsi untuk mengira bilangan set sel yang tidak kosong; menyimpan jawapan terakhir; Traverses Row - Bijaksana; Traverses Column Wise; Pada akhirnya tolak n * m kerana tiada set tunggal telah ditambah dua kali. ; Kod pemacu", "code": "using System ; class GFG { static int m = 3 ; static int n = 2 ; static long countSets ( int [ , ] a ) { long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i , j ] == 1 ) u ++ ; else v ++ ; } res += ( long ) ( Math . Pow ( 2 , u ) - 1 + Math . Pow ( 2 , v ) ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j , i ] == 1 ) u ++ ; else v ++ ; } res += ( long ) ( Math . Pow ( 2 , u ) - 1 + Math . Pow ( 2 , v ) ) - 1 ; } return res - ( n * m ) ; } public static void Main ( ) { int [ , ] a = { { 1 , 0 , 1 } , { 0 , 1 , 0 } } ; Console . WriteLine ( countSets ( a ) ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Code C # mudah untuk memeriksa matriks adalah simetri atau tidak. ; Mengisi transpose mat [n] [n] dalam tr [n] [n]; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100 ; static void transpose ( int [ , ] mat , int [ , ] tr , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i , j ] = mat [ j , i ] ; } static bool isSymmetric ( int [ , ] mat , int N ) { int [ , ] tr = new int [ N , MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] != tr [ i , j ] ) return false ; return true ; } public static void Main ( ) { int [ , ] mat = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod C # yang cekap untuk memeriksa matriks adalah simetri atau tidak; statik int max = 100; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "using System ; class GFG { static bool isSymmetric ( int [ , ] mat , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] != mat [ j , i ] ) return false ; return true ; } public static void Main ( ) { int [ , ] mat = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Program untuk mencari normal dan jejak matriks | C # Program untuk mencari jejak dan normal matriks yang diberikan; Pulangan normal matriks saiz n x n; Mengembalikan jejak matriks saiz n x n; Sumber yang didorong", "code": "using System ; class GFG { static int findNormal ( int [ , ] mat , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i , j ] * mat [ i , j ] ; return ( int ) Math . Sqrt ( sum ) ; } static int findTrace ( int [ , ] mat , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i , i ] ; return sum ; } public static void Main ( ) { int [ , ] mat = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; Console . Write ( \" Trace ▁ of ▁ Matrix ▁ = ▁ \" + findTrace ( mat , 5 ) + \" STRNEWLINE \" ) ; Console . Write ( \" Normal ▁ of ▁ Matrix ▁ = ▁ \" + findNormal ( mat , 5 ) ) ; } }"}
{"text": "Penentu maksimum matriks dengan setiap nilai sama ada 0 atau n | C # Program untuk mencari penentu maksimum mungkin 0 / N matriks. ; Fungsi untuk penentu maksimum; Berfungsi untuk mencetak matriks resulatant; tiga kedudukan di mana 0 muncul; kedudukan di mana n muncul; Kod pemacu", "code": "using System ; public class GFG { static int maxDet ( int n ) { return ( 2 * n * n * n ) ; } void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) Console . Write ( \"0 ▁ \" ) ; else if ( i == 1 && j == 0 ) Console . Write ( \"0 ▁ \" ) ; else if ( i == 2 && j == 1 ) Console . Write ( \"0 ▁ \" ) ; else Console . Write ( n + \" ▁ \" ) ; } Console . WriteLine ( \" \" ) ; } } static public void Main ( String [ ] args ) { int n = 15 ; GFG geeks = new GFG ( ) ; Console . WriteLine ( \" Maximum ▁ Determinant ▁ = ▁ \" + maxDet ( n ) ) ; Console . WriteLine ( \" Resultant ▁ Matrix ▁ : \" ) ; geeks . resMatrix ( n ) ; } }"}
{"text": "Kira nombor negatif dalam lajur | C # Pelaksanaan kaedah naif untuk mengira nombor negatif dalam m [n] [m]; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; Tiada nombor negatif dalam baris ini; Kod pemacu", "code": "using System ; class GFG { static int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i , j ] < 0 ) count += 1 ; else break ; } } return count ; } public static void Main ( ) { int [ , ] M = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; Console . WriteLine ( countNegative ( M , 3 , 4 ) ) ; } }"}
{"text": "Kira nombor negatif dalam lajur | C # Pelaksanaan kaedah yang cekap untuk mengira nombor negatif dalam m [n] [m]; Berfungsi untuk mengira nombor negatif; memulakan hasil; Mulakan dengan sudut kanan atas; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; J ialah indeks nombor negatif terakhir dalam baris ini. Jadi mesti ada (j + 1); Nombor negatif dalam baris ini. ; Pindah ke kiri dan lihat jika kita dapat mencari nombor negatif di sana; Kod pemacu", "code": "using System ; class GFG { static int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i , j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } public static void Main ( ) { int [ , ] M = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; Console . WriteLine ( countNegative ( M , 3 , 4 ) ) ; } }"}
{"text": "Kira nombor negatif dalam lajur | C # Pelaksanaan kaedah yang lebih efisien untuk mengira bilangan nombor negatif dalam baris - matriks disusun lajur m [n, m]; Carian binari rekursif untuk mendapatkan nilai negatif terakhir berturut -turut antara permulaan dan akhir; Kes asas; Dapatkan pertengahan untuk carian binari; Jika elemen semasa adalah negatif; Jika ia adalah elemen negatif paling kanan dalam baris semasa; Semak separuh kanan array; Semak di separuh kiri array; Fungsi untuk mengembalikan kiraan nombor negatif dalam matriks yang diberikan; Memulakan hasil; Untuk menyimpan indeks elemen negatif paling kanan dalam baris yang dipertimbangkan; Melangkah ke atas semua baris matriks; Jika elemen pertama baris semasa adalah positif maka tidak akan ada negatif dalam matriks di bawah atau selepas itu; Jalankan carian binari hanya sehingga indeks Int negatif terakhir dalam baris di atas; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int getLastNegativeIndex ( int [ ] array , int start , int end ) { if ( start == end ) { return start ; } int mid = start + ( end - start ) / 2 ; if ( array [ mid ] < 0 ) { if ( mid + 1 < array . GetLength ( 0 ) && array [ mid + 1 ] >= 0 ) { return mid ; } return getLastNegativeIndex ( array , mid + 1 , end ) ; } else { return getLastNegativeIndex ( array , start , mid - 1 ) ; } } static int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; int nextEnd = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( M [ i , 0 ] >= 0 ) { break ; } nextEnd = getLastNegativeIndex ( GetRow ( M , i ) , 0 , nextEnd ) ; count += nextEnd + 1 ; } return count ; } public static int [ ] GetRow ( int [ , ] matrix , int row ) { var rowLength = matrix . GetLength ( 1 ) ; var rowVector = new int [ rowLength ] ; for ( var i = 0 ; i < rowLength ; i ++ ) rowVector [ i ] = matrix [ row , i ] ; return rowVector ; } public static void Main ( String [ ] args ) { int [ , ] M = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; int r = M . GetLength ( 0 ) ; int c = M . GetLength ( 1 ) ; Console . WriteLine ( countNegative ( M , r , c ) ) ; } }"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah naif untuk mencari nilai maksimum MAT [d] [e] - mat [a] [b] seperti d> a dan e> b; Fungsi ini mengembalikan nilai maksimum a (d, e) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua d> a dan e> b. ; Kedai nilai maksimum; Pertimbangkan semua kemungkinan pasangan tikar [a] [b] dan mat [d] [e]; Kod pemacu", "code": "using System ; class GFG { static int findMaxValue ( int N , int [ , ] mat ) { int maxValue = int . MinValue ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d , e ] - mat [ a , b ] ) ) maxValue = mat [ d , e ] - mat [ a , b ] ; return maxValue ; } public static void Main ( ) { int N = 5 ; int [ , ] mat = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; Console . Write ( \" Maximum ▁ Value ▁ is ▁ \" + findMaxValue ( N , mat ) ) ; } }"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah yang cekap untuk mencari nilai maksimum MAT1 [d] - ma [a] [b] sedemikian rupa sehingga c> a dan d> b; Fungsi ini mengembalikan nilai maksimum a (c, d) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua c> a dan d> b. ; Kedai nilai maksimum; maxarr [i] [j] menyimpan max unsur -unsur dalam matriks dari (i, j) hingga (n - 1, n - 1); Elemen terakhir Maxarr akan menjadi sama seperti matriks input; Preprocess Last Row Inisialisasi Max; preprocess lajur terakhir memulakan max; PREPROCESS ROST OF MATRIX DARI BAWAH; Kemas kini MaxValue; Tetapkan Maxarr (i, j); Kod pemacu", "code": "using System ; class GFG { static int findMaxValue ( int N , int [ , ] mat ) { int maxValue = int . MinValue ; int [ , ] maxArr = new int [ N , N ] ; maxArr [ N - 1 , N - 1 ] = mat [ N - 1 , N - 1 ] ; int maxv = mat [ N - 1 , N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 , j ] > maxv ) maxv = mat [ N - 1 , j ] ; maxArr [ N - 1 , j ] = maxv ; } maxv = mat [ N - 1 , N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i , N - 1 ] > maxv ) maxv = mat [ i , N - 1 ] ; maxArr [ i , N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 , j + 1 ] - mat [ i , j ] > maxValue ) maxValue = maxArr [ i + 1 , j + 1 ] - mat [ i , j ] ; maxArr [ i , j ] = Math . Max ( mat [ i , j ] , Math . Max ( maxArr [ i , j + 1 ] , maxArr [ i + 1 , j ] ) ) ; } } return maxValue ; } public static void Main ( ) { int N = 5 ; int [ , ] mat = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; Console . Write ( \" Maximum ▁ Value ▁ is ▁ \" + findMaxValue ( N , mat ) ) ; } }"}
{"text": "Cetak semua elemen dalam susunan yang disusun dari baris dan lajur yang bijak matriks disusun | Program C # untuk mencetak semua elemen dalam susunan yang disusun dari baris dan lajur yang disusun dengan bijak; Fungsi utiliti untuk Youngify meja muda. Ini berbeza dengan Standard Youngify. Ia mengandaikan bahawa nilai pada MAT [0] [0] adalah tak terhingga. ; Cari nilai -nilai di bawah dan kanan tikar [i] [j]; Jika tikar [i] [j] adalah elemen sudut kanan, kembali; Gerakkan lebih kecil daripada dua nilai (downval dan rightval) ke tikar [i] [j] dan berulang untuk nilai yang lebih kecil; Fungsi utiliti untuk mengekstrak elemen minimum dari Tableau muda; Fungsi ini menggunakan ExtractMin () untuk mencetak elemen dalam urutan yang disusun; Kod pemacu", "code": "using System ; class GFG { static int INF = int . MaxValue ; static int N = 4 ; static void youngify ( int [ , ] mat , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 , j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i , j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) { return ; } if ( downVal < rightVal ) { mat [ i , j ] = downVal ; mat [ i + 1 , j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i , j ] = rightVal ; mat [ i , j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } } static int extractMin ( int [ , ] mat ) { int ret = mat [ 0 , 0 ] ; mat [ 0 , 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; } static void printSorted ( int [ , ] mat ) { Console . WriteLine ( \" Elements ▁ of ▁ matrix ▁ in ▁ sorted ▁ order ▁ n \" ) ; for ( int i = 0 ; i < N * N ; i ++ ) { Console . Write ( extractMin ( mat ) + \" ▁ \" ) ; } } static public void Main ( ) { int [ , ] mat = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; printSorted ( mat ) ; } }"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program C # mudah untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; Fungsi mudah untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; Nombor baris sel pertama dalam sub -persegi semasa saiz k x k; Lajur sel pertama dalam sub -persegi semasa saiz k x k; Hitung dan cetak jumlah sub -persegi semasa; Pemisah garis untuk sub -dataran bermula dengan baris seterusnya; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int n = 5 ; static void printSumSimple ( int [ , ] mat , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p , q ] ; Console . Write ( sum + \" ▁ \" ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int [ , ] mat = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } } ; int k = 3 ; printSumSimple ( mat , k ) ; } }"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program C # yang cekap untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; A o (n ^ 2) berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi yang diberikan saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; 1: Preprocessing untuk menyimpan jumlah semua jalur saiz k x 1; Pergi lajur mengikut lajur; Hitung jumlah pertama K x 1 segi empat tepat dalam lajur ini; Hitung jumlah segi empat tepat; 2: Kirakan jumlah sub - dataran menggunakan stripsum [] []; Hitung dan cetak jumlah Subsquare Pertama dalam baris ini; Kirakan jumlah kuadrat yang tinggal dalam baris semasa dengan mengeluarkan jalur paling kiri sub -persegi sebelumnya dan menambah jalur baru; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int n = 5 ; static void printSumTricky ( int [ , ] mat , int k ) { if ( k > n ) return ; int [ , ] stripSum = new int [ n , n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i , j ] ; stripSum [ 0 , j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 , j ] - mat [ i - 1 , j ] ) ; stripSum [ i , j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i , j ] ; Console . Write ( sum + \" ▁ \" ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i , j + k - 1 ] - stripSum [ i , j - 1 ] ) ; Console . Write ( sum + \" ▁ \" ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int [ , ] mat = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; } }"}
{"text": "Program untuk mencari transpose matriks | C # Program untuk mencari transpose matriks; Fungsi ini menyimpan transpose a [] [] dalam b [] []; Kod pemacu", "code": "using System ; class GFG { static int M = 3 ; static int N = 4 ; static void transpose ( int [ , ] A , int [ , ] B ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i , j ] = A [ j , i ] ; } public static void Main ( ) { int [ , ] A = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int [ , ] B = new int [ N , M ] ; transpose ( A , B ) ; Console . WriteLine ( \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) Console . Write ( B [ i , j ] + \" ▁ \" ) ; Console . Write ( \" STRNEWLINE \" ) ; } } }"}
{"text": "Program untuk mencari transpose matriks | C # Program untuk mencari transpose matriks; Mencari transpose dari [] [] di tempat; Kod pemacu", "code": "using System ; class GFG { static int N = 4 ; static void transpose ( int [ , ] A ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i , j ] ; A [ i , j ] = A [ j , i ] ; A [ j , i ] = temp ; } } public static void Main ( ) { int [ , ] A = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; Console . WriteLine ( \" Modified ▁ matrix ▁ is ▁ \" ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) Console . Write ( A [ i , j ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } } }"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program C # rekursif naif untuk mengira laluan dengan duit syiling 'k' yang tepat; Fungsi rekursif untuk mengira laluan dengan jumlah k dari (0, 0) hingga (m, n); Kes asas; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas PathCountrec (); Kod pemacu", "code": "using System ; public class GFG { public const int R = 3 ; public const int C = 3 ; public static int pathCountRec ( int [ ] [ ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) { return 0 ; } if ( m == 0 && n == 0 && ( k == mat [ m ] [ n ] ) ) { return 1 ; } return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; } public static int pathCount ( int [ ] [ ] mat , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; } public static void Main ( string [ ] args ) { int k = 12 ; int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 4 , 6 , 5 } , new int [ ] { 3 , 2 , 1 } } ; Console . WriteLine ( pathCount ( mat , k ) ) ; } }"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program C # berasaskan pengaturcaraan yang dinamik untuk mengira laluan dengan duit syiling 'k' yang tepat; Kes asas; Jika subproblem ini sudah diselesaikan; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Fungsi ini terutamanya memulakan [,] dp [] dan memanggil PathCountDPrecdp (); Kod pemacu", "code": "using System ; class GFG { static readonly int R = 3 ; static readonly int C = 3 ; static readonly int MAX_K = 100 ; static int [ , , ] dp = new int [ R , C , MAX_K ] ; static int pathCountDPRecDP ( int [ , ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m , n ] ? 1 : 0 ) ; if ( dp [ m , n , k ] != - 1 ) return dp [ m , n , k ] ; dp [ m , n , k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m , n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m , n ] ) ; return dp [ m , n , k ] ; } static int pathCountDP ( int [ , ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_K ; l ++ ) dp [ i , j , l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; } public static void Main ( String [ ] args ) { int k = 12 ; int [ , ] mat = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; Console . WriteLine ( pathCountDP ( mat , k ) ) ; } }"}
{"text": "Susun Matriks yang Diberikan | C # pelaksanaan untuk menyusun matriks yang diberikan; berfungsi untuk menyusun matriks yang diberikan; matriks sementara saiz n ^ 2; Salin unsur -unsur matriks satu demi satu ke temp []; Susun temp []; Salin unsur -unsur temp [] satu demi satu dalam tikar [] []; berfungsi untuk mencetak matriks yang diberikan; Kod pemacu", "code": "using System ; class GFG { static int SIZE = 10 ; static void sortMat ( int [ , ] mat , int n ) { int [ ] temp = new int [ n * n ] ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i , j ] ; Array . Sort ( temp ) ; k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i , j ] = temp [ k ++ ] ; } static void printMat ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) Console . Write ( mat [ i , j ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int [ , ] mat = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int n = 3 ; Console . WriteLine ( \" Original ▁ Matrix : \" ) ; printMat ( mat , n ) ; sortMat ( mat , n ) ; Console . WriteLine ( \" Matrix ▁ After ▁ Sorting : \" ) ; printMat ( mat , n ) ; } }"}
{"text": "Pemilihan jenis | C # Program untuk pelaksanaan pilihan pemilihan; Susun fungsi; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Mencetak array; Kod pemacu", "code": "using System ; class GFG { static void sort ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int min_idx = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } } static void printArray ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 64 , 25 , 12 , 22 , 11 } ; sort ( arr ) ; Console . WriteLine ( \" Sorted ▁ array \" ) ; printArray ( arr ) ; } }"}
{"text": "Bubble sort | Optimum C # pelaksanaan Bubble Sort; Versi bubble yang dioptimumkan; swap arr [j] dan arr [j + 1]; Jika tidak ada dua elemen yang ditukar dengan gelung dalaman, kemudian pecah; Berfungsi untuk mencetak array; Kaedah Pemandu", "code": "using System ; class GFG { static void bubbleSort ( int [ ] arr , int n ) { int i , j , temp ; bool swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; } } static void printArray ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = arr . Length ; bubbleSort ( arr , n ) ; Console . WriteLine ( \" Sorted ▁ array \" ) ; printArray ( arr , n ) ; } }"}
{"text": "Cari K Elemen yang paling dekat dengan nilai yang diberikan | C # Program untuk mencari elemen yang paling dekat dengan nilai tertentu; Berfungsi untuk mencari titik silang (titik sebelum unsur -unsur lebih kecil daripada atau sama dengan x dan selepas itu lebih besar daripada x); Kes asas X lebih besar daripada semua; X lebih kecil daripada semua; Cari titik tengah; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Fungsi ini mencetak elemen yang paling dekat dengan x dalam arr []. n ialah bilangan elemen dalam arr []; Cari titik crossover; Indeks yang betul untuk mencari; Untuk menjejaki kiraan elemen; Jika x hadir dalam arr [], maka mengurangkan asumsi indeks kiri: semua elemen dalam arr [] adalah berbeza; Bandingkan unsur -unsur di kiri dan kanan titik crossover untuk mencari unsur -unsur yang paling dekat; Jika tidak ada lagi elemen di sebelah kanan, maka cetak elemen kiri; Sekiranya tidak ada lagi elemen di sebelah kiri, maka cetak elemen kanan; Program pemacu untuk menyemak fungsi di atas", "code": "using System ; class GFG { static int findCrossOver ( int [ ] arr , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; } static void printKclosest ( int [ ] arr , int x , int k , int n ) { int l = findCrossOver ( arr , 0 , n - 1 , x ) ; int r = l + 1 ; int count = 0 ; if ( arr [ l ] == x ) l -- ; while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) Console . Write ( arr [ l -- ] + \" ▁ \" ) ; else Console . Write ( arr [ r ++ ] + \" ▁ \" ) ; count ++ ; } while ( count < k && l >= 0 ) { Console . Write ( arr [ l -- ] + \" ▁ \" ) ; count ++ ; } while ( count < k && r < n ) { Console . Write ( arr [ r ++ ] + \" ▁ \" ) ; count ++ ; } } public static void Main ( ) { int [ ] arr = { 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 } ; int n = arr . Length ; int x = 35 ; printKclosest ( arr , x , 4 , n ) ; } }"}
{"text": "SENARAI SENSI UNTUK SENDIRI SISTY LINKED | C # Program untuk menyusun senarai pautan menggunakan jenis penyisipan; Fungsi utiliti untuk memasukkan nod pada permulaan senarai yang dipautkan; memperuntukkan nod; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Fungsi untuk menyusun senarai yang berkaitan dengan menggunakan jenis penyisipan; Memulakan senarai yang disusun; Melintasi senarai yang dipautkan dan masukkan setiap nod untuk disusun; Simpan seterusnya untuk lelaran seterusnya; Masukkan arus dalam senarai yang disusun; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun; * Fungsi untuk memasukkan new_node dalam senarai. Ambil perhatian bahawa * fungsi ini menjangkakan penunjuk ke head_ref sebagai * ini boleh mengubah suai kepala senarai berkaitan input * (serupa dengan push ()); Kes khas untuk hujung kepala; Cari nod sebelum titik penyisipan; Berfungsi untuk mencetak senarai yang dipautkan; Kod pemacu", "code": "using System ; public class LinkedlistIS { public node head ; public node sorted ; public class node { public int val ; public node next ; public node ( int val ) { this . val = val ; } } void push ( int val ) { node newnode = new node ( val ) ; newnode . next = head ; head = newnode ; } void insertionSort ( node headref ) { sorted = null ; node current = headref ; while ( current != null ) { node next = current . next ; sortedInsert ( current ) ; current = next ; } head = sorted ; } void sortedInsert ( node newnode ) { if ( sorted == null sorted . val >= newnode . val ) { newnode . next = sorted ; sorted = newnode ; } else { node current = sorted ; while ( current . next != null && current . next . val < newnode . val ) { current = current . next ; } newnode . next = current . next ; current . next = newnode ; } } void printlist ( node head ) { while ( head != null ) { Console . Write ( head . val + \" ▁ \" ) ; head = head . next ; } } public static void Main ( String [ ] args ) { LinkedlistIS list = new LinkedlistIS ( ) ; list . push ( 5 ) ; list . push ( 20 ) ; list . push ( 4 ) ; list . push ( 3 ) ; list . push ( 30 ) ; Console . WriteLine ( \" Linked ▁ List ▁ before ▁ Sorting . . \" ) ; list . printlist ( list . head ) ; list . insertionSort ( list . head ) ; Console . WriteLine ( \" STRNEWLINE LinkedList ▁ After ▁ sorting \" ) ; list . printlist ( list . head ) ; } }"}
{"text": "Perubahan duit syiling | DP | Program C # Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program Pemandu", "code": "using System ; class GFG { static int count ( int [ ] S , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int m = arr . Length ; Console . Write ( count ( arr , m , 4 ) ) ; } }"}
{"text": "Perubahan duit syiling | DP | Pengaturcaraan Dynamic C # Pelaksanaan masalah perubahan duit syiling; Jadual [i] akan menyimpan bilangan penyelesaian untuk nilai i. Kami memerlukan baris n + 1 kerana jadual dibina dengan cara bawah menggunakan kes asas (n = 0); Kes asas (jika diberi nilai adalah 0); Pilih semua syiling satu demi satu dan kemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai duit syiling yang dipilih; Kod pemacu", "code": "using System ; class GFG { static int count ( int [ ] S , int m , int n ) { int [ ] table = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int m = arr . Length ; int n = 4 ; Console . Write ( count ( arr , m , n ) ) ; } }"}
{"text": "Pendaraban rantai matriks | DP | C # Program menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "using System ; class GFG { static int [ , ] dp = new int [ 100 , 100 ] ; static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i , j ] != - 1 ) { return dp [ i , j ] ; } dp [ i , j ] = Int32 . MaxValue ; for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i , j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { dp [ i , j ] = - 1 ; } } Console . WriteLine ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , n ) ) ; } }"}
{"text": "Pendaraban rantai matriks | DP | Pengaturcaraan Dinamik C # Pelaksanaan pendaraban rantai matriks. Lihat buku Cormen untuk butiran algoritma berikut; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam M [] []. 0 bar dan lajur 0 M [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu", "code": "using System ; class GFG { static int MatrixChainOrder ( int [ ] p , int n ) { int [ , ] m = new int [ n , n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i , i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i , j ] = int . MaxValue ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i , k ] + m [ k + 1 , j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i , j ] ) m [ i , j ] = q ; } } } return m [ 1 , n - 1 ] ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . Length ; Console . Write ( \" Minimum ▁ number ▁ of ▁ \" + \" multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , size ) ) ; } }"}
{"text": "Memotong batang | DP | Penyelesaian rekursif naif untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Recursif memotong batang dalam kepingan yang berbeza dan membandingkan konfigurasi yang berbeza; Kod pemacu", "code": "using System ; class GFG { static int cutRod ( int [ ] price , int n ) { if ( n <= 0 ) return 0 ; int max_val = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . Max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . Length ; Console . WriteLine ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + cutRod ( arr , size ) ) ; } }"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Kod pemacu", "code": "using System ; class GFG { static int cutRod ( int [ ] price , int n ) { int [ ] val = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = int . MinValue ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . Max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . Length ; Console . WriteLine ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + cutRod ( arr , size ) ) ; } }"}
{"text": "Multiply dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung | Mengalikan dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung; berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; kes di mana y adalah negatif; Kod pemacu", "code": "using System ; class GFG { static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; } public static void Main ( ) { Console . WriteLine ( multiply ( 5 , - 11 ) ) ; } }"}
{"text": "Sieve of Eratosthenes | C # Program untuk mencetak semua prima yang lebih kecil daripada atau sama dengan N menggunakan penapis eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor utama; Kod pemacu", "code": "using System ; namespace prime { public class GFG { public static void SieveOfEratosthenes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) Console . Write ( i + \" ▁ \" ) ; } } public static void Main ( ) { int n = 30 ; Console . WriteLine ( \" Following ▁ are ▁ the ▁ prime ▁ numbers \" ) ; Console . WriteLine ( \" smaller ▁ than ▁ or ▁ equal ▁ to ▁ \" + n ) ; SieveOfEratosthenes ( n ) ; } } }"}
{"text": "Segitiga Pascal | C # kod untuk segitiga Pascal; BinomialCoeff; Berfungsi untuk mencetak garisan N pertama dari segitiga Pascal; Berulang melalui setiap baris dan cetak penyertaan di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Kod pemacu", "code": "using System ; class GFG { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static void printPascal ( int n ) { for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) Console . Write ( binomialCoeff ( line , i ) + \" ▁ \" ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 7 ; printPascal ( n ) ; } }"}
{"text": "Segitiga Pascal | C # Program untuk Segitiga Pascal; A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga pascal yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai lain adalah jumlah nilai; Kod pemacu", "code": "using System ; class GFG { public static void printPascal ( int n ) { int [ , ] arr = new int [ n , n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line , i ] = 1 ; else arr [ line , i ] = arr [ line - 1 , i - 1 ] + arr [ line - 1 , i ] ; Console . Write ( arr [ line , i ] ) ; } Console . WriteLine ( \" \" ) ; } } public static void Main ( ) { int n = 5 ; printPascal ( n ) ; } }"}
{"text": "Segitiga Pascal | C # Program untuk Pascal 's' u u (n ^ 2) ~ masa u dan u (1) ~ tambahan ~ »kaedah ~ untuk segitiga Pascal; digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu", "code": "using System ; class GFG { public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { Console . Write ( C + \" ▁ \" ) ; C = C * ( line - i ) / i ; } Console . Write ( \" STRNEWLINE \" ) ; } } public static void Main ( ) { int n = 5 ; printPascal ( n ) ; } }"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | C # Program untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } public static void Main ( ) { Console . WriteLine ( Add ( 15 , 32 ) ) ; } }"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik |", "code": "static int Add ( int x , int y ) { if ( y == 0 ) return x ; else return Add ( x ^ y , ( x & y ) << 1 ) ; }"}
{"text": "Mengira Bahagian Modulus dengan Kuasa | C # kod untuk mengira bahagian modulus dengan kuasa - daripada - 2 - nombor; Fungsi ini akan kembali n % d. D mestilah salah satu: 1, 2, 4, 8, 16, 32, ...; Kod pemacu; D mesti menjadi kuasa 2", "code": "using System ; class GFG { static uint getModulo ( uint n , uint d ) { return ( n & ( d - 1 ) ) ; } static public void Main ( ) { uint n = 6 ; uint d = 4 ; Console . WriteLine ( n + \" ▁ moduo ▁ \" + d + \" ▁ is ▁ \" + getModulo ( n , d ) ) ; } }"}
{"text": "Count set bit dalam integer | C # Program untuk mengira set bit dalam integer; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Kod pemacu", "code": "using System ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } public static void Main ( ) { int i = 9 ; Console . Write ( countSetBits ( i ) ) ; } }"}
{"text": "Count set bit dalam integer | C # Pelaksanaan untuk pendekatan rekursif untuk mencari bilangan bit yang ditetapkan menggunakan algoritma Brian Kernighan; fungsi rekursif untuk mengira set bit; Kes asas; Kod pemacu; Dapatkan nilai dari pengguna; fungsi panggilan", "code": "using System ; class GFG { public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } static public void Main ( ) { int n = 9 ; Console . WriteLine ( countSetBits ( n ) ) ; } }"}
{"text": "Count set bit dalam integer | C # pelaksanaan pendekatan; Jadual carian; Berfungsi untuk memulakan jadual carian; Pada mulanya menjana jadual algoritma; Berfungsi untuk mengembalikan kiraan bit set dalam n; Kod pemacu; Memulakan jadual carian", "code": "using System ; using System . Collections . Generic ; class GFG { static int [ ] BitsSetTable256 = new int [ 256 ] ; public static void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } } public static int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; } public static void Main ( String [ ] args ) { initialize ( ) ; int n = 9 ; Console . Write ( countSetBits ( n ) ) ; } }"}
{"text": "Count set bit dalam integer | C # program untuk menunjukkan __builtin_popcount (); Kod pemacu", "code": "using System ; using System . Linq ; class GFG { public static void Main ( ) { Console . WriteLine ( Convert . ToString ( 4 , 2 ) . Count ( c = > c == '1' ) ) ; Console . WriteLine ( Convert . ToString ( 15 , 2 ) . Count ( c = > c == '1' ) ) ; } }"}
{"text": "Count set bit dalam integer | C # Program untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu", "code": "class GFG { static int [ ] num_to_bits = new int [ 16 ] { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } static void Main ( ) { int num = 31 ; System . Console . WriteLine ( countSetBitsRec ( num ) ) ; } }"}
{"text": "Count set bit dalam integer |  ; Semak setiap bit dalam nombor ditetapkan atau tidak dan kembalikan jumlah kiraan bit yang ditetapkan. ; (1 << i) = pow (2, i); Kod pemacu", "code": "using System ; class GFG { static int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; } static void Main ( ) { int N = 15 ; Console . WriteLine ( countSetBits ( N ) ) ; } }"}
{"text": "Program untuk mencari pariti | C # Program untuk mencari pariti integer; Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Kod pemacu", "code": "using System ; class GFG { static bool getParity ( int n ) { bool parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } public static void Main ( ) { int n = 7 ; Console . Write ( \" Parity ▁ of ▁ no ▁ \" + n + \" ▁ = ▁ \" + ( getParity ( n ) ? \" odd \" : \" even \" ) ) ; } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | C # Program untuk mencari sama ada tidak ada kuasa dua; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "using System ; class GFG { static bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( int ) ( Math . Ceiling ( ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ) == ( int ) ( Math . Floor ( ( ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ) ) ; } public static void Main ( ) { if ( isPowerOfTwo ( 31 ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; if ( isPowerOfTwo ( 64 ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | C # Program untuk mencari sama ada tidak ada kuasa dua; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Program Pemandu", "code": "using System ; class GFG { static bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; } public static void Main ( ) { Console . WriteLine ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; Console . WriteLine ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | C # Program untuk pendekatan di atas; Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; Panggilan fungsi rekursif; Kod pemacu; Benar; Palsu", "code": "using System ; class GFG { static bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } static void Main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) ) { Console . Write ( \" True \" + \" STRNEWLINE \" ) ; } else { Console . Write ( \" False \" + \" STRNEWLINE \" ) ; } if ( powerOf2 ( m ) ) { Console . Write ( \" True \" ) ; } else { Console . Write ( \" False \" ) ; } } }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | C # Program untuk memeriksa kuasa untuk 2; Kaedah untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kaedah Pemandu", "code": "using System ; class GFG { static bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } public static void Main ( ) { Console . WriteLine ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; Console . WriteLine ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }"}
{"text": "Cari nombor pengulangan maksimum dalam O (n) masa dan O (1) ruang tambahan | C # Program untuk mencari nombor pengulangan maksimum; Mengembalikan elemen berulang maksimum dalam ARR [0. n - 1]. Unsur -unsur array berada dalam jarak dari 0 hingga k - 1; Berulang walaupun array input, untuk setiap elemen arr [i], kenaikan arr [arr [i] % k] oleh k; Cari indeks elemen berulang maksimum; Indeks pulangan elemen maksimum; Fungsi pemacu untuk memeriksa fungsi di atas", "code": "using System ; class GFG { static int maxRepeating ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = arr . Length ; int k = 8 ; Console . Write ( \" Maximum ▁ repeating ▁ \" + \" element ▁ is : ▁ \" + maxRepeating ( arr , n , k ) ) ; } }"}
{"text": "Pertanyaan pelbagai pada array yang setiap elemen adalah xor nilai indeks dan elemen sebelumnya | C # Program untuk menyelesaikan pertanyaan pelbagai pada array yang setiap elemennya adalah xor nilai indeks dan elemen sebelumnya. ; Fungsi pulangan nilai formula yang diperolehi. ; Mencari nilai XOR julat [y ... x]; Fungsi untuk menyelesaikan pertanyaan untuk l dan r. ; jika l atau r ialah 0 .; Mencari X boleh dibahagikan dengan 2 atau tidak. ; Program yang didorong", "code": "using System ; class GFG { static int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } static int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } static void allQueries ( int q , int [ ] l , int [ ] r ) { for ( int i = 0 ; i < q ; i ++ ) Console . WriteLine ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) ) ; } public static void Main ( ) { int q = 3 ; int [ ] l = { 2 , 2 , 5 } ; int [ ] r = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; } }"}
{"text": "Pertanyaan pada Xor pembahagi ganjil yang paling hebat dari julat | C # Kod pertanyaan pada XOR pembahagi ganjil yang paling hebat; Precompute awalan xor pembahagi ganjil yang paling besar; Mencari pembahagi ganjil yang paling besar; Mencari awalan xor; Kembali xor julat; Program yang didorong", "code": "using System ; class GFG { static void prefixXOR ( int [ ] arr , int [ ] preXOR , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; } static int query ( int [ ] preXOR , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; } public static void Main ( ) { int [ ] arr = { 3 , 4 , 5 } ; int n = arr . Length ; int [ ] preXOR = new int [ n ] ; prefixXOR ( arr , preXOR , n ) ; Console . WriteLine ( query ( preXOR , 0 , 2 ) ) ; Console . WriteLine ( query ( preXOR , 1 , 2 ) ) ; } }"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari | C # kod untuk mencari bilangan swap minimum untuk menyusun array binari; Fungsi untuk mencari swap minimum untuk menyusun pelbagai 0 s dan 1 s. ; Array untuk menyimpan kiraan sifar; Kira bilangan sifar di sebelah kanan setiap satu. ; Kira jumlah swap dengan menambahkan bilangan sifar di sebelah kanan setiap satu. ; Kod pemacu", "code": "using System ; class GFG { static int findMinSwaps ( int [ ] arr , int n ) { int [ ] noOfZeroes = new int [ n ] ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } public static void Main ( ) { int [ ] ar = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; Console . WriteLine ( findMinSwaps ( ar , ar . Length ) ) ; } }"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari |  ; Kod pemacu", "code": "using System ; class GFG { static int minswaps ( int [ ] arr , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 2 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } static void Main ( ) { int [ ] arr = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; Console . WriteLine ( minswaps ( arr , 9 ) ) ; } }"}
{"text": "Program untuk memeriksa sama ada array disusun atau tidak (berulang dan rekursif) | Pendekatan rekursif untuk memeriksa sama ada array disusun atau tidak; Fungsi yang pulih benar jika array disusun dalam perintah yang tidak menurun. ; Array mempunyai satu atau tiada elemen; Pasangan yang tidak disusun dijumpai; Tiada pasangan yang tidak disusun dijumpai; Kod pemacu", "code": "using System ; class GFG { static bool arraySortedOrNot ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } public static void Main ( String [ ] args ) { int [ ] arr = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . Length ; if ( arraySortedOrNot ( arr , n ) ) Console . Write ( \" Yes STRNEWLINE \" ) ; else Console . Write ( \" No STRNEWLINE \" ) ; } }"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | C # Program untuk mencari dua elemen yang ganjil; Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan xor semua elemen dalam arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana ia dapat. ; Bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; fungsi utama", "code": "using System ; class main { static void printTwoOdd ( int [ ] arr , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( \" The ▁ two ▁ ODD ▁ elements ▁ are ▁ \" + x + \" ▁ & ▁ \" + y ) ; } public static void Main ( ) { int [ ] arr = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . Length ; printTwoOdd ( arr , arr_size ) ; } }"}
{"text": "Cari pasangan dengan perbezaan yang diberikan | C # Program untuk mencari pasangan dengan perbezaan yang diberikan; Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static bool findPair ( int [ ] arr , int n ) { int size = arr . Length ; int i = 0 , j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { Console . Write ( \" Pair ▁ Found : ▁ \" + \" ( ▁ \" + arr [ i ] + \" , ▁ \" + arr [ j ] + \" ▁ ) \" ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } Console . Write ( \" No ▁ such ▁ pair \" ) ; return false ; } public static void Main ( ) { int [ ] arr = { 1 , 8 , 30 , 40 , 100 } ; int n = 60 ; findPair ( arr , n ) ; } }"}
{"text": "Cari K Unsur Maksimum Array dalam Perintah Asal | C # Program untuk mencari unsur maksimum array dalam urutan asal; Berfungsi untuk mencetak elemen maksimum; Array untuk menyimpan salinan array asal; Menyusun array dalam urutan menurun; Melintasi array asal dan mencetak semua unsur -unsur yang berada dalam k -siswa yang disusun pertama. goo. GL / UJ5RCD Sila rujuk https: untuk butiran array. BinarySearch (); Kod pemacu", "code": "using System ; using System . Linq ; class GFG { public static void printMax ( int [ ] arr , int k , int n ) { int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; Array . Sort ( brr ) ; Array . Reverse ( brr ) ; int [ ] crr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { crr [ i ] = brr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( crr . Contains ( arr [ i ] ) ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } } public static void Main ( ) { int [ ] arr = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = arr . Length ; int k = 3 ; printMax ( arr , k , n ) ; } }"}
{"text": "Cetak n elemen terkecil dari array yang diberikan dalam urutan asal mereka | C # untuk mencetak nombor N terkecil dalam urutan; Berfungsi untuk mencetak nombor N terkecil; Buat salinan Array; Susun Arahan Salin; Bagi setiap arr [i] mendapati sama ada ia adalah sebahagian daripada N - terkecil dengan carian binari; Kod pemacu", "code": "using System ; class GFG { static void printSmall ( int [ ] arr , int asize , int n ) { int [ ] copy_arr = new int [ asize ] ; Array . Copy ( arr , copy_arr , asize ) ; Array . Sort ( copy_arr ) ; for ( int i = 0 ; i < asize ; ++ i ) { if ( Array . BinarySearch ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . Length ; int n = 5 ; printSmall ( arr , asize , n ) ; } }"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | C # Program untuk memeriksa sama ada array yang diberikan boleh membentuk perkembangan aritmetik; Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; Kod pemacu", "code": "using System ; class GFG { static bool checkIsAP ( int [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } public static void Main ( ) { int [ ] arr = { 20 , 15 , 5 , 0 , 10 } ; int n = arr . Length ; if ( checkIsAP ( arr , n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Kira cara memilih pasangan dengan perbezaan maksimum | C # kod untuk mencari tidak. cara memilih pasangan dengan perbezaan maksimum; Untuk mencari minimum dan maksimum array; untuk mencari kiraan elemen minimum dan maksimum; Kiraan pembolehubah; keadaan untuk semua elemen sama; Kod pemacu", "code": "using System ; class GFG { static int countPairs ( int [ ] a , int n ) { int mn = int . MaxValue ; int mx = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . Min ( mn , a [ i ] ) ; mx = Math . Max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } public static void Main ( ) { int [ ] a = { 3 , 2 , 1 , 1 , 3 } ; int n = a . Length ; Console . WriteLine ( countPairs ( a , n ) ) ; } }"}
{"text": "Susun semula senarai yang dipautkan dalam | C # kod untuk menyusun semula senarai yang dipautkan di tempat; Fungsi untuk menyusun semula senarai yang dipautkan dengan nilai tinggi dan rendah. ; Kes asas; Pembolehubah dua penunjuk. ; Fungsi swap untuk menukar data. ; Fungsi swap untuk menukar data. ; Fungsi untuk memasukkan nod dalam senarai yang dipautkan pada mulanya. ; Fungsi untuk memaparkan nod senarai yang dipautkan. ; Kod pemacu; Biarkan membuat senarai yang dipautkan. 9. 6. 8. 3. 7", "code": "using System ; class GFG { class Node { public int data ; public Node next ; } static Node rearrange ( Node head ) { if ( head == null ) return null ; Node prev = head , curr = head . next ; while ( curr != null ) { if ( prev . data > curr . data ) { int t = prev . data ; prev . data = curr . data ; curr . data = t ; } if ( curr . next != null && curr . next . data > curr . data ) { int t = curr . next . data ; curr . next . data = curr . data ; curr . data = t ; } prev = curr . next ; if ( curr . next == null ) break ; curr = curr . next . next ; } return head ; } static Node push ( Node head , int k ) { Node tem = new Node ( ) ; tem . data = k ; tem . next = head ; head = tem ; return head ; } static void display ( Node head ) { Node curr = head ; while ( curr != null ) { Console . Write ( curr . data + \" ▁ \" ) ; curr = curr . next ; } } public static void Main ( string [ ] args ) { Node head = null ; head = push ( head , 7 ) ; head = push ( head , 3 ) ; head = push ( head , 8 ) ; head = push ( head , 6 ) ; head = push ( head , 9 ) ; head = rearrange ( head ) ; display ( head ) ; } }"}
{"text": "Susun semula senarai yang dipautkan dalam | C # pelaksanaan; Mewujudkan struktur untuk nod;  ; Berfungsi untuk mencetak senarai; Berfungsi untuk menyusun semula; Kami menetapkan kiri = null, apabila kita mencapai keadaan berhenti, jadi tiada pemprosesan diperlukan selepas itu; Kondisi Hentikan: Kes Ganjil: Kiri = Kanan, Malah Kes: Kiri. seterusnya = kanan; Hentikan keadaan, tetapkan null ke nod kiri; Malah kes; Kes ganjil; Kod pemacu; Cetak senarai asal; Mengubah suai senarai; Cetak senarai yang diubahsuai", "code": "using System ; public class Node { public int data ; public Node next ; public Node ( int key ) { data = key ; next = null ; } } class GFG { Node left = null ; void printlist ( Node head ) { while ( head != null ) { Console . Write ( head . data + \" ▁ \" ) ; if ( head . next != null ) { Console . Write ( \" - > \" ) ; } head = head . next ; } Console . WriteLine ( ) ; } void rearrange ( Node head ) { if ( head != null ) { left = head ; reorderListUtil ( left ) ; } } void reorderListUtil ( Node right ) { if ( right == null ) { return ; } reorderListUtil ( right . next ) ; if ( left == null ) { return ; } if ( left != right && left . next != right ) { Node temp = left . next ; left . next = right ; right . next = temp ; left = temp ; } else { if ( left . next == right ) { left . next . next = null ; left = null ; } else { left . next = null ; left = null ; } } } static public void Main ( ) { Node head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 3 ) ; head . next . next . next = new Node ( 4 ) ; head . next . next . next . next = new Node ( 5 ) ; GFG gfg = new GFG ( ) ; gfg . printlist ( head ) ; gfg . rearrange ( head ) ; gfg . printlist ( head ) ; } }"}
{"text": "Kurangkan dua nombor yang diwakili sebagai senarai yang dipautkan | C # Program untuk menolak senarai bernilai yang lebih kecil dari senarai bernilai yang lebih besar dan hasil pulangan sebagai senarai. ; Ketua Senarai; Kelas nod; Fungsi utiliti untuk mendapatkan panjang senarai yang dipautkan; Utiliti yang sifar Padds di hadapan nod, dengan perbezaan yang diberikan; Kurangkan Helper LinkedList adalah fungsi rekursif, bergerak sehingga nod terakhir, dan tolak digit dan buat nod dan kembalikan nod. Jika D1 <D2, kami meminjam nombor dari digit sebelumnya. ; Jika anda telah memberikan nilai nilai kepada digit seterusnya maka kurangkan D1 dengan 1; Jika D1 <D2, kemudian pinjam nombor dari digit sebelumnya. Tambah 10 hingga D1 dan set Borrow = true; ; tolak digit; Buat nod dengan sub nilai; Tetapkan penunjuk seterusnya seperti sebelumnya; API ini menolak dua senarai yang dipautkan dan mengembalikan senarai yang dipautkan yang akan mempunyai hasil yang dikurangkan. ; Kes asas. ; Dalam kedua -dua kes itu, dapatkan panjang kedua -dua senarai yang dipautkan. ; Jika panjang berbeza, hitung nod yang lebih kecil dan sifar PADD untuk nod yang lebih kecil dan pastikan kedua -dua nod yang lebih besar dan nod yang lebih kecil mempunyai panjang yang sama. ; Jika kedua -dua senarai panjang adalah sama, maka hitung senarai yang lebih besar dan lebih kecil. Jika 5 - 6 - 7 & 5 - 6 - 8 adalah senarai yang dipautkan, kemudian berjalan melalui senarai yang dipautkan pada nod terakhir sebagai 7 <8, nod yang lebih besar adalah 5 - 6 - 8 dan nod yang lebih kecil ialah 5 - 6 - 7 .; Setelah mengira nod yang lebih besar dan lebih kecil, call tolakLinkedListHelper yang mengembalikan senarai yang dipautkan. ; berfungsi untuk memaparkan senarai yang dipautkan; Kod pemacu", "code": "using System ; public class LinkedList { static Node head ; bool borrow ; public class Node { public int data ; public Node next ; public Node ( int d ) { data = d ; next = null ; } } int getLength ( Node node ) { int size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; } Node paddZeros ( Node sNode , int diff ) { if ( sNode == null ) return null ; Node zHead = new Node ( 0 ) ; diff -- ; Node temp = zHead ; while ( ( diff -- ) != 0 ) { temp . next = new Node ( 0 ) ; temp = temp . next ; } temp . next = sNode ; return zHead ; } Node subtractLinkedListHelper ( Node l1 , Node l2 ) { if ( l1 == null && l2 == null && borrow == false ) return null ; Node previous = subtractLinkedListHelper ( ( l1 != null ) ? l1 . next : null , ( l2 != null ) ? l2 . next : null ) ; int d1 = l1 . data ; int d2 = l2 . data ; int sub = 0 ; if ( borrow ) { d1 -- ; borrow = false ; } if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; } sub = d1 - d2 ; Node current = new Node ( sub ) ; current . next = previous ; return current ; } Node subtractLinkedList ( Node l1 , Node l2 ) { if ( l1 == null && l2 == null ) return null ; int len1 = getLength ( l1 ) ; int len2 = getLength ( l2 ) ; Node lNode = null , sNode = null ; Node temp1 = l1 ; Node temp2 = l2 ; if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , Math . Abs ( len1 - len2 ) ) ; } else { while ( l1 != null && l2 != null ) { if ( l1 . data != l2 . data ) { lNode = l1 . data > l2 . data ? temp1 : temp2 ; sNode = l1 . data > l2 . data ? temp2 : temp1 ; break ; } l1 = l1 . next ; l2 = l2 . next ; } } borrow = false ; return subtractLinkedListHelper ( lNode , sNode ) ; } static void printList ( Node head ) { Node temp = head ; while ( temp != null ) { Console . Write ( temp . data + \" ▁ \" ) ; temp = temp . next ; } } public static void Main ( String [ ] args ) { Node head = new Node ( 1 ) ; head . next = new Node ( 0 ) ; head . next . next = new Node ( 0 ) ; Node head2 = new Node ( 1 ) ; LinkedList ob = new LinkedList ( ) ; Node result = ob . subtractLinkedList ( head , head2 ) ; printList ( result ) ; } }"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | C # pelaksanaan untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Ketua Senarai; Kelas nod; Pembina untuk membuat nod baru; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Kirakan panjang senarai yang dipautkan, i. e, bilangan nod; 'mengira' bilangan nod yang selepas nod baru dimasukkan; 'PTR' menunjuk ke nod yang mana nod baru dimasukkan; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Kod pemacu; Membuat senarai 1.2. 4.5", "code": "using System ; public class LinkedList { static Node head ; public class Node { public int data ; public Node next ; public Node ( int d ) { data = d ; next = null ; } } static void insertAtMid ( int x ) { if ( head == null ) head = new Node ( x ) ; else { Node newNode = new Node ( x ) ; Node ptr = head ; int len = 0 ; while ( ptr != null ) { len ++ ; ptr = ptr . next ; } int count = ( ( len % 2 ) == 0 ) ? ( len / 2 ) : ( len + 1 ) / 2 ; ptr = head ; while ( count -- > 1 ) ptr = ptr . next ; newNode . next = ptr . next ; ptr . next = newNode ; } } static void display ( ) { Node temp = head ; while ( temp != null ) { Console . Write ( temp . data + \" ▁ \" ) ; temp = temp . next ; } } public static void Main ( ) { head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; Console . WriteLine ( \" Linked ▁ list ▁ before ▁ \" + \" insertion : ▁ \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; Console . WriteLine ( \" STRNEWLINE Linked ▁ list ▁ after \" + \" ▁ insertion : ▁ \" ) ; display ( ) ; } }"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | C # pelaksanaan untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Ketua Senarai; Kelas nod; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Berikan nilai kepada petunjuk yang perlahan dan cepat; gerakkan penunjuk perlahan ke nod seterusnya; Pindahkan penunjuk cepat dua nod pada satu masa; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Kod pemacu; Membuat senarai 1.2. 4.5", "code": "using System ; public class LinkedList { static Node head ; class Node { public int data ; public Node next ; public Node ( int d ) { data = d ; next = null ; } } static void insertAtMid ( int x ) { if ( head == null ) head = new Node ( x ) ; else { Node newNode = new Node ( x ) ; Node slow = head ; Node fast = head . next ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } newNode . next = slow . next ; slow . next = newNode ; } } static void display ( ) { Node temp = head ; while ( temp != null ) { Console . Write ( temp . data + \" ▁ \" ) ; temp = temp . next ; } } public static void Main ( String [ ] args ) { head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; Console . WriteLine ( \" Linked ▁ list ▁ before \" + \" ▁ insertion : ▁ \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; Console . WriteLine ( \" STRNEWLINE Linked ▁ list ▁ after \" + \" ▁ insertion : ▁ \" ) ; display ( ) ; } }"}
{"text": "SENARAI SENSI UNTUK SENARAI DUBLY LINKED | C # Pelaksanaan untuk memasukkan sort pada senarai dikaitkan dua kali ganda; Nod senarai dikaitkan dua kali ganda; berfungsi untuk membuat dan mengembalikan nod baru senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; berfungsi untuk memasukkan nod baru dalam cara yang disusun dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Jika nod dimasukkan pada permulaan senarai dikaitkan dua kali ganda; cari nod yang selepas itu nod baru dimasukkan; Membuat pautan yang sesuai; Jika nod baru tidak dimasukkan pada akhir senarai; Fungsi untuk menyusun senarai yang dikaitkan dua kali menggunakan jenis penyisipan; Inisialisasi 'disusun' - senarai dikaitkan dua kali ganda yang disusun; Melintasi senarai dikaitkan dua kali ganda dan masukkan setiap nod untuk 'disusun'; Simpan seterusnya untuk lelaran seterusnya; Mengeluarkan semua pautan untuk membuat 'semasa' sebagai nod baru untuk dimasukkan; Masukkan arus dalam senarai dikaitkan 'disusun'; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun dua kali ganda; berfungsi untuk mencetak senarai dikaitkan dua kali ganda; berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Buat seterusnya nod baru sebagai kepala dan sebelumnya sebagai batal; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Kod pemacu; Mulakan dengan senarai dikaitkan dua kali ganda; Masukkan data berikut", "code": "using System ; class GFG { public class Node { public int data ; public Node prev , next ; } ; static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; newNode . prev = newNode . next = null ; return newNode ; } static Node sortedInsert ( Node head_ref , Node newNode ) { Node current ; if ( head_ref == null ) head_ref = newNode ; else if ( ( head_ref ) . data >= newNode . data ) { newNode . next = head_ref ; newNode . next . prev = newNode ; head_ref = newNode ; } else { current = head_ref ; while ( current . next != null && current . next . data < newNode . data ) current = current . next ; newNode . next = current . next ; if ( current . next != null ) newNode . next . prev = newNode ; current . next = newNode ; newNode . prev = current ; } return head_ref ; } static Node insertionSort ( Node head_ref ) { Node sorted = null ; Node current = head_ref ; while ( current != null ) { Node next = current . next ; current . prev = current . next = null ; sorted = sortedInsert ( sorted , current ) ; current = next ; } head_ref = sorted ; return head_ref ; } static void printList ( Node head ) { while ( head != null ) { Console . Write ( head . data + \" ▁ \" ) ; head = head . next ; } } static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; new_node . prev = null ; if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ; ( head_ref ) = new_node ; return head_ref ; } public static void Main ( String [ ] args ) { Node head = null ; head = push ( head , 9 ) ; head = push ( head , 3 ) ; head = push ( head , 5 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 8 ) ; Console . WriteLine ( \" Doubly ▁ Linked ▁ List ▁ Before ▁ Sorting \" ) ; printList ( head ) ; head = insertionSort ( head ) ; Console . WriteLine ( \" STRNEWLINE Doubly ▁ Linked ▁ List ▁ After ▁ Sorting \" ) ; printList ( head ) ; } }"}
{"text": "Cetak semua kemungkinan putaran array yang diberikan | C # Program untuk mencetak semua kemungkinan putaran array yang diberikan; Perisytiharan Global Array; Fungsi untuk membalikkan array antara indeks S dan E; Berfungsi untuk menjana semua kemungkinan putaran array; Kod pemacu", "code": "using System ; class GFG { static int [ ] arr = new int [ 10000 ] ; public static void reverse ( int [ ] arr , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } } public static void fun ( int [ ] arr , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } } public static void Main ( String [ ] args ) { arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; Console . Write ( \" [ \" ) ; for ( int j = 0 ; j < 4 ; j ++ ) { Console . Write ( arr [ j ] + \" , ▁ \" ) ; } Console . Write ( \" ] \" ) ; } } }"}
{"text": "Cari jumlah array menggunakan bitwise atau selepas memisahkan array yang diberikan dalam dua bahagian selepas pergeseran bulat k | C # Program untuk mencari bitwise atau dua bahagian yang sama dengan array selepas melakukan peralihan bulat kanan K; Array untuk menyimpan pokok segmen; Berfungsi untuk membina pokok segmen; Berfungsi untuk mengembalikan atau unsur -unsur dalam julat [l, r]; Semak keadaan terikat; Cari tengah julat; Berulang untuk semua elemen dalam pelbagai; Berfungsi untuk mencari atau jumlah; Berfungsi untuk membina pokok segmen; Gelung untuk mengendalikan pertanyaan Q; Bilangan peralihan bulat yang betul; Atau separuh kedua array [n / 2 - i, n - 1 - i]; Atau separuh pertama array [n - i, n - 1] atau [0, n / 2 - 1 - i]; Cetak jawapan bacaan kepada pertanyaan; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100005 ; static int [ ] seg = new int [ 4 * MAX ] ; static void build ( int node , int l , int r , int [ ] a ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } static int query ( int node , int l , int r , int start , int end , int [ ] a ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } static void orsum ( int [ ] a , int n , int q , int [ ] k ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; Console . Write ( temp + \" STRNEWLINE \" ) ; } } public static void Main ( String [ ] args ) { int [ ] a = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = a . Length ; int q = 2 ; int [ ] k = { 4 , 2 } ; orsum ( a , n , q , k ) ; } }"}
{"text": "Memaksimumkan kiraan unsur -unsur yang sama dalam tatasusunan yang diberikan oleh putaran | C # Program pendekatan di atas; Fungsi yang mencetak elemen maksimum yang sama; Vektor untuk menyimpan indeks elemen array b; Menyimpan kedudukan array b; Arahan frekuensi untuk mengekalkan unsur -unsur dengan perbezaan yang sama dalam jarak; Melangkah melalui semua elemen dalam ARR1 []; Kirakan bilangan peralihan yang diperlukan untuk menjadikan elemen semasa sama; Jika D kurang daripada 0; Simpan kekerapan perbezaan semasa; Kirakan kekerapan maksimum yang disimpan; Mencetak bilangan maksimum elemen yang sama; Kod pemacu; Diberikan dua tatasusunan; Panggilan fungsi", "code": "using System ; class GFG { static void maximumEqual ( int [ ] a , int [ ] b , int n ) { int [ ] store = new int [ ( int ) 1e5 ] ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } int [ ] ans = new int [ ( int ) 1e5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int d = Math . Abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = Math . Max ( finalans , ans [ i ] ) ; Console . Write ( finalans + \" STRNEWLINE \" ) ; } public static void Main ( ) { int [ ] A = { 6 , 7 , 3 , 9 , 5 } ; int [ ] B = { 7 , 3 , 9 , 5 , 6 } ; int size = A . Length ; maximumEqual ( A , B , size ) ; } }"}
{"text": "Arahan cetak selepas ia betul -betul diputar k kali | C # Pelaksanaan putaran kanan array k bilangan kali; Berfungsi untuk array rightrotate; Jika putaran lebih besar daripada saiz array; Mencetak elemen kth paling kanan; Cetak array selepas elemen 'k'; Kod pemacu", "code": "using System ; class GFG { static void RightRotate ( int [ ] a , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { Console . Write ( a [ n + i - k ] + \" ▁ \" ) ; } else { Console . Write ( a [ i - k ] + \" ▁ \" ) ; } } Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { int [ ] Array = { 1 , 2 , 3 , 4 , 5 } ; int N = Array . Length ; int K = 2 ; RightRotate ( Array , N , K ) ; } }"}
{"text": "Sort Array Disusun Berputar | C # Pelaksanaan untuk memulihkan jenis asal dalam array yang disusun diputar; Berfungsi untuk memulihkan jenis asal; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "using System ; class GFG { static void restoreSortedArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } } static void reverse ( int [ ] arr , int i , int j ) { int temp ; while ( i < j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } } static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . Length ; restoreSortedArray ( arr , n - 1 ) ; printArray ( arr , n ) ; } }"}
{"text": "Sort Array Disusun Berputar | C # Pelaksanaan untuk memulihkan jenis asal dalam array disusun yang diputar menggunakan carian binari; Fungsi untuk mencari indeks permulaan array; Berfungsi untuk memulihkan jenis asal; Array sudah disusun; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "using System ; class GFG { static int findStartIndexOfArray ( int [ ] arr , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } } static void restoreSortedArray ( int [ ] arr , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; Array . Sort ( arr , 0 , start ) ; Array . Sort ( arr , start , n ) ; Array . Sort ( arr ) ; } static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; } }"}
{"text": "Putaran kiri dan putaran kanan rentetan | C # Program untuk putaran kiri dan putaran kanan rentetan; fungsi yang berputar ke kiri oleh D; fungsi yang berputar ke arah kanan oleh D; Kod pemacu", "code": "using System ; class GFG { static String leftrotate ( String str , int d ) { String ans = str . Substring ( d , str . Length - d ) + str . Substring ( 0 , d ) ; return ans ; } static String rightrotate ( String str , int d ) { return leftrotate ( str , str . Length - d ) ; } public static void Main ( String [ ] args ) { String str1 = \" GeeksforGeeks \" ; Console . WriteLine ( leftrotate ( str1 , 2 ) ) ; String str2 = \" GeeksforGeeks \" ; Console . WriteLine ( rightrotate ( str2 , 2 ) ) ; } }"}
{"text": "Cari elemen dalam Senarai Berkaitan Pekeliling Ganda | C # Program untuk membalikkan senarai menggunakan pertukaran data; Struktur nod; Berfungsi untuk memasukkan nod pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir /; Buat nod secara dinamik; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Berfungsi untuk memaparkan senarai dikaitkan dua kali ganda; Berfungsi untuk mencari elemen tertentu dari senarai; Mengisytiharkan pemboleh ubah temp; Mengisytiharkan pemboleh ubah kawalan lain untuk mencari; Jika permulaan adalah NULL RETURN - 1; Gerakkan penunjuk temp sehingga, temp. Seterusnya tidak memindahkan alamat permulaan (fesyen bulat); Kiraan kenaikan lokasi; Jika didapati menaikkan bendera dan memecahkan gelung; Penunjuk suhu kenaikan; Semak sama ada elemen terakhir dalam kandungan senarai nilai jika mengandungi, menaikkan bendera dan kiraan kenaikan; Jika bendera adalah benar, maka unsur dijumpai, lain tidak; Kod pemacu; Mulakan dengan senarai kosong /; Masukkan 4. Jadi senarai yang dipautkan menjadi 4. NULL; Masukkan 5. Jadi senarai yang dipautkan menjadi 4.5; Masukkan 7. Jadi senarai yang dipautkan menjadi 4.5. 7; Masukkan 8. Jadi senarai yang dipautkan menjadi 4.5. 7.8; Masukkan 6. Jadi senarai yang dipautkan menjadi 4.5. 7.8. 6", "code": "using System ; class GFG { public class Node { public int data ; public Node next ; public Node prev ; } ; static Node insertNode ( Node start , int value ) { Node new_node = new Node ( ) ; if ( start == null ) { new_node . data = value ; new_node . next = new_node . prev = new_node ; start = new_node ; return new_node ; } Node last = ( start ) . prev ; new_node = new Node ( ) ; new_node . data = value ; new_node . next = start ; ( start ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return start ; } static void displayList ( Node start ) { Node temp = start ; while ( temp . next != start ) { Console . Write ( \" { 0 } ▁ \" , temp . data ) ; temp = temp . next ; } Console . Write ( \" { 0 } ▁ \" , temp . data ) ; } static int searchList ( Node start , int search ) { Node temp = start ; int count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) Console . WriteLine ( \" STRNEWLINE \" + search + \" ▁ found ▁ at ▁ location ▁ \" + count ) ; else Console . WriteLine ( \" STRNEWLINE \" + search + \" ▁ not ▁ found \" ) ; } return - 1 ; } public static void Main ( String [ ] args ) { Node start = null ; start = insertNode ( start , 4 ) ; start = insertNode ( start , 5 ) ; start = insertNode ( start , 7 ) ; start = insertNode ( start , 8 ) ; start = insertNode ( start , 6 ) ; Console . Write ( \" Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ \" ) ; displayList ( start ) ; searchList ( start , 5 ) ; } }"}
{"text": "Membalikkan senarai dikaitkan bulat berganda | C # Pelaksanaan untuk mengulangi senarai dikaitkan bulat dua kali ganda; struktur nod senarai yang dipautkan; berfungsi untuk membuat dan mengembalikan nod baru; Berfungsi untuk memasukkan pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir /; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Fungsi uitlity untuk mengulangi senarai dikaitkan bulat dua kali ganda; Memulakan penunjuk kepala baru; Dapatkan penunjuk ke nod terakhir; Tetapkan 'curr' ke nod terakhir; senarai melintasi arah ke belakang; Masukkan 'curr' pada akhir senarai bermula dengan penunjuk 'baru _ kepala'; penunjuk kepala senarai terbalik; berfungsi untuk memaparkan senarai bulat berganda dalam arah ke hadapan dan ke belakang; Kod pemacu", "code": "using System ; class GFG { public class Node { public int data ; public Node next , prev ; } ; static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; return newNode ; } static Node insertEnd ( Node head , Node new_node ) { if ( head == null ) { new_node . next = new_node . prev = new_node ; head = new_node ; return head ; } Node last = ( head ) . prev ; new_node . next = head ; ( head ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return head ; } static Node reverse ( Node head ) { if ( head == null ) return null ; Node new_head = null ; Node last = head . prev ; Node curr = last , prev ; while ( curr . prev != last ) { prev = curr . prev ; new_head = insertEnd ( new_head , curr ) ; curr = prev ; } new_head = insertEnd ( new_head , curr ) ; return new_head ; } static void display ( Node head ) { if ( head == null ) return ; Node temp = head ; Console . Write ( \" Forward ▁ direction : ▁ \" ) ; while ( temp . next != head ) { Console . Write ( temp . data + \" ▁ \" ) ; temp = temp . next ; } Console . Write ( temp . data + \" ▁ \" ) ; Node last = head . prev ; temp = last ; Console . Write ( \" STRNEWLINE Backward ▁ direction : ▁ \" ) ; while ( temp . prev != last ) { Console . Write ( temp . data + \" ▁ \" ) ; temp = temp . prev ; } Console . Write ( temp . data + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { Node head = null ; head = insertEnd ( head , getNode ( 1 ) ) ; head = insertEnd ( head , getNode ( 2 ) ) ; head = insertEnd ( head , getNode ( 3 ) ) ; head = insertEnd ( head , getNode ( 4 ) ) ; head = insertEnd ( head , getNode ( 5 ) ) ; Console . Write ( \" Current ▁ list : STRNEWLINE \" ) ; display ( head ) ; head = reverse ( head ) ; Console . Write ( \" STRNEWLINE STRNEWLINE Reversed ▁ list : STRNEWLINE \" ) ; display ( head ) ; } }"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Pelaksanaan C # Naive untuk mencari LCA di dalam pokok. ; Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; Menandakan ibu bapa untuk setiap nod; Menandakan kedalaman untuk setiap nod; Propogating menandakan pokok itu; Nod dummy; Precalclating 1) kedalaman. 2) ibu bapa. untuk setiap nod; Kerumitan masa: O (ketinggian pokok) secara rekursif melompat satu nod di atas sehingga kedua -dua nod menjadi sama; Kod pemacu; Menambah tepi ke pokok", "code": "using System ; using System . Collections ; class GFG { static int MAXN = 1001 ; static int [ ] depth = new int [ MAXN ] ; static int [ ] parent = new int [ MAXN ] ; static ArrayList [ ] adj = new ArrayList [ MAXN ] ; static void addEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; } static void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . Count ; i ++ ) if ( ( int ) adj [ cur ] [ i ] != prev ) dfs ( ( int ) adj [ cur ] [ i ] , cur ) ; } static void preprocess ( ) { depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; } static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int temp = u ; u = v ; v = temp ; } v = parent [ v ] ; return LCANaive ( u , v ) ; } public static void Main ( string [ ] args ) { for ( int i = 0 ; i < MAXN ; i ++ ) adj [ i ] = new ArrayList ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; Console . WriteLine ( \" LCA ( 11 , ▁ 8 ) ▁ : ▁ \" + LCANaive ( 11 , 8 ) ) ; Console . WriteLine ( \" LCA ( 3 , ▁ 13 ) ▁ : ▁ \" + LCANaive ( 3 , 13 ) ) ; } }"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | C # Program untuk mencari LCA menggunakan penguraian SQRT; Saiz blok = matematik. Sqrt (ketinggian); Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; Kedai nenek moyang pertama di blok sebelumnya; mempraktikkan parameter yang diperlukan yang berkaitan dengan setiap nod; menandakan kedalaman node cur; menandakan ibu bapa node cur; membuat jump_parent node cur; Jika ia adalah nod pertama blok maka jump_parentnya adalah ibu bapa yang curnya; Jika bukan nod pertama blok ini maka jump_parentnya adalah jump_parent ibu bapanya; propogating menandakan subtree; menggunakan helah penguraian SQRT; mengekalkan kedalaman [v]> kedalaman [u]; Mendaki ke ibu bapa melompatnya; u dan v mempunyai jump_parent yang sama; precalclating 1) kedalaman. 2) ibu bapa. 3) Jump_parent untuk setiap nod; Kod pemacu; Menambah tepi ke pokok; Di sini kita terus mengambil ketinggian = 4 mengikut pokok yang diberikan tetapi kita boleh mengira ketinggian = kedalaman maksimum dalam satu lagi dfs", "code": "using System ; using System . Collections . Generic ; public class GFG { static readonly int MAXN = 1001 ; static int block_sz ; static int [ ] depth = new int [ MAXN ] ; static int [ ] parent = new int [ MAXN ] ; static int [ ] jump_parent = new int [ MAXN ] ; static List < int > [ ] adj = new List < int > [ MAXN ] ; static void addEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; } static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int t = u ; u = v ; v = t ; } v = parent [ v ] ; return LCANaive ( u , v ) ; } static void dfs ( int cur , int prev ) { depth [ cur ] = depth [ prev ] + 1 ; parent [ cur ] = prev ; if ( depth [ cur ] % block_sz == 0 ) jump_parent [ cur ] = parent [ cur ] ; else jump_parent [ cur ] = jump_parent [ prev ] ; for ( int i = 0 ; i < adj [ cur ] . Count ; ++ i ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } static int LCASQRT ( int u , int v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) { int t = u ; u = v ; v = t ; } v = jump_parent [ v ] ; } return LCANaive ( u , v ) ; } static void preprocess ( int height ) { block_sz = ( int ) Math . Sqrt ( height ) ; depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; } public static void Main ( String [ ] args ) { for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; int height = 4 ; preprocess ( height ) ; Console . Write ( \" LCA ( 11,8 ) ▁ : ▁ \" + LCASQRT ( 11 , 8 ) + \" STRNEWLINE \" ) ; Console . Write ( \" LCA ( 3,13 ) ▁ : ▁ \" + LCASQRT ( 3 , 13 ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Bilangan ujian yang dijangkakan untuk mendapatkan kepala berturut -turut n | C # pelaksanaan pendekatan di atas; Kod pemacu; Formula untuk bilangan laluan untuk kepala berturut -turut n", "code": "using System ; class GFG { public static void Main ( ) { int N = 3 ; Console . Write ( Math . Pow ( 2 , N + 1 ) - 2 ) ; } }"}
{"text": "Cari dan kirakan jumlah faktor Co | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n] dalam masa yang berterusan; Kirakan kiraan nombor yang boleh dibahagikan dengan A dalam julat [1, n]; Kirakan kiraan nombor yang boleh dibahagi dengan b dalam julat [1, n]; Menambah tuduhan yang boleh dibahagikan oleh A dan B; Nilai di atas mungkin mengandungi nilai berulang yang boleh dibahagikan oleh kedua -dua A dan B. Oleh itu, kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B ditemui; Kiraan yang dikira di atas dikurangkan untuk mengira kiraan readonly; Berfungsi untuk mengembalikan jumlah nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n]; Tetapkan untuk menyimpan nombor supaya nombor tidak diulang; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk melangkah melalui set dan cari jumlahnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int countOfNum ( int n , int a , int b ) { int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; } static int sumOfNum ( int n , int a , int b ) { int i ; int sum = 0 ; HashSet < int > ans = new HashSet < int > ( ) ; for ( i = a ; i <= n ; i = i + a ) { ans . Add ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . Add ( i ) ; } foreach ( int it in ans ) { sum = sum + it ; } return sum ; } public static void Main ( String [ ] args ) { int N = 88 ; int A = 11 ; int B = 8 ; int count = countOfNum ( N , A , B ) ; int sumofnum = sumOfNum ( N , A , B ) ; Console . Write ( sumofnum % count ) ; } }"}
{"text": "Cari nilai julat ungkapan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai ungkapan yang diberikan; Nilai istilah pertama; Nilai istilah terakhir; Kod pemacu; Dapatkan hasilnya", "code": "using System ; public class GFG { static double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } public static void Main ( String [ ] args ) { int L = 6 , R = 12 ; double ans = get ( L , R ) ; Console . Write ( \" { 0 : F2 } \" , ans ) ; } }"}
{"text": "Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 dalam perwakilan binari itu | C # pelaksanaan pendekatan; Untuk menyimpan bilangan bulat pra -dikira; Fungsi yang mengembalikan benar jika perwakilan binari x mengandungi 1 s; Untuk menyimpan sedikit sebelumnya; Semak sama ada bit sebelumnya dan bit semasa adalah kedua -dua 1; Mengemas kini sedikit sebelumnya; Pergi ke bit seterusnya; Fungsi untuk pra - mengira nombor yang sah dari 0 hingga maksimum; Simpan semua nombor yang tidak mempunyai 1 s berturut -turut; Berfungsi untuk mengembalikan nombor minimum yang lebih besar daripada n yang tidak mengandungi 1 s berturut -turut; Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 s; Berfungsi untuk melakukan pertanyaan; Kod pemacu; Pra - mengira nombor; Lakukan pertanyaan", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 100000 ; static List < int > v = new List < int > ( ) ; static int upper_bound ( List < int > ar , int k ) { int s = 0 ; int e = ar . Count ; while ( s != e ) { int mid = s + e >> 1 ; if ( ar [ mid ] <= k ) { s = mid + 1 ; } else { e = mid ; } } if ( s == ar . Count ) { return - 1 ; } return s ; } static int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 && p == 1 ) { return 1 ; } p = x % 2 ; x /= 2 ; } return 0 ; } static void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( consecutiveOnes ( i ) == 0 ) { v . Add ( i ) ; } } } static int nextValid ( int n ) { int it = upper_bound ( v , n ) ; int val = v [ it ] ; return val ; } static void performQueries ( int [ ] queries , int q ) { for ( int i = 0 ; i < q ; i ++ ) { Console . WriteLine ( nextValid ( queries [ i ] ) ) ; } } static public void Main ( ) { int [ ] queries = { 4 , 6 } ; int q = queries . Length ; preCompute ( ) ; performQueries ( queries , q ) ; } }"}
{"text": "Operasi minimum yang diperlukan untuk menukar rentetan binari yang diberikan kepada semua 1 s | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan operasi yang diperlukan; CTR akan menyimpan bilangan yang berturut -turut pada akhir rentetan binari yang diberikan; Gelung untuk mencari bilangan 1 s pada akhir rentetan; Jika watak semasa adalah 1; Jika kita menghadapi 0 pertama dari kedudukan LSB maka kita akan memecahkan gelung; Bilangan operasi yang diperlukan ialah (L - CTR); Berfungsi untuk mengeluarkan sifar utama dari rentetan; Gelung sehingga S [i] menjadi tidak sama dengan 1; Jika kita sampai ke hujung rentetan, ini bermakna rentetan hanya mengandungi 0 's; Kembalikan rentetan tanpa nol utama; Kod pemacu; Mengeluarkan sifar terkemuka", "code": "using System ; class GFG { static int changeToOnes ( String str ) { int i , l , ctr = 0 ; l = str . Length ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) ctr ++ ; else break ; } return l - ctr ; } static String removeZeroesFromFront ( String str ) { String s ; int i = 0 ; while ( i < str . Length && str [ i ] == '0' ) i ++ ; if ( i == str . Length ) s = \"0\" ; else s = str . Substring ( i , str . Length - i ) ; return s ; } public static void Main ( String [ ] args ) { String str = \"10010111\" ; str = removeZeroesFromFront ( str ) ; Console . WriteLine ( changeToOnes ( str ) ) ; } }"}
{"text": "Penghapusan minimum diperlukan sedemikian rupa sehingga mana -mana nombor x akan berlaku tepat x kali | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan penghapusan minimum yang diperlukan; Untuk menyimpan kekerapan elemen array; Kekerapan kedai setiap elemen; Untuk menyimpan penghapusan minimum yang diperlukan; Nilai; Kekerapan itu; Jika bilangan kurang daripada atau sama dengan kekerapannya; Padam kejadian tambahan; Padam setiap kejadian x; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int MinDeletion ( int [ ] a , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( a [ i ] ) ) { var val = mp [ a [ i ] ] ; mp . Remove ( a [ i ] ) ; mp . Add ( a [ i ] , val + 1 ) ; } else { mp . Add ( a [ i ] , 1 ) ; } } int ans = 0 ; foreach ( KeyValuePair < int , int > i in mp ) { int x = i . Key ; int frequency = i . Value ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] a = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = a . Length ; Console . WriteLine ( MinDeletion ( a , n ) ) ; } }"}
{"text": "Rentetan concatenate dalam apa -apa perintah untuk mendapatkan bilangan maksimum \"ab\" | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum abs; Pembolehubah A, B, AB untuk mengira rentetan yang berakhir dengan 'A' tetapi tidak berakhir dengan 'B', 'B' tetapi tidak berakhir dengan 'A' dan 'B' dan berakhir dengan 'A' masing -masing. ; 'Ab' sudah ada dalam rentetan sebelum menggabungkan mereka; Count rentetan yang bermula dengan 'B' dan berakhir dengan 'A; Count rentetan yang bermula dengan 'B' tetapi tidak berakhir dengan 'A'; Count rentetan yang berakhir dengan 'a' tetapi tidak berakhir dengan 'b'; mengemas kini nilai ANS dan menambah kiraan tambahan 'ab'; Kod pemacu", "code": "using System ; class GFG { static int maxCountAB ( string [ ] s , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . Length ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == ' A ' && S [ j + 1 ] == ' B ' ) { ans ++ ; } } if ( S [ 0 ] == ' B ' && S [ L - 1 ] == ' A ' ) BA ++ ; else if ( S [ 0 ] == ' B ' ) B ++ ; else if ( S [ L - 1 ] == ' A ' ) A ++ ; } if ( BA == 0 ) ans += Math . Min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . Min ( B , A ) ; return ans ; } public static void Main ( ) { string [ ] s = { \" ABCA \" , \" BOOK \" , \" BAND \" } ; int n = s . Length ; Console . WriteLine ( maxCountAB ( s , n ) ) ; } }"}
{"text": "Operasi minimum untuk membuat jumlah elemen jiran <= x | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan jumlah operasi yang diperlukan; Mula -mula membuat semua elemen sama dengan x yang lebih besar; Kiri mengimbas array; Kemas kini elemen semasa supaya jumlah jiran adalah <x; Kod pemacu", "code": "using System ; class GFG { static int MinOperations ( int n , int x , int [ ] arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . Max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } public static void Main ( String [ ] args ) { int X = 1 ; int [ ] arr = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = arr . Length ; Console . WriteLine ( MinOperations ( N , X , arr ) ) ; } }"}
{"text": "Cari nombor berulang dan nombor yang hilang menggunakan dua persamaan | C # pelaksanaan pendekatan; Berfungsi untuk mencetak nombor yang diperlukan; Jumlah nombor semulajadi n pertama; Jumlah kuadrat nombor semulajadi n pertama; Untuk menyimpan jumlah dan jumlah kuadrat unsur -unsur array; Kod pemacu", "code": "using System ; public class GFG { static void findNumbers ( int [ ] arr , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += ( int ) Math . Pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; Console . WriteLine ( \" A ▁ = ▁ \" + A + \" B = \" } public static void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 3 , 4 } ; int n = arr . Length ; findNumbers ( arr , n ) ; } }"}
{"text": "Rentetan terkecil lexicographically dengan rentetan yang diberikan sebagai awalan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari sama ada temp rentetan bermula dengan STR atau tidak; Kes asas; Semak aksara yang sepadan dalam temp & str; Berfungsi untuk mencari rentetan terkecil lexicographic yang terdiri daripada string str as awalan; Susun rentetan array yang diberikan []; Jika rentetan i - th mengandungi rentetan yang diberikan sebagai awalan, maka cetak hasilnya; Jika tiada rentetan wujud maka kembali \" - 1\"; Kod pemacu", "code": "using System ; class GFG { static bool is_prefix ( string temp , string str ) { if ( temp . Length < str . Length ) return false ; else { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] != temp [ i ] ) return false ; } return true ; } } static string lexicographicallyString ( string [ ] input , int n , string str ) { Array . Sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return \" - 1\" ; } public static void Main ( ) { string [ ] arr = { \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" } ; string S = \" app \" ; int N = 5 ; Console . WriteLine ( lexicographicallyString ( arr , N , S ) ) ; } }"}
{"text": "Susun semula Arahan untuk mencari K menggunakan algoritma carian binari tanpa menyusun | C # Program untuk pendekatan di atas; Berfungsi untuk menyusun semula array; Menyimpan array yang disusun semula; Kedai sama ada pengaturan itu mungkin atau tidak; Kemas kini k dengan kedudukan k; Menyimpan semua elemen yang lebih rendah daripada dan lebih besar daripada vektor yang lebih kecil dan lebih besar masing -masing; Melintasi array [] arr; Jika arr [i] kurang daripada arr [k]; Lain; Iterat Unil Low kurang daripada atau sama dengan tinggi; Kedai pertengahan titik; Jika pertengahan adalah sama dengan k; Jika pertengahan kurang daripada k; Jika pertengahan lebih besar daripada k; Jika f adalah - 1; Melangkah dalam julat [1, n]; Jika Ans [i] sama dengan - 1; Cetak array yang disusun semula; Kod pemacu; Input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; public class GFG { static void Rearrange ( int [ ] arr , int K , int N ) { int [ ] ans = new int [ N + 1 ] ; int f = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = - 1 ; } for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] == K ) { K = i ; break ; } } List < int > smaller = new List < int > ( ) ; List < int > greater = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ K ] ) smaller . Add ( arr [ i ] ) ; else if ( arr [ i ] > arr [ K ] ) greater . Add ( arr [ i ] ) ; } int low = 0 , high = N - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; } else if ( mid < K ) { if ( smaller . Count == 0 ) { break ; } ans [ mid ] = smaller [ smaller . Count - 1 ] ; smaller . RemoveAt ( smaller . Count - 1 ) ; low = mid + 1 ; } else { if ( greater . Count == 0 ) { break ; } ans [ mid ] = greater [ greater . Count - 1 ] ; greater . RemoveAt ( greater . Count - 1 ) ; high = mid - 1 ; } } if ( f == - 1 ) { Console . WriteLine ( - 1 ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ans [ i ] == - 1 ) { if ( smaller . Count > 0 ) { ans [ i ] = smaller [ smaller . Count - 1 ] ; smaller . RemoveAt ( smaller . Count - 1 ) ; } else if ( greater . Count > 0 ) { ans [ i ] = greater [ greater . Count - 1 ] ; greater . RemoveAt ( greater . Count - 1 ) ; } } } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( ans [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 7 , 2 , 5 , 3 , 8 } ; int K = 7 ; int N = arr . Length ; Rearrange ( arr , K , N ) ; } }"}
{"text": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; ITERATE K dari [1, n]; Jumlah gula -gula; Gula -gula yang diambil oleh orang 1; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array arr []; Jumlah yang digunakan oleh orang j; Mengemas kini bilangan gula -gula; Bahagian yang baik dari gula -gula yang dicapai; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void minimumK ( List < int > arr , int M , int N ) { int good = ( int ) ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) + 1 ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += Math . Min ( K , candies ) ; candies -= Math . Min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { Console . Write ( i ) ; return ; } } } public static void Main ( ) { int N = 13 , M = 1 ; List < int > arr = new List < int > ( ) ; arr . Add ( 50 ) ; minimumK ( arr , M , N ) ; } }"}
{"text": "Jumlah masa yang diperlukan untuk mengembara jalan yang dilambangkan oleh rentetan yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira masa yang diambil untuk perjalanan jalan; Kedai jumlah masa; Kedudukan awal; Kedai -kedai melawat segmen; Semak sama ada segmen hadir dalam set; Meningkatkan nilai masa dengan 2; Masukkan segmen ke dalam set; Cetak nilai masa; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void calcTotalTime ( string path ) { int time = 0 ; int x = 0 , y = 0 ; HashSet < string > s = new HashSet < string > ( ) ; for ( int i = 0 ; i < path . Length ; i ++ ) { int p = x ; int q = y ; if ( path [ i ] == ' N ' ) y ++ ; else if ( path [ i ] == ' S ' ) y -- ; else if ( path [ i ] == ' E ' ) x ++ ; else if ( path [ i ] == ' W ' ) x -- ; string o = ( p + x ) + \" ▁ \" + ( q + y ) ; if ( s . Contains ( o ) == false ) { time += 2 ; s . Add ( o ) ; } else time += 1 ; } Console . Write ( time ) ; } public static void Main ( ) { string path = \" NSE \" ; calcTotalTime ( path ) ; } }"}
{"text": "Kos yang diperlukan untuk menjadikan semua elemen array sama dengan 1 | C # Program untuk pendekatan di atas; Fungsi untuk mengira kos yang diperlukan untuk membuat semua elemen array sama dengan 1; Menyimpan jumlah kos; Melintasi array arr []; Jika elemen semasa ialah 0; Tukar 0 hingga 1; Tambah kos; Mengembalikan jumlah kos; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = arr . Length ; Console . Write ( findCost ( arr , N ) ) ; } }"}
{"text": "Cari indeks puncak array yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mencari indeks puncak untuk array yang diberikan; Kes asas; Semak array yang semakin meningkat; Sekiranya keadaan yang semakin meningkat dilanggar, maka pecah; Menyimpan nilai i, yang merupakan indeks puncak yang berpotensi; Traversal kedua, untuk array yang ketat; Apabila keadaan ketat yang dikurangkan dilanggar, kemudian pecah; Jika i = n - 1, ini bermakna bahawa ANS adalah indeks puncak; Jika tidak, indeks puncak tidak wujud; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static int peakIndex ( int [ ] arr ) { int N = arr . Length ; if ( arr . Length < 3 ) return - 1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return - 1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return - 1 ; } static public void Main ( ) { int [ ] arr = { 0 , 1 , 0 } ; Console . WriteLine ( peakIndex ( arr ) ) ; } }"}
{"text": "Memandangkan array A [] dan nombor x, periksa pasangan dalam [] dengan jumlah sebagai x | Tetapkan 2 | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan; Menyusun array dalam peningkatan urutan; Melintasi array, nums []; Simpan nombor yang diperlukan untuk dijumpai; Melakukan carian binari; Simpan nilai pertengahan; Jika nums [mid] lebih besar daripada x, maka kemas kini tinggi hingga pertengahan - 1; Jika Nums [Mid] kurang daripada X, maka kemas kini rendah hingga pertengahan + 1; Jika tidak; Jika pertengahan adalah sama i, periksa pertengahan - 1 dan pertengahan + 1; Jika tidak, cetak pasangan dan kembali; Jika tidak ada pasangan yang dijumpai, maka cetak - 1; Kod pemacu; Panggilan fungsi", "code": "using System ; public class GFG { static void hasArrayTwoPairs ( int [ ] nums , int n , int target ) { Array . Sort ( nums ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { Console . Write ( nums [ i ] + \" , ▁ \" ) ; Console . Write ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { Console . Write ( nums [ i ] + \" , ▁ \" ) ; Console . Write ( nums [ mid + 1 ] ) ; return ; } break ; } else { Console . Write ( nums [ i ] + \" , ▁ \" ) ; Console . Write ( nums [ mid ] ) ; return ; } } } } Console . Write ( - 1 ) ; } static public void Main ( ) { int [ ] A = { 0 , - 1 , 2 , - 3 , 1 } ; int X = - 2 ; int N = A . Length ; hasArrayTwoPairs ( A , N , X ) ; } }"}
{"text": "Pembahagi terkecil n paling dekat dengan x | C # Program untuk pendekatan di atas; Berfungsi untuk mencari pembahagi n paling dekat dengan sasaran; Berulang sehingga akar persegi n; Semak jika pembahagi adalah sama; Semak jika saya adalah yang paling dekat; Semak jika saya adalah yang paling dekat; Semak jika N / I adalah yang paling dekat; Cetak nilai terdekat; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "using System ; class GFG { static void findClosest ( int N , int target ) { int closest = - 1 ; int diff = Int32 . MaxValue ; for ( int i = 1 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( Math . Abs ( target - i ) < diff ) { diff = Math . Abs ( target - i ) ; closest = i ; } } else { if ( Math . Abs ( target - i ) < diff ) { diff = Math . Abs ( target - i ) ; closest = i ; } if ( Math . Abs ( target - N / i ) < diff ) { diff = Math . Abs ( target - N / i ) ; closest = N / i ; } } } } Console . Write ( closest ) ; } static void Main ( ) { int N = 16 , X = 5 ; findClosest ( N , X ) ; } }"}
{"text": "Cari pasangan (a, b) seperti AA + BB = n | C # Program untuk pendekatan di atas; Fungsi untuk mengira kuasa minimum a dan b lebih besar daripada n; Menyimpan kuasa A yang lebih besar daripada n; Kiraan kenaikan sebanyak 1; Bahagikan n oleh A; Fungsi untuk mencari pasangan (a, b) sedemikian rupa sehingga a ^ a + b ^ b = n; Kirakan kuasa minimum yang lebih besar daripada n; Kirakan kuasa minimum B lebih besar daripada N; Buat salinan A dan B; Melintasi setiap pasangan (i, j); Semak jika B ^ j + a ^ i = n untuk mengatasi masalah limpahan Gunakan b = n - a bukan b + a = n; Kuasa kenaikan B oleh 1; Kuasa kenaikan A sebanyak 1; Akhirnya cetak - 1 jika tiada pasangan dijumpai; Kod pemacu; Diberikan A, B dan N; Panggilan fungsi", "code": "using System ; class GFG { static int power ( int A , int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) { count ++ ; N /= A ; } return count ; } static void Pairs ( int N , int A , int B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; int intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { Console . WriteLine ( i + \" ▁ \" + j ) ; return ; } B *= intialB ; } A *= intialA ; } Console . WriteLine ( \" - 1\" ) ; return ; } public static void Main ( String [ ] args ) { int N = 106 , A = 3 , B = 5 ; Pairs ( N , A , B ) ; } }"}
{"text": "Mengira nombor dari julat tertentu yang tidak dapat dibahagikan oleh mana -mana elemen array | C # Program untuk pendekatan di atas; Berfungsi untuk mencari gandaan bukan sehingga k; Menyimpan semua gandaan yang unik; Melelehkan array; Untuk mencari pendua sekali sahaja; Memasukkan semua gandaan ke dalam set; Kembali hanya kiraan nombor yang tidak dapat dibahagikan oleh mana -mana elemen array; Berfungsi untuk mengira jumlah nilai dalam julat [l, r]; Mengira semua nilai dalam julat menggunakan prinsip pengecualian; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { public static int findNonMultiples ( int [ ] arr , int n , int k ) { HashSet < int > multiples = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! multiples . Contains ( arr [ i ] ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . Add ( arr [ i ] * j ) ; } } } return k - multiples . Count ; } public static int countValues ( int [ ] arr , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int N = arr . Length ; int L = 1 ; int R = 20 ; Console . WriteLine ( countValues ( arr , N , L , R ) ) ; } }"}
{"text": "Bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir di paling banyak jam | | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir dalam jam H; Menyimpan syiling minimum untuk dikeluarkan setiap jam; Cari elemen array maksimum; Melakukan carian binari; Simpan nilai pertengahan julat dalam k; Cari jumlah masa yang diambil untuk mengosongkan n buasir dengan mengeluarkan sy syiling sejam; Jika jumlah masa tidak melebihi h; Jika tidak; Cetak hasil yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections ; class GFG { static void minCollectingSpeed ( int [ ] piles , int H ) { int ans = - 1 ; int low = 1 , high ; Array . Sort ( piles ) ; high = piles [ piles . Length - 1 ] ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; foreach ( int ai in piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } Console . Write ( ans ) ; } static public void Main ( string [ ] args ) { int [ ] arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; } }"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Susun array; Kedai indeks penunjuk kiri; Kedai indeks penunjuk yang betul; Hitung kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Jika jumlah pasangan semasa adalah sama dengan k; Keluarkan elemen array duplikat berturut -turut; Kemas kini i; Keluarkan elemen array duplikat berturut -turut; Kemas kini j; Kemas kini CNTPairs; Kemas kini i; Kemas kini j; Jika jumlah pasangan semasa kurang daripada k; Kemas kini i; Kemas kini j; Kod pemacu", "code": "using System ; class GFG { static int cntDisPairs ( int [ ] arr , int N , int K ) { int cntPairs = 0 ; Array . Sort ( arr ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . Length ; int K = 13 ; Console . WriteLine ( cntDisPairs ( arr , N , K ) ) ; } }"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Kekerapan kedai setiap elemen yang berbeza dari array; Kemas kini kekerapan ARR [i]; Melintasi peta; Menyimpan nilai utama peta; Jika saya adalah separuh daripada k; Jika kekerapan saya lebih besar daripada 1; Kemas kini CNTPairs; Kemas kini CNTPairs; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int cntDisPairs ( int [ ] arr , int N , int K ) { int cntPairs = 0 ; Dictionary < int , int > cntFre = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( cntFre . ContainsKey ( arr [ i ] ) ) cntFre [ arr [ i ] ] = cntFre [ arr [ i ] ] + 1 ; else cntFre . Add ( arr [ i ] , 1 ) ; } foreach ( KeyValuePair < int , int > it in cntFre ) { int i = it . Key ; if ( 2 * i == K ) { if ( cntFre [ i ] > 1 ) cntPairs += 2 ; } else { if ( cntFre . ContainsKey ( K - i ) ) { cntPairs += 1 ; } } } cntPairs = cntPairs / 2 ; return cntPairs ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . Length ; int K = 13 ; Console . Write ( cntDisPairs ( arr , N , K ) ) ; } }"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | C # Program untuk pendekatan di atas; Berfungsi untuk mencari panjang seterusnya yang paling lama supaya tidak ada dua elemen bersebelahan yang sama; Gantikan elemen pada indeks x dengan y; Oleh kerana x adalah 1 - diindeks, penurunan x oleh 1; Jejaki bilangan elemen dalam masa depan; Jika elemen sebelumnya tidak sama dengan elemen semasa; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void longestSubsequence ( int N , int Q , int [ ] arr , int [ , ] Queries ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i , 0 ] ; int y = Queries [ i , 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } Console . Write ( count + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . Length ; int Q = 2 ; int [ , ] Queries = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; } }"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | C # Program untuk pendekatan di atas; Melintasi array arr []; Jika elemen sebelumnya tidak sama dengan elemen semasa; Melintasi pertanyaan; Gantikan elemen pada indeks x dengan y; Mengira semula untuk Indeks X; Tolak sumbangan elemen pada indeks x; Tambah sumbangan y; Mengira semula untuk indeks x + 1; Tolak sumbangan elemen pada indeks x + 1; Menambah sumbangan y; Menggantikan elemen; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void longestSubsequence ( int N , int Q , int [ ] arr , int [ , ] Queries ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i , 0 ] ; int y = Queries [ i , 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } Console . Write ( count + \" ▁ \" ) ; arr [ x - 1 ] = y ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . Length ; int Q = 2 ; int [ , ] Queries = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; } }"}
{"text": "Jumlah perbezaan mutlak indeks kejadian setiap elemen array | C # Program untuk pendekatan di atas; Fungsi untuk mencari jumlah perbezaan indeks kejadian setiap elemen array yang unik; Menyimpan indeks setiap elemen array; Simpan indeks; Menyimpan jumlahnya; Melintasi array; Cari jumlah untuk setiap elemen; Melangkah ke atas peta; Hitung jumlah kejadian ARR [i]; Simpan jumlah untuk elemen semasa; Cetak jawapan untuk setiap elemen; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void sum ( int [ ] arr , int n ) { Dictionary < int , List < int > > mp = new Dictionary < int , List < int > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { List < int > v = new List < int > ( ) ; v . Add ( i ) ; if ( mp . ContainsKey ( arr [ i ] ) ) v . AddRange ( mp [ arr [ i ] ] ) ; mp [ arr [ i ] ] = v ; } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; foreach ( int it in mp [ arr [ i ] ] ) { sum += Math . Abs ( it - i ) ; } ans [ i ] = sum ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + \" ▁ \" ) ; } return ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 1 , 1 , 2 } ; int n = arr . Length ; sum ( arr , n ) ; } }"}
{"text": "Tukar vokal ke dalam watak kes atas dalam rentetan yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk menukar vokal menjadi huruf besar; Menyimpan panjang str; Kod pemacu", "code": "using System ; class GFG { static void conVowUpp ( char [ ] str ) { int N = str . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { char c = char . ToUpperInvariant ( str [ i ] ) ; str [ i ] = c ; } } foreach ( char c in str ) Console . Write ( c ) ; } public static void Main ( String [ ] args ) { String str = \" eutopia \" ; conVowUpp ( str . ToCharArray ( ) ) ; } }"}
{"text": "Memaksimumkan bilangan hari yang mana c coklat boleh diedarkan secara berturut -turut kepada orang -orang n | C # Program untuk melaksanakan pendekatan di atas; Menyimpan kekerapan setiap jenis coklat; Fungsi untuk memeriksa sama ada coklat boleh dimakan untuk 'pertengahan' tidak. hari; Jika CNT melebihi n, kembali benar; Berfungsi untuk mencari bilangan maksimum hari yang mana coklat boleh dimakan; Simpan kekerapan setiap jenis coklat; Memulakan permulaan dan berakhir dengan 0 dan P masing -masing; Hitung pertengahan; Semak jika coklat boleh diedarkan selama pertengahan hari; Semak jika coklat boleh diedarkan selama lebih dari pertengahan hari berturut -turut; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; static int N , P ; static bool helper ( int mid ) { int cnt = 0 ; foreach ( KeyValuePair < int , int > i in mp ) { int temp = i . Value ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; } static int findMaximumDays ( int [ ] arr ) { for ( int i = 0 ; i < P ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 && helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } public static void Main ( String [ ] args ) { N = 3 ; P = 10 ; int [ ] arr = { 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 } ; Console . Write ( findMaximumDays ( arr ) ) ; } }"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | C # Program untuk pendekatan di atas; Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan subarray; Kedai awalan jumlah array; Kirakan Array Jumlah Awalan; Menjana semua subarray; Semak sama ada subarray ini adalah subarray yang sah atau tidak; Jumlah kiraan subarray; Kod pemacu; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void countSubarrays ( int [ ] a , int n , int k ) { int ans = 0 ; List < int > pref = new List < int > ( ) ; pref . Add ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . Add ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } Console . WriteLine ( ans ) ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = arr . Length ; int K = 4 ; countSubarrays ( arr , N , K ) ; } }"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | C # Program untuk pendekatan di atas; Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan (pref [i] - i) % k; Menyimpan kiraan subarray; Kedai awalan jumlah array; Cari Array Jumlah Awalan; Keadaan asas; Keluarkan indeks pada masa ini selepas indeks k dari indeks semasa; Kemas kini jawapan untuk subarrays yang berakhir pada indeks i - th; Tambah nilai yang dikira indeks semasa untuk dikira; Cetak kiraan subarray; Kod pemacu; Diberikan [] arr; Saiz array; Diberikan k; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void countSubarrays ( int [ ] a , int n , int k ) { Dictionary < int , int > cnt = new Dictionary < int , int > ( ) ; long ans = 0 ; List < int > pref = new List < int > ( ) ; pref . Add ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . Add ( ( a [ i ] + pref [ i ] ) % k ) ; cnt . Add ( 0 , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { int remIdx = i - k ; if ( remIdx >= 0 ) { if ( cnt . ContainsKey ( ( pref [ remIdx ] - remIdx % k + k ) % k ) ) cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] = cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] - 1 ; else cnt . Add ( ( pref [ remIdx ] - remIdx % k + k ) % k , - 1 ) ; } if ( cnt . ContainsKey ( ( pref [ i ] - i % k + k ) % k ) ) ans += cnt [ ( pref [ i ] - i % k + k ) % k ] ; if ( cnt . ContainsKey ( ( pref [ i ] - i % k + k ) % k ) ) cnt [ ( pref [ i ] - i % k + k ) % k ] = cnt [ ( pref [ i ] - i % k + k ) % k ] + 1 ; else cnt . Add ( ( pref [ i ] - i % k + k ) % k , 1 ) ; } Console . WriteLine ( ans ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = arr . Length ; int K = 4 ; countSubarrays ( arr , N , K ) ; } }"}
{"text": "Semak jika semua substring panjang k dari rentetan binari mempunyai kiraan yang sama dengan 0 s dan 1 s | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada substring panjang k mempunyai sama 0 dan 1; Melintasi rentetan; Semak sama ada setiap watak k - th adalah sama atau tidak; Melintasi substring panjang k; Jika watak semasa adalah 0; Kiraan kenaikan; Jika tidak; Kiraan pengurangan; Semak sama 0 s dan 1 s; Kod pemacu", "code": "using System ; class GFG { static bool check ( String s , int k ) { int n = s . Length ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } public static void Main ( String [ ] args ) { String s = \"101010\" ; int k = 2 ; if ( check ( s , k ) ) Console . Write ( \" Yes \" + \" STRNEWLINE \" ) ; else Console . Write ( \" No \" + \" STRNEWLINE \" ) ; } }"}
{"text": "Semak jika watak -watak rentetan yang diberikan boleh digunakan untuk membentuk sebarang rentetan yang sama | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada freq dari mana -mana watak boleh dibahagikan dengan n; Menyimpan kekerapan aksara; Jika kekerapan watak tidak dapat dibahagikan dengan n; Jika tiada watak mempunyai kekerapan sekurang -kurangnya n; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static bool isSame ( String str , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( mp . ContainsKey ( str [ i ] - ' a ' ) ) { mp [ str [ i ] - ' a ' ] = mp [ str [ i ] - ' a ' ] + 1 ; } else { mp . Add ( str [ i ] - ' a ' , 1 ) ; } } foreach ( KeyValuePair < int , int > it in mp ) { if ( ( it . Value ) >= n ) { return true ; } } return false ; } public static void Main ( String [ ] args ) { String str = \" ccabcba \" ; int n = 4 ; if ( isSame ( str , n ) ) { Console . Write ( \" Yes \" ) ; } else { Console . Write ( \" No \" ) ; } } }"}
{"text": "Cari akar fungsi yang tidak berkurangan antara a dan b | C # Program untuk pendekatan di atas; Fungsi yang diberikan; Fungsi untuk mencari akar fungsi yang tidak berkurangan; Untuk mendapatkan jawapan minimum yang mungkin untuk akar; Cari pertengahan; Cari di [rendah, x]; Cari di [x, tinggi]; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencari akar persamaan yang diberikan dalam julat [a, b]; Jika akar tidak wujud; Lain mencari akar sehingga 4 tempat perpuluhan; Kod pemacu; Julat yang diberikan; Panggilan fungsi", "code": "using System ; class GFG { static readonly double eps = 1e-6 ; static double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } static double findRoot ( double a , double b , double c , double low , double high ) { double x = - 1 ; while ( Math . Abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } static void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { Console . WriteLine ( \" No ▁ solution \" ) ; } else { Console . Write ( \" { 0 : F4 } \" , findRoot ( a , b , c , A , B ) ) ; } } public static void Main ( String [ ] args ) { double a = 2 , b = - 3 , c = - 2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; } }"}
{"text": "Median perbezaan semua pasangan dari array | C # Program untuk melaksanakan pendekatan di atas; Pemeriksaan fungsi jika pertengahan boleh menjadi indeks median pelbagai perbezaan; Saiz array; Jumlah mungkin tidak ada pasangan yang mungkin; Indeks elemen dalam perbezaan semua pasangan dari array; Kira bilangan pasangan yang mempunyai perbezaan <= MID; Jika perbezaan antara akhir dan elemen pertama kurang atau sama dengan pertengahan; Memeriksa unsur tidak kurang daripada atau sama dengan pertengahan adalah lebih besar daripada median atau tidak; Fungsi untuk mengira median perbezaan semua pasangan dari array; Saiz array; Memulakan yang rendah dan tinggi; Carian binari; Hitung pertengahan; Jika pertengahan boleh menjadi median array; Mengembalikan median perbezaan pasangan dari array; Kod pemacu", "code": "using System ; class GFG { static bool possible ( long mid , int [ ] a ) { long n = a . Length ; long total = ( n * ( n - 1 ) ) / 2 ; long need = ( total + 1 ) / 2 ; long count = 0 ; long start = 0 , end = 1 ; while ( end < n ) { if ( a [ ( int ) end ] - a [ ( int ) start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ ( int ) end - 1 ] - a [ ( int ) start ] <= mid ) { long t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; } static long findMedian ( int [ ] a ) { long n = a . Length ; long low = 0 , high = a [ ( int ) n - 1 ] - a [ 0 ] ; while ( low <= high ) { long mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; } public static void Main ( string [ ] args ) { int [ ] a = { 1 , 7 , 5 , 2 } ; Array . Sort ( a ) ; Console . Write ( findMedian ( a ) ) ; } }"}
{"text": "Cetak semua rentetan dari array a [] mempunyai semua rentetan dari array b [] sebagai berikutnya | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari rentetan dari [] mempunyai semua rentetan dalam [] b sebagai seterusnya; Hitung saiz masing -masing; Menyimpan jawapannya; Menyimpan kekerapan setiap watak dalam rentetan [] a; Kirakan frekuensi watak semua rentetan; Menyimpan kekerapan setiap aksara dalam rentetan [] b setiap watak rentetan dalam [] b; Jika kekerapan watak dalam [] b melebihi itu dalam [] a; Rentetan wujud dalam [] b yang bukan subset yang betul dari [i]; Jika semua rentetan dalam [] b adalah subset yang betul [] a; Tolak rentetan dalam vektor yang dihasilkan; Jika ada rentetan yang dijumpai; Cetak rentetan itu; Jika tidak; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void UniversalSubset ( List < String > A , List < String > B ) { int n1 = A . Count ; int n2 = B . Count ; List < String > res = new List < String > ( ) ; int [ , ] A_fre = new int [ n1 , 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i , j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . Length ; j ++ ) { A_fre [ i , A [ i ] [ j ] - ' a ' ] ++ ; } } int [ ] B_fre = new int [ 26 ] ; for ( int i = 0 ; i < n2 ; i ++ ) { int [ ] arr = new int [ 26 ] ; for ( int j = 0 ; j < B [ i ] . Length ; j ++ ) { arr [ B [ i ] [ j ] - ' a ' ] ++ ; B_fre [ B [ i ] [ j ] - ' a ' ] = Math . Max ( B_fre [ B [ i ] [ j ] - ' a ' ] , arr [ B [ i ] [ j ] - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i , j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . Add ( A [ i ] ) ; } if ( res . Count != 0 ) { for ( int i = 0 ; i < res . Count ; i ++ ) { for ( int j = 0 ; j < res [ i ] . Length ; j ++ ) Console . Write ( res [ i ] [ j ] ) ; } Console . Write ( \" ▁ \" ) ; } else Console . Write ( \" - 1\" ) ; } public static void Main ( String [ ] args ) { List < String > A = new List < String > ( ) ; A . Add ( \" geeksforgeeks \" ) ; A . Add ( \" topcoder \" ) ; A . Add ( \" leetcode \" ) ; List < String > B = new List < String > ( ) ; B . Add ( \" geek \" ) ; B . Add ( \" ee \" ) ; UniversalSubset ( A , B ) ; } }"}
{"text": "Pasangan terdekat dalam array supaya satu nombor adalah pelbagai yang lain | C # Program untuk pendekatan di atas; Berfungsi untuk mencari pasangan jarak minimum di mana seseorang adalah pelbagai yang lain; Memulakan pembolehubah; Melangkah untuk semua elemen; Gelung untuk membuat pasangan; Semak jarak minimum; Semak jika seseorang adalah pelbagai yang lain; Mengemas kini jarak; Indeks kedai; Jika tidak ada pasangan seperti itu; Cetak jawapannya; Kod pemacu; Diberikan array [] arr; Panggilan fungsi", "code": "using System ; class GFG { public static void findPair ( int [ ] a , int n ) { int min_dist = int . MaxValue ; int index_a = - 1 , index_b = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == - 1 ) { Console . WriteLine ( \" - 1\" ) ; } else { Console . Write ( \" ( \" + a [ index_a ] + \" , ▁ \" + a [ index_b ] + \" ) \" ) ; } } public static void Main ( String [ ] args ) { int [ ] a = { 2 , 3 , 4 , 5 , 6 } ; int n = a . Length ; findPair ( a , n ) ; } }"}
{"text": "Cetak semua nombor dalam julat yang diberikan dengan digit dalam perintah yang semakin meningkat | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak semua nombor dalam julat [l, r] yang mempunyai digit dalam urutan yang semakin meningkat; Melangkah ke atas julat; Melangkah ke atas digit; Semak sama ada digit semasa adalah> = digit sebelumnya; Sekiranya digit berada dalam urutan menaik; Kod pemacu; Diberikan julat l dan r; Panggilan fungsi", "code": "using System ; class GFG { static void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) Console . Write ( i + \" ▁ \" ) ; } } public static void Main ( ) { int L = 10 , R = 15 ; printNum ( L , R ) ; } }"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | C # Program untuk pendekatan di atas; Fungsi untuk mencari elemen yang hilang; Betulkan sempadan kiri dan kanan untuk carian binari; Cari Indeks Elemen Tengah; Semak jika elemen hanya selepas elemen tengah hilang; Semak jika elemen sebelum pertengahan hilang; Semak jika unsur -unsur sehingga pertengahan mengikuti AP, kemudian berulang untuk separuh kanan; Lain berulang untuk separuh kiri; Berfungsi untuk mencari elemen yang hilang dalam siri AP; Susun array [] arr; Mengira perbezaan biasa; Pencarian binari untuk yang hilang; Kod pemacu; Diberikan array [] arr; Panggilan fungsi", "code": "using System ; class GFG { static int findMissing ( int [ ] arr , int left , int right , int diff ) { if ( right <= left ) return 0 ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; } static int missingElement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; } public static void Main ( String [ ] args ) { int [ ] arr = new int [ ] { 2 , 8 , 6 , 10 } ; int n = arr . Length ; Console . WriteLine ( missingElement ( arr , n ) ) ; } }"}
{"text": "Nilai lantai kth akar nombor menggunakan carian binari rekursif | C # Program untuk pendekatan di atas; Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn); Berfungsi untuk mencari akar kth nombor n menggunakan BS; Sekiranya julat masih sah; Cari nilai pertengahan julat; Kes asas; Keadaan untuk memeriksa sama ada ruang carian kiri tidak berguna; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "using System ; class GFG { static int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } static int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; } public static void Main ( ) { int N = 16 , K = 4 ; Console . Write ( nthRootSearch ( 0 , N , N , K ) ) ; } }"}
{"text": "Count subset yang mempunyai jumlah elemen min dan max kurang daripada k | C # Program untuk mencetak kiraan subset s seperti matematik. Min (s) + matematik. Max (s) <k; Fungsi yang mengembalikan kiraan subset sedemikian rupa sehingga matematik. Min (s) + matematik. Max (s) <k; Menyusun array; Ans menyimpan jumlah subset; Tambah semua subset yang mungkin antara I dan J; Mengurangkan jumlah; Kod pemacu", "code": "using System ; class GFG { static int get_subset_count ( int [ ] arr , int K , int N ) { Array . Sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = arr . Length ; Console . Write ( get_subset_count ( arr , K , N ) ) ; } }"}
{"text": "Kurangkan perbezaan maksimum unsur -unsur bersebelahan selepas kebanyakan sisipan k | C # Program untuk mencari minimum perbezaan maksimum antara unsur -unsur bersebelahan selepas kebanyakan penyisipan K; Kirakan perbezaan bersebelahan maksimum; Jika perbezaan bersebelahan maksimum sudah sifar; Terbaik dan terburuk menentukan pelbagai perbezaan bersebelahan maksimum; Untuk menyimpan tidak ada sisipan yang diperlukan untuk nilai masing -masing MID; Jika bilangan sisipan diperlukan melebihi k; Jika tidak; Kod pemacu", "code": "using System ; class GFG { static int minMaxDiff ( int [ ] arr , int n , int k ) { int max_adj_dif = int . MinValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . Max ( max_adj_dif , Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( Math . Abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 12 , 25 , 50 } ; int n = arr . Length ; int k = 7 ; Console . WriteLine ( minMaxDiff ( arr , n , k ) ) ; } }"}
{"text": "Semak jika elemen minimum dalam array kurang daripada atau sama dengan separuh daripada setiap elemen lain | C # Pelaksanaan untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Fungsi untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Memulakan pembolehubah untuk menyimpan terkecil terkecil dan kedua terkecil; Semak jika elemen semasa lebih kecil daripada yang terkecil, terkecil semasa akan menjadi unsur detik yang paling teruk dan semasa akan menjadi yang terkecil baru; Semak jika elemen semasa lebih kecil daripada saat yang paling kecil hanya mengemas kini yang terakhir; Kod pemacu", "code": "using System ; class GFG { static void checkMin ( int [ ] arr , int len ) { int smallest = int . MaxValue ; int secondSmallest = int . MaxValue ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 } ; int len = arr . Length ; checkMin ( arr , len ) ; } }"}
{"text": "Nombor fibonacci terbesar dan terkecil dalam array | C # Program untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Fungsi untuk membuat jadual hash untuk memeriksa nombor Fibonacci; Masukkan dua nombor awal dalam jadual hash; Jumlah dua nombor sebelumnya; Kemas kini pembolehubah setiap kali; Berfungsi untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Cari nilai maksimum dalam array; Mewujudkan satu set yang mengandungi semua nombor Fibonacci sehingga nilai maksimum dalam array; Untuk menyimpan nombor Fibonacci minimum dan maksimum; Semak jika elemen semasa adalah nombor Fibonacci; Mengemas kini maksimum dan minimum yang sewajarnya; Kod pemacu", "code": "using System ; using System . Linq ; using System . Collections . Generic ; class GFG { static void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } } static void fibonacci ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; HashSet < int > hash = new HashSet < int > ( ) ; createHash ( hash , max_val ) ; int minimum = int . MaxValue ; int maximum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . Contains ( arr [ i ] ) ) { minimum = Math . Min ( minimum , arr [ i ] ) ; maximum = Math . Max ( maximum , arr [ i ] ) ; } } Console . Write ( minimum + \" , ▁ \" + maximum + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . Length ; fibonacci ( arr , n ) ; } }"}
{"text": "Substring terpanjang dengan K aksara unik menggunakan carian binari | C # pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika terdapat substring panjang len dengan <= k aksara unik; Saiz rentetan; Peta untuk menyimpan watak dan kekerapannya; Kemas kini peta untuk substring pertama; Periksa selebihnya substrings; Tambah watak baru; Keluarkan watak pertama tetingkap sebelumnya; Kemas kini peta; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai aksara unik K; Semak sama ada rentetan lengkap mengandungi aksara unik K; Saiz rentetan; Memohon carian binari; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool isValidLen ( String s , int len , int k ) { int n = s . Length ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; int right = 0 ; while ( right < len ) { if ( mp . ContainsKey ( s [ right ] ) ) { mp [ s [ right ] ] = mp [ s [ right ] ] + 1 ; } else { mp . Add ( s [ right ] , 1 ) ; } right ++ ; } if ( mp . Count <= k ) return true ; while ( right < n ) { if ( mp . ContainsKey ( s [ right ] ) ) { mp [ s [ right ] ] = mp [ s [ right ] ] + 1 ; } else { mp . Add ( s [ right ] , 1 ) ; } if ( mp . ContainsKey ( s [ right - len ] ) ) { mp [ s [ right - len ] ] = mp [ s [ right - len ] ] - 1 ; } if ( mp [ s [ right - len ] ] == 0 ) mp . Remove ( s [ right - len ] ) ; if ( mp . Count <= k ) return true ; right ++ ; } return mp . Count <= k ; } static int maxLenSubStr ( String s , int k ) { HashSet < char > uni = new HashSet < char > ( ) ; foreach ( char x in s . ToCharArray ( ) ) uni . Add ( x ) ; if ( uni . Count < k ) return - 1 ; int n = s . Length ; int lo = - 1 , hi = n + 1 ; while ( hi - lo > 1 ) { int mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; } public static void Main ( String [ ] args ) { String s = \" aabacbebebe \" ; int k = 3 ; Console . Write ( maxLenSubStr ( s , k ) ) ; } }"}
{"text": "Dataran Kawasan Terbesar di Array Apabila Elemen Boleh Dipandu | C # pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk membuat persegi dengan sisi sama dengan L; Untuk menyimpan kiraan elemen yang lebih besar daripada atau sama dengan L; Kenaikan kiraan; Jika kiraan menjadi lebih besar daripada atau sama dengan L; Berfungsi untuk mengembalikan kawasan maksimum dataran yang boleh diperolehi; Jika persegi mungkin dengan panjang sisi m; Cuba cari persegi dengan panjang sampingan yang lebih kecil; Mengembalikan kawasan itu; Kod pemacu", "code": "using System ; class GFG { static bool isSquarePossible ( int [ ] arr , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; } static int maxArea ( int [ ] arr , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 4 , 5 , 5 } ; int n = arr . Length ; Console . WriteLine ( maxArea ( arr , n ) ) ; } }"}
{"text": "Semak pendua dalam aliran rentetan | C # pelaksanaan pendekatan; Fungsi untuk memasukkan nama dan periksa sama ada ia muncul untuk kali pertama; Untuk menyimpan nama pekerja; Jika nama semasa muncul untuk kali pertama; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void insertNames ( String [ ] arr , int n ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . Contains ( arr [ i ] ) ) { Console . Write ( \" No STRNEWLINE \" ) ; set . Add ( arr [ i ] ) ; } else { Console . Write ( \" Yes STRNEWLINE \" ) ; } } } public static void Main ( String [ ] args ) { String [ ] arr = { \" geeks \" , \" for \" , \" geeks \" } ; int n = arr . Length ; insertNames ( arr , n ) ; } }"}
{"text": "Kira tiga kali ganda supaya A [i] <b [j] <c [k] | C # pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang kurang daripada kunci yang diberikan; Carian binari yang diubah suai; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang lebih besar daripada kunci yang diberikan; Carian binari yang diubah suai; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang diperlukan; Menyusun ketiga -tiga tatasusunan; Melangkah untuk semua elemen array b; Kiraan elemen dalam [] yang kurang daripada elemen yang dipilih dari B []; Kiraan unsur -unsur dalam C [] yang lebih besar daripada elemen yang dipilih dari B []; Mengemas kini kiraan; Kod pemacu", "code": "using System ; class GFG { static int countLessThan ( int [ ] arr , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } static int countGreaterThan ( int [ ] arr , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; } static int countTriplets ( int n , int [ ] a , int [ ] b , int [ ] c ) { Array . Sort ( a ) ; Array . Sort ( b ) ; Array . Sort ( c ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } public static void Main ( ) { int [ ] a = { 1 , 5 } ; int [ ] b = { 2 , 4 } ; int [ ] c = { 3 , 6 } ; int size = a . Length ; Console . WriteLine ( countTriplets ( size , a , b , c ) ) ; } }"}
{"text": "Kos untuk mengimbangi kurungan | C # kod untuk mengira kos minimum untuk membuat tanda kurung yang diberikan seimbang; Untuk menyimpan kiraan mutlak kurungan yang seimbang dan tidak seimbang; o (pendakap terbuka) menyimpan kiraan '(' dan c (pendakap dekat) kiraan ')'; Kod pemacu", "code": "using System ; class GFG { static int costToBalance ( string s ) { if ( s . Length == 0 ) Console . WriteLine ( 0 ) ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' ( ' ) o ++ ; if ( s [ i ] == ' ) ' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . Length ] ; if ( s [ 0 ] == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . Abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . Abs ( a [ i ] ) ; } return ans ; } static void Main ( ) { string s ; s = \" ) ) ) ( ( ( \" ; Console . WriteLine ( costToBalance ( s ) ) ; s = \" ) ) ( ( \" ; Console . WriteLine ( costToBalance ( s ) ) ; } }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | C # Program untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; x adalah positif jika a lebih besar daripada b. x adalah negatif jika b lebih besar daripada a. ; Sama seperti x; Sama seperti x dan y. ; Memeriksa jika B adalah tengah (X dan Y kedua -duanya adalah positif); Memeriksa jika C adalah tengah (x dan z kedua -duanya positif); Kod pemacu", "code": "using System ; class Middle { public static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } public static void Main ( ) { int a = 20 , b = 30 , c = 40 ; Console . WriteLine ( middleOfThree ( a , b , c ) ) ; } }"}
{"text": "Cari empat nombor yang hilang dalam array yang mengandungi elemen dari 1 hingga n | C # Program untuk mencari 4 elemen yang hilang dalam pelbagai saiz n di mana unsur -unsur berada dalam jarak dari 1 hingga n + 4 .; Menemukan 4 nombor dalam O (n) masa dan O (1) ruang tambahan. ; Untuk menjejaki 4 nombor yang mungkin lebih besar daripada panjang input di Java, penolong secara automatik diasaskan sebagai 0 .; Melintasi array input dan menandakan unsur -unsur yang dilawati sama ada dengan menandakan mereka sebagai negatif dalam arr [] atau dalam pembantu []. ; Jika elemen lebih kecil daripada atau sama dengan panjang, tandakan kehadirannya di arr []; Mark kehadiran dalam pembantu []; Cetak semua elemen yang kehadirannya tidak ditandakan. ; Kod pemacu", "code": "using System ; class Missing4 { public static void missing4 ( int [ ] arr ) { int [ ] helper = new int [ 4 ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int temp = Math . Abs ( arr [ i ] ) ; if ( temp <= arr . Length ) arr [ temp - 1 ] *= ( - 1 ) ; else if ( temp > arr . Length ) { if ( temp % arr . Length != 0 ) helper [ temp % arr . Length - 1 ] = - 1 ; else helper [ ( temp % arr . Length ) + arr . Length - 1 ] = - 1 ; } } for ( int i = 0 ; i < arr . Length ; i ++ ) if ( arr [ i ] > 0 ) Console . Write ( i + 1 + \" ▁ \" ) ; for ( int i = 0 ; i < helper . Length ; i ++ ) if ( helper [ i ] >= 0 ) Console . Write ( arr . Length + i + 1 + \" ▁ \" ) ; return ; } public static void Main ( ) { int [ ] arr = { 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 } ; missing4 ( arr ) ; } }"}
{"text": "Permutasi yang hadir di tengah -tengah pesanan leksikografi permutasi paling panjang n yang terdiri daripada bilangan bulat sehingga k | C # Program untuk pendekatan di atas; Fungsi yang menemui tengah -tengah urutan terkecil leksikografi; Jika k ada; Elemen pertama ialah K / 2; Unsur -unsur yang tersisa dari urutan adalah semua integer k; Menyimpan urutan apabila k adalah ganjil; Melangkah ke atas julat [0, n / 2]; Semak sama ada urutan berakhir dengan 1 atau tidak; Keluarkan urutan yang berakhir dalam 1; Sekiranya ia tidak berakhir dalam 1; Penurunan sebanyak 1; Masukkan k ke urutan sehingga saiznya adalah n; Cetak urutan yang disimpan dalam vektor; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { Console . Write ( K / 2 + \" ▁ \" ) ; for ( int i = 0 ; i < N - 1 ; ++ i ) { Console . Write ( K + \" ▁ \" ) ; } Console . WriteLine ( ) ; return ; } List < int > a = new List < int > ( ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a [ a . Count - 1 ] == 1 ) { a . Remove ( a . Count - 1 ) ; } else { a [ a . Count - 1 ] -= 1 ; while ( ( int ) a . Count < N ) { a . Add ( K ) ; } } } foreach ( int i in a ) { Console . Write ( i + \" ▁ \" ) ; } Console . WriteLine ( ) ; } public static void Main ( ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; } }"}
{"text": "Elemen array yang tinggal selepas penyingkiran elemen terkecil dari pasangan dengan perbezaan mutlak 2 atau 0 | C # Program untuk pendekatan di atas; Berfungsi untuk mencari elemen array yang terakhir selepas berulang kali mengeluarkan terkecil dari pasangan yang mempunyai perbezaan mutlak 2 atau 0; Susun array yang diberikan dalam urutan menaik; Melintasi array; Jika perbezaan antara unsur -unsur bersebelahan tidak sama dengan 0 atau 2; Jika operasi boleh dilakukan; Kod pemacu", "code": "using System ; public class GFG { static void findLastElement ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { Console . WriteLine ( \" - 1\" ) ; return ; } } Console . WriteLine ( arr [ N - 1 ] ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = arr . Length ; findLastElement ( arr , N ) ; } }"}
{"text": "Memaksimumkan kiraan subset ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira subset maksimum ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan; Susun array dalam penurunan urutan; Kedai -kedai Count Subset mungkin; Kedai mengira unsur -unsur dalam subset semasa; Melintasi array arr []; Saiz kemas kini; Jika produk elemen terkecil yang terdapat dalam subset semasa dan saiz subset semasa ialah> = k; Kemas kini MaxSub; Saiz kemas kini; Kod pemacu; Diberikan array; Saiz array; Diberi nilai x", "code": "using System ; class GFG { static void maxDivisions ( int [ ] arr , int N , int X ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } Console . WriteLine ( maxSub ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 3 , 7 } ; int N = arr . Length ; int X = 3 ; maxDivisions ( arr , N , X ) ; } }"}
{"text": "Memaksimumkan jumlah minimum kedua dalam semua empat kali ganda dari array yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari jumlah maksimum minimum minimum kedua dalam setiap empat kali ganda; Susun array; Tambah minimum kedua; Cetak jumlah maksimum yang mungkin; Kod pemacu; Diberikan array; Saiz array", "code": "using System ; public class GFG { public static void maxPossibleSum ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } Console . WriteLine ( sum ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ; int N = arr . Length ; maxPossibleSum ( arr , N ) ; } }"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | C # Program untuk pendekatan di atas; Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci kepada satu kedudukan di hadapan kedudukan semasa mereka; Berfungsi untuk mencetak pelbagai saiz n; Cetak array; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void insertionSort ( int [ ] arr , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } static void printArray ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } Console . WriteLine ( ) ; } static public void Main ( ) { int [ ] arr = new int [ ] { 12 , 11 , 13 , 5 , 6 } ; int N = arr . Length ; insertionSort ( arr , N ) ; printArray ( arr , N ) ; } }"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | C # Program untuk pendekatan di atas; Fungsi untuk mencari kiraan pasangan yang diperlukan; Kedai kiraan pasangan; Melintasi array; Periksa sama ada keadaan itu berpuas hati atau tidak; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void getPairs ( int [ ] arr , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } Console . Write ( count ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 2 , 1 } ; int N = arr . Length ; int K = 2 ; getPairs ( arr , N , K ) ; } }"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | C # Program untuk pendekatan di atas; Berfungsi untuk menggabungkan dua susunan yang disusun; i: indeks ke subarray kiri; J: Indeks ke Subarray Kanan; Kedai kiraan pasangan yang memenuhi syarat yang diberikan; Melintasi untuk memeriksa keadaan yang sah; Jika keadaan memenuhi; Semua elemen di sebelah kanan subarray kiri juga memuaskan; Susun dua tatasusunan yang diberikan dan simpan dalam array yang dihasilkan; Unsur -unsur yang tersisa di subarray kiri; Unsur -unsur yang tersisa di subarray kanan; Mengembalikan kiraan yang diperoleh; Berfungsi untuk memisahkan array menjadi dua bahagian; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Hubungi fungsi penggabungan; Berfungsi untuk mencetak kiraan pasangan yang diperlukan menggunakan jenis gabungan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int merge ( int [ ] arr , int [ ] temp , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { bool found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } static int mergeSortUtil ( int [ ] arr , int [ ] temp , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } static void mergeSort ( int [ ] arr , int N , int K ) { int [ ] temp = new int [ N ] ; Console . WriteLine ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; } static public void Main ( ) { int [ ] arr = new int [ ] { 5 , 6 , 2 , 5 } ; int N = arr . Length ; int K = 2 ; mergeSort ( arr , N , K ) ; } }"}
{"text": "Kurangkan penyingkiran berturut -turut unsur -unsur jenis yang sama untuk kosong yang diberikan | C # pelaksanaan pendekatan di atas; Fungsi untuk mengira penyingkiran minimum berturut -turut unsur -unsur jenis yang sama; Susun array; Menyimpan elemen maksimum yang terdapat dalam array; Kedai jumlah array; Hitung jumlah array; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void minRemovals ( int [ ] A , int N ) { Array . Sort ( A ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { Console . WriteLine ( 0 ) ; } else { Console . WriteLine ( 2 * mx - sum ) ; } } public static void Main ( String [ ] args ) { int [ ] A = { 3 , 3 , 2 } ; int N = A . Length ; minRemovals ( A , N ) ; } }"}
{"text": "Menyusun semula array yang diberikan supaya tiada elemen array yang sama dengan indeksnya | C # Program untuk pendekatan di atas; Berfungsi untuk menyusun semula array [] sedemikian rupa sehingga tidak ada unsur array yang sama dengan indeksnya; Susun array; Melintasi indeks [0, n - 2] dari array yang diberikan; Periksa sama ada elemen semasa adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen seterusnya; Semak jika elemen terakhir adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen sebelumnya; Cetak array yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "using System ; public class GFG { static void rearrangeArray ( int [ ] a , int n ) { Array . Sort ( a ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } } if ( a [ n - 1 ] == n ) { int temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 3 , 2 , 4 } ; int N = arr . Length ; rearrangeArray ( arr , N ) ; } }"}
{"text": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | C # Program untuk pendekatan di atas; Fungsi yang mengira langkah minimum yang diperlukan untuk rahsia ARR [] kepada BRR []; Kes asas; Jika arr [i] <arr [j]; Termasuk elemen semasa; Jika tidak, tidak termasuk elemen semasa; Fungsi yang mengira langkah minimum yang diperlukan untuk menyusun array; Jika kedua -dua tatasusunan adalah sama; Tiada langkah yang diperlukan; Jika tidak; Mencetak operasi minimum yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int minOperations ( int [ ] arr1 , int [ ] arr2 , int i , int j ) { if ( arr1 . Equals ( arr2 ) ) return 0 ; if ( i >= arr1 . Length j >= arr2 . Length ) return 0 ; if ( arr1 [ i ] < arr2 [ j ] ) return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 ) ; return Math . Max ( minOperations ( arr1 , arr2 , i , j + 1 ) , minOperations ( arr1 , arr2 , i + 1 , j ) ) ; } static void minOperationsUtil ( int [ ] arr ) { int [ ] brr = new int [ arr . Length ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) brr [ i ] = arr [ i ] ; Array . Sort ( brr ) ; if ( arr . Equals ( brr ) ) Console . Write ( \"0\" ) ; else Console . WriteLine ( minOperations ( arr , brr , 0 , 0 ) ) ; } static void Main ( ) { int [ ] arr = { 4 , 7 , 2 , 3 , 9 } ; minOperationsUtil ( arr ) ; } }"}
{"text": "Semak jika rentetan boleh diubah kepada yang lain dengan menyusun substrings | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada Str1 boleh diubah menjadi T dengan menyusun substrings; Berlaku [i] menyimpan indeks char ('a' + i) dalam rentetan s; Idx [i] menyimpan indeks char yang tersedia seterusnya ('a' + i) berlaku [i]; Sekiranya char ini tidak tersedia lagi; Penukaran tidak mungkin; Jika salah satu watak yang lebih kecil tersedia dan berlaku sebelum ini; Penukaran tidak mungkin; Cetak jawapannya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void canTransform ( String s , String t ) { int n = s . Length ; List < int > [ ] occur = new List < int > [ 26 ] ; for ( int i = 0 ; i < occur . Length ; i ++ ) occur [ i ] = new List < int > ( ) ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( s [ x ] - ' a ' ) ; occur [ ch ] . Add ( x ) ; } int [ ] idx = new int [ 26 ] ; bool poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( t [ x ] - ' a ' ) ; if ( idx [ ch ] >= occur [ ch ] . Count ) { poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . Count && occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { Console . Write ( \" Yes \" + \" STRNEWLINE \" ) ; } else { Console . Write ( \" No \" + \" STRNEWLINE \" ) ; } } public static void Main ( String [ ] args ) { String s , t ; s = \" hdecb \" ; t = \" cdheb \" ; canTransform ( s , t ) ; } }"}
{"text": "Semak sama ada dua rentetan boleh dibuat sama dengan membalikkan substring panjang yang sama dari kedua -dua rentetan | C # Program untuk pendekatan di atas; Fungsi untuk mengira kiraan penyongsangan rentetan; Untuk menyimpan kekerapan; Tambah semua watak yang kurang daripada watak ITH sebelum saya. ; Menambah kiraan kepada kiraan penyongsangan; Mengemas kini watak dalam pelbagai frekuensi; Berfungsi untuk memeriksa sama ada mana -mana rentetan mempunyai watak berulang; Fungsi untuk memeriksa sama ada String S1 dan S2 boleh dibuat sama dengan membalikkan sub rentetan saiz yang sama dalam kedua -dua rentetan; Arahan kekerapan untuk memeriksa sama ada kedua -dua rentetan mempunyai watak yang sama atau tidak; Menambah kekerapan; ; Jika watak tidak berada di S1; Menurunkan kekerapan; Jika kedua -dua rentetan tidak mempunyai aksara yang sama atau tidak; Mencari kiraan penyongsangan kedua -dua rentetan; Jika kiraan penyongsangan adalah sama, atau mempunyai pariti yang sama atau jika mana -mana rentetan mempunyai watak berulang maka jawapannya ya tidak lagi; Kod pemacu", "code": "using System ; class GFG { static int inversionCount ( String s ) { int [ ] freq = new int [ 26 ] ; int inv = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < ( int ) ( s [ i ] - ' a ' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - ' a ' ] ++ ; } return inv ; } static bool haveRepeated ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; foreach ( char i in S1 . ToCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; foreach ( char i in S2 . ToCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } return false ; } static void checkToMakeEqual ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < S1 . Length ; i ++ ) { freq [ S1 [ i ] - ' a ' ] ++ ; } bool flag = false ; for ( int i = 0 ; i < S2 . Length ; i ++ ) { if ( freq [ S2 [ i ] - ' a ' ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - ' a ' ] -- ; } if ( flag == true ) { Console . WriteLine ( \" No \" ) ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { Console . WriteLine ( \" Yes \" ) ; } else Console . WriteLine ( \" No \" ) ; } public static void Main ( String [ ] args ) { String S1 = \" abbca \" , S2 = \" acabb \" ; checkToMakeEqual ( S1 , S2 ) ; } }"}
{"text": "Susun Arahan Bitonic | C # Program untuk pendekatan di atas; Berfungsi untuk menyusun array bitonic dalam ruang malar; Memulakan nilai k; Dalam setiap lelaran Bandingkan Elemen K jarak jauh dan bertukar jika mereka tidak teratur; K dikurangkan kepada separuh selepas setiap lelaran; Cetak elemen array; Kod pemacu; Diberikan array [] arr; Panggilan fungsi", "code": "using System ; class GFG { static void sortArr ( int [ ] a , int n ) { int i , k ; k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; k = ( int ) Math . Pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { int tmp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = tmp ; } k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { Console . Write ( a [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = arr . Length ; sortArr ( arr , n ) ; } }"}
{"text": "Split array ke dalam sub subset untuk memaksimumkan jumlah maksimum dan minimum mereka | C # Program untuk melaksanakan pendekatan di atas; Fungsi yang mencetak jumlah maksimum yang mungkin; Cari elemen dalam setiap kumpulan; Menyusun semua elemen dalam perintah bukan menurun; Tambah un elemen terbesar; Untuk jumlah elemen minimum dari setiap subset; Mencetak jumlah maksimum; Kod pemacu", "code": "using System ; class GFG { static void maximumSum ( int [ ] arr , int n , int k ) { int elt = n / k ; int sum = 0 ; Array . Sort ( arr ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } Console . WriteLine ( sum ) ; } public static void Main ( String [ ] args ) { int [ ] Arr = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = Arr . Length ; maximumSum ( Arr , size , K ) ; } }"}
{"text": "Kurangkan jumlah unsur -unsur terkecil dari k -lekukan panjang l | C # Program untuk mencari jumlah minimum yang mungkin dari unsur -unsur terkecil dari kaum K; Berfungsi untuk mencari jumlah minimum; Susun array; Hitung jumlah elemen k terkecil; Mengembalikan jumlahnya; Kod pemacu", "code": "using System ; class GFG { static int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } public static void Main ( ) { int [ ] arr = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = arr . Length ; Console . Write ( findMinSum ( arr , K , L , length ) ) ; } }"}
{"text": "KTH elemen terkecil atau terbesar dalam array yang tidak disusun | Tetapkan 4 | C # Program untuk pendekatan di atas; Berfungsi untuk mencari elemen terkecil kth dalam array yang tidak disusun; Memulakan elemen max sebagai 0; ITERATE [] arr dan cari elemen maksimum di dalamnya; Arahan kekerapan untuk menyimpan frekuensi; Pemboleh ubah kaunter; Mengira frekuensi; Melangkah melalui [] freq; Semak sama ada NUM terdapat dalam array; Meningkatkan kaunter dengan kekerapan NUM; Memeriksa jika kita telah mencapai elemen terkecil KTH; Mengembalikan elemen terkecil kth; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int findKthSmallest ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int [ ] counter = new int [ max + 1 ] ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; } public static void Main ( String [ ] args ) { int [ ] arr = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = arr . Length ; int K = 5 ; Console . Write ( findKthSmallest ( arr , N , K ) ) ; } }"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak semua nombor sehingga n dalam urutan leksikografi; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void lexNumbers ( int n ) { List < String > s = new List < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . Add ( String . Join ( \" \" , i ) ) ; } s . Sort ( ) ; List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . Add ( Int32 . Parse ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ans [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }"}
{"text": "Susun Matriks dalam Perintah Menaik dan Menurun Rowwise | C # pelaksanaan untuk mencetak baris matriks dalam urutan menaik atau menurun secara alternatif; Matriks iterate rowwise; Menyusun baris dalam urutan menaik; Bandingkan unsur -unsur bersebelahan; Swap elemen bersebelahan; Menyusun baris dalam urutan menurun; Bandingkan unsur -unsur bersebelahan; Swap elemen bersebelahan; Mencetak output readonly; Kod pemacu", "code": "using System ; class GFG { static int N = 4 ; static void func ( int [ , ] a ) { int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i , j ] > a [ i , k ] ) { int temp = a [ i , j ] ; a [ i , j ] = a [ i , k ] ; a [ i , k ] = temp ; } } } } else { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i , j ] < a [ i , k ] ) { int temp = a [ i , j ] ; a [ i , j ] = a [ i , k ] ; a [ i , k ] = temp ; } } } } } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { Console . Write ( a [ i , j ] + \" ▁ \" ) ; } Console . Write ( \" STRNEWLINE \" ) ; } } public static void Main ( String [ ] args ) { int [ , ] a = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; } }"}
{"text": "Cari berat MST dalam graf lengkap dengan Edge | C # Program untuk mencari berat pokok yang merangkumi minimum dalam graf lengkap di mana tepi mempunyai berat badan sama ada 0 atau 1; Untuk menyimpan tepi graf yang diberikan; Fungsi utiliti untuk melaksanakan traversal DFS; Semak simpang yang disimpan dalam set; Vertices dimasukkan jika berat kelebihan adalah 0; Fungsi utiliti untuk mencari berat pokok minimum; Untuk mengira komponen yang disambungkan; Memasukkan simpul awal dalam set; Melintasi simpang yang disimpan dalam set dan menjalankan traversal DFS untuk setiap simpang; Meningkatkan komponen bersambung berat sifar; DFS traversal untuk setiap vertex mengeluarkan; Kod pemandu; Masukkan tepi; Fungsi Panggilan Cari berat pokok minimum", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static Dictionary < int , int > [ ] g = new Dictionary < int , int > [ 200005 ] ; static HashSet < int > s = new HashSet < int > ( ) ; static HashSet < int > ns = new HashSet < int > ( ) ; static void dfs ( int x ) { ArrayList v = new ArrayList ( ) ; ns . Clear ( ) ; foreach ( int it in s ) { if ( g [ x ] . ContainsKey ( it ) ) { v . Add ( it ) ; } else { ns . Add ( it ) ; } } s = ns ; foreach ( int i in v ) { dfs ( i ) ; } } static void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . Add ( i ) ; } ArrayList qt = new ArrayList ( ) ; foreach ( int t in s ) qt . Add ( t ) ; while ( qt . Count != 0 ) { ++ cnt ; int t = ( int ) qt [ 0 ] ; qt . RemoveAt ( 0 ) ; dfs ( t ) ; } Console . Write ( cnt - 4 ) ; } public static void Main ( string [ ] args ) { int N = 6 , M = 11 ; int [ , ] edges = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < 11 ; i ++ ) g [ i ] = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i , 0 ] ; int v = edges [ i , 1 ] ; g [ u ] [ v ] = 1 ; g [ v ] [ u ] = 1 ; } weightOfMST ( N ) ; } }"}
{"text": "Kira pasangan yang mungkin berbeza supaya elemen dari A lebih besar daripada elemen dari b | C # Program untuk mengira bilangan pasangan yang berbeza yang mungkin dari kedua -dua tatasusunan supaya elemen yang dipilih dari satu array sentiasa lebih besar daripada yang dipilih dari array yang lain; Berfungsi untuk mengembalikan kiraan pasangan; Kod pemacu", "code": "using System ; class GFG { static int countPairs ( int [ ] A , int [ ] B ) { int n = A . Length ; int ans = 0 ; Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } public static void Main ( ) { int [ ] A = { 30 , 28 , 45 , 22 } ; int [ ] B = { 35 , 25 , 22 , 48 } ; Console . Write ( countPairs ( A , B ) ) ; } }"}
{"text": "Sisa maksimum mungkin apabila elemen dibahagikan dengan elemen lain dalam array | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai mod maksimum untuk mana -mana pasangan dari array; Cari elemen maksimum kedua dari array; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int max_element ( int [ ] arr , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; } static int maxMod ( int [ ] arr , int n ) { int maxVal = max_element ( arr , n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = arr . Length ; Console . WriteLine ( maxMod ( arr , n ) ) ; } }"}
{"text": "Pilih x elemen dari elemen [] dan y dari b [] yang memenuhi syarat yang diberikan | C # pelaksanaan pendekatan di atas; Berfungsi untuk pulangan yang benar jika mungkin untuk memilih unsur -unsur; Jika unsur -unsur tidak dapat dipilih; Menyusun kedua -dua tatasusunan; Jika elemen terkecil x [] adalah lebih kecil daripada elemen terbesar Yth B []; Kod pemacu", "code": "using System ; class GFG { static bool isPossible ( int [ ] A , int [ ] B , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Array . Sort ( A ) ; Array . Sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } public static void Main ( String [ ] args ) { int [ ] A = { 1 , 1 , 1 , 1 , 1 } ; int [ ] B = { 2 , 2 } ; int n = A . Length ; int m = B . Length ; ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Cari perubahan minimum yang diperlukan dalam array untuk mengandungi elemen K yang berbeza | C # Program kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Fungsi kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Simpan kekerapan setiap elemen; Simpan kekerapan elemen; Jenis frekuensi dalam urutan menurun; Untuk menyimpan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100005 ; static int Min_Replace ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int [ ] freq = new int [ MAX ] ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Array . Sort ( freq ) ; Array . Reverse ( freq ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( Min_Replace ( arr , n , k ) ) ; } }"}
{"text": "Bilangan maksimum elemen tanpa bertindih dalam garis | C # Program untuk mencari bilangan elemen maksimum tanpa bertindih dalam baris; Berfungsi untuk mencari bilangan elemen maksimum tanpa bertindih dalam garis; Jika n = 1, maka jawapannya adalah satu; Kami sentiasa boleh membuat elemen 1 st untuk menutup segmen kiri dan nth segmen yang betul; Jika segmen kiri untuk elemen ith tidak bertindih dengan elemen i - 1 maka kemudian kiri; lain cuba ke arah yang betul jika boleh; Kemas kini x [i] ke titik akhir kanan segmen yang diliputi olehnya; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int Segment ( int [ ] x , int [ ] l , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] x = { 1 , 3 , 4 , 5 , 8 } ; int [ ] l = { 10 , 1 , 2 , 2 , 5 } ; int n = x . Length ; Console . WriteLine ( Segment ( x , l , n ) ) ; } }"}
{"text": "Padam ganjil dan bahkan nombor pada langkah alternatif supaya jumlah elemen yang tinggal diminimumkan | C # pelaksanaan pendekatan; Berfungsi untuk mencari jumlah yang diminimumkan; Jika lebih banyak elemen ganjil; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika lebih banyak elemen; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika elemen yang sama; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int MinimizeleftOverSum ( int [ ] a , int n ) { List < int > v1 = new List < int > ( ) , v2 = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . Add ( a [ i ] ) ; else v2 . Add ( a [ i ] ) ; } if ( v1 . Count > v2 . Count ) { v1 . Sort ( ) ; v2 . Sort ( ) ; int x = v1 . Count - v2 . Count - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . Count > v1 . Count ) { v1 . Sort ( ) ; v2 . Sort ( ) ; int x = v2 . Count - v1 . Count - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; } public static void Main ( String [ ] args ) { int [ ] a = { 2 , 2 , 2 , 2 } ; int n = a . Length ; Console . WriteLine ( MinimizeleftOverSum ( a , n ) ) ; } }"}
{"text": "Operasi minimum untuk membuat kekerapan semua aksara sama k | C # Program untuk menukar rentetan yang diberikan; Berfungsi untuk mencari bilangan minimum operasi untuk menukar rentetan yang diberikan; Semak jika n boleh dibahagikan dengan k; Array untuk menyimpan kekerapan aksara dalam rentetan yang diberikan; Dua tatasusunan dengan bilangan operasi yang diperlukan; Memeriksa semua kemungkinan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void minOperation ( string S , int N , int K ) { if ( N % K != 0 ) { Console . WriteLine ( \" Not ▁ Possible \" ) ; } else { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ ( S [ i ] - 97 ) ] ++ ; } int E = N / K ; List < int > greaterE = new List < int > ( ) ; List < int > lessE = new List < int > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . Add ( E - count [ i ] ) ; else greaterE . Add ( count [ i ] - E ) ; } greaterE . Sort ( ) ; lessE . Sort ( ) ; int mi = Int32 . MaxValue ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . Count >= set1 && lessE . Count >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = Math . Min ( mi , Math . Max ( step1 , step2 ) ) ; } } Console . WriteLine ( mi ) ; } } public static void Main ( ) { string S = \" accb \" ; int N = S . Length ; int K = 2 ; minOperation ( S , N , K ) ; } }"}
{"text": "Operasi Peningkatan Julat Minimum Untuk Mengasingkan Array | C # Program untuk mencari kenaikan julat minimum untuk menyusun array; Berfungsi untuk mencari kenaikan julat minimum untuk menyusun array; Jika elemen semasa didapati lebih besar daripada kenaikan elemen terakhir semua istilah dalam julat i + 1 hingga n - 1; mn = arr [i]; Minimum dalam julat I hingga n - 1; Kod pemacu", "code": "using System ; class GFG { static int minMovesToSort ( int [ ] arr , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; } static public void Main ( ) { int [ ] arr = { 3 , 5 , 2 , 8 , 4 } ; int n = arr . Length ; Console . WriteLine ( minMovesToSort ( arr , n ) ) ; } }"}
{"text": "Susun nombor utama array dalam perintah menurun | C # pelaksanaan pendekatan; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Fungsi yang menyusun semua nombor utama dari array dalam menurun; Vektor ini akan mengandungi nombor utama untuk disusun; Jika elemen itu adalah perdana; mengemas kini elemen array; Kod pemacu; Cetak hasilnya.", "code": "using System ; using System . Collections . Generic ; class GFG { static bool [ ] prime = new bool [ 100005 ] ; static void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < 100005 ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n ; i += p ) { prime [ i ] = false ; } } } } static void sortPrimes ( int [ ] arr , int n ) { SieveOfEratosthenes ( 100005 ) ; List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { v . Add ( arr [ i ] ) ; } } v . Sort ( ) ; v . Reverse ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { arr [ i ] = v [ j ++ ] ; } } } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 3 , 2 , 6 , 100 , 17 } ; int n = arr . Length ; sortPrimes ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } }"}
{"text": "Pembentukan pasangan sedemikian rupa sehingga jumlah pasangan maksimum diminimumkan | C # Program untuk membahagikan array ke pasangan N seperti pasangan maksimum diminimumkan; Selepas menyusun mengekalkan dua pembolehubah i dan j menunjuk untuk memulakan dan mengakhiri array sedemikian rupa sehingga elemen terkecil pasangan array dengan elemen terbesar; Kod pemacu", "code": "using System ; public class GFG { static void findOptimalPairs ( int [ ] arr , int N ) { Array . Sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) Console . Write ( \" ( \" + arr [ i ] + \" , ▁ \" + arr [ j ] + \" ) \" + \" ▁ \" ) ; } static public void Main ( ) { int [ ] arr = { 9 , 6 , 5 , 1 } ; int N = arr . Length ; findOptimalPairs ( arr , N ) ; } }"}
{"text": "Sort Array mengikut kiraan bit set | C # Program untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Berfungsi secara serentak menyusun kedua -dua tatasusunan menggunakan jenis penyisipan (https: www. Gunakan 2 kekunci kerana kita perlu menyusun kedua -dua tatasusunan secara serentak; Gerakkan unsur -unsur ARR [0 .. i - 1] dan aux [0 .. i - 1], seperti unsur -unsur aux [0 .. i - 1] adalah lebih besar daripada Key1, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi untuk disusun mengikut kiraan bit menggunakan array tambahan; Buat array dan kiraan bit set di dalamnya. ; Susun arr [] mengikut nilai dalam aux []; Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "using System ; public class GFG { static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } static void insertionSort ( int [ ] arr , int [ ] aux , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } } static void sortBySetBitCount ( int [ ] arr , int n ) { int [ ] aux = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; } static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . Length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }"}
{"text": "Sort Array mengikut kiraan bit set | C # Program untuk menyusun array mengikut kiraan set bit menggunakan std :: sort (); fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Fungsi untuk disusun mengikut kiraan bit. Fungsi ini mengandaikan bahawa terdapat 32 bit dalam integer. ; Digunakan sebagai indeks dalam array yang disusun semula; Melintasi semua bit bit (perhatikan bahawa kami menyusun array dalam penurunan urutan); Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } static void sortBySetBitCount ( int [ ] arr , int n ) { List < int > [ ] count = new List < int > [ 32 ] ; for ( int i = 0 ; i < count . Length ; i ++ ) count [ i ] = new List < int > ( ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . Add ( arr [ i ] ) ; } int j = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { List < int > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . Count ; p ++ ) arr [ j ++ ] = v1 [ p ] ; } } static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . Length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }"}
{"text": "Rentetan binari terkecil lexicographically dibentuk dengan membalikkan bit pada indeks yang tidak dapat dibahagi k1 atau k2 supaya kiraan 1 s sentiasa lebih besar daripada 0 s dari kiri | C # Program untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil secara lexicographically yang mempunyai bilangan 1 s lebih besar daripada bilangan 0 s; C1S dan C0S menyimpan kiraan 1 s dan 0 s pada setiap kedudukan; Melintasi rentetan s; Jika kedudukan tidak dapat dibahagikan dengan k1 dan k2; Jika c0s> = c1s dan pos [] kosong maka rentetan tidak dapat dibentuk; Jika POS [] tidak kosong maka flip sedikit kedudukan terakhir yang terdapat di POS []; Cetak hasilnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void generateString ( int k1 , int k2 , char [ ] s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; List < int > pos = new List < int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . Add ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . Count == 0 ) { Console . WriteLine ( - 1 ) ; flag = 1 ; break ; } else { int k = pos [ ( pos . Count - 1 ) ] ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . Remove ( pos . Count - 1 ) ; } } } if ( flag == 0 ) { Console . WriteLine ( s ) ; } } public static void Main ( ) { int K1 = 2 , K2 = 4 ; string S = \"11000100\" ; generateString ( K1 , K2 , S . ToCharArray ( ) ) ; } }"}
{"text": "Cari sepasang nombor dengan set bit set sebagai kebanyakan n dan yang bitwise xor adalah n | C # Program untuk pendekatan di atas; Fungsi untuk mencari pasangan (x, y) sedemikian rupa sehingga x xor y = n dan kiraan bit set dalam x dan y kurang daripada kiraan set bit dalam n; Kedai MSB (Bit Paling Penting); Menyimpan nilai x; Menyimpan nilai y; Melintasi semua bit N; Jika ia bit n ialah 0; Tetapkan sedikit x hingga 1; Tetapkan sedikit Y hingga 1; Jawapan cetak; Kod pemacu", "code": "using System ; class GFG { static void maximizeProduct ( int N ) { int MSB = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) { X += 1 << i ; Y += 1 << i ; } } Console . Write ( X + \" ▁ \" + Y ) ; } public static void Main ( ) { int N = 45 ; maximizeProduct ( N ) ; } }"}
{"text": "Count of Numbers in Range [l, r] mempunyai jumlah digit persegi sama dengan kuadrat jumlah digit | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor itu sah; Jumlah digit Num; Nombor kuadrat; Jumlah digit (num * num); Berfungsi untuk menukar rentetan ke integer; Berfungsi untuk menghasilkan semua rentetan panjang yang mungkin; Rentetan yang dikehendaki; Hanya mengambil nombor yang sah; Berulang untuk semua digit yang mungkin; Berfungsi untuk mengira nombor unik dalam julat [l, r]; Memulakan pembolehubah untuk menyimpan jawapannya; Kirakan panjang maksimum yang mungkin; Tetapkan untuk menyimpan nombor yang sah yang berbeza; Menjana semua rentetan panjang yang mungkin i; I -meletakkan set untuk mendapatkan kiraan nombor yang sah dalam julat [l, r]; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 > 0 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; } static int convert ( string s ) { int val = 0 ; char [ ] charArray = s . ToCharArray ( ) ; Array . Reverse ( charArray ) ; s = new string ( charArray ) ; int cur = 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { val += ( ( int ) s [ i ] - ( int ) '0' ) * cur ; cur *= 10 ; } return val ; } static void generate ( string s , int len , HashSet < int > uniq ) { if ( s . Length == len ) { if ( check ( convert ( s ) ) ) { uniq . Add ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + Convert . ToChar ( i + ( int ) '0' ) , len , uniq ) ; } } static int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = ( int ) Math . Log10 ( R ) + 1 ; HashSet < int > uniq = new HashSet < int > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( \" \" , i , uniq ) ; } foreach ( int x in uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } public static void Main ( ) { int L = 22 , R = 22 ; Console . Write ( totalNumbers ( L , R ) ) ; } }"}
{"text": "Tukar x ke y dengan berulang kali mengalikan x dengan 2 atau tampuk 1 pada akhir | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada x boleh ditukar kepada y dengan mengalikan x dengan 2 atau menambahkan 1 pada akhir; ITERATE Sehingga Y adalah sekurang -kurangnya x; Jika y juga; Jika digit terakhir Y ialah 1; Jika tidak; Semak sama ada x sama dengan y; Kod pemacu", "code": "using System ; class GFG { static void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } public static void Main ( String [ ] args ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; } }"}
{"text": "Lexicographically terkecil rentetan panjang maksimum yang terdiri daripada huruf k pertama yang tidak mengandungi apa -apa substring berulang | C # Program untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil lexicographically dari huruf kaum K bawah pertama yang mempunyai substrings yang unik; Menyimpan rentetan yang dihasilkan; Melewati semua watak; Gelung dalaman untuk membuat pasangan dan menambahkannya ke dalam rentetan; Menambah watak pertama supaya substring yang terdiri daripada abjad yang terakhir hadir; Cetak rentetan yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static void generateString ( int K ) { string s = \" \" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } } s += ( char ) ( 97 ) ; Console . Write ( s ) ; } public static void Main ( ) { int K = 4 ; generateString ( K ) ; } }"}
{"text": "Menjana Persamaan Kuadratik setelah memberikan jumlah dan produk akar | C # Program untuk pendekatan di atas; Berfungsi untuk mencari persamaan kuadratik dari jumlah dan produk akar yang diberikan; Cetak pekali; Kod pemacu", "code": "using System ; class GFG { public static void findEquation ( int S , int M ) { Console . Write ( \"1 ▁ \" + ( ( - 1 ) * S ) + \" ▁ \" + M ) ; } static void Main ( ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; } }"}
{"text": "Buat semua elemen array sama dengan menggantikan pasangan bersebelahan dengan jumlah mereka | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum pasang unsur -unsur bersebelahan yang diperlukan untuk digantikan oleh jumlah mereka untuk membuat semua elemen array sama; Menyimpan jumlah awalan array; Kirakan Array Jumlah Awalan; Menyimpan bilangan maksimum subarray yang mana array boleh dibahagikan; Melangkah ke atas semua jumlah yang mungkin; Melintasi array; Jika jumlahnya sama dengan jumlah awalan semasa; Kira kenaikan kumpulan sebanyak 1; Jika tidak buang jumlah subkumpulan ini; Mengemas kini maksimum ini subarray; Mengembalikan bilangan operasi minimum; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int minSteps ( List < int > a , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; int mx = - 1 ; foreach ( int subgroupsum in prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = - 1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; } public static void Main ( ) { List < int > A = new List < int > ( ) { 1 , 2 , 3 , 2 , 1 , 3 } ; int N = A . Count ; Console . Write ( minSteps ( A , N ) ) ; } }"}
{"text": "Karakter yang paling kerap dalam rentetan selepas menggantikan semua kejadian x dalam rentetan binari | C # Program untuk pendekatan di atas; Berfungsi untuk mencari watak yang paling kerap selepas menggantikan x dengan sama ada '0' atau '1' mengikut syarat -syarat yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan S; Hitung kekerapan 0 dan 1; Jika wataknya adalah 1; Jika wataknya 0; Kedai pertama berlaku 1; Melintasi rentetan untuk mengira bilangan x antara dua berturut -turut 1 s; Jika watak semasa bukan x; Jika aksara semasa adalah 1, tambahkan bilangan Xs ke Count1 dan tetapkan sebelum i; Jika tidak; Cari kejadian seterusnya 1 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Simpan kejadian pertama 0; Ulangi prosedur yang sama untuk mengira bilangan x antara dua berturut -turut 0 s; Jika watak semasa bukan x; Jika watak semasa adalah 0; Tambah kiraan XS ke Count0; Tetapkan sebelumnya ke i; Jika tidak; Cari kejadian seterusnya 0 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Kiraan bilangan x yang hadir dalam permulaan rentetan sebagai xxxx1 ...; Simpan kiraan x; Kenaikan kiraan1 dengan kiraan jika keadaan itu berpuas hati; Hitung bilangan x yang hadir pada akhir rentetan sebagai ... xxxx0; Simpan kiraan x; Kenaikan kiraan dengan kiraan jika keadaan itu berpuas hati; Jika kiraan 1 adalah sama dengan kiraan 0, cetak x; Jika tidak, jika kiraan 1 lebih besar daripada kiraan 0; Jika tidak, cetak 0; Kod pemacu", "code": "using System ; public class GFG { public static void maxOccuringCharacter ( string s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { count1 ++ ; } else if ( s [ i ] == '0' ) { count0 ++ ; } } int prev = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . Length ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ j ] == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . Length ; } } } } prev = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . Length ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ j ] == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . Length ; } } } } if ( s [ 0 ] == ' X ' ) { int count = 0 ; int i = 0 ; while ( s [ i ] == ' X ' ) { count ++ ; i ++ ; } if ( s [ i ] == '1' ) { count1 += count ; } } if ( s [ s . Length - 1 ] == ' X ' ) { int count = 0 ; int i = s . Length - 1 ; while ( s [ i ] == ' X ' ) { count ++ ; i -- ; } if ( s [ i ] == '0' ) { count0 += count ; } } if ( count0 == count1 ) { Console . WriteLine ( \" X \" ) ; } else if ( count0 > count1 ) { Console . WriteLine ( 0 ) ; } else Console . WriteLine ( 1 ) ; } public static void Main ( string [ ] args ) { string S = \" XX10XX10XXX1XX \" ; maxOccuringCharacter ( S ) ; } }"}
{"text": "Memaksimumkan kiraan lembaran yang mungkin dengan berulang kali mengurangkan kawasannya kepada separuh | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum lembaran yang mungkin dengan operasi yang diberikan; Kiraan awal lembaran; Terus membahagikan kepingan ke separuh; Mengurangkan kawasan dengan separuh; Meningkatkan kiraan dua kali; Kod pemacu", "code": "using System ; class GFG { static int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } public static void Main ( ) { int A = 5 , B = 10 ; Console . WriteLine ( maxSheets ( A , B ) ) ; } }"}
{"text": "Bilangan langkah minimum yang diperlukan untuk mencapai asal dari titik tertentu | C # Program untuk pendekatan di atas; Berfungsi untuk mencari langkah minimum yang diperlukan untuk mencapai asal dari (a, b); Menyimpan bilangan minimum bergerak; Periksa sama ada perbezaan mutlak ialah 1 atau 0; Simpan minimum a, b; Simpan maksimum a, b; Cetak jawapannya; Kod pemacu; Diberikan Co - ordinat; Panggilan fungsi", "code": "using System ; class GFG { static void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || Math . Abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = Math . Min ( a , b ) ; int j = Math . Max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } Console . Write ( ans ) ; } public static void Main ( ) { int a = 3 , b = 5 ; findMinMoves ( a , b ) ; } }"}
{"text": "Kira walaupun jumlah pasangan yang mungkin dengan memilih dua bilangan bulat dari dua julat yang diberikan masing -masing | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira maksimum walaupun jumlah pasangan dalam julat yang diberikan; Menyimpan kiraan nombor antara 1 hingga x; Menyimpan kiraan nombor ganjil antara 1 hingga x; Menyimpan kiraan nombor antara 1 hingga y; Menyimpan kiraan nombor ganjil antara 1 hingga y; Menyimpan kiraan pasangan yang mempunyai jumlah wang; Mengimbangi kiraan pasangan yang mempunyai jumlah; Kod pemacu", "code": "using System ; class GFG { static long cntEvenSumPairs ( long X , long Y ) { long cntXEvenNums = X / 2 ; long cntXOddNums = ( X + 1 ) / 2 ; long cntYEvenNums = Y / 2 ; long cntYOddNums = ( Y + 1 ) / 2 ; long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; } public static void Main ( string [ ] args ) { long X = 2 ; long Y = 3 ; Console . WriteLine ( cntEvenSumPairs ( X , Y ) ) ; } }"}
{"text": "Kurangkan elemen array yang diperlukan untuk ditingkatkan atau diturunkan untuk menukar array yang diberikan ke dalam siri Fibonacci | C # Program untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum bergerak untuk membuat urutan siri Fibonacci; Jika bilangan elemen kurang daripada 3; Memulakan nilai hasilnya; Cuba semua permutasi dua elemen pertama; Nilai elemen pertama selepas operasi; Nilai elemen kedua selepas operasi; Hitung bilangan gerakan untuk unsur -unsur array; Elemen pada indeks IDX; Sekiranya tidak mungkin untuk menukar elemen dalam satu langkah; Jika tidak; Mengemas kini jawapannya; Kembalikan jawapannya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int minMoves ( List < int > arr ) { int N = arr . Count ; if ( N <= 2 ) return 0 ; int ans = Int32 . MaxValue ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . Abs ( i ) + Math . Abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . Abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . Abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag != 0 ) ans = Math . Min ( ans , moves ) ; } } if ( ans == Int32 . MaxValue ) return - 1 ; return ans ; } public static void Main ( ) { List < int > arr = new List < int > ( ) { 4 , 8 , 9 , 17 , 27 } ; Console . WriteLine ( minMoves ( arr ) ) ; } }"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | C # Program untuk pendekatan di atas; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; Melangkah ke atas setiap pertanyaan; Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array dan mengira jumlah ungkapan; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "using System ; class GFG { static void querySum ( int [ ] arr , int N , int [ , ] Q , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i , 0 ] ; int y = Q [ i , 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } Console . Write ( sum + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 5 , 4 } ; int [ , ] Q = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . Length ; int M = Q . GetLength ( 0 ) ; querySum ( arr , N , Q , M ) ; } }"}
{"text": "Kirakan bitwise atau dua bilangan bulat dari nilai bitwise dan bitwise mereka yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bitwise atau dari bitwise xor dan bitwise dan nilai -nilai; Kod pemacu", "code": "using System ; class GFG { static int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } public static void Main ( string [ ] args ) { int X = 5 , Y = 2 ; Console . Write ( findBitwiseORGivenXORAND ( X , Y ) ) ; } }"}
{"text": "Semak jika nilai yang diberikan dapat dicapai dari nilai lain dalam barisan bulat oleh k | C # Program untuk pendekatan di atas; Berfungsi untuk mengembalikan GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa B boleh digunakan dari A dengan lompatan elemen K dalam barisan bulat; Cari GCD N dan K; Jika A - B boleh dibahagikan dengan GCD maka cetak ya; Jika tidak; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( Math . Abs ( A - B ) % gcd == 0 ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } public static void Main ( ) { int N = 5 , A = 2 , B = 1 , K = 2 ; canReach ( N , A , B , K ) ; } }"}
{"text": "Count subarrays mempunyai jumlah yang sama dengan panjangnya | Tetapkan 2 | C # Program untuk pendekatan di atas; Fungsi yang mengira subarray dengan jumlah elemennya sebagai panjangnya; Simpan kiraan elemen sehingga elemen semasa dengan panjang i; Menyimpan kiraan subarray yang dibaca; Menyimpan jumlah awalan; Jika saiz subarray adalah 1; Melelehkan array; Cari jumlahnya; Kekerapan kemas kini dalam peta; Cetak jumlah kiraan; Kod pemacu; Diberikan array [] arr; Saiz array; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void countOfSubarray ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int answer = 0 ; int sum = 0 ; mp [ 1 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . ContainsKey ( sum - i ) ) answer += mp [ sum - i ] ; if ( mp . ContainsKey ( sum - 1 ) ) mp [ sum - 1 ] ++ ; else mp [ sum - 1 ] = 1 ; } Console . Write ( answer - 2 ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 } ; int N = arr . Length ; countOfSubarray ( arr , N ) ; } }"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Menyimpan jumlah unsur set1; Menyimpan jumlah unsur set2; Melintasi nombor semulajadi n pertama; Semak sama ada jumlah unsur set1 kurang daripada atau sama dengan jumlah unsur set2; Kod pemacu", "code": "using System ; class GFG { static int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . Abs ( sumSet1 - sumSet2 ) ; } static void Main ( ) { int N = 6 ; Console . Write ( minAbsDiff ( N ) ) ; } }"}
{"text": "Semak jika nombor adalah perdana terbalik terbalik, cermin dibalik dan cermin terbalik terbalik | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada n mengandungi digit 0, 1, 2, 5, 8 sahaja; Ekstrak digit n; Kembali palsu jika mana -mana digit ini hadir; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Semak semua faktor; Fungsi untuk memeriksa sama ada n adalah perdana dalam semua bentuk yang dikehendaki; Kod pemacu", "code": "using System ; class GFG { static bool checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; } static bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static bool isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; } public static void Main ( String [ ] args ) { int N = 101 ; if ( isAllPrime ( N ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Kos minimum diperlukan untuk menjana urutan pendakap seimbang | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira kos minimum yang diperlukan untuk menjana urutan pendakap yang seimbang; Menyimpan kiraan kurungan terbuka tidak seimbang; Menyimpan kiraan kurungan tertutup yang tidak seimbang; Menyimpan kiraan kurungan terbuka; Menyimpan kiraan kurungan tertutup; Jika pendakap terbuka ditemui; Jika tidak; Sekiranya tiada kurungan terbuka tidak seimbang; Meningkatkan kiraan kurungan tertutup yang tidak seimbang; Jika tidak; Mengurangkan kiraan kurungan terbuka yang tidak seimbang; Meningkatkan kiraan kurungan tertutup; Mengira batas kos minimum yang lebih rendah; Mengurangkan kurungan terbuka atau tertutup yang berlebihan untuk mengelakkan mengira mereka dua kali; Kemas kini jawapan dengan menambahkan minimum mengeluarkan kedua -dua kurungan terbuka dan tertutup yang tidak seimbang atau memasukkan kurungan tidak seimbang tertutup ke hujung rentetan; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { static void minCost ( String str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( Math . Abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . Min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; Console . Write ( result + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { String str = \" ) ) ( ) ( ( ) ( ) ( \" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; } }"}
{"text": "Count of permutasi seperti jumlah nombor k dari julat yang diberikan adalah | C # Program untuk pendekatan di atas; Berfungsi untuk mengembalikan bilangan semua permutasi seperti jumlah nombor k dalam julat adalah walaupun; Cari jumlah kiraan nombor walaupun dan ganjil dalam julat yang diberikan; ITERATE LOOP K TIMES DAN UPDATE EVER_SUM & ODD_SUM Menggunakan nilai sebelumnya; Kemas kini prev_even dan odd_sum; Malah jumlah; Jumlah ganjil; Kembali even_sum; Kod pemacu; Diberikan julat; Panjang permutasi; Panggilan fungsi", "code": "using System ; class GFG { public static void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } Console . WriteLine ( even_sum ) ; } public static void Main ( String [ ] args ) { int low = 4 ; int high = 5 ; int K = 3 ; countEvenSum ( low , high , K ) ; } }"}
{"text": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Tetapkan 2 | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Cetak jawapannya; Kod pemacu", "code": "using System ; class GFG { public static void count ( int n , int k ) { long count = ( long ) ( Math . Pow ( 10 , k ) - Math . Pow ( 10 , k - 1 ) ) ; Console . Write ( count ) ; } public static void Main ( String [ ] args ) { int n = 2 , k = 1 ; count ( n , k ) ; } }"}
{"text": "Jumlah pembahagi terbesar nombor sehingga tidak dibahagikan dengan nombor perdana p | C # Program untuk pendekatan di atas; Berfungsi untuk mencari jumlah pembahagi terbesar nombor dalam julat 1 hingga n tidak boleh dibahagikan dengan nombor perdana p; Jumlah jumlah sehingga n; Jika tidak ada beberapa p yang ada sehingga n; Jika hanya p sendiri berada dalam lingkungan 1 hingga n; Jumlah mereka yang boleh dibahagikan dengan p; Panggilan fungsi rekursif untuk mencari jumlah untuk N / P; Kod pemacu; Diberikan n dan p; Panggilan fungsi", "code": "using System ; class GFG { static int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; } public static void Main ( String [ ] args ) { int N = 10 , P = 5 ; Console . WriteLine ( func ( N , P ) ) ; } }"}
{"text": "Kira peralihan kanan untuk setiap elemen array berada dalam kedudukan yang disusun | C # Program untuk melaksanakan pendekatan; Fungsi untuk mencari peralihan yang betul yang diperlukan untuk setiap elemen untuk mencapai kedudukan array yang disusun dalam [] A; Kedai yang diperlukan bilangan peralihan untuk setiap elemen; Jika elemen berada pada kedudukan yang disusun; Jika tidak; Kirakan peralihan kanan; Cetak peralihan masing -masing; Kod pemacu", "code": "using System ; class GFG { public static void findShifts ( int [ ] A , int N ) { int [ ] shift = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( shift [ i ] + \" ▁ \" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 4 , 3 , 2 , 5 } ; int N = arr . Length ; findShifts ( arr , N ) ; } }"}
{"text": "Membina matriks dengan jumlah yang sama dengan jumlah unsur pepenjuru | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk membina matriks dengan jumlah pepenjuru yang sama dengan jumlah matriks; Jika kedudukan pepenjuru; Elemen positif; Elemen negatif; Kod pemacu", "code": "using System ; class GFG { public static void constructmatrix ( int N ) { bool check = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) { Console . Write ( \"1 ▁ \" ) ; } else if ( check ) { Console . Write ( \"2 ▁ \" ) ; check = false ; } else { Console . Write ( \" - 2 ▁ \" ) ; check = true ; } } Console . WriteLine ( ) ; } } static public void Main ( ) { int N = 5 ; constructmatrix ( N ) ; } }"}
{"text": "Kiraan minimum nombor yang diperlukan dengan unit digit x yang merangkum sehingga n | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan bilangan minimum kali nombor dengan unit digit X perlu ditambah untuk mendapatkan jumlah n; Kirakan bilangan penambahan yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Berfungsi untuk mengembalikan nombor minimum yang diperlukan untuk mewakili n; Kedai Unit Digit N; Penambahan minimum x yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Jika tidak; Jika n lebih besar daripada atau sama dengan (x * kali); Kiraan minimum nombor yang diperlukan untuk mewakili n; Perwakilan tidak mungkin; Kod pemacu", "code": "using System ; class GFG { static int check ( int unit_digit , int X ) { int times , digit ; for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return - 1 ; } static int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == - 1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return - 1 ; } } public static void Main ( ) { int N = 58 , X = 7 ; Console . Write ( getNum ( N , X ) ) ; } }"}
{"text": "Bilangan minimum mata yang diperlukan untuk menampung semua blok 2 | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum mata yang diperlukan untuk menampung grid; Jika bilangan blok adalah juga; Mengembalikan mata minimum; Kod pemacu; Diberikan saiz grid; Panggilan fungsi", "code": "using System ; class GFG { static int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } public static void Main ( String [ ] args ) { int N = 5 , M = 7 ; Console . Write ( minPoints ( N , M ) ) ; } }"}
{"text": "String lexicographical terbesar dengan paling banyak unsur berturut -turut K | C # kod untuk pendekatan di atas; Fungsi untuk mencari rentetan leksikografi terbesar dengan kekangan yang diberikan. ; Senarai yang mengandungi kekerapan setiap aksara. ; Menetapkan kekerapan; Kosongkan rentetan jenis kelas rentetan; Gelung untuk melangkah ke atas keutamaan maksimum terlebih dahulu. ; Jika kekerapan lebih besar daripada atau sama dengan k. ; Pembolehubah sementara untuk beroperasi di tempat k. ; Menggabungkan dengan rentetan yang dihasilkan. ; Pengendalian kes K dengan menyesuaikan dengan unsur keutamaan yang lebih kecil. ; Keadaan untuk mengesahkan sama ada indeks j mempunyai kekerapan yang lebih besar daripada 0; ; Jika tiada elemen sedemikian dijumpai daripada rentetan tidak dapat diproses lagi. ; Jika kekerapan lebih besar daripada 0 dan kurang daripada k. ; Di sini kita tidak perlu memperbaiki kriteria elemen berturut -turut. ; Jika tidak, periksa elemen seterusnya yang mungkin. ; Kod pemacu", "code": "using System ; class GFG { static String getLargestString ( String s , int k ) { int [ ] frequency_array = new int [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { frequency_array [ s [ i ] - ' a ' ] ++ ; } String ans = \" \" ; for ( int i = 25 ; i >= 0 ; ) { if ( frequency_array [ i ] > k ) { int temp = k ; String st = String . Join ( \" \" , ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } frequency_array [ i ] -= k ; int j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; } if ( frequency_array [ j ] > 0 && j >= 0 ) { String str = String . Join ( \" \" , ( char ) ( j + ' a ' ) ) ; ans += str ; frequency_array [ j ] -= 1 ; } else { break ; } } else if ( frequency_array [ i ] > 0 ) { int temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; String st = String . Join ( \" \" , ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } } else { i -- ; } } return ans ; } public static void Main ( String [ ] args ) { String S = \" xxxxzza \" ; int k = 3 ; Console . Write ( getLargestString ( S , k ) ) ; } }"}
{"text": "Operasi minimum untuk menjadikan semua elemen sama menggunakan array kedua | C # Pelaksanaan untuk mencari operasi minimum menjadikan semua elemen sama menggunakan array kedua; Berfungsi untuk mencari operasi minimum yang diperlukan untuk membuat semua elemen array sama; Elemen minimum []; Melintasi semua nilai akhir; Pembolehubah yang menunjukkan sama ada semua elemen boleh ditukar kepada x atau tidak; Jumlah operasi; Melintasi semua elemen array; Semua elemen tidak boleh ditukar kepada x; Kod pemacu", "code": "using System ; using System . Linq ; class GFG { static int minOperations ( int [ ] a , int [ ] b , int n ) { int minA = a . Max ( ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; } public static void Main ( string [ ] args ) { int N = 5 ; int [ ] A = { 5 , 7 , 10 , 5 , 15 } ; int [ ] B = { 2 , 2 , 1 , 3 , 5 } ; Console . WriteLine ( minOperations ( A , B , N ) ) ; } }"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | C # pelaksanaan untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "using System ; class GFG { static int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . Max ( max_sum , i + j ) ; } } return max_sum ; } public static void Main ( string [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; Console . WriteLine ( max_sum ) ; } }"}
{"text": "Memaksimumkan jumlah array selepas mengalikan awalan dan akhiran oleh | C # pelaksanaan untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran array oleh - 1; Algoritma Kadane untuk mencari jumlah subarray maksimum; Gelung untuk mencari jumlah array subarray maksimum dalam array yang diberikan; Berfungsi untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran oleh - 1; Jumlah jumlah intital; Gelung untuk mencari jumlah maksimum array; Nilai maksimum; Kod pemacu", "code": "using System ; class GFG { static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } static int maxSum ( int [ ] a , int n ) { int S = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; } public static void Main ( String [ ] args ) { int [ ] a = { - 1 , - 2 , - 3 } ; int n = a . Length ; int max_sum = maxSum ( a , n ) ; Console . Write ( max_sum ) ; } }"}
{"text": "Count of Prima yang menarik sehingga n | C # Program untuk mencari bilangan prima yang menarik sehingga n; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Jika n boleh dibahagikan dengan nombor antara 2 dan matematik. Sqrt (n), ia bukan perdana; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk mencari bilangan prima yang menarik kurang daripada sama dengan n. ; Periksa sama ada nombor itu adalah perdana atau tidak; Berulang untuk nilai b; Periksa syarat untuk a; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; } static bool isPerfectSquare ( int x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; } static int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } public static void Main ( String [ ] args ) { int N = 10 ; Console . Write ( countInterestingPrimes ( N ) ) ; } }"}
{"text": "Memaksimumkan nombor dengan membalikkan kebanyakan bit k | C # pelaksanaan pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array [] arr; Berfungsi untuk menukar nombor yang diwakili sebagai array binari [] arr ke setara perpuluhannya; Berfungsi untuk mengembalikan nombor yang dimaksimumkan dengan membalikkan atmost k bit; Bilangan bit dalam n; Cari perwakilan binari n; Untuk mengira bilangan 0 s terbalik; Mengembalikan setara perpuluhan nombor yang dimaksimumkan; Kod pemacu", "code": "using System ; class GFG { static void decBinary ( int [ ] arr , int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int maxNum ( int n , int k ) { int l = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int [ ] a = new int [ l ] ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; } public static void Main ( String [ ] args ) { int n = 4 , k = 1 ; Console . WriteLine ( maxNum ( n , k ) ) ; } }"}
{"text": "Cari berikutnya dengan jumlah yang diberikan dalam urutan superincreasing | C # pelaksanaan pendekatan; Berfungsi untuk mencari seterusnya yang diperlukan; Elemen semasa tidak boleh menjadi sebahagian daripada berikutnya yang diperlukan; Termasuk elemen semasa dalam seterusnya yang diperlukan supaya mengemas kini jumlah; Cetak unsur -unsur berikutnya yang diperlukan; Jika elemen semasa dimasukkan ke dalam berikutnya; Kod pemacu", "code": "using System ; class GFG { static void findSubSeq ( int [ ] arr , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = - 1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != - 1 ) Console . Write ( arr [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = arr . Length ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; } }"}
{"text": "Cari abjad yang paling bernilai dalam rentetan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan abjad bernilai maksimum; Untuk menyimpan kejadian pertama dan terakhir semua watak; Tetapkan kejadian pertama dan terakhir semua aksara kepada - 1; Kemas kini kejadian watak -watak; Hanya menetapkan kejadian pertama jika ia tidak telah ditetapkan; Untuk menyimpan hasilnya; Untuk setiap abjad; Jika abjad semasa tidak muncul dalam rentetan yang diberikan; Jika watak semasa mempunyai nilai tertinggi setakat ini; Kod pemacu", "code": "using System ; class GFG { static int MAX = 26 ; static char maxAlpha ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int ans = - 1 , maxVal = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } public static void Main ( String [ ] args ) { String str = \" abbba \" ; int len = str . Length ; Console . Write ( maxAlpha ( str , len ) ) ; } }"}
{"text": "Pertanyaan untuk bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array | C # pelaksanaan pendekatan; Berfungsi untuk melakukan pertanyaan untuk mencari bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array; Periksa sama ada elemen semasa sudah dilawati atau tidak; Jika tidak melawat kaunter semasa dan kenaikannya dan semak semak sebagai 1; Jika tidak, jika dikunjungi hanya menyimpan kaunter semasa; Melakukan pertanyaan; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100001 ; static void find_distinct ( int [ ] a , int n , int q , int [ ] queries ) { int [ ] check = new int [ MAX ] ; int [ ] idx = new int [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; Console . Write ( idx [ m ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = a . Length ; int [ ] queries = { 0 , 3 , 5 , 7 } ; int q = queries . Length ; find_distinct ( a , n , q , queries ) ; } }"}
{"text": "Tukar Integer X diberikan kepada Borang 2 ^ n | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan operasi yang diperlukan; Untuk menyimpan kuasa 2; Pembolehubah sementara untuk menyimpan X; Untuk menyimpan indeks nombor yang lebih kecil daripada x; Untuk menyimpan kiraan operasi; Menyimpan indeks nombor dalam bentuk 2 ^ n - 1; Jika x sudah ada dalam bentuk 2 ^ n - 1 maka tiada operasi diperlukan; Jika nombor kurang daripada x meningkatkan indeks; Kirakan semua nilai (x xor 2 ^ n - 1) untuk semua yang mungkin n; Hanya mengambil nilai yang lebih dekat dengan nombor; Jika nombor berada dalam bentuk 2 ^ n - 1 maka pecah; Mengembalikan kiraan operasi yang diperlukan untuk mendapatkan nombor; Kod pemacu", "code": "using System ; class GFG { static int MAX = 24 ; static int countOp ( int x ) { int [ ] arr = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans = 0 ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } static public void Main ( ) { int x = 39 ; Console . WriteLine ( countOp ( x ) ) ; } }"}
{"text": "Bilangan minimum operasi yang diberikan untuk mengurangkan array ke 0 elemen | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Hitung kekerapan setiap elemen; Elemen maksimum dari array; Cari semua gandaan i; Padamkan gandaan; Meningkatkan operasi; Kod pemacu", "code": "using System ; using System . Linq ; class GFG { static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = arr . Max ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = arr . Length ; Console . WriteLine ( minOperations ( arr , n ) ) ; } }"}
{"text": "Minimum LCM dan GCD mungkin di antara semua sub | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan GCD minimum di kalangan semua subarray; GCD minimum di antara semua sub -tatasusunan akan menjadi GCD dari semua elemen array; Berfungsi untuk mengembalikan LCM minimum di kalangan semua subarray; LCM minimum di antara semua sub - tatasusunan akan menjadi elemen minimum dari array; Kod pemacu", "code": "using System ; class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } static int minGCD ( int [ ] arr , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; } static int minLCM ( int [ ] arr , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = Math . Min ( minLCM , arr [ i ] ) ; return minLCM ; } public static void Main ( ) { int [ ] arr = { 2 , 66 , 14 , 521 } ; int n = arr . Length ; Console . WriteLine ( \" LCM ▁ = ▁ \" + minLCM ( arr , n ) + \" , ▁ GCD ▁ = ▁ \" + minGCD ( arr , n ) ) ; } }"}
{"text": "Bentuk rentetan terkecil secara lexicographically dengan penggantian minimum yang mempunyai bilangan yang sama 0 s, 1 s dan 2 s | C # pelaksanaan pendekatan; Fungsi yang mengembalikan rentetan terkecil lexicographically yang diubahsuai selepas melakukan bilangan minimum operasi yang diberikan; Menyimpan frekuensi awal aksara 0 s, 1 s dan 2 s; Menyimpan bilangan aksara yang diproses sehingga titik setiap jenis; Bilangan aksara yang diperlukan setiap jenis; Jika jenis semasa telah membatalkan bilangan aksara, tidak perlu melakukan apa -apa operasi; Proses semua 3 kes; Semak 1 pertama; Lain 2; Di sini kita perlu menyemak yang diproses [1] hanya untuk 2 kerana 0 adalah kurang daripada 1 dan kita boleh menggantikannya pada bila -bila masa; Di sini kita boleh menggantikan 2 dengan 0 dan 1 bila -bila masa; Simpan kiraan aksara yang diproses setiap jenis; Kod pemacu", "code": "using System ; class GFG { static String formStringMinOperations ( char [ ] s ) { int [ ] count = new int [ 3 ] ; foreach ( char c in s ) { count [ ( int ) c - 48 ] += 1 ; } int [ ] processed = new int [ 3 ] ; int reqd = ( int ) s . Length / 3 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( count [ s [ i ] - '0' ] == reqd ) { continue ; } if ( s [ i ] == '0' && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) { if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 0 ] -- ; } else if ( count [ 2 ] < reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 0 ] -- ; } } if ( s [ i ] == '1' && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 1 ] -- ; } } if ( s [ i ] == '2' && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 2 ] -- ; } } processed [ s [ i ] - '0' ] ++ ; } return String . Join ( \" \" , s ) ; } public static void Main ( String [ ] args ) { String s = \"011200\" ; Console . WriteLine ( formStringMinOperations ( s . ToCharArray ( ) ) ) ; } }"}
{"text": "Bilangan minimum swap bersebelahan untuk mengatur unsur -unsur yang sama bersama -sama | C # Program untuk mencari bilangan minimum swap bersebelahan untuk mengatur item yang sama bersama -sama; Berfungsi untuk mencari swap minimum; Arahan yang dikunjungi untuk memeriksa sama ada nilai sudah dilihat; Jika arr [i] dilihat kali pertama; menyimpan bilangan swap yang diperlukan untuk mencari kedudukan yang betul dari rakan kongsi elemen semasa; Kiraan kenaikan hanya jika elemen semasa belum dikunjungi (jika dikunjungi, bermakna ia telah diletakkan pada kedudukan yang betul); Jika rakan kongsi elemen semasa dijumpai; Kod pemacu", "code": "using System ; class GFG { static int findMinimumAdjacentSwaps ( int [ ] arr , int N ) { bool [ ] visited = new bool [ N + 1 ] ; int minimumSwaps = 0 ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = arr . Length ; N /= 2 ; Console . WriteLine ( findMinimumAdjacentSwaps ( arr , N ) ) ; } }"}
{"text": "Nombor Palindromic Terbesar dengan Permuting Digits | C # Program untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; Berfungsi untuk memeriksa sama ada nombor boleh dibentuk untuk membentuk nombor palindrome; Mengira kejadian nombor yang ganjil; Sekiranya kejadian ganjil; Jika nombor melebihi 1; Berfungsi untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; panjang rentetan; Peta yang menandakan kejadian nombor; Semak kemungkinan nombor palindromik; array rentetan yang menyimpan nombor palindromik yang terbesar; Penunjuk depan; Ramuan bermula dari 9 hingga 0 dan letakkan nombor yang lebih besar di depan dan ganjil di tengah; Sekiranya berlakunya nombor adalah ganjil; Letakkan satu nombor ganjil di tengah; Mengurangkan kiraan; Letakkan seluruh nombor dengan tamak; Jika semua nombor berlaku walaupun masa, maka letakkan dengan tamak; Letakkan tamak di hadapan; 2 nombor diletakkan, jadi mengurangkan kiraan; Meningkatkan kedudukan meletakkan; Cetak rentetan terbesar yang terbentuk; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static bool possibility ( Dictionary < int , int > m , int length , string s ) { int countodd = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( ( m [ s [ i ] - '0' ] & 1 ) != 0 ) countodd ++ ; if ( countodd > 1 ) return false ; } return true ; } static void largestPalindrome ( string s ) { int l = s . Length ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) m [ i ] = 0 ; for ( int i = 0 ; i < l ; i ++ ) m [ s [ i ] - '0' ] ++ ; if ( possibility ( m , l , s ) == false ) { Console . Write ( \" Palindrome ▁ cannot ▁ be ▁ formed \" ) ; return ; } char [ ] largest = new char [ l ] ; int front = 0 ; for ( int i = 9 ; i >= 0 ; i -- ) { if ( ( m [ i ] & 1 ) != 0 ) { largest [ l / 2 ] = ( char ) ( i + '0' ) ; m [ i ] -- ; while ( m [ i ] > 0 ) { largest [ front ] = ( char ) ( i + '0' ) ; largest [ l - front - 1 ] = ( char ) ( i + '0' ) ; m [ i ] -= 2 ; front ++ ; } } else { while ( m [ i ] > 0 ) { largest [ front ] = ( char ) ( i + '0' ) ; largest [ l - front - 1 ] = ( char ) ( i + '0' ) ; m [ i ] -= 2 ; front ++ ; } } } for ( int i = 0 ; i < l ; i ++ ) { Console . Write ( largest [ i ] ) ; } } public static void Main ( string [ ] args ) { string s = \"313551\" ; largestPalindrome ( s ) ; } }"}
{"text": "Swap minimum untuk mengimbangi pendakap | C # Program untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Fungsi untuk mengira swap yang diperlukan; Jejaki '['; Untuk mengira bilangan yang ditemui '['; Untuk mengesan kedudukan seterusnya '[' dalam POS; Untuk menyimpan hasil; Kiraan kenaikan dan bergerak P ke kedudukan seterusnya; Kami telah menemui bahagian rentetan yang tidak seimbang; Jumlah kenaikan dengan bilangan swap yang diperlukan i. e. kedudukan seterusnya '[' - kedudukan semasa; Tetapkan semula kiraan kepada 1; Kod pemacu", "code": "using System . IO ; using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static long swapCount ( string s ) { List < int > pos = new List < int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' [ ' ) { pos . Add ( i ) ; } } int count = 0 ; int p = 0 ; long sum = 0 ; char [ ] S = s . ToCharArray ( ) ; for ( int i = 0 ; i < S . Length ; i ++ ) { if ( S [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( S [ i ] == ' ] ' ) { -- count ; } if ( count < 0 ) { sum += pos [ p ] - i ; char temp = S [ i ] ; S [ i ] = S [ pos [ p ] ] ; S [ pos [ p ] ] = temp ; ++ p ; count = 1 ; } } return sum ; } static void Main ( ) { string s = \" [ ] ] [ ] [ \" ; Console . WriteLine ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; Console . WriteLine ( swapCount ( s ) ) ; } }"}
{"text": "Kos minimum untuk memotong papan ke dalam dataran | C # Program untuk membahagikan papan ke dalam kotak m * n; kaedah mengembalikan kos minimum untuk memecahkan papan ke dalam kotak m * n; menyusun kos mendatar dalam urutan terbalik; menyusun kos menegak dalam urutan terbalik; memulakan lebar semasa sebagai 1; gelung sehingga satu atau kedua -dua kos kos diproses; meningkatkan kiraan bahagian mendatar semasa dengan 1; meningkatkan kiraan bahagian menegak semasa dengan 1; gelung untuk array mendatar, jika kekal; gelung untuk pelbagai menegak, jika kekal; Program Pemandu", "code": "using System ; class GFG { static int minimumCostOfBreaking ( int [ ] X , int [ ] Y , int m , int n ) { int res = 0 ; Array . Sort < int > ( X , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; Array . Sort < int > ( Y , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } public static void Main ( String [ ] arg ) { int m = 6 , n = 4 ; int [ ] X = { 2 , 1 , 3 , 1 , 4 } ; int [ ] Y = { 4 , 1 , 2 } ; Console . WriteLine ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ; } }"}
{"text": "Kurangkan kiraan aksara yang akan ditambah atau dikeluarkan untuk membuat pengulangan rentetan substring yang sama | C # Program untuk pendekatan di atas; Berfungsi untuk mencari minimum tiga nombor; Berfungsi untuk mencari operasi bilangan minimum yang diperlukan untuk menukar string str1 ke str2 menggunakan operasi; Menyimpan hasil subproblem; Isi dp [,] dengan cara bawah; Jika str1 kosong, masukkan semua aksara string str2; Operasi minimum ialah J; Jika str2 kosong, maka keluarkan semua aksara string str2; Operasi minimum ialah i; Jika watak terakhir adalah sama, maka abaikan watak terakhir; Jika watak terakhir berbeza, maka cari minimum; Lakukan salah satu sisipan, keluarkan dan ganti; Mengembalikan bilangan langkah minimum yang diperlukan; Berfungsi untuk mencari bilangan langkah minimum untuk mengubah suai rentetan sedemikian rupa sehingga separuh pertama dan separuh kedua menjadi sama; Menyimpan bilangan minimum operasi yang diperlukan; Melintasi rentetan yang diberikan; Cari operasi minimum; Kemas kini ANS; Cetak hasilnya; Kod pemacu", "code": "using System ; public class GFG { static int getMin ( int x , int y , int z ) { return Math . Min ( Math . Min ( x , y ) , z ) ; } static int editDistance ( string str1 , string str2 , int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i , j ] = j ; else if ( j == 0 ) dp [ i , j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i , j ] = dp [ i - 1 , j - 1 ] ; else { dp [ i , j ] = 1 + getMin ( dp [ i , j - 1 ] , dp [ i - 1 , j ] , dp [ i - 1 , j - 1 ] ) ; } } } return dp [ m , n ] ; } static void minimumSteps ( string S , int N ) { int ans = int . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { string S1 = S . Substring ( 0 , i ) ; string S2 = S . Substring ( i ) ; int count = editDistance ( S1 , S2 , S1 . Length , S2 . Length ) ; ans = Math . Min ( ans , count ) ; } Console . Write ( ans ) ; } public static void Main ( string [ ] args ) { string S = \" aabb \" ; int N = S . Length ; minimumSteps ( S , N ) ; } }"}
{"text": "Kurangkan operasi untuk mengurangkan n hingga 2 dengan berulang kali mengurangkan 3 atau membahagikan dengan 5 | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi untuk mengurangkan n hingga 2 dengan membahagikan n dengan 5 atau penurunan sebanyak 3; Memulakan array DP; Memulakan array dp []; Untuk n = 2 bilangan operasi yang diperlukan adalah sifar; Melangkah ke atas julat [1, n]; Jika ia tidak mungkin untuk membuat n semasa; Kalikan dengan 5; Menambah nilai 3; Memeriksa jika tidak mungkin untuk membuat nombor sebagai 2; Mengembalikan bilangan operasi minimum; Kod pemacu", "code": "using System ; class GFG { static int minimumOperations ( int N ) { int [ ] dp = new int [ N + 1 ] ; int i ; for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = ( int ) 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == ( int ) 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = Math . Min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = Math . Min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return - 1 ; return dp [ N ] ; } public static void Main ( String [ ] args ) { int N = 25 ; Console . Write ( minimumOperations ( N ) ) ; } }"}
{"text": "Keuntungan maksimum selepas membeli dan menjual stok dengan yuran transaksi | Tetapkan 2 | C # Program untuk pendekatan di atas; Berfungsi untuk mencari keuntungan maksimum dengan yuran transaksi; Melintasi stok untuk setiap hari; Kemas kini membeli dan menjual; Mengembalikan keuntungan maksimum; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; class GFG { static int MaxProfit ( int [ ] arr , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = Math . Max ( buy , sell - arr [ i ] ) ; sell = Math . Max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . Max ( sell , buy ) ; } public static void Main ( ) { int [ ] arr = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = arr . Length ; int transactionFee = 2 ; Console . WriteLine ( MaxProfit ( arr , n , transactionFee ) ) ; } }"}
{"text": "Jumlah maksimum dari kiri ke bawah kanan matriks melalui salah satu sel yang diberikan | C # Program untuk pendekatan di atas; Menyimpan jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Menyimpan jumlah laluan maksimum dari sel (j, j) hingga (n, m); Berfungsi untuk mencari jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Melintasi baris pertama; Melintasi lajur pertama; Melintasi matriks; Kemas kini nilai permulaan [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari sel (j, j) hingga (n, m); Melintasi baris terakhir; Melintasi lajur terakhir; Melintasi matriks; Kemas kini nilai berakhir [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari atas - kiri ke sel kanan bawah supaya laluan itu mengandungi salah satu sel dalam koordinat array [] []; Memulakan permulaan dan matriks akhir; Kirakan matriks permulaan; Kirakan matriks akhir; Menyimpan jumlah laluan maksimum; Melintasi koordinat; Kemas kini nilai ANS; Cetak nilai laluan jumlah maksimum yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static int [ , ] start = new int [ 3 , 3 ] ; static int [ , ] ending = new int [ 3 , 3 ] ; static void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 , i ] += start [ 0 , i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i , 0 ] += start [ i - 1 , 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i , j ] += Math . Max ( start [ i - 1 , j ] , start [ i , j - 1 ] ) ; } } } static void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i , m - 1 ] += ending [ i + 1 , m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 , i ] += ending [ n - 1 , i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i , j ] += Math . Max ( ending [ i + 1 , j ] , ending [ i , j + 1 ] ) ; } } } static void maximumPathSum ( int [ , ] mat , int n , int m , int q , int [ , ] coordinates ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i , j ] = mat [ i , j ] ; ending [ i , j ] = mat [ i , j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i , 0 ] - 1 ; int Y = coordinates [ i , 1 ] - 1 ; ans = Math . Max ( ans , start [ X , Y ] + ending [ X , Y ] - mat [ X , Y ] ) ; } Console . Write ( ans ) ; } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int N = 3 ; int M = 3 ; int Q = 2 ; int [ , ] coordinates = { { 1 , 2 } , { 2 , 2 } } ; maximumPathSum ( mat , N , M , Q , coordinates ) ; } }"}
{"text": "Panjang subset terpanjang yang terdiri daripada 0 s dan b 1 s dari pelbagai rentetan | Tetapkan 2 | C # Program untuk pendekatan di atas; Berfungsi untuk mencari panjang subset terpanjang pelbagai rentetan dengan paling banyak 0 s dan b 1 s; Memulakan array 2D dengan penyertaannya sebagai 0; Melintasi array yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan semasa; Melangkah dalam julat [a, sifar]; Berulang dalam julat [b, yang]; Mengemas kini nilai dp [i] [j]; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { static int MaxSubsetlength ( string [ ] arr , int A , int B ) { int [ , ] dp = new int [ A + 1 , B + 1 ] ; foreach ( string str in arr ) { int zeros = 0 , ones = 0 ; foreach ( char ch in str . ToCharArray ( ) ) { if ( ch == '0' ) zeros ++ ; else ones ++ ; } for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - zeros , j - ones ] + 1 ) ; } return dp [ A , B ] ; } public static void Main ( string [ ] args ) { string [ ] arr = { \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" } ; int A = 5 , B = 3 ; Console . WriteLine ( MaxSubsetlength ( arr , A , B ) ) ; } }"}
{"text": "Kira cara untuk memilih pasangan gula -gula warna yang berbeza (pengaturcaraan dinamik + bitmasking) | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira cara untuk memilih N yang berbeza pasangan gula -gula dengan warna yang berbeza; Jika pasangan N dipilih; Kedai mengira cara untuk memilih pasangan i - th; Melangkah ke atas julat [0, n]; Jika pasangan (i, j) tidak termasuk; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int numOfWays ( int [ , ] a , int n , int i , HashSet < int > blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i , j ] == 1 && ! blue . Contains ( j ) ) { blue . Add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . Remove ( j ) ; } } return count ; } public static void Main ( ) { int n = 3 ; int [ , ] mat = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; HashSet < int > mpp = new HashSet < int > ( ) ; Console . WriteLine ( ( numOfWays ( mat , n , 0 , mpp ) ) ) ; } }"}
{"text": "Kurangkan kos untuk mencapai hujung array oleh dua lompatan ke hadapan atau satu lompatan ke belakang dalam setiap langkah | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mencapai akhir array; Kes asas: apabila n <3; Simpan hasil dalam jadual; Memulakan kes asas; Melangkah ke atas julat [2, n - 2] untuk membina array DP; Mengendalikan kes untuk indeks terakhir, i. e. N - 1; Cetak jawapannya; Kod pemacu", "code": "using System ; public class GFG { static void minCost ( int [ ] arr , int n ) { if ( n < 3 ) { Console . WriteLine ( arr [ 0 ] ) ; return ; } int [ ] dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . Min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . Min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; Console . WriteLine ( dp [ n - 1 ] ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 9 , 4 , 6 , 8 , 5 } ; int N = arr . Length ; minCost ( arr , N ) ; } }"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); Kedai perwakilan binari n; Kedai kuasa 10; Kirakan perwakilan binari n; Jika n adalah nombor ganjil; Kemas kini x; Kemas kini pow_10; Kemas kini n; Dua kali ganda nilai x; Menyimpan nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kod pemacu", "code": "using System ; class GFG { static int M = 1000000007 ; static int power ( int X , int Y ) { int res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } static int findValue ( int n ) { int X = 0 ; int pow_10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; int res = power ( 2 , X ) ; return res ; } public static void Main ( String [ ] args ) { int n = 2 ; Console . WriteLine ( findValue ( n ) ) ; } }"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); dp [n] * dp [n]: Kedai nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kes asas; Melangkah ke atas julat [3, n]; Kedai paling tepat dari saya; Menyimpan nilai (i - y); Jika x adalah kuasa 2; Kemas kini DP [i]; Kemas kini DP [i]; Kod pemacu", "code": "using System ; class GFG { static readonly long M = 1000000007 ; static long power ( long X , long Y ) { long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y % 2 == 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } static long findValue ( int N ) { long [ ] dp = new long [ N + 1 ] ; dp [ 1 ] = 2 ; dp [ 2 ] = 1024 ; for ( int i = 3 ; i <= N ; i ++ ) { int y = ( i & ( - i ) ) ; int x = i - y ; if ( x == 0 ) { dp [ i ] = power ( dp [ i / 2 ] , 10 ) ; } else { dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; } } return ( dp [ N ] * dp [ N ] ) % M ; } public static void Main ( String [ ] args ) { int n = 150 ; Console . Write ( findValue ( n ) ) ; } }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | C # Program untuk pendekatan di atas; Fungsi untuk mencari bilangan cara untuk mendapatkan jumlah n dengan membuang dadu; Kes asas; Menyimpan jumlah jumlah cara untuk mendapatkan jumlah n; Berulang untuk semua 6 negeri; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } public static void Main ( ) { int N = 4 ; Console . Write ( findWays ( N ) ) ; } }"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | C # Program untuk pendekatan di atas; Fungsi utiliti untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Kes asas; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengembalikan nilai maksimum di antara semua 3 panggilan rekursif; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "using System ; class GFG { static int checkEqualSumUtil ( int [ ] arr , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return Math . Max ( Math . Max ( l , m ) , r ) ; } } static void checkEqualSum ( int [ ] arr , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { Console . Write ( \" Yes \" ) ; } else { Console . Write ( \" No \" ) ; } } public static void Main ( ) { int [ ] arr = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . Length ; checkEqualSum ( arr , N ) ; } }"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa array boleh menjadi partition ke dalam jumlah 3 sama; Kes asas; Jika nilai pada indeks tertentu tidak - 1 maka nilai pulangan pada indeks itu yang memastikan tiada lagi panggilan lagi; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengemas kini keadaan semasa dan mengembalikan nilai itu; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static Dictionary < string , int > dp = new Dictionary < string , int > ( ) ; static int checkEqualSumUtil ( int [ ] arr , int N , int sm1 , int sm2 , int sm3 , int j ) { string s = sm1 . ToString ( ) + \" _ \" + sm2 . ToString ( ) + j . ToString ( ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . ContainsKey ( s ) ) return dp [ s ] ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; dp [ s ] = Math . Max ( Math . Max ( l , m ) , r ) ; return dp [ s ] ; } } static void checkEqualSum ( int [ ] arr , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { Console . Write ( \" Yes \" ) ; } else { Console . Write ( \" No \" ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . Length ; checkEqualSum ( arr , N ) ; } }"}
{"text": "Indeks terkecil dalam pelbagai indeks yang tidak sama dengan x | C # Program untuk mencari indeks terkecil dalam array dalam julat [l, r] yang tidak mengandungi x; Precompute Indeks elemen yang berbeza seterusnya dalam array untuk setiap elemen array; Nilai lalai; Kirakan Nextpos [i] menggunakan Nextpos [i + 1]; Berfungsi untuk mengembalikan indeks terkecil; Nextpos [i] akan menyimpan kedudukan seterusnya p di mana arr [p]! = arr [i]; Jika x tidak hadir di l; Jika tidak; Cari indeks yang menyimpan nilai yang berbeza dari x; Jika indeks itu berada dalam julat; Kod pemacu", "code": "using System ; class GFG { static void precompute ( int [ ] nextpos , int [ ] arr , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } } static void findIndex ( int [ , ] query , int [ ] arr , int N , int Q ) { int [ ] nextpos = new int [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i , 0 ] ; r = query [ i , 1 ] ; x = query [ i , 2 ] ; int ans = - 1 ; if ( arr [ l ] != x ) ans = l ; else { int d = nextpos [ l ] ; if ( d <= r ) ans = d ; } Console . Write ( ans + \" STRNEWLINE \" ) ; } } public static void Main ( String [ ] args ) { int N , Q ; N = 6 ; Q = 3 ; int [ ] arr = { 1 , 2 , 1 , 1 , 3 , 5 } ; int [ , ] query = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; } }"}
{"text": "Mengira bilangan cara untuk menukar rentetan s ke t dengan melakukan peralihan kitaran k | C # Program untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk menukar rentetan s ke rentetan t dengan melakukan peralihan kitaran k; Hitung panjang rentetan; 'A' bukan peralihan siklik yang baik 'B' bukan peralihan siklik yang buruk; Iterat dalam rentetan; Precompute bilangan peralihan kitaran yang baik dan buruk; DP2 [i] untuk menyimpan tidak ada cara untuk mendapatkan peralihan yang buruk dalam saya bergerak; Kirakan peralihan yang baik dan buruk; Mengembalikan bilangan cara yang diperlukan; Kod pemacu; Diberikan rentetan; Memandangkan pergeseran k diperlukan; Panggilan fungsi", "code": "using System ; class GFG { static long mod = 10000000007L ; static long countWays ( string s , string t , int k ) { int n = s . Length ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . Substring ( i , n - i ) + s . Substring ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } long [ ] dp1 = new long [ k + 1 ] ; long [ ] dp2 = new long [ k + 1 ] ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } public static void Main ( string [ ] args ) { string S = \" ab \" , T = \" ab \" ; int K = 2 ; Console . Write ( countWays ( S , T , K ) ) ; } }"}
{"text": "Kurangkan langkah -langkah untuk mencapai k dari 0 dengan menambah 1 atau menggandakan pada setiap langkah | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari operasi minimum; DP diasaskan untuk menyimpan langkah -langkah; Untuk semua nombor walaupun; Kod pemacu", "code": "using System ; class GFG { static int minOperation ( int k ) { int [ ] dp = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . Min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } public static void Main ( ) { int K = 12 ; Console . Write ( minOperation ( K ) ) ; } }"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | C # Pelaksanaan untuk pendekatan rekursif yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; Abaikan elemen semasa; termasuk elemen dalam partition 1; termasuk elemen dalam partition 2; Kod pemacu; saiz array", "code": "using System ; public class GFG { static int maxSum ( int p0 , int p1 , int [ ] a , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . Max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . Max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } public static void Main ( string [ ] args ) { int n = 4 ; int [ ] a = { 1 , 2 , 3 , 6 } ; Console . WriteLine ( maxSum ( 0 , 0 , a , 0 , n ) ) ; } }"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | C # pelaksanaan untuk pendekatan pengaturcaraan dinamik yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; jumlah semua elemen; Jadual carian bawah; ; jadual DP yang memulakan dengan int_min di mana, int_min bermaksud tiada penyelesaian; Kes apabila diff adalah 0; Meletakkan elemen ITH dalam G0; Meletakkan elemen ITH dalam G1; Mengabaikan elemen ith; Kod pemacu", "code": "using System ; class GFG { static int INT_MIN = int . MinValue ; static int maxSum ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int [ , ] dp = new int [ n + 1 , limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i , j ] = INT_MIN ; } dp [ 0 , sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 , j - a [ i - 1 ] ] != INT_MIN ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 , j + a [ i - 1 ] ] != INT_MIN ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 , j ] != INT_MIN ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - 1 , j ] ) ; } } return dp [ n , sum ] ; } public static void Main ( ) { int n = 4 ; int [ ] a = { 1 , 2 , 3 , 6 } ; Console . WriteLine ( maxSum ( a , n ) ) ; } }"}
{"text": "Count of Strings mungkin dengan menggantikan dua watak yang sama berturut -turut dengan watak baru | C # Program untuk mengira borang rentetan yang berbeza dengan menggantikan dua aksara yang sama dengan satu; Array untuk mencari urutan Fibonacci; Berfungsi untuk mencari urutan Fibonacci; Berfungsi untuk mengira semua rentetan yang mungkin; Memulakan ans = 1; Jika dua char berturut -turut adalah peningkatan yang sama CNT; Lain melipatgandakan FIB [CNT] ke Ans dan memulakan Ans hingga 1; Jika str = abcdeeee, maka untuk terakhir \"eeee\" kiraan munst dikemas kini; Mengembalikan jumlah jumlah; Kod pemandu; Berfungsi untuk precompute semua nombor Fibonacci; Fungsi panggilan untuk mencari kiraan", "code": "using System ; class GFG { static int [ ] fib = new int [ 100005 ] ; static void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } static int countString ( string str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; } public static void Main ( string [ ] args ) { string str = \" abdllldefkkkk \" ; computeFibonacci ( ) ; Console . WriteLine ( countString ( str ) ) ; } }"}
{"text": "Urutan Golomb | Tetapkan 2 | C # Program untuk mencari terma pertama N Golomb urutan; Berfungsi untuk mencetak urutan Golomb; Memulakan array; Memulakan CNT hingga 0; Elemen pertama dan kedua urutan Golomb ialah 0, 1; Peta untuk menyimpan kiraan elemen semasa dalam urutan Golomb; Simpan kiraan 2; Melangkah lebih dari 2 hingga n; Jika CNT sama dengan 0 maka kita mempunyai nombor baru untuk urutan Golomb 1 2 2 3 3 4 4 4 5 5 5 yang 1 + elemen sebelumnya; Lain elemen semasa adalah elemen sebelumnya dalam urutan ini; Peta indeks semasa ke nilai semasa dalam arr []; Cetak urutan Golomb; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 1000 ; static void printGolombSequence ( int N ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) arr [ i ] = 0 ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; Dictionary < int , int > M = new Dictionary < int , int > ( ) ; M . Add ( 2 , 2 ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } if ( M . ContainsKey ( i ) ) { M [ i ] = arr [ i ] ; } else { M . Add ( i , arr [ i ] ) ; } } for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } static void Main ( ) { int N = 11 ; printGolombSequence ( N ) ; } }"}
{"text": "Kira cara untuk mencapai tangga nth dengan mengambil 1 dan 2 langkah dengan tepat satu 3 langkah | C # Pelaksanaan untuk mencari bilangan bilangan cara untuk mencapai tangga nth dengan mengambil 1, 2 langkah pada satu masa dan 3 langkah pada satu masa tepat sekali. ; Berfungsi untuk mencari bilangan bilangan cara untuk mencapai tangga nth; Array termasuk bilangan cara yang merangkumi 3; Array termasuk bilangan cara yang tidak termasuk 3; Pada mulanya untuk mencapai 3 tangga dengan mengambil 3 langkah boleh dicapai dengan 1 cara; Gelung untuk mencari nombor bilangan cara untuk mencapai tangga nth; Kod pemacu", "code": "using System ; class GFG { static int number_of_ways ( int n ) { int [ ] includes_3 = new int [ n + 1 ] ; int [ ] not_includes_3 = new int [ n + 1 ] ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } public static void Main ( String [ ] args ) { int n = 7 ; Console . Write ( number_of_ways ( n ) ) ; } }"}
{"text": "Bilangan maksimum gandaan dalam array sebelum mana -mana elemen | C # pelaksanaan pendekatan; Peta untuk menyimpan kiraan pembahagi; Berfungsi untuk menjana pembahagi semua elemen array; Berfungsi untuk mencari bilangan maksimum gandaan dalam array sebelum itu; Untuk menyimpan kiraan pembahagi maksimum; Kemas kini Ans Jika lebih banyak bilangan pembahagi dijumpai; Menjana semua pembahagi elemen seterusnya dari array; Kod pemacu", "code": "using System ; class GFG { static int MAX = 100000 ; static int [ ] divisors = new int [ MAX ] ; static void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } } static int findMaxMultiples ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = arr . Length ; Console . Write ( findMaxMultiples ( arr , n ) ) ; } }"}
{"text": "Bilangan cara untuk mencapai akhir matriks dengan bukan | C # pelaksanaan pendekatan; Arahan 3D untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Fungsi untuk mengembalikan kiraan laluan yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "using System ; class GFG { static int n = 3 ; static int maxV = 20 ; static int [ , , ] dp = new int [ n , n , maxV ] ; static int [ , , ] v = new int [ n , n , maxV ] ; static int countWays ( int i , int j , int x , int [ , ] arr ) { if ( i == n j == n ) { return 0 ; } x = ( x & arr [ i , j ] ) ; if ( x == 0 ) { return 0 ; } if ( i == n - 1 && j == n - 1 ) { return 1 ; } if ( v [ i , j , x ] == 1 ) { return dp [ i , j , x ] ; } v [ i , j , x ] = 1 ; dp [ i , j , x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i , j , x ] ; } public static void Main ( ) { int [ , ] arr = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; Console . WriteLine ( countWays ( 0 , 0 , arr [ 0 , 0 ] , arr ) ) ; } }"}
{"text": "Jumlah maksimum dari tiga tatasusunan yang memilih unsur -unsur berturut -turut dari yang sama tidak dibenarkan | C # Program untuk pendekatan di atas; Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Sudah dikunjungi; Jika elemen telah diambil dari array pertama dalam langkah sebelumnya; Jika elemen telah diambil dari array kedua dalam langkah sebelumnya; Jika elemen telah diambil dari array ketiga dalam langkah sebelumnya; Kod pemacu; Pilih elemen dari array pertama; Pilih elemen dari array kedua; Pilih elemen dari array ketiga; Cetak maksimum mereka", "code": "using System ; class GFG { static int N = 3 ; static int FindMaximumSum ( int ind , int kon , int [ ] a , int [ ] b , int [ ] c , int n , int [ , ] dp ) { if ( ind == n ) return 0 ; if ( dp [ ind , kon ] != - 1 ) return dp [ ind , kon ] ; int ans = ( int ) ( - 1e9 + 5 ) ; if ( kon == 0 ) { ans = Math . Max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . Max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = Math . Max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . Max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = Math . Max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . Max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind , kon ] = ans ; } public static void Main ( ) { int [ ] a = { 6 , 8 , 2 , 7 , 4 , 2 , 7 } ; int [ ] b = { 7 , 8 , 5 , 8 , 6 , 3 , 5 } ; int [ ] c = { 8 , 3 , 2 , 6 , 8 , 4 , 1 } ; int n = a . Length ; int [ , ] dp = new int [ n , N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i , j ] = - 1 ; } } int x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ; int y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ; int z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ; Console . WriteLine ( Math . Max ( x , Math . Max ( y , z ) ) ) ; } }"}
{"text": "Bilangan cara untuk membuat rentetan panjang panjang n sedemikian rupa sehingga 0 s sentiasa berlaku bersama dalam kumpulan saiz k | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan tidak ada cara untuk membina rentetan panjang binari sehingga 0 s selalu berlaku dalam kumpulan saiz k; Kod pemacu", "code": "using System ; class GFG { static int mod = 1000000007 ; static int noOfBinaryStrings ( int N , int k ) { int [ ] dp = new int [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } public static void Main ( ) { int N = 4 ; int K = 2 ; Console . WriteLine ( noOfBinaryStrings ( N , K ) ) ; } }"}
{"text": "Bilangan cara untuk memasangkan orang | C # Program untuk mencari bilangan cara untuk memasangkan orang dalam pesta; Berfungsi untuk mencari bilangan cara untuk memasangkan orang dalam parti; Untuk menyimpan jumlah cara. ; Menggunakan kiraan cari yang ditakrifkan berulang untuk nilai yang berbeza p. ; Kod pemacu", "code": "using System ; class GFG { public static int findWaysToPair ( int p ) { int [ ] dp = new int [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } public static void Main ( string [ ] args ) { int p = 3 ; Console . WriteLine ( findWaysToPair ( p ) ) ; } }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pelaksanaan rekursif mudah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; kes asas; Untuk kes n> 2; Kod pemacu", "code": "using System ; class GFG { static int CountWays ( int n ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( CountWays ( n ) ) ; } }"}
{"text": "Nombor pelik | C # Program untuk memeriksa sama ada nombor itu pelik atau tidak; Kod untuk mencari semua faktor nombor tidak termasuk nombor itu sendiri; Senaraikan untuk menyimpan faktor -faktor; Perhatikan bahawa gelung ini berjalan sehingga sqrt (n); jika nilai saya adalah faktor; Keadaan untuk memeriksa pembahagi bukan nombor itu sendiri; mengembalikan senarai; Berfungsi untuk memeriksa sama ada nombor itu banyak atau tidak; Cari pembahagi menggunakan fungsi; Jumlah semua faktor; Periksa banyak atau tidak; Berfungsi untuk memeriksa sama ada nombor itu separuh - sempurna atau tidak; Cari pembahagi; menyusun senarai; subset untuk memeriksa sama ada tidak semiperfect; memulakan lajur 1 st untuk benar; memulakan baris 1 st kecuali kedudukan sifar ke 0; gelung untuk mencari sama ada nombor itu semiperfect; pengiraan untuk memeriksa sama ada nombor itu boleh dibuat dengan penjumlahan pembahagi; jika tidak mungkin untuk membuat nombor dengan gabungan mana -mana pembahagi; Berfungsi untuk memeriksa pelik atau tidak; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static List < int > factors ( int n ) { List < int > v = new List < int > ( ) ; v . Add ( 1 ) ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . Add ( i ) ; if ( n / i != i ) { v . Add ( n / i ) ; } } } return v ; } static Boolean checkAbundant ( int n ) { List < int > v ; int sum = 0 ; v = factors ( n ) ; for ( int i = 0 ; i < v . Count ; i ++ ) { sum += v [ i ] ; } if ( sum > n ) return true ; else return false ; } static Boolean checkSemiPerfect ( int n ) { List < int > v ; v = factors ( n ) ; v . Sort ( ) ; int r = v . Count ; Boolean [ , ] subset = new Boolean [ r + 1 , n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i , 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 , i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i , j ] = subset [ i - 1 , j ] ; else { subset [ i , j ] = subset [ i - 1 , j ] || subset [ i - 1 , j - v [ i - 1 ] ] ; } } } if ( ( subset [ r , n ] ) == false ) return false ; else return true ; } static Boolean checkweird ( int n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; } public static void Main ( String [ ] args ) { int n = 70 ; if ( checkweird ( n ) ) Console . WriteLine ( \" Weird ▁ Number \" ) ; else Console . WriteLine ( \" Not ▁ Weird ▁ Number \" ) ; } }"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | C # Program untuk mencetak jumlah array bersebelahan terbesar apabila array dicipta selepas menggabungkan kali array kecil. ; Mengembalikan jumlah maksimum subarray yang dibuat selepas menggabungkan [0 .. n - 1] k kali. ; Di sinilah ia berbeza dari algoritma Kadane. Kami menggunakan aritmetik modular untuk mencari elemen seterusnya. ; Kod pemacu", "code": "using System ; class GFG { static int maxSubArraySumRepeated ( int [ ] a , int n , int k ) { int max_so_far = 0 ; int max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } public static void Main ( ) { int [ ] a = { 10 , 20 , - 30 , - 1 } ; int n = a . Length ; int k = 3 ; Console . Write ( \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" + maxSubArraySumRepeated ( a , n , k ) ) ; } }"}
{"text": "Terpanjang peningkatan ganjil walaupun berikutnya | C # pelaksanaan untuk mencari peningkatan yang paling lama walaupun seterusnya; berfungsi untuk mencari peningkatan yang paling lama walaupun seterusnya; lioes [i] menyimpan paling lama meningkatkan ganjil walaupun berikutnya yang berakhir di arr [i]; untuk menyimpan panjang yang paling lama meningkat ganjil walaupun berikutnya; Memulakan nilai lio untuk semua indeks; Mengira nilai lio yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai lio; panjang maksimum yang diperlukan; fungsi pemacu", "code": "using System ; class GFG { public static int longOddEvenIncSeq ( int [ ] arr , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = 10 ; Console . Write ( \" Longest ▁ Increasing ▁ Odd \" + \" ▁ Even ▁ Subsequence : ▁ \" + longOddEvenIncSeq ( arr , n ) ) ; } }"}
{"text": "Nilai minimum dan maksimum ungkapan dengan * dan + | C # Program untuk mendapatkan nilai maksimum dan minimum ungkapan; Kaedah utiliti untuk memeriksa sama ada watak adalah pengendali atau tidak; kaedah mencetak nilai minimum dan maksimum yang boleh diperolehi daripada ungkapan; pengendali kedai dan nombor dalam vektor yang berbeza; menyimpan nombor terakhir dalam vektor; memulakan array Minval dan Maxval 2D; memulakan pepenjuru utama dengan nilai NUM; Looping serupa dengan pendaraban rantai matriks dan mengemas kini kedua -dua tatasusunan 2D; Jika pengendali semasa adalah ' +', mengemas kini pembolehubah TMP dengan tambahan; Jika pengendali semasa adalah ' *', mengemas kini pembolehubah TMP dengan pendaraban; mengemas kini nilai array oleh pembolehubah TMP; Elemen terakhir baris pertama akan menyimpan hasilnya; Kod pemacu untuk menguji kaedah di atas", "code": "using System ; using System . Collections . Generic ; public class GFG { static bool isOperator ( char op ) { return ( op == ' + ' op == ' * ' ) ; } static void printMinAndMaxValueOfExp ( string exp ) { List < int > num = new List < int > ( ) ; List < char > opr = new List < char > ( ) ; string tmp = \" \" ; for ( int i = 0 ; i < exp . Length ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . Add ( exp [ i ] ) ; num . Add ( int . Parse ( tmp ) ) ; tmp = \" \" ; } else { tmp += exp [ i ] ; } } num . Add ( int . Parse ( tmp ) ) ; int len = num . Count ; int [ , ] minVal = new int [ len , len ] ; int [ , ] maxVal = new int [ len , len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i , j ] = Int32 . MaxValue ; maxVal [ i , j ] = 0 ; if ( i == j ) { minVal [ i , j ] = maxVal [ i , j ] = num [ i ] ; } } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == ' + ' ) { minTmp = minVal [ i , k ] + minVal [ k + 1 , j ] ; maxTmp = maxVal [ i , k ] + maxVal [ k + 1 , j ] ; } else if ( opr [ k ] == ' * ' ) { minTmp = minVal [ i , k ] * minVal [ k + 1 , j ] ; maxTmp = maxVal [ i , k ] * maxVal [ k + 1 , j ] ; } if ( minTmp < minVal [ i , j ] ) minVal [ i , j ] = minTmp ; if ( maxTmp > maxVal [ i , j ] ) maxVal [ i , j ] = maxTmp ; } } } Console . Write ( \" Minimum ▁ value ▁ : ▁ \" + minVal [ 0 , len - 1 ] + \" , ▁ Maximum ▁ value ▁ : ▁ \" + maxVal [ 0 , len - 1 ] ) ; } static public void Main ( ) { string expression = \"1 + 2*3 + 4*5\" ; printMinAndMaxValueOfExp ( expression ) ; } }"}
{"text": "Pendaraban rantai matriks | DP | C # kod untuk pelaksanaan rekursif naif yang hanya mengikuti harta substruktur yang optimum di atas; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu", "code": "using System ; class GFG { static int MatrixChainOrder ( int [ ] p , int i , int j ) { if ( i == j ) return 0 ; int min = int . MaxValue ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 , 3 } ; int n = arr . Length ; Console . Write ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , 1 , n - 1 ) ) ; } }"}
{"text": "Pendaraban rantai matriks | DP | C # Program menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "using System ; class GFG { static int [ , ] dp = new int [ 100 , 100 ] ; static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i , j ] != - 1 ) { return dp [ i , j ] ; } dp [ i , j ] = Int32 . MaxValue ; for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i , j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { dp [ i , j ] = - 1 ; } } Console . WriteLine ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + MatrixChainOrder ( arr , n ) ) ; } }"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit A dan B yang ditetapkan dalam kedua -dua mereka; Kosongkan bit A yang ditetapkan dalam kedua -dua A dan B; Kosongkan bit B yang ditetapkan dalam kedua -dua A dan B; Cetak dikemas kini A dan B; Kod pemacu", "code": "using System ; class GFG { static void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; Console . Write ( A + \" ▁ \" + B ) ; } public static void Main ( String [ ] args ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; } }"}
{"text": "Jumlah perbezaan perbezaan nombor berturut -turut dari 0 hingga n | Tetapkan 2 | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan jarak Hamming antara semua nombor berturut -turut dari 0 hingga n; Kod pemacu", "code": "using System ; class GFG { static int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } public static void Main ( ) { int N = 9 ; Console . Write ( TotalHammingDistance ( N ) ) ; } }"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Set 3 | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari jumlah semua pembahagi semua nombor dari 1 hingga n; Menyimpan jumlah; Menandakan titik terakhir kejadian dengan kiraan yang sama; Kirakan jumlahnya; Mengembalikan hasilnya; Kod pemacu", "code": "using System ; class GFG { static readonly int m = 1000000007 ; static void solve ( long n ) { long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = ( int ) ( n / ( Math . Floor ( ( double ) n / l ) ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( int ) ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } Console . Write ( ( s + m ) % m ) ; } public static void Main ( String [ ] args ) { long n = 12 ; solve ( n ) ; } }"}
{"text": "Kurangkan bilangan luka yang diperlukan untuk memecahkan panjang n tongkat ke dalam n unit panjang tongkat | C # Program untuk mencari masa minimum yang diperlukan untuk memecah tongkat panjang N ke dalam kepingan unit; Berfungsi untuk mengembalikan masa minimum yang diperlukan untuk memecah tongkat n ke dalam kepingan unit; Mengembalikan unit minimum masa yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ( int ) Math . Ceiling ( Math . Log ( N ) / Math . Log ( 2 ) ) ; } public static void Main ( ) { int N = 100 ; Console . Write ( min_time_to_cut ( N ) ) ; } }"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | C # Pelaksanaan untuk mengira jumlah pasangan yang berbeza antara dua array dengan nilai 1 hingga n; Berfungsi untuk mencari jumlah yang berbeza; Tetapkan untuk menyimpan jumlah yang berbeza; Memasukkan setiap jumlah; Kembali jumlah yang berbeza; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int findDistinctSums ( int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . Add ( i + j ) ; } } return s . Count ; } public static void Main ( String [ ] args ) { int N = 3 ; Console . Write ( findDistinctSums ( N ) ) ; } }"}
{"text": "Cetak Segitiga Terasing Corak | C # Program untuk mencetak corak terpisah segitiga menggunakan watak bintang dan slash; Berfungsi untuk mencetak corak secara rekursif; Kes asas; Syarat untuk mencetak slash; Keadaan untuk mencetak slash forword; Keadaan untuk mencetak slash ke belakang; Lain cetak ' *'; Panggilan rekursif untuk baris; Panggilan rekursif untuk menukar baris; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { Console . Write ( \" / \" ) ; } else { Console . Write ( \" \\ \\\" ) ; } } else { Console . Write ( \" * \" ) ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } Console . WriteLine ( ) ; return printPattern ( i + 1 , 0 , n ) ; } public static void Main ( String [ ] args ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; } }"}
{"text": "Cari indeks permulaan untuk setiap kejadian array yang diberikan b dalam array A menggunakan z | C # Pelaksanaan untuk mencari corak dalam array menggunakan Z - algoritma; Fungsi untuk mengira z - array; Gelung untuk mengira z - array; Di luar kotak z; Di dalam z - kotak; Fungsi penolong untuk menggabungkan dua tatasusunan dan membuat satu array; Array untuk menyimpan array yang digabungkan; Menyalin Array B; Menambah pemisah; Menyalin Array A; Memanggil Z - Fungsi; Fungsi untuk membantu mengira array Z; Indeks percetakan di mana array b berlaku; Kod pemacu", "code": "using System ; class GfG { private static int [ ] zArray ( int [ ] arr ) { int [ ] z ; int n = arr . Length ; z = new int [ n ] ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } private static int [ ] mergeArray ( int [ ] A , int [ ] B ) { int n = A . Length ; int m = B . Length ; int [ ] z ; int [ ] c = new int [ n + m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } private static void findZArray ( int [ ] A , int [ ] B , int n ) { int flag = 0 ; int [ ] z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . Length ; i ++ ) { if ( z [ i ] == n ) { Console . Write ( ( i - n - 1 ) + \" ▁ \" ) ; flag = 1 ; } } if ( flag == 0 ) { Console . WriteLine ( \" Not ▁ Found \" ) ; } } public static void Main ( ) { int [ ] A = { 1 , 2 , 3 , 2 , 3 , 2 } ; int [ ] B = { 2 , 3 } ; int n = B . Length ; findZArray ( A , B , n ) ; } }"}
{"text": "Semak jika rentetan boleh diulang untuk membuat rentetan lain | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan pengulangan String A untuk menjana rentetan b; Jika B tidak dapat dihasilkan dengan mengulangi A; Ulangi jumlah kiraan; Kod pemacu", "code": "using System ; class GfG { static int getCount ( String a , String b ) { if ( b . Length % a . Length != 0 ) return - 1 ; int count = b . Length / a . Length ; String str = \" \" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . Equals ( b ) ) return count ; return - 1 ; } public static void Main ( String [ ] args ) { String a = \" geeks \" ; String b = \" geeksgeeks \" ; Console . WriteLine ( getCount ( a , b ) ) ; } }"}
{"text": "Semak jika rentetan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan | C # Program untuk memeriksa sama ada rentetan yang diberikan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan; Fungsi untuk memeriksa sama ada S2 boleh dibentuk dari S1; panjang rentetan; Hash - Jadual untuk menyimpan kiraan; menyimpan kiraan setiap watak; melintasi dan memeriksa setiap watak; Jika watak S2 hadir dalam S1; Jika watak S2 tidak hadir dalam S1, maka periksa sama ada dua aksara ASCII terdahulu hadir dalam S1; Kod pemacu; Fungsi panggilan untuk memeriksa", "code": "using System ; using System . Collections . Generic ; class GFG { static bool check ( String S1 , String S2 ) { int n1 = S1 . Length ; int n2 = S2 . Length ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . ContainsKey ( ( int ) S1 [ i ] ) ) { mp [ ( int ) S1 [ i ] ] = mp [ ( int ) S1 [ i ] ] + 1 ; } else { mp . Add ( ( int ) S1 [ i ] , 1 ) ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . ContainsKey ( ( int ) S2 [ i ] ) ) { mp [ ( int ) S2 [ i ] ] = mp [ ( int ) S2 [ i ] ] - 1 ; } else if ( mp . ContainsKey ( S2 [ i ] - 1 ) && mp . ContainsKey ( S2 [ i ] - 2 ) ) { mp [ S2 [ i ] - 1 ] = mp [ S2 [ i ] - 1 ] - 1 ; mp [ S2 [ i ] - 2 ] = mp [ S2 [ i ] - 2 ] - 1 ; } else { return false ; } } return true ; } public static void Main ( String [ ] args ) { String S1 = \" abbat \" ; String S2 = \" cat \" ; if ( check ( S1 , S2 ) ) Console . Write ( \" YES \" ) ; else Console . Write ( \" NO \" ) ; } }"}
{"text": "Count kejadian corak \"1 (0 +) 1\" dalam rentetan | C # Program untuk mengira bilangan kali corak berlaku dalam rentetan yang diberikan; Mengembalikan kiraan kejadian \"1 (0 +) 1\" int str. ; int count = 0; Memulakan hasil; Semak jika ditemui '1' membentuk corak yang sah seperti yang ditentukan; jika 1 ditemui untuk pertama kali ditetapkan satu ke 1; Semak jika terdapat watak lain selain daripada '0' atau '1'. Jika demikian kemudian tetapkan Oneseen hingga 0 untuk mencari lagi untuk corak baru; Kod pemacu", "code": "using System ; class GFG { public static int countPattern ( string str ) { int len = str . Length ; bool oneSeen = false ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str [ i ] ; if ( getChar == '1' && oneSeen == true ) { if ( str [ i - 1 ] == '0' ) { count ++ ; } } if ( getChar == '1' && oneSeen == false ) { oneSeen = true ; } if ( getChar != '0' && str [ i ] != '1' ) { oneSeen = false ; } } return count ; } public static void Main ( string [ ] args ) { string str = \"100001abc101\" ; Console . WriteLine ( countPattern ( str ) ) ; } }"}
{"text": "Tukar rentetan yang diberikan ke dalam T dengan menggantikan aksara di antara rentetan sebilangan kali | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua rentetan sama dengan rentetan t; Menyimpan kekerapan semua rentetan dalam array arr []; Menyimpan kekerapan rentetan t; Melangkah ke atas watak -watak rentetan t; Melangkah dalam julat [0, n - 1]; Melangkah ke atas watak -watak rentetan arr [i]; Jika freqt [i] adalah 0 dan freqs [i] bukan 0; Jika freqs [i] adalah 0 dan freqt [i] bukan 0; Jika freqs [i] bukan freqt [i] * n; Jika tidak, kembalikan \"ya\"; Kod pemacu", "code": "using System ; public class GFG { static string checkIfPossible ( int N , string [ ] arr , string T ) { int [ ] freqS = new int [ 256 ] ; int [ ] freqT = new int [ 256 ] ; foreach ( char ch in T . ToCharArray ( ) ) { freqT [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { foreach ( char ch in arr [ i ] . ToCharArray ( ) ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return \" No \" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return \" No \" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return \" No \" ; } } return \" Yes \" ; } public static void Main ( string [ ] args ) { string [ ] arr = { \" abc \" , \" abb \" , \" acc \" } ; string T = \" abc \" ; int N = arr . Length ; Console . WriteLine ( checkIfPossible ( N , arr , T ) ) ; } }"}
{"text": "Count kumpulan berturut -turut 1 s dalam rentetan binari yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan kumpulan 1 s hanya dalam rentetan binari; Kedai bilangan kumpulan 1 s; Permulaan timbunan; Melintasi rentetan s; Jika s [i] adalah '1'; Jika tidak; Jika St kosong; Jika ST tidak kosong; Jawapan kembali; Kod pemacu; Input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int groupsOfOnes ( string S , int N ) { int count = 0 ; Stack < int > st = new Stack < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) st . Push ( 1 ) ; else { if ( st . Count > 0 ) { count ++ ; while ( st . Count > 0 ) { st . Pop ( ) ; } } } } if ( st . Count > 0 ) count ++ ; return count ; } public static void Main ( ) { string S = \"100110111\" ; int N = S . Length ; Console . Write ( groupsOfOnes ( S , N ) ) ; } }"}
{"text": "Palindromic Strings of Length 3 mungkin dengan menggunakan aksara rentetan yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak semua rentetan palindromik panjang 3 yang boleh dibentuk menggunakan aksara rentetan s; Menyimpan kiraan watak; Melintasi rentetan s; Menyimpan semua rentetan palindromik; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Jika hash [ch] sama dengan 2; Melangkah ke atas watak -watak di atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Tolak S ke set st; Jika hash [i] lebih besar daripada atau sama dengan 3; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Jika hash [j] positif; Tolak s ke set st; Melangkah ke atas set; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void generatePalindrome ( string S ) { Dictionary < char , int > Hash = new Dictionary < char , int > ( ) ; foreach ( char ch in S ) { if ( Hash . ContainsKey ( ch ) ) Hash [ ch ] ++ ; else Hash . Add ( ch , 1 ) ; } HashSet < string > st = new HashSet < string > ( ) ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( Hash . ContainsKey ( i ) && Hash [ i ] == 2 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = \" \" ; if ( Hash . ContainsKey ( j ) && i != j ) { s += i ; s += j ; s += i ; st . Add ( s ) ; } } } if ( Hash . ContainsKey ( i ) && Hash [ i ] >= 3 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = \" \" ; if ( Hash . ContainsKey ( j ) ) { s += i ; s += j ; s += i ; st . Add ( s ) ; } } } } foreach ( string ans in st ) { Console . WriteLine ( ans ) ; } } public static void Main ( ) { string S = \" ddabdac \" ; generatePalindrome ( S ) ; } }"}
{"text": "Mengira kejadian substring x sebelum setiap kejadian substring y dalam rentetan yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira kejadian rentetan y dalam rentetan s untuk setiap kejadian x dalam s; Menyimpan kiraan kejadian x; Menyimpan panjang tiga rentetan; Melintasi rentetan s; Jika substring semasa adalah y, maka kenaikan nilai kiraan sebanyak 1; Jika substring semasa adalah x, maka cetak kiraan; Kod pemacu", "code": "using System ; public class GFG { static void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . Length , A = X . Length ; int B = Y . Length ; int P = Math . Min ( A , Math . Min ( N , B ) ) ; for ( int i = 0 ; i < N - P + 1 ; i ++ ) { if ( S . Substring ( i , Math . Min ( N , B ) ) . Equals ( Y ) ) count ++ ; if ( S . Substring ( i , Math . Min ( N , A ) ) . Equals ( X ) ) Console . Write ( count + \" ▁ \" ) ; } } public static void Main ( string [ ] args ) { string S = \" abcdefdefabc \" ; string X = \" abc \" ; string Y = \" def \" ; countOccurrences ( S , X , Y ) ; } }"}
{"text": "Program untuk membina DFA untuk ungkapan biasa C (A + B) + | C # Program untuk pendekatan di atas; Fungsi untuk mencari sama ada rentetan yang diberikan diterima oleh DFA; Jika n <= 1, maka cetak tidak; Untuk mengira watak yang dipadankan; Semak jika watak pertama adalah c; Melintasi seluruh rentetan; Jika watak adalah A atau B, kiraan kenaikan sebanyak 1; Jika watak pertama tidak C, cetak - 1; Jika semua watak sepadan; Kod pemacu", "code": "using System ; class GFG { static void DFA ( string str , int N ) { if ( N <= 1 ) { Console . Write ( \" No \" ) ; return ; } int count = 0 ; if ( str [ 0 ] == ' C ' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == ' A ' str [ i ] == ' B ' ) count ++ ; else break ; } } else { Console . Write ( \" No \" ) ; return ; } if ( count == N ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } static public void Main ( ) { string str = \" CAABBAAB \" ; int N = str . Length ; DFA ( str , N ) ; } }"}
{"text": "Bilangan minimum dan maksimum digit yang diperlukan untuk dikeluarkan untuk membuat nombor tertentu dibahagikan dengan 3 | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum dan minimum digit yang akan dikeluarkan untuk menjadikan STR dibahagikan dengan 3; Tukar rentetan ke dalam pelbagai digit; Kiraan 0 s, 1 s, dan 2 s; Melintasi array; Cari jumlah digit % 3; Kes untuk mencari bilangan minimum digit yang akan dikeluarkan; Kes untuk mencari bilangan maksimum digit yang akan dikeluarkan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void minMaxDigits ( string str , int N ) { int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { Console . Write ( 0 + \" ▁ \" ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) Console . Write ( 1 + \" ▁ \" ) ; else if ( two > 1 && N > 2 ) Console . Write ( 2 + \" ▁ \" ) ; else Console . Write ( - 1 + \" ▁ \" ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) Console . Write ( 1 + \" ▁ \" ) ; else if ( one > 1 && N > 2 ) Console . Write ( 2 + \" ▁ \" ) ; else Console . Write ( - 1 + \" ▁ \" ) ; } if ( zero > 0 ) Console . Write ( N - 1 + \" ▁ \" ) ; else if ( one > 0 && two > 0 ) Console . Write ( N - 2 + \" ▁ \" ) ; else if ( one > 2 two > 2 ) Console . Write ( N - 3 + \" ▁ \" ) ; else Console . Write ( - 1 + \" ▁ \" ) ; } public static void Main ( ) { string str = \"12345\" ; int N = str . Length ; minMaxDigits ( str , N ) ; } }"}
{"text": "Penggantian minimum diperlukan untuk mendapatkan k | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum perubahan untuk membuat rentetan k - berkala dan palindrome; Memulakan ans dengan 0; Berulang dari 0 hingga (k + 1) / 2; Frekuensi penyimpanan watak; Melewati semua indeks, i, i + k, i + 2 k .... dan menyimpan kekerapan watak; Meningkatkan kekerapan watak semasa; Melewati semua indeks k - i, 2 k - i, 3 ​​k - i .... dan menyimpan kekerapan watak; Jika k adalah ganjil & i adalah samw sebagai k / 2, pecahkan gelung; Meningkatkan kekerapan watak semasa; Cari kekerapan maksimum watak di antara semua watak yang dikunjungi; Jika K adalah ganjil dan saya sama dengan K / 2 maka, hanya aksara N / K yang dikunjungi; Jika tidak, n / k * 2 aksara telah melawat; Mengembalikan hasilnya; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int findMinimumChanges ( int N , int K , char [ ] S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( int j = i ; j < N ; j += K ) { if ( mp . ContainsKey ( S [ j ] ) ) { mp [ S [ j ] ] ++ ; } else { mp . Add ( S [ j ] , 1 ) ; } } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K % 2 == 1 && i == K / 2 ) break ; if ( mp . ContainsKey ( S [ j ] ) ) { mp [ S [ j ] ] ++ ; } else { mp . Add ( S [ j ] , 1 ) ; } } int curr_max = int . MinValue ; foreach ( KeyValuePair < char , int > p in mp ) { curr_max = Math . Max ( curr_max , p . Value ) ; } if ( ( K % 2 == 1 ) && i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; } public static void Main ( String [ ] args ) { String S = \" aabbcbbcb \" ; int N = S . Length ; int K = 3 ; Console . Write ( findMinimumChanges ( N , K , S . ToCharArray ( ) ) ) ; } }"}
{"text": "Semak sama ada rentetan mengandungi sebarang indeks dengan lebih banyak daripada aktif aktif k | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mana -mana indeks mengandungi lebih banyak daripada ak aktif aktif; Simpan kejadian terakhir setiap watak dalam peta. ; Menyimpan watak aktif; Masukkan watak; Jika saiz set melebihi k; Keluarkan watak dari set jika saya adalah indeks terakhir watak semasa; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static String checkString ( String s , int K ) { int n = s . Length ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( s [ i ] ) ) mp [ s [ i ] ] = i ; else mp . Add ( s [ i ] , i ) ; } int f = 0 ; HashSet < char > st = new HashSet < char > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { st . Add ( s [ i ] ) ; if ( st . Count > K ) { f = 1 ; break ; } if ( mp [ s [ i ] ] == i ) st . Remove ( s [ i ] ) ; } return ( f == 1 ? \" Yes \" : \" No \" ) ; } public static void Main ( String [ ] args ) { String s = \" aabbcdca \" ; int k = 2 ; Console . WriteLine ( checkString ( s , k ) ) ; } }"}
{"text": "Kira bilangan rentetan dalam array yang wataknya berbeza kurang daripada m | C # pelaksanaan untuk mengira bilangan rentetan dalam array yang wataknya yang berbeza kurang daripada atau sama dengan m; Fungsi untuk mengira rentetan yang dikira watak -watak yang berbeza kurang daripada m; Gelung untuk melangkah ke atas semua rentetan array; Watak yang berbeza dalam rentetan dengan bantuan set; Memeriksa jika kurang daripada atau sama dengan m; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static void distinct ( string [ ] S , int M ) { int count = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) { HashSet < char > set = new HashSet < char > ( ) ; for ( int j = 0 ; j < S [ i ] . Length ; j ++ ) { if ( ! set . Contains ( S [ i ] [ j ] ) ) set . Add ( S [ i ] [ j ] ) ; } int c = set . Count ; if ( c <= M ) count += 1 ; } Console . Write ( count ) ; } public static void Main ( string [ ] args ) { string [ ] S = { \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" } ; int M = 7 ; distinct ( S , M ) ; } }"}
{"text": "Keluarkan aksara frekuensi ganjil dari rentetan | C # Program untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Berfungsi untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; Untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi ganjil; Jika watak mempunyai kekerapan ganjil maka langkau; Lain menggabungkan watak ke rentetan baru; Kembalikan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi ganjil", "code": "using System ; using System . Collections . Generic ; class GFG { static string removeOddFrequencyCharacters ( string s ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { char p = s [ i ] ; if ( m . ContainsKey ( p ) ) { m [ p ] ++ ; } else { m [ p ] = 1 ; } } string new_string = \" \" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( m [ s [ i ] ] & 1 ) == 1 ) continue ; new_string += s [ i ] ; } return new_string ; } public static void Main ( string [ ] args ) { string str = \" geeksforgeeks \" ; str = removeOddFrequencyCharacters ( str ) ; Console . Write ( str ) ; } }"}
{"text": "Produk nod di k | C # pelaksanaan untuk mencari produk unsur -unsur di peringkat k - th; Fungsi rekursif untuk mencari produk unsur -unsur di peringkat k - th; Jika subtree adalah batal, sama seperti jika root == null; Pertimbangkan hanya nod tahap untuk menjadi sebahagian daripada produk; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Menjaga ')' selepas subtree kiri dan kanan; Kod pemacu", "code": "using System ; class GFG { static int i ; static int productAtKthLevel ( String tree , int k , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; ++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return int . MinValue ; } public static void Main ( String [ ] args ) { String tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) \" + \" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; i = 0 ; Console . Write ( productAtKthLevel ( tree , k , 0 ) ) ; } }"}
{"text": "Cetak watak yang paling berlaku dalam pelbagai rentetan | C # Program untuk mencetak watak yang paling berlaku dalam pelbagai rentetan; Berfungsi untuk mencetak watak yang paling banyak berlaku; Mewujudkan hash saiz 26; Untuk gelung untuk melangkah melalui setiap rentetan array; Untuk gelung untuk melangkah melalui setiap watak rentetan; Meningkatkan kiraan watak dalam hash; Mencari watak dengan kiraan maksimum; Kod pemacu; Mengisytiharkan vektor jenis rentetan", "code": "using System ; class GFG { static void findMostOccurringChar ( string [ ] str ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < str . Length ; i ++ ) { for ( int j = 0 ; j < str [ i ] . Length ; j ++ ) { hash [ str [ i ] [ j ] - 97 ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } Console . Write ( ( char ) ( max + 97 ) + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { string [ ] str = { \" animal \" , \" zebra \" , \" lion \" , \" giraffe \" } ; findMostOccurringChar ( str ) ; } }"}
{"text": "Semak sama ada nombor titik terapung yang diberikan adalah palindrome | C # pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika NUM adalah palindrome; Tukar nombor titik terapung yang diberikan ke dalam rentetan; Penunjuk menunjuk kepada watak pertama dan terakhir rentetan; Bukan palindrome; Mengemas kini petunjuk; Kod pemacu", "code": "using System ; class GFG { public static bool isPalindrome ( float num ) { string s = num . ToString ( ) ; int low = 0 ; int high = s . Length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; } public static void Main ( ) { float n = 123.321f ; if ( isPalindrome ( n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Bilangan maksimum kali str1 muncul sebagai bukan | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan bilangan maksimum kali STR1 boleh muncul sebagai substring yang tidak bertindih dalam STR2; STR1 tidak boleh menjadi substring str2; Simpan kekerapan watak Str1; Simpan kekerapan watak Str2; Untuk menyimpan kiraan substring yang diperlukan; Watak semasa tidak muncul dalam str1; Kekerapan watak semasa dalam Str1 adalah lebih besar daripada kekerapannya dalam Str2; Mengemas kini kiraan substrings yang mungkin; Kod pemacu", "code": "using System ; class GFG { readonly static int MAX = 26 ; static int maxSubStr ( char [ ] str1 , int len1 , char [ ] str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int [ ] freq1 = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ i ] = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int [ ] freq2 = new int [ MAX ] ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ i ] = 0 ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = int . MaxValue ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = Math . Min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; } public static void Main ( String [ ] args ) { String str1 = \" geeks \" , str2 = \" gskefrgoekees \" ; int len1 = str1 . Length ; int len2 = str2 . Length ; Console . WriteLine ( maxSubStr ( str1 . ToCharArray ( ) , len1 , str2 . ToCharArray ( ) , len2 ) ) ; } }"}
{"text": "Bilangan cara untuk memasukkan dua pasang kurungan ke dalam rentetan aksara n | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk memasukkan pasangan kurungan; Kod pemacu", "code": "using System ; class GFG { static int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } public static void Main ( String [ ] args ) { String str = \" ab \" ; int n = str . Length ; Console . WriteLine ( cntWays ( str , n ) ) ; } }"}
{"text": "Bilangan minimum substrings rentetan yang diberikan boleh dibuang ke dalam yang memenuhi syarat -syarat yang diberikan | C # pelaksanaan pendekatan di atas; Tetapkan untuk menyimpan semua rentetan dari array yang diberikan; Untuk menyimpan kiraan yang diperlukan; Fungsi rekursif untuk mencari kiraan substrings yang boleh dibahagikan bermula dari indeks permulaan supaya semua substrings hadir dalam peta; Semua substring yang dipilih hadir dalam peta; Mengemas kini kiraan minimum substring; Bermula dari substrings panjang 1 yang bermula dengan indeks yang diberikan; Dapatkan substring; Jika substring hadir dalam set; Panggilan rekursif untuk sisa rentetan; Fungsi yang memasukkan semua rentetan dari array yang diberikan dalam satu set dan memanggil fungsi rekursif untuk mencari kiraan minimum substrings STR boleh dibuang ke dalam yang memenuhi syarat yang diberikan; Masukkan semua rentetan dari array yang diberikan dalam satu set; Cari kiraan yang diperlukan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static HashSet < String > uSet = new HashSet < String > ( ) ; static int minCnt = int . MaxValue ; static void findSubStr ( String str , int cnt , int start ) { if ( start == str . Length ) { minCnt = Math . Min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . Length - start ) ; len ++ ) { String subStr = str . Substring ( start , len ) ; if ( uSet . Contains ( subStr ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } } static void findMinSubStr ( String [ ] arr , int n , String str ) { for ( int i = 0 ; i < n ; i ++ ) uSet . Add ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; } public static void Main ( String [ ] args ) { String str = \"123456\" ; String [ ] arr = { \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" } ; int n = arr . Length ; findMinSubStr ( arr , n , str ) ; Console . WriteLine ( minCnt ) ; } }"}
{"text": "Bilangan substring yang bermula dengan \"geeks\" dan berakhir dengan \"untuk\" | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan substring yang diperlukan; Untuk setiap indeks rentetan; Jika substring bermula pada indeks semasa adalah \"geeks\"; Jika substring adalah \"untuk\"; Kod pemacu", "code": "using System ; public class GFG { static int countSubStr ( String s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 5 && \" geeks \" . Equals ( s . Substring ( i , 5 ) ) ) { c1 ++ ; } if ( i < n - 3 && \" for \" . Equals ( s . Substring ( i , 3 ) ) ) { c2 = c2 + c1 ; } } return c2 ; } public static void Main ( String [ ] args ) { String s = \" geeksforgeeksisforgeeks \" ; int n = s . Length ; Console . WriteLine ( countSubStr ( s , n ) ) ; } }"}
{"text": "Infytq 2019: Cari kedudukan dari mana kurungan tidak seimbang | C # pelaksanaan pendekatan; Menentukan rentetan; Menyimpan pendakap pembukaan dalam senarai LST1; Menyimpan pendakap penutup dalam senarai LST2; Mewujudkan senarai kosong LST; Mewujudkan kamus untuk memetakan pendakap penutup untuk membuka; Jika kedudukan pertama rentetan mengandungi sebarang pendakap penutup kembali 1; Jika watak -watak rentetan membuka pendakap maka masukkannya ke dalam senarai; Apabila saiz senarai adalah 0 dan pendakap penutup baru ditemui kemudian cetak indeksnya bermula dari 1; Ketika kami menemui pendakap penutup, kami memetakan mereka dengan pendakap pembukaan yang sesuai dengan menggunakan kamus dan periksa sama ada ia sama dengan pendakap yang dibuka terakhir (elemen terakhir dalam senarai) jika ya maka kami memadamkan elemt dari senarai; Jika tidak, kami mengembalikan indeks (bermula dari 1) di mana bersarang didapati salah; Pada akhir jika senarai kosong itu bermaksud rentetan bersarang dengan sempurna", "code": "using System ; using System . Collections . Generic ; class GFG { static void Main ( ) { string String = \" { [ ( ) ] } [ ] \" ; char [ ] lst1 = { ' { ' , ' ( ' , ' [ ' } ; char [ ] lst2 = { ' } ' , ' ) ' , ' ] ' } ; List < char > lst = new List < char > ( ) ; Dictionary < char , char > Dict = new Dictionary < char , char > ( ) ; Dict [ ' ) ' ] = ' ( ' ; Dict [ ' } ' ] = ' { ' ; Dict [ ' ] ' ] = ' [ ' ; int a = 0 , b = 0 , c = 0 ; if ( Array . Exists ( lst2 , element => element == String [ 0 ] ) ) { Console . WriteLine ( 1 ) ; } else { int k = 0 ; for ( int i = 0 ; i < String . Length ; i ++ ) { if ( Array . Exists ( lst1 , element => element == String [ i ] ) ) { lst . Add ( String [ i ] ) ; k = i + 2 ; } else { if ( lst . Count == 0 && Array . Exists ( lst2 , element => element == String [ i ] ) ) { Console . WriteLine ( ( i + 1 ) ) ; c = 1 ; break ; } else { if ( lst . Count > 0 && Dict [ String [ i ] ] == lst [ lst . Count - 1 ] ) { lst . RemoveAt ( lst . Count - 1 ) ; } else { a = 1 ; break ; } } } } if ( lst . Count == 0 && c == 0 ) { Console . WriteLine ( 0 ) ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { Console . WriteLine ( k ) ; } } } }"}
{"text": "Menyulitkan rentetan yang diberikan dengan operasi berikut | C # Pelaksanaan pendekatan di atas :; Berfungsi untuk mengembalikan rentetan yang disulitkan; Kurangkan x kerana putaran panjang 26 tidak perlu; Kirakan kekerapan aksara; Jika kekerapan aksara arus bahkan maka kenaikannya dengan x; Lain menurunkannya dengan x; Mengembalikan kiraan; Kod pemacu", "code": "using System ; class GFG { static int MAX = 26 ; public static char [ ] encryptStr ( String str , int n , int x ) { x = x % MAX ; char [ ] arr = str . ToCharArray ( ) ; int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( arr [ i ] - ' a ' + x ) % MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( arr [ i ] - ' a ' - x ) ; if ( pos < 0 ) pos += MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } } return arr ; } public static void Main ( String [ ] args ) { String s = \" abcda \" ; int n = s . Length ; int x = 3 ; Console . WriteLine ( encryptStr ( s , n , x ) ) ; } }"}
{"text": "Susun semula aksara dalam rentetan supaya tidak ada dua bersebelahan dengan menggunakan hashing | C # pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk menyusun semula watak -watak rentetan supaya tidak dua aksara berturut -turut adalah sama; Untuk menyimpan kekerapan setiap watak; Untuk menyimpan kekerapan maksimum setakat ini; Jika boleh; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static Boolean isPossible ( char [ ] str ) { Dictionary < char , int > freq = new Dictionary < char , int > ( ) ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . Length ) ; j ++ ) { if ( freq . ContainsKey ( str [ j ] ) ) { var v = freq [ str [ j ] ] + 1 ; freq . Remove ( str [ j ] ) ; freq . Add ( str [ j ] , v ) ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } else { freq . Add ( str [ j ] , 1 ) ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } } if ( max_freq <= ( str . Length - max_freq + 1 ) ) return true ; return false ; } public static void Main ( String [ ] args ) { String str = \" geeksforgeeks \" ; if ( isPossible ( str . ToCharArray ( ) ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Cari watak yang tidak biasa dari dua rentetan | Tetapkan 2 | C # pelaksanaan pendekatan; Berfungsi untuk mencetak aksara yang tidak biasa dalam rentetan yang diberikan dalam urutan yang disusun; Menukar watak ke kod ASCII; Operasi bit; Menukar watak ke kod ASCII; Operasi bit; Operasi XOR hanya meninggalkan watak -watak yang tidak biasa dalam pembolehubah ANS; Kod pemacu", "code": "using System ; class GFG { static void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { int ch = ( str1 [ i ] - ' a ' ) ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . Length ; i ++ ) { int ch = ( str2 [ i ] - ' a ' ) ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int j = 0 ; while ( j < 26 ) { if ( ans % 2 == 1 ) { Console . Write ( ( char ) ( ' a ' + j ) ) ; } ans = ans / 2 ; j ++ ; } } public static void Main ( ) { string str1 = \" geeksforgeeks \" ; string str2 = \" geeksquiz \" ; printUncommon ( str1 , str2 ) ; } }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Set | C # Program untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Untuk menyimpan bilangan pembalikan yang diperlukan. ; Untuk menyimpan nombor pendakap pembukaan yang tidak seimbang. ; Untuk menyimpan nombor kurungan penutupan yang tidak seimbang. ; Jika pendakap semasa dibuka maka kenaikan kiraan terbuka. ; Jika pendakap semasa dekat, periksa sama ada mengimbangi pendakap pembukaan. Jika ya maka pengurangan kiraan pendakap pembukaan yang tidak seimbang, lain -lain kenaikan kiraan pendakap penutupan. ; Untuk kes itu: \"} {\" Atau apabila satu penutupan dan satu pendakap pembukaan kekal untuk berpasangan, maka kedua -duanya perlu diterbalikkan. ; Kod pemacu", "code": "using System ; class GFG { static int countMinReversals ( String expr ) { int len = expr . Length ; if ( len % 2 != 0 ) return - 1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; } public static void Main ( String [ ] args ) { String expr = \" } } { { \" ; Console . WriteLine ( countMinReversals ( expr ) ) ; } }"}
{"text": "Pasangan watak dari dua rentetan dengan jumlah keseluruhan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah pasangan yang sah; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S1; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S2; Mengembalikan jumlah pasangan yang sah; Kod pemacu", "code": "using System ; class GfG { static int totalPairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { if ( ( int ) s1 [ i ] % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . Length ; i ++ ) { if ( ( int ) s2 [ i ] % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } public static void Main ( String [ ] args ) { String s1 = \" geeks \" , s2 = \" for \" ; Console . WriteLine ( totalPairs ( s1 , s2 ) ) ; } }"}
{"text": "Kejadian maksimum awalan dalam array | C # Program untuk mencari bilangan kejadian awalan yang berlaku maksimum no. masa; Berfungsi untuk mengembalikan kiraan awalan yang diperlukan; Cari kekerapan watak pertama rentetan; Kod pemacu", "code": "using System ; class GFG { static int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; } public static void Main ( ) { string str = \" abbcdabbcd \" ; Console . WriteLine ( prefixOccurrences ( str ) ) ; } }"}
{"text": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar rentetan ke rentetan lain | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan operasi minimum jenis yang diberikan untuk menukar rentetan s ke rentetan t; Watak sudah sama; Kiraan kenaikan 0 s; Kiraan kenaikan 1 s; Kod pemacu", "code": "using System ; class GFG { static int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . Max ( ct0 , ct1 ) ; } public static void Main ( ) { string s = \"010\" , t = \"101\" ; int n = s . Length ; Console . Write ( minOperations ( s , t , n ) ) ; } }"}
{"text": "Dekripsi rentetan yang disulitkan dengan mengulangi i | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disahsulit; Lompat awal akan menjadi 1; Lompat kenaikan sebanyak 1 dengan setiap watak; Kod pemacu", "code": "using System ; class GFG { static string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = \" \" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; } public static void Main ( ) { string str = \" geeeeekkkksssss \" ; int n = str . Length ; Console . Write ( decryptString ( str , n ) ) ; } }"}
{"text": "Cari bit yang flip urutan minimum menjadikan semua bit sama | C # Program untuk mencari urutan bit mana yang akan dibalik; Fungsi untuk memeriksa bit mana yang akan dibalik; pembolehubah untuk menyimpan watak pertama dan terakhir rentetan; Semak sama ada aksara pertama dan terakhir adalah sama, jika ya, kemudian kembalikan watak yang tidak akhirnya; lain kembali terakhir; Kod pemacu", "code": "using System ; class GfG { static char bitToBeFlipped ( String s ) { char last = s [ s . Length - 1 ] ; char first = s [ 0 ] ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } return last ; } public static void Main ( ) { string s = \"1101011000\" ; Console . WriteLine ( bitToBeFlipped ( s ) ) ; } }"}
{"text": "Jumlah dan produk frekuensi utama aksara dalam rentetan | C # Program untuk mencari jumlah dan produk frekuensi utama aksara dalam rentetan; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencari jumlah frekuensi utama watak -watak rentetan yang diberikan; Peta digunakan untuk menyimpan frekuensi watak; Melintasi peta; Jika kekerapan adalah perdana; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < p_size ; i += p ) { prime [ i ] = false ; } } } } static void sumProdOfPrimeFreq ( char [ ] s ) { int i ; bool [ ] prime = new bool [ s . Length + 1 ] ; for ( i = 0 ; i < s . Length + 1 ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( prime , s . Length + 1 ) ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( i = 0 ; i < s . Length ; i ++ ) { if ( mp . ContainsKey ( s [ i ] ) ) { var val = mp [ s [ i ] ] ; mp . Remove ( s [ i ] ) ; mp . Add ( s [ i ] , val + 1 ) ; } else { mp . Add ( s [ i ] , 1 ) ; } } int sum = 0 , product = 1 ; foreach ( KeyValuePair < char , int > it in mp ) { if ( prime [ it . Value ] ) { sum += it . Value ; product *= it . Value ; } } Console . Write ( \" Sum ▁ = ▁ \" + sum ) ; Console . WriteLine ( \" Product = \" } public static void Main ( String [ ] args ) { String s = \" geeksforgeeks \" ; sumProdOfPrimeFreq ( s . ToCharArray ( ) ) ; } }"}
{"text": "Semak jika kekerapan aksara dalam satu rentetan adalah faktor atau pelbagai kekerapan watak yang sama dalam rentetan lain | C # pelaksanaan pendekatan; Fungsi yang memeriksa jika kekerapan watak adalah faktor atau pelbagai antara satu sama lain; kekerapan kedai peta setiap aksara; Jika sebarang kekerapan adalah 0, maka teruskan sebagai keadaan berpuas hati; jika faktor atau berganda, maka keadaan berpuas hati; jika keadaan tidak berpuas hati; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static Boolean multipleOrFactor ( String s1 , String s2 ) { Dictionary < char , int > m1 = new Dictionary < char , int > ( ) ; Dictionary < char , int > m2 = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { if ( m1 . ContainsKey ( s1 [ i ] ) ) { var x = m1 [ s1 [ i ] ] ; m1 [ s1 [ i ] ] = ++ x ; } else m1 . Add ( s1 [ i ] , 1 ) ; } for ( int i = 0 ; i < s2 . Length ; i ++ ) { if ( m2 . ContainsKey ( s2 [ i ] ) ) { var x = m2 [ s2 [ i ] ] ; m2 [ s2 [ i ] ] = ++ x ; } else m2 . Add ( s2 [ i ] , 1 ) ; } foreach ( KeyValuePair < char , int > entry in m1 ) { if ( ! m2 . ContainsKey ( entry . Key ) ) continue ; if ( m2 [ entry . Key ] != 0 && ( m2 [ entry . Key ] % entry . Value == 0 entry . Value % m2 [ entry . Key ] == 0 ) ) continue ; else return false ; } return true ; } public static void Main ( String [ ] args ) { String s1 = \" geeksforgeeks \" , s2 = \" geeks \" ; if ( multipleOrFactor ( s1 , s2 ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Keluarkan walaupun aksara frekuensi dari rentetan | C # pelaksanaan pendekatan; Fungsi yang menghilangkan aksara yang mempunyai frekuensi dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi; Jika watak mempunyai kekerapan, maka langkau; lain menggabungkan watak ke rentetan baru; Paparkan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi bahkan", "code": "using System ; using System . Collections . Generic ; class GFG { static void solve ( String s ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m . ContainsKey ( s [ i ] ) ) { var val = m [ s [ i ] ] ; m . Remove ( s [ i ] ) ; m . Add ( s [ i ] , val + 1 ) ; } else m . Add ( s [ i ] , 1 ) ; } String new_string = \" \" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string = new_string + s [ i ] ; } Console . WriteLine ( new_string ) ; } public static void Main ( String [ ] args ) { String s = \" aabbbddeeecc \" ; solve ( s ) ; } }"}
{"text": "Keluarkan semua perkataan palindromik dari ayat yang diberikan | C # pelaksanaan untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; fungsi untuk memeriksa sama ada 'str' adalah palindrome; melintasi kedua -dua hujungnya; bukan palindrome; palindrome; berfungsi untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; 'akhir _ str' untuk menyimpan rentetan akhir dan 'kata' kepada satu demi satu kedai setiap perkataan 'str'; Tambah ruang pada akhir 'str'; melintasi 'str'; mengumpul watak -watak perkataan semasa; jika 'perkataan' bukan palindrome maka tambahnya ke 'akhir _ str'; menetapkan semula; rentetan akhir yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static bool isPalindrome ( string str ) { int i = 0 , j = str . Length - 1 ; while ( i < j ) { if ( str [ i ++ ] != str [ j -- ] ) return false ; } return true ; } static String removePalinWords ( string str ) { string final_str = \" \" , word = \" \" ; str = str + \" ▁ \" ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' ▁ ' ) word = word + str [ i ] ; else { if ( ! ( isPalindrome ( word ) ) ) final_str += word + \" ▁ \" ; word = \" \" ; } } return final_str ; } public static void Main ( ) { string str = \" Text ▁ contains ▁ malayalam ▁ \" + \" and ▁ level ▁ words \" ; Console . WriteLine ( removePalinWords ( str ) ) ; } }"}
{"text": "Jumlah semua berikutnya nombor | C # Program untuk mencari jumlah elemen yang hadir dalam semua berikutnya; Mengembalikan nilai angka berikutnya S. Berikutnya yang akan dipilih diputuskan menggunakan corak bit Num (kami memilih semua digit yang mana terdapat bit set dalam NUM); Memulakan hasilnya; sehingga n! = 0; Jika saya - bit ditetapkan maka tambahkan nombor ini; Peralihan kanan i; fungsi untuk mencari jumlah gabungan semua jumlah keseluruhan individu; panjang rentetan; menyimpan gabungan; 2 ^ n - 1 berikutnya; gelung untuk semua berikutnya; mengembalikan jumlah gabungan; Fungsi pemacu", "code": "using System ; class GFG { static int findSubSequence ( string s , int num ) { int res = 0 ; int i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s [ i ] - '0' ; i ++ ; num = num >> 1 ; } return res ; } static int combinedSum ( string s ) { int n = s . Length ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } public static void Main ( ) { string s = \"123\" ; Console . Write ( combinedSum ( s ) ) ; } }"}
{"text": "Susunan terpanjang di mana setiap watak berlaku sekurang -kurangnya k kali | C # Program untuk mencari seterusnya dengan setiap watak yang berlaku sekurang -kurangnya k kali dalam rentetan S; Berfungsi untuk mencari berikutnya; Mengambil array tambahan untuk menyimpan rekod untuk kiraan watak dalam s; Mengira kejadian semua aksara dalam STR []; Percetakan aksara dengan kiraan> = k dalam susunan yang sama kerana ia muncul dalam str. ; Kod pemacu", "code": "using System ; class GFG { static int MAX_CHAR = 26 ; static void findSubsequence ( string str , int k ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . Length ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) Console . Write ( str [ i ] ) ; } public static void Main ( ) { int k = 2 ; findSubsequence ( \" geeksforgeeks \" , k ) ; } }"}
{"text": "Google Case Of A Sentyen tertentu | C # Program untuk menukar ayat ke Google Case. ; rentetan kosong; Tukar rentetan input ke atas kes; checki jika watak bukan ruang dan menambahkannya ke rentetan w; Menukar watak pertama ke kes yang lebih rendah dan huruf awal berikutnya perkataan lain kepada kes yang lebih rendah; Kod pemacu", "code": "using System ; class GFG { static string convert ( string str ) { string w = \" \" , z = \" \" ; str = str . ToUpper ( ) + \" ▁ \" ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) w = w + ch ; else { z = z + ( Char . ToLower ( w [ 0 ] ) ) + w . Substring ( 1 ) + \" ▁ \" ; w = \" \" ; } } return z ; } static void Main ( ) { string str = \" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks \" ; Console . WriteLine ( convert ( str ) ) ; } }"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | C # Program untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan rentetan; CV untuk mengira vokal CC untuk mengira konsonan; Mengira awalan kiraan vokal dan awalan kiraan konsonan; Menjana rentetan yang disulitkan. ; Kod pemacu", "code": "using System ; class GFG { static bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static String encryptString ( char [ ] s , int n , int k ) { int [ ] cv = new int [ n ] ; int [ ] cc = new int [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 1 : 0 ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 0 : 1 ) ; } String ans = \" \" ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += String . Join ( \" \" , prod ) ; for ( int i = k ; i < s . Length ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += String . Join ( \" \" , prod ) ; } return ans ; } public static void Main ( String [ ] args ) { String s = \" hello \" ; int n = s . Length ; int k = 2 ; Console . Write ( encryptString ( s . ToCharArray ( ) , n , k ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Kira kejadian perkataan dalam rentetan | C # Program untuk mengira bilangan berlakunya perkataan dalam rentetan yang diberikan; berpecah rentetan dengan ruang; Cari corak dalam rentetan; jika perlawanan mendapati kenaikan kiraan; Kod pemacu", "code": "using System ; class GFG { static int countOccurrences ( string str , string word ) { string [ ] a = str . Split ( ' ▁ ' ) ; int count = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { if ( word . Equals ( a [ i ] ) ) count ++ ; } return count ; } public static void Main ( ) { string str = \" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ \" ; string word = \" portal \" ; Console . Write ( countOccurrences ( str , word ) ) ; } }"}
{"text": "Tinggalkan rentetan dengan menukar kes | C # Program untuk mencetak semua permutasi berkenaan dengan kes; Berfungsi untuk menjana permutasi; Bilangan permutasi adalah 2 ^ n; Menukar rentetan ke kes yang lebih rendah; Menggunakan semua berikutnya dan membenarkannya; Jika b - th bit ditetapkan, kami menukarnya ke atas kes; Mencetak gabungan semasa; Kod pemacu", "code": "using System ; class PermuteString { static void permute ( String input ) { int n = input . Length ; int max = 1 << n ; input = input . ToLower ( ) ; for ( int i = 0 ; i < max ; i ++ ) { char [ ] combination = input . ToCharArray ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = ( char ) ( combination [ j ] - 32 ) ; } Console . Write ( combination ) ; Console . Write ( \" ▁ \" ) ; } } public static void Main ( ) { permute ( \" ABC \" ) ; } }"}
{"text": "Cetak rentetan selepas watak yang ditentukan telah berlaku diberi tidak. masa | C # Program untuk pelaksanaan di atas; Kaedah untuk mencetak rentetan; Jika diberi kiraan adalah 0 cetak rentetan yang diberikan dan kembali; Mula melintasi rentetan; Kenaikan OCC jika char semasa adalah sama dengan watak yang diberikan; Pecahkan gelung jika watak yang diberikan telah berlaku tidak diberikan. masa; Cetak rentetan selepas berlakunya watak yang diberikan tidak. masa; Jika tidak, rentetan kosong; Kaedah Pemandu", "code": "using System ; public class GFG { static public void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { Console . WriteLine ( str ) ; return ; } for ( i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . Length - 1 ) Console . WriteLine ( str . Substring ( i + 1 ) ) ; else Console . WriteLine ( \" Empty ▁ string \" ) ; } static public void Main ( ) { string str = \" geeks ▁ for ▁ geeks \" ; printString ( str , ' e ' , 2 ) ; } }"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | C # Program untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Mulakan dua indeks dari dua sudut dan bergerak ke arah satu sama lain; bertukar; Kod pemacu", "code": "using System ; class GFG { static Boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } static String reverseVowel ( String str ) { int i = 0 ; int j = str . Length - 1 ; char [ ] str1 = str . ToCharArray ( ) ; while ( i < j ) { if ( ! isVowel ( str1 [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str1 [ j ] ) ) { j -- ; continue ; } char t = str1 [ i ] ; str1 [ i ] = str1 [ j ] ; str1 [ j ] = t ; i ++ ; j -- ; } String str2 = String . Join ( \" \" , str1 ) ; return str2 ; } public static void Main ( String [ ] args ) { String str = \" hello ▁ world \" ; Console . WriteLine ( reverseVowel ( str ) ) ; } }"}
{"text": "Bilangan minimum Palindromic selepas dikeluarkan untuk mengosongkan rentetan binari | C # Program untuk mengira minimum Palindromic seterusnya untuk dikeluarkan untuk membuat rentetan kosong. ; Fungsi untuk memeriksa sama ada string str adalah palindrome; Bermula dari sudut paling kiri dan paling kanan Str; Terus membandingkan watak semasa mereka sama; Mengembalikan kiraan minimum palindromic subseuqnces untuk dikeluarkan untuk membuat rentetan kosong; Jika rentetan kosong; Jika rentetan adalah palindrome; Jika rentetan bukan palindrome; Kod pemacu ke", "code": "using System ; class GFG { static bool isPalindrome ( String str ) { int l = 0 ; int h = str . Length - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; } static int minRemovals ( String str ) { if ( str [ 0 ] == ' ' ) return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } public static void Main ( ) { Console . WriteLine ( minRemovals ( \"010010\" ) ) ; Console . WriteLine ( minRemovals ( \"0100101\" ) ) ; } }"}
{"text": "Cari nilai xxxx .... . (N kali) % m di mana n adalah besar | C # pelaksanaan pendekatan; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y / 2; Fungsi untuk mengembalikan xxx .... . (N kali) % m; Mengembalikan mod dengan m nombor yang lebih kecil; Mewujudkan rentetan n x 's; Menukar rentetan ke int dan mengira modulo; Memeriksa pariti n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk ganjil n; Kod pemacu; Cetak xxx ... (n kali) % m", "code": "using System ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int findModuloByM ( int X , int N , int M ) { if ( N < 6 ) { string temp = \" \" ; for ( int i = 0 ; i < N ; i ++ ) temp = temp + ( char ) ( X + 48 ) ; int res = Convert . ToInt32 ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } public static void Main ( ) { int X = 6 , N = 14 , M = 9 ; Console . WriteLine ( findModuloByM ( X , N , M ) ) ; } }"}
{"text": "Semak jika dua lingkaran bersilang sedemikian rupa sehingga bulatan ketiga melewati titik -titik persimpangan dan pusat mereka | C # pendekatan untuk pendekatan di atas; Struktur bulatan; Fungsi utiliti untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Menyimpan jarak antara pusat C1 dan C2; Menyimpan status jika kriteria yang diberikan berpuas hati atau tidak; Jika C1C2 kurang daripada jumlah radii 2 lingkaran pertama; Jika C3 adalah titik tengah pusat di C1 dan C2; Tanda bendera benar; Bendera kembali; Fungsi untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Semak kombinasi bulatan semasa; Semak kombinasi seterusnya; Kod pemacu", "code": "using System ; class GFG { class circle { public double x ; public double y ; public double r ; public circle ( int x , int y , int r ) { this . x = x ; this . y = y ; this . r = r ; } } static bool check ( circle [ ] C ) { double C1C2 = Math . Sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; bool flag = false ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = true ; } } return flag ; } static bool IsFairTriplet ( circle [ ] c ) { bool f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; } static void swap ( circle circle1 , circle circle2 ) { circle temp = circle1 ; circle1 = circle2 ; circle2 = temp ; } public static void Main ( String [ ] args ) { circle [ ] C = new circle [ 3 ] ; C [ 0 ] = new circle ( 0 , 0 , 8 ) ; C [ 1 ] = new circle ( 0 , 10 , 6 ) ; C [ 2 ] = new circle ( 0 , 5 , 5 ) ; if ( IsFairTriplet ( C ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Program untuk mencari eksentrik hyperbola | C # Program untuk pendekatan di atas; Berfungsi untuk mencari eksentrik hiperbola; Menyimpan nisbah kuadrat paksi utama kepada paksi kecil; Kenaikan r oleh 1; Mengembalikan akar kuadrat R; Kod pemacu", "code": "using System ; class GFG { static double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . Sqrt ( r ) ; } public static void Main ( String [ ] args ) { double A = 3.0 , B = 2.0 ; Console . Write ( eccHyperbola ( A , B ) ) ; } }"}
{"text": "Kirakan kawasan kuadrilateral kitaran dengan panjang sampingan yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari kawasan kuadrilateral kitaran; Menyimpan nilai separuh perimeter; Kedai kawasan kuadrilateral kitaran; Mengembalikan kawasan yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . Sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } static public void Main ( ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; Console . Write ( calculateArea ( A , B , C , D ) ) ; } }"}
{"text": "Kirakan nisbah kawasan segitiga yang tertulis dalam elips dan segitiga yang dibentuk oleh titik yang sama pada bulatan tambahan | C # Program untuk pendekatan di atas; Fungsi untuk mengira nisbah segitiga yang tertulis dalam elips ke segitiga pada bulatan tambahan; Menyimpan nisbah separuh besar hingga separuh kapak kecil; Cetak nisbah; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; Console . WriteLine ( ratio ) ; } public static void Main ( ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; } }"}
{"text": "Program untuk mencari excenters segitiga | C # Program untuk pendekatan di atas; Berfungsi untuk mengira jarak antara sepasang mata; Fungsi untuk mengira koordinat excenters segitiga; Panjang sisi segitiga; Menyimpan koordinat excenters segitiga; Untuk i1; Untuk i2; Untuk i3; Cetak excenters segitiga; Kod pemacu", "code": "using System ; class GFG { class pair { public float first , second ; public pair ( float first , float second ) { this . first = first ; this . second = second ; } } static float distance ( int m , int n , int p , int q ) { return ( float ) Math . Sqrt ( Math . Pow ( n - m , 2 ) + Math . Pow ( q - p , 2 ) * 1.0 ) ; } static void Excenters ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { float a = distance ( x2 , x3 , y2 , y3 ) ; float b = distance ( x3 , x1 , y3 , y1 ) ; float c = distance ( x1 , x2 , y1 , y2 ) ; pair [ ] excenter = new pair [ 4 ] ; excenter [ 1 ] = new pair ( ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) / ( - a + b + c ) , ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) / ( - a + b + c ) ) ; excenter [ 2 ] = new pair ( ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) / ( a - b + c ) , ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) / ( a - b + c ) ) ; excenter [ 3 ] = new pair ( ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) / ( a + b - c ) , ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) / ( a + b - c ) ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { Console . WriteLine ( ( int ) excenter [ i ] . first + \" ▁ \" + ( int ) excenter [ i ] . second ) ; } } static void Main ( ) { int x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } }"}
{"text": "Program untuk mencari ketinggian trapezoid | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira ketinggian trapezoid; Memohon formula Heron; Hitung kawasan; Hitung ketinggian trapezoid; Cetak ketinggian; Kod pemacu; Memandangkan A, B, P1 dan P2", "code": "using System ; public class GFG { static void findHeight ( float p1 , float p2 , float b , float c ) { float a = Math . Max ( p1 , p2 ) - Math . Min ( p1 , p2 ) ; float s = ( a + b + c ) / 2 ; float area = ( int ) Math . Sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; float height = ( area * 2 ) / a ; Console . Write ( \" Height ▁ is : ▁ \" + height ) ; } public static void Main ( String [ ] args ) { float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; } }"}
{"text": "Nombor Icositetragonal | C # Program untuk mencari nombor icositetragonal nth; Berfungsi untuk mencari nombor icositetragonal; Formula untuk mengira nombor icositetragonal nth; Kod pemacu", "code": "using System ; class GFG { static int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; } public static void Main ( string [ ] args ) { int n = 3 ; Console . Write ( Icositetragonal_num ( n ) + \" STRNEWLINE \" ) ; n = 10 ; Console . Write ( Icositetragonal_num ( n ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Kawasan bulatan yang ditulis dalam trapezoid isosceles | C # Program untuk mencari rea bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Fungsi untuk mencari kawasan bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Radius bulatan oleh formula i. e. akar (m * n) / 2 kawasan bulatan = (3.141) * (r * * 2); Kod pemacu", "code": "using System ; class GFG { static double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; } public static void Main ( ) { int n = 10 ; int m = 30 ; Console . WriteLine ( area_of_circle ( m , n ) ) ; } }"}
{"text": "Kawasan segitiga sama rata yang tertulis dalam lingkaran radius r | C # pelaksanaan untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Berfungsi untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Asas dan ketinggian segitiga sama rata; Kawasan menggunakan asas dan ketinggian; Kod pemacu", "code": "using System ; class GFG { static double area ( int R ) { double Base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * Base * height ; return area ; } public static void Main ( String [ ] args ) { int R = 7 ; Console . WriteLine ( area ( R ) ) ; } }"}
{"text": "Kawasan bulatan terbesar yang boleh ditulis dalam separuh bulatan | C # Program untuk mencari bulatan terbesar yang boleh ditulis dalam separuh bulatan; Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; Kawasan bulatan terbesar; Kod pemacu", "code": "using System ; class GFG { static float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; } public static void Main ( string [ ] args ) { float R = 2 ; Console . WriteLine ( circlearea ( R ) ) ; } }"}
{"text": "Bilangan pasang garisan yang mempunyai titik persimpangan integer | C # Program kepada bilangan pasang garis yang mempunyai titik persimpangan integer; Mengira bilangan pasang garis yang mempunyai titik persimpangan integer; Memulakan susunan untuk menyimpan tuduhan; Kiraan bilangan ganjil dan bahkan pi; Kiraan bilangan ganjil dan bahkan qi; Mengembalikan kiraan pasangan; Kod pemacu", "code": "using System ; class GFG { static int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] ; int [ ] B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } public static void Main ( ) { int [ ] P = { 1 , 3 , 2 } ; int [ ] Q = { 3 , 0 } ; int N = P . Length ; int M = Q . Length ; Console . Write ( countPairs ( P , Q , N , M ) ) ; } }"}
{"text": "Bilangan maksimum persimpangan garis yang dibentuk melalui persimpangan pesawat N | C # pelaksanaan pendekatan; Berfungsi untuk mengira bilangan maksimum persimpangan yang mungkin; Kod pemacu", "code": "using System ; class GFG { static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( countIntersections ( n ) ) ; } }"}
{"text": "Kawasan pentagram biasa | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kawasan segitiga BCD; Menggunakan nisbah emas; Hitung kawasan segitiga BCD; Kawasan pulangan semua 5 segitiga adalah sama; Berfungsi untuk mengembalikan kawasan pentagon biasa; Kirakan kawasan pentagon biasa menggunakan formula di atas; Kawasan pulangan Pentagon biasa; Berfungsi untuk mengembalikan kawasan pentagram; Kawasan pentagram adalah sama dengan kawasan pentagon biasa dan lima kali kawasan segitiga; Kod pemacu", "code": "using System ; class GFG { static double PI = 3.14159 ; static double areaOfTriangle ( float d ) { float c = ( float ) ( 1.618 * d ) ; float s = ( d + c + c ) / 2 ; double area = Math . Sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; } static double areaOfRegPentagon ( float d ) { double cal = 4 * Math . Tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; } static double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; } public static void Main ( ) { float d = 5 ; Console . WriteLine ( areaOfPentagram ( d ) ) ; } }"}
{"text": "Sudut yang disebarkan oleh kord ke pusat bulatan apabila sudut yang disuntik oleh kord lain yang sama dari lingkaran kongruen diberikan | C # Program untuk mencari sudut yang disembur oleh kord ke pusat bulatan apabila sudut yang diselaraskan oleh kord lain yang sama dari lingkaran kongruen diberikan; Kod pemacu", "code": "using System ; class GFG { static void anglequichord ( int z ) { Console . WriteLine ( \" The ▁ angle ▁ is ▁ \" + z + \" ▁ degrees \" ) ; } public static void Main ( ) { int z = 48 ; anglequichord ( z ) ; } }"}
{"text": "Program untuk mencetak nilai ASCII bagi semua digit nombor tertentu | C # Program untuk menukar digit nombor ke nilai ASCIInya; Berfungsi untuk menukar digit N ke nilai ASCII masing -masing; Kod pemacu", "code": "using System ; public class GFG { static void convertToASCII ( int N ) { String num = N . ToString ( ) ; foreach ( char ch in num . ToCharArray ( ) ) { Console . Write ( ch + \" ▁ ( \" + ( int ) ch + \" ) STRNEWLINE \" ) ; } } public static void Main ( String [ ] args ) { int N = 36 ; convertToASCII ( N ) ; } }"}
{"text": "Teka -teki Arus Produk | Set 3 | C # Program untuk pendekatan di atas; Berfungsi untuk membentuk pelbagai produk dengan ruang O (n) dan o (1); Menyimpan produk array; Menyimpan kiraan sifar; Melintasi array; Jika arr [i] tidak sifar; Jika arr [i] adalah sifar maka kiraan kenaikan z oleh 1; Menyimpan nilai mutlak produk; Jika z sama dengan 1; Jika arr [i] tidak sifar; Lain; Jika kiraan 0 s sekurang -kurangnya 2; Berikan arr [i] = 0; Simpan nilai mutlak arr [i]; Cari nilai A / B; Jika arr [i] dan produk kedua -duanya kurang daripada sifar; Jika arr [i] dan produk kedua -duanya lebih besar daripada sifar; Lain; Melintasi array arr []; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void productExceptSelf ( int [ ] arr , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) product *= arr [ i ] ; if ( arr [ i ] == 0 ) z += 1 ; } int a = Math . Abs ( product ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] != 0 ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = Math . Abs ( arr [ i ] ) ; int curr = ( int ) Math . Round ( Math . Exp ( Math . Log ( a ) - Math . Log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = - 1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 3 , 5 , 6 , 2 } ; int N = arr . Length ; productExceptSelf ( arr , N ) ; } }"}
{"text": "Count Subarrays terdiri daripada single | C # Program untuk pendekatan di atas; Fungsi untuk mengira subarrays yang terdiri daripada bilangan bulat tunggal sahaja; Kedai kiraan subarray; Menyimpan kiraan nombor angka tunggal berturut -turut dalam array; Melintasi array; Saiz kenaikan blok sebanyak 1; Peningkatan res mengikut kiraan; Menetapkan kiraan = 0; Kod pemacu; Diberikan array; Saiz array", "code": "using System ; class GFG { static void singleDigitSubarrayCount ( int [ ] arr , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } Console . Write ( res ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 0 , 1 , 14 , 2 , 5 } ; int N = arr . Length ; singleDigitSubarrayCount ( arr , N ) ; } }"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor n boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut atau tidak; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Menyimpan kiraan yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int isPossible ( int N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; } static void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } Console . Write ( count ) ; } static public void Main ( ) { int N = 15 ; countElements ( N ) ; } }"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | C # pelaksanaan pendekatan di atas; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Mengira kuasa 2 sehingga n; Kiraan kenaikan; Mengemas kini kuasa semasa 2; Kod pemacu", "code": "using System ; public class GFG { static void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } Console . Write ( N - Count ) ; } public static void Main ( String [ ] args ) { int N = 15 ; countElements ( N ) ; } }"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Kirakan perbezaan bersebelahan maksimum untuk keseluruhan array; Simpan maksimum antara arr_max dan curr_max; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void maxAdjacent ( int [ ] arr , int N ) { List < int > res = new List < int > ( ) ; int arr_max = Int32 . MinValue ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = Math . Max ( arr_max , Math . Abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = Math . Abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = Math . Max ( curr_max , arr_max ) ; res . Add ( ans ) ; } foreach ( int x in res ) Console . Write ( x + \" ▁ \" ) ; Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . Length ; maxAdjacent ( arr , N ) ; } }"}
{"text": "Kurangkan kenaikan yang diperlukan untuk membuat kiraan elemen array yang sama dan ganjil sama | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari operasi min untuk membuat kiraan yang sama dan ganjil sama; Saiz ganjil tidak akan menjadi ganjil dan juga dianggap sama; Menyimpan kiraan nombor walaupun dalam array arr []; Kedai mengira nombor ganjil dalam array arr []; Melintasi array arr []; Jika arr [i] adalah nombor yang sama; Kemas kini cnteven; Nombor ganjil dalam arr []; Kembali perbezaan mutlak dibahagikan dengan 2; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int minimumIncrement ( int [ ] arr , int N ) { if ( N % 2 != 0 ) { Console . WriteLine ( \" - 1\" ) ; Environment . Exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return Math . Abs ( cntEven - cntOdd ) / 2 ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 4 , 9 } ; int N = arr . Length ; Console . WriteLine ( minimumIncrement ( arr , N ) ) ; } }"}
{"text": "Kira cara untuk membina array dengan produk walaupun dari array yang diberikan sedemikian rupa sehingga perbezaan mutlak unsur -unsur yang diindeks sama paling banyak 1 | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mencari menghitung cara untuk membina array, [] b sedemikian rupa sehingga abs (a [i] - b [i]) <= 1 dan produk unsur -unsur [] b juga; Kedai kiraan tatasusunan [] b seperti abs (a [i] - b [i]) <= 1; Kedai kiraan tatasusunan [] b yang produk elemennya tidak; Melintasi array; Jumlah kemas kini; Jika [i] adalah nombor yang sama; Kemas kini Oddarray; Cetak 3 ^ n - 2 ^ x; Kod pemacu", "code": "using System ; class GFG { static void cntWaysConsArray ( int [ ] A , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } Console . WriteLine ( total - oddArray ) ; } public static void Main ( String [ ] args ) { int [ ] A = { 2 , 4 } ; int N = A . Length ; cntWaysConsArray ( A , N ) ; } }"}
{"text": "Kira nombor sehingga n yang paling tepat ditetapkan adalah k | C # Program untuk pendekatan di atas; Fungsi untuk mengira nombor dalam julat [1, n] yang paling tepat ditetapkan adalah k; Menyimpan nombor yang paling tepat adalah k; Nombor yang paling tepat adalah i; Mengurangkan nombor yang paling tepat ditetapkan adalah saya, dari n; Oleh kerana i = k, maka nombor yang paling tepat ditetapkan adalah k disimpan; Kod pemacu", "code": "using System ; class GFG { static void countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } Console . WriteLine ( numbers_rightmost_setbit_K ) ; } static public void Main ( String [ ] args ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; } }"}
{"text": "Kira pekali ganjil dan bahkan binomial N | C # Program untuk pendekatan di atas; Fungsi untuk mengira set bit dalam perwakilan binari nombor n; Count set bit dalam n; Mengembalikan kiraan akhir; Kod pemacu; Cetak koefisien binomial ganjil; Cetak walaupun koefisien binomial", "code": "using System ; class GFG { static int countSetBits ( int N ) { int count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } public static void Main ( ) { int N = 4 ; int bits = countSetBits ( N ) ; Console . WriteLine ( \" Odd ▁ \" + \" : ▁ \" + ( int ) ( Math . Pow ( 2 , bits ) ) ) ; Console . WriteLine ( \" Even ▁ \" + \" : ▁ \" + ( N + 1 - ( int ) ( Math . Pow ( 2 , bits ) ) ) ) ; } }"}
{"text": "Buat semua elemen array walaupun dengan menggantikan mana -mana sepasang elemen array dengan jumlah mereka | C # Program untuk pendekatan di atas; Fungsi untuk mencari bilangan minimum penggantian yang diperlukan untuk membuat semua elemen array walaupun; Menyimpan kiraan elemen ganjil; Melintasi array; Meningkatkan kiraan elemen ganjil; Bilangan penggantian yang diperlukan; Dua langkah tambahan diperlukan untuk membuat elemen ganjil yang terakhir walaupun; Cetak penggantian minimum; Kod pemacu; Panggilan fungsi", "code": "using System ; public class GFG { static void minMoves ( int [ ] arr , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; Console . Write ( moves ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 3 , 7 , 20 } ; int N = arr . Length ; minMoves ( arr , N ) ; } }"}
{"text": "Split Squares of First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | C # Program untuk pendekatan di atas; Berfungsi untuk partition squares nombor semulajadi dalam dua subset; Simpan kiraan blok saiz 8; Pemisahan blok 8 elemen; Simpan perbezaan subset minimum; Pemisahan elemen N untuk meminimumkan perbezaan jumlah subset mereka; Simpan unsur subset A dan B; Jika elemen adalah jenis A; Jika elemen adalah jenis B; Cetak perbezaan subset minimum; Cetak subset pertama; Cetak subset kedua; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void minimumSubsetDifference ( int N ) { int blockOfSize8 = N / 8 ; string str = \" ABBABAAB \" ; int subsetDifference = 0 ; string partition = \" \" ; while ( blockOfSize8 -- > 0 ) { partition += str ; } int [ ] A = new int [ N ] ; int [ ] B = new int [ N ] ; int x = 0 , y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( partition [ i ] == ' A ' ) { A [ x ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } else { B [ y ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } } Console . WriteLine ( subsetDifference ) ; for ( int i = 0 ; i < x ; i ++ ) Console . Write ( A [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; for ( int i = 0 ; i < y ; i ++ ) Console . Write ( B [ i ] + \" ▁ \" ) ; } public static void Main ( string [ ] args ) { int N = 8 ; minimumSubsetDifference ( N ) ; } }"}
{"text": "Pembahagi terbesar nombor yang tidak dapat dibahagikan dengan nombor yang lain | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari nombor terbesar x supaya ia membahagikan p tetapi tidak dapat dibahagikan dengan q; Menyimpan kiraan kekerapan semua faktor utama; Meningkatkan kekerapan faktor utama semasa; Jika Q adalah faktor utama; Menyimpan hasil yang diingini; Melangkah melalui semua pembahagi Q; Menyimpan kiraan kekerapan pembahagi utama semasa untuk membahagikan p; Mengira kekerapan faktor utama semasa; Jika CUR kurang daripada kekerapan maka p adalah hasil akhir; Berulang untuk mendapatkan jawapan sementara; Mengemas kini jawapan semasa; Cetak hasil yang diinginkan; Kod pemacu; Diberikan p dan q; Panggilan fungsi", "code": "using System . Collections . Generic ; using System ; using System . Linq ; class GFG { static void findTheGreatestX ( int P , int Q ) { Dictionary < int , int > divisers = new Dictionary < int , int > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q /= i ; if ( divisers . ContainsKey ( i ) ) divisers [ i ] ++ ; else divisers [ i ] = 1 ; } } if ( Q > 1 ) { if ( divisers . ContainsKey ( Q ) ) divisers [ Q ] ++ ; else divisers [ Q ] = 1 ; } int ans = 0 ; var val = divisers . Keys . ToList ( ) ; foreach ( var key in val ) { int frequency = divisers [ key ] ; int temp = P ; int cur = 0 ; while ( temp % key == 0 ) { temp /= key ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= key ; } ans = Math . Max ( temp , ans ) ; } Console . WriteLine ( ans ) ; } public static void Main ( String [ ] args ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; } }"}
{"text": "Semak jika baris matriks boleh disusun semula untuk membuat bitwise xor lajur pertama non | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada ada baris di mana bilangan elemen unik lebih besar daripada 1; Melangkah ke atas matriks; Fungsi untuk memeriksa sama ada mungkin untuk menyusun semula [,] tikar supaya XOR lajur pertamanya bukan sifar; Cari bitwise xor dari lajur pertama [,] mat; Jika bitwise xor lajur pertama [,] tikar bukan sifar; Jika tidak, periksa semula; Kod pemacu; Diberikan matriks [,] mat; Panggilan fungsi", "code": "using System ; class GFG { static String checkRearrangements ( int [ , ] mat , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i , 0 ] != mat [ i , j ] ) { return \" Yes \" ; } } } return \" No \" ; } static String nonZeroXor ( int [ , ] mat , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i , 0 ] ; } if ( res != 0 ) return \" Yes \" ; else return checkRearrangements ( mat , N , M ) ; } public static void Main ( String [ ] args ) { int [ , ] mat = { { 1 , 1 , 2 } , { 2 , 2 , 2 } , { 3 , 3 , 3 } } ; int N = mat . GetLength ( 0 ) ; int M = mat . GetLength ( 1 ) ; Console . Write ( nonZeroXor ( mat , N , M ) ) ; } }"}
{"text": "Memaksimumkan bitwise dan elemen pertama dengan pelengkap elemen yang tinggal untuk sebarang permutasi array yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk memaksimumkan nilai untuk fungsi yang diberikan dan elemen array; Senarai array untuk mengekalkan bit mana yang ditetapkan untuk integer dalam array yang diberikan dengan menyimpan indeks integer itu; Semak jika b - th bit ditetapkan untuk integer i - th; Tolak indeks integer itu dalam setbit [j]; Cari elemen yang mempunyai bit set signifikan tertinggi dalam unsur -unsur lain; Letakkan integer itu pada indeks 0 - th; Simpan maksimum dan nilai; Kembalikan jawapannya; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int size_int = 32 ; static int functionMax ( int [ ] arr , int n ) { List < int > [ ] setBit = new List < int > [ 32 + 1 ] ; for ( int i = 0 ; i < setBit . Length ; i ++ ) setBit [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) setBit [ j ] . Add ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . Count == 1 ) { swap ( arr , 0 , setBit [ i ] [ 0 ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 8 , 16 } ; int n = arr . Length ; Console . Write ( functionMax ( arr , n ) ) ; } }"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | C # pelaksanaan pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Berfungsi untuk mengira dan mengembalikan jumlah produk; Memulakan jumlah hingga 0; Melintasi 0 hingga k; Kod pemacu", "code": "using System ; class GFG { static int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; } public static void Main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; Console . Write ( solve ( n , m , k ) ) ; } }"}
{"text": "Exponention Cepat Menggunakan Manipulasi Bit | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan A ^ n; Kedai jawapan yang dibaca; Semak jika LSB semasa ditetapkan; Peralihan kanan; Kod pemacu", "code": "using System ; class GFG { static int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } public static void Main ( String [ ] args ) { int a = 3 , n = 5 ; Console . Write ( powerOptimised ( a , n ) ) ; } }"}
{"text": "Cari M sedemikian rupa sehingga GCD M dan Nombor N adalah maksimum | C # Program untuk pendekatan di atas; Berfungsi untuk mencari integer m sedemikian rupa sehingga GCD (n, m) adalah maksimum; Memulakan pembolehubah; Cari semua pembahagi N dan kembalikan pembahagi maksimum; Semak jika saya boleh dibahagikan dengan n; Kemas kini max_gcd; Mengembalikan nilai maksimum; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "using System ; class GFG { static int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } public static void Main ( String [ ] args ) { int N = 10 ; Console . Write ( findMaximumGcd ( N ) ) ; } }"}
{"text": "Elemen pertama setiap set K mempunyai unsur berturut -turut dengan faktor -faktor utama yang kurang daripada n | C # Program untuk pendekatan di atas; Untuk menyimpan faktor utama terkecil; Fungsi Array Faktor Perdana Consmallest; Tandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri. ; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Semak jika saya adalah Perdana; Mark SPF untuk semua nombor yang boleh dibahagikan oleh i; Mark SPF [J] jika ia tidak ditandakan sebelum ini; Fungsi untuk jumlah jumlah faktor utama; Fungsi untuk mencetak unsur -unsur set un elemen berturut -turut yang mempunyai faktor utama; Untuk menyimpan hasilnya; Mengira bilangan faktor utama nombor; Jika nombor mempunyai faktor yang betul -betul mendorong hasil []; Melangkah sehingga kita mendapat unsur -unsur berturut -turut dalam hasil []; Mengira urutan sehingga k; Cetak elemen jika Count> = k; Kod pemacu; Untuk membina SPF []; Diberikan n dan k; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int x = 2000021 ; static int [ ] v = new int [ x ] ; static void sieve ( ) { v [ 1 ] = 1 ; for ( int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } } static int prime_factors ( int n ) { HashSet < int > s = new HashSet < int > ( ) ; while ( n != 1 ) { s . Add ( v [ n ] ) ; n = n / v [ n ] ; } return s . Count ; } static void distinctPrimes ( int m , int k ) { List < int > result = new List < int > ( ) ; for ( int i = 14 ; i < m + k ; i ++ ) { long count = prime_factors ( i ) ; if ( count == k ) { result . Add ( i ) ; } } int p = result . Count ; for ( int index = 0 ; index < p - 1 ; index ++ ) { long element = result [ index ] ; int count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) Console . Write ( element + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { sieve ( ) ; int N = 1000 , K = 3 ; distinctPrimes ( N , K ) ; } }"}
{"text": "Produk nombor kompleks menggunakan tiga operasi pendaraban | C # Program untuk pendekatan di atas; Berfungsi untuk membiak nombor kompleks dengan hanya tiga pendaraban; Cari nilai prod1, prod2 dan prod3; Bahagian sebenar; Bahagian khayalan; Cetak hasilnya; Kod pemacu; Diberi empat nombor; Panggilan fungsi", "code": "using System ; class GFG { static void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; Console . Write ( real + \" ▁ + ▁ \" + imag + \" i \" ) ; } public static void Main ( ) { int a , b , c , d ; a = 2 ; b = 3 ; c = 4 ; d = 5 ; print_product ( a , b , c , d ) ; } }"}
{"text": "Nombor Insolite | C # pelaksanaan untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah nombor insolit; Untuk menyimpan jumlah kuadrat digit; Untuk menyimpan produk dataran digit; mengekstrak digit; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } public static void Main ( ) { int N = 111 ; if ( isInsolite ( N ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Nombor Superabundant | C # Pelaksanaan untuk memeriksa sama ada nombor adalah superbundant; Fungsi untuk mengira jumlah semua pembahagi nombor tertentu; Jumlah pembahagi; Cari semua pembahagi yang membahagikan 'num'; Jika 'saya' adalah pembahagi 'n'; Jika kedua -dua pembahagi adalah sama maka tambahkannya sekali lagi tambah kedua -duanya; Tambah 1 dan N untuk menghasilkan seperti gelung di atas menganggap pembahagi yang betul lebih besar daripada 1; Berfungsi untuk memeriksa sama ada n adalah nombor superbundant; Untuk memeriksa semua nombor dari 1 hingga n; Kod pemacu", "code": "using System ; class GFG { static int sigma ( int n ) { if ( n == 1 ) return 1 ; int result = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } static bool isSuperabundant ( int N ) { for ( double i = 1 ; i < N ; i ++ ) { double x = sigma ( ( int ) ( i ) ) / i ; double y = sigma ( ( int ) ( N ) ) / ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; } public static void Main ( String [ ] args ) { int N = 4 ; if ( isSuperabundant ( N ) ) Console . Write ( \" Yes STRNEWLINE \" ) ; else Console . Write ( \" No STRNEWLINE \" ) ; } }"}
{"text": "D Nombor | C # pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nombor N - th icosikaipentagon; Nombor hendaklah lebih besar daripada 3; Semak setiap k dalam julat 2 hingga n - 1; Keadaan untuk nombor D; Kod pemacu", "code": "using System ; class GFG { static bool isDNum ( int n ) { if ( n < 4 ) return false ; int numerator = 0 , hcf = 0 ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = ( int ) ( Math . Pow ( k , n - 2 ) - k ) ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int n = 15 ; bool a = isDNum ( n ) ; if ( a ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Ruth | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Berfungsi untuk memeriksa nombor Ruth - Aaron; Kod pemacu", "code": "using System ; class GFG { static int Sum ( int N ) { int [ ] SumOfPrimeDivisors = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } static bool RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; } public static void Main ( ) { int N = 714 ; if ( RuthAaronNumber ( N ) ) { Console . Write ( \" Yes \" ) ; } else { Console . Write ( \" No \" ) ; } } }"}
{"text": "Memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan dalam array dengan jumlah k | C # Program untuk memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan; Fungsi untuk memaksimumkan jumlah; Perbezaan adalah 0 apabila hanya satu elemen yang terdapat dalam array; Perbezaan adalah k apabila dua elemen hadir dalam pelbagai; Jika tidak; Kod pemacu", "code": "using System ; class GFG { static int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } public static void Main ( String [ ] args ) { int N = 6 ; int K = 11 ; Console . Write ( maxAdjacentDifference ( N , K ) ) ; } }"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Tetapkan 2 | C # Program untuk pendekatan di atas; Fungsi mengembalikan jumlah nombor dari 1 hingga n; Fungsi mengembalikan jumlah nombor dari A + 1 hingga B; Fungsi mengembalikan jumlah jumlah pembahagi; Kedai Jumlah Jumlah; Mencari nombor dan kejadiannya; Jumlah produk setiap nombor dan kejadiannya; Kod pemacu", "code": "using System ; class GFG { static readonly int mod = 1000000007 ; public static int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; } public static int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; } public static int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; } public static void Main ( String [ ] args ) { int N = 4 ; Console . WriteLine ( totalSum ( N ) ) ; N = 12 ; Console . WriteLine ( totalSum ( N ) ) ; } }"}
{"text": "Nombor undulant nontrivial | C # Pelaksanaan untuk memeriksa sama ada N adalah nombor undulant nontrivial; Fungsi untuk memeriksa sama ada rentetan adalah rentetan ganda atau tidak; A dan B tidak sepatutnya sama; Keadaan untuk memeriksa sama ada panjang ganjil membuat panjang walaupun; Separuh pertama s; Separuh kedua s; Rentetan double jika separuh pertama dan terakhir adalah sama; Fungsi untuk memeriksa sama ada n adalah nombor undulant yang tidak dapat dipulihkan; Kod pemacu", "code": "using System ; class GFG { static bool isDouble ( int num ) { String s = num . ToString ( ) ; int l = s . Length ; if ( s [ 0 ] == s [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } String s1 = s . Substring ( 0 , l / 2 ) ; String s2 = s . Substring ( l / 2 ) ; return s1 . Equals ( s2 ) ; } static bool isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; } public static void Main ( String [ ] args ) { int n = 121 ; if ( isNontrivialUndulant ( n ) ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } }"}
{"text": "Nombor Megagon | C # Program untuk pendekatan di atas; Berfungsi untuk mencari nombor megagon nth; Kod pemacu", "code": "using System ; class GFG { static int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . Write ( MegagonNum ( n ) ) ; } }"}
{"text": "Produk semua pasangan dari array yang diberikan | C # pelaksanaan untuk mencari produk semua pasangan dari array yang diberikan; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Gelung bersarang untuk mengira semua pasangan yang mungkin; Melipatgandakan produk unsur -unsur pasangan semasa; Mengembalikan hasil readonly; Kod pemacu", "code": "using System ; class GFG { static readonly int mod = 1000000007 ; static int productPairs ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; Console . Write ( productPairs ( arr , n ) ) ; } }"}
{"text": "Produk semua pasangan dari array yang diberikan | C # pelaksanaan untuk mencari produk semua pasangan dari array yang diberikan; Fungsi untuk mengira (x ^ y) % 1000000007; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; Mengembalikan hasil akhir; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Berulang untuk setiap elemen array; Setiap elemen muncul (2 * n) kali; Kod pemacu", "code": "using System ; class GFG { const int mod = 1000000007 ; static int power ( int x , int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int productPairs ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; Console . Write ( productPairs ( arr , n ) ) ; } }"}
{"text": "Membina array sedemikian rupa sehingga jumlah kiub semua elemen adalah persegi yang sempurna | C # Program untuk membina array bahawa jumlah kiub semua elemen adalah persegi yang sempurna; Berfungsi untuk membuat dan mencetak array; Memulakan pelbagai saiz n; Cetak array; Kod pemacu", "code": "using System ; class GFG { static void constructArray ( int N ) { int [ ] arr = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + \" , ▁ \" ) ; } } public static void Main ( ) { int N = 6 ; constructArray ( N ) ; } }"}
{"text": "Kira semua seterusnya yang produknya adalah nombor komposit | C # Pelaksanaan untuk mengira semua seterusnya yang produknya adalah nombor komposit; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk mencari bilangan berikutnya yang produknya adalah nombor komposit; Cari jumlah berikutnya yang tidak kosong; Cari kiraan nombor utama dan yang; Kirakan yang tidak kosong; Cari kiraan seterusnya komposit; Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int countSubsequences ( int [ ] arr , int n ) { int totalSubsequence = ( int ) ( Math . Pow ( 2 , n ) - 1 ) ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = ( int ) ( Math . Pow ( 2 , countOnes ) - 1 ) ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; } public static void Main ( ) { int [ ] arr = { 2 , 1 , 2 } ; int n = arr . Length ; Console . Write ( countSubsequences ( arr , n ) ) ; } }"}
{"text": "Cari integer berturut -turut seperti jumlah mereka adalah n | C # Pelaksanaan untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah integer K berturut -turut; Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah K berturut -turut; Mencari istilah pertama AP; Memeriksa jika istilah pertama adalah integer; Gelung untuk mencetak integer K berturut -turut; Kod pemacu", "code": "using System ; class GFG { static void checksum ( int n , int k ) { float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - ( int ) ( first_term ) == 0 ) { for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { Console . Write ( i + \" ▁ \" ) ; } } else Console . Write ( \" - 1\" ) ; } public static void Main ( String [ ] args ) { int n = 33 , k = 6 ; checksum ( n , k ) ; } }"}
{"text": "Mewakili n sebagai jumlah k angka bahu | C # pelaksanaan untuk mewakili N sebagai jumlah kalah K walaupun; Berfungsi untuk mencetak perwakilan; N mestilah lebih besar daripada sama dengan 2 * k dan mestilah bahkan; Kod pemacu", "code": "using System ; class GFG { static void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { Console . Write ( \"2 ▁ \" ) ; } Console . WriteLine ( check ) ; } else { Console . WriteLine ( \" - 1\" ) ; } } static public void Main ( String [ ] args ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; } }"}
{"text": "Count of Subarrays Bersebelahan mungkin untuk setiap indeks dengan memasukkan elemen pada indeks itu | C # Program untuk mencari bilangan subarray bersebelahan termasuk elemen pada setiap indeks pelbagai saiz n; Berfungsi untuk mencari bilangan subarray termasuk elemen pada setiap indeks array; Mewujudkan pelbagai saiz n; Gelung itu berulang sehingga separuh panjang array; Keadaan untuk mengelakkan menimpa elemen pertengahan untuk array dengan panjangnya. ; Pengkomputeran bilangan subarray; Unsur ITH dari awal dan berakhir mempunyai bilangan subarray yang sama; Berfungsi untuk mencetak vektor; Kod pemacu", "code": "using System ; class GFG { public static int [ ] calculateWays ( int N ) { int x = 0 ; int [ ] v = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; } public static void printArray ( int [ ] v ) { for ( int i = 0 ; i < v . Length ; i ++ ) { Console . Write ( v [ i ] + \" ▁ \" ) ; } } public static void Main ( string [ ] args ) { int [ ] v ; v = calculateWays ( 4 ) ; printArray ( v ) ; } }"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan x yang jumlah digitnya boleh dibahagikan dengan y | C # Program untuk mencari bilangan terkecil lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Fungsi yang mengembalikan jumlah digit nombor; Memulakan pembolehubah untuk menyimpan jumlah; Tambah digit terakhir nombor; Keluarkan digit terakhir dari nombor; Fungsi yang mengembalikan bilangan terkecil lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Memulakan pemboleh ubah hasil; Gelung melalui nombor yang lebih besar daripada sama dengan x; Hitung jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan y; Kod pemacu", "code": "using System ; class GFG { static readonly int MAXN = 10000000 ; static int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; } static int smallestNum ( int X , int Y ) { int res = - 1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; } public static void Main ( String [ ] args ) { int X = 5923 , Y = 13 ; Console . Write ( smallestNum ( X , Y ) ) ; } }"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | C # Program untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Simpan semua pembahagi n; Jika saya seorang pembahagi; Jika saya tidak sama dengan N / I; Melangkah melalui semua pembahagi n - 1 dan mengira mereka sebagai jawapan; Semak jika N - 1 adalah pembahagi atau tidak; Melangkah melalui semua pembahagi dan semak n Mod D = 1 atau (n - 1) mod d = 0; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int countValues ( int N ) { List < int > div = new List < int > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . Add ( i ) ; if ( N != i * i ) { div . Add ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } foreach ( int d in div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } public static void Main ( String [ ] args ) { int N = 6 ; Console . Write ( countValues ( N ) ) ; } }"}
{"text": "Maksimum mungkin pembahagi utama yang boleh wujud dalam nombor yang mempunyai tepat n pembahagi | C # Pelaksanaan untuk mencari pembahagi utama maksimum nombor boleh mempunyai pembahagi N; Berfungsi untuk mencari pembahagi utama maksimum nombor yang boleh dimiliki dengan pembahagi N; Bilangan bilangan masa dibahagikan dengan 2; Membahagikan dengan nombor perdana lain; Jika bilangan terakhir juga perdana maka juga memasukkannya; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } } if ( n > 2 ) { max_possible_prime ++ ; } Console . Write ( max_possible_prime + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { int n = 4 ; findMaxPrimeDivisor ( n ) ; } }"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah tepat dua nombor | C # Program untuk mengira cara untuk menyatakan nombor sebagai jumlah dua nombor. ; Fungsi Mengembalikan kiraan cara menyatakan nombor sebagai jumlah dua nombor. ; Kod pemacu", "code": "using System ; class GFG { static int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; } public static void Main ( ) { int N = 8 ; Console . Write ( CountWays ( N ) ) ; } }"}
{"text": "Bahagikan array dalam dua tatasusunan panjang maksimum yang sama dengan unsur -unsur yang serupa dan berbeza | C # Program untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama supaya satu bahagian mengandungi unsur -unsur yang unik manakala yang lain mengandungi unsur -unsur yang sama; Berfungsi untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama; Array untuk mencari kekerapan setiap elemen array; Cari elemen frekuensi maksimum indeks yang terdapat dalam array arr []; Cari jumlah elemen unik yang terdapat dalam array arr []; Cari saiz maksimum yang mana array arr [] boleh dibuang; Cari array pertama yang mengandungi elemen yang sama; Cari array kedua yang mengandungi unsur -unsur yang unik; Kod pemacu; Permulaan n; Perisytiharan array; Saiz array", "code": "using System ; class GFG { static void Solve ( int [ ] arr , int size , int n ) { int [ ] v = new int [ n + 1 ] ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = - 1 , mx = - 1 ; for ( int i = 0 ; i < v . Length ; i ++ ) { if ( v [ i ] > mx ) { mx = v [ i ] ; max1 = i ; } } int cnt = 0 ; foreach ( int i in v ) { if ( i == 0 ) ++ cnt ; } int diff1 = n + 1 - cnt ; int max_size = Math . Max ( Math . Min ( v [ max1 ] - 1 , diff1 ) , Math . Min ( v [ max1 ] , diff1 - 1 ) ) ; Console . Write ( \" Maximum ▁ size ▁ is ▁ : \" + max_size + \" STRNEWLINE \" ) ; Console . Write ( \" The ▁ First ▁ Array ▁ Is ▁ : STRNEWLINE \" ) ; for ( int i = 0 ; i < max_size ; i ++ ) { Console . Write ( max1 + \" ▁ \" ) ; v [ max1 ] -= 1 ; } Console . Write ( \" STRNEWLINE \" ) ; Console . Write ( \" The ▁ Second ▁ Array ▁ Is ▁ : STRNEWLINE \" ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { Console . Write ( i + \" ▁ \" ) ; max_size -- ; } if ( max_size < 1 ) break ; } Console . Write ( \" STRNEWLINE \" ) ; } public static void Main ( string [ ] args ) { int n = 7 ; int [ ] arr = new int [ ] { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = arr . Length ; Solve ( arr , size , n ) ; } }"}
{"text": "Cari Jumlah Xor semua tiga kali ganda yang tidak teratur dari array | C # Program untuk mencari jumlah XOR dari semua triplet yang tidak teratur dari array; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Mengembalikan n ^ ( - 1) mod p; Mengembalikan NCR % P menggunakan teorem kecil Fermat. ; Kes asas; Isi pelbagai faktorial supaya kita dapat mencari semua faktorial r, n dan n - r; Fungsi mengembalikan jumlah XOR dari semua triplet yang tidak teratur dari array; Melangkah ke atas bit; Bilangan elemen yang masing -masing 1 dan 0; Memeriksa jika k 'th bit adalah 1; Menambah bahagian bit ini kepada jawapannya; Kod pemacu", "code": "using System ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; } static int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int [ ] fac = new int [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } static int SumOfXor ( int [ ] a , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; } public static void Main ( String [ ] args ) { int n = 5 ; int [ ] A = { 3 , 5 , 2 , 18 , 7 } ; Console . WriteLine ( SumOfXor ( A , n ) ) ; } }"}
{"text": "Kebarangkalian tidak mendapat dua kepala berturut -turut bersama -sama di N melemparkan duit syiling | C # Pelaksanaan untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut bersama apabila duit syiling N dibuang; Fungsi untuk mengira nombor Fibonacci N - Th dalam urutan di mana A = 2 dan B = 3; Dua nombor pertama dalam urutan dimulakan; Kes asas; Gelung untuk mengira urutan Fibonacci berdasarkan dua nombor pertama yang diasaskan; Fungsi untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut apabila duit syiling N dibuang; Mengira bilangan kes yang menggalakkan; Pengkomputeran bilangan semua hasil yang mungkin untuk N TOSses; Kod pemacu", "code": "using System ; class GFG { public static float round ( float var , int digit ) { float value = ( int ) ( var * Math . ( 10 , digit ) + .5 ) ; return ( float ) value / ( float ) Math . Pow ( 10 , digit ) ; } public static int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } } public static float operations ( int N ) { int x = probability ( N ) ; int y = ( int ) Math . Pow ( 2 , N ) ; return round ( ( float ) x / ( float ) y , 2 ) ; } public static void Main ( string [ ] args ) { int N = 10 ; Console . WriteLine ( ( operations ( N ) ) ) ; } }"}
{"text": "Semak jika nombor dibentuk dengan menyertai dua nombor adalah Cube Perfect | C # Program untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kiub yang sempurna atau tidak; Fungsi untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Menukar nombor ke rentetan menggunakan to_string (); Menggabungkan nombor dan menukarnya menjadi integer; Semak jika nilai yang disatukan adalah kiub sempurna atau tidak; Kod pemacu", "code": "using System ; class GFG { static bool isPerfectCube ( int x ) { double cr = Math . Round ( Math . Cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } static void checkCube ( int a , int b ) { string s1 = Convert . ToString ( a ) ; string s2 = Convert . ToString ( b ) ; int c = Convert . ToInt32 ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } public static void Main ( ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; } }"}
{"text": "Nombor terbesar dalam array yang dibentuk dengan berulang kali menggabungkan dua elemen yang sama | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan jumlah terbesar; Pembolehubah untuk menyimpan jumlah terbesar; Peta untuk menyimpan frekuensi setiap elemen; Menyimpan frekuensi; Gelung untuk menggabungkan elemen pendua dan mengemas kini jumlah dalam peta; Jika J adalah konsol elemen pendua. Tulis (m [arr [i]]); ; Kemas kini kekerapan 2 * j; Jika jumlah baru lebih besar daripada nilai maksimum, kemas kini maksimum; Mengembalikan jumlah terbesar; Kod pemacu; Fungsi panggilan", "code": "using System ; using System . Collections . Generic ; class GFG { static int largest_sum ( int [ ] arr , int n ) { int maximum = - 1 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { m [ arr [ i ] ] ++ ; } else { m . Add ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( m [ arr [ i ] ] > 1 ) { if ( m . ContainsKey ( 2 * arr [ i ] ) ) { m [ 2 * arr [ i ] ] = m [ 2 * arr [ i ] ] + m [ arr [ i ] ] / 2 ; } else { m . Add ( 2 * arr [ i ] , m [ arr [ i ] ] / 2 ) ; } if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } } return maximum ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = arr . Length ; Console . Write ( largest_sum ( arr , n ) ) ; } }"}
{"text": "Semak sama ada mungkin untuk membuat X dan Y Zero pada masa yang sama dengan Operasi yang diberikan | C # Program pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk membuat X dan Y boleh menjadi 0 pada masa yang sama; Semak syarat yang diberikan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void canBeReduced ( int x , int y ) { int maxi = Math . Max ( x , y ) ; int mini = Math . Min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } static void Main ( ) { int x = 6 , y = 9 ; canBeReduced ( x , y ) ; } }"}
{"text": "Algoritma Pemfaktoran Roda | C # Program untuk memeriksa sama ada nombor yang diberikan adalah kaedah pemfaktoran roda; Fungsi untuk memeriksa sama ada nombor x yang diberikan adalah perdana atau tidak; Roda untuk memeriksa nombor perdana; Kes asas; Semak nombor yang diambil sebagai asas; Semak roda di sini saya, bertindak sebagai lapisan roda; Semak senarai penapis dalam arr []; Jika nombor lebih besar daripada rehat Sqrt (n); Semak jika n adalah pelbagai nombor utama di roda; Jika di mana -mana lelaran isprime adalah palsu, pecah dari gelung; Kod pemandu; Fungsi panggilan untuk pemeriksaan primal", "code": "using System ; class GFG { static void isPrime ( int N ) { bool isPrime = true ; int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < ( int ) Math . Sqrt ( N ) ; i += 30 ) { foreach ( int c in arr ) { if ( c > ( int ) Math . Sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) Console . WriteLine ( \" Prime ▁ Number \" ) ; else Console . WriteLine ( \" Not ▁ a ▁ Prime ▁ Number \" ) ; } public static void Main ( String [ ] args ) { int N = 121 ; isPrime ( N ) ; } }"}
{"text": "Cari semua pasangan yang mungkin dari array yang diberikan | C # pelaksanaan untuk mencari semua pasangan yang mungkin dari array yang diberikan; Berfungsi untuk mencetak semua pasangan yang mungkin dari array; Gelung bersarang untuk semua pasangan yang mungkin; Kod pemacu", "code": "using System ; class GFG { static void printPairs ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( \" ( \" + arr [ i ] + \" , ▁ \" + arr [ j ] + \" ) \" + \" , ▁ \" ) ; } } } public static void Main ( string [ ] args ) { int [ ] arr = { 1 , 2 } ; int n = arr . Length ; printPairs ( arr , n ) ; } }"}
{"text": "Semak jika bulatan terletak di dalam bulatan lain atau tidak | C # Program untuk memeriksa sama ada satu bulatan terletak di dalam bulatan lain atau tidak. ; Kod pemacu", "code": "using System ; class GFG { static void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( int ) Math . Sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) { Console . WriteLine ( \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" + \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ \" + \" touching ▁ each ▁ other ▁ \" + \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" ) ; } else if ( distSq + r2 < r1 ) { Console . WriteLine ( \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" + \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ without \" + \" ▁ touching ▁ each ▁ other ▁ \" + \" at ▁ a ▁ point ▁ of ▁ circumference . \" ) ; } else { Console . WriteLine ( \" The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside \" + \" ▁ the ▁ bigger ▁ circle ▁ completely . \" ) ; } } static public void Main ( ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; } }"}
{"text": "Panjang tangen biasa langsung antara dua lingkaran bersilang | C # Program untuk mencari panjang tangen umum langsung antara dua kalangan yang saling berpotongan; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "using System ; class GFG { static void lengtang ( double r1 , double r2 , double d ) { Console . WriteLine ( \" The ▁ length ▁ of ▁ the ▁ direct \" + \" ▁ common ▁ tangent ▁ is ▁ \" + ( Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 - r2 ) , 2 ) ) ) ) ; } public static void Main ( String [ ] args ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; } }"}
{"text": "Radius bulatan apabila lebar dan ketinggian arka diberikan | C # Program untuk mencari jejari bulatan apabila lebar dan ketinggian arka diberikan; Berfungsi untuk mencari jejari; Kod pemacu", "code": "using System ; class GFG { static void rad ( double d , double h ) { Console . WriteLine ( \" The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ \" + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; } public static void Main ( ) { double d = 4 , h = 1 ; rad ( d , h ) ; } }"}
{"text": "Jarak terpendek dari pusat bulatan ke kord | C # Program untuk mencari jarak terpendek dari kord ke pusat bulatan; Berfungsi untuk mencari jarak terpendek; Kod pemacu", "code": "using System ; class GFG { static void shortdis ( double r , double d ) { Console . WriteLine ( \" The ▁ shortest ▁ distance ▁ \" + \" from ▁ the ▁ chord ▁ to ▁ centre ▁ \" + ( Math . Sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) ) ) ; } public static void Main ( ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; } }"}
{"text": "Panjang tangen biasa langsung antara kedua -dua bukan | C # Program untuk mencari panjang tangen umum langsung antara dua kalangan yang tidak menyentuh satu sama lain; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "using System ; class GFG { static void lengtang ( double r1 , double r2 , double d ) { Console . WriteLine ( \" The ▁ length ▁ of ▁ the ▁ direct \" + \" ▁ common ▁ tangent ▁ is ▁ \" + ( Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 - r2 ) , 2 ) ) ) ) ; } public static void Main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; } }"}
{"text": "Dataran terbesar yang boleh ditulis dalam segitiga sama rata | C # Program untuk mencari dataran terbesar yang boleh ditulis dalam segitiga sama rata; Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu", "code": "using System ; class GFG { static double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; } public static void Main ( ) { double a = 5 ; Console . WriteLine ( square ( a ) ) ; } }"}
{"text": "Apothem A N | C # Program untuk mencari apothem poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari apothem poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah ditukar kepada radian; Kod pemacu", "code": "using System ; class GFG { static double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; } public static void Main ( ) { double a = 9 , n = 6 ; Console . WriteLine ( Math . Round ( polyapothem ( n , a ) , 4 ) ) ; } }"}
{"text": "Kawasan n | C # Program untuk mencari kawasan poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "using System ; class GFG { static float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float A = ( a * a * n ) / ( float ) ( 4 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } public static void Main ( ) { float a = 9 , n = 6 ; Console . WriteLine ( polyarea ( n , a ) ) ; } }"}
{"text": "Sisi biasa n | C # pelaksanaan pendekatan; Fungsi untuk mengira sisi poligon yang dilampirkan dalam bulatan; Kod pemacu; Jumlah sisi poligon; Jejari lingkaran lingkungan", "code": "using System ; class GFG { static double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return Math . Round ( 2 * r * Math . Sin ( theta_in_radians / 2 ) , 4 ) ; } public static void Main ( ) { double n = 3 ; double r = 5 ; Console . WriteLine ( calculateSide ( n , r ) ) ; } }"}
{"text": "Silinder bulat kanan terbesar dalam frustum | C # Program untuk mencari silinder bulat kanan terbesar yang boleh sesuai dalam frustum; Berfungsi untuk mencari silinder bulat kanan terbesar; Radii dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "using System ; class GFG { static float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . Pow ( r1 , 2 ) * h1 ) ; return V ; } public static void Main ( ) { float r = 7 , R = 11 , h = 6 ; Console . WriteLine ( cyl ( r , R , h ) ) ; } }"}
{"text": "Program untuk mencari perimeter poligon biasa | C # Program untuk mencari perimeter poligon biasa; Berfungsi untuk mengira perimeter; Hitung perimeter; Kod pemacu; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter", "code": "using System ; class GFG { static double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; } static public void Main ( ) { int n = 5 ; double s = 2.5 , peri ; peri = Perimeter ( s , n ) ; Console . WriteLine ( \" Perimeter ▁ of ▁ Regular ▁ Polygon \" + \" ▁ with ▁ \" + n + \" ▁ sides ▁ of ▁ length ▁ \" + s + \" ▁ = ▁ \" + peri ) ; } }"}
{"text": "Kawasan rombang terbesar yang boleh ditulis dalam segi empat tepat | C # Program untuk mencari rombus terbesar yang boleh ditulis dalam segi empat tepat; Berfungsi untuk mencari kawasan rombus terbesar; Panjang dan keluasan tidak boleh negatif; kawasan rhombus; Kod pemacu", "code": "using System ; class GFG { static float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; } public static void Main ( ) { float l = 16 , b = 6 ; Console . WriteLine ( rhombusarea ( l , b ) ) ; } }"}
{"text": "Semak jika titik terletak di dalam segi empat tepat | Set | C # Program untuk memeriksa sama ada titik terletak pada atau di dalam segi empat tepat | Set - 2; Fungsi untuk mencari jika titik diberikan terletak di dalam segi empat tepat atau tidak. ; Kod pemacu; bawah - kiri dan atas - sudut kanan segi empat tepat; titik yang diberikan; panggilan fungsi", "code": "using System ; class GFG { static bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; } public static void Main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Jarak antara satu titik dan satah dalam 3 D | C # Program untuk mencari jarak serenjang (terpendek) antara satu titik dan satah dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . Abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . Sqrt ( a * a + b * b + c * c ) ; Console . Write ( \" Perpendicular ▁ distance ▁ \" + \" is ▁ \" + d / e ) ; } public static void Main ( ) { float x1 = 4 ; float y1 = - 4 ; float z1 = 3 ; float a = 2 ; float b = - 2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; } }"}
{"text": "Program untuk mencari jumlah prisma segi tiga | C # Program untuk mencari kelantangan prisma segitiga; berfungsi untuk mencari jumlah prisma segi tiga; formula untuk mencari kelantangan; Kod pemacu; fungsi panggilan", "code": "using System ; class GFG { static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } static public void Main ( ) { float l = 18 , b = 12 , h = 9 ; Console . WriteLine ( \" Volume ▁ of ▁ triangular ▁ prism : ▁ \" + findVolume ( l , b , h ) ) ; } }"}
{"text": "Semak jika diberi empat bilangan bulat (atau sisi) membuat segi empat tepat | Program mudah untuk mencari jika diberikan 4 nilai boleh mewakili 4 sisi segi empat tepat; Fungsi untuk memeriksa sama ada nilai integer yang diberikan membuat segi empat tepat; Square juga merupakan segi empat tepat; Kod pemacu", "code": "using System ; class GFG { static bool isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } public static void Main ( ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Program untuk mencari pertengahan | C # Program untuk mencari titik tengah garis; berfungsi untuk mencari titik tengah garis; Kod pemacu", "code": "using System ; class GFG { static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { Console . WriteLine ( ( x1 + x2 ) / 2 + \" ▁ , ▁ \" + ( y1 + y2 ) / 2 ) ; } public static void Main ( ) { int x1 = - 1 , y1 = 2 ; int x2 = 3 , y2 = - 6 ; midpoint ( x1 , x2 , y1 , y2 ) ; } }"}
{"text": "Panjang arka dari sudut yang diberikan | C # Program untuk mengira panjang arka; fungsi untuk mengira panjang arka; Kod pemacu", "code": "using System ; public class GFG { static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { Console . WriteLine ( \" Angle ▁ cannot \" + \" ▁ be ▁ formed \" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } public static void Main ( ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; Console . WriteLine ( arc_len ) ; } }"}
{"text": "Semak sama ada garis menyentuh atau memotong bulatan | C # Program untuk memeriksa sama ada garis menyentuh atau bersilang atau di luar bulatan. ; Mencari jarak garis dari pusat. ; Memeriksa jika jarak kurang daripada, lebih besar daripada atau sama dengan radius. ; Program yang didorong", "code": "using System ; class GFG { static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . Abs ( a * x + b * y + c ) ) / Math . Sqrt ( a * a + b * b ) ; if ( radius == dist ) Console . WriteLine ( \" Touch \" ) ; else if ( radius > dist ) Console . WriteLine ( \" Intersect \" ) ; else Console . WriteLine ( \" Outside \" ) ; } public static void Main ( ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; } }"}
{"text": "Program untuk mencari kawasan segitiga | C # Program untuk menilai kawasan formula Polygon Usingshoelace; (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; J adalah puncak sebelumnya kepada i; Kembali nilai mutlak; Program Pemandu", "code": "using System ; class GFG { static double polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . Abs ( area / 2.0 ) ; } public static void Main ( ) { double [ ] X = { 0 , 2 , 4 } ; double [ ] Y = { 1 , 3 , 7 } ; int n = X . Length ; Console . WriteLine ( polygonArea ( X , Y , n ) ) ; } }"}
{"text": "Memaksimumkan jumlah LSB bitwise atau semua mungkin n / 2 pasang dari array yang diberikan | C # Program untuk pendekatan di atas; Fungsi atas mendapatkan nilai LSB V; Penukaran binari; Fungsi untuk mencari jumlah LSB semua pasangan yang mungkin dari array yang diberikan; Menyimpan elemen array LSB; Menyimpan nilai LSB; Susun array lab_arr []; Mengambil jumlah pasangan untuk mendapatkan jumlah maksimum LSB; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; public class GFG { static int chk ( int n ) { List < int > v = new List < int > ( ) ; while ( n != 0 ) { v . Add ( n % 2 ) ; n = n / 2 ; } int j = 0 ; foreach ( int i in v ) { if ( i == 1 ) { return ( int ) Math . Pow ( 2.0 , ( double ) j ) ; } j ++ ; } return 0 ; } static void sumOfLSB ( int [ ] arr , int N ) { int [ ] lsb_arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lsb_arr [ i ] = chk ( arr [ i ] ) ; } Array . Sort ( lsb_arr ) ; int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i += 2 ) { ans += ( lsb_arr [ i + 1 ] ) ; } Console . WriteLine ( ans ) ; } static public void Main ( ) { int N = 5 ; int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; sumOfLSB ( arr , N ) ; } }"}
{"text": "Kira -kira berikutnya yang mempunyai bitwise dan nilai -nilai yang ganjil dalam array yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mencari kiraan berikutnya yang mempunyai bitwise dan nilai ganjil; Kedai mengira unsur -unsur ganjil; Melintasi array arr []; Jika x adalah kiraan kenaikan ganjil; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "using System ; public class GFG { static int countSubsequences ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } public static void Main ( string [ ] args ) { int N = 3 ; int [ ] arr = { 1 , 3 , 3 } ; Console . WriteLine ( countSubsequences ( arr , N ) ) ; } }"}
{"text": "Kira pasangan dari array dengan perbezaan mutlak tidak kurang daripada elemen minimum dalam pasangan | C # Program untuk pendekatan di atas; Fungsi untuk mencari bilangan pasangan (i, j) seperti abs (a [i] - a [j]) sekurang -kurangnya minimum (a [i], a [j]); Menyimpan kiraan pasangan yang dihasilkan; Melangkah ke atas julat [0, n]; Berulang dari arr [i] - (i % arr [i]) hingga n dengan kenaikan arr [i]; Mengira pasangan yang mungkin; Mengembalikan jumlah jumlah; Kod pemacu", "code": "using System ; class GFG { static int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . Abs ( arr [ i ] - arr [ j ] ) >= Math . Min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 2 , 3 } ; int N = arr . Length ; Console . Write ( getPairsCount ( arr , N ) ) ; } }"}
{"text": "Langkah Minimum Untuk Menukar N hingga 1 dengan menukarnya menjadi 2 * n atau n / 10 pada mana -mana langkah | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada n boleh diubah menjadi 1 atau tidak. ; Kira bilangan 2 dalam faktorisasi utama N; Mengira bilangan 5 dalam faktorisasi utama N; Kod pemacu", "code": "using System ; class GFG { static void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { Console . Write ( 2 * fives - twos ) ; } else { Console . Write ( - 1 ) ; } } public static void Main ( ) { int N = 50 ; check ( N ) ; } }"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | C # Program untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah elemen array dari L ke R; Melintasi L ke R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static void rangeSum ( int [ ] arr , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } Console . Write ( sum ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . Length ; rangeSum ( arr , N , L , R ) ; } }"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | C # Program untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah awalan; Kirakan jumlah awalan; Menyimpan jumlah elemen dari 1 hingga l - 1; Menyimpan jumlah elemen dari 1 hingga R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "using System ; class GFG { static void rangeSum ( int [ ] arr , int N , int L , int R ) { int [ ] prefix = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; Console . Write ( rightsum - leftsum ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . Length ; rangeSum ( arr , N , L , R ) ; } }"}
{"text": "Faktorial eksponen n | C # Program untuk pendekatan di atas; Berfungsi untuk mencari faktorial eksponen nombor tertentu; Menyimpan faktor exponetial N; Iterare ke atas julat [2, n]; Kemas kini res; Kembali res; Kod pemacu; Input; Panggilan fungsi", "code": "using System ; class GFG { static int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) Math . Pow ( i , res ) % mod ; return res ; } public static void Main ( ) { int N = 4 ; Console . Write ( ExpoFactorial ( N ) ) ; } }"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Set | C # Program untuk pendekatan di atas; Fungsi untuk mencari subarray bersebelahan dengan jumlah maksimum jika array diulang kali k; Simpan jumlah array arr []; Melintasi array dan cari jumlah; Simpan jawapannya; Jika k = 1; Memohon algoritma Kadane untuk mencari jumlah; Kembalikan jawapannya; Menyimpan array dua kali berulang; Melintasi julat [0, 2 * n]; Menyimpan jumlah akhiran maksimum; Menyimpan jumlah awalan maksimum; Memohon algoritma Kadane untuk 2 pengulangan array; Jika jumlah array lebih besar daripada 0; Kembalikan jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int maxSubArraySumRepeated ( int [ ] arr , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = Math . Max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . Max ( ans , curr ) ; } return ans ; } List < int > V = new List < int > ( ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . Add ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = Math . Max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = Math . Max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = Math . Max ( V [ i ] , curr + V [ i ] ) ; ans = Math . Max ( ans , curr ) ; } if ( sum > 0 ) { int temp = sum * ( K - 2 ) ; ans = Math . Max ( ans , Math . Max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { 10 , 20 , - 30 , - 1 , 40 } ; int N = arr . Length ; int K = 10 ; Console . WriteLine ( maxSubArraySumRepeated ( arr , N , K ) ) ; } }"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | C # Program untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan kiraan subarray; Menjana semua subarray yang mungkin; Menyimpan elemen maksimum subarray; Menyimpan maksimum semua elemen lain; Cari elemen maksimum dalam subarray [i, j]; Cari maksimum semua elemen lain; Jika maksimum subarray lebih besar daripada dua kali ganda maksimum elemen lain; Cetak nilai maksimum yang diperoleh; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void countSubarray ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = Math . Max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = Math . Max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = Math . Max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } Console . Write ( count ) ; } public static void Main ( ) { int [ ] arr = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . Length ; countSubarray ( arr , N ) ; } }"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | C # Program untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan elemen maksimum array; Melintasi array yang diberikan; Jika nilai 2 * arr [i] lebih besar daripada MX; Kemas kini nilai l dan keluar dari gelung; Jika nilai 2 * arr [i] lebih besar daripada Mx; Mengemas kini nilai r dan keluar dari gelung; Cetak jawapan terakhir; Kod pemacu", "code": "using System ; class GFG { static void countSubarray ( int [ ] arr , int n ) { int L = 0 , R = 0 ; int mx = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . Max ( mx , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } Console . WriteLine ( ( L + 1 ) * ( n - R ) ) ; } public static void Main ( ) { int [ ] arr = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . Length ; countSubarray ( arr , N ) ; } }"}
{"text": "Cari Nombor Perdana hanya kurang daripada dan hanya lebih besar setiap elemen array yang diberikan | C # Program untuk pendekatan di atas; Fungsi utiliti untuk memeriksa keunggulan nombor X dengan memeriksa sama ada X mempunyai faktor selain daripada 1 dan sendiri. ; Faktor yang dijumpai; Berfungsi untuk mencetak prima hanya kurang daripada dan hanya lebih besar daripada setiap elemen dalam array; Melintasi array; Traverse untuk mencari perdana kurang daripada [i]; Perdana hanya kurang daripada yang dijumpai; Melintasi untuk mencari perdana lebih besar daripada [i]; Perdana hanya lebih besar daripada yang dijumpai; Kod pemacu; Input; Panggilan fungsi", "code": "using System ; class GFG { static bool isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) if ( X % i == 0 ) return false ; return true ; } static void printPrimes ( int [ ] A , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( isPrime ( j ) ) { Console . Write ( j + \" ▁ \" ) ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( isPrime ( j ) ) { Console . Write ( j + \" ▁ \" ) ; break ; } } Console . WriteLine ( ) ; } } public static void Main ( ) { int [ ] A = { 17 , 28 } ; int N = A . Length ; printPrimes ( A , N ) ; } }"}
{"text": "Elemen terkecil kth dalam array yang mengandungi [i] betul -betul b [i] kali | C # Program untuk pendekatan di atas; Fungsi untuk mencari elemen terkecil kth yang mengandungi [i] tepat b [i] kali; Melintasi array yang diberikan; Menyimpan kekerapan setiap elemen; Melintasi array yang diberikan; Memulakan pembolehubah untuk menyimpan jumlah awalan; Melangkah ke atas julat [0, M]; Jumlah kenaikan oleh freq [i]; Jika jumlah lebih besar daripada atau sama dengan k; Mengembalikan elemen semasa sebagai jawapan; Kembali - 1; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; class GFG { static int KthSmallest ( int [ ] A , int [ ] B , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . Max ( A [ i ] , M ) ; } int [ ] freq = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return - 1 ; } public static void Main ( String [ ] args ) { int [ ] A = { 3 , 4 , 5 } ; int [ ] B = { 2 , 1 , 3 } ; int N = A . Length ; int K = 4 ; Console . Write ( KthSmallest ( A , B , N , K ) ) ; } }"}
{"text": "Bitwise atau bitwise dan semua subarrays array | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarrays; Menyimpan hasil yang diperlukan; Menjana semua subarray; Simpan elemen semasa; Cari bitwise atau; Mengemas kini hasilnya; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { static void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } Console . Write ( res ) ; } static void Main ( ) { int [ ] A = { 1 , 2 , 3 } ; int N = A . Length ; findbitwiseOR ( A , N ) ; } }"}
{"text": "Bitwise atau bitwise dan semua subarrays array | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subset berturut -turut dari array; Menyimpan hasil yang diperlukan; Melintasi array yang diberikan; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { static void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; Console . Write ( res ) ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 3 } ; int N = A . Length ; findbitwiseOR ( A , N ) ; } }"}
{"text": "Semak jika jumlah digit nombor melebihi produk digit nombor itu | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada jumlah digit N adalah lebih besar daripada produk digit N atau tidak; Menyimpan jumlah dan produk digit N; Menyimpan digit terakhir jika n; Kenaikan nilai sumofdigit; Mengemas kini prodofdigit; Bahagikan n oleh 10; Cetak hasilnya; Kod pemacu", "code": "using System ; class GFG { static void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } public static void Main ( ) { int N = 1234 ; check ( N ) ; } }"}
{"text": "Cetak semua awalan yang berbeza dan ganjil bitwise xors pertama n Nombor semula jadi | C # Program untuk pendekatan di atas; Cetak semua awalan yang berbeza & ganjil bitwise xors dari 1 hingga n; Cetak nombor juga; Cetak nombor ganjil; Kod pemacu", "code": "using System ; class GFG { static void evenOddBitwiseXOR ( int N ) { Console . Write ( \" Even : ▁ \" + 0 + \" ▁ \" ) ; for ( int i = 4 ; i <= N ; i = i + 4 ) { Console . Write ( i + \" ▁ \" ) ; } Console . Write ( \" STRNEWLINE \" ) ; Console . Write ( \" Odd : ▁ \" + 1 + \" ▁ \" ) ; for ( int i = 4 ; i <= N ; i = i + 4 ) { Console . Write ( i - 1 + \" ▁ \" ) ; } if ( N % 4 == 2 ) Console . Write ( N + 1 ) ; else if ( N % 4 == 3 ) Console . Write ( N ) ; } public static void Main ( ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; } }"}
{"text": "Permutasi terbesar lexicographically mungkin dengan swap yang lebih kecil daripada array yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk permutasi terbesar lexicographic mungkin dengan swap yang lebih kecil daripada array yang diberikan; Cari indeks elemen pertama sedemikian rupa sehingga arr [i]> arr [i + 1]; Jika array disusun dalam peningkatan urutan; Cari indeks elemen pertama yang lebih kecil daripada arr [i]; Jika arr [j] = = arr [j - 1]; Pengurangan j; Swap elemen; Cetak array arr []; Kod pemacu", "code": "using System ; class GFG { static void findPermutation ( int [ ] arr ) { int N = arr . Length ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == - 1 ) { Console . Write ( \" - 1\" ) ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; foreach ( int it in arr ) { Console . Write ( it + \" ▁ \" ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; } }"}
{"text": "Perbezaan mutlak antara kiraan ganjil dan juga faktor n | C # Program untuk pendekatan di atas; Berfungsi untuk mencari faktor utama terkecil dari semua nombor menggunakan ayak eratosthenes; Kedai sama ada nombor mana -mana atau tidak; Memulakan faktor terkecil sebagai 2 untuk semua nombor walaupun; Melangkah ke atas julat [3, n]; Sekiranya saya adalah perdana; Melepasi semua gandaan i; Saya adalah faktor utama terkecil i * j; Fungsi untuk mencari perbezaan mutlak antara kiraan ganjil dan juga faktor n; Menyimpan faktor utama terkecil i; Isi nilai dalam S [] menggunakan ayak eratosthenes; Menyimpan jumlah faktor dan jumlah faktor ganjil dan bahkan; Simpan faktor utama semasa nombor n; Simpan kuasa faktor utama semasa; Gelung manakala n lebih besar daripada 1; Jika n juga mempunyai faktor utama terkecil seperti Curr, maka kenaikan CNT oleh 1; Kemas kini hanya jumlah faktor jika curr adalah 2; Mengemas kini jumlah faktor dan jumlah faktor ganjil; Mengemas kini faktor utama semasa S [n] dan dikira sebagai 1; Kirakan bilangan faktor walaupun; Cetak perbezaan; Kod pemacu", "code": "using System ; class GFG { static void sieveOfEratosthenes ( int N , int [ ] s ) { bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } static void findDifference ( int N ) { int [ ] s = new int [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; Console . Write ( Math . Abs ( even - odd ) ) ; } public static void Main ( ) { int N = 12 ; findDifference ( N ) ; } }"}
{"text": "Kirakan median dari nilai min dan mod yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari median sekumpulan data dengan min dan mod yang diberikan; Kirakan median; Cetak median; Kod pemacu", "code": "using System ; class GFG { static void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; Console . Write ( Median ) ; } public static void Main ( ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; } }"}
{"text": "Program untuk mencari magnitud vektor | C # Program untuk pendekatan di atas; Berfungsi untuk mengira magnitud vektor 3 dimensi; Menyimpan jumlah kuadrat koordinat vektor; Mengembalikan magnitud; Kod pemacu", "code": "using System ; class GFG { private static double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return Math . Sqrt ( sum ) ; } static void Main ( ) { int x = 1 ; int y = 2 ; int z = 3 ; Console . Write ( vectorMagnitude ( x , y , z ) ) ; } }"}
{"text": "Program untuk mencari produk nombor dengan nombor Mersenne | C # Program untuk pendekatan di atas; Berfungsi untuk mencari prodcut nombor Mersenne dengan nombor lain; Menyimpan kuasa 2 integer m + 1; Mengembalikan produk; Kod pemacu", "code": "using System ; class GFG { static int multiplyByMersenne ( int N , int M ) { int x = ( int ) ( Math . Log ( M + 1 ) / Math . Log ( 2 ) ) ; return ( ( N << x ) - N ) ; } static public void Main ( ) { int N = 4 ; int M = 15 ; Console . Write ( multiplyByMersenne ( N , M ) ) ; } }"}
{"text": "Kuasa terdekat 2 dari dataran sempurna terdekat bukan | C # Program untuk pendekatan di atas; Berfungsi untuk mencari persegi yang paling dekat dengan Num; Kirakan akar kuadrat NUM; Kirakan persegi sempurna; Cari dataran sempurna terdekat; Berfungsi untuk mencari kuasa 2 yang paling dekat dengan nombor nombor; Hitung asas log 2 dari NUM; Kuasa tertinggi 2 iaitu <= num; Berfungsi untuk mencari persegi sempurna yang terdekat dan kuasa terdekat 2 dari setiap elemen array yang kejadiannya adalah 1; Kedai kekerapan elemen array; Melintasi array dan kemas kini kekerapan elemen array semasa; Melintasi peta freq; Jika kekerapan adalah 1; Cari persegi sempurna yang terdekat; Cetak kuasa terdekat 2; Sekiranya mana -mana tidak mengandungi unsur -unsur yang tidak berulang; Kod pemacu", "code": "using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static int perfectSquare ( int num ) { int sr = ( int ) ( Math . Sqrt ( num ) ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } } static int powerOfTwo ( int num ) { int lg = ( int ) ( Math . Log ( num ) / Math . Log ( 2 ) ) ; int p = ( int ) ( Math . Pow ( 2 , lg ) ) ; return p ; } static void uniqueElement ( int [ ] arr , int N ) { bool ans = true ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq [ arr [ i ] ] = 1 ; } } foreach ( var el in freq . OrderBy ( el => el . Key ) ) { if ( el . Value == 1 ) { ans = false ; int ps = perfectSquare ( el . Key ) ; Console . Write ( powerOfTwo ( ps ) + \" ▁ \" ) ; } } if ( ans ) Console . Write ( \" - 1\" ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 4 , 11 , 4 , 3 , 4 } ; int N = arr . Length ; uniqueElement ( arr , N ) ; } }"}
{"text": "Arahan partition menjadi dua subarray dengan setiap elemen di subarray kanan dengan ketat daripada setiap elemen di subarray kiri | C # Program pendekatan di atas; Berfungsi untuk memisahkan array menjadi dua subarrays bukan kosong yang memenuhi syarat yang diberikan; Menyimpan array akhiran min; Menyimpan minimum akhiran; Melintasi array secara terbalik; Mengemas kini minimum; Simpan minimum; Menyimpan nilai maksimum awalan; Menyimpan indeks partition; Kemas kini Max; Jika max kurang daripada min [i + 1]; Simpan indeks partition; rehat; Jika Ind tidak - 1; Cetak subarray pertama; Cetak subarray kedua; Jika tidak; Kod pemacu", "code": "using System ; class GFG { static void partitionArray ( int [ ] a , int n ) { int [ ] min = new int [ n ] ; int mini = Int32 . MaxValue ; for ( int i = n - 1 ; i >= 0 ; i -- ) { mini = Math . Min ( mini , a [ i ] ) ; min [ i ] = mini ; } int maxi = Int32 . MinValue ; int ind = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { maxi = Math . Max ( maxi , a [ i ] ) ; if ( maxi < min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != - 1 ) { for ( int i = 0 ; i <= ind ; i ++ ) Console . Write ( a [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; for ( int i = ind + 1 ; i < n ; i ++ ) Console . Write ( a [ i ] + \" ▁ \" ) ; } else Console . Write ( \" Impossible \" ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 5 , 3 , 2 , 7 , 9 } ; int N = arr . Length ; partitionArray ( arr , N ) ; } }"}
{"text": "Semak sama ada nombor boleh diwakili sebagai jumlah integer positif k di mana sekurang -kurangnya k | C # Program untuk pendekatan di atas; Berfungsi untuk mengira semua faktor utama nombor tertentu; Kira bilangan 2 s yang membahagikan n; Oleh kerana N adalah ganjil pada ketika ini, langkau satu elemen; Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Jika n adalah nombor perdana yang lebih besar daripada 2; Berfungsi untuk mencari jumlah nombor pertama N hampir utama; Simpan jumlah yang diperlukan; Tambah nombor ini jika ia memenuhi syarat; Kiraan kenaikan hampir nombor utama; Fungsi untuk memeriksa sama ada n boleh diwakili sebagai jumlah k antara bilangan bulat positif yang berbeza di mana sekurang -kurangnya k - 1 daripadanya adalah hampir perdana; Simpan jumlah pertama k - 1 hampir nombor utama; Jika jumlah lebih besar daripada atau sama dengan n; Jika tidak, cetak ya; Kod pemacu", "code": "using System ; public class GFG { static int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= ( int ) Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; } static void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) Console . WriteLine ( \" No \" ) ; else Console . WriteLine ( \" Yes \" ) ; } public static void Main ( String [ ] args ) { int n = 100 , k = 6 ; check ( n , k ) ; } }"}
{"text": "Kira cara untuk mewakili integer sebagai eksponen | C # Program untuk pendekatan di atas; Berfungsi untuk mengira GCD A dan B menggunakan algoritma Euclidean; Iterat sehingga B bukan sifar; Mengembalikan GCD; Fungsi untuk mengira bilangan cara n boleh dinyatakan sebagai x ^ y; Kes asas; Menyimpan GCD kuasa; Kirakan tahap 2 dalam n; Kirakan tahap nombor utama dalam n; Kirakan tahap perdana 'i' dalam n; Jika n adalah perdana, G menjadi 1 .; Menyimpan bilangan cara untuk mewakili n sebagai x ^ y; Cari bilangan faktor G; Mengemas kini kiraan cara; Berulang untuk mencari bilangan nombor perdana; Cari kuasa i; Mengemas kini kiraan cara; Jika G adalah Perdana; Mengembalikan jumlah cara; Kod pemacu", "code": "using System ; public class GFG { static int gcd ( int a , int b ) { while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; } return a ; } static int countNumberOfWays ( int n ) { if ( n == 1 ) return - 1 ; int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= ( int ) Math . Sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= ( int ) Math . Sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } public static void Main ( String [ ] args ) { int N = 64 ; Console . Write ( countNumberOfWays ( N ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan integer yang diberikan | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor positif yang diberikan; Fungsi lantai digunakan untuk menentukan nilai yang dekat dengan nombor; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor negatif yang diberikan; Fungsi Ceil digunakan untuk nombor negatif sebagai - 1> - 4. Ia akan bertentangan dengan nombor positif di mana 1 <4; Berfungsi untuk mencari kuasa tertinggi 2; Untuk memeriksa sama ada nombor yang diberikan positif atau negatif; Jika nombor itu negatif, maka siling nombor positif dikira dan tanda negatif ditambah; Kod pemacu", "code": "using System ; class GFG { static int powOfPositive ( int n ) { int pos = ( int ) Math . Floor ( ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; return ( int ) Math . Pow ( 2 , pos ) ; } static int powOfNegative ( int n ) { int pos = ( int ) Math . Ceiling ( ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . Pow ( 2 , pos ) ) ; } static void highestPowerOf2 ( int n ) { if ( n > 0 ) { Console . WriteLine ( powOfPositive ( n ) ) ; } else { n = - n ; Console . WriteLine ( powOfNegative ( n ) ) ; } } public static void Main ( ) { int n = - 24 ; highestPowerOf2 ( n ) ; } }"}
{"text": "Bilangan kad yang diperlukan membina rumah kad tahap n | C # pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan kad yang diperlukan; Kod pemacu", "code": "using System ; class GFG { public static int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . Write ( noOfCards ( n ) ) ; } }"}
{"text": "Cari nombor terkecil dari sejumlah besar yang diberikan dengan kiraan digit yang sama | C # pelaksanaan pendekatan di atas; Fungsi untuk mencari nombor yang paling kecil selepas menukar digit beberapa kali; Pembolehubah untuk menyimpan jawapan yang dibaca; Array untuk menyimpan kiraan kejadian setiap digit; Gelung untuk mengira bilangan kejadian setiap digit; Gelung untuk mendapatkan nombor terkecil; Mengembalikan jawapannya; Kod pemacu", "code": "using System ; class GFG { static String smallestPoss ( String s , int n ) { String ans = \" \" ; int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + String . Join ( \" \" , i ) ; } return ans ; } public static void Main ( String [ ] args ) { int N = 15 ; String K = \"325343273113434\" ; Console . Write ( smallestPoss ( K , N ) ) ; } }"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan sub -tatasusunan dengan jumlah yang lebih besar daripada unsur -unsur array yang tinggal; Untuk gelung untuk titik permulaan subarray; Untuk gelung untuk titik akhir subarray; Permulaan subarray_sum dan sisa_sum hingga 0; Untuk gelung untuk mengira jumlah subarray yang dihasilkan; Untuk gelung untuk mengira unsur array sisa jumlah; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah unsur array yang tinggal; Kod pemacu", "code": "using System ; class GFG { static int Count_subarray ( int [ ] arr , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 9 , 12 , 6 } ; int n = arr . Length ; Console . Write ( Count_subarray ( arr , n ) ) ; } }"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | C # pelaksanaan pendekatan di atas; Mengira jumlah jumlah array yang diberikan; Untuk gelung untuk titik permulaan subarray; permulaan subarray_sum hingga 0; Untuk gelung untuk mengira subarray_sum dan sisa_sum; Mengira subarray_sum dan sisa yang sama; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah baki elemen array; Kod pemacu", "code": "using System ; class GFG { static int Count_subarray ( int [ ] arr , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } public static void Main ( ) { int [ ] arr = { 10 , 9 , 12 , 6 } ; int n = arr . Length ; Console . WriteLine ( Count_subarray ( arr , n ) ) ; } }"}
{"text": "Keluarkan satu elemen untuk mendapatkan XOR maksimum | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan XOR yang dimaksimumkan selepas mengeluarkan elemen dari array; Cari xor array lengkap; Untuk menyimpan jawapan yang dibaca; Melangkah melalui array untuk mencari jawapan yang dibaca; Kembalikan jawapan yang dibaca; Kod pemacu", "code": "using System ; class GFG { static int maxXOR ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 3 } ; int n = arr . Length ; Console . WriteLine ( maxXOR ( arr , n ) ) ; } }"}
{"text": "Kira nombor dari julat [l, r] yang mengandungi sekurang -kurangnya satu digit yang membahagikan k | C # pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika NUM mengandungi sekurang -kurangnya satu digit yang membahagikan k; Dapatkan digit terakhir; Jika digit bukan sifar dan ia membahagikan k; Keluarkan digit terakhir; Tiada digit dalam num yang membahagikan k; Fungsi untuk mengembalikan kiraan unsur -unsur yang diperlukan dari julat yang diberikan yang mengandungi sekurang -kurangnya satu digit yang membahagikan k; Untuk menyimpan hasilnya; Untuk setiap nombor dari julat; Jika mana -mana digit nombor semasa membahagikan k; Kod pemacu", "code": "using System ; class GFG { static bool digitDividesK ( int num , int k ) { while ( num != 0 ) { int d = num % 10 ; if ( d != 0 && k % d == 0 ) return true ; num = num / 10 ; } return false ; } static int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; } public static void Main ( ) { int l = 20 , r = 35 ; int k = 45 ; Console . WriteLine ( findCount ( l , r , k ) ) ; } }"}
{"text": "Semak jika nombor tertentu adalah faktorial mana -mana nombor | C # pelaksanaan untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah faktorial bagi mana -mana nombor; Kod pemacu", "code": "using System ; class GFG { static Boolean isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } public static void Main ( String [ ] args ) { int n = 24 ; Boolean ans = isFactorial ( n ) ; if ( ans == true ) { Console . WriteLine ( \" Yes \" ) ; } else { Console . WriteLine ( \" No \" ) ; } } }"}
{"text": "Keluarkan elemen untuk meminimumkan LCM array yang diberikan | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan LCM dua nombor; Berfungsi untuk mengembalikan LCM minimum selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik negara tunggal untuk menyimpan LCM unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan LCM dari semua elemen yang mempunyai indeks lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan LCM minimum; Kod pemacu", "code": "using System ; class GFG { static int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; } static int MinLCM ( int [ ] a , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . Min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . Min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int [ ] a = { 5 , 15 , 9 , 36 } ; int n = a . Length ; Console . WriteLine ( MinLCM ( a , n ) ) ; } }"}
{"text": "Bilangan berwarna 0 dalam n | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan berwarna 0 s dalam segi enam tahap n; Kod pemacu", "code": "using System ; class GFG { static int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( count ( n ) ) ; } }"}
{"text": "Nilai minimum yang akan diberikan kepada unsur -unsur supaya jumlahnya menjadi lebih besar daripada jumlah awal | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan nilai minimum yang diperlukan; Cari jumlah elemen array; Mengembalikan nilai yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int findMinValue ( int [ ] arr , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; } static public void Main ( ) { int [ ] arr = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . Length ; Console . WriteLine ( findMinValue ( arr , n ) ) ; } }"}
{"text": "Warna semua kotak sejajar supaya setiap kotak berturut -turut m adalah unik | C # pelaksanaan pendekatan di atas; Fungsi untuk kembali (M! % Mod); Kod pemacu", "code": "using System ; class GFG { const int MOD = 1000000007 ; static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } public static void Main ( ) { int n = 3 , m = 2 ; Console . WriteLine ( modFact ( n , m ) ) ; } }"}
{"text": "Jumlah kuadrat semua subset dari array yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kuadrat subset; Squuaring unsur -unsur dan menambahkannya ke Ans; Kod pemacu", "code": "using System ; class GFG { static readonly int mod = ( int ) ( 1e9 + 7 ) ; static long power ( int p ) { long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } static long subset_square_sum ( int [ ] A ) { int n = A . Length ; long ans = 0 ; foreach ( int i in A ) { ans += ( 1 * i * i ) % mod ; ans %= mod ; } return ( 1 * ans * power ( n - 1 ) ) % mod ; } public static void Main ( String [ ] args ) { int [ ] A = { 3 , 7 } ; Console . WriteLine ( subset_square_sum ( A ) ) ; } }"}
{"text": "Cari bilangan pasangan supaya GCD mereka sama dengan 1 | C # Program untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Berfungsi untuk mengira faktor utama paling kurang setiap nombor; Jika ia adalah nombor utama; Untuk semua gandaan yang belum dikunjungi. ; Berfungsi untuk mencari nilai fungsi Mobius untuk semua nombor dari 1 hingga n; Jika nombor adalah satu; Jika nombor mempunyai faktor utama kuasa; Multiply - 1 dengan nombor sebelumnya; Berfungsi untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Untuk menyimpan nombor maksimum; Untuk menyimpan kekerapan setiap nombor; Cari kekerapan dan nombor maksimum; Untuk menyimpan nombor pasangan dengan GCD sama dengan 1; Melintasi semua elemen yang mungkin; Mengembalikan bilangan pasangan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int N = 100050 ; static int [ ] lpf = new int [ N ] ; static int [ ] mobius = new int [ N ] ; static void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) if ( lpf [ j ] == 0 ) lpf [ j ] = i ; } static void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } } static int gcd_pairs ( int [ ] a , int n ) { int maxi = 0 ; int [ ] fre = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . Max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . Length ; Console . Write ( gcd_pairs ( a , n ) ) ; } }"}
{"text": "Membandingkan x ^ y dan y ^ x untuk nilai -nilai yang sangat besar x dan y | C # pelaksanaan pendekatan; Fungsi untuk membandingkan x ^ y dan y ^ x; Menyimpan nilai x ^ y dan y ^ x; Membandingkan nilai; Kod pemacu", "code": "using System ; class GFG { static void compareVal ( double x , double y ) { double a = y * Math . Log ( x ) ; double b = x * Math . Log ( y ) ; if ( a > b ) Console . Write ( x + \" ^ \" + y + \" ▁ > ▁ \" + y + \" ^ \" + x ) ; else if ( a < b ) Console . Write ( x + \" ^ \" + y + \" ▁ < ▁ \" + y + \" ^ \" + x ) ; else if ( a == b ) Console . Write ( x + \" ^ \" + y + \" ▁ = ▁ \" + y + \" ^ \" + x ) ; } static public void Main ( ) { double x = 4 , y = 5 ; compareVal ( x , y ) ; } }"}
{"text": "Nombor Euler Zigzag (Permutasi Ganti) | C # Program untuk mencari urutan zigzag; Berfungsi untuk mencetak nombor zigzag pertama; Untuk menyimpan nombor factorial dan n 'th zig zag; Memulakan factorial sehingga n; Tetapkan dua nombor Zig Zag pertama; Cetak dua nombor zig zag pertama; Cetak nombor zig zag selebihnya; Binomial (n, k) * a (k) * a (n - k); Simpan nilai; Cetak nombor; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void ZigZag ( int n ) { long [ ] fact = new long [ n + 1 ] ; long [ ] zig = new long [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) zig [ i ] = 0 ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; Console . Write ( \" zig ▁ zag ▁ numbers : ▁ \" ) ; Console . Write ( zig [ 0 ] + \" ▁ \" + zig [ 1 ] + \" ▁ \" ) ; for ( int i = 2 ; i < n ; i ++ ) { long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; Console . Write ( sum / 2 + \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int n = 10 ; ZigZag ( n ) ; } }"}
{"text": "Urutan Gijswijt | C # Program untuk menunjukkan urutan Gijswijt; Jika urutan adalah (1) a (2) a (3). . A (n - 1) Periksa jika urutan boleh diwakili sebagai x * (y ^ k) mencari nilai terbesar k; kiraan; Corak unsur -unsur saiz I dari akhir urutan; kiraan; ekstrak corak dalam urutan terbalik; Semak berapa kali corak diulang; Jika elemen tidak sepadan; Jika akhir corak dicapai nilai set k = 0 dan tingkatkan kiraan; mengembalikan kiraan maksimum; cetak pertama n terma urutan Gijswijt; Tetapkan kiraan; membongkok elemen; Cetak istilah N pertama urutan; tolak elemen; Cari kiraan untuk nombor seterusnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int find_count ( List < int > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . Count ; i ++ ) { List < int > p = new List < int > ( ) ; int c = 0 , j ; for ( j = ele . Count - 1 ; j >= ( ele . Count - 1 - i ) && j >= 0 ; j -- ) { p . Add ( ele [ j ] ) ; } j = ele . Count - 1 ; int k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) { break ; } j -- ; k ++ ; if ( k == p . Count ) { c ++ ; k = 0 ; } } count = Math . Max ( count , c ) ; } return count ; } static void solve ( int n ) { int count = 1 ; List < int > ele = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( count + \" , ▁ \" ) ; ele . Add ( count ) ; count = find_count ( ele ) ; } } public static void Main ( String [ ] args ) { int n = 10 ; solve ( n ) ; } }"}
{"text": "Wedderburn - Nombor Etherington | C # Program untuk mencari istilah urutan; Menyimpan nombor Wedderburn Etherington; Berfungsi untuk mengembalikan nombor Nth Wedderburn Etherington; Kes asas; Jika n adalah n = 2 x; Dapatkan x; A (2 x) = A (1) A (2 x - 1) + A (2) A (2 x - 2) + ... + A (x - 1) A (x + 1); a (x) (a (x) + 1) / 2; Simpan Ans; Mengembalikan jawapan yang diperlukan; Jika n adalah ganjil; a (2 x - 1) = a (1) a (2 x - 2) + a (2) a (2 x - 3) + ... + a (x - 1) a (x) ,; Simpan Ans; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencetak nombor N First N Wedderburn Etherington; Simpan nombor 3 pertama; Cetak n terma; Kod pemacu; panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static Dictionary < int , int > store = new Dictionary < int , int > ( ) ; static int Wedderburn ( int n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; if ( store . ContainsKey ( n ) ) { store . Remove ( n ) ; store . Add ( n , ans ) ; } else store . Add ( n , ans ) ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } if ( store . ContainsKey ( n ) ) { store . Remove ( n ) ; store . Add ( n , ans ) ; } else store . Add ( n , ans ) ; return ans ; } } static void Wedderburn_Etherington ( int n ) { store . Add ( 0 , 0 ) ; store . Add ( 1 , 1 ) ; store . Add ( 2 , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( Wedderburn ( i ) ) ; if ( i != n - 1 ) Console . Write ( \" ▁ \" ) ; } } public static void Main ( String [ ] args ) { int n = 10 ; Wedderburn_Etherington ( n ) ; } }"}
{"text": "Nilai maksimum selepas menggabungkan semua elemen dalam array | C # Program ke nilai maksimum selepas menggabungkan semua elemen dalam array; Berfungsi dengan nilai maksimum selepas menggabungkan semua elemen dalam array; Untuk memeriksa sama ada elemen positif dan negatif hadir atau tidak; Semak integer positif; Semak integer negatif; Jika kedua -dua unsur positif dan negatif hadir; Untuk menyimpan nilai maksimum yang mungkin; Untuk mencari nilai minimum; Keluarkan elemen minimum; Menggantikan dengan nilai mutlak; Untuk mencari nilai minimum; Keluarkan elemen minimum; Mengembalikan jumlah yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static int Max_sum ( int [ ] a , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( ( pos == 1 ) && ( neg == 1 ) ) break ; } int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . Abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . Min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . Abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . Min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 3 , 5 , - 2 , - 6 } ; int n = a . Length ; Console . WriteLine ( Max_sum ( a , n ) ) ; } }"}
{"text": "Perpuluhan untuk binari menggunakan rekursi dan tanpa menggunakan pengendali kuasa | C # pelaksanaan pendekatan; Fungsi rekursif untuk menukar n kepada bersamaan binari; Kes asas; Panggilan rekursif; Kod pemacu", "code": "using System ; class GFG { static void decimalToBinary ( int n ) { if ( n == 0 ) { Console . Write ( \"0\" ) ; return ; } decimalToBinary ( n / 2 ) ; Console . Write ( n % 2 ) ; } public static void Main ( String [ ] args ) { int n = 13 ; decimalToBinary ( n ) ; } }"}
{"text": "Cari nilai minimum a, b dan c apabila dua (a + b), (a + c) dan (b + c) diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mencari A, B dan C; Simpan nombor minimum dalam x; Cari nombor; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; Console . WriteLine ( a + \" ▁ \" + b + \" ▁ \" + c ) ; } public static void Main ( ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; } }"}
{"text": "Semak sama ada mungkin untuk menukar A ke B | C # pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika A boleh ditukar kepada B dengan operasi yang diberikan; Jika nombor semasa berakhir dengan 1; Jika nombor semasa boleh dibahagikan dengan 2; Jika di atas dua keadaan gagal; Sekiranya mungkin untuk menukar A ke B; Kod pemacu", "code": "using System ; class GFG { static bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; } public static void Main ( ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Count Rectangles yang berbeza dalam N * N Chessboard | C # Program untuk mengira segi empat tepat yang unik di papan catur; Fungsi untuk mengira segi empat tepat yang berbeza; Kod pemacu", "code": "using System ; class Rectangle { static int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } public static void Main ( ) { int n = 4 ; Console . Write ( count ( n ) ) ; } }"}
{"text": "Jumlah hari yang diambil untuk menyelesaikan tugas jika selepas hari -hari tertentu seseorang meninggalkan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan hari yang diperlukan; Kod pemacu", "code": "using System ; class GFG { static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } public static void Main ( ) { int a = 10 , b = 20 , n = 5 ; Console . WriteLine ( numberOfDays ( a , b , n ) ) ; } }"}
{"text": "Cari purata dua nombor menggunakan operasi bit | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan purata x dan y menggunakan operasi bit; Kirakan nilai lantai purata (x + y) / 2; Kod pemacu", "code": "using System ; class GFG { static int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } public static void Main ( ) { int x = 10 , y = 9 ; Console . WriteLine ( getAverage ( x , y ) ) ; } }"}
{"text": "Indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya; Pada mulanya; Melintasi array; Semak jika elemen array adalah 1; a [i] = 0; Kembali minimum kedua -duanya; Kod pemacu", "code": "using System ; class GFG { static int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . Min ( right1 , right0 ) ; } public static void Main ( ) { int [ ] a = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = a . Length ; Console . Write ( smallestIndex ( a , n ) ) ; } }"}
{"text": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Tetapkan 2 | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan dataran yang boleh dikunjungi oleh raja dalam gerakan; Untuk menyimpan kiraan dataran; Semak semua dataran papan catur; Semak jika persegi (i, j) berada pada jarak <= m unit dari kedudukan semasa Raja; Kembali kiraan kuadrat; Kod pemacu", "code": "using System ; class GFG { static int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( Math . Max ( Math . Abs ( i - r ) , Math . Abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } public static void Main ( ) { int r = 4 , c = 4 , m = 1 ; Console . Write ( countSquares ( r , c , m ) ) ; } }"}
{"text": "Bilangan kuadrup di mana tiga syarat pertama berada dalam AP dan tiga istilah terakhir adalah dalam gp | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan kuadrup; Jadual Hash untuk mengira bilangan kejadian; Melintasi dan meningkatkan kiraan; Jalankan dua gelung bersarang untuk elemen kedua dan ketiga; Jika mereka sama; Pada mulanya mengurangkan kiraan; Cari elemen pertama menggunakan perbezaan bersama; Cari elemen keempat menggunakan gp y ^ 2 = x * z harta; Jika ia adalah integer; Jika tidak sama; Unsur yang sama; Kemudian meningkatkan nilai untuk pengiraan masa depan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int countQuadruples ( int [ ] a , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . ContainsKey ( a [ i ] ) ) { mp [ a [ i ] ] = mp [ a [ i ] ] + 1 ; } else { mp . Add ( a [ i ] , 1 ) ; } int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp [ a [ j ] ] = mp [ a [ j ] ] - 1 ; mp [ a [ k ] ] = mp [ a [ k ] ] - 1 ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . ContainsKey ( first ) && mp . ContainsKey ( fourth ) ) count += mp [ first ] * mp [ fourth ] ; } else if ( mp . ContainsKey ( first ) && mp . ContainsKey ( fourth ) ) count += mp [ first ] * ( mp [ fourth ] - 1 ) ; } if ( mp . ContainsKey ( a [ j ] ) ) { mp [ a [ j ] ] = mp [ a [ j ] ] + 1 ; } else { mp . Add ( a [ j ] , 1 ) ; } if ( mp . ContainsKey ( a [ k ] ) ) { mp [ a [ k ] ] = mp [ a [ k ] ] + 1 ; } else { mp . Add ( a [ k ] , 1 ) ; } } } return count ; } public static void Main ( String [ ] args ) { int [ ] a = { 2 , 6 , 4 , 9 , 2 } ; int n = a . Length ; Console . Write ( countQuadruples ( a , n ) ) ; } }"}
{"text": "Nombor dalam julat dengan akar digital yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor yang ada dalam julat yang diberikan; Bilangan kumpulan 9 elemen bermula dari L; Meninggalkan unsur -unsur yang tidak diliputi dalam Faktor 9; Satu nombor dalam setiap kumpulan 9; Untuk memeriksa sama ada nombor dalam REM memenuhi harta itu; Kod pemacu", "code": "using System ; class GFG { static int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; } public static void Main ( ) { int L = 10 ; int R = 22 ; int K = 3 ; Console . WriteLine ( countNumbers ( L , R , K ) ) ; } }"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | C # pelaksanaan pendekatan; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Jika elemen semasa adalah walaupun; Jika elemen bahkan kemudian keluarkannya dari jumlah; Jika nilai menjadi walaupun selepas mengemas kini; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "using System ; class GFG { static void BalanceArray ( int [ ] A , int [ , ] Q ) { int [ ] ANS = new int [ A . Length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . Length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . GetLength ( 0 ) ; i ++ ) { int index = Q [ i , 0 ] ; int value = Q [ i , 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS [ i ] = sum ; } for ( i = 0 ; i < ANS . Length ; i ++ ) Console . Write ( ANS [ i ] + \" ▁ \" ) ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 3 , 4 } ; int [ , ] Q = { { 0 , 1 } , { 1 , - 3 } , { 0 , - 4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; } }"}
{"text": "Bilangan Siklus Hamiltonian | C # Program untuk pelaksanaan program di atas; Fungsi yang mengira bilangan kitaran Hamiltonian; Mengira faktorial; Kod pemacu", "code": "using System ; class GFG { static int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } public static void Main ( ) { int N = 5 ; int Number = Cycles ( N ) ; Console . Write ( \" Hamiltonian ▁ cycles ▁ = ▁ \" + Number ) ; } }"}
{"text": "Integer terkecil lebih besar daripada n sedemikian rupa sehingga ia terdiri daripada digit m tepat kali K | C # pelaksanaan pendekatan; Fungsi yang pulih benar jika n mengandungi digit m tepat k kali; Berfungsi untuk mengembalikan integer terkecil> n dengan digit m yang berlaku tepat kali K; Kod pemacu", "code": "using System ; class GFG { static bool digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; } static int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } } public static void Main ( ) { int n = 111 , m = 2 , k = 2 ; Console . WriteLine ( findInt ( n , m , k ) ) ; } }"}
{"text": "KOMPOSITE XOR DAN COPRIME DAN | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan nombor ganjil dalam array; Pembolehubah untuk mengira nombor ganjil; Nombor ganjil; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "using System ; class GFG { static int countOdd ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; } static int countValidPairs ( int [ ] arr , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; Console . WriteLine ( countValidPairs ( arr , n ) ) ; } }"}
{"text": "Cube sempurna terkecil dibahagi dengan semua elemen array | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan LCM dari unsur -unsur array; Untuk mengira LCM dua nombor melipatgandakan mereka dan membahagikan hasilnya dengan GCD kedua -dua nombor; Mengembalikan LCM unsur -unsur array; Berfungsi untuk mengembalikan kiub sempurna yang paling smaintest yang boleh dibahagikan dengan tidak elemen arr []; LCM semua elemen ARR []; Jika 2 membahagikan bilangan kali LCM CNT; Semak nombor yang membahagikan LCM; Kembalikan jawapannya; Kod pemacu", "code": "using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int lcmOfArray ( int [ ] arr , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } static int minPerfectCube ( int [ ] arr , int n ) { int minPerfectCube ; int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } public static void Main ( ) { int [ ] arr = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . Length ; Console . WriteLine ( minPerfectCube ( arr , n ) ) ; } }"}
{"text": "Semak jika n adalah Perdana yang kuat | C # Program untuk memeriksa sama ada nombor tertentu adalah perdana yang kuat; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah perdana yang kuat; Jika n bukan nombor perdana atau n adalah perdana pertama maka kembali palsu; Inisialisasi sebelumnya_prime ke n - 1 dan next_prime ke n + 1; Cari nombor perdana seterusnya; Cari nombor perdana sebelumnya; Min aritmetik; Jika n adalah perdana yang kuat; Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; } public static void Main ( ) { int n = 11 ; if ( isStrongPrime ( n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Penyingkiran minimum dalam nombor yang boleh dibahagikan dengan 10 kuasa yang dibangkitkan kepada k | C # Program untuk mengira bilangan digit yang boleh dikeluarkan sedemikian rupa sehingga nombor itu boleh dibahagikan dengan 10 ^ k; berfungsi untuk mengembalikan bilangan digit yang diperlukan untuk dikeluarkan; Menukar nombor yang diberikan ke dalam rentetan; pembolehubah untuk menyimpan nombor digit yang akan dikeluarkan; Pembolehubah untuk menunjukkan jika sekurang -kurangnya satu sifar telah dijumpai; sifar dijumpai; saiz pulangan - 1 jika k tidak sifar dan atleast satu sifar hadir, jika tidak hasilnya; Kod pemacu untuk menguji fungsi di atas", "code": "using System ; public class GFG { static int countDigitsToBeRemoved ( int N , int K ) { string s = Convert . ToString ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . Length - 1 ; return - 1 ; } public static void Main ( ) { int N = 10904025 ; int K = 2 ; Console . Write ( countDigitsToBeRemoved ( N , K ) + \" STRNEWLINE \" ) ; N = 1000 ; K = 5 ; Console . Write ( countDigitsToBeRemoved ( N , K ) + \" STRNEWLINE \" ) ; N = 23985 ; K = 2 ; Console . Write ( countDigitsToBeRemoved ( N , K ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Program untuk mencari jumlah siri (1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n) | C # Program untuk mencari jumlah siri yang diberikan; Berfungsi untuk mengembalikan jumlah siri; pembolehubah untuk menyimpan jawapannya; Matematik. pow (x, y) mengembalikan x ^ y; Kod pemacu; Cetak jumlah siri", "code": "using System ; class GFG { public static double getSum ( int a , int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . Pow ( a , i ) ) ; } return sum ; } static public void Main ( ) { int a = 3 , n = 3 ; Console . WriteLine ( getSum ( a , n ) ) ; } }"}
{"text": "Semak sama ada nombor adalah nombor yang tidak biasa atau tidak | C # Program untuk memeriksa nombor yang tidak biasa; Fungsi utiliti untuk mencari faktor utama terbesar bagi nombor; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; n >> = 1; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya untuk bilangan bulat yang ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk memeriksa nombor yang tidak biasa; Dapatkan faktor utama terbesar nombor; Semak jika faktor utama terbesar adalah lebih besar daripada sqrt (n); Kod pemacu", "code": "using System ; class GFG { static int largestPrimeFactor ( int n ) { int max = - 1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; } static bool checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > Math . Sqrt ( n ) ) { return true ; } else { return false ; } } public static void Main ( ) { int n = 14 ; if ( checkUnusual ( n ) ) { Console . WriteLine ( \" YES \" ) ; } else { Console . WriteLine ( \" NO \" ) ; } } }"}
{"text": "Semak jika sekurang -kurangnya separuh array boleh diturunkan kepada sifar dengan melakukan beberapa operasi | C # Program untuk mencari sama ada separuh - array boleh diturunkan kepada 0; Berfungsi untuk mencetak hasil yang diingini selepas pengiraan; Kod pemacu", "code": "using System ; public class GFG { static void isHalfReducible ( int [ ] arr , int n , int m ) { int [ ] frequencyHash = new int [ m + 1 ] ; int i ; for ( i = 0 ; i < frequencyHash . Length ; i ++ ) frequencyHash [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } public static void Main ( ) { int [ ] arr = { 8 , 16 , 32 , 3 , 12 } ; int n = arr . Length ; int m = 7 ; isHalfReducible ( arr , n , m ) ; } }"}
{"text": "Semak jika nombor yang diberikan adalah nombor bijih atau tidak | C # Program untuk memeriksa sama ada nombor yang diberikan adalah nombor bijih; Fungsi yang mengembalikan purata harmonik. ; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi sama, simpan 'i'; lain sebaliknya menyimpan 'i' dan 'n / i' kedua -duanya; Fungsi utiliti untuk mengira min harmonik pembahagi; Mengisytiharkan pembolehubah jumlah dan permulaan dengan sifar. ; hitung penyebut; Mengira min dan pulangan harmonik; Berfungsi untuk memeriksa sama ada nombor adalah nombor bijih; Kirakan min harmonik pembahagi n; Semak jika min harmonik adalah integer atau tidak; Kod pemacu", "code": "using System ; using System . Collections ; class GFG { static ArrayList arr = new ArrayList ( ) ; static void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . Add ( i ) ; { arr . Add ( i ) ; arr . Add ( n / i ) ; } } } } static double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . Count ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + n / ( int ) arr [ i ] ; sum = sum / n ; return arr . Count / sum ; } static bool isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - Math . Floor ( mean ) == 0 ) return true ; else return false ; } public static void Main ( ) { int n = 28 ; if ( isOreNumber ( n ) ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | C # pelaksanaan pendekatan; Berfungsi untuk menjana nombor utama dan menyimpan produk mereka; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; kedai awalan produk nombor utama ke unordered_set 's'; mengemas kini produk dengan mendarabkan Perdana Seterusnya; Masukkan 'Produce + 1' untuk ditetapkan; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Periksa sama ada nombor wujud dalam set yang tidak teratur atau tidak jika ada, kembali benar; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "using System ; using System . Collections . Generic ; class GFG { static int MAX = 10000 ; static HashSet < int > s = new HashSet < int > ( ) ; static void SieveOfEratosthenes ( ) { Boolean [ ] prime = new Boolean [ MAX ] ; for ( int p = 0 ; p < MAX ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . Add ( product + 1 ) ; } } } static Boolean isEuclid ( int n ) { if ( s . Contains ( n ) ) return true ; else return false ; } public static void Main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isEuclid ( n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; n = 42 ; if ( isEuclid ( n ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Semak sama ada nombor yang diberikan ialah Wagstaff Prime atau tidak | C # Program untuk memeriksa sama ada nombor adalah Wagstaff Prime atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi utiliti untuk memeriksa kuasa dua; Kod pemacu; Semak jika nombor adalah perdana dan borang (2 ^ q + 1) / 3", "code": "using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } public static void Main ( ) { int n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { Console . WriteLine ( \" YES \" ) ; } else { Console . WriteLine ( \" NO \" ) ; } } }"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segi enam | C # Program untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segi enam; Berfungsi untuk mencari kawasan dataran; sisi segi enam tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "using System ; class GFG { static float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . Pow ( ( a * Math . Sqrt ( 3 ) ) / ( Math . Sqrt ( 2 ) ) , 2 ) ; return area ; } public static void Main ( ) { float a = 5 ; Console . WriteLine ( area ( a ) ) ; } }"}
{"text": "Program untuk mencari istilah n Siri 1, 6, 17, 34, 56, 86, 121, 162, ... .... | C # Program untuk mencari istilah n siri: 1, 6, 17, 34, 56, 86, 121, 162, .... . ; mengira istilah siri nth; Kod pemacu", "code": "using System ; class GFG { static int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) - 4 * n + 2 ; } public static void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }"}
{"text": "Jumlah terma pertama N Siri 2, 10, 30, 68, .... | C # Program untuk mencari jumlah terma pertama N; Berfungsi untuk mengira jumlah; Kod pemacu; bilangan syarat yang akan dimasukkan dalam jumlah; Cari jumlahnya", "code": "using System ; class gfg { public void calculateSum ( int n ) { double r = ( n * ( n + 1 ) / 2 + Math . Pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ) ; Console . WriteLine ( \" Sum ▁ = ▁ \" + r ) ; } public static int Main ( ) { gfg g = new gfg ( ) ; int n = 3 ; g . calculateSum ( n ) ; Console . Read ( ) ; return 0 ; } }"}
{"text": "Semak jika dua tatasusunan adalah permutasi antara satu sama lain menggunakan operasi matematik | C # kod untuk memeriksa sama ada tatasusunan adalah permutasi EAH yang lain; Fungsi untuk memeriksa sama ada tatasusunan adalah permutasi antara satu sama lain. ; Mengira jumlah dan kalikan array pertama; Mengira jumlah dan kalikan array kedua; Jika jumlah dan Mul kedua -dua tatasusunan adalah sama, kembali benar, lain kembali palsu. ; Kod pemacu", "code": "using System ; class GFG { static bool arePermutations ( int [ ] a , int [ ] b , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 2 } ; int [ ] b = { 3 , 1 , 2 } ; int n = a . Length ; int m = b . Length ; if ( arePermutations ( a , b , n , m ) == true ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Program untuk mencari permulaan dalam perlumbaan | C # pelaksanaan pendekatan di atas; Fungsi untuk mencari B mula c; Apabila B menyelesaikannya 100 meter kemudian selesai meter dengan C adalah; Kod pemacu; Apabila ia menyelesaikannya 100 meter kemudian selesai meter b dan c adalah", "code": "using System ; class GFG { static int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } public static void Main ( ) { int B = 10 ; int C = 28 ; B = 100 - B ; C = 100 - C ; Console . Write ( Race ( B , C ) + \" ▁ meters \" ) ; } }"}
{"text": "Masa minimum diperlukan untuk mengisi tangki menggunakan paip n | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengira masa; Kod pemacu", "code": "using System ; class GFG { static float Time ( float [ ] arr , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; } public static void Main ( ) { float [ ] arr = { 12 , 14 } ; float Emptypipe = 30 ; int n = arr . Length ; Console . WriteLine ( ( int ) ( Time ( arr , n , Emptypipe ) ) + \" ▁ Hours \" ) ; } }"}
{"text": "Semak jika perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 | C # Program untuk memeriksa sama ada perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 atau tidak; Berfungsi untuk memeriksa kebolehpasaran; Jumlah semua digit individu; Keadaan; Kod pemacu; Nombor oktal", "code": "using System ; class GFG { static int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } public static void Main ( String [ ] args ) { int n = 25 ; String s = ( check ( n ) == 1 ) ? \" YES \" : \" NO \" ; Console . WriteLine ( s ) ; } }"}
{"text": "Jumlah semua pembahagi utama nombor | C # Program untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; } public static void Main ( ) { int n = 60 ; Console . WriteLine ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + SumOfPrimeDivisors ( n ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Jumlah semua pembahagi utama nombor | C # Program untuk mencari pembahagi utama semua nombor dari 1 hingga n; berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Kod pemacu", "code": "using System ; class GFG { static int Sum ( int N ) { int [ ] SumOfPrimeDivisors = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 0 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } public static void Main ( ) { int N = 60 ; Console . Write ( \" Sum ▁ of ▁ prime ▁ \" + \" divisors ▁ of ▁ 60 ▁ is ▁ \" + Sum ( N ) + \" STRNEWLINE \" ) ; } }"}
{"text": "Cari (a ^ b) % m di mana 'b' sangat besar | C # Program untuk mencari (a ^ b) % m untuk b sangat besar. ; Berfungsi untuk mencari kuasa; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasilnya; y mestilah sekarang y = y >> 1; y = y / 2; Kod pemacu; Input rentetan sebagai B sangat besar; Kurangkan bilangan B ke bilangan kecil menggunakan fermat kecil", "code": "using System ; class GFG { static long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } public static void Main ( ) { long a = 3 ; string b = \"100000000000000000000000000\" ; long remainderB = 0 ; long MOD = 1000000007 ; for ( int i = 0 ; i < b . Length ; i ++ ) remainderB = ( remainderB * 10 + b [ i ] - '0' ) % ( MOD - 1 ) ; Console . WriteLine ( power ( a , remainderB , MOD ) ) ; } }"}
{"text": "Kuadrat nombor dengan digit tunggal berulang | Tetapkan 1 (3, 6 dan 9) | C # Program untuk mencari persegi jumlah besar ini; Fungsi untuk mencari persegi 333. .. .333, 666. .666 dan 999.. .999; Sekiranya nombornya adalah 333. .. .333; Jika nombor itu 666. .. .666; Jika nombor itu 999 .. .999; pembolehubah untuk hasil pegangan; Cari tidak digit; tambah saiz - 1 kali dalam hasil; Tambah satu kali B hasil; tambah saiz - 1 kali c dalam hasil; tambah satu kali d hasil; hasil pulangan; Kod pemacu; Cari persegi 33. .33; cari persegi 66. .66; cari persegi 66. .66", "code": "using System ; class GFG { static string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; } else if ( num [ 0 ] == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; } else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; } string result = \" \" ; int size = num . Length ; for ( int i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; } public static void Main ( ) { string num_3 , num_6 , num_9 ; num_3 = \"3333\" ; num_6 = \"6666\" ; num_9 = \"9999\" ; string result = \" \" ; result = find_Square_369 ( num_3 ) ; Console . Write ( \" Square ▁ of ▁ \" + num_3 + \" ▁ is ▁ : ▁ \" + result + \" STRNEWLINE \" ) ; result = find_Square_369 ( num_6 ) ; Console . Write ( \" Square ▁ of ▁ \" + num_9 + \" ▁ is ▁ : ▁ \" + result + \" STRNEWLINE \" ) ; result = find_Square_369 ( num_9 ) ; Console . Write ( \" Square ▁ of ▁ \" + num_9 + \" ▁ is ▁ : ▁ \" + result + \" STRNEWLINE \" ) ; } }"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) |", "code": "using System ; class GFG { public static void Main ( ) { long ans = 1 ; long mod = ( long ) 1000000007 * 120 ; for ( int i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % mod ; ans = ans / 120 ; Console . Write ( \" Answer ▁ using ▁ \" + \" shortcut : ▁ \" + ans ) ; } }"}
{"text": "Cara untuk membiak elemen dengan operasi bersekutu | C # kod untuk mencari bilangan cara untuk membiak unsur -unsur dengan operasi bersekutu; Fungsi untuk mencari faktorial yang diperlukan; Berfungsi untuk mencari NCR; berfungsi untuk mencari bilangan cara; Kod pemacu", "code": "using System ; class GFG { static int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; } static int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; } static int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; } public static void Main ( ) { int n = 6 ; Console . WriteLine ( solve ( n ) ) ; } }"}
{"text": "Triplet Pythagorean dengan jumlah yang diberikan | C # Program untuk mencari triplet Pythagorean yang diberikan. ; Memandangkan tiga kali ganda dalam urutan yang disusun. Nilai elemen pertama dalam triplet yang disusun boleh diadakan - kebanyakan n / 3 .; Nilai elemen kedua mestilah kurang daripada sama dengan n / 2; Kod pemacu", "code": "using System ; class GFG { static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { Console . Write ( i + \" , ▁ \" + j + \" , ▁ \" + k ) ; return ; } } } Console . Write ( \" No ▁ Triplet \" ) ; } public static void Main ( ) { int n = 12 ; pythagoreanTriplet ( n ) ; } }"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | C # Program untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mengira faktorial nombor; berfungsi untuk mencetak siri; Mengira nilai n! ; gelung untuk memaparkan siri; Untuk mengira nilai NCR; mengira nilai A ke kuasa k dan x ke kuasa k; Paparkan siri; Fungsi utama bermula", "code": "using System ; class GFG { static int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } static void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = ( int ) Math . Pow ( A , n - i ) ; int xPow = ( int ) Math . Pow ( X , i ) ; Console . Write ( ( nFact * aPow * xPow ) / ( niFact * iFact ) + \" ▁ \" ) ; } } public static void Main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | C # Program untuk mencari jumlah siri dengan jumlah AP Square yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu", "code": "using System ; class GFG { static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } public static void Main ( ) { int n = 2 ; int [ ] a = { 1 , 2 , 3 , 4 } ; Console . WriteLine ( seiresSum ( n , a ) ) ; } }"}
{"text": "Kuasa nombor utama 'r' dalam n! | C # Program untuk mencari kuasa nombor utama 'r' dalam n! ; Berfungsi untuk mengembalikan kuasa no. 'r' dalam faktorial n; Terus membahagikan n dengan kuasa 'r' dan mengemaskini kiraan; Kod pemacu", "code": "using System ; class GFG { static int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } public static void Main ( ) { int n = 6 , r = 3 ; Console . WriteLine ( power ( n , r ) ) ; } }"}
{"text": "Purata nombor natural natur pertama | C # Program untuk mencari purata jumlah nombor semulajadi yang pertama. ; Mengembalikan AVG nombor n pertama; Jumlah nombor pertama yang pertama; Purata nombor pertama yang ganjil; Kod pemacu", "code": "using System ; class GFG { static int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } public static void Main ( ) { int n = 20 ; avg_of_odd_num ( n ) ; Console . Write ( avg_of_odd_num ( n ) ) ; } }"}
{"text": "Purata nombor natural natur pertama | C # Program untuk mencari purata jumlah nombor n pertama yang pertama; Kembalikan purata jumlah nombor pertama yang ganjil; Kod pemacu", "code": "using System ; class GFG { static int avg_of_odd_num ( int n ) { return n ; } public static void Main ( ) { int n = 8 ; Console . Write ( avg_of_odd_num ( n ) ) ; } }"}
{"text": "Program untuk mencetak segitiga Fibonacci | C # Pelaksanaan untuk Segitiga Fibonacci; berfungsi untuk mengisi nombor fibonacci dalam f []; 1 ST dan 2 ND nombor siri adalah 1 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Isi nombor Fibonacci dalam f [] menggunakan Fib (). Kami memerlukan n = n * (n + 1) / 2 nombor fibonacci untuk membuat segitiga ketinggian n; Untuk menyimpan nombor Fibonacci seterusnya untuk dicetak; untuk gelung untuk menjejaki bilangan baris; Untuk gelung untuk menjejaki nombor dalam setiap baris; Kod pemacu", "code": "using System ; class GFG { static void fib ( int [ ] f , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } static void fiboTriangle ( int n ) { int N = n * ( n + 1 ) / 2 ; int [ ] f = new int [ N + 1 ] ; fib ( f , N ) ; int fiboNum = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) Console . Write ( f [ fiboNum ++ ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 5 ; fiboTriangle ( n ) ; } }"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | C # Program untuk mencari purata nombor ganjil sehingga nombor ganjil yang diberikan. ; Fungsi untuk mengira purata nombor ganjil; mengira nombor ganjil; Simpan jumlah nombor ganjil; fungsi pemacu", "code": "using System ; class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { Console . Write ( \" Invalid ▁ Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } public static void Main ( ) { int n = 15 ; Console . Write ( averageOdd ( n ) ) ; } }"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | C # Program untuk mencari purata nombor ganjil sehingga nombor ganjil yang diberikan. ; Fungsi untuk mengira purata nombor ganjil; fungsi pemacu", "code": "using System ; class GFG { static int averageOdd ( int n ) { if ( n % 2 == 0 ) { Console . Write ( \" Invalid ▁ Input \" ) ; return - 1 ; } return ( n + 1 ) / 2 ; } public static void Main ( ) { int n = 15 ; Console . Write ( averageOdd ( n ) ) ; } }"}
{"text": "Cari Max Dua Nombor Rasional | C # Program untuk mencari max antara dua nombor rasional; Dapatkan LCM dua nombor; Dapatkan nombor rasional maksimum; Cari LCM yang pertama. Penyebut dan Sec. penyebut; Mengisytiharkan NUME1 dan NUME2 untuk mendapatkan nilai pengangka pertama dan pengangka kedua; Kod pemacu", "code": "using System ; class GFG { class Rational { public int nume , deno ; public Rational ( int nume , int deno ) { this . nume = nume ; this . deno = deno ; } } ; static int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } static Rational maxRational ( Rational first , Rational sec ) { int k = lcm ( first . deno , sec . deno ) ; int nume1 = first . nume ; int nume2 = sec . nume ; nume1 *= k / ( first . deno ) ; nume2 *= k / ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { Rational first = new Rational ( 3 , 2 ) ; Rational sec = new Rational ( 3 , 4 ) ; Rational res = maxRational ( first , sec ) ; Console . Write ( res . nume + \" / \" + res . deno ) ; } }"}
{"text": "Trinomial Triangle | C # Program untuk mencetak segitiga trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Kes asas; Kes asas; langkah rekursif. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Fungsi pemacu", "code": "using System ; public class GfG { public static int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; } public static void printTrinomial ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) Console . Write ( TrinomialValue ( i , j ) + \" ▁ \" ) ; for ( int j = 1 ; j <= i ; j ++ ) Console . Write ( TrinomialValue ( i , j ) + \" ▁ \" ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 4 ; printTrinomial ( n ) ; } }"}
{"text": "Trinomial Triangle | C # Program untuk mencetak segitiga trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Menggunakan harta segitiga trinomial. ; Jika nilai sudah dikira, kembalikan itu. ; Kes asas; Kes asas; langkah rekursif dan menyimpan nilai. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Kod pemacu", "code": "using System ; class GFG { private static int MAX = 10 ; public static int TrinomialValue ( int [ , ] dp , int n , int k ) { if ( k < 0 ) k = - k ; if ( dp [ n , k ] != 0 ) return dp [ n , k ] ; if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return ( dp [ n , k ] = TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) ; } public static void printTrinomial ( int n ) { int [ , ] dp = new int [ MAX , MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) Console . Write ( TrinomialValue ( dp , i , j ) + \" ▁ \" ) ; for ( int j = 1 ; j <= i ; j ++ ) Console . Write ( TrinomialValue ( dp , i , j ) + \" ▁ \" ) ; Console . WriteLine ( ) ; } } static public void Main ( ) { int n = 4 ; printTrinomial ( n ) ; } }"}
{"text": "Jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N | C # Pelaksanaan untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N; fungsi untuk mencari jumlah faktor utama terbesar setiap nombor kurang daripada sama dengan n; Buat array Integer \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai 0. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika 'I' adalah perdana, jika tidak, ia akan mengandungi faktor utama terbesar 'I'. ; Jika Perdana [P] adalah '0', maka ia adalah nombor utama; Kemas kini semua gandaan P; Merangkumi faktor utama terbesar bagi semua nombor; jika 'p' adalah nombor bukan utama maka perdana [p] memberikan faktor utama largesr; 'P' adalah nombor utama; Jumlah yang diperlukan; Program Pemandu", "code": "using System ; class GFG { static int sumOfLargePrimeFactor ( int n ) { int [ ] prime = new int [ n + 1 ] ; int sum = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) prime [ i ] = 0 ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( \" Sum ▁ = ▁ \" + sumOfLargePrimeFactor ( n ) ) ; } }"}
{"text": "Jumlah gandaan nombor sehingga n | C # Program untuk mencari jumlah gandaan nombor sehingga n dengan cekap; Berfungsi untuk mengira jumlah gandaan sehingga n; Bilangan gandaan; jumlah nombor semulajadi pertama; jumlah gandaan; Kod pemacu", "code": "using System ; class GFG { static int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } public static void Main ( ) { int a = 7 , N = 49 ; Console . WriteLine ( \" Sum ▁ of ▁ multiples ▁ of ▁ \" + a + \" ▁ up ▁ to ▁ \" + N + \" ▁ = ▁ \" + calculate_sum ( a , N ) ) ; } }"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | C # Program untuk mencari sama ada nombor adalah kuasa 2 atau tidak; pulangan 1 apabila STR adalah kuasa 2 pulangan 0 apabila STR bukan kuasa 2; Jumlah menyimpan dividen pertengahan semasa membahagikan. ; jika input adalah \"1\" maka kembali 0 kerana 2 ^ k = 1 di mana k> = 1 dan di sini k = 0; Bahagikan nombor sehingga ia dikurangkan kepada 1 jika kita berjaya dapat mengurangkan nombor kepada 1, ia bermakna rentetan input adalah kuasa dua jika di antara nombor ganjil muncul pada akhirnya ia bermakna rentetan tidak dibahagikan dengan dua sehingga bukan kuasa 2; Sekiranya digit terakhir adalah ganjil maka rentetan tidak dapat dibahagikan dengan 2 oleh itu bukan kuasa dua pulangan 0 .; Bahagikan keseluruhan rentetan dengan 2. Saya digunakan untuk mengesan indeks dalam nombor semasa. J digunakan untuk mengesan indeks untuk lelaran seterusnya. ; Jika num <2 maka kita perlu mengambil satu lagi digit di sebelah kanan [i] untuk menjadikannya lebih besar daripada [i]. E. g. 214/2 -> 107; Jika ia bukan indeks pertama. Contohnya 214 maka kita perlu memasukkan 0 .; untuk contohnya. \"124\" Kami tidak akan menulis 064 jadi jika indeks pertama hanya mengabaikan; Selepas setiap bahagian dengan 2 panjang rentetan diubah. ; Jika rentetan mencapai 1 maka str adalah kuasa 2 .; Kod pemacu.", "code": "using System ; class GFG { static int isPowerOf2 ( string s ) { char [ ] str = s . ToCharArray ( ) ; int len_str = str . Length ; int num = 0 ; if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ; while ( len_str != 1 str [ len_str - 1 ] != '1' ) { if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ; int j = 0 ; for ( int i = 0 ; i < len_str ; i ++ ) { num = num * 10 + ( int ) str [ i ] - ( int ) '0' ; if ( num < 2 ) { if ( i != 0 ) str [ j ++ ] = '0' ; continue ; } str [ j ++ ] = ( char ) ( ( int ) ( num / 2 ) + ( int ) '0' ) ; num = ( num ) - ( num / 2 ) * 2 ; } str [ j ] = ' \\0' ; len_str = j ; } return 1 ; } static void Main ( ) { string str1 = \"124684622466842024680246842024662202000002\" ; string str2 = \"1\" ; string str3 = \"128\" ; Console . Write ( isPowerOf2 ( str1 ) + \" STRNEWLINE \" + isPowerOf2 ( str2 ) + \" STRNEWLINE \" + isPowerOf2 ( str3 ) ) ; } }"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | C # Program untuk mencari sama ada nombor adalah kuasa 2 atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Kod pemacu", "code": "class GFG { static long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } public static void Main ( ) { long num = 549755813888 ; System . Console . WriteLine ( ispowerof2 ( num ) ) ; } }"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | C # Program untuk mengira pembahagi dalam pendaraban array. ; Untuk mengira bilangan faktor dalam nombor; Inisialisasi kiraan dengan 0; Kiraan kenaikan untuk setiap faktor nombor x yang diberikan. ; Pulangan bilangan faktor; Mengembalikan bilangan pembahagi dalam pendaraban array; Mengumpulkan semua elemen array yang diberikan. ; Fungsi panggilan yang mengira bilangan faktor nombor; Kod pemacu", "code": "using System ; class GFG { static int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; } static int countDivisorsMult ( int [ ] arr , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 6 } ; int n = arr . Length ; Console . Write ( countDivisorsMult ( arr , n ) ) ; } }"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | C # Program untuk mengira pembahagi dalam pendaraban array. ; Buat array Boolean \"Isprime [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Isprime [i] akhirnya akan menjadi palsu jika saya bukannya Isprime, yang lain benar. ; Jika Isprime [p] tidak berubah, maka ia adalah isprime; Kemas kini semua gandaan P; Cetak semua nombor isprime; Mengembalikan bilangan pembahagi dalam pendaraban array; Cari semua nombor perdana yang lebih kecil daripada elemen terbesar. ; Cari tuduhan kejadian setiap faktor utama; Mengira kiraan semua pembahagi menggunakan kiraan faktor utama. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static void SieveOfEratosthenes ( int largest , List < int > prime ) { bool [ ] isPrime = new bool [ largest + 1 ] ; Array . Fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . Add ( p ) ; } static long countDivisorsMult ( int [ ] arr , int n ) { int largest = 0 ; foreach ( int a in arr ) { largest = Math . Max ( largest , a ) ; } List < int > prime = new List < int > ( ) ; SieveOfEratosthenes ( largest , prime ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . Count ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; if ( mp . ContainsKey ( prime [ j ] ) ) { mp [ prime [ j ] ] ++ ; } else { mp . Add ( prime [ j ] , 1 ) ; } } } if ( arr [ i ] != 1 ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] ++ ; } else { mp . Add ( arr [ i ] , 1 ) ; } } } long res = 1 ; foreach ( KeyValuePair < int , int > it in mp ) res *= ( it . Value + 1L ) ; return res ; } static public void Main ( ) { int [ ] arr = { 2 , 4 , 6 } ; int n = arr . Length ; Console . WriteLine ( countDivisorsMult ( arr , n ) ) ; } }"}
{"text": "K pasangan perdana jauh dalam julat yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk menjana nombor perdana dalam julat yang diberikan [l, r]; Simpan semua nilai dalam julat; Padam 1 sebagai bukan perdana; Melakukan penapis eratosthenes; Cari pelbagai semasa; Padam kerana ia bukan perdana; Kenaikan berganda; Melintasi peta m; Jika ia. Pertama & (ia pertama + k) adalah perdana kemudian cetak pasangan ini; Berfungsi untuk mencetak semua pasangan utama dalam julat yang diberikan oleh k; Menjana semua nombor perdana; Kod pemacu; Julat yang diberikan; Diberikan k; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class solution { static void findPrimeNos ( int L , int R , Dictionary < int , int > M , int K ) { for ( int i = L ; i <= R ; i ++ ) { if ( M . ContainsKey ( i ) ) M . Add ( i , M [ i ] + 1 ) ; else M . Add ( i , 1 ) ; } if ( M [ 1 ] != 0 ) { M . Remove ( 1 ) ; } for ( int i = 2 ; i <= Math . Sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . ContainsKey ( i * multiple ) ) { M . Remove ( i * multiple ) ; } multiple ++ ; } } foreach ( KeyValuePair < int , int > entry in M ) { if ( M . ContainsKey ( entry . Key + K ) ) { Console . Write ( \" ( \" + entry . Key + \" , ▁ \" + ( entry . Key + K ) + \" ) ▁ \" ) ; } } } static void getPrimePairs ( int L , int R , int K ) { Dictionary < int , int > M = new Dictionary < int , int > ( ) ; findPrimeNos ( L , R , M , K ) ; } public static void Main ( String [ ] args ) { int L = 1 , R = 19 ; int K = 6 ; getPrimePairs ( L , R , K ) ; } }"}
{"text": "Nombor EnneAcontahExagon | C # Program untuk mencari nombor enneacontahexagon N - th; Berfungsi untuk mencari nombor enneacontahexagon nth; Kod pemacu", "code": "using System ; class GFG { static int enneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; } public static void Main ( ) { int n = 3 ; Console . Write ( enneacontahexagonNum ( n ) ) ; } }"}
{"text": "Cari dua nombor komposit supaya terdapat perbezaan adalah n | C # kod untuk mencari dua nombor komposit supaya terdapat perbezaan adalah n; Berfungsi untuk mencari dua nombor komposit; Kod pemacu", "code": "using System ; class GFG { static void find_composite_nos ( int n ) { Console . WriteLine ( 9 * n + \" ▁ \" + 8 * n ) ; } public static void Main ( ) { int n = 4 ; find_composite_nos ( n ) ; } }"}
{"text": "Kira bilangan pasangan (i, j) supaya sama ada arr [i] boleh dibahagikan dengan arr [j] atau arr [j] boleh dibahagikan dengan arr [i] | C # pelaksanaan pendekatan; Berfungsi untuk mencari bilangan pasangan yang tidak teratur; Elemen maksimum dari array; Array untuk menyimpan kekerapan setiap elemen; Menyimpan bilangan pasangan yang tidak teratur; Simpan kekerapan setiap elemen; Cari bilangan pasangan yang tidak teratur; Jika nombor j dibahagi dengan elemen ith hadir dalam array; Jika elemen ith array mempunyai kekerapan lebih daripada satu; Kod pemacu", "code": "using System ; using System . Linq ; class GFG { static int freqPairs ( int [ ] arr , int n ) { int max = arr . Max ( ) ; int [ ] freq = new int [ max + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) { count += freq [ j ] ; } } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 4 , 2 , 6 } ; int n = arr . Length ; Console . WriteLine ( freqPairs ( arr , n ) ) ; } }"}
{"text": "Cari istilah n Siri 1 + 2 + 6 + 15 + 31 + 56 + ... | C # Program untuk mencari istilah n siri: 1 + 2 + 6 + 15 + 31 + 56 + ...; Hitung istilah n siri yang diberikan; Kod pemacu", "code": "using System ; class GFG { static double Nth_Term ( int n ) { return ( 2 * Math . Pow ( n , 3 ) - 3 * Math . Pow ( n , 2 ) + n + 6 ) / 6 ; } static public void Main ( ) { int N = 8 ; Console . WriteLine ( Nth_Term ( N ) ) ; } }"}
{"text": "Program untuk mencari n | C # Program untuk mencari nombor N dalam siri yang diperbuat daripada digit 3 dan 5; Fungsi untuk mencari nombor n - th dalam siri yang diperbuat daripada 3 dan 5; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; Kod pemacu", "code": "using System ; class GFG { static int printNthElement ( int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } static void Main ( ) { int n = 6 ; Console . WriteLine ( printNthElement ( n ) ) ; } }"}
{"text": "Program untuk mencari istilah n Siri 3, 6, 18, 24, ... | C # Program untuk mencari istilah siri: 3, 6, 18, 24, 45, 54. . ; Dengan menggunakan formula di atas; Kod pemacu; Dapatkan nilai n; Buat objek kelas nth; Hitung dan cetak istilah n", "code": "using System ; class GFG { public int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } public static void Main ( ) { int N = 5 ; GFG a = new GFG ( ) ; Console . WriteLine ( \" Nth ▁ term ▁ for ▁ N ▁ = ▁ \" + N + \" ▁ : ▁ \" + a . nthTerm ( N ) ) ; } }"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | C # Program untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mencetak siri; Mengira dan mencetak istilah pertama; Pengkomputeran dan percetakan yang tersisa; Cari istilah semasa menggunakan terma sebelumnya, kami meningkatkan kuasa x oleh 1, kuasa penurunan sebanyak 1 dan mengira NCI menggunakan istilah sebelumnya dengan mengalikan istilah sebelumnya dengan (n - i + 1) / i; Fungsi utama bermula", "code": "using System ; public class GFG { static void series ( int A , int X , int n ) { int term = ( int ) Math . Pow ( A , n ) ; Console . Write ( term + \" ▁ \" ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; Console . Write ( term + \" ▁ \" ) ; } } public static void Main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }"}
{"text": "Semak jika nombor dibahagikan dengan 8 menggunakan pengendali bitwise | C # Program untuk memeriksa sama ada nombor itu boleh dibahagikan dengan 8 atau tidak menggunakan pengendali Bitwise; Fungsi untuk memeriksa nombor div oleh 8 atau tidak menggunakan pengendali bitwise; Kod pemacu", "code": "using System ; class GFG { static bool Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } public static void Main ( ) { int n = 16 ; if ( Div_by_8 ( n ) ) Console . WriteLine ( \" YES \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | C # Program untuk mencari purata nombor walaupun sehingga nombor yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; mengira nombor walaupun; Simpan jumlah nombor walaupun; fungsi pemacu", "code": "using System ; class GFG { static int averageEven ( int n ) { if ( n % 2 != 0 ) { Console . Write ( \" Invalid ▁ Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } public static void Main ( ) { int n = 16 ; Console . Write ( averageEven ( n ) ) ; } }"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | C # Program untuk mencari purata nombor walaupun sehingga nombor yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; fungsi pemacu", "code": "using System ; class GFG { static int averageEven ( int n ) { if ( n % 2 != 0 ) { Console . Write ( \" Invalid ▁ Input \" ) ; return - 1 ; } return ( n + 2 ) / 2 ; } public static void Main ( ) { int n = 16 ; Console . Write ( averageEven ( n ) ) ; } }"}
{"text": "Nombor terbesar yang membahagikan x dan co | C # Program untuk mencari pembahagi Coprime terbesar; Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; berfungsi untuk mencari pembahagi coprime terbesar; kod pembahagi", "code": "using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } static int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; } public static void Main ( ) { int x = 15 ; int y = 3 ; Console . WriteLine ( cpFact ( x , y ) ) ; x = 14 ; y = 28 ; Console . WriteLine ( cpFact ( x , y ) ) ; x = 7 ; y = 3 ; Console . WriteLine ( cpFact ( x , y ) ) ; } }"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program C # mudah untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Fungsi pemacu", "code": "using System ; public class GfG { public static int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } public static void Main ( ) { int low = 3 , high = 35 , k = 3 ; Console . WriteLine ( counLastDigitK ( low , high , k ) ) ; } }"}
{"text": "Nombor Taxicab | C # kod untuk nombor taxicab; Bermula dari 1, periksa setiap nombor jika ia adalah Taxicab sehingga Count mencapai n. ; Cuba semua pasangan yang mungkin (j, k) yang jumlah kiubnya boleh saya. ; Taxicab (2) dijumpai; Program Pemandu", "code": "using System ; class GFG { public static void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= Math . Pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . Pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; Console . WriteLine ( count + \" ▁ \" + i ) ; } i ++ ; } } public static void Main ( ) { int N = 5 ; printTaxicab2 ( N ) ; } }"}
{"text": "Nombor Komposit | Kaedah sekolah yang dioptimumkan berdasarkan program C # untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Kod pemacu", "code": "using System ; namespace Composite { public class GFG { public static bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } public static void Main ( ) { if ( isComposite ( 11 ) ) Console . WriteLine ( \" true \" ) ; else Console . WriteLine ( \" false \" ) ; if ( isComposite ( 15 ) ) Console . WriteLine ( \" true \" ) ; else Console . WriteLine ( \" false \" ) ; } } }"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | C # Program untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Untuk mencari jumlah elemen array; jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime ( sum ) ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . Length ; Console . Write ( minNumber ( arr , n ) ) ; } }"}
{"text": "Jumlah pembahagi faktorial nombor | C # Program untuk mencari jumlah pembahagi yang betul faktorial nombor; fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Kod pemacu", "code": "using System ; class Division { static int fac ( int n ) { if ( n == 0 ) return 1 ; return n * fac ( n - 1 ) ; } static int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } static int sumFactDiv ( int n ) { return div ( fac ( n ) ) ; } public static void Main ( ) { int n = 4 ; Console . Write ( sumFactDiv ( n ) ) ; } }"}
{"text": "Jumlah pembahagi faktorial nombor | C # Program untuk mencari jumlah pembahagi di N! ; AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) '' using ; Menggunakan fungsi pembahagi untuk mengira jumlah; mengembalikan jumlah pembahagi; Program pemacu untuk menjalankan kes -kes", "code": "using System ; using System . Collections ; class GFG { static ArrayList allPrimes = new ArrayList ( ) ; static void sieve ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) allPrimes . Add ( p ) ; } static int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . Count ; i ++ ) { int p = ( int ) allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * ( int ) allPrimes [ i ] ; } result = result * ( ( int ) Math . Pow ( ( int ) allPrimes [ i ] , exp + 1 ) - 1 ) / ( ( int ) allPrimes [ i ] - 1 ) ; } return result ; } static void Main ( ) { Console . WriteLine ( factorialDivisors ( 4 ) ) ; } }"}
{"text": "Nombor Pandigital dalam pangkalan yang diberikan | C # Program untuk memeriksa sama ada nombor adalah pandigital dalam asas yang diberikan. ; Kembali benar jika n adalah pandigit lain kembali palsu. ; Panjang pemeriksaan kurang daripada asas; Melintasi setiap digit nombor. ; Jika digit adalah integer; Jika digit adalah abjad; Memeriksa array hash, jika mana -mana indeks tidak ditandakan. ; Kod pemacu", "code": "using System ; class GFG { static bool checkPandigital ( int b , string n ) { if ( n . Length < b ) return false ; bool [ ] hash = new bool [ b ] ; for ( int i = 0 ; i < b ; i ++ ) hash [ i ] = false ; for ( int i = 0 ; i < n . Length ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } public static void Main ( ) { int b = 13 ; String n = \"1298450376ABC \" ; if ( checkPandigital ( b , n ) ) Console . Write ( \" Yes \" ) ; else Console . Write ( \" No \" ) ; } }"}
{"text": "Tukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan | C # pelaksanaan untuk menukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan; berfungsi untuk mencari bilangan minimum operasi yang diberikan untuk menukar m ke n; Hanya cara yang perlu dilakukan - 1 (m - n) kali; tidak mungkin; N lebih besar dan n adalah ganjil; lakukan ' - 1' pada m (atau + 1 pada n); n adalah juga; lakukan ' * 2' pada m (atau n / 2 pada n); Kod pemacu", "code": "using System ; class GFG { static int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } public static void Main ( ) { int m = 3 , n = 11 ; Console . Write ( \" Minimum ▁ number ▁ of ▁ \" + \" operations ▁ : ▁ \" + convert ( m , n ) ) ; } }"}
{"text": "Biji (atau akar benih) nombor | C # Program untuk mencari benih nombor; Kedai produk digit x dalam proddig [x]; Jika x mempunyai angka tunggal; Jika produk digit sudah dikira; Jika produk digit tidak dikira sebelum ini. ; Mencetak semua benih n; Cari semua biji menggunakan proddig []; Sekiranya tidak ada benih; Cetak biji; Kod pemacu", "code": "using System ; using System . Collections ; class GFG { static int MAX = 10000 ; static int [ ] prodDig = new int [ MAX ] ; static int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; } static void findSeed ( int n ) { ArrayList res = new ArrayList ( ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . Add ( i ) ; if ( res . Count == 0 ) { Console . WriteLine ( \" NO ▁ seed ▁ exists \" ) ; return ; } for ( int i = 0 ; i < res . Count ; i ++ ) Console . WriteLine ( res [ i ] + \" ▁ \" ) ; } static void Main ( ) { int n = 138 ; findSeed ( n ) ; } }"}
{"text": "Nombor dengan bilangan maksimum faktor utama | C # Program untuk mencari integer yang mempunyai bilangan maksimum faktor utama dalam nombor semulajadi n pertama. ; Kembalikan nombor terkecil yang mempunyai faktor utama. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama. ; Mencari nombor yang mempunyai jumlah maksimum faktor utama. ; Kod pemacu", "code": "using System ; class GFG { static int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 5 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( int j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; } public static void Main ( ) { int N = 40 ; Console . WriteLine ( maxPrimefactorNum ( N ) ) ; } }"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Program C # yang cekap untuk mengira jumlah elemen subarray; fungsi mengira jumlah semua sub - array; jumlah pengkomputeran subarray menggunakan formula; kembali semua jumlah subarray; Kod pemacu", "code": "using System ; class GFG { public static long SubArraySum ( int [ ] arr , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; Console . WriteLine ( \" Sum ▁ of ▁ SubArray : ▁ \" + SubArraySum ( arr , n ) ) ; } }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | C # kod untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Jika saya adalah kuasa 2; Kod pemacu", "code": "using System ; class GFG { public static int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( highestPowerof2 ( n ) ) ; } }"}
{"text": "Cari Pasangan Cube | Tetapkan 2 (A N ^ (1/3) Penyelesaian) | C # Program untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat pelbagai saiz saiz 'cuberoot'; Untuk indeks i, kiub [i] akan mengandungi i ^ 3; Cari semua pasangan di atas Array Cube di atas [] yang jumlahnya sama dengan N; Kod pemacu", "code": "using System ; class GFG { static void findPairs ( int n ) { int cubeRoot = ( int ) Math . Pow ( n , 1.0 / 3.0 ) ; int [ ] cube = new int [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { Console . WriteLine ( \" ( \" + l + \" , ▁ \" + r + \" ) \" ) ; l ++ ; r -- ; } } } public static void Main ( ) { int n = 20683 ; findPairs ( n ) ; } }"}
{"text": "Cari Pasangan Cube | Tetapkan 1 (A N ^ (2/3) Penyelesaian) | C # Program untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat peta kosong; Pertimbangkan semua pasangan seperti nilai kurang daripada cuberoot; Cari jumlah pasangan semasa (x, y); Jangan lakukan apa -apa jika jumlah tidak sama dengan nombor yang diberikan; Jika jumlahnya dilihat sebelum ini, kami mendapati dua pasang; Jika jumlahnya dilihat buat kali pertama; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void findPairs ( int n ) { int cubeRoot = ( int ) Math . Pow ( n , 1.0 / 3.0 ) ; Dictionary < int , pair > s = new Dictionary < int , pair > ( ) ; for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) { int sum = x * x * x + y * y * y ; if ( sum != n ) continue ; if ( s . ContainsKey ( sum ) ) { Console . Write ( \" ( \" + s [ sum ] . first + \" , ▁ \" + s [ sum ] . second + \" ) ▁ and ▁ ( \" + x + \" , ▁ \" + y + \" ) \" + \" STRNEWLINE \" ) ; } else s . Add ( sum , new pair ( x , y ) ) ; } } } public static void Main ( String [ ] args ) { int n = 13832 ; findPairs ( n ) ; } }"}
{"text": "Cari perbezaan minimum antara jadual beralih dua nombor | C # Program untuk mencari perbezaan minimum antara dua syarat dua jadual; Fungsi utiliti untuk mencari GCD A dan B; Mengembalikan perbezaan minimum antara dua terma jadual beralih 'A' dan 'B'. 'X' adalah peralihan dalam jadual 'a' dan 'y' adalah peralihan dalam jadual 'b'. ; Hitung GCD Nd B; Kirakan perbezaan antara x dan y; Kod pemacu", "code": "using System ; class GFG { static int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } static int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = Math . Abs ( x - y ) % g ; return Math . Min ( diff , g - diff ) ; } static void Main ( ) { int a = 20 , b = 52 , x = 5 , y = 7 ; Console . WriteLine ( findMinDiff ( a , b , x , y ) ) ; } }"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | A O (SQRT (N)) C # Program yang mencetak semua pembahagi dalam urutan yang disusun; kaedah untuk mencetak pembahagi; Vektor untuk menyimpan separuh daripada pembahagi; Semak jika pembahagi adalah sama; Tolak pembahagi kedua dalam vektor; Vektor akan dicetak secara terbalik; Kod pemacu", "code": "using System ; class GFG { static void printDivisors ( int n ) { int [ ] v = new int [ n ] ; int t = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) Console . Write ( i + \" ▁ \" ) ; else { Console . Write ( i + \" ▁ \" ) ; v [ t ++ ] = n / i ; } } } for ( int i = t - 1 ; i >= 0 ; i -- ) Console . Write ( v [ i ] + \" ▁ \" ) ; } public static void Main ( ) { Console . Write ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ) ; printDivisors ( 100 ) ; } }"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; Berfungsi untuk mencetak pembahagi; Kod pemacu", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static void printDivisors ( int n ) { for ( int i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) Console . Write ( i + \" ▁ \" ) ; } for ( int i = ( int ) Math . Sqrt ( n ) ; i >= 1 ; i -- ) { if ( n % i == 0 ) Console . Write ( n / i + \" ▁ \" ) ; } } public static void Main ( string [ ] arg ) { Console . Write ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ) ; printDivisors ( 100 ) ; } }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | C # Pelaksanaan kaedah naif untuk mencetak semua pembahagi; kaedah untuk mencetak pembahagi; Kaedah Pemandu", "code": "using System ; class GFG { static void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) Console . Write ( i + \" ▁ \" ) ; } public static void Main ( ) { Console . Write ( \" The ▁ divisors ▁ of \" , \" ▁ 100 ▁ are : ▁ \" ) ; printDivisors ( 100 ) ; ; } }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Penyelesaian yang lebih baik (daripada naif) untuk mencari semua pembahagi; kaedah untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; Jika tidak cetak kedua -duanya; Kaedah Pemandu", "code": "using System ; class GFG { static void printDivisors ( int n ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) Console . Write ( i + \" ▁ \" ) ; else Console . Write ( i + \" ▁ \" + n / i + \" ▁ \" ) ; } } } public static void Main ( ) { Console . Write ( \" The ▁ divisors ▁ of ▁ \" + \"100 ▁ are : ▁ STRNEWLINE \" ) ; printDivisors ( 100 ) ; } }"}
{"text": "Sieve of Atkin | C # Program untuk pelaksanaan SIEVE OF ATKIN; 2 dan 3 dikenali sebagai Perdana; Memulakan array penapis dengan nilai palsu; Mark Sieve [n] adalah benar jika salah satu daripada yang berikut adalah benar: a) n = (4 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil, i. e. , terdapat bilangan pasangan yang berbeza (x, y) yang memenuhi persamaan dan n % 12 = 1 atau n % 12 = 5. b) n = (3 * x * x) + (y * y) Bahagian utama SIEVE OF ATKIN; Tandakan semua gandaan dataran sebagai bukan perdana; Cetak prima menggunakan ayak []; Kod pemacu", "code": "using System ; class GFG { static int SieveOfAtkin ( int limit ) { if ( limit > 2 ) Console . Write ( 2 + \" ▁ \" ) ; if ( limit > 3 ) Console . Write ( 3 + \" ▁ \" ) ; bool [ ] sieve = new bool [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) Console . Write ( a + \" ▁ \" ) ; return 0 ; } public static void Main ( ) { int limit = 20 ; SieveOfAtkin ( limit ) ; } }"}
{"text": "Cari jika titik terletak di dalam bulatan | C # Program untuk memeriksa sama ada titik terletak di dalam bulatan atau tidak; Bandingkan jejari bulatan dengan jarak pusatnya dari titik yang diberikan; Program pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } public static void Main ( ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) Console . Write ( \" Inside \" ) ; else Console . Write ( \" Outside \" ) ; } }"}
{"text": "Cari semua kemungkinan hasil ekspresi yang diberikan | C # Program untuk menilai semua nilai ekspresi yang mungkin; Fungsi utiliti untuk menilai ungkapan mudah dengan satu pengendali sahaja. ; Fungsi ini menilai semua nilai yang mungkin dan mengembalikan senarai nilai yang dinilai. ; Untuk menyimpan hasil (semua kemungkinan penilaian ekspresi 'expr'); Sekiranya terdapat hanya satu watak, ia mestilah digit (atau operan), kembalikannya. ; Sekiranya terdapat hanya tiga aksara, pertengahan mestilah pengendali dan sudut mesti beroperasi; Setiap saya merujuk kepada pengendali; l merujuk kepada semua nilai yang mungkin di sebelah kiri pengendali 'expr [i]'; r merujuk kepada semua nilai yang mungkin di sebelah kanan pengendali 'expr [i]'; Ambil di atas menilai semua nilai yang mungkin di sebelah kiri 'I'; Ambil di atas menilai semua nilai yang mungkin di sebelah kanan 'I'; Kirakan nilai untuk setiap pasangan dan tambahkan nilai yang dihasilkan. ; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int eval ( int a , char op , int b ) { if ( op == ' + ' ) { return a + b ; } if ( op == ' - ' ) { return a - b ; } if ( op == ' * ' ) { return a * b ; } return int . MaxValue ; } static List < int > evaluateAll ( String expr , int low , int high ) { List < int > res = new List < int > ( ) ; if ( low == high ) { res . Add ( expr [ low ] - '0' ) ; return res ; } if ( low == ( high - 2 ) ) { int num = eval ( expr [ low ] - '0' , expr [ low + 1 ] , expr [ low + 2 ] - '0' ) ; res . Add ( num ) ; return res ; } for ( int i = low + 1 ; i <= high ; i += 2 ) { List < int > l = evaluateAll ( expr , low , i - 1 ) ; List < int > r = evaluateAll ( expr , i + 1 , high ) ; for ( int s1 = 0 ; s1 < l . Count ; s1 ++ ) { for ( int s2 = 0 ; s2 < r . Count ; s2 ++ ) { int val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) ; res . Add ( val ) ; } } } return res ; } public static void Main ( ) { String expr = \"1*2 + 3*4\" ; int len = expr . Length ; List < int > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . WriteLine ( ans [ i ] ) ; } } }"}
{"text": "Program untuk memeriksa sama ada nombor tertentu bernasib baik (semua digit adalah berbeza) | C # Program untuk memeriksa sama ada nombor tertentu bernasib baik; Fungsi ini kembali benar jika n bernasib baik; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Kod pemacu", "code": "using System ; class GFG { static bool isLucky ( int n ) { bool [ ] arr = new bool [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } public static void Main ( ) { int [ ] arr = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) if ( isLucky ( arr [ i ] ) ) Console . Write ( arr [ i ] + \" ▁ is ▁ Lucky ▁ STRNEWLINE \" ) ; else Console . Write ( arr [ i ] + \" ▁ is ▁ not ▁ Lucky ▁ STRNEWLINE \" ) ; } }"}
{"text": "Cetak kotak pertama N Nombor Semulajadi tanpa menggunakan *, / dan | C # Program untuk mencetak dataran nombor semulajadi 'n' pertama tanpa menggunakan *, / dan -; Memulakan 'persegi' dan nombor ganjil pertama; Mengira dan mencetak kotak; Cetak dataran; Kemas kini 'persegi' dan 'ganjil'; Kod pemacu", "code": "using System ; class GFG { static void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { Console . Write ( square + \" ▁ \" ) ; square = square + odd ; odd = odd + 2 ; } } public static void Main ( ) { int n = 5 ; printSquares ( n ) ; } }"}
{"text": "Tulis program untuk membalikkan digit nombor | Fungsi rekursif untuk membalikkan digit NUM; Kod pemacu", "code": "using System ; class GFG { static int rev_num = 0 ; static int base_pos = 1 ; static int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } public static void Main ( ) { int num = 4562 ; Console . WriteLine ( reversDigits ( num ) ) ; } }"}
{"text": "Cari nombor sedemikian rupa sehingga maksimum dalam array adalah minimum mungkin selepas xor | C # Program yang mendapati maksimum maksimum minimum; Fungsi rekursif yang mencari nilai minimum selepas eksklusif - atau; Keadaan jika saiz ref adalah sifar atau bit adalah negatif maka kembali 0; Keadaan jika bit semasa dimatikan kemudian tolak nilai semasa dalam vektor curr_off; Keadaan jika bit semasa berada di kemudian tolak nilai semasa dalam vektor curr_on; Keadaan jika curr_off kosong maka hubungi fungsi rekursif pada vektor curr_on; Keadaan jika curr_on kosong maka hubungi fungsi rekursif pada vektor curr_off; Kembalikan minimum curr_off dan curr_on dan tambah kuasa 2 bit semasa; Fungsi yang mencetak nilai minimum selepas eksklusif - atau; Menolak nilai dalam vektor; Jawapan percetakan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int RecursiveFunction ( List < int > re , int bit ) { if ( re . Count == 0 bit < 0 ) return 0 ; List < int > curr_on = new List < int > ( ) ; List < int > curr_off = new List < int > ( ) ; for ( int i = 0 ; i < re . Count ; i ++ ) { if ( ( ( re [ i ] >> bit ) & 1 ) == 0 ) curr_off . Add ( re [ i ] ) ; else curr_on . Add ( re [ i ] ) ; } if ( curr_off . Count == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . Count == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return Math . Min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; } static void PrintMinimum ( int [ ] a , int n ) { List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) v . Add ( a [ i ] ) ; Console . WriteLine ( RecursiveFunction ( v , 30 ) ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 1 } ; int size = arr . Length ; PrintMinimum ( arr , size ) ; } }"}
{"text": "Count of Elements yang sama dengan XOR dari dua elemen berikutnya | C # pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan elemen yang sama dengan XOR dari dua elemen berikutnya; Untuk menyimpan kiraan yang diperlukan; Untuk setiap elemen array supaya ia mempunyai sekurang -kurangnya dua elemen yang muncul selepas itu dalam array; Jika elemen semasa adalah sama dengan XOR dari dua elemen seterusnya dalam array; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int cntElements ( int [ ] arr , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = arr . Length ; Console . WriteLine ( cntElements ( arr , n ) ) ; } }"}
{"text": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | C # Program untuk mencari bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama; Berfungsi untuk mengembalikan kiraan; Hasil permulaan; Pilih unsur 1 triplet; Pilih elemen 2 nd triplet; Pilih 3 elemen triplet; Mengambil XOR dalam subarray pertama; Mengambil XOR dalam subarray kedua; Jika kedua -dua XOR adalah sama; Kod pemacu; Fungsi panggilan", "code": "using System ; class GFG { static int xor_triplet ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; Console . WriteLine ( xor_triplet ( arr , n ) ) ; } }"}
{"text": "Cari bilangan sepasang nod yang ideal di pokok tertentu | C # pelaksanaan pendekatan di atas; Senarai Adjacency; Bit: Bit Array I dan J memulakan dan menamatkan indeks termasuk; bit: array bit n: saiz array bit i adalah indeks yang akan dikemas kini diff adalah (new_val - old_val); Fungsi DFS untuk mencari pasangan yang ideal; Fungsi untuk inisialisasi; Berfungsi untuk menambah kelebihan; Berfungsi untuk mencari bilangan pasangan yang ideal; Cari akar pokok; Kod pemacu; Tambah tepi; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int N = 100005 ; static int n , k ; static List < int > [ ] al = new List < int > [ N ] ; static long Ideal_pair ; static long [ ] bit = new long [ N ] ; static bool [ ] root_node = new bool [ N ] ; static long bit_q ( int i , int j ) { long sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; } static void bit_up ( int i , long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } } static void dfs ( int node ) { Ideal_pair += bit_q ( Math . Max ( 1 , node - k ) , Math . Min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( int i = 0 ; i < al [ node ] . Count ; i ++ ) dfs ( al [ node ] [ i ] ) ; bit_up ( node , - 1 ) ; } static void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } } static void Add_Edge ( int x , int y ) { al [ x ] . Add ( y ) ; root_node [ y ] = false ; } static long Idealpairs ( ) { int r = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; } public static void Main ( String [ ] args ) { n = 6 ; k = 3 ; for ( int i = 0 ; i < al . Length ; i ++ ) al [ i ] = new List < int > ( ) ; initialise ( ) ; Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ; Console . Write ( Idealpairs ( ) ) ; } }"}
{"text": "Cetak bitwise dan set nombor n | C # Program untuk mencetak semua subset bitwise N (pendekatan yang cekap); berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu", "code": "using System ; public class GFG { static void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) Console . Write ( i + \" ▁ \" ) ; Console . WriteLine ( \"0\" ) ; } static public void Main ( ) { int n = 9 ; printSubsets ( n ) ; } }"}
{"text": "Semak jika nombor dibahagikan dengan 17 menggunakan pengendali bitwise | C # Program untuk memeriksa sama ada nombor dibahagikan dengan 17 atau tidak menggunakan pengendali Bitwise. ; fungsi untuk memeriksa secara rekursif jika nombor itu boleh dibahagikan dengan 17 atau tidak; jika n = 0 atau n = 17 maka ya; jika n kurang dari 17, tidak boleh dibahagikan dengan 17; mengurangkan nombor mengikut lantai (n / 16) - n % 16; Fungsi pemacu", "code": "using System ; class GFG { static bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } public static void Main ( ) { int n = 35 ; if ( isDivisibleby17 ( n ) == true ) Console . WriteLine ( n + \" is ▁ divisible ▁ by ▁ 17\" ) ; else Console . WriteLine ( n + \" ▁ is ▁ not ▁ divisible ▁ by ▁ 17\" ) ; } }"}
{"text": "Nombor terbesar dengan perwakilan binari ialah M 1 dan M | C # Program untuk mencari nombor terbesar yang lebih kecil daripada sama dengan n dengan m set bit kemudian m - 1 0 bit. ; Mengembalikan nombor terbesar dengan bit set M kemudian m - 1 0 bit. ; Mulakan dengan 2 bit. ; Jawapan awal adalah 1 yang memenuhi syarat yang diberikan; Semak semua nombor; mengira nombor; jika kurang kemudian n; kenaikan m untuk mendapatkan nombor seterusnya; Kod pemacu", "code": "using System ; class GFG { static long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . Pow ( 2 , m ) - 1 ) * ( ( long ) Math . Pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } static public void Main ( ) { long n = 7 ; Console . WriteLine ( answer ( n ) ) ; } }"}
{"text": "Cari bit set yang paling ketara | Program C # mudah untuk mencari nombor MSB untuk diberikan n. ; Kod pemacu", "code": "using System ; class GFG { static int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; } static public void Main ( ) { int n = 0 ; Console . WriteLine ( setBitNumber ( n ) ) ; } }"}
{"text": "Cari bit set yang paling ketara | C # Program untuk mencari nombor MSB untuk diberikan n. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Kenaikan n oleh 1 supaya hanya ada satu set bit yang hanya sebelum MSB asal. n kini menjadi 1000000000; Kembalikan MSB asal selepas beralih. n kini menjadi 100000000; Kod pemacu", "code": "using System ; class GFG { static int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } public static void Main ( ) { int n = 273 ; Console . WriteLine ( setBitNumber ( n ) ) ; } }"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod C # mudah untuk mengira sifar trailing dalam perwakilan binari nombor; Kod pemacu", "code": "using System ; class GFG { public static int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } static public void Main ( ) { Console . WriteLine ( countTrailingZero ( 11 ) ) ; } }"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | C # kod untuk mengira sifar trailing dalam perwakilan binari nombor; Peta sedikit nilai mod 37 ke kedudukannya; Hanya perbezaan antara (x dan - x) ialah nilai magnitud yang ditandatangani (leftmostbit) nombor negatif yang ditandatangani adalah 1; Kod pemacu", "code": "using System ; class GFG { static int countTrailingZero ( int x ) { int [ ] lookup = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; } static public void Main ( ) { Console . WriteLine ( countTrailingZero ( 48 ) ) ; } }"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | C # Program untuk menilai Ceil (7 N / 8) tanpa menggunakan * dan; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<'; Kod pemacu", "code": "using System ; public class GFG { static int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( multiplyBySevenByEight ( n ) ) ; } }"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | C # Program untuk menilai 7 N / 8 tanpa menggunakan * dan /; Langkah 1) Pertama kali ganda nombor dengan 7 i. e. 7 n = (n << 3) - n * Langkah 2) Bahagikan hasil sebanyak 8; Program Pemandu", "code": "using System ; public class GFG { static int multiplyBySevenByEight ( int n ) { return ( ( n << 3 ) - n ) >> 3 ; } public static void Main ( ) { int n = 15 ; Console . WriteLine ( multiplyBySevenByEight ( n ) ) ; } }"}
{"text": "Set nombor palindrome terpanjang dari julat [l, r] dengan kebanyakan perbezaan k antara maksimum dan minimum | C # Program untuk pendekatan di atas; Berfungsi untuk mencari saiz maksimum kumpulan nombor palindrome yang mempunyai perbezaan antara elemen maksimum dan minimum paling banyak k; Menyimpan semua nombor palindromik dalam julat [l, r]; Melintasi julat [l, r]; Jika saya adalah palindrome; Tambah nombor dalam senarai; Kedai kiraan nombor palindromik maksimum; Melelehkan setiap elemen dalam senarai; Kirakan indeks paling kanan dalam senarai <elemen semasa + k; Semak jika terdapat indeks paling kanan dari indeks semasa; Mengembalikan kiraan; Berfungsi untuk mencari indeks paling kanan nombor yang diberikan; Simpan indeks paling kanan; Hitung pertengahan; Jika diberi nombor <= num; Berikan Ans = Mid; Mengemas kini rendah; Mengemas kini tinggi; kembali Ans; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah palindrome atau tidak; Menjana terbalik nombor yang diberikan; Jika n adalah palindrome; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int countNumbers ( int L , int R , int K ) { List < int > list = new List < int > ( ) ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . Add ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . Count ; i ++ ) { int right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != - 1 ) count = Math . Max ( count , right_index - i + 1 ) ; } return count ; } static int search ( List < int > list , int num ) { int low = 0 , high = list . Count - 1 ; int ans = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } static bool isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; } public static void Main ( string [ ] args ) { int L = 98 , R = 112 ; int K = 13 ; Console . WriteLine ( countNumbers ( L , R , K ) ) ; } }"}
{"text": "Memaksimumkan jumlah yang mungkin dengan menolak nilai yang sama dari semua elemen subarray array yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari jumlah maksimum dengan menolak nilai yang sama dari semua elemen subarray; Kedai elemen yang lebih kecil sebelumnya; Kedai elemen yang lebih kecil seterusnya; Mengira sumbangan setiap elemen; Jawapan kembali; Berfungsi untuk menjana elemen yang lebih kecil sebelumnya untuk setiap elemen array; Unsur pertama tidak mempunyai lebih kecil sebelumnya; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku sebelum ini; Tolak indeks pertama; Pop semua elemen sehingga elemen sebelumnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil sebelumnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk menjana elemen yang lebih kecil seterusnya untuk setiap elemen array; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku seterusnya; Melangkah dalam urutan terbalik untuk mengira lebih kecil seterusnya; Pop semua elemen sehingga elemen seterusnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil seterusnya; Tolak indeks elemen semasa; Mengembalikan array; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static int findMaximumSum ( int [ ] a , int n ) { int [ ] prev_smaller = findPrevious ( a , n ) ; int [ ] next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = Math . Max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } public static int [ ] findPrevious ( int [ ] a , int n ) { int [ ] ps = new int [ n ] ; ps [ 0 ] = - 1 ; Stack < int > stack = new Stack < int > ( ) ; stack . Push ( 0 ) ; for ( int i = 1 ; i < a . Length ; i ++ ) { while ( stack . Count > 0 && a [ stack . Peek ( ) ] >= a [ i ] ) stack . Pop ( ) ; ps [ i ] = stack . Count > 0 ? stack . Peek ( ) : - 1 ; stack . Push ( i ) ; } return ps ; } public static int [ ] findNext ( int [ ] a , int n ) { int [ ] ns = new int [ n ] ; ns [ n - 1 ] = n ; Stack < int > stack = new Stack < int > ( ) ; stack . Push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( stack . Count > 0 && a [ stack . Peek ( ) ] >= a [ i ] ) stack . Pop ( ) ; ns [ i ] = stack . Count > 0 ? stack . Peek ( ) : a . Length ; stack . Push ( i ) ; } return ns ; } public static void Main ( String [ ] args ) { int n = 3 ; int [ ] a = { 80 , 48 , 82 } ; Console . WriteLine ( findMaximumSum ( a , n ) ) ; } }"}
{"text": "Semak jika rentetan yang diberikan disalurkan substring rentetan lain | Fungsi ini kembali benar jika kandungan ARR1 [] dan ARR2 [] sama, jika tidak palsu. ; Fungsi ini mencari semua permutasi pat [] dalam txt []; Countp []: Simpan kiraan semua aksara corak counttw []: kiraan kiraan tetingkap semasa teks; Melintasi watak corak yang tersisa; Bandingkan tuduhan tetingkap semasa teks dengan tuduhan corak []; Tambah aksara semasa ke tetingkap semasa; Keluarkan watak pertama tetingkap sebelumnya; Periksa tetingkap terakhir dalam teks; Kod pemacu", "code": "static bool compare ( int [ ] arr1 , int [ ] arr2 ) { for ( int i = 0 ; i < 256 ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } static bool search ( String pat , String txt ) { int M = pat . Length ; int N = txt . Length ; int [ ] countP = new int [ 256 ] ; int [ ] countTW = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) { countP [ i ] = 0 ; countTW [ i ] = 0 ; } for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] ] ) ++ ; ( countTW [ txt [ i ] ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) return true ; ( countTW [ txt [ i ] ] ) ++ ; countTW [ txt [ i - M ] ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; } public static void Main ( ) { string txt = \" BACDGABCDA \" ; string pat = \" ABCD \" ; if ( search ( pat , txt ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" NO \" ) ; } }"}
{"text": "Memaksimumkan median array yang diberikan selepas menambahkan elemen K ke array yang sama | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan median yang dimaksimumkan; Susun array; Jika saiznya juga; Jika saiz ganjil; Kod pemacu", "code": "using System ; using System . Linq ; class GFG { static double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Array . Sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; } static void Main ( ) { int [ ] arr = { 3 , 2 , 3 , 4 , 2 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( getMaxMedian ( arr , n , k ) ) ; } }"}
{"text": "Susun 3 Integer Tanpa Menggunakan Keadaan atau Menggunakan Hanya Maksimum () Fungsi | C # Program untuk mencetak tiga nombor dalam urutan yang disusun menggunakan fungsi max; Cari elemen maksimum; Cari elemen minimum; Kod pemacu", "code": "using System ; class GFG { static void printSorted ( int a , int b , int c ) { int get_max = Math . Max ( a , Math . Max ( b , c ) ) ; int get_min = - Math . Max ( - a , Math . Max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; Console . Write ( get_min + \" ▁ \" + get_mid + \" ▁ \" + get_max ) ; } public static void Main ( ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; } }"}
{"text": "Jenis penyisipan binari | pelaksanaan berulang; Berfungsi untuk menyusun array [] saiz 'n'; Cari lokasi di mana dipilih haruslah inseretd; Gerakkan semua elemen selepas lokasi untuk mewujudkan ruang; Kod pemacu", "code": "using System ; class GFG { static int binarySearch ( int [ ] a , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } static void insertionSort ( int [ ] a , int n ) { int i , loc , j , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } public static void Main ( String [ ] args ) { int [ ] a = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = a . Length , i ; insertionSort ( a , n ) ; Console . WriteLine ( \" Sorted ▁ array : \" ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + \" ▁ \" ) ; } }"}
{"text": "SENARAI SENSI | C # Program untuk pelaksanaan jenis penyisipan; Fungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu", "code": "using System ; class InsertionSort { void sort ( int [ ] arr ) { int n = arr . Length ; for ( int i = 1 ; i < n ; ++ i ) { int key = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } static void printArray ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] + \" ▁ \" ) ; Console . Write ( \" STRNEWLINE \" ) ; } public static void Main ( ) { int [ ] arr = { 12 , 11 , 13 , 5 , 6 } ; InsertionSort ob = new InsertionSort ( ) ; ob . sort ( arr ) ; printArray ( arr ) ; } }"}
{"text": "Count Permutasi yang berbeza dari rentetan yang diperoleh dengan menukar hanya aksara yang tidak sama rata | Mengimport kelas kamus; Fungsi untuk mengira jumlah bilangan permutasi yang sah; Mewujudkan kiraan yang sama dengan jumlah aksara yang hadir dan ANS yang akan menyimpan bilangan permutasi yang unik; Menyimpan kekerapan setiap watak yang ada dalam rentetan; Menambah kiraan aksara dengan tidak termasuk aksara sama dengan char semasa; Kurangkan kekerapan aksara semasa dan dikira sebanyak 1, supaya ia tidak dapat mengganggu pengiraan unsur -unsur yang sama ada di sebelah kanannya. ; Kembalikan ANS + 1 (kerana rentetan yang diberikan juga merupakan permutasi yang unik)", "code": "using System ; using System . Collections . Generic ; public class GFG { static int validPermutations ( String str ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int count = str . Length , ans = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( m . ContainsKey ( str [ i ] ) ) m [ str [ i ] ] = m [ str [ i ] ] + 1 ; else m . Add ( str [ i ] , 1 ) ; } for ( int i = 0 ; i < str . Length ; i ++ ) { ans += count - m [ str [ i ] ] ; if ( m . ContainsKey ( str [ i ] ) ) m [ str [ i ] ] = m [ str [ i ] ] - 1 ; count -- ; } return ans + 1 ; } public static void Main ( String [ ] args ) { String str = \" sstt \" ; Console . WriteLine ( validPermutations ( str ) ) ; } }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | C # Program untuk mengira jumlah laluan dari titik ke asal; Fungsi berasaskan DP untuk mengira bilangan laluan; Isi penyertaan dalam Bottommost Row dan lajur paling kiri; Isi DP dengan cara bawah; Kod pemacu", "code": "using System ; public class GFG { static int countPaths ( int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; return dp [ n , m ] ; } public static void Main ( ) { int n = 3 , m = 2 ; Console . WriteLine ( \" ▁ Number ▁ of \" + \" ▁ Paths ▁ \" + countPaths ( n , m ) ) ; } }"}
{"text": "Perubahan duit syiling | DP | Program C # Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program Pemandu", "code": "using System ; class GFG { static int count ( int [ ] S , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int m = arr . Length ; Console . Write ( count ( arr , m , 4 ) ) ; } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi ToUppercase; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "using System ; public class GFG { static bool equalIgnoreCase ( String str1 , String str2 ) { str1 = str1 . ToUpper ( ) ; str2 = str2 . ToUpper ( ) ; int x = str1 . CompareTo ( str2 ) ; if ( x != 0 ) { return false ; } else { return true ; } } static void equalIgnoreCaseUtil ( String str1 , String str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { Console . WriteLine ( \" Same \" ) ; } else { Console . WriteLine ( \" Not ▁ Same \" ) ; } } public static void Main ( ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }"}
{"text": "Gantikan setiap urutan konsonan dengan panjangnya dalam rentetan yang diberikan | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang ditukar selepas menggantikan setiap urutan konsonan dengan panjangnya; Untuk menyimpan rentetan yang dihasilkan; Memeriksa setiap watak untuk urutan konsonan; Hitung panjang urutan konsonan; Tambah panjang dalam rentetan; Tambah vokal; Semak urutan konsonan terakhir dalam rentetan; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "using System ; public class GFG { public static string replaceConsonants ( string str ) { string res = \" \" ; int i = 0 , count = 0 ; while ( i < str . Length ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) { i ++ ; count ++ ; } else { if ( count > 0 ) { res += count ; } res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) { res += count ; } return res ; } public static void Main ( string [ ] args ) { string str = \" abcdeiop \" ; Console . WriteLine ( replaceConsonants ( str ) ) ; } }"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | C # Program untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam setiap substring saiz k; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan dtring; untuk setiap substring; substring saiz k; mengira bilangan vokal dan konsonan; tambah produk untuk dijawab. ; Program yang didorong", "code": "using System ; public class GFG { static bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static String encryptString ( String s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; String ans = \" \" ; for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s [ r ] ) == true ) { countVowels ++ ; } else { countConsonants ++ ; } } ans += Convert . ToString ( countVowels * countConsonants ) ; } return ans ; } static public void Main ( ) { String s = \" hello \" ; int n = s . Length ; int k = 2 ; Console . Write ( encryptString ( s , n , k ) ) ; } }"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | C # pelaksanaan pendekatan di atas; Kami memisahkan input berdasarkan ruang (s) +: ungkapan biasa ini akan mengendalikan senario di mana kami mempunyai kata -kata yang dipisahkan oleh pelbagai ruang; Charat (0) hanya akan memilih watak pertama dari rentetan dan tambahan ke penampan; Kod pemacu", "code": "using System ; using System . Text ; class GFG { private static StringBuilder charBuffer = new StringBuilder ( ) ; public static String processWords ( String input ) { String [ ] s = input . Split ( ' ▁ ' ) ; foreach ( String values in s ) { charBuffer . Append ( values [ 0 ] ) ; } return charBuffer . ToString ( ) ; } public static void Main ( ) { String input = \" geeks ▁ for ▁ geeks \" ; Console . WriteLine ( processWords ( input ) ) ; } }"}
{"text": "Menjana semua rentetan binari tanpa berturut -turut 1 's | C # Program untuk menjana semua rentetan binari tanpa saiz 1 berturut -turut K; Penukaran array ke rentetan -; Keadaan asas apabila kami sampai pada akhir array * *; Mencetak rentetan yang dihasilkan * * kembali ke kes sebelumnya *; Jika watak pertama adalah sifar maka menambah * *; Jika watak itu adalah satu maka tambah sifar ke seterusnya * *; Memanggil secara rekursif untuk nilai berikutnya; Memulakan watak pertama kepada sifar; Menjana rentetan bermula dengan sifar -; Watak pertama yang dimulakan untuk satu -; Kod pemacu; Memanggil Fungsi Menyeronokkan dengan Argumen K", "code": "using System ; class GFG { static string toString ( char [ ] a ) { string String = new string ( a ) ; return String ; } static void generate ( int k , char [ ] ch , int n ) { if ( n == k ) { Console . Write ( toString ( ch ) + \" ▁ \" ) ; return ; } if ( ch [ n - 1 ] == '0' ) { ch [ n ] = '0' ; generate ( k , ch , n + 1 ) ; ch [ n ] = '1' ; generate ( k , ch , n + 1 ) ; } if ( ch [ n - 1 ] == '1' ) { ch [ n ] = '0' ; generate ( k , ch , n + 1 ) ; } } static void fun ( int k ) { if ( k <= 0 ) { return ; } char [ ] ch = new char [ k ] ; ch [ 0 ] = '0' ; generate ( k , ch , 1 ) ; ch [ 0 ] = '1' ; generate ( k , ch , 1 ) ; } static void Main ( ) { int k = 3 ; fun ( k ) ; } }"}
{"text": "Silinder bulat kanan terbesar dalam kiub | C # Program untuk mencari silinder bulat kanan terbesar yang boleh sesuai dalam kiub; Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "using System ; class GFG { static float findVolume ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; float h = a ; float V = ( float ) ( 3.14 * Math . Pow ( r , 2 ) * h ) ; return V ; } public static void Main ( ) { float a = 5 ; Console . WriteLine ( findVolume ( a ) ) ; } }"}
{"text": "Program untuk jumlah piramid | C # Program untuk jumlah piramid. ; Berfungsi untuk mencari jumlah piramid segi tiga; Berfungsi untuk mencari jumlah piramid persegi; Berfungsi untuk mencari jumlah piramid pentagonal; Berfungsi untuk mencari jumlah piramid heksagon; Kod pemacu", "code": "using System ; class GFG { public static float volumeTriangular ( int a , int b , int h ) { float vol = ( float ) ( 0.1666 ) * a * b * h ; return vol ; } public static float volumeSquare ( int b , int h ) { float vol = ( float ) ( 0.33 ) * b * b * h ; return vol ; } public static float volumePentagonal ( int a , int b , int h ) { float vol = ( float ) ( 0.83 ) * a * b * h ; return vol ; } public static float volumeHexagonal ( int a , int b , int h ) { float vol = ( float ) a * b * h ; return vol ; } public static void Main ( ) { int b = 4 , h = 9 , a = 4 ; Console . WriteLine ( \" Volume ▁ of ▁ triangular \" + \" ▁ base ▁ pyramid ▁ is ▁ \" + volumeTriangular ( a , b , h ) ) ; Console . WriteLine ( \" Volume ▁ of ▁ square ▁ \" + \" base ▁ pyramid ▁ is ▁ \" + volumeSquare ( b , h ) ) ; Console . WriteLine ( \" Volume ▁ of ▁ pentagonal \" + \" ▁ base ▁ pyramid ▁ is ▁ \" + volumePentagonal ( a , b , h ) ) ; Console . WriteLine ( \" Volume ▁ of ▁ Hexagonal \" + \" ▁ base ▁ pyramid ▁ is ▁ \" + volumeHexagonal ( a , b , h ) ) ; } }"}
{"text": "Program untuk mencari kawasan trapezoid | C # Program untuk mengira kawasan trapezoid; Fungsi untuk kawasan tersebut; Kod pemacu", "code": "using System ; class GFG { static double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } public static void Main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; Console . WriteLine ( \" Area ▁ is : ▁ \" + area ) ; } }"}
{"text": "Cari bilangan pepenjuru dalam polygon cembung N sisi | C # Fungsi untuk mencari bilangan pepenjuru dalam polygon cembung N); kod pemacu untuk menguji fungsi di atas", "code": "using System ; class GFG { static int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; } public static void Main ( ) { int n = 5 ; Console . Write ( n + \" ▁ sided ▁ convex ▁ polygon ▁ have ▁ \" ) ; Console . WriteLine ( numberOfDiagonals ( n ) + \" ▁ diagonals \" ) ; } }"}
{"text": "Kawasan segi empat tepat terbesar tanpa titik tertentu | C # pelaksanaan untuk mencari kawasan segi empat tepat terbesar tanpa lubang dalam segi empat tepat; Berfungsi untuk mencari kawasan maksimum supaya ia tidak mengandungi sebarang lubang; Kawasan untuk semua kedudukan yang mungkin dipotong; Cari kawasan maksimum di antara segi empat tepat di atas; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; Console . Write ( Math . Max ( Math . Max ( left , right ) , Math . Max ( above , below ) ) ) ; } public static void Main ( String [ ] args ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( L , B , X , Y ) ; } }"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | C # Program untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Simpan kos minimum yang diperlukan; Buat kamus untuk menyimpan kos maksimum penyingkiran watak; Buat kamus untuk menyimpan jumlah kos penghapusan watak; Melintasi rentetan, s; Jejaki kos maksimum setiap watak; Mengemas kini kos penghapusan maksimum; Jejaki jumlah kos setiap watak; Mengemas kini jumlah kos penghapusan; Melintasi semua watak yang unik; Simpan watak kos maksimum dan padamkan selebihnya; Kembalikan jawapannya; Kod pemacu; Diberikan rentetan; Diberikan pelbagai kos; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int delCost ( string s , int [ ] cost ) { int ans = 0 ; Dictionary < int , int > forMax = new Dictionary < int , int > ( ) ; Dictionary < int , int > forTot = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! forMax . ContainsKey ( s [ i ] ) ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = Math . Max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot . ContainsKey ( s [ i ] ) ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] += cost [ i ] ; } } foreach ( KeyValuePair < int , int > i in forMax ) { ans += forTot [ i . Key ] - i . Value ; } return ans ; } static void Main ( ) { string s = \" AAABBB \" ; int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ; Console . WriteLine ( delCost ( s , cost ) ) ; } }"}
{"text": "Pembahagi terkecil n paling dekat dengan x | C # Program untuk pendekatan di atas; Tentukan makro; Kedai pembahagi untuk semua nombor dalam pembahagi vektor; Saya adalah pembahagi dan j adalah pelbagai; Fungsi untuk membandingkan kedekatan sasaran yang diberikan; Berfungsi untuk mencari elemen yang paling dekat dengan sasaran dalam vektor pembahagi; Kes sudut; Melakukan carian binari; Semak sama ada sasaran kurang daripada elemen array kemudian cari di separuh kiri; Semak sama ada sasaran lebih besar daripada sebelumnya hingga pertengahan, kembali paling dekat dengan dua; Ulangi separuh kiri; Semak sama ada sasaran lebih besar daripada pertengahan; Kemas kini i; Hanya elemen tunggal yang tersisa selepas carian; Berfungsi untuk mencetak pembahagi n paling dekat dengan x; Fungsi panggilan untuk mengira dan menyimpan pembahagi semua nombor dalam vektor; Menyimpan nilai terdekat untuk sasaran; Cetak jawapannya; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int MAX = 10000 ; static List < int > [ ] divisors = new List < int > [ MAX + 1 ] ; static void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . Add ( i ) ; } } } static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } static int findClosest ( List < int > array , int n , int target ) { int [ ] arr = array . ToArray ( ) ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } static void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . Count , X ) ; Console . Write ( ans ) ; } public static void Main ( String [ ] args ) { int N = 16 , X = 5 ; for ( int i = 0 ; i < divisors . Length ; i ++ ) divisors [ i ] = new List < int > ( ) ; printClosest ( N , X ) ; } }"}
{"text": "Mengira elemen nilai yang sama diletakkan pada indeks yang sama dengan dua array yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk mengira elemen yang dipadankan maksimum dari array A [] dan B []; Kedai kedudukan unsur -unsur array a [] dalam array b []; Jejaki perbezaan antara indeks; Melintasi array a []; Melintasi array b []; Jika perbezaan negatif, tambahkan n kepadanya; Jejaki bilangan peralihan yang diperlukan untuk meletakkan elemen pada indeks yang sama; Mengembalikan perlawanan maksimum; Kod pemacu; Mengembalikan kiraan elemen yang dipadankan", "code": "using System ; using System . Collections . Generic ; class GFG { static int maxMatch ( int [ ] A , int [ ] B ) { Dictionary < int , int > Aindex = new Dictionary < int , int > ( ) ; Dictionary < int , int > diff = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < A . Length ; i ++ ) { Aindex [ A [ i ] ] = i ; } for ( int i = 0 ; i < B . Length ; i ++ ) { if ( i - Aindex [ B [ i ] ] < 0 ) { if ( ! diff . ContainsKey ( A . Length + i - Aindex [ B [ i ] ] ) ) { diff [ A . Length + i - Aindex [ B [ i ] ] ] = 1 ; } else { diff [ A . Length + i - Aindex [ B [ i ] ] ] += 1 ; } } else { if ( ! diff . ContainsKey ( i - Aindex [ B [ i ] ] ) ) { diff [ i - Aindex [ B [ i ] ] ] = 1 ; } else { diff [ i - Aindex [ B [ i ] ] ] += 1 ; } } } int max = 0 ; foreach ( KeyValuePair < int , int > ele in diff ) { if ( ele . Value > max ) { max = ele . Value ; } } return max ; } static void Main ( ) { int [ ] A = { 5 , 3 , 7 , 9 , 8 } ; int [ ] B = { 8 , 7 , 3 , 5 , 9 } ; Console . WriteLine ( maxMatch ( A , B ) ) ; } }"}
{"text": "Semak jika diberi penyelesaian Sudoku adalah sah atau tidak | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada semua elemen lembaga [] [] nilai kedai array dalam julat [1, 9]; Traverse Board [] [] array; Semak jika papan [i] [j] terletak dalam julat; Fungsi untuk memeriksa sama ada penyelesaian teka -teki sudoku sah atau tidak; Semak sama ada semua elemen papan [] [] menyimpan nilai dalam julat [1, 9]; Kedai nilai unik dari 1 hingga n; Melintasi setiap baris array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap lajur baris semasa; Menyimpan nilai papan [i] [j]; Semak jika baris semasa menyimpan nilai pendua; Melintasi setiap lajur array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap baris lajur semasa; Menyimpan nilai papan [j] [i]; Semak jika lajur semasa menyimpan nilai pendua; Melintasi setiap blok saiz 3 * 3 di papan [] [] array; J menyimpan lajur pertama setiap 3 * 3 blok; Memulakan array unik [] kepada palsu; Melintasi blok semasa; Kedai baris nombor blok semasa; Menyimpan nombor lajur blok semasa; Menyimpan nilai papan [x] [y]; Semak jika blok semasa menyimpan nilai pendua; Jika semua keadaan berpuas hati; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int N = 9 ; static bool isinRange ( int [ , ] board ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i , j ] <= 0 board [ i , j ] > 9 ) { return false ; } } } return true ; } static bool isValidSudoku ( int [ , ] board ) { if ( isinRange ( board ) == false ) { return false ; } bool [ ] unique = new bool [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { Array . Fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i , j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { Array . Fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j , i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { Array . Fill ( unique , false ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X , Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; } public static void Main ( ) { int [ , ] board = { { 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 } , { 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 } , { 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 } , { 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 } , { 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 } , { 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 } , { 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 } , { 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 } , { 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 } } ; if ( isValidSudoku ( board ) ) { Console . WriteLine ( \" Valid \" ) ; } else { Console . WriteLine ( \" Not ▁ Valid \" ) ; } } }"}
{"text": "Subarray panjang k yang penggabungannya membentuk palindrome | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah palindrome atau tidak di sini saya adalah indeks permulaan dan j adalah indeks terakhir subarray; Jika integer di saya tidak sama dengan j maka subarray bukan palindrome; Jika tidak; Semua [i] adalah sama dengan [j] maka subarray adalah palindrome; Berfungsi untuk mencari subarray yang penggabungannya membentuk palindrome dan mengembalikan indeks permulaannya; Melangkah ke atas subarray panjang k dan memeriksa jika subarray itu adalah palindrome; Jika tiada subarray adalah palindrome; Kod pemacu", "code": "using System ; class GFG { public static bool palindrome ( int [ ] a , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; } static int findSubArray ( int [ ] arr , int k ) { int n = arr . Length ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return - 1 ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 1 , 3 } ; int k = 4 ; int ans = findSubArray ( arr , k ) ; if ( ans == - 1 ) Console . Write ( - 1 + \" STRNEWLINE \" ) ; else { for ( int i = ans ; i < ans + k ; i ++ ) Console . Write ( arr [ i ] + \" ▁ \" ) ; Console . Write ( \" STRNEWLINE \" ) ; } } }"}
{"text": "Semak sama ada urutan laluan melawat sebarang koordinat dua kali atau tidak | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada lelaki itu melintasi koordinat sebelumnya atau tidak; Menyimpan kiraan puncak silang; Kedai (x, y) koordinat; Koordinat untuk asal; Melangkah ke atas rentetan; Keadaan kepada kenaikan x atau y co - masing -masing; Semak jika (x, y) sudah dilawati; Cetak hasilnya; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void isCrossed ( String path ) { if ( path . Length == 0 ) return ; bool ans = false ; HashSet < KeyValuePair < int , int > > mySet = new HashSet < KeyValuePair < int , int > > ( ) ; int x = 0 , y = 0 ; mySet . Add ( new KeyValuePair < int , int > ( x , y ) ) ; for ( int i = 0 ; i < path . Length ; i ++ ) { if ( path [ i ] == ' N ' ) mySet . Add ( new KeyValuePair < int , int > ( x , y ++ ) ) ; if ( path [ i ] == ' S ' ) mySet . Add ( new KeyValuePair < int , int > ( x , y -- ) ) ; if ( path [ i ] == ' E ' ) mySet . Add ( new KeyValuePair < int , int > ( x ++ , y ) ) ; if ( path [ i ] == ' W ' ) mySet . Add ( new KeyValuePair < int , int > ( x -- , y ) ) ; if ( mySet . Contains ( new KeyValuePair < int , int > ( x , y ) ) ) { ans = true ; break ; } } if ( ans ) Console . Write ( \" Crossed \" ) ; else Console . Write ( \" Not ▁ Crossed \" ) ; } public static void Main ( String [ ] args ) { String path = \" NESW \" ; isCrossed ( path ) ; } }"}
{"text": "Lebar maksimum n | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari lebar maksimum pokok menggunakan traversal urutan tahap; Simpan tepi pokok; Menyimpan lebar maksimum pokok; Menyimpan nod setiap peringkat; Masukkan nod akar; Melakukan perintah level traversal di atas pokok; Menyimpan saiz barisan; Kemas kini lebar maksimum; Tolak nod tahap seterusnya dan popkan unsur -unsur tahap semasa; Dapatkan elemen dari depan barisan; Tolak semua nod peringkat seterusnya. ; Kembalikan hasilnya. ; Kod pemacu; Pokok yang dibina ialah: 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7", "code": "using System ; using System . Collections . Generic ; class GFG { static int maxWidth ( int N , int M , List < int > cost , List < List < int > > s ) { List < List < int > > adj = new List < List < int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { adj . Add ( new List < int > ( ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . Add ( s [ i ] [ 1 ] ) ; } int result = 0 ; Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 0 ) ; while ( q . Count != 0 ) { int count = q . Count ; result = Math . Max ( count , result ) ; while ( count -- > 0 ) { int temp = q . Dequeue ( ) ; for ( int i = 0 ; i < adj [ temp ] . Count ; i ++ ) { q . Enqueue ( adj [ temp ] [ i ] ) ; } } } return result ; } static public void Main ( ) { int N = 11 , M = 10 ; List < List < int > > edges = new List < List < int > > ( ) ; edges . Add ( new List < int > ( ) { 0 , 1 } ) ; edges . Add ( new List < int > ( ) { 0 , 2 } ) ; edges . Add ( new List < int > ( ) { 0 , 3 } ) ; edges . Add ( new List < int > ( ) { 1 , 4 } ) ; edges . Add ( new List < int > ( ) { 1 , 5 } ) ; edges . Add ( new List < int > ( ) { 3 , 6 } ) ; edges . Add ( new List < int > ( ) { 4 , 7 } ) ; edges . Add ( new List < int > ( ) { 6 , 10 } ) ; edges . Add ( new List < int > ( ) { 6 , 8 } ) ; edges . Add ( new List < int > ( ) { 6 , 9 } ) ; List < int > cost = new List < int > ( ) { 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 } ; Console . WriteLine ( maxWidth ( N , M , cost , edges ) ) ; } }"}
{"text": "Kurangkan jumlah nombor perdana yang ditambah untuk membuat array bukan | C # Program untuk melaksanakan pendekatan di atas; Kedai jika indeks adalah nilai utama / bukan utama; Menyimpan perdana; Berfungsi untuk menjana semua nombor perdana; Jika elemen semasa adalah perdana; Tetapkan semua gandaannya bukan perdana; Simpan semua nombor utama; Berfungsi untuk mencari perdana terdekat dengan nombor tertentu; Memohon carian binari pada vektor prima; Jika perdana ditambah menjadikan unsur -unsur sama; Kembali ini sebagai perdana terdekat; Jika array kekal tidak menurun; Cari nombor perdana yang lebih besar; Jika tidak; Periksa sama ada perdana yang lebih kecil boleh membuat array tidak berkurangan atau tidak; Mengembalikan nombor terdekat; Berfungsi untuk mencari kos minimum; Cari semua prima; Simpan hasilnya; Melangkah ke atas array; Elemen semasa adalah kurang daripada elemen sebelumnya; Cari perdana terdekat yang membuat array tidak berkurangan; Tambah kepada kos keseluruhan; Mengemas kini elemen semasa; Mengembalikan kos minimum; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static int MAX = 10000000 ; static bool [ ] isPrime = new bool [ MAX + 1 ] ; static ArrayList primes = new ArrayList ( ) ; static void SieveOfEratosthenes ( ) { Array . Fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . Add ( p ) ; } static int prime_search ( ArrayList primes , int diff ) { int low = 0 ; int high = primes . Count - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( int ) primes [ mid ] == diff ) { return ( int ) primes [ mid ] ; } else if ( ( int ) primes [ mid ] < diff ) { low = mid + 1 ; } else { res = ( int ) primes [ mid ] ; high = mid - 1 ; } } return res ; } static int minCost ( int [ ] arr , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; } public static void Main ( string [ ] args ) { int [ ] arr = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; Console . Write ( minCost ( arr , n ) ) ; } }"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | C # pelaksanaan untuk pendekatan di atas; Berfungsi untuk mengembalikan cara untuk memecah rentetan ke dalam tiga bahagian dengan bilangan yang sama 0; Simpan jumlah kiraan 0 s; Kira Jumlah No. daripada 0 s watak dalam rentetan yang diberikan; Jika jumlah kiraan 0 watak tidak boleh dibahagikan dengan 3; Memulakan peta untuk menyimpan kekerapan k; Traverse String untuk mencari cara untuk memecah rentetan; Kiraan kenaikan jika 0 muncul; Hasil kenaikan jika jumlah sama dengan 2 * k dan k ada dalam peta; Masukkan jumlah dalam peta; Hasil pulangan; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static int count ( String s ) { int cnt = 0 ; foreach ( char c in s . ToCharArray ( ) ) { cnt += c == '0' ? 1 : 0 ; } if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ; Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { sum += s [ i ] == '0' ? 1 : 0 ; if ( sum == 2 * k && map . ContainsKey ( k ) && i < s . Length - 1 && i > 0 ) { res += map [ k ] ; } if ( map . ContainsKey ( sum ) ) map [ sum ] = map [ sum ] + 1 ; else map . Add ( sum , 1 ) ; } return res ; } public static void Main ( String [ ] args ) { String str = \"01010\" ; Console . WriteLine ( count ( str ) ) ; } }"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | C # Program untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk berpecah; Mengira jumlah sifar; Kes1 jika jumlah kiraan sifar tidak boleh dibahagikan dengan 3; Case2 Jika jumlah kiraan sifar adalah sifar; Bilangan sifar dalam setiap substring; Memulakan sifar kepada bilangan cara untuk potongan pertama dan kedua; Memulakan kiraan; Melintasi dari awal; Meningkatkan kiraan jika elemen adalah '0'; Meningkatkan cara untuk pemotongan 1 jika kiraan adalah sama dengan sifar yang diperlukan dalam setiap substring; Meningkatkan cara untuk pemotongan 2 nd jika kiraan adalah sama dengan 2 * (sifar yang diperlukan dalam setiap substring); Jumlah cara untuk berpecah adalah pendaraban cara untuk potongan 1 dan 2; Kod pemacu; Panggilan fungsi", "code": "using System . Collections . Generic ; using System ; class GFG { static int splitstring ( string s ) { int n = s . Length ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 ; int waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } public static void Main ( ) { string s = \"01010\" ; Console . WriteLine ( \" The ▁ number ▁ of ▁ ways ▁ \" + \" to ▁ split ▁ is ▁ \" + splitstring ( s ) ) ; } }"}
{"text": "Semak jika rentetan boleh ditukar kepada yang lain dengan menukar watak bersebelahan jenis yang diberikan | C # Program untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk mengubah mula berakhir; Semak urutan A, B dalam kedua -dua String Str1 dan Str2; Jika kedua -dua rentetan tidak sama; Melintasi rentetan; Semak indeks A dan B; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static bool canTransform ( string str1 , string str2 ) { string s1 = \" \" ; string s2 = \" \" ; foreach ( char c in str1 . ToCharArray ( ) ) { if ( c != ' C ' ) { s1 += c ; } } foreach ( char c in str2 . ToCharArray ( ) ) { if ( c != ' C ' ) { s2 += c ; } } if ( s1 != s2 ) return false ; int i = 0 ; int j = 0 ; int n = str1 . Length ; while ( i < n && j < n ) { if ( str1 [ i ] == ' C ' ) { i ++ ; } else if ( str2 [ j ] == ' C ' ) { j ++ ; } else { if ( ( str1 [ i ] == ' A ' && i < j ) || ( str1 [ i ] == ' B ' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } public static void Main ( string [ ] args ) { string str1 = \" BCCABCBCA \" ; string str2 = \" CBACCBBAC \" ; if ( canTransform ( str1 , str2 ) ) { Console . Write ( \" Yes \" ) ; } else { Console . Write ( \" No \" ) ; } } }"}
{"text": "Substring terpanjang yang mempunyai kiraan vokal dan konsonan yang sama | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai bilangan vokal dan konsonan yang sama; Menjana array; Memulakan pembolehubah untuk menyimpan hasil; Menyimpan jumlah subarray; Peta untuk menyimpan indeks jumlah; Gelung melalui array; Jika jumlah adalah 0; Count vokal dan konsonan adalah sama; Mengemas kini panjang maksimum substring dalam kamus; Simpan indeks jumlah; Mengembalikan panjang maksimum substring yang diperlukan; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int maxsubStringLength ( char [ ] S , int N ) { int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; int maxLen = 0 ; int curr_sum = 0 ; Dictionary < int , int > hash = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . Max ( maxLen , i + 1 ) ; if ( hash . ContainsKey ( curr_sum ) ) maxLen = Math . Max ( maxLen , i - hash [ curr_sum ] ) ; else hash . Add ( curr_sum , i ) ; } return maxLen ; } public static void Main ( String [ ] args ) { String S = \" geeksforgeeks \" ; int n = S . Length ; Console . Write ( maxsubStringLength ( S . ToCharArray ( ) , n ) ) ; } }"}
{"text": "Jarak minimum dari sel tertentu ke semua sel lain dari matriks | C # Program untuk melaksanakan pendekatan di atas; Menyimpan arahan yang boleh diakses; Fungsi untuk mencari jarak minimum dari sel tertentu ke semua sel lain dalam matriks; Menyimpan sel -sel yang boleh diakses dari sel semasa; Masukkan pasangan (x, y); Melangkah ke barisan adalah kosong; Ekstrak pasangan; Pop mereka; Memeriksa keadaan sempadan; Jika sel tidak dikunjungi; Menetapkan jarak minimum; Masukkan jiran yang dilalui ke dalam barisan; Kod pemacu; Cetak jarak yang diperlukan", "code": "using System ; using System . Collections . Generic ; class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int [ , ] mat = new int [ 1001 , 1001 ] ; static int r , c , x , y ; static int [ ] dx = { 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 } ; static int [ ] dy = { 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 } ; static void FindMinimumDistance ( ) { Queue < pair > q = new Queue < pair > ( ) ; q . Enqueue ( new pair ( x , y ) ) ; mat [ x , y ] = 0 ; while ( q . Count != 0 ) { x = q . Peek ( ) . first ; y = q . Peek ( ) . second ; q . Dequeue ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a >= r b >= c b < 0 ) continue ; if ( mat [ a , b ] == 0 ) { mat [ a , b ] = mat [ x , y ] + 1 ; q . Enqueue ( new pair ( a , b ) ) ; } } } } public static void Main ( String [ ] args ) { r = 5 ; c = 5 ; x = 1 ; y = 1 ; int t = x ; int l = y ; mat [ x , y ] = 0 ; FindMinimumDistance ( ) ; mat [ t , l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { Console . Write ( mat [ i , j ] + \" ▁ \" ) ; } Console . WriteLine ( ) ; } } }"}
{"text": "Kelebihan minimum yang diperlukan untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | C # Program untuk melaksanakan pendekatan di atas; Fungsi yang mengembalikan bilangan minimum flip untuk menukar s ke dalam penyambungan sub -panjang sub -rentetan; Menyimpan hasilnya; Melangkah melalui indeks rentetan; Kedai kiraan 0 S & 1 S; ITERATE MEMBUAT K JUMPS; Kiraan 0 's; Kiraan 1 's; Tambah flip minimum untuk Indeks I; Mengembalikan bilangan minimum; Kod pemacu", "code": "using System ; class GFG { public static int minOperations ( String S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . Length ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += Math . Min ( zero , one ) ; } return ans ; } public static void Main ( String [ ] args ) { String S = \"110100101\" ; int K = 3 ; Console . WriteLine ( minOperations ( S , K ) ) ; } }"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | C # Program untuk pendekatan di atas; Berfungsi untuk mendapatkan elemen yang hilang; Untuk elemen maksimum dalam array; Untuk elemen minimum dalam array; Untuk XOR semua elemen; Perbezaan umum siri AP; Cari elemen maksimum dan minimum; Mengira perbezaan biasa; Kirakan XOR semua elemen; Lakukan XOR dengan siri AP sebenar yang dihasilkan X akan menjadi ANS; Mengembalikan elemen yang hilang; Kod pemacu; Diberikan array; Panggilan fungsi; Cetak elemen yang hilang", "code": "using System ; class GFG { static int missingElement ( int [ ] arr , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } public static void Main ( ) { int [ ] arr = new int [ ] { 12 , 3 , 6 , 15 , 18 } ; int n = arr . Length ; int element = missingElement ( arr , n ) ; Console . Write ( element ) ; } }"}
{"text": "Memandangkan rentetan dan integer k, cari sub sub | C # pelaksanaan pendekatan; Berfungsi untuk mencetak sub -sub - string; Jumlah sub - rentetan mungkin; Jika k lebih besar daripada jumlah sub -rentetan; Untuk menyimpan nombor sub -rentetan bermula dengan watak rentetan; Mengira nilai -nilai; Substring [i - 1] ditambah untuk menyimpan jumlah kumulatif; Carian binari untuk mencari indeks permulaan sub -rentetan KTH; Untuk menyimpan indeks akhir sub -rentetan KTH; Cetak sub -rentetan; Kod pemacu", "code": "using System ; class GFG { static void Printksubstring ( String str , int n , int k ) { int total = ( n * ( n + 1 ) ) / 2 ; if ( k > total ) { Console . Write ( \" - 1 STRNEWLINE \" ) ; return ; } int [ ] substring = new int [ n + 1 ] ; substring [ 0 ] = 0 ; int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) { l = m + 1 ; } else { start = m ; break ; } } int end = n - ( substring [ start ] - k ) ; for ( int i = start - 1 ; i < end ; i ++ ) { Console . Write ( str [ i ] ) ; } } public static void Main ( String [ ] args ) { String str = \" abc \" ; int k = 4 ; int n = str . Length ; Printksubstring ( str , n , k ) ; } }"}
{"text": "Titik penyisipan yang lebih rendah | C # Program untuk mencari titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Berfungsi untuk mengembalikan titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Kes asas; Pemeriksaan akhir untuk unsur -unsur yang tersisa yang <x; Kod pemacu", "code": "using System ; public class GFG { static int LowerInsertionPoint ( int [ ] arr , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } static public void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = arr . Length ; int X = 4 ; Console . WriteLine ( LowerInsertionPoint ( arr , n , X ) ) ; } }"}
{"text": "Bilangan jawatan dengan alamat yang sama dalam baris utama dan lajur utama urutan | C # Program untuk mengira bilangan kedudukan dengan alamat yang sama dalam perintah utama dan lajur utama; Mengembalikan kiraan kedudukan yang diperlukan; array 1D mendatar; array 1D menegak; melangkah untuk semua yang mungkin saya; Memeriksa jika J adalah integer; Memeriksa jika J terletak b / w 1 hingga n; melangkah untuk semua kemungkinan j; Memeriksa jika saya adalah integer; Memeriksa jika saya terletak b / w 1 hingga m; Kod pemacu", "code": "using System ; class GFG { static int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } public static void Main ( ) { int M = 3 , N = 5 ; Console . WriteLine ( getCount ( M , N ) ) ; } }"}
{"text": "Maksimum dalam pelbagai yang boleh membuat array lain disusun | C # Program untuk membuat array disusun; Fungsi untuk memeriksa sama ada terdapat unsur swappable yang hadir untuk membuat array pertama disusun; WrongIdx adalah indeks elemen yang membuat array pertama tidak disusun; Cari elemen maksimum yang memenuhi syarat jiran yang disebutkan di atas; Jika res adalah benar maka swap elemen dan buat array pertama disusun; Fungsi untuk mencetak array yang disusun jika elemen ditukar. ; Kod pemacu", "code": "using System ; class GFG { static bool swapElement ( int [ ] arr1 , int [ ] arr2 , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } int maximum = int . MinValue ; int maxIdx = - 1 ; bool res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; } static void swap ( int [ ] a , int wrongIdx , int [ ] b , int maxIdx ) { int c = a [ wrongIdx ] ; a [ wrongIdx ] = b [ maxIdx ] ; b [ maxIdx ] = c ; } static void getSortedArray ( int [ ] arr1 , int [ ] arr2 , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr1 [ i ] + \" ▁ \" ) ; } } else { Console . Write ( \" Not ▁ Possible \" ) ; } } public static void Main ( ) { int [ ] arr1 = { 1 , 3 , 7 , 4 , 10 } ; int [ ] arr2 = { 2 , 1 , 6 , 8 , 9 } ; int n = arr1 . Length ; getSortedArray ( arr1 , arr2 , n ) ; } }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | C # Program untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Bandingkan setiap tiga nombor untuk mencari nombor tengah. Masukkan hanya jika A> B; Memutuskan A tidak lebih besar daripada b. ; Kod pemacu", "code": "using System ; class Middle { public static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } public static void Main ( ) { int a = 20 , b = 30 , c = 40 ; Console . WriteLine ( middleOfThree ( a , b , c ) ) ; } }"}
{"text": "Kawasan terbesar mungkin selepas penyingkiran siri bar mendatar & menegak | C # Program untuk pendekatan di atas; Berfungsi untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan; Menyimpan semua bar; Masukkan bar mendatar; Masukkan bar verttik; Keluarkan pemisah mendatar dari S1; Keluarkan pemisah menegak dari S2; Kedai -kedai yang ditinggalkan pemisah mendatar dan menegak; Menyusun kedua -dua senarai dalam urutan menaik; Cari perbezaan maksimum jiran List1; Cari perbezaan maksimum jiran List2; Cetak kelantangan terbesar; Kod pemacu; Diberi nilai N & M; Diberikan susunan; Fungsi panggilan untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan", "code": "using System ; using System . Collections . Generic ; class GFG { static void largestArea ( int N , int M , int [ ] H , int [ ] V ) { HashSet < int > s1 = new HashSet < int > ( ) ; HashSet < int > s2 = new HashSet < int > ( ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . Add ( i ) ; for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . Add ( i ) ; for ( int i = 0 ; i < H . Length ; i ++ ) { s1 . Remove ( H [ i ] ) ; } for ( int i = 0 ; i < V . Length ; i ++ ) { s2 . Remove ( V [ i ] ) ; } int [ ] list1 = new int [ s1 . Count ] ; int [ ] list2 = new int [ s2 . Count ] ; int I = 0 ; foreach ( int it1 in s1 ) { list1 [ I ++ ] = it1 ; } I = 0 ; foreach ( int it2 in s2 ) { list2 [ I ++ ] = it2 ; } Array . Sort ( list1 ) ; Array . Sort ( list2 ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( int j = 0 ; j < list1 . Length ; j ++ ) { maxH = Math . Max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( int j = 0 ; j < list2 . Length ; j ++ ) { maxV = Math . Max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } Console . WriteLine ( maxV * maxH ) ; } static void Main ( ) { int N = 3 , M = 3 ; int [ ] H = { 2 } ; int [ ] V = { 2 } ; largestArea ( N , M , H , V ) ; } }"}
{"text": "Semak jika array boleh disusun dengan menukar pasangan dari indeks yang terdiri daripada unsur -unsur yang tidak sama rata dalam array lain | C # Program pendekatan di atas; Fungsi untuk memeriksa sama ada array, [] boleh ditukar menjadi array yang disusun dengan bertukar (a [i], a [j]) jika b [i] tidak sama dengan b [j]; Kedai jika array A [] disusun dalam urutan menurun atau tidak; Melintasi array a []; Jika [i] lebih besar daripada [i + 1]; Bendera kemas kini; Jika array disusun mengikut urutan menaik; kiraan = 2: periksa jika 0 s dan 1 s kedua -duanya hadir dalam b []; Melintasi array; Jika elemen semasa ialah 0; Kiraan kemas kini; Melintasi array b []; Jika elemen semasa ialah 1; Jika kedua -dua 0 s dan 1 s hadir dalam array; Kod pemacu; Array input a []; Arahan input B []; Panggilan fungsi; Jika benar, cetak ya; Lain cetak no", "code": "using System ; public class GFG { static bool checkifSorted ( int [ ] A , int [ ] B , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } public static void Main ( string [ ] args ) { int [ ] A = { 3 , 1 , 2 } ; int [ ] B = { 0 , 1 , 1 } ; int N = A . Length ; bool check = checkifSorted ( A , B , N ) ; if ( check ) { Console . WriteLine ( \" YES \" ) ; } else { Console . WriteLine ( \" NO \" ) ; } } }"}
{"text": "Swap minimum diperlukan di antara dua rentetan untuk membuat satu rentetan ketat lebih besar daripada yang lain | C # Program untuk pendekatan di atas; Berfungsi untuk mencari bilangan langkah minimum untuk membuat A> B; Jika semua watak adalah sama dan m <= n; Sekiranya terdapat sebarang watak dalam B yang lebih besar daripada B [0]; Jika terdapat apa -apa watak yang lebih kecil daripada [0]; Sekiranya terdapat watak yang berada di dalam dan lebih besar daripada [0]; Sekiranya terdapat watak yang berada di B dan kurang daripada B [0]; Jika tidak; Fungsi pemacu", "code": "using System ; using System . Text ; public class GFG { static int minSteps ( StringBuilder A , StringBuilder B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A , A [ 0 ] ) == M && count ( B , B [ 0 ] ) == N ) return - 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } return 0 ; } static int count ( StringBuilder a , char c ) { int count = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) if ( a [ i ] == c ) count ++ ; return count ; } static void swap ( StringBuilder s1 , int index1 , StringBuilder s2 , int index2 ) { char c = s1 [ index1 ] ; s1 [ index1 ] = s2 [ index2 ] ; s2 [ index2 ] = c ; } static public void Main ( ) { StringBuilder A = new StringBuilder ( \" adsfd \" ) ; StringBuilder B = new StringBuilder ( \" dffff \" ) ; int M = A . Length ; int N = B . Length ; Console . WriteLine ( minSteps ( A , B , M , N ) ) ; } }"}
{"text": "Memaksimumkan jumlah produk berpasangan yang dihasilkan dari tatasusunan yang diberikan | C # Program untuk pendekatan di atas; Pembolehubah yang mewakili saiz array; Menyimpan hasilnya; Berfungsi untuk mengembalikan jumlah maksimum yang mungkin; Menyimpan kiraan susunan yang diproses; Jika lebih daripada dua tatasusunan telah diproses; Sekiranya subproblem yang telah dikira telah berlaku; Terokai semua pasangan yang mungkin; Panggilan fungsi rekursif; Memoize maksimum; Mengembalikan nilai; Berfungsi untuk mengembalikan jumlah maksimum produk pasangan yang mungkin; Memulakan array DP ke - 1; Menyusun tatasusunan dalam urutan menurun; Kod pemacu", "code": "using System ; class GFG { const int maxN = 201 ; static int n1 , n2 , n3 ; static int [ , , ] dp = new int [ maxN , maxN , maxN ] ; static int getMaxSum ( int i , int j , int k , int [ ] arr1 , int [ ] arr2 , int [ ] arr3 ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i , j , k ] != - 1 ) return dp [ i , j , k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = Math . Max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . Max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . Max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i , j , k ] = ans ; return dp [ i , j , k ] ; } static void reverse ( int [ ] tmp ) { int i , t ; int n = tmp . Length ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = tmp [ i ] ; tmp [ i ] = tmp [ n - i - 1 ] ; tmp [ n - i - 1 ] = t ; } } static int maxProductSum ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 ) { for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxN ; j ++ ) for ( int k = 0 ; k < maxN ; k ++ ) dp [ i , j , k ] = - 1 ; Array . Sort ( arr1 ) ; reverse ( arr1 ) ; Array . Sort ( arr2 ) ; reverse ( arr2 ) ; Array . Sort ( arr3 ) ; reverse ( arr3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; } public static void Main ( string [ ] args ) { n1 = 2 ; int [ ] arr1 = { 3 , 5 } ; n2 = 2 ; int [ ] arr2 = { 2 , 1 } ; n3 = 3 ; int [ ] arr3 = { 4 , 3 , 5 } ; Console . Write ( maxProductSum ( arr1 , arr2 , arr3 ) ) ; } }"}
{"text": "Triplet leksikografi terbesar dari array yang diberikan yang membentuk segitiga | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari triplet terbesar secara leksikografi yang membentuk segitiga dalam array yang diberikan; Susun array; Berulang dari akhir array; Jika triplet membentuk segitiga; Jika triplet dijumpai; Cetak triplet; Jika tidak; Kod pemacu", "code": "using System ; class GFG { static void findTriplet ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag != 0 ) { Console . Write ( arr [ i - 2 ] + \" ▁ \" + arr [ i - 1 ] + \" ▁ \" + arr [ i ] ) ; } else { Console . Write ( - 1 ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 4 , 2 , 10 , 3 , 5 } ; int N = arr . Length ; findTriplet ( arr , N ) ; } }"}
{"text": "Kira semua pasangan dalam array dengan perbezaan mutlak minimum | C # Program untuk pendekatan di atas; Berfungsi untuk mengembalikan kiraan semua pasangan yang mempunyai perbezaan mutlak yang minimum; Menyimpan kiraan pasangan; Susun array; Menyimpan perbezaan minimum antara pasangan bersebelahan; Mengemas kini perbezaan minimum antara pasangan; Meningkatkan kiraan pasangan dengan perbezaan yang sama dengan perbezaan minimum; Mengembalikan kiraan akhir; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "using System ; class GFG { static int numberofpairs ( int [ ] arr , int N ) { int answer = 0 ; Array . Sort ( arr ) ; int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . Min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 2 , 1 , 3 } ; int N = arr . Length ; Console . Write ( numberofpairs ( arr , N ) ) ; } }"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan menggunakan backtracking | C # Program untuk melaksanakan pendekatan di atas; Permulaan maksimum kemungkinan panjang berikutnya; Simpan elemen untuk membandingkan max_length dengan saiznya dan tukar nilai max_length dengan sewajarnya; Simpan unsur -unsur yang paling lama; Berfungsi untuk mencari panjang berikutnya terpanjang; Kemas kini max_length; Simpan unsur -unsur berikutnya; Secara rekursif meneruskan dengan jumlah yang diperoleh; unsur -unsur yang muncul dari belakang kedai vektor; Jika jumlah> 0 maka kita tidak memerlukannya sehingga kembali dan teruskan dengan unsur -unsur terdahulu; Susun array yang diberikan; Melintasi array; Jika max_length sudah lebih besar daripada atau sama daripada panjang yang tinggal; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int max_length = 0 ; static List < int > store = new List < int > ( ) ; static List < int > ans = new List < int > ( ) ; static void find_max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . Add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . Count ) { max_length = store . Count ; ans = store ; } } for ( int i = index + 1 ; i < arr . Length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . RemoveAt ( store . Count - 1 ) ; } else return ; } return ; } static int longestSubsequence ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . Clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; } public static void Main ( String [ ] args ) { int [ ] arr = { - 3 , 0 , 1 , 1 , 2 } ; int n = arr . Length ; int k = 1 ; Console . Write ( longestSubsequence ( arr , n , k ) ) ; } }"}
{"text": "Susun Pengurangan Permutasi N Menggunakan Swap Triple | C # Pelaksanaan untuk menyusun penurunan permutasi N menggunakan swap tiga; Fungsi untuk menyusun array; Tiga indeks yang perlu dipilih; Semak jika boleh menyusun array; Bertukar untuk membawa elemen pada kedudukan yang diperlukan membawa sekurang -kurangnya satu elemen pada kedudukan yang betul; Mengesan perubahan dalam array; Cetak array yang disusun; Jika tidak mungkin untuk menyusun; Kod pemacu", "code": "using System ; class GFG { static void sortArray ( int [ ] A , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } Console . Write ( \" Sorted ▁ Array : ▁ \" ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( A [ i ] + \" ▁ \" ) ; } else { Console . Write ( \" - 1\" ) ; } } public static void Main ( String [ ] args ) { int [ ] A = { 5 , 4 , 3 , 2 , 1 } ; int N = A . Length ; sortArray ( A , N ) ; } }"}
{"text": "Cari k sedemikian rupa sehingga mengubah semua elemen array yang lebih besar daripada k ke k akan membuat jumlah array n | C # pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan k sedemikian rupa sehingga mengubah semua elemen yang lebih besar daripada k ke k akan membuat jumlah array n sebaliknya kembali - 1; Menyusun array dalam peningkatan urutan; Gelung melalui semua elemen array; Memeriksa jika jumlah array sama dengan n; Kod pemacu", "code": "using System ; class GFG { static int findK ( int [ ] arr , int size , int N ) { Array . Sort ( arr ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; } public static void Main ( ) { int [ ] arr = { 3 , 1 , 10 , 4 , 8 } ; int size = arr . Length ; int N = 16 ; Console . Write ( findK ( arr , size , N ) ) ; } }"}
{"text": "Cari tiga elemen dari tiga array yang diberikan supaya jumlah mereka adalah x | Tetapkan 2 | C # pelaksanaan pendekatan; Fungsi yang kembali benar jika terdapat triplet dengan jumlah x; Menyusun susunan sedemikian rupa sehingga [] mewakili array terkecil; Mengalihkan array terkecil; Dua petunjuk pada array kedua dan ketiga; Jika triplet yang sah dijumpai;  ; Kod pemacu", "code": "using System ; class GFG { static bool existsTriplet ( int [ ] a , int [ ] b , int [ ] c , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 && l2 <= l3 ) { swap ( l2 , l1 ) ; swap ( a , b ) ; } else if ( l3 <= l1 && l3 <= l2 ) { swap ( l3 , l1 ) ; swap ( a , c ) ; } for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } private static void swap ( int x , int y ) { int temp = x ; x = y ; y = temp ; } private static void swap ( int [ ] x , int [ ] y ) { int [ ] temp = x ; x = y ; y = temp ; } public static void Main ( String [ ] args ) { int [ ] a = { 2 , 7 , 8 , 10 , 15 } ; int [ ] b = { 1 , 6 , 7 , 8 } ; int [ ] c = { 4 , 5 , 5 } ; int l1 = a . Length ; int l2 = b . Length ; int l3 = c . Length ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Susun nombor yang diberikan untuk membentuk nombor terkecil | C # pelaksanaan untuk pendekatan di atas; Fungsi utiliti untuk mencetak kandungan array; Fungsi perbandingan yang kembali negatif jika 'ab' lebih kecil daripada 'ba' apabila kita menggabungkan dua nombor 'A' dan 'B' sebagai contoh, ia akan mengembalikan nilai negatif jika kita lulus 12 dan 24 sebagai argumen. Fungsi ini akan digunakan semasa jenis; Tukar nombor pertama ke format rentetan; Tukar nombor kedua ke format rentetan; Semak jika 'ab' lebih kecil atau 'ba' dan pulangkan nilai integer; Berfungsi untuk mencetak susunan dengan nilai terkecil; Susun menggunakan fungsi Bandingkan yang ditakrifkan di atas; Cetak array yang disusun; Kod pemacu", "code": "using System ; class GFG { public static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] ) ; } public static int compare ( int num1 , int num2 ) { String A = num1 . ToString ( ) ; String B = num2 . ToString ( ) ; return ( A + B ) . CompareTo ( B + A ) ; } public static void printSmallest ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } printArr ( arr , N ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 2 , 9 , 21 , 1 } ; int N = arr . Length ; printSmallest ( N , arr ) ; } }"}
{"text": "Stabil Pemilihan Susun | C # Program untuk mengubah suai pilihan pemilihan supaya ia menjadi stabil. ; Melangkah melalui elemen array; Cari elemen minimum dari arr [i] ke arr [n - 1]. ; Gerakkan elemen minimum pada semasa i. ; Kod pemacu", "code": "using System ; class GFG { static void stableSelectionSort ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + \" ▁ \" ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] a = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = a . Length ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; } }"}
{"text": "Permut dua tatasusunan sedemikian rupa sehingga jumlah setiap pasangan lebih besar atau sama dengan k | C # Program untuk memeriksa sama ada permutasi dua tatasusunan memenuhi syarat [i] + b [i]> = k. ; Semak sama ada apa -apa permutasi wujud yang memenuhi syarat. ; Susun array a [] dalam urutan yang berkurangan. ; Susun array B [] dalam peningkatan urutan. ; Memeriksa keadaan pada setiap indeks. ; Kod pemacu", "code": "using System ; class GFG { static bool isPossible ( int [ ] a , int [ ] b , int n , int k ) { Array . Sort ( a ) ; Array . Reverse ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } public static void Main ( ) { int [ ] a = { 2 , 1 , 3 } ; int [ ] b = { 7 , 8 , 9 } ; int k = 10 ; int n = a . Length ; if ( isPossible ( a , b , n , k ) ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Sort Array mengikut kiraan bit set | C # Program untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; Fungsi untuk mengira setbit; Fungsi untuk disusun oleh SetBitCount; Melangkah ke atas semua nilai dan masukkan ke dalam multimap; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { static int setBitCount ( int num ) { int count = 0 ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) count ++ ; num >>= 1 ; } return count ; } static void sortBySetBitCount ( int [ ] arr , int n ) { List < Tuple < int , int > > count = new List < Tuple < int , int > > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { count . Add ( new Tuple < int , int > ( ( - 1 ) * setBitCount ( arr [ i ] ) , arr [ i ] ) ) ; } count . Sort ( ) ; foreach ( Tuple < int , int > i in count ) { Console . Write ( i . Item2 + \" ▁ \" ) ; } Console . WriteLine ( ) ; } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . Length ; sortBySetBitCount ( arr , n ) ; } }"}
{"text": "Semak jika akhir rentetan binari yang diberikan dapat dicapai dengan memilih nilai lompat di antara julat yang diberikan | C # Program untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mencapai hujung rentetan binari menggunakan lompatan yang diberikan; Menyimpan negeri -negeri DP; Keadaan awal; Kedai -kedai mengira indeks dari mana ia mungkin untuk mencapai Indeks I; Melintasi rentetan yang diberikan; Mengemas kini nilai pra dengan sewajarnya; Jika saiz lompat keluar dari julat [l, r]; Jawapan kembali; Kod pemacu", "code": "using System ; public class GFG { static int canReach ( String s , int L , int R ) { int [ ] dp = new int [ s . Length ] ; dp [ 0 ] = 1 ; int pre = 0 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } if ( pre > 0 && s [ i ] == '0' ) dp [ i ] = 1 ; else dp [ i ] = 0 ; } return dp [ s . Length - 1 ] ; } public static void Main ( ) { String S = \"01101110\" ; int L = 2 , R = 3 ; if ( canReach ( S , L , R ) == 1 ) Console . WriteLine ( \" Yes \" ) ; else Console . WriteLine ( \" No \" ) ; } }"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | C # Program untuk pendekatan di atas; Fungsi rekursif untuk mencari semua kemungkinan pemecahan array ke subarrays dan cari maksimum bitwise XOR; Jika nilai n ialah 0; Menyimpan hasil jika kumpulan baru dibentuk dengan elemen pertama sebagai arr [i]; Kedai jika keputusan jika ARR [i] dimasukkan ke dalam kumpulan terakhir; Mengembalikan maksimum x dan y; Berfungsi untuk mencari maksimum bitwise xor dari semua nilai yang mungkin dari array selepas memecahkan tatasusunan ke subarrays; Mengembalikan hasilnya; Kod pemacu", "code": "using System ; class GFG { static int maxXORUtil ( int [ ] arr , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return Math . Max ( x , y ) ; } static int maximumXOR ( int [ ] arr , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; } static void Main ( ) { int [ ] arr = { 1 , 5 , 7 } ; int N = arr . Length ; Console . Write ( maximumXOR ( arr , N ) ) ; } }"}
{"text": "Bina N | C # Program untuk melaksanakan pendekatan di atas; Menjejaki nod yang dikunjungi; Berfungsi untuk membina pokok supaya tidak ada dua nod bersebelahan dengan berat yang sama; Jika elemen minimum dan maksimum adalah sama, i. e. Array mengandungi satu elemen yang berbeza; Pokok tidak boleh dibina; Jika tidak; Pokok boleh dibina; Pilih berat [0] sebagai akar; Node pertama dikunjungi; Melintasi array; Jika tidak, buat kelebihan; Tandakan nod ini seperti yang dikunjungi; Cari berat badan yang tidak sama dengan root & membuat tepi dengan nod itu; Sertai bukan akar dengan nod yang tinggal; Semak jika nod semasa berat ~ sama dengan berat badan dan jika ia tidak dikunjungi atau tidak; Kod pemacu; Panggilan fungsi", "code": "using System ; using System . Linq ; class GFG { static int N = 100000 + 5 ; static int [ ] visited = new int [ N ] ; static void construct_tree ( int [ ] weights , int n ) { int minimum = weights . Min ( ) ; int maximum = weights . Max ( ) ; if ( minimum == maximum ) { Console . WriteLine ( \" No \" ) ; return ; } else { Console . WriteLine ( \" Yes \" ) ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { Console . WriteLine ( 1 + \" ▁ \" + ( i + 1 ) + \" ▁ \" ) ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { Console . WriteLine ( notroot + \" ▁ \" + ( i + 1 ) ) ; visited [ i + 1 ] = 1 ; } } } public static void Main ( ) { int [ ] weights = { 1 , 2 , 1 , 2 , 5 } ; int N = weights . Length ; construct_tree ( weights , N ) ; } }"}
{"text": "Kurangkan kos untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | C # Program untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk menukar rentetan yang diberikan ke dalam rentetan panjang K substring yang sama; Kedai panjang rentetan; Menyimpan kos minimum; Melintasi substring kiri panjang K; Menyimpan kekerapan; Kedai kos minimum untuk urutan indeks S [i] % K; Semak watak yang optimum; Cari jumlah jarak 'a' + ch dari indeks kara [i] % k; Pilih kos minimum untuk setiap indeks i; Kenaikan ans; Cetak kos minimum untuk menukar rentetan; Kod pemacu; Diberikan rentetan s; Panggilan fungsi", "code": "using System ; class GFG { static void minCost ( string s , int k ) { int n = s . Length ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int [ ] a = new int [ 26 ] ; for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - ' a ' ] ++ ; } int min_cost = Int32 . MaxValue ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += Math . Abs ( ch - tr ) * a [ tr ] ; min_cost = Math . Min ( min_cost , cost ) ; } ans += min_cost ; } Console . WriteLine ( ans ) ; } public static void Main ( ) { string S = \" abcdefabc \" ; int K = 3 ; minCost ( S , K ) ; } }"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | C # Program untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Kod pemacu", "code": "using System ; class GFG { static int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } public static void Main ( String [ ] args ) { int N = 6 ; Console . WriteLine ( minAbsDiff ( N ) ) ; } }"}
{"text": "Cari padanan maksimum dalam pokok binari yang diberikan | C # Program untuk pendekatan di atas; Senarai Adjacency untuk menyimpan tepi; Tambah kelebihan antara u dan v dalam pokok; Kelebihan dari u ke v; Tepi dari v ke u; Fungsi yang mendapati pemadanan maksimum DFS; Pergi lebih jauh kerana kami tidak dibenarkan pergi ke arah ibu bapanya; Jika u dan ibu induknya tidak diambil maka kita mesti mengambil & menandakannya sebagai diambil; Saiz kenaikan set tepi; Berfungsi untuk mencari padanan maksimum dalam graf; Mengambil 1 sebagai akar pokok; Cetak padanan maksimum; Kod pemacu; Menyertai kelebihan antara dua nod dalam pokok; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static readonly int N = 10000 ; static List < int > [ ] adj = new List < int > [ N ] ; static int [ ] used = new int [ N ] ; static int max_matching ; static void AddEdge ( int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; } static void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . Count ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } } static void maxMatching ( ) { Matching_dfs ( 1 , 0 ) ; Console . Write ( max_matching + \" STRNEWLINE \" ) ; } public static void Main ( String [ ] args ) { for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; maxMatching ( ) ; } }"}
{"text": "Kurangkan kos untuk menukar dua tatasusunan yang diberikan | C # Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan kos minimum yang diperlukan untuk menukar dua tatasusunan; Mengembalikan jumlah kos minimum; Kod pemacu", "code": "using System ; class GFG { static int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . Min ( mini , Math . Min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } public static void Main ( String [ ] args ) { int N = 3 ; int [ ] A = { 1 , 4 , 2 } ; int [ ] B = { 10 , 6 , 12 } ; Console . Write ( getMinCost ( A , B , N ) ) ; } }"}
{"text": "Cetak semua cara yang mungkin untuk menulis n sebagai jumlah dua atau lebih integer positif | C # Program untuk pendekatan di atas; Berfungsi untuk mencetak nilai yang disimpan dalam arr vektor; Melintasi arr vektor; Fungsi rekursif untuk mencetak cara yang berbeza di mana n boleh ditulis sebagai jumlah pada 2 atau lebih bilangan bulat positif; Jika n adalah sifar maka cetak cara ini memecahkan nombor; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack untuk mengeluarkan elemen semasa dari perwakilan; Kod pemacu; Diberikan jumlah n; Untuk menyimpan perwakilan melanggar N; Panggilan fungsi", "code": "using System ; using System . Collections . Generic ; class GFG { static void printList ( List < int > arr ) { if ( arr . Count != 1 ) { for ( int i = 0 ; i < arr . Count ; i ++ ) { Console . Write ( arr [ i ] + \" ▁ \" ) ; } Console . WriteLine ( ) ; } } static void findWays ( List < int > arr , int i , int n ) { if ( n == 0 ) printList ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . Add ( j ) ; findWays ( arr , j , n - j ) ; arr . RemoveAt ( arr . Count - 1 ) ; } } public static void Main ( String [ ] args ) { int n = 4 ; List < int > arr = new List < int > ( ) ; findWays ( arr , 1 , n ) ; } }"}
{"text": "Memaksimumkan kiraan penurunan berikutnya dari array yang diberikan | C # Program untuk menyusun semula array untuk menghasilkan pengurangan maksimum; Berfungsi untuk mengira berikutnya maksimum; Menyimpan kekerapan elemen array; Kedai kekerapan maksimum; Kemas kini kekerapan [i]; Mengemas kini berikutnya maksimum; Cetak hasilnya; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static void Maximum_subsequence ( int [ ] A , int N ) { Dictionary < int , int > frequency = new Dictionary < int , int > ( ) ; int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( frequency . ContainsKey ( A [ i ] ) ) { frequency [ A [ i ] ] = frequency [ A [ i ] ] + 1 ; } else { frequency . Add ( A [ i ] , 1 ) ; } } foreach ( KeyValuePair < int , int > it in frequency ) { if ( ( int ) it . Value > max_freq ) { max_freq = ( int ) it . Value ; } } Console . WriteLine ( max_freq ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = arr . Length ; Maximum_subsequence ( arr , N ) ; } }"}
{"text": "Semak jika rentetan boleh dibahagikan kepada dua rentetan dengan bilangan k | yang sama C # Program untuk masalah di atas; Berfungsi untuk mencetak susunan aksara; Kedai kekerapan aksara; Hitung watak yang mempunyai kekerapan k; Hitung watak yang mempunyai kekerapan lebih besar daripada k dan tidak sama dengan 2 k; Kes 1; Kes 2; Kes 3; Jika semua kes gagal; Kod pemacu", "code": "using System ; using System . Collections . Generic ; class GFG { public static void DivideString ( string s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ; int [ ] fr = new int [ 26 ] ; char [ ] ans = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { fr [ s [ i ] - ' a ' ] ++ ; } char ch = ' a ' , ch1 = ' a ' ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] == k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = ( char ) ( i + ' a ' ) ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = ( char ) ( i + ' a ' ) ; } } for ( i = 0 ; i < n ; i ++ ) ans [ i ] = '1' ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s [ i ] - ' a ' ] == k ) { if ( mp . ContainsKey ( s [ i ] ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp [ s [ i ] ] = 1 ; } } } } if ( ( c % 2 == 1 ) && ( c1 > 0 ) ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } } if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s [ i ] - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } Console . Write ( ans ) ; } else { Console . Write ( \" NO \" ) ; } } public static void Main ( string [ ] args ) { string S = \" abbbccc \" ; int N = S . Length ; int K = 1 ; DivideString ( S , N , K ) ; } }"}
{"text": "Semak jika dua item boleh dipilih dari dua kategori yang berbeza tanpa harga yang melebihi | C # Pelaksanaan untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Fungsi untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Gelung untuk memilih dua pasangan yang berbeza menggunakan dua gelung bersarang; Keadaan untuk memeriksa sama ada harga kedua -dua elemen ini kurang daripada S; Kod pemacu; Panggilan fungsi", "code": "using System ; class GFG { static String check ( int S , int [ ] prices , int [ ] type , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return \" Yes \" ; } } } } return \" No \" ; } public static void Main ( String [ ] args ) { int [ ] prices = { 3 , 8 , 6 , 5 } ; int [ ] type = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ; Console . Write ( check ( S , prices , type , n ) ) ; } }"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | C # pelaksanaan untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah yang membahagikan harta produk; Untuk mencari faktor terbesar k; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "using System ; class GFG { static int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . Max ( max_sum , a + b ) ; } } return max_sum ; } static public void Main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; Console . Write ( max_sum + \" STRNEWLINE \" ) ; } }"}
{"text": "Menyulitkan rentetan dengan mengulangi i | C # pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disulitkan; Bilangan kali watak semasa akan diulang; Ulangi watak semasa dalam rentetan yang disulitkan; Kod pemacu", "code": "using System ; class GFG { static String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = \" \" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; } static public void Main ( ) { String str = \" geeks \" ; int n = str . Length ; Console . WriteLine ( encryptString ( str , n ) ) ; } }"}
{"text": "Kurangkan perbezaan antara nilai maksimum dan minimum array yang diubah suai | C # Program untuk mencari perbezaan minimum. ; Fungsi untuk mengembalikan perbezaan minimum yang diperlukan; mencari nilai minimum dan maksimum; mengembalikan perbezaan minimum yang mungkin; Program pemacu; berfungsi untuk mengembalikan jawapannya", "code": "using System ; class GFG { static int minDiff ( int n , int x , int [ ] A ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . Min ( mn , A [ i ] ) ; mx = Math . Max ( mx , A [ i ] ) ; } return Math . Max ( 0 , mx - mn - 2 * x ) ; } public static void Main ( ) { int n = 3 , x = 3 ; int [ ] A = { 1 , 3 , 6 } ; Console . WriteLine ( minDiff ( n , x , A ) ) ; } }"}
{"text": "Swap minimum untuk mengimbangi pendakap | C # Program untuk mengira swap yang diperlukan untuk mengimbangi rentetan; menyimpan jumlah kurungan kiri dan kanan yang dihadapi; Swap menyimpan bilangan swap yang diperlukan ketidakseimbangan mengekalkan bilangan pasangan ketidakseimbangan; kiraan kenaikan kurungan kiri; kiraan swap adalah kiraan swap terakhir + jumlah kurungan tidak seimbang; ketidakseimbangan yang diturunkan oleh 1 kerana ia hanya menyelesaikan satu ketidakseimbangan kiri dan kanan; kiraan kenaikan kurungan kanan; Ketidakseimbangan diset semula kepada perbezaan semasa antara kurungan kiri dan kanan; Kod pemacu", "code": "using System ; class GFG { public static long swapCount ( string s ) { char [ ] chars = s . ToCharArray ( ) ; int countLeft = 0 , countRight = 0 ; int swap = 0 , imbalance = 0 ; for ( int i = 0 ; i < chars . Length ; i ++ ) { if ( chars [ i ] == ' [ ' ) { countLeft ++ ; if ( imbalance > 0 ) { swap += imbalance ; imbalance -- ; } } else if ( chars [ i ] == ' ] ' ) { countRight ++ ; imbalance = ( countRight - countLeft ) ; } } return swap ; } public static void Main ( string [ ] args ) { string s = \" [ ] ] [ ] [ \" ; Console . WriteLine ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; Console . WriteLine ( swapCount ( s ) ) ; } }"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | C # Program untuk pendekatan di atas; Fungsi untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; dp [i]: Menyimpan selanjutnya yang terpanjang sehingga i; Kes asas; Apabila keadaan memegang; Akhirnya, cetak jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "using System ; class GFG { static void longestSubSequence ( int [ , ] A , int N ) { int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j , 0 ] < A [ i , 0 ] && A [ j , 1 ] > A [ i , 1 ] ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ j ] + 1 ) ; } } } Console . Write ( dp [ N - 1 ] ) ; } static void Main ( ) { int [ , ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . GetLength ( 0 ) ; longestSubSequence ( A , N ) ; } }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | C # Program untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Kes asas; Kembali hasil yang telah disimpan; Berulang untuk semua 6 negeri; Mengembalikan hasilnya; Kod pemacu; Diberikan jumlah n; Memulakan array DP; Panggilan fungsi", "code": "using System ; class GFG { static int findWays ( int N , int [ ] dp ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } public static void Main ( String [ ] args ) { int N = 4 ; int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < dp . Length ; i ++ ) dp [ i ] = - 1 ; Console . Write ( findWays ( N , dp ) ) ; } }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | C # Program untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Memulakan array DP; Melangkah ke atas semua nilai perantaraan yang mungkin untuk mencapai n; Kirakan jumlah untuk semua 6 muka; Cetak jumlah cara; Kod pemacu; Diberikan jumlah n; Panggilan fungsi", "code": "using System ; class GFG { static void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } Console . Write ( dp [ N ] ) ; } public static void Main ( String [ ] args ) { int N = 4 ; findWays ( N ) ; } }"}
{"text": "Pecahkan rentetan ke bahagian minimum supaya setiap bahagian berada dalam rentetan lain | C # pelaksanaan untuk memecah rentetan ke dalam bilangan minimum bahagian supaya setiap bahagian juga terdapat dalam rentetan lain; Nod trie; Berfungsi untuk memasukkan nod dalam struktur data trie; Memasukkan setiap watak dari IDX hingga hujung ke rentetan ke dalam trie; Sekiranya tidak ada kelebihan yang sepadan dengan watak ITH, maka buat nod baru; Berfungsi untuk mencari bilangan minimum bahagian supaya setiap bahagian hadir ke dalam rentetan lain; Membuat trie baru; Memasukkan setiap substring S2 di Trie; Mewujudkan array DP dan init dengan tak terhingga; Kes asas; Memulakan pemotongan dari watak yang mengambil penunjuk nod sementara untuk memeriksa sama ada substring [i, j) hadir dalam trie tidak; Sekiranya watak JTH tidak berada di Trie, kami akan berehat; Mengemas kini berakhirnya watak jth dengan dp [i] + 1; Menurunkan penunjuk Trie; Jawapan tidak mungkin; Kod pemacu", "code": "using System ; class GFG { static int INF = ( int ) ( 1e9 + 9 ) ; class TrieNode { public TrieNode [ ] child = new TrieNode [ 26 ] ; } ; static void insert ( int idx , String s , TrieNode root ) { TrieNode temp = root ; for ( int i = idx ; i < s . Length ; i ++ ) { if ( temp . child [ s [ i ] - ' a ' ] == null ) temp . child [ s [ i ] - ' a ' ] = new TrieNode ( ) ; temp = temp . child [ s [ i ] - ' a ' ] ; } } static int minCuts ( String S1 , String S2 ) { int n1 = S1 . Length ; int n2 = S2 . Length ; TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } int [ ] dp = new int [ n1 + 1 ] ; for ( int i = 0 ; i <= n1 ; i ++ ) dp [ i ] = INF ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 [ j - 1 ] - ' a ' ] == null ) break ; dp [ j ] = Math . Min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp . child [ S1 [ j - 1 ] - ' a ' ] ; } } if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; } public static void Main ( String [ ] args ) { String S1 = \" abcdab \" ; String S2 = \" dabc \" ; Console . Write ( minCuts ( S1 , S2 ) ) ; } }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C # pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputation of Prefix CountDP Jumlah matriks; Gelung untuk menyelesaikan setiap pertanyaan; Carian binari ke sisi yang mempunyai atmost dalam k 1 's di persegi; Kira jumlah 1 s dalam sub persegi yang dipertimbangkan; Jika kiraan kurang daripada atau sama dengan langkah maksimum ke separuh kanan; Kod pemacu", "code": "using System . Collections . Generic ; using System ; class GFG { static void largestSquare ( int [ , ] matrix , int R , int C , int [ ] q_i , int [ ] q_j , int K , int Q ) { int [ , ] countDP = new int [ R , C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i , j ] = 0 ; countDP [ 0 , 0 ] = matrix [ 0 , 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i , 0 ] = countDP [ i - 1 , 0 ] + matrix [ i , 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 , j ] = countDP [ 0 , j - 1 ] + matrix [ 0 , j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i , j ] = matrix [ i , j ] + countDP [ i - 1 , j ] + countDP [ i , j - 1 ] - countDP [ i - 1 , j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . Min ( Math . Min ( i , j ) , Math . Min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 , y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 , y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 , y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 , y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } Console . WriteLine ( ans ) ; } } public static void Main ( ) { int [ , ] matrix = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int [ ] q_i = { 1 } ; int [ ] q_j = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }"}
