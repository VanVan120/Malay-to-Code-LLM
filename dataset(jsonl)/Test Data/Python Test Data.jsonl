{"text": "Jumlah minimum mungkin dengan mengeluarkan semua kejadian mana -mana elemen array | Berfungsi untuk mencari jumlah minimum selepas penghapusan; Kedai kekerapan elemen array; Melintasi array; Hitung jumlah; Kekerapan kemas kini elemen semasa; Menyimpan jumlah minimum yang diperlukan; Peta Traverse; Cari jumlah minimum yang diperoleh; Kembali jumlah minimum; Arahan input; Saiz array", "code": "def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( ' inf ' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Melintasi array; Menyimpan perbezaan maksimum; Semak elemen bersebelahan maksimum; Tidak termasuk elemen semasa; perbezaan maksimum pdate; Mengemas kini nilai sebelumnya; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE maxi = - 1 * float ( ' inf ' ) NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE prev = arr [ j ] NEW_LINE DEDENT res . append ( maxi ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE"}
{"text": "Kira 1 S hadir dalam pelbagai indeks [l, r] dalam array yang diberikan | Berfungsi untuk mencari saiz array jika array pada mulanya mengandungi elemen tunggal; Kes asas; P / 2 -> findSize (n 2) p % 2 -> 1 p / 2 -> findSize (n / 2); Berfungsi untuk mengembalikan kiraan 1 s dalam julat [l, r]; Kes asas; Bahagian 1 -> n / 2 [1, siz_m]; Kemas kini titik akhir kanan julat ke min (Siz_m, r); Bahagian 2 -> n % 2 [Sizm + 1, Siz_m + 1]; Bahagian 3 -> n / 2 [Sizm + 2, 2 * Siz_m - 1] Sama seperti Bahagian 1 harta simetrik beralih koordinat mengikut bahagian 1 tolak (siz_m + 1) dari kedua -dua l, r; Kod pemacu; Input; Mengira bilangan 1 dalam julat [l, r]", "code": "def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( CountOnes ( N , L , R ) ) NEW_LINE DEDENT"}
{"text": "Cari pasangan (a, b) dengan LCM minimum supaya jumlahnya sama dengan n | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kerana 1 bukan pulangan utama atau komposit palsu; Semak jika ia dibahagikan dengan mana -mana nombor maka ia bukan perdana, kembali palsu; Semak jika n tidak dibahagikan dengan mana -mana nombor maka ia adalah perdana dan oleh itu kembali benar; Fungsi untuk mencari pasangan (a, b) seperti jumlah yang N & LCM adalah minimum; Semak sama ada nombor itu adalah perdana; Sekarang, jika tidak perdana maka cari yang paling kurang divisior; Semak jika membahagikan n maka ia adalah faktor; Output yang diperlukan ialah A = N / I & B = N / I * (n - 1); Kod pemacu; Panggilan fungsi", "code": "def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 4 NEW_LINE minDivisior ( N ) NEW_LINE"}
{"text": "Cari fungsi Landau untuk nombor tertentu n | Program Python3 untuk pendekatan di atas; Untuk menyimpan fungsi Landau nombor; Berfungsi untuk mengembalikan GCD sebanyak 2 nombor; Berfungsi untuk mengembalikan LCM dua nombor; Fungsi untuk mencari nilai lcm max di antara semua perwakilan n; Hitung nilai Landau; Fungsi rekursif untuk mencari cara yang berbeza di mana n boleh ditulis sebagai jumlah atleast satu bilangan bulat positif; Semak jika jumlah menjadi n, pertimbangkan perwakilan ini; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack - Keluarkan elemen semasa dari perwakilan; Berfungsi untuk mencari fungsi Landau; Menggunakan kambuhan mencari cara yang berbeza di mana n boleh ditulis sebagai sejumlah atleast satu + ve integer; Cetak hasilnya; Diberikan n; Panggilan fungsi", "code": "import sys NEW_LINE Landau = - sys . maxsize - 1 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT N = 4 NEW_LINE Landau_function ( N ) NEW_LINE"}
{"text": "Semak jika baki N | Fungsi untuk memeriksa sama ada nombor memegang syarat (n - 1)! % N = n - 1; Kes sudut; Nombor yang boleh dibahagikan dengan 2 atau 3 bukanlah perdana; Melangkah dari 5 dan terus memeriksa perdana; Fungsi untuk memeriksa ungkapan untuk nilai n; Kod pemacu", "code": "def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE DEDENT def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT"}
{"text": "Semak sama ada mungkin untuk memecah array yang diberikan ke dalam K Odd | Fungsi untuk memeriksa sama ada array boleh dibahagikan dalam subset k yang diperlukan; Menyimpan kiraan nombor ganjil; Semak jika elemen ganjil; Semak jika perpecahan mungkin; Kod pemacu", "code": "def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Jumlah pembahagian pasangan yang mungkin untuk array yang diberikan | Program Python3 untuk mengira jumlah pembahagian semua pasangan yang mungkin untuk array yang diberikan; Berfungsi untuk mengira jumlah; Mengira kekerapan setiap istilah dan mencari maksimum di antara ia; Membuat kekerapan kumulatif; Mengambil nilai Ceil; nos. Dalam julat [(n - 0.5) x, (n + 0.5) x) akan menambah n ke ANS; Mengembalikan hasil akhir; Kod pemacu", "code": "from math import * NEW_LINE def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Count of Elements hendaklah dimasukkan untuk membuat array Jumlah dua kali xor array | Fungsi untuk mencari bilangan elemen minimum yang perlu dimasukkan supaya jumlah unsur -unsur array adalah dua kali ganda XOR array; Pembolehubah untuk menyimpan XOR semua elemen; Pembolehubah untuk menyimpan jumlah semua elemen; Gelung untuk mencari XOR dan jumlah array; Jika jumlah = 2 * xor; Tidak perlu memasukkan lebih banyak elemen; Kami memasukkan satu lagi elemen yang jumlahnya; Kami memasukkan dua lagi elemen SUM + XOR dan XOR. ; Cetak bilangan elemen yang dimasukkan dalam array; Cetak unsur -unsur yang dimasukkan dalam array; Kod pemacu", "code": "def insert_element ( a , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE print ( 2 ) NEW_LINE print ( num1 , num2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT"}
{"text": "Periksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak | Berfungsi untuk memeriksa sama ada akar persamaan kuadratik adalah timbal balik antara satu sama lain atau tidak; Kod pemacu", "code": "def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE"}
{"text": "Nombor Sunny | Program Python3 untuk pendekatan di atas; Periksa fungsi sama ada x adalah persegi yang sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Berfungsi untuk memeriksa nombor cerah; Semak jika (n + 1) adalah persegi yang sempurna atau tidak; Jika (n + 1) bukan persegi yang sempurna; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE checkSunnyNumber ( N ) NEW_LINE DEDENT"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Melangkah melalui semua bilangan bulat; Semak jika n boleh ditukar kepada 1; Meningkatkan kiraan jika ia boleh ditukar; Kod pemacu", "code": "def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT"}
{"text": "Cari nombor k dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan | Fungsi yang mencetak nombor k yang diperlukan; Cetak 1, k - 1 kali; Cetak (n - k + 1); Kod pemacu", "code": "def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT"}
{"text": "Cetak nth larian atau nombor autobiografi | Berfungsi untuk mencari nombor semula jadi yang melangkah; Mengisytiharkan barisan; Enqueue 1, 2, ..., 9 dalam perintah ini; Melakukan operasi k pada barisan; Dapatkan nombor langkah itu; Melakukan dequeue dari barisan; Jika x mod 10 tidak sama dengan 0; Kemudian enqueue 10 x + (x mod 10) - 1; Enqueue 10 x + (x mod 10); Jika x mod 10 tidak sama dengan 9; Kemudian enqueue 10 x + (x mod 10) + 1; Kembalikan jumlah operasi K - th sebagai nombor loncatan n; Kod pemacu; permulaan k", "code": "def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE DEDENT"}
{"text": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya persegi yang sempurna | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan persegi yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu", "code": "from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT"}
{"text": "Nilai pi (Î) sehingga 50 tempat perpuluhan | Program Python3 untuk mengira nilai Pi sehingga tempat perpuluhan; Fungsi yang mencetak nilai tempat perpuluhan Pi; Cari nilai PI sehingga menggunakan fungsi ACOS (); Cetak nilai Pi sehingga tempat perpuluhan; Kod pemacu; Fungsi yang mencetak nilai pi", "code": "from math import acos NEW_LINE def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 43 ; NEW_LINE printValueOfPi ( N ) ; NEW_LINE DEDENT"}
{"text": "Balikkan kth yang paling penting n | Pelaksanaan Python pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array binari arr [] setara perpuluhannya; Berfungsi untuk menggabungkan nombor binari dan mengembalikan hasil perpuluhan; Bilangan bit dalam kedua -dua nombor; Tukar bit di kedua -dua gers ke array A [] dan B []; Bilangan bit dalam n adalah kurang daripada k; Flip bit kth; Mengembalikan setara perpuluhan nombor; Kod pemacu", "code": "import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE"}
{"text": "Pertanyaan untuk produk Factorial N First | Pelaksanaan Python3 pendekatan; Mengisytiharkan hasil hasil di seluruh dunia; Berfungsi untuk precompute produk faktorial sehingga max; Inisialisasi keadaan asas jika n = 0 maka faktorial 0 adalah sama dengan 1 dan jawapan untuk n = 0 ialah 1; Gelung berulang dari 1 hingga max; faktorial (i) = factorial (i - 1) * i; Keputusan untuk n semasa adalah sama dengan hasil [i - 1] didarabkan oleh faktorial i; Berfungsi untuk melakukan pertanyaan; Precomputing hasil Timax; Melakukan pertanyaan; Kod pemacu", "code": "MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE"}
{"text": "Nombor nth dalam satu set gandaan a, b atau c | Program python3 untuk mencari istilah n yang boleh dibahagi oleh a, b atau c; Berfungsi untuk mengembalikan GCD A dan B; Fungsi untuk mengembalikan kiraan bilangan bulat dari julat [1, num] yang boleh dibahagikan dengan sama ada A, B atau C; Kirakan bilangan istilah yang boleh dibahagi dengan A, B dan C kemudian keluarkan istilah yang boleh dibahagikan dengan kedua -dua (a, b) atau (b, c) atau (c, a) dan kemudian tambah nombor yang boleh dibahagikan dengan a, b dan c; Fungsi untuk carian binari untuk mencari istilah n yang boleh dibahagikan dengan a, b atau c; Tetapkan rendah hingga 1 dan tinggi ke long_max; Jika istilah semasa kurang daripada n maka kita perlu meningkat rendah hingga pertengahan + 1; Jika istilah semasa lebih besar daripada sama dengan n maka tinggi = pertengahan; Kod pemacu", "code": "import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE"}
{"text": "Sudut antara 3 simpang yang diberikan dalam n | Fungsi yang memeriksa sama ada sudut yang diberikan boleh dibuat menggunakan mana -mana 3 sisi; Memulakan x dan y; Kirakan bilangan simpang antara i dan j, j dan k; Kirakan sudut yang diselaraskan di lilitan; Sudut yang diselaraskan di J boleh didapati menggunakan hakikat bahawa jumlah sudut segitiga adalah sama dengan 180 darjah; Kod pemacu", "code": "def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE"}
{"text": "Kerugian apabila dua item dijual pada harga yang sama dan keuntungan / kerugian peratusan yang sama | Fungsi yang akan mendapati kerugian; Kod pemacu; Fungsi panggilan", "code": "def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( \" Loss ▁ = \" , round ( loss , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT"}
{"text": "Semak elemen array iaitu CO | Pelaksanaan Python3 pendekatan; Menyimpan faktor utama terkecil untuk setiap nombor; Hash untuk menyimpan kiraan faktor utama; Berfungsi untuk mengira SPF (faktor kecil) untuk setiap nombor sehingga maxn; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; Menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; Menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Berfungsi untuk menyimpan faktor utama selepas membahagikan faktor utama terkecil di setiap langkah; Menyimpan kiraan faktor utama dalam hash; Fungsi yang mengembalikan benar jika tidak ada faktor utama yang sama antara x dan nombor array lain; Memeriksa sama ada faktor utama yang biasa dengan nombor lain; Fungsi yang mengembalikan benar jika terdapat elemen dalam array yang coprime dengan semua elemen lain dari array; Menggunakan ayak untuk menjana faktor utama; Memeriksa faktor utama biasa dengan nombor lain; Kod pemacu", "code": "MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cara untuk mengeluarkan tepi dari graf lengkap untuk membuat tepi ganjil | Berfungsi untuk mengembalikan bilangan cara untuk mengeluarkan tepi dari graf supaya bilangan tepi yang ganjil ditinggalkan dalam graf; Jumlah bilangan tepi; Kod pemacu", "code": "def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT"}
{"text": "Hitung NCR Menggunakan Segitiga Pascal | Memulakan matriks dengan 0; 0 C0 = 1; Tetapkan setiap NCR = 1 di mana r = 0; Nilai untuk sel semasa segitiga Pascal; Berfungsi untuk mengembalikan nilai NCR; Kembali NCR; Bina Segitiga Pascal", "code": "l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE"}
{"text": "Partition Jumlah Paling Berdekatan (ke dalam dua subset) nombor dari 1 hingga N | Berfungsi untuk mengembalikan perbezaan mutlak yang diperlukan minimum; Kod pemacu", "code": "def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT"}
{"text": "Semak sama ada xor kekerapan semua digit nombor n adalah sifar atau tidak | Pelaksanaan Python pendekatan di atas; mewujudkan pelbagai frekuensi; Mencari digit terakhir nombor; Membahagikan nombor dengan 10 untuk menghapuskan digit terakhir; kekerapan mengira setiap digit; Memeriksa jika XOR semua kekerapan adalah sifar atau tidak; Kod pemacu", "code": "def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cetak garis n 4 nombor supaya setiap pasangan di antara 4 nombor mempunyai gcd k | Berfungsi untuk mencetak garis N; Iterat n kali untuk mencetak garis n; Kod pemacu", "code": "def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT"}
{"text": "Jumlah pertama N Siri 3, 5, 9, 17, 33 ... | Program Python untuk mencari jumlah N Syarat Siri; Sn = n * (4 * n * n + 6 * n - 1) / 3; bilangan istilah untuk jumlah; Cari SN", "code": "def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( \" Sum ▁ = \" , calculateSum ( n ) ) NEW_LINE"}
{"text": "Kira bilangan rentetan khas panjang n | Program python3 untuk mengira bilangan rentetan khas panjang n; Berfungsi untuk mengembalikan kiraan rentetan khas; Menyimpan jawapan untuk nilai tertentu n; Untuk n = 0 kita mempunyai rentetan kosong; Untuk n = 1 kita mempunyai 2 rentetan khas; Hitung kiraan rentetan panjang panjang i; Fib [n] menyimpan kiraan rentetan khas panjang n; Kod pemacu; Permulaan n", "code": "mod = 1000000007 NEW_LINE def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE DEDENT"}
{"text": "Mengira laluan dalam array | Pelaksanaan Python3 pendekatan di atas; Cari bilangan cara untuk mencapai akhir; Kes asas; Struktur rekursif; Kod pemacu", "code": "mod = 1e9 + 7 ; NEW_LINE def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Mengira laluan dalam array | Python3 pelaksanaan pendekatan di atas; Cari bilangan cara untuk mencapai akhir; DP untuk menyimpan nilai; Kes asas; Bawah struktur DP; F [i] bergantung kepada F [i + 1] ke F [i + k]; Nilai pulangan DP [0]; Kod pemacu", "code": "mod = 10 ** 9 + 7 NEW_LINE def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | Mengembalikan kiraan ganjil dan bahkan seterusnya; Inisialisasi count_even dan count_odd hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan yang lebih baik atau ganjil. ; Cari jumlah semua berikutnya dengan mengira dan mengira ganjil dan menyimpannya semasa kami melangkah. ; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu; Memanggil fungsi", "code": "def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT DEDENT return ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum ▁ = ▁ \" , count_even , \" ▁ OddSum ▁ = ▁ \" , count_odd ) NEW_LINE"}
{"text": "Count integer panjang n dan nilai kurang daripada k sehingga ia mengandungi digit hanya dari set yang diberikan | Pelaksanaan Python3 pendekatan; Berfungsi untuk menukar nombor menjadi vektor; Tolak semua digit n dari akhir satu demi satu ke vektor; Jika nombor asalnya adalah 0; Membalikkan elemen vektor; Mengembalikan vektor yang diperlukan; Berfungsi untuk mengembalikan bilangan bilangan bulat panjang b yang kurang daripada c dan mereka mengandungi digit dari set a [] sahaja; Menukar nombor ke array digit; Kes 1: Tidak ada bilangan sedemikian mungkin kerana nombor yang dihasilkan akan selalu lebih besar daripada C; Kes 2: Semua bilangan bulat panjang B adalah sah kerana mereka semua kurang daripada C; mengandungi 0; Kes 3; Kemas kini array yang lebih rendah [seperti yang lebih rendah [i] menyimpan kiraan unsur -unsur dalam [] yang kurang daripada saya; Untuk indeks pertama kita tidak boleh menggunakan 0; Sama ada (i - 1) digit nombor yang dihasilkan boleh sama dengan (i - 1) digit C; Adakah digit [i - 1] hadir dalam A? ; Kod pemacu", "code": "MAX = 10 NEW_LINE def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE return digit NEW_LINE DEDENT def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( B < len ( digit ) ) : NEW_LINE INDENT if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE DEDENT return dp [ B ] NEW_LINE DEDENT DEDENT A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE"}
{"text": "Bilangan jalur berat w dalam k | Program Python 3 untuk mengira bilangan laluan dengan berat w dalam pokok k - ary; Berfungsi untuk mengembalikan bilangan cara yang mempunyai berat badan sebagai wt dalam pokok k - ary; Kembali 0 jika berat menjadi kurang daripada sifar; Kembali hanya jika laluan semasa telah memasukkan berat kelebihan mehaum m; Jika berat tepi semasa lebih besar daripada atau sama dengan m, set digunakan sebagai benar; Kod pemacu", "code": "import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT"}
{"text": "Cara Menulis N sebagai Jumlah Dua atau Lebih Integer Positif | Set | Berfungsi untuk mencari bilangan partition n; Kes asas; Kod pemacu", "code": "def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT"}
{"text": "Laluan Terpanjang dalam Matriks | Program Python3 untuk mencari jalan yang paling lama dalam matriks. ; Kembalikan panjang bibir dalam matriks 2D; Jika nilai belum dikira. ; Jika mencapai sel kiri bawah, kembali 1 .; Jika sampai ke sudut matriks. ; Jika nilai lebih besar daripada sel bawah. ; Jika nilai lebih besar daripada sel kiri. ; Fungsi pembalut; Kod pemacu", "code": "MAX = 20 NEW_LINE def LIP ( dp , mat , n , m , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE DEDENT return dp [ x ] [ y ] NEW_LINE DEDENT def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu", "code": "def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( \" ▁ Number ▁ of ▁ Paths ▁ \" , countPaths ( n , m ) ) NEW_LINE"}
{"text": "Masalah Tambang Emas | Program Python untuk menyelesaikan masalah lombong emas; Mengembalikan jumlah maksimum emas yang boleh dikumpulkan apabila perjalanan bermula dari lajur pertama dan bergerak yang dibenarkan adalah betul, kanan dan kanan - ke bawah; Buat jadual untuk menyimpan hasil pertengahan dan memulakan semua sel ke 0. Baris pertama Goldminetable memberikan emas maksimum yang dapat dikumpulkan oleh pelombong ketika memulakan baris itu; Emas yang dikumpulkan pergi ke sel di sebelah kanan ( ->); Emas yang dikumpulkan untuk pergi ke sel untuk ke atas ( /); Emas yang dikumpulkan untuk pergi ke sel ke kanan (\\); Max Gold yang dikumpulkan daripada mengambil salah satu daripada 3 laluan di atas; Jumlah maksimum emas yang dikumpulkan akan menjadi nilai maksimum dalam lajur pertama semua baris; Kod pemacu", "code": "MAX = 100 NEW_LINE def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE"}
{"text": "Cari Kos Pelarasan Minimum Array | Program Python3 untuk mencari kos pelarasan minimum array; Fungsi untuk mencari kos pelarasan minimum array; dp [i] [j] menyimpan kos pelarasan minimum untuk menukar [i] ke j; mengendalikan elemen pertama array secara berasingan; lakukan untuk elemen rehat array; Gantikan [i] ke J dan hitung kos pelarasan minimum DP [i] [J]; memulakan kos pelarasan minimum kepada int_max; Pertimbangkan semua k sedemikian rupa sehingga k> = max (j - sasaran, 0) dan k <= min (m, j + sasaran) dan ambil minimum; pulangan nilai minimum dari baris terakhir jadual DP; Kod pemacu", "code": "M = 100 NEW_LINE def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( \" Minimum ▁ adjustment ▁ cost ▁ is \" , minAdjustmentCost ( arr , n , target ) , sep = ' ▁ ' ) NEW_LINE"}
{"text": "Kira tiga kali ganda dari julat tertentu yang mempunyai jumlah dua nombor triplet yang sama dengan nombor ketiga | Berfungsi untuk mencari bilangan tiga kali ganda dari julat [l, r] yang mempunyai jumlah dua nombor dari triplet yang sama dengan nombor ketiga; Menyimpan jumlah tiga tiga; Cari perbezaan julat; Kes 1: Jika tiga kali boleh dibentuk, maka kembali 0; Jika tidak; Mengemas kini jumlah tiga kali ganda; Mengembalikan kiraan; Kod pemacu", "code": "def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT"}
{"text": "Bina Dua N | Berfungsi untuk menghasilkan dua susunan yang memenuhi syarat yang diberikan; Mengisytiharkan kedua -dua array A dan B; Berulang dari julat [1, 2 * n]; Berikan nombor berturut -turut kepada indeks yang sama dari kedua -dua tatasusunan; Cetak array pertama; Cetak array kedua, b; Kod pemacu; Panggilan fungsi", "code": "def printArrays ( n ) : NEW_LINE INDENT A , B = [ ] , [ ] ; NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT DEDENT print ( \" { ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT print ( \" } \" ) ; NEW_LINE print ( \" { ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( \" ▁ } \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE printArrays ( N ) ; NEW_LINE DEDENT"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Berfungsi untuk membalikkan bit A dan B yang ditetapkan dalam kedua -dua mereka; Melelehkan semua bit mungkin A dan B; Jika ia bit ditetapkan dalam kedua -dua A dan B; Jelas i - th bit a; Jelas i - th bit b; Cetak A dan B; Kod pemacu", "code": "def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | Berfungsi untuk mencari jumlah yang berbeza; Kod pemacu", "code": "def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE"}
{"text": "Count Substrings Dari Diberi String Ternary yang Mengandungi Karakter Sekurang -kurangnya sekali | Fungsi untuk mengira bilangan substrings terdiri daripada 0, 1, dan 2; Memulakan pelbagai frekuensi saiz 3; Menyimpan kiraan yang dihasilkan; Traversing string str; Arahan kekerapan kemas kini; Jika semua watak hadir mengira bilangan substrings mungkin; Kemas kini bilangan substring; Mengembalikan bilangan substring; Kod pemacu", "code": "def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT count += i NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"00021\" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE"}
{"text": "FLIPS MINIMUM UNTUK MENGURANGKAN SEBARANG TERBUKA 3 0 S atau 1 S DALAM RENCEN BINARY YANG DIPERLUKAN | Berfungsi untuk mencari bilangan minimum flip untuk membuat ketiga -tiga pasang aksara berturut -turut berbeza; Kedai -kedai yang dihasilkan pasangan pasangan; Kes asas; Melangkah ke atas julat [0, n - 2]; Jika nombor 3 berturut -turut adalah sama maka kenaikan kiraan dan kaunter; Kembalikan jawapannya; Kod pemacu", "code": "def minFlips ( st ) : NEW_LINE INDENT count = 0 NEW_LINE if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( st ) - 2 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"0011101\" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT"}
{"text": "Menyulitkan rentetan | Berfungsi untuk menukar perpuluhan ke hex; Berfungsi untuk menyulitkan rentetan; Melepasi watak -watak rentetan; Iterat sehingga S [i] sama dengan CH; Kemas kini kiraan dan saya; Penurunan I oleh 1; Menukar kiraan kepada perwakilan heksadesimal; Tambah watak; Tambah kekerapan aksara dalam perwakilan heksadesimal; Membalikkan jawapan yang diperoleh; Mengembalikan jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def convertToHex ( num ) : NEW_LINE INDENT temp = \" \" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num // 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT def encryptString ( S , N ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE while ( i < N and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE hex = convertToHex ( count ) NEW_LINE ans += ch NEW_LINE ans += hex NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abc \" NEW_LINE N = len ( S ) NEW_LINE print ( encryptString ( S , N ) ) NEW_LINE DEDENT"}
{"text": "Kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 s ~ melebihi »frekuensi ~» s | Fungsi untuk mengira dan mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Kirakan nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mengembalikan kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 's »s; Kiraan rentetan binari panjang n; Kiraan rentetan binari panjang n yang mempunyai kiraan yang sama dengan 0 dan 1 's; Untuk rentetan panjang; Kod pemacu", "code": "def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countOfString ( N ) : NEW_LINE INDENT Stotal = pow ( 2 , N ) NEW_LINE Sequal = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N // 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) // 2 NEW_LINE return S1 NEW_LINE DEDENT N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE"}
{"text": "Keluarkan semua kejadian watak dalam rentetan | Pendekatan Rekursif | Berfungsi untuk menghapuskan semua kejadian watak dalam rentetan; Kes asas; Semak watak pertama rentetan yang diberikan; Lulus sisa rentetan ke panggilan fungsi rekursi; Tambah watak pertama STR dan String dari rekursi; Diberikan rentetan; Diberikan watak; Panggilan fungsi", "code": "def removeCharRecursive ( str , X ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT if ( str [ 0 ] == X ) : NEW_LINE INDENT return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE X = ' e ' NEW_LINE str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE"}
{"text": "Masa maksimum seperti perbezaan mutlak antara jam dan minit terletak pada julat yang diberikan | Pemeriksaan fungsi sama ada masa yang diberikan adalah betul; Untuk memeriksa nilai masa; Untuk memeriksa nilai jam masa; Perubahan nilai tidak dibenarkan di kedudukan di mana '? 'tidak hadir; Fungsi memeriksa sama ada perbezaan mutlak antara jam dan nilai minit berada dalam [l, r]; Cek jika perbezaan di luar julat memberi; Memaparkan masa dalam format 24 jam yang betul; Fungsi Cari nilai masa yang dikehendaki yang perbezaannya terletak dalam julat [l, r]; Menurunkan nilai jam dari 23 hingga 0; Semak jika nilai jam sah jika tidak sah maka tidak perlu menukar nilai minit, kerana masa masih akan sah, untuk memeriksa bendera nilai jam ditetapkan kepada 1 .; Mengurangkan nilai minit dari 59 hingga 0; Semak sama ada nilai minit sah, jika tidak sah kemudian langkau lelaran semasa, untuk memeriksa bendera nilai 'minit' ditetapkan kepada 0 .; Masa input; Julat Perbezaan", "code": "def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE DEDENT if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = \" : \" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( \"0\" , hh , end = \" : \" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( \"0\" , mm ) NEW_LINE DEDENT DEDENT def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i // 10 NEW_LINE if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j // 10 NEW_LINE if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT timeValue = \" ? ? : ? ? \" NEW_LINE L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE"}
{"text": "Semak jika rentetan boleh dibahagikan kepada substrings Palindromic panjang walaupun | Fungsi untuk memeriksa string str boleh memecah rentetan ke dalam substrings palindromik panjang; Memulakan timbunan; Melelehkan rentetan; Jika watak I - tH adalah sama seperti di bahagian atas timbunan kemudian pop elemen atas; Lain -lain menolak watak semasa ke dalam timbunan; Sekiranya timbunan kosong, maka substrings palindromik mungkin; Lain tidak - mungkin; Diberikan rentetan; Panggilan fungsi", "code": "def check ( s , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT str = \" aanncddc \" ; NEW_LINE n = len ( str ) NEW_LINE if ( check ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Bilangan rentetan dalam dua array memenuhi syarat -syarat yang diberikan | Program Python3 untuk pendekatan di atas; Untuk menyimpan kekerapan rentetan selepas bitmasking; Untuk menyimpan hasil untuk setiap rentetan dalam ARR2 []; Melintasi arr1 [] dan bitmask setiap rentetan di dalamnya; Bitmasking untuk setiap rentetan s; Kemas kini kekerapan rentetan dengan nilai bitmasking; Melintasi arr2 []; Bitmasking untuk setiap rentetan s; Periksa sama ada temp ada dalam unstered_map atau tidak; Semak bit set seterusnya; Tolak kiraan untuk rentetan semasa dalam array yang dihasilkan; Cetak kiraan untuk setiap rentetan; Kod pemacu; Panggilan fungsi", "code": "from collections import defaultdict NEW_LINE def findNumOfValidWords ( w , p ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE res = [ ] NEW_LINE for s in w : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT m [ val ] += 1 NEW_LINE DEDENT for s in p : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT temp = val NEW_LINE first = ord ( s [ 0 ] ) - ord ( ' a ' ) NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT if ( ( ( temp >> first ) & 1 ) == 1 ) : NEW_LINE INDENT if ( temp in m ) : NEW_LINE INDENT count += m [ temp ] NEW_LINE DEDENT DEDENT temp = ( temp - 1 ) & val NEW_LINE DEDENT res . append ( count ) NEW_LINE DEDENT for it in res : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ \" aaaa \" , \" asas \" , \" able \" , \" ability \" , \" actt \" , \" actor \" , \" access \" ] NEW_LINE arr2 = [ \" aboveyz \" , \" abrodyz \" , \" absolute \" , \" absoryz \" , \" actresz \" , \" gaswxyz \" ] NEW_LINE findNumOfValidWords ( arr1 , arr2 ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan setara perpuluhan dengan membalikkan hanya satu set bersebelahan 0 S | Berfungsi untuk mencetak nombor binari; Semak sama ada nombor semasa ialah 0; Cari 0 s berterusan; Gantikan pada mulanya berlaku 0 dengan 1; Kembalikan rentetan dan pecahkan gelung; Kod pemacu", "code": "def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT while ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE i += 1 NEW_LINE DEDENT s = ' ' . join ( map ( str , s ) ) NEW_LINE return s NEW_LINE DEDENT DEDENT DEDENT s = \"100010001\" NEW_LINE print ( flip ( s ) ) NEW_LINE"}
{"text": "Kes Kalimat Rentetan Camel yang Diberikan | Berfungsi untuk mengembalikan rentetan asal selepas menukarnya dari unta; Cetak watak pertama seperti itu; Melintasi seluruh watak satu demi satu; Jika watak semasa adalah prspace huruf besar diikuti oleh watak semasa dalam huruf kecil; Lain mencetak watak semasa; Kod pemacu", "code": "def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = \" \" ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( \" ▁ \" , s [ i ] . lower ( ) , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT s = \" ILoveGeeksForGeeks \" NEW_LINE getOrgString ( s ) NEW_LINE"}
{"text": "Kira kejadian watak dalam rentetan berulang | Berfungsi untuk mengira watak 'a; Atleast k pengulangan diperlukan; Jika n bukanlah pelbagai pemeriksaan saiz rentetan untuk watak berulang yang tersisa. ; Kod pemacu", "code": "' NEW_LINE def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = \" abcac \" NEW_LINE print ( countChar ( str , ' a ' ) ) NEW_LINE"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program Python3 untuk mengira frekuensi item array yang mempunyai nilai kecil. ; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi unsur -unsur array dan kekerapan kiraan (dengan mengandaikan bahawa unsur -unsur dibatasi oleh had); Kod pemacu", "code": "def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 10 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE"}
{"text": "Semak jika rentetan mempunyai m berturut -turut 1 's atau ~ 0' s | Fungsi yang memeriksa jika rentetan binari mengandungi m berturut -turut 1 's atau' s; panjang rentetan binari; Count Zeros; Count 1 's; Count berturut -turut 0 's; Count berturut -turut 1 's; Kod pemacu; panggilan fungsi", "code": "def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = \"001001\" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT"}
{"text": "Produk nod di k | Berfungsi untuk mencari produk digit elemen di peringkat k - th; Memulakan hasil; peningkatan bilangan tahap; mengurangkan nombor tahap; Periksa sama ada tahap semasa adalah tahap yang dikehendaki atau tidak; produk yang diperlukan; Program Pemandu", "code": "def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" NEW_LINE k = 2 NEW_LINE print ( productAtKthLevel ( tree , k ) ) NEW_LINE"}
{"text": "Mengeluarkan baris atau lajur bijak pendua dari matriks aksara | Berfungsi untuk memeriksa pendua dalam baris dan lajur; Buat array ispresent dan mulakan semua penyertaannya sebagai palsu. Nilai ispresent [i] [j] akan benar jika s [i] [j] hadir dalam baris atau lajurnya. ; Memeriksa setiap baris untuk pendua [i] [j]; Memeriksa setiap baris untuk pendua [i] [j]; Jika watak itu unik dalam baris dan lajurnya; Kod pemacu; pelbagai watak; Fungsi panggilan", "code": "def findDuplicates ( a , n , m ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if i != k and a [ i ] [ j ] == a [ k ] [ j ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT for k in range ( m ) : NEW_LINE INDENT if j != k and a [ i ] [ j ] == a [ i ] [ k ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if not isPresent [ i ] [ j ] : NEW_LINE INDENT print ( a [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE a = [ \" zx \" , \" xz \" ] NEW_LINE findDuplicates ( a , n , m ) NEW_LINE DEDENT"}
{"text": "Program untuk memeriksa ISBN | Kod Python untuk memeriksa sama ada ISBN yang diberikan adalah sah atau tidak. ; periksa panjang; Pengkomputeran berjumlah 9 digit pertama; Memeriksa digit terakhir; Jika digit terakhir adalah 'x', tambahkan 10 hingga jumlah, tambah nilainya. ; Kembali benar jika jumlah digit berwajaran boleh dibahagikan dengan 11; Kod pemacu", "code": "def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = \"007462542X \" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Menyimpan vokal secara berasingan; Meletakkan vokal dalam urutan terbalik dalam rentetan; Kod pemacu", "code": "def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello ▁ world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Fungsi untuk mencari rentetan yang mempunyai watak pertama setiap perkataan. ; Melintasi rentetan. ; Jika ia adalah ruang, tetapkan V sebagai benar. ; Lain semak jika v adalah benar atau tidak. Jika benar, salin watak dalam rentetan output dan tetapkan V sebagai palsu. ; Kod pemacu", "code": "def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT"}
{"text": "Laluan unik yang meliputi setiap bukan | Fungsi untuk DFS. i, j ==> indeks sel semasa vis ==> untuk menandakan sel -sel yang dikunjungi ans ==> hasil z ==> kiraan semasa 0 s yang dikunjungi z_count ==> total 0 s hadir; Tandakan blok seperti yang dikunjungi; Mengemas kini kiraan; Jika blok akhir dicapai; Jika jalan meliputi semua blok bukan halangan; Naik; Ke bawah; Kiri; Betul; Unmark blok (Unvisited); Berfungsi untuk mengembalikan kiraan laluan unik; Jumlah 0 s hadir; Menghitung blok penghalang; Kedudukan permulaan; Kod pemacu", "code": "def dfs ( i , j , grid , vis , ans , z , z_count ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE vis [ i ] [ j ] = 1 NEW_LINE if ( grid [ i ] [ j ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT if ( grid [ i ] [ j ] == 2 ) : NEW_LINE INDENT if ( z == z_count ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT if ( i >= 1 and not vis [ i - 1 ] [ j ] and grid [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i - 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( i < n - 1 and not vis [ i + 1 ] [ j ] and grid [ i + 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i + 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j >= 1 and not vis [ i ] [ j - 1 ] and grid [ i ] [ j - 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j - 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j < m - 1 and not vis [ i ] [ j + 1 ] and grid [ i ] [ j + 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j + 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT def uniquePaths ( grid ) : NEW_LINE INDENT z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT x = i NEW_LINE y = j NEW_LINE DEDENT DEDENT DEDENT grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] NEW_LINE print ( uniquePaths ( grid ) ) NEW_LINE DEDENT"}
{"text": "Kira pasangan yang tidak teratur (x, y) array yang memenuhi persamaan yang diberikan | Mengembalikan bilangan pasangan yang tidak teratur yang memenuhi syarat; Ans menyimpan bilangan pasangan yang tidak teratur; Menjadikan setiap nilai array menjadi positif; Susun array; Bagi setiap indeks mengira sempadan yang betul untuk pasangan yang tidak teratur; Mengembalikan hasil akhir; Kod pemacu", "code": "def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 3 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( numPairs ( a , n ) ) NEW_LINE"}
{"text": "Kawasan persegi | Menggunakan sisi, pepenjuru dan perimeter | Berfungsi untuk mencari kawasan persegi; Gunakan formula di atas; Kod pemacu; Diberikan sisi persegi; Panggilan fungsi", "code": "def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE print ( areaOfSquare ( S ) ) NEW_LINE DEDENT"}
{"text": "Titik maksimum persimpangan yang mungkin di kalangan x lingkaran dan garis lurus y | Program Python3 untuk melaksanakan pendekatan di atas; Bilangan bulatan; Bilangan garis lurus; Panggilan fungsi", "code": "def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT x = 3 NEW_LINE y = 4 NEW_LINE print ( maxPointOfIntersection ( x , y ) ) NEW_LINE"}
{"text": "Nombor Icosihenagonal | Berfungsi untuk mencari nombor icosihenagonal; Formula untuk mengira nombor icosihenagon nth; Kod pemacu", "code": "def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE"}
{"text": "Cari centroid bukan | Program Python3 untuk melaksanakan pendekatan di atas; Untuk semua simpang; Hitung nilai menggunakan formula kasut; Mengira koordinat centroid poligon; Menyelaras simpul", "code": "def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE DEDENT signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE DEDENT vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( round ( ans [ 0 ] , 12 ) , ans [ 1 ] ) NEW_LINE"}
{"text": "Program untuk mencari sudut segiempat | Kod pemacu; Menurut formula yang diperolehi di atas; Cetak semua sudut", "code": "d = 10 NEW_LINE a = 0.0 NEW_LINE a = ( 360 - ( 6 * d ) ) / 4 NEW_LINE print ( a , \" , \" , a + d , \" , \" , a + 2 * d , \" , \" , a + 3 * d , sep = ' ▁ ' ) NEW_LINE"}
{"text": "Jarak antara dua pesawat selari dalam 3 | Program Python untuk mencari jarak antara dua pesawat selari dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu", "code": "import math NEW_LINE def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( \" Perpendicular ▁ distance ▁ is \" ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Planes ▁ are ▁ not ▁ parallel \" ) NEW_LINE DEDENT DEDENT a1 = 1 NEW_LINE b1 = 2 NEW_LINE c1 = - 1 NEW_LINE d1 = 1 NEW_LINE a2 = 3 NEW_LINE b2 = 6 NEW_LINE c2 = - 3 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) NEW_LINE"}
{"text": "Mengira cara untuk membentuk 2 kalung dari manik n yang mengandungi n / 2 manik masing -masing | Fungsi untuk mengira faktorial; Fungsi untuk mengira bilangan cara untuk membuat 2 kalung yang mempunyai manik N / 2 jika setiap manik dianggap berbeza; Bilangan cara untuk memilih manik n / 2 dari manik N; Bilangan cara untuk membekalkan manik n / 2; Bahagikan Ans oleh 2 untuk menghapuskan pengulangan; Kembali Ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def numOfNecklace ( N ) : NEW_LINE INDENT ans = factorial ( N ) // ( factorial ( N // 2 ) * factorial ( N // 2 ) ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans //= 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( numOfNecklace ( N ) ) NEW_LINE DEDENT"}
{"text": "Semak jika nombor s boleh dibuat dibahagikan dengan d dengan berulang kali menambahkan selebihnya kepada s | Fungsi untuk memeriksa sama ada S dibahagi dengan d semasa menukar s ke (s + s % d); V (0) = s % d; Menyimpan nilai yang ditemui; V (i) = (v (i - 1) + v (i - 1) % d) % d; Semak sama ada nilai telah ditemui; Kes tepi; Jika tidak, masukkannya ke dalam hashmap; Kod pemacu", "code": "def isDivisibleByDivisor ( S , D ) : NEW_LINE INDENT S %= D NEW_LINE hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE INDENT S += ( S % D ) NEW_LINE S %= D NEW_LINE if ( S in hashMap ) : NEW_LINE INDENT if ( S == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 3 NEW_LINE D = 6 NEW_LINE print ( isDivisibleByDivisor ( S , D ) ) NEW_LINE DEDENT"}
{"text": "Bilangan minimum bergerak yang diperlukan untuk mencapai (1, 1) dari (x, y) | Fungsi untuk mengira bilangan langkah yang diperlukan untuk menukar (x, y) hingga (1, 1); Simpan hasil yang diperlukan; Melangkah sementara kedua -dua x dan y tidak sama dengan 0; Jika x lebih besar daripada y; Kemas kini kiraan dan nilai x; Jika tidak; Kemas kini kiraan dan nilai y; Jika kedua -dua x dan y> 1; Cetak hasilnya; Kod pemacu; Diberikan x dan y", "code": "def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x / y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y / x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( int ( cnt ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 3 NEW_LINE y = 1 NEW_LINE minimumSteps ( x , y ) NEW_LINE DEDENT"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Selepas gelung ini, timbunan mengandungi bahagian ekspresi yang tidak seimbang, i. e. , ungkapan bentuk \"...\"; Panjang ekspresi yang dikurangkan red_len = (m + n); mengira kurungan pembukaan pada akhir timbunan; Kembali Ceil (m / 2) + Ceil (n / 2) yang sebenarnya sama dengan (m + n) / 2 + n % 2 apabila m + n juga. ; Kod pemacu", "code": "def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT red_len = len ( s ) NEW_LINE n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT return ( red_len // 2 + n % 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT expr = \" } } { { \" NEW_LINE print ( countMinReversals ( expr . strip ( ) ) ) NEW_LINE DEDENT"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Mencetak nombor minimum yang boleh dibentuk dari urutan input i dan u; Inisialisasi Current_Max (untuk memastikan bahawa kita tidak menggunakan watak berulang; permulaan last_entry (menjejaki angka bercetak terakhir); beralih ke atas array input; memulakan 'noofnextd' untuk mendapatkan kiraan d berikut yang tersedia; Cetak angka;", "code": "def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program Python3 untuk mencetak nombor minimum yang boleh dibentuk dari urutan yang diberikan IS dan DS; min_avail mewakili nombor minimum yang masih tersedia untuk memasukkan dalam vektor output. pos_of_i menjejaki indeks paling terkini di mana 'i' ditemui w. r. t vektor output; Vektor untuk menyimpan output; Meliputi kes asas; Melintasi sisa input; Cetak nombor; Kod pemacu", "code": "def printLeast ( arr ) : NEW_LINE INDENT min_avail = 1 NEW_LINE pos_of_I = 0 NEW_LINE v = [ ] NEW_LINE if ( arr [ 0 ] == ' I ' ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( 2 ) NEW_LINE v . append ( 1 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 0 NEW_LINE DEDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT v . append ( min_avail ) NEW_LINE min_avail += 1 NEW_LINE pos_of_I = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE for j in range ( pos_of_I , i + 1 ) : NEW_LINE INDENT v [ j ] += 1 NEW_LINE DEDENT min_avail += 1 NEW_LINE DEDENT DEDENT print ( * v , sep = ' ▁ ' ) NEW_LINE DEDENT printLeast ( \" IDID \" ) NEW_LINE printLeast ( \" I \" ) NEW_LINE printLeast ( \" DD \" ) NEW_LINE printLeast ( \" II \" ) NEW_LINE printLeast ( \" DIDI \" ) NEW_LINE printLeast ( \" IIDDD \" ) NEW_LINE printLeast ( \" DDIDDIID \" ) NEW_LINE"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Fungsi untuk menyahkod urutan yang diberikan untuk membina nombor minimum tanpa digit berulang; Rentetan untuk menyimpan hasil; Ambil senarai untuk berfungsi sebagai timbunan; Jalankan n + 1 kali di mana n adalah panjang urutan input, kerana panjang rentetan hasil sentiasa 1 lebih besar; Tekan nombor I + 1 ke dalam timbunan; Jika semua aksara urutan input diproses atau watak semasa adalah 'i; Jalankan semasa gelung sehingga timbunan kosong; Pop elemen di atas timbunan dan simpannya dalam rentetan hasil; Kod pemacu", "code": "def PrintMinNumberForPattern ( Strr ) : NEW_LINE INDENT res = ' ' NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( Strr ) + 1 ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if ( i == len ( Strr ) or Strr [ i ] == ' I ' ) : NEW_LINE INDENT while len ( stack ) > 0 : NEW_LINE INDENT res += str ( stack . pop ( ) ) NEW_LINE res += ' ▁ ' NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Mengembalikan nombor minimum yang dibuat dari urutan yang diberikan tanpa mengulangi digit; Gelung berjalan untuk setiap aksara input serta satu masa tambahan untuk memberikan pangkat kepada watak yang tinggal; Kod pemacu", "code": "def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inputs = [ \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" ] NEW_LINE for Input in inputs : NEW_LINE INDENT print ( * ( getMinNumberForPattern ( Input ) ) ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak jika digit pertama dan terakhir nombor terkecil membentuk Perdana | Python3 pelaksanaan pendekatan di atas; berfungsi untuk memeriksa perdana; Berfungsi untuk menghasilkan nombor yang paling kecil dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam urutan menaik untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; mengekstrak digit pertama; mengekstrak digit terakhir; mencetak kombinasi utama; Kod pemacu", "code": "import math as mt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findMinNum ( arr , n ) : NEW_LINE INDENT first , last = 0 , 0 NEW_LINE Hash = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( \" Minimum ▁ number : ▁ \" , end = \" \" ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT num = first * 10 + last NEW_LINE rev = last * 10 + first NEW_LINE print ( \" Prime ▁ combinations : ▁ \" , end = \" \" ) NEW_LINE if ( isPrime ( num ) and isPrime ( rev ) ) : NEW_LINE INDENT print ( num , \" ▁ \" , rev ) NEW_LINE DEDENT elif ( isPrime ( num ) ) : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT elif ( isPrime ( rev ) ) : NEW_LINE INDENT print ( rev ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ combinations ▁ exist \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 7 , 8 ] NEW_LINE findMinNum ( arr , 5 ) NEW_LINE"}
{"text": "Mencari Co Transitif | Berfungsi untuk mengembalikan GCD A dan B; berfungsi untuk memeriksa GCD; A dan B adalah coprime jika GCD mereka adalah 1; Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Menjana dan menyemak semua kemungkinan tiga kali ganda antara L dan R; Jika kita dapati apa -apa tiga kali ganda menetapkan bendera kepada benar; Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def coprime ( a , b ) : NEW_LINE INDENT return ( gcd ( a , b ) == 1 ) ; NEW_LINE DEDENT def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , R + 1 ) : NEW_LINE INDENT if ( coprime ( a , b ) and coprime ( b , c ) and coprime ( a , c ) == False ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = a ; NEW_LINE possibleB = b ; NEW_LINE possibleC = c ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( \" ( \" , possibleA , \" , \" , possibleB , \" , \" , possibleC , \" ) ▁ is ▁ one ▁ such \" , \" possible ▁ triplet ▁ between \" , L , \" and \" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Such ▁ Triplet ▁ exists ▁ between \" , L , \" and \" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE"}
{"text": "Jangkau A dan B dengan mengalikannya dengan k dan k ^ 2 pada setiap langkah | Program Python 3 untuk menentukan sama ada A dan B dapat dicapai bermula dari 1, 1 berikutan langkah -langkah yang diberikan. ; Fungsi untuk memeriksa adalah mungkin untuk mencapai A dan B bermula dari 1 dan 1; Cari cuberoot nombor; Bahagikan nombor dengan Cuberoot; Jika ia adalah cuberoot yang sempurna dan membahagikan A dan B; Kod pemacu", "code": "import numpy as np NEW_LINE def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 60 NEW_LINE B = 450 NEW_LINE if ( possibleToReach ( A , B ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Nombor bergelora | Program python3 untuk memeriksa sama ada nombor beralun atau tidak; Memandangkan definisi dengan sekatan bahawa terdapat sekurang -kurangnya 3 digit; Semak sama ada semua digit alternatif adalah sama atau tidak. ; Kod pemacu", "code": "def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = \"1212121\" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | Fungsi untuk mengira siri berikut; Kod pemacu", "code": "def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT n = 3 NEW_LINE res = Series ( n ) NEW_LINE print ( res ) NEW_LINE"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program python yang cekap untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Kod pemacu", "code": "import math NEW_LINE def counLastDigitK ( low , high , k ) : NEW_LINE INDENT mlow = 10 * math . ceil ( low / 10.0 ) NEW_LINE mhigh = 10 * int ( high / 10.0 ) NEW_LINE count = ( mhigh - mlow ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 <= k and ( low % 10 ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE"}
{"text": "Jumlah semua nombor yang boleh dibahagikan dengan 6 dalam julat yang diberikan | fungsi untuk mengira jumlah semua nombor yang boleh dibahagi dengan 6 dalam julat l - r. . ; tidak ada gandaan 6 sehingga r; tiada gandaan 6 sehingga l - 1; penjumlahan semua gandaan 6 sehingga r; penjumlahan semua gandaan 6 sehingga l - 1; mengembalikan jawapannya; kod pemacu", "code": "sdef sumDivisible ( L , R ) : NEW_LINE INDENT p = int ( R / 6 ) NEW_LINE q = int ( ( L - 1 ) / 6 ) NEW_LINE sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE return sumR - sumL NEW_LINE DEDENT L = 1 NEW_LINE R = 20 NEW_LINE print ( sumDivisible ( L , R ) ) NEW_LINE"}
{"text": "Largest smaller number possible using only one swap operation | Program Python3 untuk mencari nombor yang lebih kecil dengan menukar satu digit. ; Mengembalikan nombor yang mungkin terbesar dengan satu swap supaya nombor itu lebih kecil daripada STR. Dianggap bahawa terdapat 0 s. ; Traverse dari kanan sehingga kita dapati digit yang lebih besar daripada digit seterusnya. Sebagai contoh, dalam 34125, indeks kami ialah 4 .; Kami juga boleh menggunakan carian binari di sini sebagai digit selepas indeks disusun dalam peningkatan urutan. Cari digit terbesar di sebelah kanan ARR [indeks] yang lebih kecil daripada ARR [indeks]; Jika indeks adalah - 1 i. e. Digit adalah dalam urutan yang semakin meningkat. ; Menukar kedua -dua nilai; Kod pemacu", "code": "import sys NEW_LINE def prevNum ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if int ( string [ i ] ) > int ( string [ i + 1 ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT smallGreatDgt = - 1 NEW_LINE for i in range ( n - 1 , index , - 1 ) : NEW_LINE INDENT if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT DEDENT if index == - 1 : NEW_LINE INDENT return \" \" . join ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT ( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] ) NEW_LINE DEDENT return \" \" . join ( string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n_str = \"34125\" NEW_LINE ans = prevNum ( list ( n_str ) , len ( n_str ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"text": "SGN Nilai polinomial | Pulangan nilai poli [0] x (n - 1) + poli [1] x (n - 2) +. . + poli [n - 1]; Memulakan hasil; Menilai nilai polinomial menggunakan kaedah Horner; Mengembalikan nilai tanda polinomial; Marilah kita menilai nilai 2 x3 - 6 x2 + 2 x - 1 untuk x = 3", "code": "def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = ( result * x + poly [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def findSign ( poly , n , x ) : NEW_LINE INDENT result = horner ( poly , n , x ) ; NEW_LINE if ( result > 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( result < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT poly = [ 2 , - 6 , 2 , - 1 ] ; NEW_LINE x = 3 ; NEW_LINE n = len ( poly ) ; NEW_LINE print ( \" Sign ▁ of ▁ polynomial ▁ is ▁ \" , findSign ( poly , n , x ) ) ; NEW_LINE"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program Python3 untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; berfungsi untuk mengira perdana menggunakan ayak eratosthenes; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; Kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Panggil Sieveoferatostheneses untuk mengira prima; Untuk mencari jumlah elemen array; Jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "isPrime = [ 1 ] * 100005 NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Mengira jumlah semua sub - array; Pilih titik permulaan; Memilih titik akhir; jumlah subarray antara titik permulaan dan akhir semasa; Program Pemandu", "code": "def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum ▁ of ▁ SubArray ▁ : \" , SubArraySum ( arr , n ) ) NEW_LINE"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program Python3 untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Kod pemacu", "code": "import math NEW_LINE def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE"}
{"text": "Cari (a ^ b) % m di mana 'a' sangat besar | Program python untuk mencari (a ^ b) mod m untuk besar 'a; fungsi utiliti untuk mengira % m; Tukar rentetan S [i] ke integer yang memberikan nilai digit dan membentuk nombor; Pulangan mencari (a ^ b) % m; Cari % m; Sekarang kalikan Ans dengan b - 1 kali dan ambil mod dengan m; Program pemacu untuk menjalankan kes itu", "code": "' NEW_LINE def aModM ( s , mod ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT number = ( number * 10 + int ( s [ i ] ) ) NEW_LINE number = number % m NEW_LINE DEDENT return number NEW_LINE DEDENT def ApowBmodM ( a , b , m ) : NEW_LINE INDENT ans = aModM ( a , m ) NEW_LINE mul = ans NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT ans = ( ans * mul ) % m NEW_LINE DEDENT return ans NEW_LINE DEDENT a = \"987584345091051645734583954832576\" NEW_LINE b , m = 3 , 11 NEW_LINE print ApowBmodM ( a , b , m ) NEW_LINE"}
{"text": "Interpolasi LaGrange | Untuk mewakili titik data yang sepadan dengan x dan y = f (x); Fungsi untuk menginterpolasi titik data yang diberikan menggunakan Formula XI LaGrange -> sepadan dengan titik data baru yang nilainya diperoleh n -> mewakili bilangan titik data yang diketahui; Memulakan hasil; Mengira syarat individu di atas formula; Tambah istilah semasa untuk menghasilkan; Kod pemacu; mewujudkan pelbagai 4 mata data yang diketahui; Menggunakan fungsi interpolasi untuk mendapatkan titik data yang sepadan dengan x = 3", "code": "class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def interpolate ( f : list , xi : int , n : int ) -> float : NEW_LINE INDENT result = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT term = f [ i ] . y NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) NEW_LINE DEDENT DEDENT result += term NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT f = [ Data ( 0 , 2 ) , Data ( 1 , 3 ) , Data ( 2 , 12 ) , Data ( 5 , 147 ) ] NEW_LINE print ( \" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : \" , interpolate ( f , 3 , 4 ) ) NEW_LINE DEDENT"}
{"text": "Sieve of Sundaram untuk mencetak semua prima yang lebih kecil daripada n | Mencetak semua nombor perdana yang lebih kecil; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima lebih kecil daripada N, kita mengurangkan N hingga separuh; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j memulakan semua elemen sebagai tidak ditandakan; Logik utama Sundaram. Tandakan semua nombor bentuk i + j + 2 ij sebagai benar di mana 1 <= i <= j; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Kod pemacu", "code": "def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 1 ) / 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE"}
{"text": "Bina Arahan Asal Bermula dengan K dari pelbagai xor semua elemen kecuali elemen pada indeks yang sama | Berfungsi untuk membina array dengan setiap elemen yang sama dengan XOR semua elemen array kecuali elemen pada indeks yang sama; Array asal; Kedai bitwise xor array; Hitung XOR semua elemen array; Cetak array asal b; Kod pemacu; Panggilan fungsi", "code": "def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N ; NEW_LINE totalXOR = A [ 0 ] ^ K ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 13 , 14 , 10 , 6 ] ; NEW_LINE K = 2 ; NEW_LINE N = len ( A ) ; NEW_LINE constructArray ( A , N , K ) ; NEW_LINE DEDENT"}
{"text": "Cari elemen tambahan dalam array kedua | Berfungsi untuk mengembalikan elemen tambahan dalam b []; Untuk menyimpan hasilnya; Cari xor semua elemen array a [] dan array b []; Kod pemacu", "code": "def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT A = [ 10 , 15 , 5 ] ; NEW_LINE B = [ 10 , 100 , 15 , 5 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( extraElement ( A , B , n ) ) ; NEW_LINE"}
{"text": "Hamming jarak antara dua bilangan bulat | Fungsi untuk mengira jarak Hamming; Kod pemacu", "code": "def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 9 NEW_LINE n2 = 14 NEW_LINE print ( hammingDistance ( 9 , 14 ) ) NEW_LINE DEDENT"}
{"text": "Cetak bitwise dan set nombor n | berfungsi untuk mencari pendekatan naif subset bitwise; Kod pemacu", "code": "def printSubsets ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n & i ) == i ) : NEW_LINE INDENT print ( i , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT n = 9 NEW_LINE printSubsets ( n ) NEW_LINE"}
{"text": "Cari bit set yang paling ketara | Program Python untuk mencari nombor MSB untuk diberikan n. ; Untuk mencari kedudukan bit set yang paling penting; Untuk mengembalikan nilai nombor dengan set bit pada kedudukan k - th; Kod pemacu", "code": "import math NEW_LINE def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 1 << k NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Ambil input dan mulakan res = 0; Susun array; melintasi array input dan cari kekerapan maksimum; Untuk setiap nombor mencari pengulangan / kekerapannya; kemas kini res; Kod pemacu", "code": "def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( subset ( ar , n ) ) NEW_LINE"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Melintasi array input dan frekuensi elemen; Cari nilai maksimum dalam peta. ; Kod pemacu", "code": "def subset ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subset ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk mewakili nombor sebagai jumlah kotak yang sempurna | '' Kedai kotak sempurna kurang daripada atau sama dengan n; '' Fungsi utiliti untuk mengira dataran sempurna kurang daripada atau sama dengan n; '' Fungsi untuk mencari bilangan cara untuk mewakili nombor sebagai jumlah kuadrat yang sempurna; '' Mengendalikan kes asas; '' Sertakan elemen indeks i-th; '' Kecualikan elemen indeks i-th; '' Kembalikan hasilnya; '' Kod pemandu; '' Diberikan input; '' Precallulate Squares Perfect <= n; '' Panggilan fungsi", "code": "psquare = [ ] NEW_LINE def calcPsquare ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT psquare . append ( i * i ) NEW_LINE DEDENT DEDENT def countWays ( index , target ) : NEW_LINE INDENT if ( target == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( index < 0 or target < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT inc = countWays ( index , target - psquare [ index ] ) NEW_LINE exc = countWays ( index - 1 , target ) NEW_LINE return inc + exc NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE calcPsquare ( N ) NEW_LINE print ( countWays ( len ( psquare ) - 1 , N ) ) NEW_LINE DEDENT"}
{"text": "Jumlah jarak semua nod dari nod yang diberikan | '' Menyimpan jumlah jarak semua nod dari nod yang diberikan; ''Structure of a binary tree node ; '' Fungsi untuk mengira bilangan nod di subtrees kiri dan kanan; '' Inisiasi pasangan yang menyimpan pasangan {bilangan nod, kedalaman}; '' Mencari bilangan nod di subtree kiri; '' Cari bilangan nod di subtree yang betul; '' Mengisi medan saiz; '' Fungsi untuk mencari jarak keseluruhan; '' Jika nod sasaran sepadan dengan nod semasa; '' Jika root.left tidak batal; '' Kemas kini jumlah; '' Berulang untuk subtree kiri; '' Jika root.right tidak batal; '' Memohon formula yang diberikan dalam pendekatan; '' Berulang untuk subtree yang betul; '' Kod pemandu; '' Pokok input; '' Total number of nodes ; '' Cetak jumlah jarak", "code": "sum = 0 NEW_LINE class TreeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . size = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def sumofsubtree ( root ) : NEW_LINE INDENT p = [ 1 , 0 ] NEW_LINE if ( root . left ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . left ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . right ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT root . size = p [ 0 ] NEW_LINE return p NEW_LINE DEDENT def distance ( root , target , distancesum , n ) : NEW_LINE INDENT global sum NEW_LINE if ( root . data == target ) : NEW_LINE INDENT sum = distancesum NEW_LINE DEDENT if ( root . left ) : NEW_LINE INDENT tempsum = ( distancesum - root . left . size + ( n - root . left . size ) ) NEW_LINE distance ( root . left , target , tempsum , n ) NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT tempsum = ( distancesum - root . right . size + ( n - root . right . size ) ) NEW_LINE distance ( root . right , target , tempsum , n ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 1 ) NEW_LINE root . left = TreeNode ( 2 ) NEW_LINE root . right = TreeNode ( 3 ) NEW_LINE root . left . left = TreeNode ( 4 ) NEW_LINE root . left . right = TreeNode ( 5 ) NEW_LINE root . right . left = TreeNode ( 6 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE root . left . left . left = TreeNode ( 8 ) NEW_LINE root . left . left . right = TreeNode ( 9 ) NEW_LINE target = 3 NEW_LINE p = sumofsubtree ( root ) NEW_LINE totalnodes = p [ 0 ] NEW_LINE distance ( root , target , p [ 1 ] , totalnodes ) NEW_LINE print ( sum ) NEW_LINE DEDENT"}
{"text": "Menyusun semula array sedemikian rupa sehingga jumlah elemen yang diindeks yang sama adalah atmost k | '' Fungsi untuk menyusun semula array sedemikian rupa sehingga jumlah unsur -unsur yang diindeks yang sama tidak melebihi k; '' Susun array b [] dalam urutan menurun; '' Jika keadaan gagal; '' Cetak array; '' Kod pemandu; '' Diberikan tatasusunan", "code": "def rearrangeArray ( A , B , N , K ) : NEW_LINE INDENT B . sort ( reverse = True ) NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ i ] > K ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE K = 5 ; NEW_LINE rearrangeArray ( A , B , N , K ) NEW_LINE DEDENT"}
{"text": "Kira baris dengan jumlah melebihi jumlah matriks yang tinggal | '' Fungsi untuk mengira bilangan baris yang jumlahnya melebihi jumlah unsur -unsur matriks yang tinggal; '' Menyimpan dimensi matriks; '' Untuk menyimpan hasilnya; '' Menyimpan jumlah jumlah unsur matriks; '' Calculate the total sum ; '' Melintasi untuk memeriksa setiap baris; '' Menyimpan jumlah unsur baris semasa; '' Kirakan jumlah elemen baris semasa; '' Jika jumlah baris semasa melebihi jumlah sisa matriks; '' Meningkatkan kiraan; '' Cetak hasilnya; '' Kod pemandu; '' Diberikan matriks; '' Panggilan fungsi", "code": "def countRows ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE totalSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT totalSum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT currSum = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT currSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( currSum > totalSum - currSum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 2 , - 1 , 5 ] , [ - 3 , 0 , - 2 ] , [ 5 , 1 , 2 ] ] NEW_LINE countRows ( mat ) NEW_LINE DEDENT"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Susun array; Selepas menyusun, periksa sama ada elemen semasa sama seperti sebelumnya atau satu lagi. ; Kod pemacu", "code": "def areElementsContiguous ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Cari elemen maksimum dan minimum. ; Harus ada sekurang -kurangnya elemen dalam pelbagai untuk menjadikannya bersebelahan. ; Buat array yang dilawati dan memulakan fals; Tandakan elemen sebagai benar. ; Jika mana -mana elemen tidak ditandakan, semua elemen tidak bersebelahan. ; Program Pemandu", "code": "def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | Berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Menyimpan unsur -unsur 'arr []' dalam jadual hash 'kami; Sebagai arr [0] hadir dalam 'kami; Bermula dengan elemen yang lebih kecil sebelumnya ARR [0]; Jika 'curr _ ele' hadir dalam 'kami; Kiraan kenaikan; Mengemas kini 'curr_ele'; bermula dengan elemen yang lebih besar dari arr [0]; jika 'curr _ ele' hadir dalam 'us; kiraan kenaikan; kemas kini' curr_ele \"; Pulangan benar jika array mengandungi satu set bilangan bulat bersebelahan lain kembali palsu; Kod pemacu", "code": "def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE"}
{"text": "Subarray terpanjang tidak mempunyai lebih banyak daripada elemen yang berbeza | berfungsi untuk mencetak pelbagai sub - paling lama; Tandakan elemen yang dikunjungi; Jika ia dikunjungi kali pertama, maka tingkatkan kaunter unsur -unsur yang berbeza dengan 1; Apabila kaunter unsur -unsur yang berbeza meningkat dari k, kemudian mengurangkannya kepada k; Dari sebelah kiri, mengurangkan bilangan masa lawatan; Sekiranya elemen masa yang dikurangkan tidak terdapat dalam segmen selanjutnya maka mengurangkan kiraan unsur -unsur yang berbeza; meningkatkan tanda subsegment; Semak panjang sub -segmen terpanjang apabila lebih besar kemudian sebelum ini kemudian tukarnya; Cetak segmen sub - terpanjang; Kod pemacu", "code": "import collections NEW_LINE def longest ( a , n , k ) : NEW_LINE INDENT freq = collections . defaultdict ( int ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE longest ( a , n , k ) NEW_LINE DEDENT"}
{"text": "Periksa sama ada Kira K dalam mana -mana Titik | Fungsi yang mengembalikan benar jika mana -mana segmen K bertindih pada bila -bila masa; Vektor untuk menyimpan titik permulaan dan titik akhir; Titik permulaan ditandakan dengan - 1 dan titik berakhir dengan + 1; Susun vektor dengan elemen pertama; Tumpukan untuk menyimpan tumpang tindih; Dapatkan elemen semasa; Jika ia adalah titik permulaan; Tolaknya dalam timbunan; Ia adalah titik akhir; Pop elemen dari timbunan; Jika lebih daripada K -ranges bertindih; Kod pemacu", "code": "def kOverlap ( pairs : list , k ) : NEW_LINE INDENT vec = list ( ) NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE INDENT vec . append ( ( pairs [ 0 ] , - 1 ) ) NEW_LINE vec . append ( ( pairs [ 1 ] , 1 ) ) NEW_LINE DEDENT vec . sort ( key = lambda a : a [ 0 ] ) NEW_LINE st = list ( ) NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT cur = vec [ i ] NEW_LINE if cur [ 1 ] == - 1 : NEW_LINE INDENT st . append ( cur ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT if len ( st ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT pairs = list ( ) NEW_LINE pairs . append ( ( 1 , 3 ) ) NEW_LINE pairs . append ( ( 2 , 4 ) ) NEW_LINE pairs . append ( ( 3 , 5 ) ) NEW_LINE pairs . append ( ( 7 , 10 ) ) NEW_LINE n = len ( pairs ) NEW_LINE k = 3 NEW_LINE if kOverlap ( pairs , k ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Cari julat terkecil yang mengandungi elemen dari senarai k | Program Python3 untuk mengetahui pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai disusun yang diberikan. ; array untuk menyimpan indeks semasa senarai i; Fungsi ini mengambil senarai yang disusun dalam bentuk array 2D sebagai hujah. Ia mendapati pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai K. ; memulakan ke 0 indeks; untuk mengekalkan indeks senarai yang mengandungi elemen minimum; melangkah ke atas semua senarai; Jika setiap elemen senarai [i] dilalui maka memecahkan gelung; Cari nilai minimum di antara semua elemen senarai yang menunjuk oleh array PTR []; mengemas kini indeks senarai; Cari nilai maksimum di antara semua elemen senarai yang menunjuk oleh array PTR []; Sekiranya ada senarai ekzos, kami tidak akan mendapat jawapan yang lebih baik, jadi pecahkan gelung sementara; mengemas kini Minrange; Kod pemacu", "code": "N = 5 NEW_LINE ptr = [ 0 for i in range ( 501 ) ] NEW_LINE def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT minrange = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE INDENT minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( \" The ▁ smallest ▁ range ▁ is ▁ [ \" , minel , maxel , \" ] \" ) NEW_LINE DEDENT arr = [ [ 4 , 7 , 9 , 12 , 15 ] , [ 0 , 8 , 10 , 14 , 20 ] , [ 6 , 12 , 16 , 30 , 50 ] ] NEW_LINE k = len ( arr ) NEW_LINE findSmallestRange ( arr , N , k ) NEW_LINE"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | berfungsi untuk mencari d terbesar; Susun array dalam urutan menaik; melangkah dari belakang untuk mencari D terbesar yang diperlukan; Oleh kerana semua empat A, B, C, D harus berbeza; Jika kombinasi semasa J, K, L dalam set adalah sama dengan S [i] mengembalikan nilai ini kerana ini akan menjadi d terbesar kerana kita melelehkan dalam urutan menurun; Kod pemacu", "code": "def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT S = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( S ) NEW_LINE ans = findLargestd ( S , n ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( \" No ▁ Solution \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + \" , \" c ▁ = ▁ d ▁ is \" , ans ) NEW_LINE DEDENT"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Fungsi ini menemui empat elemen dengan jumlah x yang diberikan; Jumlah wang (a + b) semua pasangan (a, b) dalam jadual hash; Melintasi semua pasangan dan mencari (D - C) hadir dalam jadual hash; Jika d - c ada dalam jadual hash ,; Memastikan semua elemen adalah elemen array yang berbeza dan elemen tidak dianggap lebih dari sekali. ; Kod pemacu", "code": "def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if abs_diff in mp . keys ( ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE res = findFourElements ( arr , n ) NEW_LINE if ( res == - 10 ** 9 ) : NEW_LINE INDENT print ( \" No ▁ Solution . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Sorakkan dia array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE"}
{"text": "Program untuk Putaran Array | Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar arr [] saiz n oleh d; fungsi utiliti untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % ▁ d \" % arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE"}
{"text": "Susun array dalam julat indeks yang diberikan | Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Arahan sementara; Susun array sementara; Mengubah suai array asal dengan elemen array sementara; Cetak array yang diubah suai; Kod pemacu; panjang array", "code": "def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"}
{"text": "Penyusun baris matriks dalam urutan menurun diikuti oleh lajur dalam urutan menaik | Pelaksanaan Python 3 untuk menyusun baris matriks dalam urutan menurun diikuti dengan menyusun lajur dalam urutan menaik; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh turun. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris tikar [] [] dalam urutan menurun; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menaik. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "MAX_SIZE = 10 NEW_LINE def sortByRow ( mat , n , descending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( descending == True ) : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT DEDENT def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mat [ i ] [ j ] , mat [ j ] [ i ] = mat [ j ] [ i ] , mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n , True ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n , False ) NEW_LINE transpose ( mat , n ) ; NEW_LINE DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( \" Original ▁ Matrix : ▁ \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix ▁ After ▁ Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE DEDENT"}
{"text": "Pindahkan semua sifar ke hujung array | Fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; Kod pemacu", "code": "def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array : \" ) NEW_LINE print ( arr ) NEW_LINE"}
{"text": "Pindahkan semua sifar ke hujung array | Set | berfungsi untuk memindahkan semua sifar pada akhir array; Kiraan unsur bukan sifar; Melintasi array. Jika arr [i] bukan sifar, maka swap elemen pada indeks 'kiraan' dengan elemen pada indeks 'i; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "def moveZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Original ▁ array : \" , end = \" ▁ \" ) NEW_LINE printArray ( arr , n ) NEW_LINE moveZerosToEnd ( arr , n ) NEW_LINE print ( \" Modified array : \" , ▁ end = \"   \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; berfungsi untuk menyusun semula elemen array selepas pengubahsuaian; jika 'arr []' mengandungi satu elemen sahaja; melintasi array; Jika benar, lakukan pengubahsuaian yang diperlukan; nilai indeks semasa dua kali; Letakkan 0 dalam indeks seterusnya; kenaikan sebanyak 1 untuk memindahkan dua indeks di hadapan semasa lelaran gelung; tolak semua sifar pada akhir 'arr []; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT def modifyAndRearrangeArr ( ar , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] = 2 * arr [ i ] NEW_LINE arr [ i + 1 ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT pushZerosToEnd ( arr , n ) NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Original ▁ array : \" , end = \" ▁ \" ) NEW_LINE printArray ( arr , n ) NEW_LINE modifyAndRearrangeArr ( arr , n ) NEW_LINE print ( \" Modified array : \" , end = \"   \" ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | beralih semua sifar ke sebelah kiri array; Mengekalkan indeks terakhir dengan nilai positif; Jika elemen bukan sifar; Swap Indeks Semasa, dengan LastSeen Non - Zero; Elemen seterusnya akan terakhir dilihat bukan - sifar", "code": "def shiftAllZeroToLeft ( arr , n ) : NEW_LINE INDENT lastSeenNonZero = 0 NEW_LINE for index in range ( 0 , n ) : NEW_LINE INDENT if ( array [ index ] != 0 ) : NEW_LINE INDENT array [ index ] , array [ lastSeenNonZero ] = array [ lastSeenNonZero ] , array [ index ] NEW_LINE lastSeenNonZero += 1 NEW_LINE DEDENT DEDENT DEDENT"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Fungsi utiliti untuk mencetak pelbagai saiz n; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Jika elemen semasa positif tidak melakukan apa -apa; Jika elemen semasa adalah negatif, pergeseran elemen positif ARR [0. i - 1], ke satu kedudukan di sebelah kanan mereka; Letakkan elemen negatif pada kedudukan yang betul; Kod pemacu", "code": "def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if ( key > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Berfungsi untuk mencetak array; Fungsi untuk membalikkan array. Arahan boleh diterbalikkan dalam masa O (n) dan O (1) ruang. ; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]; Indeks awal Subarray 1 ST; Indeks awal IIND; arr [i. . M] adalah positif; arr [j. . r] adalah bahagian positif yang positif dari sub - array kiri (arr [i. m]); Bahagian negatif terbalik sub - array kanan (arr [m + 1 ... j - 1]); ARR terbalik [i. . J - 1]; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Kod pemacu", "code": "def printArray ( A , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def reverse ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE l , r = l + 1 , r - 1 NEW_LINE reverse ( arr , l , r ) NEW_LINE DEDENT DEDENT def merge ( arr , l , m , r ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE while i <= m and arr [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j <= r and arr [ j ] < 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT reverse ( arr , i , m ) NEW_LINE reverse ( arr , m + 1 , j - 1 ) NEW_LINE reverse ( arr , i , j - 1 ) NEW_LINE DEDENT def RearrangePosNeg ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE RearrangePosNeg ( arr , l , m ) NEW_LINE RearrangePosNeg ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE RearrangePosNeg ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Pelaksanaan Python pendekatan di atas; Gelung sehingga arr [i] <0 dan masih di dalam array; Gelung sehingga arr [j]> 0 dan masih di dalam array; jika saya kurang daripada j; Kod pemacu", "code": "def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( arr [ i ] < 0 and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE print ( * arr ) NEW_LINE"}
{"text": "Cari pemain untuk dapat menggantikan elemen terakhir yang boleh digantikan oleh pembahagi | Fungsi untuk mencari pemenang permainan yang dimainkan berdasarkan keadaan yang diberikan; Kemenangan jika saiz array adalah ganjil; Jika tidak, B menang; Kod pemacu; Arahan input; Saiz array", "code": "def winner ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 24 , 45 , 45 , 24 ] NEW_LINE N = len ( arr ) NEW_LINE winner ( arr , N ) NEW_LINE DEDENT"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Program Python untuk pendekatan di atas; Fungsi kepada jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua nilai yang mungkin x dan y, di mana y kurang daripada atau sama dengan sqrt (n). ; Melangkah ke atas semua kemungkinan nilai x; Precompute for all possible values of an expression such that y <= sqrt ( N ) ; Jika saya + j kurang daripada n; Kemas kini DP [i] [J]; Kemas kini DP [i] [J]; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; dp [x] [y]: menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array pertanyaan, q [] []; Jika y kurang daripada atau sama dengan sqrt (n); Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array, arr []; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "import math NEW_LINE sz = 20 NEW_LINE sqr = int ( math . sqrt ( sz ) ) + 1 NEW_LINE def precomputeExpressionForAllVal ( arr , N , dp ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( i + j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def querySum ( arr , N , Q , M ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( sz ) ] for x in range ( sqr ) ] NEW_LINE precomputeExpressionForAllVal ( arr , N , dp ) NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE if ( y <= math . sqrt ( N ) ) : NEW_LINE INDENT print ( dp [ x ] [ y ] ) NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 7 , 5 , 4 ] NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q [ 0 ] ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program Python3 untuk mencari semua elemen dalam array yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Pilih elemen satu demi satu dan hitung elemen yang lebih besar. Jika kiraan lebih daripada 2, cetak elemen itu. ; Kod pemacu", "code": "def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Mengasingkan Program Python 3 untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Sumber yang didorong", "code": "def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program Python3 untuk mencari semua elemen dalam pelbagai yang mempunyai dua elemen yang lebih besar sendiri. ; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "import sys NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE"}
{"text": "Kurangkan kiraan kenaikan setiap elemen subarray yang diperlukan untuk membuat array bukan | Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk membuat array tidak meningkat; Menyimpan kiraan operasi yang diperlukan; Jika arr [i]> arr [i + 1], tiada kenaikan diperlukan. Jika tidak, tambahkan perbezaannya kepada jawapannya; Mengembalikan hasil res; Kod pemacu", "code": "def getMinOps ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 1 , 2 ] NEW_LINE print ( getMinOps ( arr ) ) NEW_LINE"}
{"text": "Cari nombor yang paling kecil | Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; program pemacu untuk menguji fungsi di atas", "code": "def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest ▁ missing ▁ element ▁ is \" , findFirstMissing ( arr , 0 , n - 1 ) ) NEW_LINE"}
{"text": "Cari nombor yang paling kecil | Berfungsi untuk mencari elemen yang hilang; Perlawanan indeks dengan nilai pada indeks itu, bermakna elemen yang hilang tidak boleh sampai ke titik itu; Berfungsi untuk mencari yang paling kecil hilang dalam array yang disusun; Semak jika 0 hilang dalam array; Cek adalah semua nombor 0 hingga n - 1 adalah prsent dalam array; Kod pemacu; Panggilan fungsi", "code": "def findFirstMissing ( arr , start , end , first ) : NEW_LINE INDENT if ( start < end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( arr [ mid ] != mid + first ) : NEW_LINE INDENT return findFirstMissing ( arr , start , mid , first ) NEW_LINE DEDENT else : NEW_LINE INDENT return findFirstMissing ( arr , mid + 1 , end , first ) NEW_LINE DEDENT DEDENT return start + first NEW_LINE DEDENT def findSmallestMissinginSortedArray ( arr ) : NEW_LINE INDENT if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ - 1 ] == len ( arr ) - 1 ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE return findFirstMissing ( arr , 0 , len ( arr ) - 1 , first ) NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" First ▁ Missing ▁ element ▁ is ▁ : \" , findSmallestMissinginSortedArray ( arr ) ) NEW_LINE"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan | Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i (tidak ternary dalam python); Max semasa termasuk i; kembali max incl and excl; Program pemacu untuk menguji fungsi di atas", "code": "def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE INDENT new_excl = excl if excl > incl else incl NEW_LINE incl = excl + i NEW_LINE excl = new_excl NEW_LINE DEDENT return ( excl if excl > incl else incl ) NEW_LINE DEDENT arr = [ 5 , 5 , 10 , 100 , 10 , 5 ] NEW_LINE print find_max_sum ( arr ) NEW_LINE"}
{"text": "Langkah -langkah minimum untuk menukar semua laluan kiri ke bawah ke bawah dalam matriks sebagai palindrome | Tetapkan 2 | Fungsi untuk mengira bilangan perubahan minimum; Jarak elemen dari (0, 0) akan saya julat [0, n + m - 2]; Frekuensi kedai [0, 9] pada jarak saya memulakan semua dengan sifar; Mengira frekuensi [0, 9]; Kekerapan Kekerapan Matriks nilai [i] [j] pada jarak i + j; Cari nilai dengan kekerapan maksimum dan hitung jumlah sel pada jarak i dari hujung depan dan belakang belakang; Tukar semua nilai ke nilai dengan kekerapan maksimum; Kembalikan jawapannya; Kod pemacu; Diberikan matriks; Panggilan fungsi", "code": "def countChanges ( matrix , n , m ) : NEW_LINE INDENT dist = n + m - 1 NEW_LINE freq = [ [ 0 ] * 10 for i in range ( dist ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE INDENT maximum = 0 NEW_LINE total_values = 0 NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT min_changes_sum += ( total_values - maximum ) NEW_LINE DEDENT return min_changes_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 ] , [ 3 , 5 ] ] NEW_LINE print ( countChanges ( mat , 2 , 2 ) ) NEW_LINE DEDENT"}
{"text": "Jadual jarang | Program python3 untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Mengisi carian array carian [] [] dengan cara bawah. ; Memulakan m untuk selang dengan panjang 1; Mengira nilai dari selang yang lebih kecil hingga lebih besar; Kirakan nilai minimum untuk semua selang dengan saiz 2 ^ j; Untuk arr [2] [10], kami membandingkan arr [lookup [0] [7]] dan arr [lookup [3] [10]]; Mengembalikan minimum arr [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan minimum unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kami membandingkan arr [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Kod pemacu", "code": "import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while ( i + ( 1 << j ) - 1 ) < n : NEW_LINE INDENT if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE if lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] : NEW_LINE INDENT return lookup [ L ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return lookup [ R - ( 1 << j ) + 1 ] [ j ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE lookup = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 4 , 7 ) ) NEW_LINE print ( query ( 7 , 8 ) ) NEW_LINE DEDENT"}
{"text": "Jadual jarang | Program python3 untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Mengisi carian array carian [] [] dengan cara bawah. ; GCD elemen tunggal adalah elemen itu sendiri; Membina meja jarang; Mengembalikan minimum arr [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan GCD unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kita dapati GCD ARR [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Kod pemacu", "code": "import math NEW_LINE def buildSparseTable ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT table [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - ( 1 << j ) : NEW_LINE INDENT table [ i ] [ j ] = math . gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE return math . gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE table = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 2 ) ) NEW_LINE print ( query ( 1 , 3 ) ) NEW_LINE print ( query ( 4 , 5 ) ) NEW_LINE DEDENT"}
{"text": "Arahan terkecil lexicographically selepas di | Modifies arr [0 .. n - 1] kepada lexicographically terkecil dengan s swap. ; Tetapkan kedudukan di mana kami mahu meletakkan integer terkecil; Jika kita melebihi swap maksimum kemudian menamatkan gelung; Cari nilai minimum dari i + 1 hingga max (k atau n); Tukar unsur -unsur dari kedudukan minimum yang kami dapati hingga sekarang ke indeks I; Tetapkan nilai akhir selepas menukar elemen POS - I; Kod pemacu;  ; Cetak Array Akhir", "code": "def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT n , k = 5 , 3 NEW_LINE arr = [ 7 , 6 , 9 , 2 , 1 ] NEW_LINE / * Function calling * / NEW_LINE minimizeWithKSwaps ( arr , n , k ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"}
{"text": "Cari subarray purata maksimum K panjang | Pulangan permulaan indeks subarray purata maksimum panjang k; Semak jika 'k' sah; Buat dan isi array untuk menyimpan jumlah kumulatif. csum [i] menyimpan jumlah arr [0] ke arr [i]; Memulakan max_sm sebagai jumlah subarray pertama; Cari jumlah subarray lain dan kemas kini max_sum jika diperlukan. ; Indeks permulaan kembali; Program Pemandu", "code": "def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length \" , k , \" begins ▁ at ▁ index \" , findMaxAverage ( arr , n , k ) ) NEW_LINE"}
{"text": "Cari subarray purata maksimum K panjang | Pulangan permulaan indeks subarray purata maksimum panjang k; Semak jika 'k' sah; Mengira jumlah elemen 'k' pertama; Mengira jumlah subarray yang tinggal; Indeks permulaan kembali; Program Pemandu", "code": "def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length \" , k , \" begins ▁ at ▁ index \" , findMaxAverage ( arr , n , k ) ) NEW_LINE"}
{"text": "Skor minimum mungkin untuk pemain dengan memilih satu atau dua elemen array berturut -turut dari array binari yang diberikan | Menyimpan skor minimum untuk setiap negeri sebagai peta <pasangan <pos, myturn>, ans>; Berfungsi untuk mencari skor minimum selepas memilih elemen dari array; Mengembalikan keadaan yang disimpan; Kes asas; Pemain A 'S giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Pemain B 's giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Fungsi yang mendapati penalti minimum selepas memilih elemen dari array binari yang diberikan; Memulakan kedudukan memilih elemen dari array; 0 menandakan pemain A Turn 1 menandakan pemain B giliran; Panggilan fungsi; Cetak jawapan untuk Pemain A dan B; Penalti minimum; Hitung jumlah semua elemen ARR; Cetak skor minimum; Kod pemacu", "code": "m = dict ( ) NEW_LINE def findMinimum ( a , n , pos , myturn ) : NEW_LINE INDENT if ( pos , myturn ) in m : NEW_LINE INDENT return m [ ( pos , myturn ) ] ; NEW_LINE DEDENT if ( pos >= n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( not myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , not myturn ) + a [ pos ] + a [ pos + 1 ] ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if ( myturn ) : NEW_LINE INDENT ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) , findMinimum ( a , n , pos + 2 , not myturn ) ) ; NEW_LINE m [ ( pos , myturn ) ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT def countPenality ( arr , N ) : NEW_LINE INDENT pos = 0 ; NEW_LINE turn = False ; NEW_LINE return findMinimum ( arr , N , pos , turn ) + 1 ; NEW_LINE DEDENT def printAnswer ( arr , N ) : NEW_LINE INDENT a = countPenality ( arr , N ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printAnswer ( arr , N ) ; NEW_LINE DEDENT"}
{"text": "Jumlah nombor utama dalam julat [l, r] dari array yang diberikan untuk pertanyaan q | Program Python3 untuk pendekatan di atas; Buat Boolean Array Prime [] dan Inisialisasi semua entinya sebagai benar nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan Perdana; Berfungsi untuk mencari nombor utama; Semak jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan; Berfungsi untuk mendapatkan indeks pertengahan dari indeks sudut; Berfungsi untuk mendapatkan jumlah nilai dalam julat array yang diberikan; Jika segmen nod ini adalah sebahagian daripada julat yang diberikan, maka kembalikan jumlah segmen; Jika segmen nod ini berada di luar julat yang diberikan; Jika sebahagian daripada segmen ini bertindih dengan julat yang diberikan; Fungsi untuk mengemas kini nod yang mempunyai indeks yang diberikan dalam julatnya; Jika indeks input terletak di luar julat segmen ini; Jika indeks input berada dalam julat nod ini, maka kemas kini nilai nod dan anak -anaknya; Berfungsi untuk mengemas kini nilai dalam array input dan pokok segmen; Semak indeks imput yang salah; Dapatkan perbezaan antara nilai baru dan nilai lama; Kemas kini nilai dalam array; Kemas kini nilai nod dalam pokok segmen hanya jika sama ada nilai sebelumnya atau nilai baru atau kedua -duanya adalah perdana; Jika hanya nilai baru adalah perdana; Jika hanya nilai lama adalah perdana; Jika kedua -duanya adalah perdana; Pulangan Jumlah Elemen dalam Julat dari Indeks QS (Permulaan Permintaan) ke QE (End Query). Ia terutamanya menggunakan getSumutil (); Semak nilai input yang salah; Fungsi yang membina pokok segmen; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Hanya tambah unsur -unsur dalam pokok segmen yang utama; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan jumlah nilai dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Panggilan fungsi; Membina pokok segmen dari array yang diberikan; Cetak jumlah nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 10 dan kemas kini nod pokok segmen yang sepadan; Cari jumlah selepas nilai dikemas kini", "code": "import math NEW_LINE MAX = 1000001 NEW_LINE prime = [ True ] * MAX NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT def getSumUtil ( st , ss , se , qs , qe , si ) : NEW_LINE INDENT if qs <= ss and qe >= se : NEW_LINE INDENT return st [ si ] NEW_LINE DEDENT if se < qs or ss > qe : NEW_LINE INDENT return 0 NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE return ( getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ) NEW_LINE DEDENT def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE INDENT if i < ss or i > se : NEW_LINE INDENT return NEW_LINE DEDENT st [ si ] = st [ si ] + diff NEW_LINE if se != ss : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT DEDENT def updateValue ( arr , st , n , i , new_val ) : NEW_LINE INDENT if i < 0 or i > n - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT diff = new_val - arr [ i ] NEW_LINE prev_val = arr [ i ] NEW_LINE arr [ i ] = new_val NEW_LINE if prime [ new_val ] or prime [ prev_val ] : NEW_LINE INDENT if not prime [ prev_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) NEW_LINE DEDENT elif not prime [ new_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT DEDENT DEDENT def getSum ( st , n , qs , qe ) : NEW_LINE INDENT if qs < 0 or qe > n - 1 or qs > qe : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) NEW_LINE DEDENT def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE INDENT if ss == se : NEW_LINE INDENT if prime [ arr [ ss ] ] : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT mid = getMid ( ss , se ) NEW_LINE st [ si ] = ( constructSTUtil ( arr , ss , mid , st , 2 * si + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , 2 * si + 2 ) ) NEW_LINE return st [ si ] NEW_LINE DEDENT def constructST ( arr , n ) : NEW_LINE INDENT x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE max_size = 2 * int ( pow ( 2 , x ) ) - 1 NEW_LINE st = [ 0 ] * max_size NEW_LINE constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE return st NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 9 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE Q = [ [ 1 , 1 , 3 ] , [ 2 , 1 , 10 ] , [ 1 , 1 , 3 ] ] NEW_LINE SieveOfEratosthenes ( ) NEW_LINE st = constructST ( arr , n ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE updateValue ( arr , st , n , 1 , 10 ) NEW_LINE print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE"}
{"text": "Kira bilangan cara untuk membina rentetan sasaran | Program Python 3 untuk mengira bilangan cara untuk membina rentetan sasaran; Kes asas; Jika subproblem semasa telah diselesaikan, gunakan nilai; watak semasa; Cari melalui semua yang ditunjukkan di mana watak semasa berlaku. Untuk setiap indeks yang lebih besar daripada sebelumnya, ambil indeks dan bergerak ke kedudukan seterusnya, dan tambahkan jawapannya. ; Simpan dan kembalikan penyelesaian untuk subproblem ini; PREPROCESS THE RINGS DENGAN MENYEDIAKAN UNTUK SETIAP KARAKTER SETIAP RENTING, INDEKS KELUARGA MEREKA KAMI AKAN MENGGUNAKAN SENARAI BERHUBUNGAN UNTUK SEMUA SETIAP HANYA SAHAJA INDEKS DALAM RENCEN DENGAN Watak dipilih; Kami menyimpan J + 1 kerana indeks yang dipilih awal dalam langkah rekursif akan NE 0. Ini hanya untuk kemudahan pelaksanaan; Inisiasi jadual DP. - 1 mewakili bahawa subproblem tidak diselesaikan; Kod pemacu", "code": "mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE INDENT if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE return dp [ pos ] [ prev ] NEW_LINE DEDENT def countWays ( a , s ) : NEW_LINE INDENT n = len ( a ) NEW_LINE index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE DEDENT DEDENT return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT"}
{"text": "Count of integer dari julat [0, n] yang jumlah digitnya adalah pelbagai k | Python 3 pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan nombor dari julat [0, n] yang jumlah digitnya adalah pelbagai k menggunakan dp bawah; Digit dalam indeks ini hanya boleh dari [0, num [idx]]; Digit dalam indeks ini boleh menjadi apa -apa dari [0, 9]; new_tight adalah nilai bendera untuk kedudukan seterusnya; Res tidak boleh menjadi negatif; Berfungsi untuk memproses rentetan ke vektor digit dari MSD ke LSD; Kod pemacu; Untuk nombor input besar n; Jumlah bilangan digit dalam n; Untuk menyimpan negeri -negeri DP; Proses rentetan ke vektor digit dari MSD ke LSD", "code": "MAX = 10005 NEW_LINE MOD = 1000000007 NEW_LINE def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE DEDENT if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"98765432109876543210\" NEW_LINE len1 = len ( n ) NEW_LINE k = 58 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ] NEW_LINE num = process ( n ) NEW_LINE print ( countNum ( 0 , 0 , 0 , num , len1 , k ) ) NEW_LINE DEDENT"}
{"text": "Double Knapsack | Pengaturcaraan Dinamik | W1_R mewakili kapasiti selebihnya 1 stnapsack w2_r mewakili kapasiti selebihnya 2 nd knapsack I mewakili indeks array arr yang kami sedang kerjakan; Kes asas; Pembolehubah untuk menyimpan hasil tiga bahagian hubungan berulang; Simpan negeri dalam array 3d; Kod pemacu; Arahan input; Arahan 3D untuk menyimpan negeri -negeri DP; Bilangan elemen dalam array; Kapasiti knapsacks; Berfungsi untuk dipanggil", "code": "def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE n = len ( arr ) NEW_LINE w1 , w2 = 10 , 3 NEW_LINE print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE DEDENT"}
{"text": "Laluan Perdana Lexicographically terbesar dari atas | Python3 pelaksanaan pendekatan di atas; Carian pertama kedalaman; Kembali jika sel mengandungi nombor bukan perdana atau halangan, atau keluar dari matriks atau sudah melawat sel atau sudah menemui jalan terbesar leksikografi; Penandaan sel sudah dikunjungi; menyimpan indeks laluan terbesar leksikografi; jika sampai ke akhir matriks; mengemas kini bilangan akhir langkah dalam laluan terbesar leksikografi; bergerak pepenjuru (mencuba laluan terbesar leksikografi); menggerakkan sel ke sel semasa; bergerak sel ke sel semasa. ; Cetak jalan utama lexicographical terbesar; Untuk mengira bilangan langkah dalam laluan utama terbesar leksikografi; Untuk menyimpan indeks jalan utama terbesar lexicographical; Untuk menandakan jika sel sudah dilalui atau tidak; melintasi DFS; mencetak laluan utama terbesar lexicographical; Kembalikan bilangan jalan utama dalam matriks. ; untuk setiap sel; Jika di barisan atas atau lajur paling kiri, tidak ada jalan di sana. ; Jika nombor bukan perdana; Mencari pemetaan matriks dengan mempertimbangkan nombor bukan perdana sebagai halangan dan nombor utama menjadi laluan yang sah. ; Ayak; Jika Perdana; jika bukan Perdana; Kod pemacu", "code": "MAX = 105 NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def dfs ( i , j , k , q , n , m ) : NEW_LINE INDENT if ( mappedMatrix [ i ] [ j ] == 0 or i > n or j > m or mark [ i ] [ j ] or q != 0 ) : NEW_LINE INDENT return q ; NEW_LINE DEDENT mark [ i ] [ j ] = 1 ; NEW_LINE ans [ k ] = [ i , j ] NEW_LINE if ( i == n and j == m ) : NEW_LINE INDENT q = k ; NEW_LINE return q ; NEW_LINE DEDENT q = dfs ( i + 1 , j + 1 , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i + 1 , j , k + 1 , q , n , m ) ; NEW_LINE q = dfs ( i , j + 1 , k + 1 , q , n , m ) ; NEW_LINE return q NEW_LINE DEDENT def lexicographicalPath ( n , m ) : NEW_LINE INDENT q = 0 ; NEW_LINE global ans , mark NEW_LINE ans = [ [ 0 , 0 ] for i in range ( MAX ) ] NEW_LINE mark = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE q = dfs ( 1 , 1 , 1 , q , n , m ) ; NEW_LINE for i in range ( 1 , q + 1 ) : NEW_LINE INDENT print ( str ( ans [ i ] [ 0 ] ) + ' ▁ ' + str ( ans [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT def countPrimePath ( n , m ) : NEW_LINE INDENT global dp NEW_LINE dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( i == 1 and j == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; NEW_LINE if ( mappedMatrix [ i ] [ j ] == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ m ] ) NEW_LINE DEDENT def preprocessMatrix ( a , n , m ) : NEW_LINE INDENT global prime NEW_LINE prime = [ 0 for i in range ( MAX ) ] NEW_LINE sieve ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( prime [ a [ i ] [ j ] ] == 0 ) : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 2 , 3 , 7 ] , [ 5 , 4 , 2 ] , [ 3 , 7 , 11 ] ] ; NEW_LINE mappedMatrix = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE preprocessMatrix ( a , n , m ) ; NEW_LINE countPrimePath ( n , m ) ; NEW_LINE lexicographicalPath ( n , m ) ; NEW_LINE DEDENT"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset + nilai subset maksimal. Pulangan saiz subset bersaiz maksimum jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan. Ia kembali - 1 jika tidak ada subset dengan jumlah yang diberikan. ; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Kod pemacu", "code": "def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE count = [ [ 0 for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE count [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE count [ i ] [ 0 ] = - 1 NEW_LINE DEDENT for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE count [ i ] [ j ] = count [ i ] [ j - 1 ] NEW_LINE if ( i >= arr [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE if ( subset [ i ] [ j ] ) : NEW_LINE INDENT count [ i ] [ j ] = ( max ( count [ i ] [ j - 1 ] , count [ i - arr [ j - 1 ] ] [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count [ sum ] [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 10 ] NEW_LINE sum = 20 NEW_LINE n = 4 NEW_LINE print ( isSubsetSum ( arr , n , sum ) ) NEW_LINE DEDENT"}
{"text": "Cetak semua sub biasa terpanjang | Program Python3 untuk mencari semua LCS dua rentetan dalam urutan yang disusun. ; Matriks DP untuk menyimpan hasil sub panggilan untuk LCS; Fungsi berasaskan memoisasi yang mengembalikan LCS STR1 [i. . len1 - 1] dan str2 [j. . len2 - 1]; keadaan asas; Jika LCS telah dikira; Jika watak -watak yang sama pulangan sebelumnya + 1 lain max dua urutan selepas mengeluarkan i 'th »dan u' th char satu demi satu; Berfungsi untuk laluan prall sub - urutan panjang lcslen panjang; jika currlcs sama dengan lcslen maka prit; Jika kita selesai dengan semua watak kedua -dua rentetan; Di sini kita perlu mengamalkan sub -urutan secara leksik, bahawa mengapa kita mula dari 'A' ke 'z' jika watak ini hadir di kedua -dua mereka kemudian memasukkannya ke dalam data [] dan bahagian yang sama; Selesai adalah bendera untuk memberitahu bahawa kami telah mencetak semua berikutnya yang sepadan dengan watak semasa; Jika watak CH hadir dalam STR1 maka periksa sama ada ia terdapat dalam STR2; Jika CH hadir dalam kedua -dua mereka dan baki panjang adalah sama dengan panjang LCS yang tinggal kemudian tambah CH dalam sub -sequenece; Jika kami mendapati LCS bermula dengan watak semasa. ; Fungsi ini mencetak semua LCS Str1 dan Str2 dalam urutan leksikografi. ; Cari panjang kedua -dua rentetan; Cari panjang LCS; LCS Prall menggunakan data backtracking rekursif [] digunakan untuk menyimpan LCS individu. ; Program pemacu untuk menjalankan kes itu", "code": "MAX = 100 NEW_LINE lcslen = 0 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def lcs ( str1 , str2 , len1 , len2 , i , j ) : NEW_LINE INDENT if ( i == len1 or j == len2 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ret = 0 NEW_LINE if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ret NEW_LINE return ret NEW_LINE DEDENT def printAll ( str1 , str2 , len1 , len2 , data , indx1 , indx2 , currlcs ) : NEW_LINE INDENT if ( currlcs == lcslen ) : NEW_LINE INDENT print ( \" \" . join ( data [ : currlcs ] ) ) NEW_LINE return NEW_LINE DEDENT if ( indx1 == len1 or indx2 == len2 ) : NEW_LINE INDENT return NEW_LINE DEDENT for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT done = False NEW_LINE for i in range ( indx1 , len1 ) : NEW_LINE INDENT if ( chr ( ch ) == str1 [ i ] ) : NEW_LINE for j in range ( indx2 , len2 ) : NEW_LINE INDENT if ( chr ( ch ) == str2 [ j ] and dp [ i ] [ j ] == lcslen - currlcs ) : NEW_LINE data [ currlcs ] = chr ( ch ) NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) NEW_LINE done = True NEW_LINE break NEW_LINE DEDENT if ( done ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT def prinlAllLCSSorted ( str1 , str2 ) : NEW_LINE INDENT global lcslen NEW_LINE len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) NEW_LINE data = [ ' a ' for i in range ( MAX ) ] NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abcabcaa \" NEW_LINE str2 = \" acbacba \" NEW_LINE prinlAllLCSSorted ( str1 , str2 ) NEW_LINE DEDENT"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program Python3 untuk menyemak unsur majoriti dalam pelbagai disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Program pemacu untuk menyemak fungsi di atas", "code": "def isMajority ( arr , n , x ) : NEW_LINE INDENT last_index = ( n // 2 + 1 ) if n % 2 == 0 else ( n // 2 ) NEW_LINE for i in range ( last_index ) : NEW_LINE INDENT if arr [ i ] == x and arr [ i + n // 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( \" % ▁ d ▁ appears ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] \" % ( x , n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" % ▁ d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] \" % ( x , n // 2 ) ) NEW_LINE DEDENT"}
{"text": "Semak elemen majoriti dalam array yang disusun | Jika x hadir dalam arr [rendah ... tinggi] maka mengembalikan indeks kejadian pertama x, jika tidak pulangan - 1; Semak jika ARR [MID] adalah kejadian pertama x. arr [pertengahan] adalah kejadian pertama jika x adalah salah satu daripada yang berikut adalah benar: (i) pertengahan == 0 dan arr [mid] = = x (ii) arr [pertengahan - 1] <x dan arr [mid] == x; Fungsi ini kembali benar jika x hadir lebih daripada n / 2 kali dalam arr [] saiz n; Cari indeks kejadian pertama x dalam arr []; Jika elemen tidak hadir sama sekali, kembali palsu; periksa sama ada elemen hadir lebih daripada n / 2 kali", "code": "def _binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid == 0 or x > arr [ mid - 1 ] ) and ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif x > arr [ mid ] : NEW_LINE INDENT return _binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return _binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def isMajority ( arr , n , x ) : NEW_LINE INDENT i = _binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( i + n // 2 ) <= ( n - 1 ) ) and arr [ i + n // 2 ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT"}
{"text": "Semak elemen majoriti dalam array yang disusun |  ; Kod pemacu", "code": "def isMajorityElement ( arr , n , key ) : NEW_LINE INDENT if ( arr [ n // 2 ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE if ( isMajorityElement ( arr , n , x ) ) : NEW_LINE INDENT print ( x , \" ▁ appears ▁ more ▁ than ▁ \" , n // 2 , \" ▁ times ▁ in ▁ arr [ ] \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , \" ▁ does ▁ not ▁ appear ▁ more ▁ than \" , n // 2 , \" ▁ times ▁ in ▁ arr [ ] \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "INT_MIN = - 32767 NEW_LINE def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + str ( cutRod ( arr , size ) ) ) NEW_LINE"}
{"text": "Ubah suai array ke array lain yang diberikan dengan menggantikan elemen array dengan jumlah array | Fungsi untuk memeriksa sama ada arr [] boleh ditukar kepada sasaran [] dengan menggantikan mana -mana elemen dalam arr [] dengan jumlah arr []; Simpan elemen maksimum; Simpan indeks elemen maksimum; Melintasi sasaran array []; Jika elemen semasa lebih besar daripada maks; Jika elemen max adalah 1; Melintasi array, sasaran []; Jika indeks semasa tidak sama dengan indeks elemen maksimum; Kemas kini Max; Jika max kurang daripada atau sama dengan 0 ,; Mengemas kini elemen maksimum; Memanggil semula fungsi secara rekursif; Kod pemacu", "code": "def isPossible ( target ) : NEW_LINE INDENT max = 0 NEW_LINE index = 0 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if ( max < target [ i ] ) : NEW_LINE max = target [ i ] NEW_LINE index = i NEW_LINE DEDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if ( i != index ) : NEW_LINE max -= target [ i ] NEW_LINE if ( max <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT target [ index ] = max NEW_LINE return isPossible ( target ) NEW_LINE DEDENT target = [ 9 , 3 , 5 ] NEW_LINE res = isPossible ( target ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Kod pemacu", "code": "def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 NEW_LINE print ( nCr ( n + m , k ) ) NEW_LINE DEDENT"}
{"text": "Semak jika n boleh didapati dari 1 dengan mengulangi secara berulang dengan 10 atau 20 | Program python untuk memeriksa sama ada n boleh diperolehi dari 1 dengan pendaraban berulang sebanyak 10 atau 20; Fungsi untuk memeriksa sama ada n boleh diperoleh atau tidak; Mengira dan mengeluarkan sifar trailing; Semak jika baki N adalah kuasa 2; Untuk memeriksa keadaan untuk mencetak ya atau tidak; Program Pemandu", "code": "import math NEW_LINE def Is_possible ( N ) : NEW_LINE INDENT C = 0 NEW_LINE D = 0 NEW_LINE while ( N % 10 == 0 ) : NEW_LINE INDENT N = N / 10 NEW_LINE C += 1 NEW_LINE DEDENT if ( math . log ( N , 2 ) - int ( math . log ( N , 2 ) ) == 0 ) : NEW_LINE INDENT D = int ( math . log ( N , 2 ) ) NEW_LINE if ( C >= D ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT N = 2000000000000 NEW_LINE Is_possible ( N ) NEW_LINE"}
{"text": "Nombor Poligonal Tengah | Fungsi untuk mencari istilah n - th dalam siri ini; Kod pemacu", "code": "def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE"}
{"text": "Program untuk mencetak Siri 1, 3, 4, 8, 15, 27, 50 â € | Sehingga N Syarat | Berfungsi untuk mencetak siri; Menjana istilah ith dan mencetaknya; Kod pemacu; Panggilan fungsi", "code": "def printSeries ( n , a , b , c ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( a , b , end = \" ▁ \" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( a , b , c , end = \" ▁ \" ) ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = a + b + c ; NEW_LINE print ( d , end = \" ▁ \" ) ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE c = d ; NEW_LINE DEDENT DEDENT N = 7 ; a = 1 ; b = 3 ; NEW_LINE c = 4 ; NEW_LINE printSeries ( N , a , b , c ) ; NEW_LINE"}
{"text": "Diameter pokok terindeks binari dengan nod n | Berfungsi untuk mencari diameter bit dengan n + 1 nod; L adalah saiz subtree sebelum subtree di mana n terletak; H ialah ketinggian subtree sebelum subtree di mana n terletak; Kes asas; Saiz subtree adalah kuasa 2; 3 kes seperti yang dijelaskan dalam pendekatan; Kod pemacu", "code": "def diameter ( n ) : NEW_LINE INDENT L , H , templen = 0 , 0 , 0 ; NEW_LINE L = 1 ; NEW_LINE H = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT while ( L * 2 <= n ) : NEW_LINE INDENT L *= 2 ; NEW_LINE H += 1 ; NEW_LINE DEDENT if ( n >= L * 2 - 1 ) : NEW_LINE INDENT return 2 * H + 1 ; NEW_LINE DEDENT elif ( n >= L + ( L / 2 ) - 1 ) : NEW_LINE INDENT return 2 * H ; NEW_LINE DEDENT return 2 * H - 1 ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( diameter ( n ) ) ; NEW_LINE"}
{"text": "Cari eksponen yang lebih besar di antara dua eksponen | Pelaksanaan Python3 pendekatan; Fungsi untuk mencari sama ada A ^ B lebih besar atau c ^ d; Cari b * log (a); Cari d * log (c); Bandingkan kedua -dua nilai; Kod pemacu", "code": "import math NEW_LINE def compareValues ( a , b , c , d ) : NEW_LINE INDENT log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE if num1 > num2 : NEW_LINE INDENT print ( a , ' ^ ' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , ' ^ ' , d ) NEW_LINE DEDENT DEDENT a = 8 NEW_LINE b = 29 NEW_LINE c = 60 NEW_LINE d = 59 NEW_LINE compareValues ( a , b , c , d ) NEW_LINE"}
{"text": "Jumlah nombor perdana tanpa digit utama yang ganjil | Program Python3 untuk pendekatan di atas; Cari semua nombor utama; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada digit adalah perdana ganjil atau tidak; Berfungsi untuk mencari jumlah; Untuk menyimpan jawapan yang diperlukan; Dapatkan semua nombor utama; Melintasi semua nombor perdana; Kedai bendera 1 Jika nombor tidak mengandungi sebarang prima yang ganjil; Cari semua digit nombor; Jika nombor tidak mengandungi sebarang prima yang ganjil; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "MAX = 100005 NEW_LINE def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def find_Sum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE v = addPrimes ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT flag = 1 NEW_LINE a = v [ i ] NEW_LINE while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a // 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT n = 7 NEW_LINE print ( find_Sum ( n ) ) NEW_LINE"}
{"text": "Kira bilangan prima dalam array jumlah awalan array yang diberikan | Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari semua prima di arr []; Berfungsi untuk menghasilkan array awalan; Isi array awalan; Kod pemacu; Arahan awalan arr []; Count of Prima dalam Array Awalan", "code": "def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT"}
{"text": "Nilai minimum yang akan ditambah kepada x supaya sekurang -kurangnya y peratus daripada n | Pelaksanaan Python pendekatan; Fungsi untuk mengembalikan nilai yang diperlukan yang mesti ditambah kepada x supaya sekurang -kurangnya y peratus daripada n; Nilai yang diperlukan; Jika x sudah> = y peratus n; Kod pemacu", "code": "import math NEW_LINE def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT n = 10 ; x = 2 ; y = 40 NEW_LINE print ( minValue ( n , x , y ) ) NEW_LINE"}
{"text": "Semak jika n adalah faktorial utama | Program Python3 untuk memeriksa sama ada nombor yang diberikan adalah perdana faktorial; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah faktorial utama; Jika n tidak perdana maka kembali palsu; Hitung faktorial; Jika n adalah perdana faktorial; n bukanlah perdana faktorial; Kod pemacu", "code": "from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isFactorialPrime ( n ) : NEW_LINE INDENT if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Susunan tempat duduk N Boys and Girls secara alternatif di sekitar meja bulat | Dapatkan n; Cari FAC1 = (n - 1)! ; Cari FAC2 = N! ; Cari jumlah cara; Cetak jumlah cara", "code": "n = 5 NEW_LINE fac1 = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE DEDENT fac2 = fac1 * n NEW_LINE totalWays = fac1 * fac2 NEW_LINE print ( totalWays ) NEW_LINE"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program Python 3 untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor perdana; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan semua nombor utama ke vektor 'arr; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Masukkan nombor perdana seterusnya dan periksa sama ada produk + 1 = n memegang atau tidak; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Cube sempurna lebih besar daripada nombor tertentu | Python 3 pelaksanaan pendekatan di atas; Berfungsi untuk mencari kiub sempurna seterusnya; Kod pemacu", "code": "from math import * NEW_LINE def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT"}
{"text": "Jumlah semua pembahagi utama nombor | Program Python3 untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kembali jenis fungsi SQRT jika terapung; Kedua -dua faktor adalah sama; Kedua -dua faktor tidak sama (i dan n / i); Kod pemacu", "code": "import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE root_n = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root_n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( int ) ( n / i ) and isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT if ( isPrime ( ( int ) ( n / i ) ) ) : NEW_LINE INDENT Sum += ( int ) ( n / i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Sum NEW_LINE DEDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is \" , SumOfPrimeDivisors ( n ) ) NEW_LINE"}
{"text": "Kedudukan N di antara nombor yang diperbuat daripada 2, 3, 5 & 7 | Kedudukan program N di antara nombor yang diperbuat daripada 2, 3, 5 & 7; Jika nombor adalah 2 maka ia berada di kedudukan pos * 2 + 1; Jika nombor adalah 3 maka ia berada di kedudukan pos * 2 + 2; Jika nombor adalah 5 maka ia berada di kedudukan pos * 2 + 3; Jika nombor adalah 7 maka ia berada di kedudukan pos * 2 + 4; Kod pemacu", "code": "def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT n = \"777\" NEW_LINE print ( findpos ( n ) ) NEW_LINE"}
{"text": "Mencari Co Transitif | Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Kes 1: Kurang daripada 3 nombor antara L dan R; Kes 2: Lebih daripada 3 nombor antara L dan R; Triplet harus selalu menjadi bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.1: Tepat 3 nombor dalam julat bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.2: Tepat 3 nombor dalam julat bentuk (2 k - 1, 2 k, 2 k + 1); Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( \" ( \" , possibleA , \" , \" , possibleB , \" , \" , possibleC , \" ) ▁ is ▁ one ▁ such \" , \" possible ▁ triplet ▁ between \" , L , \" and \" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No ▁ Such ▁ Triplet ▁ exists ▁ between \" , L , \" and \" , R ) ; NEW_LINE DEDENT DEDENT L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE"}
{"text": "Count n digit nombor tidak mempunyai digit tertentu | Pelaksanaan python kaedah di atas; Mencari bilangan nombor yang mungkin dengan digit N tidak termasuk digit tertentu; Memeriksa jika bilangan digit adalah sifar; Memeriksa jika bilangan digit adalah satu; Memeriksa jika bilangan digit adalah ganjil; Memanggil fungsi digitNumber dengan (digit - 1) / 2 digit; Memanggil fungsi digitnumber dengan n / 2 digit; Memanggil fungsi DigitNumber Memeriksa jika tidak termasuk digit adalah sifar atau bukan sifar; Memulakan pembolehubah", "code": "mod = 1000000007 NEW_LINE def digitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE DEDENT DEDENT def countExcluding ( n , d ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT DEDENT d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE"}
{"text": "Semak jika nombor yang diberikan adalah nombor emirp atau tidak | Pulangan benar jika n adalah perdana. Lain palsu. ; Kes sudut; Semak dari 2 hingga n - 1; Fungsi akan memeriksa sama ada nombor adalah emirp atau tidak; Semak jika n adalah perdana; Cari terbalik n; Jika kedua -dua asal dan terbalik adalah perdana, maka ia adalah nombor emirp; Nombor input", "code": "def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return isPrime ( rev ) NEW_LINE DEDENT n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Program untuk menukar radian ke ijazah | Fungsi untuk penukaran; Kod pemacu", "code": "def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT radian = 5 NEW_LINE print ( \" degree ▁ = \" , ( Convert ( radian ) ) ) NEW_LINE"}
{"text": "Cari jejak matriks yang dibentuk dengan menambah baris | Kembali jumlah integer pertama A AP; Kembalikan jejak jumlah baris - matriks utama dan lajur - matriks utama; Mencari elemen ke dalam AP sekiranya matriks utama baris. ; Mencari jumlah integer pertama AP dalam kes matriks utama baris; Mencari elemen ke dalam AP sekiranya matriks utama baris; Mencari jumlah integer pertama AP dalam kes matriks utama lajur; Kod pemacu", "code": "def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE rowmajorSum = sn ( n , an ) ; NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE"}
{"text": "Maksimum kawasan yang paling kecil yang boleh diperoleh dengan tepat K yang diberikan segi empat tepat | Fungsi utiliti; untuk kes 1 st; untuk kes kedua; Hasil akhir cetak; kod pemacu", "code": "def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( \" Not ▁ possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE m = 4 NEW_LINE k = 1 NEW_LINE max_area ( n , m , k ) NEW_LINE"}
{"text": "Program untuk mencari kawasan persegi | berfungsi untuk mencari kawasan; Program Pemandu", "code": "def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT side = 4 NEW_LINE area = area_fun ( side ) NEW_LINE print ( area ) NEW_LINE"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah nombor berturut -turut | Kaedah utiliti untuk mengira bilangan cara di mana n boleh diwakili sebagai jumlah nombor berturut -turut; Kekangan pada nilai L memberi kita kerumitan masa sebagai O (n ^ 0.5); Kod pemacu", "code": "def countConsecutive ( N ) : NEW_LINE INDENT count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT N = 15 NEW_LINE print countConsecutive ( N ) NEW_LINE N = 10 NEW_LINE print countConsecutive ( N ) NEW_LINE"}
{"text": "Nombor Automorphic | Berfungsi untuk memeriksa nombor automorphic; Simpan dataran; Mula membandingkan digit; Kembali palsu, jika mana -mana digit dari n tidak sesuai dengan angka -angka yang terakhir; Mengurangkan N dan persegi; Kod pemacu", "code": "def isAutomorphic ( N ) : NEW_LINE INDENT sq = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N /= 10 NEW_LINE sq /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print \" Automorphic \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Not ▁ Automorphic \" NEW_LINE DEDENT"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Nilai lalai boolean adalah palsu; Ayak eratosthenes; Menyimpan nombor perdana. ; Nombor penjanaan yang mempunyai faktor utama maksimum. ; Kod pemacu", "code": "def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ True ] * ( N + 5 ) ; NEW_LINE i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE"}
{"text": "Cari akar persegi di bawah modulo p | Tetapkan 1 (apabila p dalam bentuk 4 * i + 3) | Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p. ; res = 1 Inisialisasi hasil x = x % p kemas kini x jika lebih daripada atau sama dengan p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1 y = y / 2; Pulangan benar jika akar persegi n di bawah modulo p wujud. Asumsi: P adalah bentuk 3 * i + 4 di mana i> = 1; Cuba \" + (n ^ ((p ~ ~ 1) / 4))\"; Cuba \" - (n '((p ~ ~ 1) / 4))\"; Sekiranya tiada dua kerja di atas, maka akar persegi tidak wujud; Kod pemacu", "code": "def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def squareRoot ( n , p ) : NEW_LINE INDENT if ( p % 4 != 3 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return NEW_LINE DEDENT n = n % p NEW_LINE x = power ( n , ( p + 1 ) // 4 , p ) NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( \" Square ▁ root ▁ is ▁ \" , x ) NEW_LINE return NEW_LINE DEDENT x = p - x NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( \" Square ▁ root ▁ is ▁ \" , x ) NEW_LINE return NEW_LINE DEDENT print ( \" Square ▁ root ▁ doesn ' t ▁ exist ▁ \" ) NEW_LINE DEDENT p = 7 NEW_LINE n = 2 NEW_LINE squareRoot ( n , p ) NEW_LINE"}
{"text": "Ujian Primal | Tetapkan 3 (Millerâ € \"Rabin) | Program Python3 Miller - Rabin Primality Test; Fungsi Utiliti untuk Melakukan Eksponen Modular. pulangan palsu jika n adalah prime. bukanlah N-1 Komposit;", "code": "import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def miillerTest ( d , n ) : NEW_LINE INDENT a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT k = 4 ; NEW_LINE print ( \" All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ \" ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT"}
{"text": "Panjang paling lama berturut -turut 1 s dalam perwakilan binari | Berfungsi untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor; Memulakan hasil; Kira bilangan lelaran untuk mencapai x = 0 .; Operasi ini mengurangkan panjang setiap urutan 1 s dengan satu. ; Kod pemacu", "code": "def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program Python untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu", "code": "def subtract ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT borrow = ( ~ x ) & y NEW_LINE x = x ^ y NEW_LINE y = borrow << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( \" x ▁ - ▁ y ▁ is \" , subtract ( x , y ) ) NEW_LINE"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program Python untuk menolak dua nombor tanpa menggunakan pelaksanaan rekursif pengendali aritmetik. ; Program Pemandu", "code": "def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT x = 29 NEW_LINE y = 13 NEW_LINE print ( \" x ▁ - ▁ y ▁ is \" , subtract ( x , y ) ) NEW_LINE"}
{"text": "Kth nenek moyang semua nod dalam n | Berfungsi untuk menambah kelebihan di dalam pokok; DFS untuk mencari nenek moyang Kth setiap nod; Menolak nod semasa dalam vektor; Melintasi jirannya; Jika n nenek moyang tidak dijumpai untuk nod semasa; Tambah nenek moyang KTH untuk nod; Berfungsi untuk mencari nenek moyang setiap nod; Membina pokok; Menyimpan semua ibu bapa nod; Simpan nenek moyang semua nod; Cetak nenek moyang; Kod pemacu; Diberikan n dan k; Diberi tepi pokok n - ary; Panggilan fungsi", "code": "def addEdge ( v , x , y ) : NEW_LINE INDENT v [ x ] . append ( y ) NEW_LINE v [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( tree , temp , ancestor , u , parent , k ) : NEW_LINE INDENT temp . append ( u ) NEW_LINE for i in tree [ u ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( tree , temp , ancestor , i , u , k ) NEW_LINE DEDENT temp . pop ( ) NEW_LINE if ( len ( temp ) < k ) : NEW_LINE INDENT ancestor [ u ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ancestor [ u ] = temp [ len ( temp ) - k ] NEW_LINE DEDENT DEDENT def KthAncestor ( N , K , E , edges ) : NEW_LINE INDENT tree = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT temp = [ ] NEW_LINE ancestor = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( tree , temp , ancestor , 1 , 0 , K ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ancestor [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE K = 2 NEW_LINE E = 8 NEW_LINE edges = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 7 ] , [ 3 , 8 ] , [ 3 , 9 ] ] NEW_LINE KthAncestor ( N , K , E , edges ) NEW_LINE DEDENT"}
{"text": "Pertanyaan untuk mengira elemen array lebih besar daripada atau sama dengan nombor tertentu dengan kemas kini | Berfungsi untuk membina pokok segmen; Semak kes asas; Cari titik pertengahan; Secara rekursif membina pokok segmen; Fungsi untuk menolak operasi pada pokok segmen; Berfungsi untuk mengemas kini pokok segmen; Tumpang tindih lengkap; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Mengemas kini pokok segmen secara rekursif; Berfungsi untuk memproses pertanyaan; Kes asas; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Secara rekursif mengira hasil pertanyaan; Mengembalikan hasilnya; Fungsi untuk mengira nombor yang lebih besar daripada pertanyaan yang diberikan; Susun array input; Buat pokok segmen saiz 4 * n vektor <int> jumlah, tambah, ans; Membina pokok segmen; Melangkah ke atas pertanyaan; Kedai hasil dalam pelbagai; Mengemas kini unsur -unsur dalam julat yang diberikan; Cetak hasil pertanyaan; Kod pemacu; Panggilan fungsi", "code": "def build ( sum , a , l , r , rt ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT sum [ rt ] = a [ l - 1 ] NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE build ( sum , a , l , m , rt << 1 ) NEW_LINE build ( sum , a , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT def pushDown ( sum , add , rt , ln , rn ) : NEW_LINE INDENT if ( add [ rt ] ) : NEW_LINE INDENT add [ rt << 1 ] += add [ rt ] NEW_LINE add [ rt << 1 1 ] += add [ rt ] NEW_LINE sum [ rt << 1 ] += add [ rt ] * ln NEW_LINE sum [ rt << 1 1 ] += add [ rt ] * rn NEW_LINE add [ rt ] = 0 NEW_LINE DEDENT DEDENT def update ( sum , add , L , R , C , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT sum [ rt ] += C * ( r - l + 1 ) NEW_LINE add [ rt ] += C NEW_LINE return NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE if ( L <= m ) : NEW_LINE INDENT update ( sum , add , L , R , C , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT DEDENT def queryy ( sum , add , L , R , l , r , rt ) : NEW_LINE INDENT if ( L <= l and r <= R ) : NEW_LINE INDENT return sum [ rt ] NEW_LINE DEDENT m = ( l + r ) >> 1 NEW_LINE pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE ans = 0 NEW_LINE if ( L <= m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , m + 1 , r , ( rt << 1 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def sequenceMaintenance ( n , q , a , b , m ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE sum = [ 0 ] * ( 4 * n ) NEW_LINE add = [ 0 ] * ( 4 * n ) NEW_LINE ans = [ ] NEW_LINE build ( sum , a , 1 , n , 1 ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE pos = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( queryy ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) : NEW_LINE INDENT r = m - 1 NEW_LINE pos = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n - pos + 1 ) NEW_LINE update ( sum , add , pos , n , - m , 1 , n , 1 ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE Q = 3 NEW_LINE M = 1 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE query = [ 4 , 3 , 1 ] NEW_LINE sequenceMaintenance ( N , Q , arr , query , M ) NEW_LINE DEDENT"}
{"text": "Kurangkan panjang array dengan berulang kali menggantikan co | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari panjang array akhir dengan menggantikan pasangan coprime dengan 1; Iterate over all pairs of element ; Semak jika GCD adalah 1; Sekiranya tiada pasangan Coprime mendapati kembali palsu; Kod pemacu; Semak sama ada satu pasangan coprime wujud dalam array; Sekiranya tidak ada pasangan seperti itu", "code": "import math NEW_LINE def hasCoprimePair ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( math . gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE arr = [ 6 , 9 , 15 ] NEW_LINE if ( hasCoprimePair ( arr , n ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT"}
{"text": "Mengira cara untuk berpecah n ke dalam tiga kali ganda membentuk segitiga | Berfungsi untuk mengembalikan bilangan cara yang diperlukan; Semak jika A, B, C boleh membentuk segitiga; Mengembalikan bilangan cara; Kod pemacu", "code": "def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT n = 15 NEW_LINE print ( Numberofways ( n ) ) NEW_LINE"}
{"text": "Kira pasangan yang mempunyai setiap elemen yang sama dengan indeks yang lain dari array | Berfungsi untuk mencetak kiraan pasangan; Melangkah ke atas semua elemen array; Kenaikan kiraan; Cetak hasilnya; Kod pemacu", "code": "def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count // 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( N , arr ) NEW_LINE DEDENT"}
{"text": "Cari panjang fibonacci terpanjang seperti berikutnya | Berfungsi untuk mengembalikan panjang maksimum fibonacci seterusnya; Simpan semua elemen array dalam jadual hash; Semak sehingga elemen FIB seterusnya dijumpai; Elemen seterusnya FIB Subseq; Kod pemacu", "code": "def LongestFibSubseq ( A , n ) : NEW_LINE INDENT S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE while y in S : NEW_LINE INDENT z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT DEDENT return maxLen if maxLen >= 3 else 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Sorakkan dia array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE print ( CountMaximum ( arr , n , k ) ) NEW_LINE"}
{"text": "Jenis maksimum gula -gula seseorang boleh makan jika hanya n / 2 daripadanya boleh dimakan | Berfungsi untuk mencari bilangan jenis gula -gula; Mengisytiharkan hashset untuk menyimpan gula -gula; Melintasi array yang diberikan dan memasukkan elemen ke dalam set; Mengembalikan hasilnya; Berfungsi untuk mencari bilangan maksimum jenis gula -gula yang boleh dimakan seseorang; Simpan bilangan gula -gula yang dibenarkan makan; Simpan bilangan jenis gula -gula; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def num_candyTypes ( candies ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( candies ) ) : NEW_LINE INDENT s . add ( candies [ i ] ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def distribute_candies ( candies ) : NEW_LINE INDENT allowed = len ( candies ) / 2 NEW_LINE types = num_candyTypes ( candies ) NEW_LINE if ( types < allowed ) : NEW_LINE INDENT print ( int ( types ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( allowed ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT candies = [ 4 , 4 , 5 , 5 , 3 , 3 ] NEW_LINE distribute_candies ( candies ) NEW_LINE DEDENT"}
{"text": "Panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak | Program Python untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak; Kod pemacu", "code": "import math NEW_LINE def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT A = 6 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonals ( A , theta ) NEW_LINE print ( round ( ans [ 0 ] , 2 ) , round ( ans [ 1 ] , 2 ) ) NEW_LINE"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT y = bin ( K ) . count ( '1' ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT print ( \" Even ▁ = \" , odd , \" , ▁ Odd ▁ = \" , even ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Even ▁ = \" , even , \" , ▁ Odd ▁ = \" , odd ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE countEvenOdd ( arr , n , K ) ; NEW_LINE DEDENT"}
{"text": "Bilangan cara untuk memilih pasangan yang mengandungi nombor yang lebih dan ganjil dari 1 hingga n | Kod pemacu", "code": "N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Program Python 3 untuk pendekatan di atas; Fungsi rekursif untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; Kes asas; Tidak termasuk pasangan semasa dalam masa yang paling lama; Termasuk pasangan semasa dalam masa yang paling lama;  ; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import sys NEW_LINE def longestSubSequence ( A , N , ind = 0 , lastf = - sys . maxsize - 1 , lasts = sys . maxsize ) : NEW_LINE INDENT if ( ind == N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) NEW_LINE if ( A [ ind ] [ 0 ] > lastf and A [ ind ] [ 1 ] < lasts ) : NEW_LINE INDENT ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT / * Function * / NEW_LINE public static int longestSubSequence ( int [ , ] A , int N ) NEW_LINE { return longestSubSequence ( A , N , 0 , 0 , 0 ) ; } NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE print ( longestSubSequence ( A , N ) ) NEW_LINE DEDENT"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Input Array ; Panggilan fungsi", "code": "def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 1 , 3 ] ; NEW_LINE print ( countTriplets ( A ) ) ; NEW_LINE DEDENT"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk nilai i. 3 nilai tambahan adalah untuk menjaga kes sudut n = 0; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; Bilangan cara jika larian pertama adalah 1 + bilangan cara jika larian pertama adalah 2 dan larian kedua ialah 1; Kod pemacu", "code": "def CountWays ( n ) : NEW_LINE INDENT noOfWays = [ 0 ] * ( n + 3 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] NEW_LINE DEDENT return noOfWays [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT"}
{"text": "Cari pemain terakhir untuk dapat membalikkan watak dalam rentetan binari | Program Python3 untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada pemain A memenangi permainan atau tidak; Kedai saiz kumpulan 0 s; Kedai saiz kumpulan 0 s; Melintasi array; Kenaikan c oleh 1 jika a [i] adalah 0; Jika tidak, tolak saiz dalam array dan tetapkan semula C ke 0; Sekiranya tidak ada substring panjang ganjil yang terdiri daripada 0 s; Sekiranya terdapat hanya 1 substring panjang ganjil yang terdiri hanya 0 s; Jika tidak; Menyimpan saiz substring terbesar dan kedua terbesar 0 s; Melintasi array v []; Jika elemen semasa lebih besar daripada yang pertama, maka kemas kini kedua -dua dan kedua; Jika arr [i] berada di antara pertama dan kedua, maka kemas kini kedua; Sekiranya keadaan itu berpuas hati; Kod pemacu", "code": "import sys NEW_LINE def findWinner ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT c = 0 NEW_LINE DEDENT DEDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( \" Player ▁ B \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT if ( len ( v ) == 1 ) : NEW_LINE INDENT if ( ( v [ 0 ] & 1 ) != 0 ) : NEW_LINE INDENT print ( \" Player ▁ A \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Player ▁ B \" , end = \" \" ) NEW_LINE DEDENT return NEW_LINE DEDENT first = sys . minsize NEW_LINE second = sys . minsize NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT DEDENT if ( ( ( first & 1 ) != 0 ) and ( first + 1 ) // 2 > second ) : NEW_LINE INDENT print ( \" Player ▁ A \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Player ▁ B \" , end = \" \" ) NEW_LINE DEDENT DEDENT S = \"1100011\" NEW_LINE N = len ( S ) NEW_LINE findWinner ( S , N ) NEW_LINE"}
{"text": "Periksa sama ada rentetan kalindromik boleh dibentuk dari rentetan yang diberikan | Berfungsi untuk memeriksa sama ada K palindrome atau tidak; peta kepada kekerapan watak; Semak apabila k diberikan sama seperti panjang rentetan; Menyimpan kekerapan setiap watak dalam peta; Jika k lebih besar daripada saiz maka kembali palsu; Semak bilangan watak yang mempunyai kekerapan ganjil; Jika k kurang daripada bilangan watak frekuensi ganjil maka ia sekali lagi palsu jika tidak benar; Kod pemacu", "code": "def can_Construct ( S , K ) : NEW_LINE INDENT m = dict ( ) NEW_LINE p = 0 NEW_LINE if ( len ( S ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in S : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT if ( K > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for h in m : NEW_LINE INDENT if ( m [ h ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if ( K < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" annabelle \" NEW_LINE K = 4 NEW_LINE if ( can_Construct ( S , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Menukar ke kes yang lebih rendah; Membandingkan kedua -duanya; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . lower ( ) ; NEW_LINE str2 = str2 . lower ( ) ; NEW_LINE x = str1 == str2 ; NEW_LINE return x ; NEW_LINE DEDENT def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Same \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" Geeks \" ; NEW_LINE str2 = \" geeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = \" Geek \" ; NEW_LINE str2 = \" geeksforgeeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT"}
{"text": "Program untuk mencetak corak langkah | Program Python3 untuk mencetak corak langkah; berfungsi untuk mencetak langkah -langkah; mengisytiharkan bendera; melintasi semua watak dalam rentetan; Jika nilai x ialah 0 .. Kemudian kita mesti kenaikan sehingga n ... Tetapkan bendera kepada Benar; Jika nilai x adalah n - 1 maka kita mesti menurunkan sehingga 0 ... Tetapkan bendera sebagai palsu; cetak x * s; memeriksa sama ada untuk kenaikan atau penurunan x; Dapatkan rentetan dan nombor n; memanggil fungsi", "code": "import math as mt NEW_LINE def steps ( string , n ) : NEW_LINE INDENT flag = False NEW_LINE x = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE string = \" GeeksForGeeks \" NEW_LINE print ( \" String : ▁ \" , string ) NEW_LINE print ( \" Max ▁ Length ▁ of ▁ Steps : ▁ \" , n ) NEW_LINE steps ( string , n ) NEW_LINE"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program python untuk mengira frekuensi item array; Tandakan semua elemen array seperti yang tidak dikunjungi; Melintasi unsur -unsur array dan kekerapan kiraan; Langkau elemen ini jika sudah diproses; kekerapan kiraan; Kod pemacu", "code": "def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT a = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE"}
{"text": "Semak pembahagian rentetan binari dengan 2 ^ k | fungsi untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; kiraan bilangan 0 dari yang terakhir; Jika Count = k, nombor sama rata, jadi pulangan benar lain palsu; Contoh pertama; Contoh kedua", "code": "def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT str1 = \"10101100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT str2 = \"111010100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Semak jika ada anagram rentetan adalah palindrome atau tidak | Program Python untuk memeriksa sama ada anagram rentetan adalah palindrome atau tidak; berfungsi untuk memeriksa sama ada watak rentetan boleh membentuk palindrome; Buat array kiraan dan mulakan semua nilai sebagai 0; Bagi setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan; Mengira watak -watak yang ganjil; Kembali benar jika kiraan ganjil adalah 0 atau 1 ,; Program pemacu untuk diuji untuk mencetak cetakan", "code": "NO_OF_CHARS = 256 NEW_LINE def canFormPalindrome ( string ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in string : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if ( canFormPalindrome ( \" geeksforgeeks \" ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT if ( canFormPalindrome ( \" geeksogeeks \" ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" NO \" NEW_LINE DEDENT"}
{"text": "Program untuk memeriksa sama ada input adalah integer atau rentetan | Fungsi ini pulangan benar jika s adalah nombor lain palsu; Kod pemacu; Simpan input dalam pembolehubah STR; Fungsi pulangan 1 jika semua elemen berada dalam julat '0 ~ »~ 9'; Fungsi pulangan 0 jika input bukan integer", "code": "def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) != True : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \"6790\" NEW_LINE if isNumber ( str ) : NEW_LINE INDENT print ( \" Integer \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" String \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Cetak terbalik rentetan menggunakan rekursi | Berfungsi untuk mencetak terbalik rentetan lulus; Program pemacu untuk menguji fungsi di atas", "code": "def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = ' ' ) NEW_LINE DEDENT string = \" Geeks ▁ for ▁ Geeks \" NEW_LINE reverse ( string ) NEW_LINE"}
{"text": "Kebarangkalian mengedarkan bola yang diberikan kepada dua bahagian yang mempunyai kiraan yang sama dengan warna yang berbeza | Menyimpan kiraan warna yang berbeza dalam Box1; Menyimpan kiraan warna yang berbeza dalam Box2; Fungsi untuk mengira kebarangkalian yang diperlukan; Hitung faktorial dari [1, 10]; Berikan semua bola yang berbeza ke kotak kedua; Jumlah bola; Hitung jumlah bola; Jika k adalah nombor ganjil; Jumlah cara mengedarkan bola dalam dua bahagian yang sama; Bilangan cara yang diperlukan; Mengembalikan kebarangkalian yang diperlukan; Fungsi untuk mengira jumlah bilangan pengagihan yang mungkin memenuhi syarat yang diberikan; Jika bola yang digunakan adalah sama dengan k / 2; Jika Box1 sama dengan Box2; Keadaan asas; Menyimpan bilangan cara mengedarkan bola yang tinggal tanpa termasuk bola semasa dalam Box1; Kotak kenaikan1 dengan satu; Melangkah ke atas julat [1, bola [i]]; Jika semua bola pergi ke Box1, kemudian menurunkan Box2 dengan satu; Jumlah cara memilih bola J; Kenaikan res dengan jumlah cara yang sah untuk mengedarkan bola yang tinggal; Box1 box1 oleh satu; Box2 Box2 oleh 1; Fungsi untuk mengira faktorial n; Kes asas; Melangkah ke atas julat [1, n]; Fungsi untuk mengira NCR; Kod pemacu; Cetak hasilnya", "code": "box1 = 0 NEW_LINE box2 = 0 NEW_LINE fact = [ 0 for i in range ( 11 ) ] NEW_LINE def getProbability ( balls ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE factorial ( 10 ) NEW_LINE box2 = len ( balls ) NEW_LINE K = 0 NEW_LINE for i in range ( len ( balls ) ) : NEW_LINE INDENT K += balls [ i ] NEW_LINE DEDENT if ( K % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT all = comb ( K , K // 2 ) NEW_LINE validPermutation = validPermutations ( K // 2 , balls , 0 , 0 ) NEW_LINE return validPermutation / all NEW_LINE DEDENT def validPermutations ( n , balls , usedBalls , i ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE if ( usedBalls == n ) : NEW_LINE INDENT if ( box1 == box2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( i >= len ( balls ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = validPermutations ( n , balls , usedBalls , i + 1 ) NEW_LINE box1 += 1 NEW_LINE for j in range ( 1 , balls [ i ] + 1 ) : NEW_LINE INDENT if ( j == balls [ i ] ) : NEW_LINE INDENT box2 -= 1 NEW_LINE DEDENT combinations = comb ( balls [ i ] , j ) NEW_LINE res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 ) NEW_LINE DEDENT box1 -= 1 NEW_LINE box2 += 1 NEW_LINE return res NEW_LINE DEDENT def factorial ( N ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT DEDENT def comb ( n , r ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE res = fact [ n ] // fact [ r ] NEW_LINE res //= fact [ n - r ] NEW_LINE return res NEW_LINE DEDENT arr = [ 2 , 1 , 1 ] NEW_LINE N = 4 NEW_LINE print ( getProbability ( arr ) ) NEW_LINE"}
{"text": "Kawasan n | Program Python3 untuk mencari kawasan poligon biasa dengan radius yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Sampingan dan jejari tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "from math import sin NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"}
{"text": "Semak jika garis pada 45 darjah boleh membahagikan pesawat ke dalam dua bahagian berat yang sama |  ; Memeriksa jika satah boleh dibahagikan dengan garis pada 45 darjah supaya jumlah berat adalah sama; Putar setiap titik sebanyak 45 darjah dan mengira jumlah awalan. Juga, mencari koordinat X maksimum dan minimum; menyimpan jumlah berat sehingga titik x - y; Mencari Jumlah awalan; Line melewati saya, jadi ia tidak jatuh ke kiri atau kanan. ; Program yang didorong", "code": "from collections import defaultdict NEW_LINE def is_partition_possible ( n , x , y , w ) : NEW_LINE INDENT weight_at_x = defaultdict ( int ) NEW_LINE max_x = - 2e3 NEW_LINE min_x = 2e3 NEW_LINE for i in range ( n ) : NEW_LINE INDENT new_x = x [ i ] - y [ i ] NEW_LINE max_x = max ( max_x , new_x ) NEW_LINE min_x = min ( min_x , new_x ) NEW_LINE weight_at_x [ new_x ] += w [ i ] NEW_LINE DEDENT sum_till = [ ] NEW_LINE sum_till . append ( 0 ) NEW_LINE for x in range ( min_x , max_x + 1 ) : NEW_LINE INDENT sum_till . append ( sum_till [ - 1 ] + weight_at_x [ x ] ) NEW_LINE DEDENT total_sum = sum_till [ - 1 ] NEW_LINE partition_possible = False NEW_LINE for i in range ( 1 , len ( sum_till ) ) : NEW_LINE INDENT if ( sum_till [ i ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT DEDENT if partition_possible : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE x = [ - 1 , - 2 , 1 ] NEW_LINE y = [ 1 , 1 , - 1 ] NEW_LINE w = [ 3 , 1 , 4 ] NEW_LINE is_partition_possible ( n , x , y , w ) NEW_LINE DEDENT"}
{"text": "Cerun tegak lurus ke garisan | Berfungsi untuk mencari cerun garis lain; Kod pemacu", "code": "def findPCSlope ( m ) : NEW_LINE INDENT return - 1.0 / m NEW_LINE DEDENT m = 2.0 NEW_LINE print ( findPCSlope ( m ) ) NEW_LINE"}
{"text": "Program untuk mencari kawasan segmen bulat | Program Python3 untuk mencari kawasan segmen bulatan; Fungsi untuk mencari kawasan segmen; Mengira kawasan sektor; Mengira kawasan segitiga; Kod pemacu", "code": "import math NEW_LINE pi = 3.14159 NEW_LINE def area_of_segment ( radius , angle ) : NEW_LINE INDENT area_of_sector = pi * NEW_LINE INDENT ( radius * radius ) NEW_LINE * ( angle / 360 ) NEW_LINE DEDENT area_of_triangle = 1 / 2 * NEW_LINE INDENT ( radius * radius ) * NEW_LINE math . sin ( ( angle * pi ) / 180 ) NEW_LINE DEDENT return area_of_sector - area_of_triangle ; NEW_LINE DEDENT radius = 10.0 NEW_LINE angle = 90.0 NEW_LINE print ( \" Area ▁ of ▁ minor ▁ segment ▁ = \" , area_of_segment ( radius , angle ) ) NEW_LINE print ( \" Area ▁ of ▁ major ▁ segment ▁ = \" , area_of_segment ( radius , ( 360 - angle ) ) ) NEW_LINE"}
{"text": "Kawasan Sektor Pekeliling | Program Python untuk mencari kawasan sektor; Mengira kawasan sektor; Kod pemacu", "code": "def SectorArea ( radius , angle ) : NEW_LINE INDENT pi = 22 / 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( \" Angle ▁ not ▁ possible \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT DEDENT radius = 9 NEW_LINE angle = 60 NEW_LINE SectorArea ( radius , angle ) NEW_LINE"}
{"text": "Buat dua nombor sama dengan mendarab dengan faktor utama mereka bilangan minimum kali | Program Python untuk pendekatan di atas; Fungsi untuk mengira jumlah faktor utama dengan faktor utama mereka; Melangkah sementara nombornya juga; Mengurangkan separuh; Berulang sehingga sqrt (n); Melangkah sementara n mempunyai faktor i; Mengeluarkan satu faktor i; Berfungsi untuk mengira bilangan faktor; Cari GCD; Cari gandaan yang tersisa di x dan y; Cari faktor utama pelbagai kiri dalam x dan y; Memulakan ans; Semak sama ada mungkin untuk mendapatkan x atau tidak; Periksa sama ada mungkin untuk mendapatkan y atau tidak; kembali utama ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "import math NEW_LINE def PrimeFactor ( N ) : NEW_LINE INDENT ANS = dict ( ) NEW_LINE while N % 2 == 0 : NEW_LINE INDENT if 2 in ANS : NEW_LINE INDENT ANS [ 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ 2 ] = 1 NEW_LINE DEDENT N = N // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( N ) ) + 1 , 2 ) : NEW_LINE INDENT while N % i == 0 : NEW_LINE INDENT if i in ANS : NEW_LINE INDENT ANS [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ i ] = 1 NEW_LINE DEDENT N = N // i NEW_LINE DEDENT DEDENT if 2 < N : NEW_LINE INDENT ANS [ N ] = 1 NEW_LINE DEDENT return ANS NEW_LINE DEDENT def CountToMakeEqual ( X , Y ) : NEW_LINE INDENT GCD = math . gcd ( X , Y ) NEW_LINE newY = X // GCD NEW_LINE newX = Y // GCD NEW_LINE primeX = PrimeFactor ( newX ) NEW_LINE primeY = PrimeFactor ( newY ) NEW_LINE ans = 0 NEW_LINE for factor in primeX : NEW_LINE INDENT if X % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeX [ factor ] NEW_LINE DEDENT for factor in primeY : NEW_LINE INDENT if Y % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeY [ factor ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 36 NEW_LINE Y = 48 NEW_LINE ans = CountToMakeEqual ( X , Y ) NEW_LINE print ( ans ) NEW_LINE DEDENT"}
{"text": "Buat segmen yang diberikan bukan | Program Python3 untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada graf adalah bipartite atau tidak; Tanda nod sumber seperti yang dikunjungi; Tolak puncak sumber dalam barisan; Dapatkan bahagian depan barisan; Berikan warna kepada nod yang muncul; Melintasi senarai addacency nod u; Jika mana -mana nod dikunjungi & warna yang berbeza telah diberikan, maka kembali palsu; Tetapkan dikunjungi [x]; Tolak nod X ke dalam barisan; Kemas kini warna nod; Jika graf adalah bipartite; Berfungsi untuk menambah kelebihan antara nod U dan V; Berfungsi untuk memeriksa sama ada tugasan arah boleh dilakukan untuk semua segmen, supaya mereka tidak bersilang selepas jangka masa yang panjang; Menyimpan senarai adjacency graf yang dicipta; Menjana semua pasangan yang mungkin; Jika segmen tidak bertindih; Jika tidak, segmen bertindih; Jika kedua -dua segmen mempunyai kelajuan yang sama, maka tambahkan kelebihan; Pastikan jejak nod yang dikunjungi; Berulang untuk semua nod yang mungkin; Semak sama ada graf adalah bipartite atau tidak; Jika graf adalah bipartite; Kod pemacu", "code": "from collections import deque NEW_LINE def check ( Adj , Src , N , visited ) : NEW_LINE INDENT color = [ 0 ] * N NEW_LINE visited = [ True ] * Src NEW_LINE q = deque ( ) NEW_LINE q . append ( Src ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE Col = color [ u ] NEW_LINE for x in Adj [ u ] : NEW_LINE INDENT if ( visited [ x ] == True and color [ x ] == Col ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( visited [ x ] == False ) : NEW_LINE INDENT visited [ x ] = True NEW_LINE q . append ( x ) NEW_LINE color [ x ] = 1 - Col NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def addEdge ( Adj , u , v ) : NEW_LINE INDENT Adj [ u ] . append ( v ) NEW_LINE Adj [ v ] . append ( u ) NEW_LINE return Adj NEW_LINE DEDENT def isPossible ( Arr , N ) : NEW_LINE INDENT Adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( Arr [ i ] [ 0 ] < Arr [ j ] [ 1 ] or Arr [ i ] [ 1 ] > Arr [ j ] [ 0 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( Arr [ i ] [ 2 ] == Arr [ j ] [ 2 ] ) : NEW_LINE INDENT Adj = addEdge ( Adj , i , j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT visited = [ False ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( visited [ i ] == False and len ( Adj [ i ] ) > 0 ) : NEW_LINE INDENT if ( check ( Adj , i , N , visited ) == False ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" Yes \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 5 , 7 , 2 ] , [ 4 , 6 , 1 ] , [ 1 , 5 , 2 ] , [ 6 , 5 , 1 ] ] NEW_LINE N = len ( arr ) NEW_LINE isPossible ( arr , N ) NEW_LINE DEDENT"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program Python untuk pendekatan di atas; Kod pemacu", "code": "def lexNumbers ( n ) : NEW_LINE INDENT sol = [ ] NEW_LINE dfs ( 1 , n , sol ) NEW_LINE print ( \" [ \" , sol [ 0 ] , end = \" \" , sep = \" \" ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( \" , ▁ \" , sol [ i ] , end = \" \" , sep = \" \" ) print ( \" ] \" ) NEW_LINE DEDENT DEDENT def dfs ( temp , n , sol ) : NEW_LINE INDENT if ( temp > n ) : NEW_LINE INDENT return NEW_LINE DEDENT sol . append ( temp ) NEW_LINE dfs ( temp * 10 , n , sol ) NEW_LINE if ( temp % 10 != 9 ) : NEW_LINE INDENT dfs ( temp + 1 , n , sol ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE lexNumbers ( n ) NEW_LINE"}
{"text": "Bilangan swap minimum yang diperlukan untuk menyusun pelbagai nombor N pertama | Berfungsi untuk mencari swap minimum; Pembolehubah kiraan permulaan; Jika elemen semasa tidak berada di kedudukan yang betul; Swap elemen semasa dengan kedudukan yang betul dari elemen itu; Kenaikan untuk indeks seterusnya apabila elemen semasa berada pada kedudukan yang betul; Kod pemacu; Berfungsi untuk mencari swap minimum", "code": "def minimumSwaps ( arr ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = arr [ arr [ i ] - 1 ] ; NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] ; NEW_LINE arr [ i ] = temp ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] ; NEW_LINE print ( minimumSwaps ( arr ) ) ; NEW_LINE DEDENT"}
{"text": "Gabungkan K -Sorted Doubly Linked List dalam Order Sorted | Nod senarai yang dipautkan; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala DLL dan int, tambah nod baru pada akhir; Memperuntukkan nod; Masukkan data; Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai tidak ada; Jika senarai yang dipautkan kosong, maka buat nod baru sebagai kepala; Lain melintasi sehingga nod terakhir; Tukar nod terakhir yang akan datang; Buat nod terakhir seperti sebelumnya dari nod baru; Berfungsi untuk mencetak senarai; Jalankan semasa gelung melainkan nod menjadi tidak ada; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika mana -mana senarai kosong; Perbandingan data dua senarai yang dipautkan; Simpan penunjuk kepala sebelum menggabungkan senarai; Menukar penunjuk antara dua senarai untuk penggabungan; Menukar penunjuk antara dua senarai untuk penggabungan; Syarat untuk memeriksa sama ada sesiapa yang menyenaraikan tidak berakhir; Kembali penunjuk kepala senarai yang digabungkan; Berfungsi untuk menggabungkan semua senarai yang disusun dalam susunan yang disusun; Panggilan fungsi untuk menggabungkan dua senarai dikaitkan berganda yang disusun pada satu masa; Kembali akhir disusun senarai dua kali ganda; Kod pemacu; Gelung untuk memulakan semua senarai untuk kosong; Buat senarai senarai dua kali ganda pertama1. 1 <=> 5 <=> 9; Buat senarai dikaitkan dua kali ganda kedua2. 2 <=> 3 <=> 7 <=> 12; Buat senarai dikaitkan dua kali ganda 3 senarai3. 8 <=> 11 <=> 13 <=> 18; Panggilan fungsi untuk menggabungkan semua senarai dikaitkan dua kali ganda dalam urutan yang disusun; Cetak senarai disusun akhir", "code": "class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT def append ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE last = head_ref NEW_LINE new_node . data = new_data NEW_LINE new_node . next = None NEW_LINE if ( head_ref == None ) : NEW_LINE INDENT new_node . prev = None NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT while ( last . next != None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT last . next = new_node NEW_LINE new_node . prev = last NEW_LINE return head_ref NEW_LINE DEDENT def printList ( node ) : NEW_LINE INDENT last = None NEW_LINE while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" ▁ \" ) NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT DEDENT def mergeList ( p , q ) : NEW_LINE INDENT s = None NEW_LINE if ( p == None or q == None ) : NEW_LINE INDENT if ( p == None ) : NEW_LINE INDENT return q NEW_LINE DEDENT else : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT if ( p . data < q . data ) : NEW_LINE INDENT p . prev = s NEW_LINE s = p NEW_LINE p = p . next NEW_LINE DEDENT else : NEW_LINE INDENT q . prev = s NEW_LINE s = q NEW_LINE q = q . next NEW_LINE DEDENT head = s NEW_LINE while ( p != None and q != None ) : NEW_LINE INDENT if ( p . data < q . data ) : NEW_LINE INDENT s . next = p NEW_LINE p . prev = s NEW_LINE s = s . next NEW_LINE p = p . next NEW_LINE DEDENT else : NEW_LINE INDENT s . next = q NEW_LINE q . prev = s NEW_LINE s = s . next NEW_LINE q = q . next NEW_LINE DEDENT DEDENT if ( p == None ) : NEW_LINE INDENT s . next = q NEW_LINE q . prev = s NEW_LINE DEDENT if ( q == None ) : NEW_LINE INDENT s . next = p NEW_LINE p . prev = s NEW_LINE DEDENT return head NEW_LINE DEDENT def mergeAllList ( head , k ) : NEW_LINE INDENT finalList = None NEW_LINE i = 0 NEW_LINE while ( i < k ) : NEW_LINE INDENT finalList = mergeList ( finalList , head [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT return finalList NEW_LINE DEDENT k = 3 NEW_LINE head = [ 0 ] * k NEW_LINE i = 0 NEW_LINE while ( i < k ) : NEW_LINE INDENT head [ i ] = None NEW_LINE i = i + 1 NEW_LINE DEDENT head [ 0 ] = append ( head [ 0 ] , 1 ) NEW_LINE head [ 0 ] = append ( head [ 0 ] , 5 ) NEW_LINE head [ 0 ] = append ( head [ 0 ] , 9 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 2 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 3 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 7 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 12 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 8 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 11 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 13 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 18 ) NEW_LINE finalList = mergeAllList ( head , k ) NEW_LINE printList ( finalList ) NEW_LINE"}
{"text": "Susun Pemilihan Rekursif | Indeks minimum pulangan; Cari minimum elemen yang tinggal; Pulangan minimum semasa dan baki. ; Jenis pemilihan rekursif. N ialah saiz [] dan indeks adalah indeks elemen permulaan. ; Kembali apabila bermula dan saiznya sama; Memanggil fungsi indeks minimum untuk indeks minimum; Bertukar apabila indeks dan indeks minimum tidak sama; swap; Fungsi pemilihan pilihan rekursif; Kod pemacu; Fungsi panggilan; Percetakan Arahan yang disusun", "code": "def minIndex ( a , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return i NEW_LINE DEDENT k = minIndex ( a , i + 1 , j ) NEW_LINE return ( i if a [ i ] < a [ k ] else k ) NEW_LINE DEDENT def recurSelectionSort ( a , n , index = 0 ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT k = minIndex ( a , index , n - 1 ) NEW_LINE if k != index : NEW_LINE INDENT a [ k ] , a [ index ] = a [ index ] , a [ k ] NEW_LINE INDENT a [ k ] , a [ index ] = a [ index ] , a [ k ] NEW_LINE DEDENT DEDENT recurSelectionSort ( a , n , index + 1 ) NEW_LINE DEDENT arr = [ 3 , 1 , 5 , 2 , 7 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE recurSelectionSort ( arr , n ) NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT"}
{"text": "SENARAI SENSI RECURSIVE | Recursive function to sort an array using insertion sort ; Kes asas; Susun pertama n - 1 elemen; Masukkan elemen terakhir pada kedudukan yang betul dalam array yang disusun. ; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Program pemacu untuk menguji jenis penyisipan", "code": "def insertionSortRecursive ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT insertionSortRecursive ( arr , n - 1 ) NEW_LINE last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE insertionSortRecursive ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE"}
{"text": "Perbezaan maksimum jumlah dua subset dari array | Tetapkan 2 | Program Python 3 untuk pendekatan di atas; Menyimpan unsur -unsur positif; Menyimpan unsur -unsur negatif; Menyimpan kiraan 0 s; Jumlah semua nombor positif; Jumlah semua nombor negatif; Melangkah ke atas array; Menyimpan perbezaan; Menyusun nombor positif dalam urutan menaik; Menyusun nombor negatif dalam penurunan urutan; Kes 1: Sertakan nombor positif dan negatif; Letakkan semua nombor dalam subset a dan satu 0 dalam subset b; Letakkan semua nombor dalam subset A kecuali nombor positif terkecil yang dimasukkan ke dalam B; Letakkan semua nombor dalam subset b dan satu 0 dalam subset A; Letakkan nombor negatif terbesar dalam subset A dan baki dalam B; Kod pemacu", "code": "def maxSumAfterPartition ( arr , n ) : NEW_LINE INDENT pos = [ ] NEW_LINE neg = [ ] NEW_LINE zero = 0 NEW_LINE pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos . append ( arr [ i ] ) NEW_LINE pos_sum += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 ) : NEW_LINE INDENT neg . append ( arr [ i ] ) NEW_LINE neg_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE pos . sort ( ) NEW_LINE neg . sort ( reverse = True ) NEW_LINE if ( len ( pos ) > 0 and len ( neg ) > 0 ) : NEW_LINE INDENT ans = ( pos_sum - neg_sum ) NEW_LINE DEDENT elif ( len ( pos ) > 0 ) : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT ans = ( pos_sum ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( pos_sum - 2 * pos [ 0 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT ans = ( - 1 * neg_sum ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , - 5 , - 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumAfterPartition ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Berfungsi untuk mencari elemen bitwise atau array; Menyimpan nilai maksimum yang dihasilkan dari bitwise XOR; Melintasi array arr []; Mengembalikan nilai maksimum RES; Kod pemacu", "code": "def MaxXOR ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res |= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( MaxXOR ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Kira bilangan unsur biasa antara array yang disusun dan array yang disusun terbalik | Berfungsi untuk mengira bilangan elemen yang biasa dalam kedua -dua tatasusunan; Digunakan untuk melintasi array A [] dan B [] dari depan dan belakang; Menyimpan kiraan nombor yang biasa dalam kedua -dua array; Jika A [pertama] kurang daripada b [kedua]; Meningkatkan nilai pertama; Jika B [kedua] kurang daripada [pertama]; Menurunkan nilai kedua; A [pertama] adalah sama dengan b [kedua]; Meningkatkan nilai kiraan; Meningkatkan nilai pertama; Menurunkan nilai kedua; Mengembalikan nilai kiraan; Kod pemacu", "code": "def countEqual ( A , B , N ) : NEW_LINE INDENT first = 0 NEW_LINE second = N - 1 NEW_LINE count = 0 NEW_LINE while ( first < N and second >= 0 ) : NEW_LINE INDENT if ( A [ first ] < B [ second ] ) : NEW_LINE INDENT first += 1 NEW_LINE DEDENT elif ( B [ second ] < A [ first ] ) : NEW_LINE INDENT second -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE first += 1 NEW_LINE second -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT A = [ 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 ] NEW_LINE B = [ 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( countEqual ( A , B , N ) ) NEW_LINE"}
{"text": "Pertanyaan untuk mengira nombor palindrome dari julat yang jumlah digitnya adalah nombor utama | Program Python 3 untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor n adalah palindrome atau tidak; Simpan nilai n; Simpan sebaliknya nombor n; Tempatan terbalik dan simpan di res; Jika n adalah sama dengan res, maka kembali benar; Berfungsi untuk mencari jumlah digit nombor n; Menyimpan jumlah digit; Tambah digit terakhir nombor N ke jumlah; Keluarkan digit terakhir dari N; Mengembalikan jumlah yang dihasilkan; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Jika saya adalah 1 atau 0, maka kembali palsu; Semak jika saya boleh dibahagikan dengan mana -mana nombor dalam julat [2, n / 2]; Jika n boleh dibahagikan dengan i; Berfungsi untuk mendahului semua nombor sehingga 10 ^ 5 yang palindromik dan jumlah digitnya adalah nombor utama; Melangkah ke atas julat 1 hingga 10 ^ 5; Jika saya adalah nombor palindrome; Menyimpan jumlah digit dalam i; Jika jumlah digit dalam saya adalah nombor utama; Cari jumlah awalan arr []; Fungsi untuk mengira semua nombor dalam julat yang diberikan adalah palindromik dan jumlah digit adalah nombor utama; Fungsi panggilan untuk precompute semua nombor hingga 10 ^ 5; Melintasi pertanyaan yang diberikan Q []; Cetak hasil untuk setiap pertanyaan; Kod pemacu; Panggilan fungsi", "code": "arr = [ 0 for i in range ( 100005 ) ] NEW_LINE def isPalindrome ( N ) : NEW_LINE INDENT temp = N NEW_LINE res = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE res = res * 10 + rem NEW_LINE temp //= 10 NEW_LINE DEDENT if ( res == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def sumOfDigits ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT sum += N % 10 NEW_LINE N //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , ( n // 2 ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 , 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT sum = sumOfDigits ( i ) NEW_LINE if ( isPrime ( sum ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , 100001 , 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE DEDENT DEDENT def countNumbers ( Q , N ) : NEW_LINE INDENT precompute ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Q = [ [ 5 , 9 ] , [ 1 , 101 ] ] NEW_LINE N = len ( Q ) NEW_LINE countNumbers ( Q , N ) NEW_LINE DEDENT"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan N yang mempunyai jumlah digit tidak melebihi s | Fungsi untuk mengira jumlah digit n; Berfungsi untuk mencari integer yang paling kecil yang memenuhi syarat yang diberikan; Jika jumlah digit sudah lebih kecil daripada S; Memulakan pembolehubah; Cari digit K - th; Tambah baki; Jika jumlah digit tidak melebihi s; Kemas kini k; Diberikan n dan s; Panggilan fungsi", "code": "def sum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sm += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT def smallestNumber ( n , s ) : NEW_LINE INDENT if ( sum ( n ) <= s ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans , k = n , 1 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT digit = ( ans // k ) % 10 NEW_LINE add = k * ( ( 10 - digit ) % 10 ) NEW_LINE ans += add NEW_LINE if ( sum ( ans ) <= s ) : NEW_LINE INDENT break NEW_LINE DEDENT k *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT n , s = 3 , 2 NEW_LINE print ( smallestNumber ( n , s ) ) NEW_LINE"}
{"text": "Memaksimumkan kiraan penurunan seterusnya berturut -turut dari array | Program Python untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum bilangan berikutnya yang diperlukan; Kamus untuk menyimpan bilangan anak panah yang tersedia dengan ketinggian anak panah sebagai kunci; Menyimpan kiraan maksimum kemungkinan berikutnya; Menyimpan kiraan kemungkinan seterusnya; Semak jika elemen saya boleh menjadi sebahagian daripada mana -mana berikutnya; Kiraan seterusnya mungkin dengan arr [i] sebagai elemen seterusnya; Jika lebih daripada satu berikutnya wujud; Termasuk arr [i] dalam berikutnya; Jika tidak; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Mulakan berikutnya baru; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Kembalikan jawapannya; Kod pemacu", "code": "from collections import defaultdict NEW_LINE def maxSubsequences ( arr , n ) -> int : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE maxCount = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT count = m [ arr [ i ] ] NEW_LINE if count > 1 : NEW_LINE INDENT m [ arr [ i ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT m . pop ( arr [ i ] ) NEW_LINE DEDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT maxCount += 1 NEW_LINE INDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT return maxCount NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 4 , 5 , 2 , 1 , 4 ] NEW_LINE print ( maxSubsequences ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Keluarkan kejadian pertama dan terakhir yang diberikan dari rentetan | Berfungsi untuk menghapuskan kejadian pertama dan terakhir dari watak yang diberikan dari rentetan yang diberikan; Melintasi rentetan yang diberikan dari awal; Jika ch dijumpai; Melintasi rentetan yang diberikan dari hujungnya; Jika ch dijumpai; Kod pemacu", "code": "def removeOcc ( s , ch ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT s = \" hello ▁ world \" NEW_LINE ch = ' l ' NEW_LINE print ( removeOcc ( s , ch ) ) NEW_LINE"}
{"text": "Langkah -langkah minimum untuk meningkatkan dan mengurangkan array untuk mencapai 0 atau n | Program Python3 untuk pendekatan di atas; Fungsi yang mendapati langkah -langkah minimum untuk mencapai 0 atau n untuk peningkatan array yang semakin meningkat dan menurun; Memulakan pemboleh ubah untuk mencari elemen minimum; Cari elemen minimum dalam peningkatan array; Memulakan pembolehubah untuk mencari elemen maksimum; Cari elemen maksimum dalam penurunan array; Cari langkah minimum; Langkah minimum; Kod pemacu; Diberikan n; Memandangkan peningkatan dan penurunan array; Panggilan fungsi", "code": "import sys NEW_LINE def minSteps ( N , increasing , decreasing ) : NEW_LINE INDENT Min = sys . maxsize ; NEW_LINE for i in increasing : NEW_LINE INDENT if ( Min > i ) : NEW_LINE INDENT Min = i ; NEW_LINE DEDENT DEDENT Max = - sys . maxsize ; NEW_LINE for i in decreasing : NEW_LINE INDENT if ( Max < i ) : NEW_LINE INDENT Max = i ; NEW_LINE DEDENT DEDENT minSteps = max ( Max , N - Min ) ; NEW_LINE print ( minSteps ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 7 ; NEW_LINE increasing = [ 3 , 5 ] ; NEW_LINE decreasing = [ 6 ] ; NEW_LINE minSteps ( N , increasing , decreasing ) ; NEW_LINE DEDENT"}
{"text": "Bilangan minimum swap bersebelahan yang diperlukan untuk menukar permutasi kepada permutasi lain dengan keadaan yang diberikan | Berfungsi untuk mencari bilangan swap minimum; Array baru untuk menukar kepada pengindeksan berasaskan 1; Menyimpan swap; Semak sama ada kedudukan 'X'; Kes sudut; Swap; Cetak swap minimum; Diberi nombor n; Diberi permutasi nombor N; Panggilan fungsi", "code": "def solve ( P , n ) : NEW_LINE INDENT arr = [ ] NEW_LINE arr . append ( 0 ) NEW_LINE for x in P : NEW_LINE INDENT arr . append ( x ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if ( arr [ n ] == n ) : NEW_LINE INDENT arr [ n - 1 ] , arr [ n ] = arr [ n ] , arr [ n - 1 ] NEW_LINE cnt += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT N = 9 NEW_LINE P = [ 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 ] NEW_LINE solve ( P , N ) NEW_LINE"}
{"text": "Count of Prima yang menarik sehingga n | Berfungsi untuk mencari semua nombor utama; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Mengemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat itu; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Untuk menyimpan semua prima; Untuk menyimpan semua prima interset; Simpan semua dataran yang sempurna; Simpan semua quadruples yang sempurna; Simpan semua prima interset; Kembali kiraan prima interset; Kod pemacu", "code": "def SieveOfEratosthenes ( n , allPrimes ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT allPrimes . add ( p ) NEW_LINE DEDENT DEDENT DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT allPrimes = set ( ) NEW_LINE SieveOfEratosthenes ( n , allPrimes ) NEW_LINE interestingPrimes = set ( ) NEW_LINE squares , quadruples = [ ] , [ ] NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT squares . append ( i * i ) NEW_LINE i += 1 NEW_LINE DEDENT i = 1 NEW_LINE while i * i * i * i <= n : NEW_LINE INDENT quadruples . append ( i * i * i * i ) NEW_LINE i += 1 NEW_LINE DEDENT for a in squares : NEW_LINE INDENT for b in quadruples : NEW_LINE INDENT if a + b in allPrimes : NEW_LINE INDENT interestingPrimes . add ( a + b ) NEW_LINE DEDENT DEDENT DEDENT return len ( interestingPrimes ) NEW_LINE DEDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE"}
{"text": "Semak jika array adalah array gelombang | Fungsi untuk memeriksa sama ada array adalah array gelombang arr: array input n: saiz array; Semak borang gelombang jika ARR [1] lebih besar daripada kiri dan kanan. Corak yang sama akan diikuti oleh seluruh elemen, corak terbalik lain akan diikuti oleh unsur -unsur array; Semak elemen terakhir; Semak elemen terakhir; Kod pemacu; Array", "code": "def isWaveArray ( arr , n ) : NEW_LINE INDENT result = True NEW_LINE if ( arr [ 1 ] > arr [ 0 ] and arr [ 1 ] > arr [ 2 ] ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] <= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT DEDENT elif ( arr [ 1 ] < arr [ 0 ] and arr [ 1 ] < arr [ 2 ] ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isWaveArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Mengira urutan yang berbeza yang diperoleh dengan menggantikan semua elemen subarray yang mempunyai unsur -unsur pertama dan terakhir yang sama dengan elemen pertama sebilangan kali | Fungsi untuk mengira bilangan urutan yang memenuhi kriteria yang diberikan; Menyimpan indeks kejadian terakhir elemen; Memulakan array untuk menyimpan bilangan urutan yang berbeza yang mungkin panjang i; Kes asas; Sekiranya tiada operasi digunakan pada elemen ITH; Jika operasi digunakan pada elemen ITH; Mengemas kini kejadian terakhir Curele; Akhirnya, jawapannya; Kod pemacu", "code": "def countPossiblities ( arr , n ) : NEW_LINE INDENT lastOccur = [ - 1 ] * 100000 NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curEle = arr [ i - 1 ] NEW_LINE dp [ i ] = dp [ i - 1 ] NEW_LINE if ( lastOccur [ curEle ] != - 1 and lastOccur [ curEle ] < i - 1 ) : NEW_LINE INDENT dp [ i ] += dp [ lastOccur [ curEle ] ] NEW_LINE DEDENT lastOccur [ curEle ] = i NEW_LINE DEDENT print ( dp [ n ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE countPossiblities ( arr , N ) NEW_LINE DEDENT"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Berfungsi untuk jumlah maksimum; Jadual DP; Kes asas; Melintasi setiap lajur; Kemas kini jawapan untuk kedua -dua baris; Cetak jumlah maksimum; Kod pemacu; Diberikan array; Bilangan lajur; Panggilan fungsi", "code": "def maxSum ( arr , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( 2 ) ] NEW_LINE dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] NEW_LINE dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) NEW_LINE DEDENT DEDENT DEDENT print ( max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] NEW_LINE N = len ( arr [ 0 ] ) NEW_LINE maxSum ( arr , 2 , N ) NEW_LINE DEDENT"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Fungsi untuk mencetak jumlah maksimum yang mungkin dengan memilih kebanyakan elemen dari setiap lajur sehingga tiada pasangan berturut -turut dipilih dari satu baris; Memulakan pembolehubah; Melintasi setiap lajur; Jawapan cetak; Kod pemacu; Lajur nombor", "code": "def maxSum ( arr , n ) : NEW_LINE INDENT r1 = r2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r1 , r2 = max ( r1 , r2 + arr [ 0 ] [ i ] ) , max ( r2 , r1 + arr [ 1 ] [ i ] ) NEW_LINE DEDENT print ( max ( r1 , r2 ) ) NEW_LINE DEDENT arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] NEW_LINE n = len ( arr [ 0 ] ) NEW_LINE maxSum ( arr , n ) NEW_LINE"}
{"text": "Kira unimodal dan bukan | Program Python3 untuk pendekatan di atas; Berfungsi untuk mengira faktorial sehingga nombor; Kirakan faktorial; Berfungsi untuk mencari kuasa (a, b); Melangkah sehingga B wujud; Jika B boleh dibahagikan dengan 2; Mengurangkan nilai b; Kembalikan jawapannya; Fungsi yang mengira permutasi unimodal dan bukan unimodal dari integer yang diberikan; Fungsi panggilan untuk mencari faktorial sehingga n; Berfungsi untuk mengira permutasi unimodal; Permutasi bukan unimodal adalah N! - permutasi unimodal; Kod pemacu diberi nombor n; Panggilan fungsi", "code": "mod = 1e9 + 7 NEW_LINE mx = 1000000 NEW_LINE fact = [ 0 ] * ( mx + 1 ) NEW_LINE def Calculate_factorial ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE fact [ i ] %= mod NEW_LINE DEDENT DEDENT def UniModal_per ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b != 0 ) : NEW_LINE INDENT if ( b % 2 != 0 ) : NEW_LINE INDENT res = res * a NEW_LINE DEDENT res %= mod NEW_LINE a = a * a NEW_LINE a %= mod NEW_LINE b //= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT def countPermutations ( n ) : NEW_LINE INDENT Calculate_factorial ( ) NEW_LINE uni_modal = UniModal_per ( 2 , n - 1 ) NEW_LINE nonuni_modal = fact [ n ] - uni_modal NEW_LINE print ( int ( uni_modal ) , \" \" , int ( nonuni_modal ) ) NEW_LINE return NEW_LINE DEDENT N = 4 NEW_LINE countPermutations ( N ) NEW_LINE"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Pelaksanaan Python3 untuk mencari dataran terbesar dalam matriks sehingga ia mengandungi paling banyak k 1 s; Berfungsi untuk mengira dataran terbesar dengan atmost k 1 s untuk pertanyaan Q; Gelung untuk menyelesaikan setiap pertanyaan; Melintasi setiap sub persegi dan mengira jumlah; Pecah apabila melebihi kiraan maksimum; Kod pemacu", "code": "MAX = 100 NEW_LINE def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT for q in range ( Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) NEW_LINE ans = - 1 NEW_LINE for k in range ( min_dist + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for row in range ( i - k , i + k + 1 ) : NEW_LINE INDENT for col in range ( j - k , j + k + 1 ) : NEW_LINE INDENT count += matrix [ row ] [ col ] NEW_LINE DEDENT DEDENT if count > K : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputing jumlah awalan countdp matriks; Gelung untuk menyelesaikan pertanyaan; Mengira jarak maksimum yang mungkin dari pusat dari tepi; Mengira bilangan 1 s dalam submatrix; Kod pemacu", "code": "def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE for k in range ( 0 , min_dist + 1 ) : NEW_LINE INDENT x1 = i - k NEW_LINE x2 = i + k NEW_LINE y1 = j - k NEW_LINE y2 = j + k NEW_LINE count = countDP [ x2 ] [ y2 ] ; NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count > K ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE"}
{"text": "N Masalah Tali berturut -turut | Berfungsi untuk mengembalikan kos minimum untuk menyambungkan tali yang diberikan; dp [i] [j] = kos minimum dalam julat (i, j) jumlah [i] [j] = jumlah julat (i, j); Memulakan sum jadual memset (jumlah, 0, sizeof (0)); ; Pengkomputeran kos minimum untuk semua selang waktu yang mungkin (i, j) julat kiri; Julat kanan; Tiada kos untuk tali tunggal; Kod pemacu", "code": "def MinCost ( arr , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE sum = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT sum [ i ] [ j ] = k NEW_LINE DEDENT else : NEW_LINE INDENT k += arr [ j ] NEW_LINE sum [ i ] [ j ] = k NEW_LINE DEDENT DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT arr = [ 7 , 6 , 8 , 6 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCost ( arr , n ) ) NEW_LINE"}
{"text": "Panjang subsegment terpanjang yang dikemas kini selepas memasukkan atmost satu integer | Berfungsi untuk mengisi semula array DP; Jika f (i, state) sudah dikira maka kembalikan nilai; Hitung f (i, state) mengikut hubungan berulang dan simpan dalam dp [] []; Fungsi yang memanggil fungsi resucrsive untuk mengisi array DP dan kemudian mengembalikan hasilnya; dp [] [] array untuk menyimpan hasil f (i, 1) dan f (1, 2) memaparkan array dp [] dengan - 1; Pastikan urutan UD dan DU terpanjang bermula pada setiap indeks dikira; Anggapkan jawapannya - 1 Nilai ini hanya akan meningkat; y ialah panjang urutan UD terpanjang bermula pada i; Jika panjangnya, tambah integer dan kemudian urutan du bermula pada i + y; Jika panjang ganjil maka tambah integer dan kemudian urutan ud bermula pada i + y; Kod pemacu", "code": "def f ( i , state , A , dp , N ) : NEW_LINE INDENT if i >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif dp [ i ] [ state ] != - 1 : NEW_LINE INDENT return dp [ i ] [ state ] NEW_LINE DEDENT else : NEW_LINE INDENT if i == N - 1 : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] > A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 2 and A [ i ] < A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) NEW_LINE DEDENT elif state == 2 and A [ i ] >= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) NEW_LINE DEDENT return dp [ i ] [ state ] NEW_LINE DEDENT DEDENT def maxLenSeq ( A , N ) : NEW_LINE INDENT dp = [ [ - 1 , - 1 , - 1 ] for i in range ( 1000 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT tmp = f ( i , 1 , A , dp , N ) NEW_LINE tmp = f ( i , 2 , A , dp , N ) NEW_LINE DEDENT ans = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT y = dp [ i ] [ 1 ] NEW_LINE if ( i + y ) >= N : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 ) NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) NEW_LINE DEDENT elif y % 2 == 1 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 10 , 3 , 20 , 25 , 24 ] NEW_LINE n = len ( A ) NEW_LINE print ( maxLenSeq ( A , n ) ) NEW_LINE DEDENT"}
{"text": "Keluarkan elemen untuk memaksimumkan GCD array yang diberikan | Pelaksanaan Python3 pendekatan di atas; Berfungsi untuk mengembalikan GCD yang dimaksimumkan selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD dari semua elemen yang mempunyai lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan GCD yang dimaksimumkan; Kod pemacu", "code": "import math as mt NEW_LINE def MaxGCD ( a , n ) : NEW_LINE INDENT Prefix = [ 0 for i in range ( n + 2 ) ] NEW_LINE Suffix = [ 0 for i in range ( n + 2 ) ] NEW_LINE Prefix [ 1 ] = a [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = mt . gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT Suffix [ n ] = a [ n - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = mt . gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT ans = max ( ans , mt . gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 14 , 17 , 28 , 70 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxGCD ( a , n ) ) NEW_LINE"}
{"text": "SUM MAXIMUM SUMBER DENGAN MENGURANGKAN TANDA PALING PADA ELEMENT ARAY KEDUA | Pelaksanaan Python3 pendekatan; Berfungsi untuk mencari jumlah subarray maksimum dengan flip bermula dari indeks I; Jika bilangan flip telah melebihi; Traversal lengkap; Sekiranya negara sebelum ini telah dikunjungi; Pada mulanya; Gunakan algoritma Kadane dan hubungi dua negeri; Memoize jawapan dan mengembalikannya; Fungsi utiliti untuk memanggil flips dari indeks dan mengembalikan jawapannya; Buat array dp int dp [n, k + 1]; ITERATE dan CALL FUNGSI RECURSIF DARI SETIAP INDEX UNTUK MEMBERI JUMLAH SUBARRAY MAXIMUM; sudut casae; Kod pemacu", "code": "import numpy as np NEW_LINE right = 3 ; NEW_LINE left = 6 ; NEW_LINE dp = np . ones ( ( left , right ) ) NEW_LINE dp = - 1 * dp NEW_LINE def findSubarraySum ( ind , flips , n , a , k ) : NEW_LINE INDENT if ( flips > k ) : NEW_LINE INDENT return - 1e9 ; NEW_LINE DEDENT if ( ind == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ ind ] [ flips ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ flips ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; NEW_LINE ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; NEW_LINE dp [ ind ] [ flips ] = ans ; NEW_LINE return dp [ ind ] [ flips ] ; NEW_LINE DEDENT def findMaxSubarraySum ( a , n , k ) : NEW_LINE INDENT ans = - 1e9 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; NEW_LINE DEDENT if ans == 0 and k == 0 : NEW_LINE return max ( a ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 100 , - 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 1 ; NEW_LINE print ( findMaxSubarraySum ( a , n , k ) ) ; NEW_LINE DEDENT"}
{"text": "Cari Jumlah Nombor Fibonacci Pertama N yang pertama | Program Python3 untuk mencari jumlah nombor Fibonacci yang pertama; Fungsi untuk mengira jumlah nombor Fibonacci yang pertama; nilai asas; Kod pemacu", "code": "mod = 1000000007 ; NEW_LINE def sumOddFibonacci ( n ) : NEW_LINE INDENT Sum = [ 0 ] * ( n + 1 ) ; NEW_LINE Sum [ 0 ] = 0 ; NEW_LINE Sum [ 1 ] = 1 ; NEW_LINE Sum [ 2 ] = 2 ; NEW_LINE Sum [ 3 ] = 5 ; NEW_LINE Sum [ 4 ] = 10 ; NEW_LINE Sum [ 5 ] = 23 ; NEW_LINE for i in range ( 6 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; NEW_LINE DEDENT return Sum [ n ] ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( sumOddFibonacci ( n ) ) ; NEW_LINE"}
{"text": "Kurangkan jumlah teddies untuk diedarkan | Pelaksanaan Python pendekatan di atas; Memulakan satu tablet untuk setiap pelajar; Jika dibiarkan bersebelahan mempunyai kajian markah yang lebih tinggi dan mengubah semua nilai DP yang diberikan sebelum sehingga nilai DP yang diberikan didapati salah mengikut kekangan yang diberikan; Jika betul bersebelahan mempunyai markah yang lebih tinggi, tambahkan satu di dp kiri bersebelahan dan berikan ke kanan; n bilangan pelajar; tanda pelajar; penyelesaian masalah", "code": "def fun ( marks , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if marks [ i ] > marks [ i + 1 ] : NEW_LINE INDENT temp = i NEW_LINE while True : NEW_LINE INDENT if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : NEW_LINE INDENT if dp [ temp ] > dp [ temp + 1 ] : NEW_LINE INDENT temp -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ temp ] = dp [ temp + 1 ] + 1 NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT elif marks [ i ] < marks [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT DEDENT return ( sum ( dp ) ) NEW_LINE DEDENT n = 6 NEW_LINE marks = [ 1 , 4 , 5 , 2 , 2 , 1 ] NEW_LINE print ( fun ( marks , n ) ) NEW_LINE"}
{"text": "Bilangan cara untuk mencapai lantai nth dengan mengambil di | Program Python3 untuk mencapai tangga dengan mengambil maksimum l leap; unsur -unsur kombo [] menyimpan cara yang tidak mungkin untuk mencapainya dengan semua kombinasi K Leaps atau kurang; Dengan mengandaikan lompatan 0 wujud dan memberikan nilainya kepada 1 untuk pengiraan; gelung untuk melangkah ke atas semua kemungkinan melompat sehingga K; ; Dalam gelung ini kita mengira semua kemungkinan lompatan untuk mencapai tangga jth dengan bantuan lompatan atau kurang; Jika lompatan itu tidak lebih daripada i - j; Kirakan nilai dan simpan dalam combo [j] untuk menggunakannya semula untuk pengiraan lompatan seterusnya untuk tangga jth; Mengembalikan tidak ada kemungkinan lompatan untuk mencapai bahagian atas bangunan n tangga; Kod pemacu; N i tangga total k adalah nilai lompatan terbesar", "code": "def solve ( N , K ) : NEW_LINE INDENT combo = [ 0 ] * ( N + 1 ) NEW_LINE combo [ 0 ] = 1 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if j >= i : NEW_LINE INDENT combo [ j ] += combo [ j - i ] NEW_LINE DEDENT DEDENT DEDENT return combo [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE DEDENT"}
{"text": "Cari yang paling lama meningkat seterusnya secara bulat | Kaedah utiliti untuk mencari LIS menggunakan pengaturcaraan dinamik; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Tetapkan j berdasarkan tetingkap semasa i. e. elemen pertama tetingkap semasa; Pilih maksimum semua nilai LIS; Berfungsi untuk mencari peningkatan yang paling lama dalam cara bulat; Buat salinan Array yang diberikan dengan memasuki elemen array yang sama kepada dirinya sendiri; Lakukan lis untuk setiap tetingkap saiz n; Kod pemacu", "code": "def computeLIS ( circBuff , start , end , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( end ) ] NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( start + 1 , end ) : NEW_LINE INDENT for j in range ( start , i ) : NEW_LINE INDENT if ( circBuff [ i ] > circBuff [ j ] and LIS [ i ] < LIS [ j ] + 1 ) : NEW_LINE INDENT LIS [ i ] = LIS [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT res = - 100000 NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT res = max ( res , LIS [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def LICS ( arr , n ) : NEW_LINE INDENT circBuff = [ 0 for i in range ( 2 * n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n , 2 * n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i - n ] NEW_LINE DEDENT res = - 100000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( computeLIS ( circBuff , i , i + n , n ) , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 4 , 6 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length ▁ of ▁ LICS ▁ is \" , LICS ( arr , n ) ) NEW_LINE"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Berfungsi untuk mencari pekali binomial; Membina segitiga Pascal; Kod pemacu", "code": "def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( \" Number ▁ of ▁ Paths : \" , binomialCoeff ( n + m , n ) ) NEW_LINE"}
{"text": "Susunan peningkatan yang paling lama (LCS + LIS) | Mengembalikan panjang dan LCIS dua array ARR1 [0. n - 1] dan arr2 [0 .. m - 1]; Jadual [J] akan menyimpan panjang LCI yang berakhir dengan ARR2 [J]. Kami memulakannya sebagai 0 ,; Melintasi semua elemen ARR1 []; Memulakan panjang semasa LCI; Untuk setiap elemen arr1 [], melintasi semua elemen ARR2 []. ; Jika kedua -dua array mempunyai elemen yang sama. Perhatikan bahawa kami tidak memecahkan gelung di sini. ; Sekarang cari elemen umum yang lebih kecil sebelumnya untuk elemen semasa ARR1; Nilai maksimum dalam Jadual [] adalah hasil; Kod pemacu", "code": "def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 3 , 4 , 9 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( \" Length ▁ of ▁ LCIS ▁ is \" , LCIS ( arr1 , n , arr2 , m ) ) NEW_LINE DEDENT"}
{"text": "Panjang awalan biasa terpanjang mungkin dengan menyusun semula rentetan dalam array yang diberikan | Program Python3 untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan panjang awalan biasa terpanjang dengan menyusun semula rentetan; freq [i] [j]: Menyimpan kekerapan aksara (= j) dalam arr [i]; Melintasi array yang diberikan; Kedai panjang rentetan semasa; Melintasi rentetan arus array yang diberikan; Kemas kini nilai freq [i] [arr [i] [j]]; Menyimpan panjang awalan biasa terpanjang; Kira kekerapan minimum setiap aksara dalam semua rentetan arr []; Kedai nilai minimum dalam setiap baris freq [] []; Kirakan kekerapan minimum aksara semasa dalam semua rentetan. ; Kemas kini Minrowval; Kemas kini Maxlen; Kod pemacu", "code": "import sys NEW_LINE def longComPre ( arr , N ) : NEW_LINE INDENT freq = [ [ 0 for i in range ( 256 ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT M = len ( arr [ i ] ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT freq [ i ] [ ord ( arr [ i ] [ j ] ) ] += 1 NEW_LINE DEDENT DEDENT maxLen = 0 NEW_LINE for j in range ( 256 ) : NEW_LINE INDENT minRowVal = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT minRowVal = min ( minRowVal , freq [ i ] [ j ] ) NEW_LINE DEDENT maxLen += minRowVal NEW_LINE DEDENT return maxLen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" aabdc \" , \" abcd \" , \" aacd \" ] NEW_LINE N = 3 NEW_LINE print ( longComPre ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Keluarkan aksara dari rentetan yang kelihatan tepat k kali | Program Python 3 untuk menghapuskan aksara dari rentetan yang muncul tepat kali K; Berfungsi untuk mengurangkan rentetan dengan mengeluarkan aksara yang kelihatan tepat K kali; Jadual Hash diasaskan kepada 0; Meningkatkan kekerapan watak; Untuk menyimpan jawapan; Indeks seterusnya dalam rentetan yang dikurangkan; Tambah watak -watak yang kelihatan tepat K kali; Kod pemacu; Panggilan fungsi", "code": "MAX_CHAR = 26 NEW_LINE def removeChars ( arr , k ) : NEW_LINE INDENT hash = [ 0 ] * MAX_CHAR NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE print ( removeChars ( str , k ) ) NEW_LINE DEDENT"}
{"text": "Subsegments bersebelahan rentetan yang mempunyai aksara berikutnya yang berbeza | Fungsi yang mencetak segmen; Arahan baru untuk setiap lelaran; Periksa sama ada watak itu dalam array; Kod pemacu", "code": "def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT string = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE"}
{"text": "Program untuk mencari perkataan yang disulitkan | Berfungsi untuk mencari rentetan yang disulitkan; untuk menyimpan rentetan yang disulitkan; Selepas 'Z', ia harus pergi ke a. ; Kod pemacu", "code": "def findWord ( c , n ) : NEW_LINE INDENT co = 0 NEW_LINE s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n / 2 ) : NEW_LINE INDENT co += 1 NEW_LINE DEDENT else : NEW_LINE INDENT co = n - i NEW_LINE DEDENT if ( ord ( c [ i ] ) + co <= 122 ) : NEW_LINE INDENT s [ i ] = chr ( ord ( c [ i ] ) + co ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = chr ( ord ( c [ i ] ) + co - 26 ) NEW_LINE DEDENT DEDENT print ( * s , sep = \" \" ) NEW_LINE DEDENT s = \" abcd \" NEW_LINE findWord ( s , len ( s ) ) NEW_LINE"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; panjang rentetan pertama; panjang rentetan kedua; Jika panjang tidak sama hanya kembali palsu kerana kedua -dua rentetan tidak boleh sama jika panjang tidak sama; gelung untuk memadankan satu demi satu semua watak kedua -dua rentetan; Jika aksara semasa kedua -dua rentetan adalah sama, tambah nilai saya untuk membandingkan watak seterusnya; Jika mana -mana watak rentetan pertama adalah beberapa watak khas atau aksara angka dan tidak sama dengan watak yang sama rentetan kedua kemudian kembali palsu; Lakukan perkara yang sama untuk rentetan kedua; Blok kod ini akan dilaksanakan jika watak -watak kedua -dua rentetan adalah kes yang berbeza; Bandingkan watak dengan nilai ASCII; Jika watak dipadankan, tingkatkan nilai saya untuk membandingkan char seterusnya; Jika semua aksara rentetan pertama dipadankan dengan aksara yang sepadan dengan rentetan kedua, maka kembali benar; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE if ( len1 != len2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < len1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( ( ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) or ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( ( ( str2 [ i ] >= ' a ' and str2 [ i ] <= ' z ' ) or ( str2 [ i ] >= ' A ' and str2 [ i ] <= ' Z ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT if ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) : NEW_LINE INDENT if ( ord ( str1 [ i ] ) - 32 != ord ( str2 [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) : NEW_LINE INDENT if ( ord ( str1 [ i ] ) + 32 != ord ( str2 [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Same \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" Geeks \" NEW_LINE str2 = \" geeks \" NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) NEW_LINE str1 = \" Geek \" NEW_LINE str2 = \" geeksforgeeks \" NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan nilai A dengan menggantikan beberapa digitnya dengan digit B | Berfungsi untuk mengembalikan nilai yang dimaksimumkan A; Jenis digit dalam urutan menaik; J menunjuk kepada digit terbesar di B; Jika semua digit B telah digunakan; Digit semasa telah digunakan; Mengembalikan nilai yang dimaksimumkan; Kod pemacu", "code": "def maxValue ( a , b ) : NEW_LINE INDENT b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT x = \" \" . join ( ai ) NEW_LINE return x NEW_LINE DEDENT a = \"1234\" NEW_LINE b = \"4321\" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE"}
{"text": "Mengira nombor dalam julat supaya digit di dalamnya dan produknya dengan Q tidak sama rata | Berfungsi untuk memeriksa sama ada semua digit dalam nombor dan produknya dengan Q tidak sama atau tidak; Tukar nombor pertama ke dalam rentetan; Masukkan elemen dari nombor 1 ke hash; Hitung produk yang sepadan; Tukar produk ke rentetan; Menggunakan Hash Check jika mana -mana digit padanan produk dengan digit nombor input; Jika ya, kembali palsu; Kembali benar; Berfungsi untuk mengira nombor dalam julat [l, r] supaya semua digit nombor dan produknya dengan Q tidak sama rata; Semak setiap nombor antara L dan R; Kod pemacu; Panggilan fungsi", "code": "def checkIfUnequal ( n , q ) : NEW_LINE INDENT s1 = str ( n ) NEW_LINE a = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , len ( s1 ) , 1 ) : NEW_LINE INDENT a [ ord ( s1 [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT prod = n * q NEW_LINE s2 = str ( prod ) NEW_LINE for i in range ( 0 , len ( s2 ) , 1 ) : NEW_LINE INDENT if ( a [ ord ( s2 [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countInRange ( l , r , q ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( checkIfUnequal ( i , q ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 10 NEW_LINE r = 12 NEW_LINE q = 2 NEW_LINE print ( countInRange ( l , r , q ) ) NEW_LINE DEDENT"}
{"text": "Semak sama ada mungkin untuk menyusun semula rentetan binari dengan alternatif 0 s dan 1 s | berfungsi untuk memeriksa rentetan binari; panjang rentetan; Count Zero; Kira satu 's; jika panjangnya; jika panjang ganjil; Kod pemacu", "code": "def is_possible ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT if ( l % 2 == 0 ) : NEW_LINE INDENT return ( one == zero ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( abs ( one - zero ) == 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"100110\" NEW_LINE if ( is_possible ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program python3 untuk mengira frekuensi item array; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi aksara rentetan dan mengira frekuensi;", "code": "limit = 255 NEW_LINE def countFreq ( Str ) : NEW_LINE INDENT count = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( chr ( i ) , count [ i ] ) NEW_LINE DEDENT DEDENT / * Driver Code * / NEW_LINE Str = \" GeeksforGeeks \" NEW_LINE countFreq ( Str ) NEW_LINE"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT y = bin ( K ) . count ( '1' ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT print ( \" Even ▁ = \" , odd , \" , ▁ Odd ▁ = \" , even ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Even ▁ = \" , even , \" , ▁ Odd ▁ = \" , odd ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE countEvenOdd ( arr , n , K ) ; NEW_LINE DEDENT"}
{"text": "Google Case Of A Sentyen tertentu | Program Python untuk menukar ayat yang diberikan kepada kes unta. ; Berfungsi untuk mengeluarkan ruang dan menukar ke dalam kes unta; Semak ruang dalam ayat; penukaran ke atas kes; Jika tidak ruang, salin watak; kembali rentetan ke Main; Kod pemacu", "code": "import math NEW_LINE def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = \" \" NEW_LINE s1 = s1 + s [ 0 ] . lower ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' and i <= n ) : NEW_LINE INDENT s1 = s1 + \" ▁ \" + ( s [ i + 1 ] ) . lower ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 = s1 + ( s [ i ] ) . upper ( ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return s1 NEW_LINE DEDENT str = \" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks \" NEW_LINE print ( convert ( str ) ) NEW_LINE"}
{"text": "Program untuk mencari n | Program Python3 untuk mencari nombor n - th yang mengandungi hanya 3 dan 5 .; Jika n adalah ganjil, tambah 3 dan pindah ke ibu bapa; Jika n adalah, tambah 5 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu", "code": "def reverse ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return reverse ( s [ 1 : ] ) + s [ 0 ] NEW_LINE DEDENT DEDENT def findNthNo ( n ) : NEW_LINE INDENT res = \" \" ; NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT res = res + \"3\" ; NEW_LINE n = ( int ) ( ( n - 1 ) / 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res = res + \"5\" ; NEW_LINE n = ( int ) ( ( n - 2 ) / 2 ) ; NEW_LINE DEDENT DEDENT return reverse ( res ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( findNthNo ( n ) ) ; NEW_LINE"}
{"text": "Nth non | Program Python3 untuk mencari nombor bukan persegi. ; berfungsi untuk mencari nombor non non - persegi; Penukaran dari Int ke Long Double diperlukan untuk memelihara tempat perpuluhan selepas akar persegi. ; mengira hasilnya; memulakan nombor jangka panjang; Cetak hasilnya", "code": "import math NEW_LINE def findNthNonSquare ( n ) : NEW_LINE INDENT x = n ; NEW_LINE ans = x + math . floor ( 0.5 + math . sqrt ( x ) ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT n = 16 ; NEW_LINE print ( \" The \" , n , \" th ▁ Non - Square ▁ number ▁ is \" , findNthNonSquare ( n ) ) ; NEW_LINE"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Fungsi untuk mengira jumlah siri; Kod pemacu", "code": "def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT n = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( int ( seiresSum ( n , a ) ) ) NEW_LINE"}
{"text": "Cari nombor n yang mengandungi digit k atau dibahagikan dengan k. | Fungsi untuk memeriksa jika digit k berada dalam n atau tidak; mencari selebihnya; jika digit dijumpai; Fungsi untuk mencari nombor nth; Oleh kerana k adalah yang pertama yang memenuhi kriteria, jadi pertimbangkannya dalam kiraan membuat kiraan = 1 dan bermula dari i = k + 1; Memeriksa bahawa nombor itu mengandungi k digit atau dibahagikan oleh k; Kod pemacu", "code": "def checkdigit ( n , k ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT rem = n % 10 NEW_LINE if ( rem == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def findNthNumber ( n , k ) : NEW_LINE INDENT i = k + 1 NEW_LINE count = 1 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( checkdigit ( i , k ) or ( i % k == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( findNthNumber ( n , k ) ) NEW_LINE"}
{"text": "Count subarrays saiz K yang merupakan permutasi nombor dari 1 hingga k | Program Python3 untuk melaksanakan pendekatan di atas; Simpan indeks nombor array; Kemas kini indeks min dan max dengan indeks semasa dan periksa sama ada ia adalah permutasi yang sah; Kod pemacu", "code": "def find_permutations ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE max_ind = - 1 NEW_LINE min_ind = 10000000 ; NEW_LINE n = len ( arr ) NEW_LINE index_of = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT index_of [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_ind = max ( max_ind , index_of [ i ] ) NEW_LINE min_ind = min ( min_ind , index_of [ i ] ) NEW_LINE if ( max_ind - min_ind + 1 == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT nums = [ ] NEW_LINE nums . append ( 2 ) NEW_LINE nums . append ( 3 ) NEW_LINE nums . append ( 1 ) NEW_LINE nums . append ( 5 ) NEW_LINE nums . append ( 4 ) NEW_LINE print ( find_permutations ( nums ) ) NEW_LINE DEDENT"}
{"text": "Count of integer yang membahagikan semua elemen array yang diberikan | Berfungsi untuk mengembalikan kiraan bilangan bulat yang diperlukan; Untuk menyimpan GCD unsur -unsur array; Untuk menyimpan kiraan faktor GCD yang dijumpai; Jika G adalah persegi yang sempurna; Faktor muncul berpasangan; Kod pemacu", "code": "from math import gcd as __gcd NEW_LINE def getCount ( a , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( gcd , a [ i ] ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , gcd + 1 ) : NEW_LINE INDENT if i * i > gcd : NEW_LINE INDENT break NEW_LINE DEDENT if ( gcd % i == 0 ) : NEW_LINE INDENT if ( i * i == gcd ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 2 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT a = [ 4 , 16 , 1024 , 48 ] NEW_LINE n = len ( a ) NEW_LINE print ( getCount ( a , n ) ) NEW_LINE"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Menyimpan watak -watak yang dikunjungi; Menyimpan jawapannya; Melintasi rentetan; Jika sudah dikunjungi; Menyimpan kos maksimum untuk mengeluarkan watak tertentu; Simpan jumlah kos penghapusan watak tertentu; Tandakan watak semasa yang dikunjungi; Melintasi indeks rentetan [i, n - 1]; Jika ada pendua yang dijumpai; Mengemas kini kos maksimum dan jumlah kos; Tandakan watak semasa yang dikunjungi; Simpan watak dengan kos maksimum dan padamkan yang lain; Mengembalikan kos minimum; Kod pemandu diberikan rentetan; Arahan input; Arahan input; Panggilan fungsi", "code": "def delCost ( s , cost ) : NEW_LINE INDENT visited = [ False ] * len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT maxDel = 0 NEW_LINE totCost = 0 NEW_LINE visited [ i ] = True NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT maxDel = max ( maxDel , cost [ j ] ) NEW_LINE totCost += cost [ j ] NEW_LINE visited [ j ] = True NEW_LINE DEDENT DEDENT ans += totCost - maxDel NEW_LINE DEDENT return ans NEW_LINE DEDENT string = \" AAABBB \" NEW_LINE cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE string = \" AAABBB \" NEW_LINE print ( delCost ( string , cost ) ) NEW_LINE"}
{"text": "Buat semua elemen array sama dengan menggantikan tiga kali ganda dengan bitwise xor mereka | Fungsi untuk mencari tiga kali ganda yang menggantikannya dengan XOR mereka membuat semua elemen array sama; Jika n juga; Hitung XOR unsur array; Melintasi array; Kemas kini XOR; Jika XOR tidak sama dengan 0; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi", "code": "def checkXOR ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT xro = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT xro ^= arr [ i ] ; NEW_LINE DEDENT if ( xro != 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( 0 , N - 3 , 2 ) : NEW_LINE INDENT print ( i , \" ▁ \" , ( i + 1 ) , \" ▁ \" , ( i + 2 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT for i in range ( 0 , N - 3 , 2 ) : NEW_LINE INDENT print ( i , \" ▁ \" , ( i + 1 ) , \" ▁ \" , ( N - 1 ) , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 0 , N - 2 , 2 ) : NEW_LINE INDENT print ( i , \" ▁ \" , ( i + 1 ) , \" ▁ \" , ( i + 2 ) ) ; NEW_LINE DEDENT for i in range ( 0 , N - 2 , 2 ) : NEW_LINE INDENT print ( i , \" ▁ \" , ( i + 1 ) , \" ▁ \" , ( N - 1 ) ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 1 , 7 , 2 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE checkXOR ( arr , N ) ; NEW_LINE DEDENT"}
{"text": "Buat semua elemen array walaupun dengan menggantikan sepasang elemen array bersebelahan dengan jumlah mereka | Fungsi untuk mencari kiraan minimum operasi yang diperlukan untuk membuat semua elemen array walaupun; Kedai minimum penggantian minimum untuk membuat semua elemen array walaupun; Menyimpan kiraan nombor berterusan ganjil; Melintasi array; Jika arr [i] adalah nombor ganjil; Kemas kini ODD_CONT_SEG; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Tetapkan semula ODD_CONT_SEG = 0; Jika odd_cont_seg melebihi 0; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Hasilnya; Kod pemandu", "code": "def make_array_element_even ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE odd_cont_seg = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd_cont_seg += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( odd_cont_seg > 0 ) : NEW_LINE INDENT if ( odd_cont_seg % 2 == 0 ) : NEW_LINE INDENT res += odd_cont_seg // 2 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( odd_cont_seg // 2 ) + 2 NEW_LINE DEDENT odd_cont_seg = 0 NEW_LINE DEDENT DEDENT DEDENT if ( odd_cont_seg > 0 ) : NEW_LINE INDENT if ( odd_cont_seg % 2 == 0 ) : NEW_LINE INDENT res += odd_cont_seg // 2 NEW_LINE DEDENT else : NEW_LINE INDENT res += odd_cont_seg // 2 + 2 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 2 , 4 , 5 , 11 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( make_array_element_even ( arr , N ) ) NEW_LINE"}
{"text": "Cari nombor k sedemikian rupa sehingga betul -betul elemen array lebih besar daripada atau sama dengan k | Fungsi untuk mencari k yang mana terdapat unsur -unsur array yang lebih besar daripada atau sama dengan k; Mencari elemen array terbesar; Nilai kemungkinan k; Melintasi array; Jika elemen array semasa lebih besar daripada atau sama dengan i; Jika saya pelbagai elemen adalah lebih besar daripada atau sama dengan i; Jika tidak; Kod pemacu", "code": "def zvalue ( nums ) : NEW_LINE INDENT m = max ( nums ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 0 , m + 1 , 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 0 , len ( nums ) , 1 ) : NEW_LINE INDENT if ( nums [ j ] >= i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT nums = [ 7 , 8 , 9 , 0 , 0 , 1 ] NEW_LINE print ( zvalue ( nums ) ) NEW_LINE DEDENT"}
{"text": "Anagrams lexicographically terkecil dan terbesar rentetan yang mengandungi rentetan lain sebagai substringnya | Berfungsi untuk mencari anagram terkecil rentetan yang mengandungi rentetan lain; Memulakan kamus dan ditetapkan; Melangkah ke atas S1; Menyimpan kekerapan aksara yang ada di S1; Menyimpan watak -watak yang berbeza dalam S1; Mengurangkan kekerapan aksara dari m yang sudah ada di S2; Melintasi abjad dalam urutan yang disusun; Jika watak semasa set tidak sama dengan watak semasa S2; Jika elemen sama dengan watak semasa S2; Memeriksa watak kedua yang berbeza dalam S2; S2 [J] akan menyimpan watak kedua yang berbeza; Kembalikan jawapannya; Berfungsi untuk mencari anagram leksikografi terbesar rentetan yang mengandungi rentetan lain; Mendapatkan anagram terkecil secara lexicographically; D1 menyimpan awalan; D2 menyimpan akhiran; Mengembalikan hasilnya; Diberikan dua rentetan; Panggilan fungsi", "code": "def lexico_smallest ( s1 , s2 ) : NEW_LINE INDENT M = { } NEW_LINE S = [ ] NEW_LINE pr = { } NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if s1 [ i ] not in M : NEW_LINE INDENT M [ s1 [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ s1 [ i ] ] += 1 NEW_LINE DEDENT S . append ( s1 [ i ] ) NEW_LINE DEDENT S = list ( set ( S ) ) NEW_LINE S . sort ( ) NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT if s2 [ i ] in M : NEW_LINE INDENT M [ s2 [ i ] ] -= 1 NEW_LINE DEDENT DEDENT c = s2 [ 0 ] NEW_LINE index = 0 NEW_LINE res = \" \" NEW_LINE for x in S : NEW_LINE INDENT if ( x != c ) : NEW_LINE INDENT for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT j = 0 NEW_LINE index = len ( res ) NEW_LINE while ( s2 [ j ] == x ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( s2 [ j ] < c ) : NEW_LINE INDENT res += s2 NEW_LINE for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT index += M [ x ] NEW_LINE res += s2 NEW_LINE DEDENT DEDENT DEDENT pr [ res ] = index NEW_LINE return pr NEW_LINE DEDENT def lexico_largest ( s1 , s2 ) : NEW_LINE INDENT Pr = dict ( lexico_smallest ( s1 , s2 ) ) NEW_LINE d1 = \" \" NEW_LINE key = [ * Pr ] [ 0 ] NEW_LINE for i in range ( Pr . get ( key ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT d1 += key [ i ] NEW_LINE DEDENT d2 = \" \" NEW_LINE for i in range ( len ( key ) - 1 , Pr [ key ] + len ( s2 ) - 1 , - 1 ) : NEW_LINE INDENT d2 += key [ i ] NEW_LINE DEDENT res = d2 + s2 + d1 NEW_LINE return res NEW_LINE DEDENT s1 = \" ethgakagmenpgs \" NEW_LINE s2 = \" geeks \" NEW_LINE print ( * lexico_smallest ( s1 , s2 ) ) NEW_LINE print ( lexico_largest ( s1 , s2 ) ) NEW_LINE"}
{"text": "Pertanyaan untuk mencari kiraan laluan terpendek di dalam pokok yang mengandungi kelebihan yang diberikan | Pelaksanaan Python3 untuk pendekatan di atas; Senarai Adjacency untuk mewakili pokok; Bilangan simpang; Mark yang melawat / tidak dapat Vertices; Menyimpan saiz subtree nod yang sepadan; Berfungsi untuk mewujudkan kelebihan antara dua simpul; Tambah senarai A ke B; Tambah B ke senarai A; Berfungsi untuk melaksanakan DFS; Tandakan puncak yang dikunjungi; Termasuk nod dalam subtree; Melintasi semua anaknya; Berfungsi untuk mencetak bilangan laluan yang diperlukan; Kod pemacu; Bilangan simpang; Memanggil fungsi DFS yang diubah suai; Kira pasangan simpang di pokok", "code": "sz = 100000 NEW_LINE tree = [ [ ] for i in range ( sz ) ] NEW_LINE n = 0 NEW_LINE vis = [ False ] * sz NEW_LINE subtreeSize = [ 0 for i in range ( sz ) ] NEW_LINE def addEdge ( a , b ) : NEW_LINE INDENT global tree NEW_LINE tree [ a ] . append ( b ) NEW_LINE tree [ b ] . append ( a ) NEW_LINE DEDENT def dfs ( x ) : NEW_LINE INDENT global vis NEW_LINE global subtreeSize NEW_LINE global tree NEW_LINE vis [ x ] = True NEW_LINE subtreeSize [ x ] = 1 NEW_LINE for i in tree [ x ] : NEW_LINE INDENT if ( vis [ i ] == False ) : NEW_LINE INDENT dfs ( i ) NEW_LINE subtreeSize [ x ] += subtreeSize [ i ] NEW_LINE DEDENT DEDENT DEDENT def countPairs ( a , b ) : NEW_LINE INDENT global subtreeSize NEW_LINE sub = min ( subtreeSize [ a ] , subtreeSize [ b ] ) NEW_LINE print ( sub * ( n - sub ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE addEdge ( 0 , 1 ) NEW_LINE addEdge ( 0 , 2 ) NEW_LINE addEdge ( 1 , 3 ) NEW_LINE addEdge ( 3 , 4 ) NEW_LINE addEdge ( 3 , 5 ) NEW_LINE dfs ( 0 ) NEW_LINE countPairs ( 1 , 3 ) NEW_LINE countPairs ( 0 , 2 ) NEW_LINE DEDENT"}
{"text": "Kira permutasi array yang mempunyai setiap elemen sebagai pelbagai atau faktor indeksnya | Berfungsi untuk mencari kiraan permutasi yang dikehendaki; Kes asas; Jika saya belum dimasukkan; Backtrack; Masukkan i; Berulang untuk mencari permutasi yang sah; Keluarkan i; Mengembalikan kiraan akhir; Kod pemacu", "code": "def findPermutation ( arr , N ) : NEW_LINE INDENT pos = len ( arr ) + 1 NEW_LINE if ( pos > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i not in arr ) : NEW_LINE INDENT if ( i % pos == 0 or pos % i == 0 ) : NEW_LINE INDENT arr . add ( i ) NEW_LINE res += findPermutation ( arr , N ) NEW_LINE arr . remove ( i ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT N = 5 NEW_LINE arr = set ( ) NEW_LINE print ( findPermutation ( arr , N ) ) NEW_LINE"}
{"text": "Semak jika jumlah y boleh didapati dari array oleh operasi yang diberikan | Fungsi untuk memeriksa sama ada mungkin untuk mendapatkan jumlah y dari urutan jumlah x dari array arr []; Simpan perbezaan; Melangkah ke atas array; Jika diff dikurangkan kepada 0; Kod pemacu", "code": "def solve ( arr , n , X , Y ) : NEW_LINE INDENT diff = Y - X NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( diff == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE X , Y = 11 , 13 NEW_LINE solve ( arr , n , X , Y ) NEW_LINE"}
{"text": "Jarak paling jauh dari nod dari setiap nod pokok | Program Python3 untuk melaksanakan pendekatan di atas; Senarai adjacency untuk menyimpan graf; Menyimpan ketinggian setiap nod; Menyimpan jarak maksimum nod dari nenek moyangnya; Berfungsi untuk menambah kelebihan antara dua simpang; Masukkan kelebihan dari u ke v; Masukkan tepi dari v ke u; Berfungsi untuk mengira ketinggian setiap nod; Melangkah dalam senarai addacency nod semasa; DFS untuk nod kanak -kanak; Hitung ketinggian nod; Meningkatkan ketinggian; Fungsi untuk mengira jarak maksimum nod dari nenek moyangnya; Melangkah dalam senarai addacency nod semasa; Cari dua kanak -kanak dengan ketinggian maksimum; Kirakan jarak maksimum dengan nenek moyang untuk setiap nod; Mengira untuk kanak -kanak; Kod pemacu; Hitung ketinggian nod pokok; Kirakan jarak maksimum dengan nenek moyang; Cetak maksimum dua jarak dari setiap nod", "code": "maxN = 100001 NEW_LINE adj = [ [ ] for i in range ( maxN ) ] NEW_LINE height = [ 0 for i in range ( maxN ) ] NEW_LINE dist = [ 0 for i in range ( maxN ) ] NEW_LINE def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def dfs1 ( cur , par ) : NEW_LINE INDENT for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE INDENT dfs1 ( u , cur ) NEW_LINE height [ cur ] = max ( height [ cur ] , height [ u ] ) NEW_LINE DEDENT DEDENT height [ cur ] += 1 NEW_LINE DEDENT def dfs2 ( cur , par ) : NEW_LINE INDENT max1 = 0 NEW_LINE max2 = 0 NEW_LINE for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE INDENT if ( height [ u ] >= max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = height [ u ] NEW_LINE DEDENT elif ( height [ u ] > max2 ) : NEW_LINE INDENT max2 = height [ u ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE INDENT sum = ( max2 if ( max1 == height [ u ] ) else max1 ) NEW_LINE if ( max1 == height [ u ] ) : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max2 , dist [ cur ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max1 , dist [ cur ] ) NEW_LINE DEDENT dfs2 ( u , cur ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE addEdge ( 1 , 2 ) NEW_LINE addEdge ( 2 , 3 ) NEW_LINE addEdge ( 2 , 4 ) NEW_LINE addEdge ( 2 , 5 ) NEW_LINE addEdge ( 5 , 6 ) NEW_LINE dfs1 ( 1 , 0 ) NEW_LINE dfs2 ( 1 , 0 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( max ( dist [ i ] , height [ i ] ) - 1 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program Python3 untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Memeriksa B; Memeriksa A; Kod pemacu", "code": "def middleOfThree ( a , b , c ) : NEW_LINE INDENT def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT DEDENT a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Berfungsi untuk melaksanakan jenis pemilihan; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Kod pemacu; Panggilan fungsi; Cetak array", "code": "def selectionSort ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ min_idx ] ) : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT arr [ min_idx ] , arr [ i ] = arr [ i ] , arr [ min_idx ] NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 64 , 25 , 12 , 22 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE selectionSort ( arr , n ) NEW_LINE print ( \" Sorted ▁ array : ▁ \" ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT"}
{"text": "Semak jika rentetan yang diberikan boleh ditukar kepada yang lain dengan diberikan swap yang mungkin | Program Python3 untuk melaksanakan pendekatan di atas; Kedai panjang str1; Kedai panjang str2; Kedai watak -watak yang berbeza dari STR1; Kedai watak -watak yang berbeza dari STR2; Kedai kekerapan setiap watak Str1; Traverse string str1; Kemas kini kekerapan str1 [i]; Traverse string str1; Masukkan str1 [i] ke st1; Traverse string str2; Masukkan str1 [i] ke st1; Jika watak yang berbeza dalam str1 dan str2 tidak sama; Kedai kekerapan setiap watak Str2; Traverse string str2; Kemas kini kekerapan STR2 [i]; Sort hash1 [] array; Susun Hash2 [] array; Traverse Hash1 [] dan Hash2 []; Jika Hash1 [i] tidak sama dengan Hash2 [i]; Kod pemacu", "code": "def checkStr1CanConStr2 ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE st1 = set ( [ ] ) NEW_LINE st2 = set ( [ ] ) NEW_LINE hash1 = [ 0 ] * 256 NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT st1 . add ( str1 [ i ] ) NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT st2 . add ( str2 [ i ] ) NEW_LINE DEDENT if ( st1 != st2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT hash2 = [ 0 ] * 256 NEW_LINE for i in range ( M ) : NEW_LINE INDENT hash2 [ ord ( str2 [ i ] ) ] += 1 NEW_LINE DEDENT hash1 . sort ( ) NEW_LINE hash2 . sort ( ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( hash1 [ i ] != hash2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" xyyzzlll \" NEW_LINE str2 = \" yllzzxxx \" NEW_LINE if ( checkStr1CanConStr2 ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Susun array dalam julat indeks yang diberikan | Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Cetak array yang diubah suai; Kod pemacu", "code": "def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE arr = ( arr [ 0 : l ] + sorted ( arr [ l : r + 1 ] ) + arr [ r : N ] ) NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"}
{"text": "Cari kos minimum untuk mencapai destinasi menggunakan kereta api | Penyelesaian berasaskan pengaturcaraan dinamik untuk mencari kos min untuk mencapai stesen n - 1 dari stesen 0 .; Fungsi ini mengembalikan kos yang paling kecil untuk mencapai stesen n - 1 dari stesen 0 .; Dist [i] menyimpan kos minimum untuk mencapai stesen I dari stesen 0 .; Pergi melalui setiap stesen dan periksa jika menggunakannya sebagai stesen perantaraan memberikan jalan yang lebih baik; Program pemacu untuk menguji fungsi di atas", "code": "INF = 2147483647 NEW_LINE N = 4 NEW_LINE def minCost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT cost = [ [ 0 , 15 , 80 , 90 ] , [ INF , 0 , 40 , 50 ] , [ INF , INF , 0 , 70 ] , [ INF , INF , INF , 0 ] ] NEW_LINE print ( \" The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ \" , N , \" ▁ is ▁ \" , minCost ( cost ) ) NEW_LINE"}
{"text": "Bilangan gelung saiz k bermula dari nod tertentu | Kembalikan bilangan cara dari nod untuk membuat gelung saiz K dalam graf nod yang tidak disambungkan lengkap; Kod pemacu", "code": "def numOfways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n NEW_LINE DEDENT n = 4 NEW_LINE k = 2 NEW_LINE print ( numOfways ( n , k ) ) NEW_LINE"}
{"text": "Program untuk mencari watak bernilai ASCII terbesar dan terkecil dalam rentetan | Fungsi yang mengembalikan abjad terbesar; Memulakan abjad max ke 'a; Cari abjad terbesar; Kembali elemen terbesar; Fungsi yang mengembalikan abjad terkecil; Memulakan abjad terkecil kepada 'z; Cari abjad terkecil; Kembali abjad terkecil; Kod pemacu; Pelbagai watak; Mengira saiz rentetan; Fungsi memanggil dan mencetak nilai yang dikembalikan", "code": "def largest_alphabet ( a , n ) : NEW_LINE ' NEW_LINE INDENT max = ' A ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT def smallest_alphabet ( a , n ) : NEW_LINE ' NEW_LINE INDENT min = ' z ' ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \" GeEksforGeeks \" NEW_LINE size = len ( a ) NEW_LINE print ( \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" ▁ and ▁ \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE DEDENT ' NEW_LINE"}
{"text": "Buat palindrome terbesar dengan menukar paling banyak k | Mengembalikan maksimum palindrome menggunakan perubahan k; Memulakan l dan r oleh hujung kiri dan paling kanan; Pertama cuba membuat palindrome; Menggantikan watak kiri dan kanan dengan maksimum kedua -duanya; Jika k adalah negatif maka kita tidak boleh membuat palindrome; Pada watak pertengahan, jika k> 0 kemudian ubahnya menjadi 9; Jika watak di LTH (sama seperti RTH) kurang daripada 9; Jika tiada seorang pun daripada mereka diubah dalam gelung sebelumnya maka tolak 2 dari k dan tukar kedua -duanya ke 9; Jika salah satu daripada mereka diubah dalam gelung sebelumnya maka tolak 1 dari k (1 lagi telah dikurangkan) dan menjadikannya 9; Kod pemacu", "code": "def maximumPalinUsingKChanges ( strr , k ) : NEW_LINE INDENT palin = strr [ : : ] NEW_LINE l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = NEW_LINE INDENT max ( strr [ l ] , strr [ r ] ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return \" Not ▁ possible \" NEW_LINE DEDENT l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT if ( palin [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return palin NEW_LINE DEDENT st = \"43435\" NEW_LINE strr = [ i for i in st ] NEW_LINE k = 3 NEW_LINE a = maximumPalinUsingKChanges ( strr , k ) NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi", "code": "def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 1 , 3 ] ; NEW_LINE print ( countTriplets ( A ) ) ; NEW_LINE DEDENT"}
{"text": "Kurangkan kiraan pasangan bersebelahan dengan pariti yang berbeza | Python3 pelaksanaan pendekatan di atas; Fungsi rekursif untuk mengira pasangan bersebelahan minimum dengan pariti yang berbeza; Jika semua nombor diletakkan; Jika penggantian tidak diperlukan; Jika penggantian diperlukan; mundur; mundur; Berfungsi untuk memaparkan bilangan minimum elemen bersebelahan dengan pariti yang berbeza; Simpan tidak ada nombor yang tidak ada dalam array; Simpan tiada nombor ganjil yang tidak terdapat dalam array; Memadam nombor exisiting; Simpan bukan nombor dan nombor ganjil; Kod pemacu", "code": "mn = 1000 NEW_LINE def parity ( even , odd , v , i ) : NEW_LINE INDENT global mn NEW_LINE if ( i == len ( v ) or len ( even ) == 0 or len ( odd ) == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( len ( v ) - 1 ) : NEW_LINE INDENT if ( v [ j ] % 2 != v [ j + 1 ] % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < mn ) : NEW_LINE INDENT mn = count NEW_LINE DEDENT return NEW_LINE DEDENT if ( v [ i ] != - 1 ) : NEW_LINE INDENT parity ( even , odd , v , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( even ) != 0 ) : NEW_LINE INDENT x = even [ len ( even ) - 1 ] NEW_LINE even . remove ( even [ len ( even ) - 1 ] ) NEW_LINE v [ i ] = x NEW_LINE parity ( even , odd , v , i + 1 ) NEW_LINE even . append ( x ) NEW_LINE DEDENT if ( len ( odd ) != 0 ) : NEW_LINE INDENT x = odd [ len ( odd ) - 1 ] NEW_LINE odd . remove ( odd [ len ( odd ) - 1 ] ) NEW_LINE v [ i ] = x NEW_LINE parity ( even , odd , v , i + 1 ) NEW_LINE odd . append ( x ) NEW_LINE DEDENT DEDENT DEDENT def mnDiffParity ( v , n ) : NEW_LINE INDENT global mn NEW_LINE even = [ ] NEW_LINE odd = [ ] NEW_LINE m = { i : 0 for i in range ( 100 ) } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] != - 1 ) : NEW_LINE INDENT m . pop ( v [ i ] ) NEW_LINE DEDENT DEDENT for key in m . keys ( ) : NEW_LINE INDENT if ( key % 2 == 0 ) : NEW_LINE INDENT even . append ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( key ) NEW_LINE DEDENT DEDENT parity ( even , odd , v , 0 ) NEW_LINE print ( mn + 4 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE v = [ 2 , 1 , 4 , - 1 , - 1 , 6 , - 1 , 8 ] NEW_LINE mnDiffParity ( v , n ) NEW_LINE DEDENT"}
{"text": "Cari triplet sedemikian rupa sehingga bilangan nod yang menghubungkan triplet ini adalah maksimum | Pelaksanaan Python3 pendekatan; Untuk menyimpan nod yang diperlukan; Array induk untuk menjejaki semula nod; Arahan yang dikunjungi untuk mengelakkan DFS ke arah di garis pusat; Fungsi DFS untuk mencari startnode; Fungsi DFS untuk mencari endnode diameter dan mengekalkan array induk; Fungsi DFS untuk mencari nod akhir cawangan terpanjang ke diameter; Fungsi untuk mencari nod yang diperlukan; Untuk mencari node diameter; Untuk mencari nod akhir diameter; x adalah nod akhir diameter; Tandakan semua nod diameter menggunakan penjejakan belakang; Cari nod akhir cawangan terpanjang ke diameter; Kod pemacu", "code": "MAX = 100005 NEW_LINE adjacent = [ [ ] for i in range ( MAX ) ] NEW_LINE visited = [ False ] * MAX NEW_LINE startnode = endnode = thirdnode = None NEW_LINE maxi , N = - 1 , None NEW_LINE parent = [ None ] * MAX NEW_LINE vis = [ False ] * MAX NEW_LINE def dfs ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global startnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE dfs ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE startnode = u NEW_LINE DEDENT DEDENT DEDENT def dfs1 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global endnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE parent [ adjacent [ u ] [ i ] ] = u NEW_LINE dfs1 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE endnode = u NEW_LINE DEDENT DEDENT DEDENT def dfs2 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global thirdnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if ( not visited [ adjacent [ u ] [ i ] ] and not vis [ adjacent [ u ] [ i ] ] ) : NEW_LINE INDENT temp += 1 NEW_LINE dfs2 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE thirdnode = u NEW_LINE DEDENT DEDENT DEDENT def findNodes ( ) : NEW_LINE INDENT dfs ( 1 , 0 ) NEW_LINE global maxi NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT maxi = - 1 NEW_LINE dfs1 ( startnode , 0 ) NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT x = endnode NEW_LINE vis [ startnode ] = True NEW_LINE while x != startnode : NEW_LINE INDENT vis [ x ] = True NEW_LINE x = parent [ x ] NEW_LINE DEDENT maxi = - 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if vis [ i ] : NEW_LINE INDENT dfs2 ( i , 0 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE adjacent [ 1 ] . append ( 2 ) NEW_LINE adjacent [ 2 ] . append ( 1 ) NEW_LINE adjacent [ 1 ] . append ( 3 ) NEW_LINE adjacent [ 3 ] . append ( 1 ) NEW_LINE adjacent [ 1 ] . append ( 4 ) NEW_LINE adjacent [ 4 ] . append ( 1 ) NEW_LINE findNodes ( ) NEW_LINE print ( \" ( { } , ▁ { } , ▁ { } ) \" . format ( startnode , endnode , thirdnode ) ) NEW_LINE DEDENT"}
{"text": "Peratusan peningkatan jumlah sfera jika radius meningkat dengan peratusan tertentu | Program Python3 untuk mencari peningkatan peratusan dalam jumlah sfera jika radius meningkat dengan peratusan tertentu; Kod pemacu", "code": "def newvol ( x ) : NEW_LINE INDENT print ( \" percentage ▁ increase ▁ in ▁ the \" , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , \" % \" ) DEDENT x = 10.0 NEW_LINE newvol ( x ) NEW_LINE"}
{"text": "Panjang kord bulatan yang jejari dan sudutnya diselipkan di pusat oleh kord diberikan | Program Python3 untuk mencari kord panjang bulatan yang radius dan sudut yang diselaraskan di pusat juga diberikan; Berfungsi untuk mencari panjang kord; Kod pemacu", "code": "import math as mt NEW_LINE def length_of_chord ( r , x ) : NEW_LINE INDENT print ( \" The ▁ length ▁ of ▁ the ▁ chord \" , \" ▁ of ▁ the ▁ circle ▁ is ▁ \" , 2 * r * mt . sin ( x * ( 3.14 / 180 ) ) ) NEW_LINE DEDENT r = 4 NEW_LINE x = 63 ; NEW_LINE length_of_chord ( r , x ) NEW_LINE"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segitiga sama rata | Program Python3 untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segitiga sama rata; Berfungsi untuk mencari kawasan dataran; A tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "from math import * NEW_LINE def area ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = sqrt ( a ) / 6 NEW_LINE return area NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 NEW_LINE print ( round ( area ( a ) , 6 ) ) NEW_LINE DEDENT"}
{"text": "Panjang batang terpanjang yang boleh dimuatkan ke dalam cuboid | Program Python 3 untuk mencari rod terpanjang yang boleh dimuatkan dalam cuboid; Berfungsi untuk mencari panjang; Pembolehubah sementara untuk memegang hasil pertengahan; Panjang rod terpanjang dikira menggunakan fungsi akar persegi; Kod pemacu; Memanggil LongeStroDincuboid () berfungsi untuk mendapatkan panjang rod terpanjang", "code": "from math import * NEW_LINE def longestRodInCuboid ( length , breadth , height ) : NEW_LINE INDENT temp = length * length + breadth * breadth + height * height NEW_LINE result = sqrt ( temp ) NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT length , breadth , height = 12 , 9 , 8 NEW_LINE print ( longestRodInCuboid ( length , breadth , height ) ) NEW_LINE DEDENT"}
{"text": "Semak sama ada titik tertentu terletak pada atau di dalam segi empat tepat | Set 3 | berfungsi untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; Kod pemacu", "code": "def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print ( \" Given ▁ point ▁ lies ▁ inside \" \" ▁ the ▁ rectangle \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Given ▁ point ▁ does ▁ not ▁ lie \" \" ▁ on ▁ the ▁ rectangle \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; untuk panjang; untuk keluasan; untuk ketinggian; Mengira isipadu maksimum. ; Program yang didorong", "code": "def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( s ) : NEW_LINE INDENT k = s - i - j NEW_LINE maxvalue = max ( maxvalue , i * j * k ) NEW_LINE DEDENT DEDENT return maxvalue NEW_LINE DEDENT s = 8 NEW_LINE print ( maxvolume ( s ) ) NEW_LINE"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; mencari panjang; mencari keluasan; Mencari ketinggian; Program yang didorong", "code": "def maxvolume ( s ) : NEW_LINE INDENT length = int ( s / 3 ) NEW_LINE s -= length NEW_LINE breadth = s / 2 NEW_LINE height = s - breadth NEW_LINE return int ( length * breadth * height ) NEW_LINE DEDENT s = 8 NEW_LINE print ( maxvolume ( s ) ) NEW_LINE"}
{"text": "Kawasan Hexagon | Program Python3 untuk mencari kawasan segi enam; Fungsi untuk mengira kawasan segi enam. ; Kod pemacu; panjang sisi.", "code": "import math NEW_LINE def hexagonArea ( s ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = 4 NEW_LINE print ( \" Area : \" , \" { 0 : . 4f } \" . format ( hexagonArea ( s ) ) ) NEW_LINE DEDENT"}
{"text": "Bilangan maksimum kuadrat yang boleh dimuatkan dalam segitiga isosceles sudut kanan | fungsi untuk mencari dataran maksimum; kembali dalam O (1) dengan formula yang diperoleh; Program Pemandu", "code": "def maxSquare ( b , m ) : NEW_LINE INDENT return ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT b = 10 NEW_LINE m = 2 NEW_LINE print ( int ( maxSquare ( b , m ) ) ) NEW_LINE"}
{"text": "Semak jika segitiga yang betul mungkin dari kawasan tertentu dan hipotenus | Program Python untuk memeriksa kewujudan segitiga kanan. ; Mencetak tiga sisi segitiga kanan dari kawasan tertentu dan hipotenus jika segitiga mungkin, cetakan lain - 1 .; Deskripsi persamaan; memohon formula persamaan linear untuk mencari kedua -dua akar; Kawasan kod pemandu adalah 6 dan hipotenus adalah 5.", "code": "from math import sqrt NEW_LINE def findRightAngle ( A , H ) : NEW_LINE INDENT D = pow ( H , 4 ) - 16 * A * A NEW_LINE if D >= 0 : NEW_LINE INDENT root1 = ( H * H + sqrt ( D ) ) / 2 NEW_LINE root2 = ( H * H - sqrt ( D ) ) / 2 NEW_LINE a = sqrt ( root1 ) NEW_LINE b = sqrt ( root2 ) NEW_LINE if b >= a : NEW_LINE INDENT print a , b , H NEW_LINE DEDENT else : NEW_LINE INDENT print b , a , H NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print \" - 1\" NEW_LINE DEDENT DEDENT findRightAngle ( 6 , 5 ) NEW_LINE"}
{"text": "Bilangan maksimum 2 x2 kotak yang boleh dimuatkan di dalam segitiga isosceles kanan | Program Python3 untuk mengira bilangan 2 x 2 kotak di segitiga isosceles yang betul; Mengeluarkan bahagian tambahan yang selalu kita perlukan; Kerana setiap persegi mempunyai asas panjang 2; Kod pemacu", "code": "def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE"}
{"text": "Bitwise atau bitwise dan semua yang mungkin bukan | Berfungsi untuk mencari bitwise atau bitwise dan semua subarray yang mungkin selepas melakukan setiap pertanyaan; Melintasi setiap pasangan pertanyaan; Menyimpan bitwise atau; Mengemas kini array; Cari bitwise atau array baru yang dikemas kini; Cetak Ans; Kod pemacu", "code": "def performQuery ( arr , Q ) : NEW_LINE INDENT for i in range ( 0 , len ( Q ) ) : NEW_LINE INDENT orr = 0 NEW_LINE x = Q [ i ] [ 0 ] NEW_LINE arr [ x - 1 ] = Q [ i ] [ 1 ] NEW_LINE for j in range ( 0 , len ( arr ) ) : NEW_LINE INDENT orr = orr | arr [ j ] NEW_LINE DEDENT print ( orr , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE Q = [ [ 1 , 4 ] , [ 3 , 0 ] ] NEW_LINE performQuery ( arr , Q ) NEW_LINE"}
{"text": "Panjang terkecil nombor yang boleh dibahagi dengan k yang dibentuk dengan menggunakan d sahaja | Berfungsi untuk membentuk bilangan terkecil yang mungkin; Array untuk menandakan baki yang telah dikira sudah; Melangkah ke atas julat; Jika baki itu sudah dijumpai, kembali - 1; Kod pemacu", "code": "def smallest ( k , d ) : NEW_LINE INDENT cnt = 1 NEW_LINE m = d % k NEW_LINE v = [ 0 for i in range ( k ) ] ; NEW_LINE v [ m ] = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k NEW_LINE if ( v [ m ] == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT v [ m ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT d = 1 NEW_LINE k = 41 NEW_LINE print ( smallest ( k , d ) ) NEW_LINE"}
{"text": "Grafik Cube Fibonacci | Berfungsi untuk mencari nombor Fibonacci; Fungsi untuk mencari bilangan simpang dalam graf kiub Fibonacci; kembali nombor fibonacci untuk f (n + 2); Kod pemacu", "code": "def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT def findVertices ( n ) : NEW_LINE INDENT return fib ( n + 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findVertices ( n ) ) NEW_LINE DEDENT"}
{"text": "Ubah suai array supaya array tidak mengandungi mana -mana pembahagi biasa selain 1 | Program Python3 untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mengubah suai array supaya tidak ada faktor yang sama antara elemen array kecuali 1; Menyimpan GCD array; Hitung GCD array; Jika pembahagi semasa lebih kecil daripada x; Bahagikan GCD oleh pembahagi semasa; Jika boleh; Cetak array yang diubah suai; Jika tidak; Kod pemacu; Diberikan array; Saiz array", "code": "import math NEW_LINE def checkCommonDivisor ( arr , N , X ) : NEW_LINE INDENT G = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT G = math . gcd ( G , arr [ i ] ) NEW_LINE DEDENT copy_G = G NEW_LINE for divisor in range ( 2 , X + 1 ) : NEW_LINE INDENT while ( G % divisor == 0 ) : NEW_LINE INDENT G = G // divisor NEW_LINE DEDENT DEDENT if ( G <= X ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] // copy_G , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 6 , 15 , 6 ] NEW_LINE X = 6 NEW_LINE N = len ( arr ) NEW_LINE checkCommonDivisor ( arr , N , X ) NEW_LINE DEDENT"}
{"text": "Sort Biotonic Doubly Linked List | Nod senarai dikaitkan dua kali ganda; Berfungsi untuk membalikkan senarai dikaitkan dua kali ganda; swap seterusnya dan sebelumnya untuk semua nod senarai dikaitkan dua kali ganda; Sebelum menukar kepala, periksa kes -kes seperti senarai kosong dan senarai dengan hanya satu nod; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika senarai yang dipautkan pertama kosong; Jika senarai dikaitkan kedua kosong; Pilih nilai yang lebih kecil; berfungsi untuk menyusun senarai dikaitkan dua kali ganda biotonik; Jika senarai kosong atau jika ia mengandungi satu nod tunggal; Jika benar, maka 'semasa' adalah nod pertama yang lebih kecil daripada nod sebelumnya; Pindah ke nod seterusnya; Jika benar, maka senarai sudah disusun; tumpah ke dalam dua senarai, satu bermula dengan 'kepala' dan yang lain bermula dengan 'semasa'; membalikkan senarai bermula dengan 'semasa'; Gabungkan kedua -dua senarai dan kembalikan senarai dikaitkan dua kali ganda; Berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Oleh kerana kita menambah pada mulanya, sebelumnya tidak ada; Pautan senarai lama dari nod baru; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Berfungsi untuk mencetak nod dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Kod pemacu; Buat senarai dikaitkan dua kali: 2 <.5 <.7 <.12 <.10 <.6 <.4 <.1; Susun DLL Biotonik", "code": "class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT def reverse ( head_ref ) : NEW_LINE INDENT temp = None NEW_LINE current = head_ref NEW_LINE while ( current != None ) : NEW_LINE INDENT temp = current . prev NEW_LINE current . prev = current . next NEW_LINE current . next = temp NEW_LINE current = current . prev NEW_LINE DEDENT if ( temp != None ) : NEW_LINE INDENT head_ref = temp . prev NEW_LINE return head_ref NEW_LINE DEDENT DEDENT def merge ( first , second ) : NEW_LINE INDENT if ( first == None ) : NEW_LINE INDENT return second NEW_LINE DEDENT if ( second == None ) : NEW_LINE INDENT return first NEW_LINE DEDENT if ( first . data < second . data ) : NEW_LINE INDENT first . next = merge ( first . next , second ) NEW_LINE first . next . prev = first NEW_LINE first . prev = None NEW_LINE return first NEW_LINE DEDENT else : NEW_LINE INDENT second . next = merge ( first , second . next ) NEW_LINE second . next . prev = second NEW_LINE second . prev = None NEW_LINE return second NEW_LINE DEDENT DEDENT def sort ( head ) : NEW_LINE INDENT if ( head == None or head . next == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT current = head . next NEW_LINE while ( current != None ) : NEW_LINE INDENT if ( current . data < current . prev . data ) : NEW_LINE INDENT break NEW_LINE DEDENT current = current . next NEW_LINE DEDENT if ( current == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT current . prev . next = None NEW_LINE current . prev = None NEW_LINE current = reverse ( current ) NEW_LINE return merge ( head , current ) NEW_LINE DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( ) NEW_LINE new_node . data = new_data NEW_LINE new_node . prev = None NEW_LINE new_node . next = ( head_ref ) NEW_LINE if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . prev = new_node NEW_LINE DEDENT ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT print ( \" Doubly ▁ Linked ▁ list ▁ empty \" ) NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT head = None NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE print ( \" Original ▁ Doubly ▁ linked ▁ list : n \" ) NEW_LINE printList ( head ) NEW_LINE head = sort ( head ) NEW_LINE print ( \" Doubly linked list after sorting : \" ) NEW_LINE printList ( head ) NEW_LINE"}
{"text": "Susun konsonan dan vokal nod dalam senarai yang dipautkan | Nod senarai yang dipautkan; Fungsi utiliti untuk mencetak senarai yang dipautkan; Fungsi utiliti untuk memeriksa vokal; berfungsi untuk mengatur konsonan dan nod vokal; untuk menjejaki vokal; senarai kosong; Kita perlu menemui vokal pertama dalam senarai. Ia akan menjadi kepala yang dikembalikan, dan juga Latarvowel awal. ; Unsur pertama adalah vokal. Ia juga akan menjadi kepala baru dan Latarvowel awal; Unsur pertama bukan vokal. Keluarkan melalui senarai sehingga kita dapati vokal. Perhatikan bahawa Curr menunjuk kepada elemen * sebelum * elemen dengan vokal. ; Ini adalah kes kelebihan di mana terdapat hanya konsonan dalam senarai. ; Tetapkan Latihan Awal dan kepala baru ke item vokal yang kami dapati. Relink rantai konsonan selepas item vokal itu: old_head_consonant. Consonant1. consonant2. vokal. REST_OF_LIST menjadi vokal. old_head_consonant. Consonant1. consonant2. rest_of_list; Sekarang melintasi senarai. Curr sentiasa item * sebelum * yang kita periksa, supaya kita boleh menggunakannya untuk menghubungkan semula. ; Item yang ditemui seterusnya adalah vokal; Sekiranya ia datang secara langsung selepas vokal sebelumnya, kami tidak perlu memindahkan item di sekitar, hanya tandakan LatarVowel baru dan Advance Curr. ; Tetapi jika ia datang selepas rantaian konsonan intervensi, kita perlu mengikat vokal yang baru ditemui selepas vokal lama. Curr tidak berubah kerana selepas menghubungkannya akan mempunyai yang baru, yang belum diperiksa, dan kami sentiasa menyimpan Curr pada satu sebelum pemeriksaan seterusnya. ; Rantai dalam vokal baru; Advance Latestvowel; Keluarkan vokal yang dijumpai dari tempat sebelumnya; Re - Rantaian Konsonan Pautan Selepas Latihan Latihan; Tiada vokal dalam elemen seterusnya, Advance Curr. ; Kod pemacu", "code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def printlist ( head ) : NEW_LINE INDENT if ( not head ) : NEW_LINE INDENT print ( \" Empty ▁ List \" ) NEW_LINE return NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE if ( head . next ) : NEW_LINE INDENT print ( end = \" - > ▁ \" ) NEW_LINE DEDENT head = head . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def isVowel ( x ) : NEW_LINE INDENT return ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' or x == ' A ' or x == ' E ' or x == ' I ' or x == ' O ' or x == ' U ' ) NEW_LINE DEDENT def arrange ( head ) : NEW_LINE INDENT newHead = head NEW_LINE latestVowel = None NEW_LINE curr = head NEW_LINE if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( isVowel ( head . data ) ) : NEW_LINE INDENT latestVowel = head NEW_LINE DEDENT else : NEW_LINE INDENT while ( curr . next != None and not isVowel ( curr . next . data ) ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT if ( curr . next == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT latestVowel = newHead = curr . next NEW_LINE curr . next = curr . next . next NEW_LINE latestVowel . next = head NEW_LINE DEDENT while ( curr != None and curr . next != None ) : NEW_LINE INDENT if ( isVowel ( curr . next . data ) ) : NEW_LINE INDENT if ( curr == latestVowel ) : NEW_LINE INDENT latestVowel = curr = curr . next NEW_LINE DEDENT else : NEW_LINE INDENT temp = latestVowel . next NEW_LINE latestVowel . next = curr . next NEW_LINE latestVowel = latestVowel . next NEW_LINE curr . next = curr . next . next NEW_LINE latestVowel . next = temp NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT DEDENT return newHead NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = Node ( ' a ' ) NEW_LINE head . next = Node ( ' b ' ) NEW_LINE head . next . next = Node ( ' c ' ) NEW_LINE head . next . next . next = Node ( ' e ' ) NEW_LINE head . next . next . next . next = Node ( ' d ' ) NEW_LINE head . next . next . next . next . next = Node ( ' o ' ) NEW_LINE head . next . next . next . next . next . next = Node ( ' x ' ) NEW_LINE head . next . next . next . next . next . next . next = Node ( ' i ' ) NEW_LINE print ( \" Linked ▁ list ▁ before ▁ : \" ) NEW_LINE printlist ( head ) NEW_LINE head = arrange ( head ) NEW_LINE print ( \" Linked ▁ list ▁ after ▁ : \" ) NEW_LINE printlist ( head ) NEW_LINE DEDENT"}
{"text": "Elemen terbesar di BST menggunakan ruang tambahan yang berterusan | fungsi penolong untuk membuat nod baru; Mengira pembolehubah untuk menyimpan kiraan nod yang dikunjungi; Sekiranya anak yang betul tidak ada; kiraan kenaikan pertama dan semak jika Count = k; Jika tidak berpindah ke anak kiri; Cari pengganti inorder nod semasa; Tetapkan anak kiri pengganti ke nod semasa; gerakkan arus ke kanannya; memulihkan pokok itu kembali ke pokok carian binari asal yang mengeluarkan pautan berulir; gerakkan arus ke anak kiri; Kod pemacu; Pokok binari yang dibina adalah 4 / \\ 2 7 / \\ / \\ 1 3 6 10", "code": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = self . left = None NEW_LINE DEDENT DEDENT def KthLargestUsingMorrisTraversal ( root , k ) : NEW_LINE INDENT curr = root NEW_LINE Klargest = None NEW_LINE count = 0 NEW_LINE while ( curr != None ) : NEW_LINE INDENT if ( curr . right == None ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT Klargest = curr NEW_LINE DEDENT curr = curr . left NEW_LINE DEDENT else : NEW_LINE INDENT succ = curr . right NEW_LINE while ( succ . left != None and succ . left != curr ) : NEW_LINE INDENT succ = succ . left NEW_LINE DEDENT if ( succ . left == None ) : NEW_LINE INDENT succ . left = curr NEW_LINE curr = curr . right NEW_LINE DEDENT else : NEW_LINE INDENT succ . left = None NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT Klargest = curr NEW_LINE DEDENT curr = curr . left NEW_LINE DEDENT DEDENT DEDENT return Klargest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 4 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 7 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 10 ) NEW_LINE print ( \" Finding ▁ K - th ▁ largest ▁ Node ▁ in ▁ BST ▁ : ▁ \" , KthLargestUsingMorrisTraversal ( root , 2 ) . data ) NEW_LINE DEDENT"}
{"text": "Penyusun baris matriks dalam urutan menaik diikuti oleh lajur dalam urutan menurun | Pelaksanaan Python untuk menyusun baris matriks dalam urutan menaik diikuti dengan menyusun lajur dalam urutan menurun; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh menaik. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menurun. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "MAX_SIZE = 10 NEW_LINE def sortByRow ( mat , n , ascending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ascending ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT DEDENT DEDENT def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = temp NEW_LINE DEDENT DEDENT DEDENT def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n , True ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n , False ) NEW_LINE transpose ( mat , n ) NEW_LINE DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( \" Original ▁ Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix ▁ After ▁ Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE"}
{"text": "Susun baris matriks | Pelaksanaan Python 3 untuk menyusun baris matriks - bijak dan lajur - bijak; berfungsi untuk menyusun setiap baris matriks; Menyusun nombor baris 'i; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; sekali lagi menyusun baris tikar [] []; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "MAX_SIZE = 10 NEW_LINE def sortByRow ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] > mat [ i ] [ j + 1 ] : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ i ] [ j + 1 ] NEW_LINE mat [ i ] [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT t = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = t NEW_LINE DEDENT DEDENT DEDENT def sortMatRowAndColWise ( mat , n ) : NEW_LINE INDENT sortByRow ( mat , n ) NEW_LINE transpose ( mat , n ) NEW_LINE sortByRow ( mat , n ) NEW_LINE transpose ( mat , n ) NEW_LINE DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str ( mat [ i ] [ j ] ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT mat = [ [ 4 , 1 , 3 ] , [ 9 , 6 , 8 ] , [ 5 , 2 , 7 ] ] NEW_LINE n = 3 NEW_LINE print ( \" Original ▁ Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix After Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE"}
{"text": "Magic Square | Malah pesanan | Fungsi untuk mengira Magic Square; 2 - D matriks dengan semua penyertaan sebagai 0; Tukar nilai elemen array di lokasi pembaikan mengikut peraturan (n * n + 1) - arr [i] [[j] sudut perintah (n / 4) * (n / 4) sudut kiri atas; Sudut kanan atas; Sudut kiri bawah; Sudut kanan bawah; Pusat matriks, pesanan (n / 2) * (n / 2); Mencetak dataran; Program pemacu; Panggilan fungsi", "code": "def DoublyEven ( n ) : NEW_LINE INDENT arr = [ [ ( n * y ) + x + 1 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n / 4 ) : NEW_LINE INDENT for j in range ( 0 , n / 4 ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( 0 , n / 4 ) : NEW_LINE INDENT for j in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT for j in range ( 0 , n / 4 ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT for j in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( n / 4 , 3 * ( n / 4 ) ) : NEW_LINE INDENT for j in range ( n / 4 , 3 * ( n / 4 ) ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ' % 2d ▁ ' % ( arr [ i ] [ j ] ) , NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT n = 8 NEW_LINE DoublyEven ( n ) NEW_LINE"}
{"text": "Produk Kronecker Dua Matriks | Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Kod pemacu.", "code": "cola = 2 NEW_LINE rowa = 3 NEW_LINE colb = 3 NEW_LINE rowb = 2 NEW_LINE def Kroneckerproduct ( A , B ) : NEW_LINE INDENT C = [ [ 0 for j in range ( cola * colb ) ] for i in range ( rowa * rowb ) ] NEW_LINE for i in range ( 0 , rowa ) : NEW_LINE INDENT for k in range ( 0 , rowb ) : NEW_LINE INDENT for j in range ( 0 , cola ) : NEW_LINE INDENT for l in range ( 0 , colb ) : NEW_LINE INDENT C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] NEW_LINE print ( C [ i + l + 1 ] [ j + k + 1 ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT DEDENT A = [ [ 0 for j in range ( 2 ) ] for i in range ( 3 ) ] NEW_LINE B = [ [ 0 for j in range ( 3 ) ] for i in range ( 2 ) ] NEW_LINE A [ 0 ] [ 0 ] = 1 NEW_LINE A [ 0 ] [ 1 ] = 2 NEW_LINE A [ 1 ] [ 0 ] = 3 NEW_LINE A [ 1 ] [ 1 ] = 4 NEW_LINE A [ 2 ] [ 0 ] = 1 NEW_LINE A [ 2 ] [ 1 ] = 0 NEW_LINE B [ 0 ] [ 0 ] = 0 NEW_LINE B [ 0 ] [ 1 ] = 5 NEW_LINE B [ 0 ] [ 2 ] = 2 NEW_LINE B [ 1 ] [ 0 ] = 6 NEW_LINE B [ 1 ] [ 1 ] = 7 NEW_LINE B [ 1 ] [ 2 ] = 3 NEW_LINE Kroneckerproduct ( A , B ) NEW_LINE"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga yang lebih rendah | Fungsi untuk memeriksa matriks berada di segi tiga yang lebih rendah; Fungsi pemacu. ; Panggilan fungsi", "code": "def islowertriangular ( M ) : NEW_LINE INDENT for i in range ( 0 , len ( M ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( M ) ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT M = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 4 , 0 , 0 ] , [ 4 , 6 , 2 , 0 ] , [ 0 , 4 , 7 , 6 ] ] NEW_LINE if islowertriangular ( M ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga atas | Fungsi untuk memeriksa matriks berada di segi tiga atas; Fungsi pemacu.", "code": "def isuppertriangular ( M ) : NEW_LINE INDENT for i in range ( 1 , len ( M ) ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT M = [ [ 1 , 3 , 5 , 3 ] , [ 0 , 4 , 6 , 2 ] , [ 0 , 0 , 2 , 5 ] , [ 0 , 0 , 0 , 6 ] ] NEW_LINE if isuppertriangular ( M ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Mengira set 1 s dan 0 s dalam matriks binari | tiada lajur; tiada baris; berfungsi untuk mengira bilangan set sel yang tidak kosong; menyimpan jawapan terakhir; Traverses Row - Bijaksana; Traverses Column Wise; Pada akhirnya tolak n * m kerana tiada set tunggal telah ditambah dua kali. ; Program Pemandu untuk menguji fungsi di atas.", "code": "m = 3 NEW_LINE n = 2 NEW_LINE def countSets ( a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] [ i ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT return res - ( n * m ) NEW_LINE DEDENT a = [ [ 1 , 0 , 1 ] , [ 0 , 1 , 0 ] ] NEW_LINE print ( countSets ( a ) ) NEW_LINE"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Mengisi transpose mat [n] [n] dalam tr [n] [n]; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "def transpose ( mat , tr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT tr [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT def isSymmetric ( mat , N ) : NEW_LINE INDENT tr = [ [ 0 for j in range ( len ( mat [ 0 ] ) ) ] for i in range ( len ( mat ) ) ] NEW_LINE transpose ( mat , tr , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT"}
{"text": "Program untuk mencari normal dan jejak matriks | Program python3 untuk mencari jejak dan normal matriks yang diberikan; Saiz matriks yang diberikan; Pulangan normal matriks saiz n x n; Mengembalikan jejak matriks saiz n x n; Kod pemacu", "code": "import math NEW_LINE MAX = 100 ; NEW_LINE def findNormal ( mat , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return math . floor ( math . sqrt ( sum ) ) ; NEW_LINE DEDENT def findTrace ( mat , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] ; NEW_LINE print ( \" Trace ▁ of ▁ Matrix ▁ = \" , findTrace ( mat , 5 ) ) ; NEW_LINE print ( \" Normal ▁ of ▁ Matrix ▁ = \" , findNormal ( mat , 5 ) ) ; NEW_LINE"}
{"text": "Penentu maksimum matriks dengan setiap nilai sama ada 0 atau n | Fungsi untuk penentu maksimum; Berfungsi untuk mencetak matriks resulatant; tiga kedudukan di mana 0 muncul; kedudukan di mana n muncul; Kod pemacu", "code": "def maxDet ( n ) : NEW_LINE INDENT return 2 * n * n * n NEW_LINE DEDENT def resMatrix ( n ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if i == 0 and j == 2 : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT elif i == 1 and j == 0 : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT elif i == 2 and j == 1 : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE print ( \" Maximum ▁ Detrminat = \" , maxDet ( n ) ) NEW_LINE print ( \" Resultant ▁ Matrix : \" ) NEW_LINE resMatrix ( n ) NEW_LINE"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan Python kaedah naif untuk mengira nombor negatif dalam m [n] [m]; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; Tiada nombor negatif dalam baris ini; Kod pemacu", "code": "def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE print ( countNegative ( M , 3 , 4 ) ) NEW_LINE"}
{"text": "Kira nombor negatif dalam lajur | Berfungsi untuk mengira nombor negatif; memulakan hasil; Mulakan dengan sudut kanan atas; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; J ialah indeks nombor negatif terakhir dalam baris ini. Jadi mesti ada (j + 1); Nombor negatif dalam baris ini. ; Pindah ke kiri dan lihat jika kita dapat mencari nombor negatif di sana; Kod pemacu", "code": "def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += ( j + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE print ( countNegative ( M , 3 , 4 ) ) NEW_LINE"}
{"text": "Kira nombor negatif dalam lajur | Carian binari rekursif untuk mendapatkan nilai negatif terakhir berturut -turut antara permulaan dan akhir; Kes asas; Dapatkan pertengahan untuk carian binari; Jika elemen semasa adalah negatif; Jika ia adalah elemen negatif paling kanan dalam baris semasa; Semak separuh kanan array; Semak di separuh kiri array; Fungsi untuk mengembalikan kiraan nombor negatif dalam matriks yang diberikan; Memulakan hasil; Untuk menyimpan indeks elemen negatif paling kanan dalam baris yang dipertimbangkan; Melangkah ke atas semua baris matriks; Jika elemen pertama baris semasa adalah positif maka tidak akan ada negatif dalam matriks di bawah atau selepas itu; Jalankan carian binari hanya sehingga indeks integer negatif terakhir dalam baris di atas; Kod pemacu", "code": "def getLastNegativeIndex ( array , start , end , n ) : NEW_LINE INDENT if ( start == end ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE if ( array [ mid ] < 0 ) : NEW_LINE INDENT if ( mid + 1 < n and array [ mid + 1 ] >= 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return getLastNegativeIndex ( array , mid + 1 , end , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return getLastNegativeIndex ( array , start , mid - 1 , n ) NEW_LINE DEDENT DEDENT def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE nextEnd = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( M [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd , 4 ) NEW_LINE count += nextEnd + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE r = 3 NEW_LINE c = 4 NEW_LINE print ( countNegative ( M , r , c ) ) NEW_LINE"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah naif untuk mencari nilai maksimum MAT [d] [e] - mat [a] [b] seperti d> a dan e> b; Fungsi ini mengembalikan nilai maksimum a (d, e) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua d> a dan e> b. ; Kedai nilai maksimum; Pertimbangkan semua kemungkinan pasangan tikar [a] [b] dan mat [d] [e]; Kod pemacu", "code": "N = 5 NEW_LINE def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = 0 NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : NEW_LINE INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue ; NEW_LINE DEDENT mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] ; NEW_LINE print ( \" Maximum ▁ Value ▁ is ▁ \" + str ( findMaxValue ( mat ) ) ) NEW_LINE"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah yang cekap untuk mencari nilai maksimum MAT [d] - ma [a] [b] sedemikian rupa sehingga c> a dan d> b; Fungsi ini mengembalikan nilai maksimum a (c, d) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua c> a dan d> b. ; Kedai nilai maksimum; maxarr [i] [j] menyimpan max unsur -unsur dalam matriks dari (i, j) hingga (n - 1, n - 1); Elemen terakhir Maxarr akan menjadi sama seperti matriks input; Preprocess Last Row Inisialisasi Max; preprocess lajur terakhir memulakan max; PREPROCESS ROST OF MATRIX DARI BAWAH; Kemas kini MaxValue; Tetapkan Maxarr (i, j); Kod pemacu", "code": "import sys NEW_LINE N = 5 NEW_LINE def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = - sys . maxsize - 1 NEW_LINE maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] NEW_LINE maxv = mat [ N - 1 ] [ N - 1 ] ; NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > maxv ) : NEW_LINE INDENT maxv = mat [ N - 1 ] [ j ] NEW_LINE DEDENT maxArr [ N - 1 ] [ j ] = maxv NEW_LINE DEDENT maxv = mat [ N - 1 ] [ N - 1 ] ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] > maxv ) : NEW_LINE INDENT maxv = mat [ i ] [ N - 1 ] NEW_LINE DEDENT maxArr [ i ] [ N - 1 ] = maxv NEW_LINE DEDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) NEW_LINE DEDENT maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT return maxValue NEW_LINE DEDENT mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] NEW_LINE print ( \" Maximum ▁ Value ▁ is \" , findMaxValue ( mat ) ) NEW_LINE"}
{"text": "Cetak semua elemen dalam susunan yang disusun dari baris dan lajur yang bijak matriks disusun | Program Python 3 untuk mencetak semua elemen dalam susunan yang disusun dari matriks baris dan lajur yang disusun bijak; Fungsi utiliti untuk Youngify meja muda. Ini berbeza dengan Standard Youngify. Ia mengandaikan bahawa nilai pada MAT [0] [0] adalah tak terhingga. ; Cari nilai -nilai di bawah dan kanan tikar [i] [j]; Jika tikar [i] [j] adalah elemen sudut kanan, kembali; Gerakkan lebih kecil daripada dua nilai (downval dan rightval) ke tikar [i] [j] dan berulang untuk nilai yang lebih kecil; Fungsi utiliti untuk mengekstrak elemen minimum dari Tableau muda; Fungsi ini menggunakan ExtractMin () untuk mencetak elemen dalam urutan yang disusun; Kod pemacu", "code": "import sys NEW_LINE INF = sys . maxsize NEW_LINE N = 4 NEW_LINE def youngify ( mat , i , j ) : NEW_LINE INDENT downVal = mat [ i + 1 ] [ j ] if ( i + 1 < N ) else INF NEW_LINE rightVal = mat [ i ] [ j + 1 ] if ( j + 1 < N ) else INF NEW_LINE if ( downVal == INF and rightVal == INF ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( downVal < rightVal ) : NEW_LINE INDENT mat [ i ] [ j ] = downVal NEW_LINE mat [ i + 1 ] [ j ] = INF NEW_LINE youngify ( mat , i + 1 , j ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = rightVal NEW_LINE mat [ i ] [ j + 1 ] = INF NEW_LINE youngify ( mat , i , j + 1 ) NEW_LINE DEDENT DEDENT def extractMin ( mat ) : NEW_LINE INDENT ret = mat [ 0 ] [ 0 ] NEW_LINE mat [ 0 ] [ 0 ] = INF NEW_LINE youngify ( mat , 0 , 0 ) NEW_LINE return ret NEW_LINE DEDENT def printSorted ( mat ) : NEW_LINE INDENT print ( \" Elements ▁ of ▁ matrix ▁ in ▁ sorted ▁ order ▁ n \" ) NEW_LINE i = 0 NEW_LINE while i < N * N : NEW_LINE INDENT print ( extractMin ( mat ) , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] ] NEW_LINE printSorted ( mat ) NEW_LINE DEDENT"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | saiz k x k saiz matriks yang diberikan; Fungsi mudah untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; Nombor baris sel pertama dalam sub -persegi semasa saiz k x k; Lajur sel pertama dalam sub -persegi semasa saiz k x k; Hitung dan cetak jumlah sub -persegi semasa; Pemisah garis untuk sub -dataran bermula dengan baris seterusnya; Kod pemacu", "code": "n = 5 NEW_LINE def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumSimple ( mat , k ) NEW_LINE DEDENT"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Saiz matriks yang diberikan; A o (n ^ 2) berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi yang diberikan saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; 1: Preprocessing untuk menyimpan jumlah semua jalur saiz k x 1; Pergi lajur mengikut lajur; Hitung jumlah pertama K x 1 segi empat tepat dalam lajur ini; Hitung jumlah segi empat tepat; 2: Kirakan jumlah sub - dataran menggunakan stripsum [] []; Hitung dan prsum subsquare pertama dalam baris ini; Kirakan jumlah kuadrat yang tinggal dalam baris semasa dengan mengeluarkan jalur paling kiri sub -persegi sebelumnya dan menambah jalur baru; Kod pemacu", "code": "n = 5 NEW_LINE def printSumTricky ( mat , k ) : NEW_LINE INDENT global n NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ None ] * n for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = Sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = Sum NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT Sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( Sum , end = \" ▁ \" ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( Sum , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumTricky ( mat , k ) NEW_LINE"}
{"text": "Program untuk mencari transpose matriks | Program python3 untuk mencari transpose matriks; Fungsi ini menyimpan transpose a [] [] dalam b [] []; kod pemacu", "code": "M = 3 NEW_LINE N = 4 NEW_LINE def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] NEW_LINE B = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE transpose ( A , B ) NEW_LINE print ( \" Result ▁ matrix ▁ is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( B [ i ] [ j ] , \" ▁ \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari transpose matriks | Program python3 untuk mencari transpose matriks; Mencari transpose dari [] [] di tempat; kod pemacu", "code": "N = 4 NEW_LINE def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE transpose ( A ) NEW_LINE print ( \" Modified ▁ matrix ▁ is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( A [ i ] [ j ] , \" ▁ \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program python rekursif naif untuk mengira laluan dengan duit syiling 'k' tepat; Fungsi rekursif untuk mengira laluan dengan jumlah k dari (0, 0) hingga (m, n); Kes asas; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas PathCountrec (); Program Pemandu", "code": "R = 3 NEW_LINE C = 3 NEW_LINE def pathCountRec ( mat , m , n , k ) : NEW_LINE INDENT if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT return ( pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE DEDENT def pathCount ( mat , k ) : NEW_LINE INDENT return pathCountRec ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT k = 12 NEW_LINE mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] NEW_LINE print ( pathCount ( mat , k ) ) NEW_LINE"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program python3 berasaskan pengaturcaraan yang dinamik untuk mengira laluan dengan duit syiling 'k' tepat; Kes asas; Jika subproblem ini sudah diselesaikan; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas pathcountdprecdp (); Kod pemacu", "code": "R = 3 NEW_LINE C = 3 NEW_LINE MAX_K = 1000 NEW_LINE def pathCountDPRecDP ( mat , m , n , k ) : NEW_LINE INDENT if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT if ( dp [ m ] [ n ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] [ k ] NEW_LINE DEDENT dp [ m ] [ n ] [ k ] = ( pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE return dp [ m ] [ n ] [ k ] NEW_LINE DEDENT def pathCountDP ( mat , k ) : NEW_LINE INDENT return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT k = 12 NEW_LINE dp = [ [ [ - 1 for col in range ( MAX_K ) ] for col in range ( C ) ] for row in range ( R ) ] NEW_LINE mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] NEW_LINE print ( pathCountDP ( mat , k ) ) NEW_LINE"}
{"text": "Susun Matriks yang Diberikan | Pelaksanaan Python3 untuk menyusun matriks yang diberikan; Berfungsi untuk menyusun matriks yang diberikan; Matriks sementara saiz n ^ 2; Salin unsur -unsur matriks satu demi satu ke temp []; Susun temp []; Salin unsur -unsur temp [] satu demi satu dalam tikar [] []; Berfungsi untuk mencetak matriks yang diberikan; Program Pemandu untuk diuji di atas", "code": "SIZE = 10 NEW_LINE def sortMat ( mat , n ) : NEW_LINE INDENT temp = [ 0 ] * ( n * n ) NEW_LINE k = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT temp [ k ] = mat [ i ] [ j ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT temp . sort ( ) NEW_LINE k = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] [ j ] = temp [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE n = 3 NEW_LINE print ( \" Original ▁ Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMat ( mat , n ) NEW_LINE print ( \" Matrix After Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE"}
{"text": "Bubble sort | Versi bubble yang dioptimumkan; melintasi array dari 0 hingga n - i - 1. Swap jika elemen yang dijumpai lebih besar daripada elemen seterusnya; Jika tidak ada dua elemen yang ditukar dengan gelung dalaman, kemudian pecah; Kod pemacu untuk diuji di atas", "code": "def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT swapped = False NEW_LINE for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if swapped == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ 64 , 34 , 25 , 12 , 22 , 11 , 90 ] NEW_LINE bubbleSort ( arr ) NEW_LINE print ( \" Sorted ▁ array ▁ : \" ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( \" % d \" % arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"}
{"text": "Cari K Elemen yang paling dekat dengan nilai yang diberikan | Fungsi untuk mencari titik silang (titik yang sebelum ini unsur -unsur aresmaller daripada atau sama dengan x dan selepas itu lebih besar daripada x); Kes asas X lebih besar daripada semua; X lebih kecil daripada semua; Cari titik tengah; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Fungsi ini mencetak elemen yang paling dekat dengan x dalam arr []. n ialah bilangan elemen dalam arr []; Cari titik crossover; Indeks yang betul untuk mencari; Untuk menjejaki kiraan elemen yang telah dicetak; Jika x hadir dalam arr [], maka kurangkan indeks kiri. Asumsi: Semua elemen dalam ARR [] adalah berbeza; Bandingkan unsur -unsur di kiri dan kanan titik crossover untuk mencari unsur -unsur yang paling dekat; Jika tidak ada lagi elemen di sebelah kanan, maka cetak elemen kiri; Sekiranya tidak ada lagi elemen di sebelah kiri, maka cetak elemen kanan; Kod pemacu", "code": "def findCrossOver ( arr , low , high , x ) : NEW_LINE INDENT if ( arr [ high ] <= x ) : NEW_LINE INDENT return high NEW_LINE DEDENT if ( arr [ low ] > x ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] <= x and arr [ mid + 1 ] > x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] < x ) : NEW_LINE INDENT return findCrossOver ( arr , mid + 1 , high , x ) NEW_LINE DEDENT return findCrossOver ( arr , low , mid - 1 , x ) NEW_LINE DEDENT def printKclosest ( arr , x , k , n ) : NEW_LINE INDENT l = findCrossOver ( arr , 0 , n - 1 , x ) NEW_LINE r = l + 1 NEW_LINE count = 0 NEW_LINE if ( arr [ l ] == x ) : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT while ( l >= 0 and r < n and count < k ) : NEW_LINE INDENT if ( x - arr [ l ] < arr [ r ] - x ) : NEW_LINE INDENT print ( arr [ l ] , end = \" ▁ \" ) NEW_LINE l -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ r ] , end = \" ▁ \" ) NEW_LINE r += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT while ( count < k and l >= 0 ) : NEW_LINE INDENT print ( arr [ l ] , end = \" ▁ \" ) NEW_LINE l -= 1 NEW_LINE count += 1 NEW_LINE DEDENT while ( count < k and r < n ) : NEW_LINE INDENT print ( arr [ r ] , end = \" ▁ \" ) NEW_LINE r += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 ] NEW_LINE n = len ( arr ) NEW_LINE x = 35 NEW_LINE k = 4 NEW_LINE printKclosest ( arr , x , 4 , n ) NEW_LINE DEDENT"}
{"text": "SENARAI SENSI UNTUK SENDIRI SISTY LINKED | Pelaksanaan Pyhton algoritma di atas; Fungsi utiliti untuk memasukkan nod pada permulaan senarai yang dipautkan; memperuntukkan nod; Pautan senarai lama dari nod baru; gerakkan kepala untuk menunjuk ke nod baru; Fungsi untuk menyusun senarai yang berkaitan dengan menggunakan jenis penyisipan; Memulakan senarai yang disusun; Melintasi senarai yang dipautkan dan masukkan setiap nod untuk disusun; Simpan seterusnya untuk lelaran seterusnya; Masukkan arus dalam senarai yang disusun; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun; berfungsi untuk memasukkan new_node dalam senarai. Perhatikan bahawa fungsi ini menjangkakan penunjuk kepada HEAD_REF kerana ini dapat mengubah suai kepala senarai yang dipautkan input (serupa dengan push ()); Kes khas untuk hujung kepala; Cari nod sebelum titik penyisipan; Fungsi di bawah hanya utiliti untuk menguji fungsi sortedInsert untuk mencetak senarai yang dipautkan; Program pemacu untuk menguji fungsi di atas", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT def insertionSort ( head_ref ) : NEW_LINE INDENT sorted = None NEW_LINE current = head_ref NEW_LINE while ( current != None ) : NEW_LINE INDENT next = current . next NEW_LINE sorted = sortedInsert ( sorted , current ) NEW_LINE current = next NEW_LINE DEDENT head_ref = sorted NEW_LINE return head_ref NEW_LINE DEDENT def sortedInsert ( head_ref , new_node ) : NEW_LINE INDENT current = None NEW_LINE if ( head_ref == None or ( head_ref ) . data >= new_node . data ) : NEW_LINE INDENT new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE DEDENT else : NEW_LINE INDENT current = head_ref NEW_LINE while ( current . next != None and current . next . data < new_node . data ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT new_node . next = current . next NEW_LINE current . next = new_node NEW_LINE DEDENT return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT a = None NEW_LINE a = push ( a , 5 ) NEW_LINE a = push ( a , 20 ) NEW_LINE a = push ( a , 4 ) NEW_LINE a = push ( a , 3 ) NEW_LINE a = push ( a , 30 ) NEW_LINE print ( \" Linked ▁ List ▁ before ▁ sorting ▁ \" ) NEW_LINE printList ( a ) NEW_LINE a = insertionSort ( a ) NEW_LINE print ( \" Linked List after sorting   \" ) NEW_LINE printList ( a ) NEW_LINE"}
{"text": "Perubahan duit syiling | DP | Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program pemacu untuk menguji fungsi di atas", "code": "def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE print ( count ( arr , m , 4 ) ) NEW_LINE"}
{"text": "Perubahan duit syiling | DP | Pelaksanaan Python Pengaturcaraan Dinamik Masalah Perubahan Koin; Jadual [i] akan menyimpan bilangan penyelesaian untuk nilai i. Kami memerlukan baris n + 1 kerana jadual dibina dengan cara bawah menggunakan kes asas (n = 0) memulakan semua nilai jadual sebagai 0; Kes asas (jika diberi nilai adalah 0); Pilih semua syiling satu demi satu dan kemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai duit syiling yang dipilih; Program pemacu untuk menguji fungsi di atas", "code": "def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE"}
{"text": "Pendaraban rantai matriks | DP | Program Python menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "import sys NEW_LINE dp = [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is \" , MatrixChainOrder ( arr , n ) ) NEW_LINE"}
{"text": "Pendaraban rantai matriks | DP | Pelaksanaan Python Pengaturcaraan Dinamik Pendaraban Rantaian Matriks. Lihat buku Cormen untuk butiran algoritma berikut; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam M [] []. 0 bar dan lajur 0 M [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu", "code": "import sys NEW_LINE def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" + str ( MatrixChainOrder ( arr , size ) ) ) NEW_LINE"}
{"text": "Memotong batang | DP | Penyelesaian rekursif naif untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Recursif memotong batang dalam kepingan yang berbeza dan membandingkan konfigurasi yang berbeza; Kod pemacu", "code": "import sys NEW_LINE def max ( a , b ) : NEW_LINE INDENT return a if ( a > b ) else b NEW_LINE DEDENT def cutRod ( price , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_val = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) NEW_LINE DEDENT return max_val NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum ▁ Obtainable ▁ Value ▁ is \" , cutRod ( arr , size ) ) NEW_LINE"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "INT_MIN = - 32767 NEW_LINE def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" + str ( cutRod ( arr , size ) ) ) NEW_LINE"}
{"text": "Multiply two integers without using multiplication , division and bitwise operators , and no loops | Berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; Kes di mana y adalah negatif; Kod pemacu", "code": "def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT print ( multiply ( 5 , - 11 ) ) NEW_LINE"}
{"text": "Sieve of Eratosthenes | Program python untuk mencetak semua prima yang lebih kecil daripada atau sama dengan n menggunakan ayak eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor utama; Kod pemacu", "code": "def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT print p , NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 30 NEW_LINE print \" Following ▁ are ▁ the ▁ prime ▁ numbers ▁ smaller \" , NEW_LINE print \" than ▁ or ▁ equal ▁ to \" , n NEW_LINE SieveOfEratosthenes ( n ) NEW_LINE DEDENT"}
{"text": "Segitiga Pascal | BinomialCoeff; Program yang mudah (n ^ 3) untuk Pascal 's' fungsi »cetak» 'u u' '' '' '' ' Berulang melalui setiap baris dan cetak penyertaan di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Program Pemandu", "code": "def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def printPascal ( n ) : NEW_LINE INDENT for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT print ( binomialCoeff ( line , i ) , \" ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE printPascal ( n ) NEW_LINE"}
{"text": "Segitiga Pascal | A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga pascal yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai -nilai lain adalah jumlah nilai di atas dan kiri di atas; Kod pemacu", "code": "def printPascal ( n : int ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT if ( i == 0 or i == line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" \" , ▁ end ▁ = ▁ \" \" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printPascal ( n ) NEW_LINE"}
{"text": "Segitiga Pascal | Program Python3 untuk Pascal 's' u u (n ^ 2) ~ masa u dan u (1) ~ or »» ~ »~ ~» ~ »~» »~ ~» »~» ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu", "code": "def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = \" ▁ \" ) ; NEW_LINE C = int ( C * ( line - i ) / i ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printPascal ( n ) ; NEW_LINE"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | Program Python3 untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; Kod pemacu", "code": "def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( Add ( 15 , 32 ) ) NEW_LINE"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik |", "code": "def Add ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return Add ( x ^ y , ( x & y ) << 1 ) NEW_LINE DEDENT DEDENT"}
{"text": "Mengira Bahagian Modulus dengan Kuasa | Fungsi ini akan kembali n % d. D mestilah salah satu: 1, 2, 4, 8, 16, 32, ...; Program pemacu untuk menguji fungsi di atas; D mesti menjadi kuasa 2", "code": "def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT n = 6 NEW_LINE d = 4 NEW_LINE print ( n , \" moduo \" , d , \" is \" , getModulo ( n , d ) ) NEW_LINE"}
{"text": "Count set bit dalam integer | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Program untuk menguji fungsi countsetbits", "code": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 9 NEW_LINE print ( countSetBits ( i ) ) NEW_LINE"}
{"text": "Count set bit dalam integer | fungsi rekursif untuk mengira set bit; Kes asas; Dapatkan nilai dari pengguna; fungsi panggilan", "code": "def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"}
{"text": "Count set bit dalam integer | Jadual carian; Berfungsi untuk memulakan jadual carian; Pada mulanya menjana jadual algoritma; Berfungsi untuk mengembalikan kiraan bit set dalam n; Memulakan jadual carian", "code": "BitsSetTable256 = [ 0 ] * 256 NEW_LINE def initialize ( ) : NEW_LINE INDENT BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i // 2 ] NEW_LINE DEDENT DEDENT def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE"}
{"text": "Count set bit dalam integer | Kod pemacu", "code": "print ( bin ( 4 ) . count ( '1' ) ) ; NEW_LINE print ( bin ( 15 ) . count ( '1' ) ) ; NEW_LINE"}
{"text": "Count set bit dalam integer | Program Python3 untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu", "code": "num_to_bits = [ 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ] ; NEW_LINE def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT nibble = num & 0xf ; NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE DEDENT num = 31 ; NEW_LINE print ( countSetBitsRec ( num ) ) ; NEW_LINE"}
{"text": "Count set bit dalam integer | Semak setiap bit dalam nombor ditetapkan atau tidak dan kembalikan jumlah kiraan bit yang ditetapkan; (1 << i) = pow (2, i); Kod pemacu", "code": "def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE count += 1 NEW_LINE return count NEW_LINE N = 15 NEW_LINE print ( countSetBits ( N ) ) NEW_LINE DEDENT DEDENT"}
{"text": "Program untuk mencari pariti | Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Program Pemandu untuk Menguji GetParity ()", "code": "def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT n = 7 NEW_LINE print ( \" Parity ▁ of ▁ no ▁ \" , n , \" ▁ = ▁ \" , ( \" odd \" if getParity ( n ) else \" even \" ) ) NEW_LINE"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program Python3 untuk mencari sama ada tidak ada kuasa dua; Fungsi untuk memeriksa asas log 2; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "import math NEW_LINE def Log2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return false ; NEW_LINE DEDENT return ( math . log10 ( x ) / math . log10 ( 2 ) ) ; NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( Log2 ( n ) ) == math . floor ( Log2 ( n ) ) ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Kod pemacu; Benar; Palsu", "code": "def powerof2 ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return powerof2 ( n / 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( powerof2 ( 64 ) ) NEW_LINE print ( powerof2 ( 12 ) ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kod pemacu", "code": "def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"}
{"text": "Cari nombor pengulangan maksimum dalam O (n) masa dan O (1) ruang tambahan | Mengembalikan elemen berulang maksimum dalam ARR [0. n - 1]. The array elements are in range from 0 to k - 1 ; Berulang walaupun array input, untuk setiap elemen arr [i], kenaikan arr [arr [i] % k] oleh k; Cari indeks elemen berulang maksimum; Indeks pulangan elemen maksimum; Program pemacu untuk menguji fungsi di atas", "code": "def maxRepeating ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ arr [ i ] % k ] += k NEW_LINE DEDENT max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE print ( \" The ▁ maximum ▁ repeating ▁ number ▁ is \" , maxRepeating ( arr , n , k ) ) NEW_LINE"}
{"text": "Pertanyaan pelbagai pada array yang setiap elemen adalah xor nilai indeks dan elemen sebelumnya | Fungsi pulangan nilai formula yang diperolehi. ; Mencari nilai XOR julat [y ... x]; Fungsi untuk menyelesaikan pertanyaan untuk l dan r. ; jika l atau r ialah 0 .; Mencari X boleh dibahagikan dengan 2 atau tidak. ; Kod pemacu", "code": "def fun ( x ) : NEW_LINE INDENT y = ( x // 4 ) * 4 NEW_LINE ans = 0 NEW_LINE for i in range ( y , x + 1 ) : NEW_LINE INDENT ans ^= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def query ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = ( x + 1 ) // 2 NEW_LINE if x % 2 == 0 : NEW_LINE INDENT return ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * fun ( k ) ) NEW_LINE DEDENT DEDENT def allQueries ( q , l , r ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) NEW_LINE DEDENT DEDENT q = 3 NEW_LINE l = [ 2 , 2 , 5 ] NEW_LINE r = [ 4 , 8 , 9 ] NEW_LINE allQueries ( q , l , r ) NEW_LINE"}
{"text": "Pertanyaan pada Xor pembahagi ganjil yang paling hebat dari julat | Precompute awalan xor pembahagi ganjil yang paling besar; Mencari pembahagi ganjil yang paling besar; Mencari awalan xor; Kembali xor julat; Kod pemacu", "code": "def prefixXOR ( arr , preXOR , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT while ( arr [ i ] % 2 != 1 ) : NEW_LINE INDENT arr [ i ] = int ( arr [ i ] / 2 ) NEW_LINE DEDENT preXOR [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] NEW_LINE DEDENT DEDENT def query ( preXOR , l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return preXOR [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return preXOR [ r ] ^ preXOR [ l - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE preXOR = [ 0 for i in range ( n ) ] NEW_LINE prefixXOR ( arr , preXOR , n ) NEW_LINE print ( query ( preXOR , 0 , 2 ) ) NEW_LINE print ( query ( preXOR , 1 , 2 ) ) NEW_LINE DEDENT"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari | Fungsi untuk mencari swap minimum untuk menyusun pelbagai 0 s dan 1 s. ; Array untuk menyimpan kiraan sifar; Kira bilangan sifar di sebelah kanan setiap satu. ; Count total number of swaps by adding number of zeroes on right side of every one . ; Kod pemacu", "code": "def findMinSwaps ( arr , n ) : NEW_LINE INDENT noOfZeroes = [ 0 ] * n NEW_LINE count = 0 NEW_LINE noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i + 1 ] NEW_LINE if ( arr [ i ] == 0 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count = count + noOfZeroes [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinSwaps ( arr , n ) ) NEW_LINE"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari |  ; Kod pemacu", "code": "def minswaps ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE num_unplaced_zeros = 0 NEW_LINE for index in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ index ] == 0 : NEW_LINE INDENT num_unplaced_zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += num_unplaced_zeros NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE print ( minswaps ( arr ) ) NEW_LINE"}
{"text": "Program untuk memeriksa sama ada array disusun atau tidak (berulang dan rekursif) | Fungsi yang pulih benar jika array disusun dalam perintah yang tidak menurun. ; Array mempunyai satu atau tiada elemen; Pasangan yang tidak disusun dijumpai; Tiada pasangan yang tidak disusun dijumpai; Kod pemacu", "code": "def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan XOR semua elemen di arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana mudah diperoleh; Sekarang bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; Kod pemacu", "code": "def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( \" The ▁ two ▁ ODD ▁ elements ▁ are \" , x , \" & \" , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE"}
{"text": "Cari pasangan dengan perbezaan yang diberikan | Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Fungsi pemacu untuk menguji fungsi di atas", "code": "def findPair ( arr , n ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE i , j = 0 , 1 NEW_LINE while i < size and j < size : NEW_LINE INDENT if i != j and arr [ j ] - arr [ i ] == n : NEW_LINE INDENT print \" Pair ▁ found ▁ ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" NEW_LINE return True NEW_LINE DEDENT elif arr [ j ] - arr [ i ] < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print \" No ▁ pair ▁ found \" NEW_LINE return False NEW_LINE DEDENT arr = [ 1 , 8 , 30 , 40 , 100 ] NEW_LINE n = 60 NEW_LINE findPair ( arr , n ) NEW_LINE"}
{"text": "Cari K Unsur Maksimum Array dalam Perintah Asal | Berfungsi untuk elemen maksimum; vektor untuk menyimpan salinan array asal; Menyusun vektor dalam urutan menurun. Sila rujuk pautan di bawah untuk butiran; Melintasi array asal dan memelihara semua unsur -unsur yang berada dalam k vektor yang disusun pertama. ; Kod pemacu", "code": "def printMax ( arr , k , n ) : NEW_LINE INDENT brr = arr . copy ( ) NEW_LINE brr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in brr [ 0 : k ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 50 , 8 , 45 , 12 , 25 , 40 , 84 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printMax ( arr , k , n ) NEW_LINE"}
{"text": "Cetak n elemen terkecil dari array yang diberikan dalam urutan asal mereka | Fungsi untuk binary_search; Berfungsi untuk mencetak nombor N terkecil; Buat salinan Array; Susun Arahan Salin; Bagi setiap arr [i] mendapati sama ada ia adalah sebahagian daripada N - terkecil dengan carian binari; Kod pemacu", "code": "def binary_search ( arr , low , high , ele ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] == ele : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > ele : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printSmall ( arr , asize , n ) : NEW_LINE INDENT copy_arr = arr . copy ( ) NEW_LINE copy_arr . sort ( ) NEW_LINE for i in range ( asize ) : NEW_LINE INDENT if binary_search ( copy_arr , low = 0 , high = n , ele = arr [ i ] ) > - 1 : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE DEDENT"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; Kod pemacu", "code": "def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Yes \" ) if ( checkIsAP ( arr , n ) ) else print ( \" No \" ) NEW_LINE"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Cari yang terkecil dan kemas kini kedua terkecil; Cari kedua terkecil; Semak sama ada elemen pendua yang dijumpai atau tidak; Jika pendua dijumpai kemudian kembali palsu; Cari perbezaan antara terkecil dan kedua terkecil; Seperti yang kita telah menggunakan terkecil terkecil dan kedua, jadi kita hanya perlu menyemak unsur -unsur n - 2; Kod pemacu", "code": "def checkIsAP ( arr , n ) : NEW_LINE INDENT hm = { } NEW_LINE smallest = float ( ' inf ' ) NEW_LINE second_smallest = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < smallest ) : NEW_LINE INDENT second_smallest = smallest NEW_LINE smallest = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] != smallest and arr [ i ] < second_smallest ) : NEW_LINE INDENT second_smallest = arr [ i ] NEW_LINE DEDENT if arr [ i ] not in hm : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT diff = second_smallest - smallest NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( second_smallest ) not in hm : NEW_LINE INDENT return False NEW_LINE DEDENT second_smallest += diff NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkIsAP ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Kira cara memilih pasangan dengan perbezaan maksimum | Kod Python untuk mencari tidak. cara memilih pasangan dengan perbezaan maksimum; Untuk mencari minimum dan maksimum array; untuk mencari kiraan elemen minimum dan maksimum; Kiraan pembolehubah; keadaan untuk semua elemen sama; Kod pemacu", "code": "def countPairs ( a , n ) : NEW_LINE INDENT mn = + 2147483647 NEW_LINE mx = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( mn , a [ i ] ) NEW_LINE mx = max ( mx , a [ i ] ) NEW_LINE DEDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == mn ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( a [ i ] == mx ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT if ( mn == mx ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return c1 * c2 NEW_LINE DEDENT DEDENT a = [ 3 , 2 , 1 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n ) ) NEW_LINE"}
{"text": "Susun semula senarai yang dipautkan dalam | Kod python3 untuk menyusun semula senarai yang dipautkan di tempat; Berfungsi untuk menyusun semula senarai yang dipautkan dengan nilai tinggi dan rendah; Kes asas; Pembolehubah dua penunjuk; Fungsi pertukaran untuk menukar data; Fungsi pertukaran untuk menukar data; Berfungsi untuk memasukkan nod dalam senarai yang dipautkan pada mulanya; Berfungsi untuk memaparkan nod senarai yang dipautkan; Kod pemacu; Biarkan Buat Senarai Terkait 9. 6. 8. 3. 7", "code": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def rearrange ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT prev , curr = head , head . next NEW_LINE while ( curr ) : NEW_LINE INDENT if ( prev . data > curr . data ) : NEW_LINE INDENT prev . data , curr . data = curr . data , prev . data NEW_LINE DEDENT if ( curr . next and curr . next . data > curr . data ) : NEW_LINE INDENT curr . next . data , curr . data = curr . data , curr . next . data NEW_LINE DEDENT prev = curr . next NEW_LINE if ( not curr . next ) : NEW_LINE INDENT break NEW_LINE DEDENT curr = curr . next . next NEW_LINE DEDENT return head NEW_LINE DEDENT def push ( head , k ) : NEW_LINE INDENT tem = Node ( k ) NEW_LINE tem . data = k NEW_LINE tem . next = head NEW_LINE head = tem NEW_LINE return head NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( curr . data , end = \" ▁ \" ) NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = rearrange ( head ) NEW_LINE display ( head ) NEW_LINE DEDENT"}
{"text": "Susun semula senarai yang dipautkan dalam | Pelaksanaan Python3;  ; Berfungsi untuk mencetak senarai; Berfungsi untuk menyusun semula; Kami menetapkan kiri = null, apabila kita mencapai keadaan berhenti, jadi tiada pemprosesan diperlukan selepas itu; Kondisi Hentikan: Kes Ganjil: Kiri = Kanan, Malah Kes: Kiri. seterusnya = kanan; Hentikan keadaan, tetapkan null ke nod kiri; Malah kes; Kes ganjil; Kod pemacu; Cetak senarai asal; Mengubah suai senarai; Cetak senarai yang diubahsuai", "code": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . next = None NEW_LINE DEDENT DEDENT left = None NEW_LINE def printlist ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE if ( head . next != None ) : NEW_LINE INDENT print ( \" - > \" , end = \" \" ) NEW_LINE DEDENT head = head . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def rearrange ( head ) : NEW_LINE INDENT global left NEW_LINE if ( head != None ) : NEW_LINE INDENT left = head NEW_LINE reorderListUtil ( left ) NEW_LINE DEDENT DEDENT def reorderListUtil ( right ) : NEW_LINE INDENT global left NEW_LINE if ( right == None ) : NEW_LINE INDENT return NEW_LINE DEDENT reorderListUtil ( right . next ) NEW_LINE if ( left == None ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( left != right and left . next != right ) : NEW_LINE INDENT temp = left . next NEW_LINE left . next = right NEW_LINE right . next = temp NEW_LINE left = temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( left . next == right ) : NEW_LINE INDENT left . next . next = None NEW_LINE left = None NEW_LINE DEDENT else : NEW_LINE INDENT left . next = None NEW_LINE left = None NEW_LINE DEDENT DEDENT DEDENT head = Node ( 1 ) NEW_LINE head . next = Node ( 2 ) NEW_LINE head . next . next = Node ( 3 ) NEW_LINE head . next . next . next = Node ( 4 ) NEW_LINE head . next . next . next . next = Node ( 5 ) NEW_LINE printlist ( head ) NEW_LINE rearrange ( head ) NEW_LINE printlist ( head ) NEW_LINE"}
{"text": "Kurangkan dua nombor yang diwakili sebagai senarai yang dipautkan | Nod senarai yang dipautkan; Fungsi utiliti untuk mendapatkan panjang senarai yang dipautkan; Utiliti yang sifar Padds di hadapan nod, dengan perbezaan yang diberikan; Kurangkan Helper LinkedList adalah fungsi rekursif, bergerak sehingga nod terakhir, dan tolak digit dan buat nod dan kembalikan nod. Jika D1 <D2, kami meminjam nombor dari digit sebelumnya. ; Jika anda telah memberikan nilai nilai kepada digit seterusnya maka kurangkan D1 dengan 1; Jika D1 <D2, kemudian pinjam nombor dari digit sebelumnya. Tambah 10 hingga D1 dan set Borrow = true; tolak digit; Buat nod dengan sub nilai; Tetapkan penunjuk seterusnya seperti sebelumnya; API ini menolak dua senarai yang dipautkan dan mengembalikan senarai yang dipautkan yang akan mempunyai hasil yang dikurangkan. ; Kes asas. ; Dalam kedua -dua kes itu, dapatkan panjang kedua -dua senarai yang dipautkan. ; Jika panjang berbeza, hitung nod yang lebih kecil dan sifar PADD untuk nod yang lebih kecil dan pastikan kedua -dua nod yang lebih besar dan nod yang lebih kecil mempunyai panjang yang sama. ; Jika kedua -dua senarai panjang adalah sama, maka hitung senarai yang lebih besar dan lebih kecil. Jika 5 - 6 - 7 & 5 - 6 - 8 adalah senarai yang dipautkan, kemudian berjalan melalui senarai yang dipautkan pada nod terakhir sebagai 7 <8, nod yang lebih besar adalah 5 - 6 - 8 dan nod yang lebih kecil ialah 5 - 6 - 7 .; Setelah mengira nod yang lebih besar dan lebih kecil, call tolakLinkedListHelper yang mengembalikan senarai yang dipautkan. ; Fungsi utiliti untuk mencetak senarai yang dipautkan; Program pemacu untuk menguji fungsi di atas", "code": "class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT def getLength ( Node ) : NEW_LINE INDENT size = 0 NEW_LINE while ( Node != None ) : NEW_LINE INDENT Node = Node . next NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT def paddZeros ( sNode , diff ) : NEW_LINE INDENT if ( sNode == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT zHead = newNode ( 0 ) NEW_LINE diff = diff - 1 NEW_LINE temp = zHead NEW_LINE while ( diff > 0 ) : NEW_LINE INDENT diff = diff - 1 NEW_LINE temp . next = newNode ( 0 ) NEW_LINE temp = temp . next NEW_LINE DEDENT temp . next = sNode NEW_LINE return zHead NEW_LINE DEDENT borrow = True NEW_LINE def subtractLinkedListHelper ( l1 , l2 ) : NEW_LINE INDENT global borrow NEW_LINE if ( l1 == None and l2 == None and not borrow ) : NEW_LINE INDENT return None NEW_LINE DEDENT l3 = None NEW_LINE l4 = None NEW_LINE if ( l1 != None ) : NEW_LINE INDENT l3 = l1 . next NEW_LINE DEDENT if ( l2 != None ) : NEW_LINE INDENT l4 = l2 . next NEW_LINE DEDENT previous = subtractLinkedListHelper ( l3 , l4 ) NEW_LINE d1 = l1 . data NEW_LINE d2 = l2 . data NEW_LINE sub = 0 NEW_LINE if ( borrow ) : NEW_LINE INDENT d1 = d1 - 1 NEW_LINE borrow = False NEW_LINE DEDENT if ( d1 < d2 ) : NEW_LINE INDENT borrow = True NEW_LINE d1 = d1 + 10 NEW_LINE DEDENT sub = d1 - d2 NEW_LINE current = newNode ( sub ) NEW_LINE current . next = previous NEW_LINE return current NEW_LINE DEDENT def subtractLinkedList ( l1 , l2 ) : NEW_LINE INDENT if ( l1 == None and l2 == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT len1 = getLength ( l1 ) NEW_LINE len2 = getLength ( l2 ) NEW_LINE lNode = None NEW_LINE sNode = None NEW_LINE temp1 = l1 NEW_LINE temp2 = l2 NEW_LINE if ( len1 != len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT lNode = l1 NEW_LINE DEDENT else : NEW_LINE INDENT lNode = l2 NEW_LINE DEDENT if ( len1 > len2 ) : NEW_LINE INDENT sNode = l2 NEW_LINE DEDENT else : NEW_LINE INDENT sNode = l1 NEW_LINE DEDENT sNode = paddZeros ( sNode , abs ( len1 - len2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( l1 != None and l2 != None ) : NEW_LINE INDENT if ( l1 . data != l2 . data ) : NEW_LINE INDENT if ( l1 . data > l2 . data ) : NEW_LINE INDENT lNode = temp1 NEW_LINE DEDENT else : NEW_LINE INDENT lNode = temp2 NEW_LINE DEDENT if ( l1 . data > l2 . data ) : NEW_LINE INDENT sNode = temp2 NEW_LINE DEDENT else : NEW_LINE INDENT sNode = temp1 NEW_LINE DEDENT break NEW_LINE DEDENT l1 = l1 . next NEW_LINE l2 = l2 . next NEW_LINE DEDENT DEDENT global borrow NEW_LINE borrow = False NEW_LINE return subtractLinkedListHelper ( lNode , sNode ) NEW_LINE DEDENT def printList ( Node ) : NEW_LINE INDENT while ( Node != None ) : NEW_LINE INDENT print ( Node . data , end = \" ▁ \" ) NEW_LINE Node = Node . next NEW_LINE DEDENT print ( \" ▁ \" ) NEW_LINE DEDENT head1 = newNode ( 1 ) NEW_LINE head1 . next = newNode ( 0 ) NEW_LINE head1 . next . next = newNode ( 0 ) NEW_LINE head2 = newNode ( 1 ) NEW_LINE result = subtractLinkedList ( head1 , head2 ) NEW_LINE printList ( result ) NEW_LINE"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | Kelas nod; pembina untuk membuat nod baru; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan diberikan kepala; Jika senarai kosong; Buat nod baru untuk nilai yang akan dimasukkan; calcualte panjang senarai yang dipautkan; 'mengira' bilangan nod yang selepas nod baru perlu dimasukkan; gerakkan PTR ke nod yang mana nod baru perlu dimasukkan; Masukkan 'newnode' dan laraskan pautan dengan sewajarnya; berfungsi untuk membuang senarai yang dipautkan; Mewujudkan senarai yang dipautkan 1.2. 4.5; Memasukkan 3 di tengah -tengah senarai yang dipautkan.", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def insertAtMid ( head , x ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT head = Node ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT newNode = Node ( x ) NEW_LINE ptr = head NEW_LINE length = 0 NEW_LINE while ( ptr != None ) : NEW_LINE INDENT ptr = ptr . next NEW_LINE length += 1 NEW_LINE DEDENT if ( length % 2 == 0 ) : NEW_LINE INDENT count = length / 2 NEW_LINE DEDENT else : NEW_LINE INDENT ( length + 1 ) / 2 NEW_LINE DEDENT ptr = head NEW_LINE while ( count > 1 ) : NEW_LINE INDENT count -= 1 NEW_LINE ptr = ptr . next NEW_LINE DEDENT newNode . next = ptr . next NEW_LINE ptr . next = newNode NEW_LINE DEDENT DEDENT def display ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( str ( temp . data ) , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT head = Node ( 1 ) NEW_LINE head . next = Node ( 2 ) NEW_LINE head . next . next = Node ( 4 ) NEW_LINE head . next . next . next = Node ( 5 ) NEW_LINE print ( \" Linked ▁ list ▁ before ▁ insertion : ▁ \" , end = \" \" ) NEW_LINE display ( head ) NEW_LINE x = 3 NEW_LINE insertAtMid ( head , x ) NEW_LINE print ( \" Linked list after insertion : \" ▁ , ▁ end ▁ = ▁ \" \" ) NEW_LINE display ( head ) NEW_LINE"}
{"text": "SENARAI SENSI UNTUK SENARAI DUBLY LINKED | Nod senarai dikaitkan dua kali ganda; berfungsi untuk membuat dan mengembalikan nod baru senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; berfungsi untuk memasukkan nod baru dalam cara yang disusun dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Jika nod dimasukkan pada permulaan senarai dikaitkan dua kali ganda; cari nod yang selepas itu nod baru dimasukkan; Membuat pautan yang sesuai; Jika nod baru tidak dimasukkan pada akhir senarai; Fungsi untuk menyusun senarai yang dikaitkan dua kali menggunakan jenis penyisipan; Inisialisasi 'disusun' - senarai dikaitkan dua kali ganda yang disusun; Melintasi senarai yang dikaitkan dengan dua kali ganda dan masukkan setiap nod untuk 'disusun; Simpan seterusnya untuk lelaran seterusnya; Mengeluarkan semua pautan untuk membuat 'semasa' sebagai nod baru untuk dimasukkan; Masukkan arus dalam senarai dikaitkan 'disusun'; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun dua kali ganda; berfungsi untuk mencetak senarai dikaitkan dua kali ganda; berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Buat seterusnya nod baru sebagai kepala dan sebelumnya tidak ada; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Kod pemacu; Mulakan dengan senarai dikaitkan dua kali ganda; Masukkan data berikut", "code": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT newNode = Node ( 0 ) NEW_LINE newNode . data = data NEW_LINE newNode . prev = newNode . next = None NEW_LINE return newNode NEW_LINE DEDENT def sortedInsert ( head_ref , newNode ) : NEW_LINE INDENT current = None NEW_LINE if ( head_ref == None ) : NEW_LINE INDENT head_ref = newNode NEW_LINE DEDENT elif ( ( head_ref ) . data >= newNode . data ) : NEW_LINE INDENT newNode . next = head_ref NEW_LINE newNode . next . prev = newNode NEW_LINE head_ref = newNode NEW_LINE DEDENT else : NEW_LINE INDENT current = head_ref NEW_LINE while ( current . next != None and current . next . data < newNode . data ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT newNode . next = current . next NEW_LINE if ( current . next != None ) : NEW_LINE INDENT newNode . next . prev = newNode NEW_LINE DEDENT current . next = newNode NEW_LINE newNode . prev = current NEW_LINE DEDENT return head_ref ; NEW_LINE DEDENT def insertionSort ( head_ref ) : NEW_LINE INDENT sorted = None NEW_LINE current = head_ref NEW_LINE while ( current != None ) : NEW_LINE INDENT next = current . next NEW_LINE current . prev = current . next = None NEW_LINE sorted = sortedInsert ( sorted , current ) NEW_LINE current = next NEW_LINE DEDENT head_ref = sorted NEW_LINE return head_ref NEW_LINE DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" ▁ \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE new_node . prev = None NEW_LINE if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . prev = new_node NEW_LINE DEDENT ( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 9 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 8 ) NEW_LINE print ( \" Doubly ▁ Linked ▁ List ▁ Before ▁ Sorting \" ) NEW_LINE printList ( head ) NEW_LINE head = insertionSort ( head ) NEW_LINE print ( \" Doubly Linked List After Sorting \" ) NEW_LINE printList ( head ) NEW_LINE DEDENT"}
{"text": "Cetak semua kemungkinan putaran array yang diberikan | Fungsi untuk membalikkan array antara indeks S dan E; Berfungsi untuk menjana semua kemungkinan putaran array; Kod pemacu", "code": "def reverse ( arr , s , e ) : NEW_LINE INDENT while s < e : NEW_LINE INDENT tem = arr [ s ] NEW_LINE arr [ s ] = arr [ e ] NEW_LINE arr [ e ] = tem NEW_LINE s = s + 1 NEW_LINE e = e - 1 NEW_LINE DEDENT DEDENT def fun ( arr , k ) : NEW_LINE INDENT n = len ( arr ) - 1 NEW_LINE v = n - k NEW_LINE if v >= 0 : NEW_LINE INDENT reverse ( arr , 0 , v ) NEW_LINE reverse ( arr , v + 1 , n ) NEW_LINE reverse ( arr , 0 , n ) NEW_LINE return arr NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT count = 0 NEW_LINE p = fun ( arr , i ) NEW_LINE print ( p , end = \" ▁ \" ) NEW_LINE DEDENT"}
{"text": "Cari jumlah array menggunakan bitwise atau selepas memisahkan array yang diberikan dalam dua bahagian selepas pergeseran bulat k | Program Python3 untuk mencari bitwise atau dua bahagian yang sama dengan array selepas melakukan peralihan bulat kanan K; Array untuk menyimpan pokok segmen; Berfungsi untuk membina pokok segmen; Berfungsi untuk mengembalikan atau unsur -unsur dalam julat [l, r]; Semak keadaan terikat; Cari tengah julat; Berulang untuk semua elemen dalam pelbagai; Berfungsi untuk mencari atau jumlah; Berfungsi untuk membina pokok segmen; Gelung untuk mengendalikan pertanyaan Q; Bilangan peralihan bulat yang betul; Atau separuh kedua array [n / 2 - i, n - 1 - i]; Atau separuh pertama array [n - i, n - 1] atau [0, n / 2 - 1 - i]; Cetak jawapan akhir untuk pertanyaan; Kod pemacu", "code": "MAX = 100005 NEW_LINE seg = [ 0 ] * ( 4 * MAX ) NEW_LINE def build ( node , l , r , a ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg [ node ] = a [ l ] NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE build ( 2 * node , l , mid , a ) NEW_LINE build ( 2 * node + 1 , mid + 1 , r , a ) NEW_LINE seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) NEW_LINE DEDENT DEDENT def query ( node , l , r , start , end , a ) : NEW_LINE INDENT if ( l > end or r < start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( start <= l and r <= end ) : NEW_LINE INDENT return seg [ node ] NEW_LINE DEDENT mid = ( l + r ) // 2 NEW_LINE return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) NEW_LINE DEDENT def orsum ( a , n , q , k ) : NEW_LINE INDENT build ( 1 , 0 , n - 1 , a ) NEW_LINE for j in range ( q ) : NEW_LINE INDENT i = k [ j ] % ( n // 2 ) NEW_LINE sec = query ( 1 , 0 , n - 1 , n // 2 - i , n - i - 1 , a ) NEW_LINE first = ( query ( 1 , 0 , n - 1 , 0 , n // 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) NEW_LINE temp = sec + first NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 ] NEW_LINE n = len ( a ) NEW_LINE q = 2 NEW_LINE k = [ 4 , 2 ] NEW_LINE orsum ( a , n , q , k ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan kiraan unsur -unsur yang sama dalam tatasusunan yang diberikan oleh putaran | Fungsi yang mencetak elemen maksimum yang sama; Senaraikan untuk menyimpan indeks elemen array b; Menyimpan kedudukan array b; Arahan frekuensi untuk mengekalkan unsur -unsur dengan perbezaan yang sama dalam jarak; Melangkah melalui semua elemen dalam ARR1 []; Kirakan bilangan peralihan yang diperlukan untuk menjadikan elemen semasa sama; Jika D kurang daripada 0; Simpan kekerapan perbezaan semasa; Kirakan kekerapan maksimum yang disimpan; Mencetak bilangan maksimum elemen yang sama; Kod pemacu; Diberikan dua tatasusunan; Panggilan fungsi", "code": "def maximumEqual ( a , b , n ) : NEW_LINE INDENT store = [ 0 ] * 10 ** 5 NEW_LINE for i in range ( n ) : NEW_LINE INDENT store [ b [ i ] ] = i + 1 NEW_LINE DEDENT ans = [ 0 ] * 10 ** 5 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d = abs ( store [ a [ i ] ] - ( i + 1 ) ) NEW_LINE if ( store [ a [ i ] ] < i + 1 ) : NEW_LINE INDENT d = n - d NEW_LINE DEDENT ans [ d ] += 1 NEW_LINE DEDENT finalans = 0 NEW_LINE for i in range ( 10 ** 5 ) : NEW_LINE INDENT finalans = max ( finalans , ans [ i ] ) NEW_LINE DEDENT print ( finalans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 6 , 7 , 3 , 9 , 5 ] NEW_LINE B = [ 7 , 3 , 9 , 5 , 6 ] NEW_LINE size = len ( A ) NEW_LINE maximumEqual ( A , B , size ) NEW_LINE DEDENT"}
{"text": "Arahan cetak selepas ia betul -betul diputar k kali | Berfungsi untuk array rightrotate; Jika putaran lebih besar daripada saiz array; Mencetak elemen kth paling kanan; Cetak array selepas elemen 'k'; Kod pemacu", "code": "def RightRotate ( a , n , k ) : NEW_LINE INDENT k = k % n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT print ( a [ n + i - k ] , end = \" ▁ \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i - k ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( \" \" ) ; NEW_LINE DEDENT Array = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE N = len ( Array ) ; NEW_LINE K = 2 ; NEW_LINE RightRotate ( Array , N , K ) ; NEW_LINE"}
{"text": "Sort Array Disusun Berputar | Berfungsi untuk memulihkan jenis asal; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "def restoreSortedArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT reverse ( arr , 0 , i ) ; NEW_LINE reverse ( arr , i + 1 , n ) ; NEW_LINE reverse ( arr , 0 , n ) ; NEW_LINE DEDENT DEDENT DEDENT def reverse ( arr , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE restoreSortedArray ( arr , n - 1 ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT"}
{"text": "Sort Array Disusun Berputar | Fungsi untuk mencari indeks permulaan array; Berfungsi untuk memulihkan jenis asal; Array sudah disusun; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Kod pemacu", "code": "def findStartIndexOfArray ( arr , low , high ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( low == high ) : NEW_LINE INDENT return low ; NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT if ( arr [ mid - 1 ] > arr [ mid ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findStartIndexOfArray ( arr , low , mid - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return findStartIndexOfArray ( arr , mid + 1 , high ) ; NEW_LINE DEDENT DEDENT def restoreSortedArray ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ n - 1 ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; NEW_LINE reverse ( arr , 0 , start ) ; NEW_LINE reverse ( arr , start , n ) ; NEW_LINE reverse ( arr ) ; NEW_LINE DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT def reverse ( arr , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE restoreSortedArray ( arr , n ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT"}
{"text": "Putaran kiri dan putaran kanan rentetan | Di tempat berputar ke kiri oleh D; Di - tempat berputar ke kanan oleh D; Kod pemacu", "code": "def leftrotate ( s , d ) : NEW_LINE INDENT tmp = s [ d : ] + s [ 0 : d ] NEW_LINE return tmp NEW_LINE DEDENT def rightrotate ( s , d ) : NEW_LINE INDENT return leftrotate ( s , len ( s ) - d ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" GeeksforGeeks \" NEW_LINE print ( leftrotate ( str1 , 2 ) ) NEW_LINE str2 = \" GeeksforGeeks \" NEW_LINE print ( rightrotate ( str2 , 2 ) ) NEW_LINE DEDENT"}
{"text": "Cari elemen dalam Senarai Berkaitan Pekeliling Ganda | Program Python3 untuk menggambarkan memasukkan nod dalam senarai dikaitkan dua kali ganda dalam mengemis, akhir dan tengah; Struktur nod; Berfungsi untuk memasukkan nod pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir; Buat nod secara dinamik; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Berfungsi untuk memaparkan senarai dikaitkan dua kali ganda; Berfungsi untuk mencari elemen tertentu dari senarai; Mengisytiharkan pemboleh ubah temp; Mengisytiharkan pemboleh ubah kawalan lain untuk mencari; Jika permulaan tidak ada pulangan - 1; Gerakkan penunjuk temp sehingga, temp. Seterusnya tidak memindahkan alamat permulaan (fesyen bulat); Kiraan kenaikan lokasi; Jika didapati menaikkan bendera dan memecahkan gelung; Penunjuk suhu kenaikan; Semak sama ada elemen terakhir dalam kandungan senarai nilai jika mengandungi, menaikkan bendera dan kiraan kenaikan; Jika bendera adalah benar, maka unsur dijumpai, lain tidak; Kod pemacu; Mulakan dengan senarai kosong; Masukkan 4. Jadi senarai yang dipautkan menjadi 4. Tiada; Masukkan 5. Jadi senarai yang dipautkan menjadi 4.5; Masukkan 7. Jadi senarai yang dipautkan menjadi 4.5. 7; Masukkan 8. Jadi senarai yang dipautkan menjadi 4.5. 7.8; Masukkan 6. Jadi senarai yang dipautkan menjadi 4.5. 7.8. 6", "code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def insertNode ( start , value ) : NEW_LINE INDENT if ( start == None ) : NEW_LINE INDENT new_node = Node ( value ) NEW_LINE new_node . data = value NEW_LINE new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE start = new_node NEW_LINE return new_node NEW_LINE DEDENT last = start . prev NEW_LINE new_node = Node ( value ) NEW_LINE new_node . data = value NEW_LINE new_node . next = start NEW_LINE ( start ) . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return start NEW_LINE DEDENT def displayList ( start ) : NEW_LINE INDENT temp = start NEW_LINE while ( temp . next != start ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT def searchList ( start , search ) : NEW_LINE INDENT temp = start NEW_LINE count = 0 NEW_LINE flag = 0 NEW_LINE value = 0 NEW_LINE if ( temp == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp . next != start ) : NEW_LINE INDENT count = count + 1 NEW_LINE if ( temp . data == search ) : NEW_LINE INDENT flag = 1 NEW_LINE count = count - 1 NEW_LINE break NEW_LINE DEDENT temp = temp . next NEW_LINE DEDENT if ( temp . data == search ) : NEW_LINE INDENT count = count + 1 NEW_LINE flag = 1 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( search , \" found ▁ at ▁ location ▁ \" , count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( search , \" ▁ not ▁ found \" ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT start = None NEW_LINE start = insertNode ( start , 4 ) NEW_LINE start = insertNode ( start , 5 ) NEW_LINE start = insertNode ( start , 7 ) NEW_LINE start = insertNode ( start , 8 ) NEW_LINE start = insertNode ( start , 6 ) NEW_LINE print ( \" Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ \" , end = \" \" ) NEW_LINE displayList ( start ) NEW_LINE searchList ( start , 5 ) NEW_LINE DEDENT"}
{"text": "Membalikkan senarai dikaitkan bulat berganda | Pelaksanaan Python3 untuk mengulangi senarai dikaitkan bulat dua kali ganda; struktur nod senarai yang dipautkan; berfungsi untuk membuat dan mengembalikan nod baru; Berfungsi untuk memasukkan pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Fungsi uitlity untuk mengulangi senarai dikaitkan bulat dua kali ganda; Memulakan penunjuk kepala baru; get pointer to the the last node ; Tetapkan 'curr' ke nod terakhir; senarai melintasi arah ke belakang; Masukkan 'curr' pada akhir senarai bermula dengan penunjuk 'baru _ kepala'; penunjuk kepala senarai terbalik; berfungsi untuk memaparkan senarai bulat berganda dalam arah ke hadapan dan ke belakang; Kod pemacu", "code": "import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT def insertEnd ( head , new_node ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT last = head . prev NEW_LINE new_node . next = head NEW_LINE head . prev = new_node NEW_LINE new_node . prev = last NEW_LINE last . next = new_node NEW_LINE return head NEW_LINE DEDENT def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT new_head = None NEW_LINE last = head . prev NEW_LINE curr = last NEW_LINE while ( curr . prev != last ) : NEW_LINE INDENT prev = curr . prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE DEDENT new_head = insertEnd ( new_head , curr ) NEW_LINE return new_head NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( \" Forward ▁ direction : ▁ \" , end = \" \" ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( \" Backward ▁ direction : ▁ \" , end = \" \" ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = \" ▁ \" ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print ( \" Current ▁ list : \" ) NEW_LINE display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print ( \" Reversed list : \" ) NEW_LINE display ( head ) NEW_LINE DEDENT"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Pelaksanaan Python3 untuk mencari LCA di dalam pokok; Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; menandakan ibu bapa untuk setiap nod; menandakan kedalaman untuk setiap nod; propogating menandakan pokok itu; nod dummy; precomment 1) kedalaman. 2) ibu bapa. untuk setiap nod; Kerumitan masa: O (ketinggian pokok) secara rekursif melompat satu nod di atas sehingga kedua -dua nod menjadi sama; Kod pemacu; Menambah tepi ke pokok", "code": "MAXN = 1001 NEW_LINE depth = [ 0 for i in range ( MAXN ) ] ; NEW_LINE parent = [ 0 for i in range ( MAXN ) ] ; NEW_LINE adj = [ [ ] for i in range ( MAXN ) ] NEW_LINE def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) ; NEW_LINE adj [ v ] . append ( u ) ; NEW_LINE DEDENT def dfs ( cur , prev ) : NEW_LINE INDENT parent [ cur ] = prev ; NEW_LINE depth [ cur ] = depth [ prev ] + 1 ; NEW_LINE for i in range ( len ( adj [ cur ] ) ) : NEW_LINE INDENT if ( adj [ cur ] [ i ] != prev ) : NEW_LINE INDENT dfs ( adj [ cur ] [ i ] , cur ) ; NEW_LINE DEDENT DEDENT DEDENT def preprocess ( ) : NEW_LINE INDENT depth [ 0 ] = - 1 ; NEW_LINE dfs ( 1 , 0 ) ; NEW_LINE DEDENT def LCANaive ( u , v ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT return u ; NEW_LINE DEDENT if ( depth [ u ] > depth [ v ] ) : NEW_LINE INDENT u , v = v , u NEW_LINE DEDENT v = parent [ v ] ; NEW_LINE return LCANaive ( u , v ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT addEdge ( 1 , 2 ) ; NEW_LINE addEdge ( 1 , 3 ) ; NEW_LINE addEdge ( 1 , 4 ) ; NEW_LINE addEdge ( 2 , 5 ) ; NEW_LINE addEdge ( 2 , 6 ) ; NEW_LINE addEdge ( 3 , 7 ) ; NEW_LINE addEdge ( 4 , 8 ) ; NEW_LINE addEdge ( 4 , 9 ) ; NEW_LINE addEdge ( 9 , 10 ) ; NEW_LINE addEdge ( 9 , 11 ) ; NEW_LINE addEdge ( 7 , 12 ) ; NEW_LINE addEdge ( 7 , 13 ) ; NEW_LINE preprocess ( ) ; NEW_LINE print ( ' LCA ( 11,8 ) ▁ : ▁ ' + str ( LCANaive ( 11 , 8 ) ) ) NEW_LINE print ( ' LCA ( 3,13 ) ▁ : ▁ ' + str ( LCANaive ( 3 , 13 ) ) ) NEW_LINE DEDENT"}
{"text": "Bilangan ujian yang dijangkakan untuk mendapatkan kepala berturut -turut n | Kod pemacu; Formula untuk bilangan laluan untuk kepala berturut -turut n", "code": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( pow ( 2 , N + 1 ) - 2 ) NEW_LINE DEDENT"}
{"text": "Cari dan kirakan jumlah faktor Co | Berfungsi untuk mengembalikan kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n] dalam masa yang berterusan; Kirakan kiraan nombor yang boleh dibahagikan dengan A dalam julat [1, n]; Kirakan kiraan nombor yang boleh dibahagi dengan b dalam julat [1, n]; Menambah tuduhan yang boleh dibahagikan oleh A dan B; Nilai di atas mungkin mengandungi nilai berulang yang boleh dibahagikan oleh kedua -dua A dan B. Oleh itu, kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B ditemui; Kiraan yang dikira di atas dikurangkan untuk mengira kiraan akhir; Berfungsi untuk mengembalikan jumlah nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n]; Tetapkan untuk menyimpan nombor supaya nombor tidak diulang; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk melangkah melalui set dan cari jumlahnya; Kod pemacu", "code": "def countOfNum ( n , a , b ) : NEW_LINE INDENT cnt_of_a , cnt_of_b , cnt_of_ab , sum = 0 , 0 , 0 , 0 NEW_LINE cnt_of_a = n // a NEW_LINE cnt_of_b = n // b NEW_LINE sum = cnt_of_b + cnt_of_a NEW_LINE cnt_of_ab = n // ( a * b ) NEW_LINE sum = sum - cnt_of_ab NEW_LINE return sum NEW_LINE DEDENT def sumOfNum ( n , a , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE ans = dict ( ) NEW_LINE for i in range ( a , n + 1 , a ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT for i in range ( b , n + 1 , b ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT for it in ans : NEW_LINE INDENT sum = sum + it NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 88 NEW_LINE A = 11 NEW_LINE B = 8 NEW_LINE count = countOfNum ( N , A , B ) NEW_LINE sumofnum = sumOfNum ( N , A , B ) NEW_LINE print ( sumofnum % count ) NEW_LINE DEDENT"}
{"text": "Cari nilai julat ungkapan | Berfungsi untuk mengembalikan nilai ungkapan yang diberikan; Nilai istilah pertama; Nilai istilah terakhir; Kod pemacu; Dapatkan hasilnya", "code": "def get ( L , R ) : NEW_LINE INDENT x = 1.0 / L ; NEW_LINE y = 1.0 / ( R + 1.0 ) ; NEW_LINE return ( x - y ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 6 ; R = 12 ; NEW_LINE ans = get ( L , R ) ; NEW_LINE print ( round ( ans , 2 ) ) ; NEW_LINE DEDENT"}
{"text": "Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 dalam perwakilan binari itu | Pelaksanaan Python3 pendekatan; Untuk menyimpan bilangan bulat pra -dikira; Fungsi yang mengembalikan benar jika perwakilan binari x mengandungi 1 s; Untuk menyimpan sedikit sebelumnya; Semak sama ada bit sebelumnya dan bit semasa adalah kedua -dua 1; Mengemas kini sedikit sebelumnya; Pergi ke bit seterusnya; Fungsi untuk pra - mengira nombor yang sah dari 0 hingga maksimum; Simpan semua nombor yang tidak mempunyai 1 s berturut -turut; Berfungsi untuk mengembalikan nombor minimum yang lebih besar daripada n yang tidak mengandungi 1 s berturut -turut; Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 s; Berfungsi untuk melakukan pertanyaan; Kod pemacu; Pra - mengira nombor; Lakukan pertanyaan", "code": "from bisect import bisect_right as upper_bound NEW_LINE MAX = 100000 NEW_LINE v = [ ] NEW_LINE def consecutiveOnes ( x ) : NEW_LINE INDENT p = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 1 and p == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = x % 2 NEW_LINE x //= 2 NEW_LINE DEDENT return False NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT if ( consecutiveOnes ( i ) == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT DEDENT def nextValid ( n ) : NEW_LINE INDENT it = upper_bound ( v , n ) NEW_LINE val = v [ it ] NEW_LINE return val NEW_LINE DEDENT def performQueries ( queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( nextValid ( queries [ i ] ) ) NEW_LINE DEDENT DEDENT queries = [ 4 , 6 ] NEW_LINE q = len ( queries ) NEW_LINE preCompute ( ) NEW_LINE performQueries ( queries , q ) NEW_LINE"}
{"text": "Operasi minimum yang diperlukan untuk menukar rentetan binari yang diberikan kepada semua 1 s | Berfungsi untuk mengembalikan bilangan operasi yang diperlukan; CTR akan menyimpan bilangan yang berturut -turut pada akhir rentetan binari yang diberikan; Gelung untuk mencari bilangan 1 s pada akhir rentetan; Jika watak semasa adalah 1; Jika kita menghadapi 0 pertama dari kedudukan LSB maka kita akan memecahkan gelung; Bilangan operasi yang diperlukan ialah (L - CTR); Berfungsi untuk mengeluarkan sifar utama dari rentetan; Gelung sehingga S [i] menjadi tidak sama dengan 1; Jika kita sampai ke hujung rentetan, ini bermakna rentetan hanya mengandungi 0 's; Kembalikan rentetan tanpa nol utama; Kod pemacu; Mengeluarkan sifar terkemuka", "code": "def changeToOnes ( string ) : NEW_LINE INDENT ctr = 0 ; NEW_LINE l = len ( string ) ; NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( string [ i ] == '1' ) : NEW_LINE INDENT ctr += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return l - ctr ; NEW_LINE DEDENT def removeZeroesFromFront ( string ) : NEW_LINE INDENT s = \" \" ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( string ) and string [ i ] == '0' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( i == len ( string ) ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE DEDENT else : NEW_LINE INDENT s = string [ i : len ( string ) - i ] ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"10010111\" ; NEW_LINE string = removeZeroesFromFront ( string ) ; NEW_LINE print ( changeToOnes ( string ) ) ; NEW_LINE DEDENT"}
{"text": "Penghapusan minimum diperlukan sedemikian rupa sehingga mana -mana nombor x akan berlaku tepat x kali | Berfungsi untuk mengembalikan penghapusan minimum yang diperlukan; Untuk menyimpan kekerapan elemen array; Kekerapan kedai setiap elemen; Untuk menyimpan penghapusan minimum yang diperlukan; Nilai; Kekerapan itu; Jika bilangan kurang daripada atau sama dengan kekerapannya; Padam kejadian tambahan; Padam setiap kejadian x; Kod pemacu", "code": "def MinDeletion ( a , n ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for key , value in map . items ( ) : NEW_LINE INDENT x = key ; NEW_LINE frequency = value ; NEW_LINE if ( x <= frequency ) : NEW_LINE INDENT ans += ( frequency - x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinDeletion ( a , n ) ) ; NEW_LINE DEDENT"}
{"text": "Rentetan concatenate dalam apa -apa perintah untuk mendapatkan bilangan maksimum \"ab\" | Berfungsi untuk mencari bilangan maksimum abs; Pembolehubah A, B, AB untuk mengira rentetan yang berakhir dengan 'A' tetapi tidak berakhir dengan 'B', 'B' tetapi tidak berakhir dengan 'A' dan 'B' dan berakhir dengan 'A' masing -masing. ; 'Ab' sudah ada dalam rentetan sebelum menggabungkan mereka; Count rentetan yang bermula dengan 'B' dan berakhir dengan 'A; Count rentetan yang bermula dengan 'B' tetapi tidak berakhir dengan 'A; Count rentetan yang berakhir dengan 'a' tetapi tidak berakhir dengan 'b; Mengemas kini nilai ANS dan menambah kiraan tambahan 'AB; Kod pemacu", "code": "def maxCountAB ( s , n ) : NEW_LINE INDENT A = 0 NEW_LINE B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE INDENT if ( S [ j ] == ' A ' and S [ j + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( S [ 0 ] == ' B ' and S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT DEDENT DEDENT ' NEW_LINE INDENT elif ( S [ 0 ] == ' B ' ) : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT elif ( S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( BA == 0 ) : NEW_LINE INDENT ans += min ( B , A ) NEW_LINE DEDENT elif ( A + B == 0 ) : NEW_LINE INDENT ans += BA - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += BA + min ( B , A ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ \" ABCA \" , \" BOOK \" , \" BAND \" ] NEW_LINE n = len ( s ) NEW_LINE print ( maxCountAB ( s , n ) ) NEW_LINE DEDENT"}
{"text": "Operasi minimum untuk membuat jumlah elemen jiran <= x | Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan jumlah operasi yang diperlukan; Mula -mula membuat semua elemen sama dengan x yang lebih besar; Kiri mengimbas array; Kemas kini elemen semasa supaya jumlah jiran adalah <x; Kod pemacu", "code": "def MinOperations ( n , x , arr ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > x ) : NEW_LINE INDENT difference = arr [ i ] - x NEW_LINE total = total + difference NEW_LINE arr [ i ] = x NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] NEW_LINE if ( LeftNeigbouringSum > x ) : NEW_LINE INDENT current_diff = LeftNeigbouringSum - x NEW_LINE arr [ i ] = max ( 0 , arr [ i ] - current_diff ) NEW_LINE total = total + current_diff NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT X = 1 NEW_LINE arr = [ 1 , 6 , 1 , 2 , 0 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( MinOperations ( N , X , arr ) ) NEW_LINE"}
{"text": "Cari nombor berulang dan nombor yang hilang menggunakan dua persamaan | Pelaksanaan Python3 pendekatan; Berfungsi untuk mencetak nombor yang diperlukan; Jumlah nombor semulajadi n pertama; Jumlah kuadrat nombor semulajadi n pertama; Untuk menyimpan jumlah dan jumlah kuadrat unsur -unsur array; Kod pemacu", "code": "import math NEW_LINE def findNumbers ( arr , n ) : NEW_LINE INDENT sumN = ( n * ( n + 1 ) ) / 2 ; NEW_LINE sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE sum = 0 ; NEW_LINE sumSq = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE sumSq = sumSq + ( math . pow ( arr [ i ] , 2 ) ) ; NEW_LINE DEDENT B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; NEW_LINE A = sum - sumN + B ; NEW_LINE print ( \" A ▁ = ▁ \" , int ( A ) ) ; NEW_LINE print ( \" B ▁ = ▁ \" , int ( B ) ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNumbers ( arr , n ) ; NEW_LINE"}
{"text": "Rentetan terkecil lexicographically dengan rentetan yang diberikan sebagai awalan | Berfungsi untuk mencari sama ada temp rentetan bermula dengan STR atau tidak; Kes asas; Semak aksara yang sepadan dalam temp & str; Berfungsi untuk mencari rentetan terkecil lexicographic yang terdiri daripada string str as awalan; Susun rentetan array yang diberikan []; Jika rentetan i - th mengandungi rentetan yang diberikan sebagai awalan, maka cetak hasilnya; Jika tiada rentetan wujud maka kembali \" - 1\"; Kod pemacu", "code": "def is_prefix ( temp , str ) : NEW_LINE INDENT if ( len ( temp ) < len ( str ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != temp [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT DEDENT def lexicographicallyString ( input , n , str ) : NEW_LINE INDENT input . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = input [ i ] NEW_LINE if ( is_prefix ( temp , str ) ) : NEW_LINE INDENT return temp NEW_LINE DEDENT DEDENT return \" - 1\" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" ] NEW_LINE S = \" app \" NEW_LINE N = 5 NEW_LINE print ( lexicographicallyString ( arr , N , S ) ) NEW_LINE DEDENT"}
{"text": "Susun semula Arahan untuk mencari K menggunakan algoritma carian binari tanpa menyusun | Berfungsi untuk menyusun semula array; Menyimpan array yang disusun semula; Kedai sama ada pengaturan itu mungkin atau tidak; Kemas kini k dengan kedudukan k; Menyimpan semua elemen yang lebih rendah daripada dan lebih besar daripada vektor yang lebih kecil dan lebih besar masing -masing; Melintasi array arr []; Jika arr [i] kurang daripada arr [k]; Lain; Iterat Unil Low kurang daripada atau sama dengan tinggi; Kedai pertengahan titik; Jika pertengahan adalah sama dengan k; Jika pertengahan kurang daripada k; Jika pertengahan lebih besar daripada k; Jika f adalah - 1; Melangkah dalam julat [1, n]; Jika Ans [i] sama dengan - 1; Cetak array yang disusun semula; Kod pemacu; Input; Panggilan fungsi", "code": "def Rearrange ( arr , K , N ) : NEW_LINE INDENT ans = [ 0 ] * ( N + 1 ) NEW_LINE f = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans [ i ] = - 1 NEW_LINE DEDENT K = arr . index ( K ) NEW_LINE smaller = [ ] NEW_LINE greater = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < arr [ K ] ) : NEW_LINE INDENT smaller . append ( arr [ i ] ) NEW_LINE DEDENT elif ( arr [ i ] > arr [ K ] ) : NEW_LINE INDENT greater . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT low = 0 NEW_LINE high = N - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid == K ) : NEW_LINE INDENT ans [ mid ] = arr [ K ] NEW_LINE f = 1 NEW_LINE break NEW_LINE DEDENT elif ( mid < K ) : NEW_LINE INDENT if ( len ( smaller ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans [ mid ] = smaller [ - 1 ] NEW_LINE smaller . pop ( ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( greater ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans [ mid ] = greater [ - 1 ] NEW_LINE greater . pop ( ) NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT if ( f == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ans [ i ] == - 1 ) : NEW_LINE INDENT if ( len ( smaller ) ) : NEW_LINE INDENT ans [ i ] = smaller [ - 1 ] NEW_LINE smaller . pop ( ) NEW_LINE DEDENT elif ( len ( greater ) ) : NEW_LINE INDENT ans [ i ] = greater [ - 1 ] NEW_LINE greater . pop ( ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 7 , 2 , 5 , 3 , 8 ] NEW_LINE K = 7 NEW_LINE N = len ( arr ) NEW_LINE Rearrange ( arr , K , N ) NEW_LINE DEDENT"}
{"text": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Program Python 3 untuk pendekatan di atas; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; ITERATE K dari [1, n]; Jumlah gula -gula; Gula -gula yang diambil oleh orang 1; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array arr []; Jumlah yang digunakan oleh orang j; Mengemas kini bilangan gula -gula; Bahagian yang baik dari gula -gula yang dicapai; Kod pemacu", "code": "import math NEW_LINE def minimumK ( arr , M , N ) : NEW_LINE INDENT good = math . ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT K = i NEW_LINE candies = N NEW_LINE taken = 0 NEW_LINE while ( candies > 0 ) : NEW_LINE INDENT taken += min ( K , candies ) NEW_LINE candies -= min ( K , candies ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT consume = ( arr [ j ] * candies ) / 100 NEW_LINE candies -= consume NEW_LINE DEDENT DEDENT if ( taken >= good ) : NEW_LINE print ( i ) NEW_LINE return NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 13 NEW_LINE M = 1 NEW_LINE arr = [ 50 ] NEW_LINE minimumK ( arr , M , N ) NEW_LINE DEDENT"}
{"text": "Jumlah masa yang diperlukan untuk mengembara jalan yang dilambangkan oleh rentetan yang diberikan | Fungsi untuk mengira masa yang diambil untuk perjalanan jalan; Kedai jumlah masa; Kedudukan awal; Kedai -kedai melawat segmen; Semak sama ada segmen hadir dalam set; Meningkatkan nilai masa dengan 2; Masukkan segmen ke dalam set; Cetak nilai masa; Kod pemacu", "code": "def calcTotalTime ( path ) : NEW_LINE INDENT time = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE s = set ( [ ] ) NEW_LINE for i in range ( len ( path ) ) : NEW_LINE INDENT p = x NEW_LINE q = y NEW_LINE if ( path [ i ] == ' N ' ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif ( path [ i ] == ' S ' ) : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif ( path [ i ] == ' E ' ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif ( path [ i ] == ' W ' ) : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT if ( p + x , q + y ) not in s : NEW_LINE INDENT time += 2 NEW_LINE s . add ( ( p + x , q + y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT time += 1 NEW_LINE DEDENT DEDENT print ( time ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT path = \" NSE \" NEW_LINE calcTotalTime ( path ) NEW_LINE DEDENT"}
{"text": "Kos yang diperlukan untuk menjadikan semua elemen array sama dengan 1 | Fungsi untuk mengira kos yang diperlukan untuk membuat semua elemen array sama dengan 1; Menyimpan jumlah kos; Melintasi array arr []; Jika elemen semasa ialah 0; Tukar 0 hingga 1; Tambah kos; Mengembalikan jumlah kos; Kod pemacu", "code": "def findCost ( A , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE totalCost += i NEW_LINE DEDENT DEDENT return totalCost NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findCost ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Cari indeks puncak array yang diberikan | Fungsi untuk mencari indeks puncak untuk array yang diberikan; Kes asas; Semak array yang semakin meningkat; Sekiranya keadaan yang semakin meningkat dilanggar, maka pecah; Menyimpan nilai i, yang merupakan indeks puncak yang berpotensi; Traversal kedua, untuk array yang ketat; Apabila keadaan ketat yang dikurangkan dilanggar, kemudian pecah; Jika i = n - 1, ini bermakna bahawa ANS adalah indeks puncak; Jika tidak, indeks puncak tidak wujud; Kod pemacu", "code": "def peakIndex ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( len ( arr ) < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 0 NEW_LINE while ( i + 1 < N ) : NEW_LINE INDENT if ( arr [ i + 1 ] < arr [ i ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i == 0 or i == N - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = i NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i == N - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 1 , 0 ] NEW_LINE print ( peakIndex ( arr ) ) NEW_LINE DEDENT"}
{"text": "Memandangkan array A [] dan nombor x, periksa pasangan dalam [] dengan jumlah sebagai x | Tetapkan 2 | Fungsi untuk memeriksa sama ada array mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan; Menyusun array dalam peningkatan urutan; Melintasi array, nums []; Simpan nombor yang diperlukan untuk dijumpai; Melakukan carian binari; Simpan nilai pertengahan; Jika nums [mid] lebih besar daripada x, maka kemas kini tinggi hingga pertengahan - 1; Jika Nums [Mid] kurang daripada X, maka kemas kini rendah hingga pertengahan + 1; Jika tidak; Jika pertengahan adalah sama i, periksa pertengahan - 1 dan pertengahan + 1; Jika tidak, pasangan dan kembali; Jika tidak ada pasangan yang dijumpai, maka pr - 1; Kod pemacu; Panggilan fungsi", "code": "def hasArrayTwoPairs ( nums , n , target ) : NEW_LINE INDENT nums = sorted ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = target - nums [ i ] NEW_LINE low , high = 0 , n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( ( high - low ) // 2 ) NEW_LINE if ( nums [ mid ] > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT elif ( nums [ mid ] < x ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( mid == i ) : NEW_LINE INDENT if ( ( mid - 1 >= 0 ) and nums [ mid - 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = \" , ▁ \" ) NEW_LINE print ( nums [ mid - 1 ] ) NEW_LINE return NEW_LINE DEDENT if ( ( mid + 1 < n ) and nums [ mid + 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = \" , ▁ \" ) NEW_LINE print ( nums [ mid + 1 ] ) NEW_LINE return NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT print ( nums [ i ] , end = \" , ▁ \" ) NEW_LINE print ( nums [ mid ] ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , - 1 , 2 , - 3 , 1 ] NEW_LINE X = - 2 NEW_LINE N = len ( A ) NEW_LINE hasArrayTwoPairs ( A , N , X ) NEW_LINE DEDENT"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari pembahagi n paling dekat dengan sasaran; Berulang sehingga akar persegi n; Semak jika pembahagi adalah sama; Semak jika saya adalah yang paling dekat; Semak jika saya adalah yang paling dekat; Semak jika N / I adalah yang paling dekat; Nilai terdekat; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "from math import sqrt , floor , ceil NEW_LINE def findClosest ( N , target ) : NEW_LINE INDENT closest = - 1 NEW_LINE diff = 10 ** 18 NEW_LINE for i in range ( 1 , ceil ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( N // i == i ) : NEW_LINE INDENT if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT if ( abs ( target - N // i ) < diff ) : NEW_LINE INDENT diff = abs ( target - N // i ) NEW_LINE closest = N // i NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( closest ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , X = 16 , 5 NEW_LINE findClosest ( N , X ) NEW_LINE DEDENT"}
{"text": "Cari pasangan (a, b) seperti AA + BB = n | Fungsi untuk mengira kuasa minimum a dan b lebih besar daripada n; Menyimpan kuasa A yang lebih besar daripada n; Kiraan kenaikan sebanyak 1; Bahagikan n oleh A; Fungsi untuk mencari pasangan (a, b) sedemikian rupa sehingga a ^ a + b ^ b = n; Kirakan kuasa minimum yang lebih besar daripada n; Kirakan kuasa minimum B lebih besar daripada N; Buat salinan A dan B; Melintasi setiap pasangan (i, j); Semak jika B ^ j + a ^ i = n untuk mengatasi masalah limpahan Gunakan b = n - a bukan b + a = n; Kuasa kenaikan B oleh 1; Kuasa kenaikan A sebanyak 1; Akhirnya PR - 1 jika tiada pasangan dijumpai; Kod pemacu; Diberikan A, B dan N; Panggilan fungsi", "code": "def power ( A , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( A == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( N > 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE N //= A ; NEW_LINE DEDENT return int ( count ) ; NEW_LINE DEDENT def Pairs ( N , A , B ) : NEW_LINE INDENT powerA , powerB = 0 , 0 ; NEW_LINE powerA = power ( A , N ) ; NEW_LINE powerB = power ( B , N ) ; NEW_LINE intialB = B ; NEW_LINE intialA = A ; NEW_LINE A = 1 ; NEW_LINE for i in range ( powerA + 1 ) : NEW_LINE INDENT B = 1 ; NEW_LINE for j in range ( powerB + 1 ) : NEW_LINE INDENT if ( B == N - A ) : NEW_LINE INDENT print ( i , \" ▁ \" , j ) ; NEW_LINE return ; NEW_LINE DEDENT B *= intialB ; NEW_LINE DEDENT A *= intialA ; NEW_LINE DEDENT print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 106 ; NEW_LINE A = 3 ; NEW_LINE B = 5 ; NEW_LINE Pairs ( N , A , B ) ; NEW_LINE DEDENT"}
{"text": "Mengira nombor dari julat tertentu yang tidak dapat dibahagikan oleh mana -mana elemen array | Berfungsi untuk mencari gandaan bukan sehingga k; Menyimpan semua gandaan yang unik; Melelehkan array; Untuk mencari pendua sekali sahaja; Memasukkan semua gandaan ke dalam set; Kembali hanya kiraan nombor yang tidak dapat dibahagikan oleh mana -mana elemen array; Berfungsi untuk mengira jumlah nilai dalam julat [l, r]; Mengira semua nilai dalam julat menggunakan prinsip pengecualian; Kod pemacu; Panggilan fungsi", "code": "def findNonMultiples ( arr , n , k ) : NEW_LINE INDENT multiples = set ( [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in multiples ) : NEW_LINE INDENT for j in range ( 1 , k // arr [ i ] + 1 ) : NEW_LINE INDENT multiples . add ( arr [ i ] * j ) NEW_LINE DEDENT DEDENT DEDENT return k - len ( multiples ) NEW_LINE DEDENT def countValues ( arr , N , L , R ) : NEW_LINE INDENT return ( findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE L = 1 NEW_LINE R = 20 NEW_LINE print ( countValues ( arr , N , L , R ) ) NEW_LINE DEDENT"}
{"text": "Bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir di paling banyak jam | | Berfungsi untuk mencari bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir dalam jam H; Menyimpan syiling minimum untuk dikeluarkan setiap jam; Cari elemen array maksimum; Melakukan carian binari; Simpan nilai pertengahan julat dalam k; Cari jumlah masa yang diambil untuk mengosongkan n buasir dengan mengeluarkan sy syiling sejam; Jika jumlah masa tidak melebihi h; Jika tidak; Hasil yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "def minCollectingSpeed ( piles , H ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = 1 NEW_LINE high = max ( piles ) NEW_LINE while ( low <= high ) : NEW_LINE INDENT K = low + ( high - low ) // 2 NEW_LINE time = 0 NEW_LINE for ai in piles : NEW_LINE time += ( ai + K - 1 ) // K NEW_LINE if ( time <= H ) : NEW_LINE INDENT ans = K NEW_LINE high = K - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = K + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 7 , 11 ] NEW_LINE H = 8 NEW_LINE minCollectingSpeed ( arr , H ) NEW_LINE DEDENT"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Susun array; Kedai indeks penunjuk kiri; Kedai indeks penunjuk yang betul; Hitung kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Jika jumlah pasangan semasa adalah sama dengan k; Keluarkan elemen array duplikat berturut -turut; Kemas kini i; Keluarkan elemen array duplikat berturut -turut; Kemas kini j; Kemas kini CNTPairs; Kemas kini i; Kemas kini j; Jika jumlah pasangan semasa kurang daripada k; Kemas kini i; Kemas kini j; Kod pemacu", "code": "def cntDisPairs ( arr , N , K ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == K ) : NEW_LINE INDENT while ( i < j and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i < j and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT cntPairs += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] < K ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 5 , 7 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( cntDisPairs ( arr , N , K ) ) NEW_LINE DEDENT"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Kekerapan kedai setiap elemen yang berbeza dari array; Kemas kini kekerapan ARR [i]; Melintasi peta; Menyimpan nilai utama peta; Jika saya adalah separuh daripada k; Jika kekerapan saya lebih besar daripada 1; Kemas kini CNTPairs; Kemas kini CNTPairs; Kod pemacu", "code": "def cntDisPairs ( arr , N , K ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE cntFre = { } NEW_LINE for i in arr : NEW_LINE INDENT if i in cntFre : NEW_LINE INDENT cntFre [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntFre [ i ] = 1 NEW_LINE DEDENT DEDENT for key , value in cntFre . items ( ) : NEW_LINE INDENT i = key NEW_LINE if ( 2 * i == K ) : NEW_LINE INDENT if ( cntFre [ i ] > 1 ) : NEW_LINE INDENT cntPairs += 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( cntFre [ K - i ] ) : NEW_LINE INDENT cntPairs += 1 NEW_LINE DEDENT DEDENT DEDENT cntPairs = cntPairs / 2 NEW_LINE return cntPairs NEW_LINE DEDENT arr = [ 5 , 6 , 5 , 7 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( int ( cntDisPairs ( arr , N , K ) ) ) NEW_LINE"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Berfungsi untuk mencari panjang seterusnya yang paling lama supaya tidak ada dua elemen bersebelahan yang sama; Gantikan elemen pada indeks x dengan y; Oleh kerana x adalah 1 - diindeks, penurunan x oleh 1; Jejaki bilangan elemen dalam masa depan; Jika elemen sebelumnya tidak sama dengan elemen semasa; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT for i in range ( Q ) : NEW_LINE INDENT x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE arr [ x - 1 ] = y NEW_LINE count = 1 NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ j ] != arr [ j - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Q = 2 NEW_LINE Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE longestSubsequence ( N , Q , arr , Queries ) NEW_LINE DEDENT"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program Python3 untuk pendekatan di atas; Melintasi array arr []; Jika elemen sebelumnya tidak sama dengan elemen semasa; Melintasi pertanyaan; Gantikan elemen pada indeks x dengan y; Mengira semula untuk Indeks X; Tolak sumbangan elemen pada indeks x; Tambah sumbangan y; Mengira semula untuk indeks x + 1; Tolak sumbangan elemen pada indeks x + 1; Menambah sumbangan y; Menggantikan elemen; Kod pemacu; Panggilan fungsi", "code": "def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( Q ) : NEW_LINE INDENT x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE if ( x > 1 ) : NEW_LINE INDENT if ( arr [ x - 1 ] != arr [ x - 2 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( arr [ x - 2 ] != y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( x < N ) : NEW_LINE INDENT if ( arr [ x ] != arr [ x - 1 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( y != arr [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = ' ▁ ' ) NEW_LINE arr [ x - 1 ] = y NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Q = 2 NEW_LINE Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE longestSubsequence ( N , Q , arr , Queries ) NEW_LINE DEDENT"}
{"text": "Jumlah perbezaan mutlak indeks kejadian setiap elemen array | Program Python3 untuk pendekatan di atas; Fungsi untuk mencari jumlah perbezaan indeks kejadian setiap elemen array yang unik; Menyimpan indeks setiap elemen array; Simpan indeks; Menyimpan jumlahnya; Melintasi array; Cari jumlah untuk setiap elemen; Melangkah ke atas peta; Hitung jumlah kejadian ARR [i]; Simpan jumlah untuk elemen semasa; Cetak jawapan untuk setiap elemen; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "from collections import defaultdict NEW_LINE def sum_i ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : [ ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] . append ( i ) NEW_LINE DEDENT ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for it in mp [ arr [ i ] ] : NEW_LINE INDENT sum += abs ( it - i ) NEW_LINE ans [ i ] = sum NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 1 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE sum_i ( arr , n ) NEW_LINE DEDENT"}
{"text": "Tukar vokal ke dalam watak kes atas dalam rentetan yang diberikan | Berfungsi untuk menukar vokal menjadi huruf besar; Menyimpan panjang str; Kod pemacu", "code": "def conVowUpp ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE str1 = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT c = ( str [ i ] ) . upper ( ) NEW_LINE str1 += c NEW_LINE DEDENT else : NEW_LINE INDENT str1 += str [ i ] NEW_LINE DEDENT DEDENT print ( str1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" eutopia \" NEW_LINE conVowUpp ( str ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan bilangan hari yang mana c coklat boleh diedarkan secara berturut -turut kepada orang -orang n | Menyimpan kekerapan setiap jenis coklat; Fungsi untuk memeriksa sama ada coklat boleh dimakan untuk 'pertengahan' tidak. hari; Jika CNT melebihi n, kembali benar; Berfungsi untuk mencari bilangan maksimum hari yang mana coklat boleh dimakan; Simpan kekerapan setiap jenis coklat; Memulakan permulaan dan berakhir dengan 0 dan P masing -masing; Hitung pertengahan; Semak jika coklat boleh diedarkan selama pertengahan hari; Semak jika coklat boleh diedarkan selama lebih dari pertengahan hari berturut -turut; Kod pemacu; Panggilan fungsi", "code": "mp = { } NEW_LINE N , P = 0 , 0 NEW_LINE def helper ( mid ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in mp : NEW_LINE INDENT temp = mp [ i ] NEW_LINE while ( temp >= mid ) : NEW_LINE INDENT temp -= mid NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT return cnt >= N NEW_LINE DEDENT def findMaximumDays ( arr ) : NEW_LINE INDENT for i in range ( P ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT start = 0 NEW_LINE end = P NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE if ( mid != 0 and helper ( mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE start = mid + 1 NEW_LINE DEDENT elif ( mid == 0 ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE P = 10 NEW_LINE arr = [ 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 ] NEW_LINE print ( findMaximumDays ( arr ) ) NEW_LINE DEDENT"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan subarray; Kedai awalan jumlah array; Kirakan Array Jumlah Awalan; Menjana semua subarray; Semak sama ada subarray ini adalah subarray yang sah atau tidak; Jumlah kiraan subarray; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "def countSubarrays ( a , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans , end = ' ▁ ' ) NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 3 , 1 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE K = 4 NEW_LINE countSubarrays ( arr , N , K ) NEW_LINE"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | Fungsi yang mengira subarray s. t. Jumlah elemen dalam subarray Modulo K adalah sama dengan saiz subarray; Menyimpan kiraan (pref [i] - i) % k; Menyimpan kiraan subarray; Kedai awalan jumlah array; Cari Array Jumlah Awalan; Keadaan asas; Keluarkan indeks pada masa ini selepas indeks k dari indeks semasa; Kemas kini jawapan untuk subarrays yang berakhir pada indeks i - th; Tambah nilai yang dikira indeks semasa untuk dikira; Cetak kiraan subarray; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "def countSubarrays ( a , n , k ) : NEW_LINE INDENT cnt = { } NEW_LINE ans = 0 NEW_LINE pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT cnt [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT remIdx = i - k NEW_LINE if ( remIdx >= 0 ) : NEW_LINE INDENT if ( ( pref [ remIdx ] - remIdx % k + k ) % k in cnt ) : NEW_LINE INDENT cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] = - 1 NEW_LINE DEDENT DEDENT if ( pref [ i ] - i % k + k ) % k in cnt : NEW_LINE INDENT ans += cnt [ ( pref [ i ] - i % k + k ) % k ] NEW_LINE DEDENT if ( pref [ i ] - i % k + k ) % k in cnt : NEW_LINE INDENT cnt [ ( pref [ i ] - i % k + k ) % k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ( pref [ i ] - i % k + k ) % k ] = 1 NEW_LINE DEDENT DEDENT print ( ans , end = ' ▁ ' ) NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 3 , 1 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE K = 4 NEW_LINE countSubarrays ( arr , N , K ) NEW_LINE"}
{"text": "Semak jika semua substring panjang k dari rentetan binari mempunyai kiraan yang sama dengan 0 s dan 1 s | Fungsi untuk memeriksa sama ada substring panjang k mempunyai sama 0 dan 1; Melintasi rentetan; Semak sama ada setiap watak k - th adalah sama atau tidak; Melintasi substring panjang k; Jika watak semasa adalah 0; Kiraan kenaikan; Jika tidak; Kiraan pengurangan; Semak sama 0 s dan 1 s; Kod pemacu", "code": "def check ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( i , n , k ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT if ( c == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = \"101010\" NEW_LINE k = 2 NEW_LINE if ( check ( s , k ) != 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Semak jika watak -watak rentetan yang diberikan boleh digunakan untuk membentuk sebarang rentetan yang sama | Program Python3 untuk pendekatan di atas; Fungsi untuk memeriksa sama ada freq dari mana -mana watak boleh dibahagikan dengan n; Menyimpan kekerapan aksara; Jika kekerapan watak tidak dapat dibahagikan dengan n; Jika tiada watak mempunyai kekerapan sekurang -kurangnya n; Kod pemacu; Panggilan fungsi", "code": "from collections import defaultdict NEW_LINE def isSame ( str , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mp [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for it in mp . keys ( ) : NEW_LINE INDENT if ( mp [ it ] >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = \" ccabcba \" NEW_LINE n = 4 NEW_LINE if ( isSame ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cari akar fungsi yang tidak berkurangan antara a dan b | Program Python3 untuk pendekatan di atas; Fungsi yang diberikan; Fungsi untuk mencari akar fungsi yang tidak berkurangan; Untuk mendapatkan jawapan minimum yang mungkin untuk akar; Cari pertengahan; Cari di [rendah, x]; Cari di [x, tinggi]; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencari akar persamaan yang diberikan dalam julat [a, b]; Jika akar tidak wujud; Lain mencari akar sehingga 4 tempat perpuluhan; Kod pemacu; Julat yang diberikan; Panggilan fungsi", "code": "import math NEW_LINE eps = 1e-6 NEW_LINE def func ( a , b , c , x ) : NEW_LINE INDENT return a * x * x + b * x + c NEW_LINE DEDENT def findRoot ( a , b , c , low , high ) : NEW_LINE INDENT x = - 1 NEW_LINE while abs ( high - low ) > eps : NEW_LINE INDENT x = ( low + high ) / 2 NEW_LINE if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) : NEW_LINE INDENT high = x NEW_LINE DEDENT else : NEW_LINE INDENT low = x NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT def solve ( a , b , c , A , B ) : NEW_LINE INDENT if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) : NEW_LINE INDENT print ( \" No ▁ solution \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" { : . 4f } \" . format ( findRoot ( a , b , c , A , B ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = - 3 NEW_LINE c = - 2 NEW_LINE A = 0 NEW_LINE B = 3 NEW_LINE solve ( a , b , c , A , B ) NEW_LINE DEDENT"}
{"text": "Median perbezaan semua pasangan dari array | Pemeriksaan fungsi jika pertengahan boleh menjadi indeks median pelbagai perbezaan; Saiz array; Jumlah mungkin tidak ada pasangan yang mungkin; Indeks elemen dalam perbezaan semua pasangan dari array; Kira bilangan pasangan yang mempunyai perbezaan <= MID; Jika perbezaan antara akhir dan elemen pertama kurang atau sama dengan pertengahan; Memeriksa unsur tidak kurang daripada atau sama dengan pertengahan adalah lebih besar daripada median atau tidak; Fungsi untuk mengira median perbezaan semua pasangan dari array; Saiz array; Memulakan yang rendah dan tinggi; Carian binari; Hitung pertengahan; Jika pertengahan boleh menjadi median array; Mengembalikan median perbezaan pasangan dari array; Kod pemacu", "code": "def possible ( mid , a ) : NEW_LINE INDENT n = len ( a ) ; NEW_LINE total = ( n * ( n - 1 ) ) // 2 ; NEW_LINE need = ( total + 1 ) // 2 ; NEW_LINE count = 0 ; NEW_LINE start = 0 ; end = 1 ; NEW_LINE while ( end < n ) : NEW_LINE INDENT if ( a [ end ] - a [ start ] <= mid ) : NEW_LINE INDENT end += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( end - start - 1 ) ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT if ( end == n and start < end and a [ end - 1 ] - a [ start ] <= mid ) : NEW_LINE INDENT t = end - start - 1 ; NEW_LINE count += ( t * ( t + 1 ) // 2 ) ; NEW_LINE DEDENT if ( count >= need ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT def findMedian ( a ) : NEW_LINE INDENT n = len ( a ) ; NEW_LINE low = 0 ; high = a [ n - 1 ] - a [ 0 ] ; NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 ; NEW_LINE if ( possible ( mid , a ) ) : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT DEDENT return high + 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 7 , 5 , 2 ] ; NEW_LINE a . sort ( ) NEW_LINE print ( findMedian ( a ) ) ; NEW_LINE DEDENT"}
{"text": "Cetak semua rentetan dari array a [] mempunyai semua rentetan dari array b [] sebagai berikutnya | Berfungsi untuk mencari rentetan dari [] mempunyai semua rentetan dalam b [] sebagai seterusnya; Hitung saiz masing -masing; Menyimpan jawapannya; Menyimpan kekerapan setiap watak dalam rentetan []; Kirakan frekuensi watak semua rentetan; Menyimpan kekerapan setiap aksara dalam rentetan b [] setiap watak rentetan dalam b []; Jika kekerapan watak dalam b [] melebihi itu dalam []; Rentetan wujud dalam B [] yang bukan subset yang betul dari [i]; Jika semua rentetan dalam b [] adalah subset yang betul dari []; Tolak rentetan dalam vektor yang dihasilkan; Jika ada rentetan yang dijumpai; Cetak rentetan itu; Jika tidak; Kod pemacu", "code": "def UniversalSubset ( A , B ) : NEW_LINE INDENT n1 = len ( A ) NEW_LINE n2 = len ( B ) NEW_LINE res = [ ] NEW_LINE A_freq = [ [ 0 for x in range ( 26 ) ] for y in range ( n1 ) ] NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT A_freq [ i ] [ ord ( A [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT B_freq = [ 0 ] * 26 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE for j in range ( len ( B [ i ] ) ) : NEW_LINE INDENT arr [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE B_freq [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] = max ( B_freq [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] , arr [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] ) NEW_LINE DEDENT DEDENT for i in range ( n1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ( A_freq [ i ] [ j ] < B_freq [ j ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT res . append ( A [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( res ) ) : NEW_LINE INDENT for i in range ( len ( res ) ) : NEW_LINE INDENT for j in range ( len ( res [ i ] ) ) : NEW_LINE INDENT print ( res [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" ] NEW_LINE B = [ \" geek \" , \" ee \" ] NEW_LINE UniversalSubset ( A , B ) NEW_LINE DEDENT"}
{"text": "Pasangan terdekat dalam array supaya satu nombor adalah pelbagai yang lain | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari pasangan jarak minimum di mana seseorang adalah pelbagai yang lain; Memulakan pembolehubah; Melangkah untuk semua elemen; Gelung untuk membuat pasangan; Semak jarak minimum; Semak jika seseorang adalah pelbagai yang lain; Mengemas kini jarak; Indeks kedai; Jika tidak ada pasangan seperti itu; Cetak jawapannya; Diberikan array arr []; Panggilan fungsi", "code": "import sys NEW_LINE def findPair ( a , n ) : NEW_LINE INDENT min_dist = sys . maxsize NEW_LINE index_a = - 1 NEW_LINE index_b = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i < min_dist ) : NEW_LINE INDENT if ( ( a [ i ] % a [ j ] == 0 ) or ( a [ j ] % a [ i ] == 0 ) ) : NEW_LINE INDENT min_dist = j - i NEW_LINE index_a = i NEW_LINE index_b = j NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( index_a == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ( \" , a [ index_a ] , \" , ▁ \" , a [ index_b ] , \" ) \" ) NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE findPair ( a , n ) NEW_LINE"}
{"text": "Cetak semua nombor dalam julat yang diberikan dengan digit dalam perintah yang semakin meningkat | Berfungsi untuk mencetak semua nombor dalam julat [l, r] yang mempunyai digit dalam urutan yang semakin meningkat; Melangkah ke atas julat; Melangkah ke atas digit; Semak sama ada digit semasa adalah> = digit sebelumnya; Sekiranya digit berada dalam urutan menaik; Diberikan julat l dan r; Panggilan fungsi", "code": "def printNum ( L , R ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 10 >= c ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT L = 10 NEW_LINE R = 15 NEW_LINE printNum ( L , R ) NEW_LINE"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Program Python3 untuk pendekatan di atas; Fungsi untuk mencari elemen yang hilang; Betulkan sempadan kiri dan kanan untuk carian binari; Cari Indeks Elemen Tengah; Semak jika elemen hanya selepas elemen tengah hilang; Semak jika elemen sebelum pertengahan hilang; Semak jika unsur -unsur sehingga pertengahan mengikuti AP, kemudian berulang untuk separuh kanan; Lain berulang untuk separuh kiri; Berfungsi untuk mencari elemen yang hilang dalam siri AP; Susun array arr []; Mengira perbezaan biasa; Pencarian binari untuk yang hilang; Diberikan array arr []; Panggilan fungsi", "code": "import sys NEW_LINE def findMissing ( arr , left , right , diff ) : NEW_LINE INDENT if ( right <= left ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT mid = left + ( right - left ) // 2 NEW_LINE if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) NEW_LINE DEDENT if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) NEW_LINE DEDENT if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissing ( arr , mid + 1 , right , diff ) NEW_LINE DEDENT return findMissing ( arr , left , mid - 1 , diff ) NEW_LINE DEDENT def missingElement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff = ( arr [ n - 1 ] - arr [ 0 ] ) // n NEW_LINE return findMissing ( arr , 0 , n - 1 , diff ) NEW_LINE DEDENT arr = [ 2 , 8 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( missingElement ( arr , n ) ) NEW_LINE"}
{"text": "Nilai lantai kth akar nombor menggunakan carian binari rekursif | Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn); Berfungsi untuk mencari akar kth nombor n menggunakan BS; Sekiranya julat masih sah; Cari nilai pertengahan julat; Kes asas; Keadaan untuk memeriksa sama ada ruang carian kiri tidak berguna; Diberikan n dan k; Panggilan fungsi", "code": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = power ( x , y // 2 ) ; NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp ; NEW_LINE DEDENT DEDENT def nthRootSearch ( low , high , N , K ) : NEW_LINE INDENT if ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 ; NEW_LINE if ( ( power ( mid , K ) <= N ) and ( power ( mid + 1 , K ) > N ) ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( power ( mid , K ) < N ) : NEW_LINE INDENT return nthRootSearch ( mid + 1 , high , N , K ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return nthRootSearch ( low , mid - 1 , N , K ) ; NEW_LINE DEDENT DEDENT return low ; NEW_LINE DEDENT N = 16 ; K = 4 ; NEW_LINE print ( nthRootSearch ( 0 , N , N , K ) ) NEW_LINE"}
{"text": "Count subset yang mempunyai jumlah elemen min dan max kurang daripada k | Fungsi yang mengembalikan kiraan subset sedemikian rupa sehingga min (s) + max (s) <k; Menyusun array; Ans menyimpan jumlah subset; Tambah semua subset yang mungkin antara I dan J; Mengurangkan jumlah; Kod pemacu", "code": "def get_subset_count ( arr , K , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE left = 0 ; NEW_LINE right = N - 1 ; NEW_LINE ans = 0 ; NEW_LINE while ( left <= right ) : NEW_LINE INDENT if ( arr [ left ] + arr [ right ] < K ) : NEW_LINE INDENT ans += 1 << ( right - left ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 2 , 4 , 5 , 7 ] ; NEW_LINE K = 8 ; NEW_LINE print ( get_subset_count ( arr , K , 4 ) ) NEW_LINE"}
{"text": "Kurangkan perbezaan maksimum unsur -unsur bersebelahan selepas kebanyakan sisipan k | Program Python3 untuk mencari perbezaan maksimum maksimum antara unsur -unsur bersebelahan selepas kebanyakan penyisipan K; Kirakan perbezaan bersebelahan maksimum; Jika perbezaan bersebelahan maksimum sudah sifar; Terbaik dan terburuk menentukan pelbagai perbezaan bersebelahan maksimum; Untuk menyimpan tidak ada sisipan yang diperlukan untuk nilai masing -masing MID; Jika bilangan sisipan diperlukan melebihi k; Jika tidak; Kod pemacu", "code": "def minMaxDiff ( arr , n , k ) : NEW_LINE INDENT max_adj_dif = float ( ' - inf ' ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; NEW_LINE DEDENT if ( max_adj_dif == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT best = 1 ; NEW_LINE worst = max_adj_dif ; NEW_LINE while ( best < worst ) : NEW_LINE INDENT mid = ( best + worst ) // 2 ; NEW_LINE required = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) // mid NEW_LINE DEDENT if ( required > k ) : NEW_LINE INDENT best = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT worst = mid NEW_LINE DEDENT DEDENT return worst NEW_LINE DEDENT arr = [ 3 , 12 , 25 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( minMaxDiff ( arr , n , k ) ) NEW_LINE"}
{"text": "Semak jika elemen minimum dalam array kurang daripada atau sama dengan separuh daripada setiap elemen lain | Pelaksanaan Python3 untuk memeriksa sama ada elemen minimum dalam array lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Fungsi untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Memulakan pembolehubah untuk menyimpan terkecil terkecil dan kedua terkecil; Semak jika elemen semasa lebih kecil daripada yang terkecil, terkecil semasa akan menjadi unsur detik yang paling teruk dan semasa akan menjadi yang terkecil baru; Semak jika elemen semasa lebih kecil daripada saat yang paling kecil hanya mengemas kini yang terakhir; Kod pemacu", "code": "import math NEW_LINE def checkMin ( arr , n ) : NEW_LINE INDENT smallest = math . inf NEW_LINE secondSmallest = math . inf NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < smallest ) : NEW_LINE INDENT secondSmallest = smallest NEW_LINE smallest = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondSmallest ) : NEW_LINE INDENT secondSmallest = arr [ i ] NEW_LINE DEDENT DEDENT if ( 2 * smallest <= secondSmallest ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE checkMin ( arr , n ) NEW_LINE DEDENT"}
{"text": "Nombor fibonacci terbesar dan terkecil dalam array | Program Python 3 untuk mencari nombor Fibonacci minimum dan maksimum dalam array yang diberikan; Fungsi untuk membuat jadual hash untuk memeriksa nombor Fibonacci; Masukkan dua nombor awal dalam jadual hash; Jumlah dua nombor sebelumnya; Kemas kini pembolehubah setiap kali; Berfungsi untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Cari nilai maksimum dalam array; Mewujudkan satu set yang mengandungi semua nombor Fibonacci sehingga nilai maksimum dalam array; Untuk menyimpan nombor Fibonacci minimum dan maksimum; Semak jika elemen semasa adalah nombor Fibonacci; Mengemas kini maksimum dan minimum yang sewajarnya; Kod pemacu", "code": "import sys NEW_LINE def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def fibonacci ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE minimum = sys . maxsize NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( minimum , end = \" , ▁ \" ) NEW_LINE print ( maximum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT"}
{"text": "Substring terpanjang dengan K aksara unik menggunakan carian binari | Fungsi yang kembali benar jika terdapat sub panjang len dengan <= k aksara unik; Saiz; Peta untuk menyimpan watak dan kekerapannya; Kemas kini peta untuk sub pertama; Periksa selebihnya selebihnya; Tambah watak baru; Keluarkan watak pertama tetingkap sebelumnya; Kemas kini peta; Berfungsi untuk mengembalikan panjang sub terpanjang yang mempunyai aksara unik K; Semak sama ada yang lengkap mengandungi aksara unik K; Saiz; Memohon carian binari; Kod pemacu", "code": "def isValidLen ( s , lenn , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = dict ( ) NEW_LINE right = 0 NEW_LINE while ( right < lenn ) : NEW_LINE INDENT mp [ s [ right ] ] = mp . get ( s [ right ] , 0 ) + 1 NEW_LINE right += 1 NEW_LINE DEDENT if ( len ( mp ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( right < n ) : NEW_LINE INDENT mp [ s [ right ] ] = mp . get ( s [ right ] , 0 ) + 1 NEW_LINE mp [ s [ right - lenn ] ] -= 1 NEW_LINE if ( mp [ s [ right - lenn ] ] == 0 ) : NEW_LINE INDENT del mp [ s [ right - lenn ] ] NEW_LINE DEDENT if ( len ( mp ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE DEDENT return len ( mp ) <= k NEW_LINE DEDENT def maxLenSubStr ( s , k ) : NEW_LINE INDENT uni = dict ( ) NEW_LINE for x in s : NEW_LINE INDENT uni [ x ] = 1 NEW_LINE DEDENT if ( len ( uni ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = len ( s ) NEW_LINE lo = - 1 NEW_LINE hi = n + 1 NEW_LINE while ( hi - lo > 1 ) : NEW_LINE INDENT mid = lo + hi >> 1 NEW_LINE if ( isValidLen ( s , mid , k ) ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT s = \" aabacbebebe \" NEW_LINE k = 3 NEW_LINE print ( maxLenSubStr ( s , k ) ) NEW_LINE"}
{"text": "Dataran Kawasan Terbesar di Array Apabila Elemen Boleh Dipandu | Fungsi yang mengembalikan benar jika mungkin untuk membuat persegi dengan sisi sama dengan L; Untuk menyimpan kiraan elemen yang lebih besar daripada atau sama dengan L; Kenaikan kiraan; Jika kiraan menjadi lebih besar daripada atau sama dengan L; Berfungsi untuk mengembalikan kawasan maksimum dataran yang boleh diperolehi; Jika persegi mungkin dengan panjang sisi m; Cuba cari persegi dengan panjang sampingan yang lebih kecil; Mengembalikan kawasan itu; Kod pemacu", "code": "def isSquarePossible ( arr , n , l ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= l : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt >= l : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def maxArea ( arr , n ) : NEW_LINE INDENT l , r = 0 , n NEW_LINE len = 0 NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE if isSquarePossible ( arr , n , m ) : NEW_LINE INDENT len = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ( len * len ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxArea ( arr , n ) ) NEW_LINE"}
{"text": "Semak pendua dalam aliran rentetan | Fungsi untuk memasukkan nama dan periksa sama ada ia muncul untuk kali pertama; Untuk menyimpan nama pekerja; Jika nama semasa muncul untuk kali pertama; Kod pemacu", "code": "def insertNames ( arr , n ) : NEW_LINE INDENT string = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in string : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE string . add ( arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" for \" , \" geeks \" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE insertNames ( arr , n ) ; NEW_LINE DEDENT"}
{"text": "Kira tiga kali ganda supaya A [i] <b [j] <c [k] | Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang kurang daripada kunci yang diberikan; Carian binari yang diubah suai; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang lebih besar daripada kunci yang diberikan; Carian binari yang diubah suai; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang diperlukan; Menyusun ketiga -tiga tatasusunan; Melangkah untuk semua elemen array b; Kiraan elemen dalam [] yang kurang daripada elemen yang dipilih dari B []; Kiraan unsur -unsur dalam C [] yang lebih besar daripada elemen yang dipilih dari B []; Mengemas kini kiraan; Kod pemacu", "code": "def countLessThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( arr [ m ] < key ) : NEW_LINE INDENT l = m + 1 NEW_LINE index = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ( index + 1 ) NEW_LINE DEDENT def countGreaterThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( arr [ m ] <= key ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE index = m NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n - index ) NEW_LINE DEDENT def countTriplets ( n , a , b , c ) : NEW_LINE INDENT a . sort NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current = b [ i ] NEW_LINE a_index = - 1 NEW_LINE c_index = - 1 NEW_LINE low = countLessThan ( a , n , current ) NEW_LINE high = countGreaterThan ( c , n , current ) NEW_LINE count += ( low * high ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 5 ] NEW_LINE b = [ 2 , 4 ] NEW_LINE c = [ 3 , 6 ] NEW_LINE size = len ( a ) NEW_LINE print ( countTriplets ( size , a , b , c ) ) NEW_LINE DEDENT"}
{"text": "Kos untuk mengimbangi kurungan | Kod Python 3 untuk mengira kos minimum untuk menjadikan tanda kurung yang diberikan seimbang; Untuk menyimpan kiraan mutlak kurungan yang seimbang dan tidak seimbang; o (pendakap terbuka) menyimpan kiraan '(' dan c (pendakap dekat) kiraan '); Kod pemacu", "code": "def costToBalance ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT ans = 0 NEW_LINE DEDENT ' NEW_LINE INDENT o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT if ( s [ i ] == ' ) ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( o != c ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = [ 0 for i in range ( len ( s ) ) ] NEW_LINE if ( s [ 0 ] == ' ( ' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE DEDENT if ( a [ 0 ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : s = \" ) ) ) ( ( ( \" NEW_LINE INDENT print ( costToBalance ( s ) ) s = \" ) ) ( ( \" NEW_LINE print ( costToBalance ( s ) ) NEW_LINE DEDENT"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Berfungsi untuk mencari pertengahan tiga nombor; x adalah positif jika a lebih besar daripada b. x adalah negatif jika b lebih besar daripada a. ; Sama seperti x; Sama seperti x dan y. ; Memeriksa jika B adalah tengah (X dan Y kedua -duanya adalah positif); Memeriksa jika C adalah tengah (x dan z kedua -duanya positif); Kod pemacu", "code": "def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE"}
{"text": "Cari empat nombor yang hilang dalam array yang mengandungi elemen dari 1 hingga n | Menemukan 4 nombor dalam O (n) masa dan O (1) ruang tambahan. ; Untuk menjejaki 4 nombor yang mungkin lebih besar daripada panjang input di Java, penolong secara automatik diasaskan sebagai 0 .; Traverse the input array and mark visited elements either by marking them as negative in arr [ ] or in helper [ ] . ; Jika elemen lebih kecil daripada atau sama dengan panjang, tandakan kehadirannya di arr []; Mark kehadiran dalam pembantu []; Cetak semua elemen yang kehadirannya tidak ditandakan. ; Kod pemacu", "code": "def missing4 ( arr ) : NEW_LINE INDENT helper = [ 0 ] * 4 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT temp = abs ( arr [ i ] ) NEW_LINE if ( temp <= len ( arr ) ) : NEW_LINE INDENT arr [ temp - 1 ] = arr [ temp - 1 ] * ( - 1 ) NEW_LINE DEDENT elif ( temp > len ( arr ) ) : NEW_LINE INDENT if ( temp % len ( arr ) ) : NEW_LINE INDENT helper [ temp % len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT helper [ ( temp % len ( arr ) ) + len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT print ( ( i + 1 ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( helper ) ) : NEW_LINE INDENT if ( helper [ i ] >= 0 ) : NEW_LINE INDENT print ( ( len ( arr ) + i + 1 ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 ] NEW_LINE missing4 ( arr ) NEW_LINE"}
{"text": "Permutasi yang hadir di tengah -tengah pesanan leksikografi permutasi paling panjang n yang terdiri daripada bilangan bulat sehingga k | Fungsi yang menemui tengah -tengah urutan terkecil leksikografi; Jika k ada; Elemen pertama ialah K / 2; Unsur -unsur yang tersisa dari urutan adalah semua integer k; Menyimpan urutan apabila k adalah ganjil; Melangkah ke atas julat [0, n / 2]; Semak sama ada urutan berakhir dengan 1 atau tidak; Keluarkan urutan yang berakhir dalam 1; Sekiranya ia tidak berakhir dalam 1; Penurunan sebanyak 1; Masukkan k ke urutan sehingga saiznya adalah n; Urutan yang disimpan dalam vektor; Kod pemacu", "code": "def lexiMiddleSmallest ( K , N ) : NEW_LINE INDENT if ( K % 2 == 0 ) : NEW_LINE INDENT print ( K // 2 , end = \" ▁ \" ) NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT print ( K , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT a = [ ( K + 1 ) // 2 ] * ( N ) NEW_LINE for i in range ( N // 2 ) : NEW_LINE INDENT if ( a [ - 1 ] == 1 ) : NEW_LINE INDENT del a [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT a [ - 1 ] -= 1 NEW_LINE while ( len ( a ) < N ) : NEW_LINE INDENT a . append ( K ) NEW_LINE DEDENT DEDENT DEDENT for i in a : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K , N = 2 , 4 NEW_LINE lexiMiddleSmallest ( K , N ) NEW_LINE DEDENT"}
{"text": "Elemen array yang tinggal selepas penyingkiran elemen terkecil dari pasangan dengan perbezaan mutlak 2 atau 0 | Berfungsi untuk mencari elemen array yang terakhir selepas berulang kali mengeluarkan terkecil dari pasangan yang mempunyai perbezaan mutlak 2 atau 0; Susun array yang diberikan dalam urutan menaik; Melintasi array; Jika perbezaan antara unsur -unsur bersebelahan tidak sama dengan 0 atau 2; Jika operasi boleh dilakukan; Kod pemacu", "code": "def findLastElement ( arr , N ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != 0 \\ and arr [ i ] - arr [ i - 1 ] != 2 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( arr [ N - 1 ] ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 0 , 8 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE findLastElement ( arr , N ) ; NEW_LINE DEDENT"}
{"text": "Memaksimumkan kiraan subset ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan | Fungsi untuk mengira subset maksimum ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan; Susun array dalam penurunan urutan; Kedai -kedai Count Subset mungkin; Kedai mengira unsur -unsur dalam subset semasa; Melintasi array arr []; Saiz kemas kini; Jika produk elemen terkecil yang terdapat dalam subset semasa dan saiz subset semasa ialah> = k; Kemas kini MaxSub; Saiz kemas kini; Kod pemacu; Diberikan array; Saiz array; Diberi nilai x", "code": "def maxDivisions ( arr , N , X ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE maxSub = 0 ; NEW_LINE size = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT size += 1 ; NEW_LINE if ( arr [ i ] * size >= X ) : NEW_LINE INDENT maxSub += 1 ; NEW_LINE size = 0 ; NEW_LINE DEDENT DEDENT print ( maxSub ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 7 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE X = 3 ; NEW_LINE maxDivisions ( arr , N , X ) ; NEW_LINE DEDENT"}
{"text": "Memaksimumkan jumlah minimum kedua dalam semua empat kali ganda dari array yang diberikan | Berfungsi untuk mencari jumlah maksimum minimum minimum kedua dalam setiap empat kali ganda; Susun array; Tambah minimum kedua; Cetak jumlah maksimum yang mungkin; Kod pemacu; Diberikan array; Saiz array", "code": "def maxPossibleSum ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE j = N - 3 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE j -= 3 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 ] NEW_LINE N = 8 NEW_LINE maxPossibleSum ( arr , N ) NEW_LINE DEDENT"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci kepada satu kedudukan di hadapan kedudukan semasa mereka; Berfungsi untuk mencetak pelbagai saiz n; Cetak array; Kod pemacu; Panggilan fungsi", "code": "def insertionSort ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE key = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > key ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" , end ▁ = ▁ \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE insertionSort ( arr , N ) NEW_LINE printArray ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Fungsi untuk mencari kiraan pasangan yang diperlukan; Kedai kiraan pasangan; Melintasi array; Periksa sama ada keadaan itu berpuas hati atau tidak; Kod pemacu; Panggilan fungsi", "code": "def getPairs ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > K * arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 2 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE getPairs ( arr , N , K ) NEW_LINE DEDENT"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Berfungsi untuk menggabungkan dua susunan yang disusun; i: indeks ke subarray kiri; J: Indeks ke Subarray Kanan; Kedai kiraan pasangan yang memenuhi syarat yang diberikan; Melintasi untuk memeriksa keadaan yang sah; Jika keadaan memenuhi; Semua elemen di sebelah kanan subarray kiri juga memuaskan; Susun dua tatasusunan yang diberikan dan simpan dalam array yang dihasilkan; Unsur -unsur yang tersisa di subarray kiri; Unsur -unsur yang tersisa di subarray kanan; Mengembalikan kiraan yang diperoleh; Berfungsi untuk memisahkan array menjadi dua bahagian; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Hubungi fungsi penggabungan; Berfungsi untuk mencetak kiraan pasangan yang diperlukan menggunakan jenis gabungan; Kod pemacu; Panggilan fungsi", "code": "def merge ( arr , temp , l , m , r , K ) : NEW_LINE INDENT i = l NEW_LINE j = m + 1 NEW_LINE cnt = 0 NEW_LINE for l in range ( m + 1 ) : NEW_LINE INDENT found = False NEW_LINE while ( j <= r ) : NEW_LINE INDENT if ( arr [ i ] >= K * arr [ j ] ) : NEW_LINE INDENT found = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT cnt += j - ( m + 1 ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT k = l NEW_LINE i = l NEW_LINE j = m + 1 NEW_LINE while ( i <= m and j <= r ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i <= m ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= r ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return cnt NEW_LINE DEDENT def mergeSortUtil ( arr , temp , l , r , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( l < r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE cnt += mergeSortUtil ( arr , temp , l , m , K ) NEW_LINE cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) NEW_LINE cnt += merge ( arr , temp , l , m , r , K ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT def mergeSort ( arr , N , K ) : NEW_LINE INDENT temp = [ 0 ] * N NEW_LINE print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) NEW_LINE DEDENT arr = [ 5 , 6 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE mergeSort ( arr , N , K ) NEW_LINE"}
{"text": "Kurangkan penyingkiran berturut -turut unsur -unsur jenis yang sama untuk kosong yang diberikan | Fungsi untuk mengira penyingkiran minimum berturut -turut unsur -unsur jenis yang sama; Susun array; Menyimpan elemen maksimum yang terdapat dalam array; menyimpan jumlah array; Hitung jumlah array; Kod pemacu; Panggilan fungsi", "code": "def minRemovals ( A , N ) : NEW_LINE INDENT A . sort ( ) NEW_LINE mx = A [ N - 1 ] NEW_LINE sum = 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT if ( ( sum - mx ) >= mx ) : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * mx - sum , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 3 , 2 ] NEW_LINE N = len ( A ) NEW_LINE minRemovals ( A , N ) NEW_LINE DEDENT"}
{"text": "Menyusun semula array yang diberikan supaya tiada elemen array yang sama dengan indeksnya | Berfungsi untuk menyusun semula array a [] supaya tidak ada unsur array yang sama dengan indeksnya; Susun array; Melintasi indeks [0, n - 2] dari array yang diberikan; Periksa sama ada elemen semasa adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen seterusnya; Semak jika elemen terakhir adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen sebelumnya; Array yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "def rearrangeArray ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] == i + 1 ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT if ( a [ n - 1 ] == n ) : NEW_LINE INDENT a [ n - 1 ] , a [ n - 2 ] = a [ n - 2 ] , a [ n - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE rearrangeArray ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | Fungsi yang mengira langkah minimum yang diperlukan untuk rahsia ARR [] kepada BRR []; Kes asas; Jika arr [i] <arr [j]; Termasuk elemen semasa; Jika tidak, tidak termasuk elemen semasa; Fungsi yang mengira langkah minimum yang diperlukan untuk menyusun array; Jika kedua -dua tatasusunan adalah sama; Tiada langkah yang diperlukan; Jika tidak; Mencetak operasi minimum yang diperlukan; Kod pemacu", "code": "def minOperations ( arr1 , arr2 , i , j ) : NEW_LINE INDENT if arr1 == arr2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= len ( arr1 ) or j >= len ( arr2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 ) NEW_LINE DEDENT return max ( minOperations ( arr1 , arr2 , i , j + 1 ) , minOperations ( arr1 , arr2 , i + 1 , j ) ) NEW_LINE DEDENT def minOperationsUtil ( arr ) : NEW_LINE INDENT brr = sorted ( arr ) ; NEW_LINE if ( arr == brr ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( minOperations ( arr , brr , 0 , 0 ) ) NEW_LINE DEDENT DEDENT arr = [ 4 , 7 , 2 , 3 , 9 ] NEW_LINE minOperationsUtil ( arr ) NEW_LINE"}
{"text": "Semak jika rentetan boleh diubah kepada yang lain dengan menyusun substrings | Fungsi untuk memeriksa sama ada Str1 boleh diubah menjadi T dengan menyusun substrings; Berlaku [i] menyimpan indeks ('a' + i) dalam rentetan s; idx [i] menyimpan indeks yang tersedia seterusnya ('a' + i) berlaku [i]; Sekiranya ini tidak tersedia lagi; Penukaran tidak mungkin; Jika salah satu watak yang lebih kecil tersedia dan berlaku sebelum ini; Penukaran tidak mungkin; Cetak jawapannya; Kod pemacu", "code": "def canTransform ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE occur = [ [ ] for i in range ( 26 ) ] NEW_LINE for x in range ( n ) : NEW_LINE INDENT ch = ord ( s [ x ] ) - ord ( ' a ' ) NEW_LINE occur [ ch ] . append ( x ) NEW_LINE DEDENT idx = [ 0 ] * ( 26 ) NEW_LINE poss = True NEW_LINE for x in range ( n ) : NEW_LINE INDENT ch = ord ( t [ x ] ) - ord ( ' a ' ) NEW_LINE if ( idx [ ch ] >= len ( occur [ ch ] ) ) : NEW_LINE INDENT poss = False NEW_LINE break NEW_LINE DEDENT for small in range ( ch ) : NEW_LINE INDENT if ( idx [ small ] < len ( occur [ small ] ) and occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) : NEW_LINE INDENT poss = False NEW_LINE break NEW_LINE DEDENT DEDENT idx [ ch ] += 1 NEW_LINE DEDENT if ( poss ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hdecb \" NEW_LINE t = \" cdheb \" NEW_LINE canTransform ( s , t ) NEW_LINE DEDENT"}
{"text": "Semak sama ada dua rentetan boleh dibuat sama dengan membalikkan substring panjang yang sama dari kedua -dua rentetan | fungsi untuk mengira kiraan penyongsangan rentetan; untuk menyimpan kekerapan; Kami akan menambah semua watak yang kurang daripada watak ITH sebelum saya. ; Menambah kiraan kepada kiraan penyongsangan; mengemas kini watak dalam pelbagai frekuensi; berfungsi untuk memeriksa sama ada mana -mana rentetan mempunyai watak berulang; fungsi untuk memeriksa sama ada String S1 dan S2 boleh dibuat sama dengan membalikkan Sub Strings ofsame saiz dalam kedua -dua rentetan; Arahan kekerapan untuk memeriksa sama ada kedua -dua rentetan mempunyai watak yang sama atau tidak; menambah kekerapan; ; Jika watak tidak berada di S1; menurunkan kekerapan; Jika kedua -dua rentetan tidak mempunyai aksara yang sama atau tidak; mencari kiraan penyongsangan kedua -dua rentetan; Jika kiraan penyongsangan adalah sama, atau mempunyai pariti yang sama atau jika mana -mana rentetan mempunyai watak berulang maka jawapannya ya tidak lagi; Kod pemacu", "code": "def inversionCount ( s ) : NEW_LINE INDENT freq = [ 0 for _ in range ( 26 ) ] NEW_LINE inv = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( ' a ' ) ) : NEW_LINE INDENT temp += freq [ j ] NEW_LINE DEDENT inv += ( i - temp ) NEW_LINE freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return inv NEW_LINE DEDENT def haveRepeated ( S1 , S2 ) : NEW_LINE INDENT freq = [ 0 for _ in range ( 26 ) ] NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE INDENT if freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( S2 ) ) : NEW_LINE INDENT if freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def checkToMakeEqual ( S1 , S2 ) : NEW_LINE INDENT freq = [ 0 for _ in range ( 26 ) ] NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE INDENT freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( len ( S2 ) ) : NEW_LINE INDENT if freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT invCount1 = inversionCount ( S1 ) NEW_LINE invCount2 = inversionCount ( S2 ) NEW_LINE if ( ( invCount1 == invCount2 ) or ( ( invCount1 % 2 ) == ( invCount2 % 2 ) ) or haveRepeated ( S1 , S2 ) == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT S1 = \" abbca \" NEW_LINE S2 = \" acabb \" NEW_LINE checkToMakeEqual ( S1 , S2 ) NEW_LINE"}
{"text": "Susun Arahan Bitonic | Program Python3 untuk pendekatan di atas; Berfungsi untuk menyusun array bitonic dalam ruang malar; Inisialisasi thevalue k; Dalam setiap lelaran membandingkan unsur -unsur k jarak jauh dan menukarnya, mereka tidak teratur; K dikurangkan kepada separuh selepas setiap lelaran; Cetak elemen array; Diberikan array; Panggilan fungsi", "code": "import math NEW_LINE def sortArr ( a , n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE k = int ( pow ( 2 , k ) ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT i = 0 NEW_LINE while i + k < n : NEW_LINE INDENT if a [ i ] > a [ i + k ] : NEW_LINE INDENT a [ i ] , a [ i + k ] = a [ i + k ] , a [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT k = k // 2 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 ] NEW_LINE n = len ( a ) NEW_LINE sortArr ( a , n ) NEW_LINE"}
{"text": "Split array ke dalam sub subset untuk memaksimumkan jumlah maksimum dan minimum mereka | Fungsi yang mencetak jumlah maksimum yang mungkin; Cari elemen dalam setiap kumpulan; Menyusun semua elemen dalam perintah bukan menurun; Tambah un elemen terbesar; Untuk jumlah elemen minimum dari setiap subset; Mencetak jumlah maksimum; Kod pemacu", "code": "def maximumSum ( arr , n , k ) : NEW_LINE INDENT elt = n // k ; NEW_LINE sum = 0 ; NEW_LINE arr . sort ( ) ; NEW_LINE count = 0 ; NEW_LINE i = n - 1 ; NEW_LINE while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE i -= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE i += elt - 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Arr = [ 1 , 13 , 7 , 17 , 6 , 5 ] ; NEW_LINE K = 2 ; NEW_LINE size = len ( Arr ) ; NEW_LINE maximumSum ( Arr , size , K ) ; NEW_LINE DEDENT"}
{"text": "Kurangkan jumlah unsur -unsur terkecil dari k -lekukan panjang l | Berfungsi untuk mencari jumlah minimum; Susun array; Hitung jumlah elemen k terkecil; Mengembalikan jumlahnya; Kod pemacu", "code": "def findMinSum ( arr , K , L , size ) : NEW_LINE INDENT if ( K * L > size ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minsum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT minsum += arr [ i ] NEW_LINE DEDENT return minsum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 ] NEW_LINE K = 3 NEW_LINE L = 2 NEW_LINE length = len ( arr ) NEW_LINE print ( findMinSum ( arr , K , L , length ) ) NEW_LINE DEDENT"}
{"text": "KTH elemen terkecil atau terbesar dalam array yang tidak disusun | Tetapkan 4 | Berfungsi untuk mencari elemen terkecil kth dalam array yang tidak disusun; Memulakan elemen max sebagai 0; Iterate arr [ ] and find the maximum element in it ; Arahan kekerapan untuk menyimpan frekuensi; Pemboleh ubah kaunter; Mengira frekuensi; Melangkah melalui freq []; Semak sama ada NUM terdapat dalam array; Meningkatkan kaunter dengan kekerapan NUM; Memeriksa jika kita telah mencapai elemen terkecil KTH; Mengembalikan elemen terkecil kth; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "def findKthSmallest ( arr , n , k ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT counter = [ 0 ] * ( max + 1 ) NEW_LINE smallest = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT counter [ arr [ i ] ] += 1 NEW_LINE DEDENT for num in range ( 1 , max + 1 ) : NEW_LINE INDENT if ( counter [ num ] > 0 ) : NEW_LINE INDENT smallest += counter [ num ] NEW_LINE DEDENT if ( smallest >= k ) : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 7 , 1 , 4 , 4 , 20 , 15 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 5 NEW_LINE print ( findKthSmallest ( arr , N , K ) ) NEW_LINE DEDENT"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Berfungsi untuk mencetak semua nombor sehingga n dalam urutan leksikografi; Kod pemacu", "code": "def lexNumbers ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s . append ( str ( i ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( int ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 NEW_LINE lexNumbers ( n ) NEW_LINE DEDENT"}
{"text": "Susun Matriks dalam Perintah Menaik dan Menurun Rowwise | Python3 implementation to print row of matrix in ascending or descending order alternatively ; Matriks iterate rowwise; Menyusun baris dalam urutan menaik; Bandingkan unsur -unsur bersebelahan; Swap elemen bersebelahan; Menyusun baris dalam urutan menurun; Bandingkan unsur -unsur bersebelahan; Swap elemen bersebelahan; Mencetak output akhir; Kod pemacu", "code": "N = 4 NEW_LINE def func ( a ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE INDENT if a [ i ] [ j ] > a [ i ] [ k ] : NEW_LINE INDENT temp = a [ i ] [ j ] NEW_LINE a [ i ] [ j ] = a [ i ] [ k ] NEW_LINE a [ i ] [ k ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE INDENT if a [ i ] [ j ] < a [ i ] [ k ] : NEW_LINE INDENT temp = a [ i ] [ j ] NEW_LINE a [ i ] [ j ] = a [ i ] [ k ] NEW_LINE a [ i ] [ k ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ [ 5 , 7 , 3 , 4 ] , [ 9 , 5 , 8 , 2 ] , [ 6 , 3 , 8 , 1 ] , [ 5 , 8 , 9 , 3 ] ] NEW_LINE func ( a ) NEW_LINE DEDENT"}
{"text": "Cari berat MST dalam graf lengkap dengan Edge | Untuk menyimpan tepi graf yang diberikan; Fungsi utiliti untuk melaksanakan traversal DFS; Semak simpang yang disimpan dalam set; Vertices dimasukkan jika berat kelebihan adalah 0; Fungsi utiliti untuk mencari berat pokok minimum; To count the connected components ; Memasukkan simpul awal dalam set; Melintasi simpang yang disimpan dalam set dan menjalankan traversal DFS untuk setiap simpang; Meningkatkan komponen bersambung berat sifar; DFS traversal untuk setiap vertex mengeluarkan; Kod pemandu; Masukkan tepi; Fungsi Panggilan Cari berat pokok minimum", "code": "g = [ dict ( ) for i in range ( 200005 ) ] NEW_LINE s = set ( ) NEW_LINE ns = set ( ) NEW_LINE def dfs ( x ) : NEW_LINE INDENT global s , g , ns NEW_LINE v = [ ] NEW_LINE v . clear ( ) ; NEW_LINE ns . clear ( ) ; NEW_LINE for it in s : NEW_LINE INDENT if ( x in g and not g [ x ] [ it ] ) : NEW_LINE INDENT v . append ( it ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ns . add ( it ) ; NEW_LINE DEDENT DEDENT s = ns ; NEW_LINE for i in v : NEW_LINE INDENT dfs ( i ) ; NEW_LINE DEDENT DEDENT def weightOfMST ( N ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s . add ( i ) ; NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE t = list ( s ) [ 0 ] NEW_LINE s . discard ( t ) ; NEW_LINE dfs ( t ) ; NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE M = 11 ; NEW_LINE edges = [ [ 1 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 1 , 6 ] , [ 2 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 4 ] , [ 3 , 5 ] , [ 3 , 6 ] ] ; NEW_LINE for i in range ( M ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] ; NEW_LINE v = edges [ i ] [ 1 ] ; NEW_LINE g [ u ] [ v ] = 1 ; NEW_LINE g [ v ] [ u ] = 1 ; NEW_LINE DEDENT weightOfMST ( N ) ; NEW_LINE DEDENT"}
{"text": "Kira pasangan yang mungkin berbeza supaya elemen dari A lebih besar daripada elemen dari b | Berfungsi untuk mengembalikan kiraan pasangan; Kod pemacu", "code": "def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 30 , 28 , 45 , 22 ] NEW_LINE B = [ 35 , 25 , 22 , 48 ] NEW_LINE print ( countPairs ( A , B ) ) NEW_LINE DEDENT"}
{"text": "Sisa maksimum mungkin apabila elemen dibahagikan dengan elemen lain dalam array | Berfungsi untuk mengembalikan nilai mod maksimum untuk mana -mana pasangan dari array; Cari elemen maksimum kedua dari array; Kod pemacu", "code": "def maxMod ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) NEW_LINE secondMax = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < maxVal and arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return secondMax NEW_LINE DEDENT arr = [ 2 , 4 , 1 , 5 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxMod ( arr , n ) ) NEW_LINE"}
{"text": "Pilih x elemen dari elemen [] dan y dari b [] yang memenuhi syarat yang diberikan | Berfungsi untuk pulangan yang benar jika mungkin untuk memilih unsur -unsur; Jika unsur -unsur tidak dapat dipilih; Menyusun kedua -dua tatasusunan; Jika elemen terkecil x [] adalah lebih kecil daripada elemen terbesar Yth B []; Kod pemacu", "code": "def isPossible ( A , B , n , m , x , y ) : NEW_LINE INDENT if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = [ 2 , 2 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE if ( isPossible ( A , B , n , m , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cari perubahan minimum yang diperlukan dalam array untuk mengandungi elemen K yang berbeza | Program Python 3 kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Fungsi kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Simpan kekerapan setiap elemen; Simpan kekerapan elemen; Jenis frekuensi dalam urutan menurun; Untuk menyimpan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "MAX = 100005 NEW_LINE def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT"}
{"text": "Bilangan maksimum elemen tanpa bertindih dalam garis | Berfungsi untuk mencari bilangan elemen maksimum tanpa bertindih dalam garis; Jika n = 1, maka jawapannya adalah satu; Kami sentiasa boleh membuat elemen 1 st untuk menutup segmen kiri dan nth segmen yang betul; Jika segmen kiri untuk elemen ith tidak bertindih dengan elemen i - 1 maka kemudian kiri; lain cuba ke arah yang betul jika boleh; Kemas kini x [i] ke segmen endpoof kanan yang diliputi olehnya; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "def Segment ( x , l , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( x [ i ] - l [ i ] > x [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( x [ i ] + l [ i ] < x [ i + 1 ] ) : NEW_LINE INDENT x [ i ] = x [ i ] + l [ i ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT x = [ 1 , 3 , 4 , 5 , 8 ] NEW_LINE l = [ 10 , 1 , 2 , 2 , 5 ] NEW_LINE n = len ( x ) NEW_LINE print ( Segment ( x , l , n ) ) NEW_LINE"}
{"text": "Padam ganjil dan bahkan nombor pada langkah alternatif supaya jumlah elemen yang tinggal diminimumkan | Berfungsi untuk mencari jumlah yang diminimumkan; Jika lebih banyak elemen ganjil; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika lebih banyak elemen; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika elemen yang sama; Kod pemacu", "code": "def MinimizeleftOverSum ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( v1 ) > len ( v2 ) ) : NEW_LINE INDENT v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE x = len ( v1 ) - len ( v2 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < x ) : NEW_LINE INDENT sum += v1 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT return sum ; NEW_LINE DEDENT elif ( len ( v2 ) > len ( v1 ) ) : NEW_LINE INDENT v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE x = len ( v2 ) - len ( v1 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < x ) : NEW_LINE INDENT sum += v2 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT return sum ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 2 , 2 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinimizeleftOverSum ( a , n ) ) ; NEW_LINE DEDENT"}
{"text": "Operasi minimum untuk membuat kekerapan semua aksara sama k | Berfungsi untuk mencari bilangan minimum operasi untuk menukar rentetan yang diberikan; Semak jika n boleh dibahagikan dengan k; Array untuk menyimpan kekerapan aksara dalam rentetan yang diberikan; Dua tatasusunan dengan bilangan operasi yang diperlukan; Memeriksa semua kemungkinan; Kod pemacu", "code": "def minOperation ( S , N , K ) : NEW_LINE INDENT if N % K : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE return NEW_LINE DEDENT count = [ 0 ] * 26 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT count [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT E = N // K NEW_LINE greaterE = [ ] NEW_LINE lessE = [ ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT if count [ i ] < E : NEW_LINE INDENT lessE . append ( E - count [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT greaterE . append ( count [ i ] - E ) NEW_LINE DEDENT DEDENT greaterE . sort ( ) NEW_LINE lessE . sort ( ) NEW_LINE mi = float ( ' inf ' ) NEW_LINE for i in range ( 0 , K + 1 ) : NEW_LINE INDENT set1 , set2 = i , K - i NEW_LINE if ( len ( greaterE ) >= set1 and len ( lessE ) >= set2 ) : NEW_LINE INDENT step1 , step2 = 0 , 0 NEW_LINE for j in range ( 0 , set1 ) : NEW_LINE INDENT step1 += greaterE [ j ] NEW_LINE DEDENT for j in range ( 0 , set2 ) : NEW_LINE INDENT step2 += lessE [ j ] NEW_LINE DEDENT mi = min ( mi , max ( step1 , step2 ) ) NEW_LINE DEDENT DEDENT print ( mi ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" accb \" NEW_LINE N = len ( S ) NEW_LINE K = 2 NEW_LINE minOperation ( S , N , K ) NEW_LINE DEDENT"}
{"text": "Operasi Peningkatan Julat Minimum Untuk Mengasingkan Array | Berfungsi untuk mencari kenaikan julat minimum untuk menyusun array; Jika elemen semasa didapati lebih besar daripada kenaikan elemen terakhir semua istilah dalam julat i + 1 hingga n - 1; mn = arr [i] minimum dalam julat i ke n - 1; Kod pemacu", "code": "def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT DEDENT return moves NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMovesToSort ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Susun nombor utama array dalam perintah menurun | Pelaksanaan Python3 pendekatan; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Fungsi yang menyusun semua nombor utama dari array dalam menurun; Vektor ini akan mengandungi nombor utama untuk disusun; Jika elemen itu adalah perdana; mengemas kini elemen array; Kod pemacu; Cetak hasilnya.", "code": "def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def sortPrimes ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( reverse = True ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT arr [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 6 , 100 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE prime = [ True ] * 100006 NEW_LINE arr = sortPrimes ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Pembentukan pasangan sedemikian rupa sehingga jumlah pasangan maksimum diminimumkan | Program Python 3 untuk membahagikan array ke pasangan N seperti pasangan maksimum diminimumkan; Selepas menyusun mengekalkan dua pembolehubah i dan j menunjuk untuk memulakan dan mengakhiri array sedemikian rupa sehingga elemen terkecil pasangan array dengan elemen terbesar; Kod pemacu", "code": "def findOptimalPairs ( arr , N ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT print ( \" ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" , end = \" ▁ \" ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 6 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE findOptimalPairs ( arr , N ) NEW_LINE DEDENT"}
{"text": "Sort Array mengikut kiraan bit set | fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Berfungsi secara serentak menyusun kedua -dua tatasusunan menggunakan jenis penyisipan (http: kuiz geeksforgeeks. Org / sisipan - sort /); Gunakan 2 kekunci kerana kita perlu menyusun kedua -dua tatasusunan secara serentak; Gerakkan unsur -unsur ARR [0 .. i - 1] dan aux [0 .. i - 1], seperti unsur -unsur aux [0 .. i - 1] adalah lebih besar daripada Key1, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi untuk disusun mengikut kiraan bit menggunakan array tambahan; Buat array dan kiraan bit set di dalamnya. ; Susun arr [] mengikut nilai dalam aux []; Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def insertionSort ( arr , aux , n ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT key1 = aux [ i ] NEW_LINE key2 = arr [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 and aux [ j ] < key1 ) : NEW_LINE INDENT aux [ j + 1 ] = aux [ j ] NEW_LINE arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT aux [ j + 1 ] = key1 NEW_LINE arr [ j + 1 ] = key2 NEW_LINE DEDENT DEDENT def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT aux [ i ] = countBits ( arr [ i ] ) NEW_LINE DEDENT insertionSort ( arr , aux , n ) NEW_LINE DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE DEDENT"}
{"text": "Sort Array mengikut kiraan bit set | fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Fungsi untuk disusun mengikut bit Count fungsi ini mengandaikan bahawa terdapat 32 bit dalam integer. ; Melintasi semua bit bit (perhatikan bahawa kami menyusun array dalam penurunan urutan); Fungsi utiliti ke Array Pran; Kod pemacu", "code": "def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT count = [ [ ] for i in range ( 32 ) ] NEW_LINE setbitcount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT setbitcount = countBits ( arr [ i ] ) NEW_LINE count [ setbitcount ] . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT v1 = count [ i ] NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT arr [ j ] = v1 [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT print ( * arr ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE"}
{"text": "Lexicographically terkecil rentetan binari yang dibentuk dengan membalikkan bit pada indeks yang tidak dapat dibahagi k1 atau k2 supaya kiraan 1 s selalu lebih besar daripada 0 s dari kiri | Berfungsi untuk mencari rentetan terkecil secara lexicographically yang mempunyai bilangan 1 s lebih besar daripada bilangan 0 s; C1S dan C0S menyimpan kiraan 1 s dan 0 s pada setiap kedudukan; Melintasi rentetan s; Jika kedudukan tidak dapat dibahagikan dengan k1 dan k2; Jika c0s> = c1s dan pos [] kosong maka rentetan tidak dapat dibentuk; Jika POS [] tidak kosong maka flip sedikit kedudukan terakhir yang terdapat di POS []; Cetak hasilnya; Kod pemacu", "code": "def generateString ( k1 , k2 , s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE C1s = 0 NEW_LINE C0s = 0 NEW_LINE flag = 0 NEW_LINE pos = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT C0s += 1 NEW_LINE if ( ( i + 1 ) % k1 != 0 and ( i + 1 ) % k2 != 0 ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT C1s += 1 NEW_LINE DEDENT if ( C0s >= C1s ) : NEW_LINE INDENT if ( len ( pos ) == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT k = pos [ len ( pos ) - 1 ] NEW_LINE s [ k ] = '1' NEW_LINE C0s -= 1 NEW_LINE C1s += 1 NEW_LINE pos = pos [ : - 1 ] NEW_LINE DEDENT DEDENT DEDENT s = ' ' . join ( s ) NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K1 = 2 NEW_LINE K2 = 4 NEW_LINE S = \"11000100\" NEW_LINE generateString ( K1 , K2 , S ) NEW_LINE DEDENT"}
{"text": "Cari sepasang nombor dengan set bit set sebagai kebanyakan n dan yang bitwise xor adalah n | Program Python 3 untuk pendekatan di atas; Fungsi untuk mencari pasangan (x, y) sedemikian rupa sehingga x xor y = n dan kiraan bit set dalam x dan y kurang daripada kiraan set bit dalam n; Kedai MSB (Bit Paling Penting); Menyimpan nilai x; / Menyimpan nilai y; Melintasi semua bit N; Jika ia bit n ialah 0; / Set ith bit x hingga 1; Tetapkan sedikit Y hingga 1; Jawapan cetak; Kod pemacu", "code": "import math NEW_LINE def maximizeProduct ( N ) : NEW_LINE INDENT MSB = ( int ) ( math . log2 ( N ) ) NEW_LINE X = 1 << MSB NEW_LINE Y = N - ( 1 << MSB ) NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( not ( N & ( 1 << i ) ) ) : NEW_LINE INDENT X += 1 << i NEW_LINE Y += 1 << i NEW_LINE DEDENT DEDENT print ( X , Y ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 45 NEW_LINE maximizeProduct ( N ) NEW_LINE DEDENT"}
{"text": "Count of Numbers in Range [l, r] mempunyai jumlah digit persegi sama dengan kuadrat jumlah digit | Program Python 3 untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor itu sah; Jumlah digit Num; Nombor kuadrat; Jumlah digit (num * num); Berfungsi untuk menukar rentetan ke integer; Berfungsi untuk menghasilkan semua rentetan panjang yang mungkin; Rentetan yang dikehendaki; Hanya mengambil nombor yang sah; Berulang untuk semua digit yang mungkin; Berfungsi untuk mengira nombor unik dalam julat [l, r]; Memulakan pembolehubah untuk menyimpan jawapannya; Kirakan panjang maksimum yang mungkin; Tetapkan untuk menyimpan nombor yang sah yang berbeza; Menjana semua rentetan panjang yang mungkin i; I -meletakkan set untuk mendapatkan kiraan nombor yang sah dalam julat [l, r]; Kod pemacu", "code": "from math import log10 NEW_LINE def check ( num ) : NEW_LINE INDENT sm = 0 NEW_LINE num2 = num * num NEW_LINE while ( num ) : NEW_LINE INDENT sm += num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT sm2 = 0 NEW_LINE while ( num2 ) : NEW_LINE INDENT sm2 += num2 % 10 NEW_LINE num2 //= 10 NEW_LINE DEDENT return ( ( sm * sm ) == sm2 ) NEW_LINE DEDENT def convert ( s ) : NEW_LINE INDENT val = 0 NEW_LINE s = s [ : : - 1 ] NEW_LINE cur = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val += ( ord ( s [ i ] ) - ord ( '0' ) ) * cur NEW_LINE cur *= 10 NEW_LINE DEDENT return val NEW_LINE DEDENT def generate ( s , len1 , uniq ) : NEW_LINE INDENT if ( len ( s ) == len1 ) : NEW_LINE INDENT if ( check ( convert ( s ) ) ) : NEW_LINE INDENT uniq . add ( convert ( s ) ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 4 ) : NEW_LINE INDENT generate ( s + chr ( i + ord ( '0' ) ) , len1 , uniq ) NEW_LINE DEDENT DEDENT def totalNumbers ( L , R ) : NEW_LINE INDENT ans = 0 NEW_LINE max_len = int ( log10 ( R ) ) + 1 NEW_LINE uniq = set ( ) NEW_LINE for i in range ( 1 , max_len + 1 , 1 ) : NEW_LINE INDENT generate ( \" \" , i , uniq ) NEW_LINE DEDENT for x in uniq : NEW_LINE INDENT if ( x >= L and x <= R ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 22 NEW_LINE R = 22 NEW_LINE print ( totalNumbers ( L , R ) ) NEW_LINE DEDENT"}
{"text": "Tukar x ke y dengan berulang kali mengalikan x dengan 2 atau tampuk 1 pada akhir | Fungsi untuk memeriksa sama ada x boleh ditukar kepada y dengan mengalikan x dengan 2 atau menambahkan 1 pada akhir; ITERATE Sehingga Y adalah sekurang -kurangnya x; Jika y juga; Jika digit terakhir Y ialah 1; Jika tidak; Semak sama ada x sama dengan y; Kod pemacu", "code": "def convertXintoY ( X , Y ) : NEW_LINE INDENT while ( Y > X ) : NEW_LINE INDENT if ( Y % 2 == 0 ) : NEW_LINE INDENT Y //= 2 NEW_LINE DEDENT elif ( Y % 10 == 1 ) : NEW_LINE INDENT Y //= 10 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( X == Y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X , Y = 100 , 40021 NEW_LINE convertXintoY ( X , Y ) NEW_LINE DEDENT"}
{"text": "Lexicographically terkecil rentetan panjang maksimum yang terdiri daripada huruf k pertama yang tidak mengandungi apa -apa substring berulang | Berfungsi untuk mencari rentetan terkecil lexicographically dari huruf kaum K bawah pertama yang mempunyai substrings yang unik; Menyimpan rentetan yang dihasilkan; Melewati semua watak; Gelung dalaman untuk membuat pasangan dan menambahkannya ke dalam rentetan; Menambah watak pertama supaya substring yang terdiri daripada abjad yang terakhir hadir; Cetak rentetan yang dihasilkan; Kod pemacu", "code": "def generateString ( K ) : NEW_LINE INDENT s = \" \" NEW_LINE for i in range ( 97 , 97 + K , 1 ) : NEW_LINE INDENT s = s + chr ( i ) ; NEW_LINE for j in range ( i + 1 , 97 + K , 1 ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE DEDENT DEDENT s += chr ( 97 ) NEW_LINE print ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 4 NEW_LINE generateString ( K ) NEW_LINE DEDENT"}
{"text": "Menjana Persamaan Kuadratik setelah memberikan jumlah dan produk akar | Berfungsi untuk mencari persamaan kuadratik dari jumlah dan produk akar yang diberikan; Cetak pekali; Kod pemacu", "code": "def findEquation ( S , M ) : NEW_LINE INDENT print ( \"1 ▁ \" , ( ( - 1 ) * S ) , \" ▁ \" , M ) NEW_LINE DEDENT S = 5 NEW_LINE M = 6 NEW_LINE findEquation ( S , M ) NEW_LINE"}
{"text": "Buat semua elemen array sama dengan menggantikan pasangan bersebelahan dengan jumlah mereka | Fungsi untuk mengira bilangan minimum pasang unsur -unsur bersebelahan yang diperlukan untuk digantikan oleh jumlah mereka untuk menjadikan semua elemen arrat sama; Menyimpan jumlah awalan array; Kirakan Array Jumlah Awalan; Menyimpan bilangan maksimum subarray yang mana array boleh dibahagikan; Melangkah ke atas semua jumlah yang mungkin; Melintasi array; Jika jumlahnya sama dengan jumlah awalan semasa; Kira kenaikan kumpulan sebanyak 1; Jika tidak buang jumlah subkumpulan ini; Mengemas kini maksimum ini subarray; Mengembalikan bilangan operasi minimum; Kod pemacu; Panggilan fungsi", "code": "def minSteps ( a , n ) : NEW_LINE INDENT prefix_sum = a [ : ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT mx = - 1 NEW_LINE for subgroupsum in prefix_sum : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE grp_count = 0 NEW_LINE while i < n : NEW_LINE INDENT sum += a [ i ] NEW_LINE if sum == subgroupsum : NEW_LINE INDENT grp_count += 1 NEW_LINE sum = 0 NEW_LINE DEDENT elif sum > subgroupsum : NEW_LINE INDENT grp_count = - 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if grp_count > mx : NEW_LINE INDENT mx = grp_count NEW_LINE DEDENT DEDENT return n - mx NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 2 , 1 , 3 ] NEW_LINE N = len ( A ) NEW_LINE print ( minSteps ( A , N ) ) NEW_LINE DEDENT"}
{"text": "Karakter yang paling kerap dalam rentetan selepas menggantikan semua kejadian x dalam rentetan binari | Berfungsi untuk mencari watak yang paling kerap selepas menggantikan x dengan sama ada '0' atau '1' mengikut syarat -syarat yang diberikan; Simpan kiraan 0 s dan 1 s dalam s; Hitung kekerapan 0 dan 1; Jika wataknya adalah 1; Jika wataknya 0; Kedai pertama berlaku 1; Melintasi untuk mengira bilangan x antara dua berturut -turut 1 s; Jika watak semasa bukan x; Jika aksara semasa adalah 1, tambahkan bilangan Xs ke Count1 dan tetapkan sebelum i; Jika tidak; Cari kejadian seterusnya 1 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Simpan kejadian pertama 0; Ulangi prosedur yang sama untuk mengira bilangan x antara dua berturut -turut 0 s; Jika watak semasa bukan x; Jika watak semasa adalah 0; Tambah kiraan XS ke Count0; Tetapkan sebelumnya ke i; Jika tidak; Cari kejadian seterusnya 0 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Kiraan bilangan x yang hadir dalam permulaan rentetan sebagai xxxx1 ...; Simpan kiraan x; Kenaikan kiraan1 dengan kiraan jika keadaan itu berpuas hati; Kira bilangan x yang hadir pada akhir As ... xxxx0; Simpan kiraan x; Kenaikan kiraan dengan kiraan jika keadaan itu berpuas hati; Jika kiraan 1 adalah sama dengan kiraan 0, PRX; Jika tidak, jika kiraan 1 lebih besar daripada kiraan 0; Otherwise , pr0 ; Kod pemacu", "code": "def maxOccuringCharacter ( s ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE count1 += 1 NEW_LINE elif ( s [ i ] == '0' ) : NEW_LINE count0 += 1 NEW_LINE DEDENT prev = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE prev = i NEW_LINE break NEW_LINE DEDENT for i in range ( prev + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != ' X ' ) : NEW_LINE if ( s [ i ] == '1' ) : NEW_LINE INDENT count1 += i - prev - 1 NEW_LINE prev = i NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE if ( s [ j ] == '1' ) : NEW_LINE INDENT flag = False NEW_LINE prev = j NEW_LINE break NEW_LINE DEDENT if ( flag == False ) : NEW_LINE i = prev NEW_LINE else : NEW_LINE i = len ( s ) NEW_LINE DEDENT DEDENT prev = - 1 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE prev = i NEW_LINE break NEW_LINE DEDENT for i in range ( prev + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != ' X ' ) : NEW_LINE if ( s [ i ] == '0' ) : NEW_LINE INDENT count0 += i - prev - 1 NEW_LINE prev = i NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE if ( s [ j ] == '0' ) : NEW_LINE INDENT prev = j NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT if ( flag == False ) : NEW_LINE i = prev NEW_LINE else : NEW_LINE i = len ( s ) NEW_LINE DEDENT DEDENT if ( s [ 0 ] == ' X ' ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while ( s [ i ] == ' X ' ) : NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE if ( s [ i ] == '1' ) : NEW_LINE count1 += count NEW_LINE DEDENT if ( s [ ( len ( s ) - 1 ) ] == ' X ' ) : NEW_LINE INDENT count = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' X ' ) : NEW_LINE count += 1 NEW_LINE i -= 1 NEW_LINE if ( s [ i ] == '0' ) : NEW_LINE count0 += count NEW_LINE DEDENT if ( count0 == count1 ) : NEW_LINE INDENT print ( \" X \" ) NEW_LINE DEDENT elif ( count0 > count1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT S = \" XX10XX10XXX1XX \" NEW_LINE maxOccuringCharacter ( S ) NEW_LINE"}
{"text": "Memaksimumkan kiraan lembaran yang mungkin dengan berulang kali mengurangkan kawasannya kepada separuh | Fungsi untuk mengira bilangan maksimum lembaran yang mungkin dengan operasi yang diberikan; Kiraan awal lembaran; Terus membahagikan kepingan ke separuh; Mengurangkan kawasan dengan separuh; Meningkatkan kiraan dua kali; Kod pemacu", "code": "def maxSheets ( A , B ) : NEW_LINE INDENT area = A * B NEW_LINE count = 1 NEW_LINE while ( area % 2 == 0 ) : NEW_LINE INDENT area //= 2 NEW_LINE count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT A = 5 NEW_LINE B = 10 NEW_LINE print ( maxSheets ( A , B ) ) NEW_LINE"}
{"text": "Bilangan langkah minimum yang diperlukan untuk mencapai asal dari titik tertentu | berfungsi untuk mencari langkah minimum yang diperlukan untuk mencapai asal dari (a, b); Menyimpan bilangan minimum bergerak; Periksa sama ada perbezaan mutlak ialah 1 atau 0; Simpan minimum a, b; Simpan maksimum a, b; Jawapannya; Kod pemacu; Diberikan Co - ordinat; Panggilan fungsi", "code": "def findMinMoves ( a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( a == b or abs ( a - b ) == 1 ) : NEW_LINE INDENT ans = a + b NEW_LINE DEDENT else : NEW_LINE INDENT k = min ( a , b ) NEW_LINE j = max ( a , b ) NEW_LINE ans = 2 * k + 2 * ( j - k ) - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = 3 , 5 NEW_LINE findMinMoves ( a , b ) NEW_LINE DEDENT"}
{"text": "Kira walaupun jumlah pasangan yang mungkin dengan memilih dua bilangan bulat dari dua julat yang diberikan masing -masing | Berfungsi untuk mengira walaupun jumlah pasangan dalam julat yang diberikan; Menyimpan kiraan nombor antara 1 hingga x; Menyimpan kiraan nombor ganjil antara 1 hingga x; Menyimpan kiraan nombor antara 1 hingga y; Menyimpan kiraan nombor ganjil antara 1 hingga y; Menyimpan kiraan pasangan yang mempunyai jumlah wang; Mengembalikan kiraan pasangan yang mempunyai jumlah; Kod pemacu", "code": "def cntEvenSumPairs ( X , Y ) : NEW_LINE INDENT cntXEvenNums = X / 2 NEW_LINE cntXOddNums = ( X + 1 ) / 2 NEW_LINE cntYEvenNums = Y / 2 NEW_LINE cntYOddNums = ( Y + 1 ) / 2 NEW_LINE cntPairs = ( ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ) NEW_LINE return cntPairs NEW_LINE DEDENT X = 2 NEW_LINE Y = 3 NEW_LINE print ( cntEvenSumPairs ( X , Y ) ) NEW_LINE"}
{"text": "Kurangkan elemen array yang diperlukan untuk ditingkatkan atau diturunkan untuk menukar array yang diberikan ke dalam siri Fibonacci | Program Python3 untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum bergerak untuk membuat urutan siri Fibonacci; Jika bilangan elemen kurang daripada 3; Memulakan nilai hasilnya; Cuba semua permutasi dua elemen pertama; Nilai elemen pertama selepas operasi; Nilai elemen kedua selepas operasi; Hitung bilangan gerakan untuk unsur -unsur array; Elemen pada indeks IDX; Sekiranya tidak mungkin untuk menukar elemen dalam satu langkah; Jika tidak; Mengemas kini jawapannya; Kembalikan jawapannya; Kod pemacu", "code": "import sys NEW_LINE def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( - 1 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 ) : NEW_LINE INDENT num1 = arr [ 0 ] + i NEW_LINE num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE for idx in range ( 2 , N ) : NEW_LINE INDENT num = num1 + num2 NEW_LINE if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 17 , 27 ] NEW_LINE print ( minMoves ( arr ) ) NEW_LINE DEDENT"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; Melangkah ke atas setiap pertanyaan; Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array dan mengira jumlah ungkapan; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "def querySum ( arr , N , Q , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 5 , 4 ] ; NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE DEDENT"}
{"text": "Kirakan bitwise atau dua bilangan bulat dari nilai bitwise dan bitwise mereka yang diberikan | Fungsi untuk mengira bitwise atau dari bitwise xor dan bitwise dan nilai -nilai; Kod pemacu", "code": "def findBitwiseORGivenXORAND ( X , Y ) : NEW_LINE INDENT return X + Y NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 5 NEW_LINE Y = 2 NEW_LINE print ( findBitwiseORGivenXORAND ( X , Y ) ) NEW_LINE DEDENT"}
{"text": "Semak jika nilai yang diberikan dapat dicapai dari nilai lain dalam barisan bulat oleh k | Berfungsi untuk mengembalikan GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa B boleh digunakan dari A dengan lompatan elemen K dalam barisan bulat; Cari GCD N dan K; If A - B is divisible by gcd then prYes ; Jika tidak; Kod pemacu; Panggilan fungsi", "code": "def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def canReach ( N , A , B , K ) : NEW_LINE INDENT gcd = GCD ( N , K ) NEW_LINE if ( abs ( A - B ) % gcd == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE A = 2 NEW_LINE B = 1 NEW_LINE K = 2 NEW_LINE canReach ( N , A , B , K ) NEW_LINE DEDENT"}
{"text": "Count subarrays mempunyai jumlah yang sama dengan panjangnya | Tetapkan 2 | Program Python3 untuk pendekatan di atas; Fungsi yang mengira subarray dengan jumlah elemennya sebagai panjangnya; Simpan kiraan elemen sehingga elemen semasa dengan panjang i; Menyimpan kiraan akhir subarray; Menyimpan jumlah awalan; Jika saiz subarray adalah 1; Melelehkan array; Cari jumlahnya; Kekerapan kemas kini dalam peta; Cetak jumlah kiraan; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi", "code": "from collections import defaultdict NEW_LINE def countOfSubarray ( arr , N ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE answer = 0 NEW_LINE sum = 0 NEW_LINE mp [ 1 ] += 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE answer += mp [ sum - i ] NEW_LINE mp [ sum - i ] += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE countOfSubarray ( arr , N ) NEW_LINE DEDENT"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Menyimpan jumlah unsur set1; Menyimpan jumlah unsur set2; Melintasi nombor semulajadi n pertama; Semak sama ada jumlah unsur set1 kurang daripada atau sama dengan jumlah unsur set2; Kod pemacu", "code": "def minAbsDiff ( N ) : NEW_LINE INDENT sumSet1 = 0 NEW_LINE sumSet2 = 0 NEW_LINE for i in reversed ( range ( N + 1 ) ) : NEW_LINE INDENT if sumSet1 <= sumSet2 : NEW_LINE sumSet1 = sumSet1 + i NEW_LINE else : NEW_LINE sumSet2 = sumSet2 + i NEW_LINE DEDENT return abs ( sumSet1 - sumSet2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( minAbsDiff ( N ) ) NEW_LINE"}
{"text": "Semak jika nombor adalah perdana terbalik terbalik, cermin dibalik dan cermin terbalik terbalik | Fungsi untuk memeriksa sama ada n mengandungi digit 0, 1, 2, 5, 8 sahaja; Ekstrak digit n; Kembali palsu jika mana -mana digit ini hadir; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Semak semua faktor; Fungsi untuk memeriksa sama ada n adalah perdana dalam semua bentuk yang dikehendaki; Kod pemacu", "code": "def checkDigits ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r == 3 or r == 4 or r == 6 or r == 7 or r == 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isAllPrime ( n ) : NEW_LINE INDENT return isPrime ( n ) and checkDigits ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 101 NEW_LINE if ( isAllPrime ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Kos minimum diperlukan untuk menjana urutan pendakap seimbang | Fungsi untuk mengira kos minimum yang diperlukan untuk menjana urutan pendakap yang seimbang; Menyimpan kiraan kurungan terbuka tidak seimbang; Menyimpan kiraan kurungan tertutup yang tidak seimbang; Menyimpan kiraan kurungan terbuka; Menyimpan kiraan kurungan tertutup; Jika pendakap terbuka ditemui; Jika tidak; Sekiranya tiada kurungan terbuka tidak seimbang; Meningkatkan kiraan kurungan tertutup yang tidak seimbang; Jika tidak; Mengurangkan kiraan kurungan terbuka yang tidak seimbang; Meningkatkan kiraan kurungan tertutup; Mengira batas kos minimum yang lebih rendah; Mengurangkan kurungan terbuka atau tertutup yang berlebihan untuk mengelakkan mengira mereka dua kali; Kemas kini jawapan dengan menambahkan minimum mengeluarkan kedua -dua kurungan terbuka dan tertutup yang tidak seimbang atau memasukkan kurungan tidak seimbang tertutup ke hujung rentetan; Hasilnya; Kod pemacu", "code": "def minCost ( str , a , b ) : NEW_LINE INDENT openUnbalanced = 0 ; NEW_LINE closedUnbalanced = 0 ; NEW_LINE openCount = 0 ; NEW_LINE closedCount = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT openUnbalanced += 1 ; NEW_LINE openCount += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( openUnbalanced == 0 ) : NEW_LINE INDENT closedUnbalanced += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT openUnbalanced -= 1 ; NEW_LINE DEDENT closedCount += 1 ; NEW_LINE DEDENT DEDENT result = a * ( abs ( openCount - closedCount ) ) ; NEW_LINE if ( closedCount > openCount ) : NEW_LINE INDENT closedUnbalanced -= ( closedCount - openCount ) ; NEW_LINE DEDENT if ( openCount > closedCount ) : NEW_LINE INDENT openUnbalanced -= ( openCount - closedCount ) ; NEW_LINE DEDENT result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; NEW_LINE print ( result ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : str = \" ) ) ( ) ( ( ) ( ) ( \" ; NEW_LINE INDENT A = 1 ; B = 3 ; NEW_LINE minCost ( str , A , B ) ; NEW_LINE DEDENT"}
{"text": "Count of permutasi seperti jumlah nombor k dari julat yang diberikan adalah | Berfungsi untuk mengembalikan bilangan semua permutasi seperti jumlah nombor k dalam julat adalah walaupun; Cari jumlah kiraan nombor walaupun dan ganjil dalam julat yang diberikan; ITERATE LOOP K TIMES DAN UPDATE EVER_SUM & ODD_SUM Menggunakan nilai sebelumnya; Kemas kini prev_even dan odd_sum; Malah jumlah; Jumlah ganjil; Kembali even_sum; Diberikan julat; Panjang permutasi; Panggilan fungsi", "code": "def countEvenSum ( low , high , k ) : NEW_LINE INDENT even_count = high / 2 - ( low - 1 ) / 2 NEW_LINE odd_count = ( high + 1 ) / 2 - low / 2 NEW_LINE even_sum = 1 NEW_LINE odd_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prev_even = even_sum NEW_LINE prev_odd = odd_sum NEW_LINE even_sum = ( ( prev_even * even_count ) + ( prev_odd * odd_count ) ) NEW_LINE odd_sum = ( ( prev_even * odd_count ) + ( prev_odd * even_count ) ) NEW_LINE DEDENT print ( int ( even_sum ) ) NEW_LINE DEDENT low = 4 ; NEW_LINE high = 5 ; NEW_LINE K = 3 ; NEW_LINE countEvenSum ( low , high , K ) ; NEW_LINE"}
{"text": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Tetapkan 2 | Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Cetak jawapannya; Kod pemacu", "code": "def count ( n , k ) : NEW_LINE INDENT count = ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; NEW_LINE print ( count ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 ; NEW_LINE k = 1 ; NEW_LINE count ( n , k ) ; NEW_LINE DEDENT"}
{"text": "Jumlah pembahagi terbesar nombor sehingga tidak dibahagikan dengan nombor perdana p | Berfungsi untuk mencari jumlah pembahagi terbesar nombor dalam julat 1 hingga n tidak boleh dibahagikan dengan nombor perdana p; Jumlah jumlah sehingga n; Jika tidak ada beberapa p yang ada sehingga n; Jika hanya p sendiri berada dalam lingkungan 1 hingga n; Jumlah mereka yang boleh dibahagikan dengan p; Panggilan fungsi rekursif untuk mencari jumlah untuk N / P; Kod pemacu; Diberikan n dan p; Panggilan fungsi", "code": "def func ( N , P ) : NEW_LINE INDENT sumUptoN = ( N * ( N + 1 ) / 2 ) ; NEW_LINE sumOfMultiplesOfP = 0 ; NEW_LINE if ( N < P ) : NEW_LINE INDENT return sumUptoN ; NEW_LINE DEDENT elif ( ( N / P ) == 1 ) : NEW_LINE INDENT return sumUptoN - P + 1 ; NEW_LINE DEDENT sumOfMultiplesOfP = ( ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ) ; NEW_LINE return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 ; NEW_LINE P = 5 ; NEW_LINE print ( func ( N , P ) ) ; NEW_LINE DEDENT"}
{"text": "Kira peralihan kanan untuk setiap elemen array berada dalam kedudukan yang disusun | Berfungsi untuk mencari peralihan yang betul yang diperlukan untuk setiap elemen untuk mencapai kedudukan array yang disusun dalam []; Kedai yang diperlukan bilangan peralihan untuk setiap elemen; Jika elemen berada pada kedudukan yang disusun; Jika tidak; Kirakan peralihan kanan; Cetak peralihan masing -masing; Kod pemacu", "code": "def findShifts ( A , N ) : NEW_LINE INDENT shift = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == A [ i ] - 1 ) : NEW_LINE INDENT shift [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT shift [ i ] = ( A [ i ] - 1 - i + N ) % N NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( shift [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 3 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findShifts ( arr , N ) NEW_LINE DEDENT"}
{"text": "Membina matriks dengan jumlah yang sama dengan jumlah unsur pepenjuru | Berfungsi untuk membina matriks dengan jumlah pepenjuru yang sama dengan jumlah matriks; Jika kedudukan pepenjuru; Elemen positif; Elemen negatif; Kod pemacu", "code": "def constructmatrix ( N ) : NEW_LINE INDENT check = bool ( True ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( 1 , end = \" ▁ \" ) NEW_LINE DEDENT elif ( check ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE check = bool ( False ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 2 , end = \" ▁ \" ) NEW_LINE check = bool ( True ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE constructmatrix ( 5 ) NEW_LINE"}
{"text": "Kiraan minimum nombor yang diperlukan dengan unit digit x yang merangkum sehingga n | Fungsi untuk mengira dan mengembalikan bilangan minimum kali nombor dengan unit digit X perlu ditambah untuk mendapatkan jumlah n; Kirakan bilangan penambahan yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Berfungsi untuk mengembalikan nombor minimum yang diperlukan untuk mewakili n; Kedai Unit Digit N; Penambahan minimum x yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Jika tidak; Jika n lebih besar daripada atau sama dengan (x * kali); Kiraan minimum nombor yang diperlukan untuk mewakili n; Perwakilan tidak mungkin; Kod pemacu", "code": "def check ( unit_digit , X ) : NEW_LINE INDENT for times in range ( 1 , 11 ) : NEW_LINE INDENT digit = ( X * times ) % 10 NEW_LINE if ( digit == unit_digit ) : NEW_LINE INDENT return times NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def getNum ( N , X ) : NEW_LINE INDENT unit_digit = N % 10 NEW_LINE times = check ( unit_digit , X ) NEW_LINE if ( times == - 1 ) : NEW_LINE INDENT return times NEW_LINE DEDENT else : NEW_LINE INDENT if ( N >= ( times * X ) ) : NEW_LINE INDENT return times NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT N = 58 NEW_LINE X = 7 NEW_LINE print ( getNum ( N , X ) ) NEW_LINE"}
{"text": "Bilangan minimum mata yang diperlukan untuk menampung semua blok 2 | Berfungsi untuk mencari bilangan minimum mata yang diperlukan untuk menampung grid; Jika bilangan blok adalah juga; Mengembalikan mata minimum; Kod pemacu; Diberikan saiz grid; Panggilan fungsi", "code": "def minPoints ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( ( n % 2 != 0 ) and ( m % 2 != 0 ) ) : NEW_LINE INDENT ans = ( ( n * m ) // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n * m ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE M = 7 NEW_LINE print ( minPoints ( N , M ) ) NEW_LINE DEDENT"}
{"text": "String lexicographical terbesar dengan paling banyak unsur berturut -turut K | Fungsi untuk mencari rentetan leksikografi terbesar dengan kekangan yang diberikan. ; Vektor yang mengandungi kekerapan setiap aksara. ; Menetapkan kekerapan kepada; Kosongkan rentetan jenis kelas rentetan; Gelung untuk melangkah ke atas keutamaan maksimum terlebih dahulu. ; Jika kekerapan lebih besar daripada atau sama dengan k. ; Pembolehubah sementara untuk beroperasi di tempat k. ; menggabungkan dengan rentetan yang dihasilkan. ; Pengendalian kes K dengan menyesuaikan dengan unsur keutamaan yang lebih kecil. ; Keadaan untuk mengesahkan sama ada indeks j mempunyai kekerapan yang lebih besar daripada 0; ; Jika tiada elemen sedemikian dijumpai daripada rentetan tidak dapat diproses lagi. ; Jika kekerapan lebih besar daripada 0 dan kurang daripada k. ; Di sini kita tidak perlu memperbaiki kriteria elemen berturut -turut. ; Jika tidak, periksa elemen seterusnya yang mungkin. ; Kod pemacu", "code": "def getLargestString ( s , k ) : NEW_LINE INDENT frequency_array = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT frequency_array [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = \" \" NEW_LINE i = 25 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( frequency_array [ i ] > k ) : NEW_LINE INDENT temp = k NEW_LINE st = chr ( i + ord ( ' a ' ) ) NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT ans += st NEW_LINE temp -= 1 NEW_LINE DEDENT frequency_array [ i ] -= k NEW_LINE j = i - 1 NEW_LINE while ( frequency_array [ j ] <= 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( frequency_array [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT str1 = chr ( j + ord ( ' a ' ) ) NEW_LINE ans += str1 NEW_LINE frequency_array [ j ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( frequency_array [ i ] > 0 ) : NEW_LINE INDENT temp = frequency_array [ i ] NEW_LINE frequency_array [ i ] -= temp NEW_LINE st = chr ( i + ord ( ' a ' ) ) NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT ans += st NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" xxxxzza \" NEW_LINE k = 3 NEW_LINE print ( getLargestString ( S , k ) ) NEW_LINE DEDENT"}
{"text": "Operasi minimum untuk menjadikan semua elemen sama menggunakan array kedua | Berfungsi untuk mencari operasi minimum yang diperlukan untuk membuat semua elemen array sama; Elemen minimum a; Melintasi semua nilai akhir; Pembolehubah yang menunjukkan sama ada semua elemen boleh ditukar kepada x atau tidak; Jumlah operasi; Melintasi semua elemen array; Semua elemen tidak boleh ditukar kepada x; Kod pemacu", "code": "def minOperations ( a , b , n ) : NEW_LINE INDENT minA = min ( a ) ; NEW_LINE for x in range ( minA , - 1 , - 1 ) : NEW_LINE INDENT check = True ; NEW_LINE operations = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x % b [ i ] == a [ i ] % b [ i ] ) : NEW_LINE INDENT operations += ( a [ i ] - x ) / b [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT check = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( check ) : NEW_LINE INDENT return operations ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE A = [ 5 , 7 , 10 , 5 , 15 ] ; NEW_LINE B = [ 2 , 2 , 1 , 3 , 5 ] ; NEW_LINE print ( int ( minOperations ( A , B , N ) ) ) ; NEW_LINE DEDENT"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "def getLargestSum ( N ) : NEW_LINE INDENT max_sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i * j % ( i + j ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , i + j ) NEW_LINE DEDENT DEDENT DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE max_sum = getLargestSum ( N ) NEW_LINE print ( max_sum ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan jumlah array selepas mengalikan awalan dan akhiran oleh | Algoritma Kadane untuk mencari jumlah subarray maksimum; Gelung untuk mencari jumlah array subarray maksimum dalam array yang diberikan; Berfungsi untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran oleh - 1; Jumlah jumlah intital; Gelung untuk mencari jumlah maksimum array; Nilai maksimum; Kod pemacu", "code": "def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 10 ** 9 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def maxSum ( a , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += a [ i ] NEW_LINE DEDENT X = maxSubArraySum ( a , n ) NEW_LINE return 2 * X - S NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 1 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE max_sum = maxSum ( a , n ) NEW_LINE print ( max_sum ) NEW_LINE DEDENT"}
{"text": "Count of Prima yang menarik sehingga n | Program Python3 untuk mencari bilangan prima yang menarik sehingga N; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Jika n boleh dibahagikan dengan mana -mana nombor antara 2 dan sqrt (n), ia bukan perdana; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Cari povalue terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk mencari bilangan prima yang menarik kurang daripada sama dengan n. ; Periksa sama ada nombor itu adalah perdana atau tidak; Berulang untuk nilai b; Periksa syarat untuk a; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if flag == 1 else False ) NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE INDENT if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan nombor dengan membalikkan kebanyakan bit k | Pelaksanaan Python pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan nombor yang dimaksimumkan dengan membalikkan atmost k bit; Bilangan bit dalam n; Cari perwakilan binari n; Untuk mengira bilangan 0 s terbalik; Mengembalikan setara perpuluhan nombor yang dimaksimumkan; Kod pemacu", "code": "import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def maxNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE cn = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( a [ i ] == 0 and cn < k ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE cn = cn + 1 NEW_LINE DEDENT DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 4 NEW_LINE k = 1 NEW_LINE print ( maxNum ( n , k ) ) NEW_LINE"}
{"text": "Cari berikutnya dengan jumlah yang diberikan dalam urutan superincreasing | Berfungsi untuk mencari seterusnya yang diperlukan; Elemen semasa tidak boleh menjadi sebahagian daripada berikutnya yang diperlukan; Termasuk elemen semasa dalam seterusnya yang diperlukan supaya mengemas kini jumlah; Cetak unsur -unsur berikutnya yang diperlukan; Jika elemen semasa dimasukkan ke dalam berikutnya; Kod pemacu", "code": "def findSubSeq ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sum < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 17 , 25 , 46 , 94 , 201 , 400 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sum = 272 ; NEW_LINE findSubSeq ( arr , n , sum ) ; NEW_LINE DEDENT"}
{"text": "Cari abjad yang paling bernilai dalam rentetan | Pelaksanaan Python pendekatan; Berfungsi untuk mengembalikan abjad bernilai maksimum; Tetapkan kejadian pertama dan terakhir semua aksara kepada - 1; Kemas kini kejadian watak -watak; Hanya menetapkan kejadian pertama jika ia tidak telah ditetapkan; Untuk menyimpan hasilnya; Untuk setiap abjad; Jika abjad semasa tidak muncul dalam rentetan yang diberikan; Jika watak semasa mempunyai nilai tertinggi setakat ini; Kod pemacu", "code": "MAX = 26 NEW_LINE def maxAlpha ( str , len ) : NEW_LINE INDENT first = [ - 1 for x in range ( MAX ) ] NEW_LINE last = [ - 1 for x in range ( MAX ) ] NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT index = ord ( str [ i ] ) - 97 NEW_LINE if ( first [ index ] == - 1 ) : NEW_LINE INDENT first [ index ] = i NEW_LINE DEDENT last [ index ] = i NEW_LINE DEDENT ans = - 1 NEW_LINE maxVal = - 1 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT if ( first [ i ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ( last [ i ] - first [ i ] ) > maxVal ) : NEW_LINE INDENT maxVal = last [ i ] - first [ i ] ; NEW_LINE ans = i NEW_LINE DEDENT DEDENT return chr ( ans + 97 ) NEW_LINE DEDENT str = \" abbba \" NEW_LINE len = len ( str ) NEW_LINE print ( maxAlpha ( str , len ) ) NEW_LINE"}
{"text": "Pertanyaan untuk bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array | Pelaksanaan Python pendekatan; Berfungsi untuk melakukan pertanyaan untuk mencari bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array; Periksa sama ada elemen semasa sudah dilawati atau tidak; Jika tidak melawat kaunter semasa dan kenaikannya dan semak semak sebagai 1; Jika tidak, jika dikunjungi hanya menyimpan kaunter semasa; Melakukan pertanyaan; Kod pemacu", "code": "MAX = 100001 ; NEW_LINE def find_distinct ( a , n , q , queries ) : NEW_LINE INDENT check = [ 0 ] * MAX ; NEW_LINE idx = [ 0 ] * MAX ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( check [ a [ i ] ] == 0 ) : NEW_LINE INDENT idx [ i ] = cnt ; NEW_LINE check [ a [ i ] ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT idx [ i ] = cnt - 1 ; NEW_LINE DEDENT DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT m = queries [ i ] ; NEW_LINE print ( idx [ m ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE queries = [ 0 , 3 , 5 , 7 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE find_distinct ( a , n , q , queries ) ; NEW_LINE"}
{"text": "Tukar Integer X diberikan kepada Borang 2 ^ n | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan kiraan operasi yang diperlukan; Untuk menyimpan kuasa 2; Pembolehubah sementara untuk menyimpan X; Untuk menyimpan indeks nombor yang lebih kecil daripada x; Untuk menyimpan kiraan operasi; Menyimpan indeks nombor dalam bentuk 2 ^ n - 1; Jika x sudah ada dalam bentuk 2 ^ n - 1 maka tiada operasi diperlukan; Jika nombor kurang daripada x meningkatkan indeks; Kirakan semua nilai (x xor 2 ^ n - 1) untuk semua yang mungkin n; Hanya mengambil nilai yang lebih dekat dengan nombor; Jika nombor berada dalam bentuk 2 ^ n - 1 maka pecah; Mengembalikan kiraan operasi yang diperlukan untuk mendapatkan nombor; Kod pemacu", "code": "MAX = 24 ; NEW_LINE def countOp ( x ) : NEW_LINE INDENT arr = [ 0 ] * MAX ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] * 2 ; NEW_LINE DEDENT temp = x ; NEW_LINE flag = True ; NEW_LINE ans = 0 ; NEW_LINE operations = 0 ; NEW_LINE flag2 = False ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] - 1 == x ) : NEW_LINE INDENT flag2 = True ; NEW_LINE DEDENT if ( arr [ i ] > x ) : NEW_LINE INDENT ans = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( flag ) : NEW_LINE INDENT if ( arr [ ans ] < x ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT operations += 1 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT take = x ^ ( arr [ i ] - 1 ) ; NEW_LINE if ( take <= arr [ ans ] - 1 ) : NEW_LINE INDENT if ( take > temp ) : NEW_LINE INDENT temp = take ; NEW_LINE DEDENT DEDENT DEDENT if ( temp == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT temp += 1 ; NEW_LINE operations += 1 ; NEW_LINE x = temp ; NEW_LINE if ( x == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT DEDENT return operations ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 39 ; NEW_LINE print ( countOp ( x ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan minimum operasi yang diberikan untuk mengurangkan array ke 0 elemen | Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Hitung kekerapan setiap elemen; Elemen maksimum dari array; Cari semua gandaan i; Padamkan gandaan; Meningkatkan operasi; Kod pemacu", "code": "def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Minimum LCM dan GCD mungkin di antara semua sub | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan GCD minimum di kalangan semua subarray; GCD minimum di antara semua sub -tatasusunan akan menjadi GCD dari semua elemen array; Berfungsi untuk mengembalikan LCM minimum di kalangan semua subarray; LCM minimum di antara semua sub - tatasusunan akan menjadi elemen minimum dari array; Kod pemacu", "code": "from math import gcd NEW_LINE def minGCD ( arr , n ) : NEW_LINE INDENT minGCD = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT minGCD = gcd ( minGCD , arr [ i ] ) ; NEW_LINE DEDENT return minGCD ; NEW_LINE DEDENT def minLCM ( arr , n ) : NEW_LINE INDENT minLCM = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minLCM = min ( minLCM , arr [ i ] ) ; NEW_LINE DEDENT return minLCM ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 66 , 14 , 521 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" LCM ▁ = ▁ \" , minLCM ( arr , n ) , \" , ▁ GCD ▁ = \" , minGCD ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Bentuk rentetan terkecil secara lexicographically dengan penggantian minimum yang mempunyai bilangan yang sama 0 s, 1 s dan 2 s | Pelaksanaan Python3 pendekatan; Fungsi yang mengembalikan rentetan terkecil lexicographically yang diubahsuai selepas melakukan bilangan minimum operasi yang diberikan; Menyimpan frekuensi awal aksara 0 s, 1 s dan 2 s; Menyimpan bilangan aksara yang diproses sehingga titik setiap jenis; Bilangan aksara yang diperlukan setiap jenis; Jika jenis semasa telah membatalkan bilangan aksara, tidak perlu melakukan apa -apa operasi; Proses semua 3 kes; Semak 1 pertama; Lain 2; Di sini kita perlu menyemak yang diproses [1] hanya untuk 2 kerana 0 adalah kurang daripada 1 dan kita boleh menggantikannya pada bila -bila masa; Di sini kita boleh menggantikan 2 dengan 0 dan 1 bila -bila masa; Simpan kiraan aksara yang diproses setiap jenis; Kod pemacu", "code": "import math NEW_LINE def formStringMinOperations ( ss ) : NEW_LINE INDENT count = [ 0 ] * 3 ; NEW_LINE s = list ( ss ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 ; NEW_LINE DEDENT processed = [ 0 ] * 3 ; NEW_LINE reqd = math . floor ( len ( s ) / 3 ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( count [ ord ( s [ i ] ) - ord ( '0' ) ] == reqd ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( s [ i ] == '0' and count [ 0 ] > reqd and processed [ 0 ] >= reqd ) : NEW_LINE INDENT if ( count [ 1 ] < reqd ) : NEW_LINE INDENT s [ i ] = '1' ; NEW_LINE count [ 1 ] += 1 ; NEW_LINE count [ 0 ] -= 1 ; NEW_LINE DEDENT elif ( count [ 2 ] < reqd ) : NEW_LINE INDENT s [ i ] = '2' ; NEW_LINE count [ 2 ] += 1 ; NEW_LINE count [ 0 ] -= 1 ; NEW_LINE DEDENT DEDENT if ( s [ i ] == '1' and count [ 1 ] > reqd ) : NEW_LINE INDENT if ( count [ 0 ] < reqd ) : NEW_LINE INDENT s [ i ] = '0' ; NEW_LINE count [ 0 ] += 1 ; NEW_LINE count [ 1 ] -= 1 ; NEW_LINE DEDENT elif ( count [ 2 ] < reqd and processed [ 1 ] >= reqd ) : NEW_LINE INDENT s [ i ] = '2' ; NEW_LINE count [ 2 ] += 1 ; NEW_LINE count [ 1 ] -= 1 ; NEW_LINE DEDENT DEDENT if ( s [ i ] == '2' and count [ 2 ] > reqd ) : NEW_LINE INDENT if ( count [ 0 ] < reqd ) : NEW_LINE INDENT s [ i ] = '0' ; NEW_LINE count [ 0 ] += 1 ; NEW_LINE count [ 2 ] -= 1 ; NEW_LINE DEDENT elif ( count [ 1 ] < reqd ) : NEW_LINE INDENT s [ i ] = '1' ; NEW_LINE count [ 1 ] += 1 ; NEW_LINE count [ 2 ] -= 1 ; NEW_LINE DEDENT DEDENT processed [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 ; NEW_LINE DEDENT return ' ' . join ( s ) ; NEW_LINE DEDENT s = \"011200\" ; NEW_LINE print ( formStringMinOperations ( s ) ) ; NEW_LINE"}
{"text": "Bilangan minimum swap bersebelahan untuk mengatur unsur -unsur yang sama bersama -sama | Berfungsi untuk mencari swap minimum; Arahan yang dikunjungi untuk memeriksa sama ada nilai sudah dilihat; Jika arr [i] dilihat kali pertama; menyimpan bilangan swap yang diperlukan untuk mencari kedudukan yang betul dari rakan kongsi elemen semasa; Kiraan kenaikan hanya jika elemen semasa belum dikunjungi (jika dikunjungi, bermakna ia telah diletakkan pada kedudukan yang betul); Jika rakan kongsi elemen semasa dijumpai; Kod pemacu", "code": "def findMinimumAdjacentSwaps ( arr , N ) : NEW_LINE INDENT visited = [ False ] * ( N + 1 ) NEW_LINE minimumSwaps = 0 NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT if ( visited [ arr [ i ] ] == False ) : NEW_LINE INDENT visited [ arr [ i ] ] = True NEW_LINE count = 0 NEW_LINE for j in range ( i + 1 , 2 * N ) : NEW_LINE INDENT if ( visited [ arr [ j ] ] == False ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT minimumSwaps += count NEW_LINE DEDENT DEDENT DEDENT DEDENT return minimumSwaps NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE N //= 2 NEW_LINE print ( findMinimumAdjacentSwaps ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Nombor Palindromic Terbesar dengan Permuting Digits | Program Python3 untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; Berfungsi untuk memeriksa sama ada nombor boleh dibentuk untuk membentuk nombor palindrome; Mengira kejadian nombor yang ganjil; Sekiranya kejadian ganjil; jika nombor melebihi 1; Berfungsi untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; panjang rentetan; peta yang menandakan kejadian nombor; Semak kemungkinan nombor palindromik; array rentetan yang menyimpan nombor palindromik yang terbesar; penunjuk depan; Ramuan bermula dari 9 hingga 0 dan letakkan nombor yang lebih besar di depan dan ganjil di tengah; Sekiranya berlakunya nombor adalah ganjil; Letakkan satu nombor ganjil di tengah; mengurangkan kiraan; Letakkan seluruh nombor dengan tamak; Jika semua nombor berlaku walaupun masa, maka letakkan dengan tamak; Letakkan tamak di hadapan; 2 nombor diletakkan, jadi mengurangkan kiraan; meningkatkan kedudukan meletakkan; Cetak rentetan terbesar yang terbentuk; Kod pemacu", "code": "from collections import defaultdict NEW_LINE def possibility ( m , length , s ) : NEW_LINE INDENT countodd = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if m [ int ( s [ i ] ) ] & 1 : NEW_LINE INDENT countodd += 1 NEW_LINE DEDENT if countodd > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def largestPalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT m [ int ( s [ i ] ) ] += 1 NEW_LINE DEDENT if possibility ( m , l , s ) == False : NEW_LINE INDENT print ( \" Palindrome ▁ cannot ▁ be ▁ formed \" ) NEW_LINE return NEW_LINE DEDENT largest = [ None ] * l NEW_LINE front = 0 NEW_LINE for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if m [ i ] & 1 : NEW_LINE INDENT largest [ l // 2 ] = chr ( i + 48 ) NEW_LINE m [ i ] -= 1 NEW_LINE while m [ i ] > 0 : NEW_LINE INDENT largest [ front ] = chr ( i + 48 ) NEW_LINE largest [ l - front - 1 ] = chr ( i + 48 ) NEW_LINE m [ i ] -= 2 NEW_LINE front += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while m [ i ] > 0 : NEW_LINE INDENT largest [ front ] = chr ( i + 48 ) NEW_LINE largest [ l - front - 1 ] = chr ( i + 48 ) NEW_LINE m [ i ] -= 2 NEW_LINE front += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , l ) : NEW_LINE INDENT print ( largest [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"313551\" NEW_LINE largestPalindrome ( s ) NEW_LINE DEDENT"}
{"text": "Swap minimum untuk mengimbangi pendakap | Fungsi untuk mengira swap yang diperlukan; Jejaki '[; Untuk mengira bilangan yang ditemui '['; Untuk mengesan kedudukan seterusnya '[' dalam POS; Untuk menyimpan hasil; Kiraan kenaikan dan bergerak P ke kedudukan seterusnya; Kami telah menemui bahagian rentetan yang tidak seimbang; Jumlah kenaikan dengan bilangan swap yang diperlukan i. e. kedudukan seterusnya '[' - kedudukan semasa; Tetapkan semula kiraan kepada 1; Kod pemacu", "code": "def swapCount ( s ) : NEW_LINE ' NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' [ ' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE p = 0 NEW_LINE sum = 0 NEW_LINE s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' [ ' ) : NEW_LINE INDENT count += 1 NEW_LINE p += 1 NEW_LINE DEDENT elif ( s [ i ] == ' ] ' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count < 0 ) : NEW_LINE INDENT sum += pos [ p ] - i NEW_LINE s [ i ] , s [ pos [ p ] ] = ( s [ pos [ p ] ] , s [ i ] ) NEW_LINE p += 1 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT s = \" [ ] ] [ ] [ \" NEW_LINE print ( swapCount ( s ) ) NEW_LINE s = \" [ [ ] [ ] ] \" NEW_LINE print ( swapCount ( s ) ) NEW_LINE"}
{"text": "Kos minimum untuk memotong papan ke dalam dataran | Kaedah mengembalikan kos minimum untuk memecahkan papan ke dalam kotak m * n; menyusun kos mendatar dalam urutan terbalik; menyusun kos menegak dalam urutan terbalik; memulakan lebar semasa sebagai 1; gelung sehingga satu atau kedua -dua kos kos diproses; meningkatkan kiraan bahagian mendatar semasa dengan 1; meningkatkan kiraan bahagian menegak semasa dengan 1; gelung untuk array mendatar, jika kekal; gelung untuk pelbagai menegak, jika kekal; Program Pemandu", "code": "def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 ; vert = 1 NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT m = 6 ; n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE"}
{"text": "Kurangkan kiraan aksara yang akan ditambah atau dikeluarkan untuk membuat pengulangan rentetan substring yang sama | Berfungsi untuk mencari minimum tiga nombor; Berfungsi untuk mencari operasi bilangan minimum yang diperlukan untuk menukar string str1 ke str2 menggunakan operasi; Menyimpan hasil subproblem; Isi dp [] [] dengan cara bawah; Jika str1 kosong, masukkan semua aksara string str2; Operasi minimum ialah J; Jika str2 kosong, maka keluarkan semua aksara string str2; Operasi minimum ialah i; Jika watak terakhir adalah sama, maka abaikan watak terakhir; Jika watak terakhir berbeza, maka cari minimum; Lakukan salah satu sisipan, keluarkan dan ganti; Mengembalikan bilangan langkah minimum yang diperlukan; Berfungsi untuk mencari bilangan langkah minimum untuk mengubah suai rentetan sedemikian rupa sehingga separuh pertama dan separuh kedua menjadi sama; Menyimpan bilangan minimum operasi yang diperlukan; Melintasi rentetan yang diberikan; Cari operasi minimum; Kemas kini ANS; Cetak hasilnya; Kod pemacu", "code": "def getMin ( x , y , z ) : NEW_LINE INDENT return min ( min ( x , y ) , z ) NEW_LINE DEDENT def editDistance ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT def minimumSteps ( S , N ) : NEW_LINE INDENT ans = 10 ** 10 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S1 = S [ : i ] NEW_LINE S2 = S [ i : ] NEW_LINE count = editDistance ( S1 , S2 , len ( S1 ) , len ( S2 ) ) NEW_LINE ans = min ( ans , count ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT S = \" aabb \" NEW_LINE N = len ( S ) NEW_LINE minimumSteps ( S , N ) NEW_LINE"}
{"text": "Kurangkan operasi untuk mengurangkan n hingga 2 dengan berulang kali mengurangkan 3 atau membahagikan dengan 5 | Berfungsi untuk mencari bilangan minimum operasi untuk mengurangkan n hingga 2 dengan membahagikan n dengan 5 atau penurunan sebanyak 3; Memulakan array DP; Memulakan array dp []; Untuk n = 2 bilangan operasi yang diperlukan adalah sifar; Melangkah ke atas julat [1, n]; Jika ia tidak mungkin untuk membuat n semasa; Kalikan dengan 5; Menambah nilai 3; Memeriksa jika tidak mungkin untuk membuat nombor sebagai 2; Mengembalikan bilangan operasi minimum; Kod pemacu", "code": "def minimumOperations ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] = 1000000000 NEW_LINE DEDENT dp [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT if ( dp [ i ] == 1000000000 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i * 5 <= N ) : NEW_LINE INDENT dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) NEW_LINE DEDENT if ( i + 3 <= N ) : NEW_LINE INDENT dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) NEW_LINE DEDENT DEDENT if ( dp [ N ] == 1000000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( minimumOperations ( N ) ) NEW_LINE DEDENT"}
{"text": "Keuntungan maksimum selepas membeli dan menjual stok dengan yuran transaksi | Tetapkan 2 | Berfungsi untuk mencari keuntungan maksimum dengan yuran transaksi; Melintasi stok untuk setiap hari; Kemas kini membeli dan menjual; Mengembalikan keuntungan maksimum; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def MaxProfit ( arr , n , transactionFee ) : NEW_LINE INDENT buy = - arr [ 0 ] NEW_LINE sell = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT temp = buy NEW_LINE buy = max ( buy , sell - arr [ i ] ) NEW_LINE sell = max ( sell , temp + arr [ i ] - transactionFee ) NEW_LINE DEDENT return max ( sell , buy ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE transactionFee = 2 NEW_LINE print ( MaxProfit ( arr , n , transactionFee ) ) NEW_LINE DEDENT"}
{"text": "Jumlah maksimum dari kiri ke bawah kanan matriks melalui salah satu sel yang diberikan | Menyimpan jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Menyimpan jumlah laluan maksimum dari sel (j, j) hingga (n, m); Berfungsi untuk mencari jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Melintasi baris pertama; Melintasi lajur pertama; Melintasi matriks; Kemas kini nilai permulaan [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari sel (j, j) hingga (n, m); Melintasi baris terakhir; Melintasi lajur terakhir; Melintasi matriks; Kemas kini nilai berakhir [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari atas - kiri ke sel kanan bawah supaya laluan itu mengandungi salah satu sel dalam koordinat array [] []; Memulakan permulaan dan matriks akhir; Kirakan matriks permulaan; Kirakan matriks akhir; Menyimpan jumlah laluan maksimum; Melintasi koordinat; Kemas kini nilai ANS; Cetak nilai laluan jumlah maksimum yang dihasilkan; Kod pemacu", "code": "start = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE ending = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE def calculateStart ( n , m ) : NEW_LINE INDENT for i in range ( 1 , m , 1 ) : NEW_LINE INDENT start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT for j in range ( 1 , m , 1 ) : NEW_LINE INDENT start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def calculateEnd ( n , m ) : NEW_LINE INDENT i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i = m - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = m - 2 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) NEW_LINE j -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT def maximumPathSum ( mat , n , m , q , coordinates ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT start [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE ending [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT calculateStart ( n , m ) NEW_LINE calculateEnd ( n , m ) NEW_LINE ans = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT X = coordinates [ i ] [ 0 ] - 1 NEW_LINE Y = coordinates [ i ] [ 1 ] - 1 NEW_LINE ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE N = 3 NEW_LINE M = 3 NEW_LINE Q = 2 NEW_LINE coordinates = [ [ 1 , 2 ] , [ 2 , 2 ] ] NEW_LINE maximumPathSum ( mat , N , M , Q , coordinates ) NEW_LINE DEDENT"}
{"text": "Panjang subset terpanjang yang terdiri daripada 0 s dan b 1 s dari pelbagai rentetan | Tetapkan 2 | Berfungsi untuk mencari panjang subset terpanjang pelbagai rentetan dengan paling banyak 0 s dan b 1 s; Memulakan array 2D dengan penyertaannya sebagai 0; Melintasi array yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan semasa; Melangkah dalam julat [a, sifar]; Berulang dalam julat [b, yang]; Mengemas kini nilai dp [i] [j]; Cetak hasilnya; Kod pemacu", "code": "def MaxSubsetlength ( arr , A , B ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( B + 1 ) ] for i in range ( A + 1 ) ] NEW_LINE for str in arr : NEW_LINE INDENT zeros = str . count ( '0' ) NEW_LINE ones = str . count ( '1' ) NEW_LINE for i in range ( A , zeros - 1 , - 1 ) : NEW_LINE INDENT for j in range ( B , ones - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ A ] [ B ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" ] NEW_LINE A , B = 5 , 3 NEW_LINE print ( MaxSubsetlength ( arr , A , B ) ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk memilih pasangan gula -gula warna yang berbeza (pengaturcaraan dinamik + bitmasking) | Fungsi untuk mengira cara untuk memilih N yang berbeza pasangan gula -gula dengan warna yang berbeza; Jika pasangan N dipilih; Kedai mengira cara untuk memilih pasangan i - th; Melangkah ke atas julat [0, n]; Jika pasangan (i, j) tidak termasuk; Kod pemacu", "code": "def numOfWays ( a , n , i = 0 , blue = [ ] ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 and j not in blue : NEW_LINE INDENT count += numOfWays ( mat , n , i + 1 , blue + [ j ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 0 , 1 , 1 ] , [ 1 , 0 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( numOfWays ( mat , n ) ) NEW_LINE DEDENT"}
{"text": "Kurangkan kos untuk mencapai hujung array oleh dua lompatan ke hadapan atau satu lompatan ke belakang dalam setiap langkah | Berfungsi untuk mencari kos minimum untuk mencapai akhir array; Kes asas: apabila n <3; Simpan hasil dalam jadual; Memulakan kes asas; Melangkah ke atas julat [2, n - 2] untuk membina array DP; Mengendalikan kes untuk indeks terakhir, i. e. N - 1; Cetak jawapannya; Kod pemacu", "code": "def minCost ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] NEW_LINE for i in range ( 2 , n - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) NEW_LINE print ( dp [ n - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 4 , 6 , 8 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE minCost ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program Python3 untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); Kedai perwakilan binari n; Kedai kuasa 10; Kirakan perwakilan binari n; Jika n adalah nombor ganjil; Kemas kini x; Kemas kini pow_10; Kemas kini n; Dua kali ganda nilai x; Menyimpan nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kod pemacu", "code": "M = 1000000007 NEW_LINE def power ( X , Y ) : NEW_LINE INDENT res = 1 NEW_LINE X = X % M NEW_LINE if ( X == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( Y > 0 ) : NEW_LINE INDENT if ( Y & 1 ) : NEW_LINE INDENT res = ( res * X ) % M NEW_LINE DEDENT Y = Y >> 1 NEW_LINE X = ( X * X ) % M NEW_LINE DEDENT return res NEW_LINE DEDENT def findValue ( n ) : NEW_LINE INDENT X = 0 NEW_LINE pow_10 = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT X += pow_10 NEW_LINE DEDENT pow_10 *= 10 NEW_LINE n //= 2 NEW_LINE DEDENT X = ( X * 2 ) % M NEW_LINE res = power ( 2 , X ) NEW_LINE return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( findValue ( n ) ) NEW_LINE DEDENT"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program Python3 untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); dp [n] * dp [n]: Kedai nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kes asas; Melangkah ke atas julat [3, n]; Kedai paling tepat dari saya; Menyimpan nilai (i - y); Jika x adalah kuasa 2; Kemas kini DP [i]; Kemas kini DP [i]; Kod pemacu", "code": "M = 1000000007 ; NEW_LINE def power ( X , Y ) : NEW_LINE INDENT res = 1 ; NEW_LINE X = X % M ; NEW_LINE if ( X == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( Y > 0 ) : NEW_LINE INDENT if ( Y % 2 == 1 ) : NEW_LINE INDENT res = ( res * X ) % M ; NEW_LINE DEDENT Y = Y >> 1 ; NEW_LINE X = ( X * X ) % M ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findValue ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) ; NEW_LINE dp [ 1 ] = 2 ; NEW_LINE dp [ 2 ] = 1024 ; NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT y = ( i & ( - i ) ) ; NEW_LINE x = i - y ; NEW_LINE if ( x == 0 ) : NEW_LINE INDENT dp [ i ] = power ( dp [ i // 2 ] , 10 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; NEW_LINE DEDENT DEDENT return ( dp [ N ] * dp [ N ] ) % M ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 150 ; NEW_LINE print ( findValue ( n ) ) ; NEW_LINE DEDENT"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Fungsi untuk mencari bilangan cara untuk mendapatkan jumlah n dengan membuang dadu; Kes asas; Menyimpan jumlah jumlah cara untuk mendapatkan jumlah n; Berulang untuk semua 6 negeri; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "def findWays ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = cnt + findWays ( N - i ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( findWays ( N ) ) NEW_LINE DEDENT"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Fungsi utiliti untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Kes asas; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengembalikan nilai maksimum di antara semua 3 panggilan rekursif; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Diberikan array arr []; Panggilan fungsi", "code": "def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE INDENT if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE return max ( l , m , r ) NEW_LINE DEDENT DEDENT def checkEqualSum ( arr , N ) : NEW_LINE INDENT sum1 = sum2 = sum3 = 0 NEW_LINE if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE checkEqualSum ( arr , N ) NEW_LINE"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program Python3 untuk pendekatan di atas; Fungsi untuk memeriksa array boleh menjadi partition ke dalam jumlah 3 sama; Kes asas; Jika nilai pada indeks tertentu tidak - 1 maka nilai pulangan pada indeks itu yang memastikan tiada lagi panggilan lagi; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengemas kini keadaan semasa dan mengembalikan nilai itu; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Diberikan array arr []; Panggilan fungsi", "code": "dp = { } NEW_LINE def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE INDENT s = str ( sm1 ) + \" _ \" + str ( sm2 ) + str ( j ) NEW_LINE if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if s in dp : NEW_LINE INDENT return dp [ s ] NEW_LINE DEDENT l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE dp [ s ] = max ( l , m , r ) NEW_LINE return dp [ s ] NEW_LINE DEDENT def checkEqualSum ( arr , N ) : NEW_LINE INDENT sum1 = sum2 = sum3 = 0 NEW_LINE if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE checkEqualSum ( arr , N ) NEW_LINE"}
{"text": "Indeks terkecil dalam pelbagai indeks yang tidak sama dengan x | Precompute Indeks elemen yang berbeza seterusnya dalam array untuk setiap elemen array; Nilai lalai; Kirakan Nextpos [i] menggunakan Nextpos [i + 1]; Berfungsi untuk mengembalikan indeks terkecil; Nextpos [i] akan menyimpan kedudukan seterusnya p di mana arr [p]! = arr [i]; Jika x tidak hadir di l; Jika tidak; Find the index which stores a value different from X ; Jika indeks itu berada dalam julat; Kod pemacu", "code": "def precompute ( nextpos , arr , N ) : NEW_LINE INDENT nextpos [ N - 1 ] = N NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT nextpos [ i ] = nextpos [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nextpos [ i ] = i + 1 NEW_LINE DEDENT DEDENT DEDENT def findIndex ( query , arr , N , Q ) : NEW_LINE INDENT nextpos = [ 0 ] * N NEW_LINE precompute ( nextpos , arr , N ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE x = query [ i ] [ 2 ] NEW_LINE ans = - 1 NEW_LINE if arr [ l ] != x : NEW_LINE INDENT ans = l NEW_LINE DEDENT else : NEW_LINE INDENT d = nextpos [ l ] NEW_LINE if d <= r : NEW_LINE INDENT ans = d NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT N = 6 NEW_LINE Q = 3 NEW_LINE arr = [ 1 , 2 , 1 , 1 , 3 , 5 ] NEW_LINE query = [ [ 0 , 3 , 1 ] , [ 1 , 5 , 2 ] , [ 2 , 3 , 1 ] ] NEW_LINE findIndex ( query , arr , N , Q ) NEW_LINE"}
{"text": "Mengira bilangan cara untuk menukar rentetan s ke t dengan melakukan peralihan kitaran k | Program Python3 untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk menukar rentetan s ke rentetan t dengan melakukan peralihan kitaran k; Hitung panjang rentetan; A tidak. Peralihan kitaran yang baik B tidak. pergeseran kitaran buruk; Iterat dalam rentetan; Precompute bilangan peralihan kitaran yang baik dan buruk; DP2 [i] untuk menyimpan tidak ada cara untuk mendapatkan peralihan yang buruk dalam saya bergerak; Kirakan peralihan yang baik dan buruk; Mengembalikan bilangan cara yang diperlukan; Diberikan rentetan; Memandangkan pergeseran k diperlukan; Panggilan fungsi", "code": "mod = 1000000007 NEW_LINE def countWays ( s , t , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = s [ i : n - i + 1 ] + s [ : i + 1 ] NEW_LINE if ( p == t ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if ( s == t ) : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ 0 ] = 0 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod NEW_LINE DEDENT return ( dp1 [ k ] ) NEW_LINE DEDENT S = ' ab ' NEW_LINE T = ' ab ' NEW_LINE K = 2 NEW_LINE print ( countWays ( S , T , K ) ) NEW_LINE"}
{"text": "Kurangkan langkah -langkah untuk mencapai k dari 0 dengan menambah 1 atau menggandakan pada setiap langkah | Berfungsi untuk mencari operasi minimum; DP diasaskan untuk menyimpan langkah -langkah; Untuk semua nombor walaupun; Kod pemacu", "code": "def minOperation ( k ) : NEW_LINE INDENT dp = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i // 2 ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 12 NEW_LINE print ( minOperation ( k ) ) NEW_LINE DEDENT"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Berfungsi untuk mencari jumlah subset maksimum; Abaikan elemen semasa; termasuk elemen dalam partition 1; termasuk elemen dalam partition 2; Kod pemacu; saiz array", "code": "def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) ; NEW_LINE DEDENT"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Pelaksanaan Python3 untuk pendekatan pengaturcaraan dinamik yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; jumlah semua elemen; Jadual carian bawah; ; jadual DP yang memulakan dengan int_min di mana, int_min bermaksud tiada penyelesaian; Kes apabila diff adalah 0; Meletakkan elemen ITH dalam G0; Meletakkan elemen ITH dalam G1; Mengabaikan elemen ith; Kod pemacu", "code": "import numpy as np NEW_LINE import sys NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) NEW_LINE def maxSum ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT limit = 2 * sum + 1 ; NEW_LINE dp = np . zeros ( ( n + 1 , limit ) ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT dp [ i ] [ j ] = INT_MIN ; NEW_LINE DEDENT DEDENT dp [ 0 ] [ sum ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT if ( ( j - a [ i - 1 ] ) >= 0 and dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; NEW_LINE DEDENT if ( ( j + a [ i - 1 ] ) < limit and dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ sum ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( a , n ) ) ; NEW_LINE DEDENT"}
{"text": "Count of Strings mungkin dengan menggantikan dua watak yang sama berturut -turut dengan watak baru | Array untuk mencari urutan Fibonacci; Berfungsi untuk mencari urutan Fibonacci; Berfungsi untuk mengira semua rentetan yang mungkin; Memulakan ans = 1; Jika dua char berturut -turut adalah peningkatan yang sama CNT; Lain melipatgandakan FIB [CNT] ke Ans dan memulakan Ans hingga 1; Jika str = abcdeeee, maka untuk terakhir \"eeee\" kiraan munst dikemas kini; Mengembalikan jumlah jumlah; Kod pemandu; Berfungsi untuk precompute semua nombor Fibonacci; Fungsi panggilan untuk mencari kiraan", "code": "fib = [ 0 ] * 100005 ; NEW_LINE def computeFibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 ; NEW_LINE fib [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , 100005 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; NEW_LINE DEDENT DEDENT def countString ( string ) : NEW_LINE INDENT ans = 1 ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * fib [ cnt ] ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT ans = ans * fib [ cnt ] ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abdllldefkkkk \" ; NEW_LINE computeFibonacci ( ) ; NEW_LINE print ( countString ( string ) ) ; NEW_LINE DEDENT"}
{"text": "Urutan Golomb | Tetapkan 2 | Program Python3 untuk mencari terma pertama N Golomb urutan; Berfungsi untuk mencetak urutan Golomb; Memulakan array; Memulakan CNT hingga 0; Elemen pertama dan kedua urutan Golomb ialah 0, 1; Peta untuk menyimpan kiraan elemen semasa dalam urutan Golomb; Simpan kiraan 2; Melangkah lebih dari 2 hingga n; Jika CNT sama dengan 0 maka kami mempunyai nombor baru untuk urutan Golomb yang 1 + elemen sebelumnya; Lain elemen semasa adalah elemen sebelumnya dalam urutan ini; Peta indeks semasa ke nilai semasa dalam arr []; Cetak urutan Golomb; Kod pemacu", "code": "MAX = 100001 NEW_LINE def printGolombSequence ( N ) : NEW_LINE INDENT arr = [ 0 ] * MAX NEW_LINE cnt = 0 NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE M = dict ( ) NEW_LINE M [ 2 ] = 2 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( cnt == 0 ) : NEW_LINE INDENT arr [ i ] = 1 + arr [ i - 1 ] NEW_LINE cnt = M [ arr [ i ] ] NEW_LINE cnt -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE cnt -= 1 NEW_LINE DEDENT M [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N = 11 NEW_LINE printGolombSequence ( N ) NEW_LINE"}
{"text": "Kira cara untuk mencapai tangga nth dengan mengambil 1 dan 2 langkah dengan tepat satu 3 langkah | Berfungsi untuk mencari bilangan bilangan cara untuk mencapai tangga nth; Array termasuk bilangan cara yang merangkumi 3; Array termasuk bilangan cara yang tidak termasuk 3; Pada mulanya untuk mencapai 3 tangga dengan mengambil 3 langkah boleh dicapai dengan 1 cara; Gelung untuk mencari nombor bilangan cara untuk mencapai tangga nth; Kod pemacu", "code": "def number_of_ways ( n ) : NEW_LINE INDENT includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE not_includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE includes_3 [ 3 ] = 1 NEW_LINE not_includes_3 [ 1 ] = 1 NEW_LINE not_includes_3 [ 2 ] = 2 NEW_LINE not_includes_3 [ 3 ] = 3 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] NEW_LINE not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] NEW_LINE DEDENT return includes_3 [ n ] NEW_LINE DEDENT n = 7 NEW_LINE print ( number_of_ways ( n ) ) NEW_LINE"}
{"text": "Bilangan maksimum gandaan dalam array sebelum mana -mana elemen | Pelaksanaan Python3 pendekatan; Peta untuk menyimpan kiraan pembahagi; Berfungsi untuk menjana pembahagi semua elemen array; Berfungsi untuk mencari bilangan maksimum gandaan dalam array sebelum itu; Untuk menyimpan kiraan pembahagi maksimum; Kemas kini Ans Jika lebih banyak bilangan pembahagi dijumpai; Menjana semua pembahagi elemen seterusnya dari array; Kod pemacu", "code": "from math import ceil , sqrt NEW_LINE MAX = 100000 NEW_LINE divisors = [ 0 ] * MAX NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE divisors [ n // i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def findMaxMultiples ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( divisors [ arr [ i ] ] , ans ) NEW_LINE generateDivisors ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxMultiples ( arr , n ) ) NEW_LINE"}
{"text": "Bilangan cara untuk mencapai akhir matriks dengan bukan | Pelaksanaan Python3 pendekatan; Arahan 3D untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Fungsi untuk mengembalikan kiraan laluan yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "n = 3 NEW_LINE maxV = 20 NEW_LINE dp = [ [ [ 0 for i in range ( maxV ) ] for i in range ( n ) ] for i in range ( n ) ] NEW_LINE v = [ [ [ 0 for i in range ( maxV ) ] for i in range ( n ) ] for i in range ( n ) ] NEW_LINE def countWays ( i , j , x , arr ) : NEW_LINE INDENT if ( i == n or j == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = ( x & arr [ i ] [ j ] ) NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( v [ i ] [ j ] [ x ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT v [ i ] [ j ] [ x ] = 1 NEW_LINE dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; NEW_LINE return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT arr = [ [ 1 , 2 , 1 ] , [ 1 , 1 , 0 ] , [ 2 , 1 , 1 ] ] NEW_LINE print ( countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ) NEW_LINE"}
{"text": "Jumlah maksimum dari tiga tatasusunan yang memilih unsur -unsur berturut -turut dari yang sama tidak dibenarkan | Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Sudah dikunjungi; Jika elemen telah diambil dari array pertama dalam langkah sebelumnya; Jika elemen telah diambil dari array kedua dalam langkah sebelumnya; Jika elemen telah diambil dari array ketiga dalam langkah sebelumnya; Kod pemacu; Pilih elemen dari array pertama; Pilih elemen dari array kedua; Pilih elemen dari array ketiga; Cetak maksimum mereka", "code": "def FindMaximumSum ( ind , kon , a , b , c , n , dp ) : NEW_LINE INDENT if ind == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ ind ] [ kon ] != - 1 : NEW_LINE INDENT return dp [ ind ] [ kon ] NEW_LINE DEDENT ans = - 10 ** 9 + 5 NEW_LINE if kon == 0 : NEW_LINE INDENT ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT elif kon == 1 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT elif kon == 2 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE DEDENT dp [ ind ] [ kon ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE a = [ 6 , 8 , 2 , 7 , 4 , 2 , 7 ] NEW_LINE b = [ 7 , 8 , 5 , 8 , 6 , 3 , 5 ] NEW_LINE c = [ 8 , 3 , 2 , 6 , 8 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE dp = [ [ - 1 for i in range ( N ) ] for j in range ( n ) ] NEW_LINE x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) NEW_LINE y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) NEW_LINE z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) NEW_LINE print ( max ( x , y , z ) ) NEW_LINE DEDENT"}
{"text": "Bilangan cara untuk membuat rentetan panjang panjang n sedemikian rupa sehingga 0 s sentiasa berlaku bersama dalam kumpulan saiz k | Python3 iimplementasi pendekatan di atas; Berfungsi untuk mengembalikan tidak ada cara untuk membina rentetan panjang binari sehingga 0 s selalu berlaku dalam kumpulan saiz k; Kod pemacu", "code": "mod = 1000000007 ; NEW_LINE def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE K = 2 ; NEW_LINE print ( noOfBinaryStrings ( N , K ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan cara untuk memasangkan orang | Berfungsi untuk mencari bilangan cara untuk memasangkan orang dalam parti; Untuk menyimpan jumlah cara. ; Menggunakan kiraan cari yang ditakrifkan berulang untuk nilai yang berbeza p. ; Kod pemacu", "code": "def findWays ( p ) : NEW_LINE INDENT dp = [ 0 ] * ( p + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE for i in range ( 3 , p + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return dp [ p ] NEW_LINE DEDENT p = 3 NEW_LINE print ( findWays ( p ) ) NEW_LINE"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pelaksanaan rekursif mudah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Kes asas; Untuk kes n> 2; Kod pemacu", "code": "def CountWays ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 1 + 1 NEW_LINE DEDENT return CountWays ( n - 1 ) + CountWays ( n - 3 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT"}
{"text": "Nombor pelik | Program Python 3 untuk memeriksa sama ada nombor itu pelik atau tidak; Kod untuk mencari semua faktor nombor tidak termasuk nombor itu sendiri; vektor untuk menyimpan faktor -faktor; Perhatikan bahawa gelung ini berjalan sehingga sqrt (n); jika nilai saya adalah faktor; Keadaan untuk memeriksa pembahagi bukan nombor itu sendiri; mengembalikan vektor; Berfungsi untuk memeriksa sama ada nombor itu banyak atau tidak; Cari pembahagi menggunakan fungsi; Jumlah semua faktor; Periksa banyak atau tidak; Berfungsi untuk memeriksa sama ada nombor itu separuh - sempurna atau tidak; Cari pembahagi; menyusun vektor; subset untuk memeriksa sama ada tidak semiperfect; memulakan lajur 1 st untuk benar; memulakan baris 1 st kecuali kedudukan sifar ke 0; gelung untuk mencari sama ada nombor itu semiperfect; pengiraan untuk memeriksa sama ada nombor itu boleh dibuat dengan penjumlahan pembahagi; jika tidak mungkin untuk membuat nombor dengan gabungan mana -mana pembahagi; Berfungsi untuk memeriksa pelik atau tidak; Kod pemacu", "code": "from math import sqrt NEW_LINE def factors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE if ( int ( n / i ) != i ) : NEW_LINE INDENT v . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT def checkAbundant ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE v = factors ( n ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT if ( sum > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def checkSemiPerfect ( n ) : NEW_LINE INDENT v = factors ( n ) NEW_LINE v . sort ( reverse = False ) NEW_LINE r = len ( v ) NEW_LINE subset = [ [ 0 for i in range ( n + 1 ) ] for j in range ( r + 1 ) ] NEW_LINE for i in range ( r + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , r + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j < v [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - v [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( ( subset [ r ] [ n ] ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def checkweird ( n ) : NEW_LINE INDENT if ( checkAbundant ( n ) == True and checkSemiPerfect ( n ) == False ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 70 NEW_LINE if ( checkweird ( n ) ) : NEW_LINE INDENT print ( \" Weird ▁ Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Weird ▁ Number \" ) NEW_LINE DEDENT DEDENT"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Mengembalikan jumlah maksimum subarray yang dibuat selepas menggabungkan [0 .. n - 1] k kali. ; Di sinilah ia berbeza dari algoritma Kadane. Kami menggunakan aritmetik modular untuk mencari elemen seterusnya. ; Program pemacu untuk menguji maxsubarraysum", "code": "def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT a = [ 10 , 20 , - 30 , - 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" , maxSubArraySumRepeated ( a , n , k ) ) NEW_LINE"}
{"text": "Terpanjang peningkatan ganjil walaupun berikutnya | berfungsi untuk mencari peningkatan yang paling lama walaupun seterusnya; lioes [i] menyimpan paling lama meningkatkan ganjil walaupun berikutnya yang berakhir di arr [i]; untuk menyimpan panjang yang paling lama meningkat ganjil walaupun berikutnya; Memulakan nilai lio untuk semua indeks; Mengira nilai lio yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai lio; panjang maksimum yang diperlukan; Pemandu untuk menguji di atas", "code": "def longOddEvenIncSeq ( arr , n ) : NEW_LINE INDENT lioes = list ( ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lioes . append ( 1 ) NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if maxLen < lioes [ i ] : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT arr = [ 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Longest ▁ Increasing ▁ Odd ▁ Even ▁ \" + \" Subsequence : ▁ \" , longOddEvenIncSeq ( arr , n ) ) NEW_LINE"}
{"text": "Nilai minimum dan maksimum ungkapan dengan * dan + | Kaedah utiliti untuk memeriksa sama ada watak adalah pengendali atau tidak; kaedah mencetak nilai minimum dan maksimum yang boleh diperolehi daripada ungkapan; pengendali kedai dan nombor dalam vektor yang berbeza; menyimpan nombor terakhir dalam vektor; memulakan array Minval dan Maxval 2D; memulakan pepenjuru utama dengan nilai NUM; Looping serupa dengan pendaraban rantai matriks dan mengemas kini kedua -dua tatasusunan 2D; Jika pengendali semasa adalah ' +', mengemas kini pembolehubah TMP dengan tambahan; Jika pengendali semasa adalah ' *', mengemas kini pembolehubah TMP dengan pendaraban; mengemas kini nilai array oleh pembolehubah TMP; Elemen terakhir baris pertama akan menyimpan hasilnya; Kod pemacu", "code": "def isOperator ( op ) : NEW_LINE INDENT return ( op == ' + ' or op == ' * ' ) NEW_LINE DEDENT def printMinAndMaxValueOfExp ( exp ) : NEW_LINE INDENT num = [ ] NEW_LINE opr = [ ] NEW_LINE tmp = \" \" NEW_LINE for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( isOperator ( exp [ i ] ) ) : NEW_LINE INDENT opr . append ( exp [ i ] ) NEW_LINE num . append ( int ( tmp ) ) NEW_LINE tmp = \" \" NEW_LINE DEDENT else : NEW_LINE INDENT tmp += exp [ i ] NEW_LINE DEDENT DEDENT num . append ( int ( tmp ) ) NEW_LINE llen = len ( num ) NEW_LINE minVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE maxVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE for i in range ( llen ) : NEW_LINE INDENT for j in range ( llen ) : NEW_LINE INDENT minVal [ i ] [ j ] = 10 ** 9 NEW_LINE maxVal [ i ] [ j ] = 0 NEW_LINE if ( i == j ) : NEW_LINE INDENT minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] NEW_LINE DEDENT DEDENT DEDENT for L in range ( 2 , llen + 1 ) : NEW_LINE INDENT for i in range ( llen - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT minTmp = 0 NEW_LINE maxTmp = 0 NEW_LINE if ( opr [ k ] == ' + ' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT elif ( opr [ k ] == ' * ' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT if ( minTmp < minVal [ i ] [ j ] ) : NEW_LINE INDENT minVal [ i ] [ j ] = minTmp NEW_LINE DEDENT if ( maxTmp > maxVal [ i ] [ j ] ) : NEW_LINE INDENT maxVal [ i ] [ j ] = maxTmp NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" Minimum ▁ value ▁ : ▁ \" , minVal [ 0 ] [ llen - 1 ] , \" , ▁ \\ ▁ Maximum ▁ value ▁ : ▁ \" , maxVal [ 0 ] [ llen - 1 ] ) NEW_LINE DEDENT expression = \"1 + 2*3 + 4*5\" NEW_LINE printMinAndMaxValueOfExp ( expression ) NEW_LINE"}
{"text": "Pendaraban rantai matriks | DP | Pelaksanaan rekursif naif yang hanya mengikuti harta substruktur yang optimum di atas; Matrix A [i] mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu", "code": "import sys NEW_LINE def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT return _min NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" , MatrixChainOrder ( arr , 1 , n - 1 ) ) NEW_LINE"}
{"text": "Pendaraban rantai matriks | DP | Program Python menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "import sys NEW_LINE dp = [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ multiplications ▁ is \" , MatrixChainOrder ( arr , n ) ) NEW_LINE"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Berfungsi untuk membalikkan bit A dan B yang ditetapkan dalam kedua -dua mereka; Kosongkan bit A yang ditetapkan dalam kedua -dua A dan B; Kosongkan bit B yang ditetapkan dalam kedua -dua A dan B; Cetak dikemas kini A dan B; Kod pemacu", "code": "def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT A = A ^ ( A & B ) NEW_LINE B = B ^ ( A & B ) NEW_LINE print ( A , B ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 10 NEW_LINE B = 20 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT"}
{"text": "Jumlah perbezaan perbezaan nombor berturut -turut dari 0 hingga n | Tetapkan 2 | Fungsi untuk mengira dan mengembalikan jarak Hamming antara semua nombor berturut -turut dari 0 hingga n; Kod pemacu", "code": "def TotalHammingDistance ( n ) : NEW_LINE INDENT i = 1 NEW_LINE sum = 0 NEW_LINE while ( n // i > 0 ) : NEW_LINE INDENT sum = sum + n // i NEW_LINE i = i * 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE print ( TotalHammingDistance ( N ) ) NEW_LINE DEDENT"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Set 3 | Program Python3 untuk melaksanakan pendekatan di atas; Fungsi untuk mencari jumlah semua pembahagi semua nombor dari 1 hingga n; Menyimpan jumlah; Menandakan kejadian terakhir yang berlaku dengan kiraan yang sama; Kirakan jumlahnya; Mengembalikan hasilnya; Kod pemacu", "code": "import math NEW_LINE m = 1000000007 NEW_LINE def solve ( n ) : NEW_LINE INDENT s = 0 ; NEW_LINE l = 1 ; NEW_LINE while ( l < n + 1 ) : NEW_LINE INDENT r = ( int ) ( n / math . floor ( n / l ) ) ; NEW_LINE x = ( ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ) ; NEW_LINE y = ( ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ) ; NEW_LINE p = ( int ) ( ( n / l ) % m ) ; NEW_LINE s = ( ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ) ; NEW_LINE s %= m ; NEW_LINE l = r + 1 ; NEW_LINE DEDENT print ( int ( ( s + m ) % m ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT"}
{"text": "Kurangkan bilangan luka yang diperlukan untuk memecahkan panjang n tongkat ke dalam n unit panjang tongkat | Program Python3 untuk mencari masa minimum yang diperlukan untuk memecah tongkat panjang N ke dalam kepingan unit; Berfungsi untuk mengembalikan masa minimum yang diperlukan untuk memecah tongkat n ke dalam kepingan unit; Mengembalikan unit minimum masa yang diperlukan; Kod pemacu", "code": "import math NEW_LINE def min_time_to_cut ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( math . log2 ( N ) ) + 1 NEW_LINE DEDENT N = 100 NEW_LINE print ( min_time_to_cut ( N ) ) NEW_LINE"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | Berfungsi untuk mencari jumlah yang berbeza; Tetapkan untuk menyimpan jumlah yang berbeza; Memasukkan setiap jumlah; Kembali jumlah yang berbeza; Kod pemacu", "code": "def findDistinctSums ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT s . add ( i + j ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE"}
{"text": "Cetak Segitiga Terasing Corak | Berfungsi untuk mencetak corak secara rekursif; Kes asas; Syarat untuk mencetak slash; Keadaan untuk mencetak slash forword; Keadaan untuk mencetak slash ke belakang; Lain cetak '*; Panggilan rekursif untuk baris; Panggilan rekursif untuk menukar baris; Kod pemacu; Panggilan fungsi", "code": "def printPattern ( i , j , n ) : NEW_LINE INDENT if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( j == i or j == n - 1 - i ) : NEW_LINE INDENT if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" / \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \\\\ \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE return printPattern ( i + 1 , 0 , n ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE printPattern ( 0 , 0 , N ) NEW_LINE DEDENT"}
{"text": "Cari indeks permulaan untuk setiap kejadian array yang diberikan b dalam array A menggunakan z | Pelaksanaan Python3 untuk mencari corak dalam array menggunakan algoritma Z; Function to calculate Z - Array ; Gelung untuk mengira z - array; Di luar kotak z; Di dalam z - kotak; Fungsi penolong untuk menggabungkan dua tatasusunan dan membuat satu array; Array untuk menyimpan array yang digabungkan; Menyalin Array B; Menambah pemisah; Menyalin Array A; Memanggil Z - Fungsi; Fungsi untuk membantu mengira array Z; Indeks percetakan di mana array b berlaku; Kod pemacu", "code": "import sys ; NEW_LINE def zArray ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE z = [ 0 ] * n ; NEW_LINE r = 0 ; NEW_LINE l = 0 ; NEW_LINE for k in range ( 1 , n ) : NEW_LINE INDENT if ( k > r ) : NEW_LINE INDENT r = l = k ; NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 ; NEW_LINE DEDENT z [ k ] = r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT k1 = k - l ; NEW_LINE if ( z [ k1 ] < r - k + 1 ) : NEW_LINE INDENT z [ k ] = z [ k1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT l = k ; NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 ; NEW_LINE DEDENT z [ k ] = r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT DEDENT return z ; NEW_LINE DEDENT def mergeArray ( A , B ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE m = len ( B ) ; NEW_LINE c = [ 0 ] * ( n + m + 1 ) ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT c [ i ] = B [ i ] ; NEW_LINE DEDENT c [ m ] = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ m + i + 1 ] = A [ i ] ; NEW_LINE DEDENT z = zArray ( c ) ; NEW_LINE return z ; NEW_LINE DEDENT def findZArray ( A , B , n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE z = mergeArray ( A , B ) ; NEW_LINE for i in range ( len ( z ) ) : NEW_LINE INDENT if ( z [ i ] == n ) : NEW_LINE INDENT print ( i - n - 1 , end = \" ▁ \" ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" Not ▁ Found \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 2 , 3 , 2 ] ; NEW_LINE B = [ 2 , 3 ] ; NEW_LINE n = len ( B ) ; NEW_LINE findZArray ( A , B , n ) ; NEW_LINE DEDENT"}
{"text": "Semak jika rentetan boleh diulang untuk membuat rentetan lain | Berfungsi untuk mengembalikan kiraan pengulangan String A untuk menjana rentetan b; Jika B tidak dapat dihasilkan dengan mengulangi A; Ulangi jumlah kiraan; Kod pemacu", "code": "def getCount ( a , b ) : NEW_LINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT count = int ( len ( b ) / len ( a ) ) NEW_LINE a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = ' geeks ' NEW_LINE b = ' geeksgeeks ' NEW_LINE print ( getCount ( a , b ) ) NEW_LINE DEDENT"}
{"text": "Semak jika rentetan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan | Program Python3 untuk memeriksa sama ada rentetan yang diberikan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan; Fungsi untuk memeriksa sama ada S2 boleh dibentuk dari S1; panjang rentetan; Hash - Jadual untuk menyimpan kiraan; menyimpan kiraan setiap watak; melintasi dan memeriksa setiap watak; Jika watak S2 hadir dalam S1; Jika watak S2 tidak hadir dalam S1, maka periksa sama ada dua aksara ASCII terdahulu hadir dalam S1; Kod pemacu; Fungsi panggilan untuk memeriksa", "code": "from collections import defaultdict NEW_LINE def check ( S1 , S2 ) : NEW_LINE INDENT n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT mp [ S1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if mp [ S2 [ i ] ] : NEW_LINE INDENT mp [ S2 [ i ] ] -= 1 NEW_LINE DEDENT elif ( mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] and mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] ) : NEW_LINE INDENT mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] -= 1 NEW_LINE mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S1 = \" abbat \" NEW_LINE S2 = \" cat \" NEW_LINE if check ( S1 , S2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Count kejadian corak \"1 (0 +) 1\" dalam rentetan | Mengembalikan kiraan kejadian \"1 (0 +) 1\"; Count = 0 Inisialisasi hasil; Semak jika ditemui '1' membentuk corak yang sah seperti yang ditentukan; jika 1 ditemui untuk pertama kali ditetapkan satu ke 1; Semak jika terdapat watak lain selain daripada '0' atau '1'. Jika demikian kemudian tetapkan Oneseen hingga 0 untuk mencari lagi untuk corak baru; Kod pemacu", "code": "def countPattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE oneSeen = False NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] == '1' and oneSeen ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( s [ i ] == '1' and oneSeen == 0 ) : NEW_LINE INDENT oneSeen = True NEW_LINE DEDENT if ( s [ i ] != '0' and s [ i ] != '1' ) : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = \"100001abc101\" NEW_LINE print countPattern ( s ) NEW_LINE"}
{"text": "Tukar rentetan yang diberikan ke dalam T dengan menggantikan aksara di antara rentetan sebilangan kali | Fungsi untuk memeriksa sama ada mungkin untuk membuat semua rentetan sama dengan t; Menyimpan kekerapan semua rentetan dalam array arr []; Menyimpan kekerapan t; Melangkah ke atas watak -watak T; Melangkah dalam julat [0, n - 1]; Melangkah ke atas watak -watak arr [i]; Jika freqt [i] adalah 0 dan freqs [i] bukan 0; Jika freqs [i] adalah 0 dan freqt [i] bukan 0; Jika freqs [i] bukan freqt [i] * n; Jika tidak, kembalikan \"ya\"; Kod pemacu", "code": "def checkIfPossible ( N , arr , T ) : NEW_LINE INDENT freqS = [ 0 ] * 256 NEW_LINE freqT = [ 0 ] * 256 NEW_LINE for ch in T : NEW_LINE INDENT freqT [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for ch in arr [ i ] : NEW_LINE INDENT freqS [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 256 ) : NEW_LINE INDENT if ( freqT [ i ] == 0 and freqS [ i ] != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT elif ( freqS [ i ] == 0 and freqT [ i ] != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT elif ( freqT [ i ] != 0 and freqS [ i ] != ( freqT [ i ] * N ) ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" abc \" , \" abb \" , \" acc \" ] NEW_LINE T = \" abc \" NEW_LINE N = len ( arr ) NEW_LINE print ( checkIfPossible ( N , arr , T ) ) NEW_LINE DEDENT"}
{"text": "Palindromic Strings of Length 3 mungkin dengan menggunakan aksara rentetan yang diberikan | Berfungsi untuk mencetak semua rentetan palindromik panjang 3 yang boleh dibentuk menggunakan aksara rentetan s; Menyimpan kiraan watak; Melintasi rentetan s; Menyimpan semua rentetan palindromik; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Jika hash [ch] sama dengan 2; Melangkah ke atas watak -watak di atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Tolak S ke set st; Jika hash [i] lebih besar daripada atau sama dengan 3; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Jika hash [j] positif; Tolak s ke set st; Melangkah ke atas set; Kod pemacu", "code": "def generatePalindrome ( S ) : NEW_LINE INDENT Hash = { } NEW_LINE for ch in S : NEW_LINE INDENT Hash [ ch ] = Hash . get ( ch , 0 ) + 1 NEW_LINE DEDENT st = { } NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT if ( chr ( i ) in Hash and Hash [ chr ( i ) ] == 2 ) : NEW_LINE INDENT for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT s = \" \" NEW_LINE if ( chr ( j ) in Hash and i != j ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE s += chr ( i ) NEW_LINE st [ s ] = 1 NEW_LINE DEDENT DEDENT DEDENT if ( ( chr ( i ) in Hash ) and Hash [ chr ( i ) ] >= 3 ) : NEW_LINE INDENT for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT s = \" \" NEW_LINE if ( chr ( j ) in Hash ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE s += chr ( i ) NEW_LINE st [ s ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for ans in st : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" ddabdac \" NEW_LINE generatePalindrome ( S ) NEW_LINE DEDENT"}
{"text": "Mengira kejadian substring x sebelum setiap kejadian substring y dalam rentetan yang diberikan | Fungsi untuk mengira kejadian rentetan y dalam rentetan s untuk setiap kejadian x dalam s; Menyimpan kiraan kejadian x; Menyimpan panjang tiga rentetan; Melintasi rentetan s; Jika substring semasa adalah y, maka kenaikan nilai kiraan sebanyak 1; Jika substring semasa adalah x, maka cetak kiraan; Kod pemacu", "code": "def countOccurrences ( S , X , Y ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE A = len ( X ) NEW_LINE B = len ( Y ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i : i + B ] == Y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( S [ i : i + A ] == X ) : NEW_LINE INDENT print ( count , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT S = \" abcdefdefabc \" NEW_LINE X = \" abc \" NEW_LINE Y = \" def \" NEW_LINE countOccurrences ( S , X , Y ) NEW_LINE"}
{"text": "Program untuk membina DFA untuk ungkapan biasa C (A + B) + | Fungsi untuk mencari sama ada yang diberikan diterima oleh DFA; Jika n <= 1, maka prno; Untuk mengira watak yang dipadankan; Semak jika watak pertama adalah c; Melintasi seluruh rentetan; Jika watak adalah A atau B, kiraan kenaikan sebanyak 1; Jika watak pertama tidak C, pr - 1; Jika semua watak sepadan; Kod pemacu", "code": "def DFA ( str , N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE if ( str [ 0 ] == ' C ' ) : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( str [ i ] == ' A ' or str [ i ] == ' B ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT if ( count == N ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" CAABBAAB \" NEW_LINE N = len ( str ) NEW_LINE DFA ( str , N ) NEW_LINE DEDENT"}
{"text": "Bilangan minimum dan maksimum digit yang diperlukan untuk dikeluarkan untuk membuat nombor tertentu dibahagikan dengan 3 | Berfungsi untuk mencari bilangan maksimum dan minimum digit yang akan dikeluarkan untuk menjadikan STR dibahagikan dengan 3; Tukar rentetan ke dalam pelbagai digit; Kiraan 0 s, 1 s, dan 2 s; Melintasi array; Cari jumlah digit % 3; Kes untuk mencari bilangan minimum digit yang akan dikeluarkan; Kes untuk mencari bilangan maksimum digit yang akan dikeluarkan; Kod pemacu; Panggilan fungsi", "code": "def minMaxDigits ( str , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] = ( ord ( str [ i ] ) - ord ( '0' ) ) % 3 NEW_LINE DEDENT zero = 0 NEW_LINE one = 0 NEW_LINE two = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = ( sum + arr [ i ] ) % 3 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" ▁ \" ) NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT if ( one and N > 1 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT elif ( two > 1 and N > 2 ) : NEW_LINE INDENT print ( \"2\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( sum == 2 ) : NEW_LINE INDENT if ( two and N > 1 ) : NEW_LINE INDENT print ( \"1\" , end = \" ▁ \" ) NEW_LINE DEDENT elif ( one > 1 and N > 2 ) : NEW_LINE INDENT print ( \"2\" , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if ( zero > 0 ) : NEW_LINE INDENT print ( N - 1 , end = \" ▁ \" ) NEW_LINE DEDENT elif ( one > 0 and two > 0 ) : NEW_LINE INDENT print ( N - 2 , end = \" ▁ \" ) NEW_LINE DEDENT elif ( one > 2 or two > 2 ) : NEW_LINE INDENT print ( N - 3 , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT str = \"12345\" NEW_LINE N = len ( str ) NEW_LINE minMaxDigits ( str , N ) NEW_LINE"}
{"text": "Penggantian minimum diperlukan untuk mendapatkan k | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum perubahan untuk membuat rentetan k - berkala dan palindrome; Memulakan ans dengan 0; Berulang dari 0 hingga (k + 1) / 2; Frekuensi penyimpanan watak; Melewati semua indeks, i, i + k, i + 2 k .... dan menyimpan kekerapan watak; Meningkatkan kekerapan watak semasa; Melewati semua indeks k - i, 2 k - i, 3 ​​k - i .... dan menyimpan kekerapan watak; Jika k adalah ganjil & i adalah samw sebagai k / 2, pecahkan gelung; Meningkatkan kekerapan watak semasa; Cari kekerapan maksimum watak di antara semua watak yang dikunjungi; Jika K adalah ganjil dan saya sama dengan K / 2 maka, hanya aksara N / K yang dikunjungi; Jika tidak, n / k * 2 aksara telah melawat; Mengembalikan hasilnya; Kod pemacu; Panggilan fungsi", "code": "import sys NEW_LINE def findMinimumChanges ( N , K , S ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( ( K + 1 ) // 2 ) : NEW_LINE INDENT mp = { } NEW_LINE for j in range ( i , N , K ) : NEW_LINE INDENT mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE DEDENT j = N - i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( ( K & 1 ) and ( i == K // 2 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE j -= K NEW_LINE DEDENT curr_max = - sys . maxsize - 1 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT curr_max = max ( curr_max , value ) NEW_LINE DEDENT if ( ( K & 1 ) and ( i == K // 2 ) ) : NEW_LINE INDENT ans += ( N // K - curr_max ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( N // K * 2 - curr_max ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aabbcbbcb \" NEW_LINE N = len ( S ) NEW_LINE K = 3 NEW_LINE print ( findMinimumChanges ( N , K , S ) ) NEW_LINE DEDENT"}
{"text": "Semak sama ada rentetan mengandungi sebarang indeks dengan lebih banyak daripada aktif aktif k | Fungsi untuk memeriksa sama ada mana -mana indeks mengandungi lebih banyak daripada ak aktif aktif; Simpan kejadian terakhir setiap watak; Menyimpan watak aktif; Masukkan watak; Jika saiz set melebihi k; Keluarkan watak dari set jika saya adalah indeks terakhir watak semasa; Kod pemacu", "code": "def checkString ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE dict = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT dict [ s [ i ] ] = i ; NEW_LINE DEDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( s [ i ] ) NEW_LINE if len ( st ) > K : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT if dict [ s [ i ] ] == i : NEW_LINE INDENT st . remove ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( \" No \" ) NEW_LINE DEDENT s = \" aabbcdca \" NEW_LINE K = 2 NEW_LINE checkString ( s , K ) NEW_LINE"}
{"text": "Kira bilangan rentetan dalam array yang wataknya berbeza kurang daripada m | Fungsi untuk mengira rentetan yang dikira watak -watak yang berbeza kurang daripada m; Gelung untuk melangkah ke atas semua rentetan array; Watak yang berbeza dalam rentetan dengan bantuan set; Memeriksa jika kurang daripada atau sama dengan m; Kod pemacu", "code": "def distinct ( S , M ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT c = len ( set ( [ d for d in S [ i ] ] ) ) NEW_LINE if ( c <= M ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = [ \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" ] NEW_LINE M = 7 NEW_LINE distinct ( S , M ) NEW_LINE DEDENT"}
{"text": "Keluarkan aksara frekuensi ganjil dari rentetan | Berfungsi untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; Untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi ganjil; Jika watak mempunyai kekerapan ganjil maka langkau; Lain menggabungkan watak ke rentetan baru; Kembalikan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi ganjil", "code": "def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT new_s = \" \" NEW_LINE for i in s : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_s += i NEW_LINE DEDENT return new_s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE str = removeOddFrequencyCharacters ( str ) NEW_LINE print ( str ) NEW_LINE DEDENT"}
{"text": "Produk nod di k | Fungsi rekursif untuk mencari produk unsur -unsur di peringkat k - th; Jika subtree adalah batal, sama seperti jika root == null; Pertimbangkan hanya nod tahap untuk menjadi sebahagian daripada produk; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Menjaga ')' selepas subtree kiri dan kanan; Kod pemacu", "code": "def productAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i [ 0 ] ] == ' ( ' ) : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE if ( tree [ i [ 0 ] ] == ' ) ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT product = 1 NEW_LINE if ( level == k ) : NEW_LINE INDENT product = int ( tree [ i [ 0 ] ] ) NEW_LINE DEDENT i [ 0 ] += 1 NEW_LINE leftproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE rightproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE return product * leftproduct * rightproduct NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" NEW_LINE k = 2 NEW_LINE i = [ 0 ] NEW_LINE print ( productAtKthLevel ( tree , k , i , 0 ) ) NEW_LINE DEDENT"}
{"text": "Cetak watak yang paling berlaku dalam pelbagai rentetan | Berfungsi untuk mencetak watak yang paling banyak berlaku; Mewujudkan hash saiz 26; Untuk gelung untuk melangkah melalui setiap rentetan array; Untuk gelung untuk melangkah melalui setiap watak rentetan; Meningkatkan kiraan watak dalam hash; Mencari watak dengan kiraan maksimum; Kod pemacu; Mengisytiharkan vektor jenis rentetan", "code": "def findMostOccurringChar ( string ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT for j in range ( len ( string [ i ] ) ) : NEW_LINE INDENT hash [ ord ( string [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT max = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT max = i if hash [ i ] > hash [ max ] else max ; NEW_LINE DEDENT print ( ( chr ) ( max + 97 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = [ ] ; NEW_LINE string . append ( \" animal \" ) ; NEW_LINE string . append ( \" zebra \" ) ; NEW_LINE string . append ( \" lion \" ) ; NEW_LINE string . append ( \" giraffe \" ) ; NEW_LINE findMostOccurringChar ( string ) ; NEW_LINE DEDENT"}
{"text": "Semak sama ada nombor titik terapung yang diberikan adalah palindrome | Fungsi yang mengembalikan benar jika NUM adalah palindrome; Tukar nombor titik terapung yang diberikan ke dalam rentetan; Penunjuk menunjuk kepada watak pertama dan terakhir rentetan; Bukan palindrome; Mengemas kini petunjuk; Kod pemacu", "code": "def isPalindrome ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE low = 0 NEW_LINE high = len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 123.321 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Bilangan maksimum kali str1 muncul sebagai bukan | Pelaksanaan Python3 pendekatan; Fungsi untuk mengembalikan bilangan maksimum kali STR1 boleh muncul sebagai STR2 Substring Bin Str2 yang tidak bertindih; STR1 tidak boleh menjadi substring str2; Simpan kekerapan watak Str1; Simpan kekerapan watak Str2; Untuk menyimpan kiraan substring yang diperlukan; Watak semasa tidak muncul dalam str1; Kekerapan watak semasa dalam Str1 adalah lebih besar daripada kekerapannya dalam Str2; Mengemas kini kiraan substrings yang mungkin; Kod pemacu", "code": "import sys NEW_LINE MAX = 26 ; NEW_LINE def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; NEW_LINE DEDENT return int ( minPoss ) ; NEW_LINE DEDENT str1 = \" geeks \" ; str2 = \" gskefrgoekees \" ; NEW_LINE len1 = len ( str1 ) ; NEW_LINE len2 = len ( str2 ) ; NEW_LINE print ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ; NEW_LINE"}
{"text": "Bilangan cara untuk memasukkan dua pasang kurungan ke dalam rentetan aksara n | Berfungsi untuk mengembalikan bilangan cara untuk memasukkan pasangan kurungan; Kod pemacu", "code": "def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) // 12 ; NEW_LINE return ways ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ab \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( cntWays ( string , n ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan minimum substrings rentetan yang diberikan boleh dibuang ke dalam yang memenuhi syarat -syarat yang diberikan | Pelaksanaan Python3 pendekatan; Tetapkan untuk menyimpan semua rentetan dari array yang diberikan; Untuk menyimpan kiraan yang diperlukan; Fungsi rekursif untuk mencari kiraan substrings yang boleh dibahagikan bermula dari indeks permulaan supaya semua substrings hadir dalam peta; Semua substring yang dipilih hadir dalam peta; Mengemas kini kiraan minimum substring; Bermula dari substrings panjang 1 yang bermula dengan indeks yang diberikan; Dapatkan substring; Jika substring hadir dalam set; Panggilan rekursif untuk sisa rentetan; Fungsi yang memasukkan semua rentetan dari array yang diberikan dalam satu set dan memanggil fungsi rekursif untuk mencari kiraan minimum substrings STR boleh dibuang ke dalam yang memenuhi syarat yang diberikan; Masukkan semua rentetan dari array yang diberikan dalam satu set; Cari kiraan yang diperlukan; Kod pemacu", "code": "import sys NEW_LINE uSet = set ( ) ; NEW_LINE minCnt = sys . maxsize ; NEW_LINE def findSubStr ( string , cnt , start ) : NEW_LINE INDENT global minCnt ; NEW_LINE if ( start == len ( string ) ) : NEW_LINE INDENT minCnt = min ( cnt , minCnt ) ; NEW_LINE DEDENT for length in range ( 1 , len ( string ) - start + 1 ) : NEW_LINE INDENT subStr = string [ start : start + length ] ; NEW_LINE if subStr in uSet : NEW_LINE INDENT findSubStr ( string , cnt + 1 , start + length ) ; NEW_LINE DEDENT DEDENT DEDENT def findMinSubStr ( arr , n , string ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT uSet . add ( arr [ i ] ) ; NEW_LINE DEDENT findSubStr ( string , 0 , 0 ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"123456\" ; NEW_LINE arr = [ \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMinSubStr ( arr , n , string ) ; NEW_LINE print ( minCnt ) ; NEW_LINE DEDENT"}
{"text": "Bilangan substring yang bermula dengan \"geeks\" dan berakhir dengan \"untuk\" | Berfungsi untuk mengembalikan kiraan substring yang diperlukan; Untuk setiap indeks rentetan; Jika substring bermula pada indeks semasa adalah \"geeks\"; Jika substring adalah \"untuk\"; Kod pemacu", "code": "def countSubStr ( s , n ) : NEW_LINE INDENT c1 = 0 ; c2 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i : i + 5 ] == \" geeks \" ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT if ( s [ i : i + 3 ] == \" for \" ) : NEW_LINE INDENT c2 = c2 + c1 ; NEW_LINE DEDENT DEDENT return c2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeksisforgeeks \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( countSubStr ( s , n ) ) ; NEW_LINE DEDENT"}
{"text": "Infytq 2019: Cari kedudukan dari mana kurungan tidak seimbang | Menentukan rentetan; Menyimpan pendakap pembukaan dalam senarai LST1; Menyimpan pendakap penutup dalam senarai LST2; Mewujudkan senarai kosong LST; Mewujudkan kamus untuk memetakan pendakap penutup untuk membuka; Jika kedudukan pertama rentetan mengandungi sebarang pendakap penutup kembali 1; Jika watak -watak rentetan membuka pendakap maka masukkannya ke dalam senarai; Apabila saiz senarai adalah 0 dan pendakap penutup baru ditemui kemudian cetak indeksnya bermula dari 1; Ketika kami menemui pendakap penutup, kami memetakan mereka dengan pendakap pembukaan yang sesuai dengan menggunakan kamus dan periksa sama ada ia sama dengan pendakap yang dibuka terakhir (elemen terakhir dalam senarai) jika ya maka kami memadamkan elemt dari senarai; Jika tidak, kami mengembalikan indeks (bermula dari 1) di mana bersarang didapati salah; Pada akhir jika senarai kosong itu bermaksud rentetan bersarang dengan sempurna", "code": "string = \" { [ ( ) ] } [ ] \" NEW_LINE lst1 = [ ' { ' , ' ( ' , ' [ ' ] NEW_LINE lst2 = [ ' } ' , ' ) ' , ' ] ' ] NEW_LINE lst = [ ] NEW_LINE Dict = { ' ) ' : ' ( ' , ' } ' : ' { ' , ' ] ' : ' [ ' } NEW_LINE a = b = c = 0 NEW_LINE if string [ 0 ] in lst2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if string [ i ] in lst1 : NEW_LINE INDENT lst . append ( string [ i ] ) NEW_LINE k = i + 2 NEW_LINE DEDENT else : NEW_LINE INDENT if len ( lst ) == 0 and ( string [ i ] in lst2 ) : NEW_LINE INDENT print ( i + 1 ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if Dict [ string [ i ] ] == lst [ len ( lst ) - 1 ] : NEW_LINE INDENT lst . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i + 1 ) NEW_LINE a = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if len ( lst ) == 0 and c == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE b = 1 NEW_LINE DEDENT if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT DEDENT"}
{"text": "Menyulitkan rentetan yang diberikan dengan operasi berikut | Pelaksanaan Python3 pendekatan di atas :; Berfungsi untuk mengembalikan rentetan yang disulitkan; Kurangkan x kerana putaran panjang 26 tidak perlu; Kirakan kekerapan aksara; Jika kekerapan aksara arus bahkan maka kenaikannya dengan x; Lain menurunkannya dengan x; Mengembalikan kiraan; Kod pemacu", "code": "MAX = 26 NEW_LINE def encryptstrr ( strr , n , x ) : NEW_LINE INDENT x = x % MAX NEW_LINE arr = list ( strr ) NEW_LINE freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( arr [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT pos = ( ord ( arr [ i ] ) - ord ( ' a ' ) + x ) % MAX NEW_LINE arr [ i ] = chr ( pos + ord ( ' a ' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = ( ord ( arr [ i ] ) - ord ( ' a ' ) - x ) NEW_LINE if ( pos < 0 ) : NEW_LINE INDENT pos += MAX NEW_LINE DEDENT arr [ i ] = chr ( pos + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT return \" \" . join ( arr ) NEW_LINE DEDENT s = \" abcda \" NEW_LINE n = len ( s ) NEW_LINE x = 3 NEW_LINE print ( encryptstrr ( s , n , x ) ) NEW_LINE"}
{"text": "Susun semula aksara dalam rentetan supaya tidak ada dua bersebelahan dengan menggunakan hashing | Fungsi yang mengembalikan benar jika mungkin untuk menyusun semula watak -watak rentetan supaya tidak dua aksara berturut -turut adalah sama; Untuk menyimpan kekerapan setiap watak; Untuk menyimpan kekerapan maksimum setakat ini; Jika boleh; Kod pemacu", "code": "def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Cari watak yang tidak biasa dari dua rentetan | Tetapkan 2 | Berfungsi untuk mencetak aksara yang tidak biasa dalam rentetan yang diberikan dalam urutan yang disusun; Menukar watak ke kod ASCII; Operasi bit; Menukar watak ke kod ASCII; Operasi bit; Operasi XOR hanya meninggalkan watak -watak yang tidak biasa dalam pembolehubah ANS; Kod pemacu", "code": "def printUncommon ( str1 , str2 ) : NEW_LINE INDENT a1 = 0 ; a2 = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT ch = ord ( str1 [ i ] ) - ord ( ' a ' ) ; NEW_LINE a1 = a1 | ( 1 << ch ) ; NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT ch = ord ( str2 [ i ] ) - ord ( ' a ' ) ; NEW_LINE a2 = a2 | ( 1 << ch ) ; NEW_LINE DEDENT ans = a1 ^ a2 ; NEW_LINE i = 0 ; NEW_LINE while ( i < 26 ) : NEW_LINE INDENT if ( ans % 2 == 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) ; NEW_LINE DEDENT ans = ans // 2 ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE str2 = \" geeksquiz \" ; NEW_LINE printUncommon ( str1 , str2 ) ; NEW_LINE DEDENT"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Set | Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Untuk menyimpan bilangan pembalikan yang diperlukan. ; Untuk menyimpan nombor pendakap pembukaan yang tidak seimbang. ; Untuk menyimpan nombor kurungan penutupan yang tidak seimbang. ; Jika pendakap semasa dibuka maka kenaikan kiraan terbuka. ; Jika pendakap semasa dekat, periksa sama ada mengimbangi pendakap pembukaan. Jika ya maka pengurangan kiraan pendakap pembukaan yang tidak seimbang, lain -lain kenaikan kiraan pendakap penutupan. ; Untuk kes itu: \"\" atau apabila satu penutupan dan satu pendakap pembukaan kekal untuk berpasangan, maka kedua -duanya perlu dibalikkan. ; Kod pemacu", "code": "def countMinReversals ( expr ) : NEW_LINE INDENT length = len ( expr ) NEW_LINE if length % 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = 0 NEW_LINE open = 0 NEW_LINE close = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if expr [ i ] == \" \" : NEW_LINE INDENT open += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if not open : NEW_LINE INDENT close += 1 NEW_LINE DEDENT else : NEW_LINE INDENT open -= 1 NEW_LINE DEDENT DEDENT DEDENT ans = ( close // 2 ) + ( open // 2 ) NEW_LINE close %= 2 NEW_LINE open %= 2 NEW_LINE if close > 0 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT expr = \" } } { { \" NEW_LINE print ( countMinReversals ( expr ) ) NEW_LINE DEDENT"}
{"text": "Pasangan watak dari dua rentetan dengan jumlah keseluruhan | Berfungsi untuk mengembalikan jumlah pasangan yang sah; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S1; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S2; Mengembalikan jumlah pasangan yang sah; Kod pemacu", "code": "def totalPairs ( s1 , s2 ) : NEW_LINE INDENT a1 = 0 ; b1 = 0 ; NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( ord ( s1 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT b1 += 1 ; NEW_LINE DEDENT DEDENT a2 = 0 ; b2 = 0 ; NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( ord ( s2 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a2 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT b2 += 1 ; NEW_LINE DEDENT DEDENT return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" for \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT"}
{"text": "Kejadian maksimum awalan dalam array | Berfungsi untuk mengembalikan kiraan awalan yang diperlukan; Cari kekerapan watak pertama str1ing; Kod pemacu", "code": "def prefixOccurrences ( str1 ) : NEW_LINE INDENT c = str1 [ 0 ] NEW_LINE countc = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == c ) : NEW_LINE INDENT countc += 1 NEW_LINE DEDENT DEDENT return countc NEW_LINE DEDENT str1 = \" abbcdabbcd \" NEW_LINE print ( prefixOccurrences ( str1 ) ) NEW_LINE"}
{"text": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar rentetan ke rentetan lain | Berfungsi untuk mengembalikan operasi minimum jenis yang diberikan untuk menukar rentetan s ke rentetan t; Watak sudah sama; Kiraan kenaikan 0 s; Kiraan kenaikan 1 s; Kod pemacu", "code": "def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT"}
{"text": "Dekripsi rentetan yang disulitkan dengan mengulangi i | Berfungsi untuk mengembalikan rentetan yang disahsulit; Lompat awal akan menjadi 1; Lompat kenaikan sebanyak 1 dengan setiap watak; Kod pemacu", "code": "def decryptString ( str , n ) : NEW_LINE INDENT i = 0 NEW_LINE jump = 1 NEW_LINE decryptedStr = \" \" NEW_LINE while ( i < n ) : NEW_LINE INDENT decryptedStr += str [ i ] ; NEW_LINE i += jump NEW_LINE jump += 1 NEW_LINE DEDENT return decryptedStr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeeeekkkksssss \" NEW_LINE n = len ( str ) NEW_LINE print ( decryptString ( str , n ) ) NEW_LINE DEDENT"}
{"text": "Cari bit yang flip urutan minimum menjadikan semua bit sama | Fungsi untuk memeriksa bit mana yang akan dibalik; pembolehubah untuk menyimpan watak pertama dan terakhir rentetan; Semak sama ada aksara pertama dan terakhir adalah sama, jika ya, kemudian kembalikan watak yang tidak akhirnya; lain kembali terakhir; Kod pemacu", "code": "def bitToBeFlipped ( s ) : NEW_LINE INDENT last = s [ len ( s ) - 1 ] NEW_LINE first = s [ 0 ] NEW_LINE if ( last == first ) : NEW_LINE INDENT if ( last == '0' ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT else : NEW_LINE INDENT return '0' NEW_LINE DEDENT DEDENT elif ( last != first ) : NEW_LINE INDENT return last NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"1101011000\" NEW_LINE print ( bitToBeFlipped ( s ) ) NEW_LINE DEDENT"}
{"text": "Jumlah dan produk frekuensi utama aksara dalam rentetan | Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencari jumlah frekuensi utama watak -watak rentetan yang diberikan; Peta digunakan untuk menyimpan frekuensi watak; Melintasi peta; Jika kekerapan adalah perdana; Kod pemacu", "code": "def SieveofEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumProdOfPrimeFreq ( s ) : NEW_LINE INDENT prime = [ True ] * ( len ( s ) + 2 ) NEW_LINE SieveofEratosthenes ( prime , len ( s ) + 1 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = ( m [ s [ i ] ] + 1 ) if s [ i ] in m else 1 NEW_LINE DEDENT s = 0 NEW_LINE product = 1 NEW_LINE for it in m : NEW_LINE INDENT if prime [ m [ it ] ] : NEW_LINE INDENT s += m [ it ] NEW_LINE product *= m [ it ] NEW_LINE DEDENT DEDENT print ( \" Sum ▁ = \" , s ) NEW_LINE print ( \" Product ▁ = \" , product ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sumProdOfPrimeFreq ( s ) NEW_LINE DEDENT"}
{"text": "Semak jika kekerapan aksara dalam satu rentetan adalah faktor atau pelbagai kekerapan watak yang sama dalam rentetan lain | Python3 pelaksanaan pendekatan di atas; Fungsi yang memeriksa jika kekerapan watak adalah faktor atau pelbagai antara satu sama lain; kekerapan kedai peta setiap aksara; Jika sebarang kekerapan adalah 0, maka teruskan sebagai keadaan berpuas hati; jika faktor atau berganda, maka keadaan berpuas hati; jika keadaan tidak berpuas hati; Kod pemacu", "code": "from collections import defaultdict NEW_LINE def multipleOrFactor ( s1 , s2 ) : NEW_LINE INDENT m1 = defaultdict ( lambda : 0 ) NEW_LINE m2 = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s1 ) ) : NEW_LINE INDENT m1 [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( s2 ) ) : NEW_LINE INDENT m2 [ s2 [ i ] ] += 1 NEW_LINE DEDENT for it in m1 : NEW_LINE INDENT if it not in m2 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( m2 [ it ] % m1 [ it ] == 0 or m1 [ it ] % m2 [ it ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" geeks \" NEW_LINE if multipleOrFactor ( s1 , s2 ) : print ( \" YES \" ) NEW_LINE else : print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Keluarkan walaupun aksara frekuensi dari rentetan | Fungsi yang menghilangkan aksara yang mempunyai frekuensi dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi; Jika watak mempunyai kekerapan, maka langkau; lain menggabungkan watak ke rentetan baru; Paparkan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi bahkan", "code": "def solve ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_string = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT new_string = new_string + s [ i ] NEW_LINE DEDENT print ( new_string ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE solve ( s ) NEW_LINE DEDENT"}
{"text": "Jumlah semua berikutnya nombor | Mengembalikan nilai angka berikutnya S. Berikutnya yang akan dipilih diputuskan menggunakan corak bit num (kami memilih semua thedigits yang mana terdapat set bit dalam NUM); Memulakan hasilnya; sehingga n! = 0; Jika saya - bit ditetapkan maka tambahkan nombor ini; Peralihan kanan i; fungsi untuk mencari jumlah gabungan semua jumlah keseluruhan individu; panjang rentetan; menyimpan gabungan; 2 ^ n - 1 berikutnya; gelung untuk semua berikutnya; mengembalikan jumlah gabungan; kod pemacu", "code": "def findSubSequence ( s , num ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE num = num >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def combinedSum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c_sum = 0 NEW_LINE ran = ( 1 << n ) - 1 NEW_LINE for i in range ( ran + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT return c_sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"123\" NEW_LINE print ( combinedSum ( s ) ) NEW_LINE DEDENT"}
{"text": "Susunan terpanjang di mana setiap watak berlaku sekurang -kurangnya k kali | Program Python untuk mencari seterusnya dengan setiap watak yang berlaku sekurang -kurangnya k kali dalam rentetan s; Berfungsi untuk mencari berikutnya; Mengambil array tambahan untuk menyimpan rekod untuk kiraan watak dalam s; Mengira kejadian semua aksara dalam STR []; Percetakan aksara dengan kiraan> = k dalam susunan yang sama kerana ia muncul dalam str. ; Kod pemacu", "code": "MAX_CHAR = 26 NEW_LINE def findSubsequence ( stri , k ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( len ( stri ) ) : NEW_LINE INDENT a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( stri ) ) : NEW_LINE INDENT if a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] >= k : NEW_LINE INDENT print ( stri [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT k = 2 NEW_LINE findSubsequence ( \" geeksforgeeks \" , k ) NEW_LINE"}
{"text": "Google Case Of A Sentyen tertentu | Program Python3 untuk menukar ayat ke Google Case. ; rentetan kosong; Tukar rentetan input ke atas kes; checki jika watak bukan ruang dan menambahkannya ke rentetan w; Menukar watak pertama ke kes yang lebih rendah dan huruf awal berikutnya perkataan lain kepada kes yang lebih rendah; Kod pemacu", "code": "def convert ( str ) : NEW_LINE INDENT w = \" \" NEW_LINE z = \" \" ; NEW_LINE str = str . upper ( ) + \" ▁ \" ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] ; NEW_LINE if ( ch != ' ▁ ' ) : NEW_LINE INDENT w = w + ch ; NEW_LINE DEDENT else : NEW_LINE INDENT z = ( z + ( w [ 0 ] ) . lower ( ) + w [ 1 : len ( w ) ] + \" ▁ \" ) ; NEW_LINE w = \" \" ; NEW_LINE DEDENT DEDENT return z ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks \" ; NEW_LINE print ( convert ( str ) ) ; NEW_LINE DEDENT"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan rentetan; CV untuk mengira vokal CC untuk mengira konsonan; Mengira awalan kiraan vokal dan awalan kiraan konsonan; Menjana rentetan yang disulitkan. ; Kod pemacu", "code": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT cv = [ 0 for i in range ( n ) ] NEW_LINE cc = [ 0 for i in range ( n ) ] NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT cv [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + isVowel ( s [ i ] ) NEW_LINE cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == False ) NEW_LINE DEDENT ans = \" \" NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += str ( prod ) NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ) NEW_LINE ans += str ( prod ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hello \" NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT"}
{"text": "Kira kejadian perkataan dalam rentetan | Program Python untuk mengira bilangan berlakunya perkataan dalam rentetan yang diberikan; berpecah rentetan dengan ruang dalam A; Cari corak dalam A; jika perlawanan mendapati kenaikan kiraan; Kod pemacu", "code": "def countOccurrences ( str , word ) : NEW_LINE INDENT a = str . split ( \" ▁ \" ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( word == a [ i ] ) : NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str = \" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ \" NEW_LINE word = \" portal \" NEW_LINE print ( countOccurrences ( str , word ) ) NEW_LINE"}
{"text": "Program untuk mencari inisial nama. | Program python3 untuk mencetak inisial nama; Pecahkan rentetan menggunakan 'ruang' dan cetak watak pertama setiap perkataan; Kod pemacu", "code": "def printInitials ( name ) : NEW_LINE INDENT if ( len ( name ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT words = name . split ( \" ▁ \" ) NEW_LINE for word in words : NEW_LINE INDENT print ( word [ 0 ] . upper ( ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT name = \" prabhat ▁ kumar ▁ singh \" NEW_LINE printInitials ( name ) NEW_LINE DEDENT"}
{"text": "Tinggalkan rentetan dengan menukar kes | Berfungsi untuk menjana permutasi; Bilangan permutasi adalah 2 ^ n; Menukar rentetan ke kes yang lebih rendah; Menggunakan semua berikutnya dan membenarkannya; Jika b - th bit ditetapkan, kami menukarnya ke atas kes; Mencetak gabungan semasa; Kod pemacu", "code": "def permute ( inp ) : NEW_LINE INDENT n = len ( inp ) NEW_LINE mx = 1 << n NEW_LINE inp = inp . lower ( ) NEW_LINE for i in range ( mx ) : NEW_LINE INDENT combination = [ k for k in inp ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) == 1 ) : NEW_LINE INDENT combination [ j ] = inp [ j ] . upper ( ) NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for i in combination : NEW_LINE INDENT temp += i NEW_LINE DEDENT print temp , NEW_LINE DEDENT DEDENT permute ( \" ABC \" ) NEW_LINE"}
{"text": "Cetak rentetan selepas watak yang ditentukan telah berlaku diberi tidak. masa | Berfungsi untuk mencetak rentetan; Jika diberi kiraan adalah 0 cetak rentetan yang diberikan dan kembali; Mula melintasi rentetan; Kenaikan OCC jika char semasa adalah sama dengan watak yang diberikan; Pecahkan gelung jika watak yang diberikan telah berlaku tidak diberikan. masa; Cetak rentetan selepas berlakunya watak yang diberikan tidak. masa; Jika tidak, rentetan kosong; Kod pemacu", "code": "def printString ( str , ch , count ) : NEW_LINE INDENT occ , i = 0 , 0 NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occ += 1 NEW_LINE DEDENT if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : len ( str ) - i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Empty ▁ string \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE printString ( str , ' e ' , 2 ) NEW_LINE DEDENT"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Mulakan dua indeks dari dua sudut dan bergerak ke arah satu sama lain; bertukar; Fungsi pemacu", "code": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT def reverseVowel ( str ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello ▁ world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT"}
{"text": "Bilangan minimum Palindromic selepas dikeluarkan untuk mengosongkan rentetan binari | Fungsi untuk memeriksa sama ada string str adalah palindrome; Bermula dari sudut paling kiri dan paling kanan Str; Terus membandingkan watak semasa mereka sama; Mengembalikan kiraan minimum palindromic subseuqnces untuk dikeluarkan untuk membuat rentetan kosong; Jika rentetan kosong; Jika rentetan adalah palindrome; Jika rentetan bukan palindrome; Kod pemacu", "code": "def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = l + 1 NEW_LINE h = h - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def minRemovals ( str ) : NEW_LINE INDENT if ( str [ 0 ] == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT print ( minRemovals ( \"010010\" ) ) NEW_LINE print ( minRemovals ( \"0100101\" ) ) NEW_LINE"}
{"text": "Cari nilai xxxx .... . (N kali) % m di mana n adalah besar | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y 2; Fungsi untuk mengembalikan xxx .... . (N kali) % m; Mengembalikan mod dengan m nombor yang lebih kecil; Mewujudkan rentetan n x 's; Menukar rentetan ke int dan mengira modulo; Memeriksa pariti n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk ganjil n; Kod pemacu; Cetak xxx ... (n kali) % m", "code": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findModuloByM ( X , N , M ) : NEW_LINE INDENT if ( N < 6 ) : NEW_LINE INDENT temp = chr ( 48 + X ) * N NEW_LINE res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N // 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE DEDENT else : NEW_LINE INDENT half = findModuloByM ( X , N // 2 , M ) % M ; NEW_LINE res = ( half * power ( 10 , N // 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE print ( findModuloByM ( X , N , M ) ) ; NEW_LINE DEDENT"}
{"text": "Semak jika dua lingkaran bersilang sedemikian rupa sehingga bulatan ketiga melewati titik -titik persimpangan dan pusat mereka | Program Python3 untuk pendekatan di atas; Struktur bulatan; Fungsi utiliti untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Menyimpan jarak antara pusat C1 dan C2; Menyimpan status jika kriteria yang diberikan berpuas hati atau tidak; Jika C1C2 kurang daripada jumlah radii 2 lingkaran pertama; Jika C3 adalah titik tengah pusat di C1 dan C2; Tanda bendera benar; Bendera kembali; Fungsi untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Semak kombinasi bulatan semasa; Semak kombinasi seterusnya; Kod pemacu", "code": "from math import sqrt NEW_LINE class circle : NEW_LINE INDENT def __init__ ( self , a , b , c ) : NEW_LINE INDENT self . x = a NEW_LINE self . y = b NEW_LINE self . r = c NEW_LINE DEDENT DEDENT def check ( C ) : NEW_LINE INDENT C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) NEW_LINE flag = 0 NEW_LINE if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) : NEW_LINE INDENT if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x and ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT def IsFairTriplet ( c ) : NEW_LINE INDENT f = False NEW_LINE f |= check ( c ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c [ 0 ] , c [ 2 ] = c [ 2 ] , c [ 0 ] NEW_LINE f |= check ( c ) NEW_LINE DEDENT return f NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = [ circle ( 0 , 0 , 0 ) for i in range ( 3 ) ] NEW_LINE C [ 0 ] = circle ( 0 , 0 , 8 ) NEW_LINE C [ 1 ] = circle ( 0 , 10 , 6 ) NEW_LINE C [ 2 ] = circle ( 0 , 5 , 5 ) NEW_LINE if ( IsFairTriplet ( C ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Program untuk mencari eksentrik hyperbola | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari eksentrik hiperbola; Menyimpan nisbah kuadrat paksi utama kepada paksi kecil; Kenaikan r oleh 1; Mengembalikan akar kuadrat R; Kod pemacu", "code": "import math NEW_LINE def eccHyperbola ( A , B ) : NEW_LINE INDENT r = B * B / A * A NEW_LINE r += 1 NEW_LINE return math . sqrt ( r ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 3.0 NEW_LINE B = 2.0 NEW_LINE print ( eccHyperbola ( A , B ) ) NEW_LINE DEDENT"}
{"text": "Kirakan kawasan kuadrilateral kitaran dengan panjang sampingan yang diberikan | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari kawasan kuadrilateral kitaran; Menyimpan nilai separuh perimeter; Kedai kawasan kuadrilateral kitaran; Mengembalikan kawasan yang dihasilkan; Kod pemacu", "code": "from math import sqrt NEW_LINE def calculateArea ( A , B , C , D ) : NEW_LINE INDENT S = ( A + B + C + D ) // 2 NEW_LINE area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 10 NEW_LINE B = 15 NEW_LINE C = 20 NEW_LINE D = 25 NEW_LINE print ( round ( calculateArea ( A , B , C , D ) , 3 ) ) NEW_LINE DEDENT"}
{"text": "Kirakan nisbah kawasan segitiga yang tertulis dalam elips dan segitiga yang dibentuk oleh titik yang sama pada bulatan tambahan | Fungsi untuk mengira nisbah segitiga yang tertulis dalam elips ke segitiga pada bulatan tambahan; Menyimpan nisbah separuh besar hingga separuh kapak kecil; Cetak nisbah; Kod pemacu", "code": "def triangleArea ( a , b ) : NEW_LINE INDENT ratio = b / a NEW_LINE print ( ratio ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE triangleArea ( a , b ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari excenters segitiga | Program Python3 untuk pendekatan di atas; Berfungsi untuk mengira jarak antara sepasang mata; Fungsi untuk mengira koordinat excenters segitiga; Panjang sisi segitiga; Menyimpan koordinat excenters segitiga; Untuk i1; Untuk i2; Untuk i3; Cetak excenters segitiga; Kod pemacu", "code": "from math import sqrt NEW_LINE def distance ( m , n , p , q ) : NEW_LINE INDENT return ( sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ) NEW_LINE DEDENT def Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT a = distance ( x2 , x3 , y2 , y3 ) NEW_LINE b = distance ( x3 , x1 , y3 , y1 ) NEW_LINE c = distance ( x1 , x2 , y1 , y2 ) NEW_LINE excenter = [ [ 0 , 0 ] for i in range ( 4 ) ] NEW_LINE excenter [ 1 ] [ 0 ] = ( ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) // ( - a + b + c ) ) NEW_LINE excenter [ 1 ] [ 1 ] = ( ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) // ( - a + b + c ) ) NEW_LINE excenter [ 2 ] [ 0 ] = ( ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) // ( a - b + c ) ) NEW_LINE excenter [ 2 ] [ 1 ] = ( ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) // ( a - b + c ) ) NEW_LINE excenter [ 3 ] [ 0 ] = ( ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) // ( a + b - c ) ) NEW_LINE excenter [ 3 ] [ 1 ] = ( ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) // ( a + b - c ) ) NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT print ( int ( excenter [ i ] [ 0 ] ) , int ( excenter [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE x2 = 3 NEW_LINE x3 = 0 NEW_LINE y1 = 0 NEW_LINE y2 = 0 NEW_LINE y3 = 4 NEW_LINE Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari ketinggian trapezoid | Program Python3 untuk melaksanakan pendekatan di atas; Fungsi untuk mengira ketinggian trapezoid; Memohon formula Heron; Hitung kawasan; Hitung ketinggian trapezoid; Prthe height ; Memandangkan A, B, P1 dan P2", "code": "import math NEW_LINE def findHeight ( p1 , p2 , b , c ) : NEW_LINE INDENT a = max ( p1 , p2 ) - min ( p1 , p2 ) NEW_LINE s = ( a + b + c ) // 2 NEW_LINE area = math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE height = ( area * 2 ) / a NEW_LINE print ( \" Height ▁ is : ▁ \" , height ) NEW_LINE DEDENT p1 = 25 NEW_LINE p2 = 10 NEW_LINE a = 14 NEW_LINE b = 13 NEW_LINE findHeight ( p1 , p2 , a , b ) NEW_LINE"}
{"text": "Nombor Icositetragonal | Berfungsi untuk mencari nombor icositetragonal; Formula untuk mengira nombor icositetragonal nth; Kod pemacu", "code": "def Icositetragonal_num ( n ) : NEW_LINE INDENT return ( 22 * n * n - 20 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Icositetragonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icositetragonal_num ( n ) ) ) NEW_LINE"}
{"text": "Kawasan bulatan yang ditulis dalam trapezoid isosceles | Fungsi untuk mencari kawasan bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Radius bulatan oleh formula i. e. akar (m * n) / 2 kawasan bulatan = (3.141) * (r * * 2); Kod pemacu", "code": "def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT"}
{"text": "Kawasan segitiga sama rata yang tertulis dalam lingkaran radius r | Berfungsi untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Asas dan ketinggian segitiga sama rata; Kawasan menggunakan asas dan ketinggian; Kod pemacu", "code": "def area ( R ) : NEW_LINE INDENT base = 1.732 * R NEW_LINE height = ( 3 / 2 ) * R NEW_LINE area = ( ( 1 / 2 ) * base * height ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT R = 7 NEW_LINE print ( area ( R ) ) NEW_LINE DEDENT"}
{"text": "Kawasan bulatan terbesar yang boleh ditulis dalam separuh bulatan | Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; Kawasan bulatan terbesar; Kod pemacu", "code": "def circlearea ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( 3.14 * R * R ) / 4 ; NEW_LINE return a ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 2 ; NEW_LINE print ( circlearea ( R ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan pasang garisan yang mempunyai titik persimpangan integer | Kiraan bilangan pasang garis yang mempunyai ersection ersection po; Memulakan susunan untuk menyimpan tuduhan; Kiraan bilangan ganjil dan bahkan pi; Kiraan bilangan ganjil dan bahkan qi; Mengembalikan kiraan pasangan; Kod pemacu", "code": "def countPairs ( P , Q , N , M ) : NEW_LINE INDENT A = [ 0 ] * 2 NEW_LINE B = [ 0 ] * 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ P [ i ] % 2 ] += 1 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT B [ Q [ i ] % 2 ] += 1 NEW_LINE DEDENT return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) NEW_LINE DEDENT P = [ 1 , 3 , 2 ] NEW_LINE Q = [ 3 , 0 ] NEW_LINE N = len ( P ) NEW_LINE M = len ( Q ) NEW_LINE print ( countPairs ( P , Q , N , M ) ) NEW_LINE"}
{"text": "Bilangan maksimum persimpangan garis yang dibentuk melalui persimpangan pesawat N | Berfungsi untuk mengira bilangan maksimum persimpangan yang mungkin; Kod pemacu", "code": "def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE"}
{"text": "Kawasan pentagram biasa | Pelaksanaan Python3 pendekatan; Berfungsi untuk mengembalikan kawasan segitiga BCD; Menggunakan nisbah emas; Hitung kawasan segitiga BCD; Kawasan pulangan semua 5 segitiga adalah sama; Berfungsi untuk mengembalikan kawasan pentagon biasa; Kirakan kawasan pentagon biasa menggunakan formula di atas; Kawasan pulangan Pentagon biasa; Berfungsi untuk mengembalikan kawasan pentagram; Kawasan pentagram adalah sama dengan kawasan pentagon biasa dan lima kali kawasan segitiga; Kod pemacu", "code": "import math NEW_LINE PI = 3.14159 NEW_LINE def areaOfTriangle ( d ) : NEW_LINE INDENT c = 1.618 * d NEW_LINE s = ( d + c + c ) / 2 NEW_LINE area = math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) NEW_LINE return 5 * area NEW_LINE DEDENT def areaOfRegPentagon ( d ) : NEW_LINE INDENT global PI NEW_LINE cal = 4 * math . tan ( PI / 5 ) NEW_LINE area = ( 5 * d * d ) / cal NEW_LINE return area NEW_LINE DEDENT def areaOfPentagram ( d ) : NEW_LINE INDENT return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) NEW_LINE DEDENT d = 5 NEW_LINE print ( areaOfPentagram ( d ) ) NEW_LINE"}
{"text": "Sudut yang disebarkan oleh kord ke pusat bulatan apabila sudut yang disuntik oleh kord lain yang sama dari lingkaran kongruen diberikan | Program Python 3 untuk mencari sudut yang disembur oleh kord ke pusat bulatan apabila sudut yang diselaraskan oleh satu lagi kord yang sama dari lingkaran kongruen diberikan; Kod pemacu", "code": "def anglequichord ( z ) : NEW_LINE INDENT print ( \" The ▁ angle ▁ is ▁ \" , z , \" ▁ degrees \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT"}
{"text": "Program untuk mencetak nilai ASCII bagi semua digit nombor tertentu | Berfungsi untuk menukar digit N ke nilai ASCII masing -masing; Kod pemacu", "code": "def convertToASCII ( N ) : NEW_LINE INDENT num = str ( N ) NEW_LINE i = 0 NEW_LINE for ch in num : NEW_LINE INDENT print ( ch , \" ( \" , ord ( ch ) , \" ) \" ) NEW_LINE DEDENT DEDENT N = 36 NEW_LINE convertToASCII ( N ) NEW_LINE"}
{"text": "Teka -teki Arus Produk | Set 3 | Program Python 3 untuk pendekatan di atas; Berfungsi untuk membentuk pelbagai produk dengan ruang O (n) dan o (1); Menyimpan produk array; Menyimpan kiraan sifar; Melintasi array; Jika arr [i] tidak sifar; Jika arr [i] adalah sifar maka kiraan kenaikan z oleh 1; Menyimpan nilai mutlak produk; Jika z sama dengan 1; Jika arr [i] tidak sifar; Lain; Jika kiraan 0 s sekurang -kurangnya 2; Berikan arr [i] = 0; Simpan nilai mutlak arr [i]; Cari nilai A / B; Jika arr [i] dan produk kedua -duanya kurang daripada sifar; Jika arr [i] dan produk kedua -duanya lebih besar daripada sifar; Lain; Melintasi array arr []; Kod pemacu; Panggilan fungsi", "code": "import math NEW_LINE def productExceptSelf ( arr , N ) : NEW_LINE INDENT product = 1 NEW_LINE z = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT a = abs ( product ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( z == 1 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = product NEW_LINE DEDENT continue NEW_LINE DEDENT elif ( z > 1 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT b = abs ( arr [ i ] ) NEW_LINE curr = round ( math . exp ( math . log ( a ) - math . log ( b ) ) ) NEW_LINE if ( arr [ i ] < 0 and product < 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT elif ( arr [ i ] > 0 and product > 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 * curr NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE productExceptSelf ( arr , N ) NEW_LINE"}
{"text": "Count Subarrays terdiri daripada single | Fungsi untuk mengira subarrays yang terdiri daripada bilangan bulat tunggal sahaja; Kedai kiraan subarray; Menyimpan kiraan nombor angka tunggal berturut -turut dalam array; Melintasi array; Saiz kenaikan blok sebanyak 1; Peningkatan res mengikut kiraan; Menetapkan kiraan = 0; Kod pemacu; Diberikan array; Saiz array", "code": "def singleDigitSubarrayCount ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE res += count NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 1 , 14 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE singleDigitSubarrayCount ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Fungsi untuk memeriksa sama ada nombor n boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut atau tidak; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Menyimpan kiraan yang diperlukan; Kod pemacu", "code": "def isPossible ( N ) : NEW_LINE INDENT return ( ( N & ( N - 1 ) ) and N ) NEW_LINE DEDENT def countElements ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isPossible ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE countElements ( N ) NEW_LINE DEDENT"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Mengira kuasa 2 sehingga n; Kiraan kenaikan; Mengemas kini kuasa semasa 2; Kod pemacu", "code": "def countElements ( N ) : NEW_LINE INDENT Cur_Ele = 1 NEW_LINE Count = 0 NEW_LINE while ( Cur_Ele <= N ) : NEW_LINE INDENT Count += 1 NEW_LINE Cur_Ele = Cur_Ele * 2 NEW_LINE DEDENT print ( N - Count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE countElements ( N ) NEW_LINE DEDENT"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Program Python 3 untuk pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Kirakan perbezaan bersebelahan maksimum untuk keseluruhan array; Simpan maksimum antara arr_max dan curr_max; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "import sys NEW_LINE def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE arr_max = - sys . maxsize - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT for i in range ( 1 , N - 1 ) : NEW_LINE INDENT curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) NEW_LINE ans = max ( curr_max , arr_max ) NEW_LINE res . append ( ans ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kurangkan kenaikan yang diperlukan untuk membuat kiraan elemen array yang sama dan ganjil sama | Berfungsi untuk mencari operasi min untuk membuat kiraan yang sama dan ganjil sama; Saiz ganjil tidak akan menjadi ganjil dan juga dianggap sama; Menyimpan kiraan nombor walaupun dalam array arr []; Kedai mengira nombor ganjil dalam array arr []; Melintasi array arr []; Jika arr [i] adalah nombor yang sama; Kemas kini cnteven; Nombor ganjil dalam arr []; Kembali perbezaan mutlak dibahagikan dengan 2; Kod pemacu; Panggilan fungsi", "code": "def minimumIncrement ( arr , N ) : NEW_LINE INDENT if ( N % 2 != 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT cntEven = 0 NEW_LINE cntOdd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 NEW_LINE DEDENT DEDENT cntOdd = N - cntEven NEW_LINE return abs ( cntEven - cntOdd ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minimumIncrement ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk membina array dengan produk walaupun dari array yang diberikan sedemikian rupa sehingga perbezaan mutlak unsur -unsur yang diindeks sama paling banyak 1 | Fungsi untuk mencari mengira cara untuk membina array, B [] seperti abs (a [i] - b [i]) <= 1 dan produk unsur -unsur B [] adalah walaupun; Kedai kiraan tatasusunan b [] seperti abs (a [i] - b [i]) <= 1; Kedai -kedai Count of Arrays B [] yang produk elemennya tidak; Melintasi array; Jumlah kemas kini; Jika [i] adalah nombor yang sama; Kemas kini Oddarray; Cetak 3 ^ n - 2 ^ x; Kod pemacu", "code": "def cntWaysConsArray ( A , N ) : NEW_LINE INDENT total = 1 ; NEW_LINE oddArray = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT total = total * 3 ; NEW_LINE if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT oddArray *= 2 ; NEW_LINE DEDENT DEDENT print ( total - oddArray ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 4 ] ; NEW_LINE N = len ( A ) ; NEW_LINE cntWaysConsArray ( A , N ) ; NEW_LINE DEDENT"}
{"text": "Kira nombor sehingga n yang paling tepat ditetapkan adalah k | Fungsi untuk mengira nombor dalam julat [1, n] yang paling tepat ditetapkan adalah k; Menyimpan nombor yang paling tepat adalah k; Nombor yang paling tepat adalah i; Mengurangkan nombor yang paling tepat ditetapkan adalah saya, dari n; Oleh kerana i = k, maka nombor yang paling tepat ditetapkan adalah k disimpan; Kod pemacu", "code": "def countNumberHavingKthBitSet ( N , K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT numbers_rightmost_bit_i = ( N + 1 ) // 2 NEW_LINE N -= numbers_rightmost_bit_i NEW_LINE if ( i == K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = numbers_rightmost_bit_i NEW_LINE DEDENT DEDENT print ( numbers_rightmost_setbit_K ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE K = 2 NEW_LINE countNumberHavingKthBitSet ( N , K ) NEW_LINE DEDENT"}
{"text": "Kira pekali ganjil dan bahkan binomial N | Fungsi untuk mengira set bit dalam perwakilan binari nombor n; Count set bit dalam n; Mengembalikan kiraan akhir; Kod pemacu; Cetak koefisien binomial ganjil; Cetak walaupun koefisien binomial", "code": "def countSetBits ( N : int ) -> int : NEW_LINE INDENT count = 0 NEW_LINE while ( N ) : NEW_LINE INDENT N = N & ( N - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE bits = countSetBits ( N ) NEW_LINE print ( \" Odd ▁ : ▁ { } \" . format ( pow ( 2 , bits ) ) ) NEW_LINE print ( \" Even ▁ : ▁ { } \" . format ( N + 1 - pow ( 2 , bits ) ) ) NEW_LINE DEDENT"}
{"text": "Buat semua elemen array walaupun dengan menggantikan mana -mana sepasang elemen array dengan jumlah mereka | Fungsi untuk mencari bilangan minimum penggantian yang diperlukan untuk membuat semua elemen array walaupun; Menyimpan kiraan elemen ganjil; Melintasi array; Meningkatkan kiraan elemen ganjil; Bilangan penggantian yang diperlukan; Dua langkah tambahan diperlukan untuk membuat elemen ganjil yang terakhir walaupun; Premen penggantian minimum; Kod pemacu; Panggilan fungsi", "code": "def minMoves ( arr , N ) : NEW_LINE INDENT odd_element_cnt = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT odd_element_cnt += 1 ; NEW_LINE DEDENT DEDENT moves = ( odd_element_cnt ) // 2 ; NEW_LINE if ( odd_element_cnt % 2 != 0 ) : NEW_LINE INDENT moves += 2 ; NEW_LINE DEDENT print ( moves ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 7 , 20 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE minMoves ( arr , N ) ; NEW_LINE DEDENT"}
{"text": "Split Squares of First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Berfungsi untuk partition squares nombor semulajadi dalam dua subset; Simpan kiraan blok saiz 8; Pemisahan blok 8 elemen; Simpan perbezaan subset minimum; Pemisahan elemen N untuk meminimumkan perbezaan jumlah subset mereka; Simpan unsur subset A dan B; Jika elemen adalah jenis A; Jika elemen adalah jenis B; Cetak perbezaan subset minimum; Cetak subset pertama; Cetak subset kedua; Kod pemacu; Panggilan fungsi", "code": "def minimumSubsetDifference ( N ) : NEW_LINE INDENT blockOfSize8 = N // 8 NEW_LINE str = \" ABBABAAB \" NEW_LINE subsetDifference = 0 NEW_LINE partition = \" \" NEW_LINE while blockOfSize8 != 0 : NEW_LINE INDENT partition = partition + str NEW_LINE blockOfSize8 = blockOfSize8 - 1 NEW_LINE DEDENT A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if partition [ i ] == ' A ' : NEW_LINE INDENT A . append ( ( i + 1 ) * ( i + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( ( i + 1 ) * ( i + 1 ) ) NEW_LINE DEDENT DEDENT print ( subsetDifference ) NEW_LINE for i in A : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE for i in B : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT N = 8 NEW_LINE minimumSubsetDifference ( N ) NEW_LINE"}
{"text": "Pembahagi terbesar nombor yang tidak dapat dibahagikan dengan nombor yang lain | Program Python3 untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari nombor terbesar x supaya ia membahagikan p tetapi tidak dapat dibahagikan dengan q; Menyimpan kiraan kekerapan semua faktor utama; Meningkatkan kekerapan faktor utama semasa; Jika Q adalah faktor utama; Menyimpan hasil yang diingini; Melangkah melalui semua pembahagi Q; Menyimpan kiraan kekerapan pembahagi utama semasa untuk membahagikan p; Mengira kekerapan faktor utama semasa; Jika CUR kurang daripada kekerapan maka p adalah hasil akhir; Berulang untuk mendapatkan jawapan sementara; Mengemas kini jawapan semasa; Cetak hasil yang diinginkan; Kod pemacu; Diberikan p dan q; Panggilan fungsi", "code": "from collections import defaultdict NEW_LINE def findTheGreatestX ( P , Q ) : NEW_LINE INDENT divisiors = defaultdict ( int ) NEW_LINE i = 2 NEW_LINE while i * i <= Q : NEW_LINE INDENT while ( Q % i == 0 and Q > 1 ) : NEW_LINE INDENT Q //= i NEW_LINE divisiors [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( Q > 1 ) : NEW_LINE INDENT divisiors [ Q ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in divisiors : NEW_LINE INDENT frequency = divisiors [ i ] NEW_LINE temp = P NEW_LINE cur = 0 NEW_LINE while ( temp % i == 0 ) : NEW_LINE INDENT temp //= i NEW_LINE cur += 1 NEW_LINE DEDENT if ( cur < frequency ) : NEW_LINE INDENT ans = P NEW_LINE break NEW_LINE DEDENT temp = P NEW_LINE for j in range ( cur , frequency - 1 , - 1 ) : NEW_LINE INDENT temp //= i NEW_LINE DEDENT ans = max ( temp , ans ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT P = 10 NEW_LINE Q = 4 NEW_LINE findTheGreatestX ( P , Q ) NEW_LINE DEDENT"}
{"text": "Semak jika baris matriks boleh disusun semula untuk membuat bitwise xor lajur pertama non | Fungsi untuk memeriksa sama ada ada baris di mana bilangan elemen unik lebih besar daripada 1; Melangkah ke atas matriks; Fungsi untuk memeriksa sama ada mungkin untuk menyusun semula tikar [] [] supaya xor lajur pertamanya bukan sifar; Cari bitwise xor lajur pertama Mat [] []; Jika bitwise xor lajur pertama tikar [] [] bukan sifar; Jika tidak, periksa semula; Kod pemacu; Diberikan matriks mat [] []; Panggilan fungsi", "code": "def checkRearrangements ( mat , N , M ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT DEDENT return \" No \" NEW_LINE DEDENT def nonZeroXor ( mat , N , M ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = res ^ mat [ i ] [ 0 ] NEW_LINE DEDENT if ( res != 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return checkRearrangements ( mat , N , M ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 2 ] , [ 2 , 2 , 2 ] , [ 3 , 3 , 3 ] ] NEW_LINE N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE print ( nonZeroXor ( mat , N , M ) ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan bitwise dan elemen pertama dengan pelengkap elemen yang tinggal untuk sebarang permutasi array yang diberikan | Fungsi untuk memaksimumkan nilai untuk fungsi yang diberikan dan elemen array; Arahan vektor untuk mengekalkan bit mana yang ditetapkan untuk integer dalam array yang diberikan dengan menyimpan indeks integer itu; Semak jika b - th bit ditetapkan untuk integer i - th; Tolak indeks integer itu dalam setbit [j]; Cari elemen yang mempunyai bit set signifikan tertinggi dalam unsur -unsur lain; Letakkan integer itu pada indeks 0 - th; Simpan maksimum dan nilai; Kembalikan jawapannya; Kod pemacu; Panggilan fungsi", "code": "def functionMax ( arr , n ) : NEW_LINE INDENT setBit = [ [ ] for i in range ( 32 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << j ) ) : NEW_LINE INDENT setBit [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( len ( setBit [ i ] ) == 1 ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ setBit [ i ] [ 0 ] ] NEW_LINE arr [ setBit [ i ] [ 0 ] ] = temp NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT maxAnd = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT maxAnd = ( maxAnd & ( ~ arr [ i ] ) ) NEW_LINE DEDENT return maxAnd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE print ( functionMax ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Berfungsi untuk mengira dan mengembalikan jumlah produk; Memulakan jumlah hingga 0; Melintasi 0 hingga k; Kod pemacu", "code": "def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res ; NEW_LINE DEDENT def solve ( n , m , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT sum += nCr ( n , i ) * nCr ( m , k - i ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 ; NEW_LINE print ( solve ( n , m , k ) ) NEW_LINE DEDENT"}
{"text": "Exponention Cepat Menggunakan Manipulasi Bit | Berfungsi untuk mengembalikan A ^ n; Kedai Jawapan Akhir; Semak jika LSB semasa ditetapkan; Peralihan kanan; Kod pemacu", "code": "def powerOptimised ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last_bit = ( n & 1 ) NEW_LINE if ( last_bit ) : NEW_LINE INDENT ans = ans * a NEW_LINE DEDENT a = a * a NEW_LINE n = n >> 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE n = 5 NEW_LINE print ( powerOptimised ( a , n ) ) NEW_LINE DEDENT"}
{"text": "Cari M sedemikian rupa sehingga GCD M dan Nombor N adalah maksimum | Berfungsi untuk mencari integer m sedemikian rupa sehingga GCD (n, m) adalah maksimum; Memulakan pembolehubah; Cari semua pembahagi N dan kembalikan pembahagi maksimum; Semak jika saya boleh dibahagikan dengan n; Kemas kini max_gcd; Mengembalikan nilai maksimum; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "def findMaximumGcd ( n ) : NEW_LINE INDENT max_gcd = 1 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if ( i > max_gcd ) : NEW_LINE INDENT max_gcd = i NEW_LINE DEDENT if ( ( n / i != i ) and ( n / i != n ) and ( ( n / i ) > max_gcd ) ) : NEW_LINE INDENT max_gcd = n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( int ( max_gcd ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findMaximumGcd ( n ) ) NEW_LINE DEDENT"}
{"text": "Elemen pertama setiap set K mempunyai unsur berturut -turut dengan faktor -faktor utama yang kurang daripada n | Program Python3 untuk pendekatan di atas; Untuk menyimpan faktor utama terkecil; Fungsi membina pelbagai faktor utama terkecil; Tandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Semak jika saya adalah Perdana; Mark SPF untuk semua nombor yang boleh dibahagikan oleh i; Mark SPF [i] jika ia tidak ditandakan sebelum ini; Fungsi untuk jumlah jumlah faktor utama; Fungsi untuk mencetak unsur -unsur set un elemen berturut -turut yang mempunyai faktor utama; Untuk menyimpan hasilnya; Mengira bilangan faktor utama nombor; Jika nombor mempunyai faktor yang betul -betul puch dalam hasil []; Melangkah sehingga kita mendapat unsur -unsur berturut -turut dalam hasil []; Mengira urutan sehingga k; Cetak elemen jika Count> = k; Kod pemacu; Untuk membina SPF []; Diberikan n dan k; Panggilan fungsi", "code": "x = 2000021 NEW_LINE v = [ 0 ] * x NEW_LINE def sieve ( ) : NEW_LINE INDENT v [ 1 ] = 1 NEW_LINE for i in range ( 2 , x ) : NEW_LINE INDENT v [ i ] = i NEW_LINE DEDENT for i in range ( 4 , x , 2 ) : NEW_LINE INDENT v [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < x ) : NEW_LINE INDENT if ( v [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , x , i ) : NEW_LINE INDENT if ( v [ j ] == j ) : NEW_LINE INDENT v [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def prime_factors ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE while ( n != 1 ) : NEW_LINE INDENT s . add ( v [ n ] ) NEW_LINE n = n // v [ n ] NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT def distinctPrimes ( m , k ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 14 , m + k ) : NEW_LINE INDENT count = prime_factors ( i ) NEW_LINE if ( count == k ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT p = len ( result ) NEW_LINE for index in range ( p - 1 ) : NEW_LINE INDENT element = result [ index ] NEW_LINE count = 1 NEW_LINE z = index NEW_LINE while ( z < p - 1 and count <= k and result [ z ] + 1 == result [ z + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE z += 1 NEW_LINE DEDENT if ( count >= k ) : NEW_LINE INDENT print ( element , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sieve ( ) NEW_LINE N = 1000 NEW_LINE K = 3 NEW_LINE distinctPrimes ( N , K ) NEW_LINE DEDENT"}
{"text": "Produk nombor kompleks menggunakan tiga operasi pendaraban | Berfungsi untuk membiak nombor kompleks dengan hanya tiga pendaraban; Cari nilai prod1, prod2 dan prod3; Bahagian sebenar; Bahagian khayalan; Cetak hasilnya; Given four numbers ; Panggilan fungsi", "code": "def print_product ( a , b , c , d ) : NEW_LINE INDENT prod1 = a * c NEW_LINE prod2 = b * d NEW_LINE prod3 = ( a + b ) * ( c + d ) NEW_LINE real = prod1 - prod2 NEW_LINE imag = prod3 - ( prod1 + prod2 ) NEW_LINE print ( real , \" ▁ + ▁ \" , imag , \" i \" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE print_product ( a , b , c , d ) NEW_LINE"}
{"text": "Nombor Insolite | Fungsi untuk memeriksa sama ada nombor adalah nombor insolit; Untuk menyimpan jumlah kuadrat digit; Untuk menyimpan produk dataran digit; mengekstrak digit; Kod pemacu; Panggilan fungsi", "code": "def isInsolite ( n ) : NEW_LINE INDENT N = n ; NEW_LINE sum = 0 ; NEW_LINE product = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 ; NEW_LINE sum = sum + r * r ; NEW_LINE product = product * r * r ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return ( ( N % sum == 0 ) and ( N % product == 0 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 111 ; NEW_LINE if ( isInsolite ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text": "D Nombor | Pelaksanaan Python3 untuk pendekatan di atas; Berfungsi untuk mencari nombor N - th icosikaipentagon; Nombor hendaklah lebih besar daripada 3; Semak setiap k dalam julat 2 hingga n - 1; keadaan untuk nombor D; Kod pemacu", "code": "import math NEW_LINE def isDNum ( n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return False NEW_LINE DEDENT for k in range ( 2 , n ) : NEW_LINE INDENT numerator = pow ( k , n - 2 ) - k NEW_LINE hcf = math . gcd ( n , k ) NEW_LINE if ( hcf == 1 and ( numerator % n ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 15 NEW_LINE if isDNum ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Ruth | Berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; Jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Berfungsi untuk memeriksa nombor Ruth - Aaron; Kod pemacu", "code": "def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT DEDENT DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE DEDENT def RuthAaronNumber ( n ) : NEW_LINE INDENT if ( Sum ( n ) == Sum ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT N = 714 NEW_LINE if ( RuthAaronNumber ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan dalam array dengan jumlah k | Fungsi untuk memaksimumkan jumlah; Perbezaan adalah 0 apabila hanya satu elemen yang terdapat dalam array; Perbezaan adalah k apabila dua elemen hadir dalam pelbagai; Jika tidak; Kod pemacu", "code": "def maxAdjacentDifference ( N , K ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return K ; NEW_LINE DEDENT return 2 * K ; NEW_LINE DEDENT N = 6 ; NEW_LINE K = 11 ; NEW_LINE print ( maxAdjacentDifference ( N , K ) ) ; NEW_LINE"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Tetapkan 2 | Program Python3 untuk pendekatan di atas; Fungsi mengembalikan jumlah nombor dari 1 hingga n; Fungsi mengembalikan jumlah nombor dari A + 1 hingga B; Fungsi mengembalikan jumlah jumlah pembahagi; Kedai Jumlah Jumlah; Mencari nombor dan kejadiannya; Jumlah produk setiap nombor dan kejadiannya; Kod pemacu", "code": "mod = 1000000007 NEW_LINE def linearSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) // 2 % mod NEW_LINE DEDENT def rangeSum ( b , a ) : NEW_LINE INDENT return ( linearSum ( b ) - ( linearSum ( a ) ) ) % mod NEW_LINE DEDENT def totalSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT result += rangeSum ( n // i , n // ( i + 1 ) ) * ( i % mod ) % mod ; NEW_LINE result %= mod ; NEW_LINE if i == n : NEW_LINE INDENT break NEW_LINE DEDENT i = n // ( n // ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( totalSum ( N ) ) NEW_LINE N = 12 NEW_LINE print ( totalSum ( N ) ) NEW_LINE"}
{"text": "Nombor undulant nontrivial | Fungsi untuk memeriksa sama ada rentetan adalah rentetan ganda atau tidak; A dan B tidak sepatutnya sama; Keadaan untuk memeriksa sama ada panjang ganjil membuat panjang walaupun; Separuh pertama s; Separuh kedua s; Rentetan double jika separuh pertama dan terakhir adalah sama; Fungsi untuk memeriksa sama ada n adalah nombor undulant yang tidak dapat dipulihkan; Kod pemacu", "code": "def isDouble ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE l = len ( s ) NEW_LINE if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( l % 2 == 1 ) : NEW_LINE INDENT s = s + s [ 1 ] NEW_LINE l += 1 NEW_LINE DEDENT s1 = s [ : l // 2 ] NEW_LINE s2 = s [ l // 2 : ] NEW_LINE return s1 == s2 NEW_LINE DEDENT def isNontrivialUndulant ( N ) : NEW_LINE INDENT return N > 100 and isDouble ( N ) NEW_LINE DEDENT n = 121 NEW_LINE if ( isNontrivialUndulant ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Nombor Megagon | Berfungsi untuk mencari nombor megagon nth; Kod pemacu", "code": "def MegagonNum ( n ) : NEW_LINE INDENT return ( 999998 * n * n - 999996 * n ) // 2 ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( MegagonNum ( n ) ) ; NEW_LINE"}
{"text": "Produk semua pasangan dari array yang diberikan | Pelaksanaan Python3 untuk mencari produk semua pasangan dari array yang diberikan; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Gelung bersarang untuk mengira semua pasangan yang mungkin; Melipatgandakan produk unsur -unsur pasangan semasa; Mengembalikan hasil akhir; Kod pemacu", "code": "mod = 1000000007 ; NEW_LINE def productPairs ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; NEW_LINE product = product % mod ; NEW_LINE DEDENT DEDENT return product % mod ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( productPairs ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Produk semua pasangan dari array yang diberikan | Pelaksanaan Python3 untuk mencari produk semua pasangan dari array yang diberikan; Fungsi untuk mengira (x ^ y) % 1000000007; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; Mengembalikan hasil akhir; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Berulang untuk setiap elemen array; Setiap elemen muncul (2 * n) kali; Kod pemacu", "code": "mod = 1000000007 NEW_LINE def power ( x , y ) : NEW_LINE INDENT p = 1000000007 NEW_LINE res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) != 0 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def productPairs ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = ( product % mod * ( int ) ( power ( arr [ i ] , ( 2 * n ) ) ) % mod ) % mod NEW_LINE DEDENT return ( product % mod ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPairs ( arr , n ) ) NEW_LINE"}
{"text": "Membina array sedemikian rupa sehingga jumlah kiub semua elemen adalah persegi yang sempurna | Berfungsi untuk membuat dan mencetak array; Memulakan pelbagai saiz n; Cetak array; Kod pemacu", "code": "def constructArray ( N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i - 1 ] = i ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT N = 6 ; NEW_LINE constructArray ( N ) ; NEW_LINE"}
{"text": "Kira semua seterusnya yang produknya adalah nombor komposit | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk mencari bilangan berikutnya yang produknya adalah nombor komposit; Cari jumlah berikutnya yang tidak kosong; Cari kiraan nombor utama dan yang; Kirakan yang tidak kosong; Cari kiraan seterusnya komposit; Kod pemacu", "code": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def countSubsequences ( arr , n ) : NEW_LINE INDENT totalSubsequence = ( int ) ( pow ( 2 , n ) - 1 ) ; NEW_LINE countPrime = 0 ; NEW_LINE countOnes = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT countOnes += 1 ; NEW_LINE DEDENT elif ( isPrime ( arr [ i ] ) ) : NEW_LINE INDENT countPrime += 1 ; NEW_LINE DEDENT DEDENT compositeSubsequence = 0 ; NEW_LINE onesSequence = ( int ) ( pow ( 2 , countOnes ) - 1 ) ; NEW_LINE compositeSubsequence = ( totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ) ; NEW_LINE return compositeSubsequence ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countSubsequences ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Cari integer berturut -turut seperti jumlah mereka adalah n | Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah K berturut -turut; Mencari istilah pertama AP; Memeriksa jika istilah pertama adalah integer; Gelung untuk mencetak integer K berturut -turut; Kod pemacu", "code": "def checksum ( n , k ) : NEW_LINE INDENT first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 NEW_LINE if ( first_term - int ( first_term ) == 0 ) : NEW_LINE INDENT for i in range ( int ( first_term ) , int ( first_term ) + k ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( n , k ) = ( 33 , 6 ) NEW_LINE checksum ( n , k ) NEW_LINE DEDENT"}
{"text": "Mewakili n sebagai jumlah k angka bahu | Berfungsi untuk mencetak perwakilan; N mestilah lebih besar daripada sama dengan 2 * k dan mestilah bahkan; Kod pemacu", "code": "def sumEvenNumbers ( N , K ) : NEW_LINE INDENT check = N - 2 * ( K - 1 ) NEW_LINE if ( check > 0 and check % 2 == 0 ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( \"2 ▁ \" , end = \" \" ) NEW_LINE DEDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT N = 8 NEW_LINE K = 2 NEW_LINE sumEvenNumbers ( N , K ) NEW_LINE"}
{"text": "Count of Subarrays Bersebelahan mungkin untuk setiap indeks dengan memasukkan elemen pada indeks itu | Berfungsi untuk mencari bilangan subarray termasuk elemen pada setiap indeks array; Mewujudkan pelbagai saiz n; Gelung itu berulang sehingga separuh panjang array; Keadaan untuk mengelakkan menimpa elemen pertengahan untuk array dengan panjangnya. ; Pengkomputeran bilangan subarray; Unsur ITH dari awal dan berakhir mempunyai bilangan subarray yang sama; Berfungsi untuk mencetak vektor; Kod pemacu", "code": "def calculateWays ( N ) : NEW_LINE INDENT x = 0 ; NEW_LINE v = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT v . append ( 0 ) ; NEW_LINE DEDENT for i in range ( N // 2 + 1 ) : NEW_LINE INDENT if ( N % 2 == 0 and i == N // 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT x = N * ( i + 1 ) - ( i + 1 ) * i ; NEW_LINE v [ i ] = x ; NEW_LINE v [ N - i - 1 ] = x ; NEW_LINE DEDENT return v ; NEW_LINE DEDENT def printArray ( v ) : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = calculateWays ( 4 ) ; NEW_LINE printArray ( v ) ; NEW_LINE DEDENT"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan x yang jumlah digitnya boleh dibahagikan dengan y | Program Python3 untuk mencari bilangan terkecil yang lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Fungsi yang mengembalikan jumlah digit nombor; Memulakan pembolehubah untuk menyimpan jumlah; Tambah digit terakhir nombor; Keluarkan digit terakhir dari nombor; Fungsi yang mengembalikan bilangan terkecil lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Memulakan pemboleh ubah hasil; Gelung melalui nombor yang lebih besar daripada sama dengan x; Hitung jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan y; Kod pemacu", "code": "MAXN = 10000000 NEW_LINE def sumOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def smallestNum ( X , Y ) : NEW_LINE INDENT res = - 1 ; NEW_LINE for i in range ( X , MAXN ) : NEW_LINE INDENT sum_of_digit = sumOfDigits ( i ) NEW_LINE if sum_of_digit % Y == 0 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( X , Y ) = ( 5923 , 13 ) NEW_LINE print ( smallestNum ( X , Y ) ) NEW_LINE DEDENT"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Simpan semua pembahagi n; Jika saya seorang pembahagi; Jika saya tidak sama dengan N / I; Melangkah melalui semua pembahagi n - 1 dan mengira mereka sebagai jawapan; Semak jika N - 1 adalah pembahagi atau tidak; Melangkah melalui semua pembahagi dan semak n Mod D = 1 atau (n - 1) mod d = 0; Kod pemacu", "code": "def countValues ( N ) : NEW_LINE INDENT div = [ ] NEW_LINE i = 2 NEW_LINE while ( ( i * i ) <= N ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT div . append ( i ) NEW_LINE if ( N != i * i ) : NEW_LINE INDENT div . append ( N // i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT answer = 0 NEW_LINE i = 1 NEW_LINE while ( ( i * i ) <= N - 1 ) : NEW_LINE INDENT if ( ( N - 1 ) % i == 0 ) : NEW_LINE INDENT if ( i * i == N - 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for d in div : NEW_LINE INDENT K = N NEW_LINE while ( K % d == 0 ) : NEW_LINE INDENT K //= d NEW_LINE DEDENT if ( ( K - 1 ) % d == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT"}
{"text": "Maksimum mungkin pembahagi utama yang boleh wujud dalam nombor yang mempunyai tepat n pembahagi | Berfungsi untuk mencari pembahagi utama maksimum nombor yang boleh dimiliki dengan pembahagi N; Bilangan bilangan masa dibahagikan dengan 2; Membahagikan dengan nombor perdana lain; Jika bilangan terakhir juga perdana maka juga memasukkannya; Kod pemacu; Panggilan fungsi", "code": "def findMaxPrimeDivisor ( n ) : NEW_LINE INDENT max_possible_prime = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE n = n // i NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE DEDENT print ( max_possible_prime ) NEW_LINE DEDENT n = 4 NEW_LINE findMaxPrimeDivisor ( n ) NEW_LINE"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah tepat dua nombor | Fungsi Mengembalikan kiraan cara menyatakan nombor sebagai jumlah dua nombor. ; Kod pemacu", "code": "def CountWays ( n ) : NEW_LINE INDENT ans = ( n - 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT N = 8 NEW_LINE print ( CountWays ( N ) ) NEW_LINE"}
{"text": "Bahagikan array dalam dua tatasusunan panjang maksimum yang sama dengan unsur -unsur yang serupa dan berbeza | Berfungsi untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama; Vektor untuk mencari kekerapan setiap elemen senarai; Cari elemen frekuensi maksimum yang ada dalam senarai ARR; Cari jumlah elemen unik yang ada dalam senarai ARR; Cari saiz maksimum yang mana array arr [] boleh dibuang; Cari array pertama yang mengandungi elemen yang sama; Cari array kedua yang mengandungi unsur -unsur yang unik; Kod pemacu; Permulaan n; Perisytiharan array; Saiz array", "code": "def Solve ( arr , size , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT v [ arr [ i ] ] += 1 NEW_LINE DEDENT max1 = max ( set ( arr ) , key = v . count ) NEW_LINE diff1 = n + 1 - v . count ( 0 ) NEW_LINE max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) NEW_LINE print ( \" Maximum ▁ size ▁ is ▁ : \" , max_size ) NEW_LINE print ( \" The ▁ First ▁ Array ▁ Is ▁ : ▁ \" ) NEW_LINE for i in range ( max_size ) : NEW_LINE INDENT print ( max1 , end = \" ▁ \" ) NEW_LINE v [ max1 ] -= 1 NEW_LINE DEDENT print ( ) NEW_LINE print ( \" The ▁ Second ▁ Array ▁ Is ▁ : ▁ \" ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( v [ i ] > 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE max_size -= 1 NEW_LINE DEDENT if ( max_size < 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 7 NEW_LINE arr = [ 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE Solve ( arr , size , n ) NEW_LINE DEDENT"}
{"text": "Cari Jumlah Xor semua tiga kali ganda yang tidak teratur dari array | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1 y = y / 2; Mengembalikan n ^ ( - 1) mod p; Mengembalikan NCR % P menggunakan teorem kecil Fermat. ; Kes asas; Isi pelbagai faktorial supaya kita dapat mencari semua faktorial r, n dan n - r; Fungsi mengembalikan jumlah XOR dari semua triplet yang tidak teratur dari array; Melangkah ke atas bit; Bilangan elemen yang masing -masing 1 dan 0; Memeriksa jika k 'th bit adalah 1; Menambah bahagian bit ini kepada jawapannya; Kod pemandu", "code": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModPFermat ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fac = [ 0 ] * ( n + 1 ) NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def SumOfXor ( a , n ) : NEW_LINE INDENT mod = 10037 NEW_LINE answer = 0 NEW_LINE for k in range ( 32 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & ( 1 << k ) ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE A = [ 3 , 5 , 2 , 18 , 7 ] NEW_LINE print ( SumOfXor ( A , n ) ) NEW_LINE DEDENT"}
{"text": "Kebarangkalian tidak mendapat dua kepala berturut -turut bersama -sama di N melemparkan duit syiling | Pelaksanaan Python3 untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut bersama apabila duit syiling N dibuang; Fungsi untuk mengira nombor Fibonacci N - Th dalam urutan di mana A = 2 dan B = 3; Dua nombor pertama dalam urutan dimulakan; Kes asas; Gelung untuk mengira urutan Fibonacci berdasarkan dua nombor pertama yang diasaskan; Fungsi untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut apabila duit syiling N dibuang; Mengira bilangan kes yang menggalakkan; Pengkomputeran bilangan semua hasil yang mungkin untuk N TOSses; Kod pemacu", "code": "import math NEW_LINE def probability ( N ) : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE if N == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 3 , N + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT DEDENT def operations ( N ) : NEW_LINE INDENT x = probability ( N ) NEW_LINE y = math . pow ( 2 , N ) NEW_LINE return round ( x / y , 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( operations ( N ) ) NEW_LINE DEDENT"}
{"text": "Check if number formed by joining two Numbers is Perfect Cube | Berfungsi untuk memeriksa sama ada nombor adalah kiub yang sempurna atau tidak; Fungsi untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Menukar nombor ke rentetan menggunakan to_string (); Menggabungkan nombor dan menukarnya menjadi integer; Semak jika nilai yang disatukan adalah kiub sempurna atau tidak; Kod pemacu", "code": "def isPerfectCube ( x ) : NEW_LINE INDENT x = abs ( x ) NEW_LINE return int ( round ( x ** ( 1. / 3 ) ) ) ** 3 == x NEW_LINE DEDENT def checkCube ( a , b ) : NEW_LINE INDENT s1 = str ( a ) NEW_LINE s2 = str ( b ) NEW_LINE c = int ( s1 + s2 ) NEW_LINE if ( isPerfectCube ( c ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 6 NEW_LINE b = 4 NEW_LINE checkCube ( a , b ) NEW_LINE DEDENT"}
{"text": "Nombor terbesar dalam array yang dibentuk dengan berulang kali menggabungkan dua elemen yang sama | Berfungsi untuk mengembalikan jumlah terbesar; Pembolehubah untuk menyimpan jumlah terbesar; Peta untuk menyimpan frekuensi setiap elemen; Menyimpan frekuensi; Gelung untuk menggabungkan elemen pendua dan mengemas kini jumlah dalam peta; Jika J adalah elemen pendua; Kemas kini kekerapan 2 * j; Jika jumlah baru lebih besar daripada nilai maksimum, kemas kini maksimum; Mengembalikan jumlah terbesar; Kod pemacu; Fungsi panggilan", "code": "def largest_sum ( arr , n ) : NEW_LINE INDENT maximum = - 1 NEW_LINE m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT for j in list ( m ) : NEW_LINE INDENT if ( ( j in m ) and m [ j ] > 1 ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if 2 * j in m : NEW_LINE INDENT m [ 2 * j ] = m [ 2 * j ] + m [ j ] // 2 NEW_LINE DEDENT else : NEW_LINE INDENT m [ 2 * j ] = m [ j ] // 2 NEW_LINE DEDENT if ( 2 * j > maximum ) : NEW_LINE INDENT maximum = 2 * j NEW_LINE DEDENT DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 4 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest_sum ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Semak sama ada mungkin untuk membuat X dan Y Zero pada masa yang sama dengan Operasi yang diberikan | Fungsi untuk memeriksa sama ada mungkin untuk membuat X dan Y boleh menjadi 0 pada masa yang sama; Semak syarat yang diberikan; Kod pemacu; Panggilan fungsi", "code": "def canBeReduced ( x , y ) : NEW_LINE INDENT maxi = max ( x , y ) NEW_LINE mini = min ( x , y ) NEW_LINE if ( ( ( x + y ) % 3 ) == 0 and maxi <= 2 * mini ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 6 NEW_LINE y = 9 NEW_LINE canBeReduced ( x , y ) NEW_LINE DEDENT"}
{"text": "Algoritma Pemfaktoran Roda | Program Python3 untuk memeriksa sama ada nombor yang diberikan adalah kaedah pemfaktoran roda; Fungsi untuk memeriksa sama ada nombor x yang diberikan adalah perdana atau tidak; Roda untuk memeriksa nombor perdana; Kes asas; Semak nombor yang diambil sebagai asas; Semak roda di sini saya, bertindak sebagai lapisan roda; Semak senarai penapis dalam arr []; Jika nombor lebih besar daripada rehat Sqrt (n); Semak jika n adalah pelbagai nombor utama di roda; Jika di mana -mana lelaran isprime adalah palsu, pecah dari gelung; Kod pemandu; Fungsi panggilan untuk pemeriksaan primal", "code": "import math NEW_LINE def isPrime ( N ) : NEW_LINE INDENT isPrime = True ; NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( 0 , int ( math . sqrt ( N ) ) , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if ( c > int ( math . sqrt ( N ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( not isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT print ( \" Prime ▁ Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ a ▁ Prime ▁ Number \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 121 NEW_LINE isPrime ( N ) NEW_LINE DEDENT"}
{"text": "Cari semua pasangan yang mungkin dari array yang diberikan | Berfungsi untuk prall mungkin pasangan dari array; Gelung bersarang untuk semua pasangan yang mungkin; Kod pemacu", "code": "def printPairs ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( \" ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" , end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE"}
{"text": "Jumlah kiub semua subset dari array yang diberikan | Pelaksanaan Python3 pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kiub subset; Cubing unsur -unsur dan menambahkannya ke Ans; Kod pemacu", "code": "mod = int ( 1e9 ) + 7 ; NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 ; NEW_LINE res %= mod ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT def subset_cube_sum ( A ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE ans = 0 ; NEW_LINE for i in A : NEW_LINE INDENT ans += ( i * i * i ) % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT return ( ans * power ( n - 1 ) ) % mod ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 ] ; NEW_LINE print ( subset_cube_sum ( A ) ) ; NEW_LINE DEDENT"}
{"text": "Semak jika bulatan terletak di dalam bulatan lain atau tidak | Program Python3 untuk memeriksa sama ada satu bulatan terletak di dalam bulatan lain atau tidak. ; Kod pemacu", "code": "def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ** ( .5 ) NEW_LINE if ( distSq + r2 == r1 ) : NEW_LINE INDENT print ( \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ \" \" touching ▁ each ▁ other ▁ \" \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" ) NEW_LINE DEDENT elif ( distSq + r2 < r1 ) : NEW_LINE INDENT print ( \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ without \" \" ▁ touching ▁ each ▁ other ▁ \" \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside \" \" ▁ the ▁ bigger ▁ circle ▁ completely . \" ) NEW_LINE DEDENT DEDENT x1 , y1 = 10 , 8 NEW_LINE x2 , y2 = 1 , 2 NEW_LINE r1 , r2 = 30 , 10 NEW_LINE circle ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE"}
{"text": "Panjang tangen biasa langsung antara dua lingkaran bersilang | Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( \" The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ \" , ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT r1 = 4 ; r2 = 6 ; d = 3 ; NEW_LINE lengtang ( r1 , r2 , d ) ; NEW_LINE"}
{"text": "Radius bulatan apabila lebar dan ketinggian arka diberikan | Berfungsi untuk mencari jejari; Kod pemacu", "code": "def rad ( d , h ) : NEW_LINE INDENT print ( \" The ▁ radius ▁ of ▁ the ▁ circle ▁ is \" , ( ( d * d ) / ( 8 * h ) + h / 2 ) ) NEW_LINE DEDENT d = 4 ; h = 1 ; NEW_LINE rad ( d , h ) ; NEW_LINE"}
{"text": "Jarak terpendek dari pusat bulatan ke kord | Berfungsi untuk mencari jarak terpendek; Kod pemacu", "code": "def shortdis ( r , d ) : NEW_LINE INDENT print ( \" The ▁ shortest ▁ distance ▁ \" , end = \" \" ) ; NEW_LINE print ( \" from ▁ the ▁ chord ▁ to ▁ centre ▁ \" , end = \" \" ) ; NEW_LINE print ( ( ( r * r ) - ( ( d * d ) / 4 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT r = 4 ; NEW_LINE d = 3 ; NEW_LINE shortdis ( r , d ) ; NEW_LINE"}
{"text": "Panjang tangen biasa langsung antara kedua -dua bukan | Program Python3 untuk mencari panjang tangen umum langsung antara dua kalangan yang tidak menyentuh satu sama lain; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "import math NEW_LINE def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( \" The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is \" , ( ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ) ; NEW_LINE DEDENT r1 = 4 ; r2 = 6 ; d = 12 ; NEW_LINE lengtang ( r1 , r2 , d ) ; NEW_LINE"}
{"text": "Dataran terbesar yang boleh ditulis dalam segitiga sama rata | Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu", "code": "def square ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE return x NEW_LINE DEDENT a = 5 NEW_LINE print ( square ( a ) ) NEW_LINE"}
{"text": "Apothem A N | Program Python 3 untuk mencari apothem poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari apothem poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah ditukar kepada radian; Kod pemacu", "code": "from math import tan NEW_LINE def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyapothem ( n , a ) ) ) NEW_LINE DEDENT"}
{"text": "Kawasan n | Program Python 3 untuk mencari kawasan poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "from math import tan NEW_LINE def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyarea ( n , a ) ) ) NEW_LINE DEDENT"}
{"text": "Sisi biasa n | Python 3 pelaksanaan pendekatan; Fungsi untuk mengira sisi poligon yang dilampirkan dalam bulatan; Kod pemacu; Jumlah sisi poligon; Jejari lingkaran lingkungan", "code": "from math import sin NEW_LINE def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 / n NEW_LINE theta_in_radians = theta * 3.14 / 180 NEW_LINE return 2 * r * sin ( theta_in_radians / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE r = 5 NEW_LINE print ( ' { 0 : . 5 } ' . format ( calculateSide ( n , r ) ) ) NEW_LINE DEDENT"}
{"text": "Silinder bulat kanan terbesar dalam frustum | Berfungsi untuk mencari silinder bulat kanan terbesar; Radii dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "def cyl ( r , R , h ) : NEW_LINE INDENT if ( h < 0 and r < 0 and R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r1 = r NEW_LINE h1 = h NEW_LINE V = 3.14 * pow ( r1 , 2 ) * h1 NEW_LINE return round ( V , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , R , h = 7 , 11 , 6 NEW_LINE print ( cyl ( r , R , h ) ) NEW_LINE DEDENT"}
{"text": "Program to find the Perimeter of a Regular Polygon | Berfungsi untuk mengira perimeter; Hitung perimeter; kod pemacu; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter", "code": "def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s = 2.5 NEW_LINE peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter ▁ of ▁ Regular ▁ Polygon ▁ with \" , n , \" sides ▁ of ▁ length \" , s , \" = \" , peri ) NEW_LINE DEDENT"}
{"text": "Kawasan rombang terbesar yang boleh ditulis dalam segi empat tepat | Berfungsi untuk mencari kawasan rombus terbesar; Panjang dan keluasan tidak boleh negatif; kawasan rhombus; Kod pemacu", "code": "def rhombusarea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( l * b ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 16 NEW_LINE b = 6 NEW_LINE print ( rhombusarea ( l , b ) ) NEW_LINE DEDENT"}
{"text": "Semak jika titik terletak di dalam segi empat tepat | Set | Fungsi untuk mencari jika titik diberikan terletak di dalam segi empat tepat atau tidak. ; Kod pemacu; Bawah - kiri dan atas - Sudut kanan segi empat tepat. Gunakan pelbagai tugasan; titik yang diberikan; panggilan fungsi", "code": "def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 , y1 , x2 , y2 = 0 , 0 , 10 , 8 NEW_LINE x , y = 1 , 5 NEW_LINE if FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Jarak antara satu titik dan satah dalam 3 D | Program Python untuk mencari jarak serenjang (terpendek) antara satu titik dan satah dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu; Panggilan fungsi", "code": "import math NEW_LINE def shortest_distance ( x1 , y1 , z1 , a , b , c , d ) : NEW_LINE INDENT d = abs ( ( a * x1 + b * y1 + c * z1 + d ) ) NEW_LINE e = ( math . sqrt ( a * a + b * b + c * c ) ) NEW_LINE print ( \" Perpendicular ▁ distance ▁ is \" , d / e ) NEW_LINE DEDENT x1 = 4 NEW_LINE y1 = - 4 NEW_LINE z1 = 3 NEW_LINE a = 2 NEW_LINE b = - 2 NEW_LINE c = 5 NEW_LINE d = 8 NEW_LINE shortest_distance ( x1 , y1 , z1 , a , b , c , d ) NEW_LINE"}
{"text": "Program untuk mencari jumlah prisma segi tiga | berfungsi untuk mencari jumlah prisma segi tiga; formula untuk mencari kelantangan; Kod pemacu; fungsi panggilan", "code": "def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE print ( \" Volume ▁ of ▁ triangular ▁ prism : ▁ \" , findVolume ( l , b , h ) ) NEW_LINE"}
{"text": "Semak jika diberi empat bilangan bulat (atau sisi) membuat segi empat tepat | Fungsi untuk memeriksa sama ada nilai integer yang diberikan membuat segi empat tepat; Semak semua sisi kombinasi segi empat tepat; Kod pemacu", "code": "def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and d == c ) or ( a == c and b == d ) or ( a == d and b == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE"}
{"text": "Program untuk mencari pertengahan | Berfungsi untuk mencari titik tengah garis; Kod pemacu", "code": "def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , \" ▁ , ▁ \" , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = - 1 , 2 , 3 , - 6 NEW_LINE midpoint ( x1 , x2 , y1 , y2 ) NEW_LINE"}
{"text": "Panjang arka dari sudut yang diberikan | Kod python3 untuk mengira panjang arka; fungsi untuk mengira panjang arka; Kod pemacu", "code": "import math NEW_LINE def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( \" Angle ▁ cannot ▁ be ▁ formed \" ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT diameter = 25.0 NEW_LINE angle = 45.0 NEW_LINE arc_len = arcLength ( diameter , angle ) NEW_LINE print ( arc_len ) NEW_LINE"}
{"text": "Semak sama ada garis menyentuh atau memotong bulatan | Program Python untuk memeriksa sama ada garis menyentuh atau bersilang atau di luar bulatan. ; Mencari jarak garis dari pusat. ; Memeriksa jika jarak kurang daripada, lebih besar daripada atau sama dengan radius. ; Program yang didorong", "code": "import math NEW_LINE def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( \" Touch \" ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( \" Intersect \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Outside \" ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 25 NEW_LINE checkCollision ( a , b , c , x , y , radius ) NEW_LINE"}
{"text": "Program untuk mencari circumcenter segitiga | Fungsi untuk mencari garis yang diberikan dua mata; Fungsi yang menukarkan garis input ke bisektor tegak lurus. Ia juga memasukkan titik -titik yang pertengahannya terletak pada bisektor; c = - bx + ay; Mengembalikan titik persimpangan dua baris; Garis selari. Ini dipermudahkan dengan mengembalikan sepasang (10.0) * * 19; PQ Line diwakili sebagai AX + BY = C; Line QR diwakili sebagai ex + fy = g; Converting lines PQ and QR to perpendicular vbisectors . Selepas ini, l = ax + by = c m = ex + fy = g; Titik persimpangan L dan M memberikan lekuk; Kod pemacu.", "code": "def lineFromPoints ( P , Q , a , b , c ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE return a , b , c NEW_LINE DEDENT def perpendicularBisectorFromLine ( P , Q , a , b , c ) : NEW_LINE INDENT mid_point = [ ( P [ 0 ] + Q [ 0 ] ) // 2 , ( P [ 1 ] + Q [ 1 ] ) // 2 ] NEW_LINE c = - b * ( mid_point [ 0 ] ) + a * ( mid_point [ 1 ] ) NEW_LINE temp = a NEW_LINE a = - b NEW_LINE b = temp NEW_LINE return a , b , c NEW_LINE DEDENT def lineLineIntersection ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT determinant = a1 * b2 - a2 * b1 NEW_LINE if ( determinant == 0 ) : NEW_LINE INDENT return [ ( 10.0 ) ** 19 , ( 10.0 ) ** 19 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = ( b2 * c1 - b1 * c2 ) // determinant NEW_LINE y = ( a1 * c2 - a2 * c1 ) // determinant NEW_LINE return [ x , y ] NEW_LINE DEDENT DEDENT def findCircumCenter ( P , Q , R ) : NEW_LINE INDENT a , b , c = 0.0 , 0.0 , 0.0 NEW_LINE a , b , c = lineFromPoints ( P , Q , a , b , c ) NEW_LINE e , f , g = 0.0 , 0.0 , 0.0 NEW_LINE e , f , g = lineFromPoints ( Q , R , e , f , g ) NEW_LINE a , b , c = perpendicularBisectorFromLine ( P , Q , a , b , c ) NEW_LINE e , f , g = perpendicularBisectorFromLine ( Q , R , e , f , g ) NEW_LINE circumcenter = lineLineIntersection ( a , b , c , e , f , g ) NEW_LINE if ( circumcenter [ 0 ] == ( 10.0 ) ** 19 and circumcenter [ 1 ] == ( 10.0 ) ** 19 ) : NEW_LINE INDENT print ( \" The ▁ two ▁ perpendicular ▁ bisectors ▁ found ▁ come ▁ parallel \" ) NEW_LINE print ( \" Thus , ▁ the ▁ given ▁ points ▁ do ▁ not ▁ form ▁ a ▁ triangle ▁ and ▁ are ▁ collinear \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The ▁ circumcenter ▁ of ▁ the ▁ triangle ▁ PQR ▁ is : ▁ \" , end = \" \" ) NEW_LINE print ( \" ( \" , circumcenter [ 0 ] , \" , \" , circumcenter [ 1 ] , \" ) \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = [ 6 , 0 ] NEW_LINE Q = [ 0 , 0 ] NEW_LINE R = [ 0 , 8 ] NEW_LINE findCircumCenter ( P , Q , R ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari kawasan segitiga | (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; Kembali nilai mutlak; Program pemacu untuk menguji fungsi di atas", "code": "def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE"}
{"text": "Memaksimumkan jumlah LSB bitwise atau semua mungkin n / 2 pasang dari array yang diberikan | Fungsi atas mendapatkan nilai LSB V; Penukaran binari; Fungsi untuk mencari jumlah LSB semua pasangan yang mungkin dari array yang diberikan; Menyimpan elemen array LSB; Menyimpan nilai LSB; Susun array lab_arr []; Mengambil jumlah pasangan untuk mendapatkan jumlah maksimum LSB; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "def chk ( v ) : NEW_LINE INDENT v = list ( bin ( v ) [ 2 : ] ) NEW_LINE v . reverse ( ) NEW_LINE if ( '1' in v ) : NEW_LINE INDENT v = v . index ( '1' ) NEW_LINE return ( 2 ** v ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def sumOfLSB ( arr , N ) : NEW_LINE INDENT lsb_arr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT lsb_arr . append ( chk ( arr [ i ] ) ) NEW_LINE DEDENT lsb_arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N - 1 , 2 ) : NEW_LINE INDENT ans += ( lsb_arr [ i + 1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT N = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE sumOfLSB ( arr , N ) NEW_LINE"}
{"text": "Kira -kira berikutnya yang mempunyai bitwise dan nilai -nilai yang ganjil dalam array yang diberikan | Fungsi untuk mencari kiraan berikutnya yang mempunyai bitwise dan nilai ganjil; Kedai mengira unsur -unsur ganjil; Melintasi array arr []; Jika x adalah kiraan kenaikan ganjil; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 NEW_LINE for x in arr : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT return ( 1 << odd ) - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 ] NEW_LINE print ( countSubsequences ( arr ) ) NEW_LINE DEDENT"}
{"text": "Kira pasangan dari array dengan perbezaan mutlak tidak kurang daripada elemen minimum dalam pasangan | Fungsi untuk mencari bilangan pasangan (i, j) seperti abs (a [i] - a [j]) sekurang -kurangnya minimum (a [i], a [j]); Menyimpan kiraan pasangan yang dihasilkan; Melangkah ke atas julat [0, n]; Berulang dari arr [i] - (i % arr [i]) hingga n dengan kenaikan arr [i]; Mengira pasangan yang mungkin; Mengembalikan jumlah jumlah; Kod pemacu", "code": "def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE INDENT if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getPairsCount ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Langkah Minimum Untuk Menukar N hingga 1 dengan menukarnya menjadi 2 * n atau n / 10 pada mana -mana langkah | Fungsi untuk memeriksa sama ada n boleh diubah menjadi 1 atau tidak. ; Kira bilangan 2 dalam faktorisasi utama N; Mengira bilangan 5 dalam faktorisasi utama N; Kod pemacu", "code": "def check ( N ) : NEW_LINE INDENT twos = 0 NEW_LINE fives = 0 NEW_LINE while ( N % 2 == 0 ) : NEW_LINE INDENT N /= 2 NEW_LINE twos += 1 NEW_LINE DEDENT while ( N % 5 == 0 ) : NEW_LINE INDENT N /= 5 NEW_LINE fives += 1 NEW_LINE DEDENT if ( N == 1 and twos <= fives ) : NEW_LINE INDENT print ( 2 * fives - twos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 50 NEW_LINE check ( N ) NEW_LINE DEDENT"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah elemen array dari L ke R; Melintasi L ke R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( L - 1 , R , 1 ) : NEW_LINE INDENT sum += arr [ i % N ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 6 , 9 ] NEW_LINE L = 10 NEW_LINE R = 13 NEW_LINE N = len ( arr ) NEW_LINE rangeSum ( arr , N , L , R ) NEW_LINE DEDENT"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah awalan; Kirakan jumlah awalan; Menyimpan jumlah elemen dari 1 hingga l - 1; Menyimpan jumlah elemen dari 1 hingga R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT prefix = [ 0 for i in range ( N + 1 ) ] NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT leftsum = ( ( L - 1 ) // N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] NEW_LINE rightsum = ( R // N ) * prefix [ N ] + prefix [ R % N ] NEW_LINE print ( rightsum - leftsum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 6 , 9 ] NEW_LINE L = 10 NEW_LINE R = 13 NEW_LINE N = len ( arr ) NEW_LINE rangeSum ( arr , N , L , R ) NEW_LINE DEDENT"}
{"text": "Faktorial eksponen n | Berfungsi untuk mencari faktorial eksponen nombor tertentu; Menyimpan faktor exponetial N; Iterare ke atas julat [2, n]; Kemas kini res; Kembali res; Input; Panggilan fungsi", "code": "def ExpoFactorial ( N ) : NEW_LINE INDENT res = 1 NEW_LINE mod = ( int ) ( 1000000007 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT res = pow ( i , res , mod ) NEW_LINE DEDENT return res NEW_LINE DEDENT N = 4 NEW_LINE print ( ExpoFactorial ( N ) ) NEW_LINE"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Set | Fungsi untuk mencari subarray bersebelahan dengan jumlah maksimum jika array diulang kali k; Simpan jumlah array arr []; Melintasi array dan cari jumlah; Simpan jawapannya; Jika k = 1; Memohon algoritma Kadane untuk mencari jumlah; Kembalikan jawapannya; Menyimpan array dua kali berulang; Melintasi julat [0, 2 * n]; Menyimpan jumlah akhiran maksimum; Menyimpan jumlah awalan maksimum; Memohon algoritma Kadane untuk 2 pengulangan array; Jika jumlah array lebih besar daripada 0; Kembalikan jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def maxSubArraySumRepeated ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT curr = arr [ 0 ] NEW_LINE ans = arr [ 0 ] NEW_LINE if ( K == 1 ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT curr = max ( arr [ i ] , curr + arr [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT return ans NEW_LINE DEDENT V = [ ] NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT V . append ( arr [ i % N ] ) NEW_LINE DEDENT maxSuf = V [ 0 ] NEW_LINE maxPref = V [ 2 * N - 1 ] NEW_LINE curr = V [ 0 ] NEW_LINE for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxPref = max ( maxPref , curr ) NEW_LINE DEDENT curr = V [ 2 * N - 1 ] NEW_LINE i = 2 * N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxSuf = max ( maxSuf , curr ) NEW_LINE i -= 1 NEW_LINE DEDENT curr = V [ 0 ] NEW_LINE for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr = max ( V [ i ] , curr + V [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT temp = sum * ( K - 2 ) NEW_LINE ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , - 30 , - 1 , 40 ] NEW_LINE N = len ( arr ) NEW_LINE K = 10 NEW_LINE print ( maxSubArraySumRepeated ( arr , N , K ) ) NEW_LINE DEDENT"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan kiraan subarray; Menjana semua subarray yang mungkin; Menyimpan elemen maksimum subarray; Menyimpan maksimum semua elemen lain; Cari elemen maksimum dalam subarray [i, j]; Cari maksimum semua elemen lain; Jika maksimum subarray lebih besar daripada dua kali ganda maksimum elemen lain; Cetak nilai maksimum yang diperoleh; Kod pemacu", "code": "def countSubarray ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n , 1 ) : NEW_LINE INDENT mxSubarray = 0 NEW_LINE mxOther = 0 NEW_LINE for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT mxSubarray = max ( mxSubarray , arr [ k ] ) NEW_LINE DEDENT for k in range ( 0 , i , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT if ( mxSubarray > ( 2 * mxOther ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countSubarray ( arr , N ) NEW_LINE DEDENT"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan elemen maksimum array; Melintasi array yang diberikan; Jika nilai 2 * arr [i] lebih besar daripada MX; Kemas kini nilai l dan keluar dari gelung; Jika nilai 2 * arr [i] lebih besar daripada Mx; Mengemas kini nilai r dan keluar dari gelung; Cetak jawapan terakhir; Kod pemacu", "code": "def countSubarray ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE L = 0 NEW_LINE R = 0 NEW_LINE mx = max ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] * 2 > mx ) : NEW_LINE INDENT L = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] * 2 > mx ) : NEW_LINE INDENT R = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ( L + 1 ) * ( n - R ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countSubarray ( arr , N ) NEW_LINE DEDENT"}
{"text": "Cari Nombor Perdana hanya kurang daripada dan hanya lebih besar setiap elemen array yang diberikan | Program Python3 untuk pendekatan di atas; Fungsi utiliti untuk memeriksa keunggulan nombor X dengan memeriksa sama ada X HAACCs apa -apa faktor selain daripada 1 dan sendiri. ; Faktor yang dijumpai; Berfungsi untuk mencetak prima hanya kurang daripada dan hanya lebih besar daripada setiap elemen dalam array; Melintasi array; Traverse untuk mencari perdana kurang daripada [i]; Perdana hanya kurang daripada yang dijumpai; Melintasi untuk mencari perdana lebih besar daripada [i]; Perdana hanya lebih besar daripada yang dijumpai; Kod pemacu; Input; Panggilan fungsi", "code": "from math import sqrt NEW_LINE def isPrime ( X ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( X ) ) + 1 , 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printPrimes ( A , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT j = A [ i ] - 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( isPrime ( j ) ) : NEW_LINE INDENT print ( j , end = \" ▁ \" ) NEW_LINE break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT j = A [ i ] + 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( isPrime ( j ) ) : NEW_LINE INDENT print ( j , end = \" ▁ \" ) NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( \" \" , ▁ end ▁ = ▁ \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 17 , 28 ] NEW_LINE N = len ( A ) NEW_LINE printPrimes ( A , N ) NEW_LINE DEDENT"}
{"text": "Elemen terkecil kth dalam array yang mengandungi [i] betul -betul b [i] kali | Fungsi untuk mencari elemen terkecil kth yang mengandungi [i] tepat b [i] kali; Melintasi array yang diberikan; Menyimpan kekerapan setiap elemen; Melintasi array yang diberikan; Memulakan pembolehubah untuk menyimpan jumlah awalan; Melangkah ke atas julat [0, M]; Jumlah kenaikan oleh freq [i]; Jika jumlah lebih besar daripada atau sama dengan k; Mengembalikan elemen semasa sebagai jawapan; Kembali - 1; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def KthSmallest ( A , B , N , K ) : NEW_LINE INDENT M = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT M = max ( A [ i ] , M ) NEW_LINE DEDENT freq = [ 0 ] * ( M + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq [ A [ i ] ] += B [ i ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( M + 1 ) : NEW_LINE INDENT sum += freq [ i ] NEW_LINE if ( sum >= K ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 4 , 5 ] NEW_LINE B = [ 2 , 1 , 3 ] NEW_LINE N = len ( A ) NEW_LINE K = 4 NEW_LINE print ( KthSmallest ( A , B , N , K ) ) NEW_LINE DEDENT"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Berfungsi untuk mencari bitwise atau bitwise dan semua subarrays; Menyimpan hasil yang diperlukan; Menjana semua subarray; Simpan elemen semasa; Cari bitwise atau; Mengemas kini hasilnya; Cetak hasilnya; Kod pemacu", "code": "def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sub_array = a [ i ] NEW_LINE res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE findbitwiseOR ( A , N ) NEW_LINE DEDENT"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Berfungsi untuk mencari bitwise atau bitwise dan semua subset berturut -turut dari array; Menyimpan hasil yang diperlukan; Melintasi array yang diberikan; Cetak hasilnya; Kod pemacu", "code": "def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res | a [ i ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE findbitwiseOR ( A , N ) NEW_LINE DEDENT"}
{"text": "Semak jika jumlah digit nombor melebihi produk digit nombor itu | Berfungsi untuk memeriksa sama ada jumlah digit N adalah lebih besar daripada produk digit N atau tidak; Menyimpan jumlah dan produk digit N; Menyimpan digit terakhir jika n; Kenaikan nilai sumofdigit; Mengemas kini prodofdigit; Bahagikan n oleh 10; Cetak hasilnya; Kod pemacu", "code": "def check ( n ) : NEW_LINE INDENT sumOfDigit = 0 NEW_LINE prodOfDigit = 1 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE sumOfDigit += rem NEW_LINE prodOfDigit *= rem NEW_LINE n = n // 10 NEW_LINE DEDENT if sumOfDigit > prodOfDigit : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT N = 1234 NEW_LINE check ( N ) NEW_LINE"}
{"text": "Cetak semua awalan yang berbeza dan ganjil bitwise xors pertama n Nombor semula jadi | Cetak semua awalan yang berbeza & ganjil bitwise xors dari 1 hingga n; Cetak nombor juga; Cetak nombor ganjil; Kod pemacu", "code": "def evenOddBitwiseXOR ( N ) : NEW_LINE INDENT print ( \" Even : ▁ \" , 0 , end = \" ▁ \" ) NEW_LINE for i in range ( 4 , N + 1 , 4 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE print ( \" Odd : ▁ \" , 1 , end = \" ▁ \" ) NEW_LINE for i in range ( 4 , N + 1 , 4 ) : NEW_LINE INDENT print ( i - 1 , end = \" ▁ \" ) NEW_LINE DEDENT if ( N % 4 == 2 ) : NEW_LINE INDENT print ( N + 1 ) NEW_LINE DEDENT elif ( N % 4 == 3 ) : NEW_LINE INDENT print ( N ) NEW_LINE DEDENT DEDENT N = 6 NEW_LINE evenOddBitwiseXOR ( N ) NEW_LINE"}
{"text": "Permutasi terbesar lexicographically mungkin dengan swap yang lebih kecil daripada array yang diberikan | Berfungsi untuk permutasi terbesar lexicographic mungkin dengan swap yang lebih kecil daripada array yang diberikan; Cari indeks elemen pertama sedemikian rupa sehingga arr [i]> arr [i + 1]; Jika array disusun dalam peningkatan urutan; Cari indeks elemen pertama yang lebih kecil daripada arr [i]; Jika arr [j] = = arr [j - 1]; Pengurangan j; Swap elemen; Pr array arr []; Kod pemacu", "code": "def findPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 and arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT j = N - 1 NEW_LINE while ( j > i and arr [ j ] >= arr [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( j > i and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE for it in arr : NEW_LINE INDENT print ( it , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE findPermutation ( arr ) NEW_LINE"}
{"text": "Perbezaan mutlak antara kiraan ganjil dan juga faktor n | Berfungsi untuk mencari faktor utama terkecil dari semua nombor menggunakan ayak eratosthenes; Kedai sama ada nombor mana -mana atau tidak; Memulakan faktor terkecil sebagai 2 untuk semua nombor walaupun; Melangkah ke atas julat [3, n]; Sekiranya saya adalah perdana; Melepasi semua gandaan i; Saya adalah faktor utama terkecil i * j; Fungsi untuk mencari perbezaan mutlak antara kiraan ganjil dan juga faktor n; Menyimpan faktor utama terkecil i; Isi nilai dalam S [] menggunakan ayak eratosthenes; Menyimpan jumlah faktor dan jumlah faktor ganjil dan bahkan; Simpan faktor utama semasa nombor n; Simpan kuasa faktor utama semasa; Gelung manakala n lebih besar daripada 1; Jika n juga mempunyai faktor utama terkecil seperti Curr, maka kenaikan CNT oleh 1; Kemas kini hanya jumlah faktor jika curr adalah 2; Mengemas kini jumlah faktor dan jumlah faktor ganjil; Mengemas kini faktor utama semasa S [n] dan dikira sebagai 1; Kirakan bilangan faktor walaupun; Cetak perbezaan; Kod pemacu", "code": "def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , N , 2 ) : NEW_LINE INDENT if j * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( not prime [ i * j ] ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def findDifference ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE total , odd , even = 1 , 1 , 0 NEW_LINE curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT if ( curr == 2 ) : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE odd = odd * ( cnt + 1 ) NEW_LINE DEDENT curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE DEDENT even = total - odd NEW_LINE print ( abs ( even - odd ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE findDifference ( N ) NEW_LINE DEDENT"}
{"text": "Kirakan median dari nilai min dan mod yang diberikan | Berfungsi untuk mencari median sekumpulan data dengan min dan mod yang diberikan; Kirakan median; Cetak median; Kod pemacu", "code": "def findMedian ( Mean , Mode ) : NEW_LINE INDENT Median = ( 2 * Mean + Mode ) // 3 NEW_LINE print ( Median ) NEW_LINE DEDENT Mode = 6 NEW_LINE Mean = 3 NEW_LINE findMedian ( Mean , Mode ) NEW_LINE"}
{"text": "Program untuk mencari magnitud vektor | Program Python3 untuk pendekatan di atas; Berfungsi untuk mengira magnitud vektor 3 dimensi; Menyimpan jumlah kuadrat koordinat vektor; Mengembalikan magnitud; Kod pemacu", "code": "from math import sqrt NEW_LINE def vectorMagnitude ( x , y , z ) : NEW_LINE INDENT sum = x * x + y * y + z * z NEW_LINE return sqrt ( sum ) NEW_LINE DEDENT x = 1 NEW_LINE y = 2 NEW_LINE z = 3 NEW_LINE print ( vectorMagnitude ( x , y , z ) ) NEW_LINE"}
{"text": "Program untuk mencari produk nombor dengan nombor Mersenne | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari prodcut nombor Mersenne dengan nombor lain; Menyimpan kuasa 2 integer m + 1; Mengembalikan produk; Kod pemacu", "code": "import math NEW_LINE def multiplyByMersenne ( N , M ) : NEW_LINE INDENT x = int ( math . log2 ( M + 1 ) ) NEW_LINE return ( ( N << x ) - N ) NEW_LINE DEDENT N = 4 NEW_LINE M = 15 NEW_LINE print ( multiplyByMersenne ( N , M ) ) NEW_LINE"}
{"text": "Kuasa terdekat 2 dari dataran sempurna terdekat bukan | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari persegi yang paling dekat dengan Num; Kirakan akar kuadrat NUM; Kirakan persegi sempurna; Cari dataran sempurna terdekat; Berfungsi untuk mencari kuasa 2 yang paling dekat dengan nombor nombor; Hitung asas log 2 dari NUM; Kuasa tertinggi 2 iaitu <= num; Berfungsi untuk mencari persegi sempurna yang terdekat dan kuasa terdekat 2 dari setiap elemen array yang kejadiannya adalah 1; Kedai kekerapan elemen array; Melintasi array dan kemas kini kekerapan elemen array semasa; Melintasi peta freq; Jika kekerapan adalah 1; Cari persegi sempurna yang terdekat; Cetak kuasa terdekat 2; Sekiranya mana -mana tidak mengandungi unsur -unsur yang tidak berulang; Kod pemacu", "code": "from math import sqrt , log2 , pow NEW_LINE def perfectSquare ( num ) : NEW_LINE INDENT sr = int ( sqrt ( num ) ) NEW_LINE a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE if ( ( num - a ) < ( b - num ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def powerOfTwo ( num ) : NEW_LINE INDENT lg = int ( log2 ( num ) ) NEW_LINE p = int ( pow ( 2 , lg ) ) NEW_LINE return p NEW_LINE DEDENT def uniqueElement ( arr , N ) : NEW_LINE INDENT ans = True NEW_LINE freq = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] in freq ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = [ ] NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( value == 1 ) : NEW_LINE INDENT ans = False NEW_LINE ps = perfectSquare ( key ) NEW_LINE res . append ( powerOfTwo ( ps ) ) NEW_LINE DEDENT DEDENT res . sort ( reverse = False ) NEW_LINE for x in res : NEW_LINE print ( x , end = \" ▁ \" ) NEW_LINE if ( ans ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 11 , 4 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE uniqueElement ( arr , N ) NEW_LINE DEDENT"}
{"text": "Arahan partition menjadi dua subarray dengan setiap elemen di subarray kanan dengan ketat daripada setiap elemen di subarray kiri | Program Python3 untuk pendekatan di atas; Berfungsi untuk memisahkan array menjadi dua subarrays bukan kosong yang memenuhi syarat yang diberikan; Menyimpan array akhiran min; Menyimpan minimum akhiran; Melintasi array secara terbalik; Mengemas kini minimum; Simpan minimum; Menyimpan nilai maksimum awalan; Menyimpan indeks partition; Kemas kini Max; Jika max kurang daripada min [i + 1]; Simpan indeks partition; rehat; Jika Ind tidak - 1; Cetak subarray pertama; Cetak subarray kedua; Jika tidak; Kod pemacu", "code": "import sys NEW_LINE def partitionArray ( a , n ) : NEW_LINE INDENT Min = [ 0 ] * n NEW_LINE Mini = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT Mini = min ( Mini , a [ i ] ) NEW_LINE Min [ i ] = Mini NEW_LINE DEDENT Maxi = - sys . maxsize - 1 NEW_LINE ind = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT Maxi = max ( Maxi , a [ i ] ) NEW_LINE if ( Maxi < Min [ i + 1 ] ) : NEW_LINE ind = i NEW_LINE break NEW_LINE DEDENT if ( ind != - 1 ) : NEW_LINE INDENT for i in range ( ind + 1 ) : NEW_LINE print ( a [ i ] , end = \" ▁ \" ) NEW_LINE print ( ) NEW_LINE for i in range ( ind + 1 , n , 1 ) : NEW_LINE print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 2 , 7 , 9 ] NEW_LINE N = 5 NEW_LINE partitionArray ( arr , N ) NEW_LINE"}
{"text": "Semak sama ada nombor boleh diwakili sebagai jumlah integer positif k di mana sekurang -kurangnya k | Program Python3 untuk pendekatan di atas; Berfungsi untuk mengira semua faktor utama nombor tertentu; Kira bilangan 2 s yang membahagikan n; Oleh kerana N adalah ganjil pada ketika ini, langkau satu elemen; Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Jika n adalah nombor perdana yang lebih besar daripada 2; Berfungsi untuk mencari jumlah nombor pertama N hampir utama; Simpan jumlah yang diperlukan; Tambah nombor ini jika ia memenuhi syarat; Kiraan kenaikan hampir nombor utama; Fungsi untuk memeriksa sama ada n boleh diwakili sebagai jumlah k antara bilangan bulat positif yang berbeza di mana sekurang -kurangnya k - 1 daripadanya adalah hampir perdana; Simpan jumlah pertama k - 1 hampir nombor utama; Jika jumlahnya hebat daripada atau sama dengan n; Jika tidak, Pryes; Kod pemacu", "code": "import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE DEDENT def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == 2 ) : NEW_LINE INDENT sum += num NEW_LINE i += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT def check ( n , k ) : NEW_LINE INDENT s = findSum ( k - 1 ) NEW_LINE if ( s >= n ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT n = 100 NEW_LINE k = 6 NEW_LINE check ( n , k ) NEW_LINE"}
{"text": "Kira cara untuk mewakili integer sebagai eksponen | Program Python3 untuk pendekatan di atas; Berfungsi untuk mengira GCD A dan B menggunakan algoritma Euclidean; Iterat sehingga B bukan sifar; Mengembalikan GCD; Fungsi untuk mengira bilangan cara n boleh dinyatakan sebagai x ^ y; Kes asas; Menyimpan GCD kuasa; Kirakan tahap 2 dalam n; Kirakan tahap nombor utama dalam n; Kirakan tahap perdana 'i' dalam n; Jika n adalah perdana, G menjadi 1 .; Menyimpan bilangan cara untuk mewakili n sebagai x ^ y; Cari bilangan faktor G; Mengemas kini kiraan cara; Berulang untuk mencari bilangan nombor perdana; Cari kuasa i; Mengemas kini kiraan cara; Jika G adalah Perdana; Mengembalikan jumlah cara; Kod pemacu", "code": "import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT while ( b > 0 ) : NEW_LINE INDENT rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return a NEW_LINE DEDENT def countNumberOfWays ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT g = 0 NEW_LINE power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n //= 2 NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n //= i NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT g = gcd ( g , 1 ) NEW_LINE DEDENT ways = 1 NEW_LINE power = 0 NEW_LINE while ( g % 2 == 0 ) : NEW_LINE INDENT g //= 2 NEW_LINE power += 1 NEW_LINE DEDENT ways *= ( power + 1 ) NEW_LINE for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( g % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE g /= i NEW_LINE DEDENT ways *= ( power + 1 ) NEW_LINE DEDENT if ( g > 2 ) : NEW_LINE INDENT ways *= 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT N = 64 NEW_LINE print ( countNumberOfWays ( N ) ) NEW_LINE"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan integer yang diberikan | Pelaksanaan Python3 pendekatan di atas; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor positif yang diberikan; Fungsi lantai digunakan untuk menentukan nilai yang dekat dengan nombor; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor negatif yang diberikan; Fungsi Ceil digunakan untuk nombor negatif sebagai - 1> - 4. Ia akan bertentangan dengan nombor positif di mana 1 <4; Berfungsi untuk mencari kuasa tertinggi 2; Untuk memeriksa sama ada nombor yang diberikan positif atau negatif; Jika nombor itu negatif, maka siling nombor positif dikira dan tanda negatif ditambah; Kod pemacu", "code": "from math import floor , ceil , log2 NEW_LINE def powOfPositive ( n ) : NEW_LINE INDENT pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE DEDENT def powOfNegative ( n ) : NEW_LINE INDENT pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE DEDENT def highestPowerOf2 ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT"}
{"text": "Bilangan kad yang diperlukan membina rumah kad tahap n | Berfungsi untuk mencari bilangan kad yang diperlukan; Kod pemacu", "code": "def noOfCards ( n ) : NEW_LINE INDENT return n * ( 3 * n + 1 ) // 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( noOfCards ( n ) ) NEW_LINE"}
{"text": "Cari nombor terkecil dari sejumlah besar yang diberikan dengan kiraan digit yang sama | Fungsi untuk mencari nombor yang paling kecil selepas menukar digit beberapa kali; Pembolehubah untuk menyimpan jawapan terakhir; Array untuk menyimpan kiraan kejadian setiap digit; Gelung untuk mengira bilangan kejadian setiap digit; Gelung untuk mendapatkan nombor terkecil; Mengembalikan jawapannya; Kod pemacu", "code": "def smallestPoss ( s , n ) : NEW_LINE INDENT ans = \" \" ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; NEW_LINE K = \"325343273113434\" ; NEW_LINE print ( smallestPoss ( K , N ) ) ; NEW_LINE DEDENT"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | Berfungsi untuk mengira bilangan sub -tatasusunan dengan jumlah yang lebih besar daripada unsur -unsur array yang tinggal; Untuk gelung untuk titik permulaan subarray; Untuk gelung untuk titik akhir subarray; Permulaan subarray_sum dan sisa_sum ke 0; Untuk gelung untuk mengira jumlah subarray yang dihasilkan; Untuk gelung untuk mengira unsur array sisa jumlah; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah unsur array yang tinggal; Kod pemacu", "code": "def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE remaining_sum = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] ; NEW_LINE DEDENT for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | Pelaksanaan Python3 pendekatan di atas; Mengira jumlah jumlah array yang diberikan; Untuk gelung untuk titik permulaan subarray; permulaan subarray_sum hingga 0; For loop for calculating subarray_sum and remaining_sum ; Mengira subarray_sum dan sisa yang sama; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah baki elemen array; Kod pemacu", "code": "def Count_subarray ( arr , n ) : NEW_LINE INDENT total_sum = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT subarray_sum += arr [ j ] ; NEW_LINE remaining_sum = total_sum - subarray_sum ; NEW_LINE if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Keluarkan satu elemen untuk mendapatkan XOR maksimum | Berfungsi untuk mengembalikan XOR yang dimaksimumkan selepas mengeluarkan elemen dari array; Cari xor array lengkap; Untuk menyimpan jawapan terakhir; Melangkah melalui array untuk mencari jawapan terakhir; Kembalikan jawapan terakhir; Kod pemacu", "code": "def maxXOR ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 1 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxXOR ( arr , n ) ) NEW_LINE"}
{"text": "Kira nombor dari julat [l, r] yang mengandungi sekurang -kurangnya satu digit yang membahagikan k | Fungsi yang mengembalikan benar jika NUM mengandungi sekurang -kurangnya satu digit yang membahagikan k; Dapatkan digit terakhir; Jika digit bukan sifar dan ia membahagikan k; Keluarkan digit terakhir; Tiada digit dalam num yang membahagikan k; Fungsi untuk mengembalikan kiraan unsur -unsur yang diperlukan dari julat yang diberikan yang mengandungi sekurang -kurangnya satu digit yang membahagikan k; Untuk menyimpan hasilnya; Untuk setiap nombor dari julat; Jika mana -mana digit nombor semasa membahagikan k; Kod pemacu", "code": "def digitDividesK ( num , k ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT d = num % 10 NEW_LINE if ( d != 0 and k % d == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT def findCount ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( digitDividesK ( i , k ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 20 NEW_LINE r = 35 NEW_LINE k = 45 NEW_LINE print ( findCount ( l , r , k ) ) NEW_LINE"}
{"text": "Semak jika nombor tertentu adalah faktorial mana -mana nombor | Fungsi untuk memeriksa sama ada nombor yang diberikan adalah faktorial bagi mana -mana nombor; Kod pemacu", "code": "def isFactorial ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n //= i ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 ; NEW_LINE ans = isFactorial ( n ) ; NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text": "Keluarkan elemen untuk meminimumkan LCM array yang diberikan | Pelaksanaan Python3 pendekatan di atas; Berfungsi untuk mengembalikan LCM dua nombor; Berfungsi untuk mengembalikan LCM minimum selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik negara tunggal untuk menyimpan LCM unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan LCM dari semua elemen yang mempunyai indeks lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan LCM minimum; Kod pemacu", "code": "from math import gcd NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT GCD = gcd ( a , b ) ; NEW_LINE return ( a * b ) // GCD ; NEW_LINE DEDENT def MinLCM ( a , n ) : NEW_LINE INDENT Prefix = [ 0 ] * ( n + 2 ) ; NEW_LINE Suffix = [ 0 ] * ( n + 2 ) ; NEW_LINE Prefix [ 1 ] = a [ 0 ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; NEW_LINE DEDENT Suffix [ n ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; NEW_LINE DEDENT ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 15 , 9 , 36 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinLCM ( a , n ) ) ; NEW_LINE DEDENT"}
{"text": "Bilangan berwarna 0 dalam n | Berfungsi untuk mengembalikan kiraan berwarna 0 s dalam segi enam tahap n; Kod pemacu", "code": "def count ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) // 2 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE DEDENT"}
{"text": "Nilai minimum yang akan diberikan kepada unsur -unsur supaya jumlahnya menjadi lebih besar daripada jumlah awal | Berfungsi untuk mengembalikan nilai minimum yang diperlukan; Cari jumlah elemen array; Mengembalikan nilai yang diperlukan; Kod pemacu", "code": "def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return ( sum // n ) + 1 NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 10 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinValue ( arr , n ) ) NEW_LINE"}
{"text": "Warna semua kotak sejajar supaya setiap kotak berturut -turut m adalah unik | Pelaksanaan Python3 pendekatan; Fungsi untuk kembali (M! % Mod); Kod pemacu", "code": "MOD = 1000000007 NEW_LINE def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE"}
{"text": "Jumlah kuadrat semua subset dari array yang diberikan | Pelaksanaan Python3 pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kuadrat subset; Mengikat unsur -unsur dan menambahkannya ke Ans; Kod pemacu", "code": "mod = 10 ** 9 + 7 NEW_LINE def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE DEDENT A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE"}
{"text": "Cari bilangan pasangan supaya GCD mereka sama dengan 1 | Program python3 untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Berfungsi untuk mengira faktor utama paling kurang setiap nombor; Jika ia adalah nombor utama; Untuk semua gandaan yang belum dikunjungi. ; Berfungsi untuk mencari nilai fungsi Mobius untuk semua nombor dari 1 hingga n; Jika nombor adalah satu; Jika nombor mempunyai faktor utama kuasa; Multiply - 1 dengan nombor sebelumnya; Berfungsi untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Untuk menyimpan nombor maksimum; Untuk menyimpan kekerapan setiap nombor; Cari kekerapan dan nombor maksimum; Untuk menyimpan nombor pasangan dengan GCD sama dengan 1; Melintasi semua elemen yang mungkin; Mengembalikan bilangan pasangan; Kod pemacu; Panggilan fungsi", "code": "N = 100050 NEW_LINE lpf = [ 0 for i in range ( N ) ] NEW_LINE mobius = [ 0 for i in range ( N ) ] NEW_LINE def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( lpf [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( lpf [ j ] == 0 ) : NEW_LINE INDENT lpf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def Mobius ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT mobius [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( lpf [ ( i // lpf [ i ] ) ] == lpf [ i ] ) : NEW_LINE INDENT mobius [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT mobius [ i ] = - 1 * mobius [ i // lpf [ i ] ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def gcd_pairs ( a , n ) : NEW_LINE INDENT maxi = 0 NEW_LINE fre = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ a [ i ] ] += 1 NEW_LINE maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT least_prime_factor ( ) NEW_LINE Mobius ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( mobius [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = 0 NEW_LINE for j in range ( i , maxi + 1 , i ) : NEW_LINE INDENT temp += fre [ j ] NEW_LINE DEDENT ans += temp * ( temp - 1 ) // 2 * mobius [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( gcd_pairs ( a , n ) ) NEW_LINE"}
{"text": "Membandingkan x ^ y dan y ^ x untuk nilai -nilai yang sangat besar x dan y | Pelaksanaan Python3 pendekatan; Fungsi untuk membandingkan x ^ y dan y ^ x; Menyimpan nilai x ^ y dan y ^ x; Membandingkan nilai; Kod pemacu", "code": "from math import log NEW_LINE def compareVal ( x , y ) : NEW_LINE INDENT a = y * log ( x ) ; NEW_LINE b = x * log ( y ) ; NEW_LINE if ( a > b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" > \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT elif ( a < b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" < \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" = \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 4 ; y = 5 ; NEW_LINE compareVal ( x , y ) ; NEW_LINE DEDENT"}
{"text": "Nombor Euler Zigzag (Permutasi Ganti) | Berfungsi untuk nombor n zigzag prfirst; Untuk menyimpan nombor factorial dan n 'th zig zag; Memulakan factorial sehingga n; Tetapkan dua nombor Zig Zag pertama; Cetak dua nombor zig zag pertama; Cetak nombor zig zag selebihnya; Binomial ( n , k ) * a ( k ) * a ( n - k ) ; Simpan nilai; Cetak nombor; Kod pemacu; Panggilan fungsi", "code": "def ZigZag ( n ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE zig = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT zig [ 0 ] = 1 NEW_LINE zig [ 1 ] = 1 NEW_LINE print ( \" zig ▁ zag ▁ numbers : ▁ \" , end = \" ▁ \" ) NEW_LINE print ( zig [ 0 ] , zig [ 1 ] , end = \" ▁ \" ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , i ) : NEW_LINE INDENT sum += ( ( fact [ i - 1 ] // ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ) NEW_LINE DEDENT zig [ i ] = sum // 2 NEW_LINE print ( sum // 2 , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE ZigZag ( n ) NEW_LINE"}
{"text": "Urutan Gijswijt | Jika urutan adalah (1) a (2) a (3). . A (n - 1) Periksa jika urutan boleh diwakili sebagai x * (y ^ k) mencari nilai terbesar k; kiraan; Corak unsur -unsur saiz I dari akhir urutan; kiraan; ekstrak corak dalam urutan terbalik; Semak berapa kali corak diulang; jika perlawanan dosis elemen; Jika akhir corak dicapai nilai set k = 0 dan tingkatkan kiraan; mengembalikan kiraan maksimum; cetak pertama n terma urutan Gijswijt; Tetapkan kiraan; membongkok elemen; Cetak istilah N pertama urutan; tolak elemen; Cari kiraan untuk nombor seterusnya; Kod pemacu", "code": "def find_count ( ele ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE INDENT p = [ ] NEW_LINE c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT count = max ( count , c ) NEW_LINE DEDENT return count NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT count = 1 NEW_LINE ele = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" ▁ \" ) NEW_LINE ele . append ( count ) NEW_LINE count = find_count ( ele ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT"}
{"text": "Wedderburn - Nombor Etherington | Menyimpan nombor Wedderburn Etherington; Berfungsi untuk mengembalikan nombor Nth Wedderburn Etherington; Kes asas; Jika n adalah n = 2 x; Dapatkan x; A (2 x) = A (1) A (2 x - 1) + A (2) A (2 x - 2) + ... + A (x - 1) A (x + 1); a (x) (a (x) + 1) / 2; Simpan Ans; Mengembalikan jawapan yang diperlukan; Jika n adalah ganjil; a (2 x - 1) = a (1) a (2 x - 2) + a (2) a (2 x - 3) + ... + a (x - 1) a (x) ,; Simpan Ans; Mengembalikan jawapan yang diperlukan; Berfungsi untuk nombor Nedderburn Etherington; Simpan nombor 3 pertama; Istilah PRN; Kod pemacu; panggilan fungsi", "code": "store = dict ( ) NEW_LINE def Wedderburn ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return store [ n ] NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT x = n // 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT ans += ( store [ x ] * ( store [ x ] + 1 ) ) // 2 NEW_LINE store [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT x = ( n + 1 ) // 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT store [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT def Wedderburn_Etherington ( n ) : NEW_LINE INDENT store [ 0 ] = 0 NEW_LINE store [ 1 ] = 1 NEW_LINE store [ 2 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( Wedderburn ( i ) , end = \" \" ) NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( end = \" , ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT n = 10 NEW_LINE Wedderburn_Etherington ( n ) NEW_LINE"}
{"text": "Nilai maksimum selepas menggabungkan semua elemen dalam array | Berfungsi dengan nilai maksimum selepas menggabungkan semua elemen dalam array; Untuk memeriksa sama ada elemen positif dan negatif hadir atau tidak; Semak integer positif; Semak integer negatif; Jika kedua -dua unsur positif dan negatif hadir; Untuk menyimpan nilai maksimum yang mungkin; Untuk mencari nilai minimum; Keluarkan elemen minimum; Menggantikan dengan nilai mutlak; Untuk mencari nilai minimum; Keluarkan elemen minimum; Mengembalikan jumlah yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "def Max_sum ( a , n ) : NEW_LINE INDENT pos = 0 NEW_LINE neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT pos = 1 NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT neg = 1 NEW_LINE DEDENT if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT elif ( pos == 1 ) : NEW_LINE INDENT mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT sum -= 2 * mini NEW_LINE DEDENT elif ( neg == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT sum -= 2 * mini NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 5 , - 2 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( Max_sum ( a , n ) ) NEW_LINE DEDENT"}
{"text": "Perpuluhan untuk binari menggunakan rekursi dan tanpa menggunakan pengendali kuasa | Fungsi rekursif untuk menukar n kepada bersamaan binari; Kes asas; Panggilan rekursif; Kod pemacu", "code": "def decimalToBinary ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT decimalToBinary ( n // 2 ) ; NEW_LINE print ( n % 2 , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE decimalToBinary ( n ) ; NEW_LINE DEDENT"}
{"text": "Cari nilai minimum a, b dan c apabila dua (a + b), (a + c) dan (b + c) diberikan | Berfungsi untuk mencari A, B dan C; Simpan nombor minimum dalam x; Cari nombor; Kod pemacu; Panggilan fungsi", "code": "def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT x = 123 NEW_LINE y = 13 NEW_LINE MinimumValue ( x , y ) NEW_LINE"}
{"text": "Check whether it is possible to convert A into B | Fungsi yang mengembalikan benar jika A boleh ditukar kepada B dengan operasi yang diberikan; Jika nombor semasa berakhir dengan 1; Jika nombor semasa boleh dibahagikan dengan 2; Jika dua keadaan di atas gagal; Sekiranya mungkin untuk menukar A ke B; Kod pemacu", "code": "def canConvert ( a , b ) : NEW_LINE INDENT while ( b > a ) : NEW_LINE INDENT if ( b % 10 == 1 ) : NEW_LINE INDENT b //= 10 ; NEW_LINE continue ; NEW_LINE DEDENT if ( b % 2 == 0 ) : NEW_LINE INDENT b /= 2 ; NEW_LINE continue ; NEW_LINE DEDENT return false ; NEW_LINE DEDENT if ( b == a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 ; B = 82 ; NEW_LINE if ( canConvert ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"}
{"text": "Count Rectangles yang berbeza dalam N * N Chessboard | Berfungsi untuk mengembalikan kiraan segi empat tepat; Kod pemacu", "code": "def count ( N ) : NEW_LINE INDENT a = 0 ; NEW_LINE a = ( N * ( N + 1 ) ) / 2 ; NEW_LINE return int ( a ) ; NEW_LINE DEDENT N = 4 ; NEW_LINE print ( count ( N ) ) ; NEW_LINE"}
{"text": "Jumlah hari yang diambil untuk menyelesaikan tugas jika selepas hari -hari tertentu seseorang meninggalkan | Berfungsi untuk mengembalikan bilangan hari yang diperlukan; Kod pemacu", "code": "def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 NEW_LINE b = 20 NEW_LINE n = 5 NEW_LINE print ( numberOfDays ( a , b , n ) ) NEW_LINE DEDENT"}
{"text": "Cari purata dua nombor menggunakan operasi bit | Berfungsi untuk mengembalikan purata x dan y menggunakan operasi bit; Kirakan nilai lantai purata (x + y) / 2; Kod pemacu", "code": "def getAverage ( x , y ) : NEW_LINE INDENT avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; NEW_LINE return avg NEW_LINE DEDENT x = 10 NEW_LINE y = 9 NEW_LINE print ( getAverage ( x , y ) ) NEW_LINE"}
{"text": "Indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya | Berfungsi untuk mencari indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya; Pada mulanya; Melintasi array; Semak jika elemen array adalah 1; a [i] = 0; Kembali minimum kedua -duanya; Kod pemacu", "code": "def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT"}
{"text": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Tetapkan 2 | Berfungsi untuk mengembalikan kiraan dataran yang boleh dikunjungi oleh raja dalam gerakan; Untuk menyimpan kiraan dataran; Semak semua dataran papan catur; Semak jika persegi (i, j) berada pada jarak <= m unit dari kedudukan semasa Raja; Kembali kiraan kuadrat; Kod pemacu", "code": "def countSquares ( r , c , m ) : NEW_LINE INDENT squares = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT for j in range ( 1 , 9 ) : NEW_LINE INDENT if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) : NEW_LINE INDENT squares = squares + 1 NEW_LINE DEDENT DEDENT DEDENT return squares NEW_LINE DEDENT r = 4 NEW_LINE c = 4 NEW_LINE m = 1 NEW_LINE print ( countSquares ( r , c , m ) ) ; NEW_LINE"}
{"text": "Bilangan kuadrup di mana tiga syarat pertama berada dalam AP dan tiga istilah terakhir adalah dalam gp | Berfungsi untuk mengembalikan kiraan kuadrup; Jadual Hash untuk mengira bilangan kejadian; Melintasi dan meningkatkan kiraan; Jalankan dua gelung bersarang untuk elemen kedua dan ketiga; Jika mereka sama; Pada mulanya mengurangkan kiraan; Cari elemen pertama menggunakan perbezaan bersama; Cari elemen keempat menggunakan gp y ^ 2 = x * z harta; Jika ia adalah integer; Jika tidak sama; Unsur yang sama; Kemudian meningkatkan nilai untuk pengiraan masa depan; Kod pemacu", "code": "def countQuadruples ( a , n ) : NEW_LINE INDENT mpp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if ( j == k ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT mpp [ a [ j ] ] -= 1 ; NEW_LINE mpp [ a [ k ] ] -= 1 ; NEW_LINE first = a [ j ] - ( a [ k ] - a [ j ] ) ; NEW_LINE if first not in mpp : NEW_LINE INDENT mpp [ first ] = 0 ; NEW_LINE DEDENT fourth = ( a [ k ] * a [ k ] ) // a [ j ] ; NEW_LINE if fourth not in mpp : NEW_LINE INDENT mpp [ fourth ] = 0 ; NEW_LINE DEDENT if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) : NEW_LINE INDENT if ( a [ j ] != a [ k ] ) : NEW_LINE INDENT count += mpp [ first ] * mpp [ fourth ] ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( mpp [ first ] * ( mpp [ fourth ] - 1 ) ) ; NEW_LINE DEDENT DEDENT mpp [ a [ j ] ] += 1 ; NEW_LINE mpp [ a [ k ] ] += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 6 , 4 , 9 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( countQuadruples ( a , n ) ) ; NEW_LINE DEDENT"}
{"text": "Nombor dalam julat dengan akar digital yang diberikan | Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor yang ada dalam julat yang diberikan; Bilangan kumpulan 9 elemen bermula dari L; Meninggalkan unsur -unsur yang tidak diliputi dalam Faktor 9; Satu nombor dalam setiap kumpulan 9; Untuk memeriksa sama ada nombor dalam REM memenuhi harta itu; Kod pemacu", "code": "def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT totalnumbers = R - L + 1 NEW_LINE factor9 = totalnumbers // 9 NEW_LINE rem = totalnumbers % 9 NEW_LINE ans = factor9 NEW_LINE for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | Berfungsi untuk mengembalikan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Tambah nilai yang diberikan kepada [indeks]; Untuk menyimpan jumlah elemen walaupun; Jika elemen semasa adalah walaupun; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Vektor yang dihasilkan yang menyimpan hasil untuk setiap pertanyaan; Dapatkan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "def EvenSum ( A , index , value ) : NEW_LINE INDENT A [ index ] = A [ index ] + value NEW_LINE sum = 0 NEW_LINE for i in A : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT def BalanceArray ( A , Q ) : NEW_LINE INDENT ANS = [ ] NEW_LINE i , sum = 0 , 0 NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT index = Q [ i ] [ 0 ] NEW_LINE value = Q [ i ] [ 1 ] NEW_LINE sum = EvenSum ( A , index , value ) NEW_LINE ANS . append ( sum ) NEW_LINE DEDENT for i in ANS : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] NEW_LINE BalanceArray ( A , Q ) NEW_LINE"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Jika elemen semasa adalah walaupun; Jika elemen bahkan kemudian keluarkannya dari jumlah; Jika nilai menjadi walaupun selepas mengemas kini; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "def BalanceArray ( A , Q ) : NEW_LINE INDENT ANS = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( len ( Q ) ) : NEW_LINE INDENT index = Q [ i ] [ 0 ] ; NEW_LINE value = Q [ i ] [ 1 ] ; NEW_LINE if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum -= A [ index ] ; NEW_LINE DEDENT A [ index ] += value ; NEW_LINE if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ index ] ; NEW_LINE DEDENT ANS . append ( sum ) ; NEW_LINE DEDENT for i in range ( len ( ANS ) ) : NEW_LINE INDENT print ( ANS [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] ; NEW_LINE Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] ; NEW_LINE BalanceArray ( A , Q ) ; NEW_LINE DEDENT"}
{"text": "Bilangan Siklus Hamiltonian | Program Python3 untuk pelaksanaan program di atas; Fungsi yang mengira bilangan kitaran Hamiltonian; Mengira faktorial; Kod pemacu", "code": "import math as mt NEW_LINE def Cycles ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE result = N - 1 NEW_LINE i = result NEW_LINE while ( i > 0 ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact // 2 NEW_LINE DEDENT N = 5 NEW_LINE Number = Cycles ( N ) NEW_LINE print ( \" Hamiltonian ▁ cycles ▁ = ▁ \" , Number ) NEW_LINE"}
{"text": "Integer terkecil lebih besar daripada n sedemikian rupa sehingga ia terdiri daripada digit m tepat kali K | Fungsi yang pulih benar jika n mengandungi digit m tepat k kali; Berfungsi untuk mengembalikan integer terkecil> n dengan digit m yang berlaku tepat kali K; Kod pemacu", "code": "def digitWell ( n , m , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == m ) : NEW_LINE INDENT cnt = cnt + 1 ; NEW_LINE DEDENT n = ( int ) ( n / 10 ) ; NEW_LINE DEDENT return cnt == k ; NEW_LINE DEDENT def findInt ( n , m , k ) : NEW_LINE INDENT i = n + 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( digitWell ( i , m , k ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT DEDENT n = 111 ; m = 2 ; k = 2 ; NEW_LINE print ( findInt ( n , m , k ) ) ; NEW_LINE"}
{"text": "KOMPOSITE XOR DAN COPRIME DAN | Berfungsi untuk mengembalikan kiraan nombor ganjil dalam array; Pembolehubah untuk mengira nombor ganjil; Nombor ganjil; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "def countOdd ( arr , n ) : NEW_LINE INDENT odd = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd = odd + 1 ; NEW_LINE DEDENT DEDENT return odd ; NEW_LINE DEDENT def countValidPairs ( arr , n ) : NEW_LINE INDENT odd = countOdd ( arr , n ) ; NEW_LINE return ( odd * ( odd - 1 ) ) / 2 ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( int ( countValidPairs ( arr , n ) ) ) ; NEW_LINE"}
{"text": "Cube sempurna terkecil dibahagi dengan semua elemen array | Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan LCM semua elemen array; Untuk mengira LCM dua nombor melipatgandakan mereka dan membahagikan hasilnya dengan GCD kedua -dua nombor; Mengembalikan LCM unsur -unsur array; Berfungsi untuk mengembalikan kiub sempurna yang paling kecil yang boleh dibahagikan dengan semua elemen arr []; LCM semua elemen ARR []; Jika 2 membahagikan bilangan kali LCM CNT; Semak semua nombor yang membahagikan LCM; Kembalikan jawapannya; Kod pemacu", "code": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) ; NEW_LINE DEDENT return lcm NEW_LINE DEDENT def minPerfectCube ( arr , n ) : NEW_LINE INDENT lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT if ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return minPerfectCube NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Semak jika n adalah Perdana yang kuat | Program Python 3 untuk memeriksa sama ada nombor yang diberikan adalah perdana yang kuat; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah perdana yang kuat; Jika n bukan nombor perdana atau n adalah perdana pertama maka kembali palsu; Inisialisasi sebelumnya_prime ke n - 1 dan next_prime ke n + 1; Cari nombor perdana seterusnya; Cari nombor perdana sebelumnya; Min aritmetik; Jika n adalah perdana yang kuat; Kod pemacu", "code": "from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isStrongPrime ( n ) : NEW_LINE INDENT if ( isPrime ( n ) == False or n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT previous_prime = n - 1 NEW_LINE next_prime = n + 1 NEW_LINE while ( isPrime ( next_prime ) == False ) : NEW_LINE INDENT next_prime += 1 NEW_LINE DEDENT while ( isPrime ( previous_prime ) == False ) : NEW_LINE INDENT previous_prime -= 1 NEW_LINE DEDENT mean = ( previous_prime + next_prime ) / 2 NEW_LINE if ( n > mean ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 11 NEW_LINE if ( isStrongPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Penyingkiran minimum dalam nombor yang boleh dibahagikan dengan 10 kuasa yang dibangkitkan kepada k | berfungsi untuk mengembalikan bilangan digit yang diperlukan untuk dikeluarkan; Menukar nombor yang diberikan ke dalam rentetan; pembolehubah untuk menyimpan nombor digit yang akan dikeluarkan; Pembolehubah untuk menunjukkan jika sekurang -kurangnya satu sifar telah dijumpai; sifar dijumpai; saiz pulangan - 1 jika k tidak sifar dan atleast satu sifar hadir, jika tidak hasilnya; Kod pemacu", "code": "def countDigitsToBeRemoved ( N , K ) : NEW_LINE INDENT s = str ( N ) ; NEW_LINE res = 0 ; NEW_LINE f_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT f_zero = 1 ; NEW_LINE K -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT elif ( f_zero > 0 ) : NEW_LINE INDENT return len ( s ) - 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT N = 10904025 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 1000 ; NEW_LINE K = 5 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 23985 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE"}
{"text": "Program untuk mencari jumlah siri (1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n) | Program Python 3 untuk mencari jumlah siri yang diberikan; Berfungsi untuk mengembalikan jumlah siri; pembolehubah untuk menyimpan jawapannya; Matematik. pow (x, y) mengembalikan x ^ y; Kod pemacu; Cetak jumlah siri", "code": "import math NEW_LINE def getSum ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i / math . pow ( a , i ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT a = 3 ; n = 3 ; NEW_LINE print ( getSum ( a , n ) ) ; NEW_LINE"}
{"text": "Semak sama ada nombor adalah nombor yang tidak biasa atau tidak | Program Python untuk memeriksa nombor luar biasa; Fungsi utiliti untuk mencari faktor utama terbesar bagi nombor; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya untuk bilangan bulat yang ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk memeriksa nombor yang tidak biasa; Dapatkan faktor utama terbesar nombor; Semak jika faktor utama terbesar adalah lebih besar daripada sqrt (n); Kod pemacu", "code": "from math import sqrt NEW_LINE def largestPrimeFactor ( n ) : NEW_LINE INDENT max = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT max = 2 ; NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT max = i ; NEW_LINE n = n / i ; NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT max = n NEW_LINE DEDENT return max NEW_LINE DEDENT def checkUnusual ( n ) : NEW_LINE INDENT factor = largestPrimeFactor ( n ) NEW_LINE if factor > sqrt ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if checkUnusual ( n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak jika sekurang -kurangnya separuh array boleh diturunkan kepada sifar dengan melakukan beberapa operasi | Berfungsi untuk mencetak hasil yang diingini selepas pengiraan; Kod pemacu", "code": "def isHalfReducible ( arr , n , m ) : NEW_LINE INDENT frequencyHash = [ 0 ] * ( m + 1 ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT frequencyHash [ ( arr [ i ] % ( m + 1 ) ) ] += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( i <= m ) : NEW_LINE INDENT if ( frequencyHash [ i ] >= ( n / 2 ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( i <= m ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT arr = [ 8 , 16 , 32 , 3 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 7 ; NEW_LINE isHalfReducible ( arr , n , m ) ; NEW_LINE"}
{"text": "Semak jika nombor yang diberikan adalah nombor bijih atau tidak | Program Python3 untuk memeriksa sama ada nombor yang diberikan adalah nombor bijih; Fungsi yang mengembalikan min harmonik; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, simpan 'i; Jika tidak, simpan 'i' dan 'n / i' kedua -duanya; Fungsi utiliti untuk mengira min harmonik pembahagi; Mengisytiharkan pembolehubah jumlah dan permulaan dengan sifar. ; hitung penyebut; Mengira min dan pulangan harmonik; Berfungsi untuk memeriksa sama ada nombor adalah nombor bijih; Kirakan min harmonik pembahagi n; Semak jika min harmonik adalah integer atau tidak; Kod pemacu", "code": "arr = [ ] NEW_LINE def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if n // i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n // i ) NEW_LINE DEDENT DEDENT def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n / arr [ i ] ) NEW_LINE DEDENT Sum = Sum / n NEW_LINE return length / Sum NEW_LINE DEDENT def isOreNumber ( n ) : NEW_LINE INDENT mean = harmonicMean ( n ) NEW_LINE if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if isOreNumber ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program Python3 untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor utama dan menyimpan produk mereka; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; kedai awalan produk nombor perdana kepada unordered_set 's; mengemas kini produk dengan mendarabkan Perdana Seterusnya; Masukkan 'Produce + 1' untuk ditetapkan; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Periksa sama ada nombor wujud dalam set yang tidak teratur atau tidak jika ada, kembali benar; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "MAX = 10000 NEW_LINE s = set ( ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX ) NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 100 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT ' NEW_LINE INDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT product = product * p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT if n in s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if isEuclid ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT n = 42 NEW_LINE if isEuclid ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak sama ada nombor yang diberikan ialah Wagstaff Prime atau tidak | Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi utiliti untuk memeriksa kuasa dua; Kod pemacu; Semak jika nombor adalah perdana dan borang (2 ^ q + 1) / 3", "code": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE if ( isPrime ( n ) and isPowerOfTwo ( n * 3 - 1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segi enam | Program Python 3 untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segi enam; Berfungsi untuk mencari kawasan dataran; sisi segi enam tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "from math import pow , sqrt NEW_LINE def area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE print ( \" { 0 : . 3 } \" . format ( area ( a ) ) ) NEW_LINE DEDENT"}
{"text": "Program untuk mencari istilah n Siri 1, 6, 17, 34, 56, 86, 121, 162, ... .... | mengira istilah siri nth; Kod pemacu", "code": "def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE"}
{"text": "Jumlah terma pertama N Siri 2, 10, 30, 68, .... | Berfungsi untuk mengira jumlah; bilangan syarat yang akan dimasukkan dalam jumlah; Cari jumlahnya", "code": "def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 + pow ( ( n * ( n + 1 ) // 2 ) , 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( \" Sum ▁ = ▁ \" , calculateSum ( n ) ) NEW_LINE"}
{"text": "Semak jika dua tatasusunan adalah permutasi antara satu sama lain menggunakan operasi matematik | Fungsi untuk memeriksa sama ada tatasusunan adalah permutasi antara satu sama lain; Mengira jumlah dan kalikan array pertama; Mengira jumlah dan kalikan array kedua; Jika jumlah dan Mul kedua -dua tatasusunan adalah sama, kembali benar, lain kembali palsu. ; Kod pemacu", "code": "def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 , sum2 , mul1 , mul2 = 0 , 0 , 1 , 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if arePermutations ( a , b , n , m ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Program untuk mencari permulaan dalam perlumbaan | Fungsi untuk mencari B mula c; Apabila B menyelesaikannya 100 meter kemudian selesai meter dengan C adalah; Kod pemacu; Apabila ia menyelesaikannya 100 meter kemudian selesai meter b dan c adalah", "code": "def Race ( B , C ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = ( ( C * 100 ) // B ) NEW_LINE return 100 - result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT B = 10 NEW_LINE C = 28 NEW_LINE B = 100 - B ; NEW_LINE C = 100 - C ; NEW_LINE print ( str ( Race ( B , C ) ) + \" ▁ meters \" ) NEW_LINE DEDENT"}
{"text": "Masa minimum diperlukan untuk mengisi tangki menggunakan paip n | Berfungsi untuk mengira masa; Kod pemacu", "code": "def Time ( arr , n , Emptypipe ) : NEW_LINE INDENT fill = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fill += ( 1 / arr [ i ] ) NEW_LINE DEDENT fill = fill - ( 1 / float ( Emptypipe ) ) NEW_LINE return int ( 1 / fill ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 14 ] NEW_LINE Emptypipe = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( ( Time ( arr , n , Emptypipe ) ) , \" Hours \" ) NEW_LINE DEDENT"}
{"text": "Semak jika perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 | Berfungsi untuk memeriksa kebolehpasaran; Jumlah semua digit individu; Keadaan; Kod pemacu; Nombor oktal", "code": "def check ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT if sum % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 25 NEW_LINE print ( ( \" YES \" ) if check ( n ) == 1 else print ( \" NO \" ) ) NEW_LINE DEDENT"}
{"text": "Jumlah semua pembahagi utama nombor | Program Python 3 untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kod pemacu", "code": "N = 1000005 NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT n = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE"}
{"text": "Jumlah semua pembahagi utama nombor | berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Kod pemacu", "code": "def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT DEDENT DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE DEDENT N = 60 NEW_LINE print ( \" Sum ▁ of ▁ prime \" , \" divisors ▁ of ▁ 60 ▁ is \" , Sum ( N ) ) ; NEW_LINE"}
{"text": "Cari (a ^ b) % m di mana 'b' sangat besar | Berfungsi untuk mencari kuasa; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasilnya; y mestilah sekarang y = y >> 1 y = y / 2; Kod pemacu; Input rentetan sebagai B sangat besar; Kurangkan bilangan B ke bilangan kecil menggunakan fermat kecil", "code": "def power ( x , y , p ) : NEW_LINE INDENT x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT a = 3 NEW_LINE b = \"100000000000000000000000000\" NEW_LINE remainderB = 0 NEW_LINE MOD = 1000000007 NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT remainderB = ( ( remainderB * 10 + ord ( b [ i ] ) - 48 ) % ( MOD - 1 ) ) NEW_LINE DEDENT print ( power ( a , remainderB , MOD ) ) NEW_LINE"}
{"text": "Kuadrat nombor dengan digit tunggal berulang | Tetapkan 1 (3, 6 dan 9) | Fungsi untuk mencari persegi 333. .. .333, 666. .666 dan 999.. .999; Sekiranya nombornya adalah 333. .. .333; Jika nombor itu 666. .. .666; Jika nombor itu 999 .. .999; pembolehubah untuk hasil pegangan; Cari tidak digit; tambah saiz - 1 kali dalam hasil; Tambah satu kali B hasil; tambah saiz - 1 kali c dalam hasil; tambah satu kali d hasil; hasil pulangan; Pemandu kod kod Python 3 anda; Cari persegi 33. .33; cari persegi 66. .66; cari persegi 66. .66", "code": "def find_Square_369 ( num ) : NEW_LINE INDENT if ( num [ 0 ] == '3' ) : NEW_LINE INDENT a = '1' NEW_LINE b = '0' NEW_LINE c = '8' NEW_LINE d = '9' NEW_LINE DEDENT elif ( num [ 0 ] == '6' ) : NEW_LINE INDENT a = '4' NEW_LINE b = '3' NEW_LINE c = '5' NEW_LINE d = '6' NEW_LINE DEDENT else : NEW_LINE INDENT a = '9' NEW_LINE b = '8' NEW_LINE c = '0' NEW_LINE d = '1' NEW_LINE DEDENT result = \" \" NEW_LINE size = len ( num ) NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT result += a NEW_LINE DEDENT result += b NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT result += c NEW_LINE DEDENT result += d NEW_LINE return result NEW_LINE DEDENT num_3 = \"3333\" NEW_LINE num_6 = \"6666\" NEW_LINE num_9 = \"9999\" NEW_LINE result = \" \" NEW_LINE result = find_Square_369 ( num_3 ) NEW_LINE print ( \" Square ▁ of ▁ \" + num_3 + \" ▁ is ▁ : ▁ \" + result ) ; NEW_LINE result = find_Square_369 ( num_6 ) NEW_LINE print ( \" Square ▁ of ▁ \" + num_6 + \" ▁ is ▁ : ▁ \" + result ) ; NEW_LINE result = find_Square_369 ( num_9 ) NEW_LINE print ( \" Square ▁ of ▁ \" + num_9 + \" ▁ is ▁ : ▁ \" + result ) ; NEW_LINE"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) | Program Python3 Untuk melaksanakan pendekatan di atas untuk menjalankan kod ini, kita perlu menyalin modular songsang dari pos di bawah. HTTPS: www. Geeksforgeeks. org / multiplicative - songsang - bawah - modulo - m /; Kaedah naif - mengira hasil dalam satu baris; modular_inverse () adalah fungsi yang ditetapkan pengguna yang mengira songsang nombor; Ia akan menggunakan algoritma Eucledian yang dilanjutkan atau teorem kecil Fermat untuk pengiraan.  MMI dari 120 di bawah Bahagian oleh 1000000007 akan menjadi 8083333339", "code": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT naive_answer = ( ( ( 55555 * 55554 * 55553 * 55552 * 55551 ) // 120 ) % 1000000007 ) NEW_LINE ans = 1 NEW_LINE i = modular_inverse ( 120 , 10000007 ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans = ( ( ans * ( 55555 - i ) ) % 1000000007 ) NEW_LINE DEDENT ans = ( ans * i ) % 1000000007 NEW_LINE print ( \" Answer ▁ using ▁ naive ▁ method : \" , naive_answer ) NEW_LINE print ( \" Answer ▁ using ▁ multiplicative \" + \" modular ▁ inverse ▁ concept : \" , ans ) NEW_LINE DEDENT"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) |", "code": "ans = 1 NEW_LINE mod = 1000000007 * 120 NEW_LINE for i in range ( 0 , 5 ) : NEW_LINE INDENT ans = ( ans * ( 55555 - i ) ) % mod NEW_LINE DEDENT ans = int ( ans / 120 ) NEW_LINE print ( \" Answer ▁ using ▁ shortcut : ▁ \" , ans ) NEW_LINE"}
{"text": "Cara untuk membiak elemen dengan operasi bersekutu | Fungsi untuk mencari faktorial yang diperlukan; Berfungsi untuk mencari NCR; berfungsi untuk mencari bilangan cara; Kod pemacu", "code": "def fact ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT ans = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT Nr = n ; Dr = 1 ; ans = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans = int ( ( ans * Nr ) / ( Dr ) ) ; NEW_LINE Nr = Nr - 1 ; NEW_LINE Dr = Dr + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT N = 2 * n - 2 ; NEW_LINE R = n - 1 ; NEW_LINE return ( nCr ( N , R ) * fact ( n - 1 ) ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( solve ( n ) ) ; NEW_LINE"}
{"text": "Triplet Pythagorean dengan jumlah yang diberikan | Program Python3 untuk mencari triplet Pythagorean yang diberikan. ; Memandangkan tiga kali ganda dalam urutan yang disusun. Nilai elemen pertama dalam triplet yang disusun boleh diadakan - kebanyakan n / 3 .; Nilai elemen kedua mestilah kurang daripada sama dengan n / 2; Kod pemacu", "code": "def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , \" , ▁ \" , j , \" , ▁ \" , k , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" No ▁ Triplet \" ) NEW_LINE DEDENT n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | berfungsi untuk mengira faktorial nombor; Berfungsi untuk mencetak siri; Mengira nilai n! ; gelung untuk memaparkan siri; Untuk mengira nilai NCR; mengira nilai A ke kuasa k dan x ke kuasa k; Paparkan siri; Kod pemacu", "code": "def factorial ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f *= i NEW_LINE DEDENT return f NEW_LINE DEDENT def series ( A , X , n ) : NEW_LINE INDENT nFact = factorial ( n ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT niFact = factorial ( n - i ) NEW_LINE iFact = factorial ( i ) NEW_LINE aPow = pow ( A , n - i ) NEW_LINE xPow = pow ( X , i ) NEW_LINE print ( int ( ( nFact * aPow * xPow ) / ( niFact * iFact ) ) , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Fungsi untuk mengira jumlah siri; Kod pemacu", "code": "def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( seiresSum ( n , a ) ) NEW_LINE"}
{"text": "Kuasa nombor utama 'r' dalam n! | Berfungsi untuk mengembalikan kuasa no. 'r' dalam faktorial n; Terus membahagikan n dengan kuasa 'r' dan mengemaskini kiraan; Kod pemacu", "code": "def power ( n , r ) : NEW_LINE INDENT count = 0 ; i = r NEW_LINE while ( ( n / i ) >= 1 ) : NEW_LINE INDENT count += n / i NEW_LINE i = i * r NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT n = 6 ; r = 3 NEW_LINE print ( power ( n , r ) ) NEW_LINE"}
{"text": "Purata nombor natural natur pertama | Mengembalikan AVG nombor n pertama; Jumlah nombor pertama yang pertama; Purata nombor pertama yang ganjil; Kod pemacu", "code": "def avg_of_odd_num ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 2 * i + 1 ) NEW_LINE DEDENT return sm // n NEW_LINE DEDENT n = 20 NEW_LINE print ( avg_of_odd_num ( n ) ) NEW_LINE"}
{"text": "Purata nombor natural natur pertama | Kembalikan purata jumlah nombor pertama yang ganjil; Kod pemacu", "code": "def avg_of_odd_num ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT n = 8 NEW_LINE print ( avg_of_odd_num ( n ) ) NEW_LINE"}
{"text": "Program untuk mencetak segitiga Fibonacci | berfungsi untuk mengisi nombor fibonacci dalam f []; 1 ST dan 2 ND nombor siri adalah 1 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Isi nombor Fibonacci dalam f [] menggunakan Fib (). Kami memerlukan n = n * (n + 1) / 2 nombor fibonacci untuk membuat segitiga ketinggian n; Untuk menyimpan nombor Fibonacci seterusnya untuk dicetak; untuk gelung untuk menjejaki bilangan baris; Untuk gelung untuk menjejaki nombor dalam setiap baris; Kod pemacu", "code": "def fib ( f , N ) : NEW_LINE INDENT f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE DEDENT DEDENT def fiboTriangle ( n ) : NEW_LINE INDENT N = n * ( n + 1 ) // 2 NEW_LINE f = [ 0 ] * ( N + 1 ) NEW_LINE fib ( f , N ) NEW_LINE fiboNum = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( f [ fiboNum ] , \" ▁ \" , end = \" \" ) NEW_LINE fiboNum = fiboNum + 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE fiboTriangle ( n ) NEW_LINE"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Fungsi untuk mengira purata nombor ganjil; mengira nombor ganjil; Simpan jumlah nombor ganjil; Fungsi pemacu", "code": "def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count = count + 1 NEW_LINE sm = sm + n NEW_LINE n = n - 2 NEW_LINE DEDENT return sm // count NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Fungsi untuk mengira purata nombor ganjil; fungsi pemacu", "code": "def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) // 2 NEW_LINE DEDENT n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE"}
{"text": "Cari Max Dua Nombor Rasional | Program Python untuk mencari Max antara dua nombor rasional; Dapatkan LCM dua nombor; Dapatkan nombor rasional maksimum; Cari LCM pertama -> penyebut dan SEC -> penyebut; Mengisytiharkan NUME1 dan NUME2 untuk mendapatkan nilai pengangka pertama dan pengangka kedua; Kod pemacu", "code": "import math NEW_LINE def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( math . gcd ( a , b ) ) NEW_LINE DEDENT def maxRational ( first , sec ) : NEW_LINE INDENT k = lcm ( first [ 1 ] , sec [ 1 ] ) NEW_LINE nume1 = first [ 0 ] NEW_LINE nume2 = sec [ 0 ] NEW_LINE nume1 *= k // ( first [ 1 ] ) NEW_LINE nume2 *= k // ( sec [ 1 ] ) NEW_LINE return first if ( nume2 < nume1 ) else sec NEW_LINE DEDENT first = [ 3 , 2 ] NEW_LINE sec = [ 3 , 4 ] NEW_LINE res = maxRational ( first , sec ) NEW_LINE print ( res [ 0 ] , \" / \" , res [ 1 ] , sep = \" \" ) NEW_LINE"}
{"text": "Trinomial Triangle | Fungsi untuk mencari nilai segitiga trinomial. ; Kes asas; CAS asas; langkah rekursif. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Kod yang didorong", "code": "def TrinomialValue ( n , k ) : NEW_LINE INDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k < - n or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ) NEW_LINE DEDENT def printTrinomial ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( - i , 1 ) : NEW_LINE INDENT print ( TrinomialValue ( i , j ) , end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( TrinomialValue ( i , j ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE printTrinomial ( n ) NEW_LINE"}
{"text": "Trinomial Triangle | Fungsi untuk mencari nilai segitiga trinomial. ; Menggunakan harta segitiga trinomial. ; Jika nilai sudah dikira, kembalikan itu. ; Kes asas; Kes asas; langkah rekursif dan menyimpan nilai. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Program yang didorong", "code": "def TrinomialValue ( dp , n , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT k = - k NEW_LINE DEDENT if dp [ n ] [ k ] != 0 : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k < - n or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) NEW_LINE DEDENT def printTrinomial ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * 10 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( - i , 1 ) : NEW_LINE INDENT print ( TrinomialValue ( dp , i , j ) , end = \" ▁ \" ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( TrinomialValue ( dp , i , j ) , end = \" ▁ \" ) NEW_LINE DEDENT print ( \" \" , end = ' ' ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE printTrinomial ( n ) NEW_LINE"}
{"text": "Jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N | fungsi untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan n; Buat array Integer \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai 0. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika 'I' adalah perdana, jika tidak, ia akan mengandungi faktor utama terbesar 'I'. ; Jika Perdana [P] adalah '0', maka ia adalah nombor utama; Kemas kini semua gandaan P; Merangkumi faktor utama terbesar bagi semua nombor; jika 'p' adalah nombor bukan utama maka perdana [p] memberikan faktor utama largesr; 'P' adalah nombor utama; Jumlah yang diperlukan; Kod pemacu untuk menguji fungsi di atas", "code": "def sumOfLargePrimeFactor ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE max = int ( n / 2 ) NEW_LINE for p in range ( 2 , max + 1 ) : NEW_LINE INDENT if prime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT sum += prime [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 12 NEW_LINE print ( \" Sum ▁ = \" , sumOfLargePrimeFactor ( n ) ) NEW_LINE"}
{"text": "Jumlah gandaan nombor sehingga n | Mengira jumlah gandaan nombor sehingga n; Bilangan gandaan; jumlah nombor semulajadi pertama; jumlah gandaan; Kod pemacu", "code": "def calculate_sum ( a , N ) : NEW_LINE INDENT m = N / a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * sum NEW_LINE print ( \" Sum ▁ of ▁ multiples ▁ of ▁ \" , a , \" ▁ up ▁ to ▁ \" , N , \" ▁ = ▁ \" , ans ) NEW_LINE DEDENT calculate_sum ( 7 , 49 ) NEW_LINE"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | pulangan 1 apabila STR adalah kuasa 2 pulangan 0 apabila STR bukan kuasa 2; Jumlah menyimpan dividen pertengahan semasa membahagikan. ; jika input adalah \"1\" maka kembali 0 kerana 2 ^ k = 1 di mana k> = 1 dan di sini k = 0; Bahagikan nombor sehingga ia dikurangkan kepada 1 jika kita berjaya dapat mengurangkan nombor kepada 1, ia bermakna rentetan input adalah kuasa dua jika di antara nombor ganjil muncul pada akhirnya ia bermakna rentetan tidak dibahagikan dengan dua sehingga bukan kuasa 2; Sekiranya digit terakhir adalah ganjil maka rentetan tidak dapat dibahagikan dengan 2 oleh itu bukan kuasa dua pulangan 0 .; Bahagikan keseluruhan rentetan dengan 2. Saya digunakan untuk mengesan indeks dalam nombor semasa. J digunakan untuk mengesan indeks untuk lelaran seterusnya. ; Jika num <2 maka kita perlu mengambil satu lagi digit di sebelah kanan [i] untuk menjadikannya lebih besar daripada [i]. E. g. 214/2 -> 107; Jika ia bukan indeks pertama. Contohnya 214 maka kita perlu memasukkan 0 .; untuk contohnya. \"124\" Kami tidak akan menulis 064 jadi jika indeks pertama hanya mengabaikan; Selepas setiap bahagian dengan 2 panjang rentetan diubah. ; Jika rentetan mencapai 1 maka str adalah kuasa 2 .; Kod pemacu.", "code": "def isPowerOf2 ( sttr ) : NEW_LINE INDENT len_str = len ( sttr ) ; NEW_LINE sttr = list ( sttr ) ; NEW_LINE num = 0 ; NEW_LINE if ( len_str == 1 and sttr [ len_str - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( len_str != 1 or sttr [ len_str - 1 ] != '1' ) : NEW_LINE INDENT if ( ( ord ( sttr [ len_str - 1 ] ) - ord ( '0' ) ) % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( len_str ) : NEW_LINE INDENT num = num * 10 + ( ord ( sttr [ i ] ) - ord ( '0' ) ) ; NEW_LINE if ( num < 2 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT sttr [ j ] = '0' ; NEW_LINE j += 1 ; NEW_LINE DEDENT continue ; NEW_LINE DEDENT sttr [ j ] = chr ( ( num // 2 ) + ord ( '0' ) ) ; NEW_LINE j += 1 ; NEW_LINE num = ( num ) - ( num // 2 ) * 2 ; NEW_LINE DEDENT len_str = j ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT str1 = \"124684622466842024680246842024662202000002\" ; NEW_LINE str2 = \"1\" ; NEW_LINE str3 = \"128\" ; NEW_LINE print ( \" \" , isPowerOf2 ( str1 ) ,   \" \" , isPowerOf2 ( str2 ) ,   \" \" , isPowerOf2 ( str3 ) ) ; NEW_LINE"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Berfungsi untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Fungsi pemacu", "code": "def ispowerof2 ( num ) : NEW_LINE INDENT if ( ( num & ( num - 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 549755813888 NEW_LINE print ( ispowerof2 ( num ) ) NEW_LINE DEDENT"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Untuk mengira bilangan faktor dalam nombor; Inisialisasi kiraan dengan 0; Kiraan kenaikan untuk setiap faktor nombor x yang diberikan. ; Pulangan bilangan faktor; Mengembalikan bilangan pembahagi dalam pendaraban array; Mengumpulkan semua elemen array yang diberikan. ; Fungsi panggilan yang mengira bilangan faktor nombor; Kod pemacu", "code": "def counDivisors ( X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , X + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def countDivisorsMult ( arr , n ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul *= arr [ i ] NEW_LINE DEDENT return counDivisors ( mul ) NEW_LINE DEDENT arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDivisorsMult ( arr , n ) ) NEW_LINE"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Program Python 3 untuk mengira pembahagi dalam pendaraban array. ; Buat array Boolean \"Isprime [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Isprime [i] akhirnya akan menjadi palsu jika saya bukannya Isprime, yang lain benar. ; Jika Isprime [p] tidak berubah, maka ia adalah isprime; Kemas kini semua gandaan P; Cetak semua nombor isprime; Mengembalikan bilangan pembahagi dalam pendaraban array; Cari semua nombor perdana yang lebih kecil daripada elemen terbesar. ; Cari tuduhan kejadian setiap faktor utama; Mengira kiraan semua pembahagi menggunakan kiraan faktor utama. ; Kod pemacu", "code": "from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( largest , prime ) : NEW_LINE INDENT isPrime = [ True ] * ( largest + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= largest : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , largest + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , largest + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def countDivisorsMult ( arr , n ) : NEW_LINE INDENT largest = max ( arr ) NEW_LINE prime = [ ] NEW_LINE SieveOfEratosthenes ( largest , prime ) NEW_LINE mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( prime ) ) : NEW_LINE INDENT while ( arr [ i ] > 1 and arr [ i ] % prime [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] //= prime [ j ] NEW_LINE mp [ prime [ j ] ] += 1 NEW_LINE DEDENT DEDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT res = 1 NEW_LINE for it in mp . values ( ) : NEW_LINE INDENT res *= ( it + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDivisorsMult ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "K pasangan perdana jauh dalam julat yang diberikan | Program Python3 untuk pendekatan di atas; Berfungsi untuk menjana nombor perdana dalam julat yang diberikan [l, r]; Simpan semua nilai dalam julat; Padam 1 sebagai bukan perdana; Melakukan penapis eratosthenes; Cari pelbagai semasa; Padam kerana ia bukan perdana; Kenaikan berganda; Berfungsi untuk mencetak semua pasangan utama dalam julat yang diberikan oleh k; Menjana semua nombor perdana; Melintasi peta m; Jika ia. Pertama & (ia pertama + k) adalah perdana kemudian cetak pasangan ini; Kod pemacu; Julat yang diberikan; Diberikan k; Panggilan fungsi", "code": "from math import sqrt NEW_LINE def findPrimeNos ( L , R , M ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT M [ i ] = M . get ( i , 0 ) + 1 NEW_LINE DEDENT if ( 1 in M ) : NEW_LINE INDENT M . pop ( 1 ) NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( R ) ) + 1 , 1 ) : NEW_LINE INDENT multiple = 2 NEW_LINE while ( ( i * multiple ) <= R ) : NEW_LINE INDENT if ( ( i * multiple ) in M ) : NEW_LINE INDENT M . pop ( i * multiple ) NEW_LINE DEDENT multiple += 1 NEW_LINE DEDENT DEDENT DEDENT def getPrimePairs ( L , R , K ) : NEW_LINE INDENT M = { } NEW_LINE findPrimeNos ( L , R , M ) NEW_LINE for key , values in M . items ( ) : NEW_LINE INDENT if ( ( key + K ) in M ) : NEW_LINE INDENT print ( \" ( \" , key , \" , \" , key + K , \" ) \" , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 19 NEW_LINE K = 6 NEW_LINE getPrimePairs ( L , R , K ) NEW_LINE DEDENT"}
{"text": "Nombor EnneAcontahExagon | Berfungsi untuk mencari nombor enneacontahexagon nth; Kod pemacu", "code": "def EnneacontahexagonNum ( n ) : NEW_LINE INDENT return ( 94 * n * n - 92 * n ) // 2 ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( EnneacontahexagonNum ( n ) ) ; NEW_LINE"}
{"text": "Cari dua nombor komposit supaya terdapat perbezaan adalah n | Berfungsi untuk mencari dua nombor komposit; Kod pemacu", "code": "def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE find_composite_nos ( n ) ; NEW_LINE DEDENT"}
{"text": "Kira bilangan pasangan (i, j) supaya sama ada arr [i] boleh dibahagikan dengan arr [j] atau arr [j] boleh dibahagikan dengan arr [i] | Berfungsi untuk mencari bilangan pasangan yang tidak teratur; Elemen maksimum dari array; Array untuk menyimpan kekerapan setiap elemen; Menyimpan bilangan pasangan yang tidak teratur; Simpan kekerapan setiap elemen; Cari bilangan pasangan yang tidak teratur; Jika nombor j dibahagi dengan elemen ith hadir dalam array; Jika elemen ith array mempunyai kekerapan lebih daripada satu; Kod pemacu", "code": "def freqPairs ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT freq = [ 0 for i in range ( max + 1 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 * arr [ i ] , max + 1 , arr [ i ] ) : NEW_LINE INDENT if ( freq [ j ] >= 1 ) : NEW_LINE INDENT count += freq [ j ] NEW_LINE DEDENT DEDENT if ( freq [ arr [ i ] ] > 1 ) : NEW_LINE INDENT count += freq [ arr [ i ] ] - 1 NEW_LINE freq [ arr [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 4 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( freqPairs ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Cari istilah n Siri 1 + 2 + 6 + 15 + 31 + 56 + ... | Hitung istilah n siri yang diberikan; Kod pemacu", "code": "def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) // 6 NEW_LINE DEDENT N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE"}
{"text": "Program untuk mencari n | Kembali nombor n - th dalam siri yang diperbuat daripada 3 dan 5; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; Kod pemacu", "code": "def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 3 NEW_LINE arr [ 2 ] = 5 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 3 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 5 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT n = 6 NEW_LINE print ( printNthElement ( n ) ) NEW_LINE"}
{"text": "Program untuk mencari istilah n Siri 3, 6, 18, 24, ... | fungsi untuk mengira istilah siri nth; Dengan menggunakan formula di atas; Dapatkan nilai n; Hitung dan cetak istilah n", "code": "def nthTerm ( N ) : NEW_LINE INDENT return ( N * ( ( N // 2 ) + ( ( N % 2 ) * 2 ) + N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( \" Nth ▁ term ▁ for ▁ N ▁ = ▁ \" , N , \" ▁ : ▁ \" , nthTerm ( N ) ) NEW_LINE DEDENT"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | Berfungsi untuk mencetak siri; Mengira dan mencetak istilah pertama; Pengkomputeran dan percetakan yang tersisa; Cari istilah semasa menggunakan terma sebelumnya kita meningkatkan kuasa x oleh 1, kuasa pengurangan sebanyak 1 dan mengira NCI menggunakan istilah sebelumnya dengan mengalikan istilah sebelumnya dengan (n - i + 1) / i; Kod pemacu", "code": "def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) / ( i * A ) ) NEW_LINE print ( term , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE"}
{"text": "Semak jika nombor dibahagikan dengan 8 menggunakan pengendali bitwise | Program Python untuk memeriksa sama ada nombor itu boleh dibahagikan dengan 8 atau tidak menggunakan pengendali Bitwise; Fungsi untuk memeriksa nombor div oleh 8 atau tidak menggunakan pengendali bitwise; kod pemacu", "code": "import math NEW_LINE def Div_by_8 ( n ) : NEW_LINE INDENT return ( ( ( n >> 3 ) << 3 ) == n ) NEW_LINE DEDENT n = 16 NEW_LINE if ( Div_by_8 ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Fungsi untuk mengira purata nombor walaupun; mengira nombor walaupun; Simpan jumlah nombor walaupun; fungsi pemacu", "code": "def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE sm = sm + n NEW_LINE n = n - 2 NEW_LINE DEDENT return sm // count NEW_LINE DEDENT n = 16 NEW_LINE print ( averageEven ( n ) ) NEW_LINE"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Fungsi untuk mengira purata nombor walaupun; Fungsi pemacu", "code": "def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid ▁ Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 2 ) // 2 NEW_LINE DEDENT n = 16 NEW_LINE print ( averageEven ( n ) ) NEW_LINE"}
{"text": "Nombor terbesar yang membahagikan x dan co | Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; berfungsi untuk mencari pembahagi coprime terbesar; kod pembahagi", "code": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def cpFact ( x , y ) : NEW_LINE INDENT while gcd ( x , y ) != 1 : NEW_LINE INDENT x = x / gcd ( x , y ) NEW_LINE DEDENT return int ( x ) NEW_LINE DEDENT x = 15 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 14 NEW_LINE y = 28 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 7 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Program Pemandu", "code": "def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( i % 10 == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE"}
{"text": "Nombor Taxicab | Pelaksanaan Python3 untuk mencetak nombor pertama N Taxicab (2); Bermula dari 1, periksa setiap nombor jika ia adalah Taxicab sehingga Count mencapai n. ; Cuba semua pasangan yang mungkin (j, k) yang jumlah kiubnya boleh saya. ; Taxicab (2) dijumpai; Kod pemacu", "code": "import math NEW_LINE def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" ▁ \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE"}
{"text": "Nombor Komposit | Program python berasaskan kaedah sekolah yang dioptimumkan untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Program pemacu untuk menguji fungsi di atas", "code": "def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT print ( \" true \" ) if ( isComposite ( 11 ) ) else print ( \" false \" ) NEW_LINE print ( \" true \" ) if ( isComposite ( 15 ) ) else print ( \" false \" ) NEW_LINE"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; Kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Untuk mencari jumlah elemen array; Jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE"}
{"text": "Jumlah pembahagi faktorial nombor | fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Kod pemacu", "code": "def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT def div ( x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def sumFactDiv ( n ) : NEW_LINE INDENT return div ( fact ( n ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( sumFactDiv ( n ) ) NEW_LINE"}
{"text": "Jumlah pembahagi faktorial nombor | AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) '' using ; Menggunakan fungsi pembahagi untuk mengira jumlah; mengembalikan jumlah pembahagi; Kod pemacu", "code": "allPrimes = [ ] ; NEW_LINE def sieve ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT allPrimes . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def factorialDivisors ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( len ( allPrimes ) ) : NEW_LINE INDENT p = allPrimes [ i ] ; NEW_LINE exp = 0 ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT exp = exp + int ( n / p ) ; NEW_LINE p = p * allPrimes [ i ] ; NEW_LINE DEDENT result = int ( result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT print ( factorialDivisors ( 4 ) ) ; NEW_LINE"}
{"text": "Nombor Pandigital dalam pangkalan yang diberikan | Kembali benar jika n adalah pandigit lain kembali palsu. ; Panjang pemeriksaan kurang daripada asas; Melintasi setiap digit nombor. ; Jika digit adalah integer; Jika digit adalah abjad; Memeriksa array hash, jika mana -mana indeks tidak ditandakan. ; Kod pemacu", "code": "def checkPandigital ( b , n ) : NEW_LINE INDENT if ( len ( n ) < b ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT hash = [ 0 ] * b ; NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 ; NEW_LINE DEDENT elif ( ord ( n [ i ] ) - ord ( ' A ' ) <= b - 11 ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( b ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT b = 13 ; NEW_LINE n = \"1298450376ABC \" ; NEW_LINE if ( checkPandigital ( b , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT"}
{"text": "Tukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan | Berfungsi untuk mencari bilangan minimum operasi yang diberikan untuk menukar m ke n; Hanya cara yang perlu dilakukan - 1 (m - n): masa; tidak mungkin; N lebih besar dan n adalah ganjil; lakukan ' - 1' pada m (atau + 1 pada n) :; n adalah juga; lakukan ' * 2' pada m (atau n / 2 pada n) :; Kod pemacu", "code": "def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + conver ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + conver ( m , n / 2 ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum ▁ number ▁ of ▁ operations ▁ : \" , conver ( m , n ) ) NEW_LINE"}
{"text": "Biji (atau akar benih) nombor | Program python3 untuk mencari benih nombor; Kedai produk digit x dalam proddig [x]; Jika x mempunyai angka tunggal; Jika produk digit sudah dikira; Jika produk digit tidak dikira sebelum ini. ; Mencetak semua benih n; Cari semua biji menggunakan proddig []; Sekiranya tidak ada benih; Cetak biji; Kod pemacu", "code": "MAX = 10000 ; NEW_LINE prodDig = [ 0 ] * MAX ; NEW_LINE def getDigitProduct ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] ; NEW_LINE DEDENT prod = ( int ( x % 10 ) * getDigitProduct ( int ( x / 10 ) ) ) ; NEW_LINE prodDig [ x ] = prod ; NEW_LINE return prod ; NEW_LINE DEDENT def findSeed ( n ) : NEW_LINE INDENT res = [ ] ; NEW_LINE for i in range ( 1 , int ( n / 2 + 2 ) ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" NO ▁ seed ▁ exists \" ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT n = 138 ; NEW_LINE findSeed ( n ) ; NEW_LINE"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Program Python 3 untuk mencari integer yang mempunyai jumlah maksimum faktor utama dalam nombor semulajadi n pertama. ; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama. ; Mencari nombor yang mempunyai jumlah maksimum faktor utama. ; Kod pemacu", "code": "from math import sqrt NEW_LINE def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 5 ) ] NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 NEW_LINE DEDENT DEDENT arr [ i ] = 1 NEW_LINE DEDENT maxval = 0 NEW_LINE maxint = 1 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] NEW_LINE maxint = i NEW_LINE DEDENT DEDENT return maxint NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT"}
{"text": "Jumlah semua subarray | Tetapkan 1 | fungsi mengira jumlah semua sub - array; jumlah pengkomputeran subarray menggunakan formula; kembali semua jumlah subarray; Program Pemandu", "code": "def SubArraySum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum ▁ of ▁ SubArray ▁ : ▁ \" , SubArraySum ( arr , n ) ) NEW_LINE"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program Python3 untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Jika saya adalah kuasa 2; Kod pemacu", "code": "def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE"}
{"text": "Cari Pasangan Cube | Tetapkan 2 (A N ^ (1/3) Penyelesaian) | Program Python3 untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat pelbagai saiz saiz 'cuberoot; Untuk indeks i, kiub [i] akan mengandungi i ^ 3; Cari semua pasangan di atas Array Cube di atas [] yang jumlahnya sama dengan N; Kod pemacu", "code": "import math NEW_LINE def findPairs ( n ) : NEW_LINE INDENT cubeRoot = int ( math . pow ( n , 1.0 / 3.0 ) ) ; NEW_LINE DEDENT ' NEW_LINE INDENT cube = [ 0 ] * ( cubeRoot + 1 ) ; NEW_LINE for i in range ( 1 , cubeRoot + 1 ) : NEW_LINE INDENT cube [ i ] = i * i * i ; NEW_LINE DEDENT l = 1 ; NEW_LINE r = cubeRoot ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( cube [ l ] + cube [ r ] < n ) : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT elif ( cube [ l ] + cube [ r ] > n ) : NEW_LINE INDENT r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ( \" , l , \" , ▁ \" , math . floor ( r ) , \" ) \" , end = \" \" ) ; NEW_LINE print ( ) ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT DEDENT n = 20683 ; NEW_LINE findPairs ( n ) ; NEW_LINE"}
{"text": "Cari Pasangan Cube | Tetapkan 1 (A N ^ (2/3) Penyelesaian) | Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat peta kosong; Pertimbangkan semua pasangan seperti nilai kurang daripada cuberoot; Cari jumlah pasangan semasa (x, y); Jangan lakukan apa -apa jika jumlah tidak sama dengan nombor yang diberikan; Jika jumlahnya dilihat sebelum ini, kami mendapati dua pasang; Jika jumlahnya dilihat buat kali pertama; Kod pemacu", "code": "def findPairs ( n ) : NEW_LINE INDENT cubeRoot = pow ( n , 1.0 / 3.0 ) ; NEW_LINE s = { } NEW_LINE for x in range ( int ( cubeRoot ) ) : NEW_LINE INDENT for y in range ( x + 1 , int ( cubeRoot ) + 1 ) : NEW_LINE INDENT sum = x * x * x + y * y * y ; NEW_LINE if ( sum != n ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if sum in s . keys ( ) : NEW_LINE INDENT print ( \" ( \" + str ( s [ sum ] [ 0 ] ) + \" , ▁ \" + str ( s [ sum ] [ 1 ] ) + \" ) ▁ and ▁ ( \" + str ( x ) + \" , ▁ \" + str ( y ) + \" ) \" +   \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ sum ] = [ x , y ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13832 NEW_LINE findPairs ( n ) NEW_LINE DEDENT"}
{"text": "Cari perbezaan minimum antara jadual beralih dua nombor | Program Python3 untuk mencari perbezaan minimum antara dua syarat dua jadual; Fungsi utiliti untuk mencari GCD A dan B; Mengembalikan perbezaan minimum antara dua terma jadual beralih 'A' dan 'B'. 'X' adalah peralihan dalam jadual 'a' dan 'y' adalah peralihan dalam jadual 'b'. ; Hitung GCD Nd B; Kirakan perbezaan antara x dan y; Kod pemacu", "code": "import math as mt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT def findMinDiff ( a , b , x , y ) : NEW_LINE INDENT g = gcd ( a , b ) NEW_LINE diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE DEDENT a , b , x , y = 20 , 52 , 5 , 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | A O (SQRT (N)) Program Java yang mencetak semua pembahagi dalam urutan yang disusun; Kaedah untuk mencetak pembahagi; Senaraikan untuk menyimpan separuh daripada pembahagi; Semak jika pembahagi adalah sama; Jika tidak cetak kedua -duanya; Senarai ini akan dicetak secara terbalik; Kaedah Pemandu", "code": "import math NEW_LINE def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT print ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" ) NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; Berfungsi untuk mencetak pembahagi; Kod pemacu", "code": "from math import * NEW_LINE def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( int ( sqrt ( n ) ) , 0 , - 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT print ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" ) NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | kaedah untuk mencetak pembahagi; Kaedah Pemandu", "code": "def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT print \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Penyelesaian yang lebih baik (daripada naif) untuk mencari semua divisior; kaedah untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; Jika tidak cetak kedua -duanya; Kaedah Pemandu", "code": "import math NEW_LINE def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT else : NEW_LINE INDENT print i , n / i , NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT DEDENT print \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ \" NEW_LINE printDivisors ( 100 ) NEW_LINE"}
{"text": "Sieve of Atkin | Program Python 3 untuk pelaksanaan SIEVE OF ATKIN; 2 dan 3 dikenali sebagai Perdana; Memulakan array penapis dengan nilai palsu; Mark Sieve [n] adalah benar jika salah satu daripada yang berikut adalah benar: a) n = (4 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil, i. e. , terdapat bilangan pasangan yang berbeza (x, y) yang memenuhi persamaan dan n % 12 = 1 atau n % 12 = 5. b) n = (3 * x * x) + (y * y) Bahagian utama SIEVE OF ATKIN; Tandakan semua gandaan dataran sebagai bukan perdana; Cetak prima menggunakan ayak []; Kod pemacu", "code": "def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" ▁ \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" ▁ \" ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT DEDENT limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE"}
{"text": "Cari jika titik terletak di dalam bulatan | Program Python3 untuk memeriksa sama ada titik terletak di dalam bulatan atau tidak; Bandingkan jejari bulatan dengan jarak pusatnya dari titik yang diberikan; Kod pemacu", "code": "def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT x = 1 ; NEW_LINE y = 1 ; NEW_LINE circle_x = 0 ; NEW_LINE circle_y = 1 ; NEW_LINE rad = 2 ; NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( \" Inside \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Outside \" ) ; NEW_LINE DEDENT"}
{"text": "Program untuk memeriksa sama ada nombor tertentu bernasib baik (semua digit adalah berbeza) | Program Python untuk memeriksa sama ada nombor tertentu bernasib baik; Fungsi ini kembali benar jika n bernasib baik; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Program pemacu untuk menguji fungsi di atas.", "code": "import math NEW_LINE def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , \" ▁ is ▁ Lucky ▁ \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , \" ▁ is ▁ not ▁ Lucky ▁ \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Cetak kotak pertama N Nombor Semulajadi tanpa menggunakan *, / dan | Program Python3 untuk mencetak dataran pertama 'n' Nombor semulajadi menggunakan *, / dan -; Memulakan 'persegi' dan nombor ganjil pertama; Mengira dan mencetak kotak; Cetak dataran; Kemas kini 'Square' dan 'Odd; Kod pemacu", "code": "def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT n = 5 ; NEW_LINE printSquares ( n ) NEW_LINE"}
{"text": "Tulis program untuk membalikkan digit nombor | Program Python 3 untuk membalikkan digit nombor; Fungsi rekursif untuk membalikkan digit NUM; Kod pemacu", "code": "rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num / 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT num = 4562 NEW_LINE print ( \" Reverse ▁ of ▁ no . ▁ is ▁ \" , reversDigits ( num ) ) NEW_LINE"}
{"text": "Cari nombor sedemikian rupa sehingga maksimum dalam array adalah minimum mungkin selepas xor | Fungsi rekursif yang mencari nilai minimum selepas eksklusif - atau; Keadaan jika saiz ref adalah sifar atau bit adalah negatif maka kembali 0; Keadaan jika bit semasa dimatikan kemudian tolak nilai semasa dalam vektor curr_off; Keadaan jika bit semasa berada di kemudian tolak nilai semasa dalam vektor curr_on; Keadaan jika curr_off kosong maka hubungi fungsi rekursif pada vektor curr_on; Keadaan jika curr_on kosong maka hubungi fungsi rekursif pada vektor curr_off; Kembalikan minimum curr_off dan curr_on dan tambah kuasa 2 bit semasa; Fungsi yang mencetak nilai minimum selepas eksklusif - atau; Menolak nilai dalam vektor; Jawapan percetakan; Kod pemacu", "code": "def RecursiveFunction ( ref , bit ) : NEW_LINE INDENT if ( len ( ref ) == 0 or bit < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT curr_on = [ ] NEW_LINE curr_off = [ ] NEW_LINE for i in range ( len ( ref ) ) : NEW_LINE INDENT if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) : NEW_LINE INDENT curr_off . append ( ref [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT curr_on . append ( ref [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( curr_off ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_on , bit - 1 ) NEW_LINE DEDENT if ( len ( curr_on ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_off , bit - 1 ) NEW_LINE DEDENT return ( min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ) NEW_LINE DEDENT def PrintMinimum ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT v . append ( a [ i ] ) NEW_LINE DEDENT print ( RecursiveFunction ( v , 30 ) ) NEW_LINE DEDENT arr = [ 3 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE PrintMinimum ( arr , size ) NEW_LINE"}
{"text": "Count of Elements yang sama dengan XOR dari dua elemen berikutnya | Fungsi untuk mengembalikan kiraan elemen yang sama dengan XOR dari dua elemen berikutnya; Untuk menyimpan kiraan yang diperlukan; Untuk setiap elemen array supaya ia mempunyai sekurang -kurangnya dua elemen yang muncul selepas itu dalam array; Jika elemen semasa adalah sama dengan XOR dari dua elemen seterusnya dalam array; Kod pemacu", "code": "def cntElements ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 3 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntElements ( arr , n ) ) NEW_LINE"}
{"text": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | Berfungsi untuk mengembalikan kiraan; Hasil permulaan; Pilih unsur 1 triplet; Pilih elemen 2 nd triplet; Pilih 3 elemen triplet; Mengambil XOR dalam subarray pertama; Mengambil XOR dalam subarray kedua; Jika kedua -dua XOR adalah sama; Kod pemacu; Fungsi panggilan", "code": "def xor_triplet ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT xor1 = 0 ; xor2 = 0 ; NEW_LINE for x in range ( i , j ) : NEW_LINE INDENT xor1 ^= arr [ x ] ; NEW_LINE DEDENT for x in range ( j , k + 1 ) : NEW_LINE INDENT xor2 ^= arr [ x ] ; NEW_LINE DEDENT if ( xor1 == xor2 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( xor_triplet ( arr , n ) ) ; NEW_LINE DEDENT"}
{"text": "Cari bilangan sepasang nod yang ideal di pokok tertentu | Pelaksanaan Python3 pendekatan; Senarai Adjacency; Bit: Bit Array I dan J memulakan dan menamatkan indeks termasuk; bit: array bit n: saiz array bit i adalah indeks yang akan dikemas kini diff adalah (new_val - old_val); Fungsi DFS untuk mencari pasangan yang ideal; Fungsi untuk inisialisasi; Berfungsi untuk menambah kelebihan; Berfungsi untuk mencari bilangan pasangan yang ideal; Cari akar pokok; Kod pemacu; Tambah tepi; Panggilan fungsi", "code": "N = 100005 NEW_LINE Ideal_pair = 0 NEW_LINE al = [ [ ] for i in range ( 100005 ) ] NEW_LINE bit = [ 0 for i in range ( N ) ] NEW_LINE root_node = [ 0 for i in range ( N ) ] NEW_LINE def bit_q ( i , j ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( j > 0 ) : NEW_LINE INDENT sum += bit [ j ] NEW_LINE j -= ( j & ( j * - 1 ) ) NEW_LINE DEDENT i -= 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum -= bit [ i ] NEW_LINE i -= ( i & ( i * - 1 ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def bit_up ( i , diff ) : NEW_LINE INDENT while ( i <= n ) : NEW_LINE INDENT bit [ i ] += diff NEW_LINE i += i & - i NEW_LINE DEDENT DEDENT def dfs ( node , x ) : NEW_LINE INDENT Ideal_pair = x NEW_LINE Ideal_pair += bit_q ( max ( 1 , node - k ) , min ( n , node + k ) ) NEW_LINE bit_up ( node , 1 ) NEW_LINE for i in range ( len ( al [ node ] ) ) : NEW_LINE INDENT Ideal_pair = dfs ( al [ node ] [ i ] , Ideal_pair ) NEW_LINE DEDENT bit_up ( node , - 1 ) NEW_LINE return Ideal_pair NEW_LINE DEDENT def initialise ( ) : NEW_LINE INDENT Ideal_pair = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT root_node [ i ] = True NEW_LINE bit [ i ] = 0 NEW_LINE DEDENT DEDENT def Add_Edge ( x , y ) : NEW_LINE INDENT al [ x ] . append ( y ) NEW_LINE root_node [ y ] = False NEW_LINE DEDENT def Idealpairs ( ) : NEW_LINE INDENT r = - 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( root_node [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT Ideal_pair = dfs ( r , 0 ) NEW_LINE return Ideal_pair NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE initialise ( ) NEW_LINE Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 3 , 4 ) NEW_LINE Add_Edge ( 3 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE print ( Idealpairs ( ) ) NEW_LINE DEDENT"}
{"text": "Cetak bitwise dan set nombor n | berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu", "code": "def printSubsets ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( i != 0 ) : NEW_LINE INDENT print ( i , end = \" ▁ \" ) NEW_LINE i = ( i - 1 ) & n NEW_LINE DEDENT print ( \"0\" ) NEW_LINE DEDENT n = 9 NEW_LINE printSubsets ( n ) NEW_LINE"}
{"text": "Semak jika nombor dibahagikan dengan 17 menggunakan pengendali bitwise | fungsi untuk memeriksa secara rekursif jika nombor itu boleh dibahagikan dengan 17 atau tidak; jika n = 0 atau n = 17 maka ya; jika n kurang dari 17, tidak boleh dibahagikan dengan 17; mengurangkan nombor mengikut lantai (n / 16) - n % 16; kod pemacu untuk memeriksa fungsi di atas", "code": "def isDivisibleby17 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 17 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 17 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) NEW_LINE DEDENT n = 35 NEW_LINE if ( isDivisibleby17 ( n ) ) : NEW_LINE INDENT print ( n , \" is ▁ divisible ▁ by ▁ 17\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is ▁ not ▁ divisible ▁ by ▁ 17\" ) NEW_LINE DEDENT"}
{"text": "Nombor terbesar dengan perwakilan binari ialah M 1 dan M | Program Python3 untuk mencari nombor terbesar yang lebih kecil daripada sama dengan N dengan set bit M - 1 0 bit. ; Mengembalikan nombor terbesar dengan bit set M kemudian m - 1 0 bit. ; Mulakan dengan 2 bit. ; Jawapan awal adalah 1 yang memenuhi syarat yang diberikan; Semak semua nombor; mengira nombor; jika kurang kemudian n; kenaikan m untuk mendapatkan nombor seterusnya; Kod pemacu", "code": "import math NEW_LINE def answer ( n ) : NEW_LINE INDENT m = 2 ; NEW_LINE ans = 1 ; NEW_LINE r = 1 ; NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT m = m + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT print ( answer ( 7 ) ) ; NEW_LINE"}
{"text": "Cari bit set yang paling ketara | Program Python3 mudah untuk mencari nombor MSB untuk diberikan n. ; Kod pemacu", "code": "def setBitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT msb = 0 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = int ( n / 2 ) ; NEW_LINE msb += 1 ; NEW_LINE DEDENT return ( 1 << msb ) ; NEW_LINE DEDENT n = 0 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE"}
{"text": "Cari bit set yang paling ketara | Program Python untuk mencari nombor MSB untuk diberikan n. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Kenaikan n oleh 1 supaya hanya ada satu set bit yang hanya sebelum MSB asal. n kini menjadi 1000000000; Kembalikan MSB asal selepas beralih. n kini menjadi 100000000; Kod pemacu", "code": "def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod Python 3 untuk mengira sifar trailing dalam perwakilan binari nombor; Kod pemacu", "code": "def countTrailingZero ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( x & 1 ) == 0 ) : NEW_LINE INDENT x = x >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( countTrailingZero ( 11 ) ) NEW_LINE DEDENT"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod Python3 untuk mengira sifar trailing dalam perwakilan binari nombor; Peta sedikit nilai mod 37 ke kedudukannya; Hanya perbezaan antara (x dan - x) ialah nilai magnitud yang ditandatangani (leftmostbit) nombor negatif yang ditandatangani adalah 1; Kod pemacu", "code": "def countTrailingZero ( x ) : NEW_LINE INDENT lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] NEW_LINE return lookup [ ( - x & x ) % 37 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( countTrailingZero ( 48 ) ) NEW_LINE DEDENT"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program Python untuk menilai Ceil (7 n / 8) tanpa menggunakan * dan /; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<<; Program pemacu untuk menguji fungsi di atas", "code": "def multiplyBySevenByEight ( n ) : NEW_LINE ' NEW_LINE INDENT return ( n - ( n >> 3 ) ) NEW_LINE DEDENT n = 9 NEW_LINE print ( multiplyBySevenByEight ( n ) ) NEW_LINE"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program Python3 untuk menilai 7 n / 8 tanpa menggunakan * dan /; Langkah 1) Pertama kali ganda nombor dengan 7 i. e. 7 n = (n << 3) - n Langkah 2) Bahagikan hasil sebanyak 8; Kod pemacu", "code": "def multiplyBySevenByEight ( n ) : NEW_LINE INDENT return ( ( n << 3 ) - n ) >> 3 ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( multiplyBySevenByEight ( n ) ) ; NEW_LINE"}
{"text": "Set nombor palindrome terpanjang dari julat [l, r] dengan kebanyakan perbezaan k antara maksimum dan minimum | Berfungsi untuk mencari saiz maksimum kumpulan nombor palindrome yang mempunyai perbezaan antara elemen maksimum dan minimum paling banyak k; Menyimpan semua nombor palindromik dalam julat [l, r]; Melintasi julat [l, r]; Jika saya adalah palindrome; Tambah nombor dalam senarai; Kedai kiraan nombor palindromik maksimum; Melelehkan setiap elemen dalam senarai; Kirakan indeks paling kanan dalam senarai <elemen semasa + k; Semak jika terdapat indeks paling kanan dari indeks semasa; Mengembalikan kiraan; Berfungsi untuk mencari indeks paling kanan nombor yang diberikan; Simpan indeks paling kanan; Hitung pertengahan; Jika diberi nombor <= num; Berikan Ans = Mid; Mengemas kini rendah; Mengemas kini tinggi; kembali Ans; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah palindrome atau tidak; Menjana terbalik nombor yang diberikan; Jika n adalah palindrome; Kod pemacu", "code": "def countNumbers ( L , R , K ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT list . append ( i ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( len ( list ) ) : NEW_LINE INDENT right_index = search ( list , list [ i ] + K - 1 ) NEW_LINE if ( right_index != - 1 ) : NEW_LINE INDENT count = max ( count , right_index - i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def search ( list , num ) : NEW_LINE INDENT low , high = 0 , len ( list ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( list [ mid ] <= num ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rev = rev * 10 + n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return rev == temp NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 98 , 112 NEW_LINE K = 13 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan jumlah yang mungkin dengan menolak nilai yang sama dari semua elemen subarray array yang diberikan | Berfungsi untuk mencari jumlah maksimum dengan menolak nilai yang sama dari semua elemen subarray; Kedai elemen yang lebih kecil sebelumnya; Kedai elemen yang lebih kecil seterusnya; Mengira sumbangan setiap elemen; Jawapan kembali; Berfungsi untuk menjana elemen yang lebih kecil sebelumnya untuk setiap elemen array; Unsur pertama tidak mempunyai lebih kecil sebelumnya; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku sebelum ini; Tolak indeks pertama; Pop semua elemen sehingga elemen sebelumnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil sebelumnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk menjana elemen yang lebih kecil seterusnya untuk setiap elemen array; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku seterusnya; Melangkah dalam urutan terbalik untuk mengira lebih kecil seterusnya; Pop semua elemen sehingga elemen seterusnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil seterusnya; Tolak indeks elemen semasa; Mengembalikan array; Kod pemacu", "code": "def findMaximumSum ( a , n ) : NEW_LINE INDENT prev_smaller = findPrevious ( a , n ) NEW_LINE next_smaller = findNext ( a , n ) NEW_LINE max_value = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) NEW_LINE DEDENT return max_value NEW_LINE DEDENT def findPrevious ( a , n ) : NEW_LINE INDENT ps = [ 0 ] * n NEW_LINE ps [ 0 ] = - 1 NEW_LINE stack = [ ] NEW_LINE stack . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT ps [ i ] = stack [ - 1 ] if len ( stack ) > 0 else - 1 NEW_LINE stack . append ( i ) NEW_LINE DEDENT return ps NEW_LINE DEDENT def findNext ( a , n ) : NEW_LINE INDENT ns = [ 0 ] * n NEW_LINE ns [ n - 1 ] = n NEW_LINE stack = [ ] NEW_LINE stack . append ( n - 1 ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT while ( len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT ns [ i ] = stack [ - 1 ] if len ( stack ) > 0 else n NEW_LINE stack . append ( i ) NEW_LINE DEDENT return ns NEW_LINE DEDENT n = 3 NEW_LINE a = [ 80 , 48 , 82 ] NEW_LINE print ( findMaximumSum ( a , n ) ) NEW_LINE"}
{"text": "Semak jika rentetan yang diberikan disalurkan substring rentetan lain | '' Fungsi ini kembali benar jika kandungan arr1 [] dan arr2 [] sama, jika tidak palsu. ; Fungsi ini mencari semua permutasi pat [] dalam txt []; Countp []: Simpan kiraan semua aksara corak counttw []: kiraan kiraan tetingkap semasa teks; Melintasi watak corak yang tersisa; Bandingkan tuduhan tetingkap semasa teks dengan tuduhan corak []; Tambah aksara semasa ke tetingkap semasa; Keluarkan watak pertama tetingkap sebelumnya; Periksa tetingkap terakhir dalam teks; Kod pemacu", "code": "MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT global MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 for i in range ( MAX ) ] NEW_LINE countTW = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if ( compare ( countP , countTW ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i - M ] ) ] -= 1 NEW_LINE DEDENT if ( compare ( countP , countTW ) ) : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT DEDENT txt = \" BACDGABCDA \" NEW_LINE pat = \" ABCD \" NEW_LINE if ( search ( pat , txt ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan median array yang diberikan selepas menambahkan elemen K ke array yang sama | Berfungsi untuk mengembalikan median yang dimaksimumkan; Susun array; Jika saiznya juga; Jika saiz ganjil; Kod pemacu", "code": "def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( getMaxMedian ( arr , n , k ) ) NEW_LINE DEDENT"}
{"text": "Susun 3 Integer Tanpa Menggunakan Keadaan atau Menggunakan Hanya Maksimum () Fungsi | Program Python3 untuk mencetak tiga nombor dalam urutan yang disusun menggunakan fungsi max; Cari elemen maksimum; Cari elemen minimum; Kod pemacu", "code": "def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , \" ▁ \" , get_mid , \" ▁ \" , get_max ) NEW_LINE DEDENT a , b , c = 4 , 1 , 9 NEW_LINE printSorted ( a , b , c ) NEW_LINE"}
{"text": "Jenis penyisipan binari | pelaksanaan berulang; Berfungsi untuk menyusun array [] saiz 'n; Cari lokasi di mana dipilih haruslah inseretd; Gerakkan semua elemen selepas lokasi untuk mewujudkan ruang; Kod pemacu", "code": "def binarySearch ( a , item , low , high ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( item == a [ mid ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT elif ( item > a [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT ' NEW_LINE def insertionSort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = i - 1 NEW_LINE selected = a [ i ] NEW_LINE loc = binarySearch ( a , selected , 0 , j ) NEW_LINE while ( j >= loc ) : NEW_LINE INDENT a [ j + 1 ] = a [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT a [ j + 1 ] = selected NEW_LINE DEDENT DEDENT a = [ 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 ] NEW_LINE n = len ( a ) NEW_LINE insertionSort ( a , n ) NEW_LINE print ( \" Sorted ▁ array : ▁ \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT"}
{"text": "SENARAI SENSI | Fungsi untuk melakukan penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Kod pemacu untuk diuji di atas", "code": "def insertionSort ( arr ) : NEW_LINE INDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE j = i - 1 NEW_LINE while j >= 0 and key < arr [ j ] : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE insertionSort ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( \" % ▁ d \" % arr [ i ] ) NEW_LINE DEDENT"}
{"text": "Count Permutasi yang berbeza dari rentetan yang diperoleh dengan menukar hanya aksara yang tidak sama rata | Fungsi untuk mengira jumlah bilangan permutasi yang sah; Mewujudkan kiraan yang sama dengan jumlah aksara yang hadir dan ANS yang akan menyimpan bilangan permutasi yang unik; Menyimpan kekerapan setiap watak yang ada dalam rentetan; Menambah kiraan aksara dengan tidak termasuk aksara sama dengan char semasa; Kurangkan kekerapan aksara semasa dan dikira sebanyak 1, supaya ia tidak dapat mengganggu pengiraan unsur -unsur yang sama ada di sebelah kanannya. ; Kembali Ans + 1 (kerana rentetan yang diberikan juga merupakan permutasi yang unik); Kod pemacu", "code": "def validPermutations ( str ) : NEW_LINE INDENT m = { } NEW_LINE count = len ( str ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] in m ) : NEW_LINE INDENT m [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT ans += count - m [ str [ i ] ] NEW_LINE m [ str [ i ] ] -= 1 NEW_LINE count -= 1 NEW_LINE DEDENT return ans + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" sstt \" NEW_LINE print ( validPermutations ( str ) ) NEW_LINE DEDENT"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu", "code": "def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( \" Number ▁ of ▁ Paths \" , countPaths ( n , m ) ) NEW_LINE"}
{"text": "Perubahan duit syiling | DP | Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program pemacu untuk menguji fungsi di atas", "code": "def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE print ( count ( arr , m , 4 ) ) NEW_LINE"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf besar; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . upper ( ) ; NEW_LINE str2 = str2 . upper ( ) ; NEW_LINE x = str1 == str2 ; NEW_LINE return x ; NEW_LINE DEDENT def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Same \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" Geeks \" ; NEW_LINE str2 = \" geeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = \" Geek \" ; NEW_LINE str2 = \" geeksforgeeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT"}
{"text": "Gantikan setiap urutan konsonan dengan panjangnya dalam rentetan yang diberikan | Berfungsi untuk mengembalikan rentetan yang ditukar selepas menggantikan setiap urutan konsonan dengan panjangnya; Untuk menyimpan rentetan yang dihasilkan; Memeriksa setiap watak untuk urutan konsonan; Hitung panjang urutan konsonan; Tambah panjang dalam rentetan; Tambah vokal; Semak urutan konsonan terakhir dalam rentetan; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "def replaceConsonants ( string ) : NEW_LINE INDENT res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE while ( i < len ( string ) ) : NEW_LINE INDENT if ( string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' o ' and string [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT res += string [ i ] ; NEW_LINE i += 1 NEW_LINE count = 0 ; NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdeiop \" ; NEW_LINE print ( replaceConsonants ( string ) ) ; NEW_LINE DEDENT"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan dtring; untuk setiap substring; substring saiz k; mengira bilangan vokal dan konsonan; tambah produk untuk menjawab; Kod pemacu", "code": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = \" \" NEW_LINE for l in range ( n - k + 1 ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE for r in range ( l , l + k ) : NEW_LINE INDENT if ( isVowel ( s [ r ] ) == True ) : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT DEDENT ans += ( str ) ( countVowels * countConsonants ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hello \" NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Pelaksanaan Python3 yang cekap dari pendekatan di atas; Kami memisahkan input berdasarkan ruang (s) +: ungkapan biasa ini akan mengendalikan senario di mana kami mempunyai kata -kata yang dipisahkan oleh pelbagai ruang; Charat (0) hanya akan memilih watak pertama dari rentetan dan tambahan ke penampan; Kod pemacu", "code": "charBuffer = [ ] NEW_LINE def processWords ( input ) : NEW_LINE INDENT s = input . split ( \" ▁ \" ) NEW_LINE for values in s : NEW_LINE INDENT charBuffer . append ( values [ 0 ] ) NEW_LINE DEDENT return charBuffer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( * processWords ( input ) , sep = \" \" ) NEW_LINE DEDENT"}
{"text": "Menjana semua rentetan binari tanpa berturut -turut 1 's | Fungsi utiliti menjana semua rentetan tanpa berturut -turut 1 'sof saiz k; cetak rentetan binari tanpa berturut -turut 1 's; menamatkan rentetan binari; Jika watak sebelumnya adalah '1' maka kami hanya meletakkan 0 pada akhir rentetan contoh str = \"01\" maka rentetan baru menjadi \"000\"; Jika watak sebelumnya adalah '0' daripada kami meletakkan kedua -dua '1' dan '0' pada akhir rentetan contoh str = \"00\" kemudian rentetan baru \"001\" dan \"000\"; fungsi menjana semua rentetan binari tanpa berturut -turut 1; Kes asas; Satu demi satu kedai setiap rentetan panjang binari k; Menjana semua rentetan binari bermula dengan '0; Menjana semua rentetan binari bermula dengan '1; Kod pemacu", "code": "def generateAllStringsUtil ( K , str , n ) : NEW_LINE INDENT if ( n == K ) : NEW_LINE INDENT print ( * str [ : n ] , sep = \" \" , end = \" ▁ \" ) NEW_LINE return NEW_LINE DEDENT if ( str [ n - 1 ] == '1' ) : NEW_LINE INDENT str [ n ] = '0' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE DEDENT if ( str [ n - 1 ] == '0' ) : NEW_LINE INDENT str [ n ] = '0' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE str [ n ] = '1' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE DEDENT DEDENT def generateAllStrings ( K ) : NEW_LINE INDENT if ( K <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT str = [ 0 ] * K NEW_LINE DEDENT ' NEW_LINE INDENT str [ 0 ] = '0' NEW_LINE generateAllStringsUtil ( K , str , 1 ) NEW_LINE DEDENT ' NEW_LINE INDENT str [ 0 ] = '1' NEW_LINE generateAllStringsUtil ( K , str , 1 ) NEW_LINE DEDENT K = 3 NEW_LINE generateAllStrings ( K ) NEW_LINE"}
{"text": "Silinder bulat kanan terbesar dalam kiub | Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "def findVolume ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE h = a NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 5 NEW_LINE print ( findVolume ( a ) ) NEW_LINE DEDENT"}
{"text": "Program untuk jumlah piramid | Berfungsi untuk mengira jumlah piramid segi tiga; Fungsi untuk mengira jumlah piramid persegi; Fungsi untuk mengira jumlah piramid pentagonal; Fungsi untuk mengira jumlah piramid heksagon; Kod pemacu", "code": "def volumeTriangular ( a , b , h ) : NEW_LINE INDENT return ( 0.1666 ) * a * b * h NEW_LINE DEDENT def volumeSquare ( b , h ) : NEW_LINE INDENT return ( 0.33 ) * b * b * h NEW_LINE DEDENT def volumePentagonal ( a , b , h ) : NEW_LINE INDENT return ( 0.83 ) * a * b * h NEW_LINE DEDENT def volumeHexagonal ( a , b , h ) : NEW_LINE INDENT return a * b * h NEW_LINE DEDENT b = float ( 4 ) NEW_LINE h = float ( 9 ) NEW_LINE a = float ( 4 ) NEW_LINE print ( \" Volume ▁ of ▁ triangular ▁ base ▁ pyramid ▁ is ▁ \" , volumeTriangular ( a , b , h ) ) NEW_LINE print ( \" Volume ▁ of ▁ square ▁ base ▁ pyramid ▁ is ▁ \" , volumeSquare ( b , h ) ) NEW_LINE print ( \" Volume ▁ of ▁ pentagonal ▁ base ▁ pyramid ▁ is ▁ \" , volumePentagonal ( a , b , h ) ) NEW_LINE print ( \" Volume ▁ of ▁ Hexagonal ▁ base ▁ pyramid ▁ is ▁ \" , volumeHexagonal ( a , b , h ) ) NEW_LINE"}
{"text": "Program untuk mencari kawasan trapezoid | Fungsi untuk kawasan tersebut; Kod pemacu", "code": "def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT base1 = 8 ; base2 = 10 ; height = 6 NEW_LINE area = Area ( base1 , base2 , height ) NEW_LINE print ( \" Area ▁ is : \" , area ) NEW_LINE"}
{"text": "Cari bilangan pepenjuru dalam polygon cembung N sisi | '' Program Python3 untuk mencari bilangan pepenjuru dalam poligon cembung n; '' Kod pemacu untuk menguji fungsi di atas", "code": "def numberOfDiagonals ( n ) : NEW_LINE INDENT return n * ( n - 3 ) / 2 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" ▁ sided ▁ convex ▁ polygon ▁ have ▁ \" ) NEW_LINE print ( numberOfDiagonals ( n ) , \" ▁ diagonals \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"}
{"text": "Kawasan segi empat tepat terbesar tanpa titik tertentu | Berfungsi untuk mencari kawasan maksimum supaya ia tidak mengandungi sebarang lubang; Kawasan untuk semua kedudukan yang mungkin dipotong; Cari kawasan maksimum di antara segi empat tepat di atas; Kod pemacu; Panggilan fungsi", "code": "def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE maximumArea ( l , b , x , y ) NEW_LINE"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Simpan kos minimum yang diperlukan; Buat kamus untuk menyimpan kos maksimum penyingkiran watak; Buat kamus untuk menyimpan jumlah kos penghapusan watak; Melintasi rentetan, s; Jejaki kos maksimum setiap watak; Mengemas kini kos penghapusan maksimum; Jejaki jumlah kos setiap watak; Mengemas kini jumlah kos penghapusan; Melintasi semua watak yang unik; Simpan watak kos maksimum dan padamkan selebihnya; Kembalikan jawapannya; Diberikan rentetan; Diberikan pelbagai kos; Panggilan fungsi", "code": "def delCost ( s , cost ) : NEW_LINE INDENT ans = 0 NEW_LINE forMax = { } NEW_LINE forTot = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in forMax : NEW_LINE INDENT forMax [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) NEW_LINE DEDENT if s [ i ] not in forTot : NEW_LINE INDENT forTot [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT forTot [ s [ i ] ] += cost [ i ] NEW_LINE DEDENT DEDENT for i in forMax : NEW_LINE INDENT ans += forTot [ i ] - forMax [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT string = \" AAABBB \" NEW_LINE cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( delCost ( string , cost ) ) NEW_LINE"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Program Python3 untuk pendekatan di atas; Kedai pembahagi untuk semua nombor dalam pembahagi vektor; Saya adalah pembahagi dan j adalah pelbagai; Fungsi untuk membandingkan kedekatan sasaran yang diberikan; Berfungsi untuk mencari elemen yang paling dekat dengan sasaran dalam vektor pembahagi; Kes sudut; Melakukan carian binari; Semak sama ada sasaran kurang daripada elemen array kemudian cari di separuh kiri; Semak sama ada sasaran lebih besar daripada sebelumnya hingga pertengahan, kembali paling dekat dengan dua; Ulangi separuh kiri; Semak sama ada sasaran lebih besar daripada pertengahan; Kemas kini i; Hanya elemen tunggal yang tersisa selepas carian; Berfungsi untuk mencetak pembahagi n paling dekat dengan x; Fungsi panggilan untuk mengira dan menyimpan pembahagi semua nombor dalam vektor; Menyimpan nilai terdekat untuk sasaran; Cetak jawapannya; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "MAX = 10000 NEW_LINE divisors = [ [ ] for i in range ( MAX + 1 ) ] NEW_LINE def computeDivisors ( ) : NEW_LINE INDENT global divisors NEW_LINE global MAX NEW_LINE for i in range ( 1 , MAX + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 , i ) : NEW_LINE INDENT divisors [ j ] . append ( i ) NEW_LINE DEDENT DEDENT DEDENT def getClosest ( val1 , val2 , target ) : NEW_LINE INDENT if ( target - val1 >= val2 - target ) : NEW_LINE INDENT return val2 NEW_LINE DEDENT else : NEW_LINE INDENT return val1 NEW_LINE DEDENT DEDENT def findClosest ( arr , n , target ) : NEW_LINE INDENT if ( target <= arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( target >= arr [ n - 1 ] ) : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT i = 0 NEW_LINE j = n NEW_LINE mid = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT mid = ( i + j ) // 2 NEW_LINE if ( arr [ mid ] == target ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( target < arr [ mid ] ) : NEW_LINE INDENT if ( mid > 0 and target > arr [ mid - 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) NEW_LINE DEDENT j = mid NEW_LINE DEDENT else : NEW_LINE INDENT if ( mid < n - 1 and target < arr [ mid + 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) NEW_LINE DEDENT i = mid + 1 NEW_LINE DEDENT DEDENT return arr [ mid ] NEW_LINE DEDENT def printClosest ( N , X ) : NEW_LINE INDENT global divisors NEW_LINE computeDivisors ( ) NEW_LINE ans = findClosest ( divisors [ N ] , len ( divisors [ N ] ) , X ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE X = 5 NEW_LINE printClosest ( N , X ) NEW_LINE DEDENT"}
{"text": "Mengira elemen nilai yang sama diletakkan pada indeks yang sama dengan dua array yang diberikan | Fungsi untuk mengira elemen yang dipadankan maksimum dari array A [] dan B []; Kedai kedudukan unsur -unsur array a [] dalam array b []; Jejaki perbezaan antara indeks; Melintasi array a []; Melintasi array b []; Jika perbezaan negatif, tambahkan n kepadanya; Jejaki bilangan peralihan yang diperlukan untuk meletakkan elemen pada indeks yang sama; Mengembalikan perlawanan maksimum; Kod pemacu; Mengembalikan kiraan elemen yang dipadankan", "code": "def maxMatch ( A , B ) : NEW_LINE INDENT Aindex = { } NEW_LINE diff = { } NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT Aindex [ A [ i ] ] = i NEW_LINE DEDENT for i in range ( len ( B ) ) : NEW_LINE INDENT if i - Aindex [ B [ i ] ] < 0 : NEW_LINE INDENT if len ( A ) + i - Aindex [ B [ i ] ] not in diff : NEW_LINE INDENT diff [ len ( A ) + i - Aindex [ B [ i ] ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff [ len ( A ) + i - Aindex [ B [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i - Aindex [ B [ i ] ] not in diff : NEW_LINE INDENT diff [ i - Aindex [ B [ i ] ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff [ i - Aindex [ B [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( diff . values ( ) ) NEW_LINE DEDENT A = [ 5 , 3 , 7 , 9 , 8 ] NEW_LINE B = [ 8 , 7 , 3 , 5 , 9 ] NEW_LINE print ( maxMatch ( A , B ) ) NEW_LINE"}
{"text": "Semak jika diberi penyelesaian Sudoku adalah sah atau tidak | Berfungsi untuk memeriksa sama ada semua elemen lembaga [] [] nilai kedai array dalam julat [1, 9]; Traverse Board [] [] array; Semak jika papan [i] [j] terletak dalam julat; Fungsi untuk memeriksa sama ada penyelesaian teka -teki sudoku sah atau tidak; Semak sama ada semua elemen papan [] [] menyimpan nilai dalam julat [1, 9]; Kedai nilai unik dari 1 hingga n; Melintasi setiap baris array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap lajur baris semasa; Menyimpan nilai papan [i] [j]; Semak jika baris semasa menyimpan nilai pendua; Melintasi setiap lajur array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap baris lajur semasa; Menyimpan nilai papan [j] [i]; Semak jika lajur semasa menyimpan nilai pendua; Melintasi setiap blok saiz 3 * 3 di papan [] [] array; J menyimpan lajur pertama setiap 3 * 3 blok; Memulakan array unik [] kepada palsu; Melintasi blok semasa; Kedai baris nombor blok semasa; Menyimpan nombor lajur blok semasa; Menyimpan nilai papan [x] [y]; Semak jika blok semasa menyimpan nilai pendua; Jika semua keadaan berpuas hati; Kod pemacu", "code": "def isinRange ( board ) : NEW_LINE INDENT N = 9 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE if ( ( board [ i ] [ j ] <= 0 ) or ( board [ i ] [ j ] > 9 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isValidSudoku ( board ) : NEW_LINE INDENT N = 9 NEW_LINE if ( isinRange ( board ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for m in range ( 0 , N + 1 ) : NEW_LINE unique [ m ] = False NEW_LINE for j in range ( 0 , N ) : NEW_LINE Z = board [ i ] [ j ] NEW_LINE if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT for m in range ( 0 , N + 1 ) : NEW_LINE unique [ m ] = False NEW_LINE for j in range ( 0 , N ) : NEW_LINE Z = board [ j ] [ i ] NEW_LINE if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE DEDENT for i in range ( 0 , N - 2 , 3 ) : NEW_LINE INDENT for j in range ( 0 , N - 2 , 3 ) : NEW_LINE for m in range ( 0 , N + 1 ) : NEW_LINE INDENT unique [ m ] = False NEW_LINE DEDENT for k in range ( 0 , 3 ) : NEW_LINE INDENT for l in range ( 0 , 3 ) : NEW_LINE X = i + k NEW_LINE Y = j + l NEW_LINE Z = board [ X ] [ Y ] NEW_LINE if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT board = [ [ 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 ] , [ 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 ] , [ 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 ] , [ 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 ] , [ 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 ] , [ 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 ] , [ 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 ] , [ 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 ] , [ 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 ] ] NEW_LINE if ( isValidSudoku ( board ) ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Valid \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Subarray panjang k yang penggabungannya membentuk palindrome | Fungsi untuk memeriksa sama ada nombor adalah palindrome atau tidak di sini saya adalah indeks permulaan dan j adalah indeks terakhir subarray; Jika integer di saya tidak sama dengan j maka subarray bukan palindrome; Jika tidak; Semua [i] adalah sama dengan [j] maka subarray adalah palindrome; Berfungsi untuk mencari subarray yang penggabungannya membentuk palindrome dan mengembalikan indeks permulaannya; Melangkah ke atas subarray panjang k dan memeriksa jika subarray itu adalah palindrome; Jika tiada subarray adalah palindrome; Kod pemacu", "code": "def palindrome ( a , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( a [ i ] != a [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSubArray ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if ( palindrome ( arr , i , i + k - 1 ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 1 , 3 ] NEW_LINE k = 4 NEW_LINE ans = findSubArray ( arr , k ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( ans , ans + k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Semak sama ada urutan laluan melawat sebarang koordinat dua kali atau tidak | Berfungsi untuk memeriksa sama ada lelaki itu melintasi koordinat sebelumnya atau tidak; Menyimpan kiraan puncak silang; Kedai (x, y) koordinat; Koordinat untuk asal; Melangkah ke atas rentetan; Keadaan kepada kenaikan x atau y co - masing -masing; Semak jika (x, y) sudah dilawati; Cetak hasilnya; Diberikan rentetan; Panggilan fungsi", "code": "def isCrossed ( path ) : NEW_LINE INDENT if ( len ( path ) == 0 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT ans = bool ( False ) NEW_LINE Set = set ( ) NEW_LINE x , y = 0 , 0 NEW_LINE Set . add ( ( x , y ) ) NEW_LINE for i in range ( len ( path ) ) : NEW_LINE INDENT if ( path [ i ] == ' N ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y + 1 NEW_LINE DEDENT if ( path [ i ] == ' S ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y - 1 NEW_LINE DEDENT if ( path [ i ] == ' E ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x + 1 NEW_LINE DEDENT if ( path [ i ] == ' W ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x - 1 NEW_LINE DEDENT if ( x , y ) in Set : NEW_LINE INDENT ans = bool ( True ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT print ( \" Crossed \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Crossed \" ) NEW_LINE DEDENT DEDENT path = \" NESW \" NEW_LINE isCrossed ( path ) NEW_LINE"}
{"text": "Lebar maksimum n | Program Python3 untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari lebar maksimum. dia pokok menggunakan perintah lever traversal; Simpan tepi pokok; Menyimpan lebar maksimum pokok; Menyimpan nod setiap peringkat; Masukkan nod akar; Melakukan perintah level traversal di atas pokok; Menyimpan saiz barisan; Kemas kini lebar maksimum; Tolak nod tahap seterusnya dan popkan unsur -unsur tahap semasa; Dapatkan elemen dari depan barisan; Tolak semua nod peringkat seterusnya. ; Kembalikan hasilnya. ; Kod pemacu; Pokok yang dibina ialah: 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7", "code": "from collections import deque NEW_LINE def maxWidth ( N , M , cost , s ) : NEW_LINE INDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT adj [ s [ i ] [ 0 ] ] . append ( s [ i ] [ 1 ] ) NEW_LINE DEDENT result = 0 NEW_LINE q = deque ( ) NEW_LINE q . append ( 0 ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT count = len ( q ) NEW_LINE result = max ( count , result ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT temp = q . popleft ( ) NEW_LINE for i in adj [ temp ] : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT count -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE M = 10 NEW_LINE edges = [ ] NEW_LINE edges . append ( [ 0 , 1 ] ) NEW_LINE edges . append ( [ 0 , 2 ] ) NEW_LINE edges . append ( [ 0 , 3 ] ) NEW_LINE edges . append ( [ 1 , 4 ] ) NEW_LINE edges . append ( [ 1 , 5 ] ) NEW_LINE edges . append ( [ 3 , 6 ] ) NEW_LINE edges . append ( [ 4 , 7 ] ) NEW_LINE edges . append ( [ 6 , 1 ] ) NEW_LINE edges . append ( [ 6 , 8 ] ) NEW_LINE edges . append ( [ 6 , 9 ] ) NEW_LINE cost = [ 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 ] NEW_LINE print ( maxWidth ( N , M , cost , edges ) ) NEW_LINE DEDENT"}
{"text": "Kurangkan jumlah nombor perdana yang ditambah untuk membuat array bukan | Program PTHON3 untuk melaksanakan pendekatan di atas; Kedai jika indeks adalah nilai utama / bukan utama; Menyimpan perdana; Berfungsi untuk menjana semua nombor perdana; Jika elemen semasa adalah perdana; Tetapkan semua gandaannya bukan perdana; Simpan semua nombor utama; Berfungsi untuk mencari perdana terdekat dengan nombor tertentu; Memohon carian binari pada vektor prima; Jika perdana ditambah menjadikan unsur -unsur sama; Kembali ini sebagai perdana terdekat; Jika array kekal tidak menurun; Cari nombor perdana yang lebih besar; Jika tidak; Periksa sama ada perdana yang lebih kecil boleh membuat array tidak berkurangan atau tidak; Mengembalikan nombor terdekat; Berfungsi untuk mencari kos minimum; Cari semua prima; Simpan hasilnya; Melangkah ke atas array; Elemen semasa adalah kurang daripada elemen sebelumnya; Cari perdana terdekat yang membuat array tidak berkurangan; Tambah kepada kos keseluruhan; Mengemas kini elemen semasa; Mengembalikan kos minimum; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "MAX = 10000000 NEW_LINE isPrime = [ True ] * ( MAX + 1 ) NEW_LINE primes = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT global isPrime NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def prime_search ( primes , diff ) : NEW_LINE INDENT low = 0 NEW_LINE high = len ( primes ) - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( primes [ mid ] == diff ) : NEW_LINE INDENT return primes [ mid ] NEW_LINE DEDENT elif ( primes [ mid ] < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT res = primes [ mid ] NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def minCost ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT diff = arr [ i - 1 ] - arr [ i ] NEW_LINE closest_prime = prime_search ( primes , diff ) NEW_LINE res += closest_prime NEW_LINE arr [ i ] += closest_prime NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 4 , 3 ] NEW_LINE n = 5 NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | Berfungsi untuk mengembalikan cara untuk memecah rentetan ke dalam tiga bahagian dengan bilangan yang sama 0; Simpan jumlah kiraan 0 s; Kira Jumlah No. daripada 0 s watak dalam rentetan yang diberikan; Jika jumlah kiraan 0 watak tidak boleh dibahagikan dengan 3; Memulakan peta untuk menyimpan kekerapan k; Traverse String untuk mencari cara untuk memecah rentetan; Kiraan kenaikan jika 0 muncul; Hasil kenaikan jika jumlah sama dengan 2 * k dan k ada dalam peta; Masukkan jumlah dalam peta; Hasil pulangan; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "def count ( s ) : NEW_LINE INDENT cnt = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE k = cnt // 3 NEW_LINE sum = 0 NEW_LINE mp = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 2 * k and k in mp and i < len ( s ) - 1 and i > 0 ) : NEW_LINE INDENT res += mp [ k ] NEW_LINE DEDENT if sum in mp : NEW_LINE INDENT mp [ sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ sum ] = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT st = \"01010\" NEW_LINE print ( count ( st ) ) NEW_LINE DEDENT"}
{"text": "Semak jika rentetan boleh ditukar kepada yang lain dengan menukar watak bersebelahan jenis yang diberikan | Berfungsi untuk memeriksa sama ada mungkin untuk mengubah mula berakhir; Semak urutan A, B dalam kedua -dua String Str1 dan Str2; Jika kedua -dua rentetan tidak sama; Melintasi rentetan; Semak indeks A dan B; Kod pemacu; Panggilan fungsi", "code": "def canTransform ( str1 , str2 ) : NEW_LINE INDENT s1 = \" \" NEW_LINE s2 = \" \" NEW_LINE for c in str1 : NEW_LINE INDENT if ( c != ' C ' ) : NEW_LINE INDENT s1 += c NEW_LINE DEDENT DEDENT for c in str2 : NEW_LINE INDENT if ( c != ' C ' ) : NEW_LINE INDENT s2 += c NEW_LINE DEDENT DEDENT if ( s1 != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE n = len ( str1 ) NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( str1 [ i ] == ' C ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( str2 [ j ] == ' C ' ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( str1 [ i ] == ' A ' and i < j ) or ( str1 [ i ] == ' B ' and i > j ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" BCCABCBCA \" NEW_LINE str2 = \" CBACCBBAC \" NEW_LINE if ( canTransform ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Substring terpanjang yang mempunyai kiraan vokal dan konsonan yang sama | Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai bilangan vokal dan konsonan yang sama; Menjana array; Memulakan pembolehubah untuk menyimpan hasil; Menyimpan jumlah subarray; Peta untuk menyimpan indeks jumlah; Gelung melalui array; Jika jumlah adalah 0; Count vokal dan konsonan adalah sama; Mengemas kini panjang maksimum substring dalam hashmap; Simpan indeks jumlah; Mengembalikan panjang maksimum substring yang diperlukan; Kod pemacu", "code": "def maxsubstringLength ( S , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' a ' or S [ i ] == ' e ' or S [ i ] == ' i ' or S [ i ] == ' o ' or S [ i ] == ' u ' ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT maxLen = 0 NEW_LINE curr_sum = 0 NEW_LINE hash = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if ( curr_sum == 0 ) : NEW_LINE INDENT maxLen = max ( maxLen , i + 1 ) NEW_LINE DEDENT if ( curr_sum in hash . keys ( ) ) : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash [ curr_sum ] = i NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT S = \" geeksforgeeks \" NEW_LINE n = len ( S ) NEW_LINE print ( maxsubstringLength ( S , n ) ) NEW_LINE"}
{"text": "Jarak minimum dari sel tertentu ke semua sel lain dari matriks | Program Python3 untuk melaksanakan pendekatan di atas; Menyimpan arahan yang boleh diakses; Fungsi untuk mencari jarak minimum dari sel tertentu ke semua sel lain dalam matriks; Menyimpan sel -sel yang boleh diakses dari sel semasa; Masukkan pasangan (x, y); Melangkah ke barisan adalah kosong; Ekstrak pasangan; Pop mereka; Memeriksa keadaan sempadan; Jika sel tidak dikunjungi; Menetapkan jarak minimum; Masukkan jiran yang dilalui ke dalam barisan; Kod pemacu; Cetak jarak yang diperlukan", "code": "mat = [ [ 0 for x in range ( 1001 ) ] for y in range ( 1001 ) ] NEW_LINE dx = [ 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 ] NEW_LINE dy = [ 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 ] NEW_LINE def FindMinimumDistance ( ) : NEW_LINE INDENT global x , y , r , c NEW_LINE q = [ ] NEW_LINE q . append ( [ x , y ] ) NEW_LINE mat [ x ] [ y ] = 0 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT x = q [ 0 ] [ 0 ] NEW_LINE y = q [ 0 ] [ 1 ] NEW_LINE q . pop ( 0 ) NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT a = x + dx [ i ] NEW_LINE b = y + dy [ i ] NEW_LINE if ( a < 0 or a >= r or b >= c or b < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( mat [ a ] [ b ] == 0 ) : NEW_LINE INDENT mat [ a ] [ b ] = mat [ x ] [ y ] + 1 NEW_LINE q . append ( [ a , b ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT r = 5 NEW_LINE c = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE t = x NEW_LINE l = y NEW_LINE mat [ x ] [ y ] = 0 NEW_LINE FindMinimumDistance ( ) NEW_LINE mat [ t ] [ l ] = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT"}
{"text": "Kelebihan minimum yang diperlukan untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Fungsi yang mengembalikan bilangan minimum flip untuk menukar s ke dalam penyambungan sub -panjang sub -rentetan; Menyimpan hasilnya; Melangkah melalui indeks rentetan; Kedai kiraan 0 S & 1 S; ITERATE MEMBUAT K JUMPS; Kiraan 0 's; Kiraan 1 's; Tambah flip minimum untuk Indeks I; Mengembalikan bilangan minimum; Kod pemacu", "code": "def minOperations ( S , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT zero , one = 0 , 0 NEW_LINE for j in range ( i , len ( S ) , K ) : NEW_LINE INDENT if ( S [ j ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT ans += min ( zero , one ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"110100101\" NEW_LINE K = 3 NEW_LINE print ( minOperations ( s , K ) ) NEW_LINE DEDENT"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Berfungsi untuk mendapatkan elemen yang hilang; Untuk elemen maksimum dalam array; Untuk elemen minimum dalam array; Untuk XOR semua elemen; Perbezaan umum siri AP; Cari elemen maksimum dan minimum; Mengira perbezaan biasa; Kirakan XOR semua elemen; Lakukan XOR dengan siri AP sebenar yang dihasilkan X akan menjadi ANS; Mengembalikan elemen yang hilang; Kod pemacu; Diberikan array; Panggilan fungsi; Cetak elemen yang hilang", "code": "def missingElement ( arr , n ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE x = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min_ele ) : NEW_LINE INDENT min_ele = arr [ i ] NEW_LINE DEDENT DEDENT d = ( max_ele - min_ele ) // n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT x = x ^ ( min_ele + ( i * d ) ) NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 3 , 6 , 15 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE element = missingElement ( arr , n ) NEW_LINE print ( element ) NEW_LINE DEDENT"}
{"text": "Memandangkan rentetan dan integer k, cari sub sub | Berfungsi untuk mencetak sub -sub - string; Jumlah sub - rentetan mungkin; Jika k lebih besar daripada jumlah sub -rentetan; Untuk menyimpan nombor sub -rentetan bermula dengan watak rentetan; Mengira nilai -nilai; Substring [i - 1] ditambah untuk menyimpan jumlah kumulatif; Carian binari untuk mencari indeks permulaan sub -rentetan KTH; Untuk menyimpan indeks akhir sub -rentetan KTH; Cetak sub -rentetan; Kod pemacu", "code": "def Printksubstring ( str1 , n , k ) : NEW_LINE INDENT total = int ( ( n * ( n + 1 ) ) / 2 ) NEW_LINE if ( k > total ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT substring = [ 0 for i in range ( n + 1 ) ] NEW_LINE substring [ 0 ] = 0 NEW_LINE temp = n NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT substring [ i ] = substring [ i - 1 ] + temp NEW_LINE temp -= 1 NEW_LINE DEDENT l = 1 NEW_LINE h = n NEW_LINE start = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = int ( ( l + h ) / 2 ) NEW_LINE if ( substring [ m ] > k ) : NEW_LINE INDENT start = m NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( substring [ m ] < k ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = m NEW_LINE break NEW_LINE DEDENT DEDENT end = n - ( substring [ start ] - k ) NEW_LINE for i in range ( start - 1 , end ) : NEW_LINE INDENT print ( str1 [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abc \" NEW_LINE k = 4 NEW_LINE n = len ( str1 ) NEW_LINE Printksubstring ( str1 , n , k ) NEW_LINE DEDENT"}
{"text": "Titik penyisipan yang lebih rendah | Berfungsi untuk mengembalikan titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Kes asas; Pemeriksaan akhir untuk unsur -unsur yang tersisa yang <x; Kod pemacu", "code": "def LowerInsertionPoint ( arr , n , X ) : NEW_LINE INDENT if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lowerPnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lowerPnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT while ( lowerPnt < n and arr [ lowerPnt ] < X ) : NEW_LINE INDENT lowerPnt += 1 NEW_LINE DEDENT return lowerPnt NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE X = 4 NEW_LINE print ( LowerInsertionPoint ( arr , n , X ) ) NEW_LINE DEDENT"}
{"text": "Bilangan jawatan dengan alamat yang sama dalam baris utama dan lajur utama urutan | Mengembalikan kiraan kedudukan yang diperlukan; array 1D mendatar; array 1D menegak; melangkah untuk semua yang mungkin saya; Memeriksa jika J adalah integer; Memeriksa jika J terletak b / w 1 hingga n; melangkah untuk semua kemungkinan j; Memeriksa jika saya adalah integer; Memeriksa jika saya terletak b / w 1 hingga m; Kod pemacu", "code": "def getCount ( M , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( M == 1 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return M ; NEW_LINE DEDENT if ( N > M ) : NEW_LINE INDENT for i in range ( 1 , M + 1 ) : NEW_LINE INDENT numerator = N * i - N + M - i ; NEW_LINE denominator = M - 1 ; NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT j = numerator / denominator ; NEW_LINE if ( j >= 1 and j <= N ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT numerator = M * j - M + N - j ; NEW_LINE denominator = N - 1 ; NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT i = numerator / denominator ; NEW_LINE if ( i >= 1 and i <= M ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M , N = 3 , 5 ; NEW_LINE print ( getCount ( M , N ) ) ; NEW_LINE DEDENT"}
{"text": "Maksimum dalam pelbagai yang boleh membuat array lain disusun | Program python3 untuk membuat array disusun; Fungsi untuk memeriksa sama ada terdapat unsur swappable yang hadir untuk membuat array pertama disusun; WrongIdx adalah indeks elemen yang membuat array pertama tidak disusun; Cari elemen maksimum yang memenuhi syarat jiran yang disebutkan di atas; Jika res adalah benar maka swap elemen dan buat array pertama disusun; Fungsi untuk mencetak array yang disusun jika elemen ditukar. ; Kod pemacu", "code": "import sys NEW_LINE def swapElement ( arr1 , arr2 , n ) : NEW_LINE INDENT wrongIdx = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr1 [ i - 1 ] ) : NEW_LINE INDENT wrongIdx = i NEW_LINE DEDENT DEDENT maximum = - ( sys . maxsize - 1 ) NEW_LINE maxIdx = - 1 NEW_LINE res = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr2 [ i ] > maximum and arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) : NEW_LINE INDENT if ( wrongIdx + 1 <= n - 1 and arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) : NEW_LINE INDENT maximum = arr2 [ i ] NEW_LINE maxIdx = i NEW_LINE res = True NEW_LINE DEDENT DEDENT DEDENT if ( res ) : NEW_LINE INDENT ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) = ( arr2 [ maxIdx ] , arr1 [ wrongIdx ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def getSortedArray ( arr1 , arr2 , n ) : NEW_LINE INDENT if ( swapElement ( arr1 , arr2 , n ) ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Not ▁ Possible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 1 , 3 , 7 , 4 , 10 ] NEW_LINE arr2 = [ 2 , 1 , 6 , 8 , 9 ] NEW_LINE n = len ( arr1 ) NEW_LINE getSortedArray ( arr1 , arr2 , n ) NEW_LINE DEDENT"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Berfungsi untuk mencari pertengahan tiga nombor; Bandingkan setiap tiga nombor untuk mencari nombor tengah. Masukkan hanya jika A> B; Memutuskan A tidak lebih besar daripada b. ; Kod pemacu", "code": "def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT DEDENT a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE"}
{"text": "Susun Lajur Matriks | Berfungsi untuk mencari transpose matriks mat []; Menyimpan transpose matriks mat [] []; Melintasi setiap baris matriks; Melintasi setiap lajur matriks; Elemen matriks transpose; Berfungsi untuk menyusun matriks yang diberikan dengan cara yang bijak; Melintasi baris; Baris - penyortiran bijak; Berfungsi untuk mencetak matriks dalam lajur yang disusun dengan bijak; Fungsi panggilan untuk mencari transpose matriks mat [] []; Menyusun baris matriks - bijak; Kirakan transpose b [] []; Cetak matriks mat [] []; Kod pemacu; Input; Fungsi panggilan untuk mencetak matriks dalam lajur yang disusun dengan bijak", "code": "def transpose ( mat , row , col ) : NEW_LINE INDENT tr = [ [ 0 for i in range ( row ) ] for i in range ( col ) ] NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT tr [ j ] [ i ] = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT return tr NEW_LINE DEDENT def RowWiseSort ( B ) : NEW_LINE INDENT for i in range ( len ( B ) ) : NEW_LINE INDENT B [ i ] = sorted ( B [ i ] ) NEW_LINE DEDENT return B NEW_LINE DEDENT def sortCol ( mat , N , M ) : NEW_LINE INDENT B = transpose ( mat , N , M ) NEW_LINE B = RowWiseSort ( B ) NEW_LINE mat = transpose ( B , M , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 6 , 10 ] , [ 8 , 5 , 9 ] , [ 9 , 4 , 15 ] , [ 7 , 3 , 60 ] ] NEW_LINE N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE sortCol ( mat , N , M ) NEW_LINE DEDENT"}
{"text": "Kawasan terbesar mungkin selepas penyingkiran siri bar mendatar & menegak | Berfungsi untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan; Menyimpan semua bar; Masukkan bar mendatar; Masukkan bar verttik; Keluarkan pemisah mendatar dari S1; Keluarkan pemisah menegak dari S2; Kedai -kedai yang ditinggalkan pemisah mendatar dan menegak; Menyusun kedua -dua senarai dalam urutan menaik; Cari perbezaan maksimum jiran List1; Cari perbezaan maksimum jiran List2; Cetak kelantangan terbesar; Kod pemacu; Diberi nilai N & M; Diberikan susunan; Fungsi panggilan untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan", "code": "def largestArea ( N , M , H , V , h , v ) : NEW_LINE INDENT s1 = set ( [ ] ) ; NEW_LINE s2 = set ( [ ] ) ; NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT s1 . add ( i ) ; NEW_LINE DEDENT for i in range ( 1 , M + 2 ) : NEW_LINE INDENT s2 . add ( i ) ; NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT s1 . remove ( H [ i ] ) ; NEW_LINE DEDENT for i in range ( v ) : NEW_LINE INDENT s2 . remove ( V [ i ] ) ; NEW_LINE DEDENT list1 = [ 0 ] * len ( s1 ) NEW_LINE list2 = [ 0 ] * len ( s2 ) ; NEW_LINE i = 0 ; NEW_LINE for it1 in s1 : NEW_LINE INDENT list1 [ i ] = it1 ; NEW_LINE i += 1 NEW_LINE DEDENT i = 0 ; NEW_LINE for it2 in s2 : NEW_LINE INDENT list2 [ i ] = it2 NEW_LINE i += 1 NEW_LINE DEDENT list1 . sort ( ) ; NEW_LINE list2 . sort ( ) ; NEW_LINE maxH = 0 NEW_LINE p1 = 0 NEW_LINE maxV = 0 NEW_LINE p2 = 0 ; NEW_LINE for j in range ( len ( s1 ) ) : NEW_LINE INDENT maxH = max ( maxH , list1 [ j ] - p1 ) ; NEW_LINE p1 = list1 [ j ] ; NEW_LINE DEDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT maxV = max ( maxV , list2 [ j ] - p2 ) ; NEW_LINE p2 = list2 [ j ] ; NEW_LINE DEDENT print ( ( maxV * maxH ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE M = 3 ; NEW_LINE H = [ 2 ] NEW_LINE V = [ 2 ] ; NEW_LINE h = len ( H ) NEW_LINE v = len ( V ) ; NEW_LINE largestArea ( N , M , H , V , h , v ) ; NEW_LINE DEDENT"}
{"text": "Semak jika array boleh disusun dengan menukar pasangan dari indeks yang terdiri daripada unsur -unsur yang tidak sama rata dalam array lain | Fungsi untuk memeriksa sama ada array, [] boleh ditukar menjadi array yang disusun dengan bertukar (a [i], a [j]) jika b [i] tidak sama dengan b [j]; Kedai jika array A [] disusun dalam urutan menurun atau tidak; Melintasi array a []; Jika [i] lebih besar daripada [i + 1]; Bendera kemas kini; Jika array disusun mengikut urutan menaik; kiraan = 2: periksa jika 0 s dan 1 s kedua -duanya hadir dalam b []; Melintasi array; Jika elemen semasa ialah 0; Kiraan kemas kini; Melintasi array b []; Jika elemen semasa ialah 1; Jika kedua -dua 0 s dan 1 s hadir dalam array; Array input a []; Arahan input B []; Panggilan fungsi; Jika benar, cetak ya; Lain cetak no", "code": "def checkifSorted ( A , B , N ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT if ( not flag ) : NEW_LINE INDENT return True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( B [ i ] == 0 ) : NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if B [ i ] : NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT if ( count == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT A = [ 3 , 1 , 2 ] NEW_LINE B = [ 0 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE check = checkifSorted ( A , B , N ) NEW_LINE if ( check ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"}
{"text": "Swap minimum diperlukan di antara dua rentetan untuk membuat satu rentetan ketat lebih besar daripada yang lain | Function to find the minimum number of steps to make A > B ; Jika semua watak adalah sama dan m <= n; Sekiranya terdapat sebarang watak dalam B yang lebih besar daripada B [0]; Jika terdapat apa -apa watak yang lebih kecil daripada [0]; Sekiranya terdapat watak yang berada di dalam dan lebih besar daripada [0]; Sekiranya terdapat watak yang berada di B dan kurang daripada B [0]; Jika tidak; Kod pemacu", "code": "def minSteps ( A , B , M , N ) : NEW_LINE INDENT if ( A [ 0 ] > B [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B [ 0 ] > A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( M <= N and A [ 0 ] == B [ 0 ] and A . count ( A [ 0 ] ) == M and B . count ( B [ 0 ] ) == N ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] > B [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] < A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] > A [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] < B [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" adsfd \" NEW_LINE B = \" dffff \" NEW_LINE M = len ( A ) NEW_LINE N = len ( B ) NEW_LINE print ( minSteps ( A , B , M , N ) ) NEW_LINE DEDENT"}
{"text": "Memaksimumkan jumlah produk berpasangan yang dihasilkan dari tatasusunan yang diberikan | Program Python3 untuk pendekatan di atas; Pembolehubah yang mewakili saiz array; Stores the results ; Berfungsi untuk mengembalikan jumlah maksimum yang mungkin; Menyimpan kiraan susunan yang diproses; Jika lebih daripada dua tatasusunan telah diproses; Sekiranya subproblem yang telah dikira telah berlaku; Terokai semua pasangan yang mungkin; Panggilan fungsi rekursif; Memoize maksimum; Mengembalikan nilai; Berfungsi untuk mengembalikan jumlah maksimum produk pasangan yang mungkin; Memulakan array DP ke - 1; Menyusun tatasusunan dalam urutan menurun; Kod pemacu", "code": "maxN = 201 ; NEW_LINE n1 , n2 , n3 = 0 , 0 , 0 ; NEW_LINE dp = [ [ [ 0 for i in range ( maxN ) ] for j in range ( maxN ) ] for j in range ( maxN ) ] ; NEW_LINE def getMaxSum ( i , j , k , arr1 , arr2 , arr3 ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE if ( i >= n1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( j >= n2 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( k >= n3 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( cnt >= 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE if ( i < n1 and j < n2 ) : NEW_LINE INDENT ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; NEW_LINE DEDENT if ( i < n1 and k < n3 ) : NEW_LINE INDENT ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; NEW_LINE DEDENT if ( j < n2 and k < n3 ) : NEW_LINE INDENT ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; NEW_LINE DEDENT dp [ i ] [ j ] [ k ] = ans ; NEW_LINE return dp [ i ] [ j ] [ k ] ; NEW_LINE DEDENT def reverse ( tmp ) : NEW_LINE INDENT i , k , t = 0 , 0 , 0 ; NEW_LINE n = len ( tmp ) ; NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT t = tmp [ i ] ; NEW_LINE tmp [ i ] = tmp [ n - i - 1 ] ; NEW_LINE tmp [ n - i - 1 ] = t ; NEW_LINE DEDENT DEDENT def maxProductSum ( arr1 , arr2 , arr3 ) : NEW_LINE INDENT for i in range ( len ( dp ) ) : NEW_LINE INDENT for j in range ( len ( dp [ 0 ] ) ) : NEW_LINE INDENT for k in range ( len ( dp [ j ] [ 0 ] ) ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 ; NEW_LINE DEDENT DEDENT DEDENT arr1 . sort ( ) ; NEW_LINE reverse ( arr1 ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE reverse ( arr2 ) ; NEW_LINE arr3 . sort ( ) ; NEW_LINE reverse ( arr3 ) ; NEW_LINE return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 2 ; NEW_LINE arr1 = [ 3 , 5 ] ; NEW_LINE n2 = 2 ; NEW_LINE arr2 = [ 2 , 1 ] ; NEW_LINE n3 = 3 ; NEW_LINE arr3 = [ 4 , 3 , 5 ] ; NEW_LINE print ( maxProductSum ( arr1 , arr2 , arr3 ) ) ; NEW_LINE DEDENT"}
{"text": "Triplet leksikografi terbesar dari array yang diberikan yang membentuk segitiga | Berfungsi untuk mencari triplet terbesar secara leksikografi yang membentuk segitiga dalam array yang diberikan; Susun array; Berulang dari akhir array; Jika triplet membentuk segitiga; Jika triplet dijumpai; Cetak triplet; Jika tidak; Kod pemacu", "code": "def findTriplet ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while i - 2 >= 0 : NEW_LINE INDENT if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT print ( arr [ i - 2 ] , arr [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 10 , 3 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findTriplet ( arr , N ) NEW_LINE DEDENT"}
{"text": "Kira semua pasangan dalam array dengan perbezaan mutlak minimum | Berfungsi untuk mengembalikan kiraan semua pasangan yang mempunyai perbezaan mutlak yang minimum; Menyimpan kiraan pasangan; Susun array; Menyimpan perbezaan minimum antara pasangan bersebelahan; Mengemas kini perbezaan minimum antara pasangan; Meningkatkan kiraan pasangan dengan perbezaan yang sama dengan perbezaan minimum; Mengembalikan kiraan akhir; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "def numberofpairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE arr . sort ( ) NEW_LINE minDiff = 10000000 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] == minDiff : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 1 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( numberofpairs ( arr , N ) ) NEW_LINE DEDENT"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan menggunakan backtracking | Permulaan maksimum kemungkinan panjang berikutnya; Simpan elemen untuk membandingkan max_length dengan saiznya dan tukar nilai max_length dengan sewajarnya; Simpan unsur -unsur yang paling lama; Berfungsi untuk mencari panjang berikutnya terpanjang; Kemas kini max_length; Simpan unsur -unsur berikutnya; Secara rekursif meneruskan dengan jumlah yang diperoleh; unsur -unsur yang muncul dari belakang kedai vektor; jika jumlah> 0 maka kita tidak memerlukannya sehingga kembali dan teruskan dengan unsur -unsur terdahulu; Susun array yang diberikan; Melintasi array; Jika max_length sudah lebih besar daripada atau sama daripada panjang yang tinggal; Kod pemacu", "code": "max_length = 0 NEW_LINE store = [ ] NEW_LINE ans = [ ] NEW_LINE def find_max_length ( arr , index , sum , k ) : NEW_LINE INDENT global max_length NEW_LINE sum = sum + arr [ index ] NEW_LINE store . append ( arr [ index ] ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT if ( max_length < len ( store ) ) : NEW_LINE INDENT max_length = len ( store ) NEW_LINE ans = store NEW_LINE DEDENT DEDENT for i in range ( index + 1 , len ( arr ) ) : NEW_LINE INDENT if ( sum + arr [ i ] <= k ) : NEW_LINE INDENT find_max_length ( arr , i , sum , k ) NEW_LINE store . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT def longestSubsequence ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max_length >= n - i ) : NEW_LINE INDENT break NEW_LINE DEDENT store . clear ( ) NEW_LINE find_max_length ( arr , i , 0 , k ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 3 , 0 , 1 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( longestSubsequence ( arr , n , k ) ) NEW_LINE DEDENT"}
{"text": "Susun Pengurangan Permutasi N Menggunakan Swap Triple | Fungsi untuk menyusun array; Semak jika boleh menyusun array; Bertukar untuk membawa elemen pada kedudukan yang diperlukan membawa sekurang -kurangnya satu elemen pada kedudukan yang betul; Mengesan perubahan dalam array; Cetak array yang disusun; Jika tidak mungkin untuk menyusun; Kod pemacu", "code": "def sortArray ( A , N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT for i in range ( N // 2 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE DEDENT print ( \" Sorted ▁ Array : ▁ \" , end = \" \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT A = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE sortArray ( A , N ) NEW_LINE"}
{"text": "Cari k sedemikian rupa sehingga mengubah semua elemen array yang lebih besar daripada k ke k akan membuat jumlah array n | Berfungsi untuk mengembalikan k sedemikian rupa sehingga mengubah semua elemen yang lebih besar daripada k ke k akan membuat jumlah array n sebaliknya kembali - 1; Menyusun array dalam peningkatan urutan; Gelung melalui semua elemen array; Memeriksa jika jumlah array sama dengan n; Kod pemacu", "code": "def findK ( arr , size , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE temp_sum = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT temp_sum += arr [ i ] NEW_LINE if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 3 , 1 , 10 , 4 , 8 ] NEW_LINE size = len ( arr ) NEW_LINE N = 16 NEW_LINE print ( findK ( arr , size , N ) ) NEW_LINE"}
{"text": "Cari tiga elemen dari tiga array yang diberikan supaya jumlah mereka adalah x | Tetapkan 2 | Fungsi yang kembali benar jika terdapat triplet dengan jumlah x; Menyusun susunan sedemikian rupa sehingga mewakili array terkecil; Mengalihkan array terkecil; Dua petunjuk pada array kedua dan ketiga; Jika triplet yang sah dijumpai; Kod pemacu", "code": "def existsTriplet ( a , b , c , x , l1 , l2 , l3 ) : NEW_LINE INDENT if ( l2 <= l1 and l2 <= l3 ) : NEW_LINE INDENT l1 , l2 = l2 , l1 NEW_LINE a , b = b , a NEW_LINE DEDENT elif ( l3 <= l1 and l3 <= l2 ) : NEW_LINE INDENT l1 , l3 = l3 , l1 NEW_LINE a , c = c , a NEW_LINE DEDENT for i in range ( l1 ) : NEW_LINE INDENT j = 0 NEW_LINE k = l3 - 1 NEW_LINE while ( j < l2 and k >= 0 ) : NEW_LINE INDENT if ( a [ i ] + b [ j ] + c [ k ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( a [ i ] + b [ j ] + c [ k ] < x ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT a = [ 2 , 7 , 8 , 10 , 15 ] NEW_LINE b = [ 1 , 6 , 7 , 8 ] NEW_LINE c = [ 4 , 5 , 5 ] NEW_LINE l1 = len ( a ) NEW_LINE l2 = len ( b ) NEW_LINE l3 = len ( c ) NEW_LINE x = 14 NEW_LINE if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Susun nombor yang diberikan untuk membentuk nombor terkecil | Fungsi utiliti untuk mencetak kandungan array; Fungsi perbandingan yang kembali benar jika 'ab' lebih kecil daripada 'ba' apabila kita menggabungkan dua nombor 'a' dan 'b' misalnya, ia akan kembali benar jika kita lulus 12 dan 24 sebagai argumen. Fungsi ini akan digunakan oleh fungsi sort (); Tukar nombor pertama ke format rentetan; Tukar nombor kedua ke format rentetan; Semak jika 'ab' lebih kecil atau 'ba' dan kembali nilai bool sejak pengendali perbandingan '<=' mengembalikan benar atau palsu;  ; Berfungsi untuk mencetak susunan dengan nilai terkecil; Jika kita lulus nama fungsi perbandingan, ia akan menyusun array mengikut fungsi membandingkan; Cetak array yang disusun; Kod pemacu", "code": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT def compare ( num1 , num2 ) : NEW_LINE INDENT A = str ( num1 ) NEW_LINE B = str ( num2 ) NEW_LINE return int ( A + B ) <= int ( B + A ) NEW_LINE DEDENT def sort ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT if compare ( arr [ i ] , arr [ j ] ) == False : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def printSmallest ( N , arr ) : NEW_LINE INDENT sort ( arr ) NEW_LINE printArr ( arr , N ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 2 , 9 , 21 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printSmallest ( N , arr ) NEW_LINE DEDENT"}
{"text": "Stabil Pemilihan Susun | Program Python3 untuk mengubah suai pilihan pemilihan supaya ia menjadi stabil. ; Melintasi semua elemen array; Cari elemen minimum dalam array yang tidak disusun; Gerakkan elemen minimum pada semasa i; Kod pemacu", "code": "def stableSelectionSort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ min_idx ] > a [ j ] : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT key = a [ min_idx ] NEW_LINE while min_idx > i : NEW_LINE INDENT a [ min_idx ] = a [ min_idx - 1 ] NEW_LINE min_idx -= 1 NEW_LINE DEDENT a [ i ] = key NEW_LINE DEDENT DEDENT def printArray ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( \" % d \" % a [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT a = [ 4 , 5 , 3 , 2 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE stableSelectionSort ( a , n ) NEW_LINE printArray ( a , n ) NEW_LINE"}
{"text": "Permut dua tatasusunan sedemikian rupa sehingga jumlah setiap pasangan lebih besar atau sama dengan k | Semak sama ada apa -apa permutasi wujud yang memenuhi syarat. ; Susun array a [] dalam urutan yang berkurangan. ; Susun array B [] dalam peningkatan urutan. ; Memeriksa keadaan pada setiap indeks. ; Kod pemacu", "code": "def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 2 , 1 , 3 ] NEW_LINE b = [ 7 , 8 , 9 ] NEW_LINE k = 10 NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , b , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"}
{"text": "Sort Array mengikut kiraan bit set | Fungsi untuk mengira setbit; Fungsi untuk disusun oleh SetBitCount; Melangkah ke atas semua nilai dan masukkan ke dalam multimap; Kod pemacu", "code": "def setBitCount ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT num = num >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count . append ( [ ( - 1 ) * setBitCount ( arr [ i ] ) , arr [ i ] ] ) NEW_LINE DEDENT count . sort ( key = lambda x : x [ 0 ] ) NEW_LINE for i in range ( len ( count ) ) : NEW_LINE INDENT print ( count [ i ] [ 1 ] , end = \" ▁ \" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE"}
{"text": "Semak jika akhir rentetan binari yang diberikan dapat dicapai dengan memilih nilai lompat di antara julat yang diberikan | Fungsi untuk memeriksa sama ada mungkin untuk mencapai hujung rentetan binari menggunakan lompatan yang diberikan; Menyimpan negeri -negeri DP; Keadaan awal; Kedai -kedai mengira indeks dari mana ia mungkin untuk mencapai Indeks I; Melintasi rentetan yang diberikan; Mengemas kini nilai pra dengan sewajarnya; Jika saiz lompat keluar dari julat [l, r]; Jawapan kembali; Kod pemacu", "code": "def canReach ( s , L , R ) : NEW_LINE INDENT dp = [ 0 for _ in range ( len ( s ) ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE pre = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( i >= L ) : NEW_LINE INDENT pre += dp [ i - L ] NEW_LINE DEDENT if ( i > R ) : NEW_LINE INDENT pre -= dp [ i - R - 1 ] NEW_LINE DEDENT dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) NEW_LINE DEDENT return dp [ len ( s ) - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"01101110\" NEW_LINE L = 2 NEW_LINE R = 3 NEW_LINE if canReach ( S , L , R ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Fungsi rekursif untuk mencari semua kemungkinan pemecahan array o subarrays dan cari maksimum bitwise xor; Jika nilai n ialah 0; Menyimpan hasil jika kumpulan baru dibentuk dengan elemen pertama sebagai arr [i]; Kedai jika keputusan jika ARR [i] dimasukkan ke dalam kumpulan terakhir; Mengembalikan maksimum x dan y; Berfungsi untuk mencari maksimum bitwise xor dari semua nilai yang mungkin dari array selepas memecahkan susunan o subarrays; Mengembalikan hasilnya; Kod pemacu", "code": "def maxXORUtil ( arr , N , xrr , orr ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return xrr ^ orr NEW_LINE DEDENT x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) NEW_LINE y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) NEW_LINE return max ( x , y ) NEW_LINE DEDENT def maximumXOR ( arr , N ) : NEW_LINE INDENT return maxXORUtil ( arr , N , 0 , 0 ) NEW_LINE DEDENT arr = 1 , 5 , 7 NEW_LINE N = len ( arr ) NEW_LINE print ( maximumXOR ( arr , N ) ) NEW_LINE"}
{"text": "Bina N | Program Python3 untuk melaksanakan pendekatan di atas; Menjejaki nod yang dikunjungi; Berfungsi untuk membina pokok supaya tidak ada dua nod bersebelahan dengan berat yang sama; Jika elemen minimum dan maksimum adalah sama, i. e. Array mengandungi satu elemen yang berbeza; Pokok tidak boleh dibina; Jika tidak; Pokok boleh dibina; Pilih berat [0] sebagai akar; Node pertama dikunjungi; Melintasi array; Jika tidak, buat kelebihan; Tandakan nod ini seperti yang dikunjungi; Cari berat badan yang tidak sama dengan root & membuat tepi dengan nod itu; Sertai bukan akar dengan nod yang tinggal; Semak jika nod semasa berat ~ sama dengan berat badan dan jika ia tidak dikunjungi atau tidak; Kod pemacu; Panggilan fungsi", "code": "N = 10 ** 5 + 5 NEW_LINE visited = [ 0 ] * N NEW_LINE def construct_tree ( weights , n ) : NEW_LINE INDENT minimum = min ( weights ) NEW_LINE maximum = max ( weights ) NEW_LINE if ( minimum == maximum ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT root = weights [ 0 ] NEW_LINE visited [ 1 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( weights [ i ] != root and visited [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( 1 , i + 1 ) NEW_LINE visited [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT notroot = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( weights [ i ] != root ) : NEW_LINE INDENT notroot = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( weights [ i ] == root and visited [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( notroot , i + 1 ) NEW_LINE visited [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT weights = [ 1 , 2 , 1 , 2 , 5 ] NEW_LINE N = len ( weights ) NEW_LINE construct_tree ( weights , N ) NEW_LINE DEDENT"}
{"text": "Kurangkan kos untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Program Python3 untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk menukar rentetan yang diberikan ke dalam rentetan panjang K substring yang sama; Kedai panjang rentetan; Menyimpan kos minimum; Melintasi substring kiri panjang K; Menyimpan kekerapan; Kedai kos minimum untuk urutan indeks S [i] % K; Semak watak yang optimum; Cari jumlah jarak 'a' + ch dari indeks kara [i] % k; Pilih kos minimum untuk setiap indeks i; Kenaikan ans; Cetak kos minimum untuk menukar rentetan; Diberikan rentetan s; Panggilan fungsi", "code": "import sys NEW_LINE def minCost ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = [ 0 ] * 26 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT a [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT min_cost = sys . maxsize - 1 NEW_LINE for ch in range ( 26 ) : NEW_LINE INDENT cost = 0 NEW_LINE for tr in range ( 26 ) : NEW_LINE INDENT cost += abs ( ch - tr ) * a [ tr ] NEW_LINE DEDENT min_cost = min ( min_cost , cost ) NEW_LINE DEDENT ans += min_cost NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT S = \" abcdefabc \" NEW_LINE K = 3 NEW_LINE minCost ( S , K ) NEW_LINE"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Kod pemacu", "code": "def minAbsDiff ( N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT N = 6 NEW_LINE print ( minAbsDiff ( N ) ) NEW_LINE"}
{"text": "Cari padanan maksimum dalam pokok binari yang diberikan | Program Python3 untuk pendekatan di atas; Senarai Adjacency untuk menyimpan tepi; Tambah kelebihan antara u dan v dalam pokok; Kelebihan dari u ke v; Tepi dari v ke u; Fungsi yang mendapati pemadanan maksimum DFS; Pergi lebih jauh kerana kami tidak dibenarkan pergi ke arah ibu bapanya; Jika u dan ibu induknya tidak diambil maka kita mesti mengambil & menandakannya sebagai diambil; Saiz kenaikan set tepi; Berfungsi untuk mencari padanan maksimum dalam graf; Mengambil 1 sebagai akar pokok; Cetak padanan maksimum; Kod pemacu; Menyertai kelebihan antara dua nod dalam pokok; Panggilan fungsi", "code": "N = 10000 NEW_LINE adj = { } NEW_LINE used = [ 0 for i in range ( N ) ] NEW_LINE max_matching = 0 NEW_LINE def AddEdge ( u , v ) : NEW_LINE INDENT if u not in adj : NEW_LINE INDENT adj [ u ] = [ ] NEW_LINE DEDENT if v not in adj : NEW_LINE INDENT adj [ v ] = [ ] NEW_LINE DEDENT adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def Matching_dfs ( u , p ) : NEW_LINE INDENT global max_matching NEW_LINE for i in range ( len ( adj [ u ] ) ) : NEW_LINE INDENT if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT Matching_dfs ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT DEDENT if ( not used [ u ] and not used [ p ] and p != 0 ) : NEW_LINE INDENT max_matching += 1 NEW_LINE used [ u ] = 1 NEW_LINE used [ p ] = 1 NEW_LINE DEDENT DEDENT def maxMatching ( ) : NEW_LINE INDENT Matching_dfs ( 1 , 0 ) NEW_LINE print ( max_matching ) NEW_LINE DEDENT n = 5 NEW_LINE AddEdge ( 1 , 2 ) NEW_LINE AddEdge ( 1 , 3 ) NEW_LINE AddEdge ( 3 , 4 ) NEW_LINE AddEdge ( 3 , 5 ) NEW_LINE maxMatching ( ) NEW_LINE"}
{"text": "Kurangkan kos untuk menukar dua tatasusunan yang diberikan | Program Python3 untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan kos minimum yang diperlukan untuk menukar dua tatasusunan; Mengembalikan jumlah kos minimum; Kod pemacu", "code": "import sys NEW_LINE def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT return mini * ( 2 * N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE A = [ 1 , 4 , 2 ] NEW_LINE B = [ 10 , 6 , 12 ] NEW_LINE print ( getMinCost ( A , B , N ) ) NEW_LINE"}
{"text": "Cetak semua cara yang mungkin untuk menulis n sebagai jumlah dua atau lebih integer positif | Berfungsi untuk mencetak nilai yang disimpan dalam arr vektor; Melintasi arr vektor; Fungsi rekursif kepada cara -cara prdifferent di mana n boleh ditulis sebagai jumlah pada 2 atau lebih bilangan bulat positif; Jika n adalah sifar maka cara -cara memecahkan nombor; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack untuk mengeluarkan elemen semasa dari perwakilan; Kod pemacu; Diberikan jumlah n; Untuk menyimpan perwakilan melanggar N; Panggilan fungsi", "code": "def printVector ( arr ) : NEW_LINE INDENT if ( len ( arr ) != 1 ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" ▁ \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT printVector ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE del arr [ - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE DEDENT"}
{"text": "Semak jika rentetan boleh dibahagikan kepada dua rentetan dengan bilangan k | yang sama Berfungsi untuk mencetak susunan aksara; Kedai kekerapan aksara; Hitung watak yang mempunyai kekerapan k; Hitung watak yang mempunyai kekerapan lebih besar daripada k dan tidak sama dengan 2 k; Kes 1; Kes 2; Kes 3; Jika semua kes gagal; Kod pemacu", "code": "def DivideString ( s , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE no = 1 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE fr = [ 0 ] * 26 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( fr [ i ] == k ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( fr [ i ] > k and fr [ i ] != 2 * k ) : NEW_LINE INDENT c1 += 1 NEW_LINE ch = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT if ( fr [ i ] == 2 * k ) : NEW_LINE INDENT c2 += 1 NEW_LINE ch1 = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT ans . append ( \"1\" ) NEW_LINE DEDENT mp = { } NEW_LINE if ( c % 2 == 0 or c1 > 0 or c2 > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( fr [ ord ( s [ i ] ) - ord ( ' a ' ) ] == k ) : NEW_LINE INDENT if ( s [ i ] in mp ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE DEDENT else : NEW_LINE INDENT if ( no <= ( c // 2 ) ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE mp [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( c % 2 == 1 and c1 > 0 ) : NEW_LINE INDENT no = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ch and no <= k ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE DEDENT DEDENT DEDENT if ( c % 2 == 1 and c1 == 0 ) : NEW_LINE INDENT no = 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ch1 and no <= k ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE DEDENT if ( fr [ s [ i ] - ' a ' ] == k and flag == 0 and ans [ i ] == '1' ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" \" . join ( ans ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abbbccc \" NEW_LINE N = len ( S ) NEW_LINE K = 1 NEW_LINE DivideString ( S , N , K ) NEW_LINE DEDENT"}
{"text": "Semak jika dua item boleh dipilih dari dua kategori yang berbeza tanpa harga yang melebihi | Fungsi untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Gelung untuk memilih dua pasangan yang berbeza menggunakan dua gelung bersarang; Keadaan untuk memeriksa sama ada harga kedua -dua elemen ini kurang daripada S; Kod pemacu; Panggilan fungsi", "code": "def check ( S , prices , type1 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( type1 [ j ] == 0 and type1 [ k ] == 1 ) or ( type1 [ j ] == 1 and type1 [ k ] == 0 ) ) : NEW_LINE INDENT if ( prices [ j ] + prices [ k ] <= S ) : NEW_LINE INDENT return \" Yes \" ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return \" No \" ; NEW_LINE DEDENT prices = [ 3 , 8 , 6 , 5 ] ; NEW_LINE type1 = [ 0 , 1 , 1 , 0 ] ; NEW_LINE S = 10 ; NEW_LINE n = 4 ; NEW_LINE print ( check ( S , prices , type1 , n ) ) ; NEW_LINE"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah yang membahagikan harta produk; Untuk mencari faktor terbesar k; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "def getLargestSum ( N ) : NEW_LINE INDENT for i in range ( 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT k = N // j ; NEW_LINE a = k * i ; NEW_LINE b = k * j ; NEW_LINE if ( a <= N and b <= N and a * b % ( a + b ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , a + b ) ; NEW_LINE DEDENT DEDENT DEDENT return max_sum ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 25 ; NEW_LINE max_sum = getLargestSum ( N ) ; NEW_LINE print ( max_sum ) ; NEW_LINE DEDENT"}
{"text": "Menyulitkan rentetan dengan mengulangi i | Berfungsi untuk mengembalikan rentetan yang disulitkan; Bilangan kali watak semasa akan diulang; Ulangi watak semasa dalam rentetan yang disulitkan; Kod pemacu", "code": "def encryptString ( string , n ) : NEW_LINE INDENT i , cnt = 0 , 0 NEW_LINE encryptedStr = \" \" NEW_LINE while i < n : NEW_LINE INDENT cnt = i + 1 NEW_LINE while cnt > 0 : NEW_LINE INDENT encryptedStr += string [ i ] NEW_LINE cnt -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return encryptedStr NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" NEW_LINE n = len ( string ) NEW_LINE print ( encryptString ( string , n ) ) NEW_LINE DEDENT"}
{"text": "Kurangkan perbezaan antara nilai maksimum dan minimum array yang diubah suai | Fungsi untuk mengembalikan perbezaan minimum yang diperlukan; mencari nilai minimum dan maksimum; mengembalikan perbezaan minimum yang mungkin; Program pemacu; berfungsi untuk mengembalikan jawapannya", "code": "def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT n = 3 NEW_LINE x = 3 NEW_LINE A = [ 1 , 3 , 6 ] NEW_LINE print ( minDiff ( n , x , A ) ) NEW_LINE"}
{"text": "Swap minimum untuk mengimbangi pendakap | Program Python3 untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Kedai Jumlah bilangan kurungan kiri dan kanan yang ditemui; Swap menyimpan bilangan swap yang diperlukan ketidakseimbangan mengekalkan bilangan pasangan ketidakseimbangan; Kiraan kenaikan kurungan kiri; Kiraan swap adalah kiraan swap terakhir + jumlah kurungan tidak seimbang; Imbalance decremented by 1 as it solved only one imbalance of left and right ; Kiraan kenaikan kurungan kanan; Ketidakseimbangan diset semula kepada perbezaan semasa antara kurungan kiri dan kanan; Kod pemacu", "code": "def swapCount ( s ) : NEW_LINE INDENT chars = s NEW_LINE countLeft = 0 NEW_LINE countRight = 0 NEW_LINE swap = 0 NEW_LINE imbalance = 0 ; NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT if chars [ i ] == ' [ ' : NEW_LINE INDENT countLeft += 1 NEW_LINE if imbalance > 0 : NEW_LINE INDENT swap += imbalance NEW_LINE imbalance -= 1 NEW_LINE DEDENT DEDENT elif chars [ i ] == ' ] ' : NEW_LINE INDENT countRight += 1 NEW_LINE imbalance = ( countRight - countLeft ) NEW_LINE DEDENT DEDENT return swap NEW_LINE DEDENT s = \" [ ] ] [ ] [ \" ; NEW_LINE print ( swapCount ( s ) ) NEW_LINE s = \" [ [ ] [ ] ] \" ; NEW_LINE print ( swapCount ( s ) ) NEW_LINE"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Fungsi untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; dp [i]: Menyimpan selanjutnya yang terpanjang sehingga i; Kes asas; Apabila keadaan memegang; Akhirnya, jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "def longestSubSequence ( A , N ) : NEW_LINE INDENT dp = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] and A [ j ] [ 1 ] > A [ i ] [ 1 ] ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N - 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE longestSubSequence ( A , N ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Kes asas; Kembali hasil yang telah disimpan; Berulang untuk semua 6 negeri; Mengembalikan hasilnya; Kod pemacu; Diberikan jumlah n; Memulakan array DP; Panggilan fungsi", "code": "def findWays ( N , dp ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ N ] != - 1 ) : NEW_LINE INDENT return dp [ N ] NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = ( cnt + findWays ( N - i , dp ) ) NEW_LINE DEDENT DEDENT dp [ N ] = cnt NEW_LINE return dp [ N ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE dp = [ - 1 ] * ( N + 1 ) NEW_LINE print ( findWays ( N , dp ) ) NEW_LINE DEDENT"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Memulakan array DP; Melangkah ke atas semua nilai perantaraan yang mungkin untuk mencapai n; Kirakan jumlah untuk semua 6 muka; Cetak jumlah cara; Kod pemacu; Diberikan jumlah n; Panggilan fungsi", "code": "def findWays ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 ; NEW_LINE for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE findWays ( N ) ; NEW_LINE DEDENT"}
{"text": "Pecahkan rentetan ke bahagian minimum supaya setiap bahagian berada dalam rentetan lain | Pelaksanaan Python3 untuk memecah rentetan ke dalam bilangan minimum bahagian supaya setiap bahagian juga terdapat dalam rentetan lain; Nod trie; Berfungsi untuk memasukkan nod dalam struktur data trie; Memasukkan setiap watak dari IDX hingga hujung ke rentetan ke dalam trie; Sekiranya tidak ada kelebihan yang sepadan dengan watak ITH, maka buat nod baru; Berfungsi untuk mencari bilangan minimum bahagian supaya setiap bahagian hadir ke dalam rentetan lain; Membuat trie baru; Memasukkan setiap substring S2 di Trie; Mewujudkan array DP dan init dengan tak terhingga; Kes asas; Memulakan pemotongan dari watak yang mengambil penunjuk nod sementara untuk memeriksa sama ada substring [i, j) hadir dalam trie tidak; Sekiranya watak JTH tidak berada di Trie, kami akan berehat; Mengemas kini berakhirnya watak jth dengan dp [i] + 1; Menurunkan penunjuk Trie; Jawapan tidak mungkin; Kod pemacu", "code": "INF = 1e9 + 9 NEW_LINE class TrieNode ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . child = [ None ] * 26 NEW_LINE DEDENT DEDENT def insert ( idx , s , root ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( idx , len ( s ) ) : NEW_LINE INDENT if temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] == None : NEW_LINE INDENT temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] = TrieNode ( ) NEW_LINE DEDENT temp = temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT DEDENT def minCuts ( S1 , S2 ) : NEW_LINE INDENT n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE root = TrieNode ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT insert ( i , S2 , root ) NEW_LINE DEDENT dp = [ INF ] * ( n1 + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT temp = root NEW_LINE for j in range ( i + 1 , n1 + 1 ) : NEW_LINE INDENT if temp . child [ ord ( S1 [ j - 1 ] ) - ord ( ' a ' ) ] == None : NEW_LINE INDENT break NEW_LINE DEDENT dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) NEW_LINE temp = temp . child [ ord ( S1 [ j - 1 ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT DEDENT if dp [ n1 ] >= INF : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n1 ] NEW_LINE DEDENT DEDENT S1 = \" abcdab \" NEW_LINE S2 = \" dabc \" NEW_LINE print ( minCuts ( S1 , S2 ) ) NEW_LINE"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputing jumlah awalan countdp matriks; Gelung untuk menyelesaikan pertanyaan; Mengira jarak maksimum yang mungkin dari pusat dari tepi; Kira jumlah 1 s dalam sub persegi yang dipertimbangkan; Jika kiraan kurang daripada atau sama dengan langkah maksimum ke separuh kanan; Kod pemacu", "code": "def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE l = 0 NEW_LINE u = min_dist NEW_LINE while ( l <= u ) : NEW_LINE INDENT mid = int ( ( l + u ) / 2 ) NEW_LINE x1 = i - mid NEW_LINE x2 = i + mid NEW_LINE y1 = j - mid NEW_LINE y2 = j + mid NEW_LINE count = countDP [ x2 ] [ y2 ] NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count <= K ) : NEW_LINE INDENT ans = 2 * mid + 1 NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT u = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE"}
