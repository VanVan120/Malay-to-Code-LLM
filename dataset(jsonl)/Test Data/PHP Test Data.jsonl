{"text": "Kerugian apabila dua item dijual pada harga yang sama dan keuntungan / kerugian peratusan yang sama | Fungsi yang akan mendapati kerugian; Kod pemacu; Fungsi panggilan", "code": "< ? php function Loss ( $ SP , $ P ) { $ loss = 0 ; $ loss = ( ( 2 * $ P * $ P * $ SP ) / ( 100 * 100 - $ P * $ P ) ) ; print ( \" Loss ▁ = ▁ \" . round ( $ loss , 3 ) ) ; } $ SP = 2400 ; $ P = 30 ; Loss ( $ SP , $ P ) ; ? >"}
{"text": "Semak elemen array iaitu CO | Pelaksanaan PHP pendekatan; Menyimpan faktor utama terkecil untuk setiap nombor; Hash untuk menyimpan kiraan faktor utama; Fungsi untuk mengira SPF (faktor utama terkecil) untuk setiap nombor sehingga maxn; Menandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; Menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; Menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Berfungsi untuk menyimpan faktor utama selepas membahagikan faktor utama terkecil di setiap langkah; Menyimpan kiraan faktor utama dalam hash; Fungsi yang mengembalikan benar jika tidak ada faktor utama yang sama antara x dan nombor array lain; Memeriksa sama ada faktor utama yang biasa dengan nombor lain; Fungsi yang mengembalikan benar jika terdapat elemen dalam array yang coprime dengan semua elemen lain dari array; Menggunakan ayak untuk menjana faktor utama; Memeriksa faktor utama biasa dengan nombor lain; Kod pemacu", "code": "< ? php $ MAXN = 10001 ; $ spf = array_fill ( 0 , $ MAXN , 0 ) ; $ hash1 = array_fill ( 0 , $ MAXN , 0 ) ; function sieve ( ) { global $ spf , $ MAXN , $ hash1 ; $ spf [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ MAXN ; $ i ++ ) $ spf [ $ i ] = $ i ; for ( $ i = 4 ; $ i < $ MAXN ; $ i += 2 ) $ spf [ $ i ] = 2 ; for ( $ i = 3 ; $ i * $ i < $ MAXN ; $ i ++ ) { if ( $ spf [ $ i ] == $ i ) { for ( $ j = $ i * $ i ; $ j < $ MAXN ; $ j += $ i ) if ( $ spf [ $ j ] == $ j ) $ spf [ $ j ] = $ i ; } } } function getFactorization ( $ x ) { global $ spf , $ MAXN , $ hash1 ; while ( $ x != 1 ) { $ temp = $ spf [ $ x ] ; if ( $ x % $ temp == 0 ) { $ hash1 [ $ spf [ $ x ] ] ++ ; $ x = ( int ) ( $ x / $ spf [ $ x ] ) ; } while ( $ x % $ temp == 0 ) $ x = ( int ) ( $ x / $ temp ) ; } } function check ( $ x ) { global $ spf , $ MAXN , $ hash1 ; while ( $ x != 1 ) { $ temp = $ spf [ $ x ] ; if ( $ x % $ temp == 0 && $ hash1 [ $ temp ] > 1 ) return false ; while ( $ x % $ temp == 0 ) $ x = ( int ) ( $ x / $ temp ) ; } return true ; } function hasValidNum ( $ arr , $ n ) { global $ spf , $ MAXN , $ hash1 ; sieve ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) getFactorization ( $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( check ( $ arr [ $ i ] ) ) return true ; return false ; } $ arr = array ( 2 , 8 , 4 , 10 , 6 , 7 ) ; $ n = count ( $ arr ) ; if ( hasValidNum ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cara untuk mengeluarkan tepi dari graf lengkap untuk membuat tepi ganjil | Berfungsi untuk mengembalikan bilangan cara untuk mengeluarkan tepi dari graf supaya bilangan tepi yang ganjil ditinggalkan dalam graf; Jumlah bilangan tepi; Kod pemacu", "code": "< ? php function countWays ( $ N ) { $ E = ( $ N * ( $ N - 1 ) ) / 2 ; if ( $ N == 1 ) return 0 ; return ( int ) pow ( 2 , $ E - 1 ) ; } $ N = 4 ; echo ( countWays ( $ N ) ) ; ? >"}
{"text": "Partition Jumlah Paling Berdekatan (ke dalam dua subset) nombor dari 1 hingga N | Berfungsi untuk mengembalikan perbezaan mutlak yang diperlukan minimum; Kod pemacu", "code": "< ? php function minAbsDiff ( $ n ) { $ mod = $ n % 4 ; if ( $ mod == 0 $ mod == 3 ) return 0 ; return 1 ; } $ n = 5 ; echo minAbsDiff ( $ n ) ; ? >"}
{"text": "Semak sama ada xor kekerapan semua digit nombor n adalah sifar atau tidak | Pelaksanaan PHP pendekatan di atas; mewujudkan pelbagai frekuensi; Mencari digit terakhir nombor; Membahagikan nombor dengan 10 untuk menghapuskan digit terakhir; kekerapan mengira setiap digit; Memeriksa jika XOR semua kekerapan adalah sifar atau tidak; Pemacu utama", "code": "< ? php function check ( $ s ) { $ freq = array_fill ( 0 , 10 , 0 ) ; while ( $ s != 0 ) { $ r = $ s % 10 ; $ s = ( int ) ( $ s / 10 ) ; $ freq [ $ r ] += 1 ; } $ xor = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ xor = $ xor ^ $ freq [ $ i ] ; if ( $ xor == 0 ) return true ; else return false ; } $ s = 122233 ; if ( check ( $ s ) ) print ( \" Yes \" ) ; else print ( \" No \" ) ; ? >"}
{"text": "Cetak garis n 4 nombor supaya setiap pasangan di antara 4 nombor mempunyai gcd k | Berfungsi untuk mencetak garis N; Iterat n kali untuk mencetak garis n; Kod pemacu", "code": "< ? php function printLines ( $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ k * ( 6 * $ i + 1 ) ) ; echo ( \" ▁ \" ) ; echo ( $ k * ( 6 * $ i + 2 ) ) ; echo ( \" ▁ \" ) ; echo ( $ k * ( 6 * $ i + 3 ) ) ; echo ( \" ▁ \" ) ; echo ( $ k * ( 6 * $ i + 5 ) ) ; echo ( \" STRNEWLINE \" ) ; } } $ n = 2 ; $ k = 2 ; printLines ( $ n , $ k ) ; ? >"}
{"text": "Jumlah pertama N Siri 3, 5, 9, 17, 33 ... | Program PHP untuk mencari jumlah terma pertama N; Sn = n * (4 * n * n + 6 * n - 1) / 3; bilangan terma yang akan dimasukkan dalam jumlah; Cari SN", "code": "< ? php function calculateSum ( $ n ) { return ( pow ( 2 , $ n + 1 ) + $ n - 2 ) ; } $ n = 4 ; echo \" Sum = \" ? >"}
{"text": "Cara Menulis N sebagai Jumlah Dua atau Lebih Integer Positif | Set | Berfungsi untuk mencari bilangan partition n; Kes asas; Kod pemacu", "code": "< ? php function partitions ( $ n ) { $ p = array_fill ( 0 , $ n + 1 , 0 ) ; $ p [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) { $ k = 1 ; while ( ( $ k * ( 3 * $ k - 1 ) ) / 2 <= $ i ) { $ p [ $ i ] += ( ( $ k % 2 ? 1 : -1 ) * $ p [ $ i - ( $ k * ( 3 * $ k - 1 ) ) / 2 ] ) ; if ( $ k > 0 ) $ k *= -1 ; else $ k = 1 - $ k ; } } return $ p [ $ n ] ; } $ N = 20 ; print ( partitions ( $ N ) ) ; ? >"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu", "code": "< ? php function countPaths ( $ n , $ m ) { if ( $ n == 0 $ m == 0 ) return 1 ; return ( countPaths ( $ n - 1 , $ m ) + countPaths ( $ n , $ m - 1 ) ) ; } $ n = 3 ; $ m = 2 ; echo \" ▁ Number ▁ of ▁ Paths ▁ \" , countPaths ( $ n , $ m ) ; ? >"}
{"text": "Masalah Tambang Emas | Mengembalikan jumlah maksimum emas yang boleh dikumpulkan apabila perjalanan bermula dari lajur pertama dan bergerak yang dibenarkan adalah betul, kanan dan kanan - ke bawah; Buat jadual untuk menyimpan hasil pertengahan dan memulakan semua sel ke 0. Baris pertama Goldminetable memberikan emas maksimum yang dapat dikumpulkan oleh pelombong ketika memulakan baris itu; Emas yang dikumpulkan untuk pergi ke sel di atas rigth ( ->); Emas yang dikumpulkan untuk pergi ke sel untuk ke atas ( /); Emas yang dikumpulkan untuk pergi ke sel ke kanan (\\); Max Gold yang dikumpulkan daripada mengambil salah satu daripada 3 laluan di atas; Jumlah maksimum emas yang dikumpulkan akan menjadi nilai maksimum dalam lajur pertama semua baris; Kod pemacu", "code": "< ? php function getMaxGold ( $ gold , $ m , $ n ) { $ MAX = 100 ; $ goldTable = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ goldTable [ $ i ] [ $ j ] = 0 ; for ( $ col = $ n - 1 ; $ col >= 0 ; $ col -- ) { for ( $ row = 0 ; $ row < $ m ; $ row ++ ) { if ( $ col == $ n - 1 ) $ right = 0 ; else $ right = $ goldTable [ $ row ] [ $ col + 1 ] ; if ( $ row == 0 or $ col == $ n - 1 ) $ right_up = 0 ; else $ right_up = $ goldTable [ $ row - 1 ] [ $ col + 1 ] ; if ( $ row == $ m - 1 or $ col == $ n - 1 ) $ right_down = 0 ; else $ right_down = $ goldTable [ $ row + 1 ] [ $ col + 1 ] ; $ goldTable [ $ row ] [ $ col ] = $ gold [ $ row ] [ $ col ] + max ( $ right , $ right_up , $ right_down ) ; } } $ res = $ goldTable [ 0 ] [ 0 ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = max ( $ res , $ goldTable [ $ i ] [ 0 ] ) ; return $ res ; } $ gold = array ( array ( 1 , 3 , 1 , 5 ) , array ( 2 , 2 , 4 , 1 ) , array ( 5 , 0 , 2 , 3 ) , array ( 0 , 6 , 1 , 2 ) ) ; $ m = 4 ; $ n = 4 ; echo getMaxGold ( $ gold , $ m , $ n ) ; ? >"}
{"text": "Cari Kos Pelarasan Minimum Array | Program PHP untuk mencari kos pelarasan minimum array; Fungsi untuk mencari kos pelarasan minimum array; dp [i] [j] menyimpan kos pelarasan minimum untuk menukar [i] ke j; mengendalikan elemen pertama array secara berasingan; lakukan untuk elemen rehat array; Gantikan [i] ke J dan hitung kos pelarasan minimum DP [i] [j]; memulakan kos pelarasan minimum kepada int_max; Pertimbangkan semua k sedemikian rupa sehingga k> = max (j - sasaran, 0) dan k <= min (m, j + sasaran) dan ambil minimum; pulangan nilai minimum dari baris terakhir jadual DP; Kod pemacu", "code": "< ? php $ M = 100 ; function minAdjustmentCost ( $ A , $ n , $ target ) { global $ M ; $ dp = array ( array ( ) ) ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ dp [ 0 ] [ $ j ] = abs ( $ j - $ A [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = max ( $ j - $ target , 0 ) ; $ k <= min ( $ M , $ j + $ target ) ; $ k ++ ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i - 1 ] [ $ k ] + abs ( $ A [ $ i ] - $ j ) ) ; } } $ res = PHP_INT_MAX ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ res = min ( $ res , $ dp [ $ n - 1 ] [ $ j ] ) ; return $ res ; } $ arr = array ( 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ) ; $ n = count ( $ arr ) ; $ target = 10 ; echo \" Minimum ▁ adjustment ▁ cost ▁ is ▁ \" , minAdjustmentCost ( $ arr , $ n , $ target ) ; ? >"}
{"text": "Kira kejadian watak dalam rentetan berulang | Berfungsi untuk mengira watak 'A'; Atleast k pengulangan diperlukan; Jika n bukanlah pelbagai pemeriksaan saiz rentetan untuk watak berulang yang tersisa. ; Kod pemacu", "code": "< ? php function countChar ( $ str , $ x ) { $ count = 0 ; $ n = 10 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ count ++ ; $ repetitions = ( int ) ( $ n / strlen ( $ str ) ) ; $ count = $ count * $ repetitions ; for ( $ i = 0 ; $ i < $ n % strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) $ count ++ ; } return $ count ; } $ str = \" abcac \" ; echo countChar ( $ str , ' a ' ) ; ? >"}
{"text": "Semak jika rentetan mempunyai m berturut -turut 1 's atau ~ 0' s | Fungsi yang memeriksa jika rentetan binari mengandungi m berturut -turut 1 's atau' s; panjang rentetan binari; Count Zeros; Count 1 's; Count berturut -turut 0 's; Count berturut -turut 1 's; Kod pemacu; panggilan fungsi", "code": "< ? php function check ( $ s , $ m ) { $ l = count ( $ s ) ; $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i <= $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) { $ c2 = 0 ; $ c1 ++ ; } else { $ c1 = 0 ; $ c2 ++ ; } if ( $ c1 == $ m or $ c2 == $ m ) return true ; } return false ; } $ s = \"001001\" ; $ m = 2 ; if ( check ( $ s , $ m ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Produk nod di k | Berfungsi untuk mencari produk digit elemen di peringkat k - th; $ produk = 1; Memulakan hasil; peningkatan bilangan tahap; mengurangkan nombor tahap; Periksa sama ada tahap semasa adalah tahap yang dikehendaki atau tidak; produk yang diperlukan; Kod pemacu", "code": "< ? php function productAtKthLevel ( $ tree , $ k ) { $ level = -1 ; $ n = strlen ( $ tree ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ tree [ $ i ] == ' ( ' ) $ level ++ ; else if ( $ tree [ $ i ] == ' ) ' ) $ level -- ; else { if ( $ level == $ k ) $ product *= ( ord ( $ tree [ $ i ] ) - ord ( '0' ) ) ; } } return $ product ; } $ tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; $ k = 2 ; echo productAtKthLevel ( $ tree , $ k ) ; ? >"}
{"text": "Program untuk memeriksa ISBN | Program PHP untuk memeriksa sama ada ISBN yang diberikan adalah sah atau tidak. ; panjang mestilah 10; Pengkomputeran berjumlah 9 digit pertama; Memeriksa digit terakhir. ; Jika digit terakhir adalah 'x', tambahkan 10 hingga jumlah, tambah nilainya. ; Kembali benar jika jumlah digit berwajaran boleh dibahagikan dengan 11 .; Kod pemacu", "code": "< ? php function isValidISBN ( $ isbn ) { $ n = strlen ( $ isbn ) ; if ( $ n != 10 ) return -1 ; $ sum = 0 ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { $ digit = $ isbn [ $ i ] - '0' ; if ( 0 > $ digit 9 < $ digit ) return -1 ; $ sum += ( $ digit * ( 10 - $ i ) ) ; } $ last = $ isbn [ 9 ] ; if ( $ last != ' X ' && ( $ last < '0' $ last > '9' ) ) return -1 ; $ sum += ( ( $ last == ' X ' ) ? 10 : ( $ last - '0' ) ) ; return ( $ sum % 11 == 0 ) ; } $ isbn = \"007462542X \" ; if ( isValidISBN ( $ isbn ) ) echo \" Valid \" ; else echo \" Invalid \" ; ? >"}
{"text": "Program untuk mencari sudut segiempat | Kod pemacu; Menurut formula yang diperolehi di atas; Cetak semua sudut", "code": "< ? php $ d = 10 ; $ a = ( 360 - ( 6 * $ d ) ) / 4 ; echo $ a , \" , ▁ \" , $ a + $ d , \" , ▁ \" , $ a + ( 2 * $ d ) , \" , ▁ \" , $ a + ( 3 * $ d ) ; ? >"}
{"text": "Jarak antara dua pesawat selari dalam 3 | Berfungsi untuk mencari jarak; Kod pemacu", "code": "< ? php function distance ( $ a1 , $ b1 , $ c1 , $ d1 , $ a2 , $ b2 , $ c2 , $ d2 ) { if ( $ a1 / $ a2 == $ b1 / $ b2 && $ b1 / $ b2 == $ c1 / $ c2 ) { $ x1 = $ y1 = 0 ; $ z1 = - $ d1 / $ c1 ; $ d = abs ( ( $ c2 * $ z1 + $ d2 ) ) / ( sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ) ; echo \" Perpendicular ▁ distance ▁ is ▁ \" , $ d ; } else echo \" Planes ▁ are ▁ not ▁ parallel \" ; } $ a1 = 1 ; $ b1 = 2 ; $ c1 = -1 ; $ d1 = 1 ; $ a2 = 3 ; $ b2 = 6 ; $ c2 = -3 ; $ d2 = -4 ; distance ( $ a1 , $ b1 , $ c1 , $ d1 , $ a2 , $ b2 , $ c2 , $ d2 ) ; ? >"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Mencetak nombor minimum yang boleh dibentuk dari urutan input i dan u; Inisialisasi Current_Max (untuk memastikan bahawa kita tidak menggunakan watak berulang; permulaan last_entry (menjejaki angka bercetak terakhir); beralih ke atas array input; memulakan 'noofnextd' untuk mendapatkan kiraan d berikut yang tersedia; Cetak angka untuk saya", "code": "< ? php function PrintMinNumberForPattern ( $ arr ) { $ curr_max = 0 ; $ last_entry = 0 ; $ j ; for ( $ i = 0 ; $ i < strlen ( $ arr ) ; $ i ++ ) { $ noOfNextD = 0 ; switch ( $ arr [ $ i ] ) { case ' I ' : $ j = $ i + 1 ; while ( $ arr [ $ j ] == ' D ' && $ j < strlen ( $ arr ) ) { $ noOfNextD ++ ; $ j ++ ; } if ( $ i == 0 ) { $ curr_max = $ noOfNextD + 2 ; echo \" ▁ \" , ++ $ last_entry ; echo \" ▁ \" , $ curr_max ; $ last_entry = $ curr_max ; } else { $ curr_max = $ curr_max + $ noOfNextD + 1 ; $ last_entry = $ curr_max ; echo \" ▁ \" , $ last_entry ; } for ( $ k = 0 ; $ k < $ noOfNextD ; $ k ++ ) { echo \" ▁ \" , -- $ last_entry ; $ i ++ ; } break ; case ' D ' : if ( $ i == 0 ) { $ j = $ i + 1 ; while ( ( $ arr [ $ j ] == ' D ' ) && ( $ j < strlen ( $ arr ) ) ) { $ noOfNextD ++ ; $ j ++ ; } $ curr_max = $ noOfNextD + 2 ; echo \" ▁ \" , $ curr_max , \" ▁ \" , $ curr_max - 1 ; $ last_entry = $ curr_max - 1 ; } else { echo \" ▁ \" , $ last_entry - 1 ; $ last_entry -- ; } break ; } } echo \" STRNEWLINE \" ; } PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; ? >"}
{"text": "Semak jika digit pertama dan terakhir nombor terkecil membentuk Perdana | berfungsi untuk memeriksa perdana; Berfungsi untuk menghasilkan nombor yang paling kecil dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam urutan menaik untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; mengekstrak digit pertama; mengekstrak digit terakhir; mencetak kombinasi utama; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { $ c = 0 ; for ( $ i = 1 ; $ i < $ n / 2 ; $ i ++ ) { if ( $ n % $ i == 0 ) $ c ++ ; } if ( $ c == 1 ) return 1 ; else return 0 ; } function findMinNum ( $ arr , $ n ) { $ first = 0 ; $ last = 0 ; $ num ; $ rev ; $ i ; $ hash = array_fill ( 0 , 20 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ hash [ $ arr [ $ i ] ] ++ ; } echo \" Minimum ▁ number : ▁ \" ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ hash [ $ i ] ; $ j ++ ) echo $ i ; } for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { if ( $ hash [ $ i ] != 0 ) { $ first = $ i ; break ; } } for ( $ i = 9 ; $ i >= 0 ; $ i -- ) { if ( $ hash [ $ i ] != 0 ) { $ last = $ i ; break ; } } $ num = $ first * 10 + $ last ; $ rev = $ last * 10 + $ first ; echo \" Prime combinations : \" if ( isPrime ( $ num ) && isPrime ( $ rev ) ) echo $ num . \" ▁ \" . $ rev ; else if ( isPrime ( $ num ) ) echo $ num ; else if ( isPrime ( $ rev ) ) echo $ rev ; else echo \" No ▁ combinations ▁ exist \" ; } $ arr = array ( 1 , 2 , 4 , 7 , 8 ) ; findMinNum ( $ arr , 5 ) ; ? >"}
{"text": "Mencari Co Transitif | Berfungsi untuk mengembalikan GCD A dan B; berfungsi untuk memeriksa GCD; A dan B adalah coprime jika GCD mereka adalah 1; Memeriksa jika ada triplet yang mungkin (a, b, c) menetapkan keadaan bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Menjana dan menyemak semua kemungkinan tiga kali ganda antara L dan R; Jika kita dapati apa -apa tiga kali ganda menetapkan bendera kepada benar; Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; } function coprime ( $ a , $ b ) { return ( gcd ( $ a , $ b ) == 1 ) ; } function possibleTripletInRange ( $ L , $ R ) { $ flag = false ; $ possibleA ; $ possibleB ; $ possibleC ; for ( $ a = $ L ; $ a <= $ R ; $ a ++ ) { for ( $ b = $ a + 1 ; $ b <= $ R ; $ b ++ ) { for ( $ c = $ b + 1 ; $ c <= $ R ; $ c ++ ) { if ( coprime ( $ a , $ b ) && coprime ( $ b , $ c ) && ! coprime ( $ a , $ c ) ) { $ flag = true ; $ possibleA = $ a ; $ possibleB = $ b ; $ possibleC = $ c ; break ; } } } } if ( $ flag == true ) { echo \" ( \" , $ possibleA , \" , ▁ \" , $ possibleB , \" , ▁ \" , $ possibleC , \" ) \" , \" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ between ▁ \" , $ L , \" ▁ and ▁ \" , $ R , \" STRNEWLINE \" ; } else { echo \" No ▁ Such ▁ Triplet ▁ exists ▁ between ▁ \" , $ L , \" ▁ and ▁ \" , $ R , \" STRNEWLINE \" ; } } $ L ; $ R ; $ L = 2 ; $ R = 10 ; possibleTripletInRange ( $ L , $ R ) ; $ L = 23 ; $ R = 46 ; possibleTripletInRange ( $ L , $ R ) ; ? >"}
{"text": "Jangkau A dan B dengan mengalikannya dengan k dan k ^ 2 pada setiap langkah | Fungsi untuk memeriksa adalah mungkin untuk mencapai A dan B bermula dari 1 dan 1; Cari cuberoot nombor; Bahagikan nombor dengan Cuberoot; Jika ia adalah cuberoot yang sempurna dan membahagikan A dan B; Kod pemacu", "code": "< ? php function possibleToReach ( $ a , $ b ) { $ c = ( $ a * $ b ) ; $ re1 = $ a / $ c ; $ re2 = $ b / $ c ; if ( ( $ re1 * $ re1 * $ re2 == $ a ) && ( $ re2 * $ re2 * $ re1 == $ b ) ) return 1 ; else return -1 ; } $ A = 60 ; $ B = 450 ; if ( possibleToReach ( $ A , $ B ) ) echo \" yes \" ; else echo \" no \" ; ? >"}
{"text": "Nombor bergelora | Program PHP untuk memeriksa sama ada nombor beralun atau tidak; Memandangkan definisi dengan sekatan bahawa terdapat sekurang -kurangnya 3 digit; Semak sama ada semua digit alternatif adalah sama atau tidak. ; Kod pemacu", "code": "< ? php function isUndulating ( $ n ) { if ( strlen ( $ n ) <= 2 ) return false ; for ( $ i = 2 ; $ i < strlen ( $ n ) ; $ i ++ ) if ( $ n [ $ i - 2 ] != $ n [ $ i ] ) false ; return true ; } $ n = \"1212121\" ; if ( isUndulating ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | Fungsi untuk mengira siri berikut; Kod pemacu", "code": "< ? php function Series ( $ n ) { $ i ; $ sums = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sums += ( $ i * $ i ) ; return $ sums ; } $ n = 3 ; $ res = Series ( $ n ) ; echo ( $ res ) ; ? >"}
{"text": "Jumlah semua nombor yang boleh dibahagikan dengan 6 dalam julat yang diberikan | fungsi untuk mengira jumlah semua nombor yang boleh dibahagi dengan 6 dalam julat l - r. . ; tidak ada gandaan 6 sehingga r; tiada gandaan 6 sehingga l - 1; penjumlahan semua gandaan 6 sehingga r; penjumlahan semua gandaan 6 sehingga l - 1; mengembalikan jawapannya; Kod pemacu", "code": "< ? php function sum ( $ L , $ R ) { $ p = intval ( $ R / 6 ) ; $ q = intval ( ( $ L - 1 ) / 6 ) ; $ sumR = intval ( 3 * ( $ p * ( $ p + 1 ) ) ) ; $ sumL = intval ( ( $ q * ( $ q + 1 ) ) * 3 ) ; return $ sumR - $ sumL ; } $ L = 1 ; $ R = 20 ; echo sum ( $ L , $ R ) ; ? >"}
{"text": "Nombor yang lebih kecil yang terbesar mungkin menggunakan hanya satu operasi swap | Program PHP untuk mencari nombor yang lebih kecil dengan menukar satu digit. Mengembalikan nombor yang mungkin terbesar dengan satu swap supaya nombor itu lebih kecil daripada STR. Dianggap bahawa terdapat 0 s. ; Traverse dari kanan sehingga kita dapati digit yang lebih besar daripada digit seterusnya. Sebagai contoh, dalam 34125, indeks kami ialah 4 .; Kami juga boleh menggunakan carian binari di sini sebagai digit selepas indeks disusun dalam peningkatan urutan. Cari digit terbesar di sebelah kanan ARR [indeks] yang lebih kecil daripada ARR [indeks]; Jika indeks adalah - 1 i. e. Digit adalah dalam urutan yang semakin meningkat. ; Menukar kedua -dua nilai; swap (str [index], str [smallgreatdgt]); ; Kod pemacu", "code": "< ? php function prevNum ( $ str ) { $ len = strlen ( $ str ) ; $ index = -1 ; for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] > $ str [ $ i + 1 ] ) { $ index = $ i ; break ; } } $ smallGreatDgt = -1 ; for ( $ i = $ len - 1 ; $ i > $ index ; $ i -- ) { if ( $ str [ $ i ] < $ str [ $ index ] ) { if ( $ smallGreatDgt == -1 ) $ smallGreatDgt = $ i ; else if ( $ str [ $ i ] >= $ str [ $ smallGreatDgt ] ) $ smallGreatDgt = $ i ; } } if ( $ index == -1 ) return \" - 1\" ; if ( $ smallGreatDgt != -1 ) { list ( $ str [ $ index ] , $ str [ $ smallGreatDgt ] ) = array ( $ str [ $ smallGreatDgt ] , $ str [ $ index ] ) ; return $ str ; } return \" - 1\" ; } $ str = \"34125\" ; echo prevNum ( $ str ) ; ? >"}
{"text": "SGN Nilai polinomial | Pulangan nilai poli [0] x (n - 1) + poli [1] x (n - 2) +. . + poli [n - 1]; Memulakan hasil; Menilai nilai polinomial menggunakan kaedah Horner; Mengembalikan nilai tanda polinomial; Marilah kita menilai nilai 2 x3 - 6 x2 + 2 x - 1 untuk x = 3", "code": "< ? php function horner ( $ poly , $ n , $ x ) { $ result = $ poly [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ result = $ result * $ x + $ poly [ $ i ] ; return $ result ; } function findSign ( $ poly , $ n , $ x ) { $ result = horner ( $ poly , $ n , $ x ) ; if ( $ result > 0 ) return 1 ; else if ( $ result < 0 ) return -1 ; return 0 ; } $ poly = array ( 2 , -6 , 2 , -1 ) ; $ x = 3 ; $ n = count ( $ poly ) ; echo \" Sign ▁ of ▁ polynomial ▁ is ▁ \" , findSign ( $ poly , $ n , $ x ) ; ? >"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program PHP untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; berfungsi untuk mengira prima menggunakan ayak eratosthenes; Cari nombor perdana lebih besar daripada nombor; Untuk mengembalikan nombor perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Panggil Sieveoferatostheneses untuk mengira prima; Untuk mencari jumlah elemen array; Untuk mencari nombor perdana yang lebih besar maka jumlahnya; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "< ? php $ MAX = 100005 ; function sieveOfEratostheneses ( ) { $ isPrime = array_fill ( true , $ MAX , NULL ) ; $ isPrime [ 1 ] = false ; for ( $ i = 2 ; $ i * $ i < $ MAX ; $ i ++ ) { if ( $ isPrime [ $ i ] ) { for ( $ j = 2 * $ i ; $ j < $ MAX ; $ j += $ i ) $ isPrime [ $ j ] = false ; } } } function findPrime ( $ n ) { $ num = $ n + 1 ; while ( $ num ) { if ( $ isPrime [ $ num ] ) return $ num ; $ num = $ num + 1 ; } return 0 ; } function minNumber ( & $ arr , $ n ) { sieveOfEratostheneses ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( $ isPrime [ $ sum ] ) return 0 ; $ num = findPrime ( $ sum ) ; return $ num - $ sum ; } $ arr = array ( 2 , 4 , 6 , 8 , 12 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo minNumber ( $ arr , $ n ) ; return 0 ; ? >"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Mengira jumlah semua sub - array; Pilih titik permulaan; Memilih titik akhir; jumlah subarray antara titik permulaan dan akhir semasa; Kod pemacu", "code": "< ? php function SubArraySum ( $ arr , $ n ) { $ result = 0 ; $ temp = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ temp += $ arr [ $ j ] $ result += $ temp ; } } return $ result ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum ▁ of ▁ SubArray ▁ : ▁ \" , SubArraySum ( $ arr , $ n ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program PHP untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Kod pemacu", "code": "< ? php function highestPowerof2 ( $ n ) { $ p = ( int ) log ( $ n , 2 ) ; return ( int ) pow ( 2 , $ p ) ; } $ n = 10 ; echo highestPowerof2 ( $ n ) ; ? >"}
{"text": "Cari (a ^ b) % m di mana 'a' sangat besar | fungsi utiliti untuk mengira % m; (S [i] - '0') memberikan nilai digit dan membentuk nombor; Pulangan mencari (a ^ b) % m; Cari % m; Sekarang kalikan Ans dengan b - 1 kali dan ambil mod dengan m; Kod pemacu", "code": "< ? php function aModM ( $ s , $ mod ) { $ number = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ number = ( $ number * 10 + ( $ s [ $ i ] - '0' ) ) ; $ number %= $ mod ; } return $ number ; } function ApowBmodM ( $ a , $ b , $ m ) { $ ans = aModM ( $ a , $ m ) ; $ mul = $ ans ; for ( $ i = 1 ; $ i < $ b ; $ i ++ ) $ ans = ( $ ans * $ mul ) % $ m ; return $ ans ; } $ a = \"987584345091051645734583954832576\" ; $ b = 3 ; $ m = 11 ; echo ApowBmodM ( $ a , $ b , $ m ) ; return 0 ; ? >"}
{"text": "Sieve of Sundaram untuk mencetak semua prima yang lebih kecil daripada n | Mencetak semua nombor perdana yang lebih kecil; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima lebih kecil daripada N, kita mengurangkan N hingga separuh; Memulakan semua elemen sebagai tidak ditandakan; Logik utama Sundaram. Tandakan semua nombor bentuk i + j + 2 ij sebagai benar di mana 1 <= i <= j; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Kod pemacu", "code": "< ? php function SieveOfSundaram ( $ n ) { $ nNew = ( $ n - 1 ) / 2 ; $ marked = array_fill ( 0 , ( $ nNew + 1 ) , false ) ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) for ( $ j = $ i ; ( $ i + $ j + 2 * $ i * $ j ) <= $ nNew ; $ j ++ ) $ marked [ $ i + $ j + 2 * $ i * $ j ] = true ; if ( $ n > 2 ) echo \"2 ▁ \" ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) if ( $ marked [ $ i ] == false ) echo ( 2 * $ i + 1 ) . \" ▁ \" ; } $ n = 20 ; SieveOfSundaram ( $ n ) ; ? >"}
{"text": "Hamming jarak antara dua bilangan bulat | Fungsi untuk mengira jarak Hamming; Kod pemacu", "code": "< ? php function hammingDistance ( $ n1 , $ n2 ) { $ x = $ n1 ^ $ n2 ; $ setBits = 0 ; while ( $ x > 0 ) { $ setBits += $ x & 1 ; $ x >>= 1 ; } return $ setBits ; } $ n1 = 9 ; $ n2 = 14 ; echo ( hammingDistance ( 9 , 14 ) ) ; ? >"}
{"text": "Cetak bitwise dan set nombor n | berfungsi untuk mencari pendekatan naif subset bitwise; Kod pemacu", "code": "< ? php function printSubsets ( $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n & $ i ) == $ i ) echo $ i . \" \" ; } $ n = 9 ; printSubsets ( $ n ) ; ? >"}
{"text": "Cari bit set yang paling ketara | Program PHP untuk mencari nombor MSB untuk diberikan n. ; Untuk mencari kedudukan bit set yang paling penting; Untuk mengembalikan nilai nombor dengan set bit pada kedudukan k - th; Kod pemacu", "code": "< ? php function setBitNumber ( $ n ) { $ k = ( int ) ( log ( $ n , 2 ) ) ; return 1 << $ k ; } $ n = 273 ; echo setBitNumber ( $ n ) ; ? >"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Ambil input dan mulakan res = 0; Susun array; Melintasi array input dan cari kekerapan maksimum; Untuk setiap nombor mencari pengulangan / kekerapannya; Kemas kini res; Kod pemacu", "code": "< ? php function subset ( $ ar , $ n ) { $ res = 0 ; sort ( $ ar ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; for ( ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ count ++ ; else break ; } $ res = max ( $ res , $ count ) ; } return $ res ; } $ arr = array ( 5 , 6 , 9 , 3 , 4 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; echo subset ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Susun array; Selepas menyusun, periksa sama ada elemen semasa sama seperti sebelumnya atau satu lagi. ; Kod pemacu", "code": "< ? php function areElementsContiguous ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] > 1 ) return false ; return true ; } $ arr = array ( 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ) ; $ n = sizeof ( $ arr ) ; if ( areElementsContiguous ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | berfungsi untuk mencari d terbesar; Susun array dalam urutan menaik; melangkah dari belakang untuk mencari D terbesar yang diperlukan; Oleh kerana semua empat A, B, C, D harus berbeza; Jika kombinasi semasa J, K, L dalam set adalah sama dengan S [i] mengembalikan nilai ini kerana ini akan menjadi d terbesar kerana kita melelehkan dalam urutan menurun; Kod pemacu", "code": "< ? php function findLargestd ( $ S , $ n ) { $ found = false ; sort ( $ S ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) continue ; for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ i == $ k ) continue ; for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( $ i == $ l ) continue ; if ( $ S [ $ i ] == $ S [ $ j ] + $ S [ $ k ] + $ S [ $ l ] ) { $ found = true ; return $ S [ $ i ] ; } } } } } if ( $ found == false ) return PHP_INT_MIN ; } $ S = array ( 2 , 3 , 5 , 7 , 12 ) ; $ n = count ( $ S ) ; $ ans = findLargestd ( $ S , $ n ) ; if ( $ ans == PHP_INT_MIN ) echo \" No ▁ Solution \" ; else echo \" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + ▁ \" , \" c ▁ = ▁ d ▁ is ▁ \" , $ ans ; ? >"}
{"text": "Program untuk Putaran Array | Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar arr [] saiz n oleh d; fungsi utiliti untuk mencetak array; Kod pemacu", "code": "< ? php function leftRotatebyOne ( & $ arr , $ n ) { $ temp = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ arr [ $ i ] = $ arr [ $ i + 1 ] ; $ arr [ $ n - 1 ] = $ temp ; } function leftRotate ( & $ arr , $ d , $ n ) { for ( $ i = 0 ; $ i < $ d ; $ i ++ ) leftRotatebyOne ( $ arr , $ n ) ; } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; $ n = sizeof ( $ arr ) ; leftRotate ( $ arr , 2 , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Susun array dalam julat indeks yang diberikan |  ; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Arahan sementara; Susun array sementara; Mengubah suai array asal dengan elemen array sementara; Cetak array yang diubah suai; Kod pemacu; panjang array", "code": "< ? php < ? php # PHP  program to sort the NEW_LINE # array  in a given index range NEW_LINE function partSort ( $ arr , $ N , $ a , $ b ) { $ l = min ( $ a , $ b ) ; $ r = max ( $ a , $ b ) ; $ temp = array ( ) ; $ j = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ temp [ $ j ] = $ arr [ $ i ] ; $ j ++ ; } sort ( $ temp ) ; $ j = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ arr [ $ i ] = $ temp [ $ j ] ; $ j ++ ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { echo $ arr [ $ i ] . \" \" ; } } $ arr = array ( 7 , 8 , 4 , 5 , 2 ) ; $ a = 1 ; $ b = 4 ; $ N = count ( $ arr ) ; partSort ( $ arr , $ N , $ a , $ b ) ; ? >"}
{"text": "Pindahkan semua sifar ke hujung array | Fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; Kod pemacu", "code": "< ? php function pushZerosToEnd ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != 0 ) $ arr [ $ count ++ ] = $ arr [ $ i ] ; while ( $ count < $ n ) $ arr [ $ count ++ ] = 0 ; } $ arr = array ( 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ) ; $ n = sizeof ( $ arr ) ; pushZerosToEnd ( $ arr , $ n ) ; echo \" Array ▁ after ▁ pushing ▁ all ▁ \" . \" zeros ▁ to ▁ end ▁ of ▁ array ▁ : STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Fungsi utiliti untuk mencetak pelbagai saiz n; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Jika elemen semasa positif tidak melakukan apa -apa; Jika elemen semasa adalah negatif, pergeseran elemen positif ARR [0. i - 1], ke satu kedudukan di sebelah kanan mereka; Letakkan elemen negatif pada kedudukan yang betul; Program Pemandu", "code": "< ? php function printArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ $ i ] . \" ▁ \" ) ; } function RearrangePosNeg ( & $ arr , $ n ) { $ key ; $ j ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ key = $ arr [ $ i ] ; if ( $ key > 0 ) continue ; $ j = $ i - 1 ; while ( $ j >= 0 && $ arr [ $ j ] > 0 ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j = $ j - 1 ; } $ arr [ $ j + 1 ] = $ key ; } } { $ arr = array ( -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 ) ; $ n = sizeof ( $ arr ) ; RearrangePosNeg ( $ arr , $ n ) ; printArray ( $ arr , $ n ) ; }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program PHP mudah untuk mencari semua elemen dalam pelbagai yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Pilih elemen satu demi satu dan hitung elemen yang lebih besar. Jika kiraan lebih daripada 2, cetak elemen itu. ; Kod pemacu", "code": "< ? php function findElements ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] > $ arr [ $ i ] ) $ count ++ ; if ( $ count >= 2 ) echo $ arr [ $ i ] . \" ▁ \" ; } } $ arr = array ( 2 , -6 , 3 , 5 , 1 ) ; $ n = sizeof ( $ arr ) ; findElements ( $ arr , $ n ) ; ? >"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program PHP berasaskan menyusun untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Kod pemacu", "code": "< ? php function findElements ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 2 , -6 , 3 , 5 , 1 ) ; $ n = count ( $ arr ) ; findElements ( $ arr , $ n ) ; ? > ;"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program PHP untuk mencari semua elemen dalam pelbagai yang mempunyai dua elemen yang lebih besar sendiri. ; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "< ? php function findElements ( $ arr , $ n ) { $ first = PHP_INT_MIN ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second ) $ second = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ second ) echo $ arr [ $ i ] , \" ▁ \" ; } $ arr = array ( 2 , -6 , 3 , 5 , 1 ) ; $ n = count ( $ arr ) ; findElements ( $ arr , $ n ) ; ? >"}
{"text": "Cari nombor yang paling kecil | Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; Kod pemacu", "code": "< ? php function findFirstMissing ( $ array , $ start , $ end ) { if ( $ start > $ end ) return $ end + 1 ; if ( $ start != $ array [ $ start ] ) return $ start ; $ mid = ( $ start + $ end ) / 2 ; if ( $ array [ $ mid ] == $ mid ) return findFirstMissing ( $ array , $ mid + 1 , $ end ) ; return findFirstMissing ( $ array , $ start , $ mid ) ; } $ arr = array ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ) ; $ n = count ( $ arr ) ; echo \" Smallest ▁ missing ▁ element ▁ is ▁ \" , findFirstMissing ( $ arr , 2 , $ n - 1 ) ; ? >"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan | Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i; Max semasa termasuk i; kembali max incl and excl; Kod pemacu", "code": "< ? php function FindMaxSum ( $ arr , $ n ) { $ incl = $ arr [ 0 ] ; $ excl = 0 ; $ excl_new ; $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = ( $ incl > $ excl ) ? $ incl : $ excl ; $ incl = $ excl + $ arr [ $ i ] ; $ excl = $ excl_new ; } return ( ( $ incl > $ excl ) ? $ incl : $ excl ) ; } $ arr = array ( 5 , 5 , 10 , 100 , 10 , 5 ) ; $ n = sizeof ( $ arr ) ; echo FindMaxSum ( $ arr , $ n ) ; ? >"}
{"text": "Cari subarray purata maksimum K panjang | Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Buat dan isi array untuk menyimpan jumlah kumulatif. csum [i] menyimpan jumlah arr [0] ke arr [i]; Memulakan max_sm sebagai jumlah subarray pertama; Cari jumlah subarray lain dan kemas kini max_sum jika diperlukan. ; Indeks permulaan kembali; Kod pemacu", "code": "< ? php function findMaxAverage ( $ arr , $ n , $ k ) { if ( $ k > $ n ) return -1 ; $ csum = array ( ) ; $ csum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ csum [ $ i ] = $ csum [ $ i - 1 ] + $ arr [ $ i ] ; $ max_sum = $ csum [ $ k - 1 ] ; $ max_end = $ k - 1 ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum = $ csum [ $ i ] - $ csum [ $ i - $ k ] ; if ( $ curr_sum > $ max_sum ) { $ max_sum = $ curr_sum ; $ max_end = $ i ; } } return $ max_end - $ k + 1 ; } $ arr = array ( 1 , 12 , -5 , -6 , 50 , 3 ) ; $ k = 4 ; $ n = count ( $ arr ) ; echo \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ \" , \" length ▁ \" , $ k , \" ▁ begins ▁ at ▁ index ▁ \" , findMaxAverage ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Cari subarray purata maksimum K panjang | Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Mengira jumlah elemen 'k' pertama; Mengira jumlah subarray yang tinggal; Indeks permulaan kembali; Kod pemacu", "code": "< ? php function findMaxAverage ( $ arr , $ n , $ k ) { if ( $ k > $ n ) return -1 ; $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ k ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ max_sum = $ sum ; $ max_end = $ k - 1 ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ sum > $ max_sum ) { $ max_sum = $ sum ; $ max_end = $ i ; } } return $ max_end - $ k + 1 ; } $ arr = array ( 1 , 12 , -5 , -6 , 50 , 3 ) ; $ k = 4 ; $ n = count ( $ arr ) ; echo \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ \" , \" length ▁ \" , $ k , \" ▁ begins ▁ at ▁ index ▁ \" , findMaxAverage ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program PHP untuk memeriksa elemen majoriti dalam fungsi array yang disusun mengembalikan elemen majoriti dalam array yang disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Kod pemacu", "code": "< ? php function isMajority ( $ arr , $ n , $ x ) { $ i ; $ last_index = $ n % 2 ? ( $ n / 2 + 1 ) : ( $ n / 2 ) ; for ( $ i = 0 ; $ i < $ last_index ; $ i ++ ) { if ( $ arr [ $ i ] == $ x && $ arr [ $ i + $ n / 2 ] == $ x ) return 1 ; } return 0 ; } $ arr = array ( 1 , 2 , 3 , 4 , 4 , 4 , 4 ) ; $ n = sizeof ( $ arr ) ; $ x = 4 ; if ( isMajority ( $ arr , $ n , $ x ) ) echo $ x , \" ▁ appears ▁ more ▁ than ▁ \" , floor ( $ n / 2 ) , \" ▁ times ▁ in ▁ arr [ ] \" ; else echo $ x , \" does ▁ not ▁ appear ▁ more ▁ than ▁ \" , floor ( $ n / 2 ) , \" times ▁ in ▁ arr [ ] \" ; ? >"}
{"text": "Memotong batang | DP | Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function cutRod ( $ price , $ n ) { $ val = array ( ) ; $ val [ 0 ] = 0 ; $ i ; $ j ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ max_val = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ max_val = max ( $ max_val , $ price [ $ j ] + $ val [ $ i - $ j - 1 ] ) ; $ val [ $ i ] = $ max_val ; } return $ val [ $ n ] ; } $ arr = array ( 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ) ; $ size = count ( $ arr ) ; echo \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" , cutRod ( $ arr , $ size ) ; ? >"}
{"text": "Kira bilangan prima dalam array jumlah awalan array yang diberikan | Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari semua prima di arr []; Berfungsi untuk menghasilkan array awalan; Isi array awalan; Kod pemacu; Arahan awalan arr []; Count of Prima dalam Array Awalan", "code": "< ? php function primeCount ( $ arr , $ n ) { $ max_val = max ( $ arr ) ; $ prime = array_fill ( 0 , $ max_val + 1 , true ) ; $ prime [ 0 ] = false ; $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ max_val ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ max_val ; $ i += $ p ) $ prime [ $ i ] = false ; } } $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ prime [ $ arr [ $ i ] ] ) $ count ++ ; return $ count ; } function getPrefixArray ( $ arr , $ n , $ pre ) { $ pre [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ pre [ $ i ] = $ pre [ $ i - 1 ] + $ arr [ $ i ] ; } return $ pre ; } $ arr = array ( 1 , 4 , 8 , 4 ) ; $ n = count ( $ arr ) ; $ pre = array ( ) ; $ pre = getPrefixArray ( $ arr , $ n , $ pre ) ; echo primeCount ( $ pre , $ n ) ; ? >"}
{"text": "Nilai minimum yang akan ditambah kepada x supaya sekurang -kurangnya y peratus daripada n | Fungsi untuk mengembalikan nilai yang diperlukan yang mesti ditambah kepada x supaya sekurang -kurangnya y peratus daripada n; Nilai yang diperlukan; Jika x sudah> = y peratus n; Kod pemacu", "code": "< ? php function minValue ( $ n , $ x , $ y ) { $ val = ( $ y * $ n ) / 100 ; if ( $ x >= $ val ) return 0 ; else return ( ceil ( $ val ) - $ x ) ; } { $ n = 10 ; $ x = 2 ; $ y = 40 ; echo ( minValue ( $ n , $ x , $ y ) ) ; }"}
{"text": "Semak jika n adalah faktorial utama | Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah faktorial utama; Jika n tidak perdana maka kembali palsu; Hitung faktorial; Jika n adalah perdana faktorial; n bukanlah perdana faktorial; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isFactorialPrime ( $ n ) { if ( ! isPrime ( $ n ) ) return false ; $ fact = 1 ; $ i = 1 ; while ( $ fact <= $ n + 1 ) { $ fact = $ fact * $ i ; if ( $ n + 1 == $ fact $ n - 1 == $ fact ) return true ; $ i ++ ; } return false ; } $ n = 23 ; if ( isFactorialPrime ( $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Susunan tempat duduk N Boys and Girls secara alternatif di sekitar meja bulat | Dapatkan n; Cari FAC1 = (n - 1)! ; Cari FAC2 = N! ; Cari jumlah cara; Cetak jumlah cara", "code": "< ? php $ n = 5 ; $ fac1 = 1 ; for ( $ i = 2 ; $ i <= $ n - 1 ; $ i ++ ) $ fac1 = $ fac1 * $ i ; $ fac2 = $ fac1 * $ n ; $ totalWays = $ fac1 * $ fac2 ; echo $ totalWays . \" STRNEWLINE \" ;"}
{"text": "Cube sempurna lebih besar daripada nombor tertentu | Berfungsi untuk mencari kiub sempurna seterusnya; Kod pemacu", "code": "< ? php function nextPerfectCube ( $ N ) { $ nextN = ( int ) ( floor ( pow ( $ N , ( 1 / 3 ) ) ) + 1 ) ; return $ nextN * $ nextN * $ nextN ; } $ n = 35 ; print ( nextPerfectCube ( $ n ) ) ; ? >"}
{"text": "Kedudukan N di antara nombor yang diperbuat daripada 2, 3, 5 & 7 | Kedudukan program PHP N di antara nombor yang diperbuat daripada 2, 3, 5 & 7; Jika nombor adalah 2 maka ia berada di kedudukan pos * 2 + 1; Jika nombor adalah 3 maka ia berada di kedudukan pos * 2 + 2; Jika nombor adalah 5 maka ia berada di kedudukan pos * 2 + 3; Jika nombor adalah 7 maka ia berada di kedudukan pos * 2 + 4; Kod pemacu", "code": "< ? php function findpos ( $ n ) { $ pos = 0 ; for ( $ i = 0 ; isset ( $ n [ $ i ] ) != NULL ; $ i ++ ) { switch ( $ n [ $ i ] ) { case '2' : $ pos = $ pos * 4 + 1 ; break ; case '3' : $ pos = $ pos * 4 + 2 ; break ; case '5' : $ pos = $ pos * 4 + 3 ; break ; case '7' : $ pos = $ pos * 4 + 4 ; break ; } } return $ pos ; } $ n = \"777\" ; echo findpos ( $ n ) ; ? >"}
{"text": "Count n digit nombor tidak mempunyai digit tertentu | Pelaksanaan PHP kaedah di atas; Mencari bilangan nombor yang mungkin dengan digit N tidak termasuk digit tertentu; Memeriksa jika bilangan digit adalah sifar; Memeriksa jika bilangan digit adalah satu; Memeriksa jika bilangan digit adalah ganjil; Memanggil fungsi digitNumber dengan (digit - 1) / 2 digit; ; Memanggil fungsi digitnumber dengan n / 2 digit; Memanggil fungsi DigitNumber Memeriksa jika tidak termasuk digit adalah sifar atau bukan sifar; Memulakan pembolehubah", "code": "< ? php $ mod = 1000000007 ; function digitNumber ( $ n ) { global $ mod ; if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 9 ; if ( $ n % 2 != 0 ) { $ temp = digitNumber ( ( $ n - 1 ) / 2 ) % $ mod ; return ( 9 * ( $ temp * $ temp ) % $ mod ) % $ mod ; } else { $ temp = digitNumber ( $ n / 2 ) % $ mod ; return ( $ temp * $ temp ) % $ mod ; } } function countExcluding ( $ n , $ d ) { global $ mod ; if ( $ d == 0 ) return ( 9 * digitNumber ( $ n - 1 ) ) % $ mod ; else return ( 8 * digitNumber ( $ n - 1 ) ) % $ mod ; } $ d = 9 ; $ n = 3 ; print ( countExcluding ( $ n , $ d ) ) ; ? >"}
{"text": "Semak jika nombor yang diberikan adalah nombor emirp atau tidak | Pulangan benar jika n adalah perdana lain palsu; Kes sudut; Semak dari 2 hingga n - 1; Fungsi akan memeriksa sama ada nombor adalah emirp atau tidak; Semak jika n adalah perdana; Cari terbalik n; Jika kedua -dua asal dan terbalik adalah perdana, maka ia adalah nombor emirp; Nombor input", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return -1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return -1 ; return 1 ; } function isEmirp ( $ n ) { if ( isPrime ( $ n ) == -1 ) return -1 ; $ rev = 0 ; while ( $ n != 0 ) { $ d = $ n % 10 ; $ rev = $ rev * 10 + $ d ; $ n /= 10 ; } return isPrime ( $ rev ) ; } $ n = 13 ; if ( isEmirp ( $ n ) == -1 ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk menukar radian ke ijazah | Fungsi untuk penukaran; Kod pemacu", "code": "< ? php function Convert ( $ radian ) { $ pi = 3.14159 ; return ( $ radian * ( 180 / $ pi ) ) ; } $ radian = 5.0 ; $ degree = Convert ( $ radian ) ; echo ( $ degree ) ; ? >"}
{"text": "Cari jejak matriks yang dibentuk dengan menambah baris | Kembali jumlah integer pertama A AP; Kembalikan jejak jumlah baris - matriks utama dan lajur - matriks utama; Mencari elemen ke dalam AP sekiranya matriks utama baris. ; Mencari jumlah integer pertama AP dalam kes matriks utama baris; Mencari elemen ke dalam AP sekiranya matriks utama baris; Mencari jumlah integer pertama AP dalam kes matriks utama lajur; Kod pemacu", "code": "< ? php function sn ( $ n , $ an ) { return ( $ n * ( 1 + $ an ) ) / 2 ; } function trace ( $ n , $ m ) { $ an = 1 + ( $ n - 1 ) * ( $ m + 1 ) ; $ rowmajorSum = sn ( $ n , $ an ) ; $ an = 1 + ( $ n - 1 ) * ( $ n + 1 ) ; $ colmajorSum = sn ( $ n , $ an ) ; return $ rowmajorSum + $ colmajorSum ; } $ N = 3 ; $ M = 3 ; echo trace ( $ N , $ M ) , \" STRNEWLINE \" ; ? >"}
{"text": "Maksimum kawasan yang paling kecil yang boleh diperoleh dengan tepat K yang diberikan segi empat tepat | Fungsi utiliti; untuk kes 1 st; untuk kes kedua; Hasil akhir cetak; Kod pemacu", "code": "< ? php function max_area ( $ n , $ m , $ k ) { if ( $ k > ( $ n + $ m - 2 ) ) echo \" Not ▁ possible \" , \" STRNEWLINE \" ; else { $ result ; if ( $ k < max ( $ m , $ n ) - 1 ) { $ result = max ( $ m * ( $ n / ( $ k + 1 ) ) , $ n * ( $ m / ( $ k + 1 ) ) ) ; } else { $ result = max ( $ m / ( $ k - $ n + 2 ) , $ n / ( $ k - $ m + 2 ) ) ; } echo $ result , \" STRNEWLINE \" ; } } $ n = 3 ; $ m = 4 ; $ k = 1 ; max_area ( $ n , $ m , $ k ) ; ? >"}
{"text": "Program untuk mencari kawasan persegi | berfungsi untuk mencari kawasan; Program Pemandu", "code": "< ? php function area_fun ( $ side ) { $ area = $ side * $ side ; return $ area ; } $ side = 4 ; $ area = area_fun ( $ side ) ; echo ( $ area ) ; ? >"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah nombor berturut -turut | Kaedah utiliti untuk mengira bilangan cara di mana n boleh diwakili sebagai jumlah nombor berturut -turut; Kekangan pada nilai L memberi kita kerumitan masa sebagai O (n ^ 0.5); Kod pemacu", "code": "< ? php function countConsecutive ( $ N ) { $ count = 0 ; for ( $ L = 1 ; $ L * ( $ L + 1 ) < 2 * $ N ; $ L ++ ) { $ a = ( int ) ( 1.0 * $ N - ( $ L * ( int ) ( $ L + 1 ) ) / 2 ) / ( $ L + 1 ) ; if ( $ a - ( int ) $ a == 0.0 ) $ count ++ ; } return $ count ; } $ N = 15 ; echo countConsecutive ( $ N ) , \" STRNEWLINE \" ; $ N = 10 ; echo countConsecutive ( $ N ) , \" STRNEWLINE \" ; ? >"}
{"text": "Nombor Automorphic | Berfungsi untuk memeriksa nombor automorphic; Simpan dataran; Mula membandingkan digit; Kembali palsu, jika mana -mana digit dari n tidak sesuai dengan angka -angka yang terakhir; Mengurangkan N dan persegi; Kod pemacu", "code": "< ? php function isAutomorphic ( $ N ) { $ sq = $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ sq % 10 ) return -1 ; $ N /= 10 ; $ sq /= 10 ; } return 1 ; } $ N = 5 ; $ geeks = isAutomorphic ( $ N ) ? \" Automorphic \" : \" Not ▁ Automorphic \" ; echo $ geeks ; ? >"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Nilai lalai boolean adalah palsu; Ayak eratosthenes; Menyimpan nombor perdana. ; Nombor penjanaan yang mempunyai faktor utama maksimum. ; Kod pemacu", "code": "< ? php function maxPrimefactorNum ( $ N ) { $ arr = array_fill ( 0 , $ N + 5 , true ) ; for ( $ i = 3 ; $ i * $ i <= $ N ; $ i += 2 ) { if ( $ arr [ $ i ] ) for ( $ j = $ i * $ i ; $ j <= $ N ; $ j += $ i ) $ arr [ $ j ] = false ; } $ prime = array ( ) ; array_push ( $ prime , 2 ) ; for ( $ i = 3 ; $ i <= $ N ; $ i += 2 ) if ( $ arr [ $ i ] ) array_push ( $ prime , $ i ) ; $ i = 0 ; $ ans = 1 ; while ( $ ans * $ prime [ $ i ] <= $ N && $ i < count ( $ prime ) ) { $ ans *= $ prime [ $ i ] ; $ i ++ ; } return $ ans ; } $ N = 40 ; print ( maxPrimefactorNum ( $ N ) ) ; ? >"}
{"text": "Jumlah semua pembahagi yang betul dari nombor semulajadi | Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Kod pemacu", "code": "< ? php function divSum ( $ num ) { $ result = 0 ; for ( $ i = 2 ; $ i <= sqrt ( $ num ) ; $ i ++ ) { if ( $ num % $ i == 0 ) { if ( $ i == ( $ num / $ i ) ) $ result += $ i ; else $ result += ( $ i + $ num / $ i ) ; } } return ( $ result + 1 ) ; } $ num = 36 ; echo ( divSum ( $ num ) ) ; ? >"}
{"text": "Cari akar persegi di bawah modulo p | Tetapkan 1 (apabila p dalam bentuk 4 * i + 3) | Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p. ; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y / 2; Pulangan benar jika akar kuadrat n di bawah modulo p ada asumsi: p adalah bentuk 3 * i + 4 di mana i> = 1; Cuba \" + (n ^ ((p ~ ~ 1) / 4))\"; Cuba \" - (n '((p ~ ~ 1) / 4))\"; Sekiranya tiada dua kerja di atas, maka akar persegi tidak wujud; Kod pemacu", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ y = $ y >> 1 ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function squareRoot ( $ n , $ p ) { if ( $ p % 4 != 3 ) { echo \" Invalid ▁ Input \" ; return ; } $ n = $ n % $ p ; $ x = power ( $ n , ( $ p + 1 ) / 4 , $ p ) ; if ( ( $ x * $ x ) % $ p == $ n ) { echo \" Square ▁ root ▁ is ▁ \" , $ x ; return ; } $ x = $ p - $ x ; if ( ( $ x * $ x ) % $ p == $ n ) { echo \" Square ▁ root ▁ is ▁ \" , $ x ; return ; } echo \" Square ▁ root ▁ doesn ' t ▁ exist ▁ \" ; } $ p = 7 ; $ n = 2 ; squareRoot ( $ n , $ p ) ; ? >"}
{"text": "Ujian Primal | Tetapkan 3 (Millerâ € \"Rabin) | fungsi utiliti untuk melakukan eksponensi modular. adalah nombor ganjil seperti d * 2 < / sup> = n - 1 untuk beberapa r> = 1; pulangan jika n adalah komposit dan pulangan benar jika n adalah prime.", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function miillerTest ( $ d , $ n ) { $ a = 2 + rand ( ) % ( $ n - 4 ) ; $ x = power ( $ a , $ d , $ n ) ; if ( $ x == 1 $ x == $ n - 1 ) return true ; while ( $ d != $ n - 1 ) { $ x = ( $ x * $ x ) % $ n ; $ d *= 2 ; if ( $ x == 1 ) return false ; if ( $ x == $ n - 1 ) return true ; } return false ; } function isPrime ( $ n , $ k ) { if ( $ n <= 1 $ n == 4 ) return false ; if ( $ n <= 3 ) return true ; $ d = $ n - 1 ; while ( $ d % 2 == 0 ) $ d /= 2 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( ! miillerTest ( $ d , $ n ) ) return false ; return true ; } $ k = 4 ; echo \" All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ STRNEWLINE \" ; for ( $ n = 1 ; $ n < 100 ; $ n ++ ) if ( isPrime ( $ n , $ k ) ) echo $ n , \" ▁ \" ; ? >"}
{"text": "Panjang paling lama berturut -turut 1 s dalam perwakilan binari | Berfungsi untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor; Memulakan hasil; Kira bilangan lelaran untuk mencapai x = 0 .; Operasi ini mengurangkan panjang setiap urutan 1 s dengan satu. ; Kod pemacu", "code": "< ? php function maxConsecutiveOnes ( $ x ) { $ count = 0 ; while ( $ x != 0 ) { $ x = ( $ x & ( $ x << 1 ) ) ; $ count ++ ; } return $ count ; } echo maxConsecutiveOnes ( 14 ) , \" STRNEWLINE \" ; echo maxConsecutiveOnes ( 222 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program PHP untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu", "code": "< ? php function subtract ( $ x , $ y ) { while ( $ y != 0 ) { $ borrow = ( ~ $ x ) & $ y ; $ x = $ x ^ $ y ; $ y = $ borrow << 1 ; } return $ x ; } $ x = 29 ; $ y = 13 ; echo \" x ▁ - ▁ y ▁ is ▁ \" , subtract ( $ x , $ y ) ; ? >"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program PHP untuk menolak dua nombor tanpa menggunakan pelaksanaan rekursif pengendali aritmetik. ; Kod pemacu", "code": "< ? php function subtract ( $ x , $ y ) { if ( $ y == 0 ) return $ x ; return subtract ( $ x ^ $ y , ( ~ $ x & $ y ) << 1 ) ; } $ x = 29 ; $ y = 13 ; echo \" x ▁ - ▁ y ▁ is ▁ \" , subtract ( $ x , $ y ) ; # This  code is contributed by ajit NEW_LINE ? >"}
{"text": "Bilangan cara untuk memilih pasangan yang mengandungi nombor yang lebih dan ganjil dari 1 hingga n | Kod pemacu", "code": "< ? php $ N = 6 ; $ Even = $ N / 2 ; $ Odd = $ N - $ Even ; echo $ Even * $ Odd ; ? >"}
{"text": "Program untuk mencetak corak langkah | berfungsi untuk mencetak langkah -langkah; mengisytiharkan bendera; melintasi semua watak dalam rentetan; Jika nilai x ialah 0 .. Kemudian kita mesti kenaikan sehingga n ... Tetapkan bendera kepada Benar; Jika nilai x adalah n - 1 maka kita mesti menurunkan sehingga 0 ... Tetapkan bendera sebagai palsu; cetak x * s; memeriksa sama ada untuk kenaikan atau penurunan x; Dapatkan rentetan dan nombor n; memanggil fungsi", "code": "< ? php function steps ( $ str , $ n ) { $ x = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ x == 0 ) $ flag = true ; if ( $ x == $ n - 1 ) $ flag = false ; for ( $ j = 0 ; $ j < $ x ; $ j ++ ) echo \" * \" ; echo $ str [ $ i ] , \" STRNEWLINE \" ; if ( $ flag == true ) $ x ++ ; else $ x -- ; } } $ n = 4 ; $ str = \" GeeksForGeeks \" ; echo \" String : \" , ▁ $ str , ▁ \" \" ; STRNEWLINE echo ▁ \" Max Length of Steps : \" , ▁ $ n , ▁ \" \" steps ( $ str , $ n ) ; ? >"}
{"text": "Semak pembahagian rentetan binari dengan 2 ^ k | fungsi untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; kiraan bilangan 0 dari yang terakhir; Jika Count = k, nombor sama rata, jadi pulangan benar lain palsu; Contoh pertama; Contoh kedua", "code": "< ? php function isDivisible ( $ str , $ k ) { $ n = strlen ( $ str ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( $ str [ $ n - $ i - 1 ] == '0' ) $ c ++ ; return ( $ c == $ k ) ; } $ str1 = \"10101100\" ; $ k = 2 ; if ( isDivisible ( $ str1 , $ k ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; $ str2 = \"111010100\" ; $ k = 2 ; if ( isDivisible ( $ str2 , $ k ) ) echo \" Yes \" , \" STRNEWLINE \" ; else echo \" No \" , \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk memeriksa sama ada input adalah integer atau rentetan | Pulangan benar jika s adalah nombor lain palsu; Menyimpan input dalam rentetan; Fungsi pulangan 1 jika semua elemen berada dalam jarak '0-9'; Fungsi pulangan 0 jika input bukan integer", "code": "< ? php function isNumber ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) if ( is_numeric ( $ s [ $ i ] ) == false ) return false ; return true ; } $ str = \"6790\" ; if ( isNumber ( $ str ) ) echo \" Integer \" ; else echo \" String \" ; ? >"}
{"text": "Cetak terbalik rentetan menggunakan rekursi | Berfungsi untuk mencetak terbalik rentetan lulus; Kod pemacu", "code": "< ? php function reverse ( $ str ) { if ( ( $ str == null ) || ( strlen ( $ str ) <= 1 ) ) echo ( $ str ) ; else { echo ( $ str [ strlen ( $ str ) - 1 ] ) ; reverse ( substr ( $ str , 0 , ( strlen ( $ str ) - 1 ) ) ) ; } } $ str = \" Geeks ▁ for ▁ Geeks \" ; reverse ( $ str ) ; ? >"}
{"text": "Kawasan n | Berfungsi untuk mencari kawasan poligon biasa; Sampingan dan jejari tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "< ? php function polyarea ( $ n , $ r ) { if ( $ r < 0 && $ n < 0 ) return -1 ; $ A = ( ( $ r * $ r * $ n ) * sin ( ( 360 / $ n ) * 3.14159 / 180 ) ) / 2 ; return $ A ; } $ r = 9 ; $ n = 6 ; echo polyarea ( $ n , $ r ) . \" STRNEWLINE \" ; ? >"}
{"text": "Cerun tegak lurus ke garisan | Berfungsi untuk mencari cerun garis lain; Kod pemacu", "code": "< ? php function findPCSlope ( $ m ) { return -1.0 / $ m ; } $ m = 2.0 ; echo findPCSlope ( $ m ) ; ? >"}
{"text": "Program untuk mencari kawasan segmen bulat | Fungsi untuk mencari kawasan segmen; Mengira kawasan sektor; Mengira kawasan segitiga; Kod pemacu", "code": "< ? php function area_of_segment ( $ radius , $ angle ) { $ pi = 3.14159 ; $ area_of_sector = $ pi * ( $ radius * $ radius ) * ( $ angle / 360 ) ; $ area_of_triangle = 1 / 2 * ( $ radius * $ radius ) * sin ( ( $ angle * $ pi ) / 180 ) ; return $ area_of_sector - $ area_of_triangle ; } $ radius = 10.0 ; $ angle = 90.0 ; echo ( \" Area ▁ of ▁ minor ▁ segment ▁ = ▁ \" ) ; echo ( area_of_segment ( $ radius , $ angle ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Area ▁ of ▁ major ▁ segment ▁ = ▁ \" ) ; echo ( area_of_segment ( $ radius , ( 360 - $ angle ) ) ) ; ? >"}
{"text": "Kawasan Sektor Pekeliling | Program PHP untuk mencari kawasan sektor; Mengira kawasan sektor; Kod pemacu", "code": "< ? php function SectorArea ( $ radius , $ angle ) { if ( $ angle >= 360 ) echo ( \" Angle ▁ not ▁ possible \" ) ; else { $ sector = ( ( 22 * $ radius * $ radius ) / 7 ) * ( $ angle / 360 ) ; echo ( $ sector ) ; } } $ radius = 9 ; $ angle = 60 ; SectorArea ( $ radius , $ angle ) ; ? >"}
{"text": "SENARAI SENSI RECURSIVE | Fungsi rekursif untuk menyusun array menggunakan jenis penyisipan; Kes asas; Susun pertama n - 1 elemen; Masukkan elemen terakhir pada kedudukan yang betul dalam array yang disusun. ; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu", "code": "< ? php function insertionSortRecursive ( & $ arr , $ n ) { if ( $ n <= 1 ) return ; insertionSortRecursive ( $ arr , $ n - 1 ) ; $ last = $ arr [ $ n - 1 ] ; $ j = $ n - 2 ; while ( $ j >= 0 && $ arr [ $ j ] > $ last ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j -- ; } $ arr [ $ j + 1 ] = $ last ; } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; } $ arr = array ( 12 , 11 , 13 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; insertionSortRecursive ( $ arr , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Semak jika array adalah array gelombang | Fungsi untuk memeriksa sama ada array adalah array gelombang arr: array input n: saiz array; Semak borang gelombang * jika arr [1] lebih besar daripada corak kiri dan kanan * yang sama akan diikuti oleh seluruh elemen *, corak terbalik lain * akan diikuti oleh unsur -unsur array; Semak elemen terakhir; Semak elemen terakhir; Array", "code": "< ? php function isWaveArray ( $ arr , $ n ) { $ result = true ; if ( $ arr [ 1 ] > $ arr [ 0 ] && $ arr [ 1 ] > $ arr [ 2 ] ) { for ( $ i = 1 ; $ i < ( $ n - 1 ) ; $ i += 2 ) { if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] && $ arr [ $ i ] > $ arr [ $ i + 1 ] ) { $ result = true ; } else { $ result = false ; break ; } } if ( $ result == true && $ n % 2 == 0 ) { if ( $ arr [ $ n - 1 ] <= $ arr [ $ n - 2 ] ) { $ result = false ; } } } else if ( $ arr [ 1 ] < $ arr [ 0 ] && $ arr [ 1 ] < $ arr [ 2 ] ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i += 2 ) { if ( $ arr [ $ i ] < $ arr [ $ i - 1 ] && $ arr [ $ i ] < $ arr [ $ i + 1 ] ) { $ result = true ; } else { $ result = false ; break ; } } if ( $ result == true && $ n % 2 == 0 ) { if ( $ arr [ $ n - 1 ] >= $ arr [ $ n - 2 ] ) { $ result = false ; } } } return $ result ; } $ arr = array ( 1 , 3 , 2 , 4 ) ; $ n = sizeof ( $ arr ) ; if ( isWaveArray ( $ arr , $ n ) ) { echo \" YES \" ; } else { echo \" NO \" ; } ? >"}
{"text": "Cari Jumlah Nombor Fibonacci Pertama N yang pertama | Program PHP untuk mencari jumlah nombor Fibonacci yang pertama; Fungsi untuk mengira jumlah nombor Fibonacci yang pertama; nilai asas; Kod pemacu", "code": "< ? php $ mod = 1000000007 ; function sumOddFibonacci ( $ n ) { global $ mod ; $ Sum [ $ n + 1 ] = array ( ) ; $ Sum [ 0 ] = 0 ; $ Sum [ 1 ] = 1 ; $ Sum [ 2 ] = 2 ; $ Sum [ 3 ] = 5 ; $ Sum [ 4 ] = 10 ; $ Sum [ 5 ] = 23 ; for ( $ i = 6 ; $ i <= $ n ; $ i ++ ) { $ Sum [ $ i ] = ( ( $ Sum [ $ i - 1 ] + ( 4 * $ Sum [ $ i - 2 ] ) % $ mod - ( 4 * $ Sum [ $ i - 3 ] ) % $ mod + $ mod ) % $ mod + ( $ Sum [ $ i - 4 ] - $ Sum [ $ i - 5 ] + $ mod ) % $ mod ) % $ mod ; } return $ Sum [ $ n ] ; } $ n = 6 ; echo sumOddFibonacci ( $ n ) ; ? >"}
{"text": "Bilangan cara untuk mencapai lantai nth dengan mengambil di | Program PHP untuk mencapai tangga dengan mengambil maksimum l leap; unsur -unsur kombo [] menyimpan cara yang tidak mungkin untuk mencapainya dengan semua kombinasi K Leaps atau kurang; Dengan mengandaikan lompatan 0 wujud dan memberikan nilainya kepada 1 untuk pengiraan; gelung untuk melangkah ke atas semua kemungkinan melompat sehingga K; ; Dalam gelung ini kita mengira semua kemungkinan lompatan untuk mencapai tangga jth dengan bantuan lompatan atau kurang; Jika lompatan itu tidak lebih daripada i - j; Kirakan nilai dan simpan dalam combo [j] untuk menggunakannya semula untuk pengiraan lompatan seterusnya untuk tangga jth; Mengembalikan tidak ada kemungkinan lompatan untuk mencapai bahagian atas bangunan n tangga; N i tangga total k adalah nilai lompatan terbesar", "code": "< ? php function solve ( $ N , $ K ) { $ combo [ $ N + 1 ] = array ( ) ; $ combo [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ K ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ N ; $ j ++ ) { if ( $ j >= $ i ) { $ combo [ $ j ] += $ combo [ $ j - $ i ] ; } } } return $ combo [ $ N ] ; } $ N = 29 ; $ K = 5 ; echo solve ( $ N , $ K ) ; solve ( $ N , $ K ) ; ? >"}
{"text": "Cari yang paling lama meningkat seterusnya secara bulat | Fungsi utiliti untuk mencari LIS menggunakan pengaturcaraan dinamik; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Tetapkan j berdasarkan tetingkap semasa i. e. elemen pertama tetingkap semasa; Pilih maksimum semua nilai LIS; Berfungsi untuk mencari lis secara bulat; Buat salinan Array yang diberikan dengan memasuki elemen array yang sama kepada dirinya sendiri; Lakukan lis untuk setiap tetingkap saiz n; Kod pemacu", "code": "< ? php function computeLIS ( $ circBuff , $ start , $ end , $ n ) { $ LIS = Array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i ++ ) $ LIS [ $ i ] = 1 ; for ( $ i = $ start + 1 ; $ i < $ end ; $ i ++ ) for ( $ j = $ start ; $ j < $ i ; $ j ++ ) if ( $ circBuff [ $ i ] > $ circBuff [ $ j ] && $ LIS [ $ i ] < $ LIS [ $ j ] + 1 ) $ LIS [ $ i ] = $ LIS [ $ j ] + 1 ; $ res = PHP_INT_MIN ; for ( $ i = $ start ; $ i < $ end ; $ i ++ ) $ res = max ( $ res , $ LIS [ $ i ] ) ; return $ res ; } function LICS ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ circBuff [ $ i ] = $ arr [ $ i ] ; for ( $ i = $ n ; $ i < 2 * $ n ; $ i ++ ) $ circBuff [ $ i ] = $ arr [ $ i - $ n ] ; $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = max ( computeLIS ( $ circBuff , $ i , $ i + $ n , $ n ) , $ res ) ; return $ res ; } $ arr = array ( 1 , 4 , 6 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Length ▁ of ▁ LICS ▁ is ▁ \" , LICS ( $ arr , $ n ) ; ? >"}
{"text": "Susunan peningkatan yang paling lama (LCS + LIS) | Mengembalikan panjang dan LCIS dua array ARR1 [0. n - 1] dan arr2 [0 .. m - 1]; Jadual [J] akan menyimpan panjang LCI yang berakhir dengan ARR2 [J]. Kami memulakannya sebagai 0 ,; Melintasi semua elemen ARR1 []; Memulakan panjang semasa LCI; Untuk setiap elemen arr1 [], trvars semua elemen ARR2 []. ; Jika kedua -dua array mempunyai elemen yang sama. Perhatikan bahawa kami tidak memecahkan gelung di sini. ; Sekarang cari elemen umum yang lebih kecil sebelumnya untuk elemen semasa ARR1; Nilai maksimum dalam Jadual [] adalah hasil; Kod pemacu", "code": "< ? php function LCIS ( $ arr1 , $ n , $ arr2 , $ m ) { $ table = Array ( ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ table [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ arr1 [ $ i ] == $ arr2 [ $ j ] ) if ( $ current + 1 > $ table [ $ j ] ) $ table [ $ j ] = $ current + 1 ; if ( $ arr1 [ $ i ] > $ arr2 [ $ j ] ) if ( $ table [ $ j ] > $ current ) $ current = $ table [ $ j ] ; } } $ result = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ table [ $ i ] > $ result ) $ result = $ table [ $ i ] ; return $ result ; } $ arr1 = array ( 3 , 4 , 9 , 1 ) ; $ arr2 = array ( 5 , 3 , 8 , 9 , 10 , 2 , 1 ) ; $ n = sizeof ( $ arr1 ) ; $ m = sizeof ( $ arr2 ) ; echo \" Length ▁ of ▁ LCIS ▁ is ▁ \" , LCIS ( $ arr1 , $ n , $ arr2 , $ m ) ; ? >"}
{"text": "Memaksimumkan nilai A dengan menggantikan beberapa digitnya dengan digit B | Berfungsi untuk mengembalikan nilai yang dimaksimumkan A; Jenis digit dalam urutan menaik; J menunjuk kepada digit terbesar di B; Jika semua digit B telah digunakan; Digit semasa telah digunakan; Tukar array menjadi rentetan; Mengembalikan nilai yang dimaksimumkan; Kod pemacu", "code": "< ? php function maxValue ( $ a , $ b ) { sort ( $ b ) ; $ n = sizeof ( $ a ) ; $ m = sizeof ( $ b ) ; $ j = $ m - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ j < 0 ) break ; if ( $ b [ $ j ] > $ a [ $ i ] ) { $ a [ $ i ] = $ b [ $ j ] ; $ j -- ; } } $ a = implode ( \" \" , $ a ) ; return $ a ; } # convert  string into array NEW_LINE $ a = str_split ( \"1234\" ) ; $ b = str_split ( \"4321\" ) ; echo maxValue ( $ a , $ b ) ; ? >"}
{"text": "Mengira nombor dalam julat supaya digit di dalamnya dan produknya dengan Q tidak sama rata | Berfungsi untuk memeriksa sama ada semua digit dalam nombor dan produknya dengan Q tidak sama atau tidak; Tukar nombor pertama ke dalam rentetan; Masukkan elemen dari nombor 1 ke hash; Hitung produk yang sepadan; Tukar produk ke rentetan; Menggunakan Hash Check jika mana -mana digit padanan produk dengan digit nombor input; Jika ya, kembali palsu; Lain, kembali benar; Berfungsi untuk mengira nombor dalam julat [l, r] supaya semua digit nombor dan produknya dengan Q tidak sama rata; Semak setiap nombor antara L dan R; Kod pemacu; Panggilan fungsi", "code": "< ? php function checkIfUnequal ( $ n , $ q ) { $ s1 = strval ( $ n ) ; $ a = array_fill ( 0 , 26 , NULL ) ; for ( $ i = 0 ; $ i < strlen ( $ s1 ) ; $ i ++ ) $ a [ ord ( $ s1 [ $ i ] ) - ord ( '0' ) ] ++ ; $ prod = $ n * $ q ; $ s2 = strval ( $ prod ) ; for ( $ i = 0 ; $ i < strlen ( $ s2 ) ; $ i ++ ) { if ( $ a [ ord ( $ s2 [ $ i ] ) - ord ( '0' ) ] ) return false ; } return true ; } function countInRange ( $ l , $ r , $ q ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( checkIfUnequal ( $ i , $ q ) ) $ count ++ ; } return $ count ; } $ l = 10 ; $ r = 12 ; $ q = 2 ; echo countInRange ( $ l , $ r , $ q ) ; ? >"}
{"text": "Semak sama ada mungkin untuk menyusun semula rentetan binari dengan alternatif 0 s dan 1 s | berfungsi untuk memeriksa rentetan binari; panjang rentetan; Count Zero; Kira satu 's; jika panjangnya; jika panjang ganjil; Kod pemacu", "code": "< ? php function is_possible ( $ s ) { $ l = strlen ( $ s ) ; $ one = 0 ; $ zero = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) $ zero ++ ; else $ one ++ ; } if ( $ l % 2 == 0 ) return ( $ one == $ zero ) ; else return ( abs ( $ one - $ zero ) == 1 ) ; } $ s = \"100110\" ; if ( is_possible ( $ s ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Google Case Of A Sentyen tertentu | Berfungsi untuk mengeluarkan ruang dan menukar ke dalam kes unta; Semak ruang dalam ayat; penukaran ke atas kes; Jika tidak ruang, salin watak; kembali rentetan ke Main; Kod pemacu", "code": "< ? php function convert ( $ s ) { $ n = strlen ( $ s ) ; $ s [ 0 ] = strtolower ( $ s [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' ▁ ' && $ i < $ n ) { $ s [ $ i + 1 ] = strtolower ( $ s [ $ i + 1 ] ) ; $ i ++ ; } else $ s [ $ i ] = strtoupper ( $ s [ $ i ] ) ; } return $ s ; } $ str = \" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks \" ; echo ( convert ( $ str ) ) ; ? >"}
{"text": "Ubah rentetan | Fungsi untuk mengubah kes watak; Jika watak adalah perubahan huruf kecil ke huruf besar; Jika watak adalah perubahan huruf besar kepada huruf kecil; Berfungsi untuk memadam vokal; Jika watak adalah konsonan; Fungsi untuk memasukkan \" #\"; Jika watak tidak istimewa; Berfungsi untuk mengubah rentetan; Kod pemacu; Fungsi panggilan", "code": "< ? php function change_case ( $ a ) { $ l = strlen ( $ a ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ a [ $ i ] >= ' a ' && $ a [ $ i ] <= ' z ' ) $ a [ $ i ] = chr ( 65 + ( ord ( $ a [ $ i ] ) - ord ( ' a ' ) ) ) ; else if ( $ a [ $ i ] >= ' A ' && $ a [ $ i ] <= ' Z ' ) $ a [ $ i ] = chr ( 97 + ( ord ( $ a [ $ i ] ) - ord ( ' a ' ) ) ) ; } return $ a ; } function delete_vowels ( $ a ) { $ temp = \" \" ; $ l = strlen ( $ a ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ a [ $ i ] != ' a ' && $ a [ $ i ] != ' e ' && $ a [ $ i ] != ' i ' && $ a [ $ i ] != ' o ' && $ a [ $ i ] != ' u ' && $ a [ $ i ] != ' A ' && $ a [ $ i ] != ' E ' && $ a [ $ i ] != ' O ' && $ a [ $ i ] != ' U ' && $ a [ $ i ] != ' I ' ) $ temp = $ temp . $ a [ $ i ] ; } return $ temp ; } function insert_hash ( $ a ) { $ temp = \" \" ; $ l = strlen ( $ a ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( ( $ a [ $ i ] >= ' a ' && $ a [ $ i ] <= ' z ' ) || ( $ a [ $ i ] >= ' A ' && $ a [ $ i ] <= ' Z ' ) ) $ temp = $ temp . ' # ' . $ a [ $ i ] ; else $ temp = $ temp . $ a [ $ i ] ; } return $ temp ; } function transformSting ( $ a ) { $ b = delete_vowels ( $ a ) ; $ c = change_case ( $ b ) ; $ d = insert_hash ( $ c ) ; echo ( $ d ) ; } $ a = \" SunshinE ! ! \" ; transformSting ( $ a ) ; ? >"}
{"text": "Program untuk mencari n | Program PHP untuk mencari nombor N - tH yang mengandungi hanya 3 dan 5 .; Jika n adalah ganjil, tambah 3 dan pindah ke ibu bapa; Jika n adalah, tambah 5 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu", "code": "< ? php function findNthNo ( $ n ) { $ res = \" \" ; while ( $ n >= 1 ) { if ( $ n & 1 ) { $ res = $ res + \"3\" ; $ n = ( $ n - 1 ) / 2 ; } else { $ res = $ res . \"5\" ; $ n = ( $ n - 2 ) / 2 ; } } $ res = strrev ( $ res ) ; return $ res ; } $ n = 5 ; echo findNthNo ( $ n ) ; ? >"}
{"text": "Nth non | berfungsi untuk mencari nombor non non - persegi; Penukaran dari Int ke Long Double diperlukan untuk memelihara tempat perpuluhan selepas akar persegi. ; mengira hasilnya; memulakan nombor jangka panjang; Cetak hasilnya", "code": "< ? php function findNthNonSquare ( $ n ) { $ x = $ n ; $ ans = $ x + floor ( 0.5 + sqrt ( $ x ) ) ; return ( int ) $ ans ; } $ n = 16 ; echo \" The ▁ \" . $ n . \" th ▁ Non - Square ▁ number ▁ is ▁ \" ; echo findNthNonSquare ( $ n ) ;"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | fungsi untuk mengira jumlah siri; Kod pemacu", "code": "< ? php function seiresSum ( $ n , $ a ) { return $ n * ( $ a [ 0 ] * $ a [ 0 ] - $ a [ 2 * $ n - 1 ] * $ a [ 2 * $ n - 1 ] ) / ( 2 * $ n - 1 ) ; } $ n = 2 ; $ a = array ( 1 , 2 , 3 , 4 ) ; echo seiresSum ( $ n , $ a ) ; ? >"}
{"text": "Cari nombor n yang mengandungi digit k atau dibahagikan dengan k. | Fungsi untuk memeriksa jika digit k berada dalam n atau tidak; mencari selebihnya; jika digit dijumpai; Fungsi untuk mencari nombor nth; Oleh kerana k adalah yang pertama yang memenuhi kriteria, jadi pertimbangkannya dalam kiraan membuat kiraan = 1 dan bermula dari i = k + 1; Memeriksa bahawa nombor itu mengandungi k digit atau dibahagikan oleh k; Kod pemacu", "code": "< ? php function checkdigit ( $ n , $ k ) { while ( $ n ) { $ rem = $ n % 10 ; if ( $ rem == $ k ) return 1 ; $ n = $ n / 10 ; } return 0 ; } function findNthNumber ( $ n , $ k ) { for ( $ i = $ k + 1 , $ count = 1 ; $ count < $ n ; $ i ++ ) { if ( checkdigit ( $ i , $ k ) || ( $ i % $ k == 0 ) ) $ count ++ ; if ( $ count == $ n ) return $ i ; } return -1 ; } $ n = 10 ; $ k = 2 ; echo findNthNumber ( $ n , $ k ) ; ? >"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program PHP untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Memeriksa B; Memeriksa A; Kod pemacu", "code": "< ? php function middleOfThree ( $ a , $ b , $ c ) { function middleOfThree ( $ a , $ b , $ c ) { if ( ( $ a < $ b && $ b < $ c ) or ( $ c < $ b && $ b < $ a ) ) return $ b ; else if ( ( $ b < $ a and $ a < $ c ) or ( $ c < $ a and $ a < $ b ) ) return $ a ; else return $ c ; } $ a = 20 ; $ b = 30 ; $ c = 40 ; echo middleOfThree ( $ a , $ b , $ c ) ; ? >"}
{"text": "Cari kos minimum untuk mencapai destinasi menggunakan kereta api | Penyelesaian berasaskan pengaturcaraan dinamik untuk mencari kos min untuk mencapai stesen n - 1 dari stesen 0 .; Fungsi ini mengembalikan kos yang paling kecil untuk mencapai stesen n - 1 dari stesen 0 .; Dist [i] menyimpan kos minimum untuk mencapai stesen I dari stesen 0 .; Pergi melalui setiap stesen dan periksa jika menggunakannya sebagai stesen perantaraan memberikan jalan yang lebih baik; Program pemacu untuk menguji fungsi di atas", "code": "< ? php $ INF = PHP_INT_MAX ; $ N = 4 ; function minCost ( $ cost ) { global $ INF ; global $ N ; $ dist [ $ N ] = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dist [ $ i ] = $ INF ; $ dist [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ dist [ $ j ] > $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ) $ dist [ $ j ] = $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ; return $ dist [ $ N - 1 ] ; } $ cost = array ( array ( 0 , 15 , 80 , 90 ) , array ( INF , 0 , 40 , 50 ) , array ( INF , INF , 0 , 70 ) , array ( INF , INF , INF , 0 ) ) ; echo \" The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ \" , $ N , \" ▁ is ▁ \" , minCost ( $ cost ) ; ? >"}
{"text": "Bilangan gelung saiz k bermula dari nod tertentu | Kembalikan bilangan cara dari nod untuk membuat gelung saiz K dalam graf nod yang tidak disambungkan lengkap; Kod pemacu", "code": "< ? php function numOfways ( $ n , $ k ) { $ p = 1 ; if ( $ k % 2 ) $ p = -1 ; return ( pow ( $ n - 1 , $ k ) + $ p * ( $ n - 1 ) ) / $ n ; } $ n = 4 ; $ k = 2 ; echo numOfways ( $ n , $ k ) ; ? >"}
{"text": "Panjang kord bulatan yang jejari dan sudutnya diselipkan di pusat oleh kord diberikan | Berfungsi untuk mencari panjang kord; Kod pemacu", "code": "< ? php function length_of_chord ( $ r , $ x ) { echo \" The ▁ length ▁ of ▁ the ▁ chord \" , \" ▁ of ▁ the ▁ circle ▁ is ▁ \" , 2 * $ r * sin ( $ x * ( 3.14 / 180 ) ) ; } $ r = 4 ; $ x = 63 ; length_of_chord ( $ r , $ x ) ; ? >"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segitiga sama rata | Berfungsi untuk mencari kawasan dataran; A tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "< ? php function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = sqrt ( $ a ) / 6 ; return $ area ; } $ a = 10 ; echo area ( $ a ) ; ? >"}
{"text": "Panjang batang terpanjang yang boleh dimuatkan ke dalam cuboid | Berfungsi untuk mencari panjang; Pembolehubah sementara untuk memegang hasil pertengahan; Panjang rod terpanjang dikira menggunakan fungsi akar persegi; Kod pemacu; Memanggil LongeStroDincuboid () berfungsi untuk mendapatkan panjang rod terpanjang", "code": "< ? php function longestRodInCuboid ( $ length , $ breadth , $ height ) { $ result ; $ temp ; $ temp = $ length * $ length + $ breadth * $ breadth + $ height * $ height ; $ result = sqrt ( $ temp ) ; return $ result ; } $ length = 12 ; $ breadth = 9 ; $ height = 8 ; echo longestRodInCuboid ( $ length , $ breadth , $ height ) ; ? >"}
{"text": "Semak sama ada titik tertentu terletak pada atau di dalam segi empat tepat | Set 3 | berfungsi untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; Kod pemacu", "code": "< ? php function LiesInsieRectangle ( $ a , $ b , $ x , $ y ) { if ( $ x - $ y - $ b <= 0 && $ x - $ y + $ b >= 0 && $ x + $ y - 2 * $ a + $ b <= 0 && $ x + $ y - $ b >= 0 ) return true ; return false ; } $ a = 7 ; $ b = 2 ; $ x = 4 ; $ y = 5 ; if ( LiesInsieRectangle ( $ a , $ b , $ x , $ y ) ) echo \" Given ▁ point ▁ lies ▁ \" . \" inside ▁ the ▁ rectangle \" ; else echo \" Given ▁ point ▁ does ▁ not \" . \" ▁ lie ▁ on ▁ the ▁ rectangle \" ; ? >"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; untuk panjang; untuk keluasan; untuk ketinggian; Mengira isipadu maksimum. ; Kod pemacu", "code": "< ? php function maxvolume ( $ s ) { $ maxvalue = 0 ; for ( $ i = 1 ; $ i <= $ s - 2 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ s - 1 ; $ j ++ ) { $ k = $ s - $ i - $ j ; $ maxvalue = max ( $ maxvalue , $ i * $ j * $ k ) ; } } return $ maxvalue ; } $ s = 8 ; echo ( maxvolume ( $ s ) ) ; ? >"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; mencari panjang; mencari keluasan; Mencari ketinggian; Kod yang didorong", "code": "< ? php function maxvolume ( $ s ) { $ length = ( int ) ( $ s / 3 ) ; $ s -= $ length ; $ breadth = ( int ) ( $ s / 2 ) ; $ height = $ s - $ breadth ; return $ length * $ breadth * $ height ; } $ s = 8 ; echo ( maxvolume ( $ s ) ) ; ? >"}
{"text": "Kawasan Hexagon | Fungsi untuk mengira kawasan segi enam. ; Panjang sisi", "code": "< ? php function hexagonArea ( $ s ) { return ( ( 3 * sqrt ( 3 ) * ( $ s * $ s ) ) / 2 ) ; } $ s = 4 ; echo ( \" Area ▁ : ▁ \" ) ; echo ( hexagonArea ( $ s ) ) ; ? >"}
{"text": "Bilangan maksimum kuadrat yang boleh dimuatkan dalam segitiga isosceles sudut kanan | fungsi untuk mencari dataran maksimum; kembali dalam O (1) dengan formula yang diperoleh; Kod pemacu", "code": "< ? php function maxSquare ( $ b , $ m ) { return ( $ b / $ m - 1 ) * ( $ b / $ m ) / 2 ; } $ b = 10 ; $ m = 2 ; echo maxSquare ( $ b , $ m ) ;"}
{"text": "Semak jika segitiga yang betul mungkin dari kawasan tertentu dan hipotenus | Mencetak tiga sisi segitiga kanan dari kawasan tertentu dan hipotenus jika segitiga mungkin, cetakan lain - 1 .; Deskripsi persamaan; memohon formula persamaan linear untuk mencari kedua -dua akar; Kod pemacu", "code": "< ? php function findRightAngle ( $ A , $ H ) { $ D = pow ( $ H , 4 ) - 16 * $ A * $ A ; if ( $ D >= 0 ) { $ root1 = ( $ H * $ H + sqrt ( $ D ) ) / 2 ; $ root2 = ( $ H * $ H - sqrt ( $ D ) ) / 2 ; $ a = sqrt ( $ root1 ) ; $ b = sqrt ( $ root2 ) ; if ( $ b >= $ a ) echo $ a , \" ▁ \" , $ b , \" ▁ \" , $ H ; else echo $ b , \" ▁ \" , $ a , \" ▁ \" , $ H ; } else echo \" - 1\" ; } findRightAngle ( 6 , 5 ) ;"}
{"text": "Bilangan maksimum 2 x2 kotak yang boleh dimuatkan di dalam segitiga isosceles kanan | Program PHP untuk mengira bilangan 2 x 2 kotak di segitiga isosceles yang betul; Mengeluarkan bahagian tambahan yang selalu kita perlukan; Kerana setiap persegi mempunyai asas panjang 2; Kod pemacu", "code": "< ? php function numberOfSquares ( $ base ) { $ base = ( $ base - 2 ) ; $ base = intdiv ( $ base , 2 ) ; return $ base * ( $ base + 1 ) / 2 ; } $ base = 8 ; echo numberOfSquares ( $ base ) ; ? >"}
{"text": "Grafik Cube Fibonacci | berfungsi untuk mencari nombor Fibonacci; fungsi untuk mencari bilangan simpang dalam graf kiub Fibonacci; kembali nombor fibonacci untuk f (n + 2); Kod pemacu", "code": "< ? php function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; } function findVertices ( $ n ) { return fib ( $ n + 2 ) ; } $ n = 3 ; echo findVertices ( $ n ) ; ? >"}
{"text": "Penyusun baris matriks dalam urutan menaik diikuti oleh lajur dalam urutan menurun | Pelaksanaan PHP untuk menyusun baris matriks dalam urutan menaik diikuti dengan menyusun lajur dalam urutan menurun; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh menaik. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menurun. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "< ? php $ MAX_SIZE = 10 ; function sortByRow ( & $ mat , $ n , $ ascending ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ ascending ) sort ( $ mat [ $ i ] ) ; else rsort ( $ mat [ $ i ] ) ; } } function transpose ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ temp = $ mat [ $ i ] [ $ j ] ; $ mat [ $ i ] [ $ j ] = $ mat [ $ j ] [ $ i ] ; $ mat [ $ j ] [ $ i ] = $ temp ; } } } function sortMatRowAndColWise ( & $ mat , $ n ) { sortByRow ( $ mat , $ n , true ) ; transpose ( $ mat , $ n ) ; sortByRow ( $ mat , $ n , false ) ; transpose ( $ mat , $ n ) ; } function printMat ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ mat [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 3 ; $ mat = array ( array ( 3 , 2 , 1 ) , array ( 9 , 8 , 7 ) , array ( 6 , 5 , 4 ) ) ; echo \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( $ mat , $ n ) ; sortMatRowAndColWise ( $ mat , $ n ) ; echo \" Matrix After Sorting : \" ; printMat ( $ mat , $ n ) ; ? >"}
{"text": "Susun baris matriks | Pelaksanaan PHP untuk menyusun baris matriks - bijak dan lajur - bijak; berfungsi untuk menyusun setiap baris matriks; menyusun nombor baris 'i'; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; sekali lagi menyusun baris tikar [] []; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "< ? php $ MAX_SIZE = 10 ; function sortByRow ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) sort ( $ mat [ $ i ] ) ; } function transpose ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ t = $ mat [ $ i ] [ $ j ] ; $ mat [ $ i ] [ $ j ] = $ mat [ $ j ] [ $ i ] ; $ mat [ $ j ] [ $ i ] = $ t ; } } } function sortMatRowAndColWise ( & $ mat , $ n ) { sortByRow ( $ mat , $ n ) ; transpose ( $ mat , $ n ) ; sortByRow ( $ mat , $ n ) ; transpose ( $ mat , $ n ) ; } function printMat ( & $ mat , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ mat [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 4 , 1 , 3 ) , array ( 9 , 6 , 8 ) , array ( 5 , 2 , 7 ) ) ; $ n = 3 ; echo \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( $ mat , $ n ) ; sortMatRowAndColWise ( $ mat , $ n ) ; echo \" Matrix After Sorting : \" ; printMat ( $ mat , $ n ) ; ? >"}
{"text": "Magic Square | Malah pesanan | Fungsi untuk mengira Magic Square; Mengisi matriks dengan nilai kiraannya bermula dari 1; ; Tukar nilai elemen array di lokasi pembaikan seperti peraturan (n * n + 1) - arr [i] [j] sudut kiri atas matriks (perintah (n / 4) * (n / 4)); Sudut kanan atas matriks (perintah (n / 4) * (n / 4)); Sudut kiri bawah matriks (pesanan (n / 4) * (n / 4)); Sudut kanan bawah matriks (pesanan (n / 4) * (n / 4)); Pusat matriks (perintah (n / 2) * (n / 2)); Mencetak Magic - Square; Kod pemacu; Panggilan fungsi", "code": "< ? php function doublyEven ( $ n ) { $ arr = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = ( $ n * $ i ) + $ j + 1 ; for ( $ i = 0 ; $ i < $ n / 4 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n / 4 ; $ j ++ ) $ arr [ $ i ] [ $ j ] = ( $ n * $ n + 1 ) - $ arr [ $ i ] [ $ j ] ; for ( $ i = 0 ; $ i < $ n / 4 ; $ i ++ ) for ( $ j = 3 * ( $ n / 4 ) ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = ( $ n * $ n + 1 ) - $ arr [ $ i ] [ $ j ] ; for ( $ i = 3 * $ n / 4 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n / 4 ; $ j ++ ) $ arr [ $ i ] [ $ j ] = ( $ n * $ n + 1 ) - $ arr [ $ i ] [ $ j ] ; for ( $ i = 3 * $ n / 4 ; $ i < $ n ; $ i ++ ) for ( $ j = 3 * $ n / 4 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = ( $ n * $ n + 1 ) - $ arr [ $ i ] [ $ j ] ; for ( $ i = $ n / 4 ; $ i < 3 * $ n / 4 ; $ i ++ ) for ( $ j = $ n / 4 ; $ j < 3 * $ n / 4 ; $ j ++ ) $ arr [ $ i ] [ $ j ] = ( $ n * $ n + 1 ) - $ arr [ $ i ] [ $ j ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ arr [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 8 ; doublyEven ( $ n ) ; ? >"}
{"text": "Produk Kronecker Dua Matriks | Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Kod pemacu", "code": "< ? php $ cola = 2 ; $ rowa = 3 ; $ colb = 3 ; $ rowb = 2 ; function Kroneckerproduct ( $ A , $ B ) { global $ cola ; global $ rowa ; global $ colb ; global $ rowb ; $ C ; for ( $ i = 0 ; $ i < $ rowa ; $ i ++ ) { for ( $ k = 0 ; $ k < $ rowb ; $ k ++ ) { for ( $ j = 0 ; $ j < $ cola ; $ j ++ ) { for ( $ l = 0 ; $ l < $ colb ; $ l ++ ) { $ C [ $ i + $ l + 1 ] [ $ j + $ k + 1 ] = $ A [ $ i ] [ $ j ] * $ B [ $ k ] [ $ l ] ; echo ( $ C [ $ i + $ l + 1 ] [ $ j + $ k + 1 ] ) , \" TABSYMBOL \" ; } } echo \" STRNEWLINE \" ; } } } $ A = array ( array ( 1 , 2 ) , array ( 3 , 4 ) , array ( 1 , 0 ) ) ; $ B = array ( array ( 0 , 5 , 2 ) , array ( 6 , 7 , 3 ) ) ; Kroneckerproduct ( $ A , $ B ) ; ? >"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga yang lebih rendah | Program PHP untuk memeriksa matriks segi tiga yang lebih rendah. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga yang lebih rendah atau tidak. ; Kod pemacu; Panggilan fungsi", "code": "< ? php $ N = 4 ; function isLowerTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; } $ mat = array ( array ( 1 , 0 , 0 , 0 ) , array ( 1 , 4 , 0 , 0 ) , array ( 4 , 6 , 2 , 0 ) , array ( 0 , 4 , 7 , 6 ) ) ; if ( isLowerTriangularMatrix ( $ mat ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga atas | Program PHP untuk memeriksa matriks segi tiga atas. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga atas atau tidak. ; Kod pemacu", "code": "< ? php $ N = 4 ; function isUpperTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; } $ mat = array ( array ( 1 , 3 , 5 , 3 ) , array ( 0 , 4 , 6 , 2 ) , array ( 0 , 0 , 2 , 5 ) , array ( 0 , 0 , 0 , 6 ) ) ; if ( isUpperTriangularMatrix ( $ mat ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Mengira set 1 s dan 0 s dalam matriks binari | tiada lajur; tiada baris; berfungsi untuk mengira bilangan set sel yang tidak kosong; menyimpan jawapan terakhir; Traverses Row - Bijaksana; Traverses Column Wise; Pada akhirnya tolak n * m kerana tiada set tunggal telah ditambah dua kali. ; Kod pemacu", "code": "< ? php $ m = 3 ; $ n = 2 ; function countSets ( $ a ) { global $ m , $ n ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ u = 0 ; $ v = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ a [ $ i ] [ $ j ] ? $ u ++ : $ v ++ ; $ res += pow ( 2 , $ u ) - 1 + pow ( 2 , $ v ) - 1 ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ u = 0 ; $ v = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ a [ $ j ] [ $ i ] ? $ u ++ : $ v ++ ; $ res += pow ( 2 , $ u ) - 1 + pow ( 2 , $ v ) - 1 ; } return $ res - ( $ n * $ m ) ; } $ a = array ( array ( 1 , 0 , 1 ) , array ( 0 , 1 , 0 ) ) ; echo countSets ( $ a ) ; ? >"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Mengisi transpose mat [n] [n] dalam tr [n] [n]; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "< ? php for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ tr [ $ i ] [ $ j ] ) return false ; return true ; } function isSymmetric ( $ mat , $ N ) { $ tr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ tr [ $ i ] [ $ j ] = $ mat [ $ j ] [ $ i ] ; $ mat = array ( array ( 1 , 3 , 5 ) , array ( 3 , 2 , 4 ) , array ( 5 , 4 , 1 ) ) ; if ( isSymmetric ( $ mat , 3 ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod PHP yang cekap untuk memeriksa matriks adalah simetri atau tidak. ; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "< ? php $ MAX = 100 ; function isSymmetric ( $ mat , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) return false ; return true ; } $ mat = array ( array ( 1 , 3 , 5 ) , array ( 3 , 2 , 4 ) , array ( 5 , 4 , 1 ) ) ; if ( isSymmetric ( $ mat , 3 ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Program untuk mencari normal dan jejak matriks | Saiz matriks yang diberikan; Pulangan normal matriks saiz n x n; Mengembalikan jejak matriks saiz n x n; Kod pemacu", "code": "< ? php $ MAX = 100 ; function findNormal ( $ mat , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ mat [ $ i ] [ $ j ] * $ mat [ $ i ] [ $ j ] ; return floor ( sqrt ( $ sum ) ) ; } function findTrace ( $ mat , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ mat [ $ i ] [ $ i ] ; return $ sum ; } $ mat = array ( array ( 1 , 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 , 4 ) , array ( 5 , 5 , 5 , 5 , 5 ) ) ; echo \" Trace ▁ of ▁ Matrix ▁ = ▁ \" , findTrace ( $ mat , 5 ) , \" STRNEWLINE \" ; echo \" Normal ▁ of ▁ Matrix ▁ = ▁ \" , findNormal ( $ mat , 5 ) ; ? >"}
{"text": "Penentu maksimum matriks dengan setiap nilai sama ada 0 atau n | Fungsi untuk penentu maksimum; Berfungsi untuk mencetak matriks resulatant; tiga kedudukan di mana 0 muncul; kedudukan di mana n muncul; Kod pemacu", "code": "< ? php function maxDet ( $ n ) { return ( 2 * $ n * $ n * $ n ) ; } function resMatrix ( $ n ) { for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { for ( $ j = 0 ; $ j < 3 ; $ j ++ ) { if ( $ i == 0 && $ j == 2 ) echo \"0 ▁ \" ; else if ( $ i == 1 && $ j == 0 ) echo \"0 ▁ \" ; else if ( $ i == 2 && $ j == 1 ) echo \"0 ▁ \" ; else echo $ n , \" ▁ \" ; } echo \" STRNEWLINE \" ; } } $ n = 15 ; echo \" Maximum ▁ Determinant ▁ = ▁ \" , maxDet ( $ n ) ; echo \" Resultant Matrix : \" resMatrix ( $ n ) ; ? >"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan PHP kaedah naif untuk mengira nombor negatif dalam m [n] [m]; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; Tiada nombor negatif dalam baris ini; Kod pemacu", "code": "< ? php function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ M [ $ i ] [ $ j ] < 0 ) $ count += 1 ; else break ; } } return $ count ; } $ M = array ( array ( -3 , -2 , -1 , 1 ) , array ( -2 , 2 , 3 , 4 ) , array ( 4 , 5 , 7 , 8 ) ) ; echo countNegative ( $ M , 3 , 4 ) ; ? >"}
{"text": "Kira nombor negatif dalam lajur | Berfungsi untuk mengira nombor negatif; memulakan hasil; Mulakan dengan sudut kanan atas; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; J ialah indeks nombor negatif terakhir dalam baris ini. Jadi mesti ada (j + 1); Nombor negatif dalam baris ini. ; Pindah ke kiri dan lihat jika kita dapat mencari nombor negatif di sana; Kod pemacu", "code": "< ? php function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; $ i = 0 ; $ j = $ m - 1 ; while ( $ j >= 0 and $ i < $ n ) { if ( $ M [ $ i ] [ $ j ] < 0 ) { $ count += $ j + 1 ; $ i += 1 ; } else $ j -= 1 ; } return $ count ; } $ M = array ( array ( -3 , -2 , -1 , 1 ) , array ( -2 , 2 , 3 , 4 ) , array ( 4 , 5 , 7 , 8 ) ) ; echo countNegative ( $ M , 3 , 4 ) ; return 0 ; ? >"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah naif untuk mencari nilai maksimum $ mat [d] [e] - ma [a] [b] seperti $ d> $ a dan $ e> $ b; Fungsi ini mengembalikan nilai maksimum a (d, e) - a (a, b) ke atas semua pilihan indeks supaya kedua -dua $ d> $ a dan $ e> $ b. ; Kedai nilai maksimum; Pertimbangkan semua pasangan yang mungkin $ mat [$ a] [$ b] dan $ mat [$ d] [$ e]; Kod pemacu", "code": "< ? php $ N = 5 ; function findMaxValue ( & $ mat ) { global $ N ; $ maxValue = PHP_INT_MIN ; for ( $ a = 0 ; $ a < $ N - 1 ; $ a ++ ) for ( $ b = 0 ; $ b < $ N - 1 ; $ b ++ ) for ( $ d = $ a + 1 ; $ d < $ N ; $ d ++ ) for ( $ e = $ b + 1 ; $ e < $ N ; $ e ++ ) if ( $ maxValue < ( $ mat [ $ d ] [ $ e ] - $ mat [ $ a ] [ $ b ] ) ) $ maxValue = $ mat [ $ d ] [ $ e ] - $ mat [ $ a ] [ $ b ] ; return $ maxValue ; } $ mat = array ( array ( 1 , 2 , -1 , -4 , -20 ) , array ( -8 , -3 , 4 , 2 , 1 ) , array ( 3 , 8 , 6 , 1 , 3 ) , array ( -4 , -1 , 1 , 7 , -6 ) , array ( 0 , -4 , 10 , -5 , 1 ) ) ; echo \" Maximum ▁ Value ▁ is ▁ \" . findMaxValue ( $ mat ) ; ? >"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah yang cekap untuk mencari nilai maksimum MAT [d] - ma [a] [b] sedemikian rupa sehingga c> a dan d> b; Fungsi ini mengembalikan nilai maksimum a (c, d) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua c> a dan d> b. ; Kedai nilai maksimum; maxarr [i] [j] menyimpan max unsur -unsur dalam matriks dari (i, j) hingga (n - 1, n - 1); Elemen terakhir Maxarr akan menjadi sama seperti matriks input; Preprocess Last Row Inisialisasi Max; preprocess lajur terakhir memulakan max; PREPROCESS ROST OF MATRIX DARI BAWAH; Kemas kini MaxValue; Tetapkan Maxarr (i, j); Kod pemacu", "code": "< ? php $ N = 5 ; function findMaxValue ( $ mat ) { global $ N ; $ maxValue = PHP_INT_MIN ; $ maxArr [ $ N ] [ $ N ] = array ( ) ; $ maxArr [ $ N - 1 ] [ $ N - 1 ] = $ mat [ $ N - 1 ] [ $ N - 1 ] ; $ maxv = $ mat [ $ N - 1 ] [ $ N - 1 ] ; for ( $ j = $ N - 2 ; $ j >= 0 ; $ j -- ) { if ( $ mat [ $ N - 1 ] [ $ j ] > $ maxv ) $ maxv = $ mat [ $ N - 1 ] [ $ j ] ; $ maxArr [ $ N - 1 ] [ $ j ] = $ maxv ; } $ maxv = $ mat [ $ N - 1 ] [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { if ( $ mat [ $ i ] [ $ N - 1 ] > $ maxv ) $ maxv = $ mat [ $ i ] [ $ N - 1 ] ; $ maxArr [ $ i ] [ $ N - 1 ] = $ maxv ; } for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ N - 2 ; $ j >= 0 ; $ j -- ) { if ( $ maxArr [ $ i + 1 ] [ $ j + 1 ] - $ mat [ $ i ] [ $ j ] > $ maxValue ) $ maxValue = $ maxArr [ $ i + 1 ] [ $ j + 1 ] - $ mat [ $ i ] [ $ j ] ; $ maxArr [ $ i ] [ $ j ] = max ( $ mat [ $ i ] [ $ j ] , max ( $ maxArr [ $ i ] [ $ j + 1 ] , $ maxArr [ $ i + 1 ] [ $ j ] ) ) ; } } return $ maxValue ; } $ mat = array ( array ( 1 , 2 , -1 , -4 , -20 ) , array ( -8 , -3 , 4 , 2 , 1 ) , array ( 3 , 8 , 6 , 1 , 3 ) , array ( -4 , -1 , 1 , 7 , -6 ) , array ( 0 , -4 , 10 , -5 , 1 ) ) ; echo \" Maximum ▁ Value ▁ is ▁ \" . findMaxValue ( $ mat ) ; ? >"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | saiz k x k saiz matriks yang diberikan; berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; Nombor baris sel pertama dalam sub -persegi semasa saiz k x k; Lajur sel pertama dalam sub -persegi semasa saiz k x k; Hitung dan cetak jumlah sub -persegi semasa; Pemisah garis untuk sub -dataran bermula dengan baris seterusnya; Kod pemacu", "code": "< ? php $ n = 5 ; function printSumSimple ( $ mat , $ k ) { global $ n ; if ( $ k > $ n ) return ; for ( $ i = 0 ; $ i < $ n - $ k + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ k + 1 ; $ j ++ ) { $ sum = 0 ; for ( $ p = $ i ; $ p < $ k + $ i ; $ p ++ ) for ( $ q = $ j ; $ q < $ k + $ j ; $ q ++ ) $ sum += $ mat [ $ p ] [ $ q ] ; echo $ sum , \" \" ; } echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 1 , 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 , 2 , ) , array ( 3 , 3 , 3 , 3 , 3 , ) , array ( 4 , 4 , 4 , 4 , 4 , ) , array ( 5 , 5 , 5 , 5 , 5 ) ) ; $ k = 3 ; printSumSimple ( $ mat , $ k ) ; ? >"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Saiz matriks yang diberikan; A o (n ^ 2) berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi yang diberikan saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; 1: Preprocessing untuk menyimpan jumlah semua jalur saiz k x 1; Pergi lajur mengikut lajur; Hitung jumlah pertama K x 1 segi empat tepat dalam lajur ini; Hitung jumlah segi empat tepat; 2: Kirakan jumlah sub - dataran menggunakan stripsum [] []; Hitung dan cetak jumlah Subsquare Pertama dalam baris ini; Kirakan jumlah kuadrat yang tinggal dalam baris semasa dengan mengeluarkan jalur paling kiri sub -persegi sebelumnya dan menambah jalur baru; Kod pemacu", "code": "< ? php $ n = 5 ; function printSumTricky ( $ mat , $ k ) { global $ n ; if ( $ k > $ n ) return ; $ stripSum = array ( array ( ) ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ sum += $ mat [ $ i ] [ $ j ] ; $ stripSum [ 0 ] [ $ j ] = $ sum ; for ( $ i = 1 ; $ i < $ n - $ k + 1 ; $ i ++ ) { $ sum += ( $ mat [ $ i + $ k - 1 ] [ $ j ] - $ mat [ $ i - 1 ] [ $ j ] ) ; $ stripSum [ $ i ] [ $ j ] = $ sum ; } } for ( $ i = 0 ; $ i < $ n - $ k + 1 ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) $ sum += $ stripSum [ $ i ] [ $ j ] ; echo $ sum , \" \" ; for ( $ j = 1 ; $ j < $ n - $ k + 1 ; $ j ++ ) { $ sum += ( $ stripSum [ $ i ] [ $ j + $ k - 1 ] - $ stripSum [ $ i ] [ $ j - 1 ] ) ; echo $ sum , \" \" ; } echo \" STRNEWLINE \" ; } } $ mat = array ( array ( 1 , 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 , 4 ) , array ( 5 , 5 , 5 , 5 , 5 ) ) ; $ k = 3 ; printSumTricky ( $ mat , $ k ) ; ? >"}
{"text": "Program untuk mencari transpose matriks | Program PHP untuk mencari transpose matriks; Fungsi ini menyimpan transpose a [] [] dalam b [] []; Kod pemacu", "code": "< ? php $ N = 4 ; $ M = 3 ; function transpose ( & $ A , & $ B ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ M ; $ j ++ ) $ B [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) ) ; $ N = 4 ; $ M = 3 ; transpose ( $ A , $ B ) ; echo \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { echo $ B [ $ i ] [ $ j ] ; echo \" ▁ \" ; } echo \" STRNEWLINE \" ; } ? >"}
{"text": "Program untuk mencari transpose matriks | Program PHP untuk mencari transpose matriks; Menukarkan [] [] ke transposinya; Kod pemacu", "code": "< ? php $ N = 4 ; function transpose ( & $ A ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { $ temp = $ A [ $ i ] [ $ j ] ; $ A [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; $ A [ $ j ] [ $ i ] = $ temp ; } } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; transpose ( $ A ) ; echo \" Modified ▁ matrix ▁ is ▁ \" . \" STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) echo $ A [ $ i ] [ $ j ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } ? >"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program php rekursif naif untuk mengira laluan dengan syiling 'k' yang tepat; Fungsi rekursif untuk mengira laluan dengan jumlah k dari (0, 0) hingga (m, n); Kes asas; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas PathCountrec (); Program Pemandu", "code": "< ? php $ R = 3 ; $ C = 3 ; function pathCountRec ( $ mat , $ m , $ n , $ k ) { if ( $ m < 0 or $ n < 0 ) return 0 ; if ( $ m == 0 and $ n == 0 ) return ( $ k == $ mat [ $ m ] [ $ n ] ) ; return pathCountRec ( $ mat , $ m - 1 , $ n , $ k - $ mat [ $ m ] [ $ n ] ) + pathCountRec ( $ mat , $ m , $ n - 1 , $ k - $ mat [ $ m ] [ $ n ] ) ; } function pathCount ( $ mat , $ k ) { global $ R , $ C ; return pathCountRec ( $ mat , $ R - 1 , $ C - 1 , $ k ) ; } $ k = 12 ; $ mat = array ( array ( 1 , 2 , 3 ) , array ( 4 , 6 , 5 ) , array ( 3 , 2 , 1 ) ) ; echo pathCount ( $ mat , $ k ) ; ? >"}
{"text": "Pemilihan jenis | Susun fungsi; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar nilai minimum kepada $ ith node; Kod pemacu", "code": "< ? php function selection_sort ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ low = $ i ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] < $ arr [ $ low ] ) { $ low = $ j ; } } if ( $ arr [ $ i ] > $ arr [ $ low ] ) { $ tmp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ low ] ; $ arr [ $ low ] = $ tmp ; } } } $ arr = array ( 64 , 25 , 12 , 22 , 11 ) ; $ len = count ( $ arr ) ; selection_sort ( $ arr , $ len ) ; echo \" Sorted ▁ array ▁ : ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Bubble sort | Versi bubble yang dioptimumkan; melintasi array dari 0 hingga n - i - 1. Swap jika elemen yang dijumpai lebih besar daripada elemen seterusnya; Jika tidak ada dua elemen yang ditukar dengan gelung dalaman, kemudian pecah; Kod pemacu untuk diuji di atas", "code": "< ? php function bubbleSort ( & $ arr ) { $ n = sizeof ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ swapped = False ; for ( $ j = 0 ; $ j < $ n - $ i - 1 ; $ j ++ ) { if ( $ arr [ $ j ] > $ arr [ $ j + 1 ] ) { $ t = $ arr [ $ j ] ; $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ arr [ $ j + 1 ] = $ t ; $ swapped = True ; } } if ( $ swapped == False ) break ; } } $ arr = array ( 64 , 34 , 25 , 12 , 22 , 11 , 90 ) ; $ len = sizeof ( $ arr ) ; bubbleSort ( $ arr ) ; echo \" Sorted ▁ array ▁ : ▁ STRNEWLINE \" ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; ? >"}
{"text": "Cari K Elemen yang paling dekat dengan nilai yang diberikan | Berfungsi untuk mencari titik silang (titik sebelum unsur -unsur lebih kecil daripada atau sama dengan x dan selepas itu lebih besar daripada x); Kes asas X lebih besar daripada semua; X lebih kecil daripada semua; Cari titik tengah; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Fungsi ini mencetak elemen yang paling dekat dengan x dalam arr []. n ialah bilangan elemen dalam arr []; Cari titik crossover; Indeks yang betul untuk mencari; Untuk menjejaki kiraan elemen yang telah dicetak; Jika x hadir dalam arr [], maka mengurangkan asumsi indeks kiri: semua elemen dalam arr [] adalah berbeza; Bandingkan unsur -unsur di kiri dan kanan titik crossover untuk mencari unsur -unsur yang paling dekat; Jika tidak ada lagi elemen di sebelah kanan, maka cetak elemen kiri; Sekiranya tidak ada lagi elemen di sebelah kiri, maka cetak elemen kanan; Kod pemacu", "code": "< ? php function findCrossOver ( $ arr , $ low , $ high , $ x ) { if ( $ arr [ $ high ] <= $ x ) return $ high ; if ( $ arr [ $ low ] > $ x ) return $ low ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] <= $ x and $ arr [ $ mid + 1 ] > $ x ) return $ mid ; if ( $ arr [ $ mid ] < $ x ) return findCrossOver ( $ arr , $ mid + 1 , $ high , $ x ) ; return findCrossOver ( $ arr , $ low , $ mid - 1 , $ x ) ; } function printKclosest ( $ arr , $ x , $ k , $ n ) { $ l = findCrossOver ( $ arr , 0 , $ n - 1 , $ x ) ; $ r = $ l + 1 ; $ count = 0 ; if ( $ arr [ $ l ] == $ x ) $ l -- ; while ( $ l >= 0 and $ r < $ n and $ count < $ k ) { if ( $ x - $ arr [ $ l ] < $ arr [ $ r ] - $ x ) echo $ arr [ $ l -- ] , \" ▁ \" ; else echo $ arr [ $ r ++ ] , \" ▁ \" ; $ count ++ ; } while ( $ count < $ k and $ l >= 0 ) echo $ arr [ $ l -- ] , \" ▁ \" ; $ count ++ ; while ( $ count < $ k and $ r < $ n ) echo $ arr [ $ r ++ ] ; $ count ++ ; } $ arr = array ( 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 ) ; $ n = count ( $ arr ) ; $ x = 35 ; $ k = 4 ; printKclosest ( $ arr , $ x , 4 , $ n ) ; ? >"}
{"text": "Perubahan duit syiling | DP | Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Kod pemacu", "code": "< ? php function coun ( $ S , $ m , $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n < 0 ) return 0 ; if ( $ m <= 0 && $ n >= 1 ) return 0 ; return coun ( $ S , $ m - 1 , $ n ) + coun ( $ S , $ m , $ n - $ S [ $ m - 1 ] ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ m = count ( $ arr ) ; echo coun ( $ arr , $ m , 4 ) ; ? >"}
{"text": "Perubahan duit syiling | DP | Pengaturcaraan dinamik PHP pelaksanaan masalah perubahan duit syiling; Jadual [i] akan menyimpan bilangan penyelesaian untuk nilai i. Kami memerlukan baris n + 1 kerana jadual dibina dengan cara bawah menggunakan kes asas (n = 0); Kes asas (jika diberi nilai adalah 0); Pilih semua syiling satu demi satu dan kemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai duit syiling yang dipilih; Kod pemacu", "code": "< ? php function count_1 ( & $ S , $ m , $ n ) { $ table = array_fill ( 0 , $ n + 1 , NULl ) ; $ table [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = $ S [ $ i ] ; $ j <= $ n ; $ j ++ ) $ table [ $ j ] += $ table [ $ j - $ S [ $ i ] ] ; return $ table [ $ n ] ; } $ arr = array ( 1 , 2 , 3 ) ; $ m = sizeof ( $ arr ) ; $ n = 4 ; $ x = count_1 ( $ arr , $ m , $ n ) ; echo $ x ; ? >"}
{"text": "Pendaraban rantai matriks | DP | Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam M [] []. 0 bar dan lajur 0 M [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu", "code": "< ? php function MatrixChainOrder ( $ p , $ n ) { $ m [ ] [ ] = array ( $ n , $ n ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ m [ $ i ] [ $ i ] = 0 ; for ( $ L = 2 ; $ L < $ n ; $ L ++ ) { for ( $ i = 1 ; $ i < $ n - $ L + 1 ; $ i ++ ) { $ j = $ i + $ L - 1 ; if ( $ j == $ n ) continue ; $ m [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = $ i ; $ k <= $ j - 1 ; $ k ++ ) { $ q = $ m [ $ i ] [ $ k ] + $ m [ $ k + 1 ] [ $ j ] + $ p [ $ i - 1 ] * $ p [ $ k ] * $ p [ $ j ] ; if ( $ q < $ m [ $ i ] [ $ j ] ) $ m [ $ i ] [ $ j ] = $ q ; } } } return $ m [ 1 ] [ $ n - 1 ] ; } $ arr = array ( 1 , 2 , 3 , 4 ) ; $ size = sizeof ( $ arr ) ; echo \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" . MatrixChainOrder ( $ arr , $ size ) ; ? >"}
{"text": "Memotong batang | DP | Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Recursif memotong batang dalam kepingan yang berbeza dan membandingkan konfigurasi yang berbeza; Kod pemacu", "code": "< ? php function cutRod ( $ price , $ n ) { if ( $ n <= 0 ) return 0 ; $ max_val = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ max_val = max ( $ max_val , $ price [ $ i ] + cutRod ( $ price , $ n - $ i - 1 ) ) ; return $ max_val ; } $ arr = array ( 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ) ; $ size = count ( $ arr ) ; echo \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" , cutRod ( $ arr , $ size ) ; ? >"}
{"text": "Memotong batang | DP | Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "< ? php function cutRod ( $ price , $ n ) { $ val = array ( ) ; $ val [ 0 ] = 0 ; $ i ; $ j ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ max_val = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ max_val = max ( $ max_val , $ price [ $ j ] + $ val [ $ i - $ j - 1 ] ) ; $ val [ $ i ] = $ max_val ; } return $ val [ $ n ] ; } $ arr = array ( 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ) ; $ size = count ( $ arr ) ; echo \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" , cutRod ( $ arr , $ size ) ; ? >"}
{"text": "Multiply dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung | berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; kes di mana y adalah negatif; Kod pemacu", "code": "< ? php function multiply ( $ x , $ y ) { if ( $ y == 0 ) return 0 ; if ( $ y > 0 ) return ( $ x + multiply ( $ x , $ y - 1 ) ) ; if ( $ y < 0 ) return - multiply ( $ x , - $ y ) ; } echo multiply ( 5 , -11 ) ; ? >"}
{"text": "Sieve of Eratosthenes | Program PHP untuk mencetak semua prima yang lebih kecil daripada atau sama dengan N menggunakan penapis eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cetak semua nombor utama; Kod pemacu", "code": "< ? php function SieveOfEratosthenes ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * $ p ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) if ( $ prime [ $ p ] ) echo $ p . \" \" ; } $ n = 30 ; echo \" Following ▁ are ▁ the ▁ prime ▁ numbers ▁ \" . \" smaller ▁ than ▁ or ▁ equal ▁ to ▁ \" . $ n . \" STRNEWLINE \" ; SieveOfEratosthenes ( $ n ) ; ? >"}
{"text": "Segitiga Pascal | BinomialCoeff; Berfungsi untuk mencetak garisan N pertama dari segitiga Pascal; Berulang melalui setiap baris dan cetak penyertaan di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Kod pemacu", "code": "< ? php function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; } function printPascal ( $ n ) { for ( $ line = 0 ; $ line < $ n ; $ line ++ ) { for ( $ i = 0 ; $ i <= $ line ; $ i ++ ) echo \" \" . binomialCoeff ( $ line , $ i ) . \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 7 ; printPascal ( $ n ) ; ? >"}
{"text": "Segitiga Pascal | A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga PSCAL yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai -nilai lain adalah jumlah nilai di atas dan kiri di atas; Kod pemacu", "code": "< ? php function printPascal ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ line = 0 ; $ line < $ n ; $ line ++ ) { for ( $ i = 0 ; $ i <= $ line ; $ i ++ ) { if ( $ line == $ i $ i == 0 ) $ arr [ $ line ] [ $ i ] = 1 ; else $ arr [ $ line ] [ $ i ] = $ arr [ $ line - 1 ] [ $ i - 1 ] + $ arr [ $ line - 1 ] [ $ i ] ; echo $ arr [ $ line ] [ $ i ] . \" \" ; } echo \" STRNEWLINE \" ; } } $ n = 5 ; printPascal ( $ n ) ; ? >"}
{"text": "Segitiga Pascal | Program php untuk Pascal 's' u u (n ^ 2) ~ masa u dan u (1) ~ or ruang »Kaedah ~ untuk fungsi Pascal Pascal Pascal; digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu", "code": "< ? php function printPascal ( $ n ) { for ( $ line = 1 ; $ line <= $ n ; $ line ++ ) { $ C = 1 ; for ( $ i = 1 ; $ i <= $ line ; $ i ++ ) { print ( $ C . \" \" ) ; $ C = $ C * ( $ line - $ i ) / $ i ; } print ( \" STRNEWLINE \" ) ; } } $ n = 5 ; printPascal ( $ n ) ; ? >"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | Program PHP untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; Kod pemacu", "code": "< ? php function Add ( $ x , $ y ) { while ( $ y != 0 ) { $ carry = $ x & $ y ; $ x = $ x ^ $ y ; $ y = $ carry << 1 ; } return $ x ; } echo Add ( 15 , 32 ) ; ? >"}
{"text": "Mengira Bahagian Modulus dengan Kuasa | Fungsi ini akan kembali n % d. D mestilah salah satu: 1, 2, 4, 8, 16, 32, ...; Kod pemacu; D mesti menjadi kuasa 2", "code": "< ? php function getModulo ( $ n , $ d ) { return ( $ n & ( $ d - 1 ) ) ; } $ n = 6 ; $ d = 4 ; echo $ n , \" ▁ moduo \" , \" ▁ \" , $ d , \" ▁ is ▁ \" , \" ▁ \" , getModulo ( $ n , $ d ) ; ? >"}
{"text": "Count set bit dalam integer | Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Kod pemacu", "code": "< ? php function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; } $ i = 9 ; echo countSetBits ( $ i ) ; ? >"}
{"text": "Count set bit dalam integer | fungsi rekursif untuk mengira set bit; Kes asas; Dapatkan nilai dari pengguna; fungsi panggilan", "code": "< ? php function countSetBits ( $ n ) { if ( $ n == 0 ) return 0 ; else return 1 + countSetBits ( $ n & ( $ n - 1 ) ) ; } $ n = 9 ; echo countSetBits ( $ n ) ; ? >"}
{"text": "Count set bit dalam integer | Kod pemacu", "code": "< ? php $ t = log10 ( 4 ) ; $ x = log ( 15 , 2 ) ; $ tt = ceil ( $ t ) ; $ xx = ceil ( $ x ) ; echo ( $ tt ) , \" STRNEWLINE \" ; echo ( $ xx ) , \" STRNEWLINE \" ; ? >"}
{"text": "Count set bit dalam integer | Program PHP untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu", "code": "< ? php $ num_to_bits = array ( 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ) ; function countSetBitsRec ( $ num ) { global $ num_to_bits ; $ nibble = 0 ; if ( 0 == $ num ) return $ num_to_bits [ 0 ] ; $ nibble = $ num & 0xf ; return $ num_to_bits [ $ nibble ] + countSetBitsRec ( $ num >> 4 ) ; } $ num = 31 ; echo ( countSetBitsRec ( $ num ) ) ; ? >"}
{"text": "Program untuk mencari pariti | Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Kod pemacu", "code": "< ? php function getParity ( $ n ) { $ parity = 0 ; while ( $ n ) { $ parity = ! $ parity ; $ n = $ n & ( $ n - 1 ) ; } return $ parity ; } $ n = 7 ; echo \" Parity ▁ of ▁ no ▁ \" , $ n , \" ▁ = ▁ \" , getParity ( $ n ) ? \" odd \" : \" even \" ; ? >"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program PHP untuk mencari sama ada NO adalah kuasa dua fungsi untuk memeriksa asas log 2; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "< ? php function Log2 ( $ x ) { return ( log10 ( $ x ) / log10 ( 2 ) ) ; } function isPowerOfTwo ( $ n ) { return ( ceil ( Log2 ( $ n ) ) == floor ( Log2 ( $ n ) ) ) ; } if ( isPowerOfTwo ( 31 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isPowerOfTwo ( 64 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ n ) { if ( $ n == 0 ) return 0 ; while ( $ n != 1 ) { if ( $ n % 2 != 0 ) return 0 ; $ n = $ n / 2 ; } return 1 ; } if ( isPowerOfTwo ( 31 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isPowerOfTwo ( 64 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kod pemacu", "code": "< ? php function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; } if ( isPowerOfTwo ( 31 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; if ( isPowerOfTwo ( 64 ) ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; ? >"}
{"text": "Cari nombor pengulangan maksimum dalam O (n) masa dan O (1) ruang tambahan | Mengembalikan elemen berulang maksimum dalam ARR [0. n - 1]. Unsur -unsur array berada dalam jarak dari 0 hingga k - 1; Berulang walaupun array input, untuk setiap elemen arr [i], kenaikan arr [arr [i] % k] oleh k; Cari indeks elemen berulang maksimum; Indeks pulangan elemen maksimum; Kod pemacu", "code": "< ? php function maxRepeating ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ arr [ $ i ] % $ k ] += $ k ; $ max = $ arr [ 0 ] ; $ result = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) { $ max = $ arr [ $ i ] ; $ result = $ i ; } } return $ result ; } $ arr = array ( 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 ) ; $ n = sizeof ( $ arr ) ; $ k = 8 ; echo \" The ▁ maximum ▁ repeating ▁ number ▁ is ▁ \" , maxRepeating ( $ arr , $ n , $ k ) ; ? >"}
{"text": "Pertanyaan pelbagai pada array yang setiap elemen adalah xor nilai indeks dan elemen sebelumnya | Fungsi pulangan nilai formula yang diperolehi. ; Mencari nilai XOR julat [y ... x]; Fungsi untuk menyelesaikan pertanyaan untuk l dan r. ; jika l atau r ialah 0 .; Mencari X boleh dibahagikan dengan 2 atau tidak. ; Kod pemacu", "code": "< ? php function fun ( $ x ) { $ y = ( ( int ) ( $ x / 4 ) * 4 ) ; $ ans = 0 ; for ( $ i = $ y ; $ i <= $ x ; $ i ++ ) $ ans ^= $ i ; return $ ans ; } function query ( $ x ) { if ( $ x == 0 ) return 0 ; $ k = ( int ) ( ( $ x + 1 ) / 2 ) ; return ( $ x %= 2 ) ? 2 * fun ( $ k ) : ( ( fun ( $ k - 1 ) * 2 ) ^ ( $ k & 1 ) ) ; } function allQueries ( $ q , $ l , $ r ) { for ( $ i = 0 ; $ i < $ q ; $ i ++ ) echo ( query ( $ r [ $ i ] ) ^ query ( $ l [ $ i ] - 1 ) ) , \" STRNEWLINE \" ; } $ q = 3 ; $ l = array ( 2 , 2 , 5 ) ; $ r = array ( 4 , 8 , 9 ) ; allQueries ( $ q , $ l , $ r ) ; ? >"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari | Fungsi untuk mencari swap minimum untuk menyusun pelbagai 0 s dan 1 s. ; Array untuk menyimpan kiraan sifar; Kira bilangan sifar di sebelah kanan setiap satu. ; Kira jumlah swap dengan menambahkan bilangan sifar di sebelah kanan setiap satu. ; Kod pemacu", "code": "< ? php function findMinSwaps ( $ arr , $ n ) { $ noOfZeroes [ $ n ] = array ( ) ; $ noOfZeroes = array_fill ( 0 , $ n , true ) ; $ count = 0 ; $ noOfZeroes [ $ n - 1 ] = 1 - $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ noOfZeroes [ $ i ] = $ noOfZeroes [ $ i + 1 ] ; if ( $ arr [ $ i ] == 0 ) $ noOfZeroes [ $ i ] ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 1 ) $ count += $ noOfZeroes [ $ i ] ; } return $ count ; } $ arr = array ( 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ) ; $ n = sizeof ( $ arr ) ; echo findMinSwaps ( $ arr , $ n ) ; ? >"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan XOR semua elemen di arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana mudah diperoleh; Sekarang bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; Kod pemacu", "code": "< ? php function printTwoOdd ( $ arr , $ size ) { $ xor2 = $ arr [ 0 ] ; $ set_bit_no ; $ i ; $ n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor2 = $ xor2 ^ $ arr [ $ i ] ; $ set_bit_no = $ xor2 & ~ ( $ xor2 - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo \" The ▁ two ▁ ODD ▁ elements ▁ are ▁ \" , $ x , \" ▁ & ▁ \" , $ y ; } $ arr = array ( 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ) ; $ arr_size = sizeof ( $ arr ) ; printTwoOdd ( $ arr , $ arr_size ) ; ? >"}
{"text": "Cari pasangan dengan perbezaan yang diberikan | Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Kod pemacu", "code": "< ? php function findPair ( & $ arr , $ size , $ n ) { $ i = 0 ; $ j = 1 ; while ( $ i < $ size && $ j < $ size ) { if ( $ i != $ j && $ arr [ $ j ] - $ arr [ $ i ] == $ n ) { echo \" Pair ▁ Found : ▁ \" . \" ( \" . $ arr [ $ i ] . \" , ▁ \" . $ arr [ $ j ] . \" ) \" ; return true ; } else if ( $ arr [ $ j ] - $ arr [ $ i ] < $ n ) $ j ++ ; else $ i ++ ; } echo \" No ▁ such ▁ pair \" ; return false ; } $ arr = array ( 1 , 8 , 30 , 40 , 100 ) ; $ size = sizeof ( $ arr ) ; $ n = 60 ; findPair ( $ arr , $ size , $ n ) ; ? >"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; Kod pemacu", "code": "< ? php function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; } $ arr = array ( 20 , 15 , 5 , 0 , 10 ) ; $ n = count ( $ arr ) ; if ( checkIsAP ( $ arr , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Kira cara memilih pasangan dengan perbezaan maksimum | Kod PHP untuk mencari tidak. cara memilih pasangan dengan perbezaan maksimum; Untuk mencari minimum dan maksimum array; untuk mencari kiraan elemen minimum dan maksimum; Kiraan pembolehubah; keadaan untuk semua elemen sama; Kod pemacu", "code": "< ? php function countPairs ( $ a , $ n ) { $ mn = PHP_INT_MAX ; $ mx = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ mn = min ( $ mn , $ a [ $ i ] ) ; $ mx = max ( $ mx , $ a [ $ i ] ) ; } $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ mn ) $ c1 ++ ; if ( $ a [ $ i ] == $ mx ) $ c2 ++ ; } if ( $ mn == $ mx ) return $ n * ( $ n - 1 ) / 2 ; else return $ c1 * $ c2 ; } $ a = array ( 3 , 2 , 1 , 1 , 3 ) ; $ n = count ( $ a ) ; echo countPairs ( $ a , $ n ) ; ? >"}
{"text": "Cari nombor berulang dan nombor yang hilang menggunakan dua persamaan | Berfungsi untuk mencetak nombor yang diperlukan; Jumlah nombor semulajadi n pertama; Jumlah kuadrat nombor semulajadi n pertama; Untuk menyimpan jumlah dan jumlah kuadrat unsur -unsur array; Kod pemacu", "code": "< ? php function findNumbers ( $ arr , $ n ) { $ sumN = ( $ n * ( $ n + 1 ) ) / 2 ; $ sumSqN = ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; $ sum = 0 ; $ sumSq = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ sumSq += pow ( $ arr [ $ i ] , 2 ) ; } $ B = ( ( ( $ sumSq - $ sumSqN ) / ( $ sum - $ sumN ) ) + $ sumN - $ sum ) / 2 ; $ A = $ sum - $ sumN + $ B ; echo \" A = \" , ▁ $ A , ▁ \" B = \" } $ arr = array ( 1 , 2 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) ; findNumbers ( $ arr , $ n ) ; ? >"}
{"text": "Kira tiga kali ganda supaya A [i] <b [j] <c [k] | Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang kurang daripada kunci yang diberikan; Carian binari yang diubah suai; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang lebih besar daripada kunci yang diberikan; Carian binari yang diubah suai; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang diperlukan; Menyusun ketiga -tiga tatasusunan; Melangkah untuk semua elemen array b; Kiraan elemen dalam [] yang kurang daripada elemen yang dipilih dari B []; Kiraan unsur -unsur dalam C [] yang lebih besar daripada elemen yang dipilih dari B []; Mengemas kini kiraan; Kod pemacu", "code": "< ? php function countLessThan ( & $ arr , $ n , $ key ) { $ l = 0 ; $ r = $ n - 1 ; $ index = -1 ; while ( $ l <= $ r ) { $ m = intval ( ( $ l + $ r ) / 2 ) ; if ( $ arr [ $ m ] < $ key ) { $ l = $ m + 1 ; $ index = $ m ; } else { $ r = $ m - 1 ; } } return ( $ index + 1 ) ; } function countGreaterThan ( & $ arr , $ n , $ key ) { $ l = 0 ; $ r = $ n - 1 ; $ index = -1 ; while ( $ l <= $ r ) { $ m = intval ( ( $ l + $ r ) / 2 ) ; if ( $ arr [ $ m ] <= $ key ) { $ l = $ m + 1 ; } else { $ r = $ m - 1 ; $ index = $ m ; } } if ( $ index == -1 ) return 0 ; return ( $ n - $ index ) ; } function countTriplets ( $ n , & $ a , & $ b , & $ c ) { sort ( $ a ) ; sort ( $ b ) ; sort ( $ c ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ current = $ b [ $ i ] ; $ a_index = -1 ; $ c_index = -1 ; $ low = countLessThan ( $ a , $ n , $ current ) ; $ high = countGreaterThan ( $ c , $ n , $ current ) ; $ count += ( $ low * $ high ) ; } return $ count ; } $ a = array ( 1 , 5 ) ; $ b = array ( 2 , 4 ) ; $ c = array ( 3 , 6 ) ; $ size = sizeof ( $ a ) ; echo countTriplets ( $ size , $ a , $ b , $ c ) ; ? >"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Berfungsi untuk mencari pertengahan tiga nombor; x adalah positif jika a lebih besar daripada b. x adalah negatif jika b lebih besar daripada a. ; Sama seperti x; Sama seperti x dan y. ; Memeriksa jika B adalah tengah (X dan Y kedua -duanya adalah positif); Memeriksa jika C adalah tengah (x dan z kedua -duanya positif); Kod pemacu", "code": "< ? php function middleOfThree ( $ a , $ b , $ c ) { $ x = $ a - $ b ; $ y = $ b - $ c ; $ z = $ a - $ c ; if ( $ x * $ y > 0 ) return $ b ; else if ( $ x * $ z > 0 ) return $ c ; else return $ a ; } $ a = 20 ; $ b = 30 ; $ c = 40 ; echo middleOfThree ( $ a , $ b , $ c ) ; ? >"}
{"text": "Cari empat nombor yang hilang dalam array yang mengandungi elemen dari 1 hingga n | Menemukan 4 nombor dalam O (n) masa dan O (1) ruang tambahan. ; Untuk menjejaki 4 nombor yang mungkin lebih besar daripada panjang input arus yang diasaskan sebagai 0 .; Melintasi array input dan menandakan unsur -unsur yang dilawati sama ada dengan menandakan mereka sebagai negatif dalam arr [] atau dalam pembantu []. ; Jika elemen lebih kecil daripada atau sama dengan panjang, tandakan kehadirannya di arr []; Mark kehadiran dalam pembantu []; Cetak semua elemen yang kehadirannya tidak ditandakan. ; Kod pemacu", "code": "< ? php function missing4 ( $ arr , $ n ) { $ helper = array ( 0 , 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = abs ( $ arr [ $ i ] ) ; if ( $ temp <= $ n ) $ arr [ $ temp - 1 ] = $ arr [ $ temp - 1 ] * ( -1 ) ; else if ( $ temp > $ n ) { if ( $ temp % $ n != 0 ) $ helper [ $ temp % $ n - 1 ] = -1 ; else $ helper [ ( $ temp % $ n ) + $ n - 1 ] = -1 ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > 0 ) { $ a = $ i + 1 ; echo \" $ a \" , \" ▁ \" ; } for ( $ i = 0 ; $ i < 4 ; $ i ++ ) if ( $ helper [ $ i ] >= 0 ) { $ b = $ n + $ i + 1 ; echo \" $ b \" , \" ▁ \" ; } echo \" STRNEWLINE \" ; return ; } $ arr = array ( 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 ) ; $ n = sizeof ( $ arr ) ; missing4 ( $ arr , $ n ) ; ? >"}
{"text": "Operasi Peningkatan Julat Minimum Untuk Mengasingkan Array | Berfungsi untuk mencari kenaikan julat minimum untuk menyusun array; Jika elemen semasa didapati lebih besar daripada kenaikan elemen terakhir semua istilah dalam julat i + 1 hingga n - 1; $ mn = $ arr [$ i]; Minimum dalam julat I hingga n - 1; Kod pemacu", "code": "< ? php function minMovesToSort ( $ arr , $ n ) { $ moves = 0 ; $ mn = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ mn ) $ moves += $ arr [ $ i ] - $ mn ; } return $ moves ; } $ arr = array ( 3 , 5 , 2 , 8 , 4 ) ; $ n = sizeof ( $ arr ) ; echo minMovesToSort ( $ arr , $ n ) ; ? >"}
{"text": "Pembentukan pasangan sedemikian rupa sehingga jumlah pasangan maksimum diminimumkan | Program PHP untuk membahagikan array ke pasangan N sedemikian rupa sehingga pasangan maksimum diminimumkan; Selepas menyusun mengekalkan dua pembolehubah i dan j menunjuk untuk memulakan dan mengakhiri array sedemikian rupa sehingga elemen terkecil pasangan array dengan elemen terbesar; Kod pemacu", "code": "< ? php function findOptimalPairs ( $ arr , $ N ) { sort ( $ arr ) ; for ( $ i = 0 , $ j = $ N - 1 ; $ i <= $ j ; $ i ++ , $ j -- ) echo \" ( \" , $ arr [ $ i ] , \" , ▁ \" , $ arr [ $ j ] , \" ) \" , \" ▁ \" ; } $ arr = array ( 9 , 6 , 5 , 1 ) ; $ N = sizeof ( $ arr ) ; findOptimalPairs ( $ arr , $ N ) ; ? >"}
{"text": "Bilangan minimum operasi yang diberikan untuk mengurangkan array ke 0 elemen | Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Hitung kekerapan setiap elemen; Elemen maksimum dari array; Cari semua gandaan i; Padamkan gandaan; Meningkatkan operasi; Kod pemacu", "code": "< ? php function minOperations ( $ arr , $ n ) { $ result = 0 ; $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ arr [ $ i ] ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = $ arr [ $ i ] ; $ freq [ $ x ] ++ ; } $ maxi = max ( $ arr ) ; for ( $ i = 1 ; $ i <= $ maxi ; $ i ++ ) { if ( $ freq [ $ i ] != 0 ) { for ( $ j = $ i * 2 ; $ j <= $ maxi ; $ j = $ j + $ i ) { $ freq [ $ j ] = 0 ; } $ result ++ ; } } return $ result ; } $ arr = array ( 2 , 4 , 2 , 4 , 4 , 4 ) ; $ n = count ( $ arr ) ; echo minOperations ( $ arr , $ n ) ; ? >"}
{"text": "Minimum LCM dan GCD mungkin di antara semua sub | Berfungsi untuk mengembalikan GCD minimum di kalangan semua subarray; GCD minimum di antara semua sub -tatasusunan akan menjadi GCD dari semua elemen array; Berfungsi untuk mengembalikan LCM minimum di kalangan semua subarray; LCM minimum di antara semua sub - tatasusunan akan menjadi elemen minimum dari array; Kod pemacu", "code": "< ? php function __gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return __gcd ( $ b % $ a , $ a ) ; } function minGCD ( $ arr , $ n ) { $ minGCD = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ minGCD = __gcd ( $ minGCD , $ arr [ $ i ] ) ; return $ minGCD ; } function minLCM ( $ arr , $ n ) { $ minLCM = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ minLCM = min ( $ minLCM , $ arr [ $ i ] ) ; return $ minLCM ; } $ arr = array ( 2 , 66 , 14 , 521 ) ; $ n = sizeof ( $ arr ) ; echo \" LCM = \" ▁ . ▁ minLCM ( $ arr , ▁ $ n ) ▁ . ▁ \" , \" echo \" GCD ▁ = ▁ \" . minGCD ( $ arr , $ n ) ; ? >"}
{"text": "Bentuk rentetan terkecil secara lexicographically dengan penggantian minimum yang mempunyai bilangan yang sama 0 s, 1 s dan 2 s | Fungsi yang mengembalikan rentetan terkecil lexicographically yang diubahsuai selepas melakukan bilangan minimum operasi yang diberikan; Menyimpan frekuensi awal aksara 0 s, 1 s dan 2 s; Menyimpan bilangan aksara yang diproses sehingga titik setiap jenis; Bilangan aksara yang diperlukan setiap jenis; Jika jenis semasa telah membatalkan bilangan aksara, tidak perlu melakukan apa -apa operasi; Proses semua 3 kes; Semak 1 pertama; Lain 2; Di sini kita perlu menyemak yang diproses [1] hanya untuk 2 kerana 0 adalah kurang daripada 1 dan kita boleh menggantikannya pada bila -bila masa; Di sini kita boleh menggantikan 2 dengan 0 dan 1 bila -bila masa; Simpan kiraan aksara yang diproses setiap jenis; Kod pemacu", "code": "< ? php function formStringMinOperations ( $ s ) { $ count = array_fill ( 0 , 3 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) $ count [ $ s [ $ i ] - '0' ] ++ ; $ processed = array_fill ( 0 , 3 , 0 ) ; $ reqd = floor ( strlen ( $ s ) / 3 ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ count [ $ s [ $ i ] - '0' ] == $ reqd ) continue ; if ( $ s [ $ i ] == '0' && $ count [ 0 ] > $ reqd && $ processed [ 0 ] >= $ reqd ) { if ( $ count [ 1 ] < $ reqd ) { $ s [ $ i ] = '1' ; $ count [ 1 ] ++ ; $ count [ 0 ] -- ; } else if ( $ count [ 2 ] < $ reqd ) { $ s [ $ i ] = '2' ; $ count [ 2 ] ++ ; $ count [ 0 ] -- ; } } if ( $ s [ $ i ] == '1' && $ count [ 1 ] > $ reqd ) { if ( $ count [ 0 ] < $ reqd ) { $ s [ $ i ] = '0' ; $ count [ 0 ] ++ ; $ count [ 1 ] -- ; } else if ( count [ 2 ] < $ reqd && $ processed [ 1 ] >= $ reqd ) { $ s [ $ i ] = '2' ; $ count [ 2 ] ++ ; $ count [ 1 ] -- ; } } if ( $ s [ $ i ] == '2' && $ count [ 2 ] > $ reqd ) { if ( $ count [ 0 ] < $ reqd ) { $ s [ $ i ] = '0' ; $ count [ 0 ] ++ ; $ count [ 2 ] -- ; } else if ( $ count [ 1 ] < $ reqd ) { $ s [ $ i ] = '1' ; $ count [ 1 ] ++ ; $ count [ 2 ] -- ; } } $ processed [ $ s [ $ i ] - '0' ] ++ ; } return $ s ; } $ s = \"011200\" ; echo formStringMinOperations ( $ s ) ; ? >"}
{"text": "Jumlah maksimum dari tiga tatasusunan yang memilih unsur -unsur berturut -turut dari yang sama tidak dibenarkan | Pelaksanaan PHP pendekatan; Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Sudah dikunjungi; Jika elemen telah diambil dari array pertama dalam langkah sebelumnya; Jika elemen telah diambil dari array kedua dalam langkah sebelumnya; Jika elemen telah diambil dari array ketiga dalam langkah sebelumnya; Kod pemacu; Pilih elemen dari array pertama; Pilih elemen dari array kedua; Pilih elemen dari array ketiga; Cetak maksimum mereka", "code": "< ? php $ N = 3 ; function FindMaximumSum ( $ ind , $ kon , $ a , $ b , $ c , $ n , $ dp ) { global $ N ; if ( $ ind == $ n ) return 0 ; if ( $ dp [ $ ind ] [ $ kon ] != -1 ) return $ dp [ $ ind ] [ $ kon ] ; $ ans = -1e9 + 5 ; if ( $ kon == 0 ) { $ ans = max ( $ ans , $ b [ $ ind ] + FindMaximumSum ( $ ind + 1 , 1 , $ a , $ b , $ c , $ n , $ dp ) ) ; $ ans = max ( $ ans , $ c [ $ ind ] + FindMaximumSum ( $ ind + 1 , 2 , $ a , $ b , $ c , $ n , $ dp ) ) ; } else if ( $ kon == 1 ) { $ ans = max ( $ ans , $ a [ $ ind ] + FindMaximumSum ( $ ind + 1 , 0 , $ a , $ b , $ c , $ n , $ dp ) ) ; $ ans = max ( $ ans , $ c [ $ ind ] + FindMaximumSum ( $ ind + 1 , 2 , $ a , $ b , $ c , $ n , $ dp ) ) ; } else if ( $ kon == 2 ) { $ ans = max ( $ ans , $ a [ $ ind ] + FindMaximumSum ( $ ind + 1 , 1 , $ a , $ b , $ c , $ n , $ dp ) ) ; $ ans = max ( $ ans , $ b [ $ ind ] + FindMaximumSum ( $ ind + 1 , 0 , $ a , $ b , $ c , $ n , $ dp ) ) ; } return $ dp [ $ ind ] [ $ kon ] = $ ans ; } $ a = array ( 6 , 8 , 2 , 7 , 4 , 2 , 7 ) ; $ b = array ( 7 , 8 , 5 , 8 , 6 , 3 , 5 ) ; $ c = array ( 8 , 3 , 2 , 6 , 8 , 4 , 1 ) ; $ n = count ( $ a ) ; $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ N , -1 ) ) ; $ x = FindMaximumSum ( 0 , 0 , $ a , $ b , $ c , $ n , $ dp ) ; $ y = FindMaximumSum ( 0 , 1 , $ a , $ b , $ c , $ n , $ dp ) ; $ z = FindMaximumSum ( 0 , 2 , $ a , $ b , $ c , $ n , $ dp ) ; print ( max ( $ x , max ( $ y , $ z ) ) ) ; ? >"}
{"text": "Bilangan cara untuk membuat rentetan panjang panjang n sedemikian rupa sehingga 0 s sentiasa berlaku bersama dalam kumpulan saiz k | Pelaksanaan PHP pendekatan di atas; Berfungsi untuk mengembalikan tidak ada cara untuk membina rentetan panjang binari sehingga 0 s selalu berlaku dalam kumpulan saiz k; Kod pemacu", "code": "< ? php $ mod = 1000000007 ; function noOfBinaryStrings ( $ N , $ k ) { global $ mod ; $ dp = array ( 0 , 100002 , NULL ) ; for ( $ i = 1 ; $ i <= $ k - 1 ; $ i ++ ) { $ dp [ $ i ] = 1 ; } $ dp [ $ k ] = 2 ; for ( $ i = $ k + 1 ; $ i <= $ N ; $ i ++ ) { $ dp [ $ i ] = ( $ dp [ $ i - 1 ] + $ dp [ $ i - $ k ] ) % $ mod ; } return $ dp [ $ N ] ; } $ N = 4 ; $ K = 2 ; echo noOfBinaryStrings ( $ N , $ K ) ; ? >"}
{"text": "Bilangan cara untuk memasangkan orang | Berfungsi untuk mencari bilangan cara untuk memasangkan orang dalam parti; Untuk menyimpan jumlah cara. ; Menggunakan kiraan cari yang ditakrifkan berulang untuk nilai yang berbeza p. ; Kod pemacu", "code": "< ? php function findWaysToPair ( $ p ) { $ dp = array ( ) ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ p ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ p ] ; } $ p = 3 ; echo findWaysToPair ( $ p ) ; ? >"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pelaksanaan rekursif mudah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; kes asas; Untuk kes n> 2; Kod pemacu", "code": "< ? php function CountWays ( $ n ) { if ( $ n == 0 ) { return 1 ; } if ( $ n == 1 ) { return 1 ; } if ( $ n == 2 ) { return 1 + 1 ; } return CountWays ( $ n - 1 ) + CountWays ( $ n - 3 ) ; } $ n = 5 ; echo CountWays ( $ n ) ; ? >"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Mengembalikan jumlah maksimum subarray yang dibuat selepas menggabungkan [0 .. n - 1] k kali. ; Di sinilah ia berbeza dari algoritma Kadane.  Kami menggunakan aritmetik modular untuk mencari elemen seterusnya. ; Kod pemacu", "code": "< ? php function maxSubArraySumRepeated ( $ a , $ n , $ k ) { $ INT_MIN = 0 ; $ max_so_far = $ INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ n * $ k ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i % $ n ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; } $ a = array ( 10 , 20 , -30 , -1 ) ; $ n = sizeof ( $ a ) ; $ k = 3 ; echo \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" , maxSubArraySumRepeated ( $ a , $ n , $ k ) ; ? >"}
{"text": "Terpanjang peningkatan ganjil walaupun berikutnya | berfungsi untuk mencari peningkatan yang paling lama walaupun seterusnya; lioes [i] menyimpan paling lama meningkatkan ganjil walaupun berikutnya yang berakhir di arr [i]; untuk menyimpan panjang yang paling lama meningkat ganjil walaupun berikutnya; Memulakan nilai lio untuk semua indeks; Mengira nilai lio yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai lio; panjang maksimum yang diperlukan; Kod pemacu", "code": "< ? php function longOddEvenIncSeq ( & $ arr , $ n ) { $ lioes = array_fill ( 0 , $ n , NULL ) ; $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lioes [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && ( $ arr [ $ i ] + $ arr [ $ j ] ) % 2 != 0 && $ lioes [ $ i ] < $ lioes [ $ j ] + 1 ) $ lioes [ $ i ] = $ lioes [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ maxLen < $ lioes [ $ i ] ) $ maxLen = $ lioes [ $ i ] ; return $ maxLen ; } $ arr = array ( 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 ) ; $ n = sizeof ( $ arr ) ; echo \" Longest ▁ Increasing ▁ Odd ▁ Even ▁ \" . \" Subsequence : ▁ \" . longOddEvenIncSeq ( $ arr , $ n ) ; ? >"}
{"text": "Pendaraban rantai matriks | DP | Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu", "code": "< ? php function MatrixChainOrder ( & $ p , $ i , $ j ) { if ( $ i == $ j ) return 0 ; $ min = PHP_INT_MAX ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) { $ count = MatrixChainOrder ( $ p , $ i , $ k ) + MatrixChainOrder ( $ p , $ k + 1 , $ j ) + $ p [ $ i - 1 ] * $ p [ $ k ] * $ p [ $ j ] ; if ( $ count < $ min ) $ min = $ count ; } return $ min ; } $ arr = array ( 1 , 2 , 3 , 4 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" . MatrixChainOrder ( $ arr , 1 , $ n - 1 ) ; ? >"}
{"text": "Semak jika rentetan boleh diulang untuk membuat rentetan lain | Berfungsi untuk mengembalikan kiraan pengulangan String A untuk menjana rentetan b; Jika B tidak dapat dihasilkan dengan mengulangi A; Ulangi bilangan kiraan mengulangi jumlah kiraan kali; Kod pemacu", "code": "< ? php function getCount ( $ a , $ b ) { if ( strlen ( $ b ) % strlen ( $ a ) != 0 ) return -1 ; $ count = floor ( strlen ( $ b ) / strlen ( $ a ) ) ; $ str = \" \" ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ str = $ str . $ a ; } if ( strcmp ( $ a , $ b ) ) return $ count ; return -1 ; } $ a = ' eeks ' $ b = ' eeksgeeks ' echo getCount ( $ a , $ b ) ; ? >"}
{"text": "Count kejadian corak \"1 (0 +) 1\" dalam rentetan | Mengembalikan kiraan kejadian \"1 (0 +) 1\"; $ count = 0; Memulakan hasil; Semak jika ditemui '1' membentuk corak yang sah seperti yang ditentukan; jika 1 ditemui untuk pertama kali ditetapkan satu ke 1; Semak jika terdapat watak lain selain daripada '0' atau '1'. Jika demikian kemudian tetapkan Oneseen hingga 0 untuk mencari lagi untuk corak baru; Kod pemacu", "code": "< ? php function countPattern ( $ str ) { $ len = strlen ( $ str ) ; $ oneSeen = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == '1' && $ oneSeen == 1 ) if ( $ str [ $ i - 1 ] == '0' ) $ count ++ ; if ( $ str [ $ i ] == '1' && $ oneSeen == 0 ) $ oneSeen = 1 ; if ( $ str [ $ i ] != '0' && $ str [ $ i ] != '1' ) $ oneSeen = 0 ; } return $ count ; } $ str = \"100001abc101\" ; echo countPattern ( $ str ) ; ? >"}
{"text": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar rentetan ke rentetan lain | Berfungsi untuk mengembalikan operasi minimum jenis yang diberikan untuk menukar rentetan s ke rentetan t; Watak sudah sama; Kiraan kenaikan 0 s; Kiraan kenaikan 1 s; Kod pemacu", "code": "< ? php function minOperations ( $ s , $ t , $ n ) { $ ct0 = 0 ; $ ct1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ t [ $ i ] ) continue ; if ( $ s [ $ i ] == '0' ) $ ct0 ++ ; else $ ct1 ++ ; } return max ( $ ct0 , $ ct1 ) ; } $ s = \"010\" ; $ t = \"101\" ; $ n = strlen ( $ s ) ; echo minOperations ( $ s , $ t , $ n ) ; ? >"}
{"text": "Dekripsi rentetan yang disulitkan dengan mengulangi i | Berfungsi untuk mengembalikan rentetan yang disahsulit; Lompat awal akan menjadi 1; Lompat kenaikan sebanyak 1 dengan setiap watak; Kod pemacu", "code": "< ? php function decryptString ( $ str , $ n ) { $ i = 0 ; $ jump = 1 ; $ decryptedStr = \" \" ; while ( $ i < $ n ) { $ decryptedStr . = $ str [ $ i ] ; $ i += $ jump ; $ jump ++ ; } return $ decryptedStr ; } $ str = \" geeeeekkkksssss \" ; $ n = strlen ( $ str ) ; echo decryptString ( $ str , $ n ) ; ? >"}
{"text": "Cari bit yang flip urutan minimum menjadikan semua bit sama | Fungsi untuk memeriksa bit mana yang akan dibalik; pembolehubah untuk menyimpan watak pertama dan terakhir rentetan; Semak sama ada aksara pertama dan terakhir adalah sama, jika ya, kemudian kembalikan watak yang tidak akhirnya; lain kembali terakhir; Kod pemacu", "code": "< ? php function bitToBeFlipped ( $ s ) { $ last = $ s [ strlen ( $ s ) - 1 ] ; $ first = $ s [ 0 ] ; if ( $ last == $ first ) { if ( $ last == '0' ) { return '1' ; } else { return '0' ; } } else if ( $ last != $ first ) { return $ last ; } } $ s = \"1101011000\" ; echo bitToBeFlipped ( $ s ) ; ? >"}
{"text": "Jumlah semua berikutnya nombor | Mengembalikan nilai angka berikutnya S. Berikutnya yang akan dipilih diputuskan menggunakan corak bit num (kami memilih semua thedigits yang mana terdapat set bit dalam NUM); Memulakan hasilnya; sehingga n! = 0; Jika saya - bit ditetapkan maka tambahkan nombor ini; shintift kanan i; fungsi untuk mencari jumlah gabungan semua jumlah keseluruhan individu; panjang rentetan; menyimpan gabungan; 2 ^ n - 1 berikutnya; gelung untuk semua berikutnya; mengembalikan jumlah gabungan; Kod pemacu", "code": "< ? php function findSubSequence ( $ s , $ num ) { $ res = 0 ; $ i = 0 ; while ( $ num ) { if ( $ num & 1 ) $ res += $ s [ $ i ] - '0' ; $ i ++ ; $ num = $ num >> 1 ; } return $ res ; } function combinedSum ( string $ s ) { $ n = strlen ( $ s ) ; $ c_sum = 0 ; $ range = ( 1 << $ n ) - 1 ; for ( $ i = 0 ; $ i <= $ range ; $ i ++ ) $ c_sum += findSubSequence ( $ s , $ i ) ; return $ c_sum ; } $ s = \"123\" ; echo combinedSum ( $ s ) ; ? >"}
{"text": "Susunan terpanjang di mana setiap watak berlaku sekurang -kurangnya k kali | Berfungsi untuk mencari berikutnya; Mengambil array tambahan untuk menyimpan rekod untuk kiraan watak dalam s; Mengira kejadian semua aksara dalam STR []; Percetakan aksara dengan kiraan> = k dalam susunan yang sama kerana ia muncul dalam str. ; Kod pemacu", "code": "< ? php function findSubsequence ( $ str , $ k ) { $ a = array ( 1024 ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ a [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ temp = ord ( $ str [ $ i ] ) - ord ( ' a ' ) ; $ a [ $ temp ] += 1 ; } for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ a [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] >= $ k ) echo $ str [ $ i ] ; } $ k = 2 ; findSubsequence ( \" geeksforgeeks \" , $ k ) ; ? >"}
{"text": "Google Case Of A Sentyen tertentu | Program PHP untuk menukar ayat ke Google Case. ; rentetan kosong; menukar input ke atas kes; checki jika watak bukan ruang dan menambahkannya kepada $ w; Menukar watak pertama ke kes yang lebih rendah dan huruf awal berikutnya perkataan lain kepada kes yang lebih rendah; Kod pemacu", "code": "< ? php function convert ( $ str ) { $ w = \" \" ; $ z = \" \" ; $ str = strtoupper ( $ str ) . \" ▁ \" ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ ch != ' ▁ ' ) $ w = $ w . $ ch ; else { $ z = $ z . strtolower ( $ w [ 0 ] ) . substr ( $ w , 1 ) . \" ▁ \" ; $ w = \" \" ; } } return $ z ; } $ str = \" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks \" ; echo ( convert ( $ str ) ) ; ? >"}
{"text": "Kira kejadian perkataan dalam rentetan | Program PHP untuk mengira bilangan berlakunya perkataan dalam rentetan yang diberikan; berpecah rentetan dengan ruang; Cari corak dalam rentetan; jika perlawanan mendapati kenaikan kiraan; Kod pemacu", "code": "< ? php function countOccurrences ( $ str , $ word ) { $ a = explode ( \" ▁ \" , $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { if ( $ word == $ a [ $ i ] ) $ count ++ ; } return $ count ; } $ str = \" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ \" ; $ word = \" portal \" ; echo ( countOccurrences ( $ str , $ word ) ) ; ? >"}
{"text": "Tinggalkan rentetan dengan menukar kes | Berfungsi untuk menjana permutasi; Bilangan permutasi adalah 2 ^ n; Menukar rentetan ke kes yang lebih rendah; Menggunakan semua berikutnya dan membenarkannya; Jika b - th bit ditetapkan, kami menukarnya ke atas kes; Mencetak gabungan semasa; Kod pemacu", "code": "< ? php function permute ( $ input ) { $ n = strlen ( $ input ) ; $ max = 1 << $ n ; $ input = strtolower ( $ input ) ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { $ combination = $ input ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( ( $ i >> $ j ) & 1 ) == 1 ) $ combination [ $ j ] = chr ( ord ( $ combination [ $ j ] ) - 32 ) ; } echo $ combination . \" \" ; } } permute ( \" ABC \" ) ; ? >"}
{"text": "Bilangan minimum Palindromic selepas dikeluarkan untuk mengosongkan rentetan binari | Fungsi untuk memeriksa sama ada string str adalah palindrome; Bermula dari sudut paling kiri dan paling kanan Str; Terus membandingkan watak semasa mereka sama; Mengembalikan kiraan minimum Palindromic selepas dikeluarkan untuk membuat rentetan kosong; Jika rentetan kosong; Jika rentetan adalah palindrome; Jika rentetan bukan palindrome; Kod pemacu", "code": "< ? php function isPalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) - 1 ; while ( $ h > $ l ) if ( $ str [ $ l ++ ] != $ str [ $ h -- ] ) return false ; return true ; } function minRemovals ( $ str ) { if ( $ str [ 0 ] == ' ' ) return 0 ; if ( isPalindrome ( $ str ) ) return 1 ; return 2 ; } echo minRemovals ( \" 010010 \" ) , \" STRNEWLINE \" ; echo minRemovals ( \" 0100101 \" ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari nilai xxxx .... . (N kali) % m di mana n adalah besar | Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y 2; Fungsi untuk mengembalikan xxx .... . (N kali) % m; Mengembalikan mod dengan m nombor yang lebih kecil; Mewujudkan rentetan n x 's; Menukar rentetan ke int dan mengira modulo; Memeriksa pariti n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk ganjil n; Kod pemacu; Cetak xxx ... (n kali) % m", "code": "< ? php function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ y = $ y >> 1 ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } function findModuloByM ( $ X , $ N , $ M ) { if ( $ N < 6 ) { $ temp = chr ( 48 + $ X ) * $ N ; $ res = intval ( $ temp ) % $ M ; return $ res ; } if ( $ N % 2 == 0 ) { $ half = findModuloByM ( $ X , ( int ) ( $ N / 2 ) , $ M ) % $ M ; $ res = ( $ half * power ( 10 , ( int ) ( $ N / 2 ) , $ M ) + $ half ) % $ M ; return $ res ; } else { $ half = findModuloByM ( $ X , ( int ) ( $ N / 2 ) , $ M ) % $ M ; $ res = ( $ half * power ( 10 , ( int ) ( $ N / 2 ) + 1 , $ M ) + $ half * 10 + $ X ) % $ M ; return $ res ; } } $ X = 6 ; $ N = 14 ; $ M = 9 ; print ( findModuloByM ( $ X , $ N , $ M ) ) ; ? >"}
{"text": "Panjang tangen biasa langsung antara dua lingkaran bersilang | Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "< ? php function lengtang ( $ r1 , $ r2 , $ d ) { echo \" The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ \" , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) ; } $ r1 = 4 ; $ r2 = 6 ; $ d = 3 ; lengtang ( $ r1 , $ r2 , $ d ) ; ? >"}
{"text": "Radius bulatan apabila lebar dan ketinggian arka diberikan | Berfungsi untuk mencari jejari; Kod pemacu", "code": "< ? php function rad ( $ d , $ h ) { echo \" The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ \" , ( ( $ d * $ d ) / ( 8 * $ h ) + $ h / 2 ) , \" STRNEWLINE \" ; } $ d = 4 ; $ h = 1 ; rad ( $ d , $ h ) ; ? >"}
{"text": "Jarak terpendek dari pusat bulatan ke kord | Berfungsi untuk mencari jarak terpendek; Kod pemacu", "code": "< ? php function shortdis ( $ r , $ d ) { echo \" The ▁ shortest ▁ distance ▁ \" ; echo \" from ▁ the ▁ chord ▁ to ▁ centre ▁ \" ; echo sqrt ( ( $ r * $ r ) - ( ( $ d * $ d ) / 4 ) ) ; } $ r = 4 ; $ d = 3 ; shortdis ( $ r , $ d ) ; ? >"}
{"text": "Panjang tangen biasa langsung antara kedua -dua bukan | Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "< ? php function lengtang ( $ r1 , $ r2 , $ d ) { echo \" The ▁ length ▁ of ▁ the ▁ direct \" , \" ▁ common ▁ tangent ▁ is ▁ \" , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) , \" STRNEWLINE \" ; } $ r1 = 4 ; $ r2 = 6 ; $ d = 12 ; lengtang ( $ r1 , $ r2 , $ d ) ; ? >"}
{"text": "Dataran terbesar yang boleh ditulis dalam segitiga sama rata | Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu", "code": "< ? php function square ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; return $ x ; } $ a = 5 ; echo square ( $ a ) ; ? >"}
{"text": "Apothem A N | Berfungsi untuk mencari apothem poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah ditukar kepada radian; Kod pemacu", "code": "< ? php function polyapothem ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return $ a / ( 2 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; } $ a = 9 ; $ n = 6 ; echo polyapothem ( $ n , $ a ) . \" STRNEWLINE \" ; ? >"}
{"text": "Kawasan n | Berfungsi untuk mencari kawasan poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "< ? php function polyarea ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; $ A = ( $ a * $ a * $ n ) / ( 4 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; return $ A ; } $ a = 9 ; $ n = 6 ; echo round ( polyarea ( $ n , $ a ) , 3 ) ; ? >"}
{"text": "Sisi biasa n | Fungsi untuk mengira sisi poligon yang dilampirkan dalam bulatan; Jumlah sisi poligon; Jejari lingkaran lingkungan", "code": "< ? php function calculateSide ( $ n , $ r ) { $ theta ; $ theta_in_radians ; $ theta = 360 / $ n ; $ theta_in_radians = $ theta * 3.14 / 180 ; return 2 * $ r * sin ( $ theta_in_radians / 2 ) ; } $ n = 3 ; $ r = 5 ; echo calculateSide ( $ n , $ r ) ; ? >"}
{"text": "Silinder bulat kanan terbesar dalam frustum | Berfungsi untuk mencari silinder bulat kanan terbesar; Radii dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "< ? php function cyl ( $ r , $ R , $ h ) { if ( $ h < 0 && $ r < 0 && $ R < 0 ) return -1 ; $ r1 = $ r ; $ h1 = $ h ; $ V = ( 3.14 * pow ( $ r1 , 2 ) * $ h1 ) ; return $ V ; } $ r = 7 ; $ R = 11 ; $ h = 6 ; echo cyl ( $ r , $ R , $ h ) ;"}
{"text": "Program untuk mencari perimeter poligon biasa | Berfungsi untuk mengira perimeter; Hitung perimeter; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter", "code": "< ? php function Perimeter ( $ s , $ n ) { $ perimeter = 1 ; $ perimeter = $ n * $ s ; return $ perimeter ; } $ n = 5 ; $ s = 2.5 ; $ peri = Perimeter ( $ s , $ n ) ; echo \" Perimeter ▁ of ▁ Regular ▁ Polygon \" , \" ▁ with ▁ \" , $ n , \" ▁ sides ▁ of ▁ length ▁ \" , $ s , \" ▁ = ▁ \" , $ peri ; ? >"}
{"text": "Kawasan rombang terbesar yang boleh ditulis dalam segi empat tepat | Berfungsi untuk mencari kawasan rombus terbesar; Panjang dan keluasan tidak boleh negatif; kawasan rhombus; Kod pemacu", "code": "< ? php function rhombusarea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; return ( $ l * $ b ) / 2 ; } $ l = 16 ; $ b = 6 ; echo rhombusarea ( $ l , $ b ) . \" STRNEWLINE \" ;"}
{"text": "Semak jika titik terletak di dalam segi empat tepat | Set | Fungsi untuk mencari jika titik diberikan terletak di dalam segi empat tepat atau tidak. ; bawah - kiri dan atas - sudut kanan segi empat tepat; titik yang diberikan; panggilan fungsi", "code": "< ? php function FindPoint ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) { if ( $ x > $ x1 and $ x < $ x2 and $ y > $ y1 and $ y < $ y2 ) return true ; return false ; } $ x1 = 0 ; $ y1 = 0 ; $ x2 = 10 ; $ y2 = 8 ; $ x = 1 ; $ y = 5 ; if ( FindPoint ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Jarak antara satu titik dan satah dalam 3 D | Berfungsi untuk mencari jarak; Kod pemacu; panggilan fungsi", "code": "< ? php function shortest_distance ( $ x1 , $ y1 , $ z1 , $ a , $ b , $ c , $ d ) { $ d = abs ( ( $ a * $ x1 + $ b * $ y1 + $ c * $ z1 + $ d ) ) ; $ e = sqrt ( $ a * $ a + $ b * $ b + $ c * $ c ) ; echo \" Perpendicular ▁ distance ▁ is ▁ \" . $ d / $ e ; } $ x1 = 4 ; $ y1 = -4 ; $ z1 = 3 ; $ a = 2 ; $ b = -2 ; $ c = 5 ; $ d = 8 ; shortest_distance ( $ x1 , $ y1 , $ z1 , $ a , $ b , $ c , $ d ) ; ? >"}
{"text": "Program untuk mencari jumlah prisma segi tiga | berfungsi untuk mencari jumlah prisma segi tiga; formula untuk mencari kelantangan; Kod pemacu; fungsi panggilan", "code": "< ? php function findVolume ( $ l , $ b , $ h ) { $ volume = ( $ l * $ b * $ h ) / 2 ; return $ volume ; } $ l = 18 ; $ b = 12 ; $ h = 9 ; echo \" Volume ▁ of ▁ triangular ▁ prism : ▁ \" . findVolume ( $ l , $ b , $ h ) ; ? >"}
{"text": "Program untuk mencari pertengahan | berfungsi untuk mencari titik tengah garis; Kod pemacu", "code": "< ? php function midpoint ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . \" ▁ , ▁ \" . ( float ) ( $ y1 + $ y2 ) / 2 ) ; } $ x1 = -1 ; $ y1 = 2 ; $ x2 = 3 ; $ y2 = -6 ; midpoint ( $ x1 , $ x2 , $ y1 , $ y2 ) ; ? >"}
{"text": "Panjang arka dari sudut yang diberikan | fungsi untuk mengira panjang arka; Kod pemacu", "code": "< ? php function arcLength ( $ diameter , $ angle ) { $ pi = 22.0 / 7.0 ; $ arc ; if ( $ angle >= 360 ) { echo \" Angle ▁ cannot \" , \" ▁ be ▁ formed \" ; return 0 ; } else { $ arc = ( $ pi * $ diameter ) * ( $ angle / 360.0 ) ; return $ arc ; } } $ diameter = 25.0 ; $ angle = 45.0 ; $ arc_len = arcLength ( $ diameter , $ angle ) ; echo ( $ arc_len ) ; ? >"}
{"text": "Semak sama ada garis menyentuh atau memotong bulatan | Program PHP untuk memeriksa sama ada garis menyentuh atau bersilang atau di luar bulatan. ; Mencari jarak garis dari pusat. ; Memeriksa jika jarak kurang daripada, lebih besar daripada atau sama dengan radius. ; Kod pemacu", "code": "< ? php function checkCollision ( $ a , $ b , $ c , $ x , $ y , $ radius ) { $ dist = ( abs ( $ a * $ x + $ b * $ y + $ c ) ) / sqrt ( $ a * $ a + $ b * $ b ) ; if ( $ radius == $ dist ) echo \" Touch \" ; else if ( $ radius > $ dist ) echo \" Intersect \" ; else echo \" Outside \" ; } $ radius = 5 ; $ x = 0 ; $ y = 0 ; $ a = 3 ; $ b = 4 ; $ c = 25 ; checkCollision ( $ a , $ b , $ c , $ x , $ y , $ radius ) ; ? >"}
{"text": "Program untuk mencari kawasan segitiga | (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; J adalah puncak sebelumnya kepada i; Kembali nilai mutlak; Kod pemacu", "code": "< ? php function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; } $ X = array ( 0 , 2 , 4 ) ; $ Y = array ( 1 , 3 , 7 ) ; $ n = count ( $ X ) ; echo polygonArea ( $ X , $ Y , $ n ) ; ? >"}
{"text": "Cari purata dua nombor menggunakan operasi bit | Berfungsi untuk mengembalikan purata x dan y menggunakan operasi bit; Kirakan nilai lantai purata (x + y) / 2; Kod pemacu", "code": "< ? php function getAverage ( $ x , $ y ) { $ avg = ( $ x & $ y ) + ( ( $ x ^ $ y ) >> 1 ) ; return $ avg ; } $ x = 10 ; $ y = 9 ; echo getAverage ( $ x , $ y ) ; ? >"}
{"text": "Indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya | Berfungsi untuk mencari indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya; Pada mulanya; Melintasi array; Semak jika elemen array adalah 1; a [i] = 0; Kembali minimum kedua -duanya; Kod pemacu", "code": "< ? php function smallestIndex ( $ a , $ n ) { $ right1 = 0 ; $ right0 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ right1 = $ i ; else $ right0 = $ i ; } return min ( $ right1 , $ right0 ) ; } $ a = array ( 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ) ; $ n = sizeof ( $ a ) ; echo smallestIndex ( $ a , $ n ) ; ? >"}
{"text": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Tetapkan 2 | Berfungsi untuk mengembalikan kiraan dataran yang boleh dikunjungi oleh raja dalam gerakan; Untuk menyimpan kiraan dataran; Semak semua dataran papan catur; Semak jika persegi (i, j) berada pada jarak <= m unit dari kedudukan semasa Raja; Kembali kiraan kuadrat; Kod pemacu", "code": "< ? php function countSquares ( $ r , $ c , $ m ) { $ squares = 0 ; for ( $ i = 1 ; $ i <= 8 ; $ i ++ ) { for ( $ j = 1 ; $ j <= 8 ; $ j ++ ) { if ( max ( abs ( $ i - $ r ) , abs ( $ j - $ c ) ) <= $ m ) $ squares ++ ; } } return $ squares ; } $ r = 4 ; $ c = 4 ; $ m = 1 ; echo countSquares ( $ r , $ c , $ m ) ; ? >"}
{"text": "Nombor dalam julat dengan akar digital yang diberikan | Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor yang ada dalam julat yang diberikan; Bilangan kumpulan 9 elemen bermula dari L; Meninggalkan unsur -unsur yang tidak diliputi dalam Faktor 9; Satu nombor dalam setiap kumpulan 9; Untuk memeriksa sama ada nombor dalam REM memenuhi harta itu; Kod pemacu", "code": "< ? php function countNumbers ( $ L , $ R , $ K ) { if ( $ K == 9 ) $ K = 0 ; $ totalnumbers = $ R - $ L + 1 ; $ factor9 = intval ( $ totalnumbers / 9 ) ; $ rem = $ totalnumbers % 9 ; $ ans = $ factor9 ; for ( $ i = $ R ; $ i > $ R - $ rem ; $ i -- ) { $ rem1 = $ i % 9 ; if ( $ rem1 == $ K ) $ ans ++ ; } return $ ans ; } $ L = 10 ; $ R = 22 ; $ K = 3 ; echo countNumbers ( $ L , $ R , $ K ) ; ? >"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Jika elemen semasa adalah walaupun; Jika elemen bahkan kemudian keluarkannya dari jumlah; Jika nilai menjadi walaupun selepas mengemas kini; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "< ? php function BalanceArray ( $ A , & $ Q ) { $ ANS = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] % 2 == 0 ) $ sum = $ sum + $ A [ $ i ] ; for ( $ i = 0 ; $ i < count ( $ Q ) ; $ i ++ ) { $ index = $ Q [ $ i ] [ 0 ] ; $ value = $ Q [ $ i ] [ 1 ] ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum - $ A [ $ index ] ; $ A [ $ index ] = $ A [ $ index ] + $ value ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum + $ A [ $ index ] ; array_push ( $ ANS , $ sum ) ; } for ( $ i = 0 ; $ i < count ( $ ANS ) ; $ i ++ ) echo $ ANS [ $ i ] . \" ▁ \" ; } $ A = array ( 1 , 2 , 3 , 4 ) ; $ Q = array ( array ( 0 , 1 ) , array ( 1 , -3 ) , array ( 0 , -4 ) , array ( 3 , 2 ) ) ; BalanceArray ( $ A , $ Q ) ; ? >"}
{"text": "Bilangan Siklus Hamiltonian | Fungsi yang mengira bilangan kitaran Hamiltonian; Mengira faktorial; Kod pemacu", "code": "< ? php function Cycles ( $ N ) { $ fact = 1 ; $ result = 0 ; $ result = $ N - 1 ; $ i = $ result ; while ( $ i > 0 ) { $ fact = $ fact * $ i ; $ i -- ; } return floor ( $ fact / 2 ) ; } $ N = 5 ; $ Number = Cycles ( $ N ) ; echo \" Hamiltonian ▁ cycles ▁ = ▁ \" , $ Number ; ? >"}
{"text": "Integer terkecil lebih besar daripada n sedemikian rupa sehingga ia terdiri daripada digit m tepat kali K | Fungsi yang pulih benar jika n mengandungi digit m tepat k kali; Berfungsi untuk mengembalikan integer terkecil> n dengan digit m yang berlaku tepat kali K; Kod pemacu", "code": "< ? php function digitWell ( $ n , $ m , $ k ) { $ cnt = 0 ; while ( $ n > 0 ) { if ( $ n % 10 == $ m ) ++ $ cnt ; $ n = floor ( $ n / 10 ) ; } return $ cnt == $ k ; } function findInt ( $ n , $ m , $ k ) { $ i = $ n + 1 ; while ( true ) { if ( digitWell ( $ i , $ m , $ k ) ) return $ i ; $ i ++ ; } } $ n = 111 ; $ m = 2 ; $ k = 2 ; echo findInt ( $ n , $ m , $ k ) ; ? >"}
{"text": "KOMPOSITE XOR DAN COPRIME DAN | Berfungsi untuk mengembalikan kiraan nombor ganjil dalam array; Pembolehubah untuk mengira nombor ganjil; Nombor ganjil; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "< ? php function countOdd ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 1 ) $ odd ++ ; } return $ odd ; } function countValidPairs ( $ arr , $ n ) { $ odd = countOdd ( $ arr , $ n ) ; return ( $ odd * ( $ odd - 1 ) ) / 2 ; } $ arr = array ( 1 , 2 , 3 , 4 , 5 ) ; $ n = sizeof ( $ arr ) ; echo countValidPairs ( $ arr , $ n ) ; ? >"}
{"text": "Cube sempurna terkecil dibahagi dengan semua elemen array | Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan LCM semua elemen array; Untuk mengira LCM dua nombor melipatgandakan mereka dan membahagikan hasilnya dengan GCD kedua -dua nombor; Mengembalikan LCM unsur -unsur array; Berfungsi untuk mengembalikan kiub sempurna yang paling kecil yang boleh dibahagikan dengan semua elemen arr []; LCM semua elemen ARR []; Jika 2 membahagikan bilangan kali LCM CNT; Semak semua nombor yang membahagikan LCM; Kembalikan jawapannya; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; else return gcd ( $ b , $ a % $ b ) ; } function lcmOfArray ( & $ arr , $ n ) { if ( $ n < 1 ) return 0 ; $ lcm = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ lcm = ( $ lcm * $ arr [ $ i ] ) / gcd ( $ lcm , $ arr [ $ i ] ) ; return $ lcm ; } function minPerfectCube ( & $ arr , $ n ) { $ lcm = lcmOfArray ( $ arr , $ n ) ; $ minPerfectCube = $ lcm ; $ cnt = 0 ; while ( $ lcm > 1 && $ lcm % 2 == 0 ) { $ cnt ++ ; $ lcm /= 2 ; } if ( $ cnt % 3 == 2 ) $ minPerfectCube *= 2 ; else if ( $ cnt % 3 == 1 ) $ minPerfectCube *= 4 ; $ i = 3 ; while ( $ lcm > 1 ) { $ cnt = 0 ; while ( $ lcm % $ i == 0 ) { $ cnt ++ ; $ lcm /= $ i ; } if ( $ cnt % 3 == 1 ) $ minPerfectCube *= $ i * $ i ; else if ( $ cnt % 3 == 2 ) $ minPerfectCube *= $ i ; $ i += 2 ; } return $ minPerfectCube ; } $ arr = array ( 10 , 125 , 14 , 42 , 100 ) ; $ n = sizeof ( $ arr ) ; echo ( minPerfectCube ( $ arr , $ n ) ) ; ? >"}
{"text": "Semak jika n adalah Perdana yang kuat | Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah perdana yang kuat; Jika n bukan nombor perdana atau n adalah perdana pertama maka kembali palsu; Inisialisasi sebelumnya_prime ke n - 1 dan next_prime ke n + 1; Cari nombor perdana seterusnya; Cari nombor perdana sebelumnya; Min aritmetik; Jika n adalah perdana yang kuat; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function isStrongPrime ( $ n ) { if ( ! isPrime ( $ n ) $ n == 2 ) return false ; $ previous_prime = $ n - 1 ; $ next_prime = $ n + 1 ; while ( ! isPrime ( $ next_prime ) ) $ next_prime ++ ; while ( ! isPrime ( $ previous_prime ) ) $ previous_prime -- ; $ mean = ( $ previous_prime + $ next_prime ) / 2 ; if ( $ n > $ mean ) return true ; else return false ; } $ n = 11 ; if ( isStrongPrime ( $ n ) ) echo ( \" Yes \" ) ; else echo ( \" No \" ) ; ? >"}
{"text": "Penyingkiran minimum dalam nombor yang boleh dibahagikan dengan 10 kuasa yang dibangkitkan kepada k | berfungsi untuk mengembalikan bilangan digit yang diperlukan untuk dikeluarkan; Menukar nombor yang diberikan ke dalam rentetan; pembolehubah untuk menyimpan nombor digit yang akan dikeluarkan; Pembolehubah untuk menunjukkan jika sekurang -kurangnya satu sifar telah dijumpai; sifar dijumpai; saiz pulangan - 1 jika k tidak sifar dan atleast satu sifar hadir, jika tidak hasilnya; Kod pemacu untuk menguji fungsi di atas", "code": "< ? php function countDigitsToBeRemoved ( $ N , $ K ) { $ s = strval ( $ N ) ; $ res = 0 ; $ f_zero = 0 ; for ( $ i = strlen ( $ s ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ K == 0 ) return $ res ; if ( $ s [ $ i ] == '0' ) { $ f_zero = 1 ; $ K -- ; } else $ res ++ ; } if ( ! $ K ) return $ res ; else if ( $ f_zero ) return strlen ( $ s ) - 1 ; return -1 ; } $ N = 10904025 ; $ K = 2 ; echo countDigitsToBeRemoved ( $ N , $ K ) . \" \" ; $ N = 1000 ; $ K = 5 ; echo countDigitsToBeRemoved ( $ N , $ K ) . \" \" ; $ N = 23985 ; $ K = 2 ; echo countDigitsToBeRemoved ( $ N , $ K ) ; ? >"}
{"text": "Program untuk mencari jumlah siri (1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n) | Berfungsi untuk mengembalikan jumlah siri; pembolehubah untuk menyimpan jawapannya; Matematik. pow (x, y) mengembalikan x ^ y; Kod pemacu; Cetak jumlah siri", "code": "< ? php function getSum ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ sum += ( $ i / pow ( $ a , $ i ) ) ; } return $ sum ; } $ a = 3 ; $ n = 3 ; echo ( getSum ( $ a , $ n ) ) ; ? >"}
{"text": "Semak sama ada nombor adalah nombor yang tidak biasa atau tidak | Fungsi utiliti untuk mencari faktor utama terbesar bagi nombor; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; $ n >> = 1; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya untuk bilangan bulat yang ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk memeriksa nombor yang tidak biasa; Dapatkan faktor utama terbesar nombor; Semak jika faktor utama terbesar adalah lebih besar daripada sqrt (n); Kod pemacu", "code": "< ? php function largestPrimeFactor ( $ n ) { $ max = -1 ; while ( $ n % 2 == 0 ) { $ max = 2 ; } for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i += 2 ) { while ( $ n % $ i == 0 ) { $ max = $ i ; $ n = $ n / $ i ; } } if ( $ n > 2 ) $ max = $ n ; return $ max ; } function checkUnusual ( $ n ) { $ factor = largestPrimeFactor ( $ n ) ; if ( $ factor > sqrt ( $ n ) ) { return true ; } else { return false ; } } $ n = 14 ; if ( checkUnusual ( $ n ) ) { echo \" YES \" . \" STRNEWLINE \" ; } else { echo \" NO \" . \" STRNEWLINE \" ; } ? >"}
{"text": "Semak jika sekurang -kurangnya separuh array boleh diturunkan kepada sifar dengan melakukan beberapa operasi | Berfungsi untuk mencetak hasil yang diingini selepas pengiraan; Kod pemacu", "code": "< ? php function isHalfReducible ( $ arr , $ n , $ m ) { $ frequencyHash = array_fill ( 0 , $ m + 1 , 0 ) ; $ i = 0 ; for ( ; $ i < $ n ; $ i ++ ) { $ frequencyHash [ ( $ arr [ $ i ] % ( $ m + 1 ) ) ] ++ ; } for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { if ( $ frequencyHash [ $ i ] >= ( $ n / 2 ) ) break ; } if ( $ i <= $ m ) echo \" Yes STRNEWLINE \" ; else echo \" No STRNEWLINE \" ; } $ arr = array ( 8 , 16 , 32 , 3 , 12 ) ; $ n = sizeof ( $ arr ) ; $ m = 7 ; isHalfReducible ( $ arr , $ n , $ m ) ; ? >"}
{"text": "Semak sama ada nombor yang diberikan ialah Wagstaff Prime atau tidak | Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi utiliti untuk memeriksa kuasa dua; Kod pemacu; Semak jika nombor adalah perdana dan borang (2 ^ q + 1) / 3", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 or $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 or $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } function isPowerOfTwo ( $ n ) { return ( $ n && ! ( $ n & ( $ n - 1 ) ) ) ; } $ n = 43 ; if ( isPrime ( $ n ) && ( isPowerOfTwo ( $ n * 3 - 1 ) ) ) { echo \" YES \" ; } else { echo \" NO \" ; } ? >"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segi enam | Berfungsi untuk mencari kawasan dataran; sisi segi enam tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "< ? php function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( ( $ a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return $ area ; } $ a = 5 ; echo area ( $ a ) . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk mencari istilah n Siri 1, 6, 17, 34, 56, 86, 121, 162, ... .... | mengira istilah siri nth; Kod pemacu", "code": "< ? php function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) - 4 * $ n + 2 ; } $ N = 4 ; echo nthTerm ( $ N ) . \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah terma pertama N Siri 2, 10, 30, 68, .... | Berfungsi untuk mengira jumlah; bilangan syarat yang akan dimasukkan dalam jumlah; Cari jumlahnya", "code": "< ? php function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + pow ( ( $ n * ( $ n + 1 ) / 2 ) , 2 ) ; } $ n = 3 ; echo \" Sum = \" ? >"}
{"text": "Semak jika dua tatasusunan adalah permutasi antara satu sama lain menggunakan operasi matematik | Fungsi untuk memeriksa sama ada tatasusunan adalah permutasi antara satu sama lain. ; Mengira jumlah dan kalikan array pertama; Mengira jumlah dan kalikan array kedua; Jika jumlah dan Mul kedua -dua tatasusunan adalah sama, kembali benar, lain kembali palsu. ; Kod pemacu", "code": "< ? php function arePermutations ( $ a , $ b , $ n , $ m ) { $ sum1 = 0 ; $ sum2 = 0 ; $ mul1 = 1 ; $ mul2 = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 += $ a [ $ i ] ; $ mul1 *= $ a [ $ i ] ; } for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { $ sum2 += $ b [ $ i ] ; $ mul2 *= $ b [ $ i ] ; } return ( ( $ sum1 == $ sum2 ) && ( $ mul1 == $ mul2 ) ) ; } $ a = array ( 1 , 3 , 2 ) ; $ b = array ( 3 , 1 , 2 ) ; $ n = sizeof ( $ a ) ; $ m = sizeof ( $ b ) ; if ( arePermutations ( $ a , $ b , $ n , $ m ) ) echo \" Yes \" . \" STRNEWLINE \" ; else echo \" No \" . \" STRNEWLINE \" ;"}
{"text": "Program untuk mencari permulaan dalam perlumbaan | Fungsi untuk mencari B mula c; Apabila B menyelesaikannya 100 meter kemudian selesai meter dengan C adalah; Kod pemacu; Apabila ia menyelesaikannya 100 meter kemudian selesai meter b dan c adalah", "code": "< ? php function Race ( $ B , $ C ) { $ result = 0 ; $ result = ( ( $ C * 100 ) / $ B ) ; return 100 - $ result ; } $ B = 10 ; $ C = 28 ; $ B = 100 - $ B ; $ C = 100 - $ C ; echo Race ( $ B , $ C ) . \" ▁ meters \" ; ? >"}
{"text": "Masa minimum diperlukan untuk mengisi tangki menggunakan paip n | Berfungsi untuk mengira masa; Kod pemacu", "code": "< ? php function T_ime ( $ arr , $ n , $ Emptypipe ) { $ fill = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ fill += 1 / $ arr [ $ i ] ; $ fill = $ fill - ( 1 / $ Emptypipe ) ; return 1 / $ fill ; } $ arr = array ( 12 , 14 ) ; $ Emptypipe = 30 ; $ n = count ( $ arr ) ; echo ( int ) T_ime ( $ arr , $ n , $ Emptypipe ) . \" ▁ Hours \" ; ? >"}
{"text": "Semak jika perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 | Berfungsi untuk memeriksa kebolehpasaran; Jumlah semua digit individu; Keadaan; Nombor oktal", "code": "< ? php function check ( $ n ) { $ sum = 0 ; while ( $ n != 0 ) { $ sum += $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ sum % 7 == 0 ) return 1 ; else return 0 ; } $ n = 25 ; ( check ( $ n ) == 1 ) ? print ( \" YES STRNEWLINE \" ) : print ( \" NO STRNEWLINE \" ) ; ? >"}
{"text": "Jumlah semua pembahagi utama nombor | Program PHP untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kod pemacu", "code": "< ? php $ N = 1000005 ; function isPrime ( $ n ) { global $ N ; if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return false ; return true ; } function SumOfPrimeDivisors ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( isPrime ( $ i ) ) $ sum += $ i ; } } return $ sum ; } $ n = 60 ; echo \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" . SumOfPrimeDivisors ( $ n ) ; ? >"}
{"text": "Jumlah semua pembahagi utama nombor | berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Kod pemacu", "code": "< ? php function Sum ( $ N ) { for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ SumOfPrimeDivisors [ $ i ] = 0 ; for ( $ i = 2 ; $ i <= $ N ; ++ $ i ) { if ( ! $ SumOfPrimeDivisors [ $ i ] ) { for ( $ j = $ i ; $ j <= $ N ; $ j += $ i ) { $ SumOfPrimeDivisors [ $ j ] += $ i ; } } } return $ SumOfPrimeDivisors [ $ N ] ; } $ N = 60 ; echo \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" . Sum ( $ N ) ; ? >"}
{"text": "Cari (a ^ b) % m di mana 'b' sangat besar | Berfungsi untuk mencari kuasa; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasilnya; y mestilah sekarang $ y = $ y >> 1; y = y / 2; Kod pemacu; Input rentetan sebagai B sangat besar; Kurangkan bilangan B ke bilangan kecil menggunakan fermat kecil", "code": "< ? php function power ( $ x , $ y , $ p ) { $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; } $ a = 3 ; $ b = \"100000000000000000000000000\" ; $ remainderB = 0 ; $ MOD = 1000000007 ; for ( $ i = 0 ; $ i < strlen ( $ b ) ; $ i ++ ) $ remainderB = ( $ remainderB * 10 + $ b [ $ i ] - '0' ) % ( $ MOD - 1 ) ; echo power ( $ a , $ remainderB , $ MOD ) ; ? >"}
{"text": "Kuadrat nombor dengan digit tunggal berulang | Tetapkan 1 (3, 6 dan 9) | Fungsi untuk mencari persegi 333. .. .333, 666. .666 dan 999.. .999; Sekiranya nombornya adalah 333. .. .333; Jika nombor itu 666. .. .666; Jika nombor itu 999 .. .999; pembolehubah untuk hasil pegangan; Cari tidak digit; tambah saiz - 1 kali dalam hasil; Tambah satu kali B hasil; tambah saiz - 1 kali c dalam hasil; tambah satu kali d hasil; hasil pulangan; Kod pemacu; Cari persegi 33. .33; cari persegi 66. .66; cari persegi 66. .66", "code": "< ? php function find_Square_369 ( $ num ) { if ( $ num [ 0 ] == '3' ) { $ a = '1' ; $ b = '0' ; $ c = '8' ; $ d = '9' ; } else if ( $ num [ 0 ] == '6' ) { $ a = '4' ; $ b = '3' ; $ c = '5' ; $ d = '6' ; } else { $ a = '9' ; $ b = '8' ; $ c = '0' ; $ d = '1' ; } $ result = \" \" ; $ size = strlen ( $ num ) ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ result = $ result . $ a ; $ result = $ result . $ b ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ result = $ result . $ c ; $ result = $ result . $ d ; return $ result ; } $ num_3 = \"3333\" ; $ num_6 = \"6666\" ; $ num_9 = \"9999\" ; $ result = \" \" ; $ result = find_Square_369 ( $ num_3 ) ; echo \" Square ▁ of ▁ \" . $ num_3 . \" ▁ is ▁ : ▁ \" . $ result . \" STRNEWLINE \" ; $ result = find_Square_369 ( $ num_6 ) ; echo \" Square ▁ of ▁ \" . $ num_6 . \" ▁ is ▁ : ▁ \" . $ result . \" STRNEWLINE \" ; $ result = find_Square_369 ( $ num_9 ) ; echo \" Square ▁ of ▁ \" . $ num_9 . \" ▁ is ▁ : ▁ \" . $ result . \" STRNEWLINE \" ; return 0 ; ? >"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) |", "code": "< ? php < ? php $ ans = 1 ; $ mod = 1000000007 * 120 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) $ ans = ( $ ans * ( 55555 - $ i ) ) % $ mod ; $ ans = $ ans / 120 ; echo \" Answer ▁ using ▁ shortcut : ▁ \" , $ ans ; ? >"}
{"text": "Cara untuk membiak elemen dengan operasi bersekutu | Fungsi untuk mencari faktorial yang diperlukan; Berfungsi untuk mencari NCR; berfungsi untuk mencari bilangan cara; Kod pemacu", "code": "< ? php function fact ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; $ ans = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans = $ ans * $ i ; return $ ans ; } function nCr ( $ n , $ r ) { $ Nr = $ n ; $ Dr = 1 ; $ ans = 1 ; for ( $ i = 1 ; $ i <= $ r ; $ i ++ ) { $ ans = ( $ ans * $ Nr ) / ( $ Dr ) ; $ Nr -- ; $ Dr ++ ; } return $ ans ; } function solve ( $ n ) { $ N = 2 * $ n - 2 ; $ R = $ n - 1 ; return nCr ( $ N , $ R ) * fact ( $ n - 1 ) ; } $ n = 6 ; echo solve ( $ n ) ; ? >"}
{"text": "Triplet Pythagorean dengan jumlah yang diberikan | Program PHP untuk mencari triplet Pythagorean yang diberikan. ; Memandangkan tiga kali ganda dalam urutan yang disusun. Nilai elemen pertama dalam triplet yang disusun boleh diadakan - kebanyakan n / 3 .; Nilai elemen kedua mestilah kurang daripada sama dengan n / 2; Kod pemacu", "code": "< ? php function pythagoreanTriplet ( $ n ) { for ( $ i = 1 ; $ i <= $ n / 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ n / 2 ; $ j ++ ) { $ k = $ n - $ i - $ j ; if ( $ i * $ i + $ j * $ j == $ k * $ k ) { echo $ i , \" , ▁ \" , $ j , \" , ▁ \" , $ k ; return ; } } } echo \" No ▁ Triplet \" ; } $ n = 12 ; pythagoreanTriplet ( $ n ) ; ? >"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | berfungsi untuk mengira faktorial nombor; berfungsi untuk mencetak siri; Mengira nilai n! ; gelung untuk memaparkan siri; Untuk mengira nilai NCR; mengira nilai A ke kuasa k dan x ke kuasa k; Paparkan siri; Kod pemacu", "code": "< ? php function factorial ( $ n ) { $ f = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ f *= $ i ; return $ f ; } function series ( $ A , $ X , $ n ) { $ nFact = factorial ( $ n ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) { $ niFact = factorial ( $ n - $ i ) ; $ iFact = factorial ( $ i ) ; $ aPow = pow ( $ A , $ n - $ i ) ; $ xPow = pow ( $ X , $ i ) ; echo ( $ nFact * $ aPow * $ xPow ) / ( $ niFact * $ iFact ) , \" \" ; } } $ A = 3 ; $ X = 4 ; $ n = 5 ; series ( $ A , $ X , $ n ) ; ? >"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | fungsi untuk mengira jumlah siri; Kod pemacu", "code": "< ? php function seiresSum ( $ n , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < 2 * $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ res += $ a [ $ i ] * $ a [ $ i ] ; else $ res -= $ a [ $ i ] * $ a [ $ i ] ; } return $ res ; } $ n = 2 ; $ a = array ( 1 , 2 , 3 , 4 ) ; echo seiresSum ( $ n , $ a ) ; ? >"}
{"text": "Kuasa nombor utama 'r' dalam n! | Berfungsi untuk mengembalikan kuasa no. 'r' dalam faktorial n; Terus membahagikan n dengan kuasa 'r' dan mengemaskini kiraan; Kod pemacu", "code": "< ? php function power ( $ n , $ r ) { $ count = 0 ; for ( $ i = $ r ; ( $ n / $ i ) >= 1 ; $ i = $ i * $ r ) $ count += $ n / $ i ; return $ count ; } $ n = 6 ; $ r = 3 ; echo power ( $ n , $ r ) ; ? >"}
{"text": "Purata nombor natural natur pertama | Mengembalikan AVG nombor n pertama; Jumlah nombor pertama yang pertama; Purata nombor pertama yang ganjil; Kod pemacu", "code": "< ? php function avg_of_odd_num ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( 2 * $ i + 1 ) ; return $ sum / $ n ; } $ n = 20 ; echo ( avg_of_odd_num ( $ n ) ) ; ? >"}
{"text": "Purata nombor natural natur pertama | Kembalikan purata jumlah nombor pertama yang ganjil; Kod pemacu", "code": "< ? php function avg_of_odd_num ( $ n ) { return $ n ; } $ n = 8 ; echo ( avg_of_odd_num ( $ n ) ) ; ? >"}
{"text": "Program untuk mencetak segitiga Fibonacci | berfungsi untuk mengisi nombor fibonacci dalam f []; 1 ST dan 2 ND nombor siri adalah 1 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Isi nombor Fibonacci dalam f [] menggunakan Fib (). Kami memerlukan n = n * (n + 1) / 2 nombor fibonacci untuk membuat segitiga ketinggian n; Untuk menyimpan nombor Fibonacci seterusnya untuk dicetak; untuk gelung untuk menjejaki bilangan baris; Untuk gelung untuk menjejaki nombor dalam setiap baris; Kod pemacu", "code": "< ? php function fib ( & $ f , $ N ) { $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ N ; $ i ++ ) $ f [ $ i ] = $ f [ $ i - 1 ] + $ f [ $ i - 2 ] ; } function fiboTriangle ( $ n ) { $ N = $ n * ( $ n + 1 ) / 2 ; $ f = array ( ) ; fib ( $ f , $ N ) ; $ fiboNum = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) echo ( $ f [ $ fiboNum ++ ] . \" ▁ \" ) ; echo ( \" STRNEWLINE \" ) ; } } $ n = 5 ; fiboTriangle ( $ n ) ; ? >"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Fungsi untuk mengira purata nombor ganjil; mengira nombor ganjil; Simpan jumlah nombor ganjil; Kod pemacu", "code": "< ? php function averageOdd ( $ n ) { if ( $ n % 2 == 0 ) { echo ( \" Invalid ▁ Input \" ) ; return -1 ; } $ sum = 0 ; $ count = 0 ; while ( $ n >= 1 ) { $ count ++ ; $ sum += $ n ; $ n = $ n - 2 ; } return $ sum / $ count ; } $ n = 15 ; echo ( averageOdd ( $ n ) ) ; ? >"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Fungsi untuk mengira purata nombor ganjil; Kod pemacu", "code": "< ? php function averageOdd ( $ n ) { if ( $ n % 2 == 0 ) { echo ( \" Invalid ▁ Input \" ) ; return -1 ; } return ( $ n + 1 ) / 2 ; } $ n = 15 ; echo ( averageOdd ( $ n ) ) ; ? >"}
{"text": "Trinomial Triangle | Fungsi untuk mencari nilai segitiga trinomial. ; Kes asas; Kes asas; langkah rekursif. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Kod pemacu", "code": "< ? php function TrinomialValue ( $ n , $ k ) { if ( $ n == 0 && $ k == 0 ) return 1 ; if ( $ k < - $ n $ k > $ n ) return 0 ; return TrinomialValue ( $ n - 1 , $ k - 1 ) + TrinomialValue ( $ n - 1 , $ k ) + TrinomialValue ( $ n - 1 , $ k + 1 ) ; } function printTrinomial ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = - $ i ; $ j <= 0 ; $ j ++ ) echo TrinomialValue ( $ i , $ j ) , \" ▁ \" ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) echo TrinomialValue ( $ i , $ j ) , \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 4 ; printTrinomial ( $ n ) ; ? >"}
{"text": "Trinomial Triangle | Program PHP untuk mencetak segitiga trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Menggunakan harta segitiga trinomial. ; Jika nilai sudah dikira, kembalikan itu. ; Kes asas; Kes asas; langkah rekursif dan menyimpan nilai. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Kod yang didorong", "code": "< ? php $ MAX = 10 ; function TrinomialValue ( $ dp , $ n , $ k ) { if ( $ k < 0 ) $ k = - $ k ; if ( $ dp [ $ n ] [ $ k ] != 0 ) return $ dp [ $ n ] [ $ k ] ; if ( $ n == 0 && $ k == 0 ) return 1 ; if ( $ k < - $ n $ k > $ n ) return 0 ; return ( $ dp [ $ n ] [ $ k ] = TrinomialValue ( $ dp , $ n - 1 , $ k - 1 ) + TrinomialValue ( $ dp , $ n - 1 , $ k ) + TrinomialValue ( $ dp , $ n - 1 , $ k + 1 ) ) ; } function printTrinomial ( $ n ) { global $ MAX ; $ dp ; for ( $ i = 0 ; $ i < $ MAX ; $ i ++ ) for ( $ j = 0 ; $ j < $ MAX ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = - $ i ; $ j <= 0 ; $ j ++ ) echo TrinomialValue ( $ dp , $ i , $ j ) . \" ▁ \" ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) echo TrinomialValue ( $ dp , $ i , $ j ) . \" ▁ \" ; echo \" STRNEWLINE \" ; } } $ n = 4 ; printTrinomial ( $ n ) ; ? >"}
{"text": "Jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N | fungsi untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan n; Buat array Integer \"Perdana [0 ... n]\" dan memulakan semua penyertaannya sebagai 0. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika 'i' adalah perdana, jika tidak, ia akan mengandungi faktor utama terbesar 'I'. ; Jika Perdana [P] adalah '0', maka ia adalah nombor utama; Kemas kini semua gandaan P; Merangkumi faktor utama terbesar bagi semua nombor; jika 'p' adalah nombor bukan utama maka perdana [p] memberikan faktor utama largesr; 'P' adalah nombor utama; Jumlah yang diperlukan; Program Pemandu untuk diuji di atas", "code": "< ? php function sumOfLargePrimeFactor ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , 0 ) ; $ sum = 0 ; $ max = ( int ) ( $ n / 2 ) ; for ( $ p = 2 ; $ p <= $ max ; $ p ++ ) { if ( $ prime [ $ p ] == 0 ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = $ p ; } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] ) $ sum += $ prime [ $ p ] ; else $ sum += $ p ; } return $ sum ; } $ n = 12 ; echo \" Sum = \" ? >"}
{"text": "Jumlah gandaan nombor sehingga n | Berfungsi untuk mengira jumlah gandaan sehingga n; Bilangan gandaan; jumlah nombor semulajadi pertama; jumlah gandaan; Kod pemacu", "code": "< ? php function calculate_sum ( $ a , $ N ) { $ m = $ N / $ a ; $ sum = $ m * ( $ m + 1 ) / 2 ; $ ans = $ a * $ sum ; return $ ans ; } $ a = 7 ; $ N = 49 ; echo \" Sum ▁ of ▁ multiples ▁ of ▁ \" . $ a , \" ▁ up ▁ to ▁ \" . $ N . \" ▁ = ▁ \" . calculate_sum ( $ a , $ N ) ; ? >"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | pulangan 1 apabila STR adalah kuasa 2 pulangan 0 apabila STR bukan kuasa 2; Jumlah menyimpan dividen pertengahan semasa membahagikan. ; jika input adalah \"1\" maka kembali 0 kerana 2 ^ k = 1 di mana k> = 1 dan di sini k = 0; Bahagikan nombor sehingga ia dikurangkan kepada 1 jika kita berjaya dapat mengurangkan bilangannya kepada 1, ia bermakna rentetan input adalah kuasa dua jika di antara nombor ganjil muncul pada akhirnya ia bermakna rentetan tidak dibahagikan dengan dua oleh itu bukan kuasa 2; Sekiranya digit terakhir adalah ganjil maka rentetan tidak dapat dibahagikan dengan 2 oleh itu bukan kuasa dua pulangan 0 .; Bahagikan keseluruhan rentetan dengan 2. Saya digunakan untuk mengesan indeks dalam nombor semasa. J digunakan untuk mengesan indeks untuk lelaran seterusnya. ; Jika num <2 maka kita perlu mengambil satu lagi digit di sebelah kanan [i] untuk menjadikannya lebih besar daripada [i]. E. g. 214/2 -> 107; Jika ia bukan indeks pertama. Contohnya 214 maka kita perlu memasukkan 0 .; untuk contohnya. \"124\" Kami tidak akan menulis 064 jadi jika indeks pertama hanya mengabaikan; Selepas setiap bahagian dengan 2 panjang rentetan diubah. ; Jika rentetan mencapai 1 maka str adalah kuasa 2 .; Kod pemacu.", "code": "< ? php function isPowerOf2 ( $ str ) { $ len_str = strlen ( $ str ) ; $ num = 0 ; if ( $ len_str == 1 && $ str [ $ len_str - 1 ] == '1' ) return 0 ; while ( $ len_str != 1 $ str [ $ len_str - 1 ] != '1' ) { if ( ord ( $ str [ $ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ; $ j = 0 ; for ( $ i = 0 ; $ i < $ len_str ; $ i ++ ) { $ num = $ num * 10 + ( ord ( $ str [ $ i ] ) - ord ( '0' ) ) ; if ( $ num < 2 ) { if ( $ i != 0 ) $ str [ $ j ++ ] = '0' ; continue ; } $ str [ $ j ++ ] = chr ( ( int ) ( $ num / 2 ) + ord ( '0' ) ) ; $ num = ( $ num ) - ( int ) ( $ num / 2 ) * 2 ; } $ len_str = $ j ; } return 1 ; } $ str1 = \"124684622466842024680246842024662202000002\" ; $ str2 = \"1\" ; $ str3 = \"128\" ; print ( isPowerOf2 ( $ str1 ) . \" \" . isPowerOf2 ( $ str2 ) . \" \" ? > ? >"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Berfungsi untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Kod pemacu", "code": "< ? php function ispowerof2 ( $ num ) { if ( ( $ num & ( $ num - 1 ) ) == 0 ) return 1 ; return 0 ; } $ num = 549755813888 ; echo ispowerof2 ( $ num ) ; ? >"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Untuk mengira bilangan faktor dalam nombor; Inisialisasi kiraan dengan 0; Kiraan kenaikan untuk setiap faktor nombor x yang diberikan. ; Pulangan bilangan faktor; Mengembalikan bilangan pembahagi dalam pendaraban array; Mengumpulkan semua elemen array yang diberikan. ; Fungsi panggilan yang mengira bilangan faktor nombor; Kod pemacu", "code": "< ? php function counDivisors ( $ X ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ X ; ++ $ i ) { if ( $ X % $ i == 0 ) { $ count ++ ; } } return $ count ; } function countDivisorsMult ( $ arr , $ n ) { $ mul = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ mul *= $ arr [ $ i ] ; return counDivisors ( $ mul ) ; } $ arr = array ( 2 , 4 , 6 ) ; $ n = sizeof ( $ arr ) ; echo countDivisorsMult ( $ arr , $ n ) ; ? >"}
{"text": "Kira bilangan pasangan (i, j) supaya sama ada arr [i] boleh dibahagikan dengan arr [j] atau arr [j] boleh dibahagikan dengan arr [i] | Berfungsi untuk mencari bilangan pasangan yang tidak teratur; Elemen maksimum dari array; Array untuk menyimpan kekerapan setiap elemen; Menyimpan bilangan pasangan yang tidak teratur; Simpan kekerapan setiap elemen; Cari bilangan pasangan yang tidak teratur; Jika nombor j dibahagi dengan elemen ith hadir dalam array; Jika elemen ith array mempunyai kekerapan lebih daripada satu; Kod pemacu", "code": "< ? php function freqPairs ( $ arr , $ n ) { $ max = max ( $ arr ) ; $ freq = array_fill ( 0 , $ max + 1 , 0 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ $ arr [ $ i ] ] ++ ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 2 * $ arr [ $ i ] ; $ j <= $ max ; $ j += $ arr [ $ i ] ) { if ( $ freq [ $ j ] >= 1 ) $ count += $ freq [ $ j ] ; } if ( $ freq [ $ arr [ $ i ] ] > 1 ) { $ count += $ freq [ $ arr [ $ i ] ] - 1 ; $ freq [ $ arr [ $ i ] ] -- ; } } return $ count ; } $ arr = array ( 3 , 2 , 4 , 2 , 6 ) ; $ n = count ( $ arr ) ; echo freqPairs ( $ arr , $ n ) ; ? >"}
{"text": "Cari istilah n Siri 1 + 2 + 6 + 15 + 31 + 56 + ... | Hitung istilah n siri yang diberikan; Kod pemacu", "code": "< ? php function Nth_Term ( $ n ) { return ( 2 * pow ( $ n , 3 ) - 3 * pow ( $ n , 2 ) + $ n + 6 ) / 6 ; } $ N = 8 ; echo Nth_Term ( $ N ) ; ? >"}
{"text": "Program untuk mencari n | Fungsi untuk mencari nombor n - th dalam siri yang diperbuat daripada 3 dan 5; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; Kod pemacu", "code": "< ? php function printNthElement ( $ n ) { $ arr = array_fill ( 0 , ( $ n + 1 ) , NULL ) ; $ arr [ 1 ] = 3 ; $ arr [ 2 ] = 5 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i / 2 ] * 10 + 3 ; else $ arr [ $ i ] = $ arr [ ( $ i / 2 ) - 1 ] * 10 + 5 ; } return $ arr [ $ n ] ; } $ n = 6 ; echo printNthElement ( $ n ) ; ? >"}
{"text": "Program untuk mencari istilah n Siri 3, 6, 18, 24, ... | Fungsi untuk mengira istilah siri nth; Dengan menggunakan formula abeove; Dapatkan nilai nthterm; Hitung dan cetak istilah n", "code": "< ? php function nthTerm ( $ N ) { return ( $ N * ( ( int ) ( $ N / 2 ) + ( ( $ N % 2 ) * 2 ) + $ N ) ) ; } $ N = 5 ; echo \" Nth ▁ term ▁ for ▁ N ▁ = ▁ \" , $ N , \" ▁ : ▁ \" , nthTerm ( $ N ) ; ? >"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | berfungsi untuk mencetak siri; Mengira dan mencetak istilah pertama; Pengkomputeran dan percetakan yang tersisa; Cari istilah semasa menggunakan terma sebelumnya, kami meningkatkan kuasa x oleh 1, kuasa penurunan sebanyak 1 dan mengira NCI menggunakan istilah sebelumnya dengan mengalikan istilah sebelumnya dengan (n - i + 1) / i; Kod pemacu", "code": "< ? php function series ( $ A , $ X , $ n ) { $ term = pow ( $ A , $ n ) ; echo $ term , \" \" ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ term = $ term * $ X * ( $ n - $ i + 1 ) / ( $ i * $ A ) ; echo $ term , \" \" ; } } $ A = 3 ; $ X = 4 ; $ n = 5 ; series ( $ A , $ X , $ n ) ; ? >"}
{"text": "Semak jika nombor dibahagikan dengan 8 menggunakan pengendali bitwise | Fungsi untuk memeriksa nombor div oleh 8 atau tidak menggunakan pengendali bitwise; Program Pemandu", "code": "< ? php function Div_by_8 ( $ n ) { return ( ( ( $ n >> 3 ) << 3 ) == $ n ) ; } $ n = 16 ; if ( Div_by_8 ( $ n ) ) echo \" YES \" ; else echo \" NO \" ; ? >"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Fungsi untuk mengira purata nombor walaupun; mengira nombor walaupun; Simpan jumlah nombor walaupun; Kod pemacu", "code": "< ? php function averageEven ( $ n ) { if ( $ n % 2 != 0 ) { echo ( \" Invalid ▁ Input \" ) ; return -1 ; } $ sum = 0 ; $ count = 0 ; while ( $ n >= 2 ) { $ count ++ ; $ sum += $ n ; $ n = $ n - 2 ; } return $ sum / $ count ; } $ n = 16 ; echo ( averageEven ( $ n ) ) ; ? >"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Fungsi untuk mengira purata nombor walaupun; Kod pemacu", "code": "< ? php function averageEven ( $ n ) { if ( $ n % 2 != 0 ) { echo ( \" Invalid ▁ Input \" ) ; return -1 ; } return ( $ n + 2 ) / 2 ; } $ n = 16 ; echo ( averageEven ( $ n ) ) ; return 0 ; ? >"}
{"text": "Nombor terbesar yang membahagikan x dan co | Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; berfungsi untuk mencari pembahagi coprime terbesar; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return 0 ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; } function cpFact ( $ x , $ y ) { while ( gcd ( $ x , $ y ) != 1 ) { $ x = $ x / gcd ( $ x , $ y ) ; } return $ x ; } $ x = 15 ; $ y = 3 ; echo cpFact ( $ x , $ y ) , \" STRNEWLINE \" ; $ x = 14 ; $ y = 28 ; echo cpFact ( $ x , $ y ) , \" STRNEWLINE \" ; $ x = 7 ; $ y = 3 ; echo cpFact ( $ x , $ y ) ; ? >"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Kod pemacu", "code": "< ? php function counLastDigitK ( $ low , $ high , $ k ) { $ count = 0 ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) if ( $ i % 10 == $ k ) $ count ++ ; return $ count ; } $ low = 3 ; $ high = 35 ; $ k = 3 ; echo counLastDigitK ( $ low , $ high , $ k ) ; ? >"}
{"text": "Nombor Taxicab | Pelaksanaan PHP untuk mencetak nombor pertama N Taxicab (2) :; Bermula dari 1, periksa setiap nombor jika ia adalah Taxicab sehingga Count mencapai n. ; Cuba semua pasangan yang mungkin (j, k) yang jumlah kiubnya boleh saya. ; Taxicab (2) dijumpai; Kod pemacu", "code": "< ? php function printTaxicab2 ( $ N ) { $ i = 1 ; $ count = 0 ; while ( $ count < $ N ) { $ int_count = 0 ; for ( $ j = 1 ; $ j <= pow ( $ i , 1.0 / 3 ) ; $ j ++ ) for ( $ k = $ j + 1 ; $ k <= pow ( $ i , 1.0 / 3 ) ; $ k ++ ) if ( $ j * $ j * $ j + $ k * $ k * $ k == $ i ) $ int_count ++ ; if ( $ int_count == 2 ) { $ count ++ ; echo $ count , \" \" , ▁ $ i , ▁ \" \" } $ i ++ ; } } $ N = 5 ; printTaxicab2 ( $ N ) ; ? >"}
{"text": "Nombor Komposit | Program PHP berasaskan kaedah sekolah yang dioptimumkan untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Kod pemacu", "code": "< ? php function isComposite ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return false ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return true ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return true ; return false ; } if ( isComposite ( 11 ) ) echo \" true \" ; else echo \" false \" ; echo \" STRNEWLINE \" ; if ( isComposite ( 15 ) ) echo \" true \" ; else echo \" false \" ; echo \" STRNEWLINE \" ; ? >"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Untuk mencari jumlah elemen array; jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "< ? php function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; } function findPrime ( $ n ) { $ num = $ n + 1 ; while ( $ num ) { if ( isPrime ( $ num ) ) return $ num ; $ num = $ num + 1 ; } return 0 ; } function minNumber ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; if ( isPrime ( $ sum ) ) return 0 ; $ num = findPrime ( $ sum ) ; return $ num - $ sum ; } $ arr = array ( 2 , 4 , 6 , 8 , 12 ) ; $ n = sizeof ( $ arr ) ; echo minNumber ( $ arr , $ n ) ; ? >"}
{"text": "Jumlah pembahagi faktorial nombor | fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Kod pemacu", "code": "< ? php function fact ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * fact ( $ n - 1 ) ; } function div ( $ x ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ x ; $ i ++ ) if ( $ x % $ i == 0 ) $ ans += $ i ; return $ ans ; } function sumFactDiv ( $ n ) { return div ( fact ( $ n ) ) ; } $ n = 4 ; echo sumFactDiv ( $ n ) ; ? >"}
{"text": "Jumlah pembahagi faktorial nombor | AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) '' using ; Menggunakan fungsi pembahagi untuk mengira jumlah; mengembalikan jumlah pembahagi; Program pemacu untuk menjalankan kes -kes", "code": "< ? php $ allPrimes = array ( ) ; function sieve ( $ n ) { global $ allPrimes ; $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) if ( $ prime [ $ p ] ) array_push ( $ allPrimes , $ p ) ; } function factorialDivisors ( $ n ) { global $ allPrimes ; $ result = 1 ; for ( $ i = 0 ; $ i < count ( $ allPrimes ) ; $ i ++ ) { $ p = $ allPrimes [ $ i ] ; $ exp = 0 ; while ( $ p <= $ n ) { $ exp = $ exp + ( int ) ( $ n / $ p ) ; $ p = $ p * $ allPrimes [ $ i ] ; } $ result = $ result * ( pow ( $ allPrimes [ $ i ] , $ exp +1 ) - 1 ) / ( $ allPrimes [ $ i ] - 1 ) ; } return $ result ; } print ( factorialDivisors ( 4 ) ) ; ? >"}
{"text": "Nombor Pandigital dalam pangkalan yang diberikan | Kembali benar jika n adalah pandigit lain kembali palsu. ; Panjang pemeriksaan kurang daripada asas; Melintasi setiap digit nombor. ; Jika digit adalah integer; Jika digit adalah abjad; Memeriksa array hash, jika mana -mana indeks tidak ditandakan. ; Program Pemandu", "code": "< ? php function checkPandigital ( $ b , $ n ) { if ( strlen ( $ n ) < $ b ) return 0 ; $ hash = array ( ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) $ hash [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ n ) ; $ i ++ ) { if ( $ n [ $ i ] >= '0' && $ n [ $ i ] <= '9' ) $ hash [ $ n [ $ i ] - '0' ] = 1 ; else if ( ord ( $ n [ $ i ] ) - ord ( ' A ' ) <= $ b - 11 ) $ hash [ ord ( $ n [ $ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; } for ( $ i = 0 ; $ i < $ b ; $ i ++ ) if ( $ hash [ $ i ] == 0 ) return 0 ; return 1 ; } $ b = 13 ; $ n = \"1298450376ABC \" ; if ( checkPandigital ( $ b , $ n ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Tukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan | Berfungsi untuk mencari bilangan minimum operasi yang diberikan untuk menukar m ke n; Hanya cara yang perlu dilakukan - 1 (m - n) kali; tidak mungkin; N lebih besar dan n adalah ganjil; lakukan ' - 1' pada m (atau + 1 pada n); n adalah juga; lakukan ' * 2' pada m (atau n / 2 pada n); Kod pemacu", "code": "< ? php function convert ( $ m , $ n ) { if ( $ m == $ n ) return 0 ; if ( $ m > $ n ) return $ m - $ n ; if ( $ m <= 0 && $ n > 0 ) return -1 ; if ( $ n % 2 == 1 ) return 1 + convert ( $ m , $ n + 1 ) ; else return 1 + convert ( $ m , $ n / 2 ) ; } { $ m = 3 ; $ n = 11 ; echo \" Minimum ▁ number ▁ of ▁ \" . \" operations ▁ : ▁ \" , convert ( $ m , $ n ) ; return 0 ; } ? >"}
{"text": "Biji (atau akar benih) nombor | Program PHP untuk mencari benih nombor; Kedai produk digit x dalam proddig [x]; Jika x mempunyai angka tunggal; Jika produk digit sudah dikira; Jika produk digit tidak dikira sebelum ini. ; Mencetak semua benih n; Cari semua biji menggunakan proddig []; Sekiranya tidak ada benih; Cetak biji; Kod pemacu", "code": "< ? php $ MAX = 10000 ; $ prodDig = array_fill ( 0 , $ MAX , 0 ) ; function getDigitProduct ( $ x ) { global $ prodDig ; if ( $ x < 10 ) return $ x ; if ( $ prodDig [ $ x ] != 0 ) return $ prodDig [ $ x ] ; $ prod = ( int ) ( $ x % 10 ) * getDigitProduct ( ( int ) ( $ x / 10 ) ) ; $ prodDig [ $ x ] = $ prod ; return $ prod ; } function findSeed ( $ n ) { $ res = array ( ) ; for ( $ i = 1 ; $ i <= ( int ) ( $ n / 2 + 1 ) ; $ i ++ ) if ( $ i * getDigitProduct ( $ i ) == $ n ) array_push ( $ res , $ i ) ; if ( count ( $ res ) == 0 ) { echo \" NO ▁ seed ▁ exists STRNEWLINE \" ; return ; } for ( $ i = 0 ; $ i < count ( $ res ) ; $ i ++ ) echo $ res [ $ i ] . \" ▁ \" ; } $ n = 138 ; findSeed ( $ n ) ; ? >"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama. ; Mencari nombor yang mempunyai jumlah maksimum faktor utama. ; Kod pemacu", "code": "< ? php function maxPrimefactorNum ( $ N ) { $ arr [ $ N + 5 ] = array ( ) ; $ arr = array_fill ( 0 , $ N + 1 , NULL ) ; for ( $ i = 2 ; ( $ i * $ i ) <= $ N ; $ i ++ ) { if ( ! $ arr [ $ i ] ) for ( $ j = 2 * $ i ; $ j <= $ N ; $ j += $ i ) $ arr [ $ j ] ++ ; $ arr [ $ i ] = 1 ; } $ maxval = 0 ; $ maxint = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ arr [ $ i ] > $ maxval ) { $ maxval = $ arr [ $ i ] ; $ maxint = $ i ; } } return $ maxint ; } $ N = 40 ; echo maxPrimefactorNum ( $ N ) , \" STRNEWLINE \" ; ? >"}
{"text": "Jumlah semua subarray | Tetapkan 1 | fungsi mengira jumlah semua sub - array; jumlah pengkomputeran subarray menggunakan formula; kembali semua jumlah subarray; Kod pemacu", "code": "< ? php function SubArraySum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ arr [ $ i ] * ( $ i + 1 ) * ( $ n - $ i ) ) ; return $ result ; } $ arr = array ( 1 , 2 , 3 ) ; $ n = sizeof ( $ arr ) ; echo \" Sum ▁ of ▁ SubArray ▁ : ▁ \" , SubArraySum ( $ arr , $ n ) , \" STRNEWLINE \" ; #This  code is contributed by aj_36 NEW_LINE ? >"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program PHP untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Jika saya adalah kuasa 2; Kod pemacu", "code": "< ? php function highestPowerof2 ( $ n ) { $ res = 0 ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ( $ i & ( $ i - 1 ) ) == 0 ) { $ res = $ i ; break ; } } return $ res ; } $ n = 10 ; echo highestPowerof2 ( $ n ) ; ? >"}
{"text": "Cari Pasangan Cube | Tetapkan 2 (A N ^ (1/3) Penyelesaian) | Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat pelbagai saiz saiz 'cuberoot'; Untuk indeks i, kiub [i] akan mengandungi i ^ 3; Cari semua pasangan di atas Array Cube di atas [] yang jumlahnya sama dengan N; Kod pemacu", "code": "< ? php function findPairs ( $ n ) { $ cubeRoot = pow ( $ n , 1.0 / 3.0 ) ; $ cube = array ( ) ; for ( $ i = 1 ; $ i <= $ cubeRoot ; $ i ++ ) $ cube [ $ i ] = $ i * $ i * $ i ; $ l = 1 ; $ r = $ cubeRoot ; while ( $ l < $ r ) { if ( $ cube [ $ l ] + $ cube [ $ r ] < $ n ) $ l ++ ; else if ( $ cube [ $ l ] + $ cube [ $ r ] > $ n ) $ r -- ; else { echo \" ( \" , $ l , \" , ▁ \" , floor ( $ r ) , \" ) \" ; echo \" STRNEWLINE \" ; $ l ++ ; $ r -- ; } } } $ n = 20683 ; findPairs ( $ n ) ; ? >"}
{"text": "Cari perbezaan minimum antara jadual beralih dua nombor | Fungsi utiliti untuk mencari GCD A dan B; Mengembalikan perbezaan minimum antara dua terma jadual beralih 'A' dan 'B'. 'X' adalah peralihan dalam jadual 'a' dan 'y' adalah peralihan dalam jadual 'b'. ; Hitung GCD Nd B; Kirakan perbezaan antara x dan y; Kod pemacu", "code": "< ? php function gcd ( $ a , $ b ) { while ( $ b != 0 ) { $ t = $ b ; $ b = $ a % $ b ; $ a = $ t ; } return $ a ; } function findMinDiff ( $ a , $ b , $ x , $ y ) { $ g = gcd ( $ a , $ b ) ; $ diff = abs ( $ x - $ y ) % $ g ; return min ( $ diff , $ g - $ diff ) ; } $ a = 20 ; $ b = 52 ; $ x = 5 ; $ y = 7 ; echo findMinDiff ( $ a , $ b , $ x , $ y ) , \" STRNEWLINE \" ; ? >"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | berfungsi untuk mencetak pembahagi; Vektor untuk menyimpan separuh daripada pembahagi; Semak jika pembahagi adalah sama; Tolak pembahagi kedua dalam vektor; Vektor akan dicetak secara terbalik; Kod pemacu", "code": "< ? php function printDivisors ( $ n ) { $ v ; $ t = 0 ; for ( $ i = 1 ; $ i <= ( int ) sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( ( int ) $ n / $ i == $ i ) echo $ i . \" \" ; else { echo $ i . \" \" ; $ v [ $ t ++ ] = ( int ) $ n / $ i ; } } } for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) echo $ v [ $ i ] . \" ▁ \" ; } echo \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; ? >"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | berfungsi untuk mencetak pembahagi; Kod pemacu", "code": "< ? php function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i , \" ▁ \" ; } echo \" The ▁ divisors ▁ of ▁ 100 ▁ are : STRNEWLINE \" ; printDivisors ( 100 ) ; ? >"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Berfungsi untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; Jika tidak cetak kedua -duanya; Kod pemacu", "code": "< ? php function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) echo $ i , \" ▁ \" ; else echo $ i , \" ▁ \" , $ n / $ i , \" ▁ \" ; } } } echo \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; ? >"}
{"text": "Sieve of Atkin | Program PHP untuk pelaksanaan SIEVE OF ATKIN; 2 dan 3 dikenali sebagai Perdana; Memulakan array penapis dengan nilai palsu; Mark Sieve [n] adalah benar jika salah satu daripada yang berikut adalah benar: a) n = (4 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil, i. e. , terdapat bilangan pasangan yang berbeza (x, y) yang memenuhi persamaan dan n % 12 = 1 atau n % 12 = 5. b) n = (3 * x * x) + (y * y) Bahagian utama SIEVE OF ATKIN; Tandakan semua gandaan dataran sebagai bukan perdana; Cetak prima menggunakan ayak []; Kod pemacu", "code": "< ? php function SieveOfAtkin ( $ limit ) { if ( $ limit > 2 ) echo 2 , \" ▁ \" ; if ( $ limit > 3 ) echo 3 , \" ▁ \" ; $ sieve [ $ limit ] = 0 ; for ( $ i = 0 ; $ i < $ limit ; $ i ++ ) $ sieve [ $ i ] = false ; for ( $ x = 1 ; $ x * $ x < $ limit ; $ x ++ ) { for ( $ y = 1 ; $ y * $ y < $ limit ; $ y ++ ) { $ n = ( 4 * $ x * $ x ) + ( $ y * $ y ) ; if ( $ n <= $ limit && ( $ n % 12 == 1 $ n % 12 == 5 ) ) $ sieve [ $ n ] ^= true ; $ n = ( 3 * $ x * $ x ) + ( $ y * $ y ) ; if ( $ n <= $ limit && $ n % 12 == 7 ) $ sieve [ $ n ] = true ; $ n = ( 3 * $ x * $ x ) - ( $ y * $ y ) ; if ( $ x > $ y && $ n <= $ limit && $ n % 12 == 11 ) $ sieve [ $ n ] ^= true ; } } for ( $ r = 5 ; $ r * $ r < $ limit ; $ r ++ ) { if ( $ sieve [ $ r ] ) { for ( $ i = $ r * $ r ; $ i < $ limit ; $ i += $ r * $ r ) $ sieve [ $ i ] = false ; } } for ( $ a = 5 ; $ a < $ limit ; $ a ++ ) if ( $ sieve [ $ a ] ) echo $ a , \" ▁ \" ; } $ limit = 20 ; SieveOfAtkin ( $ limit ) ; ? >"}
{"text": "Cari jika titik terletak di dalam bulatan | Program PHP untuk memeriksa sama ada titik terletak di dalam bulatan atau tidak; Bandingkan jejari bulatan dengan jarak pusatnya dari titik yang diberikan; Kod pemacu", "code": "< ? php function isInside ( $ circle_x , $ circle_y , $ rad , $ x , $ y ) { if ( ( $ x - $ circle_x ) * ( $ x - $ circle_x ) + ( $ y - $ circle_y ) * ( $ y - $ circle_y ) <= $ rad * $ rad ) return true ; else return false ; } $ x = 1 ; $ y = 1 ; $ circle_x = 0 ; $ circle_y = 1 ; $ rad = 2 ; if ( isInside ( $ circle_x , $ circle_y , $ rad , $ x , $ y ) ) echo \" Inside \" ; else echo \" Outside \" ; ? >"}
{"text": "Cari semua kemungkinan hasil ekspresi yang diberikan | Fungsi utiliti untuk menilai ungkapan mudah dengan satu pengendali sahaja. ; Fungsi ini menilai semua nilai yang mungkin dan mengembalikan senarai nilai eval1ued. ; Untuk menyimpan hasil (semua kemungkinan penilaian ekspresi 'expr'); Sekiranya terdapat hanya satu watak, ia mestilah digit (atau operan), kembalikannya. ; Sekiranya terdapat hanya tiga aksara, pertengahan mestilah pengendali dan sudut mesti beroperasi; Setiap saya merujuk kepada pengendali; l merujuk kepada semua nilai yang mungkin di sebelah kiri pengendali 'expr [i]'; r merujuk kepada semua nilai yang mungkin di sebelah kanan pengendali 'expr [i]'; Ambil di atas eval1ued semua nilai yang mungkin di sebelah kiri 'i'; Ambil di atas menilai semua nilai yang mungkin di sebelah kanan 'i'; Kirakan nilai untuk setiap pasangan dan tambahkan nilai yang dihasilkan. ; Kod pemacu", "code": "< ? php function eval1 ( $ a , $ op , $ b ) { if ( $ op == ' + ' ) return $ a + $ b ; if ( $ op == ' - ' ) return $ a - $ b ; if ( $ op == ' * ' ) return $ a * $ b ; } function eval1uateAll ( $ expr , $ low , $ high ) { $ res = array ( ) ; if ( $ low == $ high ) { array_push ( $ res , ord ( $ expr [ $ low ] ) - ord ( ' 0 ' ) ) ; return $ res ; } if ( $ low == ( $ high - 2 ) ) { $ num = eval1 ( ord ( $ expr [ $ low ] ) - ord ( '0' ) , $ expr [ $ low + 1 ] , ord ( $ expr [ $ low + 2 ] ) - ord ( '0' ) ) ; array_push ( $ res , $ num ) ; return $ res ; } for ( $ i = $ low + 1 ; $ i <= $ high ; $ i += 2 ) { $ l = eval1uateAll ( $ expr , $ low , $ i - 1 ) ; $ r = eval1uateAll ( $ expr , $ i + 1 , $ high ) ; for ( $ s1 = 0 ; $ s1 < count ( $ l ) ; $ s1 ++ ) { for ( $ s2 = 0 ; $ s2 < count ( $ r ) ; $ s2 ++ ) { $ val = eval1 ( $ l [ $ s1 ] , $ expr [ $ i ] , $ r [ $ s2 ] ) ; array_push ( $ res , $ val ) ; } } } return $ res ; } $ expr = \"1*2 + 3*4\" ; $ len = strlen ( $ expr ) ; $ ans = eval1uateAll ( $ expr , 0 , $ len - 1 ) ; for ( $ i = 0 ; $ i < count ( $ ans ) ; $ i ++ ) echo $ ans [ $ i ] . \" STRNEWLINE \" ; ? >"}
{"text": "Program untuk memeriksa sama ada nombor tertentu bernasib baik (semua digit adalah berbeza) | Fungsi ini kembali benar jika n bernasib baik; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Kod pemacu", "code": "< ? php function isLucky ( $ n ) { $ arr = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ arr [ $ i ] = false ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ arr [ $ digit ] ) return false ; $ arr [ $ digit ] = true ; $ n = ( int ) ( $ n / 10 ) ; } return true ; } $ arr = array ( 1291 , 897 , 4566 , 1232 , 80 , 700 ) ; $ n = sizeof ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( isLucky ( $ arr [ $ i ] ) ) echo $ arr [ $ i ] , \" ▁ is ▁ Lucky ▁ STRNEWLINE \" ; else echo $ arr [ $ i ] , \" ▁ is ▁ not ▁ Lucky ▁ STRNEWLINE \" ; ? >"}
{"text": "Cetak kotak pertama N Nombor Semulajadi tanpa menggunakan *, / dan | Program PHP untuk mencetak dataran nombor pertama 'n' Nombor semulajadi menggunakan *, / dan -; Memulakan 'persegi' dan nombor ganjil pertama; Mengira dan mencetak kotak; Cetak dataran; Kemas kini 'persegi' dan 'ganjil'; Kod pemacu", "code": "< ? php function printSquares ( $ n ) { $ square = 0 ; $ odd = 1 ; for ( $ x = 0 ; $ x < $ n ; $ x ++ ) { echo $ square , \" \" ; $ square = $ square + $ odd ; $ odd = $ odd + 2 ; } } $ n = 5 ; printSquares ( $ n ) ; ? >"}
{"text": "Tulis program untuk membalikkan digit nombor | Program PHP untuk membalikkan digit nombor; Fungsi rekursif untuk membalikkan digit NUM; Kod pemacu", "code": "< ? php $ rev_num = 0 ; $ base_pos = 1 ; function reversDigits ( $ num ) { global $ rev_num ; global $ base_pos ; if ( $ num > 0 ) { reversDigits ( ( int ) ( $ num / 10 ) ) ; $ rev_num += ( $ num % 10 ) * $ base_pos ; $ base_pos *= 10 ; } return $ rev_num ; } $ num = 4562 ; echo \" Reverse ▁ of ▁ no . ▁ is ▁ \" , reversDigits ( $ num ) ; ? >"}
{"text": "Cetak bitwise dan set nombor n | berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu", "code": "< ? php function printSubsets ( $ n ) { for ( $ i = $ n ; $ i > 0 ; $ i = ( $ i - 1 ) & $ n ) echo $ i . \" \" ; echo \"0\" ; } $ n = 9 ; printSubsets ( $ n ) ; ? >"}
{"text": "Semak jika nombor dibahagikan dengan 17 menggunakan pengendali bitwise | fungsi untuk memeriksa secara rekursif jika nombor itu boleh dibahagikan dengan 17 atau tidak; jika n = 0 atau n = 17 maka ya; jika n kurang dari 17, tidak boleh dibahagikan dengan 17; mengurangkan nombor mengikut lantai (n / 16) - n % 16; Kod pemacu", "code": "< ? php function isDivisibleby17 ( $ n ) { if ( $ n == 0 $ n == 17 ) return true ; if ( $ n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( $ n >> 4 ) - ( int ) ( $ n & 15 ) ) ; } $ n = 35 ; if ( isDivisibleby17 ( $ n ) ) echo $ n . \" ▁ is ▁ divisible ▁ by ▁ 17\" ; else echo $ n . \" ▁ is ▁ not ▁ divisible ▁ by ▁ 17\" ; ? >"}
{"text": "Nombor terbesar dengan perwakilan binari ialah M 1 dan M | Mengembalikan nombor terbesar dengan bit set M kemudian m - 1 0 bit. ; Mulakan dengan 2 bit. ; Jawapan awal adalah 1 yang memenuhi syarat yang diberikan; Semak semua nombor; mengira nombor; jika kurang kemudian n; kenaikan m untuk mendapatkan nombor seterusnya; Kod pemacu", "code": "< ? php function answer ( $ n ) { $ m = 2 ; $ ans = 1 ; $ r = 1 ; while ( $ r < $ n ) { $ r = ( pow ( 2 , $ m ) - 1 ) * ( pow ( 2 , $ m - 1 ) ) ; if ( $ r < $ n ) $ ans = $ r ; $ m ++ ; } return $ ans ; } $ n = 7 ; echo answer ( $ n ) ; ? >"}
{"text": "Cari bit set yang paling ketara | Program PHP mudah untuk mencari nombor MSB untuk diberikan n. ; Kod pemacu", "code": "< ? php function setBitNumber ( $ n ) { if ( $ n == 0 ) return 0 ; $ msb = 0 ; $ n = $ n / 2 ; while ( $ n != 0 ) { $ n = $ n / 2 ; $ msb ++ ; } return ( 1 << $ msb ) ; } $ n = 0 ; echo setBitNumber ( $ n ) ; ? >"}
{"text": "Cari bit set yang paling ketara | Program PHP untuk mencari nombor MSB untuk diberikan n. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Kenaikan n oleh 1 supaya hanya ada satu set bit yang hanya sebelum MSB asal. n kini menjadi 1000000000; Kembalikan MSB asal selepas beralih. n kini menjadi 100000000; Kod pemacu", "code": "< ? php function setBitNumber ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ n = $ n + 1 ; return ( $ n >> 1 ) ; } $ n = 273 ; echo setBitNumber ( $ n ) ; ? >"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod PHP mudah untuk mengira sifar trailing dalam perwakilan binari nombor; Kod pemacu", "code": "< ? php function countTrailingZero ( $ x ) { $ count = 0 ; while ( ( $ x & 1 ) == 0 ) { $ x = $ x >> 1 ; $ count ++ ; } return $ count ; } echo countTrailingZero ( 11 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod PHP untuk mengira sifar trailing dalam perwakilan binari nombor; Peta sedikit nilai mod 37 ke kedudukannya; Hanya perbezaan antara (x dan - x) ialah nilai magnitud yang ditandatangani (leftmostbit) nombor negatif yang ditandatangani adalah 1; Kod pemacu", "code": "< ? php function countTrailingZero ( $ x ) { $ lookup = array ( 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ) ; return $ lookup [ ( - $ x & $ x ) % 37 ] ; } echo countTrailingZero ( 48 ) , \" STRNEWLINE \" ; ? >"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program PHP untuk menilai Ceil (7 n / 8) tanpa menggunakan * dan; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<'; Kod pemacu", "code": "< ? php function multiplyBySevenByEight ( $ n ) { return ( $ n - ( $ n >> 3 ) ) ; } $ n = 9 ; echo multiplyBySevenByEight ( $ n ) ; ? >"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program PHP untuk menilai 7 N / 8 tanpa menggunakan * dan /; Langkah 1) Pertama kali ganda nombor dengan 7 i. e. 7 n = (n << 3) - n Langkah 2) Bahagikan hasil sebanyak 8; Kod pemacu", "code": "< ? php function multiplyBySevenByEight ( $ n ) { return ( ( $ n << 3 ) - $ n ) >> 3 ; } $ n = 15 ; echo multiplyBySevenByEight ( $ n ) ; ? >"}
{"text": "Memaksimumkan median array yang diberikan selepas menambahkan elemen K ke array yang sama | Pelaksanaan PHP fungsi pendekatan untuk mengembalikan median yang dimaksimumkan; Susun array; Jika saiznya juga; Jika saiz ganjil; Kod pemacu", "code": "< ? php function getMaxMedian ( $ arr , $ n , $ k ) { $ size = $ n + $ k ; sort ( $ arr , $ n ) ; if ( $ size % 2 == 0 ) { $ median = ( float ) ( $ arr [ ( $ size / 2 ) - 1 ] + $ arr [ $ size / 2 ] ) / 2 ; return $ median ; } $ median = $ arr [ $ size / 2 ] ; return $ median ; } $ arr = array ( 3 , 2 , 3 , 4 , 2 ) ; $ n = sizeof ( $ arr ) ; $ k = 2 ; echo ( getMaxMedian ( $ arr , $ n , $ k ) ) ;"}
{"text": "Susun 3 Integer Tanpa Menggunakan Keadaan atau Menggunakan Hanya Maksimum () Fungsi | Program PHP untuk mencetak tiga nombor dalam susunan yang disusun menggunakan fungsi max; Cari elemen maksimum; Cari elemen minimum; Kod pemacu", "code": "< ? php function printSorted ( $ a , $ b , $ c ) { $ get_max = max ( $ a , max ( $ b , $ c ) ) ; $ get_min = - max ( - $ a , max ( - $ b , - $ c ) ) ; $ get_mid = ( $ a + $ b + $ c ) - ( $ get_max + $ get_min ) ; echo $ get_min , \" \" ▁ , ▁ $ get _ mid , ▁ \" \" } $ a = 4 ; $ b = 1 ; $ c = 9 ; printSorted ( $ a , $ b , $ c ) ; ? >"}
{"text": "SENARAI SENSI | Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu", "code": "< ? php function insertionSort ( & $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ key = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 && $ arr [ $ j ] > $ key ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j = $ j - 1 ; } $ arr [ $ j + 1 ] = $ key ; } } function printArray ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . \" ▁ \" ; echo \" STRNEWLINE \" ; } $ arr = array ( 12 , 11 , 13 , 5 , 6 ) ; $ n = sizeof ( $ arr ) ; insertionSort ( $ arr , $ n ) ; printArray ( $ arr , $ n ) ; ? >"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Fungsi berasaskan DP untuk mengira bilangan laluan; $ dp [$ n + 1] [$ m + 1]; Isi penyertaan dalam Bottommost Row dan lajur paling kiri; Isi DP dengan cara bawah; Kod pemacu", "code": "< ? php function countPaths ( $ n , $ m ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ m ] ; } $ n = 3 ; $ m = 2 ; echo \" ▁ Number ▁ of ▁ Paths ▁ \" , countPaths ( $ n , $ m ) ; ? >"}
{"text": "Perubahan duit syiling | DP | Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Kod pemacu", "code": "< ? php function coun ( $ S , $ m , $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n < 0 ) return 0 ; if ( $ m <= 0 && $ n >= 1 ) return 0 ; return coun ( $ S , $ m - 1 , $ n ) + coun ( $ S , $ m , $ n - $ S [ $ m - 1 ] ) ; } $ arr = array ( 1 , 2 , 3 ) ; $ m = count ( $ arr ) ; echo coun ( $ arr , $ m , 4 ) ; ? >"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan dtring; untuk setiap substring; substring saiz k; mengira bilangan vokal dan konsonan; tambah produk untuk dijawab. ; Kod pemacu", "code": "< ? php function isVowel ( $ c ) { return ( $ c == ' a ' $ c == ' e ' $ c == ' i ' $ c == ' o ' $ c == ' u ' ) ; } function encryptString ( $ s , $ n , $ k ) { $ countVowels = 0 ; $ countConsonants = 0 ; $ ans = \" \" ; for ( $ l = 0 ; $ l <= $ n - $ k ; $ l ++ ) { $ countVowels = 0 ; $ countConsonants = 0 ; for ( $ r = $ l ; $ r <= $ l + $ k - 1 ; $ r ++ ) { if ( isVowel ( $ s [ $ r ] ) == true ) $ countVowels ++ ; else $ countConsonants ++ ; } $ ans = $ ans . ( string ) ( $ countVowels * $ countConsonants ) ; } return $ ans ; } $ s = \" hello \" ; $ n = strlen ( $ s ) ; $ k = 2 ; echo encryptString ( $ s , $ n , $ k ) . \" STRNEWLINE \" ;"}
{"text": "Silinder bulat kanan terbesar dalam kiub | Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "< ? php function findVolume ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = $ a / 2 ; $ h = $ a ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; } $ a = 5 ; echo findVolume ( $ a ) . \" STRNEWLINE \" ;"}
{"text": "Program untuk jumlah piramid | Berfungsi untuk mencari jumlah piramid segi tiga; Berfungsi untuk mencari jumlah piramid persegi; Berfungsi untuk mencari jumlah piramid pentagonal; Berfungsi untuk mencari jumlah piramid heksagon; Kod pemacu", "code": "< ? php function volumeTriangular ( $ a , $ b , $ h ) { $ vol = ( 0.1666 ) * $ a * $ b * $ h ; return $ vol ; } function volumeSquare ( $ b , $ h ) { $ vol = ( 0.33 ) * $ b * $ b * $ h ; return $ vol ; } function volumePentagonal ( $ a , $ b , $ h ) { $ vol = ( 0.83 ) * $ a * $ b * $ h ; return $ vol ; } function volumeHexagonal ( $ a , $ b , $ h ) { $ vol = $ a * $ b * $ h ; return $ vol ; } $ b = 4 ; $ h = 9 ; $ a = 4 ; echo ( \" Volume ▁ of ▁ triangular ▁ base ▁ pyramid ▁ is ▁ \" ) ; echo ( volumeTriangular ( $ a , $ b , $ h ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Volume ▁ of ▁ square ▁ base ▁ pyramid ▁ is ▁ \" ) ; echo ( volumeSquare ( $ b , $ h ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Volume ▁ of ▁ pentagonal ▁ base ▁ pyramid ▁ is ▁ \" ) ; echo ( volumePentagonal ( $ a , $ b , $ h ) ) ; echo ( \" STRNEWLINE \" ) ; echo ( \" Volume ▁ of ▁ Hexagonal ▁ base ▁ pyramid ▁ is ▁ \" ) ; echo ( volumeHexagonal ( $ a , $ b , $ h ) ) ; ? >"}
{"text": "Program untuk mencari kawasan trapezoid | Fungsi untuk kawasan tersebut; Kod pemacu", "code": "< ? php function Area ( $ b1 , $ b2 , $ h ) { return ( ( $ b1 + $ b2 ) / 2 ) * $ h ; } $ base1 = 8 ; $ base2 = 10 ; $ height = 6 ; $ area = Area ( $ base1 , $ base2 , $ height ) ; echo ( \" Area ▁ is : ▁ \" ) ; echo ( $ area ) ; ? >"}
{"text": "Cari bilangan pepenjuru dalam polygon cembung N sisi | Fungsi PHP untuk mencari bilangan pepenjuru dalam poligon cembung N; Kod pemacu", "code": "< ? php function numberOfDiagonals ( $ n ) { return $ n * ( $ n - 3 ) / 2 ; } $ n = 5 ; echo $ n , \" ▁ sided ▁ convex ▁ polygon ▁ have ▁ \" ; echo numberOfDiagonals ( $ n ) , \" ▁ diagonals \" ;"}
{"text": "Memandangkan rentetan dan integer k, cari sub sub | Berfungsi untuk mencetak sub -sub - string; Jumlah sub - rentetan mungkin; Jika k lebih besar daripada jumlah sub -rentetan; Untuk menyimpan nombor sub -rentetan bermula dengan watak rentetan; Mengira nilai -nilai; Substring [i - 1] ditambah untuk menyimpan jumlah kumulatif; Carian binari untuk mencari indeks permulaan sub -rentetan KTH; Untuk menyimpan indeks akhir sub -rentetan KTH; Cetak sub -rentetan; Kod pemacu", "code": "< ? php function Printksubstring ( $ str , $ n , $ k ) { $ total = floor ( ( $ n * ( $ n + 1 ) ) / 2 ) ; if ( $ k > $ total ) { printf ( \" - 1 STRNEWLINE \" ) ; return ; } $ substring = array ( ) ; $ substring [ 0 ] = 0 ; $ temp = $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ substring [ $ i ] = $ substring [ $ i - 1 ] + $ temp ; $ temp -- ; } $ l = 1 ; $ h = $ n ; $ start = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( $ substring [ $ m ] > $ k ) { $ start = $ m ; $ h = $ m - 1 ; } else if ( $ substring [ $ m ] < $ k ) $ l = $ m + 1 ; else { $ start = $ m ; break ; } } $ end = $ n - ( $ substring [ $ start ] - $ k ) ; for ( $ i = $ start - 1 ; $ i < $ end ; $ i ++ ) print ( $ str [ $ i ] ) ; } $ str = \" abc \" ; $ k = 4 ; $ n = strlen ( $ str ) ; Printksubstring ( $ str , $ n , $ k ) ; ? >"}
{"text": "Titik penyisipan yang lebih rendah | Berfungsi untuk mengembalikan titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Kes asas; Pemeriksaan akhir untuk unsur -unsur yang tersisa yang <x; Kod pemacu", "code": "< ? php function LowerInsertionPoint ( $ arr , $ n , $ X ) { if ( $ X < $ arr [ 0 ] ) return 0 ; else if ( $ X > $ arr [ $ n - 1 ] ) return $ n ; $ lowerPnt = 0 ; $ i = 1 ; while ( $ i < $ n && $ arr [ $ i ] < $ X ) { $ lowerPnt = $ i ; $ i = $ i * 2 ; } while ( $ lowerPnt < $ n && $ arr [ $ lowerPnt ] < $ X ) $ lowerPnt ++ ; return $ lowerPnt ; } $ arr = array ( 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 ) ; $ n = sizeof ( $ arr ) ; $ X = 4 ; echo LowerInsertionPoint ( $ arr , $ n , $ X ) ; ? >"}
{"text": "Bilangan jawatan dengan alamat yang sama dalam baris utama dan lajur utama urutan | Mengembalikan kiraan kedudukan yang diperlukan; array 1D mendatar; array 1D menegak; melangkah untuk semua yang mungkin saya; Memeriksa jika J adalah integer; Memeriksa jika J terletak b / w 1 hingga n; melangkah untuk semua kemungkinan j; Memeriksa jika saya adalah integer; Memeriksa jika saya terletak b / w 1 hingga m; Kod pemacu", "code": "< ? php function getCount ( $ M , $ N ) { $ count = 0 ; if ( $ M == 1 ) return $ N ; if ( $ N == 1 ) return $ M ; if ( $ N > $ M ) { for ( $ i = 1 ; $ i <= $ M ; $ i ++ ) { $ numerator = $ N * $ i - $ N + $ M - $ i ; $ denominator = $ M - 1 ; if ( $ numerator % $ denominator == 0 ) { $ j = $ numerator / $ denominator ; if ( $ j >= 1 and $ j <= $ N ) $ count ++ ; } } } else { for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) { $ numerator = $ M * $ j - $ M + $ N - $ j ; $ denominator = $ N - 1 ; if ( $ numerator % $ denominator == 0 ) { $ i = $ numerator / $ denominator ; if ( $ i >= 1 and $ i <= $ M ) $ count ++ ; } } } return $ count ; } $ M = 3 ; $ N = 5 ; echo getCount ( $ M , $ N ) ; ? >"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Berfungsi untuk mencari pertengahan tiga nombor; Bandingkan setiap tiga nombor untuk mencari nombor tengah. Masukkan hanya jika A> B; Memutuskan A tidak lebih besar daripada b. ; Kod pemacu", "code": "< ? php function middleOfThree ( $ a , $ b , $ c ) { if ( $ a > $ b ) { if ( $ b > $ c ) return $ b ; else if ( $ a > $ c ) return $ c ; else return $ a ; } else { if ( $ a > $ c ) return $ a ; else if ( $ b > $ c ) return $ c ; else return $ b ; } } $ a = 20 ; $ b = 30 ; $ c = 40 ; echo middleOfThree ( $ a , $ b , $ c ) ; ? >"}
{"text": "Susun nombor yang diberikan untuk membentuk nombor terkecil | Fungsi utiliti untuk mencetak kandungan array; Fungsi perbandingan yang kembali benar jika 'ab' lebih kecil daripada 'ba' apabila kita menggabungkan dua nombor 'a' dan 'b' misalnya, ia akan kembali benar jika kita lulus 12 dan 24 sebagai argumen. Fungsi ini akan digunakan oleh fungsi sort (); Tukar nombor pertama ke format rentetan; Tukar nombor kedua ke format rentetan; Semak jika 'ab' lebih kecil atau 'ba' dan kembali nilai bool sejak pengendali perbandingan '<=' mengembalikan benar atau palsu;  ; Berfungsi untuk mencetak susunan dengan nilai terkecil; Jika kita lulus nama fungsi perbandingan, ia akan menyusun array mengikut fungsi membandingkan; Cetak array yang disusun; Kod pemacu", "code": "< ? php function printArr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] ; } function compare ( $ num1 , $ num2 ) { $ A = ( string ) $ num1 ; $ B = ( string ) $ num2 ; if ( ( int ) ( $ A . $ B ) <= ( int ) ( $ B . $ A ) ) { return true ; } else return false ; } function sort_arr ( $ arr ) { for ( $ i = 0 ; $ i < count ( $ arr ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < count ( $ arr ) ; $ j ++ ) { if ( compare ( $ arr [ $ i ] , $ arr [ $ j ] ) == false ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; } } } return $ arr ; } function printSmallest ( $ N , $ arr ) { $ arr = sort_arr ( $ arr ) ; printArr ( $ arr , $ N ) ; } $ arr = array ( 5 , 6 , 2 , 9 , 21 , 1 ) ; $ N = count ( $ arr ) ; printSmallest ( $ N , $ arr ) ; ? >"}
{"text": "Permut dua tatasusunan sedemikian rupa sehingga jumlah setiap pasangan lebih besar atau sama dengan k | Semak sama ada apa -apa permutasi wujud yang memenuhi syarat. ; Susun array a [] dalam urutan yang berkurangan. ; Susun array B [] dalam peningkatan urutan. ; Memeriksa keadaan pada setiap indeks. ; Program yang didorong", "code": "< ? php function isPossible ( $ a , $ b , $ n , $ k ) { sort ( $ a ) ; rsort ( $ b ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] + $ b [ $ i ] < $ k ) return false ; return true ; } $ a = array ( 2 , 1 , 3 ) ; $ b = array ( 7 , 8 , 9 ) ; $ k = 10 ; $ n = count ( $ a ) ; if ( isPossible ( $ a , $ b , $ n , $ k ) ) echo \" Yes \" ; else echo \" No \" ; ? >"}
{"text": "Menyulitkan rentetan dengan mengulangi i | Berfungsi untuk mengembalikan rentetan yang disulitkan; Bilangan kali watak semasa akan diulang; Ulangi watak semasa dalam rentetan yang disulitkan; Kod pemacu", "code": "< ? php function encryptString ( $ str , $ n ) { $ i = 0 ; $ cnt = 0 ; $ encryptedStr = \" \" ; while ( $ i < $ n ) { $ cnt = $ i + 1 ; while ( $ cnt -- ) $ encryptedStr . = $ str [ $ i ] ; $ i ++ ; } return $ encryptedStr ; } $ str = \" geeks \" ; $ n = strlen ( $ str ) ; echo encryptString ( $ str , $ n ) ; ? >"}
{"text": "Kurangkan perbezaan antara nilai maksimum dan minimum array yang diubah suai | Fungsi untuk mengembalikan perbezaan minimum yang diperlukan; mencari nilai minimum dan maksimum; mengembalikan perbezaan minimum yang mungkin; Program pemacu; berfungsi untuk mengembalikan jawapannya", "code": "< ? php function minDiff ( $ n , $ x , $ A ) { $ mn = $ A [ 0 ] ; $ mx = $ A [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ mn = min ( $ mn , $ A [ $ i ] ) ; $ mx = max ( $ mx , $ A [ $ i ] ) ; } return max ( 0 , $ mx - $ mn - 2 * $ x ) ; } $ n = 3 ; $ x = 3 ; $ A = array ( 1 , 3 , 6 ) ; echo minDiff ( $ n , $ x , $ A ) ; ? >"}
