{"text": "Jumlah minimum mungkin dengan mengeluarkan semua kejadian mana -mana elemen array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah minimum selepas penghapusan; Kedai kekerapan elemen array; Melintasi array; Hitung jumlah; Kekerapan kemas kini elemen semasa; Menyimpan jumlah minimum yang diperlukan; Peta Traverse; Cari jumlah minimum yang diperoleh; Kembali jumlah minimum; Kod pemacu; Arahan input; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int A [ ] , int N ) { map < int , int > mp ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; } int minSum = INT_MAX ; for ( auto it : mp ) { minSum = min ( minSum , sum - ( it . first * it . second ) ) ; } return minSum ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , N ) << \" STRNEWLINE \" ; }"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Melintasi array; Menyimpan perbezaan maksimum; Semak elemen bersebelahan maksimum; Tidak termasuk elemen semasa; Mengemas kini perbezaan maksimum; Mengemas kini nilai sebelumnya; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = INT_MIN ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = max ( maxi , abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . push_back ( maxi ) ; } for ( auto x : res ) cout << x << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }"}
{"text": "Kira 1 S hadir dalam pelbagai indeks [l, r] dalam array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari saiz array jika array pada mulanya mengandungi elemen tunggal; Kes asas; P / 2 -> findSize (n / 2) p % 2 -> 1 p / 2 -> findSize (n / 2); Berfungsi untuk mengembalikan kiraan 1 s dalam julat [l, r]; Kes asas; Bahagian 1 -> n / 2 [1, siz_m]; Kemas kini titik akhir kanan julat ke min (Siz_m, r); Bahagian 2 -> n % 2 [Sizm + 1, Siz_m + 1]; Bahagian 3 -> n / 2 [Sizm + 2, 2 * Siz_m - 1] Sama seperti Bahagian 1 harta simetrik beralih koordinat mengikut bahagian 1 tolak (siz_m + 1) dari kedua -dua l, r; Kod pemacu; Input; Mengira bilangan 1 dalam julat [l, r]", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; } int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } int main ( ) { int N = 7 , L = 2 , R = 5 ; cout << CountOnes ( N , L , R ) << endl ; return 0 ; }"}
{"text": "Cari pasangan (a, b) dengan LCM minimum supaya jumlahnya sama dengan n | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kerana 1 bukan pulangan utama atau komposit palsu; Semak jika ia dibahagikan dengan mana -mana nombor maka ia bukan perdana, kembali palsu; Semak jika n tidak dibahagikan dengan mana -mana nombor maka ia adalah perdana dan oleh itu kembali benar; Fungsi untuk mencari pasangan (a, b) seperti jumlah yang N & LCM adalah minimum; Semak sama ada nombor itu adalah perdana; Sekarang, jika tidak perdana maka cari yang paling kurang divisior; Semak jika membahagikan n maka ia adalah faktor; Output yang diperlukan ialah A = N / I & B = N / I * (n - 1); Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } void minDivisior ( int n ) { if ( prime ( n ) ) { cout << 1 << \" ▁ \" << n - 1 ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { cout << n / i << \" ▁ \" << n / i * ( i - 1 ) ; break ; } } } } int main ( ) { int N = 4 ; minDivisior ( N ) ; return 0 ; }"}
{"text": "Cari fungsi Landau untuk nombor tertentu n | Program C ++ untuk pendekatan di atas; Untuk menyimpan fungsi Landau nombor; Berfungsi untuk mengembalikan GCD sebanyak 2 nombor; Berfungsi untuk mengembalikan LCM dua nombor; Fungsi untuk mencari nilai lcm max di antara semua perwakilan n; Hitung nilai Landau; Fungsi rekursif untuk mencari cara yang berbeza di mana n boleh ditulis sebagai jumlah atleast satu bilangan bulat positif; Semak jika jumlah menjadi n, pertimbangkan perwakilan ini; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack - Keluarkan elemen semasa dari perwakilan; Berfungsi untuk mencari fungsi Landau; Menggunakan kambuhan mencari cara yang berbeza di mana n boleh ditulis sebagai sejumlah atleast satu + ve integer; Cetak hasilnya; Kod pemacu; Diberikan n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Landau = INT_MIN ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } void findLCM ( vector < int > & arr ) { int nth_lcm = arr [ 0 ] ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = max ( Landau , nth_lcm ) ; } void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } } void Landau_function ( int n ) { vector < int > arr ; findWays ( arr , 1 , n ) ; cout << Landau ; } int main ( ) { int N = 4 ; Landau_function ( N ) ; return 0 ; }"}
{"text": "Semak jika baki N | Pelaksanaan C ++ untuk memeriksa ungkapan berikut untuk integer n adalah sah atau tidak; Fungsi untuk memeriksa sama ada nombor memegang syarat (n - 1)! % N = n - 1; Kes sudut; Nombor yang boleh dibahagikan dengan 2 atau 3 bukanlah perdana; Melangkah dari 5 dan terus memeriksa perdana; Fungsi untuk memeriksa ungkapan untuk nilai n; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } void checkExpression ( int n ) { if ( isPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int N = 3 ; checkExpression ( N ) ; return 0 ; }"}
{"text": "Semak sama ada mungkin untuk memecah array yang diberikan ke dalam K Odd | C ++ pelaksanaan untuk memeriksa sama ada mungkin untuk memecah array ke dalam sub subset dengan jumlah ganjil; Fungsi untuk memeriksa sama ada array boleh dibahagikan dalam subset k yang diperlukan; Menyimpan kiraan nombor ganjil; Semak jika elemen ganjil; Semak jika perpecahan mungkin; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; if ( checkArray ( n , k , arr ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Jumlah pembahagian pasangan yang mungkin untuk array yang diberikan | C ++ pelaksanaan untuk mengira jumlah pembahagian semua pasangan yang mungkin untuk array yang diberikan; Berfungsi untuk mengira jumlah; Mengira kekerapan setiap istilah dan mencari maksimum di antara ia; Membuat kekerapan kumulatif; Mengambil nilai Ceil; nos. Dalam julat [(n - 0.5) x, (n + 0.5) x) akan menambah n ke ANS; Mengembalikan hasil akhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; int func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ 100005 ] = { 0 } ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] ) { i = ( double ) i ; double j ; ll value = 0 ; double cur = ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = min ( maxx , ( int ) ( ceil ( i * j ) - 1.0 ) ) ; int times = ( freq [ i ] - freq [ i - 1 ] ) , con = j - 0.5 ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( ll ) ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << func ( arr , n ) << endl ; return 0 ; }"}
{"text": "Count of Elements hendaklah dimasukkan untuk membuat array Jumlah dua kali xor array | Program C ++ untuk mencari kiraan elemen yang akan dimasukkan untuk membuat jumlah array dua kali ganda XOR array; Fungsi untuk mencari bilangan elemen minimum yang perlu dimasukkan supaya jumlah unsur -unsur array adalah dua kali ganda XOR array; Pembolehubah untuk menyimpan XOR semua elemen; Pembolehubah untuk menyimpan jumlah semua elemen; Gelung untuk mencari XOR dan jumlah array; Jika jumlah = 2 * xor; Tidak perlu memasukkan lebih banyak elemen; Kami memasukkan satu lagi elemen yang jumlahnya; Kami memasukkan dua lagi elemen SUM + XOR dan XOR. ; Cetak bilangan elemen yang dimasukkan dalam array; Cetak unsur -unsur yang dimasukkan dalam array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { cout << \"0\" << endl ; return ; } if ( Xor == 0 ) { cout << \"1\" << endl ; cout << Sum << endl ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; cout << \"2\" ; cout << num1 << \" ▁ \" << num2 << endl ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; insert_element ( a , n ) ; }"}
{"text": "Periksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak | Program C ++ untuk memeriksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak; Berfungsi untuk memeriksa sama ada akar persamaan kuadratik adalah timbal balik antara satu sama lain atau tidak; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }"}
{"text": "Nombor Sunny | Program C ++ untuk pendekatan di atas; Periksa fungsi sama ada x adalah persegi yang sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Berfungsi untuk memeriksa nombor cerah; Semak jika (n + 1) adalah persegi yang sempurna atau tidak; Jika (n + 1) bukan persegi yang sempurna; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { cout << \" Yes STRNEWLINE \" ; } else { cout << \" No STRNEWLINE \" ; } } int main ( ) { int N = 8 ; checkSunnyNumber ( N ) ; return 0 ; }"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Program C ++ untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Melangkah melalui semua bilangan bulat; Semak jika n boleh ditukar kepada 1; Meningkatkan kiraan jika ia boleh ditukar; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }"}
{"text": "Cari nombor k dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan | Program C ++ untuk mencari nombor K dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan; Fungsi yang mencetak nombor k yang diperlukan; Cetak 1, k - 1 kali; Cetak (n - k + 1); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << \" ▁ \" ; cout << ( N - K + 1 ) ; } int main ( ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; return 0 ; }"}
{"text": "Cetak nth larian atau nombor autobiografi | C ++ pelaksanaan untuk mencari nombor semulajadi natmth; Berfungsi untuk mencari nombor semula jadi yang melangkah; Mengisytiharkan barisan; Enqueue 1, 2, ..., 9 dalam perintah ini; Melakukan operasi k pada barisan; Dapatkan nombor langkah itu; Melakukan dequeue dari barisan; Jika x mod 10 tidak sama dengan 0; Kemudian enqueue 10 x + (x mod 10) - 1; Enqueue 10 x + (x mod 10); Jika x mod 10 tidak sama dengan 9; Kemudian enqueue 10 x + (x mod 10) + 1; Kembalikan jumlah operasi K - th sebagai nombor loncatan n; Kod pemacu; permulaan k", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int NthSmallest ( int K ) { queue < int > Q ; int x ; for ( int i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . front ( ) ; Q . pop ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; } int main ( ) { int N = 16 ; cout << NthSmallest ( N ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya persegi yang sempurna | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan persegi yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } int main ( ) { int n = 14 ; cout << nearest ( n ) << endl ; n = 16 ; cout << nearest ( n ) << endl ; n = 18 ; cout << nearest ( n ) << endl ; return 0 ; }"}
{"text": "Nilai pi (Î) sehingga 50 tempat perpuluhan | Program C ++ untuk mengira nilai Pi sehingga tempat perpuluhan; Fungsi yang mencetak nilai tempat perpuluhan Pi; Cari nilai PI sehingga menggunakan fungsi ACOS (); Cetak nilai Pi sehingga tempat perpuluhan; Kod pemacu; Fungsi yang mencetak nilai pi", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void printValueOfPi ( int N ) { double pi = 2 * acos ( 0.0 ) ; printf ( \" % . * lf STRNEWLINE \" , N , pi ) ; } int main ( ) { int N = 45 ; printValueOfPi ( N ) ; return 0 ; }"}
{"text": "Balikkan kth yang paling penting n | C ++ pelaksanaan pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan integer yang dikemas kini selepas membalikkan kth; Bilangan bit dalam n; Cari perwakilan binari n; Bilangan bit dalam N adalah kurang daripada k; Flip bit kth; Mengembalikan setara perpuluhan nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int getNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } int main ( ) { int n = 56 , k = 2 ; cout << getNum ( n , k ) ; return 0 ; }"}
{"text": "Pertanyaan untuk produk Factorial N First | C ++ pelaksanaan pendekatan; Mengisytiharkan hasil hasil di seluruh dunia; Berfungsi untuk precompute produk faktorial sehingga max; Inisialisasi keadaan asas jika n = 0 maka faktorial 0 adalah sama dengan 1 dan jawapan untuk n = 0 ialah 1; Gelung berulang dari 1 hingga max; faktorial (i) = factorial (i - 1) * i; Keputusan untuk n semasa adalah sama dengan hasil [i - 1] didarabkan oleh faktorial i; Berfungsi untuk melakukan pertanyaan; Precomputing hasil sehingga max; Melakukan pertanyaan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAX  1000000 NEW_LINE const ll MOD = 1e9 + 7 ; ll result [ MAX + 1 ] ; ll fact [ MAX + 1 ] ; void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) cout << result [ q [ i ] ] << \" STRNEWLINE \" ; } int main ( ) { int q [ ] = { 4 , 5 } ; int n = sizeof ( q ) / sizeof ( q [ 0 ] ) ; performQueries ( q , n ) ; return 0 ; }"}
{"text": "Nombor nth dalam satu set gandaan a, b atau c | Program C ++ untuk mencari istilah n yang boleh dibahagi dengan a, b atau c; Berfungsi untuk mengembalikan GCD A dan B; Fungsi untuk mengembalikan kiraan bilangan bulat dari julat [1, num] yang boleh dibahagikan dengan sama ada A, B atau C; Kirakan bilangan istilah yang boleh dibahagi dengan A, B dan C kemudian keluarkan istilah yang boleh dibahagikan dengan kedua -dua (a, b) atau (b, c) atau (c, a) dan kemudian tambah nombor yang boleh dibahagikan dengan a, b dan c; Fungsi untuk carian binari untuk mencari istilah n yang boleh dibahagikan dengan a, b atau c; Tetapkan rendah hingga 1 dan tinggi ke long_max; Jika istilah semasa kurang daripada n maka kita perlu meningkat rendah hingga pertengahan + 1; Jika istilah semasa lebih besar daripada sama dengan n maka tinggi = pertengahan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( ( ( a * b ) / gcd ( a , b ) ) * c ) / gcd ( ( ( a * b ) / gcd ( a , b ) ) , c ) ) ) ) ; } int findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = LONG_MAX , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { long a = 2 , b = 3 , c = 5 , n = 100 ; cout << findNthTerm ( a , b , c , n ) ; return 0 ; }"}
{"text": "Sudut antara 3 simpang yang diberikan dalam n | C ++ pelaksanaan pendekatan; Fungsi yang memeriksa sama ada sudut yang diberikan boleh dibuat menggunakan mana -mana 3 sisi; Memulakan x dan y; Kirakan bilangan simpang antara i dan j, j dan k; Kirakan sudut yang diselaraskan di lilitan; Sudut yang diselaraskan di J boleh didapati menggunakan hakikat bahawa jumlah sudut segitiga adalah sama dengan 180 darjah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } int main ( ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; cout << calculate_angle ( n , a1 , a2 , a3 ) ; return 0 ; }"}
{"text": "Kerugian apabila dua item dijual pada harga yang sama dan keuntungan / kerugian peratusan yang sama | C ++ pelaksanaan pendekatan di atas. ; Fungsi yang akan mendapati kerugian; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) / float ( 100 * 100 - P * P ) ; cout << \" Loss ▁ = ▁ \" << loss ; } int main ( ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; return 0 ; }"}
{"text": "Semak elemen array iaitu CO | C ++ pelaksanaan pendekatan; Menyimpan faktor utama terkecil untuk setiap nombor; Hash untuk menyimpan kiraan faktor utama; Fungsi untuk mengira SPF (faktor utama terkecil) untuk setiap nombor sehingga maxn; Menandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; Menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; Menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Berfungsi untuk menyimpan faktor utama selepas membahagikan faktor utama terkecil di setiap langkah; Menyimpan kiraan faktor utama dalam hash; Fungsi yang mengembalikan benar jika tidak ada faktor utama yang sama antara x dan nombor array lain; Memeriksa sama ada faktor utama yang biasa dengan nombor lain; Fungsi yang mengembalikan benar jika terdapat elemen dalam array yang coprime dengan semua elemen lain dari array; Menggunakan ayak untuk menjana faktor utama; Memeriksa faktor utama biasa dengan nombor lain; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1000001 NEW_LINE int spf [ MAXN ] ; int hash1 [ MAXN ] = { 0 } ; void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } bool check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } bool hasValidNum ( int arr [ ] , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } int main ( ) { int arr [ ] = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( hasValidNum ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Cara untuk mengeluarkan tepi dari graf lengkap untuk membuat tepi ganjil | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk mengeluarkan tepi dari graf supaya bilangan tepi yang ganjil ditinggalkan dalam graf; Jumlah bilangan tepi; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; } int main ( ) { int N = 4 ; cout << countWays ( N ) ; return 0 ; }"}
{"text": "Hitung NCR Menggunakan Segitiga Pascal | C ++ pelaksanaan pendekatan; Memulakan matriks dengan 0; 0 C0 = 1; Tetapkan setiap NCR = 1 di mana r = 0; Nilai untuk sel semasa segitiga Pascal; Berfungsi untuk mengembalikan nilai NCR; Kembali NCR; Kod pemacu; Bina Segitiga Pascal", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int l [ 1001 ] [ 1001 ] = { 0 } ; void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } int nCr ( int n , int r ) { return l [ n ] [ r ] ; } int main ( ) { initialize ( ) ; int n = 8 ; int r = 3 ; cout << nCr ( n , r ) ; }"}
{"text": "Partition Jumlah Paling Berdekatan (ke dalam dua subset) nombor dari 1 hingga N | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan perbezaan mutlak yang diperlukan minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) return 0 ; return 1 ; } int main ( ) { int n = 5 ; cout << minAbsDiff ( n ) ; return 0 ; }"}
{"text": "Semak sama ada xor kekerapan semua digit nombor n adalah sifar atau tidak | C ++ pelaksanaan pendekatan di atas; mewujudkan pelbagai frekuensi; Mencari digit terakhir nombor; Membahagikan nombor dengan 10 untuk menghapuskan digit terakhir; kekerapan mengira setiap digit; Memeriksa jika XOR semua kekerapan adalah sifar atau tidak; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int s ) { int freq [ 10 ] = { 0 } , r ; while ( s != 0 ) { r = s % 10 ; s = int ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } } int main ( ) { int s = 122233 ; if ( check ( s ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; }"}
{"text": "Cetak garis n 4 nombor supaya setiap pasangan di antara 4 nombor mempunyai gcd k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencetak garis N; Iterat n kali untuk mencetak garis n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { cout << k * ( 6 * i + 1 ) << \" ▁ \" << k * ( 6 * i + 2 ) << \" ▁ \" << k * ( 6 * i + 3 ) << \" ▁ \" << k * ( 6 * i + 5 ) << endl ; } } int main ( ) { int n = 2 , k = 2 ; printLines ( n , k ) ; return 0 ; }"}
{"text": "Jumlah pertama N Siri 3, 5, 9, 17, 33 ... | Program C ++ untuk mencari jumlah terma pertama N; Sn = n * (4 * n * n + 6 * n - 1) / 3; Kod pemacu; bilangan terma yang akan dimasukkan dalam jumlah; Cari SN", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return ( pow ( 2 , n + 1 ) + n - 2 ) ; } int main ( ) { int n = 4 ; cout << \" Sum ▁ = ▁ \" << calculateSum ( n ) ; return 0 ; }"}
{"text": "Kira bilangan rentetan khas panjang n | Program C ++ untuk mengira bilangan rentetan khas panjang n; Berfungsi untuk mengembalikan kiraan rentetan khas; menyimpan jawapan untuk nilai tertentu n; Untuk n = 0 kita mempunyai rentetan kosong; Untuk n = 1 kita mempunyai 2 rentetan khas; Hitung kiraan rentetan panjang panjang i; Fib [n] menyimpan kiraan rentetan khas panjang n; Kod pemacu; permulaan n", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE long count_special ( long n ) { long fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } int main ( ) { long n = 3 ; cout << count_special ( n ) << endl ; return 0 ; }"}
{"text": "Mengira laluan dalam array | C ++ pelaksanaan pendekatan di atas; Cari bilangan cara untuk mencapai akhir; Kes asas; Struktur rekursif; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( 0 , arr , n ) << endl ; return 0 ; }"}
{"text": "Mengira laluan dalam array | C ++ pelaksanaan; Cari bilangan cara untuk mencapai akhir; DP untuk menyimpan nilai; Kes asas; Bawah struktur DP; F [i] bergantung kepada F [i + 1] ke F [i + k]; Nilai pulangan DP [0]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int arr [ ] , int n ) { int dp [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( arr , n ) % mod << endl ; return 0 ; }"}
{"text": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | C ++ pelaksanaan; Mengembalikan kiraan ganjil dan bahkan seterusnya; Pembolehubah untuk menyimpan kiraan bahkan seterusnya dan berikutnya yang ganjil; Inisialisasi count_even dan count_odd hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan yang lebih baik atau ganjil. ; Cari jumlah semua berikutnya dengan mengira dan mengira ganjil dan menyimpannya semasa kami melangkah. ; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu; Memanggil fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > countSum ( int arr [ ] , int n ) { int result = 0 ; int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return { count_even , count_odd } ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pair < int , int > ans = countSum ( arr , n ) ; cout << \" EvenSum ▁ = ▁ \" << ans . first ; cout << \" ▁ OddSum ▁ = ▁ \" << ans . second ; return 0 ; }"}
{"text": "Count integer panjang n dan nilai kurang daripada k sehingga ia mengandungi digit hanya dari set yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk menukar nombor menjadi vektor; Tolak semua digit n dari akhir satu demi satu ke vektor; Jika nombor asalnya adalah 0; Membalikkan elemen vektor; Mengembalikan vektor yang diperlukan; Berfungsi untuk mengembalikan bilangan bilangan bulat panjang b yang kurang daripada c dan mereka mengandungi digit dari set a [] sahaja; Menukar nombor ke array digit; Kes 1: Tidak ada bilangan sedemikian mungkin kerana nombor yang dihasilkan akan selalu lebih besar daripada C; Kes 2: Semua bilangan bulat panjang B adalah sah kerana mereka semua kurang daripada C; mengandungi 0; Kes 3; Kemas kini array yang lebih rendah [seperti yang lebih rendah [i] menyimpan kiraan unsur -unsur dalam [] yang kurang daripada saya; Untuk indeks pertama kita tidak boleh menggunakan 0; Sama ada (i - 1) digit nombor yang dihasilkan boleh sama dengan (i - 1) digit C; Adakah digit [i - 1] hadir dalam A? ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10 NEW_LINE vector < int > numToVec ( int N ) { vector < int > digit ; while ( N != 0 ) { digit . push_back ( N % 10 ) ; N = N / 10 ; } if ( digit . size ( ) == 0 ) digit . push_back ( 0 ) ; reverse ( digit . begin ( ) , digit . end ( ) ) ; return digit ; } int solve ( vector < int > & A , int B , int C ) { vector < int > digit ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A [ 0 ] == 0 && B != 1 ) return ( d - 1 ) * pow ( d , B - 1 ) ; else return pow ( d , B ) ; } else { int dp [ B + 1 ] = { 0 } ; int lower [ MAX + 1 ] = { 0 } ; for ( int i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; bool flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } } int main ( ) { vector < int > A = { 0 , 1 , 2 , 5 } ; int N = 2 ; int k = 21 ; cout << solve ( A , N , k ) ; return 0 ; }"}
{"text": "Bilangan jalur berat w dalam k | Program C ++ untuk mengira bilangan laluan dengan berat w dalam pokok k - ary; Berfungsi untuk mengembalikan bilangan cara yang mempunyai berat badan sebagai wt dalam pokok k - ary; Kembali 0 jika berat menjadi kurang daripada sifar; Kembali hanya jika laluan semasa telah memasukkan berat kelebihan mehaum m; Jika berat tepi semasa lebih besar daripada atau sama dengan m, set digunakan sebagai benar; Kod pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used ) return 1 ; return 0 ; } if ( dp [ wt ] [ used ] != -1 ) return dp [ wt ] [ used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt ] [ used ] = ans ; } int main ( ) { int W = 3 , K = 3 , M = 2 ; int dp [ W + 1 ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << solve ( dp , W , K , M , 0 ) << endl ; return 0 ; }"}
{"text": "Cara Menulis N sebagai Jumlah Dua atau Lebih Integer Positif | Set | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan partition n; Kes asas; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long partitions ( int n ) { vector < long long > p ( n + 1 , 0 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) k *= -1 ; else k = 1 - k ; } } return p [ n ] ; } int main ( ) { int N = 20 ; cout << partitions ( N ) ; return 0 ; }"}
{"text": "Laluan Terpanjang dalam Matriks | Program CPP untuk mencari jalan yang paling lama dalam matriks. ; Kembalikan panjang bibir dalam matriks 2D; Jika nilai belum dikira. ; Jika mencapai sel kiri bawah, kembali 1 .; Jika sampai ke sudut matriks. ; Jika nilai lebih besar daripada sel bawah. ; Jika nilai lebih besar daripada sel kiri. ; Fungsi pembalut; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  10 NEW_LINE using namespace std ; int LIP ( int dp [ ] [ MAX ] , int mat [ ] [ MAX ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } int wrapper ( int mat [ ] [ MAX ] , int n , int m ) { int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; cout << wrapper ( mat , n , m ) << endl ; return 0 ; }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Program C ++ untuk mengira jumlah laluan dari titik ke asal; Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } int main ( ) { int n = 3 , m = 2 ; cout << \" ▁ Number ▁ of ▁ Paths ▁ \" << countPaths ( n , m ) ; return 0 ; }"}
{"text": "Masalah Tambang Emas | Program C ++ untuk menyelesaikan masalah lombong emas; Mengembalikan jumlah maksimum emas yang boleh dikumpulkan apabila perjalanan bermula dari lajur pertama dan bergerak yang dibenarkan adalah betul, kanan dan kanan - ke bawah; Buat jadual untuk menyimpan hasil pertengahan dan memulakan semua sel ke 0. Baris pertama Goldminetable memberikan emas maksimum yang dapat dikumpulkan oleh pelombong ketika memulakan baris itu; Emas yang dikumpulkan pergi ke sel di sebelah kanan ( ->); Emas yang dikumpulkan untuk pergi ke sel untuk ke atas ( /); Emas yang dikumpulkan untuk pergi ke sel ke kanan (\\); Max Gold yang dikumpulkan daripada mengambil salah satu daripada 3 laluan di atas; Jumlah maksimum emas yang dikumpulkan akan menjadi nilai maksimum dalam lajur pertama semua baris; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } int main ( ) { int gold [ MAX ] [ MAX ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; cout << getMaxGold ( gold , m , n ) ; return 0 ; }"}
{"text": "Cari Kos Pelarasan Minimum Array | Program C ++ untuk mencari kos pelarasan minimum array; Fungsi untuk mencari kos pelarasan minimum array; dp [i] [j] menyimpan kos pelarasan minimum untuk menukar [i] ke j; mengendalikan elemen pertama array secara berasingan; lakukan untuk elemen rehat array; Gantikan [i] ke J dan hitung kos pelarasan minimum DP [i] [j]; memulakan kos pelarasan minimum kepada int_max; Pertimbangkan semua k sedemikian rupa sehingga k> = max (j - sasaran, 0) dan k <= min (m, j + sasaran) dan ambil minimum; pulangan nilai minimum dari baris terakhir jadual DP; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  100 NEW_LINE int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } int main ( ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 10 ; cout << \" Minimum ▁ adjustment ▁ cost ▁ is ▁ \" << minAdjustmentCost ( arr , n , target ) << endl ; return 0 ; }"}
{"text": "Kira tiga kali ganda dari julat tertentu yang mempunyai jumlah dua nombor triplet yang sama dengan nombor ketiga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda dari julat [l, r] yang mempunyai jumlah dua nombor dari triplet yang sama dengan nombor ketiga; Menyimpan jumlah tiga tiga; Cari perbezaan julat; Kes 1: Jika tiga kali boleh dibentuk, maka kembali 0; Jika tidak; Mengemas kini jumlah tiga kali ganda; Mengembalikan kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } int main ( ) { int L = 2 , R = 6 ; cout << totalCombination ( L , R ) ; return 0 ; }"}
{"text": "Bina Dua N | Program C ++ untuk pendekatan di atas; Berfungsi untuk menghasilkan dua susunan yang memenuhi syarat yang diberikan; Mengisytiharkan kedua -dua array A dan B; Berulang dari julat [1, 2 * n]; Berikan nombor berturut -turut kepada indeks yang sama dari kedua -dua tatasusunan; Cetak array pertama; Cetak array kedua, b; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArrays ( int n ) { vector < int > A , B ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . push_back ( i ) ; else B . push_back ( i ) ; } cout << \" { ▁ \" ; for ( int i = 0 ; i < n ; i ++ ) { cout << A [ i ] ; if ( i != n - 1 ) cout << \" , ▁ \" ; } cout << \" ▁ } STRNEWLINE \" ; cout << \" { ▁ \" ; for ( int i = 0 ; i < n ; i ++ ) { cout << B [ i ] ; if ( i != n - 1 ) cout << \" , ▁ \" ; } cout << \" ▁ } \" ; } int main ( ) { int N = 5 ; printArrays ( N ) ; return 0 ; }"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit a dan b yang ditetapkan bit dalam a dan b; Iterater semua bit mungkin a dan b; Jika ia bit ditetapkan dalam kedua -dua A dan B; Jelas i - th bit a; Jelas i - th bit b; Cetak A dan B; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) ) && ( B & ( 1 << i ) ) ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << \" ▁ \" << B ; } int main ( ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; return 0 ; }"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | C ++ pelaksanaan untuk mencari kiraan jumlah pasangan yang berbeza antara dua array nilai 1 hingga n; Berfungsi untuk mencari jumlah yang berbeza; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }"}
{"text": "Count Substrings Dari Diberi String Ternary yang Mengandungi Karakter Sekurang -kurangnya sekali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan substrings terdiri daripada 0, 1, dan 2; Memulakan pelbagai frekuensi saiz 3; Menyimpan kiraan yang dihasilkan; Traversing string str; Arahan kekerapan kemas kini; Jika semua watak hadir mengira bilangan substrings mungkin; Kemas kini bilangan substring; Mengembalikan bilangan substring; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int countSubstrings ( string & str ) { int freq [ 3 ] = { 0 } ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; } int main ( ) { string str = \"00021\" ; int count = countSubstrings ( str ) ; cout << count ; return 0 ; }"}
{"text": "FLIPS MINIMUM UNTUK MENGURANGKAN SEBARANG TERBUKA 3 0 S atau 1 S DALAM RENCEN BINARY YANG DIPERLUKAN | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum flip untuk membuat ketiga -tiga pasang aksara berturut -turut berbeza; Kedai -kedai yang dihasilkan pasangan pasangan; Kes asas; Melangkah ke atas julat [0, n - 2]; Jika nombor 3 berturut -turut adalah sama maka kenaikan kiraan dan kaunter; Kembalikan jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlips ( string str ) { int count = 0 ; if ( str . size ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . size ( ) - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } int main ( ) { string S = \"0011101\" ; cout << minFlips ( S ) ; return 0 ; }"}
{"text": "Menyulitkan rentetan | Program C ++ untuk pendekatan di atas; Berfungsi untuk menukar perpuluhan ke hex; Berfungsi untuk menyulitkan rentetan; Melepasi watak -watak rentetan; Iterat sehingga S [i] sama dengan CH; Kemas kini kiraan dan saya; Penurunan I oleh 1; Menukar kiraan kepada perwakilan heksadesimal; Tambah watak; Tambah kekerapan aksara dalam perwakilan heksadesimal; Membalikkan jawapan yang diperoleh; Mengembalikan jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string convertToHex ( int num ) { string temp = \" \" ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = rem + 48 ; } else { c = rem + 87 ; } temp += c ; num = num / 16 ; } return temp ; } string encryptString ( string S , int N ) { string ans = \" \" ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S [ i ] ; int count = 0 ; string hex ; while ( i < N && S [ i ] == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans += ch ; ans += hex ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; return ans ; } int main ( ) { string S = \" abc \" ; int N = S . size ( ) ; cout << encryptString ( S , N ) ; return 0 ; }"}
{"text": "Kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 s ~ melebihi »frekuensi ~» s | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Kirakan nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mengembalikan kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 's »s; Kiraan rentetan binari panjang n; Kiraan rentetan binari panjang n yang mempunyai kiraan yang sama dengan 0 dan 1 's; Untuk rentetan panjang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned long int n , unsigned long int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int countOfString ( int N ) { unsigned long int Stotal = pow ( 2 , N ) ; unsigned long int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; unsigned long int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; } int main ( ) { int N = 3 ; cout << countOfString ( N ) ; return 0 ; }"}
{"text": "Keluarkan semua kejadian watak dalam rentetan | Pendekatan Rekursif | Program C ++ untuk pendekatan di atas; Berfungsi untuk menghapuskan semua kejadian watak dalam rentetan; Kes asas; Semak watak pertama rentetan yang diberikan; Lulus sisa rentetan ke panggilan fungsi rekursi; Tambah watak pertama STR dan String dari rekursi; Kod pemacu; Diberikan rentetan; Diberikan watak; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeCharRecursive ( string str , char X ) { if ( str . length ( ) == 0 ) { return \" \" ; } if ( str [ 0 ] == X ) { return removeCharRecursive ( str . substr ( 1 ) , X ) ; } return str [ 0 ] + removeCharRecursive ( str . substr ( 1 ) , X ) ; } int main ( ) { string str = \" geeksforgeeks \" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; cout << str ; return 0 ; }"}
{"text": "Masa maksimum seperti perbezaan mutlak antara jam dan minit terletak pada julat yang diberikan | Program C ++ untuk pendekatan di atas; Pemeriksaan fungsi sama ada masa yang diberikan adalah betul; Untuk memeriksa nilai masa; Untuk memeriksa nilai jam masa; Perubahan nilai tidak dibenarkan di kedudukan di mana '? 'tidak hadir; Fungsi memeriksa sama ada perbezaan mutlak antara jam dan nilai minit berada dalam [l, r]; Cek jika perbezaan di luar julat memberi; Memaparkan masa dalam format 24 jam yang betul; Fungsi Cari nilai masa yang dikehendaki yang perbezaannya terletak dalam julat [l, r]; Menurunkan nilai jam dari 23 hingga 0; Semak jika nilai jam sah jika tidak sah maka tidak perlu menukar nilai minit, kerana masa masih akan sah, untuk memeriksa bendera nilai jam ditetapkan kepada 1 .; Mengurangkan nilai minit dari 59 hingga 0; Semak sama ada nilai minit sah, jika tidak sah kemudian langkau lelaran semasa, untuk memeriksa bendera nilai 'minit' ditetapkan kepada 0 .; Kod pemacu; Masa input; Julat Perbezaan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( char a1 , char a2 , string str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; } bool inRange ( int hh , int mm , int L , int R ) { int a = abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } void displayTime ( int hh , int mm ) { if ( hh > 10 ) cout << hh << \" : \" ; else if ( hh < 10 ) cout << \"0\" << hh << \" : \" ; if ( mm > 10 ) cout << mm << endl ; else if ( mm < 10 ) cout << \"0\" << mm << endl ; } void maximumTimeWithDifferenceInRange ( string str , int L , int R ) { int i , j ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ; if ( ! isValid ( h1 + '0' , h2 + '0' , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ; if ( ! isValid ( m1 + '0' , m2 + '0' , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else cout << \" - 1\" << endl ; } int main ( ) { string timeValue = \" ? ? : ? ? \" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; return 0 ; }"}
{"text": "Semak jika rentetan boleh dibahagikan kepada substrings Palindromic panjang walaupun | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa string str boleh memecah rentetan ke dalam substrings palindromik panjang; Memulakan timbunan; Melelehkan rentetan; Jika watak I - tH adalah sama seperti di bahagian atas timbunan kemudian pop elemen atas; Lain -lain menolak watak semasa ke dalam timbunan; Sekiranya timbunan kosong, maka substrings palindromik mungkin; Lain tidak - mungkin; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s , int n ) { stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . empty ( ) && st . top ( ) == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . empty ( ) ) { return true ; } else { return false ; } } int main ( ) { string str = \" aanncddc \" ; int n = str . length ( ) ; if ( check ( str , n ) ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } return 0 ; }"}
{"text": "Bilangan rentetan dalam dua array memenuhi syarat -syarat yang diberikan | Program C ++ untuk pendekatan di atas; Untuk menyimpan kekerapan rentetan selepas bitmasking; Untuk menyimpan hasil untuk setiap rentetan dalam ARR2 []; Melintasi arr1 [] dan bitmask setiap rentetan di dalamnya; Bitmasking untuk setiap rentetan s; Kemas kini kekerapan rentetan dengan nilai bitmasking; Melintasi arr2 []; Bitmasking untuk setiap rentetan s; Periksa sama ada temp ada dalam unstered_map atau tidak; Semak bit set seterusnya; Tolak kiraan untuk rentetan semasa dalam array yang dihasilkan; Cetak kiraan untuk setiap rentetan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumOfValidWords ( vector < string > & w , vector < string > & p ) { unordered_map < int , int > m ; vector < int > res ; for ( string & s : w ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } m [ val ] ++ ; } for ( string & s : p ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s [ 0 ] - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . find ( temp ) != m . end ( ) ) { count += m [ temp ] ; } } temp = ( temp - 1 ) & val ; } res . push_back ( count ) ; } for ( auto & it : res ) { cout << it << ' ' ; } } int main ( ) { vector < string > arr1 ; arr1 = { \" aaaa \" , \" asas \" , \" able \" , \" ability \" , \" actt \" , \" actor \" , \" access \" } ; vector < string > arr2 ; arr2 = { \" aboveyz \" , \" abrodyz \" , \" absolute \" , \" absoryz \" , \" actresz \" , \" gaswxyz \" } ; findNumOfValidWords ( arr1 , arr2 ) ; return 0 ; }"}
{"text": "Memaksimumkan setara perpuluhan dengan membalikkan hanya satu set bersebelahan 0 S | C ++ pelaksanaan untuk memaksimumkan nilai setara perpuluhan yang diberikan dalam bentuk binari; Berfungsi untuk mencetak nombor binari; Semak sama ada nombor semasa ialah 0; Cari 0 s berterusan; Gantikan pada mulanya berlaku 0 dengan 1; Keluar dari gelung jika 1 berlaku; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void flip ( string & s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } } int main ( ) { string s = \"100010001\" ; flip ( s ) ; cout << s ; return 0 ; }"}
{"text": "Kes Kalimat Rentetan Camel yang Diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan asal selepas menukarnya dari unta; Cetak watak pertama seperti itu; Melintasi seluruh watak satu demi satu; Jika watak semasa adalah ruang cetak huruf besar diikuti oleh watak semasa dalam huruf kecil; Lain mencetak watak semasa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void getOrgString ( string s ) { cout << s [ 0 ] ; int i = 1 ; while ( i < s . length ( ) ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) cout << \" ▁ \" << ( char ) tolower ( s [ i ] ) ; else cout << s [ i ] ; i ++ ; } } int main ( ) { string s = \" ILoveGeeksForGeeks \" ; getOrgString ( s ) ; return 0 ; }"}
{"text": "Kira kejadian watak dalam rentetan berulang | Program CPP untuk mencari kejadian aksara x dalam rentetan berulang tak terhingga sehingga panjang n; Berfungsi untuk mengira watak 'A'; Atleast k pengulangan diperlukan; Jika n bukanlah pelbagai pemeriksaan saiz rentetan untuk watak berulang yang tersisa. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countChar ( string str , char x ) { int count = 0 , n = 10 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . size ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . size ( ) ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; } int main ( ) { string str = \" abcac \" ; cout << countChar ( str , ' a ' ) ; return 0 ; }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program C ++ untuk mengira frekuensi item array yang mempunyai nilai kecil. ; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi unsur -unsur array dan kekerapan kiraan (dengan mengandaikan bahawa unsur -unsur dibatasi oleh had); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countFreq ( int arr [ ] , int n , int limit ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << i << \" ▁ \" << count [ i ] << endl ; } int main ( ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int limit = 10 ; countFreq ( arr , n , limit ) ; return 0 ; }"}
{"text": "Semak jika rentetan mempunyai m berturut -turut 1 's atau ~ 0' s | Program untuk memeriksa sama ada rentetan binari mengandungi m berturut -turut 1 's atau' s; Fungsi yang memeriksa jika rentetan binari mengandungi m berturut -turut 1 's atau' s; panjang rentetan binari; Count Zeros; Count 1 's; Count berturut -turut 0 's; Count berturut -turut 1 's; Kod pemacu; panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #include <stdio.h> NEW_LINE using namespace std ; bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } int main ( ) { string s = \"001001\" ; int m = 2 ; if ( check ( s , m ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }"}
{"text": "Produk nod di k | C ++ pelaksanaan untuk mencari produk digit elemen pada tahap k - th; Berfungsi untuk mencari produk digit elemen di peringkat k - th; int produk = 1; Memulakan hasil; peningkatan bilangan tahap; mengurangkan nombor tahap; Periksa sama ada tahap semasa adalah tahap yang dikehendaki atau tidak; produk yang diperlukan; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; } int main ( ) { string tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; cout << productAtKthLevel ( tree , k ) ; return 0 ; }"}
{"text": "Mengeluarkan baris atau lajur bijak pendua dari matriks aksara | Kod CPP untuk membentuk rentetan selepas mengeluarkan pendua dari baris dan lajur. ; Berfungsi untuk memeriksa pendua dalam baris dan lajur; Buat array ispresent dan mulakan semua penyertaannya sebagai palsu. Nilai ispresent [i] [j] akan benar jika s [i] [j] hadir dalam baris atau lajurnya. ; Memeriksa setiap baris untuk pendua [i] [j]; Memeriksa setiap lajur untuk aksara pendua; Jika watak itu unik dalam baris dan lajurnya; Kod pemacu; pelbagai watak; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDuplciates ( string a [ ] , int n , int m ) { bool isPresent [ n ] [ m ] ; memset ( isPresent , 0 , sizeof ( isPresent ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] [ j ] == a [ k ] [ j ] && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] [ j ] == a [ i ] [ k ] && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( ! isPresent [ i ] [ j ] ) printf ( \" % c \" , a [ i ] [ j ] ) ; } int main ( ) { int n = 2 , m = 5 ; string a [ ] = { \" zx \" , \" xz \" } ; findDuplciates ( a , n , m ) ; return 0 ; }"}
{"text": "Program untuk memeriksa ISBN | Program CPP untuk memeriksa sama ada ISBN yang diberikan adalah sah atau tidak; panjang mestilah 10; Pengkomputeran berjumlah 9 digit pertama; Memeriksa digit terakhir. ; Jika digit terakhir adalah 'x', tambahkan 10 hingga jumlah, tambah nilainya. ; Kembali benar jika jumlah digit berwajaran boleh dibahagikan dengan 11 .; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } int main ( ) { string isbn = \"007462542X \" ; if ( isValidISBN ( isbn ) ) cout << \" Valid \" ; else cout << \" Invalid \" ; return 0 ; }"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | Program C ++ untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Menyimpan vokal secara berasingan; Meletakkan vokal dalam urutan terbalik dalam rentetan; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } string reverseVowel ( string str ) { int j = 0 ; string vowel ; for ( int i = 0 ; str [ i ] != ' \\0' ; i ++ ) if ( isVowel ( str [ i ] ) ) vowel [ j ++ ] = str [ i ] ; for ( int i = 0 ; str [ i ] != ' \\0' ; i ++ ) if ( isVowel ( str [ i ] ) ) str [ i ] = vowel [ -- j ] ; return str ; } int main ( ) { string str = \" hello ▁ world \" ; cout << reverseVowel ( str ) ; return 0 ; }"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Program C ++ untuk mencari rentetan yang mengandungi watak pertama setiap perkataan rentetan lain. ; Fungsi untuk mencari rentetan yang mempunyai watak pertama setiap perkataan. ; Melintasi rentetan. ; Jika ia adalah ruang, tetapkan V sebagai benar. ; Lain semak jika v adalah benar atau tidak. Jika benar, salin watak dalam rentetan output dan tetapkan V sebagai palsu. ; Pemandu CPDE", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string firstLetterWord ( string str ) { string result = \" \" ; bool v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' ) v = true ; else if ( str [ i ] != ' ▁ ' && v == true ) { result . push_back ( str [ i ] ) ; v = false ; } } return result ; } int main ( ) { string str = \" geeks ▁ for ▁ geeks \" ; cout << firstLetterWord ( str ) ; return 0 ; }"}
{"text": "Laluan unik yang meliputi setiap bukan | C ++ pelaksanaan pendekatan; Fungsi untuk DFS. i, j ==> indeks sel semasa vis ==> untuk menandakan sel -sel yang dikunjungi ans ==> hasil z ==> kiraan semasa 0 s yang dikunjungi z_count ==> total 0 s hadir; Tandakan blok seperti yang dikunjungi; mengemas kini kiraan; Jika blok akhir dicapai; Jika jalan meliputi semua blok bukan halangan; Naik; Ke bawah; Kiri; Betul; Unmark blok (Unvisited); Berfungsi untuk mengembalikan kiraan laluan unik; int z_count = 0; Jumlah 0 s hadir; Menghitung blok penghalang; Kedudukan permulaan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int i , int j , vector < vector < int > > & grid , vector < vector < bool > > & vis , int & ans , int z , int z_count ) { int n = grid . size ( ) , m = grid [ 0 ] . size ( ) ; vis [ i ] [ j ] = 1 ; if ( grid [ i ] [ j ] == 0 ) z ++ ; if ( grid [ i ] [ j ] == 2 ) { if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = 0 ; return ; } if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != -1 ) dfs ( i - 1 , j , grid , vis , ans , z , z_count ) ; if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != -1 ) dfs ( i + 1 , j , grid , vis , ans , z , z_count ) ; if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != -1 ) dfs ( i , j - 1 , grid , vis , ans , z , z_count ) ; if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != -1 ) dfs ( i , j + 1 , grid , vis , ans , z , z_count ) ; vis [ i ] [ j ] = 0 ; } int uniquePaths ( vector < vector < int > > & grid ) { int n = grid . size ( ) , m = grid [ 0 ] . size ( ) ; int ans = 0 ; vector < vector < bool > > vis ( n , vector < bool > ( m , 0 ) ) ; int x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i , y = j ; } } } dfs ( x , y , grid , vis , ans , 0 , z_count ) ; return ans ; } int main ( ) { vector < vector < int > > grid { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , -1 } } ; cout << uniquePaths ( grid ) ; return 0 ; }"}
{"text": "Kira pasangan yang tidak teratur (x, y) array yang memenuhi persamaan yang diberikan | Program C ++ untuk mencari bilangan pasangan yang tidak teratur (x, y) yang memenuhi persamaan yang diberikan untuk array; Mengembalikan bilangan pasangan yang tidak teratur yang memenuhi syarat; Ans menyimpan bilangan pasangan yang tidak teratur; Menjadikan setiap nilai array menjadi positif; Susun array; Bagi setiap indeks mengira sempadan yang betul untuk pasangan yang tidak teratur; Mengembalikan hasil akhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) { index = upper_bound ( a , a + n , 2 * a [ i ] ) - a ; ans += index - i - 1 ; } return ans ; } int main ( ) { int a [ ] = { 3 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << numPairs ( a , n ) << endl ; return 0 ; }"}
{"text": "Kawasan persegi | Menggunakan sisi, pepenjuru dan perimeter | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kawasan persegi; Gunakan formula di atas; Kod pemacu; Diberikan sisi persegi; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int areaOfSquare ( int S ) { int area = S * S ; return area ; } int main ( ) { int S = 5 ; cout << areaOfSquare ( S ) ; return 0 ; }"}
{"text": "Titik maksimum persimpangan yang mungkin di kalangan x lingkaran dan garis lurus y | Program C ++ untuk melaksanakan pendekatan di atas; Kod pemacu; Bilangan bulatan; Bilangan garis lurus; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } int main ( ) { int x = 3 ; int y = 4 ; cout << ( maxPointOfIntersection ( x , y ) ) ; }"}
{"text": "Nombor Icosihenagonal | Program C ++ untuk mencari nombor icosihenagon nth; Berfungsi untuk mencari nombor icosihenagon; Formula untuk mengira nombor icosihenagon nth; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icosihenagonal_num ( n ) << endl ; n = 10 ; cout << Icosihenagonal_num ( n ) << endl ; return 0 ; }"}
{"text": "Cari centroid bukan | Program C ++ untuk melaksanakan pendekatan di atas; Untuk semua simpang; Hitung nilai menggunakan formula kasut; Mengira koordinat centroid poligon; Kod pemacu; Menyelaras simpul", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < double , double > find_Centroid ( vector < pair < double , double > > & v ) { pair < double , double > ans = { 0 , 0 } ; int n = v . size ( ) ; double signedArea = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { double x0 = v [ i ] . first , y0 = v [ i ] . second ; double x1 = v [ ( i + 1 ) % n ] . first , y1 = v [ ( i + 1 ) % n ] . second ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans . first += ( x0 + x1 ) * A ; ans . second += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans . first = ( ans . first ) / ( 6 * signedArea ) ; ans . second = ( ans . second ) / ( 6 * signedArea ) ; return ans ; } int main ( ) { vector < pair < double , double > > vp = { { 1 , 2 } , { 3 , -4 } , { 6 , -7 } } ; pair < double , double > ans = find_Centroid ( vp ) ; cout << setprecision ( 12 ) << ans . first << \" ▁ \" << ans . second << ' ' ; return 0 ; }"}
{"text": "Program untuk mencari sudut segiempat | C ++ pelaksanaan pendekatan; Kod pemacu; Menurut formula yang diperolehi di atas; Cetak semua sudut", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int main ( ) { int d = 10 ; double a ; a = ( double ) ( 360 - ( 6 * d ) ) / 4 ; cout << a << \" , ▁ \" << a + d << \" , ▁ \" << a + ( 2 * d ) << \" , ▁ \" << a + ( 3 * d ) << endl ; return 0 ; }"}
{"text": "Jarak antara dua pesawat selari dalam 3 | Program C ++ untuk mencari jarak antara dua pesawat selari dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; cout << \" Perpendicular ▁ distance ▁ is ▁ \" << d << endl ; } else cout << \" Planes ▁ are ▁ not ▁ parallel \" ; return ; } int main ( ) { float a1 = 1 ; float b1 = 2 ; float c1 = -1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = -3 ; float d2 = -4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; return 0 ; }"}
{"text": "Mengira cara untuk membentuk 2 kalung dari manik n yang mengandungi n / 2 manik masing -masing | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira faktorial; Fungsi untuk mengira bilangan cara untuk membuat 2 kalung yang mempunyai manik N / 2 jika setiap manik dianggap berbeza; Bilangan cara untuk memilih manik n / 2 dari manik N; Bilangan cara untuk membekalkan manik n / 2; Bahagikan Ans oleh 2 untuk menghapuskan pengulangan; Kembali Ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } long long numOfNecklace ( int N ) { long long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; } int main ( ) { int N = 4 ; cout << numOfNecklace ( N ) << endl ; return 0 ; }"}
{"text": "Semak jika nombor s boleh dibuat dibahagikan dengan d dengan berulang kali menambahkan selebihnya kepada s | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada S dibahagi dengan d semasa menukar s ke (s + s % d); V (0) = s % d; Menyimpan nilai yang ditemui; V (i) = (v (i - 1) + v (i - 1) % d) % d; Semak sama ada nilai telah ditemui; Kes tepi; Jika tidak, masukkannya ke dalam hashmap; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string isDivisibleByDivisor ( int S , int D ) { S %= D ; unordered_set < int > hashMap ; hashMap . insert ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . find ( S ) != hashMap . end ( ) ) { if ( S == 0 ) { return \" Yes \" ; } return \" No \" ; } else hashMap . insert ( S ) ; } return \" Yes \" ; } int main ( ) { int S = 3 , D = 6 ; cout << isDivisibleByDivisor ( S , D ) ; return 0 ; }"}
{"text": "Bilangan minimum bergerak yang diperlukan untuk mencapai (1, 1) dari (x, y) | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan langkah yang diperlukan untuk menukar (x, y) hingga (1, 1); Simpan hasil yang diperlukan; Melangkah sementara kedua -dua x dan y tidak sama dengan 0; Jika x lebih besar daripada y; Kemas kini kiraan dan nilai x; Jika tidak; Kemas kini kiraan dan nilai y; Jika kedua -dua x dan y> 1; Cetak hasilnya; Kod pemacu; Diberikan x dan y", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = -1 ; cout << cnt ; } int main ( ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; return 0 ; }"}
{"text": "Semak jika array adalah stack Sortable | C ++ pelaksanaan pendekatan di atas. ; Fungsi untuk memeriksa sama ada [] adalah stack sortable atau tidak. ; Stack s; Penunjuk ke nilai akhir array b. ; Melintasi setiap elemen [] dari memulakan pemeriksaan jika terdapat operasi yang sah yang boleh dilakukan. ; Jika timbunan tidak kosong; Bahagian atas timbunan. ; Jika bahagian atas timbunan adalah sama dengan B_end + 1, kami akan pop dan kenaikan b_end oleh 1 .; Jika bahagian atas semasa adalah sama dengan b_end + 1, kami akan meningkatkan b_end ke b_end + 1; Pop elemen teratas. ; Sekiranya timbunan kosong, kita tidak dapat terus berusaha operasi ini. Oleh itu pecah; Atas semasa; Jika timbunan kosong tolak elemen semasa; Jika elemen semasa array A [] jika lebih kecil daripada bahagian atas timbunan kita boleh menolaknya dalam timbunan. ; Lain -lain kita tidak dapat menyusun array menggunakan mana -mana operasi yang sah. ; Tidak boleh disusun; Jika timbunan kosong tolak elemen semasa dalam timbunan. ; Stack Sortable; Kod pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int A [ ] , int N ) { stack < int > S ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . top ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . top ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . top ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } int main ( ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; check ( A , N ) ? cout << \" YES \" : cout << \" NO \" ; return 0 ; }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Program C ++ untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Selepas gelung ini, timbunan mengandungi bahagian ekspresi yang tidak seimbang, i. e. , ungkapan bentuk \"}}.} {{.. {\"; Panjang ekspresi yang dikurangkan red_len = (m + n); mengira kurungan pembukaan pada akhir timbunan; Kembali Ceil (m / 2) + Ceil (n / 2) yang sebenarnya sama dengan (m + n) / 2 + n % 2 apabila m + n juga. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) s . pop ( ) ; else s . push ( expr [ i ] ) ; } else s . push ( expr [ i ] ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } int main ( ) { string expr = \" } } { { \" ; cout << countMinReversals ( expr ) ; return 0 ; }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Program C ++ untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Ekspresi panjang ganjil tidak boleh seimbang; Jika kita menemui pendakap kiri maka kita hanya menambah kurungan kiri; Lain jika pendakap kiri adalah 0 maka kita dapati pendakap kanan yang tidak seimbang dan pendakap kanan kenaikan atau jika ungkapan seimbang maka kita menurunkan kiri; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) { return -1 ; } int left_brace = 0 , right_brace = 0 ; int ans ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ceil ( left_brace / 2 ) + ceil ( right_brace / 2 ) ; return ans ; } int main ( ) { string expr = \" } } { { \" ; cout << countMinReversals ( expr ) ; return 0 ; }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program C ++ untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Mencetak nombor minimum yang boleh dibentuk dari urutan input i dan u; Inisialisasi Current_Max (untuk memastikan bahawa kita tidak menggunakan watak berulang; permulaan last_entry (menjejaki angka bercetak terakhir); beralih ke atas array input; memulakan 'noofnextd' untuk mendapatkan kiraan d berikut yang tersedia; Cetak angka untuk saya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; cout << \" ▁ \" << ++ last_entry ; cout << \" ▁ \" << curr_max ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; cout << \" ▁ \" << last_entry ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { cout << \" ▁ \" << -- last_entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; cout << \" ▁ \" << curr_max << \" ▁ \" << curr_max - 1 ; last_entry = curr_max - 1 ; } else { cout << \" ▁ \" << last_entry - 1 ; last_entry -- ; } break ; } } cout << endl ; } int main ( ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; return 0 ; }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program C ++ untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; min_avail mewakili nombor minimum yang masih tersedia untuk memasukkan dalam vektor output. pos_of_i menjejaki indeks paling terkini di mana 'i' ditemui w. r. t vektor output; vektor untuk menyimpan output; meliputi kes asas; Melintasi sisa input; Cetak nombor; Program pemacu untuk memeriksa fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLeast ( string arr ) { int min_avail = 1 , pos_of_I = 0 ; vector < int > v ; if ( arr [ 0 ] == ' I ' ) { v . push_back ( 1 ) ; v . push_back ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { v . push_back ( 2 ) ; v . push_back ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr [ i ] == ' I ' ) { v . push_back ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { v . push_back ( v [ i ] ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) v [ j ] ++ ; min_avail ++ ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { printLeast ( \" IDID \" ) ; printLeast ( \" I \" ) ; printLeast ( \" DD \" ) ; printLeast ( \" II \" ) ; printLeast ( \" DIDI \" ) ; printLeast ( \" IIDDD \" ) ; printLeast ( \" DDIDDIID \" ) ; return 0 ; }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program C ++ untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Fungsi untuk menyahkod urutan yang diberikan untuk membina nombor minimum tanpa digit berulang; Hasil Store Output String; Buat timbunan integer kosong; Jalankan n + 1 kali di mana n adalah panjang urutan input; Tekan nombor I + 1 ke dalam timbunan; Jika semua aksara urutan input diproses atau watak semasa adalah 'I' (meningkat); Jalankan sehingga timbunan kosong; Keluarkan elemen teratas dari timbunan dan tambahkannya ke penyelesaian; fungsi utama", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string seq ) { string result ; stack < int > stk ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) seq [ i ] == ' I ' ) { while ( ! stk . empty ( ) ) { result += to_string ( stk . top ( ) ) ; result += \" ▁ \" ; stk . pop ( ) ; } } } cout << result << endl ; } int main ( ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; return 0 ; }"}
{"text": "Borang Nombor Minimum Dari Urutan yang Diberikan | C ++ program pendekatan di atas; Mengembalikan nombor minimum yang dibuat dari urutan yang diberikan tanpa mengulangi digit; Gelung berjalan untuk setiap aksara input serta satu masa tambahan untuk memberikan pangkat kepada watak yang tinggal; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return \" - 1\" ; string result ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= -1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; } int main ( ) { string inputs [ ] = { \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" } ; for ( string input : inputs ) { cout << getMinNumberForPattern ( input ) << \" STRNEWLINE \" ; } return 0 ; }"}
{"text": "Semak jika digit pertama dan terakhir nombor terkecil membentuk Perdana | C ++ pelaksanaan pendekatan di atas; berfungsi untuk memeriksa perdana; Berfungsi untuk menghasilkan nombor yang paling kecil dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam urutan menaik untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; mengekstrak digit pertama; mengekstrak digit terakhir; mencetak kombinasi utama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) return 1 ; else return 0 ; } void findMinNum ( int arr [ ] , int n ) { int first = 0 , last = 0 , num , rev , i ; int hash [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } cout << \" Minimum ▁ number : ▁ \" ; for ( int i = 0 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) cout << i ; } cout << endl ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } } for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ; cout << \" Prime ▁ combinations : ▁ \" ; if ( isPrime ( num ) && isPrime ( rev ) ) cout << num << \" ▁ \" << rev ; else if ( isPrime ( num ) ) cout << num ; else if ( isPrime ( rev ) ) cout << rev ; else cout << \" No ▁ combinations ▁ exist \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 7 , 8 } ; findMinNum ( arr , 5 ) ; return 0 ; }"}
{"text": "Mencari Co Transitif | Program C ++ untuk mencari kemungkinan triplets bukan transitif btw l dan r; Berfungsi untuk mengembalikan GCD A dan B; berfungsi untuk memeriksa GCD; A dan B adalah coprime jika GCD mereka adalah 1; Memeriksa jika ada triplet yang mungkin (a, b, c) memenuhi syarat bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Menjana dan menyemak semua kemungkinan tiga kali ganda antara L dan R; Jika kita dapati apa -apa tiga kali ganda menetapkan bendera kepada benar; Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } bool coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; } void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA , possibleB , possibleC ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) { if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } } if ( flag == true ) { cout << \" ( \" << possibleA << \" , ▁ \" << possibleB << \" , ▁ \" << possibleC << \" ) \" << \" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } else { cout << \" No ▁ Such ▁ Triplet ▁ exists ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } } int main ( ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; return 0 ; }"}
{"text": "Jangkau A dan B dengan mengalikannya dengan k dan k ^ 2 pada setiap langkah | Program CPP untuk menentukan sama ada A dan B boleh dicapai bermula dari 1, 1 berikutan langkah -langkah yang diberikan. ; Fungsi untuk memeriksa adalah mungkin untuk mencapai A dan B bermula dari 1 dan 1; Cari cuberoot nombor; Bahagikan nombor dengan Cuberoot; Jika ia adalah cuberoot yang sempurna dan membahagikan A dan B; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possibleToReach ( int a , int b ) { int c = cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } int main ( ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) cout << \" yes \" ; else cout << \" no \" ; return 0 ; }"}
{"text": "Nombor bergelora | Program C ++ untuk memeriksa sama ada nombor beralun atau tidak; Memandangkan definisi dengan sekatan bahawa terdapat sekurang -kurangnya 3 digit; Semak sama ada semua digit alternatif adalah sama atau tidak. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isUndulating ( string n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) false ; return true ; } int main ( ) { string n = \"1212121\" ; if ( isUndulating ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; }"}
{"text": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | Program CPP untuk mengira siri berikut; Fungsi untuk mengira siri berikut; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } int main ( ) { int n = 3 ; int res = Series ( n ) ; cout << res << endl ; }"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program CPP yang cekap untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLastDigitK ( long long low , long long high , long long K ) { long long mlow = 10 * ceil ( low / 10.0 ) ; long long mhigh = 10 * floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= K ) count ++ ; if ( low % 10 <= K && ( low % 10 ) ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << countLastDigitK ( low , high , k ) ; return 0 ; }"}
{"text": "Jumlah semua nombor yang boleh dibahagikan dengan 6 dalam julat yang diberikan | Program CPP untuk mencari jumlah nombor yang boleh dibahagi dengan 6 dalam julat tertentu. ; fungsi untuk mengira jumlah semua nombor yang boleh dibahagi dengan 6 dalam julat l - r. . ; tidak ada gandaan 6 sehingga r; tiada gandaan 6 sehingga l - 1; penjumlahan semua gandaan 6 sehingga r; penjumlahan semua gandaan 6 sehingga l - 1; mengembalikan jawapannya; program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } int main ( ) { int L = 1 , R = 20 ; cout << sum ( L , R ) ; return 0 ; }"}
{"text": "Nombor yang lebih kecil yang terbesar mungkin menggunakan hanya satu operasi swap | Program C ++ untuk mencari nombor yang lebih kecil terbesar dengan menukar satu digit. ; Mengembalikan nombor yang mungkin terbesar dengan satu swap supaya nombor itu lebih kecil daripada STR. Dianggap bahawa terdapat 0 s. ; Traverse dari kanan sehingga kita dapati digit yang lebih besar daripada digit seterusnya. Sebagai contoh, dalam 34125, indeks kami ialah 4 .; Kami juga boleh menggunakan carian binari di sini sebagai digit selepas indeks disusun dalam peningkatan urutan. Cari digit terbesar di sebelah kanan ARR [indeks] yang lebih kecil daripada ARR [indeks]; Jika indeks adalah - 1 i. e. Digit adalah dalam urutan yang semakin meningkat. ; Menukar kedua -dua nilai; Kod pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string prevNum ( string str ) { int len = str . length ( ) ; int index = -1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { index = i ; break ; } } int smallGreatDgt = -1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str [ i ] < str [ index ] ) { if ( smallGreatDgt == -1 ) smallGreatDgt = i ; else if ( str [ i ] >= str [ smallGreatDgt ] ) smallGreatDgt = i ; } } if ( index == -1 ) return \" - 1\" ; if ( smallGreatDgt != -1 ) { swap ( str [ index ] , str [ smallGreatDgt ] ) ; return str ; } return \" - 1\" ; } int main ( ) { string str = \"34125\" ; cout << prevNum ( str ) ; return 0 ; }"}
{"text": "SGN Nilai polinomial | Program CPP untuk mencari nilai tanda polinomial; Pulangan nilai poli [0] x (n - 1) + poli [1] x (n - 2) +. . + poli [n - 1]; Menilai nilai polinomial menggunakan kaedah Horner; Mengembalikan nilai tanda polinomial; Program pemacu untuk menguji fungsi di atas. ; Marilah kita menilai nilai 2 x3 - 6 x2 + 2 x - 1 untuk x = 3", "code": "#include <iostream> NEW_LINE using namespace std ; int horner ( int poly [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; } int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return -1 ; return 0 ; } int main ( ) { int poly [ ] = { 2 , -6 , 2 , -1 } ; int x = 3 ; int n = sizeof ( poly ) / sizeof ( poly [ 0 ] ) ; cout << \" Sign ▁ of ▁ polynomial ▁ is ▁ \" << findSign ( poly , n , x ) ; return 0 ; }"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program C ++ untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; Array untuk menyimpan prima; berfungsi untuk mengira prima menggunakan ayak eratosthenes; Cari nombor perdana lebih besar daripada nombor; Untuk mengembalikan nombor perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Panggil Sieveoferatostheneses untuk mengira prima; Untuk mencari jumlah elemen array; Untuk mencari nombor perdana yang lebih besar maka jumlahnya; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE bool isPrime [ MAX ] ; void sieveOfEratostheneses ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = false ; } } } int findPrime ( int n ) { int num = n + 1 ; while ( num ) { if ( isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } int minNumber ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNumber ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Program C ++ mudah untuk mengira jumlah elemen subarray; Mengira jumlah semua sub - array; Pilih titik permulaan; Memilih titik akhir; jumlah subarray antara titik permulaan dan akhir semasa; program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Sum ▁ of ▁ SubArray ▁ : ▁ \" << SubArraySum ( arr , n ) << endl ; return 0 ; }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program C ++ untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }"}
{"text": "Susun semula aksara dalam rentetan supaya tidak dua bersebelahan adalah sama | Program C ++ untuk menyusun semula aksara dalam rentetan supaya tidak ada dua aksara bersebelahan yang sama. ; frekuensi penyimpanan watak; fungsi untuk keutamaan_queue untuk menyimpan kunci mengikut freq; Berfungsi untuk menyusun semula watak rentetan supaya tiada char mengulangi dua kali; Simpan frekuensi semua aksara dalam rentetan; Masukkan semua aksara dengan frekuensi mereka ke Priority_Queue; 'str' yang akan menyimpan nilai yang dihasilkan; Bekerja sebagai elemen awal yang dilawati sebelum ini. (' #' dan frekuensi ' - 1'); Giliran Traverse; Pop atas elemen dari barisan dan tambahkannya ke rentetan. ; Jika kekerapan watak sebelumnya kurang daripada sifar yang bermaksud ia tidak berguna, kita tidak perlu menolaknya; Buat watak semasa sebagai kekerapan 'char' yang terdahulu oleh 'satu'; Jika panjang rentetan yang dihasilkan dan rentetan asal tidak sama maka rentetan tidak sah; rentetan sah; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; struct Key { int freq ; char ch ; bool operator< ( const Key & k ) const { return freq < k . freq ; } } ; void rearrangeString ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; priority_queue < Key > pq ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] ) { pq . push ( Key { count [ val ] , c } ) ; } } str = \" \" ; Key prev { -1 , ' # ' } ; while ( ! pq . empty ( ) ) { Key k = pq . top ( ) ; pq . pop ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . push ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) cout << \" ▁ Not ▁ valid ▁ String ▁ \" << endl ; else cout << str << endl ; } int main ( ) { string str = \" bbbaa \" ; rearrangeString ( str ) ; return 0 ; }"}
{"text": "Cari (a ^ b) % m di mana 'a' sangat besar | Program C ++ untuk mencari (a ^ b) mod m untuk 'a' yang besar; fungsi utiliti untuk mengira % m; (S [i] - '0') memberikan nilai digit dan membentuk nombor; Pulangan mencari (a ^ b) % m; Cari % m; Sekarang kalikan Ans dengan b - 1 kali dan ambil mod dengan m; Program pemacu untuk menjalankan kes itu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int aModM ( string s , unsigned int mod ) { unsigned int number = 0 ; for ( unsigned int i = 0 ; i < s . length ( ) ; i ++ ) { number = ( number * 10 + ( s [ i ] - '0' ) ) ; number %= mod ; } return number ; } unsigned int ApowBmodM ( string & a , unsigned int b , unsigned int m ) { unsigned int ans = aModM ( a , m ) ; unsigned int mul = ans ; for ( unsigned int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; } int main ( ) { string a = \"987584345091051645734583954832576\" ; unsigned int b = 3 , m = 11 ; cout << ApowBmodM ( a , b , m ) ; return 0 ; }"}
{"text": "Interpolasi LaGrange | Program C ++ untuk pelaksanaan interpolasi LaGrange; Untuk mewakili titik data yang sepadan dengan x dan y = f (x); Fungsi untuk menginterpolasi titik data yang diberikan menggunakan Formula XI LaGrange sepadan dengan titik data baru yang nilainya diperoleh n mewakili bilangan titik data yang diketahui; hasil berganda = 0; Memulakan hasil; Mengira syarat individu di atas formula; Tambah istilah semasa untuk menghasilkan; fungsi pemacu untuk menyemak program; mewujudkan pelbagai 4 mata data yang diketahui; Menggunakan fungsi interpolasi untuk mendapatkan titik data yang sepadan dengan x = 3", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Data { int x , y ; } ; double interpolate ( Data f [ ] , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / double ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } int main ( ) { Data f [ ] = { { 0 , 2 } , { 1 , 3 } , { 2 , 12 } , { 5 , 147 } } ; cout << \" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ \" << interpolate ( f , 3 , 5 ) ; return 0 ; }"}
{"text": "Sieve of Sundaram untuk mencetak semua prima yang lebih kecil daripada n | Program C ++ untuk mencetak prima yang lebih kecil daripada N menggunakan ayak Sundaram. ; Mencetak semua nombor perdana yang lebih kecil; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima lebih kecil daripada N, kita mengurangkan N hingga separuh; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; Memulakan semua elemen sebagai tidak ditandakan; Logik utama Sundaram. Tandakan semua nombor bentuk i + j + 2 ij sebagai benar di mana 1 <= i <= j; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool marked [ nNew + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << \" ▁ \" ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << \" ▁ \" ; } int main ( void ) { int n = 20 ; SieveOfSundaram ( n ) ; return 0 ; }"}
{"text": "Bina Arahan Asal Bermula dengan K dari pelbagai xor semua elemen kecuali elemen pada indeks yang sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk membina array dengan setiap elemen yang sama dengan XOR semua elemen array kecuali elemen pada indeks yang sama; Array asal; Kedai bitwise xor array; Hitung XOR semua elemen array; Cetak array asal B []; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int A [ ] , int N , int K ) { int B [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << \" ▁ \" ; } } int main ( ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; constructArray ( A , N , K ) ; return 0 ; }"}
{"text": "Cari elemen tambahan dalam array kedua | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan elemen tambahan dalam b []; Untuk menyimpan hasilnya; Cari xor semua elemen array a [] dan array b []; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } int main ( ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << extraElement ( A , B , n ) ; return 0 ; }"}
{"text": "Hamming jarak antara dua bilangan bulat | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mengira jarak Hamming; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } int main ( ) { int n1 = 9 , n2 = 14 ; cout << hammingDistance ( 9 , 14 ) << endl ; return 0 ; }"}
{"text": "Cetak bitwise dan set nombor n | Program CPP untuk mencetak semua subset bitwise N (pendekatan naif); berfungsi untuk mencari pendekatan naif subset bitwise; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) cout << i << \" ▁ \" ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }"}
{"text": "Cari bit set yang paling ketara | Program CPP untuk mencari nombor MSB untuk diberikan n. ; Untuk mencari kedudukan bit set yang paling penting; Untuk mengembalikan nilai nombor dengan set bit pada kedudukan k - th; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBitNumber ( int n ) { int k = ( int ) ( log2 ( n ) ) ; return 1 << k ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; }"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan penyortiran untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Ambil input dan mulakan res = 0; Susun array; Melintasi array input dan cari kekerapan maksimum; Untuk setiap nombor mencari pengulangan / kekerapannya; Kemas kini res; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }"}
{"text": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan hash untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Melintasi array input dan frekuensi elemen; Cari nilai maksimum dalam peta. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto x : mp ) res = max ( res , x . second ) ; return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }"}
{"text": "Kira cara untuk mewakili nombor sebagai jumlah kotak yang sempurna | Program C ++ untuk pendekatan di atas; Simpan kotak sempurna kurang daripada atau sama dengan n; Fungsi utiliti untuk mengira dataran sempurna kurang daripada atau sama dengan n; Berfungsi untuk mencari bilangan cara untuk mewakili nombor sebagai jumlah kuadrat yang sempurna; Mengendalikan kes asas; Sertakan elemen indeks I - th; Tidak termasuk elemen indeks i - th; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Precomment squares sempurna <= n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > psquare ; void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . push_back ( i * i ) ; } int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - psquare [ index ] ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; } int main ( ) { int N = 9 ; calcPsquare ( N ) ; cout << countWays ( psquare . size ( ) - 1 , N ) ; return 0 ; }"}
{"text": "Jumlah jarak semua nod dari nod yang diberikan | Program C ++ untuk pendekatan di atas; Struktur nod pokok binari; Fungsi yang memperuntukkan nod baru dengan data yang diberikan dan batal ke petunjuk kiri dan kanannya; Kembali nod yang baru dibuat; Berfungsi untuk mengira bilangan nod di subtrees kiri dan kanan; Memulakan pasangan yang menyimpan pasangan {bilangan nod, kedalaman}; Mencari bilangan nod di subtree kiri; Cari bilangan nod di subtree yang betul; Mengisi medan saiz; Menyimpan jumlah jarak semua nod dari nod yang diberikan; Berfungsi untuk mencari jarak keseluruhan; Jika nod sasaran sepadan dengan nod semasa; Jika akar -> kiri tidak batal; Kemas kini Jumlah; Berulang untuk subtree kiri; Jika akar -> betul tidak batal; Memohon formula yang diberikan dalam pendekatan; Berulang untuk subtree yang betul; Kod pemacu; Pokok input; Jumlah nod; Cetak jumlah jarak", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; class TreeNode { public : int data , size ; TreeNode * left ; TreeNode * right ; } ; TreeNode * newNode ( int data ) { TreeNode * Node = new TreeNode ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } pair < int , int > sumofsubtree ( TreeNode * root ) { pair < int , int > p = make_pair ( 1 , 0 ) ; if ( root -> left ) { pair < int , int > ptemp = sumofsubtree ( root -> left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root -> right ) { pair < int , int > ptemp = sumofsubtree ( root -> right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root -> size = p . first ; return p ; } int sum = 0 ; void distance ( TreeNode * root , int target , int distancesum , int n ) { if ( root -> data == target ) { sum = distancesum ; } if ( root -> left ) { int tempsum = distancesum - root -> left -> size + ( n - root -> left -> size ) ; distance ( root -> left , target , tempsum , n ) ; } if ( root -> right ) { int tempsum = distancesum - root -> right -> size + ( n - root -> right -> size ) ; distance ( root -> right , target , tempsum , n ) ; } } int main ( ) { TreeNode * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; int target = 3 ; pair < int , int > p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; cout << sum << endl ; return 0 ; }"}
{"text": "Menyusun semula array sedemikian rupa sehingga jumlah elemen yang diindeks yang sama adalah atmost k | Program C ++ untuk pendekatan di atas; Fungsi untuk menyusun semula array sedemikian rupa sehingga jumlah unsur -unsur yang diindeks yang sama tidak melebihi k; Susun array b [] dalam urutan menurun; Jika keadaan gagal; Cetak array; Kod pemacu; Diberikan susunan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { sort ( B , B + N , greater < int > ( ) ) ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { cout << \" - 1\" << endl ; } else { for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << \" ▁ \" ; } } } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; return 0 ; }"}
{"text": "Kira baris dengan jumlah melebihi jumlah matriks yang tinggal | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira bilangan baris yang jumlahnya melebihi jumlah unsur -unsur matriks yang tinggal; Untuk menyimpan hasilnya; Menyimpan jumlah keseluruhan unsur matriks; Kirakan jumlah keseluruhan; Melintasi untuk memeriksa setiap baris; Menyimpan jumlah elemen baris semasa; Kirakan jumlah elemen baris semasa; Jika jumlah baris semasa melebihi jumlah sisa matriks; Peningkatan kiraan; Cetak hasilnya; Kod pemacu; Diberikan matriks; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  3 NEW_LINE void countRows ( int mat [ M ] [ N ] ) { int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < M ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } cout << count ; } int main ( ) { int mat [ N ] [ M ] = { { 2 , -1 , 5 } , { -3 , 0 , -2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | C ++ pelaksanaan untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Cari elemen maksimum dan minimum. ; Harus ada sekurang -kurangnya elemen dalam pelbagai untuk menjadikannya bersebelahan. ; Buat array yang dikunjungi dan mulakan palsu. ; Tandakan elemen sebagai benar. ; Jika mana -mana elemen tidak ditandakan, semua elemen tidak bersebelahan. ; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | C ++ pelaksanaan untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Menyimpan unsur -unsur 'arr []' dalam jadual hash 'kami'; sebagai Arr [0] hadir dalam 'kami'; Bermula dengan elemen yang lebih kecil sebelumnya ARR [0]; jika 'curr _ ele' hadir dalam 'kami'; kiraan kenaikan; mengemas kini 'curr_ele'; bermula dengan elemen yang lebih besar dari arr [0]; jika 'curr _ ele' hadir dalam 'us'; kiraan kenaikan; kemas kini 'curr_ele \"; pulangan benar jika array mengandungi satu set bilangan bulat bersebelahan lain kembali palsu; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { unordered_set < int > us ; for ( int i = 0 ; i < n ; i ++ ) us . insert ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele ++ ; } return ( count == ( int ) ( us . size ( ) ) ) ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Subarray terpanjang tidak mempunyai lebih banyak daripada elemen yang berbeza | Program CPP untuk mencari subarray terpanjang dengan K atau kurang elemen yang berbeza. ; berfungsi untuk mencetak pelbagai sub - paling lama; Tandakan elemen yang dikunjungi; Jika ia dikunjungi kali pertama, maka tingkatkan kaunter unsur -unsur yang berbeza dengan 1; Apabila kaunter unsur -unsur yang berbeza meningkat dari k, kemudian mengurangkannya kepada k; Dari sebelah kiri, mengurangkan bilangan masa lawatan; Sekiranya elemen masa yang dikurangkan tidak terdapat dalam segmen selanjutnya maka mengurangkan kiraan unsur -unsur yang berbeza; meningkatkan tanda subsegment; Semak panjang sub -segmen terpanjang apabila lebih besar kemudian sebelum ini kemudian tukarnya; Cetak segmen sub - terpanjang; program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << \" ▁ \" ; } int main ( ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; longest ( a , n , k ) ; return 0 ; }"}
{"text": "Periksa sama ada Kira K dalam mana -mana Titik | C ++ pelaksanaan pendekatan; Komparator untuk menyusun vektor pasangan; Fungsi yang mengembalikan benar jika mana -mana segmen K bertindih pada bila -bila masa; Titik permulaan ditandakan dengan - 1 dan titik berakhir dengan + 1; Susun vektor dengan elemen pertama; Tumpukan untuk menyimpan tumpang tindih; Dapatkan elemen semasa; Jika ia adalah titik permulaan; Tolaknya dalam timbunan; Ia adalah titik akhir; Pop elemen dari timbunan; Jika lebih daripada K -ranges bertindih; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sortby ( const pair < int , int > & a , const pair < int , int > & b ) { if ( a . first != b . first ) return a . first < b . first ; return ( a . second < b . second ) ; } bool kOverlap ( vector < pair < int , int > > pairs , int k ) { vector < pair < int , int > > vec ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) { vec . push_back ( { pairs [ i ] . first , -1 } ) ; vec . push_back ( { pairs [ i ] . second , +1 } ) ; } sort ( vec . begin ( ) , vec . end ( ) ) ; stack < pair < int , int > > st ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { pair < int , int > cur = vec [ i ] ; if ( cur . second == -1 ) { st . push ( cur ) ; } else { st . pop ( ) ; } if ( st . size ( ) >= k ) { return true ; } } return false ; } int main ( ) { vector < pair < int , int > > pairs ; pairs . push_back ( make_pair ( 1 , 3 ) ) ; pairs . push_back ( make_pair ( 2 , 4 ) ) ; pairs . push_back ( make_pair ( 3 , 5 ) ) ; pairs . push_back ( make_pair ( 7 , 10 ) ) ; int n = pairs . size ( ) , k = 3 ; if ( kOverlap ( pairs , k ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Cari julat terkecil yang mengandungi elemen dari senarai k | Program C ++ untuk mengetahui pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai disusun yang diberikan. ; array untuk menyimpan indeks semasa senarai i; Fungsi ini mengambil senarai yang disusun dalam bentuk array 2D sebagai hujah. Ia mendapati pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai K. ; memulakan ke 0 indeks; ; untuk mengekalkan indeks senarai yang mengandungi elemen minimum; melangkah ke atas semua senarai; Jika setiap elemen senarai [i] dilalui maka memecahkan gelung; Cari nilai minimum di antara semua elemen senarai yang menunjuk oleh array PTR []; mengemas kini indeks senarai; Cari nilai maksimum di antara semua elemen senarai yang menunjuk oleh array PTR []; Sekiranya ada senarai ekzos, kami tidak akan mendapat jawapan yang lebih baik, jadi pecahkan gelung sementara; mengemas kini Minrange; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int ptr [ 501 ] ; void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) ptr [ i ] = 0 ; minrange = INT_MAX ; while ( 1 ) { minind = -1 ; minval = INT_MAX ; maxval = INT_MIN ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } printf ( \" The ▁ smallest ▁ range ▁ is ▁ [ % d , ▁ % d ] STRNEWLINE \" , minel , maxel ) ; } int main ( ) { int arr [ ] [ N ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSmallestRange ( arr , N , k ) ; return 0 ; }"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Program CPP untuk mencari yang terbesar D sedemikian rupa sehingga D = A + B + C; berfungsi untuk mencari d terbesar; Susun array dalam urutan menaik; melangkah dari belakang untuk mencari D terbesar yang diperlukan; Oleh kerana semua empat A, B, C, D harus berbeza; Jika kombinasi semasa J, K, L dalam set adalah sama dengan S [i] mengembalikan nilai ini kerana ini akan menjadi d terbesar kerana kita melelehkan dalam urutan menurun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; } int main ( ) { int S [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; int ans = findLargestd ( S , n ) ; if ( ans == INT_MIN ) cout << \" No ▁ Solution \" << endl ; else cout << \" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + ▁ \" << \" c ▁ = ▁ d ▁ is ▁ \" << ans << endl ; return 0 ; }"}
{"text": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Program CPP berasaskan hashing untuk mencari D terbesar sehingga A + B + C = D. ; Fungsi ini menemui empat elemen dengan jumlah x yang diberikan; Jumlah wang (a + b) semua pasangan (a, b) dalam jadual hash; Melintasi semua pasangan dan mencari (D - C) hadir dalam jadual hash; Jika d - c ada dalam jadual hash ,; Memastikan semua elemen adalah elemen array yang berbeza dan elemen tidak dianggap lebih dari sekali. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFourElements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = findFourElements ( arr , n ) ; if ( res == INT_MIN ) cout << \" No ▁ Solution . \" ; else cout << res ; return 0 ; }"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Susun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }"}
{"text": "Program untuk Putaran Array | Program C ++ untuk memutar array oleh elemen D; Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar arr [] saiz n oleh d; fungsi utiliti untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftRotatebyOne ( int arr [ ] , int n ) { int temp = arr [ 0 ] , i ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; leftRotate ( arr , 2 , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Susun array dalam julat indeks yang diberikan | Program C ++ untuk menyusun array dalam julat indeks yang diberikan; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Arahan sementara; Susun array sementara; Mengubah suai array asal dengan elemen array sementara; Cetak array yang diubah suai; Kod pemacu; panjang array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; int temp [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } sort ( temp , temp + r - l + 1 ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 ; int b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; return 0 ; }"}
{"text": "Penyusun baris matriks dalam urutan menurun diikuti oleh lajur dalam urutan menaik | C ++ pelaksanaan untuk menyusun baris matriks dalam urutan menurun diikuti dengan menyusun lajur dalam urutan menaik; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh turun. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris tikar [] [] dalam urutan menurun; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menaik. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ ] [ MAX_SIZE ] , int n , bool descending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) sort ( mat [ i ] , mat [ i ] + n , greater < int > ( ) ) ; else sort ( mat [ i ] , mat [ i ] + n ) ; } } void transpose ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } void printMat ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 3 ; int mat [ n ] [ MAX_SIZE ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }"}
{"text": "Pindahkan semua sifar ke hujung array | Program C ++ untuk memindahkan semua sifar pada akhir array; Fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan adalah; Tambahan sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } int main ( ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pushZerosToEnd ( arr , n ) ; cout << \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array ▁ : STRNEWLINE \" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }"}
{"text": "Pindahkan semua sifar ke hujung array | Set | C ++ pelaksanaan untuk memindahkan semua sifar pada akhir array; berfungsi untuk memindahkan semua sifar pada akhir array; Kiraan unsur bukan sifar; Melintasi array. Jika arr [i] bukan sifar, maka swap elemen pada indeks 'kiraan' dengan elemen pada indeks 'i'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "#include <iostream> NEW_LINE using namespace std ; void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) swap ( arr [ count ++ ] , arr [ i ] ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Original ▁ array : ▁ \" ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; cout << \" Modified array : \" printArray ( arr , n ) ; return 0 ; }"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | C ++ pelaksanaan untuk menyusun semula elemen array selepas pengubahsuaian; fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; berfungsi untuk menyusun semula elemen array selepas pengubahsuaian; jika 'arr []' mengandungi satu elemen sahaja; melintasi array; Jika benar, lakukan pengubahsuaian yang diperlukan; nilai indeks semasa dua kali; Letakkan 0 dalam indeks seterusnya; kenaikan sebanyak 1 untuk memindahkan dua indeks di hadapan semasa lelaran gelung; tolak semua sifar pada akhir 'arr []'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Original ▁ array : ▁ \" ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; cout << \" Modified array : \" printArray ( arr , n ) ; return 0 ; }"}
{"text": "Gandakan elemen pertama dan gerakkan sifar ke akhir | Fungsi utiliti untuk menukar dua elemen array; beralih semua sifar ke sebelah kiri array; Mengekalkan indeks terakhir dengan nilai positif; Jika elemen bukan sifar; Swap Indeks Semasa, dengan LastSeen Non - Zero; Elemen seterusnya akan terakhir dilihat bukan - sifar", "code": "void swap ( int & a , int & b ) { a = b + a - ( b = a ) ; } void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Program C ++ untuk menyusun semula nombor positif dan negatif dalam array; Fungsi utiliti untuk mencetak pelbagai saiz n; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Jika elemen semasa positif tidak melakukan apa -apa; Jika elemen semasa adalah negatif, pergeseran elemen positif ARR [0. i - 1], ke satu kedudukan di sebelah kanan mereka; Letakkan elemen negatif pada kedudukan yang betul; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Program C ++ untuk menyusun semula nombor positif dan negatif dalam array; Berfungsi untuk mencetak array; Fungsi untuk membalikkan array. Arahan boleh diterbalikkan dalam masa O (n) dan O (1) ruang. ; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]; Indeks awal Subarray 1 ST; Indeks awal IIND; arr [i. . M] adalah positif; arr [j. . r] adalah bahagian positif yang positif dari sub - array kiri (arr [i. m]); Bahagian negatif terbalik sub - array kanan (arr [m + 1 ... j - 1]); ARR terbalik [i. . J - 1]; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << A [ i ] << \" ▁ \" ; cout << endl ; } void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { swap ( arr [ l ] , arr [ r ] ) ; reverse ( arr , ++ l , -- r ) ; } } void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }"}
{"text": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | C ++ pelaksanaan pendekatan di atas; Gelung sehingga arr [i] <0 dan masih di dalam array; Gelung sehingga arr [j]> 0 dan masih di dalam array; jika saya kurang daripada j; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void RearrangePosNeg ( int arr [ ] , int n ) { int i = 0 ; int j = n - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < n ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }"}
{"text": "Cari pemain untuk dapat menggantikan elemen terakhir yang boleh digantikan oleh pembahagi | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari pemenang permainan yang dimainkan berdasarkan keadaan yang diberikan; Kemenangan jika saiz array adalah ganjil; Jika tidak, B menang; Kod pemacu; Arahan input; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { cout << \" A \" ; } else { cout << \" B \" ; } } int main ( ) { int arr [ ] = { 24 , 45 , 45 , 24 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; winner ( arr , N ) ; }"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Program C ++ untuk pendekatan di atas; Fungsi kepada jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua nilai yang mungkin x dan y, di mana y kurang daripada atau sama dengan sqrt (n). ; Melangkah ke atas semua kemungkinan nilai x; Precompute untuk semua nilai yang mungkin dari ungkapan seperti y <= sqrt (n); Jika saya + j kurang daripada n; Kemas kini DP [i] [J]; Kemas kini DP [i] [J]; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; dp [x] [y]: menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array pertanyaan, q [] []; Jika y kurang daripada atau sama dengan sqrt (n); Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array, arr []; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 20 ; const int sqr = int ( sqrt ( sz ) ) + 1 ; void precomputeExpressionForAllVal ( int arr [ ] , int N , int dp [ sz ] [ sqr ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= sqrt ( N ) ; j ++ ) { if ( i + j < N ) { dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] ; } else { dp [ i ] [ j ] = arr [ i ] ; } } } } int querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { int dp [ sz ] [ sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; if ( y <= sqrt ( N ) ) { cout << dp [ x ] [ y ] << \" ▁ \" ; continue ; } int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ 2 ] = { { 2 , 1 } , { 3 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; querySum ( arr , N , Q , M ) ; return 0 ; }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program C ++ mudah untuk mencari semua elemen dalam pelbagai yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Pilih elemen satu demi satu dan hitung elemen yang lebih besar. Jika kiraan lebih daripada 2, cetak elemen itu. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Mengasingkan program C ++ untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }"}
{"text": "Cari semua elemen dalam pelbagai yang ada di | Program C ++ untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }"}
{"text": "Kurangkan kiraan kenaikan setiap elemen subarray yang diperlukan untuk membuat array bukan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk membuat array tidak meningkat; Menyimpan kiraan operasi yang diperlukan; Jika arr [i]> arr [i + 1], tiada kenaikan diperlukan. Jika tidak, tambahkan perbezaannya kepada jawapannya; Mengembalikan hasil res; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinOps ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMinOps ( arr , N ) ; }"}
{"text": "Cari nombor yang paling kecil | Program C ++ untuk mencari unsur -unsur terkecil yang hilang dalam array yang disusun. ; Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Smallest ▁ missing ▁ element ▁ is ▁ \" << findFirstMissing ( arr , 0 , n - 1 ) << endl ; }"}
{"text": "Cari nombor yang paling kecil | Program C ++ untuk pendekatan di atas; Program untuk mencari yang paling kecil hilang dalam pelbagai disusun; Semak jika 0 hilang dalam array; Cek adalah semua nombor 0 hingga n - 1 adalah prsent dalam array; Program untuk mencari elemen yang hilang; * Perlawanan indeks dengan nilai pada indeks itu, bermakna elemen yang hilang tidak boleh sampai ke po; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallestMissinginSortedArray ( vector < int > arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . size ( ) - 1 ] == arr . size ( ) - 1 ) return arr . size ( ) ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . size ( ) - 1 , first ) ; } int findFirstMissing ( vector < int > arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } int main ( ) { vector < int > arr = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . size ( ) ; cout << \" First ▁ Missing ▁ element ▁ is ▁ : ▁ \" << findSmallestMissinginSortedArray ( arr ) ; }"}
{"text": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan | program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i; Max semasa termasuk i; kembali max incl and excl; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } int main ( ) { vector < int > arr = { 5 , 5 , 10 , 100 , 10 , 5 } ; cout << FindMaxSum ( arr , arr . size ( ) ) ; }"}
{"text": "Langkah -langkah minimum untuk menukar semua laluan kiri ke bawah ke bawah dalam matriks sebagai palindrome | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan perubahan minimum; Jarak elemen dari (0, 0) akan saya julat [0, n + m - 2]; Frekuensi kedai [0, 9] pada jarak I; Memulakan frekuensi sebagai 0; Mengira frekuensi [0, 9]; Kekerapan Kekerapan Matriks nilai [i] [j] pada jarak i + j; Cari nilai dengan kekerapan maksimum dan hitung jumlah sel pada jarak i dari hujung depan dan belakang belakang; Tukar semua nilai ke nilai dengan kekerapan maksimum; Kembalikan jawapannya; Kod pemacu; Diberikan matriks; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  7 NEW_LINE int countChanges ( int matrix [ ] [ N ] , int n , int m ) { int dist = n + m - 1 ; int freq [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } int main ( ) { int mat [ ] [ N ] = { { 1 , 2 } , { 3 , 5 } } ; cout << countChanges ( mat , 2 , 2 ) ; return 0 ; }"}
{"text": "Jadual jarang | Program C ++ untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan nilai minimum dalam arr [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Mengisi carian array carian [] [] dengan cara bawah. ; Memulakan m untuk selang dengan panjang 1; Mengira nilai dari selang yang lebih kecil hingga lebih besar; Kirakan nilai minimum untuk semua selang dengan saiz 2 ^ j; Untuk arr [2] [10], kami membandingkan arr [lookup [0] [7]] dan arr [lookup [3] [10]]; Mengembalikan minimum arr [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan minimum unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kami membandingkan arr [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int lookup [ MAX ] [ MAX ] ; void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } int query ( int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; buildSparseTable ( a , n ) ; cout << query ( 0 , 4 ) << endl ; cout << query ( 4 , 7 ) << endl ; cout << query ( 7 , 8 ) << endl ; return 0 ; }"}
{"text": "Jadual jarang | Program C ++ untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan GCD ARR [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Ia membina meja jarang. ; GCD elemen tunggal adalah elemen itu sendiri; Membina meja jarang; Mengembalikan GCD ARR [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan GCD unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kita dapati GCD ARR [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int table [ MAX ] [ MAX ] ; void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } int query ( int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; buildSparseTable ( a , n ) ; cout << query ( 0 , 2 ) << endl ; cout << query ( 1 , 3 ) << endl ; cout << query ( 4 , 5 ) << endl ; return 0 ; }"}
{"text": "Arahan terkecil lexicographically selepas di | Program C ++ untuk mencari nilai minimum lexicographically selepas k swap. ; Modifies arr [0 .. n - 1] kepada lexicographically terkecil dengan s swap. ; Tetapkan kedudukan di mana kita mahu meletakkan integer terkecil; Jika kita melebihi swap maksimum kemudian menamatkan gelung; Cari nilai minimum dari i + 1 hingga max k atau n; Tukar unsur -unsur dari kedudukan minimum yang kami dapati hingga sekarang ke indeks I; Tetapkan nilai akhir selepas menukar elemen POS - I; Kod pemacu; Fungsi panggilan; Cetak Array Akhir", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } } int main ( ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << \" ▁ \" ; }"}
{"text": "Cari subarray purata maksimum K panjang | Program C ++ untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Buat dan isi array untuk menyimpan jumlah kumulatif. csum [i] menyimpan jumlah arr [0] ke arr [i]; Memulakan max_sm sebagai jumlah subarray pertama; Cari jumlah subarray lain dan kemas kini max_sum jika diperlukan. ; Untuk mengelakkan kebocoran ingatan; Indeks permulaan kembali; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ \" \" length ▁ \" << k << \" ▁ begins ▁ at ▁ index ▁ \" << findMaxAverage ( arr , n , k ) ; return 0 ; }"}
{"text": "Cari subarray purata maksimum K panjang | Program C ++ untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Mengira jumlah elemen 'k' pertama; Mengira jumlah subarray yang tinggal; Indeks permulaan kembali; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ \" \" length ▁ \" << k << \" ▁ begins ▁ at ▁ index ▁ \" << findMaxAverage ( arr , n , k ) ; return 0 ; }"}
{"text": "Skor minimum mungkin untuk pemain dengan memilih satu atau dua elemen array berturut -turut dari array binari yang diberikan | Program C ++ untuk pendekatan di atas; Menyimpan skor minimum untuk setiap negeri sebagai peta <pasangan <pos, myturn>, ans>; Berfungsi untuk mencari skor minimum selepas memilih elemen dari array; Mengembalikan keadaan yang disimpan; Kes asas; Pemain A 'S giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Pemain B 's giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Fungsi yang mendapati penalti minimum selepas memilih elemen dari array binari yang diberikan; Memulakan kedudukan memilih elemen dari array; 0 menandakan pemain A Turn 1 menandakan pemain B giliran; Panggilan fungsi; Cetak jawapan untuk Pemain A dan B; Penalti minimum; Hitung jumlah semua elemen ARR; Cetak skor minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < pair < int , int > , int > m ; int findMinimum ( int a [ ] , int n , int pos , int myturn ) { if ( m . find ( { pos , myturn } ) != m . end ( ) ) { return m [ { pos , myturn } ] ; } if ( pos >= n ) { return 0 ; } if ( ! myturn ) { int ans = min ( findMinimum ( a , n , pos + 1 , ! myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , ! myturn ) + a [ pos ] + a [ pos + 1 ] ) ; m [ { pos , myturn } ] = ans ; return ans ; } if ( myturn ) { int ans = min ( findMinimum ( a , n , pos + 1 , ! myturn ) , findMinimum ( a , n , pos + 2 , ! myturn ) ) ; m [ { pos , myturn } ] = ans ; return ans ; } return 0 ; } int countPenality ( int arr [ ] , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) ; } void printAnswer ( int * arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } cout << a ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAnswer ( arr , N ) ; return 0 ; }"}
{"text": "Jumlah nombor utama dalam julat [l, r] dari array yang diberikan untuk pertanyaan q | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nombor perdana; Buat Boolean Array Prime [] dan memulakan semua penyertaannya sebagai benar nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana; Semak jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan; Berfungsi untuk mendapatkan indeks pertengahan dari indeks sudut; Berfungsi untuk mendapatkan jumlah nilai dalam julat array yang diberikan; Jika segmen nod ini adalah sebahagian daripada julat yang diberikan, maka kembalikan jumlah segmen; Jika segmen nod ini berada di luar julat yang diberikan; Jika sebahagian daripada segmen ini bertindih dengan julat yang diberikan; Fungsi untuk mengemas kini nod yang mempunyai indeks yang diberikan dalam julatnya; Jika indeks input terletak di luar julat segmen ini; Jika indeks input berada dalam julat nod ini, maka kemas kini nilai nod dan anak -anaknya; Berfungsi untuk mengemas kini nilai dalam array input dan pokok segmen; Semak indeks input yang salah; Dapatkan perbezaan antara nilai baru dan nilai lama; Kemas kini nilai dalam array; Kemas kini nilai nod dalam pokok segmen hanya jika sama ada nilai sebelumnya atau nilai baru atau kedua -duanya adalah perdana; Jika hanya nilai baru adalah perdana; Jika hanya nilai baru adalah perdana; Jika kedua -duanya adalah perdana; Pulangan Jumlah Elemen dalam Julat dari Indeks QS (Permulaan Permintaan) ke QE (End Query). Ia terutamanya menggunakan getSumutil (); Semak nilai input yang salah; Fungsi yang membina pokok segmen; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Hanya tambah unsur -unsur dalam pokok segmen yang utama; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan jumlah nilai dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Panggilan fungsi; Membina pokok segmen dari array yang diberikan; Cetak jumlah nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 10 dan kemas kini nod pokok segmen yang sepadan; Cari jumlah selepas nilai dikemas kini", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int const MAX = 1000001 ; bool prime [ MAX ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } int getSumUtil ( int * st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } void updateValueUtil ( int * st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } void updateValue ( int arr [ ] , int * st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { cout << \" - 1\" ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( prime [ new_val ] prime [ prev_val ] ) { if ( ! prime [ prev_val ] ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( ! prime [ new_val ] ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } } int getSum ( int * st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { cout << \" - 1\" ; return -1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q [ 3 ] [ 3 ] = { { 1 , 1 , 3 } , { 2 , 1 , 10 } , { 1 , 1 , 3 } } ; SieveOfEratosthenes ( ) ; int * st = constructST ( arr , n ) ; cout << getSum ( st , n , 1 , 3 ) << endl ; updateValue ( arr , st , n , 1 , 10 ) ; cout << getSum ( st , n , 1 , 3 ) << endl ; return 0 ; }"}
{"text": "Kira bilangan cara untuk membina rentetan sasaran | Program C ++ untuk mengira bilangan cara untuk membina rentetan sasaran; Kes asas; Jika subproblem semasa telah diselesaikan, gunakan nilai; watak semasa; Cari melalui semua yang ditunjukkan di mana watak semasa berlaku. Untuk setiap indeks yang lebih besar daripada sebelumnya, ambil indeks dan bergerak ke kedudukan seterusnya, dan tambahkan jawapannya. ; Simpan dan kembalikan penyelesaian untuk subproblem ini; PREPROCESS THE RINGS DENGAN MENYEDIAKAN UNTUK SETIAP KARAKTER SETIAP RENTING, INDEKS KELUARGA MEREKA KAMI AKAN MENGGUNAKAN SENARAI BERHUBUNGAN UNTUK SEMUA SETIAP HANYA SAHAJA INDEKS DALAM RENCEN DENGAN Watak dipilih; Kami menyimpan J + 1 kerana indeks yang dipilih awal dalam langkah rekursif akan NE 0. Ini hanya untuk kemudahan pelaksanaan; Inisiasi jadual DP. - 1 mewakili bahawa subproblem tidak diselesaikan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1000000007 ; int dp [ 1000 ] [ 1000 ] ; int calculate ( int pos , int prev , string s , vector < int > * index ) { if ( pos == s . length ( ) ) return 1 ; if ( dp [ pos ] [ prev ] != -1 ) return dp [ pos ] [ prev ] ; int c = s [ pos ] - ' a ' ; int answer = 0 ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( index [ i ] > prev ) { answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod ; } } return dp [ pos ] [ prev ] = answer ; } int countWays ( vector < string > & a , string s ) { int n = a . size ( ) ; vector < int > index [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a [ i ] . length ( ) ; j ++ ) { index [ a [ i ] [ j ] - ' a ' ] . push_back ( j + 1 ) ; } } memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 0 , s , index ) ; } int main ( ) { vector < string > A ; A . push_back ( \" adc \" ) ; A . push_back ( \" aec \" ) ; A . push_back ( \" erg \" ) ; string S = \" ac \" ; cout << countWays ( A , S ) ; return 0 ; }"}
{"text": "Count of integer dari julat [0, n] yang jumlah digitnya adalah pelbagai k | C ++ pelaksanaan pendekatan; Untuk menyimpan negeri -negeri DP; Berfungsi untuk mengembalikan kiraan nombor dari julat [0, n] yang jumlah digitnya adalah pelbagai k menggunakan dp bawah; Digit dalam indeks ini hanya boleh dari [0, num [idx]]; Digit dalam indeks ini boleh menjadi apa -apa dari [0, 9]; new_tight adalah nilai bendera untuk kedudukan seterusnya; Res tidak boleh menjadi negatif; Berfungsi untuk memproses rentetan ke vektor digit dari MSD ke LSD; Kod pemacu; Untuk nombor input besar n; Jumlah bilangan digit dalam n; Jadual DP Bersih; Proses rentetan ke vektor digit dari MSD ke LSD", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE #define MOD  1000000007 NEW_LINE int dp [ MAX ] [ 101 ] [ 2 ] ; int countNum ( int idx , int sum , int tight , vector < int > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != -1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } vector < int > process ( string s ) { vector < int > num ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . push_back ( s [ i ] - '0' ) ; } return num ; } int main ( ) { string n = \"98765432109876543210\" ; int len = n . length ( ) ; int k = 58 ; memset ( dp , -1 , sizeof ( dp ) ) ; vector < int > num = process ( n ) ; cout << countNum ( 0 , 0 , 0 , num , len , k ) ; return 0 ; }"}
{"text": "Double Knapsack | Pengaturcaraan Dinamik | C ++ pelaksanaan pendekatan di atas; Arahan 3D untuk menyimpan negeri -negeri DP; W1_R mewakili kapasiti selebihnya 1 stnapsack w2_r mewakili kapasiti selebihnya 2 nd knapsack I mewakili indeks array arr yang kami sedang kerjakan; Kes asas; Pembolehubah untuk menyimpan hasil tiga bahagian hubungan berulang; Simpan negeri dalam array 3d; Kod pemacu; Arahan input; Memulakan array dengan - 1; Bilangan elemen dalam array; Kapasiti knapsacks; Berfungsi untuk dipanggil", "code": "#include <bits/stdc++.h> NEW_LINE #define maxN  31 NEW_LINE #define maxW  31 NEW_LINE using namespace std ; int dp [ maxN ] [ maxW ] [ maxW ] ; int maxWeight ( int * arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != -1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } int main ( ) { int arr [ ] = { 8 , 2 , 3 } ; memset ( dp , -1 , sizeof ( dp ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int w1 = 10 , w2 = 3 ; cout << maxWeight ( arr , n , w1 , w2 , 0 ) ; return 0 ; }"}
{"text": "Jumlah bitwise dan semua submatrices | Program C ++ untuk mencari jumlah bit - bijak dan semua submatrik; Berfungsi untuk mencari awalan - kiraan untuk setiap baris dari kanan ke kiri; Berfungsi untuk mencari bilangan submatrik dengan semua 1 s; Array untuk menyimpan kiraan awalan yang diperlukan 1 s dari kanan ke kiri untuk array boolean; Pembolehubah untuk menyimpan jawapan terakhir; Untuk setiap indeks lajur, tentukan bilangan sub -matriks bermula dari indeks itu dan mempunyai semua 1 s; Stack untuk menyimpan unsur -unsur dan kiraan nombor yang mereka muncul bahagian pertama pasangan adalah nilai elemen yang dimasukkan bahagian kedua adalah mengira bilangan elemen yang ditolak sebelum dengan nilai yang lebih besar; pembolehubah untuk menyimpan bilangan submatrik dengan semua 1 s; Berfungsi untuk mencari jumlah bitwise - dan semua submatrices; matriks untuk menyimpan status ith bit setiap elemen matriks arr; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; #define n  3 NEW_LINE void findPrefixCount ( int p_arr [ ] [ n ] , bool set_bit [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( int ) set_bit [ i ] [ j ] ; } } } int matrixAllOne ( bool set_bit [ ] [ n ] ) { int p_arr [ n ] [ n ] = { 0 } ; findPrefixCount ( p_arr , set_bit ) ; int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; stack < pair < int , int > > q ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 and q . top ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . top ( ) . second + 1 ) * ( q . top ( ) . first - p_arr [ i ] [ j ] ) ; c += q . top ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( { p_arr [ i ] [ j ] , c } ) ; i -- ; } } return ans ; } int sumAndMatrix ( int arr [ ] [ n ] ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { bool set_bit [ n ] [ n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; } int main ( ) { int arr [ ] [ n ] = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; cout << sumAndMatrix ( arr ) ; return 0 ; }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk 3 nilai terakhir sebelum i. ; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Bilangan cara jika larian pertama adalah 2 dan larian kedua ialah 1; Ingat 3 nilai terakhir; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { int noOfWays [ 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 5 ; cout << CountWays ( n ) ; return 0 ; }"}
{"text": "Laluan Perdana Lexicographically terbesar dari atas | C ++ pelaksanaan pendekatan di atas; Carian pertama kedalaman; Kembali jika sel mengandungi nombor bukan perdana atau halangan, atau keluar dari matriks atau sudah melawat sel atau sudah menemui jalan terbesar leksikografi; Penandaan sel sudah dikunjungi; menyimpan indeks laluan terbesar leksikografi; jika sampai ke akhir matriks; mengemas kini bilangan akhir langkah dalam laluan terbesar leksikografi; bergerak pepenjuru (mencuba laluan terbesar leksikografi); menggerakkan sel ke sel semasa; bergerak sel ke sel semasa. ; Cetak jalan utama lexicographical terbesar; untuk mengira bilangan langkah dalam laluan utama terbesar leksikografi; untuk menyimpan indeks jalan utama terbesar lexicographical; untuk menandakan jika sel sudah dilalui atau tidak; melintasi DFS; mencetak laluan utama terbesar lexicographical; Kembalikan bilangan jalan utama dalam matriks. ; untuk setiap sel; Jika di barisan atas atau lajur paling kiri, tidak ada jalan di sana. ; Jika nombor bukan perdana; Mencari pemetaan matriks dengan mempertimbangkan nombor bukan perdana sebagai halangan dan nombor utama menjadi laluan yang sah. ; Ayak; Jika Perdana; jika bukan Perdana; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  105 NEW_LINE void sieve ( int prime [ ] ) { for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j <= MAX ; j += i ) prime [ j ] = 1 ; } } } void dfs ( int i , int j , int k , int * q , int n , int m , int mappedMatrix [ ] [ MAX ] , int mark [ ] [ MAX ] , pair < int , int > ans [ ] ) { if ( mappedMatrix [ i ] [ j ] == 0 || i > n || j > m || mark [ i ] [ j ] || ( * q ) ) return ; mark [ i ] [ j ] = 1 ; ans [ k ] = make_pair ( i , j ) ; if ( i == n && j == m ) { ( * q ) = k ; return ; } dfs ( i + 1 , j + 1 , k + 1 , q , n , m , mappedMatrix , mark , ans ) ; dfs ( i + 1 , j , k + 1 , q , n , m , mappedMatrix , mark , ans ) ; dfs ( i , j + 1 , k + 1 , q , n , m , mappedMatrix , mark , ans ) ; } void lexicographicalPath ( int n , int m , int mappedMatrix [ ] [ MAX ] ) { int q = 0 ; pair < int , int > ans [ MAX ] ; int mark [ MAX ] [ MAX ] ; dfs ( 1 , 1 , 1 , & q , n , m , mappedMatrix , mark , ans ) ; for ( int i = 1 ; i <= q ; i ++ ) cout << ans [ i ] . first << \" ▁ \" << ans [ i ] . second << \" STRNEWLINE \" ; } void countPrimePath ( int mappedMatrix [ ] [ MAX ] , int n , int m ) { int dp [ MAX ] [ MAX ] = { 0 } ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } cout << dp [ n ] [ m ] << \" STRNEWLINE \" ; } void preprocessMatrix ( int mappedMatrix [ ] [ MAX ] , int a [ ] [ MAX ] , int n , int m ) { int prime [ MAX ] ; sieve ( prime ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } } int main ( ) { int n = 3 ; int m = 3 ; int a [ MAX ] [ MAX ] = { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int mappedMatrix [ MAX ] [ MAX ] = { 0 } ; preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; return 0 ; }"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset + nilai subset maksimal. ; Pulangan saiz subset bersaiz maksimum jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan. Ia kembali - 1 jika tidak ada subset dengan jumlah yang diberikan. ; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ sum + 1 ] [ n + 1 ] ; int count [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = -1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } int main ( ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = 4 ; cout << isSubsetSum ( set , n , sum ) ; }"}
{"text": "Cetak semua sub biasa terpanjang | Program C ++ untuk mencari semua LCS dua rentetan dalam urutan yang disusun. ; panjang LCS; Matriks DP untuk menyimpan hasil sub panggilan untuk LCS; Fungsi berasaskan memoisasi yang mengembalikan LCS STR1 [i. . len1 - 1] dan str2 [j. . len2 - 1]; keadaan asas; Jika LCS telah dikira; Jika watak -watak yang sama pulangan sebelumnya + 1 lain max dua urutan selepas mengeluarkan i 'th »dan u' th char satu demi satu; Berfungsi untuk mencetak semua laluan sub - urutan panjang lcslen panjang; Jika currlcs sama dengan lcslen maka cetaknya; Jika kita selesai dengan semua watak kedua -dua rentetan; Di sini kita perlu mencetak semua sub -urutan secara lexicographically, bahawa mengapa kita mula dari 'a' ke 'z' jika watak ini hadir dalam kedua -dua mereka kemudian menambahnya dalam data [] dan bahagian yang sama; Selesai adalah bendera untuk memberitahu bahawa kami telah mencetak semua berikutnya yang sepadan dengan watak semasa; Jika watak CH hadir dalam STR1 maka periksa sama ada ia terdapat dalam STR2; Jika CH hadir dalam kedua -dua mereka dan baki panjang adalah sama dengan panjang LCS yang tinggal kemudian tambah CH dalam sub -sequenece; Jika kami mendapati LCS bermula dengan watak semasa. ; Fungsi ini mencetak semua LCS Str1 dan Str2 dalam urutan leksikografi. ; Cari panjang kedua -dua rentetan; Cari panjang LCS; Cetak semua LCS menggunakan data backtracking rekursif [] digunakan untuk menyimpan LCS individu. ; Program pemacu untuk menjalankan kes itu", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int lcslen = 0 ; int dp [ MAX ] [ MAX ] ; int lcs ( string str1 , string str2 , int len1 , int len2 , int i , int j ) { int & ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != -1 ) return ret ; ret = 0 ; if ( str1 [ i ] == str2 [ j ] ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; } void printAll ( string str1 , string str2 , int len1 , int len2 , char data [ ] , int indx1 , int indx2 , int currlcs ) { if ( currlcs == lcslen ) { data [ currlcs ] = ' \\0' ; puts ( data ) ; return ; } if ( indx1 == len1 indx2 == len2 ) return ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { bool done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) { if ( ch == str1 [ i ] ) { for ( int j = indx2 ; j < len2 ; j ++ ) { if ( ch == str2 [ j ] && dp [ i ] [ j ] == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } } if ( done ) break ; } } } void prinlAllLCSSorted ( string str1 , string str2 ) { int len1 = str1 . length ( ) , len2 = str2 . length ( ) ; memset ( dp , -1 , sizeof ( dp ) ) ; lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char data [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; } int main ( ) { string str1 = \" abcabcaa \" , str2 = \" acbacba \" ; prinlAllLCSSorted ( str1 , str2 ) ; return 0 ; }"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program C ++ untuk memeriksa elemen majoriti dalam array yang disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( isMajority ( arr , n , x ) ) cout << x << \" ▁ appears ▁ more ▁ than ▁ \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; else cout << x << \" ▁ does ▁ not ▁ appear ▁ more ▁ than \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; return 0 ; }"}
{"text": "Semak elemen majoriti dalam array yang disusun | Program C ++ untuk memeriksa elemen majoriti dalam array yang disusun; Jika x hadir dalam arr [rendah ... tinggi] maka mengembalikan indeks kejadian pertama x, jika tidak pulangan - 1; Semak jika ARR [MID] adalah kejadian pertama x. arr [pertengahan] adalah kejadian pertama jika x adalah salah satu daripada yang berikut adalah benar: (i) pertengahan == 0 dan arr [mid] = = x (ii) arr [pertengahan - 1] <x dan arr [mid] == x; Fungsi ini kembali benar jika x hadir lebih daripada n / 2 kali dalam arr [] saiz n; Cari indeks kejadian pertama x dalam arr []; Jika elemen tidak hadir sama sekali, kembali palsu; Semak jika elemen hadir lebih daripada n / 2 kali; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; } bool isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == -1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajority ( arr , n , x ) ) cout << x << \" ▁ appears ▁ more ▁ than ▁ \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; else cout << x << \" ▁ does ▁ not ▁ appear ▁ more ▁ than \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; return 0 ; }"}
{"text": "Semak elemen majoriti dalam array yang disusun |  ;", "code": "#include <iostream> NEW_LINE using namespace std ; bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) cout << x << \" ▁ appears ▁ more ▁ than ▁ \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; else cout << x << \" ▁ does ▁ not ▁ appear ▁ more ▁ than \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; return 0 ; }"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" << cutRod ( arr , size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Memotong batang | DP | Program CPP untuk pendekatan di atas; Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << \" Maximum ▁ obtained ▁ value ▁ is ▁ \" << un_kp ( price , length , n , Max_len ) << endl ; }"}
{"text": "Ubah suai array ke array lain yang diberikan dengan menggantikan elemen array dengan jumlah array | Program CPP untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada arr [] boleh ditukar kepada sasaran [] dengan menggantikan mana -mana elemen dalam arr [] dengan jumlah arr []; Simpan elemen maksimum; Simpan indeks elemen maksimum; Melintasi sasaran array []; Jika elemen semasa lebih besar daripada maks; Jika elemen max adalah 1; Melintasi array, sasaran []; Jika indeks semasa tidak sama dengan indeks elemen maksimum; Kemas kini Max; Jika max kurang daripada atau sama dengan 0 ,; Mengemas kini elemen maksimum; Memanggil semula fungsi secara rekursif; Kod pemacu; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int target [ ] , int n ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target , n ) ; } int main ( ) { int target [ ] = { 9 , 3 , 5 } ; int n = sizeof ( target ) / sizeof ( target [ 0 ] ) ; bool res = isPossible ( target , n ) ; if ( res ) { cout << \" YES \" ; } else { cout << \" NO \" ; } return 0 ; }"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | C ++ pelaksanaan pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 3 , m = 2 , k = 2 ; cout << nCr ( n + m , k ) ; return 0 ; }"}
{"text": "Semak jika n boleh didapati dari 1 dengan mengulangi secara berulang dengan 10 atau 20 | Program C ++ untuk memeriksa sama ada n boleh diperolehi dari 1 dengan pendaraban berulang sebanyak 10 atau 20; Fungsi untuk memeriksa sama ada n boleh diperoleh atau tidak; Mengira dan mengeluarkan sifar trailing; Semak jika baki N adalah kuasa 2; Untuk memeriksa keadaan untuk mencetak ya atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Is_possible ( long long int N ) { int C = 0 ; int D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( pow ( 2 , ( int ) log2 ( N ) ) == N ) { D = ( int ) log2 ( N ) ; if ( C >= D ) cout << \" YES \" ; else cout << \" NO \" ; } else cout << \" NO \" ; } int main ( ) { long long int N = 2000000000000 ; Is_possible ( N ) ; }"}
{"text": "Nombor Poligonal Tengah | Program C ++ untuk mencari istilah N - Th dalam siri ini; Fungsi untuk mencari istilah n - th dalam siri ini; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findNthTerm ( int n ) { cout << n * n - n + 1 << endl ; } int main ( ) { int N = 4 ; findNthTerm ( N ) ; return 0 ; }"}
{"text": "Anti | Program C ++ untuk pendekatan di atas; Fungsi berulang untuk membalikkan digit NUM; Mengembalikan nombor terbalik; Fungsi untuk mengira jumlah pembalikan semua pembahagi yang betul; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi Num; Jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Fungsi untuk memeriksa sama ada n adalah anti - sempurna atau tidak; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } } return ( result + 1 ) ; } bool isAntiPerfect ( int n ) { return divSum ( n ) == n ; } int main ( ) { int N = 244 ; if ( isAntiPerfect ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk mencetak Siri 1, 3, 4, 8, 15, 27, 50 â € | Sehingga N Syarat | Pelaksanaan C ++ untuk mencetak istilah N siri yang tiga istilahnya diberikan; Berfungsi untuk mencetak siri; Menjana istilah ith dan mencetaknya; Kod pemacu; Panggilan fungsi", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { cout << a << \" ▁ \" ; return ; } if ( n == 2 ) { cout << a << \" ▁ \" << b << \" ▁ \" ; return ; } cout << a << \" ▁ \" << b << \" ▁ \" << c << \" ▁ \" ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; cout << d << \" ▁ \" ; a = b ; b = c ; c = d ; } } int main ( ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; return 0 ; }"}
{"text": "Diameter pokok terindeks binari dengan nod n |  ; Berfungsi untuk mencari diameter bit dengan n + 1 nod; L adalah saiz subtree sebelum subtree di mana n terletak; H ialah ketinggian subtree sebelum subtree di mana n terletak; Kes asas; Saiz subtree adalah kuasa 2; 3 kes seperti yang dijelaskan dalam pendekatan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } int main ( ) { int n = 15 ; cout << diameter ( n ) << endl ; }"}
{"text": "Cari eksponen yang lebih besar di antara dua eksponen | C ++ pelaksanaan pendekatan; Fungsi untuk mencari sama ada A ^ B lebih besar atau c ^ d; Cari b * log (a); Cari d * log (c); Bandingkan kedua -dua nilai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void compareValues ( int a , int b , int c , int d ) { double log1 = log10 ( a ) ; double num1 = log1 * b ; double log2 = log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) cout << a << \" ^ \" << b ; else cout << c << \" ^ \" << d ; } int main ( ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; }"}
{"text": "Jumlah nombor perdana tanpa digit utama yang ganjil |  ; Cari semua nombor utama; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada digit adalah perdana ganjil atau tidak; Berfungsi untuk mencari jumlah; Untuk menyimpan jawapan yang diperlukan; Dapatkan semua nombor utama; Melintasi semua nombor perdana; Kedai bendera 1 Jika nombor tidak mengandungi sebarang prima yang ganjil; Cari semua digit nombor; Jika nombor tidak mengandungi sebarang prima yang ganjil; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE vector < int > addPrimes ( ) { int n = MAX ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } vector < int > ans ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push_back ( p ) ; return ans ; } bool is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; } int find_Sum ( int n ) { int sum = 0 ; vector < int > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) and n ; i ++ ) { int flag = 1 ; int a = v [ i ] ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v [ i ] ; } } return sum ; } int main ( ) { int n = 7 ; cout << find_Sum ( n ) ; return 0 ; }"}
{"text": "Kira bilangan prima dalam array jumlah awalan array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari semua prima di arr []; Berfungsi untuk menghasilkan array awalan; Isi array awalan; Kod pemacu; Arahan awalan arr []; Count of Prima dalam Array Awalan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int primeCount ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } void getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } } int main ( ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pre [ n ] ; getPrefixArray ( arr , n , pre ) ; cout << primeCount ( pre , n ) ; return 0 ; }"}
{"text": "Nilai minimum yang akan ditambah kepada x supaya sekurang -kurangnya y peratus daripada n | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan nilai yang diperlukan yang mesti ditambah kepada x supaya sekurang -kurangnya y peratus daripada n; Nilai yang diperlukan; Jika x sudah> = y peratus n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; } int main ( ) { int n = 10 , x = 2 , y = 40 ; cout << minValue ( n , x , y ) ; }"}
{"text": "Semak jika n adalah faktorial utama | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah faktorial utama; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah faktorial utama; Jika n tidak perdana maka kembali palsu; Hitung faktorial; Jika n adalah perdana faktorial; n bukanlah perdana faktorial; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; } int main ( ) { int n = 23 ; if ( isFactorialPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Susunan tempat duduk N Boys and Girls secara alternatif di sekitar meja bulat | Program C ++ untuk mencari bilangan cara di mana N Boys dan N Girls boleh duduk secara alternatif bunyi meja bulat. ; Kod pemacu; Dapatkan n; Cari FAC1 = (n - 1)! ; Cari FAC2 = N! ; Cari jumlah cara; Cetak jumlah cara", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long int NEW_LINE int main ( ) { ll n = 5 ; ll fac1 = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; ll fac2 = fac1 * n ; ll totalWays = fac1 * fac2 ; cout << totalWays << endl ; return 0 ; }"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program CPP untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor perdana; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan semua nombor utama ke vektor 'arr'; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Masukkan nombor perdana seterusnya dan periksa sama ada produk + 1 = n memegang atau tidak; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE vector < int > arr ; void SieveOfEratosthenes ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . push_back ( p ) ; } bool isEuclid ( long n ) { long long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr [ i ] ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } int main ( ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; n = 42 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; return 0 ; }"}
{"text": "Cube sempurna lebih besar daripada nombor tertentu | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari kiub sempurna seterusnya; Kod pemacu", "code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int nextPerfectCube ( int N ) { int nextN = floor ( cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } int main ( ) { int n = 35 ; cout << nextPerfectCube ( n ) ; return 0 ; }"}
{"text": "Jumlah semua pembahagi utama nombor | Program C ++ untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kembali jenis fungsi SQRT jika terapung; Kedua -dua faktor adalah sama; Kedua -dua faktor tidak sama (i dan n / i); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; } int main ( ) { int n = 60 ; cout << \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" << SumOfPrimeDivisors ( n ) << endl ; }"}
{"text": "Kedudukan N di antara nombor yang diperbuat daripada 2, 3, 5 & 7 |  ; Jika nombor adalah 2 maka ia berada di kedudukan pos * 2 + 1; Jika nombor adalah 3 maka ia berada di kedudukan pos * 2 + 2; Jika nombor adalah 5 maka ia berada di kedudukan pos * 2 + 3; Jika nombor adalah 7 maka ia berada di kedudukan pos * 2 + 4; Kod pemacu", "code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int findpos ( string n ) { int pos = 0 ; for ( int i = 0 ; n [ i ] != ' \\0' ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } int main ( ) { string n = \"777\" ; cout << findpos ( n ) ; }"}
{"text": "Mencari Co Transitif | Program C ++ untuk mencari Triplets Perdana yang tidak transitif di antara L dan R; Memeriksa jika ada triplet yang mungkin (a, b, c) memenuhi syarat bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Kes 1: Kurang daripada 3 nombor antara L dan R; Kes 2: Lebih daripada 3 nombor antara L dan R; Triplet harus selalu menjadi bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.1: Tepat 3 nombor dalam julat bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.2: Tepat 3 nombor dalam julat bentuk (2 k - 1, 2 k, 2 k + 1); Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA , possibleB , possibleC ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { cout << \" ( \" << possibleA << \" , ▁ \" << possibleB << \" , ▁ \" << possibleC << \" ) \" << \" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } else { cout << \" No ▁ Such ▁ Triplet ▁ exists ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } } int main ( ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; return 0 ; }"}
{"text": "Count n digit nombor tidak mempunyai digit tertentu | C ++ pelaksanaan kaedah di atas; Mencari bilangan nombor yang mungkin dengan digit N tidak termasuk digit tertentu; Memeriksa jika bilangan digit adalah sifar; Memeriksa jika bilangan digit adalah satu; Memeriksa jika bilangan digit adalah ganjil; Memanggil fungsi digitNumber dengan (digit - 1) / 2 digit; Memanggil fungsi digitnumber dengan n / 2 digit; Memanggil fungsi DigitNumber Memeriksa jika tidak termasuk digit adalah sifar atau bukan sifar; Fungsi pemacu untuk menjalankan program di atas; Memulakan pembolehubah", "code": "#include <bits/stdc++.h> NEW_LINE #define mod  1000000007 NEW_LINE using namespace std ; long long digitNumber ( long long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 ) { long long temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { long long temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } int main ( ) { long long d = 9 ; int n = 3 ; cout << countExcluding ( n , d ) << endl ; return 0 ; }"}
{"text": "Semak jika nombor yang diberikan adalah nombor emirp atau tidak | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah emirp atau tidak. ; Pulangan benar jika n adalah perdana. Lain palsu. ; Kes sudut; Semak dari 2 hingga n - 1; Fungsi akan memeriksa sama ada nombor adalah emirp atau tidak; Semak jika n adalah perdana; Cari terbalik n; Jika kedua -dua asal dan terbalik adalah perdana, maka ia adalah nombor emirp; Kod pemacu; Nombor input", "code": "#include <iostream> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } bool isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; } int main ( ) { int n = 13 ; if ( isEmirp ( n ) == true ) cout << \" Yes \" ; else cout << \" No \" ; }"}
{"text": "Program untuk menukar radian ke ijazah | C ++ kod untuk menukar radian ke ijazah; Fungsi untuk penukaran; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } int main ( ) { double radian = 5.0 ; double degree = Convert ( radian ) ; cout << degree ; return 0 ; }"}
{"text": "Cari jejak matriks yang dibentuk dengan menambah baris | Program C ++ untuk mencari jejak matriks yang dibentuk dengan menambah baris - utama dan lajur - urutan utama matriks yang sama; Kembali jumlah integer pertama A AP; Kembalikan jejak jumlah baris - matriks utama dan lajur - matriks utama; Mencari elemen ke dalam AP sekiranya matriks utama baris. ; Mencari jumlah integer pertama AP dalam kes matriks utama baris; Mencari elemen ke dalam AP sekiranya matriks utama baris; Mencari jumlah integer pertama AP dalam kes matriks utama lajur; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } int main ( ) { int N = 3 , M = 3 ; cout << trace ( N , M ) << endl ; return 0 ; }"}
{"text": "Maksimum kawasan yang paling kecil yang boleh diperoleh dengan tepat K yang diberikan segi empat tepat | C ++ Kod untuk maksimum kawasan yang paling kecil yang boleh mendapatkan dengan tepat K Cut dari segi empat tepat yang diberikan; Fungsi utiliti; untuk kes 1 st; untuk kes kedua; Hasil akhir cetak; kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << \" Not ▁ possible \" << endl ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result << endl ; } } int main ( ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; }"}
{"text": "Program untuk mencari kawasan persegi | Program CPP untuk mencari kawasan persegi; berfungsi untuk mencari kawasan; Program Pemandu", "code": "#include <iostream> NEW_LINE using namespace std ; int area_fun ( int side ) { int area = side * side ; return area ; } int main ( ) { int side = 4 ; int area = area_fun ( side ) ; cout << area ; return 0 ; }"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah nombor berturut -turut | Program C ++ untuk mengira bilangan cara untuk menyatakan N sebagai jumlah nombor berturut -turut. ; Kaedah utiliti untuk mengira bilangan cara di mana n boleh diwakili sebagai jumlah nombor berturut -turut; Kekangan pada nilai L memberi kita kerumitan masa sebagai O (n ^ 0.5); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long int countConsecutive ( long int N ) { long int count = 0 ; for ( long int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } int main ( ) { long int N = 15 ; cout << countConsecutive ( N ) << endl ; N = 10 ; cout << countConsecutive ( N ) << endl ; return 0 ; }"}
{"text": "Nombor Automorphic | Program C ++ untuk memeriksa sama ada nombor adalah authomorphic; Berfungsi untuk memeriksa nombor automorphic; Simpan dataran; Mula membandingkan digit; Kembali palsu, jika mana -mana digit dari n tidak sesuai dengan angka -angka yang terakhir; Mengurangkan N dan persegi; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } int main ( ) { int N = 5 ; isAutomorphic ( N ) ? cout << \" Automorphic \" : cout << \" Not ▁ Automorphic \" ; return 0 ; }"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Program C ++ untuk mencari integer yang mempunyai bilangan maksimum faktor utama dalam nombor semulajadi n pertama; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Nilai lalai boolean adalah palsu; Ayak eratosthenes; Menyimpan nombor perdana. ; Nombor penjanaan yang mempunyai faktor utama maksimum. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { bool arr [ N + 5 ] ; memset ( arr , true , sizeof ( arr ) ) ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( arr [ i ] ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = false ; } vector < int > prime ; prime . push_back ( 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) if ( arr [ i ] ) prime . push_back ( i ) ; int i = 0 , ans = 1 ; while ( ans * prime [ i ] <= N && i < prime . size ( ) ) { ans *= prime [ i ] ; i ++ ; } return ans ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program C ++ untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Semak bit set; Kemudian kita mengeluarkan semua tetapi bit atas oleh xor 'ing u »'» s dengan rentetan 1 's' u u u u u u u u u u u u u u u u u u u u u u. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; unsigned highestPowerof2 ( unsigned x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Jumlah semua pembahagi yang betul dari nombor semulajadi | Program C ++ untuk mencari jumlah semua pembahagi nombor semulajadi; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Tidak akan ada pembahagi yang betul; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Program pemacu untuk menjalankan kes itu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int divSum ( int num ) { int result = 0 ; if ( num == 1 ) return result ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } int main ( ) { int num = 36 ; cout << divSum ( num ) ; return 0 ; }"}
{"text": "Cari akar persegi di bawah modulo p | Tetapkan 1 (apabila p dalam bentuk 4 * i + 3) | Program C ++ yang cekap untuk mencari akar persegi di bawah modulo p apabila p ialah 7, 11, 19, 23, 31, ... dan lain -lain. ; Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p. ; int res = 1; Inisialisasi hasil x = x % p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Pulangan benar jika akar kuadrat n di bawah modulo p ada asumsi: p adalah bentuk 3 * i + 4 di mana i> = 1; Cuba \" + (n ^ ((p ~ ~ 1) / 4))\"; Cuba \" - (n '((p ~ ~ 1) / 4))\"; Sekiranya tiada dua kerja di atas, maka akar persegi tidak wujud; Program Pemandu untuk Menguji", "code": "#include <iostream> NEW_LINE using namespace std ; int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { cout << \" Invalid ▁ Input \" ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { cout << \" Square ▁ root ▁ is ▁ \" << x ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { cout << \" Square ▁ root ▁ is ▁ \" << x ; return ; } cout << \" Square ▁ root ▁ doesn ' t ▁ exist ▁ \" ; } int main ( ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; return 0 ; }"}
{"text": "Ujian Primal | Tetapkan 3 (Millerâ € \"Rabin) | C ++ Program Miller - Rabin Primality Test; Fungsi Utiliti untuk Melakukan Eksponen Modular. Benar jika n adalah perdana. N-1 Komposit;", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } bool miillerTest ( int d , int n ) { int a = 2 + rand ( ) % ( n - 4 ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } bool isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; } int main ( ) { int k = 4 ; cout << \" All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ STRNEWLINE \" ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) cout << n << \" ▁ \" ; return 0 ; }"}
{"text": "Panjang paling lama berturut -turut 1 s dalam perwakilan binari | Program C ++ untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor. ; Berfungsi untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor; Memulakan hasil; Kira bilangan lelaran untuk mencapai x = 0 .; Operasi ini mengurangkan panjang setiap urutan 1 s dengan satu. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } int main ( ) { cout << maxConsecutiveOnes ( 14 ) << endl ; cout << maxConsecutiveOnes ( 222 ) << endl ; return 0 ; }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program C ++ untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } int main ( ) { int x = 29 , y = 13 ; cout << \" x ▁ - ▁ y ▁ is ▁ \" << subtract ( x , y ) ; return 0 ; }"}
{"text": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program CPP untuk menolak dua nombor tanpa menggunakan pelaksanaan rekursif pengendali aritmetik. ; Program Pemandu", "code": "#include <iostream> NEW_LINE using namespace std ; int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } int main ( ) { int x = 29 , y = 13 ; cout << \" x ▁ - ▁ y ▁ is ▁ \" << subtract ( x , y ) ; return 0 ; }"}
{"text": "Kth nenek moyang semua nod dalam n | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk menambah kelebihan di dalam pokok; DFS untuk mencari nenek moyang Kth setiap nod; Menolak nod semasa dalam vektor; Melintasi jirannya; Jika n nenek moyang tidak dijumpai untuk nod semasa; Tambah nenek moyang KTH untuk nod; Berfungsi untuk mencari nenek moyang setiap nod; Membina pokok; Menyimpan semua ibu bapa nod; Simpan nenek moyang semua nod; Cetak nenek moyang; Kod pemacu; Diberikan n dan k; Diberi tepi pokok n - ary; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void addEdge ( vector < int > v [ ] , int x , int y ) { v [ x ] . push_back ( y ) ; v [ y ] . push_back ( x ) ; } void dfs ( vector < int > tree [ ] , vector < int > & temp , int ancestor [ ] , int u , int parent , int k ) { temp . push_back ( u ) ; for ( auto i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . pop_back ( ) ; if ( temp . size ( ) < k ) { ancestor [ u ] = -1 ; } else { ancestor [ u ] = temp [ temp . size ( ) - k ] ; } } void KthAncestor ( int N , int K , int E , int edges [ ] [ 2 ] ) { vector < int > tree [ N + 1 ] ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } vector < int > temp ; int ancestor [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { cout << ancestor [ i ] << \" ▁ \" ; } } int main ( ) { int N = 9 ; int K = 2 ; int E = 8 ; int edges [ 8 ] [ 2 ] = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ; KthAncestor ( N , K , E , edges ) ; return 0 ; }"}
{"text": "Pertanyaan untuk mengira elemen array lebih besar daripada atau sama dengan nombor tertentu dengan kemas kini | Program C ++ untuk pendekatan di atas; Berfungsi untuk membina pokok segmen; Semak kes asas; Cari titik pertengahan; Secara rekursif membina pokok segmen; Fungsi untuk menolak operasi pada pokok segmen; Berfungsi untuk mengemas kini pokok segmen; Tumpang tindih lengkap; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Mengemas kini pokok segmen secara rekursif; Berfungsi untuk memproses pertanyaan; Kes asas; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Secara rekursif mengira hasil pertanyaan; Mengembalikan hasilnya; Fungsi untuk mengira nombor yang lebih besar daripada pertanyaan yang diberikan; Susun array input; Buat pokok segmen saiz 4 * n; Membina pokok segmen; Melangkah ke atas pertanyaan; Kedai hasil dalam pelbagai; Mengemas kini unsur -unsur dalam julat yang diberikan; Cetak hasil pertanyaan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void build ( vector < int > & sum , vector < int > & a , int l , int r , int rt ) { if ( l == r ) { sum [ rt ] = a [ l - 1 ] ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; } void pushDown ( vector < int > & sum , vector < int > & add , int rt , int ln , int rn ) { if ( add [ rt ] ) { add [ rt << 1 ] += add [ rt ] ; add [ rt << 1 1 ] += add [ rt ] ; sum [ rt << 1 ] += add [ rt ] * ln ; sum [ rt << 1 1 ] += add [ rt ] * rn ; add [ rt ] = 0 ; } } void update ( vector < int > & sum , vector < int > & add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum [ rt ] += C * ( r - l + 1 ) ; add [ rt ] += C ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) update ( sum , add , L , R , C , l , m , rt << 1 ) ; if ( R > m ) update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } int query ( vector < int > & sum , vector < int > & add , int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum [ rt ] ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ; if ( L <= m ) ans += query ( sum , add , L , R , l , m , rt << 1 ) ; if ( R > m ) ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; return ans ; } void sequenceMaintenance ( int n , int q , vector < int > & a , vector < int > & b , int m ) { sort ( a . begin ( ) , a . end ( ) ) ; vector < int > sum , add , ans ; sum . assign ( n << 2 , 0 ) ; add . assign ( n << 2 , 0 ) ; build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = -1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( query ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == -1 ) ans . push_back ( 0 ) ; else { ans . push_back ( n - pos + 1 ) ; update ( sum , add , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << \" ▁ \" ; } } int main ( ) { int N = 4 ; int Q = 3 ; int M = 1 ; vector < int > arr = { 1 , 2 , 3 , 4 } ; vector < int > query = { 4 , 3 , 1 } ; sequenceMaintenance ( N , Q , arr , query , M ) ; return 0 ; }"}
{"text": "Kurangkan panjang array dengan berulang kali menggantikan co | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari panjang array akhir dengan menggantikan pasangan coprime dengan 1; Melangkah ke atas semua pasang elemen; Semak jika GCD adalah 1; Sekiranya tiada pasangan Coprime mendapati kembali palsu; Kod pemacu; Semak sama ada satu pasangan coprime wujud dalam array; Sekiranya tidak ada pasangan seperti itu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool hasCoprimePair ( vector < int > & arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( arr [ i ] , arr [ j ] ) == 1 ) { return true ; } } } return false ; } int main ( ) { int n = 3 ; vector < int > arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { cout << 1 << endl ; } else { cout << n << endl ; } }"}
{"text": "Mengira cara untuk berpecah n ke dalam tiga kali ganda membentuk segitiga | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan bilangan cara yang diperlukan; Semak jika A, B dan C boleh membentuk segitiga; Mengembalikan bilangan cara; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } int main ( ) { int n = 15 ; cout << Numberofways ( n ) << endl ; return 0 ; }"}
{"text": "Kira pasangan yang mempunyai setiap elemen yang sama dengan indeks yang lain dari array | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak kiraan pasangan; Melangkah ke atas semua elemen array; Kenaikan kiraan; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } cout << ( count / 2 ) << endl ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( N , arr ) ; }"}
{"text": "Cari panjang fibonacci terpanjang seperti berikutnya | Pelaksanaan CPP pendekatan di atas; Berfungsi untuk mengembalikan panjang maksimum fibonacci seterusnya; Simpan semua elemen array dalam jadual hash; Semak sehingga elemen FIB seterusnya dijumpai; Elemen seterusnya FIB Subseq; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestFibSubseq ( int A [ ] , int n ) { unordered_set < int > S ( A , A + n ) ; int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 2 ; while ( S . find ( y ) != S . end ( ) ) { int z = x + y ; x = y ; y = z ; maxLen = max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << LongestFibSubseq ( A , n ) ; return 0 ; }"}
{"text": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Sorakkan dia array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }"}
{"text": "Jenis maksimum gula -gula seseorang boleh makan jika hanya n / 2 daripadanya boleh dimakan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan jenis gula -gula; Mengisytiharkan hashset untuk menyimpan gula -gula; Melintasi array yang diberikan dan memasukkan elemen ke dalam set; Mengembalikan hasilnya; Berfungsi untuk mencari bilangan maksimum jenis gula -gula yang boleh dimakan seseorang; Simpan bilangan gula -gula yang dibenarkan makan; Simpan bilangan jenis gula -gula; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int num_candyTypes ( vector < int > & candies ) { unordered_set < int > s ; for ( int i = 0 ; i < candies . size ( ) ; i ++ ) { s . insert ( candies [ i ] ) ; } return s . size ( ) ; } void distribute_candies ( vector < int > & candies ) { int allowed = candies . size ( ) / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) cout << types ; else cout << allowed ; } int main ( ) { vector < int > candies = { 4 , 4 , 5 , 5 , 3 , 3 } ; distribute_candies ( candies ) ; return 0 ; }"}
{"text": "Panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double Length_Diagonals ( int a , double theta ) { double p = a * sqrt ( 2 + ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; double q = a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; cout << fixed << setprecision ( 2 ) << p << \" ▁ \" << q ; } int main ( ) { int a = 6 ; int theta = 45 ; Length_Diagonals ( a , theta ) ; return 0 ; }"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Program C ++ untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << \" Even ▁ = ▁ \" << odd << \" , ▁ Odd ▁ = ▁ \" << even ; } else { cout << \" Even ▁ = ▁ \" << even << \" , ▁ Odd ▁ = ▁ \" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }"}
{"text": "Bilangan cara untuk memilih pasangan yang mengandungi nombor yang lebih dan ganjil dari 1 hingga n | C ++ pelaksanaan pendekatan di atas; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; cout << Even * Odd ; return 0 ; }"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Program C ++ untuk pendekatan di atas; Fungsi rekursif untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; Kes asas; Tidak termasuk pasangan semasa dalam masa yang paling lama; Termasuk pasangan semasa dalam masa yang paling lama; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubSequence ( pair < int , int > A [ ] , int N , int ind = 0 , int lastf = INT_MIN , int lasts = INT_MAX ) { if ( ind == N ) return 0 ; int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ; if ( A [ ind ] . first > lastf && A [ ind ] . second < lasts ) ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] . first , A [ ind ] . second ) + 1 ) ; return ans ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << longestSubSequence ( A , N ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk nilai i. 3 nilai tambahan adalah untuk menjaga kes sudut n = 0; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { int noOfWays [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 0 ; cout << CountWays ( n ) ; return 0 ; }"}
{"text": "Program untuk mencetak corak lingkaran |  ; Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "#include <iostream> NEW_LINE using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << \" ▁ \" ; else cout << n << \" ▁ \" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }"}
{"text": "Cari pemain terakhir untuk dapat membalikkan watak dalam rentetan binari | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada pemain A memenangi permainan atau tidak; Kedai saiz kumpulan 0 s; Kedai saiz kumpulan 0 s; Melintasi array; Kenaikan c oleh 1 jika a [i] adalah 0; Jika tidak, tolak saiz dalam array dan tetapkan semula C ke 0; Sekiranya tidak ada substring panjang ganjil yang terdiri daripada 0 s; Sekiranya terdapat hanya 1 substring panjang ganjil yang terdiri hanya 0 s; Jika tidak; Menyimpan saiz substring terbesar dan kedua terbesar 0 s; Melintasi array v []; Jika elemen semasa lebih besar daripada yang pertama, maka kemas kini kedua -dua dan kedua; Jika arr [i] berada di antara pertama dan kedua, maka kemas kini kedua; Sekiranya keadaan itu berpuas hati; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( string a , int n ) { vector < int > v ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) { c ++ ; } else { if ( c != 0 ) v . push_back ( c ) ; c = 0 ; } } if ( c != 0 ) v . push_back ( c ) ; if ( v . size ( ) == 0 ) { cout << \" Player ▁ B \" ; return ; } if ( v . size ( ) == 1 ) { if ( v [ 0 ] & 1 ) cout << \" Player ▁ A \" ; else cout << \" Player ▁ B \" ; return ; } int first = INT_MIN ; int second = INT_MIN ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) && ( first + 1 ) / 2 > second ) cout << \" Player ▁ A \" ; else cout << \" Player ▁ B \" ; } int main ( ) { string S = \"1100011\" ; int N = S . length ( ) ; findWinner ( S , N ) ; return 0 ; }"}
{"text": "Periksa sama ada rentetan kalindromik boleh dibentuk dari rentetan yang diberikan | Program C ++ untuk memeriksa sama ada rentetan adalah K palindrome atau tidak; berfungsi untuk memeriksa sama ada rentetan adalah k palindrome atau tidak; peta kepada kekerapan watak; Semak apabila k diberikan sama seperti panjang rentetan; Iterator untuk peta; menyimpan kekerapan setiap watak dalam peta; jika k lebih besar daripada saiz rentetan maka kembali palsu; Semak bilangan watak yang mempunyai kekerapan ganjil; Jika k kurang daripada bilangan watak frekuensi ganjil maka ia sekali lagi palsu yang lain bijak; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <map> NEW_LINE using namespace std ; bool can_Construct ( string S , int K ) { map < int , int > m ; int i = 0 , j = 0 , p = 0 ; if ( S . length ( ) == K ) { return true ; } map < int , int > :: iterator h ; for ( i = 0 ; i < S . length ( ) ; i ++ ) { m [ S [ i ] ] = m [ S [ i ] ] + 1 ; } if ( K > S . length ( ) ) { return false ; } else { for ( h = m . begin ( ) ; h != m . end ( ) ; h ++ ) { if ( m [ h -> first ] % 2 != 0 ) { p = p + 1 ; } } } if ( K < p ) { return false ; } return true ; } int main ( ) { string S = \" annabelle \" ; int K = 4 ; if ( can_Construct ( S , K ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka |  ; Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi transform () dan :: Tolower di STL; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; transform ( str1 . begin ( ) , str1 . end ( ) , str1 . begin ( ) , :: tolower ) ; transform ( str2 . begin ( ) , str2 . end ( ) , str2 . begin ( ) , :: tolower ) ; int x = str1 . compare ( str2 ) ; if ( x != 0 ) return false ; else return true ; } void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << \" Same \" << endl ; else cout << \" Not ▁ Same \" << endl ; } int main ( ) { string str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; return 0 ; }"}
{"text": "Program untuk mencetak corak langkah | Program C ++ untuk mencetak corak langkah; berfungsi untuk mencetak langkah -langkah; mengisytiharkan bendera; melintasi semua watak dalam rentetan; Jika nilai x ialah 0 .. Kemudian kita mesti kenaikan sehingga n ... Tetapkan bendera kepada Benar; Jika nilai x adalah n - 1 maka kita mesti menurunkan sehingga 0 ... Tetapkan bendera sebagai palsu; cetak x * s; memeriksa sama ada untuk kenaikan atau penurunan x; Kod pemacu; Dapatkan rentetan dan nombor n; memanggil fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; void steps ( string str , int n ) { bool flag ; int x = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( x == 0 ) flag = true ; if ( x == n - 1 ) flag = false ; for ( int j = 0 ; j < x ; j ++ ) cout << \" * \" ; cout << str [ i ] << \" STRNEWLINE \" ; if ( flag == true ) x ++ ; else x -- ; } } int main ( ) { int n = 4 ; string str = \" GeeksForGeeks \" ; cout << \" String : ▁ \" << str << endl ; cout << \" Max ▁ Length ▁ of ▁ Steps : ▁ \" << n << endl ; steps ( str , n ) ; return 0 ; }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program C ++ untuk mengira frekuensi item array; Tandakan semua elemen array seperti yang tidak dikunjungi; Melintasi unsur -unsur array dan kekerapan kiraan; Langkau elemen ini jika sudah diproses; Kekerapan kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countFreq ( int arr [ ] , int n ) { vector < int > visited ( n , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } cout << arr [ i ] << \" ▁ \" << count << endl ; } } int main ( ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countFreq ( arr , n ) ; return 0 ; }"}
{"text": "Semak pembahagian rentetan binari dengan 2 ^ k | C ++ pelaksanaan untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; fungsi untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; kiraan bilangan 0 dari yang terakhir; Jika Count = k, nombor sama rata, jadi pulangan benar lain palsu; Program pemandu untuk menguji di atas; Contoh pertama; Contoh kedua", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; } int main ( ) { char str1 [ ] = \"10101100\" ; int k = 2 ; if ( isDivisible ( str1 , k ) ) cout << \" Yes \" << endl ; else cout << \" No \" << \" STRNEWLINE \" ; char str2 [ ] = \"111010100\" ; k = 2 ; if ( isDivisible ( str2 , k ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }"}
{"text": "Semak jika ada anagram rentetan adalah palindrome atau tidak |  ; berfungsi untuk memeriksa sama ada watak rentetan boleh membentuk palindrome; Buat array kiraan dan mulakan semua nilai sebagai 0; Bagi setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan; Mengira watak -watak yang ganjil; Kembali benar jika kiraan ganjil adalah 0 atau 1 ,; Program pemacu untuk diuji untuk mencetak cetakan", "code": "#include <iostream> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } int main ( ) { canFormPalindrome ( \" geeksforgeeks \" ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; canFormPalindrome ( \" geeksogeeks \" ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada input adalah integer atau rentetan | Program CPP untuk memeriksa sama ada rentetan yang diberikan adalah integer yang sah; Pulangan benar jika s adalah nombor lain palsu; Kod pemacu; Menyimpan input dalam rentetan; Fungsi pulangan 1 jika semua elemen berada dalam jarak '0-9'; Fungsi pulangan 0 jika input bukan integer", "code": "#include <iostream> NEW_LINE using namespace std ; bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; } int main ( ) { string str = \"6790\" ; if ( isNumber ( str ) ) cout << \" Integer \" ; else cout << \" String \" ; }"}
{"text": "Cetak terbalik rentetan menggunakan rekursi | Program C ++ untuk membalikkan rentetan menggunakan rekursi; Berfungsi untuk mencetak terbalik rentetan lulus; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverse ( string str ) { if ( str . size ( ) == 0 ) { return ; } reverse ( str . substr ( 1 ) ) ; cout << str [ 0 ] ; } int main ( ) { string a = \" Geeks ▁ for ▁ Geeks \" ; reverse ( a ) ; return 0 ; }"}
{"text": "Kebarangkalian mengedarkan bola yang diberikan kepada dua bahagian yang mempunyai kiraan yang sama dengan warna yang berbeza | Program C ++ untuk pendekatan di atas; Menyimpan kiraan warna yang berbeza dalam Box1; Menyimpan kiraan warna yang berbeza dalam Box2; Fungsi untuk mengira kebarangkalian yang diperlukan; Hitung faktorial dari [1, 10]; Berikan semua bola yang berbeza ke kotak kedua; Jumlah bola; Hitung jumlah bola; Jika k adalah nombor ganjil; Jumlah cara mengedarkan bola dalam dua bahagian yang sama; Bilangan cara yang diperlukan; Mengembalikan kebarangkalian yang diperlukan; Fungsi untuk mengira jumlah bilangan pengagihan yang mungkin memenuhi syarat yang diberikan; Jika bola yang digunakan adalah sama dengan k / 2; Jika Box1 sama dengan Box2; Keadaan asas; Menyimpan bilangan cara mengedarkan bola yang tinggal tanpa termasuk bola semasa dalam Box1; Kotak kenaikan1 dengan satu; Melangkah ke atas julat [1, bola [i]]; Jika semua bola pergi ke Box1, kemudian menurunkan Box2 dengan satu; Jumlah cara memilih bola J; Kenaikan res dengan jumlah cara yang sah untuk mengedarkan bola yang tinggal; Box1 box1 oleh satu; Box2 Box2 oleh 1; Fungsi untuk mengira faktorial n; Kes asas; Melangkah ke atas julat [1, n]; Fungsi untuk mengira NCR; Kod pemacu; Cetak hasilnya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; static int box1 = 0 ; static int box2 = 0 ; static int fact [ 11 ] ; double getProbability ( int balls [ ] , int M ) { factorial ( 10 ) ; box2 = M ; int K = 0 ; for ( int i = 0 ; i < M ; i ++ ) K += balls [ i ] ; if ( K % 2 == 1 ) return 0 ; long all = comb ( K , K / 2 ) ; long validPermutation = validPermutations ( K / 2 , balls , 0 , 0 , M ) ; return ( double ) validPermutation / all ; } long validPermutations ( int n , int balls [ ] , int usedBalls , int i , int M ) { if ( usedBalls == n ) { return box1 == box2 ? 1 : 0 ; } if ( i >= M ) return 0 ; long res = validPermutations ( n , balls , usedBalls , i + 1 , M ) ; box1 ++ ; for ( int j = 1 ; j <= balls [ i ] ; j ++ ) { if ( j == balls [ i ] ) box2 -- ; long combinations = comb ( balls [ i ] , j ) ; res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 , M ) ; } box1 -- ; box2 ++ ; return res ; } void factorial ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; } long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 } ; int N = 4 ; int M = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( getProbability ( arr , M ) ) ; return 0 ; }"}
{"text": "Kawasan n | Program C ++ untuk mencari kawasan poligon biasa dengan radius yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Sampingan dan jejari tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyarea ( float n , float r ) { if ( r < 0 && n < 0 ) return -1 ; float A = ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } int main ( ) { float r = 9 , n = 6 ; cout << polyarea ( n , r ) << endl ; return 0 ; }"}
{"text": "Semak jika garis pada 45 darjah boleh membahagikan pesawat ke dalam dua bahagian berat yang sama |  ; Memeriksa jika satah boleh dibahagikan dengan garis pada 45 darjah supaya jumlah berat adalah sama; Putar setiap titik sebanyak 45 darjah dan mengira jumlah awalan. Juga, mencari koordinat X maksimum dan minimum; menyimpan jumlah berat sehingga titik x - y; Mencari Jumlah awalan; Line melewati saya, jadi ia tidak jatuh ke kiri atau kanan. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { map < int , int > weight_at_x ; int max_x = -2e3 , min_x = 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = max ( max_x , new_x ) ; min_x = min ( min_x , new_x ) ; weight_at_x [ new_x ] += w [ i ] ; } vector < int > sum_till ; sum_till . push_back ( 0 ) ; for ( int x = min_x ; x <= max_x ; x ++ ) { sum_till . push_back ( sum_till . back ( ) + weight_at_x [ x ] ) ; } int total_sum = sum_till . back ( ) ; int partition_possible = false ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = true ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = true ; } printf ( partition_possible ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ) ; } int main ( ) { int n = 3 ; int x [ ] = { -1 , -2 , 1 } ; int y [ ] = { 1 , 1 , -1 } ; int w [ ] = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; return 0 ; }"}
{"text": "Cerun tegak lurus ke garisan | Program C ++ Cari cerun garis tegak lurus; Berfungsi untuk mencari cerun garis lain; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double findPCSlope ( double m ) { return -1.0 / m ; } int main ( ) { double m = 2.0 ; cout << findPCSlope ( m ) ; return 0 ; }"}
{"text": "Program untuk mencari kawasan segmen bulat | Program C ++ untuk mencari kawasan segmen bulatan; Fungsi untuk mencari kawasan segmen; Mengira kawasan sektor; Mengira kawasan segitiga; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float pi = 3.14159 ; float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; } int main ( ) { float radius = 10.0 , angle = 90.0 ; cout << \" Area ▁ of ▁ minor ▁ segment ▁ = ▁ \" << area_of_segment ( radius , angle ) << endl ; cout << \" Area ▁ of ▁ major ▁ segment ▁ = ▁ \" << area_of_segment ( radius , ( 360 - angle ) ) ; }"}
{"text": "Kawasan Sektor Pekeliling | Program C ++ untuk mencari kawasan sektor; Mengira kawasan sektor; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << \" Angle ▁ not ▁ possible \" ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } } int main ( ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; return 0 ; }"}
{"text": "Buat dua nombor sama dengan mendarab dengan faktor utama mereka bilangan minimum kali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah faktor utama dengan faktor utama mereka; Melangkah sementara nombornya juga; Mengurangkan separuh; Berulang sehingga sqrt (n); Melangkah sementara n mempunyai faktor i; Mengeluarkan satu faktor i; Berfungsi untuk mengira bilangan faktor; Cari GCD; Cari gandaan yang tersisa di x dan y; Cari faktor utama pelbagai kiri dalam x dan y; Memulakan ans; Semak sama ada mungkin untuk mendapatkan x atau tidak; Periksa sama ada mungkin untuk mendapatkan y atau tidak; kembali utama ans; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_map < int , int > PrimeFactor ( int N ) { unordered_map < int , int > primef ; while ( N % 2 == 0 ) { if ( primef . count ( 2 ) ) { primef [ 2 ] += 1 ; } else { primef [ 2 ] = 1 ; } N /= 2 ; } for ( int i = 3 ; i <= sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . count ( i ) ) { primef [ i ] += 1 ; } else { primef [ i ] = 1 ; } N /= 2 ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; } int CountToMakeEqual ( int X , int Y ) { int gcdofXY = __gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; unordered_map < int , int > primeX ; unordered_map < int , int > primeY ; primeX = PrimeFactor ( newX ) ; primeY = PrimeFactor ( newY ) ; int ans = 0 ; for ( auto c : primeX ) { if ( X % c . first != 0 ) { return -1 ; } ans += primeX [ c . first ] ; } for ( auto c : primeY ) { if ( Y % c . first != 0 ) { return -1 ; } ans += primeY [ c . first ] ; } return ans ; } int main ( ) { int X = 36 ; int Y = 48 ; int ans = CountToMakeEqual ( X , Y ) ; cout << ans << endl ; return 0 ; }"}
{"text": "Buat segmen yang diberikan bukan | Program C ++ untuk pendekatan di atas; Menyimpan butiran segmen; Berfungsi untuk memeriksa sama ada graf adalah bipartite atau tidak; Tanda nod sumber seperti yang dikunjungi; Tolak puncak sumber dalam barisan; Dapatkan bahagian depan barisan; Berikan warna kepada nod yang muncul; Melintasi senarai addacency nod u; Jika mana -mana nod dikunjungi & warna yang berbeza telah diberikan, maka kembali palsu; Tetapkan dikunjungi [x]; Tolak nod X ke dalam barisan; Kemas kini warna nod; Jika graf adalah bipartite; Berfungsi untuk menambah kelebihan antara nod U dan V; Berfungsi untuk memeriksa sama ada tugasan arah boleh dilakukan untuk semua segmen, supaya mereka tidak bersilang selepas jangka masa yang panjang; Menyimpan senarai adjacency graf yang dicipta; Menjana semua pasangan yang mungkin; Jika segmen tidak bertindih; Jika tidak, segmen bertindih; Jika kedua -dua segmen mempunyai kelajuan yang sama, maka tambahkan kelebihan; Pastikan jejak nod yang dikunjungi; Berulang untuk semua nod yang mungkin; Semak sama ada graf adalah bipartite atau tidak; Jika graf adalah bipartite; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int L , R , V ; } ; bool check ( vector < int > Adj [ ] , int Src , int N , bool visited [ ] ) { int color [ N ] = { 0 } ; visited [ Src ] = true ; queue < int > q ; q . push ( Src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; int Col = color [ u ] ; for ( int x : Adj [ u ] ) { if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) { visited [ x ] = true ; q . push ( x ) ; color [ x ] = 1 - Col ; } } } return true ; } void addEdge ( vector < int > Adj [ ] , int u , int v ) { Adj [ u ] . push_back ( v ) ; Adj [ v ] . push_back ( u ) ; } void isPossible ( struct Node Arr [ ] , int N ) { vector < int > Adj [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } bool visited [ N ] = { false } ; for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . size ( ) > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { cout << \" No \" ; return ; } } } cout << \" Yes \" ; } int main ( ) { struct Node arr [ ] = { { 5 , 7 , 2 } , { 4 , 6 , 1 } , { 1 , 5 , 2 } , { 6 , 5 , 1 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isPossible ( arr , N ) ; return 0 ; }"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program C ++ untuk pendekatan di atas; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int temp , int n , vector < int > & sol ) ; void lexNumbers ( int n ) { vector < int > sol ; dfs ( 1 , n , sol ) ; cout << \" [ \" << sol [ 0 ] ; for ( int i = 1 ; i < sol . size ( ) ; i ++ ) cout << \" , ▁ \" << sol [ i ] ; cout << \" ] \" ; } void dfs ( int temp , int n , vector < int > & sol ) { if ( temp > n ) return ; sol . push_back ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; } int main ( ) { int n = 15 ; lexNumbers ( n ) ; return 0 ; }"}
{"text": "Bilangan swap minimum yang diperlukan untuk menyusun pelbagai nombor N pertama | Berfungsi untuk mencari swap minimum; Pembolehubah kiraan permulaan; Jika elemen semasa tidak berada di kedudukan yang betul; Swap elemen semasa dengan kedudukan yang betul dari elemen itu; Kenaikan untuk indeks seterusnya apabila elemen semasa berada pada kedudukan yang betul; Kod pemacu; Berfungsi untuk mencari swap minimum", "code": "#include <iostream> NEW_LINE using namespace std ; int minimumSwaps ( int arr [ ] , int n ) { int count = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumSwaps ( arr , n ) ; }"}
{"text": "Gabungkan K -Sorted Doubly Linked List dalam Order Sorted | Program C ++ untuk menggabungkan senarai yang disusun dua kali ganda dalam urutan yang disusun; Nod senarai yang dipautkan; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala DLL dan int, tambah nod baru pada akhir; Memperuntukkan nod; Masukkan data; Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai batal; Jika senarai yang dipautkan kosong, maka buat nod baru sebagai kepala; Lain melintasi sehingga nod terakhir; Tukar nod terakhir yang akan datang; Buat nod terakhir seperti sebelumnya dari nod baru; Berfungsi untuk mencetak senarai; Jalankan semasa gelung melainkan nod menjadi batal; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika mana -mana senarai kosong; Perbandingan data dua senarai yang dipautkan; Simpan penunjuk kepala sebelum menggabungkan senarai; Menukar penunjuk antara dua senarai untuk penggabungan; Menukar penunjuk antara dua senarai untuk penggabungan; Syarat untuk memeriksa sama ada sesiapa yang menyenaraikan tidak berakhir; Kembali penunjuk kepala senarai yang digabungkan; Berfungsi untuk menggabungkan semua senarai yang disusun dalam susunan yang disusun; Panggilan fungsi untuk menggabungkan dua senarai dikaitkan berganda yang disusun pada satu masa; Kembali akhir disusun senarai dua kali ganda; Kod pemacu; Gelung untuk memulakan semua senarai untuk kosong; Buat senarai dikaitkan pertama List1 -> 1 <=> 5 <=> 9; Buat senarai dua kali ganda dikaitkan list2 -> 2 <=> 3 <=> 7 <=> 12; Buat senarai dikaitkan dua kali ganda senarai3 -> 8 <=> 11 <=> 13 <=> 18; Panggilan fungsi untuk menggabungkan semua senarai dikaitkan dua kali ganda dalam urutan yang disusun; Cetak senarai disusun akhir", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; Node * prev ; } ; void append ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * last = * head_ref ; new_node -> data = new_data ; new_node -> next = NULL ; if ( * head_ref == NULL ) { new_node -> prev = NULL ; * head_ref = new_node ; return ; } while ( last -> next != NULL ) last = last -> next ; last -> next = new_node ; new_node -> prev = last ; return ; } void printList ( Node * node ) { Node * last ; while ( node != NULL ) { cout << node -> data << \" ▁ \" ; last = node ; node = node -> next ; } } Node * mergeList ( Node * p , Node * q ) { Node * s = NULL ; if ( p == NULL q == NULL ) { return ( p == NULL ? q : p ) ; } if ( p -> data < q -> data ) { p -> prev = s ; s = p ; p = p -> next ; } else { q -> prev = s ; s = q ; q = q -> next ; } Node * head = s ; while ( p != NULL && q != NULL ) { if ( p -> data < q -> data ) { s -> next = p ; p -> prev = s ; s = s -> next ; p = p -> next ; } else { s -> next = q ; q -> prev = s ; s = s -> next ; q = q -> next ; } } if ( p == NULL ) { s -> next = q ; q -> prev = s ; } if ( q == NULL ) { s -> next = p ; p -> prev = s ; } return head ; } Node * mergeAllList ( Node * head [ ] , int k ) { Node * finalList = NULL ; for ( int i = 0 ; i < k ; i ++ ) { finalList = mergeList ( finalList , head [ i ] ) ; } return finalList ; } int main ( ) { int k = 3 ; Node * head [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { head [ i ] = NULL ; } append ( & head [ 0 ] , 1 ) ; append ( & head [ 0 ] , 5 ) ; append ( & head [ 0 ] , 9 ) ; append ( & head [ 1 ] , 2 ) ; append ( & head [ 1 ] , 3 ) ; append ( & head [ 1 ] , 7 ) ; append ( & head [ 1 ] , 12 ) ; append ( & head [ 2 ] , 8 ) ; append ( & head [ 2 ] , 11 ) ; append ( & head [ 2 ] , 13 ) ; append ( & head [ 2 ] , 18 ) ; Node * finalList = mergeAllList ( head , k ) ; printList ( finalList ) ; return 0 ; }"}
{"text": "Susun Pemilihan Rekursif | Program C ++ rekursif untuk menyusun pelbagai menggunakan pilihan pemilihan; Indeks minimum pulangan; Cari minimum elemen yang tinggal; Pulangan minimum semasa dan baki. ; Jenis pemilihan rekursif. N ialah saiz [] dan indeks adalah indeks elemen permulaan. ; Kembali apabila bermula dan saiznya sama; Memanggil fungsi indeks minimum untuk indeks minimum; Bertukar apabila indeks indeks minimum tidak sama; swap; Fungsi pemilihan pilihan rekursif; Kod pemacu; Fungsi panggilan; Percetakan Arahan yang disusun", "code": "#include <iostream> NEW_LINE using namespace std ; int minIndex ( int a [ ] , int i , int j ) { if ( i == j ) return i ; int k = minIndex ( a , i + 1 , j ) ; return ( a [ i ] < a [ k ] ) ? i : k ; } void recurSelectionSort ( int a [ ] , int n , int index = 0 ) { if ( index == n ) return ; int k = minIndex ( a , index , n - 1 ) ; if ( k != index ) swap ( a [ k ] , a [ index ] ) ; recurSelectionSort ( a , n , index + 1 ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 5 , 2 , 7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; recurSelectionSort ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << endl ; return 0 ; }"}
{"text": "SENARAI SENSI RECURSIVE | Program C ++ rekursif untuk jenis penyisipan; Fungsi rekursif untuk menyusun array menggunakan jenis penyisipan; Kes asas; Susun pertama n - 1 elemen; Masukkan elemen terakhir pada kedudukan yang betul dalam array yang disusun. ; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Program pemacu untuk menguji jenis penyisipan", "code": "#include <iostream> NEW_LINE using namespace std ; void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSortRecursive ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Susun gelembung rekursif | C / C ++ Program untuk pelaksanaan rekursif jenis gelembung; Fungsi untuk melaksanakan jenis gelembung; Kes asas; Satu lulus jenis gelembung. Selepas lulus ini, elemen terbesar dipindahkan (atau bubbled) untuk berakhir. ; swap arr [i], arr [i + 1]; Unsur terbesar ditetapkan, berulang untuk array yang tinggal; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void bubbleSort ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) swap ( arr [ i ] , arr [ i + 1 ] ) ; bubbleSort ( arr , n - 1 ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bubbleSort ( arr , n ) ; printf ( \" Sorted ▁ array ▁ : ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Perbezaan maksimum jumlah dua subset dari array | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Menyimpan unsur -unsur positif; Menyimpan unsur -unsur negatif; Menyimpan kiraan 0 s; Jumlah semua nombor positif; Jumlah semua nombor negatif; Melangkah ke atas array; Menyimpan perbezaan; Menyusun nombor positif dalam urutan menaik; Menyusun nombor negatif dalam penurunan urutan; Kes 1: Sertakan nombor positif dan negatif; Letakkan semua nombor dalam subset a dan satu 0 dalam subset b; Letakkan semua nombor dalam subset A kecuali nombor positif terkecil yang dimasukkan ke dalam B; Letakkan semua nombor dalam subset b dan satu 0 dalam subset A; Letakkan nombor negatif terbesar dalam subset A dan baki dalam B; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumAfterPartition ( int arr [ ] , int n ) { vector < int > pos ; vector < int > neg ; int zero = 0 ; int pos_sum = 0 ; int neg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . push_back ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . push_back ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } int ans = 0 ; sort ( pos . begin ( ) , pos . end ( ) ) ; sort ( neg . begin ( ) , neg . end ( ) , greater < int > ( ) ) ; if ( pos . size ( ) > 0 && neg . size ( ) > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . size ( ) > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos [ 0 ] ) ; } } else { if ( zero > 0 ) { ans = ( -1 * neg_sum ) ; } else { ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , -5 , -7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSumAfterPartition ( arr , n ) ; return 0 ; }"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari elemen bitwise atau array; Menyimpan nilai maksimum yang dihasilkan dari bitwise XOR; Melintasi array arr []; Mengembalikan nilai maksimum RES; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaxXOR ( arr , N ) ; return 0 ; }"}
{"text": "Kira bilangan unsur biasa antara array yang disusun dan array yang disusun terbalik | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira bilangan elemen yang biasa dalam kedua -dua tatasusunan; Digunakan untuk melintasi array A [] dan B [] dari depan dan belakang; Menyimpan kiraan nombor yang biasa dalam kedua -dua array; Jika A [pertama] kurang daripada b [kedua]; Meningkatkan nilai pertama; Jika B [kedua] kurang daripada [pertama]; Menurunkan nilai kedua; A [pertama] adalah sama dengan b [kedua]; Meningkatkan nilai kiraan; Meningkatkan nilai pertama; Menurunkan nilai kedua; Mengembalikan nilai kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEqual ( int A [ ] , int B [ ] , int N ) { int first = 0 ; int second = N - 1 ; int count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; } int main ( ) { int A [ ] = { 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 } ; int B [ ] = { 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 } ; int N = sizeof ( A ) / sizeof ( int ) ; cout << countEqual ( A , B , N ) ; return 0 ; }"}
{"text": "Pertanyaan untuk mengira nombor palindrome dari julat yang jumlah digitnya adalah nombor utama | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor n adalah palindrome atau tidak; Simpan nilai n; Simpan sebaliknya nombor n; Tempatan terbalik dan simpan di res; Jika n adalah sama dengan res, maka kembali benar; Berfungsi untuk mencari jumlah digit nombor n; Menyimpan jumlah digit; Tambah digit terakhir nombor N ke jumlah; Keluarkan digit terakhir dari N; Mengembalikan jumlah yang dihasilkan; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Jika saya adalah 1 atau 0, maka kembali palsu; Semak jika saya boleh dibahagikan dengan mana -mana nombor dalam julat [2, n / 2]; Jika n boleh dibahagikan dengan i; Berfungsi untuk mendahului semua nombor sehingga 10 ^ 5 yang palindromik dan jumlah digitnya adalah nombor utama; Melangkah ke atas julat 1 hingga 10 ^ 5; Jika saya adalah nombor palindrome; Menyimpan jumlah digit dalam i; Jika jumlah digit dalam saya adalah nombor utama; Cari jumlah awalan arr []; Fungsi untuk mengira semua nombor dalam julat yang diberikan adalah palindromik dan jumlah digit adalah nombor utama; Fungsi panggilan untuk precompute semua nombor hingga 10 ^ 5; Melintasi pertanyaan yang diberikan Q []; Cetak hasil untuk setiap pertanyaan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ 100005 ] ; bool isPalindrome ( int N ) { int temp = N ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == N ) { return true ; } else { return false ; } } int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; } bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i <= n / 2 ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; } void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { int sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } } void countNumbers ( int Q [ ] [ 2 ] , int N ) { precompute ( ) ; for ( int i = 0 ; i < N ; i ++ ) { cout << ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) ; cout << endl ; } } int main ( ) { int Q [ ] [ 2 ] = { { 5 , 9 } , { 1 , 101 } } ; int N = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; countNumbers ( Q , N ) ; }"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan N yang mempunyai jumlah digit tidak melebihi s | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah digit n; Berfungsi untuk mencari integer yang paling kecil yang memenuhi syarat yang diberikan; Jika jumlah digit sudah lebih kecil daripada S; Memulakan pembolehubah; Mencari digit kth terakhir; Tambah baki untuk membuat digit 0; Jika jumlah digit tidak melebihi s; Kemas kini k; Kod pemacu; Diberikan n dan s; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } int smallestNumber ( int n , int s ) { if ( sum ( n ) <= s ) { return n ; } int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) { int digit = ( ans / k ) % 10 ; int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; } int main ( ) { int N = 3 , S = 2 ; cout << smallestNumber ( N , S ) << endl ; return 0 ; }"}
{"text": "Memaksimumkan kiraan penurunan seterusnya berturut -turut dari array | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum bilangan berikutnya yang diperlukan; HashMap untuk menyimpan bilangan anak panah yang tersedia dengan ketinggian anak panah sebagai kunci; Menyimpan kiraan maksimum kemungkinan berikutnya; Menyimpan kiraan kemungkinan seterusnya; Semak jika elemen saya boleh menjadi sebahagian daripada mana -mana berikutnya; Kiraan seterusnya mungkin dengan arr [i] sebagai elemen seterusnya; Jika lebih daripada satu berikutnya wujud; Termasuk arr [i] dalam berikutnya; Jika tidak; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Mulakan berikutnya baru; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Kembalikan jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubsequences ( int arr [ ] , int n ) { unordered_map < int , int > m ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . find ( arr [ i ] ) != m . end ( ) ) { count = m [ arr [ i ] ] ; if ( count > 1 ) { m [ arr [ i ] ] = count - 1 ; } else m . erase ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } } return maxCount ; } int main ( ) { int n = 5 ; int arr [ ] = { 4 , 5 , 2 , 1 , 4 } ; cout << maxSubsequences ( arr , n ) << endl ; }"}
{"text": "Keluarkan kejadian pertama dan terakhir yang diberikan dari rentetan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menghapuskan kejadian pertama dan terakhir dari watak yang diberikan dari rentetan yang diberikan; Melintasi rentetan yang diberikan dari awal; Jika ch dijumpai; Melintasi rentetan yang diberikan dari hujungnya; Jika ch dijumpai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOcc ( string & s , char ch ) { for ( int i = 0 ; s [ i ] ; i ++ ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } for ( int i = s . length ( ) - 1 ; i > -1 ; i -- ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } return s ; } int main ( ) { string s = \" hello ▁ world \" ; char ch = ' l ' ; cout << removeOcc ( s , ch ) ; return 0 ; }"}
{"text": "Langkah -langkah minimum untuk meningkatkan dan mengurangkan array untuk mencapai 0 atau n | Program C ++ untuk pendekatan di atas; Fungsi yang mendapati langkah -langkah minimum untuk mencapai 0 atau n untuk peningkatan array yang semakin meningkat dan menurun; Memulakan pemboleh ubah untuk mencari elemen minimum; Cari elemen minimum dalam peningkatan [] array; Memulakan pembolehubah untuk mencari elemen maksimum; Cari elemen maksimum dalam penurunan [] array; Cari langkah minimum; Cetak langkah minimum; Kod pemacu; Diberikan n; Memandangkan peningkatan dan penurunan array; Cari panjang tatasusunan yang semakin meningkat dan berkurangan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSteps ( int N , int increasing [ ] , int decreasing [ ] , int m1 , int m2 ) { int mini = INT_MAX ; for ( int i = 0 ; i < m1 ; i ++ ) { if ( mini > increasing [ i ] ) mini = increasing [ i ] ; } int maxi = INT_MIN ; for ( int i = 0 ; i < m2 ; i ++ ) { if ( maxi < decreasing [ i ] ) maxi = decreasing [ i ] ; } int minSteps = max ( maxi , N - mini ) ; cout << minSteps << endl ; } int main ( ) { int N = 7 ; int increasing [ ] = { 3 , 5 } ; int decreasing [ ] = { 6 } ; int m1 = sizeof ( increasing ) / sizeof ( increasing [ 0 ] ) ; int m2 = sizeof ( decreasing ) / sizeof ( decreasing [ 0 ] ) ; minSteps ( N , increasing , decreasing , m1 , m2 ) ; }"}
{"text": "Bilangan minimum swap bersebelahan yang diperlukan untuk menukar permutasi kepada permutasi lain dengan keadaan yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan swap minimum; Array baru untuk menukar kepada pengindeksan berasaskan 1; Menyimpan swap; Semak sama ada kedudukan 'X'; Kes sudut; Swap; Cetak swap minimum; Kod pemacu; Diberi nombor n; Diberi permutasi nombor N; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( vector < int > & P , int n ) { vector < int > arr ; arr . push_back ( 0 ) ; for ( auto x : P ) arr . push_back ( x ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; cnt ++ ; } } if ( arr [ n ] == n ) { swap ( arr [ n - 1 ] , arr [ n ] ) ; cnt ++ ; } cout << cnt << endl ; } signed main ( ) { int N = 9 ; vector < int > P = { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ; solve ( P , N ) ; return 0 ; }"}
{"text": "Count of Prima yang menarik sehingga n | Program C ++ untuk mencari bilangan prima yang menarik sehingga n. ; Berfungsi untuk mencari semua nombor utama; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Mengemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat itu; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Untuk menyimpan semua prima; Untuk menyimpan semua prima interset; Simpan semua dataran yang sempurna; Simpan semua quadruples yang sempurna; Simpan semua prima interset; Kembali kiraan prima interset; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n , unordered_set < int > & allPrimes ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . insert ( p ) ; } int countInterestingPrimes ( int n ) { unordered_set < int > allPrimes ; SieveOfEratosthenes ( n , allPrimes ) ; unordered_set < int > intersetingPrimes ; vector < int > squares , quadruples ; for ( int i = 1 ; i * i <= n ; i ++ ) { squares . push_back ( i * i ) ; } for ( int i = 1 ; i * i * i * i <= n ; i ++ ) { quadruples . push_back ( i * i * i * i ) ; } for ( auto a : squares ) { for ( auto b : quadruples ) { if ( allPrimes . count ( a + b ) ) intersetingPrimes . insert ( a + b ) ; } } return intersetingPrimes . size ( ) ; } int main ( ) { int N = 10 ; cout << countInterestingPrimes ( N ) ; return 0 ; }"}
{"text": "Semak jika array adalah array gelombang | Kod CPP untuk memeriksa sama ada array adalah pelbagai gelombang; Fungsi untuk memeriksa sama ada array adalah array gelombang arr: array input n: saiz array; Semak borang gelombang * jika arr [1] lebih besar daripada corak kiri dan kanan * yang sama akan diikuti oleh seluruh elemen *, corak terbalik lain * akan diikuti oleh unsur -unsur array; Semak elemen terakhir; Semak elemen terakhir; Kod pemacu; Array", "code": "#include <iostream> NEW_LINE using namespace std ; bool isWaveArray ( int arr [ ] , int n ) { bool result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( isWaveArray ( arr , n ) ) { cout << \" YES \" << endl ; } else { cout << \" NO \" << endl ; } return 0 ; }"}
{"text": "Mengira urutan yang berbeza yang diperoleh dengan menggantikan semua elemen subarray yang mempunyai unsur pertama dan terakhir yang sama dengan elemen pertama sebilangan kali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan urutan yang memenuhi kriteria yang diberikan; Menyimpan indeks kejadian terakhir elemen; Memulakan array untuk menyimpan bilangan urutan yang berbeza yang mungkin panjang i; Kes asas; Sekiranya tiada operasi digunakan pada elemen ITH; Jika operasi digunakan pada elemen ITH; Mengemas kini kejadian terakhir Curele; Akhirnya, cetak jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPossiblities ( int arr [ ] , int n ) { int lastOccur [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = -1 ; } int dp [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ; dp [ i ] = dp [ i - 1 ] ; if ( lastOccur [ curEle ] != -1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; } lastOccur [ curEle ] = i ; } cout << dp [ n ] << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPossiblities ( arr , N ) ; return 0 ; }"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak jumlah maksimum; Jadual DP; Memulakan array DP dengan 0 s; Kes asas; Melintasi setiap lajur; Kemas kini jawapan untuk kedua -dua baris; Cetak jumlah maksimum; Kod pemacu; Diberikan array; Bilangan lajur; Panggilan fungsi", "code": "#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void maxSum ( vector < vector < int > > arr , int n , int m ) { vector < vector < int > > dp ( n ) ; for ( int i = 0 ; i < 2 ; i ++ ) { dp [ i ] = vector < int > ( m ) ; for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } cout << max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int N = arr [ 0 ] . size ( ) ; maxSum ( arr , 2 , N ) ; return 0 ; }"}
{"text": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | C ++ kod untuk pendekatan di atas; Fungsi untuk mencetak jumlah maksimum yang mungkin dengan memilih kebanyakan elemen dari setiap lajur sehingga tiada pasangan berturut -turut dipilih dari satu baris; Memulakan pembolehubah; Melintasi setiap lajur; Jawapan cetak; Kod pemacu; Lajur nombor", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( vector < vector < int > > arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = max ( r2 , temp + arr [ 1 ] [ i ] ) ; } cout << max ( r1 , r2 ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int n = arr [ 0 ] . size ( ) ; maxSum ( arr , n ) ; return 0 ; }"}
{"text": "Kira unimodal dan bukan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira faktorial sehingga nombor; Kirakan faktorial; Berfungsi untuk mencari kuasa (a, b); Melangkah sehingga B wujud; Jika B boleh dibahagikan dengan 2; Mengurangkan nilai b; Kembalikan jawapannya; Fungsi yang mengira permutasi unimodal dan bukan unimodal dari integer yang diberikan; Fungsi panggilan untuk mencari faktorial sehingga n; Berfungsi untuk mengira permutasi unimodal; Permutasi bukan unimodal adalah N! - permutasi unimodal; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1e9 + 7 ; const int mx = 1e6 ; int fact [ mx + 1 ] ; void Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } } int UniModal_per ( int a , int b ) { long long int res = 1 ; while ( b ) { if ( b % 2 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b /= 2 ; } return res ; } void countPermutations ( int n ) { Calculate_factorial ( ) ; int uni_modal = UniModal_per ( 2 , n - 1 ) ; int nonuni_modal = fact [ n ] - uni_modal ; cout << uni_modal << \" ▁ \" << nonuni_modal ; return ; } int main ( ) { int N = 4 ; countPermutations ( N ) ; return 0 ; }"}
{"text": "Susunan terpanjang mungkin yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah | Program C ++ untuk mencari kemungkinan seterusnya yang paling lama yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah; Arahan awalan untuk menyimpan kejadian '1' dan '0'; Arahan awalan permulaan dengan 0; Melangkah ke atas panjang rentetan; Jika watak semasa adalah '1'; Jika watak semasa adalah '0'; Tambah '1' yang tersedia untuk rentetan pertama; Tambah '0' tersedia untuk rentetan kedua; Tambah '1' yang tersedia untuk rentetan ketiga; Jawapan kemas kini; Cetak hasil akhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubseq ( string s , int length ) { int ones [ length + 1 ] , zeroes [ length + 1 ] ; memset ( ones , 0 , sizeof ( ones ) ) ; memset ( zeroes , 0 , sizeof ( zeroes ) ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( s [ i ] == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; } else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = INT_MIN ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) { x += ones [ i ] ; x += ( zeroes [ j ] - zeroes [ i ] ) ; x += ( ones [ length ] - ones [ j ] ) ; answer = max ( answer , x ) ; x = 0 ; } } cout << answer << endl ; } int main ( ) { string s = \"10010010111100101\" ; int length = s . length ( ) ; longestSubseq ( s , length ) ; return 0 ; }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C ++ pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mengira dataran terbesar dengan atmost k 1 s untuk pertanyaan Q; Gelung untuk menyelesaikan setiap pertanyaan; Melintasi setiap sub persegi dan mengira jumlah; Pecah apabila melebihi kiraan maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C ++ pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputing jumlah awalan countdp matriks; Gelung untuk menyelesaikan pertanyaan; Mengira jarak maksimum yang mungkin dari pusat dari tepi; Mengira bilangan 1 s dalam submatrix; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }"}
{"text": "N Masalah Tali berturut -turut | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kos minimum untuk menyambungkan tali yang diberikan; dp [i] [j] = kos minimum dalam julat (i, j) jumlah [i] [j] = jumlah julat (i, j); Memulakan jadual jumlah; Pengkomputeran kos minimum untuk semua selang waktu yang mungkin (i, j) julat kiri; Julat kanan; Tiada kos untuk tali tunggal; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinCost ( int arr [ ] , int n ) { int dp [ n + 5 ] [ n + 5 ] , sum [ n + 5 ] [ n + 5 ] ; memset ( sum , 0 , sizeof ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinCost ( arr , n ) ; return 0 ; }"}
{"text": "Panjang subsegment terpanjang yang dikemas kini selepas memasukkan atmost satu integer | C ++ pelaksanaan pendekatan; Berfungsi untuk mengisi semula array DP; Jika f (i, state) sudah dikira maka kembalikan nilai; Hitung f (i, state) mengikut hubungan berulang dan simpan dalam dp [] []; Fungsi yang memanggil fungsi resucrsive untuk mengisi array DP dan kemudian mengembalikan hasilnya; dp [] [] array untuk menyimpan hasil f (i, 1) dan f (1, 2); Memaparkan array dp [] dengan - 1; Pastikan urutan UD dan DU terpanjang bermula pada setiap indeks dikira; Anggapkan jawapannya - 1 Nilai ini hanya akan meningkat; y ialah panjang urutan UD terpanjang bermula pada i; Jika panjangnya, tambah integer dan kemudian urutan du bermula pada i + y; Jika panjang ganjil maka tambah integer dan kemudian urutan ud bermula pada i + y; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int f ( int i , int state , int A [ ] , int dp [ ] [ 3 ] , int N ) { if ( i >= N ) return 0 ; else if ( dp [ i ] [ state ] != -1 ) { return dp [ i ] [ state ] ; } else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } } int maxLenSeq ( int A [ ] , int N ) { int i , tmp , y , ans ; int dp [ 1000 ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = -1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = max ( ans , dp [ i ] [ 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; } else if ( y % 2 == 1 ) { ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; } int main ( ) { int A [ ] = { 1 , 10 , 3 , 20 , 25 , 24 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << maxLenSeq ( A , n ) ; return 0 ; }"}
{"text": "Keluarkan elemen untuk memaksimumkan GCD array yang diberikan | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan GCD yang dimaksimumkan selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD dari semua elemen yang mempunyai lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan GCD yang dimaksimumkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxGCD ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 14 , 17 , 28 , 70 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxGCD ( a , n ) ; return 0 ; }"}
{"text": "SUM MAXIMUM SUMBER DENGAN MENGURANGKAN TANDA PALING PADA ELEMENT ARAY KEDUA | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari jumlah subarray maksimum dengan flip bermula dari indeks I; Jika bilangan flip telah melebihi; Traversal lengkap; Sekiranya negara sebelum ini telah dikunjungi; Pada mulanya; Gunakan algoritma Kadane dan hubungi dua negeri; Memoize jawapan dan mengembalikannya; Fungsi utiliti untuk memanggil flips dari indeks dan mengembalikan jawapannya; Buat array dp int dp [n] [k + 1]; ; ITERATE dan CALL FUNGSI RECURSIF DARI SETIAP INDEX UNTUK MEMBERI JUMLAH SUBARRAY MAXIMUM; kes sudut; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define right  2 NEW_LINE #define left  4 NEW_LINE int dp [ left ] [ right ] ; int findSubarraySum ( int ind , int flips , int n , int a [ ] , int k ) { if ( flips > k ) return -1e9 ; if ( ind == n ) return 0 ; if ( dp [ ind ] [ flips ] != -1 ) return dp [ ind ] [ flips ] ; int ans = 0 ; ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind ] [ flips ] = ans ; } int findMaxSubarraySum ( int a [ ] , int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; int ans = -1e9 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) return * max_element ( a , a + n ) ; return ans ; } int main ( ) { int a [ ] = { -1 , -2 , -100 , -10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 1 ; cout << findMaxSubarraySum ( a , n , k ) ; return 0 ; }"}
{"text": "Cari Jumlah Nombor Fibonacci Pertama N yang pertama | Program CPP untuk mencari jumlah nombor Fibonacci yang pertama; Fungsi untuk mengira jumlah nombor Fibonacci yang pertama; nilai asas; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE long long sumOddFibonacci ( int n ) { long long Sum [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; } int main ( ) { long long n = 6 ; cout << sumOddFibonacci ( n ) ; return 0 ; }"}
{"text": "Kurangkan jumlah teddies untuk diedarkan | C ++ pelaksanaan pendekatan di atas; Memulakan satu tablet untuk setiap pelajar; Jika dibiarkan bersebelahan mempunyai kajian markah yang lebih tinggi dan mengubah semua nilai DP yang diberikan sebelum sehingga nilai DP yang diberikan didapati salah mengikut kekangan yang diberikan; Jika betul bersebelahan mempunyai markah yang lebih tinggi, tambahkan satu di dp kiri bersebelahan dan berikan ke kanan; Kod pemacu; n bilangan pelajar; tanda pelajar; penyelesaian masalah", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long fun ( int marks [ ] , int n ) { long long dp [ n ] , temp ; fill ( dp , dp + n , 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; } int main ( ) { int n = 6 ; int marks [ 6 ] = { 1 , 4 , 5 , 2 , 2 , 1 } ; cout << fun ( marks , n ) ; return 0 ; }"}
{"text": "Bilangan cara untuk mencapai lantai nth dengan mengambil di | Program C ++ untuk mencapai tangga N - dengan mengambil maksimum l leap; unsur -unsur kombo [] menyimpan cara yang tidak mungkin untuk mencapainya dengan semua kombinasi K Leaps atau kurang; Dengan mengandaikan lompatan 0 wujud dan memberikan nilainya kepada 1 untuk pengiraan; gelung untuk melangkah ke atas semua kemungkinan melompat sehingga K; ; Dalam gelung ini kita mengira semua kemungkinan lompatan untuk mencapai tangga jth dengan bantuan lompatan atau kurang; Jika lompatan itu tidak lebih daripada i - j; Kirakan nilai dan simpan dalam combo [j] untuk menggunakannya semula untuk pengiraan lompatan seterusnya untuk tangga jth; Mengembalikan tidak ada kemungkinan lompatan untuk mencapai bahagian atas bangunan n tangga; Kod pemacu; N i tangga total k adalah nilai lompatan terbesar", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int N , int K ) { int combo [ N + 1 ] = { 0 } ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } int main ( ) { int N = 29 ; int K = 5 ; cout << solve ( N , K ) ; solve ( N , K ) ; return 0 ; }"}
{"text": "Cari yang paling lama meningkat seterusnya secara bulat | C ++ pelaksanaan untuk mencari LIS dengan cara bulat; Fungsi utiliti untuk mencari LIS menggunakan pengaturcaraan dinamik; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Tetapkan j berdasarkan tetingkap semasa i. e. elemen pertama tetingkap semasa; Pilih maksimum semua nilai LIS; Berfungsi untuk mencari peningkatan yang paling lama dalam cara bulat; Buat salinan Array yang diberikan dengan memasuki elemen array yang sama kepada dirinya sendiri; Lakukan lis untuk setiap tetingkap saiz n; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int computeLIS ( int circBuff [ ] , int start , int end , int n ) { int LIS [ end - start ] ; for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( int i = start + 1 ; i < end ; i ++ ) for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; int res = INT_MIN ; for ( int i = start ; i < end ; i ++ ) res = max ( res , LIS [ i ] ) ; return res ; } int LICS ( int arr [ ] , int n ) { int circBuff [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) res = max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Length ▁ of ▁ LICS ▁ is ▁ \" << LICS ( arr , n ) ; return 0 ; }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pekali binomial; Membina segitiga Pascal; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 3 , m = 2 ; cout << \" Number ▁ of ▁ Paths : ▁ \" << binomialCoeff ( n + m , n ) << endl ; return 0 ; }"}
{"text": "Susunan peningkatan yang paling lama (LCS + LIS) | Program C ++ untuk mencari panjang peningkatan yang paling lama (LCI); Mengembalikan panjang dan LCIS dua array ARR1 [0. n - 1] dan arr2 [0 .. m - 1]; Jadual [J] akan menyimpan panjang LCI yang berakhir dengan ARR2 [J]. Kami memulakannya sebagai 0 ,; Melintasi semua elemen ARR1 []; Memulakan panjang semasa LCI; Untuk setiap elemen arr1 [], melintasi semua elemen ARR2 []. ; Jika kedua -dua array mempunyai elemen yang sama. Perhatikan bahawa kami tidak memecahkan gelung di sini. ; Sekarang cari elemen umum yang lebih kecil sebelumnya untuk elemen semasa ARR1; Nilai maksimum dalam Jadual [] adalah hasil; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } int main ( ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << \" Length ▁ of ▁ LCIS ▁ is ▁ \" << LCIS ( arr1 , n , arr2 , m ) ; return ( 0 ) ; }"}
{"text": "Panjang awalan biasa terpanjang mungkin dengan menyusun semula rentetan dalam array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan panjang awalan biasa terpanjang dengan menyusun semula rentetan; freq [i] [j]: Menyimpan kekerapan aksara (= j) dalam rentetan arr [i]; Melintasi array yang diberikan; Kedai panjang rentetan semasa; Melintasi rentetan arus array yang diberikan; Kemas kini nilai freq [i] [arr [i] [j]]; Menyimpan panjang awalan biasa terpanjang; Kira kekerapan minimum setiap aksara dalam semua rentetan arr []; Kedai nilai minimum dalam setiap baris freq [] []; Kirakan kekerapan minimum aksara semasa dalam semua rentetan. ; Kemas kini Minrowval; Kemas kini Maxlen; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longComPre ( string arr [ ] , int N ) { int freq [ N ] [ 256 ] ; for ( let String of DistString ) { for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] [ j ] ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; } int main ( ) { string arr [ ] = { \" aabdc \" , \" abcd \" , \" aacd \" } ; int N = 3 ; cout << longComPre ( arr , N ) ; }"}
{"text": "Keluarkan aksara dari rentetan yang kelihatan tepat k kali | Program C ++ untuk menghapuskan aksara dari rentetan yang muncul tepat kali K; Berfungsi untuk mengurangkan rentetan dengan mengeluarkan aksara yang kelihatan tepat K kali; Jadual Hash diasaskan kepada 0; Meningkatkan kekerapan watak; Untuk menyimpan jawapan; Indeks seterusnya dalam rentetan yang dikurangkan; Tambah watak -watak yang kelihatan tepat K kali; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; string removeChars ( char arr [ ] , int k ) { int hash [ MAX_CHAR ] = { 0 } ; int n = strlen ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ; string ans = \" \" ; int index = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int k = 2 ; cout << removeChars ( str , k ) ; return 0 ; }"}
{"text": "Subsegments bersebelahan rentetan yang mempunyai aksara berikutnya yang berbeza | C ++ pelaksanaan pendekatan; Fungsi yang mencetak segmen; Arahan baru untuk setiap lelaran; Semak sama ada titik pengalihan berakhir atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sub_segments ( string str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { string newlist = str . substr ( x , n ) ; list < char > arr ; list < char > :: iterator it ; for ( auto y : newlist ) { it = find ( arr . begin ( ) , arr . end ( ) , y ) ; if ( it == arr . end ( ) ) arr . push_back ( y ) ; } for ( auto y : arr ) cout << y ; cout << endl ; } } int main ( ) { string str = \" geeksforgeeksgfg \" ; int n = 4 ; sub_segments ( str , n ) ; }"}
{"text": "Program untuk mencari perkataan yang disulitkan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari rentetan yang disulitkan; untuk menyimpan rentetan yang disulitkan; Selepas 'Z', ia harus pergi ke a. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWord ( string c , int n ) { int co = 0 , i ; string s ( n , ' ▁ ' ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ; if ( c [ i ] + co <= 122 ) s [ i ] = ( char ) ( ( int ) c [ i ] + co ) ; else s [ i ] = ( char ) ( ( int ) c [ i ] + co - 26 ) ; } cout << s ; } int main ( ) { string s = \" abcd \" ; findWord ( s , s . length ( ) ) ; return 0 ; }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; panjang rentetan pertama; panjang rentetan kedua; Jika panjang tidak sama hanya kembali palsu kerana kedua -dua rentetan tidak boleh sama jika panjang tidak sama; gelung untuk memadankan satu demi satu semua watak kedua -dua rentetan; Jika aksara semasa kedua -dua rentetan adalah sama, tambah nilai saya untuk membandingkan watak seterusnya; Jika mana -mana watak rentetan pertama adalah beberapa watak khas atau aksara angka dan tidak sama dengan watak yang sama rentetan kedua kemudian kembali palsu; Lakukan perkara yang sama untuk rentetan kedua; Blok kod ini akan dilaksanakan jika watak -watak kedua -dua rentetan adalah kes yang berbeza; Bandingkan watak dengan nilai ASCII; Jika watak dipadankan, tingkatkan nilai saya untuk membandingkan char seterusnya; Jika semua aksara rentetan pertama dipadankan dengan aksara yang sepadan dengan rentetan kedua, maka kembali benar; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; int len1 = str1 . size ( ) ; int len2 = str2 . size ( ) ; if ( len1 != len2 ) return false ; while ( i < len1 ) { if ( str1 [ i ] == str2 [ i ] ) { i ++ ; } else if ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) ) ) { return false ; } else if ( ! ( ( str2 [ i ] >= ' a ' && str2 [ i ] <= ' z ' ) || ( str2 [ i ] >= ' A ' && str2 [ i ] <= ' Z ' ) ) ) { return false ; } else { if ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) { if ( str1 [ i ] - 32 != str2 [ i ] ) return false ; } else if ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) { if ( str1 [ i ] + 32 != str2 [ i ] ) return false ; } i ++ ; return true ; void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << \" Same \" << endl ; else cout << \" Not ▁ Same \" << endl ; } int main ( ) { string str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; return 0 ; }"}
{"text": "Memaksimumkan nilai A dengan menggantikan beberapa digitnya dengan digit B | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai yang dimaksimumkan A; Jenis digit dalam urutan menaik; J menunjuk kepada digit terbesar di B; Jika semua digit B telah digunakan; Digit semasa telah digunakan; Mengembalikan nilai yang dimaksimumkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxValue ( string a , string b ) { sort ( b . begin ( ) , b . end ( ) ) ; int n = a . length ( ) ; int m = b . length ( ) ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return a ; } int main ( ) { string a = \"1234\" ; string b = \"4321\" ; cout << maxValue ( a , b ) ; return 0 ; }"}
{"text": "Mengira nombor dalam julat supaya digit di dalamnya dan produknya dengan Q tidak sama rata | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada semua digit dalam nombor dan produknya dengan Q tidak sama atau tidak; Tukar nombor pertama ke dalam rentetan; Masukkan elemen dari nombor 1 ke hash; Hitung produk yang sepadan; Tukar produk ke rentetan; Menggunakan Hash Check jika mana -mana digit padanan produk dengan digit nombor input; Jika ya, kembali palsu; Kembali benar; Berfungsi untuk mengira nombor dalam julat [l, r] supaya semua digit nombor dan produknya dengan Q tidak sama rata; Semak setiap nombor antara L dan R; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIfUnequal ( int n , int q ) { string s1 = to_string ( n ) ; int a [ 26 ] = { 0 } ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) a [ s1 [ i ] - '0' ] ++ ; int prod = n * q ; string s2 = to_string ( prod ) ; for ( int i = 0 ; i < s2 . size ( ) ; i ++ ) { if ( a [ s2 [ i ] - '0' ] ) return false ; } return true ; } int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; } int main ( ) { int l = 10 , r = 12 , q = 2 ; cout << countInRange ( l , r , q ) ; return 0 ; }"}
{"text": "Semak sama ada mungkin untuk menyusun semula rentetan binari dengan alternatif 0 s dan 1 s | Program CPP untuk memeriksa sama ada kita boleh menyusun semula rentetan supaya ia mempunyai alternatif 0 s dan 1 s. ; berfungsi untuk memeriksa rentetan binari; panjang rentetan; Count Zero; Kira satu 's; jika panjangnya; jika panjang ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_possible ( string s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( abs ( one - zero ) == 1 ) ; } int main ( ) { string s = \"100110\" ; if ( is_possible ( s ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program C ++ untuk mengira frekuensi item array; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi aksara rentetan dan mengira frekuensi; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int limit = 255 ; void countFreq ( string str ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << ( char ) i << \" ▁ \" << count [ i ] << endl ; } int main ( ) { string str = \" GeeksforGeeks \" ; countFreq ( str ) ; return 0 ; }"}
{"text": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Program C ++ untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << \" Even ▁ = ▁ \" << odd << \" , ▁ Odd ▁ = ▁ \" << even ; } else { cout << \" Even ▁ = ▁ \" << even << \" , ▁ Odd ▁ = ▁ \" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }"}
{"text": "Google Case Of A Sentyen tertentu | Program CPP untuk menukar ayat yang diberikan kepada kes unta. ; Berfungsi untuk mengeluarkan ruang dan menukar ke dalam kes unta; Semak ruang dalam ayat; penukaran ke atas kes; Jika tidak ruang, salin watak; kembali rentetan ke Main; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string s ) { int n = s . length ( ) ; s [ 0 ] = tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ) ; i ++ ; } else s [ i ] = toupper ( s [ i ] ) ; } return s ; } int main ( ) { string str = \" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks \" ; cout << convert ( str ) ; return 0 ; }"}
{"text": "Ubah rentetan | Kod CPP untuk mengubah rentetan; Fungsi untuk mengubah kes watak; Jika watak adalah perubahan huruf kecil ke huruf besar; Jika watak adalah perubahan huruf besar kepada huruf kecil; Berfungsi untuk memadam vokal; Jika watak adalah konsonan; Fungsi untuk memasukkan \" #\"; Jika watak tidak istimewa; Berfungsi untuk mengubah rentetan; Fungsi pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string change_case ( string a ) { int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] >= ' a ' && a [ i ] <= ' z ' ) a [ i ] = ( char ) ( 65 + ( int ) ( a [ i ] - ' a ' ) ) ; else if ( a [ i ] >= ' A ' && a [ i ] <= ' Z ' ) a [ i ] = ( char ) ( 97 + ( int ) ( a [ i ] - ' A ' ) ) ; } return a ; } string delete_vowels ( string a ) { string temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] != ' a ' && a [ i ] != ' e ' && a [ i ] != ' i ' && a [ i ] != ' o ' && a [ i ] != ' u ' && a [ i ] != ' A ' && a [ i ] != ' E ' && a [ i ] != ' O ' && a [ i ] != ' U ' && a [ i ] != ' I ' ) temp += a [ i ] ; } return temp ; } string insert_hash ( string a ) { string temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( a [ i ] >= ' a ' && a [ i ] <= ' z ' ) || ( a [ i ] >= ' A ' && a [ i ] <= ' Z ' ) ) temp = temp + ' # ' + a [ i ] ; else temp = temp + a [ i ] ; } return temp ; } void transformSting ( string a ) { string b = delete_vowels ( a ) ; string c = change_case ( b ) ; string d = insert_hash ( c ) ; cout << d ; } int main ( ) { string a = \" SunshinE ! ! \" ; transformSting ( a ) ; return 0 ; }"}
{"text": "Nombor TCEFREP | C ++ pelaksanaan untuk memeriksa sama ada N adalah nombor TCEFREP; Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Kod pemacu; Diberi nombor n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } int properDivSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } bool isTcefrep ( int n ) { return properDivSum ( n ) == reverse ( n ) ; } int main ( ) { int N = 6 ; if ( isTcefrep ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk mencari n | Program C ++ untuk mencari nombor N - TH yang mengandungi hanya 3 dan 5 .; Jika n adalah ganjil, tambah 3 dan pindah ke ibu bapa; Jika n adalah, tambah 5 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string findNthNo ( int n ) { string res = \" \" ; while ( n >= 1 ) { if ( n & 1 ) { res = res + \"3\" ; n = ( n - 1 ) / 2 ; } else { res = res + \"5\" ; n = ( n - 2 ) / 2 ; } } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } int main ( ) { int n = 5 ; cout << findNthNo ( n ) ; return 0 ; }"}
{"text": "Nth non | Program CPP untuk mencari nombor bukan persegi. ; berfungsi untuk mencari nombor non non - persegi; Penukaran dari Int ke Long Double diperlukan untuk memelihara tempat perpuluhan selepas akar persegi. ; mengira hasilnya; Kod pemacu; memulakan nombor jangka panjang; Cetak hasilnya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNthNonSquare ( int n ) { long double x = ( long double ) n ; long double ans = x + floor ( 0.5 + sqrt ( x ) ) ; return ( int ) ans ; } int main ( ) { int n = 16 ; cout << \" The ▁ \" << n << \" th ▁ Non - Square ▁ number ▁ is ▁ \" ; cout << findNthNonSquare ( n ) ; return 0 ; }"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Program CPP yang cekap untuk mencari jumlah siri dengan jumlah AP persegi yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }"}
{"text": "Cari nombor n yang mengandungi digit k atau dibahagikan dengan k. | Program C ++ untuk mencari nombor n yang mengandungi digit k atau dibahagikan oleh k. ; Fungsi untuk memeriksa jika digit k berada dalam n atau tidak; mencari selebihnya; jika digit dijumpai; Fungsi untuk mencari nombor nth; Oleh kerana k adalah yang pertama yang memenuhi kriteria, jadi pertimbangkannya dalam kiraan membuat kiraan = 1 dan bermula dari i = k + 1; Memeriksa bahawa nombor itu mengandungi k digit atau dibahagikan oleh k; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkdigit ( int n , int k ) { while ( n ) { int rem = n % 10 ; if ( rem == k ) return 1 ; n = n / 10 ; } return 0 ; } int findNthNumber ( int n , int k ) { for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return -1 ; } int main ( ) { int n = 10 , k = 2 ; cout << findNthNumber ( n , k ) << endl ; return 0 ; }"}
{"text": "Count subarrays saiz K yang merupakan permutasi nombor dari 1 hingga k | Program C ++ untuk melaksanakan pendekatan di atas; Simpan indeks nombor array; Kemas kini indeks min dan max dengan indeks semasa dan periksa sama ada ia adalah permutasi yang sah; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE #include <vector> NEW_LINE using namespace std ; int find_permutations ( vector < int > & arr ) { int cnt = 0 ; int max_ind = -1 , min_ind = 10000000 ; int n = arr . size ( ) ; unordered_map < int , int > index_of ; for ( int i = 0 ; i < n ; i ++ ) { index_of [ arr [ i ] ] = i + 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { max_ind = max ( max_ind , index_of [ i ] ) ; min_ind = min ( min_ind , index_of [ i ] ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; } int main ( ) { vector < int > nums ; nums . push_back ( 2 ) ; nums . push_back ( 3 ) ; nums . push_back ( 1 ) ; nums . push_back ( 5 ) ; nums . push_back ( 4 ) ; cout << find_permutations ( nums ) ; return 0 ; }"}
{"text": "Count of integer yang membahagikan semua elemen array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan bilangan bulat yang diperlukan; Untuk menyimpan GCD unsur -unsur array; Untuk menyimpan kiraan faktor GCD yang dijumpai; Jika G adalah persegi yang sempurna; Faktor muncul berpasangan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int a [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; } int main ( ) { int a [ ] = { 4 , 16 , 1024 , 48 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getCount ( a , n ) ; return 0 ; }"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; menyimpan watak yang dikunjungi; menyimpan jawapannya; melintasi rentetan; jika sudah dikunjungi; Menyimpan kos maksimum untuk mengeluarkan watak tertentu; Simpan jumlah kos penghapusan watak tertentu; Tandakan watak semasa yang dikunjungi; Melintasi indeks rentetan [i, n - 1]; Jika ada pendua yang dijumpai; Mengemas kini kos maksimum dan jumlah kos; Tandakan watak semasa yang dikunjungi; Simpan watak dengan kos maksimum dan padamkan yang lain; mengembalikan kos minimum; Kod pemacu; rentetan input; Arahan input; panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int delCost ( string s , int cost [ ] , int l1 , int l2 ) { bool visited [ l1 ] ; memset ( visited , 0 , sizeof ( visited ) ) ; int ans = 0 ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( visited [ i ] ) { continue ; } int maxDel = 0 ; int totalCost = 0 ; visited [ i ] = 1 ; for ( int j = i ; j < l1 ; j ++ ) { if ( s [ i ] == s [ j ] ) { maxDel = max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ; visited [ j ] = 1 ; } } ans += totalCost - maxDel ; } return ans ; } int main ( ) { string s = \" AAABBB \" ; int l1 = s . size ( ) ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int l2 = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << delCost ( s , cost , l1 , l2 ) ; return 0 ; }"}
{"text": "Buat semua elemen array sama dengan menggantikan tiga kali ganda dengan bitwise xor mereka | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari tiga kali ganda yang menggantikannya dengan XOR mereka membuat semua elemen array sama; Jika n juga; Hitung XOR unsur array; Melintasi array; Kemas kini XOR; Jika XOR tidak sama dengan 0; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkXOR ( int arr [ ] , int N ) { if ( N % 2 == 0 ) { int xro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xro ^= arr [ i ] ; } if ( xro != 0 ) { cout << -1 << endl ; return ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << i + 2 << endl ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << N - 1 << endl ; } } else { for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << i + 2 << endl ; } for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << N - 1 << endl ; } } } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkXOR ( arr , N ) ; }"}
{"text": "Buat semua elemen array walaupun dengan menggantikan sepasang elemen array bersebelahan dengan jumlah mereka | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan minimum operasi yang diperlukan untuk membuat semua elemen array walaupun; Kedai minimum penggantian minimum untuk membuat semua elemen array walaupun; Menyimpan kiraan nombor berterusan ganjil; Melintasi array; Jika arr [i] adalah nombor ganjil; Kemas kini ODD_CONT_SEG; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Tetapkan semula ODD_CONT_SEG = 0; Jika odd_cont_seg melebihi 0; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Cetak hasilnya; Kod pemandu", "code": "#include <iostream> NEW_LINE using namespace std ; int make_array_element_even ( int arr [ ] , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << make_array_element_even ( arr , N ) ; return 0 ; }"}
{"text": "Cari nombor k sedemikian rupa sehingga betul -betul elemen array lebih besar daripada atau sama dengan k | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari k yang mana terdapat unsur -unsur array yang lebih besar daripada atau sama dengan k; Mencari elemen array terbesar; Nilai kemungkinan k; Melintasi array; Jika elemen array semasa lebih besar daripada atau sama dengan i; Jika saya pelbagai elemen adalah lebih besar daripada atau sama dengan i; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int zvalue ( vector < int > & nums ) { int m = * max_element ( nums . begin ( ) , nums . end ( ) ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . size ( ) ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return -1 ; } int main ( ) { vector < int > nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; cout << zvalue ( nums ) << endl ; }"}
{"text": "Anagrams lexicographically terkecil dan terbesar rentetan yang mengandungi rentetan lain sebagai substringnya | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari anagram terkecil rentetan yang mengandungi rentetan lain; Memulakan peta dan set; Melangkah ke atas S1; Menyimpan kekerapan aksara yang ada di S1; Menyimpan watak -watak yang berbeza dalam S1; Mengurangkan kekerapan aksara dari m yang sudah ada di S2; Melintasi abjad dalam urutan yang disusun; Jika watak semasa set tidak sama dengan watak semasa S2; Jika elemen sama dengan watak semasa S2; Memeriksa watak kedua yang berbeza dalam S2; S2 [J] akan menyimpan watak kedua yang berbeza; Kembalikan jawapannya; Berfungsi untuk mencari anagram leksikografi terbesar rentetan yang mengandungi rentetan lain; Mendapatkan anagram terkecil secara lexicographically; D1 menyimpan awalan; D2 menyimpan akhiran; Mengembalikan hasilnya; Kod pemacu; Diberikan dua rentetan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < string , int > lexico_smallest ( string s1 , string s2 ) { map < char , int > M ; set < char > S ; pair < string , int > pr ; for ( int i = 0 ; i <= s1 . size ( ) - 1 ; ++ i ) { M [ s1 [ i ] ] ++ ; S . insert ( s1 [ i ] ) ; } for ( int i = 0 ; i <= s2 . size ( ) - 1 ; ++ i ) { M [ s2 [ i ] ] -- ; } char c = s2 [ 0 ] ; int index = 0 ; string res = \" \" ; for ( auto x : S ) { if ( x != c ) { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { int j = 0 ; index = res . size ( ) ; while ( s2 [ j ] == x ) { j ++ ; } if ( s2 [ j ] < c ) { res += s2 ; for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } index += M [ x ] ; res += s2 ; } } } pr . first = res ; pr . second = index ; return pr ; } string lexico_largest ( string s1 , string s2 ) { pair < string , int > pr = lexico_smallest ( s1 , s2 ) ; string d1 = \" \" ; for ( int i = pr . second - 1 ; i >= 0 ; i -- ) { d1 += pr . first [ i ] ; } string d2 = \" \" ; for ( int i = pr . first . size ( ) - 1 ; i >= pr . second + s2 . size ( ) ; -- i ) { d2 += pr . first [ i ] ; } string res = d2 + s2 + d1 ; return res ; } int main ( ) { string s1 = \" ethgakagmenpgs \" ; string s2 = \" geeks \" ; cout << lexico_smallest ( s1 , s2 ) . first << \" STRNEWLINE \" ; cout << lexico_largest ( s1 , s2 ) ; return ( 0 ) ; }"}
{"text": "Pertanyaan untuk mencari kiraan laluan terpendek di dalam pokok yang mengandungi kelebihan yang diberikan | C ++ pelaksanaan untuk pendekatan di atas; Senarai Adjacency untuk mewakili pokok; Bilangan simpang; Mark yang melawat / tidak dapat Vertices; Menyimpan saiz subtree nod yang sepadan; Berfungsi untuk mewujudkan kelebihan antara dua simpul; Tambah senarai A ke B; Tambah B ke senarai A; Berfungsi untuk melaksanakan DFS; Tandakan puncak yang dikunjungi; Termasuk nod dalam subtree; Melintasi semua anaknya; Berfungsi untuk mencetak bilangan laluan yang diperlukan; Kod pemacu; Bilangan simpang; Memanggil fungsi DFS yang diubah suai; Kira pasangan simpang di pokok", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; vector < int > tree [ sz ] ; int n ; bool vis [ sz ] ; int subtreeSize [ sz ] ; void addEdge ( int a , int b ) { tree [ a ] . push_back ( b ) ; tree [ b ] . push_back ( a ) ; } void dfs ( int x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; for ( auto i : tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } } void countPairs ( int a , int b ) { int sub = min ( subtreeSize [ a ] , subtreeSize [ b ] ) ; cout << sub * ( n - sub ) << endl ; } int main ( ) { n = 6 ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ; dfs ( 0 ) ; countPairs ( 1 , 3 ) ; countPairs ( 0 , 2 ) ; return 0 ; }"}
{"text": "Kira permutasi array yang mempunyai setiap elemen sebagai pelbagai atau faktor indeksnya | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kiraan permutasi yang dikehendaki; Kes asas; Jika saya belum dimasukkan; Backtrack; Masukkan i; Berulang untuk mencari permutasi yang sah; Keluarkan i; Mengembalikan kiraan akhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPermutation ( unordered_set < int > & arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . find ( i ) == arr . end ( ) ) { if ( i % pos == 0 or pos % i == 0 ) { arr . insert ( i ) ; res += findPermutation ( arr , N ) ; arr . erase ( arr . find ( i ) ) ; } } } return res ; } int main ( ) { int N = 5 ; unordered_set < int > arr ; cout << findPermutation ( arr , N ) ; return 0 ; }"}
{"text": "Semak jika jumlah y boleh didapati dari array oleh operasi yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mendapatkan jumlah y dari urutan jumlah x dari array arr []; Simpan perbezaan; Melangkah ke atas array; Jika diff dikurangkan kepada 0; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; return 0 ; }"}
{"text": "Jarak paling jauh dari nod dari setiap nod pokok | Program C ++ untuk melaksanakan pendekatan di atas; Senarai adjacency untuk menyimpan graf; Menyimpan ketinggian setiap nod; Menyimpan jarak maksimum nod dari nenek moyangnya; Berfungsi untuk menambah kelebihan antara dua simpang; Masukkan kelebihan dari u ke v; Masukkan tepi dari v ke u; Berfungsi untuk mengira ketinggian setiap nod; Melangkah dalam senarai addacency nod semasa; DFS untuk nod kanak -kanak; Hitung ketinggian nod; Meningkatkan ketinggian; Fungsi untuk mengira jarak maksimum nod dari nenek moyangnya; Melangkah dalam senarai addacency nod semasa; Cari dua kanak -kanak dengan ketinggian maksimum; Kirakan jarak maksimum dengan nenek moyang untuk setiap nod; Mengira untuk kanak -kanak; Kod pemacu; Hitung ketinggian nod pokok; Kirakan jarak maksimum dengan nenek moyang; Cetak maksimum dua jarak dari setiap nod", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  100001 NEW_LINE vector < int > adj [ maxN ] ; int height [ maxN ] ; int dist [ maxN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void dfs1 ( int cur , int par ) { for ( auto u : adj [ cur ] ) { if ( u != par ) { dfs1 ( u , cur ) ; height [ cur ] = max ( height [ cur ] , height [ u ] ) ; } } height [ cur ] += 1 ; } void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ; for ( auto u : adj [ cur ] ) { if ( u != par ) { if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; for ( auto u : adj [ cur ] ) { if ( u != par ) { sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( u , cur ) ; } } } int main ( ) { int n = 6 ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 5 , 6 ) ; dfs1 ( 1 , 0 ) ; dfs2 ( 1 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << ( max ( dist [ i ] , height [ i ] ) - 1 ) << \" ▁ \" ; return 0 ; }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program CPP untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Memeriksa B; Memeriksa A; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Program C ++ untuk pelaksanaan pilihan pemilihan; Berfungsi untuk melaksanakan jenis pemilihan; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Kod pemacu; Panggilan fungsi; Cetak array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } cout << endl ; } int main ( ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; selectionSort ( arr , n ) ; cout << \" Sorted ▁ array : ▁ STRNEWLINE \" ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Semak jika rentetan yang diberikan boleh ditukar kepada yang lain dengan diberikan swap yang mungkin | Program C ++ untuk melaksanakan pendekatan di atas; Kedai panjang str1; Kedai panjang str2; Kedai watak -watak yang berbeza dari STR1; Kedai watak -watak yang berbeza dari STR2; Kedai kekerapan setiap watak Str1; Traverse string str1; Kemas kini kekerapan str1 [i]; Traverse string str1; Masukkan str1 [i] ke st1; Traverse string str2; Masukkan str1 [i] ke st1; Jika watak yang berbeza dalam str1 dan str2 tidak sama; Kedai kekerapan setiap watak Str2; Traverse string str2; Kemas kini kekerapan STR2 [i]; Sort hash1 [] array; Susun Hash2 [] array; Traverse Hash1 [] dan Hash2 []; Jika Hash1 [i] tidak sama dengan Hash2 [i]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkStr1CanConStr2 ( string & str1 , string & str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; set < int > st1 ; set < int > st2 ; int hash1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . insert ( str1 [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . insert ( str2 [ i ] ) ; } if ( st1 != st2 ) { return false ; } int hash2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] ] ++ ; } sort ( hash1 , hash1 + 256 ) ; sort ( hash2 , hash2 + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; } int main ( ) { string str1 = \" xyyzzlll \" ; string str2 = \" yllzzxxx \" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { cout << \" True \" ; } else { cout << \" False \" ; } }"}
{"text": "Susun array dalam julat indeks yang diberikan | Program C ++ untuk menyusun array dalam julat indeks yang diberikan; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Susun subarray dari arr [l] ke arr [r]; Cetak array yang diubah suai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; vector < int > v ( arr , arr + N ) ; sort ( v . begin ( ) + l , v . begin ( ) + r + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) cout << v [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; }"}
{"text": "Cari kos minimum untuk mencapai destinasi menggunakan kereta api | Penyelesaian berasaskan pengaturcaraan dinamik untuk mencari kos min untuk mencapai stesen n - 1 dari stesen 0 .; Fungsi ini mengembalikan kos yang paling kecil untuk mencapai stesen n - 1 dari stesen 0 .; Dist [i] menyimpan kos minimum untuk mencapai stesen I dari stesen 0 .; Pergi melalui setiap stesen dan periksa jika menggunakannya sebagai stesen perantaraan memberikan jalan yang lebih baik; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE #define N  4 NEW_LINE int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; } int main ( ) { int cost [ N ] [ N ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; cout << \" The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ \" << N << \" ▁ is ▁ \" << minCost ( cost ) ; return 0 ; }"}
{"text": "Bilangan gelung saiz k bermula dari nod tertentu | Program C ++ untuk mencari bilangan kitaran panjang K dalam graf dengan nod N. ; Kembalikan bilangan cara dari nod untuk membuat gelung saiz K dalam graf nod yang tidak disambungkan lengkap; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = -1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } int main ( ) { int n = 4 , k = 2 ; cout << numOfways ( n , k ) << endl ; return 0 ; }"}
{"text": "Program untuk mencari watak bernilai ASCII terbesar dan terkecil dalam rentetan | Program C ++ untuk mencari aksara terbesar dan terkecil dalam rentetan. ; Fungsi yang mengembalikan abjad terbesar. ; memulakan abjad max ke 'a'; Cari abjad terbesar; kembali elemen terbesar; fungsi yang mengembalikan abjad terkecil; memulakan abjad terkecil kepada 'z'; Cari abjad terkecil; kembali abjad terkecil; Kod pemacu; Pelbagai watak; Mengira saiz rentetan; fungsi memanggil dan mencetak nilai yang dikembalikan", "code": "#include <iostream> NEW_LINE using namespace std ; char largest_alphabet ( char a [ ] , int n ) { char max = ' A ' ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] > max ) max = a [ i ] ; return max ; } char smallest_alphabet ( char a [ ] , int n ) { char min = ' z ' ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < min ) min = a [ i ] ; return min ; } int main ( ) { char a [ ] = \" GeEksforGeeks \" ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" ; cout << largest_alphabet ( a , size ) << \" ▁ and ▁ \" ; cout << smallest_alphabet ( a , size ) << endl ; return 0 ; }"}
{"text": "Buat palindrome terbesar dengan menukar paling banyak k | Program C ++ untuk mendapatkan palindrome terbesar menukar digit at atmost; Mengembalikan maksimum palindrome menggunakan perubahan k; Memulakan l dan r oleh hujung kiri dan paling kanan; Pertama cuba membuat tali palindrome; Menggantikan watak kiri dan kanan dengan maksimum kedua -duanya; Jika k adalah negatif maka kita tidak boleh membuat palindrome rentetan; Pada watak pertengahan, jika k> 0 kemudian ubahnya menjadi 9; Jika watak di LTH (sama seperti RTH) kurang daripada 9; Jika tiada seorang pun daripada mereka diubah dalam gelung sebelumnya maka tolak 2 dari k dan tukar kedua -duanya ke 9; Jika salah satu daripada mereka diubah dalam gelung sebelumnya maka tolak 1 dari k (1 lagi telah dikurangkan) dan menjadikannya 9; Kod pemacu untuk menguji kaedah di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string maximumPalinUsingKChanges ( string str , int k ) { string palin = str ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return \" Not ▁ possible \" ; l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) palin [ l ] = '9' ; } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str [ l ] palin [ r ] != str [ r ] ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } return palin ; } int main ( ) { string str = \"43435\" ; int k = 3 ; cout << maximumPalinUsingKChanges ( str , k ) ; return 0 ; }"}
{"text": "Kira tiga dengan bitwise dan sama dengan sifar | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }"}
{"text": "Kurangkan kiraan pasangan bersebelahan dengan pariti yang berbeza | C ++ pelaksanaan pendekatan di atas; Fungsi rekursif untuk mengira pasangan bersebelahan minimum dengan pariti yang berbeza; Jika semua nombor diletakkan; Jika penggantian tidak diperlukan; Jika penggantian diperlukan; mundur; mundur; Berfungsi untuk memaparkan bilangan minimum elemen bersebelahan dengan pariti yang berbeza; Simpan tidak ada nombor yang tidak ada dalam array; Simpan tiada nombor ganjil yang tidak terdapat dalam array; Memadam nombor exisiting; Simpan bukan nombor dan nombor ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void parity ( vector < int > even , vector < int > odd , vector < int > v , int i , int & min ) { if ( i == v . size ( ) || even . size ( ) == 0 && odd . size ( ) == 0 ) { int count = 0 ; for ( int j = 0 ; j < v . size ( ) - 1 ; j ++ ) { if ( v [ j ] % 2 != v [ j + 1 ] % 2 ) count ++ ; } if ( count < min ) min = count ; return ; } if ( v [ i ] != -1 ) parity ( even , odd , v , i + 1 , min ) ; else { if ( even . size ( ) != 0 ) { int x = even . back ( ) ; even . pop_back ( ) ; v [ i ] = x ; parity ( even , odd , v , i + 1 , min ) ; even . push_back ( x ) ; } if ( odd . size ( ) != 0 ) { int x = odd . back ( ) ; odd . pop_back ( ) ; v [ i ] = x ; parity ( even , odd , v , i + 1 , min ) ; odd . push_back ( x ) ; } } } void minDiffParity ( vector < int > v , int n ) { vector < int > even ; vector < int > odd ; unordered_map < int , int > m ; for ( int i = 1 ; i <= n ; i ++ ) m [ i ] = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] != -1 ) m . erase ( v [ i ] ) ; } for ( auto i : m ) { if ( i . first % 2 == 0 ) even . push_back ( i . first ) ; else odd . push_back ( i . first ) ; } int min = 1000 ; parity ( even , odd , v , 0 , min ) ; cout << min << endl ; } int main ( ) { int n = 8 ; vector < int > v = { 2 , 1 , 4 , -1 , -1 , 6 , -1 , 8 } ; minDiffParity ( v , n ) ; return 0 ; }"}
{"text": "Cari triplet sedemikian rupa sehingga bilangan nod yang menghubungkan triplet ini adalah maksimum | C ++ pelaksanaan pendekatan; Untuk menyimpan nod yang diperlukan; Array induk untuk menjejaki semula nod; Arahan yang dikunjungi untuk mengelakkan DFS ke arah di garis pusat; Fungsi DFS untuk mencari startnode; Fungsi DFS untuk mencari endnode diameter dan mengekalkan array induk; Fungsi DFS untuk mencari nod akhir cawangan terpanjang ke diameter; Fungsi untuk mencari nod yang diperlukan; Untuk mencari node diameter; Untuk mencari nod akhir diameter; x adalah nod akhir diameter; Tandakan semua nod diameter menggunakan penjejakan belakang; Cari nod akhir cawangan terpanjang ke diameter; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MAX  100005 NEW_LINE using namespace std ; vector < int > adjacent [ MAX ] ; bool visited [ MAX ] ; int startnode , endnode , thirdnode ; int maxi = -1 , N ; int parent [ MAX ] ; bool vis [ MAX ] ; void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } } void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; parent [ adjacent [ u ] [ i ] ] = u ; dfs1 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } } void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] && ! vis [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs2 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } } void findNodes ( ) { dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = -1 ; dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; int x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = -1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } } int main ( ) { N = 4 ; adjacent [ 1 ] . push_back ( 2 ) ; adjacent [ 2 ] . push_back ( 1 ) ; adjacent [ 1 ] . push_back ( 3 ) ; adjacent [ 3 ] . push_back ( 1 ) ; adjacent [ 1 ] . push_back ( 4 ) ; adjacent [ 4 ] . push_back ( 1 ) ; findNodes ( ) ; cout << \" ( \" << startnode << \" , ▁ \" << endnode << \" , ▁ \" << thirdnode << \" ) \" ; return 0 ; }"}
{"text": "Peratusan peningkatan jumlah sfera jika radius meningkat dengan peratusan tertentu | Program C ++ untuk mencari peningkatan peratusan dalam jumlah sfera jika radius meningkat dengan peratusan tertentu; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void newvol ( double x ) { cout << \" percentage ▁ increase ▁ in ▁ the \" << \" ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ \" << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << \" % \" << endl ; } int main ( ) { double x = 10 ; newvol ( x ) ; return 0 ; }"}
{"text": "Panjang kord bulatan yang jejari dan sudutnya diselipkan di pusat oleh kord diberikan | Program C ++ untuk mencari kord panjang bulatan yang radius dan sudut yang diselaraskan di pusat juga diberikan; Berfungsi untuk mencari panjang kord; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void length_of_chord ( double r , double x ) { cout << \" The ▁ length ▁ of ▁ the ▁ chord \" << \" ▁ of ▁ the ▁ circle ▁ is ▁ \" << 2 * r * sin ( x * ( 3.14 / 180 ) ) << endl ; } int main ( ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; return 0 ; }"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segitiga sama rata | Program C ++ untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segitiga sama rata; Berfungsi untuk mencari kawasan dataran; A tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = sqrt ( a ) / 6 ; return area ; } int main ( ) { float a = 10 ; cout << area ( a ) << endl ; return 0 ; }"}
{"text": "Panjang batang terpanjang yang boleh dimuatkan ke dalam cuboid | Program C ++ untuk mencari rod terpanjang yang boleh dimuatkan dalam cuboid; Berfungsi untuk mencari panjang; Pembolehubah sementara untuk memegang hasil pertengahan; Panjang rod terpanjang dikira menggunakan fungsi akar persegi; Kod pemacu; Memanggil LongeStroDincuboid () berfungsi untuk mendapatkan panjang rod terpanjang", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = sqrt ( temp ) ; return result ; } int main ( ) { int length = 12 , breadth = 9 , height = 8 ; cout << longestRodInCuboid ( length , breadth , height ) ; return 0 ; }"}
{"text": "Semak sama ada titik tertentu terletak pada atau di dalam segi empat tepat | Set 3 | Program C ++ untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; berfungsi untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } int main ( ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) cout << \" Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle \" ; else cout << \" Given ▁ point ▁ does ▁ not ▁ lie ▁ on ▁ the ▁ rectangle \" ; return 0 ; }"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; Kembalikan jumlah maksimum. ; untuk panjang; untuk keluasan; untuk ketinggian; Mengira isipadu maksimum. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k ) ; } } return maxvalue ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; }"}
{"text": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; Kembalikan jumlah maksimum. ; mencari panjang; mencari keluasan; Mencari ketinggian; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; }"}
{"text": "Kawasan Hexagon | Program CPP untuk mencari kawasan segi enam; Fungsi untuk mengira kawasan segi enam. ; Kod pemacu; Panjang sisi", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; } int main ( ) { double s = 4 ; cout << \" Area ▁ : ▁ \" << hexagonArea ( s ) ; return 0 ; }"}
{"text": "Bilangan maksimum kuadrat yang boleh dimuatkan dalam segitiga isosceles sudut kanan | Program CPP untuk mencari dataran maksimum yang boleh dimuatkan dalam segi tiga sudut yang betul; fungsi untuk mencari dataran maksimum; kembali dalam O (1) dengan formula yang diperoleh; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; } int main ( ) { int b = 10 , m = 2 ; cout << maxSquare ( b , m ) ; return 0 ; }"}
{"text": "Semak jika segitiga yang betul mungkin dari kawasan tertentu dan hipotenus | Program C ++ untuk memeriksa kewujudan segitiga kanan. ; Mencetak tiga sisi segitiga kanan dari kawasan tertentu dan hipotenus jika segitiga mungkin, cetakan lain - 1 .; Deskripsi persamaan; memohon formula persamaan linear untuk mencari kedua -dua akar; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRightAngle ( int A , int H ) { long D = pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { long root1 = ( H * H + sqrt ( D ) ) / 2 ; long root2 = ( H * H - sqrt ( D ) ) / 2 ; long a = sqrt ( root1 ) ; long b = sqrt ( root2 ) ; if ( b >= a ) cout << a << \" ▁ \" << b << \" ▁ \" << H ; else cout << b << \" ▁ \" << a << \" ▁ \" << H ; } else cout << \" - 1\" ; } int main ( ) { findRightAngle ( 6 , 5 ) ; }"}
{"text": "Bilangan maksimum 2 x2 kotak yang boleh dimuatkan di dalam segitiga isosceles kanan | Program C ++ untuk mengira bilangan 2 x 2 kotak di segitiga isosceles yang betul; Mengeluarkan bahagian tambahan yang selalu kita perlukan; Kerana setiap persegi mempunyai asas panjang 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; } int main ( ) { int base = 8 ; cout << numberOfSquares ( base ) ; return 0 ; }"}
{"text": "Bitwise atau bitwise dan semua yang mungkin bukan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarray yang mungkin selepas melakukan setiap pertanyaan; Melintasi setiap pasangan pertanyaan; Menyimpan bitwise atau; Mengemas kini array; Cari bitwise atau array baru yang dikemas kini; Cetak Ans; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void performQuery ( vector < int > arr , vector < vector < int > > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int or1 = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . size ( ) ; j ++ ) { or1 = or1 | arr [ j ] ; } cout << or1 << \" ▁ \" ; } } int main ( ) { vector < int > arr ( { 1 , 2 , 3 } ) ; vector < int > v1 ( { 1 , 4 } ) ; vector < int > v2 ( { 3 , 0 } ) ; vector < vector < int > > Q ; Q . push_back ( v1 ) ; Q . push_back ( v2 ) ; performQuery ( arr , Q ) ; }"}
{"text": "Panjang terkecil nombor yang boleh dibahagi dengan k yang dibentuk dengan menggunakan d sahaja | Program C ++ untuk pendekatan di atas; Berfungsi untuk membentuk bilangan terkecil yang mungkin; Array untuk menandakan baki yang telah dikira sudah; Melangkah ke atas julat; Jika baki itu sudah dijumpai, kembali - 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; vector < int > v ( k , 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return -1 ; v [ m ] = 1 ; cnt ++ ; } return -1 ; } int main ( ) { int d = 1 ; int k = 41 ; cout << smallest ( k , d ) ; return 0 ; }"}
{"text": "Grafik Cube Fibonacci | Kod CPP untuk mencari simpul dalam graf kiub Fibonacci Order N; berfungsi untuk mencari nombor Fibonacci; fungsi untuk mencari bilangan simpang dalam graf kiub Fibonacci; kembali nombor fibonacci untuk f (n + 2); Program Pemandu", "code": "#include <iostream> NEW_LINE using namespace std ; int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } int findVertices ( int n ) { return fib ( n + 2 ) ; } int main ( ) { int n = 3 ; cout << findVertices ( n ) ; return 0 ; }"}
{"text": "Ubah suai array supaya array tidak mengandungi mana -mana pembahagi biasa selain 1 | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mengubah suai array supaya tidak ada faktor yang sama antara elemen array kecuali 1; Menyimpan GCD array; Hitung GCD array; Jika pembahagi semasa lebih kecil daripada x; Bahagikan GCD oleh pembahagi semasa; Jika boleh; Cetak array yang diubah suai; Jika tidak; Kod pemacu; Diberikan array; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCommonDivisor ( int arr [ ] , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = __gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { cout << \" Yes STRNEWLINE \" ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] / copy_G << \" ▁ \" ; cout << endl ; } else cout << \" No \" ; } int main ( ) { int arr [ ] = { 6 , 15 , 6 } , X = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkCommonDivisor ( arr , N , X ) ; }"}
{"text": "Program untuk mencetak corak lingkaran | Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran", "code": "#include <iostream> NEW_LINE using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << \" ▁ \" ; else cout << n << \" ▁ \" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }"}
{"text": "Sort Biotonic Doubly Linked List | C ++ pelaksanaan untuk menyusun senarai dikaitkan biotonik; nod senarai dikaitkan dua kali ganda; Berfungsi untuk membalikkan senarai dikaitkan dua kali ganda; swap seterusnya dan sebelumnya untuk semua nod senarai dikaitkan dua kali ganda; Sebelum menukar kepala, periksa kes -kes seperti senarai kosong dan senarai dengan hanya satu nod; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika senarai yang dipautkan pertama kosong; Jika senarai dikaitkan kedua kosong; Pilih nilai yang lebih kecil; berfungsi untuk menyusun senarai dikaitkan dua kali ganda biotonik; Jika senarai kosong atau jika ia mengandungi satu nod tunggal; Jika benar, maka 'semasa' adalah nod pertama yang lebih kecil daripada nod sebelumnya; Pindah ke nod seterusnya; Jika benar, maka senarai sudah disusun; tumpah ke dalam dua senarai, satu bermula dengan 'kepala' dan yang lain bermula dengan 'semasa'; membalikkan senarai bermula dengan 'semasa'; Gabungkan kedua -dua senarai dan kembalikan senarai dikaitkan dua kali ganda; Berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Oleh kerana kita menambah pada mulanya, sebelum ini sentiasa batal; Pautan senarai lama dari nod baru; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Berfungsi untuk mencetak nod dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Program pemandu untuk menguji di atas; Buat senarai yang dipautkan dua kali: 2 <-> 5 <-> 7 <-> 10 <--> 6 <--> 4 <-> 1; Susun DLL Biotonik", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void reverse ( struct Node * * head_ref ) { struct Node * temp = NULL ; struct Node * current = * head_ref ; while ( current != NULL ) { temp = current -> prev ; current -> prev = current -> next ; current -> next = temp ; current = current -> prev ; } if ( temp != NULL ) * head_ref = temp -> prev ; } struct Node * merge ( struct Node * first , struct Node * second ) { if ( ! first ) return second ; if ( ! second ) return first ; if ( first -> data < second -> data ) { first -> next = merge ( first -> next , second ) ; first -> next -> prev = first ; first -> prev = NULL ; return first ; } else { second -> next = merge ( first , second -> next ) ; second -> next -> prev = second ; second -> prev = NULL ; return second ; } } struct Node * sort ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return head ; struct Node * current = head -> next ; while ( current != NULL ) { if ( current -> data < current -> prev -> data ) break ; current = current -> next ; } if ( current == NULL ) return head ; current -> prev -> next = NULL ; current -> prev = NULL ; reverse ( & current ) ; return merge ( head , current ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> prev = NULL ; new_node -> next = ( * head_ref ) ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } void printList ( struct Node * head ) { if ( head == NULL ) cout << \" Doubly ▁ Linked ▁ list ▁ empty \" ; while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 1 ) ; push ( & head , 4 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; push ( & head , 12 ) ; push ( & head , 7 ) ; push ( & head , 5 ) ; push ( & head , 2 ) ; cout << \" Original ▁ Doubly ▁ linked ▁ list : n \" ; printList ( head ) ; head = sort ( head ) ; cout << \" Doubly linked list after sorting : n \" ; printList ( head ) ; return 0 ; }"}
{"text": "Susun konsonan dan vokal nod dalam senarai yang dipautkan | Program C ++ untuk mengatur konsonan dan nod vokal dalam senarai yang dipautkan; Nod senarai yang dipautkan; Berfungsi untuk menambah nod baru ke senarai; fungsi utiliti untuk mencetak senarai yang dipautkan; fungsi utiliti untuk memeriksa vokal; berfungsi untuk mengatur konsonan dan nod vokal; untuk menjejaki vokal; senarai kosong; Kita perlu menemui vokal pertama dalam senarai. Ia akan menjadi kepala yang dikembalikan, dan juga Latarvowel awal. ; Unsur pertama adalah vokal. Ia juga akan menjadi kepala baru dan Latarvowel awal; ; Unsur pertama bukan vokal. Keluarkan melalui senarai sehingga kita dapati vokal. Perhatikan bahawa Curr menunjuk kepada elemen * sebelum * elemen dengan vokal. ; Ini adalah kes kelebihan di mana terdapat hanya konsonan dalam senarai. ; Tetapkan Latihan Awal dan kepala baru ke item vokal yang kami dapati. Relink rantai konsonan selepas item vokal itu: old_head_consonant -> consonant1 -> consonant2 -> vokal -> rest_of_list menjadi vokal -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list; Sekarang melintasi senarai. Curr sentiasa item * sebelum * yang kita periksa, supaya kita boleh menggunakannya untuk menghubungkan semula. ; Item yang ditemui seterusnya adalah vokal; Sekiranya ia datang secara langsung selepas vokal sebelumnya, kami tidak perlu memindahkan item di sekitar, hanya tandakan LatarVowel baru dan Advance Curr. ; Tetapi jika ia datang selepas rantaian konsonan intervensi, kita perlu mengikat vokal yang baru ditemui selepas vokal lama. Curr tidak berubah kerana selepas menghubungkannya akan mempunyai yang baru, yang belum diperiksa, dan kami sentiasa menyimpan Curr pada satu sebelum pemeriksaan seterusnya. ; Rantai dalam vokal baru; Advance Latestvowel; Keluarkan vokal yang dijumpai dari tempat sebelumnya; Re - Rantaian Konsonan Pautan Selepas Latihan Latihan; Tiada vokal dalam elemen seterusnya, Advance Curr. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; } ; Node * newNode ( char key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } void printlist ( Node * head ) { if ( ! head ) { cout << \" Empty ▁ List STRNEWLINE \" ; return ; } while ( head != NULL ) { cout << head -> data << \" ▁ \" ; if ( head -> next ) cout << \" - > ▁ \" ; head = head -> next ; } cout << endl ; } bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } Node * arrange ( Node * head ) { Node * newHead = head ; Node * latestVowel ; Node * curr = head ; if ( head == NULL ) return NULL ; if ( isVowel ( head -> data ) ) latestVowel = head ; else { while ( curr -> next != NULL && ! isVowel ( curr -> next -> data ) ) curr = curr -> next ; if ( curr -> next == NULL ) return head ; latestVowel = newHead = curr -> next ; curr -> next = curr -> next -> next ; latestVowel -> next = head ; } while ( curr != NULL && curr -> next != NULL ) { if ( isVowel ( curr -> next -> data ) ) { if ( curr == latestVowel ) { latestVowel = curr = curr -> next ; } else { Node * temp = latestVowel -> next ; latestVowel -> next = curr -> next ; latestVowel = latestVowel -> next ; curr -> next = curr -> next -> next ; latestVowel -> next = temp ; } } else { curr = curr -> next ; } } return newHead ; } int main ( ) { Node * head = newNode ( ' a ' ) ; head -> next = newNode ( ' b ' ) ; head -> next -> next = newNode ( ' c ' ) ; head -> next -> next -> next = newNode ( ' e ' ) ; head -> next -> next -> next -> next = newNode ( ' d ' ) ; head -> next -> next -> next -> next -> next = newNode ( ' o ' ) ; head -> next -> next -> next -> next -> next -> next = newNode ( ' x ' ) ; head -> next -> next -> next -> next -> next -> next -> next = newNode ( ' i ' ) ; printf ( \" Linked ▁ list ▁ before ▁ : STRNEWLINE \" ) ; printlist ( head ) ; head = arrange ( head ) ; printf ( \" Linked ▁ list ▁ after ▁ : STRNEWLINE \" ) ; printlist ( head ) ; return 0 ; }"}
{"text": "Elemen terbesar di BST menggunakan ruang tambahan yang berterusan | Kod CPP untuk mencari nod terbesar k - menggunakan O (1) memori tambahan dan membalikkan Morris Traversal. ; Struktur nod; fungsi penolong untuk membuat nod baru; Mengira pembolehubah untuk menyimpan kiraan nod yang dikunjungi; Jika anak yang betul adalah batal; kiraan kenaikan pertama dan semak jika Count = k; Jika tidak berpindah ke anak kiri; Cari pengganti inorder nod semasa; Tetapkan anak kiri pengganti ke nod semasa; gerakkan arus ke kanannya; memulihkan pokok itu kembali ke pokok carian binari asal yang mengeluarkan pautan berulir; gerakkan arus ke anak kiri; Pokok binari yang dibina adalah 4 / \\ 2 7 / \\ / \\ 1 3 6 10", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> right = temp -> left = NULL ; return temp ; } Node * KthLargestUsingMorrisTraversal ( Node * root , int k ) { Node * curr = root ; Node * Klargest = NULL ; int count = 0 ; while ( curr != NULL ) { if ( curr -> right == NULL ) { if ( ++ count == k ) Klargest = curr ; curr = curr -> left ; } else { Node * succ = curr -> right ; while ( succ -> left != NULL && succ -> left != curr ) succ = succ -> left ; if ( succ -> left == NULL ) { succ -> left = curr ; curr = curr -> right ; } else { succ -> left = NULL ; if ( ++ count == k ) Klargest = curr ; curr = curr -> left ; } } } return Klargest ; } int main ( ) { Node * root = newNode ( 4 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 10 ) ; cout << \" Finding ▁ K - th ▁ largest ▁ Node ▁ in ▁ BST ▁ : ▁ \" << KthLargestUsingMorrisTraversal ( root , 2 ) -> data ; return 0 ; }"}
{"text": "Penyusun baris matriks dalam urutan menaik diikuti oleh lajur dalam urutan menurun | C ++ pelaksanaan untuk menyusun baris matriks dalam urutan menaik diikuti dengan menyusun lajur dalam urutan menurun; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh menaik. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menurun. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ ] [ MAX_SIZE ] , int n , bool ascending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ascending ) sort ( mat [ i ] , mat [ i ] + n ) ; else sort ( mat [ i ] , mat [ i ] + n , greater < int > ( ) ) ; } } void transpose ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } void printMat ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 3 ; int mat [ n ] [ MAX_SIZE ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }"}
{"text": "Susun baris matriks | C ++ pelaksanaan untuk menyusun baris matriks - bijak dan lajur - bijak; berfungsi untuk menyusun setiap baris matriks; menyusun nombor baris 'i'; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; sekali lagi menyusun baris tikar [] []; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( mat [ i ] , mat [ i ] + n ) ; } void transpose ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; } void printMat ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int mat [ MAX_SIZE ] [ MAX_SIZE ] = { { 4 , 1 , 3 } , { 9 , 6 , 8 } , { 5 , 2 , 7 } } ; int n = 3 ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }"}
{"text": "Magic Square | Malah pesanan | Program C ++ untuk mencetak Magic Square dari urutan dua kali ganda; Fungsi untuk mengira Magic Square; Mengisi matriks dengan nilai kiraannya bermula dari 1; ; Tukar nilai elemen array di lokasi pembaikan seperti peraturan (n * n + 1) - arr [i] [j] sudut kiri atas matriks (perintah (n / 4) * (n / 4)); Sudut kanan atas matriks (perintah (n / 4) * (n / 4)); Sudut kiri bawah matriks (pesanan (n / 4) * (n / 4)); Sudut kanan bawah matriks (pesanan (n / 4) * (n / 4)); Pusat matriks (perintah (n / 2) * (n / 2)); Mencetak Magic - Square; program pemacu; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; void doublyEven ( int n ) { int arr [ n ] [ n ] , i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 3 * n / 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << arr [ i ] [ j ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 8 ; doublyEven ( n ) ; return 0 ; }"}
{"text": "Produk Kronecker Dua Matriks | C ++ kod untuk mencari produk Kronecker dua matriks dan menyimpannya sebagai matriks C; Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; cout << C [ i + l + 1 ] [ j + k + 1 ] << \" ▁ \" ; } } cout << endl ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga yang lebih rendah | Program untuk memeriksa matriks segi tiga yang lebih rendah. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga yang lebih rendah atau tidak. ; Fungsi pemacu. ; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ; if ( isLowerTriangularMatrix ( mat ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada matriks adalah segitiga atas | Program untuk memeriksa matriks segi tiga atas. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga atas atau tidak. ; Fungsi pemacu.", "code": "#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Mengira set 1 s dan 0 s dalam matriks binari | Program CPP untuk mengira bilangan set dalam matriks binari. ; tiada lajur; tiada baris; berfungsi untuk mengira bilangan set sel yang tidak kosong; menyimpan jawapan terakhir; Traverses Row - Bijaksana; Traverses Column Wise; Pada akhirnya tolak n * m kerana tiada set tunggal telah ditambah dua kali. ; Program Pemandu untuk menguji fungsi di atas.", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int m = 3 ; const int n = 2 ; long long countSets ( int a [ n ] [ m ] ) { long long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) a [ i ] [ j ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) a [ j ] [ i ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; } int main ( ) { int a [ ] [ 3 ] = { ( 1 , 0 , 1 ) , ( 0 , 1 , 0 ) } ; cout << countSets ( a ) ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod C ++ mudah untuk memeriksa matriks adalah simetri atau tidak. ; Mengisi transpose mat [n] [n] dalam tr [n] [n]; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; void transpose ( int mat [ ] [ MAX ] , int tr [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; } bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { int tr [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada matriks adalah simetri | Kod C ++ yang cekap untuk memeriksa matriks adalah simetri atau tidak. ; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk mencari normal dan jejak matriks | Program C ++ untuk mencari jejak dan normal matriks yang diberikan; Saiz matriks yang diberikan; Pulangan normal matriks saiz n x n; Mengembalikan jejak matriks saiz n x n; Sumber yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int findNormal ( int mat [ ] [ MAX ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return sqrt ( sum ) ; } int findTrace ( int mat [ ] [ MAX ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; cout << \" Trace ▁ of ▁ Matrix ▁ = ▁ \" << findTrace ( mat , 5 ) << endl ; cout << \" Normal ▁ of ▁ Matrix ▁ = ▁ \" << findNormal ( mat , 5 ) << endl ; return 0 ; }"}
{"text": "Penentu maksimum matriks dengan setiap nilai sama ada 0 atau n | Program C ++ untuk mencari penentu maksimum mungkin 0 / N matriks. ; Fungsi untuk penentu maksimum; Berfungsi untuk mencetak matriks resulatant; tiga kedudukan di mana 0 muncul; kedudukan di mana n muncul; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDet ( int n ) { return ( 2 * n * n * n ) ; } void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) cout << \"0 ▁ \" ; else if ( i == 1 && j == 0 ) cout << \"0 ▁ \" ; else if ( i == 2 && j == 1 ) cout << \"0 ▁ \" ; else cout << n << \" ▁ \" ; } cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 15 ; cout << \" Maximum ▁ Determinant ▁ = ▁ \" << maxDet ( n ) ; cout << \" Resultant Matrix : \" resMatrix ( n ) ; return 0 ; }"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan CPP kaedah naif untuk mengira nombor negatif dalam m [n] [m]; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; Tiada nombor negatif dalam baris ini; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }"}
{"text": "Kira nombor negatif dalam lajur | Pelaksanaan CPP kaedah yang cekap untuk mengira nombor negatif dalam m [n] [m]; Berfungsi untuk mengira nombor negatif; memulakan hasil; Mulakan dengan sudut kanan atas; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; J ialah indeks nombor negatif terakhir dalam baris ini. Jadi mesti ada (j + 1); Nombor negatif dalam baris ini. ; Pindah ke kiri dan lihat jika kita dapat mencari nombor negatif di sana; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }"}
{"text": "Kira nombor negatif dalam lajur | C ++ pelaksanaan kaedah yang lebih efisien untuk mengira bilangan nombor negatif dalam baris - matriks disusun lajur m [n] [m]; Carian binari rekursif untuk mendapatkan nilai negatif terakhir berturut -turut antara permulaan dan akhir; Kes asas; Dapatkan pertengahan untuk carian binari; Jika elemen semasa adalah negatif; Jika ia adalah elemen negatif paling kanan dalam baris semasa; Semak separuh kanan array; Semak di separuh kiri array; Fungsi untuk mengembalikan kiraan nombor negatif dalam matriks yang diberikan; Memulakan hasil; Untuk menyimpan indeks elemen negatif paling kanan dalam baris yang dipertimbangkan; Melangkah ke atas semua baris matriks; Jika elemen pertama baris semasa adalah positif maka tidak akan ada negatif dalam matriks di bawah atau selepas itu; Jalankan carian binari hanya sehingga indeks integer negatif terakhir dalam baris di atas; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLastNegativeIndex ( int array [ ] , int start , int end , int n ) { if ( start == end ) { return start ; } int mid = start + ( end - start ) / 2 ; if ( array [ mid ] < 0 ) { if ( mid + 1 < n && array [ mid + 1 ] >= 0 ) { return mid ; } return getLastNegativeIndex ( array , mid + 1 , end , n ) ; } else { return getLastNegativeIndex ( array , start , mid - 1 , n ) ; } } int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int nextEnd = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( M [ i ] [ 0 ] >= 0 ) { break ; } nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd , 4 ) ; count += nextEnd + 1 ; } return count ; } int main ( ) { int M [ ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; int r = 3 ; int c = 4 ; cout << ( countNegative ( M , r , c ) ) ; return 0 ; }"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah naif untuk mencari nilai maksimum MAT [d] [e] - ma [a] [b] seperti d> a dan e> b; Fungsi ini mengembalikan nilai maksimum a (d, e) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua d> a dan e> b. ; Kedai nilai maksimum; Pertimbangkan semua kemungkinan pasangan tikar [a] [b] dan mat [d] [e]; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << \" Maximum ▁ Value ▁ is ▁ \" << findMaxValue ( mat ) ; return 0 ; }"}
{"text": "Cari pasangan tertentu dalam Matrix | Kaedah yang cekap untuk mencari nilai maksimum MAT [d] - ma [a] [b] sedemikian rupa sehingga c> a dan d> b; Fungsi ini mengembalikan nilai maksimum a (c, d) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua c> a dan d> b. ; Kedai nilai maksimum; maxarr [i] [j] menyimpan max unsur -unsur dalam matriks dari (i, j) hingga (n - 1, n - 1); Elemen terakhir Maxarr akan menjadi sama seperti matriks input; Preprocess Last Row Inisialisasi Max; preprocess lajur terakhir memulakan max; PREPROCESS ROST OF MATRIX DARI BAWAH; Kemas kini MaxValue; Tetapkan Maxarr (i, j); Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; int maxArr [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << \" Maximum ▁ Value ▁ is ▁ \" << findMaxValue ( mat ) ; return 0 ; }"}
{"text": "Cetak semua elemen dalam susunan yang disusun dari baris dan lajur yang bijak matriks disusun | Program C ++ untuk mencetak semua elemen dalam susunan yang disusun dari baris dan lajur yang disusun dengan bijak; Fungsi utiliti untuk Youngify meja muda. Ini berbeza dengan Standard Youngify. Ia mengandaikan bahawa nilai pada MAT [0] [0] adalah tak terhingga. ; Cari nilai -nilai di bawah dan kanan tikar [i] [j]; Jika tikar [i] [j] adalah elemen sudut kanan, kembali; Gerakkan lebih kecil daripada dua nilai (downval dan rightval) ke tikar [i] [j] dan berulang untuk nilai yang lebih kecil; Fungsi utiliti untuk mengekstrak elemen minimum dari Tableau muda; Fungsi ini menggunakan ExtractMin () untuk mencetak elemen dalam urutan yang disusun; program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE #define N  4 NEW_LINE void youngify ( int mat [ ] [ N ] , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) return ; if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } } int extractMin ( int mat [ ] [ N ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; } void printSorted ( int mat [ ] [ N ] ) { cout << \" Elements ▁ of ▁ matrix ▁ in ▁ sorted ▁ order ▁ n \" ; for ( int i = 0 ; i < N * N ; i ++ ) cout << extractMin ( mat ) << \" ▁ \" ; } int main ( ) { int mat [ N ] [ N ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; printSorted ( mat ) ; return 0 ; }"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program C ++ yang mudah untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; Fungsi mudah untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; Nombor baris sel pertama dalam sub -persegi semasa saiz k x k; Lajur sel pertama dalam sub -persegi semasa saiz k x k; Hitung dan cetak jumlah sub -persegi semasa; Pemisah garis untuk sub -dataran bermula dengan baris seterusnya; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << \" ▁ \" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumSimple ( mat , k ) ; return 0 ; }"}
{"text": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program C ++ yang cekap untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; A o (n ^ 2) berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi yang diberikan saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; 1: Preprocessing untuk menyimpan jumlah semua jalur saiz k x 1; Pergi lajur mengikut lajur; Hitung jumlah pertama K x 1 segi empat tepat dalam lajur ini; Hitung jumlah segi empat tepat; 2: Kirakan jumlah sub - dataran menggunakan stripsum [] []; Hitung dan cetak jumlah Subsquare Pertama dalam baris ini; Kirakan jumlah kuadrat yang tinggal dalam baris semasa dengan mengeluarkan jalur paling kiri sub -persegi sebelumnya dan menambah jalur baru; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumTricky ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; int stripSum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; cout << sum << \" ▁ \" ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; cout << sum << \" ▁ \" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; return 0 ; }"}
{"text": "Program untuk mencari transpose matriks |  ; Fungsi ini menyimpan transpose a [] [] dalam b [] []; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define M  3 NEW_LINE #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } int main ( ) { int A [ M ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ N ] [ M ] , i , j ; transpose ( A , B ) ; printf ( \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) printf ( \" % d ▁ \" , B [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Program untuk mencari transpose matriks |  ; Menukarkan [] [] ke transposinya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; printf ( \" Modified ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , A [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program C ++ rekursif naif untuk mengira laluan dengan duit syiling 'k' yang tepat; Fungsi rekursif untuk mengira laluan dengan jumlah k dari (0, 0) hingga (m, n); Kes asas; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas PathCountrec (); Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int pathCountRec ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; } int pathCount ( int mat [ ] [ C ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; } int main ( ) { int k = 12 ; int mat [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; cout << pathCount ( mat , k ) ; return 0 ; }"}
{"text": "Bilangan Jalan dengan Koin Kata Tepat | Program C ++ berasaskan pengaturcaraan yang dinamik untuk mengira laluan dengan duit syiling 'k' yang tepat; Kes asas; Jika subproblem ini sudah diselesaikan; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Fungsi ini terutamanya memulakan dp [] [] [] dan memanggil PathCountDPrecdp (); Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE #define MAX_K  1000 NEW_LINE using namespace std ; int dp [ R ] [ C ] [ MAX_K ] ; int pathCountDPRecDP ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; if ( dp [ m ] [ n ] [ k ] != -1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } int pathCountDP ( int mat [ ] [ C ] , int k ) { memset ( dp , -1 , sizeof dp ) ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; } int main ( ) { int k = 12 ; int mat [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; cout << pathCountDP ( mat , k ) ; return 0 ; }"}
{"text": "Susun Matriks yang Diberikan | C ++ pelaksanaan untuk menyusun matriks yang diberikan; berfungsi untuk menyusun matriks yang diberikan; matriks sementara saiz n ^ 2; Salin unsur -unsur matriks satu demi satu ke temp []; Susun temp []; Salin unsur -unsur temp [] satu demi satu dalam tikar [] []; berfungsi untuk mencetak matriks yang diberikan; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  10 NEW_LINE void sortMat ( int mat [ SIZE ] [ SIZE ] , int n ) { int temp [ n * n ] ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i ] [ j ] ; sort ( temp , temp + k ) ; k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = temp [ k ++ ] ; } void printMat ( int mat [ SIZE ] [ SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int n = 3 ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMat ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }"}
{"text": "Pemilihan jenis | Program C ++ untuk pelaksanaan pilihan pemilihan; fungsi swap; Susun fungsi; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; selectionSort ( arr , n ) ; cout << \" Sorted ▁ array : ▁ STRNEWLINE \" ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Bubble sort | Pelaksanaan yang dioptimumkan dari Bubble Sort; Versi bubble yang dioptimumkan; swap arr [j] dan arr [j + 1]; Jika tidak ada dua elemen yang ditukar dengan gelung dalaman, kemudian pecah; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void bubbleSort ( int arr [ ] , int n ) { int i , j ; bool swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( & arr [ j ] , & arr [ j + 1 ] ) ; swapped = true ; } } if ( swapped == false ) break ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" n \" ) ; } int main ( ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bubbleSort ( arr , n ) ; printf ( \" Sorted ▁ array : ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Cari K Elemen yang paling dekat dengan nilai yang diberikan |  ; Fungsi untuk mencari titik silang (titik sebelum ini adalah lebih kecil daripada atau sama dengan x dan selepas itu lebih besar daripada x); Kes asas X lebih besar daripada semua; X lebih kecil daripada semua; Cari titik tengah; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Fungsi ini mencetak elemen yang paling dekat dengan x dalam arr []. n ialah bilangan elemen dalam arr []; Cari titik crossover; Indeks yang betul untuk mencari; Untuk menjejaki kiraan elemen yang telah dicetak; Jika x hadir dalam arr [], maka mengurangkan asumsi indeks kiri: semua elemen dalam arr [] adalah berbeza; Bandingkan unsur -unsur di kiri dan kanan titik crossover untuk mencari unsur -unsur yang paling dekat; Jika tidak ada lagi elemen di sebelah kanan, maka cetak elemen kiri; Sekiranya tidak ada lagi elemen di sebelah kiri, maka cetak elemen kanan; Program pemacu untuk menyemak fungsi di atas", "code": "#include <stdio.h> NEW_LINE int findCrossOver ( int arr [ ] , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; } void printKclosest ( int arr [ ] , int x , int k , int n ) { int l = findCrossOver ( arr , 0 , n - 1 , x ) ; int r = l + 1 ; int count = 0 ; if ( arr [ l ] == x ) l -- ; while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) printf ( \" % d ▁ \" , arr [ l -- ] ) ; else printf ( \" % d ▁ \" , arr [ r ++ ] ) ; count ++ ; } while ( count < k && l >= 0 ) printf ( \" % d ▁ \" , arr [ l -- ] ) , count ++ ; while ( count < k && r < n ) printf ( \" % d ▁ \" , arr [ r ++ ] ) , count ++ ; } int main ( ) { int arr [ ] = { 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 35 , k = 4 ; printKclosest ( arr , x , 4 , n ) ; return 0 ; }"}
{"text": "Perubahan duit syiling | DP | Program C Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d ▁ \" , count ( arr , m , 4 ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Perubahan duit syiling | DP | Pengaturcaraan dinamik C ++ pelaksanaan masalah perubahan duit syiling; Jadual [i] akan menyimpan bilangan penyelesaian untuk nilai i. Kami memerlukan baris n + 1 kerana jadual dibina dengan cara bawah menggunakan kes asas (n = 0); Kes asas (jika diberi nilai adalah 0); Pilih semua duit syiling satu demi satu dan kemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai duit syiling yang dipilih", "code": "#include <bits/stdc++.h> NEW_LINE int count ( int S [ ] , int m , int n ) { int table [ n + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }"}
{"text": "Pendaraban rantai matriks | DP | Program C ++ menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 100 ] ; int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( dp , -1 , sizeof dp ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , n ) ; }"}
{"text": "Pendaraban rantai matriks | DP | Lihat buku Cormen untuk butiran algoritma berikut; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam M [] []. 0 bar dan lajur 0 M [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , size ) ; getchar ( ) ; return 0 ; }"}
{"text": "Memotong batang | DP | Penyelesaian rekursif naif untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Recursif memotong batang dalam kepingan yang berbeza dan membandingkan konfigurasi yang berbeza; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ % dn \" , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ % dn \" , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Memotong batang | DP | Program CPP untuk pendekatan di atas; Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << \" Maximum ▁ obtained ▁ value ▁ is ▁ \" << un_kp ( price , length , n , Max_len ) << endl ; }"}
{"text": "Multiply dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung | Program C ++ untuk membiak dua integer tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung; berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; kes di mana y adalah negatif; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; class GFG { public : int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } } ; int main ( ) { GFG g ; cout << endl << g . multiply ( 5 , -11 ) ; getchar ( ) ; return 0 ; }"}
{"text": "Sieve of Eratosthenes | Program C ++ untuk mencetak semua prima yang lebih kecil daripada atau sama dengan N menggunakan penapis eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan. ; Cetak semua nombor utama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) cout << p << \" ▁ \" ; } int main ( ) { int n = 30 ; cout << \" Following ▁ are ▁ the ▁ prime ▁ numbers ▁ smaller ▁ \" << \" ▁ than ▁ or ▁ equal ▁ to ▁ \" << n << endl ; SieveOfEratosthenes ( n ) ; return 0 ; }"}
{"text": "Segitiga Pascal | C ++ kod untuk segitiga Pascal; BinomialCoeff; Berfungsi untuk mencetak garisan N pertama dari segitiga Pascal; Berulang melalui setiap baris dan cetak penyertaan di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Program Pemandu", "code": "#include <stdio.h> NEW_LINE int binomialCoeff ( int n , int k ) ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } void printPascal ( int n ) { for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) printf ( \" % d ▁ \" , binomialCoeff ( line , i ) ) ; printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int n = 7 ; printPascal ( n ) ; return 0 ; }"}
{"text": "Segitiga Pascal | Program C ++ untuk Pascals Triangle; A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga PSCAL yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai -nilai lain adalah jumlah nilai di atas dan kiri di atas; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << \" ▁ \" ; } cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }"}
{"text": "Segitiga Pascal | Program C ++ untuk Pascals Segitiga A O (N ^ 2) Masa dan O (1) Fungsi Ruang Tambahan untuk Segitiga Pascal; digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << \" ▁ \" ; C = C * ( line - i ) / i ; } cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }"}
{"text": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | Program C ++ untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { cout << Add ( 15 , 32 ) ; return 0 ; }"}
{"text": "Mengira Bahagian Modulus dengan Kuasa |  ; Fungsi ini akan kembali n % d. D mestilah salah satu: 1, 2, 4, 8, 16, 32, ...; Kod pemacu; D mesti menjadi kuasa 2", "code": "#include <stdio.h> NEW_LINE unsigned int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; } int main ( ) { unsigned int n = 6 ; unsigned int d = 4 ; printf ( \" % u ▁ moduo ▁ % u ▁ is ▁ % u \" , n , d , getModulo ( n , d ) ) ; getchar ( ) ; return 0 ; }"}
{"text": "Count set bit dalam integer | Program C ++ untuk mengira set bit dalam integer; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Program untuk menguji fungsi countsetbits", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; cout << countSetBits ( i ) ; return 0 ; }"}
{"text": "Count set bit dalam integer | Pelaksanaan CPP untuk pendekatan rekursif untuk mencari bilangan bit yang ditetapkan menggunakan algoritma Brian Kernighans; fungsi rekursif untuk mengira set bit; Kes asas; kod pemacu; Dapatkan nilai dari pengguna; fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } int main ( ) { int n = 9 ; cout << countSetBits ( n ) ; return 0 ; }"}
{"text": "Count set bit dalam integer | C ++ pelaksanaan pendekatan; Jadual carian; Berfungsi untuk memulakan jadual carian; Pada mulanya menjana jadual algoritma; Berfungsi untuk mengembalikan kiraan bit set dalam n; Kod pemacu; Memulakan jadual carian", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int BitsSetTable256 [ 256 ] ; void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } } int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; } int main ( ) { initialize ( ) ; int n = 9 ; cout << countSetBits ( n ) ; }"}
{"text": "Count set bit dalam integer | Program C ++ untuk menunjukkan __builtin_popcount (); Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { cout << __builtin_popcount ( 4 ) << endl ; cout << __builtin_popcount ( 15 ) ; return 0 ; }"}
{"text": "Count set bit dalam integer | Program C ++ untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int num_to_bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } int main ( ) { int num = 31 ; cout << countSetBitsRec ( num ) ; return 0 ; }"}
{"text": "Count set bit dalam integer |  ; Semak setiap bit dalam nombor ditetapkan atau tidak dan kembalikan jumlah kiraan bit yang ditetapkan. ; (1 << i) = pow (2, i); Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; } int main ( ) { int N = 15 ; cout << countSetBits ( N ) << endl ; return 0 ; }"}
{"text": "Program untuk mencari pariti | Program C ++ untuk mencari pariti integer; Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Program Pemandu untuk Menguji GetParity ()", "code": "# include <bits/stdc++.h> NEW_LINE # define bool  int NEW_LINE using namespace std ; bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; cout << \" Parity ▁ of ▁ no ▁ \" << n << \" ▁ = ▁ \" << ( getParity ( n ) ? \" odd \" : \" even \" ) ; getchar ( ) ; return 0 ; }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program C ++ untuk mencari sama ada NO adalah kuasa dua; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << \" Yes \" << endl : cout << \" No \" << endl ; isPowerOfTwo ( 64 ) ? cout << \" Yes \" << endl : cout << \" No \" << endl ; return 0 ; }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; isPowerOfTwo ( 64 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua | Program C ++ untuk pendekatan di atas; Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Kod pemacu; Benar; Palsu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << \" True \" << endl ; else cout << \" False \" << endl ; if ( powerOf2 ( m ) == 1 ) cout << \" True \" << endl ; else cout << \" False \" << endl ; }"}
{"text": "Program untuk mencari sama ada tidak ada kuasa dua |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; isPowerOfTwo ( 64 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }"}
{"text": "Cari nombor pengulangan maksimum dalam O (n) masa dan O (1) ruang tambahan | Program C ++ untuk mencari nombor pengulangan maksimum; Mengembalikan elemen berulang maksimum dalam ARR [0. n - 1]. Unsur -unsur array berada dalam jarak dari 0 hingga k - 1; Berulang walaupun array input, untuk setiap elemen arr [i], kenaikan arr [arr [i] % k] oleh k; Cari indeks elemen berulang maksimum; Indeks pulangan elemen maksimum; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; cout << \" The ▁ maximum ▁ repeating ▁ number ▁ is ▁ \" << maxRepeating ( arr , n , k ) << endl ; return 0 ; }"}
{"text": "Pertanyaan pelbagai pada array yang setiap elemen adalah xor nilai indeks dan elemen sebelumnya | Program CPP untuk menyelesaikan pertanyaan pelbagai pada array yang setiap elemennya adalah XOR nilai indeks dan elemen sebelumnya. ; Fungsi pulangan nilai formula yang diperolehi. ; Mencari nilai XOR julat [y ... x]; Fungsi untuk menyelesaikan pertanyaan untuk l dan r. ; jika l atau r ialah 0 .; Mencari X boleh dibahagikan dengan 2 atau tidak. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( x %= 2 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) cout << ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) << endl ; } int main ( ) { int q = 3 ; int l [ ] = { 2 , 2 , 5 } ; int r [ ] = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; return 0 ; }"}
{"text": "Pertanyaan pada Xor pembahagi ganjil yang paling hebat dari julat |  ; Precompute awalan xor pembahagi ganjil yang paling besar; Mencari pembahagi ganjil yang paling besar; Mencari awalan xor; Kembali xor julat; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; } int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int preXOR [ n ] ; prefixXOR ( arr , preXOR , n ) ; cout << query ( preXOR , 0 , 2 ) << endl ; cout << query ( preXOR , 1 , 2 ) << endl ; return 0 ; }"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari | C ++ kod untuk mencari bilangan swap minimum untuk menyusun array binari; Fungsi untuk mencari swap minimum untuk menyusun pelbagai 0 s dan 1 s. ; Array untuk menyimpan kiraan sifar; Kira bilangan sifar di sebelah kanan setiap satu. ; Kira jumlah swap dengan menambahkan bilangan sifar di sebelah kanan setiap satu. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ n ] ; memset ( noOfZeroes , 0 , sizeof ( noOfZeroes ) ) ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSwaps ( arr , n ) ; return 0 ; }"}
{"text": "Swap bersebelahan minimum diperlukan untuk menyusun array binari |  ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; cout << minswaps ( arr , 9 ) ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada array disusun atau tidak (berulang dan rekursif) | Program C ++ untuk memeriksa sama ada array disusun atau tidak; Fungsi yang pulih benar jika array disusun dalam perintah yang tidak menurun. ; Array mempunyai satu atau tiada elemen; Pasangan yang tidak disusun dijumpai; Tiada pasangan yang tidak disusun dijumpai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( arraySortedOrNot ( arr , n ) ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; }"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Program C ++ untuk mencari dua elemen yang ganjil; Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan XOR semua elemen di arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana mudah diperoleh; Sekarang bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << \" The ▁ two ▁ ODD ▁ elements ▁ are ▁ \" << x << \" ▁ & ▁ \" << y ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }"}
{"text": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Program C ++ untuk mencari dua elemen yang ganjil; Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Buat peta dan hitung kekerapan array * elemen menggunakan array. ; Melintasi peta dan periksa jika elemen kedua yang kekerapannya ganjil atau tidak. Kemudian ini adalah elemen yang ganjil. Ia jelas disebut dalam masalah bahawa hanya terdapat dua elemen yang ganjil sehingga ini akan mencetak kedua -dua elemen tersebut. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) { m [ arr [ i ] ] ++ ; } cout << \" The ▁ two ▁ ODD ▁ elements ▁ are ▁ \" ; for ( auto & x : m ) { if ( x . second % 2 != 0 ) cout << x . first << \" , ▁ \" ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }"}
{"text": "Cari pasangan dengan perbezaan yang diberikan | Program C ++ untuk mencari pasangan dengan perbezaan yang diberikan; Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << \" Pair ▁ Found : ▁ ( \" << arr [ i ] << \" , ▁ \" << arr [ j ] << \" ) \" ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << \" No ▁ such ▁ pair \" ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 60 ; findPair ( arr , size , n ) ; return 0 ; }"}
{"text": "Cari K Unsur Maksimum Array dalam Perintah Asal | Program C ++ untuk mencari unsur maksimum array dalam urutan asal; Berfungsi untuk mencetak elemen maksimum; vektor untuk menyimpan salinan array asal; Menyusun vektor dalam urutan menurun. Sila rujuk pautan di bawah untuk butiran www. Geeksforgeeks. org / sort - c - stl / https :; Melintasi array asal dan mencetak semua unsur -unsur yang berada dalam k vektor yang disusun pertama. goo. GL / 44 RWGT Sila rujuk https: untuk butiran binary_search (); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMax ( int arr [ ] , int k , int n ) { vector < int > brr ( arr , arr + n ) ; sort ( brr . begin ( ) , brr . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) if ( binary_search ( brr . begin ( ) , brr . begin ( ) + k , arr [ i ] , greater < int > ( ) ) ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printMax ( arr , k , n ) ; return 0 ; }"}
{"text": "Cetak n elemen terkecil dari array yang diberikan dalam urutan asal mereka | CPP untuk mencetak nombor N terkecil dalam urutan; Berfungsi untuk mencetak nombor N terkecil; Buat salinan Array; Susun Arahan Salin; Bagi setiap arr [i] mendapati sama ada ia adalah sebahagian daripada N - terkecil dengan carian binari; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSmall ( int arr [ ] , int asize , int n ) { vector < int > copy_arr ( arr , arr + asize ) ; sort ( copy_arr . begin ( ) , copy_arr . begin ( ) + asize ) ; for ( int i = 0 ; i < asize ; ++ i ) if ( binary_search ( copy_arr . begin ( ) , copy_arr . begin ( ) + n , arr [ i ] ) ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 5 ; printSmall ( arr , asize , n ) ; return 0 ; }"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Program C ++ untuk memeriksa sama ada array yang diberikan boleh membentuk perkembangan aritmetik; Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; return 0 ; }"}
{"text": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Program C ++ untuk memeriksa sama ada array yang diberikan boleh membentuk perkembangan aritmetik; Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Cari yang terkecil dan kemas kini kedua terkecil; Cari kedua terkecil; Semak sama ada elemen pendua yang dijumpai atau tidak; Jika pendua dijumpai kemudian kembali palsu; Cari perbezaan antara terkecil dan kedua terkecil; Seperti yang kita telah menggunakan terkecil terkecil dan kedua, jadi kita hanya perlu menyemak unsur -unsur n - 2; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { unordered_map < int , int > hm ; int smallest = INT_MAX , second_smallest = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < smallest ) { second_smallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] != smallest && arr [ i ] < second_smallest ) second_smallest = arr [ i ] ; if ( hm . find ( arr [ i ] ) == hm . end ( ) ) hm [ arr [ i ] ] ++ ; else return false ; } int diff = second_smallest - smallest ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( hm . find ( second_smallest ) == hm . end ( ) ) return false ; second_smallest += diff ; } return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; return 0 ; }"}
{"text": "Kira cara memilih pasangan dengan perbezaan maksimum | Kod CPP untuk mencari tidak. cara memilih pasangan dengan perbezaan maksimum; Untuk mencari minimum dan maksimum array; untuk mencari kiraan elemen minimum dan maksimum; Kiraan pembolehubah; keadaan untuk semua elemen sama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { int mn = INT_MAX ; int mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( mn , a [ i ] ) ; mx = max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } int main ( ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }"}
{"text": "Susun semula senarai yang dipautkan dalam | C ++ kod untuk menyusun semula senarai yang dipautkan di tempat; Fungsi untuk menyusun semula senarai yang dipautkan dengan nilai tinggi dan rendah. ; Kes asas. ; Pembolehubah dua penunjuk. ; Fungsi swap untuk menukar data. ; Fungsi swap untuk menukar data. ; Fungsi untuk memasukkan nod dalam senarai yang dipautkan pada mulanya. ; Fungsi untuk memaparkan nod senarai yang dipautkan. ; kod pemacu; Biarkan membuat senarai yang dipautkan. 9 -> 6 -> 8 -> 3 -> 7", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * next ; } ; typedef struct node Node ; void rearrange ( Node * head ) { if ( head == NULL ) return ; Node * prev = head , * curr = head -> next ; while ( curr ) { if ( prev -> data > curr -> data ) swap ( prev -> data , curr -> data ) ; if ( curr -> next && curr -> next -> data > curr -> data ) swap ( curr -> next -> data , curr -> data ) ; prev = curr -> next ; if ( ! curr -> next ) break ; curr = curr -> next -> next ; } } void push ( Node * * head , int k ) { Node * tem = ( Node * ) malloc ( sizeof ( Node ) ) ; tem -> data = k ; tem -> next = * head ; * head = tem ; } void display ( Node * head ) { Node * curr = head ; while ( curr != NULL ) { printf ( \" % d ▁ \" , curr -> data ) ; curr = curr -> next ; } } int main ( ) { Node * head = NULL ; push ( & head , 7 ) ; push ( & head , 3 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 9 ) ; rearrange ( head ) ; display ( head ) ; return 0 ; }"}
{"text": "Kurangkan dua nombor yang diwakili sebagai senarai yang dipautkan | Program C ++ untuk menolak senarai bernilai yang lebih kecil dari senarai bernilai yang lebih besar dan hasil pulangan sebagai senarai. ; Nod senarai yang dipautkan; Fungsi utiliti untuk mendapatkan panjang senarai yang dipautkan; Utiliti yang sifar Padds di hadapan nod, dengan perbezaan yang diberikan; Kurangkan Helper LinkedList adalah fungsi rekursif, bergerak sehingga nod terakhir, dan tolak digit dan buat nod dan kembalikan nod. Jika D1 <D2, kami meminjam nombor dari digit sebelumnya. ; Jika anda telah memberikan nilai nilai kepada digit seterusnya maka kurangkan D1 dengan 1; Jika D1 <D2, kemudian pinjam nombor dari digit sebelumnya. Tambah 10 hingga D1 dan set Borrow = true; ; tolak digit; Buat nod dengan sub nilai; Tetapkan penunjuk seterusnya seperti sebelumnya; API ini menolak dua senarai yang dipautkan dan mengembalikan senarai yang dipautkan yang akan mempunyai hasil yang dikurangkan. ; Kes asas. ; Dalam kedua -dua kes itu, dapatkan panjang kedua -dua senarai yang dipautkan. ; Jika panjang berbeza, hitung nod yang lebih kecil dan sifar PADD untuk nod yang lebih kecil dan pastikan kedua -dua nod yang lebih besar dan nod yang lebih kecil mempunyai panjang yang sama. ; Jika kedua -dua senarai panjang adalah sama, maka hitung senarai yang lebih besar dan lebih kecil. Jika 5 - 6 - 7 & 5 - 6 - 8 adalah senarai yang dipautkan, kemudian berjalan melalui senarai yang dipautkan pada nod terakhir sebagai 7 <8, nod yang lebih besar adalah 5 - 6 - 8 dan nod yang lebih kecil ialah 5 - 6 - 7 .; Setelah mengira nod yang lebih besar dan lebih kecil, call tolakLinkedListHelper yang mengembalikan senarai yang dipautkan. ; Fungsi utiliti untuk mencetak senarai yang dipautkan; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> next = NULL ; return temp ; } int getLength ( Node * Node ) { int size = 0 ; while ( Node != NULL ) { Node = Node -> next ; size ++ ; } return size ; } Node * paddZeros ( Node * sNode , int diff ) { if ( sNode == NULL ) return NULL ; Node * zHead = newNode ( 0 ) ; diff -- ; Node * temp = zHead ; while ( diff -- ) { temp -> next = newNode ( 0 ) ; temp = temp -> next ; } temp -> next = sNode ; return zHead ; } Node * subtractLinkedListHelper ( Node * l1 , Node * l2 , bool & borrow ) { if ( l1 == NULL && l2 == NULL && borrow == 0 ) return NULL ; Node * previous = subtractLinkedListHelper ( l1 ? l1 -> next : NULL , l2 ? l2 -> next : NULL , borrow ) ; int d1 = l1 -> data ; int d2 = l2 -> data ; int sub = 0 ; if ( borrow ) { d1 -- ; borrow = false ; } if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; } sub = d1 - d2 ; Node * current = newNode ( sub ) ; current -> next = previous ; return current ; } Node * subtractLinkedList ( Node * l1 , Node * l2 ) { if ( l1 == NULL && l2 == NULL ) return NULL ; int len1 = getLength ( l1 ) ; int len2 = getLength ( l2 ) ; Node * lNode = NULL , * sNode = NULL ; Node * temp1 = l1 ; Node * temp2 = l2 ; if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , abs ( len1 - len2 ) ) ; } else { while ( l1 && l2 ) { if ( l1 -> data != l2 -> data ) { lNode = l1 -> data > l2 -> data ? temp1 : temp2 ; sNode = l1 -> data > l2 -> data ? temp2 : temp1 ; break ; } l1 = l1 -> next ; l2 = l2 -> next ; } } bool borrow = false ; return subtractLinkedListHelper ( lNode , sNode , borrow ) ; } void printList ( struct Node * Node ) { while ( Node != NULL ) { printf ( \" % d ▁ \" , Node -> data ) ; Node = Node -> next ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { Node * head1 = newNode ( 1 ) ; head1 -> next = newNode ( 0 ) ; head1 -> next -> next = newNode ( 0 ) ; Node * head2 = newNode ( 1 ) ; Node * result = subtractLinkedList ( head1 , head2 ) ; printList ( result ) ; return 0 ; }"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | C ++ pelaksanaan untuk memasukkan nod di tengah -tengah senarai yang dipautkan; struktur nod; berfungsi untuk membuat dan mengembalikan nod; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Kirakan panjang senarai yang dipautkan, i. e, bilangan nod; 'mengira' bilangan nod yang selepas nod baru dimasukkan; 'PTR' menunjuk ke nod yang mana nod baru dimasukkan; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Program pemandu untuk menguji di atas; Membuat Senarai 1 -> 2 -> 4 -> 5", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAtMid ( Node * * head_ref , int x ) { if ( * head_ref == NULL ) * head_ref = getNode ( x ) ; else { Node * newNode = getNode ( x ) ; Node * ptr = * head_ref ; int len = 0 ; while ( ptr != NULL ) { len ++ ; ptr = ptr -> next ; } int count = ( ( len % 2 ) == 0 ) ? ( len / 2 ) : ( len + 1 ) / 2 ; ptr = * head_ref ; while ( count -- > 1 ) ptr = ptr -> next ; newNode -> next = ptr -> next ; ptr -> next = newNode ; } } void display ( Node * head ) { while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } int main ( ) { Node * head = NULL ; head = getNode ( 1 ) ; head -> next = getNode ( 2 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; cout << \" Linked ▁ list ▁ before ▁ insertion : ▁ \" ; display ( head ) ; int x = 3 ; insertAtMid ( & head , x ) ; cout << \" Linked list after insertion : \" display ( head ) ; return 0 ; }"}
{"text": "Masukkan nod ke tengah senarai yang dipautkan | C ++ pelaksanaan untuk memasukkan nod di tengah -tengah senarai yang dipautkan; struktur nod; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Berikan nilai kepada petunjuk yang perlahan dan cepat; gerakkan penunjuk perlahan ke nod seterusnya; Pindahkan penunjuk cepat dua nod pada satu masa; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Program pemandu untuk menguji di atas; Membuat Senarai 1 -> 2 -> 4 -> 5", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAtMid ( Node * * head_ref , int x ) { if ( * head_ref == NULL ) * head_ref = getNode ( x ) ; else { Node * newNode = getNode ( x ) ; Node * slow = * head_ref ; Node * fast = ( * head_ref ) -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } newNode -> next = slow -> next ; slow -> next = newNode ; } } void display ( Node * head ) { while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } int main ( ) { Node * head = NULL ; head = getNode ( 1 ) ; head -> next = getNode ( 2 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; cout << \" Linked ▁ list ▁ before ▁ insertion : ▁ \" ; display ( head ) ; int x = 3 ; insertAtMid ( & head , x ) ; cout << \" Linked list after insertion : \" display ( head ) ; return 0 ; }"}
{"text": "SENARAI SENSI UNTUK SENARAI DUBLY LINKED | C ++ pelaksanaan untuk memasukkan sort pada senarai dikaitkan dua kali ganda; Nod senarai dikaitkan dua kali ganda; berfungsi untuk membuat dan mengembalikan nod baru senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; berfungsi untuk memasukkan nod baru dalam cara yang disusun dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Jika nod dimasukkan pada permulaan senarai dikaitkan dua kali ganda; cari nod yang selepas itu nod baru dimasukkan; Membuat pautan yang sesuai; Jika nod baru tidak dimasukkan pada akhir senarai; Fungsi untuk menyusun senarai yang dikaitkan dua kali menggunakan jenis penyisipan; Inisialisasi 'disusun' - senarai dikaitkan dua kali ganda yang disusun; Melintasi senarai dikaitkan dua kali ganda dan masukkan setiap nod untuk 'disusun'; Simpan seterusnya untuk lelaran seterusnya; Mengeluarkan semua pautan untuk membuat 'semasa' sebagai nod baru untuk dimasukkan; Masukkan arus dalam senarai dikaitkan 'disusun'; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun dua kali ganda; berfungsi untuk mencetak senarai dikaitkan dua kali ganda; berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Buat seterusnya nod baru sebagai kepala dan sebelumnya sebagai batal; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Program pemandu untuk menguji di atas; Mulakan dengan senarai dikaitkan dua kali ganda; Masukkan data berikut", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * prev , * next ; } ; struct Node * getNode ( int data ) { struct Node * newNode = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; newNode -> data = data ; newNode -> prev = newNode -> next = NULL ; return newNode ; } void sortedInsert ( struct Node * * head_ref , struct Node * newNode ) { struct Node * current ; if ( * head_ref == NULL ) * head_ref = newNode ; else if ( ( * head_ref ) -> data >= newNode -> data ) { newNode -> next = * head_ref ; newNode -> next -> prev = newNode ; * head_ref = newNode ; } else { current = * head_ref ; while ( current -> next != NULL && current -> next -> data < newNode -> data ) current = current -> next ; newNode -> next = current -> next ; if ( current -> next != NULL ) newNode -> next -> prev = newNode ; current -> next = newNode ; newNode -> prev = current ; } } void insertionSort ( struct Node * * head_ref ) { struct Node * sorted = NULL ; struct Node * current = * head_ref ; while ( current != NULL ) { struct Node * next = current -> next ; current -> prev = current -> next = NULL ; sortedInsert ( & sorted , current ) ; current = next ; } * head_ref = sorted ; } void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; push ( & head , 9 ) ; push ( & head , 3 ) ; push ( & head , 5 ) ; push ( & head , 10 ) ; push ( & head , 12 ) ; push ( & head , 8 ) ; cout << \" Doubly ▁ Linked ▁ List ▁ Before ▁ Sortingn \" ; printList ( head ) ; insertionSort ( & head ) ; cout << \" nDoubly ▁ Linked ▁ List ▁ After ▁ Sortingn \" ; printList ( head ) ; return 0 ; }"}
{"text": "Cetak semua kemungkinan putaran array yang diberikan | Program C ++ untuk mencetak semua kemungkinan putaran array yang diberikan; Perisytiharan Global Array; Fungsi untuk membalikkan array antara indeks S dan E; Berfungsi untuk menjana semua kemungkinan putaran array; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int arr [ 10000 ] ; void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } } void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } } int main ( ) { arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; cout << ( \" [ \" ) ; for ( int j = 0 ; j < 4 ; j ++ ) { cout << ( arr [ j ] ) << \" , ▁ \" ; } cout << ( \" ] \" ) ; } }"}
{"text": "Cari jumlah array menggunakan bitwise atau selepas memisahkan array yang diberikan dalam dua bahagian selepas pergeseran bulat k | Program C ++ untuk mencari bitwise atau dua bahagian yang sama dengan array selepas melakukan peralihan bulat kanan K; Array untuk menyimpan pokok segmen; Berfungsi untuk membina pokok segmen; Berfungsi untuk mengembalikan atau unsur -unsur dalam julat [l, r]; Semak keadaan terikat; Cari tengah julat; Berulang untuk semua elemen dalam pelbagai; Berfungsi untuk mencari atau jumlah; Berfungsi untuk membina pokok segmen; Gelung untuk mengendalikan pertanyaan Q; Bilangan peralihan bulat yang betul; Atau separuh kedua array [n / 2 - i, n - 1 - i]; Atau separuh pertama array [n - i, n - 1] atau [0, n / 2 - 1 - i]; Cetak jawapan akhir untuk pertanyaan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE const int MAX = 100005 ; using namespace std ; int seg [ 4 * MAX ] ; void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end or r < start ) return 0 ; if ( start <= l and r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } void orsum ( int a [ ] , int n , int q , int k [ ] ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; cout << temp << endl ; } } int main ( ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int q = 2 ; int k [ q ] = { 4 , 2 } ; orsum ( a , n , q , k ) ; return 0 ; }"}
{"text": "Memaksimumkan kiraan unsur -unsur yang sama dalam tatasusunan yang diberikan oleh putaran | C ++ program pendekatan di atas; Fungsi yang mencetak elemen maksimum yang sama; Vektor untuk menyimpan indeks elemen array b; Menyimpan kedudukan array b; Arahan frekuensi untuk mengekalkan unsur -unsur dengan perbezaan yang sama dalam jarak; Melangkah melalui semua elemen dalam ARR1 []; Kirakan bilangan peralihan yang diperlukan untuk menjadikan elemen semasa sama; Jika D kurang daripada 0; Simpan kekerapan perbezaan semasa; Kirakan kekerapan maksimum yang disimpan; Mencetak bilangan maksimum elemen yang sama; Kod pemacu; Diberikan dua tatasusunan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumEqual ( int a [ ] , int b [ ] , int n ) { vector < int > store ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } vector < int > ans ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = max ( finalans , ans [ i ] ) ; cout << finalans << \" STRNEWLINE \" ; } int main ( ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximumEqual ( A , B , size ) ; return 0 ; }"}
{"text": "Arahan cetak selepas ia betul -betul diputar k kali | C ++ pelaksanaan putaran kanan array k bilangan kali; Berfungsi untuk array rightrotate; Jika putaran lebih besar daripada saiz array; Mencetak elemen kth paling kanan; Cetak array selepas elemen 'k'; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { cout << a [ n + i - k ] << \" ▁ \" ; } else { cout << ( a [ i - k ] ) << \" ▁ \" ; } } cout << \" STRNEWLINE \" ; } int main ( ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( Array ) / sizeof ( Array [ 0 ] ) ; int K = 2 ; RightRotate ( Array , N , K ) ; }"}
{"text": "Sort Array Disusun Berputar | C ++ pelaksanaan untuk memulihkan jenis asal dalam array yang disusun diputar; Berfungsi untuk memulihkan jenis asal; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , arr + i + 1 ) ; reverse ( arr + i + 1 , arr + n ) ; reverse ( arr , arr + n ) ; } } } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Sort Array Disusun Berputar | C ++ pelaksanaan untuk memulihkan jenis asal dalam array disusun yang diputar menggunakan carian binari; Fungsi untuk mencari indeks permulaan array; Berfungsi untuk memulihkan jenis asal; Array sudah disusun; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return -1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) return mid + 1 ; if ( arr [ mid - 1 ] > arr [ mid ] ) return mid ; if ( arr [ low ] > arr [ mid ] ) return findStartIndexOfArray ( arr , low , mid - 1 ) ; else return findStartIndexOfArray ( arr , mid + 1 , high ) ; } void restoreSortedArray ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) return ; int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; reverse ( arr , arr + start ) ; reverse ( arr + start , arr + n ) ; reverse ( arr , arr + n ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Putaran kiri dan putaran kanan rentetan | Program C untuk putaran kiri dan putaran kanan rentetan; Di tempat berputar ke kiri oleh D; Di - tempat berputar ke kanan oleh D; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftrotate ( string & s , int d ) { reverse ( s . begin ( ) , s . begin ( ) + d ) ; reverse ( s . begin ( ) + d , s . end ( ) ) ; reverse ( s . begin ( ) , s . end ( ) ) ; } void rightrotate ( string & s , int d ) { leftrotate ( s , s . length ( ) - d ) ; } int main ( ) { string str1 = \" GeeksforGeeks \" ; leftrotate ( str1 , 2 ) ; cout << str1 << endl ; string str2 = \" GeeksforGeeks \" ; rightrotate ( str2 , 2 ) ; cout << str2 << endl ; return 0 ; }"}
{"text": "Cari elemen dalam Senarai Berkaitan Pekeliling Ganda | Program C ++ untuk menggambarkan memasukkan nod dalam senarai dikaitkan dua kali ganda dalam mengemis, akhir dan tengah; Struktur nod; Berfungsi untuk memasukkan nod pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir; Buat nod secara dinamik; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Berfungsi untuk memaparkan senarai dikaitkan dua kali ganda; Berfungsi untuk mencari elemen tertentu dari senarai; Mengisytiharkan pemboleh ubah temp; Mengisytiharkan pemboleh ubah kawalan lain untuk mencari; Jika permulaan adalah NULL RETURN - 1; Gerakkan penunjuk temp sehingga, temp -> seterusnya tidak bergerak alamat permulaan (fesyen bulat); Kiraan kenaikan lokasi; Jika didapati menaikkan bendera dan memecahkan gelung; Penunjuk suhu kenaikan; Semak sama ada elemen terakhir dalam kandungan senarai nilai jika mengandungi, menaikkan bendera dan kiraan kenaikan; Jika bendera adalah benar, maka unsur dijumpai, lain tidak; Kod pemacu; Mulakan dengan senarai kosong; Masukkan 4. Jadi senarai yang dipautkan menjadi 4 -> null; Masukkan 5. Jadi senarai yang dipautkan menjadi 4 -> 5; Masukkan 7. Jadi senarai yang dipautkan menjadi 4 -> 5 -> 7; Masukkan 8. Jadi senarai yang dipautkan menjadi 4 -> 5 -> 7 -> 8; Masukkan 6. Jadi senarai yang dipautkan menjadi 4 -> 5 -> 7 -> 8 -> 6", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void insertNode ( struct Node * * start , int value ) { if ( * start == NULL ) { struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = new_node -> prev = new_node ; * start = new_node ; return ; } Node * last = ( * start ) -> prev ; struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = * start ; ( * start ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } void displayList ( struct Node * start ) { struct Node * temp = start ; while ( temp -> next != start ) { printf ( \" % d ▁ \" , temp -> data ) ; temp = temp -> next ; } printf ( \" % d ▁ \" , temp -> data ) ; } int searchList ( struct Node * start , int search ) { struct Node * temp = start ; int count = 0 , flag = 0 , value ; if ( temp == NULL ) return -1 ; else { while ( temp -> next != start ) { count ++ ; if ( temp -> data == search ) { flag = 1 ; count -- ; break ; } temp = temp -> next ; } if ( temp -> data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) cout << \" STRNEWLINE \" << search << \" ▁ found ▁ at ▁ location ▁ \" << count << endl ; else cout << \" STRNEWLINE \" << search << \" ▁ not ▁ found \" << endl ; } } int main ( ) { struct Node * start = NULL ; insertNode ( & start , 4 ) ; insertNode ( & start , 5 ) ; insertNode ( & start , 7 ) ; insertNode ( & start , 8 ) ; insertNode ( & start , 6 ) ; printf ( \" Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ \" ) ; displayList ( start ) ; searchList ( start , 5 ) ; return 0 ; }"}
{"text": "Membalikkan senarai dikaitkan bulat berganda | C ++ pelaksanaan untuk mengulangi senarai dikaitkan bulat dua kali ganda; struktur nod senarai yang dipautkan; berfungsi untuk membuat dan mengembalikan nod baru; Berfungsi untuk memasukkan pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Fungsi uitlity untuk mengulangi senarai dikaitkan bulat dua kali ganda; Memulakan penunjuk kepala baru; Dapatkan penunjuk ke nod terakhir; Tetapkan 'curr' ke nod terakhir; senarai melintasi arah ke belakang; Masukkan 'curr' pada akhir senarai bermula dengan penunjuk 'baru _ kepala'; penunjuk kepala senarai terbalik; berfungsi untuk memaparkan senarai bulat berganda dalam arah ke hadapan dan ke belakang; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next , * prev ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; return newNode ; } void insertEnd ( Node * * head , Node * new_node ) { if ( * head == NULL ) { new_node -> next = new_node -> prev = new_node ; * head = new_node ; return ; } Node * last = ( * head ) -> prev ; new_node -> next = * head ; ( * head ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } Node * reverse ( Node * head ) { if ( ! head ) return NULL ; Node * new_head = NULL ; Node * last = head -> prev ; Node * curr = last , * prev ; while ( curr -> prev != last ) { prev = curr -> prev ; insertEnd ( & new_head , curr ) ; curr = prev ; } insertEnd ( & new_head , curr ) ; return new_head ; } void display ( Node * head ) { if ( ! head ) return ; Node * temp = head ; cout << \" Forward ▁ direction : ▁ \" ; while ( temp -> next != head ) { cout << temp -> data << \" ▁ \" ; temp = temp -> next ; } cout << temp -> data ; Node * last = head -> prev ; temp = last ; cout << \" Backward direction : \" while ( temp -> prev != last ) { cout << temp -> data << \" ▁ \" ; temp = temp -> prev ; } cout << temp -> data ; } int main ( ) { Node * head = NULL ; insertEnd ( & head , getNode ( 1 ) ) ; insertEnd ( & head , getNode ( 2 ) ) ; insertEnd ( & head , getNode ( 3 ) ) ; insertEnd ( & head , getNode ( 4 ) ) ; insertEnd ( & head , getNode ( 5 ) ) ; cout << \" Current ▁ list : STRNEWLINE \" ; display ( head ) ; head = reverse ( head ) ; cout << \" Reversed list : \" display ( head ) ; return 0 ; }"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Pelaksanaan C ++ naif untuk mencari LCA di dalam pokok; Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; menandakan ibu bapa untuk setiap nod; menandakan kedalaman untuk setiap nod; propogating menandakan pokok itu; nod dummy; precalclating 1) kedalaman. 2) ibu bapa. untuk setiap nod; Kerumitan masa: O (ketinggian pokok) secara rekursif melompat satu nod di atas sehingga kedua -dua nod menjadi sama; Fungsi pemacu untuk memanggil fungsi di atas; Menambah tepi ke pokok", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1001 NEW_LINE int depth [ MAXN ] ; int parent [ MAXN ] ; vector < int > adj [ MAXN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } void preprocess ( ) { depth [ 0 ] = -1 ; dfs ( 1 , 0 ) ; } int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; } int main ( int argc , char const * argv [ ] ) { addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; cout << \" LCA ( 11,8 ) ▁ : ▁ \" << LCANaive ( 11 , 8 ) << endl ; cout << \" LCA ( 3,13 ) ▁ : ▁ \" << LCANaive ( 3 , 13 ) << endl ; return 0 ; }"}
{"text": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Program C ++ untuk mencari LCA menggunakan penguraian SQRT; blok saiz = sqrt (ketinggian); Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; Kedai nenek moyang pertama di blok sebelumnya; mempraktikkan parameter yang diperlukan yang berkaitan dengan setiap nod; menandakan kedalaman node cur; menandakan ibu bapa node cur; membuat jump_parent node cur; Jika ia adalah nod pertama blok maka jump_parentnya adalah ibu bapa yang curnya; Jika bukan nod pertama blok ini maka jump_parentnya adalah jump_parent ibu bapanya; propogating menandakan subtree; menggunakan helah penguraian SQRT; mengekalkan kedalaman [v]> kedalaman [u]; Mendaki ke ibu bapa melompatnya; u dan v mempunyai jump_parent yang sama; precalclating 1) kedalaman. 2) ibu bapa. 3) Jump_parent untuk setiap nod; Fungsi pemacu untuk memanggil fungsi di atas; Menambah tepi ke pokok; Di sini kita terus mengambil ketinggian = 4 mengikut pokok yang diberikan tetapi kita boleh mengira ketinggian = kedalaman maksimum dalam satu lagi dfs", "code": "#include \" iostream \" NEW_LINE #include \" vector \" NEW_LINE #include \" math . h \" NEW_LINE using namespace std ; #define MAXN  1001 NEW_LINE int block_sz ; int depth [ MAXN ] ; int parent [ MAXN ] ; int jump_parent [ MAXN ] ; vector < int > adj [ MAXN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; } void dfs ( int cur , int prev ) { depth [ cur ] = depth [ prev ] + 1 ; parent [ cur ] = prev ; if ( depth [ cur ] % block_sz == 0 ) jump_parent [ cur ] = parent [ cur ] ; else jump_parent [ cur ] = jump_parent [ prev ] ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; ++ i ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } int LCASQRT ( int u , int v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = jump_parent [ v ] ; } return LCANaive ( u , v ) ; } void preprocess ( int height ) { block_sz = sqrt ( height ) ; depth [ 0 ] = -1 ; dfs ( 1 , 0 ) ; } int main ( int argc , char const * argv [ ] ) { addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; int height = 4 ; preprocess ( height ) ; cout << \" LCA ( 11,8 ) ▁ : ▁ \" << LCASQRT ( 11 , 8 ) << endl ; cout << \" LCA ( 3,13 ) ▁ : ▁ \" << LCASQRT ( 3 , 13 ) << endl ; return 0 ; }"}
{"text": "Bilangan ujian yang dijangkakan untuk mendapatkan kepala berturut -turut n | C ++ pelaksanaan pendekatan di atas; Kod pemacu; Formula untuk bilangan laluan untuk kepala berturut -turut n", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; int main ( ) { int N = 3 ; cout << pow ( 2 , N + 1 ) - 2 ; return 0 ; }"}
{"text": "Cari dan kirakan jumlah faktor Co | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n] dalam masa yang berterusan; Kirakan kiraan nombor yang boleh dibahagikan dengan A dalam julat [1, n]; Kirakan kiraan nombor yang boleh dibahagi dengan b dalam julat [1, n]; Menambah tuduhan yang boleh dibahagikan oleh A dan B; Nilai di atas mungkin mengandungi nilai berulang yang boleh dibahagikan oleh kedua -dua A dan B. Oleh itu, kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B ditemui; Kiraan yang dikira di atas dikurangkan untuk mengira kiraan akhir; Berfungsi untuk mengembalikan jumlah nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n]; Tetapkan untuk menyimpan nombor supaya nombor tidak diulang; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk melangkah melalui set dan cari jumlahnya; Kod pemacu", "code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <set> NEW_LINE #define ll  long long NEW_LINE using namespace std ; ll int countOfNum ( ll int n , ll int a , ll int b ) { ll int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; } ll int sumOfNum ( ll int n , ll int a , ll int b ) { ll int i ; ll int sum = 0 ; set < ll int > ans ; for ( i = a ; i <= n ; i = i + a ) { ans . insert ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . insert ( i ) ; } for ( auto it = ans . begin ( ) ; it != ans . end ( ) ; it ++ ) { sum = sum + * it ; } return sum ; } int main ( ) { ll int N = 88 ; ll int A = 11 ; ll int B = 8 ; ll int count = countOfNum ( N , A , B ) ; ll int sumofnum = sumOfNum ( N , A , B ) ; cout << sumofnum % count << endl ; return 0 ; }"}
{"text": "Cari nilai julat ungkapan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai ungkapan yang diberikan; Nilai istilah pertama; Nilai istilah terakhir; Kod pemacu; Dapatkan hasilnya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } int main ( ) { int L = 6 , R = 12 ; double ans = get ( L , R ) ; cout << fixed << setprecision ( 2 ) << ans ; return 0 ; }"}
{"text": "Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 dalam perwakilan binari itu | C ++ pelaksanaan pendekatan; Untuk menyimpan bilangan bulat pra -dikira; Fungsi yang mengembalikan benar jika perwakilan binari x mengandungi 1 s; Untuk menyimpan sedikit sebelumnya; Semak sama ada bit sebelumnya dan bit semasa adalah kedua -dua 1; Mengemas kini sedikit sebelumnya; Pergi ke bit seterusnya; Fungsi untuk pra - mengira nombor yang sah dari 0 hingga maksimum; Simpan semua nombor yang tidak mempunyai 1 s berturut -turut; Berfungsi untuk mengembalikan nombor minimum yang lebih besar daripada n yang tidak mengandungi 1 s berturut -turut; Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 s; Berfungsi untuk melakukan pertanyaan; Kod pemacu; Pra - mengira nombor; Lakukan pertanyaan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; vector < int > v ; int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 and p == 1 ) return true ; p = x % 2 ; x /= 2 ; } return false ; } void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( ! consecutiveOnes ( i ) ) v . push_back ( i ) ; } } int nextValid ( int n ) { int it = upper_bound ( v . begin ( ) , v . end ( ) , n ) - v . begin ( ) ; int val = v [ it ] ; return val ; } void performQueries ( int queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) cout << nextValid ( queries [ i ] ) << \" STRNEWLINE \" ; } int main ( ) { int queries [ ] = { 4 , 6 } ; int q = sizeof ( queries ) / sizeof ( int ) ; preCompute ( ) ; performQueries ( queries , q ) ; return 0 ; }"}
{"text": "Operasi minimum yang diperlukan untuk menukar rentetan binari yang diberikan kepada semua 1 s | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan operasi yang diperlukan; CTR akan menyimpan bilangan yang berturut -turut pada akhir rentetan binari yang diberikan; Gelung untuk mencari bilangan 1 s pada akhir rentetan; Jika watak semasa adalah 1; Jika kita menghadapi 0 pertama dari kedudukan LSB maka kita akan memecahkan gelung; Bilangan operasi yang diperlukan ialah (L - CTR); Berfungsi untuk mengeluarkan sifar utama dari rentetan; Gelung sehingga S [i] menjadi tidak sama dengan 1; Jika kita sampai ke hujung rentetan, ini bermakna rentetan hanya mengandungi 0 's; Kembalikan rentetan tanpa nol utama; Kod pemacu; Mengeluarkan sifar terkemuka", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int changeToOnes ( string str ) { int i , l , ctr = 0 ; l = str . length ( ) ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) ctr ++ ; else break ; } return l - ctr ; } string removeZeroesFromFront ( string str ) { string s ; int i = 0 ; while ( i < str . length ( ) && str [ i ] == '0' ) i ++ ; if ( i == str . length ( ) ) s = \"0\" ; else s = str . substr ( i , str . length ( ) - i ) ; return s ; } int main ( ) { string str = \"10010111\" ; str = removeZeroesFromFront ( str ) ; cout << changeToOnes ( str ) ; return 0 ; }"}
{"text": "Penghapusan minimum diperlukan sedemikian rupa sehingga mana -mana nombor x akan berlaku tepat x kali | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan penghapusan minimum yang diperlukan; Untuk menyimpan kekerapan elemen array; Kekerapan kedai setiap elemen; Untuk menyimpan penghapusan minimum yang diperlukan; Nilai; Kekerapan itu; Jika bilangan kurang daripada atau sama dengan kekerapannya; Padam kejadian tambahan; Padam setiap kejadian x; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinDeletion ( int a [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ a [ i ] ] ++ ; int ans = 0 ; for ( auto i : map ) { int x = i . first ; int frequency = i . second ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } int main ( ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinDeletion ( a , n ) ; return 0 ; }"}
{"text": "Rentetan concatenate dalam apa -apa perintah untuk mendapatkan bilangan maksimum \"ab\" | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum abs; Pembolehubah A, B, AB untuk mengira rentetan yang berakhir dengan 'A' tetapi tidak berakhir dengan 'B', 'B' tetapi tidak berakhir dengan 'A' dan 'B' dan berakhir dengan 'A' masing -masing. ; 'Ab' sudah ada dalam rentetan sebelum menggabungkan mereka; Count rentetan yang bermula dengan 'B' dan berakhir dengan 'A; Count rentetan yang bermula dengan 'B' tetapi tidak berakhir dengan 'A'; Count rentetan yang berakhir dengan 'a' tetapi tidak berakhir dengan 'b'; mengemas kini nilai ANS dan menambah kiraan tambahan 'ab'; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCountAB ( string s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . at ( j ) == ' A ' && S . at ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . at ( 0 ) == ' B ' && S . at ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . at ( 0 ) == ' B ' ) B ++ ; else if ( S . at ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; } int main ( ) { string s [ ] = { \" ABCA \" , \" BOOK \" , \" BAND \" } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; cout << maxCountAB ( s , n ) ; return 0 ; }"}
{"text": "Operasi minimum untuk membuat jumlah elemen jiran <= x | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan jumlah operasi yang diperlukan; Mula -mula membuat semua elemen sama dengan x yang lebih besar; Kiri mengimbas array; Kemas kini elemen semasa supaya jumlah jiran adalah <x; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperations ( int n , int x , int * arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } int main ( ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << MinOperations ( N , X , arr ) ; return 0 ; }"}
{"text": "Cari nombor berulang dan nombor yang hilang menggunakan dua persamaan | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak nombor yang diperlukan; Jumlah nombor semulajadi n pertama; Jumlah kuadrat nombor semulajadi n pertama; Untuk menyimpan jumlah dan jumlah kuadrat unsur -unsur array; Kod pemacu", "code": "#include <cmath> NEW_LINE #include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq = sumSq + ( pow ( arr [ i ] , 2 ) ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; cout << \" A ▁ = ▁ \" ; cout << A << endl ; cout << \" B ▁ = ▁ \" ; cout << B << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findNumbers ( arr , n ) ; return 0 ; }"}
{"text": "Rentetan terkecil lexicographically dengan rentetan yang diberikan sebagai awalan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari sama ada temp rentetan bermula dengan STR atau tidak; Kes asas; Semak aksara yang sepadan dalam temp & str; Berfungsi untuk mencari rentetan terkecil lexicographic yang terdiri daripada string str as awalan; Susun rentetan array yang diberikan []; Jika rentetan i - th mengandungi rentetan yang diberikan sebagai awalan, maka cetak hasilnya; Jika tiada rentetan wujud maka kembali \" - 1\"; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_prefix ( string temp , string str ) { if ( temp . length ( ) < str . length ( ) ) return 0 ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != temp [ i ] ) return 0 ; } return 1 ; } } string lexicographicallyString ( string input [ ] , int n , string str ) { sort ( input , input + n ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return \" - 1\" ; } int main ( ) { string arr [ ] = { \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" } ; string S = \" app \" ; int N = 5 ; cout << lexicographicallyString ( arr , N , S ) ; return 0 ; }"}
{"text": "Susun semula Arahan untuk mencari K menggunakan algoritma carian binari tanpa menyusun | Program C ++ untuk pendekatan di atas; Berfungsi untuk menyusun semula array; Menyimpan array yang disusun semula; Kedai sama ada pengaturan itu mungkin atau tidak; Kemas kini k dengan kedudukan k; Menyimpan semua elemen yang lebih rendah daripada dan lebih besar daripada vektor yang lebih kecil dan lebih besar masing -masing; Melintasi array arr []; Jika arr [i] kurang daripada arr [k]; Lain; Iterat Unil Low kurang daripada atau sama dengan tinggi; Kedai pertengahan titik; Jika pertengahan adalah sama dengan k; Jika pertengahan kurang daripada k; Jika pertengahan lebih besar daripada k; Jika f adalah - 1; Melangkah dalam julat [1, n]; Jika Ans [i] sama dengan - 1; Cetak array yang disusun semula; Kod pemacu; Input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Rearrange ( int arr [ ] , int K , int N ) { int ans [ N + 1 ] ; int f = -1 ; for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = -1 ; } K = find ( arr , arr + N , K ) - arr ; vector < int > smaller , greater ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ K ] ) smaller . push_back ( arr [ i ] ) ; else if ( arr [ i ] > arr [ K ] ) greater . push_back ( arr [ i ] ) ; } int low = 0 , high = N - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; } else if ( mid < K ) { if ( smaller . size ( ) == 0 ) { break ; } ans [ mid ] = smaller . back ( ) ; smaller . pop_back ( ) ; low = mid + 1 ; } else { if ( greater . size ( ) == 0 ) { break ; } ans [ mid ] = greater . back ( ) ; greater . pop_back ( ) ; high = mid - 1 ; } } if ( f == -1 ) { cout << -1 << endl ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ans [ i ] == -1 ) { if ( smaller . size ( ) ) { ans [ i ] = smaller . back ( ) ; smaller . pop_back ( ) ; } else if ( greater . size ( ) ) { ans [ i ] = greater . back ( ) ; greater . pop_back ( ) ; } } } for ( int i = 0 ; i < N ; i ++ ) cout << ans [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 10 , 7 , 2 , 5 , 3 , 8 } ; int K = 7 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Rearrange ( arr , K , N ) ; return 0 ; }"}
{"text": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; ITERATE K dari [1, n]; Jumlah gula -gula; Gula -gula yang diambil oleh orang 1; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array arr []; Jumlah yang digunakan oleh orang j; Mengemas kini bilangan gula -gula; Bahagian yang baik dari gula -gula yang dicapai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumK ( vector < int > & arr , int M , int N ) { int good = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { cout << i ; return ; } } } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , M , N ) ; return 0 ; }"}
{"text": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nilai pertengahan memberikan sekurang -kurangnya (n / (m + 1)) gula -gula atau tidak; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array yang diberikan; Jumlah yang digunakan oleh orang j; Mengemas kini kiraan gula -gula; Semak sama ada orang 1 mendapat bahagian yang baik dari gula -gula; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; Melangkah sehingga rendah kurang dari atau sama dengan pertengahan; Cari nilai pertengahan; Semak pertengahan, sama ada ia boleh menjadi nilai k atau tidak; Kemas kini nilai hi; Jika tidak, kemas kini nilai LO; Cetak nilai minimum yang dihasilkan k; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int K , int n , int m , vector < int > arr , int good_share ) { int candies = n , taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < m ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } return ( taken >= good_share ) ; } void minimumK ( vector < int > & arr , int N , int M ) { int good_share = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; int lo = 1 , hi = N ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( mid , N , M , arr , good_share ) ) { hi = mid ; } else { lo = mid + 1 ; } } cout << hi ; } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , N , M ) ; return 0 ; }"}
{"text": "Jumlah masa yang diperlukan untuk mengembara jalan yang dilambangkan oleh rentetan yang diberikan | C ++ kod untuk pendekatan di atas; Fungsi untuk mengira masa yang diambil untuk perjalanan jalan; Kedai jumlah masa; Kedudukan awal; Kedai -kedai melawat segmen; Semak sama ada segmen hadir dalam set; Meningkatkan nilai masa dengan 2; Masukkan segmen ke dalam set; Cetak nilai masa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void calcTotalTime ( string path ) { int time = 0 ; int x = 0 , y = 0 ; set < pair < int , int > > s ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { int p = x ; int q = y ; if ( path [ i ] == ' N ' ) y ++ ; else if ( path [ i ] == ' S ' ) y -- ; else if ( path [ i ] == ' E ' ) x ++ ; else if ( path [ i ] == ' W ' ) x -- ; if ( s . find ( { p + x , q + y } ) == s . end ( ) ) { time += 2 ; s . insert ( { p + x , q + y } ) ; } else time += 1 ; } cout << time << endl ; } int main ( ) { string path = \" NSE \" ; calcTotalTime ( path ) ; return 0 ; }"}
{"text": "Kos yang diperlukan untuk menjadikan semua elemen array sama dengan 1 | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kos yang diperlukan untuk membuat semua elemen array sama dengan 1; Menyimpan jumlah kos; Melintasi array arr []; Jika elemen semasa ialah 0; Tukar 0 hingga 1; Tambah kos; Mengembalikan jumlah kos; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCost ( arr , N ) ; return 0 ; }"}
{"text": "Cari indeks puncak array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari indeks puncak untuk array yang diberikan; Kes asas; Semak array yang semakin meningkat; Sekiranya keadaan yang semakin meningkat dilanggar, maka pecah; Menyimpan nilai i, yang merupakan indeks puncak yang berpotensi; Traversal kedua, untuk array yang ketat; Apabila keadaan ketat yang dikurangkan dilanggar, kemudian pecah; Jika i = n - 1, ini bermakna bahawa ANS adalah indeks puncak; Jika tidak, indeks puncak tidak wujud; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int peakIndex ( int arr [ ] , int N ) { if ( N < 3 ) return -1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return -1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return -1 ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << peakIndex ( arr , N ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Memandangkan array A [] dan nombor x, periksa pasangan dalam [] dengan jumlah sebagai x | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan; Menyusun array dalam peningkatan urutan; Melintasi array, nums []; Simpan nombor yang diperlukan untuk dijumpai; Melakukan carian binari; Simpan nilai pertengahan; Jika nums [mid] lebih besar daripada x, maka kemas kini tinggi hingga pertengahan - 1; Jika Nums [Mid] kurang daripada X, maka kemas kini rendah hingga pertengahan + 1; Jika tidak; Jika pertengahan adalah sama i, periksa pertengahan - 1 dan pertengahan + 1; Jika tidak, cetak pasangan dan kembali; Jika tidak ada pasangan yang dijumpai, maka cetak - 1; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void hasArrayTwoPairs ( int nums [ ] , int n , int target ) { sort ( nums , nums + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { cout << nums [ i ] << \" , ▁ \" ; cout << nums [ mid - 1 ] ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { cout << nums [ i ] << \" , ▁ \" ; cout << nums [ mid + 1 ] ; return ; } break ; } else { cout << nums [ i ] << \" , ▁ \" ; cout << nums [ mid ] ; return ; } } } } cout << -1 ; } int main ( ) { int A [ ] = { 0 , -1 , 2 , -3 , 1 } ; int X = -2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; hasArrayTwoPairs ( A , N , X ) ; return 0 ; }"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pembahagi n paling dekat dengan sasaran; Berulang sehingga akar persegi n; Semak jika pembahagi adalah sama; Semak jika saya adalah yang paling dekat; Semak jika saya adalah yang paling dekat; Semak jika N / I adalah yang paling dekat; Cetak nilai terdekat; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findClosest ( int N , int target ) { int closest = -1 ; int diff = INT_MAX ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } } else { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } if ( abs ( target - N / i ) < diff ) { diff = abs ( target - N / i ) ; closest = N / i ; } } } } cout << closest ; } int main ( ) { int N = 16 , X = 5 ; findClosest ( N , X ) ; return 0 ; }"}
{"text": "Cari pasangan (a, b) seperti AA + BB = n | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kuasa minimum a dan b lebih besar daripada n; Menyimpan kuasa A yang lebih besar daripada n; Kiraan kenaikan sebanyak 1; Bahagikan n oleh A; Fungsi untuk mencari pasangan (a, b) sedemikian rupa sehingga a ^ a + b ^ b = n; Kirakan kuasa minimum yang lebih besar daripada n; Kirakan kuasa minimum B lebih besar daripada N; Buat salinan A dan B; Melintasi setiap pasangan (i, j); Semak jika B ^ j + a ^ i = n untuk mengatasi masalah limpahan Gunakan b = n - a bukan b + a = n; Kuasa kenaikan B oleh 1; Kuasa kenaikan A sebanyak 1; Akhirnya cetak - 1 jika tiada pasangan dijumpai; Kod pemacu; Diberikan A, B dan N; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( long long int A , long long int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N ) { count ++ ; N /= A ; } return count ; } void Pairs ( long long int N , long long int A , long long int B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; long long int intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { cout << i << \" ▁ \" << j << endl ; return ; } B *= intialB ; } A *= intialA ; } cout << -1 << endl ; return ; } int main ( ) { long long int N = 106 , A = 3 , B = 5 ; Pairs ( N , A , B ) ; return 0 ; }"}
{"text": "Mengira nombor dari julat tertentu yang tidak dapat dibahagikan oleh mana -mana elemen array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari gandaan bukan sehingga k; Menyimpan semua gandaan yang unik; Melelehkan array; Untuk mencari pendua sekali sahaja; Memasukkan semua gandaan ke dalam set; Kembali hanya kiraan nombor yang tidak dapat dibahagikan oleh mana -mana elemen array; Berfungsi untuk mengira jumlah nilai dalam julat [l, r]; Mengira semua nilai dalam julat menggunakan prinsip pengecualian; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNonMultiples ( int arr [ ] , int n , int k ) { set < int > multiples ; for ( int i = 0 ; i < n ; ++ i ) { if ( multiples . find ( arr [ i ] ) == multiples . end ( ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . insert ( arr [ i ] * j ) ; } } } return k - multiples . size ( ) ; } int countValues ( int arr [ ] , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 1 , R = 20 ; cout << countValues ( arr , N , L , R ) ; return 0 ; }"}
{"text": "Bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir di paling banyak jam | | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir dalam jam H; Menyimpan syiling minimum untuk dikeluarkan setiap jam; Cari elemen array maksimum; Melakukan carian binari; Simpan nilai pertengahan julat dalam k; Cari jumlah masa yang diambil untuk mengosongkan n buasir dengan mengeluarkan sy syiling sejam; Jika jumlah masa tidak melebihi h; Jika tidak; Cetak hasil yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCollectingSpeed ( vector < int > & piles , int H ) { int ans = -1 ; int low = 1 , high ; high = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } cout << ans ; } int main ( ) { vector < int > arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; return 0 ; }"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Susun array; Kedai indeks penunjuk kiri; Kedai indeks penunjuk yang betul; Hitung kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Jika jumlah pasangan semasa adalah sama dengan k; Keluarkan elemen array duplikat berturut -turut; Kemas kini i; Keluarkan elemen array duplikat berturut -turut; Kemas kini j; Kemas kini CNTPairs; Kemas kini i; Kemas kini j; jika jumlah pasangan semasa kurang daripada k; Kemas kini i; Kemas kini j; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; sort ( arr , arr + N ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }"}
{"text": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Kekerapan kedai setiap elemen yang berbeza dari array; Kemas kini kekerapan ARR [i]; Melintasi peta; Menyimpan nilai utama peta; Jika saya adalah separuh daripada k; Jika kekerapan saya lebih besar daripada 1; Kemas kini CNTPairs; Kemas kini CNTPairs; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; unordered_map < int , int > cntFre ; for ( int i = 0 ; i < N ; i ++ ) { cntFre [ arr [ i ] ] ++ ; } for ( auto it : cntFre ) { int i = it . first ; if ( 2 * i == K ) { if ( cntFre [ i ] > 1 ) cntPairs += 2 ; } else { if ( cntFre [ K - i ] ) { cntPairs += 1 ; } } } cntPairs = cntPairs / 2 ; return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari panjang seterusnya yang paling lama supaya tidak ada dua elemen bersebelahan yang sama; Gantikan elemen pada indeks x dengan y; Oleh kerana x adalah 1 - diindeks, penurunan x oleh 1; Jejaki bilangan elemen dalam masa depan; Jika elemen sebelumnya tidak sama dengan elemen semasa; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } cout << count << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }"}
{"text": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program C ++ untuk pendekatan di atas; Melintasi array arr []; Jika elemen sebelumnya tidak sama dengan elemen semasa; Melintasi pertanyaan; Gantikan elemen pada indeks x dengan y; Mengira semula untuk Indeks X; Tolak sumbangan elemen pada indeks x; Tambah sumbangan y; Mengira semula untuk indeks x + 1; Tolak sumbangan elemen pada indeks x + 1; Menambah sumbangan y; Menggantikan elemen; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } cout << count << ' ▁ ' ; arr [ x - 1 ] = y ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }"}
{"text": "Jumlah perbezaan mutlak indeks kejadian setiap elemen array | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari jumlah perbezaan indeks kejadian setiap elemen array yang unik; Menyimpan indeks setiap elemen array; Simpan indeks; Menyimpan jumlahnya; Melintasi array; Cari jumlah untuk setiap elemen; Melangkah ke atas peta; Hitung jumlah kejadian ARR [i]; Simpan jumlah untuk elemen semasa; Cetak jawapan untuk setiap elemen; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sum ( int arr [ ] , int n ) { map < int , vector < int > > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] . push_back ( i ) ; } int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( auto it : mp [ arr [ i ] ] ) { sum += abs ( it - i ) ; } ans [ i ] = sum ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << \" ▁ \" ; } return ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum ( arr , n ) ; return 0 ; }"}
{"text": "Tukar vokal ke dalam watak kes atas dalam rentetan yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menukar vokal menjadi huruf besar; Menyimpan panjang str; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string conVowUpp ( string & str ) { int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { str [ i ] = str [ i ] - ' a ' + ' A ' ; } } return str ; } int main ( ) { string str = \" eutopia \" ; cout << conVowUpp ( str ) ; }"}
{"text": "Memaksimumkan bilangan hari yang mana c coklat boleh diedarkan secara berturut -turut kepada orang -orang n | Program C ++ untuk melaksanakan pendekatan di atas; Menyimpan kekerapan setiap jenis coklat; Fungsi untuk memeriksa sama ada coklat boleh dimakan untuk 'pertengahan' tidak. hari; Jika CNT melebihi n, kembali benar; Berfungsi untuk mencari bilangan maksimum hari yang mana coklat boleh dimakan; Simpan kekerapan setiap jenis coklat; Memulakan permulaan dan berakhir dengan 0 dan P masing -masing; Hitung pertengahan; Semak jika coklat boleh diedarkan selama pertengahan hari; Semak jika coklat boleh diedarkan selama lebih dari pertengahan hari berturut -turut; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > mp ; int N , P ; bool helper ( int mid ) { int cnt = 0 ; for ( auto i : mp ) { int temp = i . second ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; } int findMaximumDays ( int arr [ ] ) { for ( int i = 0 ; i < P ; i ++ ) { mp [ arr [ i ] ] ++ ; } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 and helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } int main ( ) { N = 3 , P = 10 ; int arr [ ] = { 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 } ; cout << findMaximumDays ( arr ) ; return 0 ; }"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | C ++ program pendekatan di atas; Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan subarray; Kedai awalan jumlah array; Kirakan Array Jumlah Awalan; Menjana semua subarray; Semak sama ada subarray ini adalah subarray yang sah atau tidak; Jumlah kiraan subarray; Kod pemacu; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }"}
{"text": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | C ++ program pendekatan di atas; Fungsi yang mengira subarray s. t. Jumlah elemen dalam subarray Modulo K adalah sama dengan saiz subarray; Menyimpan kiraan (pref [i] - i) % k; Menyimpan kiraan subarray; Kedai awalan jumlah array; Cari Array Jumlah Awalan; Keadaan asas; Keluarkan indeks pada masa ini selepas indeks k dari indeks semasa; Kemas kini jawapan untuk subarrays yang berakhir pada indeks i - th; Tambah nilai yang dikira indeks semasa untuk dikira; Cetak kiraan subarray; Kod pemacu; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { unordered_map < int , int > cnt ; long long int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; cnt [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int remIdx = i - k ; if ( remIdx >= 0 ) { cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -- ; } ans += cnt [ ( pref [ i ] - i % k + k ) % k ] ; cnt [ ( pref [ i ] - i % k + k ) % k ] ++ ; } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }"}
{"text": "Semak jika semua substring panjang k dari rentetan binari mempunyai kiraan yang sama dengan 0 s dan 1 s | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada substring panjang k mempunyai sama 0 dan 1; Melintasi rentetan; Semak sama ada setiap watak k - th adalah sama atau tidak; Melintasi substring panjang k; Jika watak semasa adalah 0; Kiraan kenaikan; Jika tidak; Kiraan pengurangan; Semak sama 0 s dan 1 s; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int check ( string & s , int k ) { int n = s . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } int main ( ) { string s = \"101010\" ; int k = 2 ; if ( check ( s , k ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }"}
{"text": "Semak jika watak -watak rentetan yang diberikan boleh digunakan untuk membentuk sebarang rentetan yang sama | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada freq dari mana -mana watak boleh dibahagikan dengan n; Menyimpan kekerapan aksara; Jika kekerapan watak tidak dapat dibahagikan dengan n; Jika tiada watak mempunyai kekerapan sekurang -kurangnya n; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSame ( string str , int n ) { map < int , int > mp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mp [ str [ i ] - ' a ' ] ++ ; } for ( auto it : mp ) { if ( ( it . second ) >= n ) { return true ; } } return false ; } int main ( ) { string str = \" ccabcba \" ; int n = 4 ; if ( isSame ( str , n ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } }"}
{"text": "Cari akar fungsi yang tidak berkurangan antara a dan b | Program C ++ untuk pendekatan di atas; Fungsi yang diberikan; Fungsi untuk mencari akar fungsi yang tidak berkurangan; Untuk mendapatkan jawapan minimum yang mungkin untuk akar; Cari pertengahan; Cari di [rendah, x]; Cari di [x, tinggi]; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencari akar persamaan yang diberikan dalam julat [a, b]; Jika akar tidak wujud; Lain mencari akar sehingga 4 tempat perpuluhan; Kod pemacu; Julat yang diberikan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define eps  1e-6 NEW_LINE double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } double findRoot ( double a , double b , double c , double low , double high ) { double x ; while ( fabs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { cout << \" No ▁ solution \" ; } else { cout << fixed << setprecision ( 4 ) << findRoot ( a , b , c , A , B ) ; } } int main ( ) { double a = 2 , b = -3 , c = -2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; return 0 ; }"}
{"text": "Median perbezaan semua pasangan dari array | Program C ++ untuk melaksanakan pendekatan di atas; Pemeriksaan fungsi jika pertengahan boleh menjadi indeks median pelbagai perbezaan; Saiz array; Jumlah mungkin tidak ada pasangan yang mungkin; Indeks elemen dalam perbezaan semua pasangan dari array; Kira bilangan pasangan yang mempunyai perbezaan <= MID; Jika perbezaan antara akhir dan elemen pertama kurang atau sama dengan pertengahan; Memeriksa unsur tidak kurang daripada atau sama dengan pertengahan adalah lebih besar daripada median atau tidak; Fungsi untuk mengira median perbezaan semua pasangan dari array; Saiz array; Memulakan yang rendah dan tinggi; Carian binari; Hitung pertengahan; Jika pertengahan boleh menjadi median array; Mengembalikan median perbezaan pasangan dari array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; bool possible ( ll mid , vector < ll > & a ) { ll n = a . size ( ) ; ll total = ( n * ( n - 1 ) ) / 2 ; ll need = ( total + 1 ) / 2 ; ll count = 0 ; ll start = 0 , end = 1 ; while ( end < n ) { if ( a [ end ] - a [ start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ end - 1 ] - a [ start ] <= mid ) { ll t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; } ll findMedian ( vector < ll > & a ) { ll n = a . size ( ) ; ll low = 0 , high = a [ n - 1 ] - a [ 0 ] ; while ( low <= high ) { ll mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; } int main ( ) { vector < ll > a = { 1 , 7 , 5 , 2 } ; sort ( a . begin ( ) , a . end ( ) ) ; cout << findMedian ( a ) << endl ; }"}
{"text": "Cetak semua rentetan dari array a [] mempunyai semua rentetan dari array b [] sebagai berikutnya | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari rentetan dari [] mempunyai semua rentetan dalam b [] sebagai seterusnya; Hitung saiz masing -masing; Menyimpan jawapannya; Menyimpan kekerapan setiap watak dalam rentetan []; Kirakan frekuensi watak semua rentetan; Menyimpan kekerapan setiap aksara dalam rentetan b [] setiap watak rentetan dalam b []; Jika kekerapan watak dalam b [] melebihi itu dalam []; Rentetan wujud dalam B [] yang bukan subset yang betul dari [i]; Jika semua rentetan dalam b [] adalah subset yang betul dari []; Tolak rentetan dalam vektor yang dihasilkan; Jika ada rentetan yang dijumpai; Cetak rentetan itu; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void UniversalSubset ( vector < string > A , vector < string > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; vector < string > res ; int A_fre [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) { A_fre [ i ] [ A [ i ] [ j ] - ' a ' ] ++ ; } } int B_fre [ 26 ] = { 0 } ; for ( int i = 0 ; i < n2 ; i ++ ) { int arr [ 26 ] = { 0 } ; for ( int j = 0 ; j < B [ i ] . size ( ) ; j ++ ) { arr [ B [ i ] [ j ] - ' a ' ] ++ ; B_fre [ B [ i ] [ j ] - ' a ' ] = max ( B_fre [ B [ i ] [ j ] - ' a ' ] , arr [ B [ i ] [ j ] - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push_back ( A [ i ] ) ; } if ( res . size ( ) ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res [ i ] . size ( ) ; j ++ ) cout << res [ i ] [ j ] ; } cout << \" ▁ \" ; } else cout << \" - 1\" ; } int main ( ) { vector < string > A = { \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" } ; vector < string > B = { \" geek \" , \" ee \" } ; UniversalSubset ( A , B ) ; return 0 ; }"}
{"text": "Pasangan terdekat dalam array supaya satu nombor adalah pelbagai yang lain | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pasangan jarak minimum di mana seseorang adalah pelbagai yang lain; Memulakan pembolehubah; Melangkah untuk semua elemen; Gelung untuk membuat pasangan; Semak jarak minimum; Semak jika seseorang adalah pelbagai yang lain; Mengemas kini jarak; Indeks kedai; Jika tidak ada pasangan seperti itu; Cetak jawapannya; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int a [ ] , int n ) { int min_dist = INT_MAX ; int index_a = -1 , index_b = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == -1 ) { cout << ( \" - 1\" ) ; } else { cout << \" ( \" << a [ index_a ] << \" , ▁ \" << a [ index_b ] << \" ) \" ; } } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( int ) ; findPair ( a , n ) ; }"}
{"text": "Cetak semua nombor dalam julat yang diberikan dengan digit dalam perintah yang semakin meningkat | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak semua nombor dalam julat [l, r] yang mempunyai digit dalam urutan yang semakin meningkat; Melangkah ke atas julat; Melangkah ke atas digit; Semak sama ada digit semasa adalah> = digit sebelumnya; Sekiranya digit berada dalam urutan menaik; Kod pemacu; Diberikan julat l dan r; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << \" ▁ \" ; } } int main ( ) { int L = 10 , R = 15 ; printNum ( L , R ) ; return 0 ; }"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari elemen yang hilang; Betulkan sempadan kiri dan kanan untuk carian binari; Cari Indeks Elemen Tengah; Semak jika elemen hanya selepas elemen tengah hilang; Semak jika elemen sebelum pertengahan hilang; Semak jika unsur -unsur sehingga pertengahan mengikuti AP, kemudian berulang untuk separuh kanan; Lain berulang untuk separuh kiri; Berfungsi untuk mencari elemen yang hilang dalam siri AP; Susun array arr []; Mengira perbezaan biasa; Pencarian binari untuk yang hilang; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return INT_MAX ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; } int missingElement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 6 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << missingElement ( arr , n ) ; return 0 ; }"}
{"text": "Nilai lantai kth akar nombor menggunakan carian binari rekursif | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn); Berfungsi untuk mencari akar kth nombor n menggunakan BS; Sekiranya julat masih sah; Cari nilai pertengahan julat; Kes asas; Keadaan untuk memeriksa sama ada ruang carian kiri tidak berguna; Kod pemacu; Diberikan n dan k; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; } int main ( ) { int N = 16 , K = 4 ; cout << nthRootSearch ( 0 , N , N , K ) << endl ; return 0 ; }"}
{"text": "Count subset yang mempunyai jumlah elemen min dan max kurang daripada k | C ++ program untuk mencetak kiraan subset s seperti min (s) + max (s) <k; Fungsi yang mengembalikan kiraan subset sedemikian rupa sehingga min (s) + max (s) <k; Menyusun array; Ans menyimpan jumlah subset; Tambah semua subset yang mungkin antara I dan J; Mengurangkan jumlah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_subset_count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get_subset_count ( arr , K , N ) ; return 0 ; }"}
{"text": "Kurangkan perbezaan maksimum unsur -unsur bersebelahan selepas kebanyakan sisipan k | Program C ++ untuk mencari perbezaan maksimum maksimum antara unsur -unsur bersebelahan selepas kebanyakan penyisipan K; Kirakan perbezaan bersebelahan maksimum; Jika perbezaan bersebelahan maksimum sudah sifar; Terbaik dan terburuk menentukan pelbagai perbezaan bersebelahan maksimum; Untuk menyimpan tidak ada sisipan yang diperlukan untuk nilai masing -masing MID; Jika bilangan sisipan diperlukan melebihi k; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } int main ( ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; cout << minMaxDiff ( arr , n , k ) ; return 0 ; }"}
{"text": "Semak jika elemen minimum dalam array kurang daripada atau sama dengan separuh daripada setiap elemen lain | Pelaksanaan C ++ untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Fungsi untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Memulakan pembolehubah untuk menyimpan terkecil terkecil dan kedua terkecil; Semak jika elemen semasa lebih kecil daripada yang terkecil, terkecil semasa akan menjadi unsur detik yang paling teruk dan semasa akan menjadi yang terkecil baru; Semak jika elemen semasa lebih kecil daripada saat yang paling kecil hanya mengemas kini yang terakhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkMin ( int arr [ ] , int len ) { int smallest = INT_MAX , secondSmallest = INT_MAX ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkMin ( arr , len ) ; }"}
{"text": "Nombor fibonacci terbesar dan terkecil dalam array | Program C ++ untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Fungsi untuk membuat jadual hash untuk memeriksa nombor Fibonacci; Masukkan dua nombor awal dalam jadual hash; Jumlah dua nombor sebelumnya; Kemas kini pembolehubah setiap kali; Berfungsi untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Cari nilai maksimum dalam array; Mewujudkan satu set yang mengandungi semua nombor Fibonacci sehingga nilai maksimum dalam array; Untuk menyimpan nombor Fibonacci minimum dan maksimum; Semak jika elemen semasa adalah nombor Fibonacci; Mengemas kini maksimum dan minimum yang sewajarnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } void fibonacci ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; set < int > hash ; createHash ( hash , max_val ) ; int minimum = INT_MAX ; int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { minimum = min ( minimum , arr [ i ] ) ; maximum = max ( maximum , arr [ i ] ) ; } } cout << minimum << \" , ▁ \" << maximum << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; fibonacci ( arr , n ) ; return 0 ; }"}
{"text": "Substring terpanjang dengan K aksara unik menggunakan carian binari | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika terdapat substring panjang len dengan <= k aksara unik; Saiz rentetan; Peta untuk menyimpan watak dan kekerapannya; Kemas kini peta untuk substring pertama; Periksa selebihnya substrings; Tambah watak baru; Keluarkan watak pertama tetingkap sebelumnya; Kemas kini peta; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai aksara unik K; Semak sama ada rentetan lengkap mengandungi aksara unik K; Saiz rentetan; Memohon carian binari; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidLen ( string s , int len , int k ) { int n = s . size ( ) ; unordered_map < char , int > mp ; int right = 0 ; while ( right < len ) { mp [ s [ right ] ] ++ ; right ++ ; } if ( mp . size ( ) <= k ) return true ; while ( right < n ) { mp [ s [ right ] ] ++ ; mp [ s [ right - len ] ] -- ; if ( mp [ s [ right - len ] ] == 0 ) mp . erase ( s [ right - len ] ) ; if ( mp . size ( ) <= k ) return true ; right ++ ; } return mp . size ( ) <= k ; } int maxLenSubStr ( string s , int k ) { set < char > uni ; for ( auto x : s ) uni . insert ( x ) ; if ( uni . size ( ) < k ) return -1 ; int n = s . size ( ) ; int lo = -1 , hi = n + 1 ; while ( hi - lo > 1 ) { int mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; } int main ( ) { string s = \" aabacbebebe \" ; int k = 3 ; cout << maxLenSubStr ( s , k ) ; return 0 ; }"}
{"text": "Dataran Kawasan Terbesar di Array Apabila Elemen Boleh Dipandu | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk membuat persegi dengan sisi sama dengan L; Untuk menyimpan kiraan elemen yang lebih besar daripada atau sama dengan L; Kenaikan kiraan; Jika kiraan menjadi lebih besar daripada atau sama dengan L; Berfungsi untuk mengembalikan kawasan maksimum dataran yang boleh diperolehi; Jika persegi mungkin dengan panjang sisi m; Cuba cari persegi dengan panjang sampingan yang lebih kecil; Mengembalikan kawasan itu; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSquarePossible ( int arr [ ] , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; } int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxArea ( arr , n ) ; return 0 ; }"}
{"text": "Semak pendua dalam aliran rentetan | C ++ pelaksanaan pendekatan; Fungsi untuk memasukkan nama dan periksa sama ada ia muncul untuk kali pertama; Untuk menyimpan nama pekerja; Jika nama semasa muncul untuk kali pertama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertNames ( string arr [ ] , int n ) { unordered_set < string > set ; for ( int i = 0 ; i < n ; i ++ ) { if ( set . find ( arr [ i ] ) == set . end ( ) ) { cout << \" No STRNEWLINE \" ; set . insert ( arr [ i ] ) ; } else { cout << \" Yes STRNEWLINE \" ; } } } int main ( ) { string arr [ ] = { \" geeks \" , \" for \" , \" geeks \" } ; int n = sizeof ( arr ) / sizeof ( string ) ; insertNames ( arr , n ) ; return 0 ; }"}
{"text": "Kira tiga kali ganda supaya A [i] <b [j] <c [k] | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang kurang daripada kunci yang diberikan; Carian binari yang diubah suai; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang lebih besar daripada kunci yang diberikan; Carian binari yang diubah suai; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang diperlukan; Menyusun ketiga -tiga tatasusunan; Melangkah untuk semua elemen array b; Kiraan elemen dalam [] yang kurang daripada elemen yang dipilih dari B []; Kiraan unsur -unsur dalam C [] yang lebih besar daripada elemen yang dipilih dari B []; Mengemas kini kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == -1 ) return 0 ; return ( n - index ) ; } int countTriplets ( int n , int * a , int * b , int * c ) { sort ( a , a + n ) ; sort ( b , b + n ) ; sort ( c , c + n ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int a_index = -1 , c_index = -1 ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } int main ( ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countTriplets ( size , a , b , c ) ; return 0 ; }"}
{"text": "Kos untuk mengimbangi kurungan | Kod CPP untuk mengira kos minimum untuk membuat tanda kurung yang diberikan seimbang; Untuk menyimpan kiraan mutlak kurungan yang seimbang dan tidak seimbang; o (pendakap terbuka) menyimpan kiraan '(' dan c (pendakap dekat) kiraan ')'; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) o ++ ; if ( s [ i ] == ' ) ' ) c ++ ; } if ( o != c ) return -1 ; int a [ s . size ( ) ] ; if ( s [ 0 ] == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = -1 ; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ) ; } return ans ; } int main ( ) { string s ; s = \" ) ) ) ( ( ( \" ; cout << costToBalance ( s ) << endl ; s = \" ) ) ( ( \" ; cout << costToBalance ( s ) << endl ; return 0 ; }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program CPP untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; x adalah positif jika a lebih besar daripada b. x adalah negatif jika b lebih besar daripada a. ; Sama seperti x; Sama seperti x dan y. ; Memeriksa jika B adalah tengah (X dan Y kedua -duanya adalah positif); Memeriksa jika C adalah tengah (x dan z kedua -duanya positif); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }"}
{"text": "Cari empat nombor yang hilang dalam array yang mengandungi elemen dari 1 hingga n | Program CPP untuk mencari 4 elemen yang hilang dalam pelbagai saiz n di mana unsur -unsur berada dalam jarak dari 1 hingga n + 4 .; Menemukan 4 nombor dalam O (n) masa dan O (1) ruang tambahan. ; Untuk menjejaki 4 nombor yang mungkin lebih besar daripada panjang input di Java, penolong secara automatik diasaskan sebagai 0 .; Melintasi array input dan menandakan unsur -unsur yang dilawati sama ada dengan menandakan mereka sebagai negatif dalam arr [] atau dalam pembantu []. ; Jika elemen lebih kecil daripada atau sama dengan panjang, tandakan kehadirannya di arr []; Mark kehadiran dalam pembantu []; Cetak semua elemen yang kehadirannya tidak ditandakan. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void missing4 ( int arr [ ] , int n ) { int helper [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { int temp = abs ( arr [ i ] ) ; if ( temp <= n ) arr [ temp - 1 ] *= ( -1 ) ; else if ( temp > n ) { if ( temp % n != 0 ) helper [ temp % n - 1 ] = -1 ; else helper [ ( temp % n ) + n - 1 ] = -1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) cout << ( i + 1 ) << \" ▁ \" ; for ( int i = 0 ; i < 4 ; i ++ ) if ( helper [ i ] >= 0 ) cout << ( n + i + 1 ) << \" ▁ \" ; return ; } int main ( ) { int arr [ ] = { 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; missing4 ( arr , n ) ; return 0 ; }"}
{"text": "Permutasi yang hadir di tengah -tengah pesanan leksikografi permutasi paling panjang n yang terdiri daripada bilangan bulat sehingga k | Program C ++ untuk pendekatan di atas; Fungsi yang menemui tengah -tengah urutan terkecil leksikografi; Jika k ada; Elemen pertama ialah K / 2; Unsur -unsur yang tersisa dari urutan adalah semua integer k; Menyimpan urutan apabila k adalah ganjil; Melangkah ke atas julat [0, n / 2]; Semak sama ada urutan berakhir dengan 1 atau tidak; Keluarkan urutan yang berakhir dalam 1; Sekiranya ia tidak berakhir dalam 1; Penurunan sebanyak 1; Masukkan k ke urutan sehingga saiznya adalah n; Cetak urutan yang disimpan dalam vektor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { cout << K / 2 << \" ▁ \" ; for ( int i = 0 ; i < N - 1 ; ++ i ) { cout << K << \" ▁ \" ; } cout << \" STRNEWLINE \" ; exit ( 0 ) ; } vector < int > a ( N , ( K + 1 ) / 2 ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . back ( ) == 1 ) { a . pop_back ( ) ; } else { -- a . back ( ) ; while ( ( int ) a . size ( ) < N ) { a . push_back ( K ) ; } } } for ( auto i : a ) { cout << i << \" ▁ \" ; } cout << \" STRNEWLINE \" ; } int main ( ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; return 0 ; }"}
{"text": "Elemen array yang tinggal selepas penyingkiran elemen terkecil dari pasangan dengan perbezaan mutlak 2 atau 0 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari elemen array yang terakhir selepas berulang kali mengeluarkan terkecil dari pasangan yang mempunyai perbezaan mutlak 2 atau 0; Susun array yang diberikan dalam urutan menaik; Melintasi array; Jika perbezaan antara unsur -unsur bersebelahan tidak sama dengan 0 atau 2; Jika operasi boleh dilakukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLastElement ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { cout << \" - 1\" << endl ; return ; } } cout << arr [ N - 1 ] << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLastElement ( arr , N ) ; return 0 ; }"}
{"text": "Memaksimumkan kiraan subset ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira subset maksimum ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan; Susun array dalam penurunan urutan; Kedai -kedai Count Subset mungkin; Kedai mengira unsur -unsur dalam subset semasa; Melintasi array arr []; Saiz kemas kini; Jika produk elemen terkecil yang terdapat dalam subset semasa dan saiz subset semasa ialah> = k; Kemas kini MaxSub; Saiz kemas kini; Kod pemacu; Diberikan array; Saiz array; Diberi nilai x", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDivisions ( int arr [ ] , int N , int X ) { sort ( arr , arr + N , greater < int > ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } cout << maxSub << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 3 ; maxDivisions ( arr , N , X ) ; return 0 ; }"}
{"text": "Memaksimumkan jumlah minimum kedua dalam semua empat kali ganda dari array yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah maksimum minimum minimum kedua dalam setiap empat kali ganda; Susun array; Tambah minimum kedua; Cetak jumlah maksimum yang mungkin; Kod pemacu; Diberikan array; Saiz array", "code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPossibleSum ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } cout << sum ; } int main ( ) { int arr [ ] = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ; int N = 8 ; maxPossibleSum ( arr , N ) ; return 0 ; }"}
{"text": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Program C ++ untuk jenis penyisipan; Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci kepada satu kedudukan di hadapan kedudukan semasa mereka; Berfungsi untuk mencetak pelbagai saiz n; Cetak array; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } cout << endl ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSort ( arr , N ) ; printArray ( arr , N ) ; return 0 ; }"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan pasangan yang diperlukan; Kedai kiraan pasangan; Melintasi array; Periksa sama ada keadaan itu berpuas hati atau tidak; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; getPairs ( arr , N , K ) ; return 0 ; }"}
{"text": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Program C ++ untuk pendekatan di atas; Berfungsi untuk menggabungkan dua susunan yang disusun; i: indeks ke subarray kiri; J: Indeks ke Subarray Kanan; Kedai kiraan pasangan yang memenuhi syarat yang diberikan; Melintasi untuk memeriksa keadaan yang sah; Jika keadaan memenuhi; Semua elemen di sebelah kanan subarray kiri juga memuaskan; Susun dua tatasusunan yang diberikan dan simpan dalam array yang dihasilkan; Unsur -unsur yang tersisa di subarray kiri; Unsur -unsur yang tersisa di subarray kanan; Mengembalikan kiraan yang diperoleh; Berfungsi untuk memisahkan array menjadi dua bahagian; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Hubungi fungsi penggabungan; Berfungsi untuk mencetak kiraan pasangan yang diperlukan menggunakan jenis gabungan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( int l = 0 ; i <= m ; i ++ ) { bool found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( int i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } int mergeSort ( int arr [ ] , int N , int K ) { int temp [ N ] ; cout << mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; mergeSort ( arr , N , K ) ; return 0 ; }"}
{"text": "Kurangkan penyingkiran berturut -turut unsur -unsur jenis yang sama untuk kosong yang diberikan | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mengira penyingkiran minimum berturut -turut unsur -unsur jenis yang sama; Susun array; Menyimpan elemen maksimum yang terdapat dalam array; Kedai jumlah array; Hitung jumlah array; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minRemovals ( int A [ ] , int N ) { sort ( A , A + N ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { cout << 0 << \" STRNEWLINE \" ; } else { cout << 2 * mx - sum << \" STRNEWLINE \" ; } } int main ( ) { int A [ ] = { 3 , 3 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minRemovals ( A , N ) ; return 0 ; }"}
{"text": "Menyusun semula array yang diberikan supaya tiada elemen array yang sama dengan indeksnya | Program C ++ untuk pendekatan di atas; Berfungsi untuk menyusun semula array a [] supaya tidak ada unsur array yang sama dengan indeksnya; Susun array; Melintasi indeks [0, n - 2] dari array yang diberikan; Periksa sama ada elemen semasa adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen seterusnya; Semak jika elemen terakhir adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen sebelumnya; Cetak array yang diubah suai; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int a [ ] , int n ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { swap ( a [ i ] , a [ i + 1 ] ) ; } } if ( a [ n - 1 ] == n ) { swap ( a [ n - 1 ] , a [ n - 2 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArray ( arr , N ) ; return 0 ; }"}
{"text": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | Program C ++ untuk pendekatan di atas; Fungsi yang mengira langkah minimum yang diperlukan untuk rahsia ARR [] kepada BRR []; Kes asas; Jika arr [i] <arr [j]; Termasuk elemen semasa; Jika tidak, tidak termasuk elemen semasa; Fungsi yang mengira langkah minimum yang diperlukan untuk menyusun array; Jika kedua -dua tatasusunan adalah sama; Tiada langkah yang diperlukan; Jika tidak; Mencetak operasi minimum yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int arr1 [ ] , int arr2 [ ] , int i , int j , int n ) { int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) f = 1 ; break ; } if ( f == 0 ) return 0 ; if ( i >= n j >= n ) return 0 ; if ( arr1 [ i ] < arr2 [ j ] ) return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 , n ) ; return max ( minOperations ( arr1 , arr2 , i , j + 1 , n ) , minOperations ( arr1 , arr2 , i + 1 , j , n ) ) ; } void minOperationsUtil ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; sort ( brr , brr + n ) ; int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) f = 1 ; break ; } if ( f == 1 ) cout << ( minOperations ( arr , brr , 0 , 0 , n ) ) ; else cout << \"0\" ; } int main ( ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minOperationsUtil ( arr , n ) ; }"}
{"text": "Semak jika rentetan boleh diubah kepada yang lain dengan menyusun substrings | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada Str1 boleh diubah menjadi T dengan menyusun substrings; Berlaku [i] menyimpan indeks char ('a' + i) dalam rentetan s; Idx [i] menyimpan indeks char yang tersedia seterusnya ('a' + i) berlaku [i]; Sekiranya char ini tidak tersedia lagi; Penukaran tidak mungkin; Jika salah satu watak yang lebih kecil tersedia dan berlaku sebelum ini; Penukaran tidak mungkin; Cetak jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void canTransform ( string & s , string & t ) { int n = s . length ( ) ; vector < int > occur [ 26 ] ; for ( int x = 0 ; x < n ; x ++ ) { char ch = s [ x ] - ' a ' ; occur [ ch ] . push_back ( x ) ; } vector < int > idx ( 26 , 0 ) ; bool poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = t [ x ] - ' a ' ; if ( idx [ ch ] >= occur [ ch ] . size ( ) ) { poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } } int main ( ) { string s , t ; s = \" hdecb \" ; t = \" cdheb \" ; canTransform ( s , t ) ; return 0 ; }"}
{"text": "Semak sama ada dua rentetan boleh dibuat sama dengan membalikkan substring panjang yang sama dari kedua -dua rentetan | Program C ++ untuk pendekatan di atas; fungsi untuk mengira kiraan penyongsangan rentetan; untuk menyimpan kekerapan; Tambah semua watak yang kurang daripada watak ITH sebelum saya. ; Menambah kiraan kepada kiraan penyongsangan; mengemas kini watak dalam pelbagai frekuensi; berfungsi untuk memeriksa sama ada mana -mana rentetan mempunyai watak berulang; fungsi untuk memeriksa sama ada String S1 dan S2 boleh dibuat sama dengan membalikkan sub rentetan saiz yang sama dalam kedua -dua rentetan; Arahan kekerapan untuk memeriksa sama ada kedua -dua rentetan mempunyai watak yang sama atau tidak; menambah kekerapan; ; Jika watak tidak berada di S1; menurunkan kekerapan; Jika kedua -dua rentetan tidak mempunyai aksara yang sama atau tidak; mencari kiraan penyongsangan kedua -dua rentetan; Jika kiraan penyongsangan adalah sama, atau mempunyai pariti yang sama atau jika mana -mana rentetan mempunyai watak berulang maka jawapannya ya tidak lagi; kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int inversionCount ( string & s ) { int freq [ 26 ] = { 0 } ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < int ( s [ i ] - ' a ' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - ' a ' ] ++ ; } return inv ; } bool haveRepeated ( string & S1 , string & S2 ) { int freq [ 26 ] = { 0 } ; for ( char i : S1 ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; for ( char i : S2 ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } return false ; } void checkToMakeEqual ( string S1 , string S2 ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { freq [ S1 [ i ] - ' a ' ] ++ ; } bool flag = 0 ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 [ i ] - ' a ' ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - ' a ' ] -- ; } if ( flag == true ) { cout << \" No STRNEWLINE \" ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { cout << \" Yes STRNEWLINE \" ; } else cout << \" No STRNEWLINE \" ; } int main ( ) { string S1 = \" abbca \" , S2 = \" acabb \" ; checkToMakeEqual ( S1 , S2 ) ; return 0 ; }"}
{"text": "Susun Arahan Bitonic | Program C ++ untuk pendekatan di atas; Berfungsi untuk menyusun array bitonic dalam ruang malar; Memulakan nilai k; Dalam setiap lelaran Bandingkan Elemen K jarak jauh dan bertukar jika mereka tidak teratur; K dikurangkan kepada separuh selepas setiap lelaran; Cetak elemen array; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArr ( int a [ ] , int n ) { int i , k ; k = ( int ) log2 ( n ) ; k = pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) swap ( a [ i ] , a [ i + k ] ) ; k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }"}
{"text": "Split array ke dalam sub subset untuk memaksimumkan jumlah maksimum dan minimum mereka | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi yang mencetak jumlah maksimum yang mungkin; Cari elemen dalam setiap kumpulan; Menyusun semua elemen dalam perintah bukan menurun; Tambah un elemen terbesar; Untuk jumlah elemen minimum dari setiap subset; Mencetak jumlah maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; sort ( arr , arr + n ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } cout << sum << \" STRNEWLINE \" ; } int main ( ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; maximumSum ( Arr , size , K ) ; return 0 ; }"}
{"text": "Kurangkan jumlah unsur -unsur terkecil dari k -lekukan panjang l | Program C ++ untuk mencari jumlah minimum elemen terkecil dari kaum K; Berfungsi untuk mencari jumlah minimum; Susun array; Hitung jumlah elemen k terkecil; Mengembalikan jumlahnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int minsum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } int main ( ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , K , L , length ) ; return 0 ; }"}
{"text": "KTH elemen terkecil atau terbesar dalam array yang tidak disusun | Tetapkan 4 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari elemen terkecil kth dalam array yang tidak disusun; Memulakan elemen max sebagai 0; ARR [] dan cari elemen maksimum di dalamnya; Arahan kekerapan untuk menyimpan frekuensi; Pemboleh ubah kaunter; Mengira frekuensi; Melangkah melalui freq []; Semak sama ada NUM terdapat dalam array; Meningkatkan kaunter dengan kekerapan NUM; Memeriksa jika kita telah mencapai elemen terkecil KTH; Mengembalikan elemen terkecil kth; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; int findKthSmallest ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int counter [ max + 1 ] = { 0 } ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } } int main ( ) { int arr [ ] = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; cout << findKthSmallest ( arr , N , K ) ; return 0 ; }"}
{"text": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak semua nombor sehingga n dalam urutan leksikografi; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( stoi ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << \" ▁ \" ; } int main ( ) { int n = 15 ; lexNumbers ( n ) ; return 0 ; }"}
{"text": "Susun Matriks dalam Perintah Menaik dan Menurun Rowwise | C ++ pelaksanaan untuk mencetak baris matriks dalam urutan menaik atau menurun secara alternatif; Matriks iterate rowwise; Menyusun baris dalam urutan menaik; Bandingkan unsur -unsur bersebelahan; swap elemen bersebelahan; Menyusun baris dalam urutan menurun; Bandingkan unsur -unsur bersebelahan; swap elemen bersebelahan; Mencetak output akhir; Kod pemacu", "code": "#include <stdio.h> NEW_LINE #define N  4 NEW_LINE void func ( int a [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( \" % d ▁ \" , a [ i ] [ j ] ) ; } printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int a [ N ] [ N ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; return 0 ; }"}
{"text": "Cari berat MST dalam graf lengkap dengan Edge | Program C ++ untuk mencari berat pokok merangkumi minimum dalam graf lengkap di mana tepi mempunyai berat badan sama ada 0 atau 1; Untuk menyimpan tepi graf yang diberikan; Fungsi utiliti untuk melaksanakan traversal DFS; Semak simpang yang disimpan dalam set; Vertices dimasukkan jika berat kelebihan adalah 0; Fungsi utiliti untuk mencari berat pokok minimum; Untuk mengira komponen yang disambungkan; Memasukkan simpul awal dalam set; Melintasi simpang yang disimpan dalam set dan menjalankan traversal DFS untuk setiap simpang; Meningkatkan komponen bersambung berat sifar; DFS traversal untuk setiap vertex mengeluarkan; Kod pemandu; Masukkan tepi; Fungsi Panggilan Cari berat pokok minimum", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > g [ 200005 ] ; set < int > s , ns ; void dfs ( int x ) { vector < int > v ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( ! g [ x ] [ it ] ) { v . push_back ( it ) ; } else { ns . insert ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } } void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . insert ( i ) ; } for ( ; s . size ( ) ; ) { ++ cnt ; int t = * s . begin ( ) ; s . erase ( t ) ; dfs ( t ) ; } cout << cnt - 1 ; } int main ( ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] [ v ] = 1 ; g [ v ] [ u ] = 1 ; } weightOfMST ( N ) ; return 0 ; }"}
{"text": "Kira pasangan yang mungkin berbeza supaya elemen dari A lebih besar daripada elemen dari b | Program C ++ untuk mengira bilangan pasangan yang berbeza yang mungkin dari kedua -dua tatasusunan seperti elemen yang dipilih dari satu array selalu lebih besar daripada yang dipilih dari array yang lain; Berfungsi untuk mengembalikan kiraan pasangan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } int main ( ) { vector < int > A = { 30 , 28 , 45 , 22 } ; vector < int > B = { 35 , 25 , 22 , 48 } ; cout << countPairs ( A , B ) ; return 0 ; }"}
{"text": "Sisa maksimum mungkin apabila elemen dibahagikan dengan elemen lain dalam array | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai mod maksimum untuk mana -mana pasangan dari array; Cari elemen maksimum kedua dari array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMod ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxMod ( arr , n ) ; return 0 ; }"}
{"text": "Pilih x elemen dari elemen [] dan y dari b [] yang memenuhi syarat yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk pulangan yang benar jika mungkin untuk memilih unsur -unsur; Jika unsur -unsur tidak dapat dipilih; Menyusun kedua -dua tatasusunan; Jika elemen terkecil x [] adalah lebih kecil daripada elemen terbesar Yth B []; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } int main ( ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = sizeof ( A ) / sizeof ( int ) ; int m = sizeof ( B ) / sizeof ( int ) ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Cari perubahan minimum yang diperlukan dalam array untuk mengandungi elemen K yang berbeza | Program CPP kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Fungsi kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Simpan kekerapan setiap elemen; Simpan kekerapan elemen; Jenis frekuensi dalam urutan menurun; Untuk menyimpan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << Min_Replace ( arr , n , k ) ; return 0 ; }"}
{"text": "Bilangan maksimum elemen tanpa bertindih dalam garis | Program CPP untuk mencari bilangan elemen maksimum tanpa bertindih dalam satu baris; Berfungsi untuk mencari bilangan elemen maksimum tanpa bertindih dalam garis; Jika n = 1, maka jawapannya adalah satu; Kami sentiasa boleh membuat elemen 1 st untuk menutup segmen kiri dan nth segmen yang betul; Jika segmen kiri untuk elemen ith tidak bertindih dengan elemen i - 1 maka kemudian kiri; lain cuba ke arah yang betul jika boleh; Kemas kini x [i] ke titik akhir kanan segmen yang diliputi olehnya; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } int main ( ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << Segment ( x , l , n ) ; return 0 ; }"}
{"text": "Padam ganjil dan bahkan nombor pada langkah alternatif supaya jumlah elemen yang tinggal diminimumkan | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari jumlah yang diminimumkan; Jika lebih banyak elemen ganjil; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika lebih banyak elemen; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika elemen yang sama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimizeleftOverSum ( int a [ ] , int n ) { vector < int > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) v1 . push_back ( a [ i ] ) ; else v2 . push_back ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; } int main ( ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinimizeleftOverSum ( a , n ) ; return 0 ; }"}
{"text": "Operasi minimum untuk membuat kekerapan semua aksara sama k | Program C ++ untuk menukar rentetan yang diberikan; Berfungsi untuk mencari bilangan minimum operasi untuk menukar rentetan yang diberikan; Semak jika n boleh dibahagikan dengan k; Array untuk menyimpan kekerapan aksara dalam rentetan yang diberikan; Dua tatasusunan dengan bilangan operasi yang diperlukan; Memeriksa semua kemungkinan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperation ( string S , int N , int K ) { if ( N % K ) { cout << \" Not ▁ Possible \" << endl ; return ; } int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ S [ i ] - 97 ] ++ ; } int E = N / K ; vector < int > greaterE ; vector < int > lessE ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push_back ( E - count [ i ] ) ; else greaterE . push_back ( count [ i ] - E ) ; } sort ( greaterE . begin ( ) , greaterE . end ( ) ) ; sort ( lessE . begin ( ) , lessE . end ( ) ) ; int mi = INT_MAX ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = min ( mi , max ( step1 , step2 ) ) ; } } cout << mi << endl ; } int main ( ) { string S = \" accb \" ; int N = S . size ( ) ; int K = 2 ; minOperation ( S , N , K ) ; return 0 ; }"}
{"text": "Operasi Peningkatan Julat Minimum Untuk Mengasingkan Array | Program C ++ untuk mencari kenaikan julat minimum untuk menyusun array; Berfungsi untuk mencari kenaikan julat minimum untuk menyusun array; Jika elemen semasa didapati lebih besar daripada kenaikan elemen terakhir semua istilah dalam julat i + 1 hingga n - 1; mn = arr [i]; Minimum dalam julat I hingga n - 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minMovesToSort ( arr , n ) ; return 0 ; }"}
{"text": "Susun nombor utama array dalam perintah menurun | C ++ pelaksanaan pendekatan; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Fungsi yang menyusun semua nombor utama dari array dalam menurun; Vektor ini akan mengandungi nombor utama untuk disusun; Jika elemen itu adalah perdana; mengemas kini elemen array; Kod pemacu; Cetak hasilnya.", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime [ 100005 ] ; void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push_back ( arr [ i ] ) ; } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) arr [ i ] = v [ j ++ ] ; } } int main ( ) { int arr [ ] = { 4 , 3 , 2 , 6 , 100 , 17 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortPrimes ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } return 0 ; }"}
{"text": "Pembentukan pasangan sedemikian rupa sehingga jumlah pasangan maksimum diminimumkan | Program CPP untuk membahagikan array ke pasangan N sedemikian rupa sehingga pasangan maksimum diminimumkan; Selepas menyusun mengekalkan dua pembolehubah i dan j menunjuk untuk memulakan dan mengakhiri array sedemikian rupa sehingga elemen terkecil pasangan array dengan elemen terbesar; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findOptimalPairs ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) cout << \" ( \" << arr [ i ] << \" , ▁ \" << arr [ j ] << \" ) \" << \" ▁ \" ; } int main ( ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findOptimalPairs ( arr , N ) ; return 0 ; }"}
{"text": "Sort Array mengikut kiraan bit set | Program C ++ untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Berfungsi secara serentak menyusun kedua -dua tatasusunan menggunakan jenis penyisipan (https: www. Geeksforgeeks. Org / sisipan - sort /); Gunakan 2 kekunci kerana kita perlu menyusun kedua -dua tatasusunan secara serentak; Gerakkan unsur -unsur ARR [0 .. i - 1] dan aux [0 .. i - 1], seperti unsur -unsur aux [0 .. i - 1] adalah lebih besar daripada Key1, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi untuk disusun mengikut kiraan bit menggunakan array tambahan; Buat array dan kiraan bit set di dalamnya. ; Susun arr [] mengikut nilai dalam aux []; Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; } void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } } void sortBySetBitCount ( int arr [ ] , int n ) { int aux [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; return 0 ; }"}
{"text": "Sort Array mengikut kiraan bit set | Program C ++ untuk menyusun array mengikut kiraan set bit menggunakan std :: sort (); fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Fungsi untuk disusun mengikut bit Count fungsi ini mengandaikan bahawa terdapat 32 bit dalam integer. ; Melintasi semua bit bit (perhatikan bahawa kami menyusun array dalam penurunan urutan); Fungsi utiliti untuk mencetak array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; } void sortBySetBitCount ( int arr [ ] , int n ) { vector < vector < int > > count ( 32 ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . push_back ( arr [ i ] ) ; } for ( int i = 31 ; i >= 0 ; i -- ) { vector < int > v1 = count [ i ] ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) arr [ j ++ ] = v1 [ i ] ; } } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; return 0 ; }"}
{"text": "Rentetan binari terkecil lexicographically dibentuk dengan membalikkan bit pada indeks yang tidak dapat dibahagi k1 atau k2 supaya kiraan 1 s sentiasa lebih besar daripada 0 s dari kiri | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil secara lexicographically yang mempunyai bilangan 1 s lebih besar daripada bilangan 0 s; C1S dan C0S menyimpan kiraan 1 s dan 0 s pada setiap kedudukan; Melintasi rentetan s; Jika kedudukan tidak dapat dibahagikan dengan k1 dan k2; Jika c0s> = c1s dan pos [] kosong maka rentetan tidak dapat dibentuk; Jika POS [] tidak kosong maka flip sedikit kedudukan terakhir yang terdapat di POS []; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int k1 , int k2 , string s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push_back ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { cout << -1 ; flag = 1 ; break ; } else { int k = pos . back ( ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . pop_back ( ) ; } } } if ( flag == 0 ) { cout << s ; } } int main ( ) { int K1 = 2 , K2 = 4 ; string S = \"11000100\" ; generateString ( K1 , K2 , S ) ; return 0 ; }"}
{"text": "Cari sepasang nombor dengan set bit set sebagai kebanyakan n dan yang bitwise xor adalah n | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari pasangan (x, y) sedemikian rupa sehingga x xor y = n dan kiraan bit set dalam x dan y kurang daripada kiraan set bit dalam n; Kedai MSB (Bit Paling Penting); Menyimpan nilai x; Menyimpan nilai y; Melintasi semua bit N; Jika ia bit n ialah 0; Tetapkan sedikit x hingga 1; Tetapkan sedikit Y hingga 1; Jawapan cetak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximizeProduct ( int N ) { int MSB = ( int ) log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << \" ▁ \" << Y ; } int main ( ) { int N = 45 ; maximizeProduct ( N ) ; return 0 ; }"}
{"text": "Count of Numbers in Range [l, r] mempunyai jumlah digit persegi sama dengan kuadrat jumlah digit | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor itu sah; Jumlah digit Num; Nombor kuadrat; Jumlah digit (num * num); Berfungsi untuk menukar rentetan ke integer; Berfungsi untuk menghasilkan semua rentetan panjang yang mungkin; Rentetan yang dikehendaki; Hanya mengambil nombor yang sah; Berulang untuk semua digit yang mungkin; Berfungsi untuk mengira nombor unik dalam julat [l, r]; Memulakan pembolehubah untuk menyimpan jawapannya; Kirakan panjang maksimum yang mungkin; Tetapkan untuk menyimpan nombor yang sah yang berbeza; Menjana semua rentetan panjang yang mungkin i; I -meletakkan set untuk mendapatkan kiraan nombor yang sah dalam julat [l, r]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; } int convert ( string s ) { int val = 0 ; reverse ( s . begin ( ) , s . end ( ) ) ; int cur = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { val += ( s [ i ] - '0' ) * cur ; cur *= 10 ; } return val ; } void generate ( string s , int len , set < int > & uniq ) { if ( s . size ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . insert ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + char ( i + '0' ) , len , uniq ) ; } } int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = log10 ( R ) + 1 ; set < int > uniq ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( \" \" , i , uniq ) ; } for ( auto x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } int main ( ) { int L = 22 , R = 22 ; cout << totalNumbers ( L , R ) ; }"}
{"text": "Tukar x ke y dengan berulang kali mengalikan x dengan 2 atau tampuk 1 pada akhir | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada x boleh ditukar kepada y dengan mengalikan x dengan 2 atau menambahkan 1 pada akhir; ITERATE Sehingga Y adalah sekurang -kurangnya x; Jika y juga; Jika digit terakhir Y ialah 1; Jika tidak; Semak sama ada x sama dengan y; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; return 0 ; }"}
{"text": "Lexicographically terkecil rentetan panjang maksimum yang terdiri daripada huruf k pertama yang tidak mengandungi apa -apa substring berulang | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil lexicographically dari huruf kaum K bawah pertama yang mempunyai substrings yang unik; Menyimpan rentetan yang dihasilkan; Melewati semua watak; Gelung dalaman untuk membuat pasangan dan menambahkannya ke dalam rentetan; Menambah watak pertama supaya substring yang terdiri daripada abjad yang terakhir hadir; Cetak rentetan yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int K ) { string s = \" \" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + char ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += char ( i ) ; s += char ( j ) ; } } s += char ( 97 ) ; cout << s ; } int main ( ) { int K = 4 ; generateString ( K ) ; return 0 ; }"}
{"text": "Menjana Persamaan Kuadratik setelah memberikan jumlah dan produk akar | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari persamaan kuadratik dari jumlah dan produk akar yang diberikan; Cetak pekali; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int S , int M ) { cout << \"1 ▁ \" << ( -1 ) * S << \" ▁ \" << M << endl ; } int main ( ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; return 0 ; }"}
{"text": "Buat semua elemen array sama dengan menggantikan pasangan bersebelahan dengan jumlah mereka | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum pasang unsur -unsur bersebelahan yang diperlukan untuk digantikan oleh jumlah mereka untuk membuat semua elemen array sama; Menyimpan jumlah awalan array; Kirakan Array Jumlah Awalan; Menyimpan bilangan maksimum subarray yang mana array boleh dibahagikan; Melangkah ke atas semua jumlah yang mungkin; Melintasi array; Jika jumlahnya sama dengan jumlah awalan semasa; Kira kenaikan kumpulan sebanyak 1; Jika tidak buang jumlah subkumpulan ini; Mengemas kini maksimum ini subarray; Mengembalikan bilangan operasi minimum; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( vector < int > a , int n ) { vector < int > prefix_sum ( n ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; int mx = -1 ; for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = -1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 2 , 1 , 3 } ; int N = A . size ( ) ; cout << minSteps ( A , N ) ; return 0 ; }"}
{"text": "Karakter yang paling kerap dalam rentetan selepas menggantikan semua kejadian x dalam rentetan binari | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari watak yang paling kerap selepas menggantikan x dengan sama ada '0' atau '1' mengikut syarat -syarat yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan S; Hitung kekerapan 0 dan 1; Jika wataknya adalah 1; Jika wataknya 0; Kedai pertama berlaku 1; Melintasi rentetan untuk mengira bilangan x antara dua berturut -turut 1 s; Jika watak semasa bukan x; Jika aksara semasa adalah 1, tambahkan bilangan Xs ke Count1 dan tetapkan sebelum i; Jika tidak; Cari kejadian seterusnya 1 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Simpan kejadian pertama 0; Ulangi prosedur yang sama untuk mengira bilangan x antara dua berturut -turut 0 s; Jika watak semasa bukan x; Jika watak semasa adalah 0; Tambah kiraan XS ke Count0; Tetapkan sebelumnya ke i; Jika tidak; Cari kejadian seterusnya 0 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Kiraan bilangan x yang hadir dalam permulaan rentetan sebagai xxxx1 ...; Simpan kiraan x; Kenaikan kiraan1 dengan kiraan jika keadaan itu berpuas hati; Hitung bilangan x yang hadir pada akhir rentetan sebagai ... xxxx0; Simpan kiraan x; Kenaikan kiraan dengan kiraan jika keadaan itu berpuas hati; Jika kiraan 1 adalah sama dengan kiraan 0, cetak x; Jika tidak, jika kiraan 1 lebih besar daripada kiraan 0; Jika tidak, cetak 0; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxOccuringCharacter ( string s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { count1 ++ ; } else if ( s [ i ] == '0' ) { count0 ++ ; } } int prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } if ( s [ 0 ] == ' X ' ) { int count = 0 ; int i = 0 ; while ( s [ i ] == ' X ' ) { count ++ ; i ++ ; } if ( s [ i ] == '1' ) { count1 += count ; } } if ( s [ ( s . length ( ) - 1 ) ] == ' X ' ) { int count = 0 ; int i = s . length ( ) - 1 ; while ( s [ i ] == ' X ' ) { count ++ ; i -- ; } if ( s [ i ] == '0' ) { count0 += count ; } } if ( count0 == count1 ) { cout << \" X \" << endl ; } else if ( count0 > count1 ) { cout << 0 << endl ; } else cout << 1 << endl ; } int main ( ) { string S = \" XX10XX10XXX1XX \" ; maxOccuringCharacter ( S ) ; }"}
{"text": "Memaksimumkan kiraan lembaran yang mungkin dengan berulang kali mengurangkan kawasannya kepada separuh | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum lembaran yang mungkin dengan operasi yang diberikan; Kiraan awal lembaran; Terus membahagikan kepingan ke separuh; Mengurangkan kawasan dengan separuh; Meningkatkan kiraan dua kali; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } int main ( ) { int A = 5 , B = 10 ; cout << maxSheets ( A , B ) ; return 0 ; }"}
{"text": "Bilangan langkah minimum yang diperlukan untuk mencapai asal dari titik tertentu | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari langkah minimum yang diperlukan untuk mencapai asal dari (a, b); Menyimpan bilangan minimum bergerak; Periksa sama ada perbezaan mutlak ialah 1 atau 0; Simpan minimum a, b; Simpan maksimum a, b; Cetak jawapannya; Kod pemacu; Diberikan Co - ordinat; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; } int main ( ) { int a = 3 , b = 5 ; findMinMoves ( a , b ) ; return 0 ; }"}
{"text": "Kira walaupun jumlah pasangan yang mungkin dengan memilih dua bilangan bulat dari dua julat yang diberikan masing -masing | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira walaupun jumlah pasangan dalam julat yang diberikan; Menyimpan kiraan nombor antara 1 hingga x; Menyimpan kiraan nombor ganjil antara 1 hingga x; Menyimpan kiraan nombor antara 1 hingga y; Menyimpan kiraan nombor ganjil antara 1 hingga y; Menyimpan kiraan pasangan yang mempunyai jumlah wang; Mengimbangi kiraan pasangan yang mempunyai jumlah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long cntEvenSumPairs ( long long X , long long Y ) { long long cntXEvenNums = X / 2 ; long long cntXOddNums = ( X + 1 ) / 2 ; long long cntYEvenNums = Y / 2 ; long long cntYOddNums = ( Y + 1 ) / 2 ; long long cntPairs = ( cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums ) ; return cntPairs ; } int main ( ) { long long X = 2 ; long long Y = 3 ; cout << cntEvenSumPairs ( X , Y ) ; return 0 ; }"}
{"text": "Kurangkan elemen array yang diperlukan untuk ditingkatkan atau diturunkan untuk menukar array yang diberikan ke dalam siri Fibonacci | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum bergerak untuk membuat urutan siri Fibonacci; Jika bilangan elemen kurang daripada 3; Memulakan nilai hasilnya; Cuba semua permutasi dua elemen pertama; Nilai elemen pertama selepas operasi; Nilai elemen kedua selepas operasi; Hitung bilangan gerakan untuk unsur -unsur array; Elemen pada indeks IDX; Sekiranya tidak mungkin untuk menukar elemen dalam satu langkah; Jika tidak; Mengemas kini jawapannya; Kembalikan jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMoves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { vector < int > arr = { 4 , 8 , 9 , 17 , 27 } ; cout << minMoves ( arr ) << endl ; return 0 ; }"}
{"text": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; Melangkah ke atas setiap pertanyaan; Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array dan mengira jumlah ungkapan; Kemas kini Jumlah; Kemas kini x; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ 2 ] = { { 2 , 1 } , { 3 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; querySum ( arr , N , Q , M ) ; return 0 ; }"}
{"text": "Kirakan bitwise atau dua bilangan bulat dari nilai bitwise dan bitwise mereka yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bitwise atau dari bitwise xor dan bitwise dan nilai -nilai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } int main ( ) { int X = 5 , Y = 2 ; cout << findBitwiseORGivenXORAND ( X , Y ) ; }"}
{"text": "Semak jika nilai yang diberikan dapat dicapai dari nilai lain dalam barisan bulat oleh k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa B boleh digunakan dari A dengan lompatan elemen K dalam barisan bulat; Cari GCD N dan K; Jika A - B boleh dibahagikan dengan GCD maka cetak ya; Jika tidak; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( abs ( A - B ) % gcd == 0 ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int N = 5 , A = 2 , B = 1 , K = 2 ; canReach ( N , A , B , K ) ; return 0 ; }"}
{"text": "Count subarrays mempunyai jumlah yang sama dengan panjangnya | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi yang mengira subarray dengan jumlah elemennya sebagai panjangnya; Simpan kiraan elemen sehingga elemen semasa dengan panjang i; Menyimpan kiraan akhir subarray; Menyimpan jumlah awalan; Jika saiz subarray adalah 1; Melelehkan array; Cari jumlahnya; Kekerapan kemas kini dalam peta; Cetak jumlah kiraan; Kod pemacu; Diberikan array arr []; Saiz array; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubarray ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , -2 , 2 , 4 } ; int N = sizeof arr / sizeof arr [ 0 ] ; countOfSubarray ( arr , N ) ; return 0 ; }"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Menyimpan jumlah unsur set1; Menyimpan jumlah unsur set2; Melintasi nombor semulajadi n pertama; Semak sama ada jumlah unsur set1 kurang daripada atau sama dengan jumlah unsur set2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return abs ( sumSet1 - sumSet2 ) ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }"}
{"text": "Semak jika nombor adalah perdana terbalik terbalik, cermin dibalik dan cermin terbalik terbalik | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada n mengandungi digit 0, 1, 2, 5, 8 sahaja; Ekstrak digit n; Kembali palsu jika mana -mana digit ini hadir; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Semak semua faktor; Fungsi untuk memeriksa sama ada n adalah perdana dalam semua bentuk yang dikehendaki; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; } bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } int isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; } int main ( ) { int N = 101 ; if ( isAllPrime ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Kos minimum diperlukan untuk menjana urutan pendakap seimbang | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira kos minimum yang diperlukan untuk menjana urutan pendakap yang seimbang; Menyimpan kiraan kurungan terbuka tidak seimbang; Menyimpan kiraan kurungan tertutup yang tidak seimbang; Menyimpan kiraan kurungan terbuka; Menyimpan kiraan kurungan tertutup; Jika pendakap terbuka ditemui; Jika tidak; Sekiranya tiada kurungan terbuka tidak seimbang; Meningkatkan kiraan kurungan tertutup yang tidak seimbang; Jika tidak; Mengurangkan kiraan kurungan terbuka yang tidak seimbang; Meningkatkan kiraan kurungan tertutup; Mengira batas kos minimum yang lebih rendah; Mengurangkan kurungan terbuka atau tertutup yang berlebihan untuk mengelakkan mengira mereka dua kali; Kemas kini jawapan dengan menambahkan minimum mengeluarkan kedua -dua kurungan terbuka dan tertutup yang tidak seimbang atau memasukkan kurungan tidak seimbang tertutup ke hujung rentetan; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; str [ i ] != ' \\0' ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; cout << result << endl ; } int main ( ) { string str = \" ) ) ( ) ( ( ) ( ) ( \" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; return 0 ; }"}
{"text": "Count of permutasi seperti jumlah nombor k dari julat yang diberikan adalah | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan bilangan semua permutasi seperti jumlah nombor k dalam julat adalah walaupun; Cari jumlah kiraan nombor walaupun dan ganjil dalam julat yang diberikan; ITERATE LOOP K TIMES DAN UPDATE EVER_SUM & ODD_SUM Menggunakan nilai sebelumnya; Kemas kini prev_even dan odd_sum; Malah jumlah; Jumlah ganjil; Kembali even_sum; Kod pemacu; Diberikan julat; Panjang permutasi; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << ( even_sum ) ; } int main ( ) { int low = 4 ; int high = 5 ; int K = 3 ; countEvenSum ( low , high , K ) ; }"}
{"text": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Tetapkan 2 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Cetak jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void count ( int n , int k ) { long count = ( long ) ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; cout << ( count ) ; } int main ( ) { int n = 2 , k = 1 ; count ( n , k ) ; }"}
{"text": "Jumlah pembahagi terbesar nombor sehingga tidak dibahagikan dengan nombor perdana p | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah pembahagi terbesar nombor dalam julat 1 hingga n tidak boleh dibahagikan dengan nombor perdana p; Jumlah jumlah sehingga n; Jika tidak ada beberapa p yang ada sehingga n; Jika hanya p sendiri berada dalam lingkungan 1 hingga n; Jumlah mereka yang boleh dibahagikan dengan p; Panggilan fungsi rekursif untuk mencari jumlah untuk N / P; Kod pemacu; Diberikan n dan p; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; } int main ( ) { int N = 10 , P = 5 ; cout << func ( N , P ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Kira peralihan kanan untuk setiap elemen array berada dalam kedudukan yang disusun | Program C ++ untuk melaksanakan pendekatan; Berfungsi untuk mencari peralihan yang betul yang diperlukan untuk setiap elemen untuk mencapai kedudukan array yang disusun dalam []; Kedai yang diperlukan bilangan peralihan untuk setiap elemen; Jika elemen berada pada kedudukan yang disusun; Jika tidak; Kirakan peralihan kanan; Cetak peralihan masing -masing; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findShifts ( int A [ ] , int N ) { int shift [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) cout << shift [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findShifts ( arr , N ) ; return 0 ; }"}
{"text": "Membina matriks dengan jumlah yang sama dengan jumlah unsur pepenjuru | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk membina matriks dengan jumlah pepenjuru yang sama dengan jumlah matriks; Jika kedudukan pepenjuru; Elemen positif; Elemen negatif; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructmatrix ( int N ) { bool check = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) { cout << 1 << \" ▁ \" ; } else if ( check ) { cout << 2 << \" ▁ \" ; check = false ; } else { cout << -2 << \" ▁ \" ; check = true ; } } cout << endl ; } } int main ( ) { int N = 5 ; constructmatrix ( 5 ) ; return 0 ; }"}
{"text": "Kiraan minimum nombor yang diperlukan dengan unit digit x yang merangkum sehingga n | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan bilangan minimum kali nombor dengan unit digit X perlu ditambah untuk mendapatkan jumlah n; Kirakan bilangan penambahan yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Berfungsi untuk mengembalikan nombor minimum yang diperlukan untuk mewakili n; Kedai Unit Digit N; Penambahan minimum x yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Jika tidak; Jika n lebih besar daripada atau sama dengan (x * kali); Kiraan minimum nombor yang diperlukan untuk mewakili n; Perwakilan tidak mungkin; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int unit_digit , int X ) { int times , digit ; for ( int times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return -1 ; } int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == -1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return -1 ; } } int main ( ) { int N = 58 , X = 7 ; cout << getNum ( N , X ) << endl ; return 0 ; }"}
{"text": "Bilangan minimum mata yang diperlukan untuk menampung semua blok 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum mata yang diperlukan untuk menampung grid; Jika bilangan blok adalah juga; Mengembalikan mata minimum; Kod pemacu; Diberikan saiz grid; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } int main ( ) { int N = 5 , M = 7 ; cout << minPoints ( N , M ) ; return 0 ; }"}
{"text": "String lexicographical terbesar dengan paling banyak unsur berturut -turut K | C ++ kod untuk pendekatan di atas; Fungsi untuk mencari rentetan leksikografi terbesar dengan kekangan yang diberikan. ; vektor yang mengandungi kekerapan setiap aksara. ; Menetapkan kekerapan kepada; kosongkan rentetan jenis kelas rentetan; Gelung untuk melangkah ke atas keutamaan maksimum terlebih dahulu. ; Jika kekerapan lebih besar daripada atau sama dengan k. ; Pembolehubah sementara untuk beroperasi di tempat k. ; menggabungkan dengan rentetan yang dihasilkan. ; Pengendalian kes K dengan menyesuaikan dengan unsur keutamaan yang lebih kecil. ; keadaan untuk mengesahkan sama ada indeks j mempunyai kekerapan yang lebih besar daripada 0; ; Jika tiada elemen sedemikian dijumpai daripada rentetan tidak dapat diproses lagi. ; Jika kekerapan lebih besar daripada 0 dan kurang daripada k. ; Di sini kita tidak perlu memperbaiki kriteria elemen berturut -turut. ; Jika tidak, periksa elemen seterusnya yang mungkin. ; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE string getLargestString ( string s , ll k ) { vector < int > frequency_array ( 26 , 0 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { frequency_array [ s [ i ] - ' a ' ] ++ ; } string ans = \" \" ; for ( int i = 25 ; i >= 0 ; ) { if ( frequency_array [ i ] > k ) { int temp = k ; string st ( 1 , i + ' a ' ) ; while ( temp > 0 ) { ans += st ; temp -- ; } frequency_array [ i ] -= k ; int j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; } if ( frequency_array [ j ] > 0 && j >= 0 ) { string str ( 1 , j + ' a ' ) ; ans += str ; frequency_array [ j ] -= 1 ; } else { break ; } } else if ( frequency_array [ i ] > 0 ) { int temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; string st ( 1 , i + ' a ' ) ; while ( temp > 0 ) { ans += st ; temp -- ; } } else { i -- ; } } return ans ; } int main ( ) { string S = \" xxxxzza \" ; int k = 3 ; cout << getLargestString ( S , k ) << endl ; return 0 ; }"}
{"text": "Operasi minimum untuk menjadikan semua elemen sama menggunakan array kedua | Pelaksanaan C ++ untuk mencari operasi minimum menjadikan semua elemen sama menggunakan array kedua; Berfungsi untuk mencari operasi minimum yang diperlukan untuk membuat semua elemen array sama; Elemen minimum []; Melintasi semua nilai akhir; Pembolehubah yang menunjukkan sama ada semua elemen boleh ditukar kepada x atau tidak; Jumlah operasi; Melintasi semua elemen array; Semua elemen tidak boleh ditukar kepada x; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = * min_element ( a , a + n ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = 1 ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = 0 ; break ; } } if ( check ) return operations ; } return -1 ; } int main ( ) { int N = 5 ; int A [ N ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ N ] = { 2 , 2 , 1 , 3 , 5 } ; cout << minOperations ( A , B , N ) ; return 0 ; }"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | C ++ pelaksanaan untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = max ( max_sum , i + j ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }"}
{"text": "Memaksimumkan jumlah array selepas mengalikan awalan dan akhiran oleh | C ++ pelaksanaan untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran array oleh - 1; Algoritma Kadane untuk mencari jumlah subarray maksimum; Gelung untuk mencari jumlah array subarray maksimum dalam array yang diberikan; Berfungsi untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran oleh - 1; Jumlah jumlah intital; Gelung untuk mencari jumlah maksimum array; Nilai maksimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } int maxSum ( int a [ ] , int n ) { int S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; } int main ( ) { int a [ ] = { -1 , -2 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSum ( a , n ) ; cout << max_sum ; return 0 ; }"}
{"text": "Count of Prima yang menarik sehingga n | Program C ++ untuk mencari bilangan prima yang menarik sehingga N; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Jika n boleh dibahagikan dengan mana -mana nombor antara 2 dan sqrt (n), ia bukan perdana; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk mencari bilangan prima yang menarik kurang daripada sama dengan n. ; Periksa sama ada nombor itu adalah perdana atau tidak; Berulang untuk nilai b; Periksa syarat untuk a; Mengembalikan jawapan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; } bool isPerfectSquare ( int x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } int main ( ) { int N = 10 ; cout << countInterestingPrimes ( N ) ; return 0 ; }"}
{"text": "Memaksimumkan nombor dengan membalikkan kebanyakan bit k | C ++ pelaksanaan pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan nombor yang dimaksimumkan dengan membalikkan atmost k bit; Bilangan bit dalam n; Cari perwakilan binari n; Untuk mengira bilangan 0 s terbalik; Mengembalikan setara perpuluhan nombor yang dimaksimumkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int maxNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; } int main ( ) { int n = 4 , k = 1 ; cout << maxNum ( n , k ) ; return 0 ; }"}
{"text": "Cari berikutnya dengan jumlah yang diberikan dalam urutan superincreasing | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari seterusnya yang diperlukan; Elemen semasa tidak boleh menjadi sebahagian daripada berikutnya yang diperlukan; Termasuk elemen semasa dalam seterusnya yang diperlukan supaya mengemas kini jumlah; Cetak unsur -unsur berikutnya yang diperlukan; Jika elemen semasa dimasukkan ke dalam berikutnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = -1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != -1 ) cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; return 0 ; }"}
{"text": "Cari abjad yang paling bernilai dalam rentetan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan abjad bernilai maksimum; Untuk menyimpan kejadian pertama dan terakhir semua watak; Tetapkan kejadian pertama dan terakhir semua aksara kepada - 1; Kemas kini kejadian watak -watak; Hanya menetapkan kejadian pertama jika ia tidak telah ditetapkan; Untuk menyimpan hasilnya; Untuk setiap abjad; Jika abjad semasa tidak muncul dalam rentetan yang diberikan; Jika watak semasa mempunyai nilai tertinggi setakat ini; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; char maxAlpha ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int ans = -1 , maxVal = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } int main ( ) { string str = \" abbba \" ; int len = str . length ( ) ; cout << maxAlpha ( str , len ) ; return 0 ; }"}
{"text": "Pertanyaan untuk bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array | C ++ pelaksanaan pendekatan; Berfungsi untuk melakukan pertanyaan untuk mencari bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array; Periksa sama ada elemen semasa sudah dilawati atau tidak; Jika tidak melawat kaunter semasa dan kenaikannya dan semak semak sebagai 1; Jika tidak, jika dikunjungi hanya menyimpan kaunter semasa; Melakukan pertanyaan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int check [ MAX ] = { 0 } ; int idx [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; cout << idx [ m ] << \" ▁ \" ; } } int main ( ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = sizeof ( queries ) / sizeof ( int ) ; find_distinct ( a , n , q , queries ) ; return 0 ; }"}
{"text": "Tukar Integer X diberikan kepada Borang 2 ^ n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan operasi yang diperlukan; Untuk menyimpan kuasa 2; Pembolehubah sementara untuk menyimpan X; Untuk menyimpan indeks nombor yang lebih kecil daripada x; Untuk menyimpan kiraan operasi; Menyimpan indeks nombor dalam bentuk 2 ^ n - 1; Jika x sudah ada dalam bentuk 2 ^ n - 1 maka tiada operasi diperlukan; Jika nombor kurang daripada x meningkatkan indeks; Kirakan semua nilai (x xor 2 ^ n - 1) untuk semua yang mungkin n; Hanya mengambil nilai yang lebih dekat dengan nombor; Jika nombor berada dalam bentuk 2 ^ n - 1 maka pecah; Mengembalikan kiraan operasi yang diperlukan untuk mendapatkan nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 24 ; int countOp ( int x ) { int arr [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } int main ( ) { int x = 39 ; cout << countOp ( x ) ; return 0 ; }"}
{"text": "Bilangan minimum operasi yang diberikan untuk mengurangkan array ke 0 elemen | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Hitung kekerapan setiap elemen; Elemen maksimum dari array; Cari semua gandaan i; Padamkan gandaan; Meningkatkan operasi; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int * arr , int n ) { int maxi , result = 0 ; vector < int > freq ( 1000001 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = * ( max_element ( arr , arr + n ) ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }"}
{"text": "Minimum LCM dan GCD mungkin di antara semua sub | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan GCD minimum di kalangan semua subarray; GCD minimum di antara semua sub -tatasusunan akan menjadi GCD dari semua elemen array; Berfungsi untuk mengembalikan LCM minimum di kalangan semua subarray; LCM minimum di antara semua sub - tatasusunan akan menjadi elemen minimum dari array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; } int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = min ( minLCM , arr [ i ] ) ; return minLCM ; } int main ( ) { int arr [ ] = { 2 , 66 , 14 , 521 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" LCM ▁ = ▁ \" << minLCM ( arr , n ) << \" , ▁ GCD ▁ = ▁ \" << minGCD ( arr , n ) ; return 0 ; }"}
{"text": "Bentuk rentetan terkecil secara lexicographically dengan penggantian minimum yang mempunyai bilangan yang sama 0 s, 1 s dan 2 s | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan rentetan terkecil lexicographically yang diubahsuai selepas melakukan bilangan minimum operasi yang diberikan; Menyimpan frekuensi awal aksara 0 s, 1 s dan 2 s; Menyimpan bilangan aksara yang diproses sehingga titik setiap jenis; Bilangan aksara yang diperlukan setiap jenis; Jika jenis semasa telah membatalkan bilangan aksara, tidak perlu melakukan apa -apa operasi; Proses semua 3 kes; Semak 1 pertama; Lain 2; Di sini kita perlu menyemak yang diproses [1] hanya untuk 2 kerana 0 adalah kurang daripada 1 dan kita boleh menggantikannya pada bila -bila masa; Di sini kita boleh menggantikan 2 dengan 0 dan 1 bila -bila masa; Simpan kiraan aksara yang diproses setiap jenis; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string formStringMinOperations ( string s ) { int count [ 3 ] = { 0 } ; for ( auto & c : s ) count ++ ; int processed [ 3 ] = { 0 } ; int reqd = ( int ) s . size ( ) / 3 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( count [ s [ i ] - '0' ] == reqd ) continue ; if ( s [ i ] == '0' && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) { if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 0 ] -- ; } else if ( count [ 2 ] < reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 0 ] -- ; } } if ( s [ i ] == '1' && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 1 ] -- ; } } if ( s [ i ] == '2' && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 2 ] -- ; } } processed [ s [ i ] - '0' ] ++ ; } return s ; } int main ( ) { string s = \"011200\" ; cout << formStringMinOperations ( s ) ; return 0 ; }"}
{"text": "Bilangan minimum swap bersebelahan untuk mengatur unsur -unsur yang sama bersama -sama | Program C ++ untuk mencari bilangan minimum swap bersebelahan untuk mengatur item yang sama bersama -sama; Berfungsi untuk mencari swap minimum; Arahan yang dikunjungi untuk memeriksa sama ada nilai sudah dilihat; Jika arr [i] dilihat kali pertama; menyimpan bilangan swap yang diperlukan untuk mencari kedudukan yang betul dari rakan kongsi elemen semasa; Kiraan kenaikan hanya jika elemen semasa belum dikunjungi (jika dikunjungi, bermakna ia telah diletakkan pada kedudukan yang betul); Jika rakan kongsi elemen semasa dijumpai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimumSwaps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; N /= 2 ; cout << findMinimumAdjacentSwaps ( arr , N ) << endl ; return 0 ; }"}
{"text": "Nombor Palindromic Terbesar dengan Permuting Digits | Program CPP untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; berfungsi untuk memeriksa sama ada nombor boleh dibentuk untuk membentuk nombor palindrome; Mengira kejadian nombor yang ganjil; Sekiranya kejadian ganjil; jika nombor melebihi 1; berfungsi untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; panjang rentetan; peta yang menandakan kejadian nombor; Semak kemungkinan nombor palindromik; array rentetan yang menyimpan nombor palindromik yang terbesar; penunjuk depan; Ramuan bermula dari 9 hingga 0 dan letakkan nombor yang lebih besar di depan dan ganjil di tengah; Sekiranya berlakunya nombor adalah ganjil; Letakkan satu nombor ganjil di tengah; mengurangkan kiraan; Letakkan seluruh nombor dengan tamak; Jika semua nombor berlaku walaupun masa, maka letakkan dengan tamak; Letakkan tamak di hadapan; 2 nombor diletakkan, jadi mengurangkan kiraan; meningkatkan kedudukan meletakkan; Cetak rentetan terbesar yang terbentuk; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possibility ( unordered_map < int , int > m , int length , string s ) { int countodd = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( m [ s [ i ] - '0' ] & 1 ) countodd ++ ; if ( countodd > 1 ) return false ; } return true ; } void largestPalindrome ( string s ) { int l = s . length ( ) ; unordered_map < int , int > m ; for ( int i = 0 ; i < l ; i ++ ) m [ s [ i ] - '0' ] ++ ; if ( possibility ( m , l , s ) == false ) { cout << \" Palindrome ▁ cannot ▁ be ▁ formed \" ; return ; } char largest [ l ] ; int front = 0 ; for ( int i = 9 ; i >= 0 ; i -- ) { if ( m [ i ] & 1 ) { largest [ l / 2 ] = char ( i + 48 ) ; m [ i ] -- ; while ( m [ i ] > 0 ) { largest [ front ] = char ( i + 48 ) ; largest [ l - front - 1 ] = char ( i + 48 ) ; m [ i ] -= 2 ; front ++ ; } } else { while ( m [ i ] > 0 ) { largest [ front ] = char ( i + 48 ) ; largest [ l - front - 1 ] = char ( i + 48 ) ; m [ i ] -= 2 ; front ++ ; } } } for ( int i = 0 ; i < l ; i ++ ) cout << largest [ i ] ; } int main ( ) { string s = \"313551\" ; largestPalindrome ( s ) ; return 0 ; }"}
{"text": "Swap minimum untuk mengimbangi pendakap | Program C ++ untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Fungsi untuk mengira swap yang diperlukan; Jejaki '['; Untuk mengira bilangan yang ditemui '['; Untuk mengesan kedudukan seterusnya '[' dalam POS; Untuk menyimpan hasil; Kiraan kenaikan dan bergerak P ke kedudukan seterusnya; Kami telah menemui bahagian rentetan yang tidak seimbang; Jumlah kenaikan dengan bilangan swap yang diperlukan i. e. kedudukan seterusnya '[' - kedudukan semasa; Tetapkan semula kiraan kepada 1; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; long swapCount ( string s ) { vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s [ i ] == ' [ ' ) pos . push_back ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( s [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos [ p ] - i ; swap ( s [ i ] , s [ pos [ p ] ] ) ; ++ p ; count = 1 ; } } return sum ; } int main ( ) { string s = \" [ ] ] [ ] [ \" ; cout << swapCount ( s ) << \" STRNEWLINE \" ; s = \" [ [ ] [ ] ] \" ; cout << swapCount ( s ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Kos minimum untuk memotong papan ke dalam dataran | Program C ++ untuk membahagikan papan ke dalam kotak m * n; kaedah mengembalikan kos minimum untuk memecahkan papan ke dalam kotak m * n; menyusun kos mendatar dalam urutan terbalik; menyusun kos menegak dalam urutan terbalik; memulakan lebar semasa sebagai 1; gelung sehingga satu atau kedua -dua kos kos diproses; meningkatkan kiraan bahagian mendatar semasa dengan 1; meningkatkan kiraan bahagian menegak semasa dengan 1; gelung untuk array mendatar, jika kekal; gelung untuk pelbagai menegak, jika kekal; Kod pemacu untuk menguji kaedah di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } int main ( ) { int m = 6 , n = 4 ; int X [ m - 1 ] = { 2 , 1 , 3 , 1 , 4 } ; int Y [ n - 1 ] = { 4 , 1 , 2 } ; cout << minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ; return 0 ; }"}
{"text": "Kurangkan kiraan aksara yang akan ditambah atau dikeluarkan untuk membuat pengulangan rentetan substring yang sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari minimum tiga nombor; Berfungsi untuk mencari operasi bilangan minimum yang diperlukan untuk menukar string str1 ke str2 menggunakan operasi; Menyimpan hasil subproblem; Isi dp [] [] dengan cara bawah; Jika str1 kosong, masukkan semua aksara string str2; Operasi minimum ialah J; Jika str2 kosong, maka keluarkan semua aksara string str2; Operasi minimum ialah i; Jika watak terakhir adalah sama, maka abaikan watak terakhir; Jika watak terakhir berbeza, maka cari minimum; Lakukan salah satu sisipan, keluarkan dan ganti; Mengembalikan bilangan langkah minimum yang diperlukan; Berfungsi untuk mencari bilangan langkah minimum untuk mengubah suai rentetan sedemikian rupa sehingga separuh pertama dan separuh kedua menjadi sama; Menyimpan bilangan minimum operasi yang diperlukan; Melintasi rentetan yang diberikan; Cari operasi minimum; Kemas kini ANS; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMin ( int x , int y , int z ) { return min ( min ( x , y ) , z ) ; } int editDistance ( string str1 , string str2 , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; } void minimumSteps ( string & S , int N ) { int ans = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { string S1 = S . substr ( 0 , i ) ; string S2 = S . substr ( i ) ; int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ; ans = min ( ans , count ) ; } cout << ans << ' ' ; } int main ( ) { string S = \" aabb \" ; int N = S . length ( ) ; minimumSteps ( S , N ) ; return 0 ; }"}
{"text": "Kurangkan operasi untuk mengurangkan n hingga 2 dengan berulang kali mengurangkan 3 atau membahagikan dengan 5 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi untuk mengurangkan n hingga 2 dengan membahagikan n dengan 5 atau penurunan sebanyak 3; Memulakan array DP; Memulakan array dp []; Untuk n = 2 bilangan operasi yang diperlukan adalah sifar; Melangkah ke atas julat [1, n]; Jika ia tidak mungkin untuk membuat n semasa; Kalikan dengan 5; Menambah nilai 3; Memeriksa jika tidak mungkin untuk membuat nombor sebagai 2; Mengembalikan bilangan operasi minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperations ( int N ) { int dp [ N + 1 ] ; int i ; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return -1 ; return dp [ N ] ; } int main ( ) { int N = 25 ; cout << minimumOperations ( N ) ; return 0 ; }"}
{"text": "Keuntungan maksimum selepas membeli dan menjual stok dengan yuran transaksi | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari keuntungan maksimum dengan yuran transaksi; Melintasi stok untuk setiap hari; Kemas kini membeli dan menjual; Mengembalikan keuntungan maksimum; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = max ( buy , sell - arr [ i ] ) ; sell = max ( sell , temp + arr [ i ] - transactionFee ) ; } return max ( sell , buy ) ; } int main ( ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int transactionFee = 2 ; cout << MaxProfit ( arr , n , transactionFee ) ; return 0 ; }"}
{"text": "Jumlah maksimum dari kiri ke bawah kanan matriks melalui salah satu sel yang diberikan | Program C ++ untuk pendekatan di atas; Menyimpan jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Menyimpan jumlah laluan maksimum dari sel (j, j) hingga (n, m); Berfungsi untuk mencari jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Melintasi baris pertama; Melintasi lajur pertama; Melintasi matriks; Kemas kini nilai permulaan [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari sel (j, j) hingga (n, m); Melintasi baris terakhir; Melintasi lajur terakhir; Melintasi matriks; Kemas kini nilai berakhir [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari atas - kiri ke sel kanan bawah supaya laluan itu mengandungi salah satu sel dalam koordinat array [] []; Memulakan permulaan dan matriks akhir; Kirakan matriks permulaan; Kirakan matriks akhir; Menyimpan jumlah laluan maksimum; Melintasi koordinat; Kemas kini nilai ANS; Cetak nilai laluan jumlah maksimum yang dihasilkan; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int start [ 3 ] [ 3 ] ; int ending [ 3 ] [ 3 ] ; void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } } void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } } void maximumPathSum ( int mat [ ] [ 3 ] , int n , int m , int q , int coordinates [ ] [ 2 ] ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ; ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } cout << ans ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int N = 3 ; int M = 3 ; int Q = 2 ; int coordinates [ ] [ 2 ] = { { 1 , 2 } , { 2 , 2 } } ; maximumPathSum ( mat , N , M , Q , coordinates ) ; }"}
{"text": "Panjang subset terpanjang yang terdiri daripada 0 s dan b 1 s dari pelbagai rentetan | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari panjang subset terpanjang pelbagai rentetan dengan paling banyak 0 s dan b 1 s; Memulakan array 2D dengan penyertaannya sebagai 0; Melintasi array yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan semasa; Melangkah dalam julat [a, sifar]; Berulang dalam julat [b, yang]; Mengemas kini nilai dp [i] [j]; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxSubsetlength ( vector < string > arr , int A , int B ) { int dp [ A + 1 ] [ B + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( auto & str : arr ) { int zeros = count ( str . begin ( ) , str . end ( ) , '0' ) ; int ones = count ( str . begin ( ) , str . end ( ) , '1' ) ; for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; } int main ( ) { vector < string > arr = { \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" } ; int A = 5 , B = 3 ; cout << MaxSubsetlength ( arr , A , B ) ; return 0 ; }"}
{"text": "Kira cara untuk memilih pasangan gula -gula warna yang berbeza (pengaturcaraan dinamik + bitmasking) | C ++ 14 Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira cara untuk memilih N yang berbeza pasangan gula -gula dengan warna yang berbeza; Jika pasangan N dipilih; Kedai mengira cara untuk memilih pasangan i - th; Melangkah ke atas julat [0, n]; Jika pasangan (i, j) tidak termasuk; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && blue . find ( j ) == blue . end ( ) ) { blue . insert ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . erase ( j ) ; } } return count ; } int main ( ) { int n = 3 ; vector < vector < int > > mat = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; set < int > mpp ; cout << ( numOfWays ( mat , n , 0 , mpp ) ) ; }"}
{"text": "Kurangkan kos untuk mencapai hujung array oleh dua lompatan ke hadapan atau satu lompatan ke belakang dalam setiap langkah | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mencapai akhir array; Kes asas: apabila n <3; Simpan hasil dalam jadual; Memulakan kes asas; Melangkah ke atas julat [2, n - 2] untuk membina array DP; Mengendalikan kes untuk indeks terakhir, i. e. N - 1; Cetak jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int * dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; } int main ( ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minCost ( arr , N ) ; return 0 ; }"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); Kedai perwakilan binari n; Kedai kuasa 10; Kirakan perwakilan binari n; Jika n adalah nombor ganjil; Kemas kini x; Kemas kini pow_10; Kemas kini n; Dua kali ganda nilai x; Menyimpan nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } int findValue ( long long int n ) { long long X = 0 ; long long pow_10 = 1 ; while ( n ) { if ( n & 1 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; long long res = power ( 2 , X ) ; return res ; } int main ( ) { long long n = 2 ; cout << findValue ( n ) ; return 0 ; }"}
{"text": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); dp [n] * dp [n]: Kedai nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kes asas; Melangkah ke atas julat [3, n]; Kedai paling tepat dari saya; Menyimpan nilai (i - y); Jika x adalah kuasa 2; Kemas kini DP [i]; Kemas kini DP [i]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } long long findValue ( long long N ) { long long dp [ N + 1 ] ; dp [ 1 ] = 2 ; dp [ 2 ] = 1024 ; for ( int i = 3 ; i <= N ; i ++ ) { int y = ( i & ( - i ) ) ; int x = i - y ; if ( x == 0 ) { dp [ i ] = power ( dp [ i / 2 ] , 10 ) ; } else { dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; } } return ( dp [ N ] * dp [ N ] ) % M ; } int main ( ) { long long n = 150 ; cout << findValue ( n ) ; return 0 ; }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan cara untuk mendapatkan jumlah n dengan membuang dadu; Kes asas; Menyimpan jumlah jumlah cara untuk mendapatkan jumlah n; Berulang untuk semua 6 negeri; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } int main ( ) { int N = 4 ; cout << findWays ( N ) ; return 0 ; }"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program C ++ untuk pendekatan di atas; Fungsi utiliti untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Kes asas; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengembalikan nilai maksimum di antara semua 3 panggilan rekursif; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return max ( max ( l , m ) , r ) ; } } void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEqualSum ( arr , N ) ; return 0 ; }"}
{"text": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa array boleh menjadi partition ke dalam jumlah 3 sama; Kes asas; Jika nilai pada indeks tertentu tidak - 1 maka nilai pulangan pada indeks itu yang memastikan tiada lagi panggilan lagi; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengemas kini keadaan semasa dan mengembalikan nilai itu; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < string , int > dp ; int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { string s = to_string ( sm1 ) + \" _ \" + to_string ( sm2 ) + to_string ( j ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return dp [ s ] = max ( max ( l , m ) , r ) ; } } void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEqualSum ( arr , N ) ; return 0 ; }"}
{"text": "Indeks terkecil dalam pelbagai indeks yang tidak sama dengan x | Program C ++ untuk mencari indeks terkecil dalam array dalam julat [l, r] yang tidak mengandungi x; Precompute Indeks elemen yang berbeza seterusnya dalam array untuk setiap elemen array; Nilai lalai; Kirakan Nextpos [i] menggunakan Nextpos [i + 1]; Berfungsi untuk mengembalikan indeks terkecil; Nextpos [i] akan menyimpan kedudukan seterusnya p di mana arr [p]! = arr [i]; Jika x tidak hadir di l; Jika tidak; Cari indeks yang menyimpan nilai yang berbeza dari x; Jika indeks itu berada dalam julat; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void precompute ( int nextpos [ ] , int arr [ ] , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } } void findIndex ( int query [ ] [ 3 ] , int arr [ ] , int N , int Q ) { int nextpos [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = -1 ; if ( arr [ l ] != x ) ans = l ; else { int d = nextpos [ l ] ; if ( d <= r ) ans = d ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ Q ] [ 3 ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; return 0 ; }"}
{"text": "Mengira bilangan cara untuk menukar rentetan s ke t dengan melakukan peralihan kitaran k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk menukar rentetan s ke rentetan t dengan melakukan peralihan kitaran k; Hitung panjang rentetan; 'A' bukan peralihan siklik yang baik 'B' bukan peralihan siklik yang buruk; Iterat dalam rentetan; Precompute bilangan peralihan kitaran yang baik dan buruk; DP2 [i] untuk menyimpan tidak ada cara untuk mendapatkan peralihan yang buruk dalam saya bergerak; Kirakan peralihan yang baik dan buruk; Mengembalikan bilangan cara yang diperlukan; Kod pemacu; Diberikan rentetan; Memandangkan pergeseran k diperlukan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  10000000007 NEW_LINE long long countWays ( string s , string t , int k ) { int n = s . size ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } vector < long long > dp1 ( k + 1 ) , dp2 ( k + 1 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } int main ( ) { string S = \" ab \" , T = \" ab \" ; int K = 2 ; cout << countWays ( S , T , K ) ; return 0 ; }"}
{"text": "Kurangkan langkah -langkah untuk mencapai k dari 0 dengan menambah 1 atau menggandakan pada setiap langkah | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari operasi minimum; Vektor DP diasaskan untuk menyimpan langkah -langkah; Untuk semua nombor walaupun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( int k ) { vector < int > dp ( k + 1 , 0 ) ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } int main ( ) { int K = 12 ; cout << minOperation ( k ) ; }"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Pelaksanaan CPP untuk pendekatan rekursif yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; Abaikan elemen semasa; termasuk elemen dalam partition 1; termasuk elemen dalam partition 2; Kod pemacu; saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( 0 , 0 , a , 0 , n ) ; return 0 ; }"}
{"text": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Pelaksanaan CPP untuk pendekatan pengaturcaraan dinamik yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; jumlah semua elemen; Jadual carian bawah; ; jadual DP yang memulakan dengan int_min di mana, int_min bermaksud tiada penyelesaian; Kes apabila diff adalah 0; Meletakkan elemen ITH dalam G0; Meletakkan elemen ITH dalam G1; Mengabaikan elemen ith; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int dp [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( a , n ) ; return 0 ; }"}
{"text": "Count of Strings mungkin dengan menggantikan dua watak yang sama berturut -turut dengan watak baru | Program C ++ untuk mengira borang rentetan yang berbeza dengan menggantikan dua aksara yang sama dengan satu; Array untuk mencari urutan Fibonacci; Berfungsi untuk mencari urutan Fibonacci; Berfungsi untuk mengira semua rentetan yang mungkin; Memulakan ans = 1; Jika dua char berturut -turut adalah peningkatan yang sama CNT; Lain melipatgandakan FIB [CNT] ke Ans dan memulakan Ans hingga 1; Jika str = abcdeeee, maka untuk terakhir \"eeee\" kiraan munst dikemas kini; Mengembalikan jumlah jumlah; Kod pemandu; Berfungsi untuk precompute semua nombor Fibonacci; Fungsi panggilan untuk mencari kiraan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fib [ 100005 ] ; void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } int countString ( string str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; str [ i ] ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; } int main ( ) { string str = \" abdllldefkkkk \" ; computeFibonacci ( ) ; cout << countString ( str ) ; return 0 ; }"}
{"text": "Urutan Golomb | Tetapkan 2 | Program C ++ untuk mencari terma pertama N Golomb urutan; Berfungsi untuk mencetak urutan Golomb; Memulakan array; Memulakan CNT hingga 0; Elemen pertama dan kedua urutan Golomb ialah 0, 1; Peta untuk menyimpan kiraan elemen semasa dalam urutan Golomb; Simpan kiraan 2; Melangkah lebih dari 2 hingga n; Jika CNT sama dengan 0 maka kami mempunyai nombor baru untuk urutan Golomb yang 1 + elemen sebelumnya; Lain elemen semasa adalah elemen sebelumnya dalam urutan ini; Peta indeks semasa ke nilai semasa dalam arr []; Cetak urutan Golomb; Kod pemacu", "code": "#include \" bits / stdc + + . h \" NEW_LINE #define MAX  100001 NEW_LINE using namespace std ; void printGolombSequence ( int N ) { int arr [ MAX ] ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; map < int , int > M ; M [ 2 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M [ i ] = arr [ i ] ; } for ( int i = 1 ; i <= N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } int main ( ) { int N = 11 ; printGolombSequence ( N ) ; return 0 ; }"}
{"text": "Kira cara untuk mencapai tangga nth dengan mengambil 1 dan 2 langkah dengan tepat satu 3 langkah | C ++ pelaksanaan untuk mencari bilangan bilangan cara untuk mencapai tangga nth dengan mengambil 1, 2 langkah pada satu masa dan 3 langkah pada satu masa tepat sekali. ; Berfungsi untuk mencari bilangan bilangan cara untuk mencapai tangga nth; Array termasuk bilangan cara yang merangkumi 3; Array termasuk bilangan cara yang tidak termasuk 3; Pada mulanya untuk mencapai 3 tangga dengan mengambil 3 langkah boleh dicapai dengan 1 cara; Gelung untuk mencari nombor bilangan cara untuk mencapai tangga nth; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int number_of_ways ( int n ) { int includes_3 [ n + 1 ] = { } ; int not_includes_3 [ n + 1 ] = { } ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } int main ( ) { int n = 7 ; cout << number_of_ways ( n ) ; return 0 ; }"}
{"text": "Bilangan maksimum gandaan dalam array sebelum mana -mana elemen | C ++ pelaksanaan pendekatan; Peta untuk menyimpan kiraan pembahagi; Berfungsi untuk menjana pembahagi semua elemen array; Berfungsi untuk mencari bilangan maksimum gandaan dalam array sebelum itu; Untuk menyimpan kiraan pembahagi maksimum; Kemas kini Ans Jika lebih banyak bilangan pembahagi dijumpai; Menjana semua pembahagi elemen seterusnya dari array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; int divisors [ MAX ] ; int generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } } int findMaxMultiples ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMaxMultiples ( arr , n ) ; return 0 ; }"}
{"text": "Bilangan cara untuk mencapai akhir matriks dengan bukan | C ++ pelaksanaan pendekatan; Arahan 3D untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Fungsi untuk mengembalikan kiraan laluan yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE #define maxV  20 NEW_LINE using namespace std ; int dp [ n ] [ n ] [ maxV ] ; int v [ n ] [ n ] [ maxV ] ; int countWays ( int i , int j , int x , int arr [ ] [ n ] ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; cout << countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ; return 0 ; }"}
{"text": "Jumlah maksimum dari tiga tatasusunan yang memilih unsur -unsur berturut -turut dari yang sama tidak dibenarkan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Sudah dikunjungi; Jika elemen telah diambil dari array pertama dalam langkah sebelumnya; Jika elemen telah diambil dari array kedua dalam langkah sebelumnya; Jika elemen telah diambil dari array ketiga dalam langkah sebelumnya; Kod pemacu; Pilih elemen dari array pertama; Pilih elemen dari array kedua; Pilih elemen dari array ketiga; Cetak maksimum mereka", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 3 ; int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ N ] ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != -1 ) return dp [ ind ] [ kon ] ; int ans = -1e9 + 5 ; if ( kon == 0 ) { ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; } int main ( ) { int a [ ] = { 6 , 8 , 2 , 7 , 4 , 2 , 7 } ; int b [ ] = { 7 , 8 , 5 , 8 , 6 , 3 , 5 } ; int c [ ] = { 8 , 3 , 2 , 6 , 8 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ n ] [ N ] ; memset ( dp , -1 , sizeof dp ) ; int x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ; int y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ; int z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ; cout << max ( x , max ( y , z ) ) ; return 0 ; }"}
{"text": "Bilangan cara untuk membuat rentetan panjang panjang n sedemikian rupa sehingga 0 s sentiasa berlaku bersama dalam kumpulan saiz k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan tidak ada cara untuk membina rentetan panjang binari sehingga 0 s selalu berlaku dalam kumpulan saiz k; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int noOfBinaryStrings ( int N , int k ) { int dp [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } int main ( ) { int N = 4 ; int K = 2 ; cout << noOfBinaryStrings ( N , K ) ; return 0 ; }"}
{"text": "Bilangan cara untuk memasangkan orang | Program CPP untuk mencari beberapa cara untuk memasangkan orang dalam parti; Berfungsi untuk mencari bilangan cara untuk memasangkan orang dalam parti; Untuk menyimpan jumlah cara. ; Menggunakan kiraan cari yang ditakrifkan berulang untuk nilai yang berbeza p. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWaysToPair ( int p ) { int dp [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } int main ( ) { int p = 3 ; cout << findWaysToPair ( p ) ; return 0 ; }"}
{"text": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pelaksanaan rekursif mudah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; kes asas; Untuk kes n> 2; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } int main ( ) { int n = 10 ; cout << CountWays ( n ) ; return 0 ; }"}
{"text": "Nombor pelik | Program C ++ untuk memeriksa sama ada nombor itu pelik atau tidak; Kod untuk mencari semua faktor nombor tidak termasuk nombor itu sendiri; vektor untuk menyimpan faktor -faktor; Perhatikan bahawa gelung ini berjalan sehingga sqrt (n); jika nilai saya adalah faktor; Keadaan untuk memeriksa pembahagi bukan nombor itu sendiri; mengembalikan vektor; Berfungsi untuk memeriksa sama ada nombor itu banyak atau tidak; Cari pembahagi menggunakan fungsi; Jumlah semua faktor; Periksa banyak atau tidak; Berfungsi untuk memeriksa sama ada nombor itu separuh - sempurna atau tidak; Cari pembahagi; menyusun vektor; subset untuk memeriksa sama ada tidak semiperfect; memulakan lajur 1 st untuk benar; memulakan baris 1 st kecuali kedudukan sifar ke 0; gelung untuk mencari sama ada nombor itu semiperfect; pengiraan untuk memeriksa sama ada nombor itu boleh dibuat dengan penjumlahan pembahagi; jika tidak mungkin untuk membuat nombor dengan gabungan mana -mana pembahagi; Berfungsi untuk memeriksa pelik atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > factors ( int n ) { vector < int > v ; v . push_back ( 1 ) ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . push_back ( i ) ; if ( n / i != i ) { v . push_back ( n / i ) ; } } } return v ; } bool checkAbundant ( int n ) { vector < int > v ; int sum = 0 ; v = factors ( n ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v [ i ] ; } if ( sum > n ) return true ; else return false ; } bool checkSemiPerfect ( int n ) { vector < int > v ; v = factors ( n ) ; sort ( v . begin ( ) , v . end ( ) ) ; int r = v . size ( ) ; bool subset [ r + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v [ i - 1 ] ] ; } } } if ( ( subset [ r ] [ n ] ) == 0 ) return false ; else return true ; } bool checkweird ( int n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; } int main ( ) { int n = 70 ; if ( checkweird ( n ) ) cout << \" Weird ▁ Number \" ; else cout << \" Not ▁ Weird ▁ Number \" ; return 0 ; }"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Program C ++ untuk mencetak jumlah array bersebelahan terbesar apabila array dicipta selepas menggabungkan kali array kecil. ; Mengembalikan jumlah maksimum subarray yang dibuat selepas menggabungkan [0 .. n - 1] k kali. ; Di sinilah ia berbeza dari algoritma Kadane. Kami menggunakan aritmetik modular untuk mencari elemen seterusnya. ; Program pemacu untuk menguji maxsubarraysum", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int main ( ) { int a [ ] = { 10 , 20 , -30 , -1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" << maxSubArraySumRepeated ( a , n , k ) ; return 0 ; }"}
{"text": "Terpanjang peningkatan ganjil walaupun berikutnya | C ++ pelaksanaan untuk mencari peningkatan yang paling lama meningkat walaupun berikutnya; berfungsi untuk mencari peningkatan yang paling lama walaupun seterusnya; lioes [i] menyimpan paling lama meningkatkan ganjil walaupun berikutnya yang berakhir di arr [i]; untuk menyimpan panjang yang paling lama meningkat ganjil walaupun berikutnya; Memulakan nilai lio untuk semua indeks; Mengira nilai lio yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai lio; panjang maksimum yang diperlukan; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } int main ( ) { int arr [ ] = { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = sizeof ( arr ) / sizeof ( n ) ; cout << \" Longest ▁ Increasing ▁ Odd ▁ Even ▁ \" << \" Subsequence : ▁ \" << longOddEvenIncSeq ( arr , n ) ; return 0 ; }"}
{"text": "Nilai minimum dan maksimum ungkapan dengan * dan + | Program C ++ untuk mendapatkan nilai maksimum dan minimum ungkapan; Kaedah utiliti untuk memeriksa sama ada watak adalah pengendali atau tidak; kaedah mencetak nilai minimum dan maksimum yang boleh diperolehi daripada ungkapan; pengendali kedai dan nombor dalam vektor yang berbeza; menyimpan nombor terakhir dalam vektor; memulakan array Minval dan Maxval 2D; memulakan pepenjuru utama dengan nilai NUM; Looping serupa dengan pendaraban rantai matriks dan mengemas kini kedua -dua tatasusunan 2D; Jika pengendali semasa adalah ' +', mengemas kini pembolehubah TMP dengan tambahan; Jika pengendali semasa adalah ' *', mengemas kini pembolehubah TMP dengan pendaraban; mengemas kini nilai array oleh pembolehubah TMP; Elemen terakhir baris pertama akan menyimpan hasilnya; Kod pemacu untuk menguji kaedah di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOperator ( char op ) { return ( op == ' + ' op == ' * ' ) ; } void printMinAndMaxValueOfExp ( string exp ) { vector < int > num ; vector < char > opr ; string tmp = \" \" ; for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . push_back ( exp [ i ] ) ; num . push_back ( atoi ( tmp . c_str ( ) ) ) ; tmp = \" \" ; } else { tmp += exp [ i ] ; } } num . push_back ( atoi ( tmp . c_str ( ) ) ) ; int len = num . size ( ) ; int minVal [ len ] [ len ] ; int maxVal [ len ] [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = INT_MAX ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] ; } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == ' + ' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr [ k ] == ' * ' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } cout << \" Minimum ▁ value ▁ : ▁ \" << minVal [ 0 ] [ len - 1 ] << \" , ▁ Maximum ▁ value ▁ : ▁ \" << maxVal [ 0 ] [ len - 1 ] ; } int main ( ) { string expression = \"1 + 2*3 + 4*5\" ; printMinAndMaxValueOfExp ( expression ) ; return 0 ; }"}
{"text": "Pendaraban rantai matriks | DP | Pelaksanaan rekursif naif yang hanya mengikuti harta substruktur yang optimum di atas; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , 1 , n - 1 ) ; }"}
{"text": "Pendaraban rantai matriks | DP | Program C ++ menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 100 ] ; int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( dp , -1 , sizeof dp ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , n ) ; }"}
{"text": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit A dan B yang ditetapkan dalam kedua -dua mereka; Kosongkan bit A yang ditetapkan dalam kedua -dua A dan B; Kosongkan bit B yang ditetapkan dalam kedua -dua A dan B; Cetak dikemas kini A dan B; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << \" ▁ \" << B ; } int main ( ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; return 0 ; }"}
{"text": "Jumlah perbezaan perbezaan nombor berturut -turut dari 0 hingga n | Tetapkan 2 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan jarak Hamming antara semua nombor berturut -turut dari 0 hingga n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } int main ( ) { int N = 9 ; cout << TotalHammingDistance ( N ) ; return 0 ; }"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Set 3 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari jumlah semua pembahagi semua nombor dari 1 hingga n; Menyimpan jumlah; Menandakan titik terakhir kejadian dengan kiraan yang sama; Kirakan jumlahnya; Mengembalikan hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE #define m  1000000007 NEW_LINE void solve ( long long n ) { long long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = n / floor ( n / l ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } cout << ( s + m ) % m ; } signed main ( ) { long long n = 12 ; solve ( n ) ; return 0 ; }"}
{"text": "Kurangkan bilangan luka yang diperlukan untuk memecahkan panjang n tongkat ke dalam n unit panjang tongkat | Program C ++ untuk mencari masa minimum yang diperlukan untuk memecah tongkat panjang N ke dalam kepingan unit; Berfungsi untuk mengembalikan masa minimum yang diperlukan untuk memecah tongkat n ke dalam kepingan unit; Mengembalikan unit minimum masa yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ceil ( log2 ( N ) ) ; } int main ( ) { int N = 100 ; cout << min_time_to_cut ( N ) ; return 0 ; }"}
{"text": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | C ++ pelaksanaan untuk mengira jumlah pasangan yang berbeza antara dua array dengan nilai 1 hingga n; Berfungsi untuk mencari jumlah yang berbeza; Tetapkan untuk menyimpan jumlah yang berbeza; Memasukkan setiap jumlah; kembali jumlah yang berbeza; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int n ) { set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . insert ( i + j ) ; } } return s . size ( ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }"}
{"text": "Cetak Segitiga Terasing Corak | Program C ++ untuk mencetak corak terpisah segitiga menggunakan watak bintang dan slash; Berfungsi untuk mencetak corak secara rekursif; Kes asas; Syarat untuk mencetak slash; Keadaan untuk mencetak slash forword; Keadaan untuk mencetak slash ke belakang; Lain cetak ' *'; Panggilan rekursif untuk baris; Panggilan rekursif untuk menukar baris; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { cout << \" / \" ; } else { cout << \" \\ \\\" ; } } else { cout << \" * \" ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } cout << endl ; return printPattern ( i + 1 , 0 , n ) ; } int main ( ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; return 0 ; }"}
{"text": "Cari indeks permulaan untuk setiap kejadian array yang diberikan b dalam array A menggunakan z | Pelaksanaan CPP untuk mencari corak dalam array menggunakan algoritma Z; Fungsi untuk mengira z - array; Gelung untuk mengira z - array; Di luar kotak z; Di dalam z - kotak; Fungsi penolong untuk menggabungkan dua tatasusunan dan membuat satu array; Array untuk menyimpan array yang digabungkan; Menyalin Array B; Menambah pemisah; Menyalin Array A; Memanggil Z - Fungsi; Fungsi untuk membantu mengira array Z; Indeks percetakan di mana array b berlaku; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > zArray ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > z ( n ) ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } vector < int > mergeArray ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; int m = B . size ( ) ; vector < int > z ; vector < int > c ( n + m + 1 ) ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } void findZArray ( vector < int > A , vector < int > B , int n ) { int flag = 0 ; vector < int > z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . size ( ) ; i ++ ) { if ( z [ i ] == n ) { cout << ( i - n - 1 ) << \" ▁ \" ; flag = 1 ; } } if ( flag == 0 ) { cout << ( \" Not ▁ Found \" ) ; } } int main ( ) { vector < int > A { 1 , 2 , 3 , 2 , 3 , 2 } ; vector < int > B { 2 , 3 } ; int n = B . size ( ) ; findZArray ( A , B , n ) ; }"}
{"text": "Semak jika rentetan boleh diulang untuk membuat rentetan lain | Pelaksanaan CPP pendekatan; Berfungsi untuk mengembalikan kiraan pengulangan String A untuk menjana rentetan b; Jika B tidak dapat dihasilkan dengan mengulangi A; Ulangi jumlah kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = \" \" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == b ) return count ; return -1 ; } int main ( ) { string a = \" geeks \" ; string b = \" geeksgeeks \" ; cout << ( getCount ( a , b ) ) ; return 0 ; }"}
{"text": "Semak jika rentetan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan | Program CPP untuk memeriksa sama ada rentetan yang diberikan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan; Fungsi untuk memeriksa sama ada S2 boleh dibentuk dari S1; panjang rentetan; Hash - Jadual untuk menyimpan kiraan; menyimpan kiraan setiap watak; melintasi dan memeriksa setiap watak; Jika watak S2 hadir dalam S1; Jika watak S2 tidak hadir dalam S1, maka periksa sama ada dua aksara ASCII terdahulu hadir dalam S1; Kod pemacu; Fungsi panggilan untuk memeriksa", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string S1 , string S2 ) { int n1 = S1 . size ( ) ; int n2 = S2 . size ( ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n1 ; i ++ ) { mp [ S1 [ i ] ] ++ ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp [ S2 [ i ] ] ) { mp [ S2 [ i ] ] -- ; } else if ( mp [ S2 [ i ] - 1 ] && mp [ S2 [ i ] - 2 ] ) { mp [ S2 [ i ] - 1 ] -- ; mp [ S2 [ i ] - 2 ] -- ; } else { return false ; } } return true ; } int main ( ) { string S1 = \" abbat \" ; string S2 = \" cat \" ; if ( check ( S1 , S2 ) ) cout << \" YES \" ; else cout << \" NO \" ; }"}
{"text": "Count kejadian corak \"1 (0 +) 1\" dalam rentetan | Program C ++ untuk mengira bilangan kali corak berlaku dalam rentetan yang diberikan; Mengembalikan kiraan kejadian \"1 (0 +) 1\" int str. ; int count = 0; Memulakan hasil; Semak jika ditemui '1' membentuk corak yang sah seperti yang ditentukan; jika 1 ditemui untuk pertama kali ditetapkan satu ke 1; Semak jika terdapat watak lain selain daripada '0' atau '1'. Jika demikian kemudian tetapkan Oneseen hingga 0 untuk mencari lagi untuk corak baru; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; int countPattern ( string str ) { int len = str . size ( ) ; bool oneSeen = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0 ; } return count ; } int main ( ) { string str = \"100001abc101\" ; cout << countPattern ( str ) ; return 0 ; }"}
{"text": "Tukar rentetan yang diberikan ke dalam T dengan menggantikan aksara di antara rentetan sebilangan kali | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua rentetan sama dengan rentetan t; Menyimpan kekerapan semua rentetan dalam array arr []; Menyimpan kekerapan rentetan t; Melangkah ke atas watak -watak rentetan t; Melangkah dalam julat [0, n - 1]; Melangkah ke atas watak -watak rentetan arr [i]; Jika freqt [i] adalah 0 dan freqs [i] bukan 0; Jika freqs [i] adalah 0 dan freqt [i] bukan 0; Jika freqs [i] bukan freqt [i] * n; Jika tidak, kembalikan \"ya\"; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; string checkIfPossible ( int N , string arr [ ] , string T ) { int freqS [ 256 ] = { 0 } ; int freqT [ 256 ] = { 0 } ; for ( char ch : T ) { freqT [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return \" No \" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return \" No \" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return \" No \" ; } } return \" Yes \" ; } int main ( ) { string arr [ ] = { \" abc \" , \" abb \" , \" acc \" } ; string T = \" abc \" ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << checkIfPossible ( N , arr , T ) ; return 0 ; }"}
{"text": "Count kumpulan berturut -turut 1 s dalam rentetan binari yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan kumpulan 1 s hanya dalam rentetan binari; Kedai bilangan kumpulan 1 s; Permulaan timbunan; Melintasi rentetan s; Jika s [i] adalah '1'; Jika tidak; Jika St kosong; Jika ST tidak kosong; Jawapan kembali; Kod pemacu; Input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int groupsOfOnes ( string S , int N ) { int count = 0 ; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } int main ( ) { string S = \"100110111\" ; int N = S . length ( ) ; cout << groupsOfOnes ( S , N ) << endl ; return 0 ; }"}
{"text": "Palindromic Strings of Length 3 mungkin dengan menggunakan aksara rentetan yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak semua rentetan palindromik panjang 3 yang boleh dibentuk menggunakan aksara rentetan s; Menyimpan kiraan watak; Melintasi rentetan s; Menyimpan semua rentetan palindromik; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Jika hash [ch] sama dengan 2; Melangkah ke atas watak -watak di atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Tolak S ke set st; Jika hash [i] lebih besar daripada atau sama dengan 3; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Jika hash [j] positif; Tolak s ke set st; Melangkah ke atas set; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generatePalindrome ( string S ) { unordered_map < char , int > Hash ; for ( auto ch : S ) { Hash [ ch ] ++ ; } set < string > st ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( Hash [ i ] == 2 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = \" \" ; if ( Hash [ j ] && i != j ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } if ( Hash [ i ] >= 3 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = \" \" ; if ( Hash [ j ] ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } } for ( auto ans : st ) { cout << ans << \" STRNEWLINE \" ; } } int main ( ) { string S = \" ddabdac \" ; generatePalindrome ( S ) ; return 0 ; }"}
{"text": "Mengira kejadian substring x sebelum setiap kejadian substring y dalam rentetan yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kejadian rentetan y dalam rentetan s untuk setiap kejadian x dalam s; Menyimpan kiraan kejadian x; Menyimpan panjang tiga rentetan; Melintasi rentetan s; Jika substring semasa adalah y, maka kenaikan nilai kiraan sebanyak 1; Jika substring semasa adalah x, maka cetak kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << \" ▁ \" ; } } int main ( ) { string S = \" abcdefdefabc \" ; string X = \" abc \" ; string Y = \" def \" ; countOccurrences ( S , X , Y ) ; return 0 ; }"}
{"text": "Program untuk membina DFA untuk ungkapan biasa C (A + B) + | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari sama ada rentetan yang diberikan diterima oleh DFA; Jika n <= 1, maka cetak tidak; Untuk mengira watak yang dipadankan; Semak jika watak pertama adalah c; Melintasi seluruh rentetan; Jika watak adalah A atau B, kiraan kenaikan sebanyak 1; Jika watak pertama tidak C, cetak - 1; Jika semua watak sepadan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void DFA ( string str , int N ) { if ( N <= 1 ) { cout << \" No \" ; return ; } int count = 0 ; if ( str [ 0 ] == ' C ' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == ' A ' str [ i ] == ' B ' ) count ++ ; else break ; } } else { cout << \" No \" ; return ; } if ( count == N ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { string str = \" CAABBAAB \" ; int N = str . size ( ) ; DFA ( str , N ) ; return 0 ; }"}
{"text": "Bilangan minimum dan maksimum digit yang diperlukan untuk dikeluarkan untuk membuat nombor tertentu dibahagikan dengan 3 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum dan minimum digit yang akan dikeluarkan untuk menjadikan STR dibahagikan dengan 3; Tukar rentetan ke dalam pelbagai digit; Kiraan 0 s, 1 s, dan 2 s; Melintasi array; Cari jumlah digit % 3; Kes untuk mencari bilangan minimum digit yang akan dikeluarkan; Kes untuk mencari bilangan maksimum digit yang akan dikeluarkan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMaxDigits ( string str , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { cout << 0 << ' ▁ ' ; } if ( sum == 1 ) { if ( one && N > 1 ) cout << 1 << ' ▁ ' ; else if ( two > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( sum == 2 ) { if ( two && N > 1 ) cout << 1 << ' ▁ ' ; else if ( one > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( zero > 0 ) cout << N - 1 << ' ▁ ' ; else if ( one > 0 && two > 0 ) cout << N - 2 << ' ▁ ' ; else if ( one > 2 two > 2 ) cout << N - 3 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } int main ( ) { string str = \"12345\" ; int N = str . length ( ) ; minMaxDigits ( str , N ) ; return 0 ; }"}
{"text": "Penggantian minimum diperlukan untuk mendapatkan k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum perubahan untuk membuat rentetan k - berkala dan palindrome; Memulakan ans dengan 0; Berulang dari 0 hingga (k + 1) / 2; Frekuensi penyimpanan watak; Melewati semua indeks, i, i + k, i + 2 k .... dan menyimpan kekerapan watak; Meningkatkan kekerapan watak semasa; Melewati semua indeks k - i, 2 k - i, 3 ​​k - i .... dan menyimpan kekerapan watak; Jika k adalah ganjil & i adalah samw sebagai k / 2, pecahkan gelung; Meningkatkan kekerapan watak semasa; Cari kekerapan maksimum watak di antara semua watak yang dikunjungi; Jika K adalah ganjil dan saya sama dengan K / 2 maka, hanya aksara N / K yang dikunjungi; Jika tidak, n / k * 2 aksara telah melawat; Mengembalikan hasilnya; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumChanges ( int N , int K , string S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { map < char , int > mp ; for ( int j = i ; j < N ; j += K ) { mp [ S [ j ] ] ++ ; } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K & 1 and i == K / 2 ) break ; mp [ S [ j ] ] ++ ; } int curr_max = INT_MIN ; for ( auto p : mp ) curr_max = max ( curr_max , p . second ) ; if ( K & 1 and i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; } int main ( ) { string S = \" aabbcbbcb \" ; int N = S . length ( ) ; int K = 3 ; cout << findMinimumChanges ( N , K , S ) ; return 0 ; }"}
{"text": "Semak sama ada rentetan mengandungi sebarang indeks dengan lebih banyak daripada aktif aktif k | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mana -mana indeks mengandungi lebih banyak daripada ak aktif aktif; Simpan kejadian terakhir setiap watak dalam peta. ; Menyimpan watak aktif; Masukkan watak; Jika saiz set melebihi k; Keluarkan watak dari set jika saya adalah indeks terakhir watak semasa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkString ( string s , int K ) { int n = s . length ( ) ; unordered_map < char , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] = i ; } int cnt = 0 , f = 0 ; unordered_set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { st . insert ( s [ i ] ) ; if ( st . size ( ) > K ) { f = 1 ; break ; } if ( mp [ s [ i ] ] == i ) st . erase ( s [ i ] ) ; } return ( f == 1 ? \" Yes \" : \" No \" ) ; } int main ( ) { string s = \" aabbcdca \" ; int k = 2 ; cout << checkString ( s , k ) ; return 0 ; }"}
{"text": "Kira bilangan rentetan dalam array yang wataknya berbeza kurang daripada m | C ++ pelaksanaan untuk mengira bilangan rentetan dalam array yang wataknya berbeza kurang daripada atau sama dengan m; Fungsi untuk mengira rentetan yang dikira watak -watak yang berbeza kurang daripada m; Gelung untuk melangkah ke atas semua rentetan array; Watak yang berbeza dalam rentetan dengan bantuan set; Memeriksa jika kurang daripada atau sama dengan m; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <set> NEW_LINE using namespace std ; void distinct ( string S [ ] , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < char > set1 ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S [ ] = { \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" } ; int M = 7 ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; distinct ( S , M , n ) ; return 0 ; }"}
{"text": "Keluarkan aksara frekuensi ganjil dari rentetan | Program C ++ untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Berfungsi untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; Untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi ganjil; Jika watak mempunyai kekerapan ganjil maka langkau; Lain menggabungkan watak ke rentetan baru; Kembalikan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi ganjil", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOddFrequencyCharacters ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] & 1 ) continue ; new_string += s [ i ] ; } return new_string ; } int main ( ) { string str = \" geeksforgeeks \" ; str = removeOddFrequencyCharacters ( str ) ; cout << str << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Produk nod di k | C ++ pelaksanaan untuk mencari produk unsur -unsur di peringkat k - th; Fungsi rekursif untuk mencari produk unsur -unsur di peringkat k - th; Jika subtree adalah batal, sama seperti jika root == null; Pertimbangkan hanya nod tahap untuk menjadi sebahagian daripada produk; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Menjaga ')' selepas subtree kiri dan kanan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int productAtKthLevel ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; int leftproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } } int main ( ) { string tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) \" \" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; int i = 0 ; cout << productAtKthLevel ( tree , k , i , 0 ) ; return 0 ; }"}
{"text": "Cetak watak yang paling berlaku dalam pelbagai rentetan | Program C ++ untuk mencetak watak yang paling banyak berlaku dalam pelbagai rentetan; Berfungsi untuk mencetak watak yang paling banyak berlaku; Mewujudkan hash saiz 26; Untuk gelung untuk melangkah melalui setiap rentetan array; Untuk gelung untuk melangkah melalui setiap watak rentetan; Meningkatkan kiraan watak dalam hash; Mencari watak dengan kiraan maksimum; Kod pemacu; Mengisytiharkan vektor jenis rentetan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMostOccurringChar ( vector < string > str ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { hash [ str [ i ] [ j ] ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } cout << ( char ) ( max + 97 ) << endl ; } int main ( ) { vector < string > str ; str . push_back ( \" animal \" ) ; str . push_back ( \" zebra \" ) ; str . push_back ( \" lion \" ) ; str . push_back ( \" giraffe \" ) ; findMostOccurringChar ( str ) ; return 0 ; }"}
{"text": "Semak sama ada nombor titik terapung yang diberikan adalah palindrome | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika NUM adalah palindrome; Tukar nombor titik terapung yang diberikan ke dalam rentetan; Penunjuk menunjuk kepada watak pertama dan terakhir rentetan; Bukan palindrome; Mengemas kini petunjuk; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( float num ) { stringstream ss ; ss << num ; string s ; ss >> s ; int low = 0 ; int high = s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; } int main ( ) { float n = 123.321f ; if ( isPalindrome ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Bilangan maksimum kali str1 muncul sebagai bukan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan maksimum kali STR1 boleh muncul sebagai substring yang tidak bertindih dalam STR2; STR1 tidak boleh menjadi substring str2; Simpan kekerapan watak Str1; Simpan kekerapan watak Str2; Untuk menyimpan kiraan substring yang diperlukan; Watak semasa tidak muncul dalam str1; Kekerapan watak semasa dalam Str1 adalah lebih besar daripada kekerapannya dalam Str2; Mengemas kini kiraan substrings yang mungkin; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int freq2 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; } int main ( ) { string str1 = \" geeks \" , str2 = \" gskefrgoekees \" ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; cout << maxSubStr ( str1 , len1 , str2 , len2 ) ; return 0 ; }"}
{"text": "Bilangan cara untuk memasukkan dua pasang kurungan ke dalam rentetan aksara n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk memasukkan pasangan kurungan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } int main ( ) { string str = \" ab \" ; int n = str . length ( ) ; cout << cntWays ( str , n ) ; return 0 ; }"}
{"text": "Bilangan minimum substrings rentetan yang diberikan boleh dibuang ke dalam yang memenuhi syarat -syarat yang diberikan | C ++ pelaksanaan pendekatan; Tetapkan untuk menyimpan semua rentetan dari array yang diberikan; Untuk menyimpan kiraan yang diperlukan; Fungsi rekursif untuk mencari kiraan substrings yang boleh dibahagikan bermula dari indeks permulaan supaya semua substrings hadir dalam peta; Semua substring yang dipilih hadir dalam peta; Mengemas kini kiraan minimum substring; Bermula dari substrings panjang 1 yang bermula dengan indeks yang diberikan; Dapatkan substring; Jika substring hadir dalam set; Panggilan rekursif untuk sisa rentetan; Fungsi yang memasukkan semua rentetan dari array yang diberikan dalam satu set dan memanggil fungsi rekursif untuk mencari kiraan minimum substrings STR boleh dibuang ke dalam yang memenuhi syarat yang diberikan; Masukkan semua rentetan dari array yang diberikan dalam satu set; Cari kiraan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_set < string > uSet ; int minCnt = INT_MAX ; void findSubStr ( string str , int cnt , int start ) { if ( start == str . length ( ) ) { minCnt = min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) { string subStr = str . substr ( start , len ) ; if ( uSet . find ( subStr ) != uSet . end ( ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } } void findMinSubStr ( string arr [ ] , int n , string str ) { for ( int i = 0 ; i < n ; i ++ ) uSet . insert ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; } int main ( ) { string str = \"123456\" ; string arr [ ] = { \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" } ; int n = sizeof ( arr ) / sizeof ( string ) ; findMinSubStr ( arr , n , str ) ; cout << minCnt ; return 0 ; }"}
{"text": "Bilangan substring yang bermula dengan \"geeks\" dan berakhir dengan \"untuk\" | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan substring yang diperlukan; Untuk setiap indeks rentetan; Jika substring bermula pada indeks semasa adalah \"geeks\"; Jika substring adalah \"untuk\"; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int countSubStr ( string s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . substr ( i , 5 ) == \" geeks \" ) c1 ++ ; if ( s . substr ( i , 3 ) == \" for \" ) c2 = c2 + c1 ; } return c2 ; } int main ( ) { string s = \" geeksforgeeksisforgeeks \" ; int n = s . size ( ) ; cout << countSubStr ( s , n ) ; return 0 ; }"}
{"text": "Infytq 2019: Cari kedudukan dari mana kurungan tidak seimbang | C ++ pelaksanaan pendekatan; Menentukan rentetan; Menyimpan pendakap pembukaan dalam senarai LST1; Menyimpan pendakap penutup dalam senarai LST2; Mewujudkan senarai kosong LST; Mewujudkan kamus untuk memetakan pendakap penutup untuk membuka; Jika kedudukan pertama rentetan mengandungi sebarang pendakap penutup kembali 1; Jika watak -watak rentetan membuka pendakap maka masukkannya ke dalam senarai; Apabila saiz senarai adalah 0 dan pendakap penutup baru ditemui kemudian cetak indeksnya bermula dari 1; Ketika kami menemui pendakap penutup, kami memetakan mereka dengan pendakap pembukaan yang sesuai dengan menggunakan kamus dan periksa sama ada ia sama dengan pendakap yang dibuka terakhir (elemen terakhir dalam senarai) jika ya maka kami memadamkan elemen itu dari senarai; Jika tidak, kami mengembalikan indeks (bermula dari 1) di mana bersarang didapati salah; Pada akhir jika senarai kosong itu bermaksud rentetan bersarang dengan sempurna", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { string String = \" { [ ( ) ] } [ ] \" ; vector < char > lst1 = { ' { ' , ' ( ' , ' [ ' } ; vector < char > lst2 = { ' } ' , ' ) ' , ' ] ' } ; vector < char > lst ; int k ; map < char , char > Dict ; Dict . insert ( pair < int , int > ( ' ) ' , ' ( ' ) ) ; Dict . insert ( pair < int , int > ( ' } ' , ' { ' ) ) ; Dict . insert ( pair < int , int > ( ' ] ' , ' [ ' ) ) ; int a = 0 , b = 0 , c = 0 ; if ( count ( lst2 . begin ( ) , lst2 . end ( ) , String [ 0 ] ) ) { cout << 1 << endl ; } else { for ( int i = 0 ; i < String . size ( ) ; i ++ ) { if ( count ( lst1 . begin ( ) , lst1 . end ( ) , String [ i ] ) ) { lst . push_back ( String [ i ] ) ; k = i + 2 ; } else { if ( lst . size ( ) == 0 && ( count ( lst2 . begin ( ) , lst2 . end ( ) , String [ i ] ) ) ) { cout << ( i + 1 ) << endl ; c = 1 ; break ; } else { if ( Dict [ String [ i ] ] == lst [ lst . size ( ) - 1 ] ) { lst . pop_back ( ) ; } else { break ; cout << ( i + 1 ) << endl ; a = 1 ; } } } } if ( lst . size ( ) == 0 && c == 0 ) { cout << 0 << endl ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { cout << k << endl ; } } return 0 ; }"}
{"text": "Menyulitkan rentetan yang diberikan dengan operasi berikut | C ++ pelaksanaan pendekatan di atas :; Berfungsi untuk mengembalikan rentetan yang disulitkan; Kurangkan x kerana putaran panjang 26 tidak perlu; Kirakan kekerapan aksara; Jika kekerapan aksara arus bahkan maka kenaikannya dengan x; Lain menurunkannya dengan x; Mengembalikan kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  26 NEW_LINE using namespace std ; string encryptStr ( string str , int n , int x ) { x = x % MAX ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( str [ i ] - ' a ' + x ) % MAX ; str [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( str [ i ] - ' a ' - x ) ; if ( pos < 0 ) { pos += MAX ; } str [ i ] = ( char ) ( pos + ' a ' ) ; } } return str ; } int main ( ) { string s = \" abcda \" ; int n = s . size ( ) ; int x = 3 ; cout << encryptStr ( s , n , x ) << endl ; return 0 ; }"}
{"text": "Susun semula aksara dalam rentetan supaya tidak ada dua bersebelahan dengan menggunakan hashing | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk menyusun semula watak -watak rentetan supaya tidak dua aksara berturut -turut adalah sama; Untuk menyimpan kekerapan setiap watak; Untuk menyimpan kekerapan maksimum setakat ini; Jika boleh; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <time.h> NEW_LINE using namespace std ; int isPossible ( string str ) { unordered_map < char , int > freq ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } if ( max_freq <= ( str . length ( ) - max_freq + 1 ) ) return true ; return false ; } int main ( ) { string str = \" geeksforgeeks \" ; if ( isPossible ( str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Cari watak yang tidak biasa dari dua rentetan | Tetapkan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak aksara yang tidak biasa dalam rentetan yang diberikan dalam urutan yang disusun; Menukar watak ke kod ASCII; Operasi bit; Menukar watak ke kod ASCII; Operasi bit; Operasi XOR hanya meninggalkan watak -watak yang tidak biasa dalam pembolehubah ANS; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = int ( str1 [ i ] ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = int ( str2 [ i ] ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { cout << char ( ' a ' + i ) ; } ans = ans / 2 ; i ++ ; } } int main ( ) { string str1 = \" geeksforgeeks \" ; string str2 = \" geeksquiz \" ; printUncommon ( str1 , str2 ) ; return 0 ; }"}
{"text": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Set | Program C ++ untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Untuk menyimpan bilangan pembalikan yang diperlukan. ; Untuk menyimpan nombor pendakap pembukaan yang tidak seimbang. ; Untuk menyimpan nombor kurungan penutupan yang tidak seimbang. ; Jika pendakap semasa dibuka maka kenaikan kiraan terbuka. ; Jika pendakap semasa dekat, periksa sama ada mengimbangi pendakap pembukaan. Jika ya maka pengurangan kiraan pendakap pembukaan yang tidak seimbang, lain -lain kenaikan kiraan pendakap penutupan. ; Untuk kes itu: \"} {\" Atau apabila satu penutupan dan satu pendakap pembukaan kekal untuk berpasangan, maka kedua -duanya perlu diterbalikkan. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; } int main ( ) { string expr = \" } } { { \" ; cout << countMinReversals ( expr ) ; return 0 ; }"}
{"text": "Pasangan watak dari dua rentetan dengan jumlah keseluruhan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah pasangan yang sah; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S1; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S2; Mengembalikan jumlah pasangan yang sah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( string s1 , string s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( int ( s1 [ i ] ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( int ( s2 [ i ] ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } int main ( ) { string s1 = \" geeks \" , s2 = \" for \" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }"}
{"text": "Kejadian maksimum awalan dalam array | Program CPP untuk mencari bilangan kejadian awalan yang berlaku maksimum no. masa; Berfungsi untuk mengembalikan kiraan awalan yang diperlukan; Cari kekerapan watak pertama rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; } int main ( ) { string str = \" abbcdabbcd \" ; cout << prefixOccurrences ( str ) ; return 0 ; }"}
{"text": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar rentetan ke rentetan lain | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan operasi minimum jenis yang diberikan untuk menukar rentetan s ke rentetan t; Watak sudah sama; Kiraan kenaikan 0 s; Kiraan kenaikan 1 s; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; } int main ( ) { string s = \"010\" , t = \"101\" ; int n = s . length ( ) ; cout << minOperations ( s , t , n ) ; return 0 ; }"}
{"text": "Dekripsi rentetan yang disulitkan dengan mengulangi i | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disahsulit; Lompat awal akan menjadi 1; Lompat kenaikan sebanyak 1 dengan setiap watak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = \" \" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; } int main ( ) { string str = \" geeeeekkkksssss \" ; int n = str . length ( ) ; cout << decryptString ( str , n ) ; return 0 ; }"}
{"text": "Cari bit yang flip urutan minimum menjadikan semua bit sama | Program C ++ untuk mencari urutan bit mana yang akan dibalik; Fungsi untuk memeriksa bit mana yang akan dibalik; pembolehubah untuk menyimpan watak pertama dan terakhir rentetan; Semak sama ada aksara pertama dan terakhir adalah sama, jika ya, kemudian kembalikan watak yang tidak akhirnya; lain kembali terakhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char bitToBeFlipped ( string s ) { char last = s [ s . length ( ) - 1 ] ; char first = s [ 0 ] ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } } int main ( ) { string s = \"1101011000\" ; cout << bitToBeFlipped ( s ) << endl ; return 0 ; }"}
{"text": "Jumlah dan produk frekuensi utama aksara dalam rentetan | Program C ++ untuk mencari jumlah dan produk frekuensi utama aksara dalam rentetan; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencari jumlah frekuensi utama watak -watak rentetan yang diberikan; Peta digunakan untuk menyimpan frekuensi watak; Melintasi peta; Jika kekerapan adalah perdana; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } void sumProdOfPrimeFreq ( string s ) { bool prime [ s . length ( ) + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , s . length ( ) + 1 ) ; int i , j ; unordered_map < char , int > m ; for ( i = 0 ; i < s . length ( ) ; i ++ ) m [ s [ i ] ] ++ ; int sum = 0 , product = 1 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { sum += it -> second ; product *= it -> second ; } } cout << \" Sum ▁ = ▁ \" << sum ; cout << \" Product = \" } int main ( ) { string s = \" geeksforgeeks \" ; sumProdOfPrimeFreq ( s ) ; return 0 ; }"}
{"text": "Semak jika kekerapan aksara dalam satu rentetan adalah faktor atau pelbagai kekerapan watak yang sama dalam rentetan lain | C ++ pelaksanaan pendekatan di atas; Fungsi yang memeriksa jika kekerapan watak adalah faktor atau pelbagai antara satu sama lain; kekerapan kedai peta setiap aksara; Jika sebarang kekerapan adalah 0, maka teruskan sebagai keadaan berpuas hati; jika faktor atau berganda, maka keadaan berpuas hati; jika keadaan tidak berpuas hati; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool multipleOrFactor ( string s1 , string s2 ) { map < char , int > m1 , m2 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) m1 [ s1 [ i ] ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) m2 [ s2 [ i ] ] ++ ; map < char , int > :: iterator it ; for ( it = m1 . begin ( ) ; it != m1 . end ( ) ; it ++ ) { if ( m2 . find ( ( * it ) . first ) == m2 . end ( ) ) continue ; if ( m2 [ ( * it ) . first ] % ( * it ) . second == 0 || ( * it ) . second % m2 [ ( * it ) . first ] == 0 ) continue ; else return false ; } } int main ( ) { string s1 = \" geeksforgeeks \" ; string s2 = \" geeks \" ; multipleOrFactor ( s1 , s2 ) ? cout << \" YES \" : cout << \" NO \" ; return 0 ; }"}
{"text": "Keluarkan walaupun aksara frekuensi dari rentetan | C ++ pelaksanaan pendekatan; Fungsi yang menghilangkan aksara yang mempunyai frekuensi dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi; Jika watak mempunyai kekerapan, maka langkau; lain menggabungkan watak ke rentetan baru; Paparkan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi bahkan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string += s [ i ] ; } cout << new_string << endl ; } int main ( ) { string s = \" aabbbddeeecc \" ; solve ( s ) ; return 0 ; }"}
{"text": "Keluarkan semua perkataan palindromik dari ayat yang diberikan | C ++ pelaksanaan untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; fungsi untuk memeriksa sama ada 'str' adalah palindrome; melintasi kedua -dua hujungnya; bukan palindrome; palindrome; berfungsi untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; 'akhir _ str' untuk menyimpan rentetan akhir dan 'kata' kepada satu demi satu kedai setiap perkataan 'str'; Tambah ruang pada akhir 'str'; melintasi 'str'; mengumpul watak -watak perkataan semasa; jika 'perkataan' bukan palindrome maka tambahnya ke 'akhir _ str'; menetapkan semula; rentetan akhir yang diperlukan; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int i = 0 , j = str . size ( ) - 1 ; while ( i < j ) if ( str [ i ++ ] != str [ j -- ] ) return false ; return true ; } string removePalinWords ( string str ) { string final_str = \" \" , word = \" \" ; str = str + \" ▁ \" ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' ▁ ' ) word = word + str [ i ] ; else { if ( ! ( isPalindrome ( word ) ) ) final_str += word + \" ▁ \" ; word = \" \" ; } } return final_str ; } int main ( ) { string str = \" Text ▁ contains ▁ malayalam ▁ and ▁ level ▁ words \" ; cout << removePalinWords ( str ) ; return 0 ; }"}
{"text": "Jumlah semua berikutnya nombor | Program CPP untuk mencari jumlah elemen yang terdapat dalam semua berikutnya; Mengembalikan nilai angka berikutnya S. Berikutnya yang akan dipilih diputuskan menggunakan corak bit num (kami memilih semua thedigits yang mana terdapat set bit dalam NUM); Memulakan hasilnya; sehingga n! = 0; Jika saya - bit ditetapkan maka tambahkan nombor ini; Peralihan kanan i; fungsi untuk mencari jumlah gabungan semua jumlah keseluruhan individu; panjang rentetan; menyimpan gabungan; 2 ^ n - 1 berikutnya; gelung untuk semua berikutnya; mengembalikan jumlah gabungan; kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubSequence ( string s , int num ) { int res = 0 ; int i = 0 ; while ( num ) { if ( num & 1 ) res += s [ i ] - '0' ; i ++ ; num = num >> 1 ; } return res ; } int combinedSum ( string s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } int main ( ) { string s = \"123\" ; cout << combinedSum ( s ) ; return 0 ; }"}
{"text": "Susunan terpanjang di mana setiap watak berlaku sekurang -kurangnya k kali | Program CPP untuk mencari seterusnya dengan setiap watak yang berlaku sekurang -kurangnya k kali dalam rentetan s; Berfungsi untuk mencari berikutnya; Mengambil array tambahan untuk menyimpan rekod untuk kiraan watak dalam s; Mengira kejadian semua aksara dalam STR []; Percetakan aksara dengan kiraan> = k dalam susunan yang sama kerana ia muncul dalam str. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; } int main ( ) { int k = 2 ; findSubsequence ( \" geeksforgeeks \" , k ) ; return 0 ; }"}
{"text": "Google Case Of A Sentyen tertentu | Program C ++ untuk menukar ayat ke Google Case. ; Rentetan kosong; Tukar rentetan input ke atas kes; Semak sama ada watak bukan ruang dan menambahkannya ke rentetan w; Menukar watak pertama ke kes yang lebih rendah dan huruf awal berikutnya perkataan lain kepada kes yang lebih rendah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string str ) { string w = \" \" , z = \" \" ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += \" ▁ \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + \" ▁ \" ; w = \" \" ; } } return z ; } int main ( ) { string str = \" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks \" ; cout << convert ( str ) << endl ; return 0 ; }"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | Program CPP untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz K; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan rentetan; CV untuk mengira vokal CC untuk mengira konsonan; Mengira awalan kiraan vokal dan awalan kiraan konsonan; Menjana rentetan yang disulitkan. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string encryptString ( string s , int n , int k ) { int cv [ n ] , cc [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + isVowel ( s [ i ] ) ; cc [ i ] = cc [ i - 1 ] + ! isVowel ( s [ i ] ) ; } string ans = \" \" ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += to_string ( prod ) ; for ( int i = k ; i < s . length ( ) ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += to_string ( prod ) ; } return ans ; } int main ( ) { string s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; cout << encryptString ( s , n , k ) << endl ; return 0 ; }"}
{"text": "Kira kejadian perkataan dalam rentetan | Program C ++ untuk mengira bilangan berlakunya perkataan dalam rentetan yang diberikan; berpecah rentetan dengan ruang dalam A; Cari corak dalam A; jika perlawanan mendapati kenaikan kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , \" ▁ \" ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , \" ▁ \" ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; } int main ( ) { char str [ ] = \" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ \" ; string word = \" portal \" ; cout << countOccurrences ( str , word ) ; return 0 ; }"}
{"text": "Tinggalkan rentetan dengan menukar kes | Kod CPP untuk mencetak semua permutasi berkenaan dengan kes; Berfungsi untuk menjana permutasi; Bilangan permutasi adalah 2 ^ n; Menukar rentetan ke kes yang lebih rendah; Menggunakan semua berikutnya dan membenarkannya; Jika b - th bit ditetapkan, kami menukarnya ke atas kes; Mencetak gabungan semasa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void permute ( string input ) { int n = input . length ( ) ; int max = 1 << n ; transform ( input . begin ( ) , input . end ( ) , input . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < max ; i ++ ) { string combination = input ; for ( int j = 0 ; j < n ; j ++ ) if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = toupper ( input . at ( j ) ) ; cout << combination << \" ▁ \" ; } } int main ( ) { permute ( \" ABC \" ) ; return 0 ; }"}
{"text": "Cetak rentetan selepas watak yang ditentukan telah berlaku diberi tidak. masa | Program C ++ untuk pelaksanaan di atas; Berfungsi untuk mencetak rentetan; Jika diberi kiraan adalah 0 cetak rentetan yang diberikan dan kembali; Mula melintasi rentetan; Kenaikan OCC jika char semasa adalah sama dengan watak yang diberikan; Pecahkan gelung jika watak yang diberikan telah berlaku tidak diberikan. masa; Cetak rentetan selepas berlakunya watak yang diberikan tidak. masa; Jika tidak, rentetan kosong; Kod pemandu", "code": "#include <iostream> NEW_LINE using namespace std ; void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { cout << str ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1 , str . length ( ) - ( i + 1 ) ) ; else cout << \" Empty ▁ string \" ; } int main ( ) { string str = \" geeks ▁ for ▁ geeks \" ; printString ( str , ' e ' , 2 ) ; return 0 ; }"}
{"text": "Vokal terbalik dalam rentetan yang diberikan | Program C ++ untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Mulakan dua indeks dari dua sudut dan bergerak ke arah satu sama lain; bertukar; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } string reverseVowel ( string str ) { int i = 0 ; int j = str . length ( ) - 1 ; while ( i < j ) { if ( ! isVowel ( str [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str [ j ] ) ) { j -- ; continue ; } swap ( str [ i ] , str [ j ] ) ; i ++ ; j -- ; } return str ; } int main ( ) { string str = \" hello ▁ world \" ; cout << reverseVowel ( str ) ; return 0 ; }"}
{"text": "Bilangan minimum Palindromic selepas dikeluarkan untuk mengosongkan rentetan binari | Program C ++ untuk mengira seterusnya Palindromic Minimum untuk dikeluarkan untuk membuat rentetan kosong. ; Fungsi untuk memeriksa sama ada string str adalah palindrome; Bermula dari sudut paling kiri dan paling kanan Str; Terus membandingkan watak semasa mereka sama; Mengembalikan kiraan minimum palindromic subseuqnces untuk dikeluarkan untuk membuat rentetan kosong; Jika rentetan kosong; Jika rentetan adalah palindrome; Jika rentetan bukan palindrome; Kod pemacu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( const char * str ) { int l = 0 ; int h = strlen ( str ) - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; } int minRemovals ( const char * str ) { if ( str [ 0 ] == ' ' ) return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } int main ( ) { cout << minRemovals ( \"010010\" ) << endl ; cout << minRemovals ( \"0100101\" ) << endl ; return 0 ; }"}
{"text": "Cari nilai xxxx .... . (N kali) % m di mana n adalah besar | C ++ pelaksanaan pendekatan; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y / 2; Fungsi untuk mengembalikan xxx .... . (N kali) % m; Mengembalikan mod dengan m nombor yang lebih kecil; Mewujudkan rentetan n x 's; Menukar rentetan ke int dan mengira modulo; Memeriksa pariti n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk ganjil n; Kod pemacu; Cetak xxx ... (n kali) % m", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } int findModuloByM ( int X , int N , int M ) { if ( N < 6 ) { string temp ( N , ( char ) ( 48 + X ) ) ; int res = stoi ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } int main ( ) { int X = 6 , N = 14 , M = 9 ; cout << findModuloByM ( X , N , M ) ; return 0 ; }"}
{"text": "Semak jika dua lingkaran bersilang sedemikian rupa sehingga bulatan ketiga melewati titik -titik persimpangan dan pusat mereka | Program C ++ untuk pendekatan di atas; Struktur bulatan; Fungsi utiliti untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Menyimpan jarak antara pusat C1 dan C2; Menyimpan status jika kriteria yang diberikan berpuas hati atau tidak; Jika C1C2 kurang daripada jumlah radii 2 lingkaran pertama; Jika C3 adalah titik tengah pusat di C1 dan C2; Tanda bendera benar; Bendera kembali; Fungsi untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Semak kombinasi bulatan semasa; Semak kombinasi seterusnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; class circle { public : double x ; double y ; double r ; } ; bool check ( circle C [ ] ) { double C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; bool flag = 0 ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = 1 ; } } return flag ; } bool IsFairTriplet ( circle c [ ] ) { bool f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; } int main ( ) { circle C [ 3 ] ; C [ 0 ] = { 0 , 0 , 8 } ; C [ 1 ] = { 0 , 10 , 6 } ; C [ 2 ] = { 0 , 5 , 5 } ; if ( IsFairTriplet ( C ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk mencari eksentrik hyperbola | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari eksentrik hiperbola; Menyimpan nisbah kuadrat paksi utama kepada paksi kecil; Kenaikan r oleh 1; Mengembalikan akar kuadrat R; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << eccHyperbola ( A , B ) ; return 0 ; }"}
{"text": "Kirakan kawasan kuadrilateral kitaran dengan panjang sampingan yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kawasan kuadrilateral kitaran; Menyimpan nilai separuh perimeter; Kedai kawasan kuadrilateral kitaran; Mengembalikan kawasan yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } int main ( ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; cout << calculateArea ( A , B , C , D ) ; return 0 ; }"}
{"text": "Kirakan nisbah kawasan segitiga yang tertulis dalam elips dan segitiga yang dibentuk oleh titik yang sama pada bulatan tambahan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira nisbah segitiga yang tertulis dalam elips ke segitiga pada bulatan tambahan; Menyimpan nisbah separuh besar hingga separuh kapak kecil; Cetak nisbah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; cout << ratio ; } int main ( ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; return 0 ; }"}
{"text": "Program untuk mencari excenters segitiga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira jarak antara sepasang mata; Fungsi untuk mengira koordinat excenters segitiga; Panjang sisi segitiga; Menyimpan koordinat excenters segitiga; Untuk i1; Untuk i2; Untuk i3; Cetak excenters segitiga; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float distance ( int m , int n , int p , int q ) { return sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ; } void Excenters ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { float a = distance ( x2 , x3 , y2 , y3 ) ; float b = distance ( x3 , x1 , y3 , y1 ) ; float c = distance ( x1 , x2 , y1 , y2 ) ; vector < pair < float , float > > excenter ( 4 ) ; excenter [ 1 ] . first = ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) / ( - a + b + c ) ; excenter [ 1 ] . second = ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) / ( - a + b + c ) ; excenter [ 2 ] . first = ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) / ( a - b + c ) ; excenter [ 2 ] . second = ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) / ( a - b + c ) ; excenter [ 3 ] . first = ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) / ( a + b - c ) ; excenter [ 3 ] . second = ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) / ( a + b - c ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { cout << excenter [ i ] . first << \" ▁ \" << excenter [ i ] . second << endl ; } } int main ( ) { float x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }"}
{"text": "Program untuk mencari ketinggian trapezoid | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira ketinggian trapezoid; Memohon formula Heron; Hitung kawasan; Hitung ketinggian trapezoid; Cetak ketinggian; Kod pemacu; Memandangkan A, B, P1 dan P2", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findHeight ( float p1 , float p2 , float b , float c ) { float a = max ( p1 , p2 ) - min ( p1 , p2 ) ; float s = ( a + b + c ) / 2 ; float area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; float height = ( area * 2 ) / a ; cout << \" Height ▁ is : ▁ \" << height ; } int main ( ) { float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; return 0 ; }"}
{"text": "Nombor Icositetragonal | Program C ++ untuk mencari nombor icositetragon nth; Berfungsi untuk mencari nombor icositetragonal; Formula untuk mengira nombor icositetragonal nth; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icositetragonal_num ( n ) << endl ; n = 10 ; cout << Icositetragonal_num ( n ) ; return 0 ; }"}
{"text": "Kawasan bulatan yang ditulis dalam trapezoid isosceles | Pelaksanaan CPP untuk mencari rea dari bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Fungsi untuk mencari kawasan bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Radius bulatan oleh formula i. e. akar (m * n) / 2 kawasan bulatan = (3.141) * (r * * 2); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; } int main ( ) { int n = 10 ; int m = 30 ; cout << ( area_of_circle ( m , n ) ) ; }"}
{"text": "Kawasan segitiga sama rata yang tertulis dalam lingkaran radius r | C ++ pelaksanaan untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Berfungsi untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Asas dan ketinggian segitiga sama rata; Kawasan menggunakan asas dan ketinggian; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } int main ( ) { int R = 7 ; cout << ( area ( R ) ) ; return 0 ; }"}
{"text": "Kawasan bulatan terbesar yang boleh ditulis dalam separuh bulatan | Program C ++ untuk mencari bulatan terbesar yang boleh ditulis dalam separuh bulatan; Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; Kawasan bulatan terbesar; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = 3.14 * R * R / 4 ; return a ; } int main ( ) { float R = 2 ; cout << circlearea ( R ) << endl ; return 0 ; }"}
{"text": "Bilangan pasang garisan yang mempunyai titik persimpangan integer | Program C ++ kepada bilangan pasang garis yang mempunyai titik persimpangan integer; Mengira bilangan pasang garis yang mempunyai titik persimpangan integer; Memulakan susunan untuk menyimpan tuduhan; Kiraan bilangan ganjil dan bahkan pi; Kiraan bilangan ganjil dan bahkan qi; Mengembalikan kiraan pasangan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } int main ( ) { int P [ ] = { 1 , 3 , 2 } , Q [ ] = { 3 , 0 } ; int N = sizeof ( P ) / sizeof ( P [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << countPairs ( P , Q , N , M ) ; return 0 ; }"}
{"text": "Bilangan maksimum persimpangan garis yang dibentuk melalui persimpangan pesawat N | C ++ pelaksanaan pProach di atas; Berfungsi untuk mengira bilangan maksimum persimpangan yang mungkin; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << countIntersections ( n ) ; return 0 ; }"}
{"text": "Kawasan pentagram biasa | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kawasan segitiga BCD; Menggunakan nisbah emas; Hitung kawasan segitiga BCD; Kawasan pulangan semua 5 segitiga adalah sama; Berfungsi untuk mengembalikan kawasan pentagon biasa; Kirakan kawasan pentagon biasa menggunakan formula di atas; Kawasan pulangan Pentagon biasa; Berfungsi untuk mengembalikan kawasan pentagram; Kawasan pentagram adalah sama dengan kawasan pentagon biasa dan lima kali kawasan segitiga; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define PI  3.14159 NEW_LINE using namespace std ; double areaOfTriangle ( float d ) { float c = 1.618 * d ; float s = ( d + c + c ) / 2 ; double area = sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; } double areaOfRegPentagon ( float d ) { double cal = 4 * tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; } double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; } int main ( ) { float d = 5 ; cout << areaOfPentagram ( d ) << endl ; return 0 ; }"}
{"text": "Sudut yang disebarkan oleh kord ke pusat bulatan apabila sudut yang disuntik oleh kord lain yang sama dari lingkaran kongruen diberikan | Program C ++ untuk mencari sudut yang disembur oleh kord ke pusat bulatan apabila sudut yang diselaraskan oleh kord lain yang sama dari lingkaran kongruen diberikan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void anglequichord ( int z ) { cout << \" The ▁ angle ▁ is ▁ \" << z << \" ▁ degrees \" << endl ; } int main ( ) { int z = 48 ; anglequichord ( z ) ; return 0 ; }"}
{"text": "Program untuk mencetak nilai ASCII bagi semua digit nombor tertentu | Program C ++ untuk menukar digit nombor kepada nilai ASCIInya; Berfungsi untuk menukar digit N ke nilai ASCII masing -masing; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int convertToASCII ( int N ) { string num = to_string ( N ) ; for ( char ch : num ) { cout << ch << \" ▁ ( \" << ( int ) ch << \" ) STRNEWLINE \" ; } } int main ( ) { int N = 36 ; convertToASCII ( N ) ; return 0 ; }"}
{"text": "Teka -teki Arus Produk | Set 3 | Program C ++ untuk pendekatan di atas; Berfungsi untuk membentuk pelbagai produk dengan ruang O (n) dan o (1); Menyimpan produk array; Menyimpan kiraan sifar; Melintasi array; Jika arr [i] tidak sifar; Jika arr [i] adalah sifar maka kiraan kenaikan z oleh 1; Menyimpan nilai mutlak produk; Jika z sama dengan 1; Jika arr [i] tidak sifar; Lain; Jika kiraan 0 s sekurang -kurangnya 2; Berikan arr [i] = 0; Simpan nilai mutlak arr [i]; Cari nilai A / B; Jika arr [i] dan produk kedua -duanya kurang daripada sifar; Jika arr [i] dan produk kedua -duanya lebih besar daripada sifar; Lain; Melintasi array arr []; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void productExceptSelf ( int arr [ ] , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] ) product *= arr [ i ] ; z += ( arr [ i ] == 0 ) ; } int a = abs ( product ) , b ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = abs ( arr [ i ] ) ; int curr = round ( exp ( log ( a ) - log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = -1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; productExceptSelf ( arr , N ) ; return 0 ; }"}
{"text": "Count Subarrays terdiri daripada single | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira subarrays yang terdiri daripada bilangan bulat tunggal sahaja; Kedai kiraan subarray; Menyimpan kiraan nombor angka tunggal berturut -turut dalam array; Melintasi array; Saiz kenaikan blok sebanyak 1; Peningkatan res mengikut kiraan; Menetapkan kiraan = 0; Kod pemacu; Diberikan array; Saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; } int main ( ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; singleDigitSubarrayCount ( arr , N ) ; return 0 ; }"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada nombor n boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut atau tidak; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Menyimpan kiraan yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int N ) { return ( ( N & ( N - 1 ) ) && N ) ; } void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) ) count ++ ; } cout << count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; }"}
{"text": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Mengira kuasa 2 sehingga n; Kiraan kenaikan; Mengemas kini kuasa semasa 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } cout << N - Count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; }"}
{"text": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Kirakan perbezaan bersebelahan maksimum untuk keseluruhan array; Simpan maksimum antara arr_max dan curr_max; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; int arr_max = INT_MIN ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = max ( curr_max , arr_max ) ; res . push_back ( ans ) ; } for ( auto x : res ) cout << x << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }"}
{"text": "Kurangkan kenaikan yang diperlukan untuk membuat kiraan elemen array yang sama dan ganjil sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari operasi min untuk membuat kiraan yang sama dan ganjil sama; Saiz ganjil tidak akan menjadi ganjil dan juga dianggap sama; Menyimpan kiraan nombor walaupun dalam array arr []; Kedai mengira nombor ganjil dalam array arr []; Melintasi array arr []; Jika arr [i] adalah nombor yang sama; Kemas kini cnteven; Nombor ganjil dalam arr []; Kembali perbezaan mutlak dibahagikan dengan 2; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { cout << \" - 1\" ; exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return abs ( cntEven - cntOdd ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumIncrement ( arr , N ) ; return 0 ; }"}
{"text": "Kira cara untuk membina array dengan produk walaupun dari array yang diberikan sedemikian rupa sehingga perbezaan mutlak unsur -unsur yang diindeks sama paling banyak 1 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari mengira cara untuk membina array, B [] seperti abs (a [i] - b [i]) <= 1 dan produk unsur -unsur B [] adalah walaupun; Kedai kiraan tatasusunan b [] seperti abs (a [i] - b [i]) <= 1; Kedai -kedai Count of Arrays B [] yang produk elemennya tidak; Melintasi array; Jumlah kemas kini; Jika [i] adalah nombor yang sama; Kemas kini Oddarray; Cetak 3 ^ n - 2 ^ x; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray << \" STRNEWLINE \" ; } int main ( ) { int A [ ] = { 2 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cntWaysConsArray ( A , N ) ; return 0 ; }"}
{"text": "Kira nombor sehingga n yang paling tepat ditetapkan adalah k | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira nombor dalam julat [1, n] yang paling tepat ditetapkan adalah k; Menyimpan nombor yang paling tepat adalah k; Nombor yang paling tepat adalah i; Mengurangkan nombor yang paling tepat ditetapkan adalah saya, dari n; Oleh kerana i = k, maka nombor yang paling tepat ditetapkan adalah k disimpan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } cout << numbers_rightmost_setbit_K ; } int main ( ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; return 0 ; }"}
{"text": "Kira pekali ganjil dan bahkan binomial N | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira set bit dalam perwakilan binari nombor n; Count set bit dalam n; Mengembalikan kiraan akhir; Kod pemacu; Cetak koefisien binomial ganjil; Cetak walaupun koefisien binomial", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; while ( N ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } int main ( ) { int N = 4 ; int bits = countSetBits ( N ) ; cout << \" Odd ▁ \" << \" : ▁ \" << pow ( 2 , bits ) << \" STRNEWLINE \" ; cout << \" Even ▁ \" << \" : ▁ \" << N + 1 - pow ( 2 , bits ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Buat semua elemen array walaupun dengan menggantikan mana -mana sepasang elemen array dengan jumlah mereka | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan minimum penggantian yang diperlukan untuk membuat semua elemen array walaupun; Menyimpan kiraan elemen ganjil; Melintasi array; Meningkatkan kiraan elemen ganjil; Bilangan penggantian yang diperlukan; Dua langkah tambahan diperlukan untuk membuat elemen ganjil yang terakhir walaupun; Cetak penggantian minimum; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; cout << moves ; } int main ( ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minMoves ( arr , N ) ; return 0 ; }"}
{"text": "Split Squares of First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program C ++ untuk pendekatan di atas; Berfungsi untuk partition squares nombor semulajadi dalam dua subset; Simpan kiraan blok saiz 8; Pemisahan blok 8 elemen; Simpan perbezaan subset minimum; Pemisahan elemen N untuk meminimumkan perbezaan jumlah subset mereka; Simpan unsur subset A dan B; Jika elemen adalah jenis A; Jika elemen adalah jenis B; Cetak perbezaan subset minimum; Cetak subset pertama; Cetak subset kedua; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSubsetDifference ( int N ) { int blockOfSize8 = N / 8 ; string str = \" ABBABAAB \" ; int subsetDifference = 0 ; string partition = \" \" ; while ( blockOfSize8 -- ) { partition += str ; } vector < int > A , B ; for ( int i = 0 ; i < N ; i ++ ) { if ( partition [ i ] == ' A ' ) { A . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } else { B . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } } cout << subsetDifference << \" STRNEWLINE \" ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) cout << A [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; for ( int i = 0 ; i < B . size ( ) ; i ++ ) cout << B [ i ] << \" ▁ \" ; } int main ( ) { int N = 8 ; minimumSubsetDifference ( N ) ; return 0 ; }"}
{"text": "Pembahagi terbesar nombor yang tidak dapat dibahagikan dengan nombor yang lain | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari nombor terbesar x supaya ia membahagikan p tetapi tidak dapat dibahagikan dengan q; Menyimpan kiraan kekerapan semua faktor utama; Meningkatkan kekerapan faktor utama semasa; Jika Q adalah faktor utama; Menyimpan hasil yang diingini; Melangkah melalui semua pembahagi Q; Menyimpan kiraan kekerapan pembahagi utama semasa untuk membahagikan p; Mengira kekerapan faktor utama semasa; Jika CUR kurang daripada kekerapan maka p adalah hasil akhir; Berulang untuk mendapatkan jawapan sementara; Mengemas kini jawapan semasa; Cetak hasil yang diinginkan; Kod pemacu; Diberikan p dan q; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTheGreatestX ( int P , int Q ) { map < int , int > divisiors ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 and Q > 1 ) { Q /= i ; divisiors [ i ] ++ ; } } if ( Q > 1 ) divisiors [ Q ] ++ ; int ans = 0 ; for ( auto i : divisiors ) { int frequency = i . second ; int temp = P ; int cur = 0 ; while ( temp % i . first == 0 ) { temp /= i . first ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . first ; } ans = max ( temp , ans ) ; } cout << ans ; } int main ( ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; return 0 ; }"}
{"text": "Semak jika baris matriks boleh disusun semula untuk membuat bitwise xor lajur pertama non | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada ada baris di mana bilangan elemen unik lebih besar daripada 1; Melangkah ke atas matriks; Fungsi untuk memeriksa sama ada mungkin untuk menyusun semula tikar [] [] supaya xor lajur pertamanya bukan sifar; Cari bitwise xor lajur pertama Mat [] []; Jika bitwise xor lajur pertama tikar [] [] bukan sifar; Jika tidak, periksa semula; Kod pemacu; Diberikan matriks mat [] []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkRearrangements ( vector < vector < int > > mat , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) { return \" Yes \" ; } } } return \" No \" ; } string nonZeroXor ( vector < vector < int > > mat , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i ] [ 0 ] ; } if ( res != 0 ) return \" Yes \" ; else return checkRearrangements ( mat , N , M ) ; } int main ( ) { vector < vector < int > > mat = { { 1 , 1 , 2 } , { 2 , 2 , 2 } , { 3 , 3 , 3 } } ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; cout << nonZeroXor ( mat , N , M ) ; return 0 ; }"}
{"text": "Memaksimumkan bitwise dan elemen pertama dengan pelengkap elemen yang tinggal untuk sebarang permutasi array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memaksimumkan nilai untuk fungsi yang diberikan dan elemen array; Arahan vektor untuk mengekalkan bit mana yang ditetapkan untuk integer dalam array yang diberikan dengan menyimpan indeks integer itu; Semak jika b - th bit ditetapkan untuk integer i - th; Tolak indeks integer itu dalam setbit [j]; Cari elemen yang mempunyai bit set signifikan tertinggi dalam unsur -unsur lain; Letakkan integer itu pada indeks 0 - th; Simpan maksimum dan nilai; Kembalikan jawapannya; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size_int  32 NEW_LINE int functionMax ( int arr [ ] , int n ) { vector < int > setBit [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push_back ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << functionMax ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah semua produk koefisien binomial dua nombor sehingga k | C ++ pelaksanaan pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Berfungsi untuk mengira dan mengembalikan jumlah produk; Memulakan jumlah hingga 0; Melintasi 0 hingga k; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; } int main ( ) { int n = 3 , m = 2 , k = 2 ; cout << solve ( n , m , k ) ; return 0 ; }"}
{"text": "Exponention Cepat Menggunakan Manipulasi Bit | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan A ^ n; Kedai Jawapan Akhir; Semak jika LSB semasa ditetapkan; Peralihan kanan; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } int main ( ) { int a = 3 , n = 5 ; cout << powerOptimised ( a , n ) ; return 0 ; }"}
{"text": "Cari M sedemikian rupa sehingga GCD M dan Nombor N adalah maksimum | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari integer m sedemikian rupa sehingga GCD (n, m) adalah maksimum; Memulakan pembolehubah; Cari semua pembahagi N dan kembalikan pembahagi maksimum; Semak jika saya boleh dibahagikan dengan n; Kemas kini max_gcd; Mengembalikan nilai maksimum; Kod pemacu; Nombor yang diberikan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } int main ( ) { int N = 10 ; cout << findMaximumGcd ( N ) ; return 0 ; }"}
{"text": "Elemen pertama setiap set K mempunyai unsur berturut -turut dengan faktor -faktor utama yang kurang daripada n | Program C ++ untuk pendekatan di atas; Untuk menyimpan faktor utama terkecil; Fungsi membina pelbagai faktor utama terkecil; Tandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri. ; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Semak jika saya adalah Perdana; Mark SPF untuk semua nombor yang boleh dibahagikan oleh i; Mark SPF [J] jika ia tidak ditandakan sebelum ini; Fungsi untuk jumlah jumlah faktor utama; Fungsi untuk mencetak unsur -unsur set un elemen berturut -turut yang mempunyai faktor utama; Untuk menyimpan hasilnya; Mengira bilangan faktor utama nombor; Jika nombor mempunyai faktor yang betul -betul mendorong hasil []; Melangkah sehingga kita mendapat unsur -unsur berturut -turut dalam hasil []; Mengira urutan sehingga k; Cetak elemen jika Count> = k; Kod pemacu; Untuk membina SPF []; Diberikan n dan k; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #define x  2000021 NEW_LINE using namespace std ; long long int v [ x ] ; void sieve ( ) { v [ 1 ] = 1 ; for ( long long int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( long long int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( long long int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( long long int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } } long long int prime_factors ( long long n ) { set < long long int > s ; while ( n != 1 ) { s . insert ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ( ) ; } void distinctPrimes ( long long int m , long long int k ) { vector < long long int > result ; for ( long long int i = 14 ; i < m + k ; i ++ ) { long long count = prime_factors ( i ) ; if ( count == k ) { result . push_back ( i ) ; } } long long int p = result . size ( ) ; for ( long long int index = 0 ; index < p - 1 ; index ++ ) { long long element = result [ index ] ; long long count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) cout << element << ' ▁ ' ; } } int main ( ) { sieve ( ) ; long long int N = 1000 , K = 3 ; distinctPrimes ( N , K ) ; return 0 ; }"}
{"text": "Produk nombor kompleks menggunakan tiga operasi pendaraban | Program C ++ untuk pendekatan di atas; Berfungsi untuk membiak nombor kompleks dengan hanya tiga pendaraban; Cari nilai prod1, prod2 dan prod3; Bahagian sebenar; Bahagian khayalan; Cetak hasilnya; Kod pemacu; Diberi empat nombor; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; cout << real << \" ▁ + ▁ \" << imag << \" i \" ; } int main ( ) { int a , b , c , d ; a = 2 ; b = 3 ; c = 4 ; d = 5 ; print_product ( a , b , c , d ) ; return 0 ; }"}
{"text": "Nombor Insolite | C ++ pelaksanaan untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah nombor insolit; Untuk menyimpan jumlah kuadrat digit; Untuk menyimpan produk dataran digit; mengekstrak digit; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } int main ( ) { int N = 111 ; if ( isInsolite ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Nombor Superabundant | C ++ pelaksanaan untuk memeriksa sama ada nombor adalah superbundant; Fungsi untuk mengira jumlah semua pembahagi nombor tertentu; Jumlah pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'n'; Jika kedua -dua pembahagi adalah sama maka tambahkannya sekali lagi tambah kedua -duanya; Tambah 1 dan N untuk menghasilkan seperti gelung di atas menganggap pembahagi yang betul lebih besar daripada 1; Berfungsi untuk memeriksa sama ada n adalah nombor superbundant; untuk memeriksa semua nombor dari 1 hingga n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sigma ( int n ) { if ( n == 1 ) return 1 ; int result = 0 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } bool isSuperabundant ( int N ) { for ( float i = 1 ; i < N ; i ++ ) { float x = sigma ( i ) / i ; float y = sigma ( N ) / ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; } int main ( ) { int N = 4 ; isSuperabundant ( N ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }"}
{"text": "D Nombor | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nombor N - th icosikaipentagon; Nombor hendaklah lebih besar daripada 3; Semak setiap k dalam julat 2 hingga n - 1; keadaan untuk nombor D; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isDNum ( int n ) { if ( n < 4 ) return false ; int numerator , hcf ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = pow ( k , n - 2 ) - k ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } int main ( ) { int n = 15 ; int a = isDNum ( n ) ; if ( a ) cout << \" Yes \" ; else cout << \" No \" ; }"}
{"text": "Ruth | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Berfungsi untuk memeriksa nombor Ruth - Aaron; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } bool RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; } int main ( ) { int N = 714 ; if ( RuthAaronNumber ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }"}
{"text": "Memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan dalam array dengan jumlah k | Program C ++ untuk memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan; Fungsi untuk memaksimumkan jumlah; Perbezaan adalah 0 apabila hanya satu elemen yang terdapat dalam array; Perbezaan adalah k apabila dua elemen hadir dalam pelbagai; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } int main ( ) { int N = 6 ; int K = 11 ; cout << maxAdjacentDifference ( N , K ) ; return 0 ; }"}
{"text": "Jumlah semua pembahagi dari 1 hingga N | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi mengembalikan jumlah nombor dari 1 hingga n; Fungsi mengembalikan jumlah nombor dari A + 1 hingga B; Fungsi mengembalikan jumlah jumlah pembahagi; Kedai Jumlah Jumlah; Mencari nombor dan kejadiannya; Jumlah produk setiap nombor dan kejadiannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1000000007 ; int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; } int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; } int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; } int main ( ) { int N = 4 ; cout << totalSum ( N ) << endl ; N = 12 ; cout << totalSum ( N ) << endl ; return 0 ; }"}
{"text": "Nombor undulant nontrivial | Pelaksanaan C ++ untuk memeriksa sama ada N adalah nombor undulant nontrivial; Fungsi untuk memeriksa sama ada rentetan adalah rentetan ganda atau tidak; A dan B tidak sepatutnya sama; Keadaan untuk memeriksa sama ada panjang ganjil membuat panjang walaupun; separuh pertama s; separuh kedua s; Rentetan double jika separuh pertama dan terakhir adalah sama; Fungsi untuk memeriksa sama ada n adalah nombor undulant yang tidak dapat dipulihkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDouble ( int num ) { string s = to_string ( num ) ; int l = s . length ( ) ; if ( s [ 0 ] == s [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } string s1 = s . substr ( 0 , l / 2 ) ; string s2 = s . substr ( l / 2 ) ; return s1 == s2 ; } bool isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; } int main ( ) { int n = 121 ; if ( isNontrivialUndulant ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Nombor Megagon | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nombor megagon nth; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << MegagonNum ( n ) ; return 0 ; }"}
{"text": "Produk semua pasangan dari array yang diberikan | C ++ pelaksanaan untuk mencari produk semua pasangan dari array yang diberikan; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Gelung bersarang untuk mengira semua pasangan yang mungkin; Melipatgandakan produk unsur -unsur pasangan semasa; Mengembalikan hasil akhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }"}
{"text": "Produk semua pasangan dari array yang diberikan | C ++ pelaksanaan untuk mencari produk semua pasangan dari array yang diberikan; Fungsi untuk mengira (x ^ y) % 1000000007; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; Mengembalikan hasil akhir; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Berulang untuk setiap elemen array; Setiap elemen muncul (2 * n) kali; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE #define ll  long long int NEW_LINE int power ( int x , unsigned int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } ll productPairs ( ll arr [ ] , ll n ) { ll product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; } int main ( ) { ll arr [ ] = { 1 , 2 , 3 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }"}
{"text": "Membina array sedemikian rupa sehingga jumlah kiub semua elemen adalah persegi yang sempurna | Program C ++ untuk membina array bahawa jumlah kiub semua elemen adalah persegi yang sempurna; Berfungsi untuk membuat dan mencetak array; memulakan pelbagai saiz n; Cetak array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int N ) { int arr [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" , ▁ \" ; } } int main ( ) { int N = 6 ; constructArray ( N ) ; return 0 ; }"}
{"text": "Kira semua seterusnya yang produknya adalah nombor komposit | C ++ pelaksanaan untuk mengira semua seterusnya yang produknya adalah nombor komposit; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk mencari bilangan berikutnya yang produknya adalah nombor komposit; Cari jumlah berikutnya yang tidak kosong; Cari kiraan nombor utama dan yang; Kirakan yang tidak kosong; Cari kiraan seterusnya komposit; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int countSubsequences ( int arr [ ] , int n ) { int totalSubsequence = pow ( 2 , n ) - 1 ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = pow ( 2 , countOnes ) - 1 ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; } int main ( ) { int arr [ ] = { 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequences ( arr , n ) ; return 0 ; }"}
{"text": "Cari integer berturut -turut seperti jumlah mereka adalah n | C ++ pelaksanaan untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah integer K berturut -turut; Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah K berturut -turut; Mencari istilah pertama AP; Memeriksa jika istilah pertama adalah integer; Gelung untuk mencetak integer K berturut -turut; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksum ( int n , int k ) { float first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ; if ( first_term - int ( first_term ) == 0 ) { for ( int i = first_term ; i <= first_term + k - 1 ; i ++ ) { cout << i << \" ▁ \" ; } } else cout << \" - 1\" ; } int main ( ) { int n = 33 , k = 6 ; checksum ( n , k ) ; return 0 ; }"}
{"text": "Mewakili n sebagai jumlah k angka bahu | C ++ pelaksanaan untuk mewakili N sebagai jumlah kalah K walaupun; Berfungsi untuk mencetak perwakilan; N mestilah lebih besar daripada sama dengan 2 * k dan mestilah bahkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << \"2 ▁ \" ; } cout << check ; } else { cout << \" - 1\" ; } } int main ( ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; return 0 ; }"}
{"text": "Count of Subarrays Bersebelahan mungkin untuk setiap indeks dengan memasukkan elemen pada indeks itu | Program C ++ untuk mencari bilangan subarray bersebelahan termasuk elemen pada setiap indeks pelbagai saiz n; Berfungsi untuk mencari bilangan subarray termasuk elemen pada setiap indeks array; Mewujudkan pelbagai saiz n; Gelung itu berulang sehingga separuh panjang array; Keadaan untuk mengelakkan menimpa elemen pertengahan untuk array dengan panjangnya. ; Pengkomputeran bilangan subarray; Unsur ITH dari awal dan berakhir mempunyai bilangan subarray yang sama; Berfungsi untuk mencetak vektor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > calculateWays ( int N ) { int x = 0 ; vector < int > v ; for ( int i = 0 ; i < N ; i ++ ) v . push_back ( 0 ) ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; } void printArray ( vector < int > v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << \" ▁ \" ; } int main ( ) { vector < int > v ; v = calculateWays ( 4 ) ; printArray ( v ) ; return 0 ; }"}
{"text": "Nombor terkecil lebih besar daripada atau sama dengan x yang jumlah digitnya boleh dibahagikan dengan y | Program C ++ untuk mencari bilangan terkecil yang lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Fungsi yang mengembalikan jumlah digit nombor; Memulakan pembolehubah untuk menyimpan jumlah; Tambah digit terakhir nombor; Keluarkan digit terakhir dari nombor; Fungsi yang mengembalikan bilangan terkecil lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Memulakan pemboleh ubah hasil; Gelung melalui nombor yang lebih besar daripada sama dengan x; Hitung jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan y; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  10000000 NEW_LINE int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; } int smallestNum ( int X , int Y ) { int res = -1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int X = 5923 , Y = 13 ; cout << smallestNum ( X , Y ) ; return 0 ; }"}
{"text": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Program C ++ untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Simpan semua pembahagi n; Jika saya seorang pembahagi; Jika saya tidak sama dengan N / I; Melangkah melalui semua pembahagi n - 1 dan mengira mereka sebagai jawapan; Semak jika N - 1 adalah pembahagi atau tidak; Melangkah melalui semua pembahagi dan semak n Mod D = 1 atau (n - 1) mod d = 0; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int N ) { vector < int > div ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push_back ( i ) ; if ( N != i * i ) { div . push_back ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( auto d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }"}
{"text": "Maksimum mungkin pembahagi utama yang boleh wujud dalam nombor yang mempunyai tepat n pembahagi | C ++ pelaksanaan untuk mencari pembahagi utama maksimum nombor boleh mempunyai pembahagi N; Berfungsi untuk mencari pembahagi utama maksimum nombor yang boleh dimiliki dengan pembahagi N; Bilangan bilangan masa dibahagikan dengan 2; Membahagikan dengan nombor perdana lain; Jika bilangan terakhir juga perdana maka juga memasukkannya; Kod pemacu; Panggilan fungsi", "code": "#include <iostream> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } } if ( n > 2 ) { max_possible_prime ++ ; } cout << max_possible_prime << \" STRNEWLINE \" ; } int main ( ) { int n = 4 ; findMaxPrimeDivisor ( n ) ; return 0 ; }"}
{"text": "Kira cara untuk menyatakan nombor sebagai jumlah tepat dua nombor | Program C ++ untuk mengira cara untuk menyatakan nombor sebagai jumlah dua nombor. ; Fungsi Mengembalikan kiraan cara menyatakan nombor sebagai jumlah dua nombor. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; } int main ( ) { int N = 8 ; cout << CountWays ( N ) ; }"}
{"text": "Bahagikan array dalam dua tatasusunan panjang maksimum yang sama dengan unsur -unsur yang serupa dan berbeza | Program C ++ untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama supaya satu bahagian mengandungi unsur -unsur yang unik manakala yang lain mengandungi unsur -unsur yang sama; Berfungsi untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama; Vektor untuk mencari kekerapan setiap elemen array; Cari elemen frekuensi maksimum yang terdapat dalam array arr []; Cari jumlah elemen unik yang terdapat dalam array arr []; Cari saiz maksimum yang mana array arr [] boleh dibuang; Cari array pertama yang mengandungi elemen yang sama; Cari array kedua yang mengandungi unsur -unsur yang unik; Kod pemacu; permulaan n; perisytiharan array; saiz array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Solve ( int arr [ ] , int size , int n ) { vector < int > v ( n + 1 ) ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = ( max_element ( v . begin ( ) , v . end ( ) ) - v . begin ( ) ) ; int diff1 = n + 1 - count ( v . begin ( ) , v . end ( ) , 0 ) ; int max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) ; cout << \" Maximum ▁ size ▁ is ▁ : \" << max_size << \" STRNEWLINE \" ; cout << \" The ▁ First ▁ Array ▁ Is ▁ : ▁ STRNEWLINE \" ; for ( int i = 0 ; i < max_size ; i ++ ) { cout << max1 << \" ▁ \" ; v [ max1 ] -= 1 ; } cout << \" STRNEWLINE \" ; cout << \" The ▁ Second ▁ Array ▁ Is ▁ : ▁ STRNEWLINE \" ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { cout << i << \" ▁ \" ; max_size -- ; } if ( max_size < 1 ) break ; } cout << \" STRNEWLINE \" ; } int main ( ) { int n = 7 ; int arr [ ] = { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Solve ( arr , size , n ) ; return 0 ; }"}
{"text": "Cari Jumlah Xor semua tiga kali ganda yang tidak teratur dari array | Program C ++ untuk mencari jumlah XOR dari semua triplet yang tidak teratur dari array; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Mengembalikan n ^ ( - 1) mod p; Mengembalikan NCR % P menggunakan teorem kecil Fermat. ; Kes asas; Isi pelbagai faktorial supaya kita dapat mencari semua faktorial r, n dan n - r; Fungsi mengembalikan jumlah XOR dari semua triplet yang tidak teratur dari array; Melangkah ke atas bit; Bilangan elemen yang masing -masing 1 dan 0; Memeriksa jika k 'th bit adalah 1; Menambah bahagian bit ini kepada jawapannya; Kod pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; } int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & ( 1 << k ) ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; } int main ( ) { int n = 5 ; int A [ n ] = { 3 , 5 , 2 , 18 , 7 } ; cout << SumOfXor ( A , n ) ; return 0 ; }"}
{"text": "Kebarangkalian tidak mendapat dua kepala berturut -turut bersama -sama di N melemparkan duit syiling | C ++ pelaksanaan untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut bersama apabila duit syiling N dibuang; Fungsi untuk mengira nombor Fibonacci N - Th dalam urutan di mana A = 2 dan B = 3; Dua nombor pertama dalam urutan dimulakan; Kes asas; Gelung untuk mengira urutan Fibonacci berdasarkan dua nombor pertama yang diasaskan; Fungsi untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut apabila duit syiling N dibuang; Mengira bilangan kes yang menggalakkan; Pengkomputeran bilangan semua hasil yang mungkin untuk N TOSses; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float round ( float var , int digit ) { float value = ( int ) ( var * pow ( 10 , digit ) + .5 ) ; return ( float ) value / pow ( 10 , digit ) ; } int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } } float operations ( int N ) { int x = probability ( N ) ; int y = pow ( 2 , N ) ; return round ( ( float ) x / ( float ) y , 2 ) ; } int main ( ) { int N = 10 ; cout << ( operations ( N ) ) ; }"}
{"text": "Semak jika nombor dibentuk dengan menyertai dua nombor adalah Cube Perfect | Program C ++ untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kiub yang sempurna atau tidak; Fungsi untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Menukar nombor ke rentetan menggunakan to_string (); Menggabungkan nombor dan menukarnya menjadi integer; Semak jika nilai yang disatukan adalah kiub sempurna atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectCube ( int x ) { long double cr = round ( cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } void checkCube ( int a , int b ) { string s1 = to_string ( a ) ; string s2 = to_string ( b ) ; int c = stoi ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; return 0 ; }"}
{"text": "Nombor terbesar dalam array yang dibentuk dengan berulang kali menggabungkan dua elemen yang sama | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan jumlah terbesar; Pembolehubah untuk menyimpan jumlah terbesar; Peta untuk menyimpan frekuensi setiap elemen; Menyimpan frekuensi; Gelung untuk menggabungkan elemen pendua dan mengemas kini jumlah dalam peta; Jika J adalah elemen pendua; Kemas kini kekerapan 2 * j; Jika jumlah baru lebih besar daripada nilai maksimum, kemas kini maksimum; Mengembalikan jumlah terbesar; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int largest_sum ( int arr [ ] , int n ) { int maximum = -1 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { if ( j . second > 1 ) { m [ 2 * j . first ] = m [ 2 * j . first ] + j . second / 2 ; if ( 2 * j . first > maximum ) maximum = 2 * j . first ; } } return maximum ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest_sum ( arr , n ) ; return 0 ; }"}
{"text": "Semak sama ada mungkin untuk membuat X dan Y Zero pada masa yang sama dengan Operasi yang diberikan | C ++ program pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk membuat X dan Y boleh menjadi 0 pada masa yang sama; Semak syarat yang diberikan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBeReduced ( int x , int y ) { int maxi = max ( x , y ) ; int mini = min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; } int main ( ) { int x = 6 , y = 9 ; canBeReduced ( x , y ) ; return 0 ; }"}
{"text": "Algoritma Pemfaktoran Roda | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah kaedah pemfaktoran roda; Fungsi untuk memeriksa sama ada nombor x yang diberikan adalah perdana atau tidak; Roda untuk memeriksa nombor perdana; Kes asas; Semak nombor yang diambil sebagai asas; Semak roda di sini saya, bertindak sebagai lapisan roda; Semak senarai penapis dalam arr []; Jika nombor lebih besar daripada rehat Sqrt (n); Semak jika n adalah pelbagai nombor utama di roda; Jika di mana -mana lelaran isprime adalah palsu, pecah dari gelung; Kod pemandu; Fungsi panggilan untuk pemeriksaan primal", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void isPrime ( int N ) { bool isPrime = true ; int arr [ 8 ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) cout << \" Prime ▁ Number \" ; else cout << \" Not ▁ a ▁ Prime ▁ Number \" ; } int main ( ) { int N = 121 ; isPrime ( N ) ; return 0 ; }"}
{"text": "Cari semua pasangan yang mungkin dari array yang diberikan | C ++ pelaksanaan untuk mencari semua pasangan yang mungkin dari array yang diberikan; Berfungsi untuk mencetak semua pasangan yang mungkin dari array; Gelung bersarang untuk semua pasangan yang mungkin; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << \" ( \" << arr [ i ] << \" , ▁ \" << arr [ j ] << \" ) \" << \" , ▁ \" ; } } } int main ( ) { int arr [ ] = { 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPairs ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah kiub semua subset dari array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kiub subset; Cubing unsur -unsur dan menambahkannya ke Ans; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; long long power ( int p ) { long long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } long long subset_cube_sum ( vector < int > & A ) { int n = ( int ) A . size ( ) ; long long ans = 0 ; for ( int i : A ) { ans += ( 1LL * i * i * i ) % mod ; ans %= mod ; } return ( 1LL * ans * power ( n - 1 ) ) % mod ; } int main ( ) { vector < int > A = { 1 , 2 } ; cout << subset_cube_sum ( A ) ; return 0 ; }"}
{"text": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya kiub yang sempurna | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan kiub yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevCube = cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ; int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ; return ans ; } int main ( ) { int n = 25 ; cout << nearest ( n ) << endl ; n = 27 ; cout << nearest ( n ) << endl ; n = 40 ; cout << nearest ( n ) << endl ; return 0 ; }"}
{"text": "Semak jika bulatan terletak di dalam bulatan lain atau tidak | Program C ++ untuk memeriksa sama ada satu bulatan terletak di dalam bulatan lain atau tidak. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) cout << \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" << \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ \" << \" touching ▁ each ▁ other ▁ \" << \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" << endl ; else if ( distSq + r2 < r1 ) cout << \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" << \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ without \" << \" ▁ touching ▁ each ▁ other ▁ \" << \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" << endl ; else cout << \" The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside \" << \" ▁ the ▁ bigger ▁ circle ▁ completely . \" << endl ; } int main ( ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; return 0 ; }"}
{"text": "Panjang tangen biasa langsung antara dua lingkaran bersilang | Program C ++ untuk mencari panjang tangen umum langsung antara dua kalangan yang saling berpotongan; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << \" The ▁ length ▁ of ▁ the ▁ direct \" << \" ▁ common ▁ tangent ▁ is ▁ \" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; return 0 ; }"}
{"text": "Radius bulatan apabila lebar dan ketinggian arka diberikan | Program C ++ untuk mencari jejari bulatan apabila lebar dan ketinggian arka diberikan; Berfungsi untuk mencari jejari; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rad ( double d , double h ) { cout << \" The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ \" << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; } int main ( ) { double d = 4 , h = 1 ; rad ( d , h ) ; return 0 ; }"}
{"text": "Jarak terpendek dari pusat bulatan ke kord | Program C ++ untuk mencari jarak terpendek dari kord ke pusat bulatan; Berfungsi untuk mencari jarak terpendek; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void shortdis ( double r , double d ) { cout << \" The ▁ shortest ▁ distance ▁ \" << \" from ▁ the ▁ chord ▁ to ▁ centre ▁ \" << sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) << endl ; } int main ( ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; return 0 ; }"}
{"text": "Panjang tangen biasa langsung antara kedua -dua bukan | Program C ++ untuk mencari panjang tangen umum langsung antara dua kalangan yang tidak menyentuh satu sama lain; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << \" The ▁ length ▁ of ▁ the ▁ direct \" << \" ▁ common ▁ tangent ▁ is ▁ \" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; return 0 ; }"}
{"text": "Dataran terbesar yang boleh ditulis dalam segitiga sama rata | Program C ++ untuk mencari dataran terbesar yang boleh ditulis dalam segitiga sama rata; Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; } int main ( ) { float a = 5 ; cout << square ( a ) << endl ; return 0 ; }"}
{"text": "Apothem A N | Program C ++ untuk mencari apothem poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari apothem poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah ditukar kepada radian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; } int main ( ) { float a = 9 , n = 6 ; cout << polyapothem ( n , a ) << endl ; return 0 ; }"}
{"text": "Kawasan n | Program C ++ untuk mencari kawasan poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } int main ( ) { float a = 9 , n = 6 ; cout << polyarea ( n , a ) << endl ; return 0 ; }"}
{"text": "Sisi biasa n | C ++ pelaksanaan pendekatan; Fungsi untuk mengira sisi poligon yang dilampirkan dalam bulatan; Kod pemacu; Jumlah sisi poligon; Jejari lingkaran lingkungan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateSide ( float n , float r ) { float theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; } int main ( ) { float n = 3 ; float r = 5 ; cout << calculateSide ( n , r ) ; }"}
{"text": "Silinder bulat kanan terbesar dalam frustum | Program C ++ untuk mencari silinder bulat kanan terbesar yang boleh sesuai dalam frustum; Berfungsi untuk mencari silinder bulat kanan terbesar; Radii dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return -1 ; float r1 = r ; float h1 = h ; float V = 3.14 * pow ( r1 , 2 ) * h1 ; return V ; } int main ( ) { float r = 7 , R = 11 , h = 6 ; cout << cyl ( r , R , h ) << endl ; return 0 ; }"}
{"text": "Program untuk mencari perimeter poligon biasa | Program C ++ untuk mencari perimeter poligon biasa; Berfungsi untuk mengira perimeter; Hitung perimeter; kod pemacu; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter", "code": "#include <iostream> NEW_LINE using namespace std ; float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; } int main ( ) { int n = 5 ; float s = 2.5 , peri ; peri = Perimeter ( s , n ) ; cout << \" Perimeter ▁ of ▁ Regular ▁ Polygon \" << \" ▁ with ▁ \" << n << \" ▁ sides ▁ of ▁ length ▁ \" << s << \" ▁ = ▁ \" << peri << endl ; return 0 ; }"}
{"text": "Kawasan rombang terbesar yang boleh ditulis dalam segi empat tepat | Program C ++ untuk mencari rombus terbesar yang boleh ditulis dalam segi empat tepat; Berfungsi untuk mencari kawasan rombus terbesar; Panjang dan keluasan tidak boleh negatif; kawasan rhombus; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; return ( l * b ) / 2 ; } int main ( ) { float l = 16 , b = 6 ; cout << rhombusarea ( l , b ) << endl ; return 0 ; }"}
{"text": "Semak jika titik terletak di dalam segi empat tepat | Set | Program CPP untuk memeriksa sama ada titik terletak pada atau di dalam segi empat tepat | Set - 2; Fungsi untuk mencari jika titik diberikan terletak di dalam segi empat tepat atau tidak. ; Kod pemacu; bawah - kiri dan atas - sudut kanan segi empat tepat; titik yang diberikan; panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Jarak antara satu titik dan satah dalam 3 D | Program C ++ untuk mencari jarak serenjang (terpendek) antara satu titik dan satah dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << \" Perpendicular ▁ distance ▁ is ▁ \" << ( d / e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; }"}
{"text": "Program untuk mencari jumlah prisma segi tiga | Program CPP untuk mencari jumlah prisma segitiga; berfungsi untuk mencari jumlah prisma segi tiga; formula untuk mencari kelantangan; Kod pemacu; fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } int main ( ) { float l = 18 , b = 12 , h = 9 ; cout << \" Volume ▁ of ▁ triangular ▁ prism : ▁ \" << findVolume ( l , b , h ) ; return 0 ; }"}
{"text": "Semak jika diberi empat bilangan bulat (atau sisi) membuat segi empat tepat | Program mudah untuk mencari jika diberikan 4 nilai boleh mewakili 4 sisi segi empat tepat; Fungsi untuk memeriksa sama ada nilai integer yang diberikan membuat segi empat tepat; Square juga merupakan segi empat tepat; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } int main ( ) { int a , b , c , d ; a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Program untuk mencari pertengahan | Program C ++ untuk mencari titik tengah garis; berfungsi untuk mencari titik tengah garis; Fungsi pemacu untuk diuji di atas", "code": "#include <iostream> NEW_LINE using namespace std ; void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << \" ▁ , ▁ \" << ( float ) ( y1 + y2 ) / 2 ; } int main ( ) { int x1 = -1 , y1 = 2 ; int x2 = 3 , y2 = -6 ; midpoint ( x1 , x2 , y1 , y2 ) ; return 0 ; }"}
{"text": "Panjang arka dari sudut yang diberikan | Program C ++ untuk mengira panjang arka; fungsi untuk mengira panjang arka; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << \" Angle ▁ cannot \" , \" ▁ be ▁ formed \" ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } int main ( ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; cout << ( arc_len ) ; return 0 ; }"}
{"text": "Semak sama ada garis menyentuh atau memotong bulatan | Program CPP untuk memeriksa sama ada garis menyentuh atau bersilang atau di luar bulatan. ; Mencari jarak garis dari pusat. ; Memeriksa jika jarak kurang daripada, lebih besar daripada atau sama dengan radius. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << \" Touch \" << endl ; else if ( radius > dist ) cout << \" Intersect \" << endl ; else cout << \" Outside \" << endl ; } int main ( ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; return 0 ; }"}
{"text": "Program untuk mencari circumcenter segitiga | Program C ++ untuk mencari lingkaran segitiga; Pasangan ini digunakan untuk menyimpan koordinat X dan Y masing -masing; Fungsi untuk mencari garis yang diberikan dua mata; Fungsi yang menukarkan garis input ke bisektor tegak lurus. Ia juga memasukkan titik -titik yang pertengahannya terletak pada bisektor; c = - bx + ay; Mengembalikan titik persimpangan dua baris; Garis selari. Ini dipermudahkan dengan mengembalikan sepasang flt_max; PQ Line diwakili sebagai AX + BY = C; Line QR diwakili sebagai ex + fy = g; Menukar garis PQ dan QR ke vBisectors tegak lurus. Selepas ini, l = ax + by = c m = ex + fy = g; Titik persimpangan L dan M memberikan lekuk; Kod pemacu.", "code": "#include <iostream> NEW_LINE #include <cfloat> NEW_LINE using namespace std ; #define pdd  pair<double, double> NEW_LINE void lineFromPoints ( pdd P , pdd Q , double & a , double & b , double & c ) { a = Q . second - P . second ; b = P . first - Q . first ; c = a * ( P . first ) + b * ( P . second ) ; } void perpendicularBisectorFromLine ( pdd P , pdd Q , double & a , double & b , double & c ) { pdd mid_point = make_pair ( ( P . first + Q . first ) / 2 , ( P . second + Q . second ) / 2 ) ; c = - b * ( mid_point . first ) + a * ( mid_point . second ) ; double temp = a ; a = - b ; b = temp ; } pdd lineLineIntersection ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determinant = a1 * b2 - a2 * b1 ; if ( determinant == 0 ) { return make_pair ( FLT_MAX , FLT_MAX ) ; } else { double x = ( b2 * c1 - b1 * c2 ) / determinant ; double y = ( a1 * c2 - a2 * c1 ) / determinant ; return make_pair ( x , y ) ; } } void findCircumCenter ( pdd P , pdd Q , pdd R ) { double a , b , c ; lineFromPoints ( P , Q , a , b , c ) ; double e , f , g ; lineFromPoints ( Q , R , e , f , g ) ; perpendicularBisectorFromLine ( P , Q , a , b , c ) ; perpendicularBisectorFromLine ( Q , R , e , f , g ) ; pdd circumcenter = lineLineIntersection ( a , b , c , e , f , g ) ; if ( circumcenter . first == FLT_MAX && circumcenter . second == FLT_MAX ) { cout << \" The ▁ two ▁ perpendicular ▁ bisectors ▁ \" \" found ▁ come ▁ parallel \" << endl ; cout << \" Thus , ▁ the ▁ given ▁ points ▁ do ▁ not ▁ form ▁ \" \" a ▁ triangle ▁ and ▁ are ▁ collinear \" << endl ; } else { cout << \" The ▁ circumcenter ▁ of ▁ the ▁ triangle ▁ PQR ▁ is : ▁ \" ; cout << \" ( \" << circumcenter . first << \" , ▁ \" << circumcenter . second << \" ) \" << endl ; } } int main ( ) { pdd P = make_pair ( 6 , 0 ) ; pdd Q = make_pair ( 0 , 0 ) ; pdd R = make_pair ( 0 , 8 ) ; findCircumCenter ( P , Q , R ) ; return 0 ; }"}
{"text": "Program untuk mencari kawasan segitiga | Program C ++ untuk menilai kawasan poligon menggunakan formula kasut; (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; j = i; J adalah puncak sebelumnya kepada i; Kembali nilai mutlak; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygonArea ( X , Y , n ) ; }"}
{"text": "Memaksimumkan jumlah LSB bitwise atau semua mungkin n / 2 pasang dari array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi atas mendapatkan nilai LSB V; Penukaran binari; Fungsi untuk mencari jumlah LSB semua pasangan yang mungkin dari array yang diberikan; Menyimpan elemen array LSB; Menyimpan nilai LSB; Susun array lab_arr []; Mengambil jumlah pasangan untuk mendapatkan jumlah maksimum LSB; Cetak hasilnya; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int chk ( int n ) { vector < int > v ; while ( n != 0 ) { v . push_back ( n % 2 ) ; n = n / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == 1 ) { return pow ( 2 , i ) ; } } return 0 ; } void sumOfLSB ( int arr [ ] , int N ) { vector < int > lsb_arr ; for ( int i = 0 ; i < N ; i ++ ) { lsb_arr . push_back ( chk ( arr [ i ] ) ) ; } sort ( lsb_arr . begin ( ) , lsb_arr . end ( ) , greater < int > ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i += 2 ) { ans += ( lsb_arr [ i + 1 ] ) ; } cout << ( ans ) ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; sumOfLSB ( arr , N ) ; }"}
{"text": "Kira -kira berikutnya yang mempunyai bitwise dan nilai -nilai yang ganjil dalam array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan berikutnya yang mempunyai bitwise dan nilai ganjil; Kedai mengira unsur -unsur ganjil; Melintasi array arr []; Jika x adalah kiraan kenaikan ganjil; Jawapan kembali; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequences ( vector < int > arr ) { int odd = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } int main ( ) { vector < int > arr = { 1 , 3 , 3 } ; cout << countSubsequences ( arr ) ; return 0 ; }"}
{"text": "Kira pasangan dari array dengan perbezaan mutlak tidak kurang daripada elemen minimum dalam pasangan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan pasangan (i, j) seperti abs (a [i] - a [j]) sekurang -kurangnya minimum (a [i], a [j]); Menyimpan kiraan pasangan yang dihasilkan; Melangkah ke atas julat [0, n]; Berulang dari arr [i] - (i % arr [i]) hingga n dengan kenaikan arr [i]; Mengira pasangan yang mungkin; Mengembalikan jumlah jumlah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPairsCount ( arr , N ) ; return 0 ; }"}
{"text": "Langkah Minimum Untuk Menukar N hingga 1 dengan menukarnya menjadi 2 * n atau n / 10 pada mana -mana langkah | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada n boleh diubah menjadi 1 atau tidak. ; Kira bilangan 2 dalam faktorisasi utama N; Mengira bilangan 5 dalam faktorisasi utama N; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { cout << 2 * fives - twos ; } else { cout << -1 ; } } int main ( ) { int N = 50 ; check ( N ) ; return 0 ; }"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah elemen array dari L ke R; Melintasi L ke R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }"}
{"text": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah awalan; Kirakan jumlah awalan; Menyimpan jumlah elemen dari 1 hingga l - 1; Menyimpan jumlah elemen dari 1 hingga R; Cetak jumlah yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; cout << rightsum - leftsum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }"}
{"text": "Faktorial eksponen n | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari faktorial eksponen nombor tertentu; Menyimpan faktor exponetial N; Iterare ke atas julat [2, n]; Kemas kini res; Kembali res; Kod pemacu; Input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) pow ( i , res ) % mod ; return res ; } int main ( ) { int N = 4 ; cout << ( ExpoFactorial ( N ) ) ;"}
{"text": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Set | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari subarray bersebelahan dengan jumlah maksimum jika array diulang kali k; Simpan jumlah array arr []; Melintasi array dan cari jumlah; Simpan jawapannya; Jika k = 1; Memohon algoritma Kadane untuk mencari jumlah; Kembalikan jawapannya; Menyimpan array dua kali berulang; Melintasi julat [0, 2 * n]; Menyimpan jumlah akhiran maksimum; Menyimpan jumlah awalan maksimum; Memohon algoritma Kadane untuk 2 pengulangan array; Jika jumlah array lebih besar daripada 0; Kembalikan jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = max ( arr [ i ] , curr + arr [ i ] ) ; ans = max ( ans , curr ) ; } return ans ; } vector < int > V ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . push_back ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = max ( V [ i ] , curr + V [ i ] ) ; ans = max ( ans , curr ) ; } if ( sum > 0 ) { int temp = 1LL * sum * ( K - 2 ) ; ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 10 , 20 , -30 , -1 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 10 ; cout << maxSubArraySumRepeated ( arr , N , K ) ; return 0 ; }"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan kiraan subarray; Menjana semua subarray yang mungkin; Menyimpan elemen maksimum subarray; Menyimpan maksimum semua elemen lain; Cari elemen maksimum dalam subarray [i, j]; Cari maksimum semua elemen lain; Jika maksimum subarray lebih besar daripada dua kali ganda maksimum elemen lain; Cetak nilai maksimum yang diperoleh; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }"}
{"text": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan elemen maksimum array; Melintasi array yang diberikan; Jika nilai 2 * arr [i] lebih besar daripada MX; Kemas kini nilai l dan keluar dari gelung; Jika nilai 2 * arr [i] lebih besar daripada Mx; Mengemas kini nilai r dan keluar dari gelung; Cetak jawapan terakhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 , L = 0 , R = 0 ; int mx = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } cout << ( L + 1 ) * ( n - R ) ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }"}
{"text": "Cari Nombor Perdana hanya kurang daripada dan hanya lebih besar setiap elemen array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi utiliti untuk memeriksa keunggulan nombor X dengan memeriksa sama ada X HAACCs apa -apa faktor selain daripada 1 dan sendiri. ; jika (x % i == 0) faktor yang dijumpai; Berfungsi untuk mencetak prima hanya kurang daripada dan hanya lebih besar daripada setiap elemen dalam array; Melintasi array; Traverse untuk mencari perdana kurang daripada [i]; Perdana hanya kurang daripada yang dijumpai; Melintasi untuk mencari perdana lebih besar daripada [i]; Perdana hanya lebih besar daripada yang dijumpai; Kod pemacu; Input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) return false ; return true ; } void printPrimes ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( isPrime ( j ) ) { cout << j << \" ▁ \" ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( isPrime ( j ) ) { cout << j << \" ▁ \" ; break ; } } cout << endl ; } } int main ( ) { int A [ ] = { 17 , 28 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPrimes ( A , N ) ; return 0 ; }"}
{"text": "Elemen terkecil kth dalam array yang mengandungi [i] betul -betul b [i] kali | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari elemen terkecil kth yang mengandungi [i] tepat b [i] kali; Melintasi array yang diberikan; Menyimpan kekerapan setiap elemen; Melintasi array yang diberikan; Memulakan pembolehubah untuk menyimpan jumlah awalan; Melangkah ke atas julat [0, M]; Jumlah kenaikan oleh freq [i]; Jika jumlah lebih besar daripada atau sama dengan k; Mengembalikan elemen semasa sebagai jawapan; Kembali - 1; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( A [ i ] , M ) ; } int freq [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return -1 ; } int main ( ) { int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 4 ; cout << KthSmallest ( A , B , N , K ) ; return 0 ; }"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarrays; Menyimpan hasil yang diperlukan; Menjana semua subarray; Simpan elemen semasa; Cari bitwise atau; Mengemas kini hasilnya; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }"}
{"text": "Bitwise atau bitwise dan semua subarrays array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subset berturut -turut dari array; Menyimpan hasil yang diperlukan; Melintasi array yang diberikan; Cetak hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }"}
{"text": "Semak jika jumlah digit nombor melebihi produk digit nombor itu | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada jumlah digit N adalah lebih besar daripada produk digit N atau tidak; Menyimpan jumlah dan produk digit N; Menyimpan digit terakhir jika n; Kenaikan nilai sumofdigit; Mengemas kini prodofdigit; Bahagikan n oleh 10; Cetak hasilnya; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int N = 1234 ; check ( N ) ; return 0 ; }"}
{"text": "Cetak semua awalan yang berbeza dan ganjil bitwise xors pertama n Nombor semula jadi | Program C ++ untuk pendekatan di atas; Cetak semua awalan yang berbeza & ganjil bitwise xors dari 1 hingga n; Cetak nombor juga; Cetak nombor ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenOddBitwiseXOR ( int N ) { cout << \" Even : ▁ \" << 0 << \" ▁ \" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i << \" ▁ \" ; } cout << \" STRNEWLINE \" ; cout << \" Odd : ▁ \" << 1 << \" ▁ \" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i - 1 << \" ▁ \" ; } if ( N % 4 == 2 ) cout << N + 1 ; else if ( N % 4 == 3 ) cout << N ; } int main ( ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; return 0 ; }"}
{"text": "Permutasi terbesar lexicographically mungkin dengan swap yang lebih kecil daripada array yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk permutasi terbesar lexicographic mungkin dengan swap yang lebih kecil daripada array yang diberikan; Cari indeks elemen pertama sedemikian rupa sehingga arr [i]> arr [i + 1]; Jika array disusun dalam peningkatan urutan; Cari indeks elemen pertama yang lebih kecil daripada arr [i]; Jika arr [j] = = arr [j - 1]; Pengurangan j; Swap elemen; Cetak array arr []; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == -1 ) { cout << \" - 1\" ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } swap ( arr [ i ] , arr [ j ] ) ; for ( auto & it : arr ) { cout << it << ' ▁ ' ; } } int main ( ) { vector < int > arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; return 0 ; }"}
{"text": "Perbezaan mutlak antara kiraan ganjil dan juga faktor n | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari faktor utama terkecil dari semua nombor menggunakan ayak eratosthenes; Kedai sama ada nombor mana -mana atau tidak; Memulakan faktor terkecil sebagai 2 untuk semua nombor walaupun; Melangkah ke atas julat [3, n]; Sekiranya saya adalah perdana; Melepasi semua gandaan i; Saya adalah faktor utama terkecil i * j; Fungsi untuk mencari perbezaan mutlak antara kiraan ganjil dan juga faktor n; Menyimpan faktor utama terkecil i; Isi nilai dalam S [] menggunakan ayak eratosthenes; Menyimpan jumlah faktor dan jumlah faktor ganjil dan bahkan; Simpan faktor utama semasa nombor n; Simpan kuasa faktor utama semasa; Gelung manakala n lebih besar daripada 1; Jika n juga mempunyai faktor utama terkecil seperti Curr, maka kenaikan CNT oleh 1; Kemas kini hanya jumlah faktor jika curr adalah 2; Mengemas kini jumlah faktor dan jumlah faktor ganjil; Mengemas kini faktor utama semasa S [n] dan dikira sebagai 1; Kirakan bilangan faktor walaupun; Cetak perbezaan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sieveOfEratosthenes ( int N , int s [ ] ) { vector < bool > prime ( N + 1 , false ) ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } void findDifference ( int N ) { int s [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; cout << abs ( even - odd ) ; } int main ( ) { int N = 12 ; findDifference ( N ) ; return 0 ; }"}
{"text": "Kirakan median dari nilai min dan mod yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari median sekumpulan data dengan min dan mod yang diberikan; Kirakan median; Cetak median; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; } int main ( ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; return 0 ; }"}
{"text": "Program untuk mencari magnitud vektor | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira magnitud vektor 3 dimensi; Menyimpan jumlah kuadrat koordinat vektor; Mengembalikan magnitud; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; } int main ( ) { int x = 1 ; int y = 2 ; int z = 3 ; cout << vectorMagnitude ( x , y , z ) ; return 0 ; }"}
{"text": "Program untuk mencari produk nombor dengan nombor Mersenne | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari prodcut nombor Mersenne dengan nombor lain; Menyimpan kuasa 2 integer m + 1; Mengembalikan produk; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long multiplyByMersenne ( long N , long M ) { long x = log2 ( M + 1 ) ; return ( ( N << x ) - N ) ; } int main ( ) { long N = 4 ; long M = 15 ; cout << multiplyByMersenne ( N , M ) ; return 0 ; }"}
{"text": "Kuasa terdekat 2 dari dataran sempurna terdekat bukan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari persegi yang paling dekat dengan Num; Kirakan akar kuadrat NUM; Kirakan persegi sempurna; Cari dataran sempurna terdekat; Berfungsi untuk mencari kuasa 2 yang paling dekat dengan nombor nombor; Hitung asas log 2 dari NUM; Kuasa tertinggi 2 iaitu <= num; Berfungsi untuk mencari persegi sempurna yang terdekat dan kuasa terdekat 2 dari setiap elemen array yang kejadiannya adalah 1; Kedai kekerapan elemen array; Melintasi array dan kemas kini kekerapan elemen array semasa; Melintasi peta freq; Jika kekerapan adalah 1; Cari persegi sempurna yang terdekat; Cetak kuasa terdekat 2; Sekiranya mana -mana tidak mengandungi unsur -unsur yang tidak berulang; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int perfectSquare ( int num ) { int sr = sqrt ( num ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } } int powerOfTwo ( int num ) { int lg = log2 ( num ) ; int p = pow ( 2 , lg ) ; return p ; } void uniqueElement ( int arr [ ] , int N ) { bool ans = true ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( auto el : freq ) { if ( el . second == 1 ) { ans = false ; int ps = perfectSquare ( el . first ) ; cout << powerOfTwo ( ps ) << ' ▁ ' ; } } if ( ans ) cout << \" - 1\" ; } int main ( ) { int arr [ ] = { 4 , 11 , 4 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; uniqueElement ( arr , N ) ; return 0 ; }"}
{"text": "Arahan partition menjadi dua subarray dengan setiap elemen di subarray kanan dengan ketat daripada setiap elemen di subarray kiri | C ++ program pendekatan di atas; Berfungsi untuk memisahkan array menjadi dua subarrays bukan kosong yang memenuhi syarat yang diberikan; Menyimpan array akhiran min; Menyimpan minimum akhiran; Melintasi array secara terbalik; Mengemas kini minimum; Simpan minimum; Menyimpan nilai maksimum awalan; Menyimpan indeks partition; Kemas kini Max; Jika max kurang daripada min [i + 1]; Simpan indeks partition; rehat; Jika Ind tidak - 1; Cetak subarray pertama; Cetak subarray kedua; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void partitionArray ( int * a , int n ) { int * Min = new int [ n ] ; int Mini = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Mini = min ( Mini , a [ i ] ) ; Min [ i ] = Mini ; } int Maxi = INT_MIN ; int ind = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { Maxi = max ( Maxi , a [ i ] ) ; if ( Maxi < Min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != -1 ) { for ( int i = 0 ; i <= ind ; i ++ ) cout << a [ i ] << \" ▁ \" ; cout << endl ; for ( int i = ind + 1 ; i < n ; i ++ ) cout << a [ i ] << \" ▁ \" ; } else cout << \" Impossible \" ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = 5 ; partitionArray ( arr , N ) ; return 0 ; }"}
{"text": "Semak sama ada nombor boleh diwakili sebagai jumlah integer positif k di mana sekurang -kurangnya k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira semua faktor utama nombor tertentu; Kira bilangan 2 s yang membahagikan n; Oleh kerana N adalah ganjil pada ketika ini, langkau satu elemen; Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Jika n adalah nombor perdana yang lebih besar daripada 2; Berfungsi untuk mencari jumlah nombor pertama N hampir utama; Simpan jumlah yang diperlukan; Tambah nombor ini jika ia memenuhi syarat; Kiraan kenaikan hampir nombor utama; Fungsi untuk memeriksa sama ada n boleh diwakili sebagai jumlah k antara bilangan bulat positif yang berbeza di mana sekurang -kurangnya k - 1 daripadanya adalah hampir perdana; Simpan jumlah pertama k - 1 hampir nombor utama; Jika jumlah lebih besar daripada atau sama dengan n; Jika tidak, cetak ya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; } void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) cout << \" No \" ; else cout << \" Yes \" ; } int main ( ) { int n = 100 , k = 6 ; check ( n , k ) ; return 0 ; }"}
{"text": "Kira cara untuk mewakili integer sebagai eksponen | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira GCD A dan B menggunakan algoritma Euclidean; Iterat sehingga B bukan sifar; Mengembalikan GCD; Fungsi untuk mengira bilangan cara n boleh dinyatakan sebagai x ^ y; Kes asas; Menyimpan GCD kuasa; Kirakan tahap 2 dalam n; Kirakan tahap nombor utama dalam n; Kirakan tahap perdana 'i' dalam n; Jika n adalah perdana, G menjadi 1 .; Menyimpan bilangan cara untuk mewakili n sebagai x ^ y; Cari bilangan faktor G; Mengemas kini kiraan cara; Berulang untuk mencari bilangan nombor perdana; Cari kuasa i; Mengemas kini kiraan cara; Jika G adalah Perdana; Mengembalikan jumlah cara; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int gcd ( long long int a , long long int b ) { while ( b > 0 ) { long long int rem = a % b ; a = b ; b = rem ; } return a ; } int countNumberOfWays ( long long int n ) { if ( n == 1 ) return -1 ; long long int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } int main ( ) { int N = 64 ; cout << countNumberOfWays ( N ) ; return 0 ; }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan integer yang diberikan | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor positif yang diberikan; Fungsi lantai digunakan untuk menentukan nilai yang dekat dengan nombor; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor negatif yang diberikan; Fungsi Ceil digunakan untuk nombor negatif sebagai - 1> - 4. Ia akan bertentangan dengan nombor positif di mana 1 <4; Berfungsi untuk mencari kuasa tertinggi 2; Untuk memeriksa sama ada nombor yang diberikan positif atau negatif; Jika nombor itu negatif, maka siling nombor positif dikira dan tanda negatif ditambah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int powOfPositive ( int n ) { int pos = floor ( log2 ( n ) ) ; return pow ( 2 , pos ) ; } int powOfNegative ( int n ) { int pos = ceil ( log2 ( n ) ) ; return ( -1 * pow ( 2 , pos ) ) ; } void highestPowerOf2 ( int n ) { if ( n > 0 ) { cout << powOfPositive ( n ) ; } else { n = - n ; cout << powOfNegative ( n ) ; } } int main ( ) { int n = -24 ; highestPowerOf2 ( n ) ; return 0 ; }"}
{"text": "Bilangan kad yang diperlukan membina rumah kad tahap n | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan kad yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << noOfCards ( n ) << \" , ▁ \" ; return 0 ; }"}
{"text": "Cari nombor terkecil dari sejumlah besar yang diberikan dengan kiraan digit yang sama | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mencari nombor yang paling kecil selepas menukar digit beberapa kali; Pembolehubah untuk menyimpan jawapan terakhir; Array untuk menyimpan kiraan kejadian setiap digit; Gelung untuk mengira bilangan kejadian setiap digit; Gelung untuk mendapatkan nombor terkecil; Mengembalikan jawapannya; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; string smallestPoss ( string s , int n ) { string ans = \" \" ; int arr [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + to_string ( i ) ; } return ans ; } int main ( ) { int N = 15 ; string K = \"325343273113434\" ; cout << smallestPoss ( K , N ) ; return 0 ; }"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan sub -tatasusunan dengan jumlah yang lebih besar daripada unsur -unsur array yang tinggal; Untuk gelung untuk titik permulaan subarray; Untuk gelung untuk titik akhir subarray; Permulaan subarray_sum dan sisa_sum ke 0; Untuk gelung untuk mengira jumlah subarray yang dihasilkan; Untuk gelung untuk mengira unsur array sisa jumlah; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah unsur array yang tinggal; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }"}
{"text": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | C ++ pelaksanaan pendekatan di atas; Mengira jumlah jumlah array yang diberikan; Untuk gelung untuk titik permulaan subarray; permulaan subarray_sum hingga 0; Untuk gelung untuk mengira subarray_sum dan sisa_sum; Mengira subarray_sum dan sisa yang sama; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah baki elemen array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }"}
{"text": "Keluarkan satu elemen untuk mendapatkan XOR maksimum | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan XOR yang dimaksimumkan selepas mengeluarkan elemen dari array; Cari xor array lengkap; Untuk menyimpan jawapan terakhir; Melangkah melalui array untuk mencari jawapan terakhir; Kembalikan jawapan terakhir; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXOR ( int * arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxXOR ( arr , n ) ; return 0 ; }"}
{"text": "Kira nombor dari julat [l, r] yang mengandungi sekurang -kurangnya satu digit yang membahagikan k | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika NUM mengandungi sekurang -kurangnya satu digit yang membahagikan k; Dapatkan digit terakhir; Jika digit bukan sifar dan ia membahagikan k; Keluarkan digit terakhir; Tiada digit dalam num yang membahagikan k; Fungsi untuk mengembalikan kiraan unsur -unsur yang diperlukan dari julat yang diberikan yang mengandungi sekurang -kurangnya satu digit yang membahagikan k; Untuk menyimpan hasilnya; Untuk setiap nombor dari julat; Jika mana -mana digit nombor semasa membahagikan k; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool digitDividesK ( int num , int k ) { while ( num ) { int d = num % 10 ; if ( d != 0 and k % d == 0 ) return true ; num = num / 10 ; } return false ; } int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; } int main ( ) { int l = 20 , r = 35 ; int k = 45 ; cout << findCount ( l , r , k ) ; return 0 ; }"}
{"text": "Semak jika nombor tertentu adalah faktorial mana -mana nombor | C ++ pelaksanaan untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah faktorial bagi mana -mana nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } int main ( ) { int n = 24 ; bool ans = isFactorial ( n ) ; if ( ans == 1 ) { cout << \" Yes STRNEWLINE \" ; } else { cout << \" No STRNEWLINE \" ; } return 0 ; }"}
{"text": "Keluarkan elemen untuk meminimumkan LCM array yang diberikan | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan LCM dua nombor; Berfungsi untuk mengembalikan LCM minimum selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik negara tunggal untuk menyimpan LCM unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan LCM dari semua elemen yang mempunyai indeks lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan LCM minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; } int MinLCM ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinLCM ( a , n ) ; return 0 ; }"}
{"text": "Bilangan berwarna 0 dalam n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan berwarna 0 s dalam segi enam tahap n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; }"}
{"text": "Nilai minimum yang akan diberikan kepada unsur -unsur supaya jumlahnya menjadi lebih besar daripada jumlah awal | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai minimum yang diperlukan; Cari jumlah elemen array; Mengembalikan nilai yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinValue ( arr , n ) ; return 0 ; }"}
{"text": "Warna semua kotak sejajar supaya setiap kotak berturut -turut m adalah unik | C ++ pelaksanaan pendekatan; Fungsi untuk kembali (M! % Mod); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } int main ( ) { int n = 3 , m = 2 ; cout << modFact ( n , m ) ; return 0 ; }"}
{"text": "Jumlah kuadrat semua subset dari array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kuadrat subset; Squuaring unsur -unsur dan menambahkannya ke Ans; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; long long power ( int p ) { long long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } long long subset_square_sum ( vector < int > & A ) { int n = ( int ) A . size ( ) ; long long ans = 0 ; for ( int i : A ) { ans += ( 1LL * i * i ) % mod ; ans %= mod ; } return ( 1LL * ans * power ( n - 1 ) ) % mod ; } int main ( ) { vector < int > A = { 3 , 7 } ; cout << subset_square_sum ( A ) ; return 0 ; }"}
{"text": "Cari bilangan pasangan supaya GCD mereka sama dengan 1 | Program CPP untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Berfungsi untuk mengira faktor utama paling kurang setiap nombor; Jika ia adalah nombor utama; Untuk semua gandaan yang belum dikunjungi. ; Berfungsi untuk mencari nilai fungsi Mobius untuk semua nombor dari 1 hingga n; Jika nombor adalah satu; Jika nombor mempunyai faktor utama kuasa; Multiply - 1 dengan nombor sebelumnya; Berfungsi untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Untuk menyimpan nombor maksimum; Untuk menyimpan kekerapan setiap nombor; Cari kekerapan dan nombor maksimum; Untuk menyimpan nombor pasangan dengan GCD sama dengan 1; Melintasi semua elemen yang mungkin; Mengembalikan bilangan pasangan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100050 NEW_LINE int lpf [ N ] , mobius [ N ] ; void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( ! lpf [ i ] ) for ( int j = i ; j < N ; j += i ) if ( ! lpf [ j ] ) lpf [ j ] = i ; } void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = -1 * mobius [ i / lpf [ i ] ] ; } } } int gcd_pairs ( int a [ ] , int n ) { int maxi = 0 ; int fre [ N ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( ! mobius [ i ] ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << gcd_pairs ( a , n ) ; return 0 ; }"}
{"text": "Membandingkan x ^ y dan y ^ x untuk nilai -nilai yang sangat besar x dan y | C ++ pelaksanaan pendekatan; Fungsi untuk membandingkan x ^ y dan y ^ x; Menyimpan nilai x ^ y dan y ^ x; Membandingkan nilai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << \" ^ \" << y << \" ▁ > ▁ \" << y << \" ^ \" << x ; else if ( a < b ) cout << x << \" ^ \" << y << \" ▁ < ▁ \" << y << \" ^ \" << x ; else if ( a == b ) cout << x << \" ^ \" << y << \" ▁ = ▁ \" << y << \" ^ \" << x ; } int main ( ) { long double x = 4 , y = 5 ; compareVal ( x , y ) ; return 0 ; }"}
{"text": "Nombor Euler Zigzag (Permutasi Ganti) | Program CPP untuk mencari urutan zigzag; Berfungsi untuk mencetak nombor zigzag pertama; Untuk menyimpan nombor factorial dan n 'th zig zag; Memulakan factorial sehingga n; Tetapkan dua nombor Zig Zag pertama; Cetak dua nombor zig zag pertama; Cetak nombor zig zag selebihnya; Binomial (n, k) * a (k) * a (n - k); Simpan nilai; Cetak nombor; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void ZigZag ( int n ) { long long fact [ n + 1 ] , zig [ n + 1 ] = { 0 } ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; cout << \" zig ▁ zag ▁ numbers : ▁ \" ; cout << zig [ 0 ] << \" ▁ \" << zig [ 1 ] << \" ▁ \" ; for ( int i = 2 ; i < n ; i ++ ) { long long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; cout << sum / 2 << \" ▁ \" ; } } int main ( ) { int n = 10 ; ZigZag ( n ) ; return 0 ; }"}
{"text": "Urutan Gijswijt | Program C ++ untuk menunjukkan urutan Gijswijt; Jika urutan adalah (1) a (2) a (3). . A (n - 1) Periksa jika urutan boleh diwakili sebagai x * (y ^ k) mencari nilai terbesar k; kiraan; Corak unsur -unsur saiz I dari akhir urutan; kiraan; ekstrak corak dalam urutan terbalik; Semak berapa kali corak diulang; jika perlawanan dosis elemen; Jika akhir corak dicapai nilai set k = 0 dan tingkatkan kiraan; mengembalikan kiraan maksimum; cetak pertama n terma urutan Gijswijt; Tetapkan kiraan; membongkok elemen; Cetak istilah N pertama urutan; tolak elemen; Cari kiraan untuk nombor seterusnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_count ( vector < int > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) { vector < int > p ; int c = 0 ; for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) p . push_back ( ele [ j ] ) ; int j = ele . size ( ) - 1 , k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) break ; j -- ; k ++ ; if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = max ( count , c ) ; } return count ; } void solve ( int n ) { int count = 1 ; vector < int > ele ; for ( int i = 0 ; i < n ; i ++ ) { cout << count << \" , ▁ \" ; ele . push_back ( count ) ; count = find_count ( ele ) ; } } int main ( ) { int n = 10 ; solve ( n ) ; return 0 ; }"}
{"text": "Wedderburn - Nombor Etherington | Program CPP untuk mencari istilah urutan; Menyimpan nombor Wedderburn Etherington; Berfungsi untuk mengembalikan nombor Nth Wedderburn Etherington; Kes asas; Jika n adalah n = 2 x; Dapatkan x; A (2 x) = A (1) A (2 x - 1) + A (2) A (2 x - 2) + ... + A (x - 1) A (x + 1); a (x) (a (x) + 1) / 2; Simpan Ans; Mengembalikan jawapan yang diperlukan; Jika n adalah ganjil; a (2 x - 1) = a (1) a (2 x - 2) + a (2) a (2 x - 3) + ... + a (x - 1) a (x) ,; Simpan Ans; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencetak nombor N First N Wedderburn Etherington; Simpan nombor 3 pertama; Cetak n terma; Kod pemacu; panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > store ; int Wedderburn ( int n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; store [ n ] = ans ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } store [ n ] = ans ; return ans ; } } void Wedderburn_Etherington ( int n ) { store [ 0 ] = 0 ; store [ 1 ] = 1 ; store [ 2 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { cout << Wedderburn ( i ) ; if ( i != n - 1 ) cout << \" , ▁ \" ; } } int main ( ) { int n = 10 ; Wedderburn_Etherington ( n ) ; return 0 ; }"}
{"text": "Nilai maksimum selepas menggabungkan semua elemen dalam array | Program CPP ke nilai maksimum selepas menggabungkan semua elemen dalam array; Berfungsi dengan nilai maksimum selepas menggabungkan semua elemen dalam array; Untuk memeriksa sama ada elemen positif dan negatif hadir atau tidak; Semak integer positif; Semak integer negatif; Jika kedua -dua unsur positif dan negatif hadir; Untuk menyimpan nilai maksimum yang mungkin; Untuk mencari nilai minimum; Keluarkan elemen minimum; Menggantikan dengan nilai mutlak; Untuk mencari nilai minimum; Keluarkan elemen minimum; Mengembalikan jumlah yang diperlukan; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Max_sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( pos == 1 and neg == 1 ) break ; } int sum = 0 ; if ( pos == 1 and neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) sum += abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } int main ( ) { int a [ ] = { 1 , 3 , 5 , -2 , -6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Max_sum ( a , n ) ; return 0 ; }"}
{"text": "Perpuluhan untuk binari menggunakan rekursi dan tanpa menggunakan pengendali kuasa | C ++ pelaksanaan pendekatan; Fungsi rekursif untuk menukar n kepada bersamaan binari; Kes asas; Panggilan rekursif; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decimalToBinary ( int n ) { if ( n == 0 ) { cout << \"0\" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; } int main ( ) { int n = 13 ; decimalToBinary ( n ) ; return 0 ; }"}
{"text": "Cari nilai minimum a, b dan c apabila dua (a + b), (a + c) dan (b + c) diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari A, B dan C; Simpan nombor minimum dalam x; Cari nombor; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumValue ( int x , int y ) { if ( x > y ) swap ( x , y ) ; int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << \" ▁ \" << b << \" ▁ \" << c ; } int main ( ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; return 0 ; }"}
{"text": "Semak sama ada mungkin untuk menukar A ke B | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika A boleh ditukar kepada B dengan operasi yang diberikan; Jika nombor semasa berakhir dengan 1; Jika nombor semasa boleh dibahagikan dengan 2; Jika di atas dua keadaan gagal; Sekiranya mungkin untuk menukar A ke B; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; } int main ( ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Count Rectangles yang berbeza dalam N * N Chessboard | C ++ kod untuk mengira segi empat tepat yang berbeza dalam papan catur; Berfungsi untuk mengembalikan kiraan segi empat tepat; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } int main ( ) { int N = 4 ; cout << count ( N ) ; }"}
{"text": "Jumlah hari yang diambil untuk menyelesaikan tugas jika selepas hari -hari tertentu seseorang meninggalkan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan hari yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } int main ( ) { int a = 10 , b = 20 , n = 5 ; cout << numberOfDays ( a , b , n ) ; return 0 ; }"}
{"text": "Cari purata dua nombor menggunakan operasi bit | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan purata x dan y menggunakan operasi bit; Kirakan nilai lantai purata (x + y) / 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } int main ( ) { int x = 10 , y = 9 ; cout << getAverage ( x , y ) ; return 0 ; }"}
{"text": "Indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya; Pada mulanya; Melintasi array; Semak jika elemen array adalah 1; a [i] = 0; Kembali minimum kedua -duanya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; } int main ( ) { int a [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << smallestIndex ( a , n ) ; return 0 ; }"}
{"text": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Tetapkan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan dataran yang boleh dikunjungi oleh raja dalam gerakan; Untuk menyimpan kiraan dataran; Semak semua dataran papan catur; Semak jika persegi (i, j) berada pada jarak <= m unit dari kedudukan semasa Raja; Kembali kiraan kuadrat; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } int main ( ) { int r = 4 , c = 4 , m = 1 ; cout << countSquares ( r , c , m ) << endl ; return 0 ; }"}
{"text": "Bilangan kuadrup di mana tiga syarat pertama berada dalam AP dan tiga istilah terakhir adalah dalam gp | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan kuadrup; Jadual Hash untuk mengira bilangan kejadian; Melintasi dan meningkatkan kiraan; Jalankan dua gelung bersarang untuk elemen kedua dan ketiga; Jika mereka sama; Pada mulanya mengurangkan kiraan; Cari elemen pertama menggunakan perbezaan bersama; Cari elemen keempat menggunakan gp y ^ 2 = x * z harta; Jika ia adalah integer; Jika tidak sama; Unsur yang sama; Kemudian meningkatkan nilai untuk pengiraan masa depan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countQuadruples ( int a [ ] , int n ) { unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) mpp [ a [ i ] ] ++ ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mpp [ a [ j ] ] -- ; mpp [ a [ k ] ] -- ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) count += mpp [ first ] * mpp [ fourth ] ; else count += mpp [ first ] * ( mpp [ fourth ] - 1 ) ; } mpp [ a [ j ] ] ++ ; mpp [ a [ k ] ] ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countQuadruples ( a , n ) ; return 0 ; }"}
{"text": "Nombor dalam julat dengan akar digital yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor yang ada dalam julat yang diberikan; Bilangan kumpulan 9 elemen bermula dari L; Meninggalkan unsur -unsur yang tidak diliputi dalam Faktor 9; Satu nombor dalam setiap kumpulan 9; Untuk memeriksa sama ada nombor dalam REM memenuhi harta itu; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int countNumbers ( int L , int R , int K ) { if ( K == 9 ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) ans ++ ; } return ans ; } int main ( ) { int L = 10 ; int R = 22 ; int K = 3 ; cout << countNumbers ( L , R , K ) ; return 0 ; }"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Tambah nilai yang diberikan kepada [indeks]; Untuk menyimpan jumlah elemen walaupun; Jika elemen semasa adalah walaupun; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Vektor yang dihasilkan yang menyimpan hasil untuk setiap pertanyaan; Dapatkan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int EvenSum ( vector < int > & A , int index , int value ) { A [ index ] = A [ index ] + value ; int sum = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; return sum ; } void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; sum = EvenSum ( A , index , value ) ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << \" ▁ \" ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }"}
{"text": "Jumlah nilai dan kemas kini pertanyaan pada array | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Jika elemen semasa adalah walaupun; Jika elemen bahkan kemudian keluarkannya dari jumlah; Jika nilai menjadi walaupun selepas mengemas kini; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << \" ▁ \" ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }"}
{"text": "Bilangan Siklus Hamiltonian | Program C ++ untuk pelaksanaan program di atas; Fungsi yang mengira bilangan kitaran Hamiltonian; Mengira faktorial; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } int main ( ) { int N = 5 ; int Number = Cycles ( N ) ; cout << \" Hamiltonian ▁ cycles ▁ = ▁ \" << Number ; return 0 ; }"}
{"text": "Integer terkecil lebih besar daripada n sedemikian rupa sehingga ia terdiri daripada digit m tepat kali K | C ++ pelaksanaan pendekatan; Fungsi yang pulih benar jika n mengandungi digit m tepat k kali; Berfungsi untuk mengembalikan integer terkecil> n dengan digit m yang berlaku tepat kali K; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; } int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } } int main ( ) { int n = 111 , m = 2 , k = 2 ; cout << findInt ( n , m , k ) ; return 0 ; }"}
{"text": "KOMPOSITE XOR DAN COPRIME DAN | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan nombor ganjil dalam array; Pembolehubah untuk mengira nombor ganjil; Nombor ganjil; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOdd ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; } int countValidPairs ( int arr [ ] , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countValidPairs ( arr , n ) ; return 0 ; }"}
{"text": "Cube sempurna terkecil dibahagi dengan semua elemen array | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan LCM semua elemen array; Untuk mengira LCM dua nombor melipatgandakan mereka dan membahagikan hasilnya dengan GCD kedua -dua nombor; Mengembalikan LCM unsur -unsur array; Berfungsi untuk mengembalikan kiub sempurna yang paling kecil yang boleh dibahagikan dengan semua elemen arr []; LCM semua elemen ARR []; Jika 2 membahagikan bilangan kali LCM CNT; Semak semua nombor yang membahagikan LCM; Kembalikan jawapannya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } ll lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; ll lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } int minPerfectCube ( int arr [ ] , int n ) { ll minPerfectCube ; ll lcm = lcmOfArray ( arr , n ) ; minPerfectCube = ( long long ) lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } int main ( ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minPerfectCube ( arr , n ) ; return 0 ; }"}
{"text": "Semak jika n adalah Perdana yang kuat | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah perdana yang kuat; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah perdana yang kuat; Jika n bukan nombor perdana atau n adalah perdana pertama maka kembali palsu; Inisialisasi sebelumnya_prime ke n - 1 dan next_prime ke n + 1; Cari nombor perdana seterusnya; Cari nombor perdana sebelumnya; Min aritmetik; Jika n adalah perdana yang kuat; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; } int main ( ) { int n = 11 ; if ( isStrongPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Penyingkiran minimum dalam nombor yang boleh dibahagikan dengan 10 kuasa yang dibangkitkan kepada k | Program CPP untuk mengira bilangan digit yang boleh dikeluarkan sedemikian rupa sehingga nombor itu boleh dibahagikan dengan 10 ^ k; berfungsi untuk mengembalikan bilangan digit yang diperlukan untuk dikeluarkan; Menukar nombor yang diberikan ke dalam rentetan; pembolehubah untuk menyimpan nombor digit yang akan dikeluarkan; Pembolehubah untuk menunjukkan jika sekurang -kurangnya satu sifar telah dijumpai; sifar dijumpai; saiz pulangan - 1 jika k tidak sifar dan atleast satu sifar hadir, jika tidak hasilnya; Kod pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; } int main ( ) { int N = 10904025 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 1000 , K = 5 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 23985 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; return 0 ; }"}
{"text": "Program untuk mencari jumlah siri (1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n) | Program C ++ untuk mencari jumlah siri yang diberikan; Berfungsi untuk mengembalikan jumlah siri; pembolehubah untuk menyimpan jawapannya; Matematik. pow (x, y) mengembalikan x ^ y; Kod pemacu; Cetak jumlah siri", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; } int main ( ) { int a = 3 , n = 3 ; cout << ( getSum ( a , n ) ) ; return 0 ; }"}
{"text": "Semak sama ada nombor adalah nombor yang tidak biasa atau tidak | Program C ++ untuk memeriksa nombor yang tidak biasa; Fungsi utiliti untuk mencari faktor utama terbesar bagi nombor; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; n >> = 1; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya untuk bilangan bulat yang ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk memeriksa nombor yang tidak biasa; Dapatkan faktor utama terbesar nombor; Semak jika faktor utama terbesar adalah lebih besar daripada sqrt (n); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestPrimeFactor ( int n ) { int max = -1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; } bool checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > sqrt ( n ) ) { return true ; } else { return false ; } } int main ( ) { int n = 14 ; if ( checkUnusual ( n ) ) { cout << \" YES \" << \" STRNEWLINE \" ; } else { cout << \" NO \" << \" STRNEWLINE \" ; } return 0 ; }"}
{"text": "Semak jika sekurang -kurangnya separuh array boleh diturunkan kepada sifar dengan melakukan beberapa operasi | Program C ++ untuk mencari sama ada separuh - array boleh diturunkan kepada 0; Berfungsi untuk mencetak hasil yang diingini selepas pengiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ m + 1 ] ; int i ; memset ( frequencyHash , 0 , sizeof ( frequencyHash ) ) ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; } int main ( ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 7 ; isHalfReducible ( arr , n , m ) ; return 0 ; }"}
{"text": "Semak jika nombor yang diberikan adalah nombor bijih atau tidak | Program CPP untuk memeriksa sama ada nombor yang diberikan adalah nombor bijih; Fungsi yang mengembalikan min harmonik; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi sama, simpan 'i'; lain sebaliknya menyimpan 'i' dan 'n / i' kedua -duanya; Fungsi utiliti untuk mengira min harmonik pembahagi; Mengisytiharkan pembolehubah jumlah dan permulaan dengan sifar. ; hitung penyebut; Mengira min dan pulangan harmonik; Berfungsi untuk memeriksa sama ada nombor adalah nombor bijih; Kirakan min harmonik pembahagi n; Semak jika min harmonik adalah integer atau tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > arr ; void generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . push_back ( i ) ; { arr . push_back ( i ) ; arr . push_back ( n / i ) ; } } } } double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + double ( n / arr [ i ] ) ; sum = double ( sum / n ) ; return double ( arr . size ( ) / sum ) ; } bool isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - int ( mean ) == 0 ) return true ; else return false ; } int main ( ) { int n = 28 ; if ( isOreNumber ( n ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }"}
{"text": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program CPP untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor utama dan menyimpan produk mereka; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; kedai awalan produk nombor utama ke unordered_set 's'; mengemas kini produk dengan mendarabkan Perdana Seterusnya; Masukkan 'Produce + 1' untuk ditetapkan; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Periksa sama ada nombor wujud dalam set yang tidak teratur atau tidak jika ada, kembali benar; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE unordered_set < long long int > s ; void SieveOfEratosthenes ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } long long int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . insert ( product + 1 ) ; } } } bool isEuclid ( long n ) { if ( s . find ( n ) != s . end ( ) ) return true ; else return false ; } int main ( ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; n = 42 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; return 0 ; }"}
{"text": "Semak sama ada nombor yang diberikan ialah Wagstaff Prime atau tidak | Program CPP untuk memeriksa sama ada nombor adalah Wagstaff Prime atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi utiliti untuk memeriksa kuasa dua; Program pemacu; Semak jika nombor adalah perdana dan borang (2 ^ q + 1) / 3", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; } int main ( ) { int n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { cout << \" YES STRNEWLINE \" ; } else { cout << \" NO STRNEWLINE \" ; } return 0 ; }"}
{"text": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segi enam | Program C ++ untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segi enam; Berfungsi untuk mencari kawasan dataran; sisi segi enam tidak boleh negatif; kawasan dataran; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }"}
{"text": "Program untuk mencari istilah n Siri 1, 6, 17, 34, 56, 86, 121, 162, ... .... | C ++ Program untuk mencari istilah n siri: 1, 6, 17, 34, 56, 86, 121, 162, .... . ; mengira istilah siri nth; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }"}
{"text": "Jumlah terma pertama N Siri 2, 10, 30, 68, .... | Program C ++ untuk mencari jumlah terma pertama N; Berfungsi untuk mengira jumlah; Kod pemacu; bilangan syarat yang akan dimasukkan dalam jumlah; Cari jumlahnya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; } int main ( ) { int n = 3 ; cout << \" Sum ▁ = ▁ \" << calculateSum ( n ) ; return 0 ; }"}
{"text": "Semak jika dua tatasusunan adalah permutasi antara satu sama lain menggunakan operasi matematik | Kod CPP untuk memeriksa sama ada array adalah permutasi EAH yang lain; Fungsi untuk memeriksa sama ada tatasusunan adalah permutasi antara satu sama lain. ; Mengira jumlah dan kalikan array pertama; Mengira jumlah dan kalikan array kedua; Jika jumlah dan Mul kedua -dua tatasusunan adalah sama, kembali benar, lain kembali palsu. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } int main ( ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; int m = sizeof ( b ) / sizeof ( int ) ; if ( arePermutations ( a , b , n , m ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }"}
{"text": "Program untuk mencari permulaan dalam perlumbaan | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mencari B mula c; Apabila B menyelesaikannya 100 meter kemudian selesai meter dengan C adalah; Kod pemacu. ; Apabila ia menyelesaikannya 100 meter kemudian selesai meter b dan c adalah", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } int main ( ) { int B = 10 , C = 28 ; B = 100 - B ; C = 100 - C ; cout << Race ( B , C ) << \" ▁ meters \" ; return 0 ; }"}
{"text": "Masa minimum diperlukan untuk mengisi tangki menggunakan paip n | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira masa; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; } int main ( ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << floor ( Time ( arr , n , Emptypipe ) ) << \" ▁ Hours \" ; return 0 ; }"}
{"text": "Semak jika perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 | Program CPP untuk memeriksa sama ada perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 atau tidak; Berfungsi untuk memeriksa kebolehpasaran; Jumlah semua digit individu; Keadaan; Kod pemacu; Nombor oktal", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } int main ( ) { int n = 25 ; ( check ( n ) == 1 ) ? cout << \" YES \" : cout << \" NO \" ; return 0 ; }"}
{"text": "Jumlah semua pembahagi utama nombor | Program CPP untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; } int main ( ) { int n = 60 ; cout << \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" << SumOfPrimeDivisors ( n ) << endl ; }"}
{"text": "Jumlah semua pembahagi utama nombor | Program CPP untuk mencari pembahagi utama semua nombor dari 1 hingga n; berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } int main ( ) { int N = 60 ; cout << \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" << Sum ( N ) << endl ; }"}
{"text": "Cari (a ^ b) % m di mana 'b' sangat besar | Program C ++ untuk mencari (a ^ b) % m untuk b sangat besar. ; Berfungsi untuk mencari kuasa; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasilnya; y mestilah sekarang y = y >> 1; y = y / 2; Kod pemacu; Input rentetan sebagai B sangat besar; Kurangkan bilangan B ke bilangan kecil menggunakan fermat kecil", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll power ( ll x , ll y , ll p ) { x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int main ( ) { ll a = 3 ; string b = \"100000000000000000000000000\" ; ll remainderB = 0 ; ll MOD = 1000000007 ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b [ i ] - '0' ) % ( MOD - 1 ) ; cout << power ( a , remainderB , MOD ) << endl ; return 0 ; }"}
{"text": "Kuadrat nombor dengan digit tunggal berulang | Tetapkan 1 (3, 6 dan 9) | Program C ++ untuk mencari persegi nombor besar ini; Fungsi untuk mencari persegi 333. .. .333, 666. .666 dan 999.. .999; Sekiranya nombornya adalah 333. .. .333; Jika nombor itu 666. .. .666; Jika nombor itu 999 .. .999; pembolehubah untuk hasil pegangan; Cari tidak digit; tambah saiz - 1 kali dalam hasil; Tambah satu kali B hasil; tambah saiz - 1 kali c dalam hasil; tambah satu kali d hasil; hasil pulangan; Kod pemacu; Cari persegi 33. .33; cari persegi 66. .66; cari persegi 66. .66", "code": "#include <iostream> NEW_LINE using namespace std ; string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) a = '1' , b = '0' , c = '8' , d = '9' ; else if ( num [ 0 ] == '6' ) a = '4' , b = '3' , c = '5' , d = '6' ; else a = '9' , b = '8' , c = '0' , d = '1' ; string result = \" \" ; int size = num . size ( ) ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += c ; result += d ; return result ; } int main ( ) { string num_3 , num_6 , num_9 ; num_3 = \"3333\" ; num_6 = \"6666\" ; num_9 = \"9999\" ; string result = \" \" ; result = find_Square_369 ( num_3 ) ; cout << \" Square ▁ of ▁ \" << num_3 << \" ▁ is ▁ : ▁ \" << result << endl ; result = find_Square_369 ( num_6 ) ; cout << \" Square ▁ of ▁ \" << num_6 << \" ▁ is ▁ : ▁ \" << result << endl ; result = find_Square_369 ( num_9 ) ; cout << \" Square ▁ of ▁ \" << num_9 << \" ▁ is ▁ : ▁ \" << result << endl ; return 0 ; }"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) | Untuk menjalankan kod ini, kita perlu menyalin modular songsang dari pos di bawah. HTTPS: www. Geeksforgeeks. org / multiplicative - songsang - bawah - modulo - m /; Kaedah naif - mengira hasil dalam satu baris; modular_inverse () adalah fungsi yang ditetapkan pengguna yang mengira songsang nombor; Ia akan menggunakan algoritma Eucledian yang dilanjutkan atau fermats sedikit teorem untuk pengiraan. MMI dari 120 di bawah Bahagian oleh 1000000007 akan menjadi 8083333339", "code": "int main ( ) { long int naive_answer = ( ( long int ) ( 55555 * 55554 * 55553 * 55552 * 55551 ) / 120 ) % 1000000007 ; long int ans = 1 ; long int i = modular_inverse ( 120 , 10000007 ) ; for ( int i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % 1000000007 ; ans = ( ans * i ) % 1000000007 ; cout << \" Answer ▁ using ▁ naive ▁ method : ▁ \" << naive_answer << endl ; cout << \" Answer ▁ using ▁ multiplicative \" << \" ▁ modular ▁ inverse ▁ concept : ▁ \" << ans ; return 0 ; }"}
{"text": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) |", "code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { long int ans = 1 ; long int mod = ( long int ) 1000000007 * 120 ; for ( int i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % mod ; ans = ans / 120 ; cout << \" Answer ▁ using ▁ shortcut : ▁ \" << ans ; return 0 ; }"}
{"text": "Cara untuk membiak elemen dengan operasi bersekutu | C ++ kod untuk mencari bilangan cara untuk membiak elemen dengan operasi bersekutu; Fungsi untuk mencari faktorial yang diperlukan; Berfungsi untuk mencari NCR; berfungsi untuk mencari bilangan cara; Kod pemacu", "code": "# include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; } int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; } int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; } int main ( ) { int n = 6 ; cout << solve ( n ) ; return 0 ; }"}
{"text": "Triplet Pythagorean dengan jumlah yang diberikan | Program C ++ untuk mencari triplet Pythagorean yang diberikan. ; Memandangkan tiga kali ganda dalam urutan yang disusun. Nilai elemen pertama dalam triplet yang disusun boleh diadakan - kebanyakan n / 3 .; Nilai elemen kedua mestilah kurang daripada sama dengan n / 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << \" , ▁ \" << j << \" , ▁ \" << k ; return ; } } } cout << \" No ▁ Triplet \" ; } int main ( ) { int n = 12 ; pythagoreanTriplet ( n ) ; return 0 ; }"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | Program CPP untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mengira faktorial nombor; berfungsi untuk mencetak siri; Mengira nilai n! ; gelung untuk memaparkan siri; Untuk mengira nilai NCR; mengira nilai A ke kuasa k dan x ke kuasa k; Paparkan siri; Fungsi utama bermula", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = pow ( A , n - i ) ; int xPow = pow ( X , i ) ; cout << ( nFact * aPow * xPow ) / ( niFact * iFact ) << \" ▁ \" ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }"}
{"text": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Program CPP untuk mencari jumlah siri dengan jumlah AP Square yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }"}
{"text": "Kuasa nombor utama 'r' dalam n! | Program C ++ untuk mencari kuasa nombor utama R dalam N! ; Berfungsi untuk mengembalikan kuasa no. 'r' dalam faktorial n; Terus membahagikan n dengan kuasa 'r' dan mengemaskini kiraan; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } int main ( ) { int n = 6 , r = 3 ; printf ( \" ▁ % d ▁ \" , power ( n , r ) ) ; return 0 ; }"}
{"text": "Purata nombor natural natur pertama | Program C ++ untuk mencari purata jumlah nombor semulajadi yang pertama. ; Mengembalikan AVG nombor n pertama; Jumlah nombor pertama yang pertama; Purata nombor pertama yang ganjil; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } int main ( ) { int n = 20 ; cout << avg_of_odd_num ( n ) ; return 0 ; }"}
{"text": "Purata nombor natural natur pertama | Program CPP untuk mencari purata jumlah nombor n pertama yang pertama; Kembalikan purata jumlah nombor pertama yang ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { return n ; } int main ( ) { int n = 8 ; cout << avg_of_odd_num ( n ) ; return 0 ; }"}
{"text": "Program untuk mencetak segitiga Fibonacci | C ++ pelaksanaan untuk segitiga Fibonacci; berfungsi untuk mengisi nombor fibonacci dalam f []; 1 ST dan 2 ND nombor siri adalah 1 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Isi nombor Fibonacci dalam f [] menggunakan Fib (). Kami memerlukan n = n * (n + 1) / 2 nombor fibonacci untuk membuat segitiga ketinggian n; Untuk menyimpan nombor Fibonacci seterusnya untuk dicetak; untuk gelung untuk menjejaki bilangan baris; Untuk gelung untuk menjejaki nombor dalam setiap baris; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void fib ( int f [ ] , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } void fiboTriangle ( int n ) { int N = n * ( n + 1 ) / 2 ; int f [ N + 1 ] ; fib ( f , N ) ; int fiboNum = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) cout << f [ fiboNum ++ ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 5 ; fiboTriangle ( n ) ; return 0 ; }"}
{"text": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Program untuk mencari purata nombor ganjil sehingga nombor ganjil yang diberikan. ; Fungsi untuk mengira purata nombor ganjil; mengira nombor ganjil; Simpan jumlah nombor ganjil; fungsi pemacu", "code": "#include <stdio.h> NEW_LINE int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 15 ; printf ( \" % d \" , averageOdd ( n ) ) ; return 0 ; }"}
{"text": "Cari Max Dua Nombor Rasional | Program CPP untuk mencari Max antara dua nombor rasional; Dapatkan LCM dua nombor; Dapatkan nombor rasional maksimum; Cari LCM pertama -> penyebut dan SEC -> penyebut; Mengisytiharkan NUME1 dan NUME2 untuk mendapatkan nilai pengangka pertama dan pengangka kedua; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Rational { int nume , deno ; } ; int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } Rational maxRational ( Rational first , Rational sec ) { int k = lcm ( first . deno , sec . deno ) ; int nume1 = first . nume ; int nume2 = sec . nume ; nume1 *= k / ( first . deno ) ; nume2 *= k / ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } int main ( ) { Rational first = { 3 , 2 } ; Rational sec = { 3 , 4 } ; Rational res = maxRational ( first , sec ) ; cout << res . nume << \" / \" << res . deno ; return 0 ; }"}
{"text": "Trinomial Triangle | Program CPP untuk mencetak segitiga trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Kes asas; Kes asas; langkah rekursif. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; } void printTrinomial ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) cout << TrinomialValue ( i , j ) << \" ▁ \" ; for ( int j = 1 ; j <= i ; j ++ ) cout << TrinomialValue ( i , j ) << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 4 ; printTrinomial ( n ) ; return 0 ; }"}
{"text": "Jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N | C ++ pelaksanaan untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N; fungsi untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan n; Buat array Integer \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai 0. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika 'I' adalah perdana, jika tidak, ia akan mengandungi faktor utama terbesar 'I'. ; Jika Perdana [P] adalah '0', maka ia adalah nombor utama; Kemas kini semua gandaan P; Merangkumi faktor utama terbesar bagi semua nombor; jika 'p' adalah nombor bukan utama maka perdana [p] memberikan faktor utama largesr; 'P' adalah nombor utama; Jumlah yang diperlukan; Program Pemandu untuk diuji di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] , sum = 0 ; memset ( prime , 0 , sizeof ( prime ) ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; } int main ( ) { int n = 12 ; cout << \" Sum ▁ = ▁ \" << sumOfLargePrimeFactor ( n ) ; return 0 ; }"}
{"text": "Jumlah gandaan nombor sehingga n | Program C ++ untuk mencari jumlah gandaan nombor sehingga n dengan cekap; Berfungsi untuk mengira jumlah gandaan sehingga n; Bilangan gandaan; jumlah nombor semulajadi pertama; jumlah gandaan; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } int main ( ) { int a = 7 , N = 49 ; cout << \" Sum ▁ of ▁ multiples ▁ of ▁ \" << a << \" ▁ up ▁ to ▁ \" << N << \" ▁ = ▁ \" << calculate_sum ( a , N ) << endl ; return 0 ; }"}
{"text": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Program C ++ untuk mencari sama ada nombor adalah kuasa 2 atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace std ; using namespace boost :: multiprecision ; bool ispowerof2 ( cpp_int num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } int main ( ) { cpp_int num = 549755813888 ; cout << ispowerof2 ( num ) << endl ; return 0 ; }"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Program C ++ mudah untuk mengira pembahagi dalam pendaraban array. ; Untuk mengira bilangan faktor dalam nombor; Inisialisasi kiraan dengan 0; Kiraan kenaikan untuk setiap faktor nombor x yang diberikan. ; Pulangan bilangan faktor; Mengembalikan bilangan pembahagi dalam pendaraban array; Mengumpulkan semua elemen array yang diberikan. ; Fungsi panggilan yang mengira bilangan faktor nombor; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; } int countDivisorsMult ( int arr [ ] , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDivisorsMult ( arr , n ) << endl ; return 0 ; }"}
{"text": "Pengiraan Pembahagi Array Multiplikasi | Program C ++ untuk mengira pembahagi dalam pendaraban array. ; Buat array Boolean \"Isprime [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Isprime [i] akhirnya akan menjadi palsu jika saya bukannya Isprime, yang lain benar. ; Jika Isprime [p] tidak berubah, maka ia adalah isprime; Kemas kini semua gandaan P; Cetak semua nombor isprime; Mengembalikan bilangan pembahagi dalam pendaraban array; Cari semua nombor perdana yang lebih kecil daripada elemen terbesar. ; Cari tuduhan kejadian setiap faktor utama; Mengira kiraan semua pembahagi menggunakan kiraan faktor utama. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int largest , vector < int > & prime ) { bool isPrime [ largest + 1 ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . push_back ( p ) ; } int countDivisorsMult ( int arr [ ] , int n ) { int largest = * max_element ( arr , arr + n ) ; vector < int > prime ; SieveOfEratosthenes ( largest , prime ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; mp [ prime [ j ] ] ++ ; } } if ( arr [ i ] != 1 ) mp [ arr [ i ] ] ++ ; } long long int res = 1 ; for ( auto it : mp ) res *= ( it . second + 1L ) ; return res ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDivisorsMult ( arr , n ) << endl ; return 0 ; }"}
{"text": "K pasangan perdana jauh dalam julat yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk menjana nombor perdana dalam julat yang diberikan [l, r]; Simpan semua nilai dalam julat; Padam 1 sebagai bukan perdana; Melakukan penapis eratosthenes; Cari pelbagai semasa; Padam kerana ia bukan perdana; Kenaikan berganda; Berfungsi untuk mencetak semua pasangan utama dalam julat yang diberikan oleh k; Menjana semua nombor perdana; Melintasi peta m; Jika ia. Pertama & (ia pertama + k) adalah perdana kemudian cetak pasangan ini; Kod pemacu; Julat yang diberikan; Diberikan k; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPrimeNos ( int L , int R , unordered_map < int , int > & M ) { for ( int i = L ; i <= R ; i ++ ) { M [ i ] ++ ; } if ( M . find ( 1 ) != M . end ( ) ) { M . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . find ( i * multiple ) != M . end ( ) ) { M . erase ( i * multiple ) ; } multiple ++ ; } } } void getPrimePairs ( int L , int R , int K ) { unordered_map < int , int > M ; findPrimeNos ( L , R , M ) ; for ( auto & it : M ) { if ( M . find ( it . first + K ) != M . end ( ) ) { cout << \" ( \" << it . first << \" , ▁ \" << it . first + K << \" ) ▁ \" ; } } } int main ( ) { int L = 1 , R = 19 ; int K = 6 ; getPrimePairs ( L , R , K ) ; return 0 ; }"}
{"text": "Nombor EnneAcontahExagon | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nombor enneacontahexagon nth; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int EnneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << EnneacontahexagonNum ( n ) ; return 0 ; }"}
{"text": "Cari dua nombor komposit supaya terdapat perbezaan adalah n | C ++ kod untuk mencari dua nombor komposit supaya terdapat perbezaan adalah n; Berfungsi untuk mencari dua nombor komposit; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_composite_nos ( int n ) { cout << 9 * n << \" ▁ \" << 8 * n ; } int main ( ) { int n = 4 ; find_composite_nos ( n ) ; return 0 ; }"}
{"text": "Kira bilangan pasangan (i, j) supaya sama ada arr [i] boleh dibahagikan dengan arr [j] atau arr [j] boleh dibahagikan dengan arr [i] | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari bilangan pasangan yang tidak teratur; Elemen maksimum dari array; Array untuk menyimpan kekerapan setiap elemen; Menyimpan bilangan pasangan yang tidak teratur; Simpan kekerapan setiap elemen; Cari bilangan pasangan yang tidak teratur; Jika nombor j dibahagi dengan elemen ith hadir dalam array; Jika elemen ith array mempunyai kekerapan lebih daripada satu; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int freqPairs ( int arr [ ] , int n ) { int max = * ( std :: max_element ( arr , arr + n ) ) ; int freq [ max + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; cout << freqPairs ( arr , n ) ; return 0 ; }"}
{"text": "Cari istilah n Siri 1 + 2 + 6 + 15 + 31 + 56 + ... | Program C ++ untuk mencari istilah n siri: 1 + 2 + 6 + 15 + 31 + 56 + ...; Hitung istilah n siri yang diberikan; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; } int main ( ) { int N = 8 ; cout << Nth_Term ( N ) ; }"}
{"text": "Program untuk mencari n | Program C ++ untuk mencari nombor N dalam siri yang diperbuat daripada digit 3 dan 5; Fungsi untuk mencari nombor n - th dalam siri yang diperbuat daripada 3 dan 5; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } int main ( ) { int n = 6 ; cout << printNthElement ( n ) ; return 0 ; }"}
{"text": "Program untuk mencari istilah n Siri 3, 6, 18, 24, ... | Program CPP untuk mencari istilah siri: 3, 6, 18, 24, 45, 54. . ; fungsi untuk mengira istilah siri nth; Dengan menggunakan formula di atas; Fungsi pemacu; Dapatkan nilai n; Hitung dan cetak istilah n", "code": "#include <iostream> NEW_LINE using namespace std ; int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } int main ( ) { int N = 5 ; cout << \" Nth ▁ term ▁ for ▁ N ▁ = ▁ \" << N << \" ▁ : ▁ \" << nthTerm ( N ) ; return 0 ; }"}
{"text": "Program untuk mencetak Siri Pengembangan Binomial | Program CPP untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mencetak siri; Mengira dan mencetak istilah pertama; Pengkomputeran dan percetakan yang tersisa; Cari istilah semasa menggunakan terma sebelumnya kita meningkatkan kuasa x oleh 1, kuasa pengurangan sebanyak 1 dan mengira NCI menggunakan istilah sebelumnya dengan mengalikan istilah sebelumnya dengan (n - i + 1) / i; Fungsi utama bermula", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << \" ▁ \" ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << \" ▁ \" ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }"}
{"text": "Semak jika nombor dibahagikan dengan 8 menggunakan pengendali bitwise | Program C ++ untuk memeriksa sama ada nombor itu boleh dibahagikan dengan 8 atau tidak menggunakan pengendali Bitwise; Fungsi untuk memeriksa nombor div oleh 8 atau tidak menggunakan pengendali bitwise; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } int main ( ) { int n = 16 ; if ( Div_by_8 ( n ) ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; return 0 ; }"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Program untuk mencari purata nombor walaupun sehingga nombor yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; mengira nombor walaupun; Simpan jumlah nombor walaupun; fungsi pemacu", "code": "#include <stdio.h> NEW_LINE int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 16 ; printf ( \" % d \" , averageEven ( n ) ) ; return 0 ; }"}
{"text": "Rata -rata nombor juga sehingga nombor yang diberikan | Program untuk mencari purata nombor walaupun sehingga nend umber yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << \" Invalid ▁ Input \" ; return -1 ; } return ( n + 2 ) / 2 ; } int main ( ) { int n = 16 ; cout << averageEven ( n ) << endl ; return 0 ; }"}
{"text": "Nombor terbesar yang membahagikan x dan co | Program CPP untuk mencari pembahagi Coprime terbesar; Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; berfungsi untuk mencari pembahagi coprime terbesar; kod pembahagi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; } int main ( ) { int x = 15 ; int y = 3 ; cout << cpFact ( x , y ) << endl ; x = 14 ; y = 28 ; cout << cpFact ( x , y ) << endl ; x = 7 ; y = 3 ; cout << cpFact ( x , y ) ; return 0 ; }"}
{"text": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program CPP mudah untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << counLastDigitK ( low , high , k ) ; return 0 ; }"}
{"text": "Nombor Taxicab | C ++ pelaksanaan untuk mencetak nombor pertama N Taxicab (2) :; Bermula dari 1, periksa setiap nombor jika ia adalah Taxicab sehingga Count mencapai n. ; Cuba semua pasangan yang mungkin (j, k) yang jumlah kiubnya boleh saya. ; Taxicab (2) dijumpai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; cout << count << \" ▁ \" << i << endl ; } i ++ ; } } int main ( ) { int N = 5 ; printTaxicab2 ( N ) ; return 0 ; }"}
{"text": "Nombor Komposit | Kaedah sekolah yang dioptimumkan berdasarkan program C ++ untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } int main ( ) { isComposite ( 11 ) ? cout << \" ▁ true STRNEWLINE \" : cout << \" ▁ false STRNEWLINE \" ; isComposite ( 15 ) ? cout << \" ▁ true STRNEWLINE \" : cout << \" ▁ false STRNEWLINE \" ; return 0 ; }"}
{"text": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program C ++ untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Untuk mencari jumlah elemen array; jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int findPrime ( int n ) { int num = n + 1 ; while ( num ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; } int minNumber ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime ( sum ) ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNumber ( arr , n ) ; return 0 ; }"}
{"text": "Jumlah pembahagi faktorial nombor | Program C ++ untuk mencari jumlah pembahagi yang betul dari faktorial nombor; fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; } int main ( ) { int n = 4 ; cout << sumFactDiv ( n ) ; }"}
{"text": "Jumlah pembahagi faktorial nombor | Program C ++ untuk mencari jumlah pembahagi di N! ; AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) '' using ; Menggunakan fungsi pembahagi untuk mengira jumlah; mengembalikan jumlah pembahagi; Program pemacu untuk menjalankan kes -kes", "code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; vector < int > allPrimes ; void sieve ( int n ) { vector < bool > prime ( n + 1 , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push_back ( p ) ; } int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { int p = allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes [ i ] ; } result = result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ; } return result ; } int main ( ) { cout << factorialDivisors ( 4 ) ; return 0 ; }"}
{"text": "Nombor Pandigital dalam pangkalan yang diberikan | Program C ++ untuk memeriksa sama ada nombor adalah pandigital dalam asas yang diberikan. ; Kembali benar jika n adalah pandigit lain kembali palsu. ; Panjang pemeriksaan kurang daripada asas; Melintasi setiap digit nombor. ; Jika digit adalah integer; Jika digit adalah abjad; Memeriksa array hash, jika mana -mana indeks tidak ditandakan. ; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } int main ( ) { int b = 13 ; char n [ ] = \"1298450376ABC \" ; ( checkPandigital ( b , n ) ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; return 0 ; }"}
{"text": "Tukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan | Pelaksanaan C ++ untuk menukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan; Berfungsi untuk mencari bilangan minimum operasi yang diberikan untuk menukar m ke n; Hanya cara yang perlu dilakukan - 1 (m - n) kali; tidak mungkin; N lebih besar dan n adalah ganjil; lakukan ' - 1' pada m (atau + 1 pada n); n adalah juga; lakukan ' * 2' pada m (atau n / 2 pada n); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return -1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } int main ( ) { int m = 3 , n = 11 ; cout << \" Minimum ▁ number ▁ of ▁ operations ▁ : ▁ \" << convert ( m , n ) ; return 0 ; }"}
{"text": "Biji (atau akar benih) nombor | Program C ++ untuk mencari benih nombor; Kedai produk digit x dalam proddig [x]; Jika x mempunyai angka tunggal; Jika produk digit sudah dikira; Jika produk digit tidak dikira sebelum ini. ; Mencetak semua benih n; Cari semua biji menggunakan proddig []; Sekiranya tidak ada benih; Cetak biji; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prodDig [ MAX ] ; int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; } void findSeed ( int n ) { vector < int > res ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . push_back ( i ) ; if ( res . size ( ) == 0 ) { cout << \" NO ▁ seed ▁ exists STRNEWLINE \" ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << \" ▁ \" ; } int main ( ) { long long int n = 138 ; findSeed ( n ) ; return 0 ; }"}
{"text": "Nombor dengan bilangan maksimum faktor utama | Program C ++ untuk mencari integer yang mempunyai bilangan maksimum faktor utama dalam nombor semulajadi n pertama. ; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama. ; Mencari nombor yang mempunyai jumlah maksimum faktor utama. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { int arr [ N + 5 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }"}
{"text": "Jumlah semua subarray | Tetapkan 1 | Program C ++ yang cekap untuk mengira jumlah elemen subarray; fungsi mengira jumlah semua sub - array; jumlah pengkomputeran subarray menggunakan formula; kembali semua jumlah subarray; program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Sum ▁ of ▁ SubArray ▁ : ▁ \" << SubArraySum ( arr , n ) << endl ; return 0 ; }"}
{"text": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program C ++ untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Jika saya adalah kuasa 2; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }"}
{"text": "Cari Pasangan Cube | Tetapkan 2 (A N ^ (1/3) Penyelesaian) | Program C ++ untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat pelbagai saiz saiz 'cuberoot'; Untuk indeks i, kiub [i] akan mengandungi i ^ 3; Cari semua pasangan di atas Array Cube di atas [] yang jumlahnya sama dengan N; Fungsi pemacu", "code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; int cube [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { cout << \" ( \" << l << \" , ▁ \" << r << \" ) \" << endl ; l ++ ; r -- ; } } } int main ( ) { int n = 20683 ; findPairs ( n ) ; return 0 ; }"}
{"text": "Cari Pasangan Cube | Tetapkan 1 (A N ^ (2/3) Penyelesaian) | Program C ++ untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat peta kosong; Pertimbangkan semua pasangan seperti nilai kurang daripada cuberoot; Cari jumlah pasangan semasa (x, y); Jangan lakukan apa -apa jika jumlah tidak sama dengan nombor yang diberikan; Jika jumlahnya dilihat sebelum ini, kami mendapati dua pasang; Jika jumlahnya dilihat buat kali pertama; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; unordered_map < int , pair < int , int > > s ; for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) { int sum = x * x * x + y * y * y ; if ( sum != n ) continue ; if ( s . find ( sum ) != s . end ( ) ) { cout << \" ( \" << s [ sum ] . first << \" , ▁ \" << s [ sum ] . second << \" ) ▁ and ▁ ( \" << x << \" , ▁ \" << y << \" ) \" << endl ; } else s [ sum ] = make_pair ( x , y ) ; } } } int main ( ) { int n = 13832 ; findPairs ( n ) ; return 0 ; }"}
{"text": "Cari perbezaan minimum antara jadual beralih dua nombor | Program C ++ untuk mencari perbezaan minimum antara dua syarat dua jadual; Fungsi utiliti untuk mencari GCD A dan B; Mengembalikan perbezaan minimum antara dua terma jadual beralih 'A' dan 'B'. 'X' adalah peralihan dalam jadual 'a' dan 'y' adalah peralihan dalam jadual 'b'. ; Hitung GCD Nd B; Kirakan perbezaan antara x dan y; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = abs ( x - y ) % g ; return min ( diff , g - diff ) ; } int main ( ) { int a = 20 , b = 52 , x = 5 , y = 7 ; cout << findMinDiff ( a , b , x , y ) << endl ; return 0 ; }"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; berfungsi untuk mencetak pembahagi; Vektor untuk menyimpan separuh daripada pembahagi; Semak jika pembahagi adalah sama; Tolak pembahagi kedua dalam vektor; Vektor akan dicetak secara terbalik; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( \" % d ▁ \" , i ) ; else { printf ( \" % d ▁ \" , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( \" % d ▁ \" , v [ i ] ) ; } int main ( ) { printf ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ n \" ) ; printDivisors ( 100 ) ; return 0 ; }"}
{"text": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; Berfungsi untuk mencetak pembahagi; Kod pemacu", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) cout << i << \" ▁ \" ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) cout << n / i << \" ▁ \" ; } } int main ( ) { cout << \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; return 0 ; }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | C ++ pelaksanaan kaedah naif untuk mencetak semua pembahagi; berfungsi untuk mencetak pembahagi; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << \" ▁ \" << i ; } int main ( ) { cout << \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; return 0 ; }"}
{"text": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Penyelesaian yang lebih baik (daripada naif) untuk mencari semua divisior; Berfungsi untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; lain sebaliknya mencetak kedua -duanya; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << \" ▁ \" << i ; cout << \" ▁ \" << i << \" ▁ \" << n / i ; } } } int main ( ) { cout << \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; return 0 ; }"}
{"text": "Sieve of Atkin | Program C ++ untuk pelaksanaan SIEVE OF ATKIN; 2 dan 3 dikenali sebagai Perdana; Memulakan array penapis dengan nilai palsu; Mark Sieve [n] adalah benar jika salah satu daripada yang berikut adalah benar: a) n = (4 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil, i. e. , terdapat bilangan pasangan yang berbeza (x, y) yang memenuhi persamaan dan n % 12 = 1 atau n % 12 = 5. b) n = (3 * x * x) + (y * y) Bahagian utama SIEVE OF ATKIN; Tandakan semua gandaan dataran sebagai bukan perdana; Cetak prima menggunakan ayak []; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << \" ▁ \" ; if ( limit > 3 ) cout << 3 << \" ▁ \" ; bool sieve [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) cout << a << \" ▁ \" ; } int main ( void ) { int limit = 20 ; SieveOfAtkin ( limit ) ; return 0 ; }"}
{"text": "Cari jika titik terletak di dalam bulatan | Program C ++ untuk memeriksa sama ada titik terletak di dalam bulatan atau tidak; Bandingkan jejari bulatan dengan jarak pusatnya dari titik yang diberikan; Fungsi pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } int main ( ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; isInside ( circle_x , circle_y , rad , x , y ) ? cout << \" Inside \" : cout << \" Outside \" ; }"}
{"text": "Cari semua kemungkinan hasil ekspresi yang diberikan | Program C ++ untuk menilai semua nilai ekspresi yang mungkin; Fungsi utiliti untuk menilai ungkapan mudah dengan satu pengendali sahaja. ; Fungsi ini menilai semua nilai yang mungkin dan mengembalikan senarai nilai yang dinilai. ; Untuk menyimpan hasil (semua kemungkinan penilaian ekspresi 'expr'); Sekiranya terdapat hanya satu watak, ia mestilah digit (atau operan), kembalikannya. ; Sekiranya terdapat hanya tiga aksara, pertengahan mestilah pengendali dan sudut mesti beroperasi; Setiap saya merujuk kepada pengendali; l merujuk kepada semua nilai yang mungkin di sebelah kiri pengendali 'expr [i]'; r merujuk kepada semua nilai yang mungkin di sebelah kanan pengendali 'expr [i]'; Ambil di atas menilai semua nilai yang mungkin di sebelah kiri 'I'; Ambil di atas menilai semua nilai yang mungkin di sebelah kanan 'I'; Kirakan nilai untuk setiap pasangan dan tambahkan nilai yang dihasilkan. ; Program Pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int eval ( int a , char op , int b ) { if ( op == ' + ' ) return a + b ; if ( op == ' - ' ) return a - b ; if ( op == ' * ' ) return a * b ; } vector < int > evaluateAll ( string expr , int low , int high ) { vector < int > res ; if ( low == high ) { res . push_back ( expr [ low ] - '0' ) ; return res ; } if ( low == ( high - 2 ) ) { int num = eval ( expr [ low ] - '0' , expr [ low + 1 ] , expr [ low + 2 ] - '0' ) ; res . push_back ( num ) ; return res ; } for ( int i = low + 1 ; i <= high ; i += 2 ) { vector < int > l = evaluateAll ( expr , low , i - 1 ) ; vector < int > r = evaluateAll ( expr , i + 1 , high ) ; for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) { for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) { int val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) ; res . push_back ( val ) ; } } } return res ; } int main ( ) { string expr = \"1*2 + 3*4\" ; int len = expr . length ( ) ; vector < int > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << endl ; return 0 ; }"}
{"text": "Program untuk memeriksa sama ada nombor tertentu bernasib baik (semua digit adalah berbeza) | Program C ++ untuk memeriksa sama ada nombor tertentu bernasib baik; Fungsi ini kembali benar jika n bernasib baik; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Program pemacu untuk menguji fungsi di atas.", "code": "#include <iostream> NEW_LINE using namespace std ; bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } int main ( ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) isLucky ( arr [ i ] ) ? cout << arr [ i ] << \" ▁ is ▁ Lucky ▁ STRNEWLINE \" : cout << arr [ i ] << \" ▁ is ▁ not ▁ Lucky ▁ STRNEWLINE \" ; return 0 ; }"}
{"text": "Cetak kotak pertama N Nombor Semulajadi tanpa menggunakan *, / dan | Program C ++ untuk mencetak dataran nombor pertama 'n' Nombor semulajadi menggunakan *, / dan -; Memulakan 'persegi' dan nombor ganjil pertama; Mengira dan mencetak kotak; Cetak dataran; Kemas kini 'persegi' dan 'ganjil'; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << \" ▁ \" ; square = square + odd ; odd = odd + 2 ; } } int main ( ) { int n = 5 ; printSquares ( n ) ; }"}
{"text": "Tulis program untuk membalikkan digit nombor | Program C ++ untuk membalikkan digit nombor; Fungsi rekursif untuk membalikkan digit NUM; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } int main ( ) { int num = 4562 ; cout << \" Reverse ▁ of ▁ no . ▁ is ▁ \" << reversDigits ( num ) ; return 0 ; }"}
{"text": "Cari nombor sedemikian rupa sehingga maksimum dalam array adalah minimum mungkin selepas xor | Program C ++ yang mendapati maksimum maksimum minimum; Fungsi rekursif yang mencari nilai minimum selepas eksklusif - atau; Keadaan jika saiz ref adalah sifar atau bit adalah negatif maka kembali 0; Keadaan jika bit semasa dimatikan kemudian tolak nilai semasa dalam vektor curr_off; Keadaan jika bit semasa berada di kemudian tolak nilai semasa dalam vektor curr_on; Keadaan jika curr_off kosong maka hubungi fungsi rekursif pada vektor curr_on; Keadaan jika curr_on kosong maka hubungi fungsi rekursif pada vektor curr_off; Kembalikan minimum curr_off dan curr_on dan tambah kuasa 2 bit semasa; Fungsi yang mencetak nilai minimum selepas eksklusif - atau; Menolak nilai dalam vektor; Jawapan percetakan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int RecursiveFunction ( vector < int > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; vector < int > curr_on , curr_off ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) curr_off . push_back ( ref [ i ] ) ; else curr_on . push_back ( ref [ i ] ) ; } if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; } void PrintMinimum ( int a [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) v . push_back ( a [ i ] ) ; cout << RecursiveFunction ( v , 30 ) << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; PrintMinimum ( arr , size ) ; return 0 ; }"}
{"text": "Count of Elements yang sama dengan XOR dari dua elemen berikutnya | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan elemen yang sama dengan XOR dari dua elemen berikutnya; Untuk menyimpan kiraan yang diperlukan; Untuk setiap elemen array supaya ia mempunyai sekurang -kurangnya dua elemen yang muncul selepas itu dalam array; Jika elemen semasa adalah sama dengan XOR dari dua elemen seterusnya dalam array; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntElements ( arr , n ) ; return 0 ; }"}
{"text": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | Program C ++ yang mudah untuk mencari bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama; Berfungsi untuk mengembalikan kiraan; Hasil permulaan; Pilih unsur 1 triplet; Pilih elemen 2 nd triplet; Pilih 3 elemen triplet; Mengambil XOR dalam subarray pertama; Mengambil XOR dalam subarray kedua; Jika kedua -dua XOR adalah sama; Kod pemacu; Fungsi panggilan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xor_triplet ( arr , n ) ; return 0 ; }"}
{"text": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | C ++ trie berasaskan program untuk mencari bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama; bilangan maksimum bit dalam integer <= 1E9; Struktur nod trie; [0] Indeks adalah bit 0 dan [1] indeks adalah bit 1; Jumlah indeks yang dimasukkan pada nod; Bilangan indeks yang dimasukkan pada nod; Pembina untuk memulakan nod yang baru dibuat; Berfungsi untuk memasukkan curr_xor ke dalam trie; Melangkah dari bit 31 ke bit ke -0 bit curr_xor; Semak sama ada bit semasa ditetapkan atau tidak; Sekiranya nod ini tidak ada dalam struktur trie masukkannya ke dalam trie. ; Meningkatkan jumlah indeks dengan nilai indeks semasa; Meningkatkan bilangan indeks sebanyak 1; Fungsi untuk memeriksa sama ada curr_xor hadir dalam trie atau tidak; Melangkah dari bit 31 ke bit ke -0 bit curr_xor; Semak sama ada bit semasa ditetapkan atau tidak; Sekiranya nod ini tidak ada dalam struktur trie yang bermaksud tidak ada sub array sehingga indeks semasa mempunyai 0 xor jadi pulangan 0; Kirakan bilangan indeks yang dimasukkan pada nod akhir; Kirakan jumlah indeks yang dimasukkan pada nod akhir; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang sah; Untuk menyimpan XOR kumulatif; Akar trie; Masukkan curr_xor dalam trie; Kemas kini XOR kumulatif; Semak sama ada XOR kumulatif hadir dalam trie atau tidak jika hadir kemudian tambah (SZ * index) - jumlah; Kod pemacu; Diberikan array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lg  31 NEW_LINE struct TrieNode { TrieNode * children [ 2 ] ; int sum_of_indexes ; int number_of_indexes ; TrieNode ( ) { this -> children [ 0 ] = nullptr ; this -> children [ 1 ] = nullptr ; this -> sum_of_indexes = 0 ; this -> number_of_indexes = 0 ; } } ; void insert ( TrieNode * node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node -> children [ curr_bit ] == nullptr ) { node -> children [ curr_bit ] = new TrieNode ( ) ; } node = node -> children [ curr_bit ] ; } node -> sum_of_indexes += index ; node -> number_of_indexes ++ ; } int query ( TrieNode * node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node -> children [ curr_bit ] == nullptr ) { return 0 ; } node = node -> children [ curr_bit ] ; } int sz = node -> number_of_indexes ; int sum = node -> sum_of_indexes ; int ans = ( sz * index ) - ( sum ) ; return ans ; } int no_of_triplets ( int arr [ ] , int n ) { int curr_xor = 0 ; int number_of_triplets = 0 ; TrieNode * root = new TrieNode ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; insert ( root , curr_xor , i ) ; curr_xor ^= x ; number_of_triplets += query ( root , curr_xor , i ) ; } return number_of_triplets ; } int main ( ) { int arr [ ] = { 5 , 2 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << no_of_triplets ( arr , n ) ; return 0 ; }"}
{"text": "Cari bilangan sepasang nod yang ideal di pokok tertentu | C ++ pelaksanaan pendekatan; Senarai Adjacency; Bit: Bit Array I dan J memulakan dan menamatkan indeks termasuk; bit: array bit n: saiz array bit i adalah indeks yang akan dikemas kini diff adalah (new_val - old_val); Fungsi DFS untuk mencari pasangan yang ideal; Fungsi untuk inisialisasi; Berfungsi untuk menambah kelebihan; Berfungsi untuk mencari bilangan pasangan yang ideal; Cari akar pokok; Kod pemacu; Tambah tepi; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int n , k ; vector < int > al [ N ] ; long long Ideal_pair ; long long bit [ N ] ; bool root_node [ N ] ; long long bit_q ( int i , int j ) { long long sum = 0ll ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * -1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * -1 ) ) ; } return sum ; } void bit_up ( int i , long long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } } void dfs ( int node ) { Ideal_pair += bit_q ( max ( 1 , node - k ) , min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( int i = 0 ; i < al [ node ] . size ( ) ; i ++ ) dfs ( al [ node ] [ i ] ) ; bit_up ( node , -1 ) ; } void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0LL ; } } void Add_Edge ( int x , int y ) { al [ x ] . push_back ( y ) ; root_node [ y ] = false ; } long long Idealpairs ( ) { int r = -1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; } int main ( ) { n = 6 , k = 3 ; initialise ( ) ; Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ; cout << Idealpairs ( ) ; return 0 ; }"}
{"text": "Cetak bitwise dan set nombor n | Program CPP untuk mencetak semua subset bitwise N (pendekatan yang cekap); berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << \" ▁ \" ; cout << 0 ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }"}
{"text": "Semak jika nombor dibahagikan dengan 17 menggunakan pengendali bitwise | Program CPP untuk memeriksa sama ada nombor dibahagikan dengan 17 atau tidak menggunakan pengendali Bitwise. ; fungsi untuk memeriksa secara rekursif jika nombor itu boleh dibahagikan dengan 17 atau tidak; jika n = 0 atau n = 17 maka ya; jika n kurang dari 17, tidak boleh dibahagikan dengan 17; mengurangkan nombor mengikut lantai (n / 16) - n % 16; kod pemacu untuk memeriksa fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } int main ( ) { int n = 35 ; if ( isDivisibleby17 ( n ) ) cout << n << \" ▁ is ▁ divisible ▁ by ▁ 17\" ; else cout << n << \" ▁ is ▁ not ▁ divisible ▁ by ▁ 17\" ; return 0 ; }"}
{"text": "Nombor terbesar dengan perwakilan binari ialah M 1 dan M | Program CPP untuk mencari bilangan terbesar yang lebih kecil daripada sama dengan n dengan m set bit kemudian m - 1 0 bit. ; Mengembalikan nombor terbesar dengan bit set M kemudian m - 1 0 bit. ; Mulakan dengan 2 bit. ; Jawapan awal adalah 1 yang memenuhi syarat yang diberikan; Semak semua nombor; mengira nombor; jika kurang kemudian n; kenaikan m untuk mendapatkan nombor seterusnya; kod pemacu untuk memeriksa keadaan di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } int main ( ) { long long n = 7 ; cout << answer ( n ) ; return 0 ; }"}
{"text": "Cari bit set yang paling ketara | Program CPP mudah untuk mencari nombor MSB untuk diberikan n. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; } int main ( ) { int n = 0 ; cout << setBitNumber ( n ) ; return 0 ; }"}
{"text": "Cari bit set yang paling ketara | Program CPP untuk mencari nombor MSB untuk diberikan n. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Kenaikan n oleh 1 supaya hanya ada satu set bit yang hanya sebelum MSB asal. n kini menjadi 1000000000; Kembalikan MSB asal selepas beralih. n kini menjadi 100000000; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; }"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod C ++ mudah untuk mengira sifar trailing dalam perwakilan binari nombor; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } int main ( ) { cout << countTrailingZero ( 11 ) << endl ; return 0 ; }"}
{"text": "Count Trailing Zero Bits Menggunakan Table Lookup | C ++ kod untuk mengira sifar trailing dalam perwakilan binari nombor; Peta sedikit nilai mod 37 ke kedudukannya; Hanya perbezaan antara (x dan - x) ialah nilai magnitud yang ditandatangani (leftmostbit) nombor negatif yang ditandatangani adalah 1; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; } int main ( ) { cout << countTrailingZero ( 48 ) << endl ; return 0 ; }"}
{"text": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program C ++ untuk menilai Ceil (7 n / 8) tanpa menggunakan * dan /; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<'; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { int n = 9 ; cout << multiplyBySevenByEight ( n ) ; return 0 ; }"}
{"text": "Set nombor palindrome terpanjang dari julat [l, r] dengan kebanyakan perbezaan k antara maksimum dan minimum | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari indeks paling kanan nombor yang diberikan; Simpan indeks paling kanan; Hitung pertengahan; Jika diberi nombor <= num; Berikan Ans = Mid; Mengemas kini rendah; Mengemas kini tinggi; kembali Ans; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah palindrome atau tidak; Menjana terbalik nombor yang diberikan; Jika n adalah palindrome; Berfungsi untuk mencari saiz maksimum kumpulan nombor palindrome yang mempunyai perbezaan antara elemen maksimum dan minimum paling banyak k; Menyimpan semua nombor palindromik dalam julat [l, r]; Melintasi julat [l, r]; Jika saya adalah palindrome; Tambah nombor dalam senarai; Kedai kiraan nombor palindromik maksimum; Melelehkan setiap elemen dalam senarai; Kirakan indeks paling kanan dalam senarai <elemen semasa + k; Semak jika terdapat indeks paling kanan dari indeks semasa; Mengembalikan kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; static int search ( vector < int > list , int num ) { int low = 0 , high = list . size ( ) - 1 ; int ans = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } bool isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; } int countNumbers ( int L , int R , int K ) { vector < int > list ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . push_back ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != -1 ) count = max ( count , right_index - i + 1 ) ; } return count ; } int main ( ) { int L = 98 , R = 112 ; int K = 13 ; cout << countNumbers ( L , R , K ) ; }"}
{"text": "Memaksimumkan jumlah yang mungkin dengan menolak nilai yang sama dari semua elemen subarray array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menjana elemen yang lebih kecil sebelumnya untuk setiap elemen array; Unsur pertama tidak mempunyai lebih kecil sebelumnya; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku sebelum ini; Tolak indeks pertama; Pop semua elemen sehingga elemen sebelumnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil sebelumnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk menjana elemen yang lebih kecil seterusnya untuk setiap elemen array; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku seterusnya; Melangkah dalam urutan terbalik untuk mengira lebih kecil seterusnya; Pop semua elemen sehingga elemen seterusnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil seterusnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk mencari jumlah maksimum dengan menolak nilai yang sama dari semua elemen subarray; Kedai elemen yang lebih kecil sebelumnya; Kedai elemen yang lebih kecil seterusnya; Mengira sumbangan setiap elemen; Jawapan kembali; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findPrevious ( vector < int > a , int n ) { vector < int > ps ( n ) ; ps [ 0 ] = -1 ; stack < int > Stack ; Stack . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ps [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : -1 ; Stack . push ( i ) ; } return ps ; } vector < int > findNext ( vector < int > a , int n ) { vector < int > ns ( n ) ; ns [ n - 1 ] = n ; stack < int > Stack ; Stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ns [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : n ; Stack . push ( i ) ; } return ns ; } int findMaximumSum ( vector < int > a , int n ) { vector < int > prev_smaller = findPrevious ( a , n ) ; vector < int > next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } int main ( ) { int n = 3 ; vector < int > a { 80 , 48 , 82 } ; cout << findMaximumSum ( a , n ) ; return 0 ; }"}
{"text": "Semak jika rentetan yang diberikan disalurkan substring rentetan lain | Fungsi ini kembali benar jika kandungan ARR1 [] dan ARR2 [] sama, jika tidak palsu. ; Fungsi ini mencari semua permutasi pat [] dalam txt []; Countp []: Simpan kiraan semua aksara corak counttw []: kiraan kiraan tetingkap semasa teks; Melintasi watak corak yang tersisa; Bandingkan tuduhan tetingkap semasa teks dengan tuduhan corak []; Tambah aksara semasa ke tetingkap semasa; Keluarkan watak pertama tetingkap sebelumnya; Periksa tetingkap terakhir dalam teks; Program pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE #include <cstring> NEW_LINE #define MAX  256 NEW_LINE using namespace std ; bool compare ( char arr1 [ ] , char arr2 [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } bool search ( char * pat , char * txt ) { int M = strlen ( pat ) , N = strlen ( txt ) ; char countP [ MAX ] = { 0 } , countTW [ MAX ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] ] ) ++ ; ( countTW [ txt [ i ] ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) return true ; ( countTW [ txt [ i ] ] ) ++ ; countTW [ txt [ i - M ] ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; } int main ( ) { char txt [ ] = \" BACDGABCDA \" ; char pat [ ] = \" ABCD \" ; if ( search ( pat , txt ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Memaksimumkan median array yang diberikan selepas menambahkan elemen K ke array yang sama | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan median yang dimaksimumkan; Susun array; Jika saiznya juga; Jika saiz ganjil; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << getMaxMedian ( arr , n , k ) ; return 0 ; }"}
{"text": "Susun 3 Integer Tanpa Menggunakan Keadaan atau Menggunakan Hanya Maksimum () Fungsi | Program C ++ untuk mencetak tiga nombor dalam susunan yang disusun menggunakan fungsi max; Cari elemen maksimum; Cari elemen minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << \" ▁ \" << get_mid << \" ▁ \" << get_max ; } int main ( ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; return 0 ; }"}
{"text": "Jenis penyisipan binari | pelaksanaan berulang; Berfungsi untuk menyusun array [] saiz 'n'; Cari lokasi di mana dipilih haruslah inseretd; Gerakkan semua elemen selepas lokasi untuk mewujudkan ruang; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } int main ( ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) , i ; insertionSort ( a , n ) ; cout << \" Sorted ▁ array : ▁ STRNEWLINE \" ; for ( i = 0 ; i < n ; i ++ ) cout << \" ▁ \" << a [ i ] ; return 0 ; }"}
{"text": "SENARAI SENSI | Program C ++ untuk jenis penyisipan; Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSort ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }"}
{"text": "Count Permutasi yang berbeza dari rentetan yang diperoleh dengan menukar hanya aksara yang tidak sama rata | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah bilangan permutasi yang sah; Mewujudkan kiraan yang sama dengan jumlah aksara yang hadir dan ANS yang akan menyimpan bilangan permutasi yang unik; Menyimpan kekerapan setiap watak yang ada dalam rentetan; Menambah kiraan aksara dengan tidak termasuk aksara sama dengan char semasa; Kurangkan kekerapan aksara semasa dan dikira sebanyak 1, supaya ia tidak dapat mengganggu pengiraan unsur -unsur yang sama ada di sebelah kanannya. ; Kembali Ans + 1 (kerana rentetan yang diberikan juga merupakan permutasi yang unik); Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int validPermutations ( string str ) { unordered_map < char , int > m ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m [ str [ i ] ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m [ str [ i ] ] ; m [ str [ i ] ] -- ; count -- ; } return ans + 1 ; } int main ( ) { string str = \" sstt \" ; cout << validPermutations ( str ) ; return 0 ; }"}
{"text": "Mengira laluan dari titik untuk mencapai asal | Program C ++ untuk mengira jumlah laluan dari titik ke asal; Fungsi berasaskan DP untuk mengira bilangan laluan; Isi penyertaan dalam Bottommost Row dan lajur paling kiri; Isi DP dengan cara bawah; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 2 ; cout << \" ▁ Number ▁ of ▁ Paths ▁ \" << countPaths ( n , m ) ; return 0 ; }"}
{"text": "Perubahan duit syiling | DP | Program C ++ Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" ▁ \" << count ( arr , m , 4 ) ; return 0 ; }"}
{"text": "Perubahan duit syiling | DP | Sama ada memilih duit syiling ini atau tidak; lain kita tidak mempunyai pilihan tetapi meninggalkan duit syiling ini; cin >> tc;", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int coinchange ( vector < int > & a , int v , int n , vector < vector < int > > & dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != -1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) { return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; } return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; } int32_t main ( ) { int tc = 1 ; while ( tc -- ) { int n , v ; n = 3 , v = 4 ; vector < int > a = { 1 , 2 , 3 } ; vector < vector < int > > dp ( n + 1 , vector < int > ( v + 1 , -1 ) ) ; int res = coinchange ( a , v , n , dp ) ; cout << res << endl ; } }"}
{"text": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf besar menggunakan fungsi transform () dan :: toupper di STL; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; transform ( str1 . begin ( ) , str1 . end ( ) , str1 . begin ( ) , :: toupper ) ; transform ( str2 . begin ( ) , str2 . end ( ) , str2 . begin ( ) , :: toupper ) ; int x = str1 . compare ( str2 ) ; if ( x != 0 ) return false ; else return true ; } void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << \" Same \" << endl ; else cout << \" Not ▁ Same \" << endl ; } int main ( ) { string str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; return 0 ; }"}
{"text": "Gantikan setiap urutan konsonan dengan panjangnya dalam rentetan yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang ditukar selepas menggantikan setiap urutan konsonan dengan panjangnya; Untuk menyimpan rentetan yang dihasilkan; Memeriksa setiap watak untuk urutan konsonan; Hitung panjang urutan konsonan; Tambah panjang dalam rentetan; Tambah vokal; Semak urutan konsonan terakhir dalam rentetan; Kembali rentetan yang dihasilkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string replaceConsonants ( string str ) { string res = \" \" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += to_string ( count ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += to_string ( count ) ; return res ; } int main ( ) { string str = \" abcdeiop \" ; cout << replaceConsonants ( str ) ; return 0 ; }"}
{"text": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | Program CPP untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam setiap substring saiz K; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan dtring; untuk setiap substring; substring saiz k; mengira bilangan vokal dan konsonan; tambah produk untuk dijawab. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string encryptString ( string s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; string ans = \" \" ; for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s [ r ] ) == true ) countVowels ++ ; else countConsonants ++ ; } ans += to_string ( countVowels * countConsonants ) ; } return ans ; } int main ( ) { string s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; cout << encryptString ( s , n , k ) << endl ; return 0 ; }"}
{"text": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | C ++ pelaksanaan pendekatan di atas; Kami memisahkan input berdasarkan ruang (s) +: ungkapan biasa ini akan mengendalikan senario di mana kami mempunyai kata -kata yang dipisahkan oleh pelbagai ruang; Charat (0) hanya akan memilih watak pertama dari rentetan dan tambahan ke penampan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string processWords ( char * input ) { char * p ; vector < string > s ; p = strtok ( input , \" ▁ \" ) ; while ( p != NULL ) { s . push_back ( p ) ; p = strtok ( NULL , \" ▁ \" ) ; } string charBuffer ; for ( string values : s ) charBuffer += values [ 0 ] ; return charBuffer ; } int main ( ) { char input [ ] = \" geeks ▁ for ▁ geeks \" ; cout << processWords ( input ) ; return 0 ; }"}
{"text": "Menjana semua rentetan binari tanpa berturut -turut 1 's | Program C ++ untuk menjana semua rentetan binari tanpa saiz Kekekulasi 1 K; Fungsi utiliti menjana semua rentetan tanpa berturut -turut 1 'sof saiz k; Cetak rentetan binari tanpa berturut -turut 1 's; Menamatkan rentetan binari; Jika watak sebelumnya adalah '1' maka kami hanya meletakkan 0 pada akhir rentetan contoh str = \"01\" maka rentetan baru menjadi \"010\"; Jika watak sebelumnya adalah '0' daripada kami meletakkan kedua -dua '1' dan '0' pada akhir rentetan contoh str = \"00\" kemudian rentetan baru \"001\" dan \"000\"; Fungsi menjana semua rentetan binari tanpa berturut -turut 1; Kes asas; Satu demi satu kedai setiap rentetan panjang binari k; Menjana semua rentetan binari bermula dengan '0'; Menjana semua rentetan binari bermula dengan '1'; Program pemacu untuk menguji fungsi di atas", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateAllStringsUtil ( int K , char str [ ] , int n ) { if ( n == K ) { str [ n ] = ' \\0' ; cout << str << \" ▁ \" ; return ; } if ( str [ n - 1 ] == '1' ) { str [ n ] = '0' ; generateAllStringsUtil ( K , str , n + 1 ) ; } if ( str [ n - 1 ] == '0' ) { str [ n ] = '0' ; generateAllStringsUtil ( K , str , n + 1 ) ; str [ n ] = '1' ; generateAllStringsUtil ( K , str , n + 1 ) ; } } void generateAllStrings ( int K ) { if ( K <= 0 ) return ; char str [ K ] ; str [ 0 ] = '0' ; generateAllStringsUtil ( K , str , 1 ) ; str [ 0 ] = '1' ; generateAllStringsUtil ( K , str , 1 ) ; } int main ( ) { int K = 3 ; generateAllStrings ( K ) ; return 0 ; }"}
{"text": "Silinder bulat kanan terbesar dalam kiub | Program C ++ untuk mencari silinder bulat kanan terbesar yang boleh sesuai dalam kiub; Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << findVolume ( a ) << endl ; return 0 ; }"}
{"text": "Program untuk jumlah piramid | Program CPP untuk mencari kelantangan. ; Berfungsi untuk mencari jumlah piramid segi tiga; Berfungsi untuk mencari jumlah piramid persegi; Berfungsi untuk mencari jumlah piramid pentagonal; Berfungsi untuk mencari jumlah piramid heksagon; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float volumeTriangular ( int a , int b , int h ) { float vol = ( 0.1666 ) * a * b * h ; return vol ; } float volumeSquare ( int b , int h ) { float vol = ( 0.33 ) * b * b * h ; return vol ; } float volumePentagonal ( int a , int b , int h ) { float vol = ( 0.83 ) * a * b * h ; return vol ; } float volumeHexagonal ( int a , int b , int h ) { float vol = a * b * h ; return vol ; } int main ( ) { int b = 4 , h = 9 , a = 4 ; cout << \" Volume ▁ of ▁ triangular \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumeTriangular ( a , b , h ) << endl ; cout << \" Volume ▁ of ▁ square ▁ \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumeSquare ( b , h ) << endl ; cout << \" Volume ▁ of ▁ pentagonal \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumePentagonal ( a , b , h ) << endl ; cout << \" Volume ▁ of ▁ Hexagonal \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumeHexagonal ( a , b , h ) ; return 0 ; }"}
{"text": "Program untuk mencari kawasan trapezoid | Program C ++ untuk mengira kawasan trapezoid; Fungsi untuk kawasan tersebut; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } int main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; cout << \" Area ▁ is : ▁ \" << area ; return 0 ; }"}
{"text": "Cari bilangan pepenjuru dalam polygon cembung N sisi | C ++ Fungsi untuk mencari bilangan pepenjuru dalam poligon cembung N); kod pemacu untuk menguji fungsi di atas", "code": "#include <iostream> NEW_LINE using namespace std ; int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; } int main ( ) { int n = 5 ; cout << n << \" ▁ sided ▁ convex ▁ polygon ▁ have ▁ \" ; cout << numberOfDiagonals ( n ) << \" ▁ diagonals \" ; return 0 ; }"}
{"text": "Kawasan segi empat tepat terbesar tanpa titik tertentu | C ++ pelaksanaan untuk mencari kawasan segi empat tepat terbesar tanpa lubang dalam segi empat tepat; Berfungsi untuk mencari kawasan maksimum supaya ia tidak mengandungi sebarang lubang; Kawasan untuk semua kedudukan yang mungkin dipotong; Cari kawasan maksimum di antara segi empat tepat di atas; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; cout << max ( max ( left , right ) , max ( above , below ) ) ; } int main ( ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( l , b , x , y ) ; return 0 ; }"}
{"text": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Simpan kos minimum yang diperlukan; Buat kamus untuk menyimpan kos maksimum penyingkiran watak; Buat kamus untuk menyimpan jumlah kos penghapusan watak; Melintasi rentetan, s; Jejaki kos maksimum setiap watak; Mengemas kini kos penghapusan maksimum; Jejaki jumlah kos setiap watak; Mengemas kini jumlah kos penghapusan; Melintasi semua watak yang unik; Simpan watak kos maksimum dan padamkan selebihnya; Kembalikan jawapannya; Kod pemacu; Diberikan rentetan; Diberikan pelbagai kos; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int delCost ( string s , int cost [ ] ) { int ans = 0 ; map < char , int > forMax ; map < char , int > forTot ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax [ s [ i ] ] ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot [ s [ i ] ] ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] = forTot [ s [ i ] ] + cost [ i ] ; } } for ( auto i : forMax ) { ans += forTot [ i . first ] - i . second ; } return ans ; } int main ( ) { string s = \" AAABBB \" ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; cout << ( delCost ( s , cost ) ) ; }"}
{"text": "Pembahagi terkecil n paling dekat dengan x | Program C ++ untuk pendekatan di atas; Tentukan makro; Kedai pembahagi untuk semua nombor dalam pembahagi vektor; Saya adalah pembahagi dan j adalah pelbagai; Fungsi untuk membandingkan kedekatan sasaran yang diberikan; Berfungsi untuk mencari elemen yang paling dekat dengan sasaran dalam vektor pembahagi; Kes sudut; Melakukan carian binari; Semak sama ada sasaran kurang daripada elemen array kemudian cari di separuh kiri; Semak sama ada sasaran lebih besar daripada sebelumnya hingga pertengahan, kembali paling dekat dengan dua; Ulangi separuh kiri; Semak sama ada sasaran lebih besar daripada pertengahan; Kemas kini i; Hanya elemen tunggal yang tersisa selepas carian; Berfungsi untuk mencetak pembahagi n paling dekat dengan x; Fungsi panggilan untuk mengira dan menyimpan pembahagi semua nombor dalam vektor; Menyimpan nilai terdekat untuk sasaran; Cetak jawapannya; Kod pemacu; Diberikan N & X; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE vector < vector < int > > divisors ( MAX + 1 ) ; void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . push_back ( i ) ; } } } int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } int findClosest ( vector < int > & arr , int n , int target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ; cout << ans ; } int main ( ) { int N = 16 , X = 5 ; printClosest ( N , X ) ; }"}
{"text": "Mengira elemen nilai yang sama diletakkan pada indeks yang sama dengan dua array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira elemen yang dipadankan maksimum dari array A [] dan B []; Kedai kedudukan unsur -unsur array a [] dalam array b []; Jejaki perbezaan antara indeks; Melintasi array a []; Melintasi array b []; Jika perbezaan negatif, tambahkan n kepadanya; Jejaki bilangan peralihan yang diperlukan untuk meletakkan elemen pada indeks yang sama; Mengembalikan perlawanan maksimum; Kod pemacu; Mengembalikan kiraan elemen yang dipadankan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMatch ( int A [ ] , int B [ ] , int M , int N ) { map < int , int > Aindex ; map < int , int > diff ; for ( int i = 0 ; i < M ; i ++ ) { Aindex [ A [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i - Aindex [ B [ i ] ] < 0 ) { diff [ M + i - Aindex [ B [ i ] ] ] += 1 ; } else { diff [ i - Aindex [ B [ i ] ] ] += 1 ; } } int max = 0 ; for ( auto ele = diff . begin ( ) ; ele != diff . end ( ) ; ele ++ ) { if ( ele -> second > max ) { max = ele -> second ; } } return max ; } int main ( ) { int A [ ] = { 5 , 3 , 7 , 9 , 8 } ; int B [ ] = { 8 , 7 , 3 , 5 , 9 } ; int M = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int N = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << maxMatch ( A , B , M , N ) ; return 0 ; }"}
{"text": "Semak jika diberi penyelesaian Sudoku adalah sah atau tidak | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada semua elemen lembaga [] [] nilai kedai array dalam julat [1, 9]; Traverse Board [] [] array; Semak jika papan [i] [j] terletak dalam julat; Fungsi untuk memeriksa sama ada penyelesaian teka -teki sudoku sah atau tidak; Semak sama ada semua elemen papan [] [] menyimpan nilai dalam julat [1, 9]; Kedai nilai unik dari 1 hingga n; Melintasi setiap baris array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap lajur baris semasa; Menyimpan nilai papan [i] [j]; Semak jika baris semasa menyimpan nilai pendua; Melintasi setiap lajur array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap baris lajur semasa; Menyimpan nilai papan [j] [i]; Semak jika lajur semasa menyimpan nilai pendua; Melintasi setiap blok saiz 3 * 3 di papan [] [] array; J menyimpan lajur pertama setiap 3 * 3 blok; Memulakan array unik [] kepada palsu; Melintasi blok semasa; Kedai baris nombor blok semasa; Menyimpan nombor lajur blok semasa; Menyimpan nilai papan [x] [y]; Semak jika blok semasa menyimpan nilai pendua; Jika semua keadaan berpuas hati; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  9 NEW_LINE bool isinRange ( int board [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; } bool isValidSudoku ( int board [ ] [ N ] ) { if ( isinRange ( board ) == false ) { return false ; } bool unique [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; } int main ( ) { int board [ N ] [ N ] = { { 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 } , { 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 } , { 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 } , { 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 } , { 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 } , { 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 } , { 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 } , { 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 } , { 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 } } ; if ( isValidSudoku ( board ) ) { cout << \" Valid \" ; } else { cout << \" Not ▁ Valid \" ; } }"}
{"text": "Subarray panjang k yang penggabungannya membentuk palindrome | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah palindrome atau tidak di sini saya adalah indeks permulaan dan j adalah indeks terakhir subarray; Jika integer di saya tidak sama dengan j maka subarray bukan palindrome; Jika tidak; Semua [i] adalah sama dengan [j] maka subarray adalah palindrome; Berfungsi untuk mencari subarray yang penggabungannya membentuk palindrome dan mengembalikan indeks permulaannya; Melangkah ke atas subarray panjang k dan memeriksa jika subarray itu adalah palindrome; Jika tiada subarray adalah palindrome; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool palindrome ( vector < int > a , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; } int findSubArray ( vector < int > arr , int k ) { int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return -1 ; } int main ( ) { vector < int > arr = { 2 , 3 , 5 , 1 , 3 } ; int k = 4 ; int ans = findSubArray ( arr , k ) ; if ( ans == -1 ) cout << -1 << \" STRNEWLINE \" ; else { for ( int i = ans ; i < ans + k ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; } return 0 ; }"}
{"text": "Semak sama ada urutan laluan melawat sebarang koordinat dua kali atau tidak | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada lelaki itu melintasi koordinat sebelumnya atau tidak; Menyimpan kiraan puncak silang; Kedai (x, y) koordinat; Koordinat untuk asal; Melangkah ke atas rentetan; Keadaan kepada kenaikan x atau y co - masing -masing; Semak jika (x, y) sudah dilawati; Cetak hasilnya; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCrossed ( string path ) { if ( path . size ( ) == 0 ) return false ; bool ans = false ; set < pair < int , int > > set ; int x = 0 , y = 0 ; set . insert ( { x , y } ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { if ( path [ i ] == ' N ' ) set . insert ( { x , y ++ } ) ; if ( path [ i ] == ' S ' ) set . insert ( { x , y -- } ) ; if ( path [ i ] == ' E ' ) set . insert ( { x ++ , y } ) ; if ( path [ i ] == ' W ' ) set . insert ( { x -- , y } ) ; if ( set . find ( { x , y } ) != set . end ( ) ) { ans = true ; break ; } } if ( ans ) cout << \" Crossed \" ; else cout << \" Not ▁ Crossed \" ; } int main ( ) { string path = \" NESW \" ; isCrossed ( path ) ; return 0 ; }"}
{"text": "Lebar maksimum n | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari lebar maksimum pokok menggunakan traversal urutan tahap; Simpan tepi pokok; Menyimpan lebar maksimum pokok; Menyimpan nod setiap peringkat; Masukkan nod akar; Melakukan perintah level traversal di atas pokok; Menyimpan saiz barisan; Kemas kini lebar maksimum; Tolak nod tahap seterusnya dan popkan unsur -unsur tahap semasa; Dapatkan elemen dari depan barisan; Tolak semua nod peringkat seterusnya. ; Kembalikan hasilnya. ; Kod pemacu; Pokok yang dibina ialah: 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push_back ( s [ i ] [ 1 ] ) ; } int result = 0 ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; result = max ( count , result ) ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; } int main ( ) { int N = 11 , M = 10 ; vector < vector < int > > edges ; edges . push_back ( { 0 , 1 } ) ; edges . push_back ( { 0 , 2 } ) ; edges . push_back ( { 0 , 3 } ) ; edges . push_back ( { 1 , 4 } ) ; edges . push_back ( { 1 , 5 } ) ; edges . push_back ( { 3 , 6 } ) ; edges . push_back ( { 4 , 7 } ) ; edges . push_back ( { 6 , 10 } ) ; edges . push_back ( { 6 , 8 } ) ; edges . push_back ( { 6 , 9 } ) ; vector < int > cost = { 1 , 2 , -1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 } ; cout << maxWidth ( N , M , cost , edges ) ; return 0 ; }"}
{"text": "Kurangkan jumlah nombor perdana yang ditambah untuk membuat array bukan | Program C ++ untuk melaksanakan pendekatan di atas; Kedai jika indeks adalah nilai utama / bukan utama; Menyimpan perdana; Berfungsi untuk menjana semua nombor perdana; Jika elemen semasa adalah perdana; Tetapkan semua gandaannya bukan perdana; Simpan semua nombor utama; Berfungsi untuk mencari perdana terdekat dengan nombor tertentu; Memohon carian binari pada vektor prima; Jika perdana ditambah menjadikan unsur -unsur sama; Kembali ini sebagai perdana terdekat; Jika array kekal tidak menurun; Cari nombor perdana yang lebih besar; Jika tidak; Periksa sama ada perdana yang lebih kecil boleh membuat array tidak berkurangan atau tidak; Mengembalikan nombor terdekat; Berfungsi untuk mencari kos minimum; Cari semua prima; Simpan hasilnya; Melangkah ke atas array; Elemen semasa adalah kurang daripada elemen sebelumnya; Cari perdana terdekat yang membuat array tidak berkurangan; Tambah kepada kos keseluruhan; Mengemas kini elemen semasa; Mengembalikan kos minimum; Kod pemacu; Diberikan array; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000000 NEW_LINE bool isPrime [ MAX ] ; vector < int > primes ; void SieveOfEratosthenes ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . push_back ( p ) ; } int prime_search ( vector < int > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes [ mid ] == diff ) { return primes [ mid ] ; } else if ( primes [ mid ] < diff ) { low = mid + 1 ; } else { res = primes [ mid ] ; high = mid - 1 ; } } return res ; } int minCost ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; cout << minCost ( arr , n ) ; return 0 ; }"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mengembalikan cara untuk memecah rentetan ke dalam tiga bahagian dengan bilangan yang sama 0; Simpan jumlah kiraan 0 s; Kira Jumlah No. daripada 0 s watak dalam rentetan yang diberikan; Jika jumlah kiraan 0 watak tidak boleh dibahagikan dengan 3; Memulakan MP untuk menyimpan kekerapan k; Traverse String untuk mencari cara untuk memecah rentetan; Kiraan kenaikan jika 0 muncul; Hasil kenaikan jika jumlah sama dengan 2 * k dan k ada dalam MP; Masukkan jumlah dalam MP; Hasil pulangan; Kod pemacu; Diberikan rentetan; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string s ) { int cnt = 0 ; for ( char c : s ) { cnt += c == '0' ? 1 : 0 ; } if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += s [ i ] == '0' ? 1 : 0 ; if ( sum == 2 * k && mp . find ( k ) != mp . end ( ) && i < s . length ( ) - 1 && i > 0 ) { res += mp [ k ] ; } mp [ sum ] ++ ; } return res ; } int main ( ) { string str = \"01010\" ; cout << count ( str ) ; }"}
{"text": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk berpecah; Mengira jumlah sifar; Kes1 jika jumlah kiraan sifar tidak boleh dibahagikan dengan 3; Case2 Jika jumlah kiraan sifar adalah sifar; Bilangan sifar dalam setiap substring; Memulakan sifar kepada bilangan cara untuk potongan pertama dan kedua; Memulakan kiraan; Melintasi dari awal; Meningkatkan kiraan jika elemen adalah '0'; Meningkatkan cara untuk pemotongan 1 jika kiraan adalah sama dengan sifar yang diperlukan dalam setiap substring; Meningkatkan cara untuk pemotongan 2 nd jika kiraan adalah sama dengan 2 * (sifar yang diperlukan dalam setiap substring); Jumlah cara untuk berpecah adalah pendaraban cara untuk potongan 1 dan 2; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int splitstring ( string s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 , waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } int main ( ) { string s = \"01010\" ; cout << \" The ▁ number ▁ of ▁ ways ▁ to ▁ split ▁ is ▁ \" << splitstring ( s ) << endl ; }"}
{"text": "Semak jika rentetan boleh ditukar kepada yang lain dengan menukar watak bersebelahan jenis yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk mengubah mula berakhir; Semak urutan A, B dalam kedua -dua String Str1 dan Str2; Jika kedua -dua rentetan tidak sama; Melintasi rentetan; Semak indeks A dan B; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canTransform ( string str1 , string str2 ) { string s1 = \" \" ; string s2 = \" \" ; for ( char c : str1 ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 ) { if ( c != ' C ' ) { s2 += c ; } } if ( s1 != s2 ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n and j < n ) { if ( str1 [ i ] == ' C ' ) { i ++ ; } else if ( str2 [ j ] == ' C ' ) { j ++ ; } else { if ( ( str1 [ i ] == ' A ' and i < j ) or ( str1 [ i ] == ' B ' and i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } int main ( ) { string str1 = \" BCCABCBCA \" ; string str2 = \" CBACCBBAC \" ; if ( canTransform ( str1 , str2 ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }"}
{"text": "Substring terpanjang yang mempunyai kiraan vokal dan konsonan yang sama | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai bilangan vokal dan konsonan yang sama; Menjana array; Memulakan pembolehubah untuk menyimpan hasil; Menyimpan jumlah subarray; Peta untuk menyimpan indeks jumlah; Gelung melalui array; Jika jumlah adalah 0; Count vokal dan konsonan adalah sama; Mengemas kini panjang maksimum substring dalam hashmap; Simpan indeks jumlah; Mengembalikan panjang maksimum substring yang diperlukan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxsubstringLength ( string S , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = -1 ; int maxLen = 0 ; int curr_sum = 0 ; unordered_map < int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = max ( maxLen , i + 1 ) ; if ( hash . find ( curr_sum ) != hash . end ( ) ) maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; else hash [ curr_sum ] = i ; } return maxLen ; } int main ( ) { string S = \" geeksforgeeks \" ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; cout << maxsubstringLength ( S , n ) ; return 0 ; }"}
{"text": "Jarak minimum dari sel tertentu ke semua sel lain dari matriks | Program C ++ untuk melaksanakan pendekatan di atas; Menyimpan arahan yang boleh diakses; Fungsi untuk mencari jarak minimum dari sel tertentu ke semua sel lain dalam matriks; Menyimpan sel -sel yang boleh diakses dari sel semasa; Masukkan pasangan (x, y); Melangkah ke barisan adalah kosong; Ekstrak pasangan; Pop mereka; Memeriksa keadaan sempadan; Jika sel tidak dikunjungi; Menetapkan jarak minimum; Masukkan jiran yang dilalui ke dalam barisan; Kod pemacu; Cetak jarak yang diperlukan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mat [ 1001 ] [ 1001 ] ; int r , c , x , y ; int dx [ ] = { 0 , -1 , -1 , -1 , 0 , 1 , 1 , 1 } ; int dy [ ] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ; void FindMinimumDistance ( ) { queue < pair < int , int > > q ; q . push ( { x , y } ) ; mat [ x ] [ y ] = 0 ; while ( ! q . empty ( ) ) { x = q . front ( ) . first ; y = q . front ( ) . second ; q . pop ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a > = r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( { a , b } ) ; } } } } int main ( ) { r = 5 , c = 5 , x = 1 , y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { cout << mat [ i ] [ j ] << \" ▁ \" ; } cout << endl ; } }"}
{"text": "Kelebihan minimum yang diperlukan untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi yang mengembalikan bilangan minimum flip untuk menukar s ke dalam penyambungan sub -panjang sub -rentetan; Menyimpan hasilnya; Melangkah melalui indeks rentetan; Kedai kiraan 0 S & 1 S; ITERATE MEMBUAT K JUMPS; Kiraan 0 's; Kiraan 1 's; Tambah flip minimum untuk Indeks I; Mengembalikan bilangan minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . size ( ) ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += min ( zero , one ) ; } return ans ; } int main ( ) { string S = \"110100101\" ; int K = 3 ; cout << minOperations ( S , K ) ; return 0 ; }"}
{"text": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Program C ++ untuk pendekatan di atas; Berfungsi untuk mendapatkan elemen yang hilang; Untuk elemen maksimum dalam array; Untuk elemen minimum dalam array; Untuk XOR semua elemen; Perbezaan umum siri AP; Cari elemen maksimum dan minimum; Mengira perbezaan biasa; Kirakan XOR semua elemen; Lakukan XOR dengan siri AP sebenar yang dihasilkan X akan menjadi ANS; Mengembalikan elemen yang hilang; Kod pemacu; Diberikan array; Panggilan fungsi; Cetak elemen yang hilang", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } int main ( ) { int arr [ ] = { 12 , 3 , 6 , 15 , 18 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int element = missingElement ( arr , n ) ; cout << element ; }"}
{"text": "Memandangkan rentetan dan integer k, cari sub sub | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak sub -sub - string; Jumlah sub - rentetan mungkin; Jika k lebih besar daripada jumlah sub -rentetan; Untuk menyimpan nombor sub -rentetan bermula dengan watak rentetan; Mengira nilai -nilai; Substring [i - 1] ditambah untuk menyimpan jumlah kumulatif; Carian binari untuk mencari indeks permulaan sub -rentetan KTH; Untuk menyimpan indeks akhir sub -rentetan KTH; Cetak sub -rentetan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Printksubstring ( string str , int n , int k ) { int total = ( n * ( n + 1 ) ) / 2 ; if ( k > total ) { printf ( \" - 1 STRNEWLINE \" ) ; return ; } int substring [ n + 1 ] ; substring [ 0 ] = 0 ; int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) l = m + 1 ; else { start = m ; break ; } } int end = n - ( substring [ start ] - k ) ; for ( int i = start - 1 ; i < end ; i ++ ) cout << str [ i ] ; } int main ( ) { string str = \" abc \" ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; return 0 ; }"}
{"text": "Titik penyisipan yang lebih rendah | Program C ++ untuk mencari titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Berfungsi untuk mengembalikan titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Kes asas; Pemeriksaan akhir untuk unsur -unsur yang tersisa yang <x; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; cout << LowerInsertionPoint ( arr , n , X ) ; return 0 ; }"}
{"text": "Bilangan jawatan dengan alamat yang sama dalam baris utama dan lajur utama urutan | Program CPP untuk mengira bilangan kedudukan dengan alamat yang sama dalam perintah utama utama dan lajur; Mengembalikan kiraan kedudukan yang diperlukan; array 1D mendatar; array 1D menegak; melangkah untuk semua yang mungkin saya; Memeriksa jika J adalah integer; Memeriksa jika J terletak b / w 1 hingga n; melangkah untuk semua kemungkinan j; Memeriksa jika saya adalah integer; Memeriksa jika saya terletak b / w 1 hingga m; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } int main ( ) { int M = 3 , N = 5 ; cout << getCount ( M , N ) << endl ; return 0 ; }"}
{"text": "Maksimum dalam pelbagai yang boleh membuat array lain disusun | Program C ++ untuk membuat array disusun; Fungsi untuk memeriksa sama ada terdapat unsur swappable yang hadir untuk membuat array pertama disusun; WrongIdx adalah indeks elemen yang membuat array pertama tidak disusun; Cari elemen maksimum yang memenuhi syarat -syarat jiran yang disebutkan di atas; Jika res adalah benar maka swap elemen dan buat array pertama disusun; Fungsi untuk mencetak array yang disusun jika elemen ditukar. ; Kod pemandu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool swapElement ( int arr1 [ ] , int arr2 [ ] , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) wrongIdx = i ; int maximum = INT_MIN ; int maxIdx = -1 ; bool res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) swap ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) ; return res ; } void getSortedArray ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) for ( int i = 0 ; i < n ; i ++ ) cout << arr1 [ i ] << \" ▁ \" ; else cout << \" Not ▁ Possible \" << endl ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 7 , 4 , 10 } ; int arr2 [ ] = { 2 , 1 , 6 , 8 , 9 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; getSortedArray ( arr1 , arr2 , n ) ; }"}
{"text": "Pertengahan tiga menggunakan perbandingan minimum | Program CPP untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Bandingkan setiap tiga nombor untuk mencari nombor tengah. Masukkan hanya jika A> B; Memutuskan A tidak lebih besar daripada b. ; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }"}
{"text": "Susun Lajur Matriks | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari transpose matriks mat []; Menyimpan transpose matriks mat [] []; Melintasi setiap baris matriks; Melintasi setiap lajur matriks; Elemen matriks transpose; Berfungsi untuk menyusun matriks yang diberikan dengan cara yang bijak; Melintasi baris; Baris - penyortiran bijak; Berfungsi untuk mencetak matriks dalam lajur yang disusun dengan bijak; Fungsi panggilan untuk mencari transpose matriks mat [] []; Menyusun baris matriks - bijak; Kirakan transpose b [] []; Cetak matriks mat [] []; Kod pemacu; Input; Fungsi panggilan untuk mencetak matriks dalam lajur yang disusun dengan bijak", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > transpose ( vector < vector < int > > mat , int row , int col ) { vector < vector < int > > tr ( col , vector < int > ( row ) ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { tr [ j ] [ i ] = mat [ i ] [ j ] ; } } return tr ; } void RowWiseSort ( vector < vector < int > > & B ) { for ( int i = 0 ; i < ( int ) B . size ( ) ; i ++ ) { sort ( B [ i ] . begin ( ) , B [ i ] . end ( ) ) ; } } void sortCol ( vector < vector < int > > mat , int N , int M ) { vector < vector < int > > B = transpose ( mat , N , M ) ; RowWiseSort ( B ) ; mat = transpose ( B , M , N ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cout << mat [ i ] [ j ] << \" ▁ \" ; } cout << ' ' ; } } int main ( ) { vector < vector < int > > mat = { { 1 , 6 , 10 } , { 8 , 5 , 9 } , { 9 , 4 , 15 } , { 7 , 3 , 60 } } ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; sortCol ( mat , N , M ) ; return 0 ; }"}
{"text": "Kawasan terbesar mungkin selepas penyingkiran siri bar mendatar & menegak | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan; Menyimpan semua bar; Masukkan bar mendatar; Masukkan bar verttik; Keluarkan pemisah mendatar dari S1; Keluarkan pemisah menegak dari S2; Kedai -kedai yang ditinggalkan pemisah mendatar dan menegak; Menyusun kedua -dua senarai dalam urutan menaik; Cari perbezaan maksimum jiran List1; Cari perbezaan maksimum jiran List2; Cetak kelantangan terbesar; Kod pemacu; Diberi nilai N & M; Diberikan susunan; Fungsi panggilan untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestArea ( int N , int M , int H [ ] , int V [ ] , int h , int v ) { set < int > s1 ; set < int > s2 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . insert ( i ) ; for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . insert ( i ) ; for ( int i = 0 ; i < h ; i ++ ) { s1 . erase ( H [ i ] ) ; } for ( int i = 0 ; i < v ; i ++ ) { s2 . erase ( V [ i ] ) ; } int list1 [ s1 . size ( ) ] ; int list2 [ s2 . size ( ) ] ; int i = 0 ; for ( auto it1 = s1 . begin ( ) ; it1 != s1 . end ( ) ; it1 ++ ) { list1 [ i ++ ] = * it1 ; } i = 0 ; for ( auto it2 = s2 . begin ( ) ; it2 != s2 . end ( ) ; it2 ++ ) { list2 [ i ++ ] = * it2 ; } sort ( list1 , list1 + s1 . size ( ) ) ; sort ( list2 , list2 + s2 . size ( ) ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( int j = 0 ; j < s1 . size ( ) ; j ++ ) { maxH = max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) { maxV = max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } cout << ( maxV * maxH ) << endl ; } int main ( ) { int N = 3 , M = 3 ; int H [ ] = { 2 } ; int V [ ] = { 2 } ; int h = sizeof ( H ) / sizeof ( H [ 0 ] ) ; int v = sizeof ( V ) / sizeof ( V [ 0 ] ) ; largestArea ( N , M , H , V , h , v ) ; return 0 ; }"}
{"text": "Semak jika array boleh disusun dengan menukar pasangan dari indeks yang terdiri daripada unsur -unsur yang tidak sama rata dalam array lain | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array, [] boleh ditukar menjadi array yang disusun dengan bertukar (a [i], a [j]) jika b [i] tidak sama dengan b [j]; Kedai jika array A [] disusun dalam urutan menurun atau tidak; Melintasi array a []; Jika [i] lebih besar daripada [i + 1]; Bendera kemas kini; Jika array disusun mengikut urutan menaik; kiraan = 2: periksa jika 0 s dan 1 s kedua -duanya hadir dalam b []; Melintasi array; Jika elemen semasa ialah 0; Kiraan kemas kini; Melintasi array b []; Jika elemen semasa ialah 1; Jika kedua -dua 0 s dan 1 s hadir dalam array; Kod pemacu; Array input a []; Arahan input B []; Panggilan fungsi; Jika benar, cetak ya; Lain cetak no", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkifSorted ( int A [ ] , int B [ ] , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; bool check = checkifSorted ( A , B , N ) ; if ( check ) { cout << \" YES \" << endl ; } else { cout << \" NO \" << endl ; } return 0 ; }"}
{"text": "Swap minimum diperlukan di antara dua rentetan untuk membuat satu rentetan ketat lebih besar daripada yang lain | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan langkah minimum untuk membuat A> B; Jika semua watak adalah sama dan m <= n; Sekiranya terdapat sebarang watak dalam B yang lebih besar daripada B [0]; Jika terdapat apa -apa watak yang lebih kecil daripada [0]; Sekiranya terdapat watak yang berada di dalam dan lebih besar daripada [0]; Sekiranya terdapat watak yang berada di B dan kurang daripada B [0]; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( string A , string B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A . begin ( ) , A . end ( ) , A [ 0 ] ) == M && count ( B . begin ( ) , B . end ( ) , B [ 0 ] ) == N ) return -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A [ i ] , B [ 0 ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A [ 0 ] , B [ i ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } return 0 ; } int main ( ) { string A = \" adsfd \" ; string B = \" dffff \" ; int M = A . length ( ) ; int N = B . length ( ) ; cout << minSteps ( A , B , M , N ) ; return 0 ; }"}
{"text": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | C ++ algoritma pendekatan di atas; Kod pemacu; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan supaya array menjadi bermakna; Memulakan vektor jenis pasangan yang mengandungi nilai dan indeks ARR; Menyusun array num atas dasar nilai; Memulakan pembolehubah yang digunakan untuk mencari panjang maksimum yang semakin meningkat dalam indeks; Mengemas kini coretan; Mengembalikan bilangan elemen yang tersisa kecuali coretan", "code": "#include <bits/stdc++.h> NEW_LINE #include <vector> NEW_LINE using namespace std ; int main ( ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int count = minOperations ( arr , n ) ; cout << count ; } int minOperations ( int arr [ ] , int n ) { vector < pair < int , int > > vect ; for ( int i = 0 ; i < n ; i ++ ) { vect . push_back ( make_pair ( arr [ i ] , i ) ) ; } sort ( vect . begin ( ) , vect . end ( ) ) ; int res = 1 ; int streak = 1 ; int prev = vect [ 0 ] . second ; for ( int i = 1 ; i < n ; i ++ ) { if ( prev < vect [ i ] . second ) { res ++ ; streak = max ( streak , res ) ; } else res = 1 ; prev = vect [ i ] . second ; } return n - streak ; }"}
{"text": "Memaksimumkan jumlah produk berpasangan yang dihasilkan dari tatasusunan yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Pembolehubah yang mewakili saiz array; Menyimpan hasilnya; Berfungsi untuk mengembalikan jumlah maksimum yang mungkin; Menyimpan kiraan susunan yang diproses; Jika lebih daripada dua tatasusunan telah diproses; Sekiranya subproblem yang telah dikira telah berlaku; Terokai semua pasangan yang mungkin; Panggilan fungsi rekursif; Memoize maksimum; Mengembalikan nilai; Berfungsi untuk mengembalikan jumlah maksimum produk pasangan yang mungkin; Memulakan array DP ke - 1; Menyusun tatasusunan dalam urutan menurun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  201 NEW_LINE int n1 , n2 , n3 ; int dp [ maxN ] [ maxN ] [ maxN ] ; int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; } int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { memset ( dp , -1 , sizeof ( dp ) ) ; sort ( arr1 , arr1 + n1 ) ; reverse ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; reverse ( arr2 , arr2 + n2 ) ; sort ( arr3 , arr3 + n3 ) ; reverse ( arr3 , arr3 + n3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; } int main ( ) { n1 = 2 ; int arr1 [ ] = { 3 , 5 } ; n2 = 2 ; int arr2 [ ] = { 2 , 1 } ; n3 = 3 ; int arr3 [ ] = { 4 , 3 , 5 } ; cout << maxProductSum ( arr1 , arr2 , arr3 ) ; return 0 ; }"}
{"text": "Triplet leksikografi terbesar dari array yang diberikan yang membentuk segitiga | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari triplet terbesar secara leksikografi yang membentuk segitiga dalam array yang diberikan; Susun array; Berulang dari akhir array; Jika triplet membentuk segitiga; Jika triplet dijumpai; Cetak triplet; Jika tidak; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplet ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag ) { cout << arr [ i - 2 ] << \" ▁ \" << arr [ i - 1 ] << \" ▁ \" << arr [ i ] << endl ; } else { cout << -1 << endl ; } } int main ( ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplet ( arr , N ) ; return 0 ; }"}
{"text": "Kira semua pasangan dalam array dengan perbezaan mutlak minimum | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan kiraan semua pasangan yang mempunyai perbezaan mutlak yang minimum; Menyimpan kiraan pasangan; Susun array; Menyimpan perbezaan minimum antara pasangan bersebelahan; Mengemas kini perbezaan minimum antara pasangan; Meningkatkan kiraan pasangan dengan perbezaan yang sama dengan perbezaan minimum; Mengembalikan kiraan akhir; Kod pemacu; Diberikan array arr []; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = ( sizeof arr ) / ( sizeof arr [ 0 ] ) ; cout << numberofpairs ( arr , N ) << \" STRNEWLINE \" ; return 0 ; }"}
{"text": "Subset saiz maksimum dengan jumlah yang diberikan menggunakan backtracking | Program C ++ untuk melaksanakan pendekatan di atas; Permulaan maksimum kemungkinan panjang berikutnya; Simpan elemen untuk membandingkan max_length dengan saiznya dan tukar nilai max_length dengan sewajarnya; Simpan unsur -unsur yang paling lama; Berfungsi untuk mencari panjang berikutnya terpanjang; Kemas kini max_length; Simpan unsur -unsur berikutnya; Secara rekursif meneruskan dengan jumlah yang diperoleh; unsur -unsur yang muncul dari belakang kedai vektor; jika jumlah> 0 maka kita tidak memerlukannya sehingga kembali dan teruskan dengan unsur -unsur terdahulu; Susun array yang diberikan; Melintasi array; Jika max_length sudah lebih besar daripada atau sama daripada panjang yang tinggal; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_length = 0 ; vector < int > store ; vector < int > ans ; void find_max_length ( vector < int > & arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . push_back ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . size ( ) ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . pop_back ( ) ; } else return ; } return ; } int longestSubsequence ( vector < int > arr , int n , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; } int main ( ) { vector < int > arr { -3 , 0 , 1 , 1 , 2 } ; int n = arr . size ( ) ; int k = 1 ; cout << longestSubsequence ( arr , n , k ) ; return 0 ; }"}
{"text": "Susun Pengurangan Permutasi N Menggunakan Swap Triple | C ++ pelaksanaan untuk menyusun pengurangan permutasi N menggunakan swap tiga; Fungsi untuk menyusun array; Tiga indeks yang perlu dipilih; Semak jika boleh menyusun array; Bertukar untuk membawa elemen pada kedudukan yang diperlukan membawa sekurang -kurangnya satu elemen pada kedudukan yang betul; Mengesan perubahan dalam array; Cetak array yang disusun; Jika tidak mungkin untuk menyusun; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArray ( int A [ ] , int N ) { int x , y , z ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << \" Sorted ▁ Array : ▁ \" ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << \" ▁ \" ; } else cout << \" - 1\" ; } int main ( ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; sortArray ( A , N ) ; return 0 ; }"}
{"text": "Cari k sedemikian rupa sehingga mengubah semua elemen array yang lebih besar daripada k ke k akan membuat jumlah array n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan k sedemikian rupa sehingga mengubah semua elemen yang lebih besar daripada k ke k akan membuat jumlah array n sebaliknya kembali - 1; Menyusun array dalam peningkatan urutan; Gelung melalui semua elemen array; Memeriksa jika jumlah array sama dengan n; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int arr [ ] , int size , int N ) { sort ( arr , arr + size ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return -1 ; } int main ( ) { int arr [ ] = { 3 , 1 , 10 , 4 , 8 } ; int size = sizeof ( arr ) / sizeof ( int ) ; int N = 16 ; cout << findK ( arr , size , N ) ; return 0 ; }"}
{"text": "Cari tiga elemen dari tiga array yang diberikan supaya jumlah mereka adalah x | Tetapkan 2 | C ++ pelaksanaan pendekatan; Fungsi yang kembali benar jika terdapat triplet dengan jumlah x; Menyusun susunan sedemikian rupa sehingga [] mewakili array terkecil; Mengalihkan array terkecil; Dua petunjuk pada array kedua dan ketiga; Jika triplet yang sah dijumpai; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 and l2 <= l3 ) swap ( l2 , l1 ) , swap ( a , b ) ; else if ( l3 <= l1 and l3 <= l2 ) swap ( l3 , l1 ) , swap ( a , c ) ; for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 and k > = 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } int main ( ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = sizeof ( a ) / sizeof ( int ) ; int l2 = sizeof ( b ) / sizeof ( int ) ; int l3 = sizeof ( c ) / sizeof ( int ) ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }"}
{"text": "Susun nombor yang diberikan untuk membentuk nombor terkecil | C ++ pelaksanaan pendekatan; Fungsi utiliti untuk mencetak kandungan array; Fungsi perbandingan yang kembali benar jika 'ab' lebih kecil daripada 'ba' apabila kita menggabungkan dua nombor 'a' dan 'b' misalnya, ia akan kembali benar jika kita lulus 12 dan 24 sebagai argumen. Fungsi ini akan digunakan oleh fungsi sort (); Tukar nombor pertama ke format rentetan; Tukar nombor kedua ke format rentetan; Semak jika 'ab' lebih kecil atau 'ba' dan kembali nilai bool sejak pengendali perbandingan '<=' mengembalikan benar atau palsu; Berfungsi untuk mencetak susunan dengan nilai terkecil; Jika kita lulus nama fungsi perbandingan, ia akan menyusun array mengikut fungsi membandingkan; Cetak array yang disusun; Kod pemacu", "code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] ; } bool compare ( int num1 , int num2 ) { string A = to_string ( num1 ) ; string B = to_string ( num2 ) ; return ( A + B ) <= ( B + A ) ; } void printSmallest ( int N , int arr [ ] ) { sort ( arr , arr + N , compare ) ; printArr ( arr , N ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 9 , 21 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printSmallest ( N , arr ) ; return 0 ; }"}
{"text": "Stabil Pemilihan Susun | Program C ++ untuk mengubah suai pilihan pemilihan supaya ia menjadi stabil. ; Melangkah melalui elemen array; Cari elemen minimum dari arr [i] ke arr [n - 1]. ; Gerakkan elemen minimum pada semasa i. ; Kod pemacu", "code": "#include <iostream> NEW_LINE using namespace std ; void stableSelectionSort ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } void printArray ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int a [ ] = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; return 0 ; }"}
{"text": "Permut dua tatasusunan sedemikian rupa sehingga jumlah setiap pasangan lebih besar atau sama dengan k | Program C ++ untuk memeriksa sama ada permutasi dua tatasusunan memenuhi syarat [i] + b [i]> = k. ; Semak sama ada apa -apa permutasi wujud yang memenuhi syarat. ; Susun array a [] dalam urutan yang berkurangan. ; Susun array B [] dalam peningkatan urutan. ; Memeriksa keadaan pada setiap indeks. ; Program yang didorong", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } int main ( ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; isPossible ( a , b , n , k ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }"}
{"text": "Sort Array mengikut kiraan bit set | Program C ++ untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; Fungsi untuk mengira setbit; Fungsi untuk disusun oleh SetBitCount; Melangkah ke atas semua nilai dan masukkan ke dalam multimap; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBitCount ( int num ) { int count = 0 ; while ( num ) { if ( num & 1 ) count ++ ; num >>= 1 ; } return count ; } void sortBySetBitCount ( int arr [ ] , int n ) { multimap < int , int > count ; for ( int i = 0 ; i < n ; ++ i ) { count . insert ( { ( -1 ) * setBitCount ( arr [ i ] ) , arr [ i ] } ) ; } for ( auto i : count ) cout << i . second << \" ▁ \" ; cout << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; }"}
{"text": "Semak jika akhir rentetan binari yang diberikan dapat dicapai dengan memilih nilai lompat di antara julat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mencapai hujung rentetan binari menggunakan lompatan yang diberikan; Menyimpan negeri -negeri DP; Keadaan awal; Kedai -kedai mengira indeks dari mana ia mungkin untuk mencapai Indeks I; Melintasi rentetan yang diberikan; Mengemas kini nilai pra dengan sewajarnya; Jika saiz lompat keluar dari julat [l, r]; Jawapan kembali; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canReach ( string s , int L , int R ) { vector < int > dp ( s . length ( ) ) ; dp [ 0 ] = 1 ; int pre = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) ; } return dp [ s . length ( ) - 1 ] ; } int main ( ) { string S = \"01101110\" ; int L = 2 , R = 3 ; cout << ( canReach ( S , L , R ) ? \" Yes \" : \" No \" ) ; return 0 ; }"}
{"text": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Program C ++ untuk pendekatan di atas; Fungsi rekursif untuk mencari semua kemungkinan pemecahan array ke subarrays dan cari maksimum bitwise XOR; Jika nilai n ialah 0; Menyimpan hasil jika kumpulan baru dibentuk dengan elemen pertama sebagai arr [i]; Kedai jika keputusan jika ARR [i] dimasukkan ke dalam kumpulan terakhir; Mengembalikan maksimum x dan y; Berfungsi untuk mencari maksimum bitwise xor dari semua nilai yang mungkin dari array selepas memecahkan tatasusunan ke subarrays; Mengembalikan hasilnya; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return max ( x , y ) ; } int maximumXOR ( int arr [ ] , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumXOR ( arr , N ) ; return 0 ; }"}
{"text": "Bina N | Program C ++ untuk melaksanakan pendekatan di atas; Menjejaki nod yang dikunjungi; Berfungsi untuk membina pokok supaya tidak ada dua nod bersebelahan dengan berat yang sama; Jika elemen minimum dan maksimum adalah sama, i. e. Array mengandungi satu elemen yang berbeza; Pokok tidak boleh dibina; Jika tidak; Pokok boleh dibina; Pilih berat [0] sebagai akar; Node pertama dikunjungi; Melintasi array; Jika tidak, buat kelebihan; Tandakan nod ini seperti yang dikunjungi; Cari berat badan yang tidak sama dengan root & membuat tepi dengan nod itu; Sertai bukan akar dengan nod yang tinggal; Semak jika nod semasa berat ~ sama dengan berat badan dan jika ia tidak dikunjungi atau tidak; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e5 + 5 ; int visited [ N ] ; void construct_tree ( int weights [ ] , int n ) { int minimum = * min_element ( weights , weights + n ) ; int maximum = * max_element ( weights , weights + n ) ; if ( minimum == maximum ) { cout << \" No \" ; return ; } else { cout << \" Yes \" << endl ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { cout << 1 << \" ▁ \" << i + 1 << \" ▁ \" << endl ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { cout << notroot << \" ▁ \" << i + 1 << endl ; visited [ i + 1 ] = 1 ; } } } int main ( ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = sizeof ( weights ) / sizeof ( weights [ 0 ] ) ; construct_tree ( weights , N ) ; }"}
{"text": "Kurangkan kos untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk menukar rentetan yang diberikan ke dalam rentetan panjang K substring yang sama; Kedai panjang rentetan; Menyimpan kos minimum; Melintasi substring kiri panjang K; Menyimpan kekerapan; Kedai kos minimum untuk urutan indeks S [i] % K; Semak watak yang optimum; Cari jumlah jarak 'a' + ch dari indeks kara [i] % k; Pilih kos minimum untuk setiap indeks i; Kenaikan ans; Cetak kos minimum untuk menukar rentetan; Kod pemacu; Diberikan rentetan s; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string s , int k ) { int n = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int a [ 26 ] ; for ( int p = 0 ; p < 26 ; p ++ ) { a [ p ] = 0 ; } for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - ' a ' ] ++ ; } int min_cost = INT_MAX ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += abs ( ch - tr ) * a [ tr ] ; min_cost = min ( min_cost , cost ) ; } ans += min_cost ; } cout << ( ans ) ; } int main ( ) { string S = \" abcdefabc \" ; int K = 3 ; minCost ( S , K ) ; }"}
{"text": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }"}
{"text": "Cari padanan maksimum dalam pokok binari yang diberikan | Program C ++ untuk pendekatan di atas; Senarai Adjacency untuk menyimpan tepi; Tambah kelebihan antara u dan v dalam pokok; Kelebihan dari u ke v; Tepi dari v ke u; Fungsi yang mendapati pemadanan maksimum DFS; Pergi lebih jauh kerana kami tidak dibenarkan pergi ke arah ibu bapanya; Jika u dan ibu induknya tidak diambil maka kita mesti mengambil & menandakannya sebagai diambil; Saiz kenaikan set tepi; Berfungsi untuk mencari padanan maksimum dalam graf; Mengambil 1 sebagai akar pokok; Cetak padanan maksimum; Kod pemacu; Menyertai kelebihan antara dua nod dalam pokok; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  10000 NEW_LINE vector < int > adj [ N ] ; int used [ N ] ; int max_matching ; void AddEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( ! used [ u ] and ! used [ p ] and p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } } void maxMatching ( ) { Matching_dfs ( 1 , 0 ) ; cout << max_matching << \" STRNEWLINE \" ; } int main ( ) { int n = 5 ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; maxMatching ( ) ; return 0 ; }"}
{"text": "Kurangkan kos untuk menukar dua tatasusunan yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan kos minimum yang diperlukan untuk menukar dua tatasusunan; Mengembalikan jumlah kos minimum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinCost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; vector < int > A = { 1 , 4 , 2 } ; vector < int > B = { 10 , 6 , 12 } ; cout << getMinCost ( A , B , N ) ; return 0 ; }"}
{"text": "Cetak semua cara yang mungkin untuk menulis n sebagai jumlah dua atau lebih integer positif | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak nilai yang disimpan dalam arr vektor; Melintasi arr vektor; Fungsi rekursif untuk mencetak cara yang berbeza di mana n boleh ditulis sebagai jumlah pada 2 atau lebih bilangan bulat positif; Jika n adalah sifar maka cetak cara ini memecahkan nombor; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack untuk mengeluarkan elemen semasa dari perwakilan; Kod pemacu; Diberikan jumlah n; Untuk menyimpan perwakilan melanggar N; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printVector ( vector < int > & arr ) { if ( arr . size ( ) != 1 ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } cout << endl ; } } void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } } int main ( ) { int n = 4 ; vector < int > arr ; findWays ( arr , 1 , n ) ; return 0 ; }"}
{"text": "Memaksimumkan kiraan penurunan berikutnya dari array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira berikutnya maksimum; Menyimpan kekerapan elemen array; Kedai frekuensi maksimum; Kemas kini kekerapan [i]; Mengemas kini maksimum Max; Cetak kiraan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maximum_subsequence ( int A [ ] , int N ) { unordered_map < int , int > frequency ; int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( auto it : frequency ) { if ( it . second > max_freq ) { max_freq = it . second ; } } cout << max_freq << endl ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Maximum_subsequence ( arr , N ) ; return 0 ; }"}
{"text": "Semak jika rentetan boleh dibahagikan kepada dua rentetan dengan bilangan k | yang sama C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencetak susunan aksara; Kedai kekerapan aksara; Hitung watak yang mempunyai kekerapan k; Hitung watak yang mempunyai kekerapan lebih besar daripada k dan tidak sama dengan 2 k; Kes 1; Kes 2; Kes 3; Jika semua kes gagal; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void DivideString ( string s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ; int fr [ 26 ] = { 0 } ; string ans = \" \" ; for ( i = 0 ; i < n ; i ++ ) { fr [ s [ i ] - ' a ' ] ++ ; } char ch , ch1 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] == k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = i + ' a ' ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = i + ' a ' ; } } for ( i = 0 ; i < n ; i ++ ) ans = ans + \"1\" ; map < char , int > mp ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s [ i ] - ' a ' ] == k ) { if ( mp . find ( s [ i ] ) != mp . end ( ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp [ s [ i ] ] = 1 ; } } } } if ( c % 2 == 1 && c1 > 0 ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } } if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s [ i ] - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } cout << ans << endl ; } else { cout << \" NO \" << endl ; } } int main ( ) { string S = \" abbbccc \" ; int N = S . size ( ) ; int K = 1 ; DivideString ( S , N , K ) ; return 0 ; }"}
{"text": "Semak jika dua item boleh dipilih dari dua kategori yang berbeza tanpa harga yang melebihi | C ++ pelaksanaan untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Fungsi untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Gelung untuk memilih dua pasangan yang berbeza menggunakan dua gelung bersarang; Keadaan untuk memeriksa sama ada harga kedua -dua elemen ini kurang daripada S; Kod pemacu; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return \" Yes \" ; } } } } return \" No \" ; } int main ( ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ; cout << check ( S , prices , type , n ) ; return 0 ; }"}
{"text": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | C ++ pelaksanaan untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah yang membahagikan harta produk; Untuk mencari faktor terbesar k; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = max ( max_sum , a + b ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }"}
{"text": "Menyulitkan rentetan dengan mengulangi i | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disulitkan; Bilangan kali watak semasa akan diulang; Ulangi watak semasa dalam rentetan yang disulitkan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = \" \" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; } int main ( ) { string str = \" geeks \" ; int n = str . length ( ) ; cout << encryptString ( str , n ) ; return 0 ; }"}
{"text": "Kurangkan perbezaan antara nilai maksimum dan minimum array yang diubah suai | Program C ++ untuk mencari perbezaan minimum. ; Fungsi untuk mengembalikan perbezaan minimum yang diperlukan; mencari nilai minimum dan maksimum; mengembalikan perbezaan minimum yang mungkin; Program pemacu; berfungsi untuk mengembalikan jawapannya", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; } int main ( ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ; cout << minDiff ( n , x , A ) ; return 0 ; }"}
{"text": "Swap minimum untuk mengimbangi pendakap | Program C ++ untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Kedai Jumlah bilangan kurungan kiri dan kanan yang ditemui; Swap menyimpan bilangan swap yang diperlukan ketidakseimbangan mengekalkan bilangan pasangan ketidakseimbangan; Kiraan kenaikan kurungan kiri; kiraan swap adalah kiraan swap terakhir + jumlah kurungan tidak seimbang; ketidakseimbangan yang diturunkan oleh 1 kerana ia hanya menyelesaikan satu ketidakseimbangan kiri dan kanan; Kiraan kenaikan kurungan kanan; Ketidakseimbangan diset semula kepada perbezaan semasa antara kurungan kiri dan kanan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long swapCount ( string chars ) { int countLeft = 0 , countRight = 0 ; int swap = 0 , imbalance = 0 ; for ( int i = 0 ; i < chars . length ( ) ; i ++ ) { if ( chars [ i ] == ' [ ' ) { countLeft ++ ; if ( imbalance > 0 ) { swap += imbalance ; imbalance -- ; } } else if ( chars [ i ] == ' ] ' ) { countRight ++ ; imbalance = ( countRight - countLeft ) ; } } return swap ; } int main ( ) { string s = \" [ ] ] [ ] [ \" ; cout << swapCount ( s ) << endl ; s = \" [ [ ] [ ] ] \" ; cout << swapCount ( s ) << endl ; return 0 ; }"}
{"text": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; dp [i]: Menyimpan selanjutnya yang terpanjang sehingga i; Kes asas; Apabila keadaan memegang; Akhirnya, cetak jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubSequence ( pair < int , int > A [ ] , int N ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] . first < A [ i ] . first && A [ j ] . second > A [ i ] . second ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } cout << dp [ N - 1 ] << endl ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; longestSubSequence ( A , N ) ; return 0 ; }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Kes asas; Kembali hasil yang telah disimpan; Berulang untuk semua 6 negeri; Mengembalikan hasilnya; Kod pemacu; Diberikan jumlah n; Memulakan array DP; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != -1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } int main ( ) { int N = 4 ; int dp [ N + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << findWays ( N , dp ) ; return 0 ; }"}
{"text": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Memulakan array DP; Melangkah ke atas semua nilai perantaraan yang mungkin untuk mencapai n; Kirakan jumlah untuk semua 6 muka; Cetak jumlah cara; Kod pemacu; Diberikan jumlah n; Panggilan fungsi", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; } int main ( ) { int N = 4 ; findWays ( N ) ; return 0 ; }"}
{"text": "Pecahkan rentetan ke bahagian minimum supaya setiap bahagian berada dalam rentetan lain | C ++ pelaksanaan untuk memecah rentetan ke dalam bilangan minimum bahagian supaya setiap bahagian juga terdapat dalam rentetan lain; Nod trie; Berfungsi untuk memasukkan nod dalam struktur data trie; Memasukkan setiap watak dari IDX hingga hujung ke rentetan ke dalam trie; Sekiranya tidak ada kelebihan yang sepadan dengan watak ITH, maka buat nod baru; Berfungsi untuk mencari bilangan minimum bahagian supaya setiap bahagian hadir ke dalam rentetan lain; Membuat trie baru; Memasukkan setiap substring S2 di Trie; Mewujudkan array DP dan init dengan tak terhingga; Kes asas; Memulakan pemotongan dari watak yang mengambil penunjuk nod sementara untuk memeriksa sama ada substring [i, j) hadir dalam trie tidak; Sekiranya watak JTH tidak berada di Trie, kami akan berehat; Mengemas kini berakhirnya watak jth dengan dp [i] + 1; Menurunkan penunjuk Trie; Jawapan tidak mungkin; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int INF = 1e9 + 9 ; struct TrieNode { TrieNode * child [ 26 ] = { NULL } ; } ; void insert ( int idx , string & s , TrieNode * root ) { TrieNode * temp = root ; for ( int i = idx ; i < s . length ( ) ; i ++ ) { if ( temp -> child [ s [ i ] - ' a ' ] == NULL ) temp -> child [ s [ i ] - ' a ' ] = new TrieNode ; temp = temp -> child [ s [ i ] - ' a ' ] ; } } int minCuts ( string S1 , string S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; TrieNode * root = new TrieNode ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } vector < int > dp ( n1 + 1 , INF ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode * temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp -> child [ S1 [ j - 1 ] - ' a ' ] == NULL ) break ; dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp -> child [ S1 [ j - 1 ] - ' a ' ] ; } } if ( dp [ n1 ] >= INF ) return -1 ; else return dp [ n1 ] ; } int main ( ) { string S1 = \" abcdab \" ; string S2 = \" dabc \" ; cout << minCuts ( S1 , S2 ) ; }"}
{"text": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C ++ pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputation of Prefix CountDP Jumlah matriks; Gelung untuk menyelesaikan setiap pertanyaan; Carian binari ke sisi yang mempunyai atmost dalam k 1 's di persegi; Kira jumlah 1 s dalam sub persegi yang dipertimbangkan; Jika kiraan kurang daripada atau sama dengan langkah maksimum ke separuh kanan; Kod pemacu", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }"}
